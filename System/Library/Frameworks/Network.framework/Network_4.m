void nw_parameters_set_url(void *a1, const char *a2)
{
  void *v3;
  void *v4;
  nw_endpoint_t url;
  void *v6;
  void *v7;
  char *v8;
  os_log_s *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  BOOL v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;
  v21 = *MEMORY[0x1895F89C0];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2 && *a2)
    {
      url = nw_endpoint_create_url(a2);
      v6 = (void *)v4[25];
      v4[25] = url;
    }

    else
    {
      v6 = (void *)v3[25];
      v3[25] = 0LL;
    }

    goto LABEL_7;
  }

  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_parameters_set_url";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_url";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_parameters_set_url";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_url";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_url";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A79ED4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_create_url(const char *url)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (url)
  {
    CFIndex v2 = strlen(url);
    v3 = CFURLCreateAbsoluteURLWithBytes((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)url, v2, 0x600u, 0LL, 0);
    BOOL v4 = -[NWConcrete_nw_url_endpoint initWithURL:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_url_endpoint), v3);
    if (v3) {
      CFRelease(v3);
    }
    return (nw_endpoint_t)v4;
  }

  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_endpoint_create_url";
  v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null url", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_endpoint_create_url";
          __int16 v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null url, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null url, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null url, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

void sub_181A7A1B8(_Unwind_Exception *exception_object)
{
}

void sub_181A7A1C4(_Unwind_Exception *exception_object)
{
  if (!v1) {
    _Unwind_Resume(exception_object);
  }
  CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t nw_utilities_create_c_string_from_cfstring(const __CFString *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_utilities_create_c_string_from_cfstring";
    uint64_t v5 = _os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault((const char *)v5, &type, &v29))
    {
LABEL_28:
      if (!v5) {
        return 0LL;
      }
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      v32 = "nw_utilities_create_c_string_from_cfstring";
      char v14 = "%{public}s called with null stringRef";
    }

    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v28 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          v32 = "nw_utilities_create_c_string_from_cfstring";
          __int16 v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null stringRef, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v5) {
          return 0LL;
        }
        goto LABEL_40;
      }

      if (!v28) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      v32 = "nw_utilities_create_c_string_from_cfstring";
      char v14 = "%{public}s called with null stringRef, no backtrace";
    }

    else
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      v32 = "nw_utilities_create_c_string_from_cfstring";
      char v14 = "%{public}s called with null stringRef, backtrace limit exceeded";
    }

    goto LABEL_25;
  }

  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding == -1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_utilities_create_c_string_from_cfstring";
    uint64_t v5 = _os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_utilities_create_c_string_from_cfstring";
        char v14 = "%{public}s CFStringGetMaximumSizeForEncoding failed";
LABEL_25:
        v21 = v12;
        os_log_type_t v22 = v13;
LABEL_26:
        _os_log_impl(&dword_181A5C000, v21, v22, v14, buf, 0xCu);
      }
    }

    else
    {
      if (v29)
      {
        v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v12, type);
        if (v15)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_utilities_create_c_string_from_cfstring";
            __int16 v33 = 2082;
            v34 = v15;
            _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s CFStringGetMaximumSizeForEncoding failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v15);
          if (!v5) {
            return 0LL;
          }
          goto LABEL_40;
        }

        if (!v17) {
          goto LABEL_27;
        }
        *(_DWORD *)buf = 136446210;
        v32 = "nw_utilities_create_c_string_from_cfstring";
        char v14 = "%{public}s CFStringGetMaximumSizeForEncoding failed, no backtrace";
        v21 = v12;
        os_log_type_t v22 = v16;
        goto LABEL_26;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_utilities_create_c_string_from_cfstring";
        char v14 = "%{public}s CFStringGetMaximumSizeForEncoding failed, backtrace limit exceeded";
        goto LABEL_25;
      }
    }

BOOL nw_calloc_type<unsigned char>(size_t __count)
{
  if (!__count)
  {
    CFIndex v4 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    uint64_t v5 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v5);
    if (result) {
      goto LABEL_8;
    }
    free(v5);
  }

  CFIndex v2 = calloc(__count, 1uLL);
  if (v2) {
    return (BOOL)v2;
  }
  id v6 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  v7 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    return (BOOL)v2;
  }

LABEL_8:
  __break(1u);
  return result;
}

  v3 = 0LL;
LABEL_9:

  return v3;
}

  return a2;
}

    uint64_t v5 = v4;
    goto LABEL_9;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v21 = "nw_endpoint_copy_proxy_original_endpoint";
  v7 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    CFIndex v4 = (id)*((void *)v3 + 14);
    if ((*((_BYTE *)v3 + 231) & 2) == 0) {
      goto LABEL_5;
    }
    goto LABEL_8;
  }

  __break(1u);
  return result;
}

    id v6 = 0LL;
LABEL_12:
    pthread_mutex_unlock(&sSettingsMutex);
    return v6;
  }

  return 0LL;
}

                  v8 = *((_WORD *)handle + 166);
                  if ((v8 & 0x400) != 0)
                  {
                    os_log_type_t v9 = v8 & 0xFBFF;
                    *((_WORD *)handle + 166) = v8 & 0xFBFF;
                    v10 = (void *)*((void *)v220 + 89);
                    if (v10)
                    {
                      v214 = v3;
                      id v11 = v10;
                      BOOL v12 = nw_read_request_list_remove_head(*((void **)v220 + 89));
                      os_log_type_t v13 = (void *)*((void *)v220 + 89);
                      *((void *)v220 + 89) = v12;

                      char v14 = v6;
                      v15 = (*((_BYTE *)v14 + 268) & 0x20) == 0;

                      if (v15)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
                        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                        {
                          BOOL v17 = v14;

                          __int16 v18 = v17;
                          os_log_type_t v19 = (*((_BYTE *)v14 + 268) & 1) == 0;

                          if (v19) {
                            BOOL v20 = "";
                          }
                          else {
                            BOOL v20 = "dry-run ";
                          }
                          v21 = nw_endpoint_handler_copy_endpoint(v18);
                          os_log_type_t v22 = nw_endpoint_get_logging_description(v21);
                          v23 = v18;
                          os_log_type_t v24 = v23;
                          v25 = v23[30];
                          log = (os_log_t)v22;
                          else {
                            v26 = off_189BBBBF0[v25];
                          }
                          v201 = v26;

                          v76 = v24;
                          v77 = "path";
                          switch(v6->mode)
                          {
                            case 0:
                              break;
                            case 1:
                              v77 = "resolver";
                              break;
                            case 2:
                              v77 = nw_endpoint_flow_mode_string(v76[31]);
                              break;
                            case 3:
                              v77 = "proxy";
                              break;
                            case 4:
                              v77 = "fallback";
                              break;
                            case 5:
                              v77 = "transform";
                              break;
                            default:
                              v77 = "unknown-mode";
                              break;
                          }

                          v200 = v77;

                          v112 = v17;
                          v113 = v11;
                          v114 = v21;
                          v115 = v76;
                          os_unfair_lock_lock((os_unfair_lock_t)v115 + 28);
                          v116 = v115[8];
                          os_unfair_lock_unlock((os_unfair_lock_t)v115 + 28);

                          v117 = v114;
                          id v11 = v113;
                          *(_DWORD *)buf = 136448258;
                          v232 = "nw_flow_connected";
                          v233 = 2082;
                          v234 = v112->id_str;
                          v235 = 2082;
                          v236 = v20;
                          v237 = 2082;
                          v238 = log;
                          v239 = 2082;
                          v240 = v201;
                          v241 = 2082;
                          v242 = v200;
                          v243 = 2114;
                          v244 = v116;
                          v245 = 2112;
                          v246 = v113;
                          v247 = 2048;
                          v248 = handle;
                          _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding new flow read request %@ to %p",  buf,  0x5Cu);
                        }
                      }

                      nw_flow_add_read_request(v14, (uint64_t)handle, v11);

                      v3 = v214;
                      a2 = v218;
                    }

                    else
                    {
                      *((_WORD *)handle + 166) = v9 | 0x20;
                      a2 = v218;
                    }
                  }

                  default_input_handler = v3->default_input_handler;
                  if (default_input_handler)
                  {
                    nw_protocol_connected(default_input_handler, (uint64_t)a2);
                    if (v3->output_handler == a2) {
                      nw_protocol_connected(v3->default_input_handler->flow_id, (uint64_t)v3);
                    }
                  }

                  goto LABEL_116;
                }
              }
            }
          }

          v120 = nw_endpoint_handler_get_minimize_logging(v6);
          v121 = nw_endpoint_handler_get_logging_disabled(v6);
          if (v120)
          {
            if ((v121 & 1) != 0) {
              goto LABEL_127;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v122 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
            {
              v181 = nw_endpoint_handler_get_id_string(v6);
              logi = nw_endpoint_handler_dry_run_string(v6);
              v182 = nw_endpoint_handler_copy_endpoint(v6);
              v183 = nw_endpoint_get_logging_description(v182);
              v184 = nw_endpoint_handler_state_string(v6);
              v185 = nw_endpoint_handler_mode_string(v6);
              v186 = nw_endpoint_handler_copy_current_path(v6);
              *(_DWORD *)buf = 136448002;
              v232 = "nw_flow_connected";
              v233 = 2082;
              v234 = (void *)v181;
              v235 = 2082;
              v236 = logi;
              v237 = 2082;
              v238 = (void *)v183;
              v239 = 2082;
              v240 = v184;
              v241 = 2082;
              v242 = v185;
              v243 = 2114;
              v244 = v186;
              v245 = 2082;
              v246 = __str;
              _os_log_impl( &dword_181A5C000,  v122,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol connected%{public}s",  buf,  0x52u);
            }
          }

          else
          {
            if ((v121 & 1) != 0)
            {
LABEL_127:
              v6->event = (nw_endpoint_handler_event_s)917507;
              nw_endpoint_handler_report(v6, 0LL, &v6->event.domain, 0LL);
              nw_flow_get_remote(v3);
              v48 = (id)objc_claimAutoreleasedReturnValue();
              if (!v48) {
                goto LABEL_96;
              }
              v132 = handle[22];
              v133 = v48;
              v134 = (unsigned __int8 *)nw_endpoint_copy_cname_array(v48);
              v135 = v134;
              if (v134 && *((void *)v134 + 3) != *((void *)v134 + 2))
              {
                v227 = 0LL;
                v228 = &v227;
                v229 = 0x2020000000LL;
                v230 = 0;
                v136 = nw_context_copy_tracker_lookup_callback(handle[23]);
                if (v136)
                {
                  v224[0] = MEMORY[0x1895F87A8];
                  v224[1] = 3221225472LL;
                  v224[2] = ___ZL17nw_flow_connectedP11nw_protocolS0__block_invoke;
                  v224[3] = &unk_189BB8F60;
                  v137 = v136;
                  v225 = v136;
                  v226 = &v227;
                  nw_array_apply(v135, (uint64_t)v224);

                  v136 = v137;
                }

                if (*((_BYTE *)v228 + 24))
                {
                  v219 = v136;
                  v138 = nw_endpoint_handler_get_minimize_logging(v6);
                  v139 = nw_endpoint_handler_get_logging_disabled(v6);
                  if (v138)
                  {
                    if ((v139 & 1) != 0) {
                      goto LABEL_144;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v217 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v217, OS_LOG_TYPE_DEBUG))
                    {
                      v194 = nw_endpoint_handler_get_id_string(v6);
                      logj = nw_endpoint_handler_dry_run_string(v6);
                      v195 = nw_endpoint_handler_copy_endpoint(v6);
                      v196 = nw_endpoint_get_logging_description(v195);
                      v197 = nw_endpoint_handler_state_string(v6);
                      v198 = nw_endpoint_handler_mode_string(v6);
                      v199 = nw_endpoint_handler_copy_current_path(v6);
                      *(_DWORD *)buf = 136447746;
                      v232 = "nw_flow_connected";
                      v233 = 2082;
                      v234 = (void *)v194;
                      v235 = 2082;
                      v236 = logj;
                      v237 = 2082;
                      v238 = (void *)v196;
                      v239 = 2082;
                      v240 = v197;
                      v241 = 2082;
                      v242 = v198;
                      v243 = 2114;
                      v244 = v199;
                      _os_log_impl( &dword_181A5C000,  v217,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol detected tracker to block",  buf,  0x48u);
                    }
                  }

                  else
                  {
                    if ((v139 & 1) != 0)
                    {
LABEL_144:
                      v147 = handle[23];
                      v222[0] = MEMORY[0x1895F87A8];
                      v222[1] = 3221225472LL;
                      v222[2] = ___ZL17nw_flow_connectedP11nw_protocolS0__block_invoke_97;
                      v222[3] = &unk_189BC93A0;
                      v223 = v6;
                      nw_queue_context_async(v147, v222);

                      _Block_object_dispose(&v227, 8);
                      goto LABEL_116;
                    }

                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v140 = (os_log_s *)(id)gconnectionLogObj;
                    if (!os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
                    {
LABEL_143:

                      goto LABEL_144;
                    }

                    v217 = v140;
                    loge = nw_endpoint_handler_get_id_string(v6);
                    v141 = nw_endpoint_handler_dry_run_string(v6);
                    v142 = nw_endpoint_handler_copy_endpoint(v6);
                    v143 = nw_endpoint_get_logging_description(v142);
                    v144 = nw_endpoint_handler_state_string(v6);
                    v145 = nw_endpoint_handler_mode_string(v6);
                    v146 = nw_endpoint_handler_copy_current_path(v6);
                    *(_DWORD *)buf = 136447746;
                    v232 = "nw_flow_connected";
                    v233 = 2082;
                    v234 = (void *)loge;
                    v235 = 2082;
                    v236 = v141;
                    v237 = 2082;
                    v238 = (void *)v143;
                    v239 = 2082;
                    v240 = v144;
                    v241 = 2082;
                    v242 = v145;
                    v243 = 2114;
                    v244 = v146;
                    _os_log_impl( &dword_181A5C000,  v217,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol de tected tracker to block",  buf,  0x48u);
                  }

                  v140 = v217;
                  goto LABEL_143;
                }

                _Block_object_dispose(&v227, 8);
              }

              goto LABEL_96;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v122 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
            {
              v123 = nw_endpoint_handler_get_id_string(v6);
              v124 = nw_endpoint_handler_dry_run_string(v6);
              v125 = nw_endpoint_handler_copy_endpoint(v6);
              v126 = v122;
              v127 = v124;
              v128 = nw_endpoint_get_logging_description(v125);
              v129 = nw_endpoint_handler_state_string(v6);
              v130 = nw_endpoint_handler_mode_string(v6);
              v131 = nw_endpoint_handler_copy_current_path(v6);
              *(_DWORD *)buf = 136448002;
              v232 = "nw_flow_connected";
              v233 = 2082;
              v234 = (void *)v123;
              v235 = 2082;
              v236 = v127;
              v237 = 2082;
              v238 = (void *)v128;
              v239 = 2082;
              v240 = v129;
              v241 = 2082;
              v242 = v130;
              v243 = 2114;
              v244 = v131;
              v245 = 2082;
              v246 = __str;
              _os_log_impl( &dword_181A5C000,  v126,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol connected%{public}s",  buf,  0x52u);

              v122 = v126;
            }
          }

          v3 = v215;
          goto LABEL_127;
        }

        v75 = "Joined";
      }

      v215 = v3;
      if (a2)
      {
        v90 = a2->callbacks;
        if (v90)
        {
          v91 = (unsigned int (*)(nw_protocol *, nw_protocol *))v90->waiting_for_output;
          if (v91)
          {
            if (v91(a2, v3))
            {
              v92 = nw_endpoint_handler_get_minimize_logging(v6);
              v93 = nw_endpoint_handler_get_logging_disabled(v6);
              if (v92)
              {
                a2 = v218;
                if ((v93 & 1) != 0) {
                  goto LABEL_8;
                }
                loga = (os_log_t)v75;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v161 = (os_log_s *)(id)gconnectionLogObj;
                if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
                {
                  v162 = nw_endpoint_handler_get_id_string(v6);
                  v163 = nw_endpoint_handler_dry_run_string(v6);
                  v164 = nw_endpoint_handler_copy_endpoint(v6);
                  v165 = nw_endpoint_get_logging_description(v164);
                  v166 = nw_endpoint_handler_state_string(v6);
                  v167 = nw_endpoint_handler_mode_string(v6);
                  v168 = nw_endpoint_handler_copy_current_path(v6);
                  *(_DWORD *)buf = 136448258;
                  v232 = "nw_flow_connected";
                  v233 = 2082;
                  v234 = (void *)v162;
                  v235 = 2082;
                  v236 = v163;
                  v237 = 2082;
                  v238 = (void *)v165;
                  v239 = 2082;
                  v240 = v166;
                  v241 = 2082;
                  v242 = v167;
                  v243 = 2114;
                  v244 = v168;
                  v245 = 2082;
                  v246 = loga;
                  v247 = 2082;
                  v248 = (id *)__str;
                  _os_log_impl( &dword_181A5C000,  v161,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol %{public}s waiting for output, ignore",  buf,  0x5Cu);
                }

                v48 = v161;
                goto LABEL_96;
              }

              a2 = v218;
              if ((v93 & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                v48 = (id)gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)v48, OS_LOG_TYPE_INFO))
                {
                  v94 = nw_endpoint_handler_get_id_string(v6);
                  v95 = nw_endpoint_handler_dry_run_string(v6);
                  logc = (os_log_s *)v48;
                  v96 = nw_endpoint_handler_copy_endpoint(v6);
                  v97 = nw_endpoint_get_logging_description(v96);
                  v98 = nw_endpoint_handler_state_string(v6);
                  v99 = nw_endpoint_handler_mode_string(v6);
                  v100 = nw_endpoint_handler_copy_current_path(v6);
                  *(_DWORD *)buf = 136448258;
                  v232 = "nw_flow_connected";
                  v233 = 2082;
                  v234 = (void *)v94;
                  v235 = 2082;
                  v236 = v95;
                  v237 = 2082;
                  v238 = (void *)v97;
                  v239 = 2082;
                  v240 = v98;
                  v241 = 2082;
                  v242 = v99;
                  v243 = 2114;
                  v244 = v100;
                  v245 = 2082;
                  v246 = v75;
                  v247 = 2082;
                  v248 = (id *)__str;
                  _os_log_impl( &dword_181A5C000,  logc,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol %{public}s waiting for output, ignore",  buf,  0x5Cu);

                  v48 = logc;
                }

                goto LABEL_96;
              }

              goto LABEL_8;
            }
          }
        }
      }

      v101 = nw_endpoint_handler_get_minimize_logging(v6);
      v102 = nw_endpoint_handler_get_logging_disabled(v6);
      if (v101)
      {
        if ((v102 & 1) != 0) {
          goto LABEL_104;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v103 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        {
          logf = nw_endpoint_handler_get_id_string(v6);
          v202 = nw_endpoint_handler_dry_run_string(v6);
          v156 = nw_endpoint_handler_copy_endpoint(v6);
          v157 = nw_endpoint_get_logging_description(v156);
          v158 = nw_endpoint_handler_state_string(v6);
          v159 = nw_endpoint_handler_mode_string(v6);
          v160 = nw_endpoint_handler_copy_current_path(v6);
          *(_DWORD *)buf = 136448258;
          v232 = "nw_flow_connected";
          v233 = 2082;
          v234 = (void *)logf;
          v235 = 2082;
          v236 = v202;
          v237 = 2082;
          v238 = (void *)v157;
          v239 = 2082;
          v240 = v158;
          v241 = 2082;
          v242 = v159;
          v243 = 2114;
          v244 = v160;
          v245 = 2082;
          v246 = v75;
          v247 = 2082;
          v248 = (id *)__str;
          _os_log_impl( &dword_181A5C000,  v103,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol connected%{public}s",  buf,  0x5Cu);
        }
      }

      else
      {
        if ((v102 & 1) != 0)
        {
LABEL_104:
          v6->event = (nw_endpoint_handler_event_s)327683;
          nw_endpoint_handler_report(v6, 0LL, &v6->event.domain, 0LL);
          a2 = v218;
          goto LABEL_8;
        }

        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v103 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
        {
          logd = v103;
          v104 = nw_endpoint_handler_get_id_string(v6);
          v105 = nw_endpoint_handler_dry_run_string(v6);
          v106 = nw_endpoint_handler_copy_endpoint(v6);
          v107 = v104;
          v108 = nw_endpoint_get_logging_description(v106);
          v109 = nw_endpoint_handler_state_string(v6);
          v110 = nw_endpoint_handler_mode_string(v6);
          v111 = nw_endpoint_handler_copy_current_path(v6);
          *(_DWORD *)buf = 136448258;
          v232 = "nw_flow_connected";
          v233 = 2082;
          v234 = (void *)v107;
          v235 = 2082;
          v236 = v105;
          v237 = 2082;
          v238 = (void *)v108;
          v239 = 2082;
          v240 = v109;
          v241 = 2082;
          v242 = v110;
          v243 = 2114;
          v244 = v111;
          v245 = 2082;
          v246 = v75;
          v247 = 2082;
          v248 = (id *)__str;
          _os_log_impl( &dword_181A5C000,  logd,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol connected%{public}s",  buf,  0x5Cu);

          v103 = logd;
        }
      }

      v3 = v215;
      goto LABEL_104;
    }

    if (a2)
    {
      v61 = a2->callbacks;
      if (v61)
      {
        v62 = (unsigned int (*)(nw_protocol *, nw_protocol *))v61->waiting_for_output;
        if (v62)
        {
          if (v62(a2, v3))
          {
            v63 = nw_endpoint_handler_get_minimize_logging(v6);
            v64 = nw_endpoint_handler_get_logging_disabled(v6);
            v216 = v3;
            if (v63)
            {
              if ((v64 & 1) != 0) {
                goto LABEL_64;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v65 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
              {
                v175 = nw_endpoint_handler_get_id_string(v6);
                logh = nw_endpoint_handler_dry_run_string(v6);
                v176 = nw_endpoint_handler_copy_endpoint(v6);
                v177 = nw_endpoint_get_logging_description(v176);
                v178 = nw_endpoint_handler_state_string(v6);
                v179 = nw_endpoint_handler_mode_string(v6);
                v180 = nw_endpoint_handler_copy_current_path(v6);
                *(_DWORD *)buf = 136447746;
                v232 = "nw_flow_connected";
                v233 = 2082;
                v234 = (void *)v175;
                v235 = 2082;
                v236 = logh;
                v237 = 2082;
                v238 = (void *)v177;
                v239 = 2082;
                v240 = v178;
                v241 = 2082;
                v242 = v179;
                v243 = 2114;
                v244 = v180;
                _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fast open started, need initial data",  buf,  0x48u);
              }
            }

            else
            {
              if ((v64 & 1) != 0)
              {
LABEL_64:
                *((_WORD *)handle + 166) |= 0x800u;
                nw_endpoint_flow_add_initial_write_request(v6);
                a2 = v218;
                v6->event = (nw_endpoint_handler_event_s)589827;
                nw_endpoint_handler_report(v6, 0LL, &v6->event.domain, 0LL);
LABEL_84:
                nw_endpoint_handler_service_writes(v6);
                nw_endpoint_handler_service_reads(v6);
                goto LABEL_8;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v65 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
              {
                v66 = nw_endpoint_handler_get_id_string(v6);
                v67 = nw_endpoint_handler_dry_run_string(v6);
                v68 = nw_endpoint_handler_copy_endpoint(v6);
                v69 = v65;
                v70 = v67;
                v71 = nw_endpoint_get_logging_description(v68);
                v72 = nw_endpoint_handler_state_string(v6);
                v73 = nw_endpoint_handler_mode_string(v6);
                v74 = nw_endpoint_handler_copy_current_path(v6);
                *(_DWORD *)buf = 136447746;
                v232 = "nw_flow_connected";
                v233 = 2082;
                v234 = (void *)v66;
                v235 = 2082;
                v236 = v70;
                v237 = 2082;
                v238 = (void *)v71;
                v239 = 2082;
                v240 = v72;
                v241 = 2082;
                v242 = v73;
                v243 = 2114;
                v244 = v74;
                _os_log_impl( &dword_181A5C000,  v69,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fast open started, need initial data",  buf,  0x48u);

                v65 = v69;
              }
            }

            v3 = v216;
            goto LABEL_64;
          }
        }
      }
    }

    v80 = nw_endpoint_handler_get_minimize_logging(v6);
    v81 = nw_endpoint_handler_get_logging_disabled(v6);
    if (v80)
    {
      if ((v81 & 1) != 0) {
        goto LABEL_83;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v82 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
      {
        v169 = nw_endpoint_handler_get_id_string(v6);
        logg = nw_endpoint_handler_dry_run_string(v6);
        v170 = nw_endpoint_handler_copy_endpoint(v6);
        v171 = nw_endpoint_get_logging_description(v170);
        v172 = nw_endpoint_handler_state_string(v6);
        v173 = nw_endpoint_handler_mode_string(v6);
        v174 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        v232 = "nw_flow_connected";
        v233 = 2082;
        v234 = (void *)v169;
        v235 = 2082;
        v236 = logg;
        v237 = 2082;
        v238 = (void *)v171;
        v239 = 2082;
        v240 = v172;
        v241 = 2082;
        v242 = v173;
        v243 = 2114;
        v244 = v174;
        v245 = 2082;
        v246 = __str;
        _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol connected%{public}s",  buf,  0x52u);
      }
    }

    else
    {
      if ((v81 & 1) != 0)
      {
LABEL_83:
        *((_WORD *)handle + 166) &= ~0x800u;
        *((_DWORD *)v220 + 251) = 0;
        nw_endpoint_flow_add_initial_write_request(v6);
        a2 = v218;
        nw_endpoint_flow_connected(v6);
        goto LABEL_84;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v82 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        logb = v82;
        v83 = nw_endpoint_handler_get_id_string(v6);
        v84 = nw_endpoint_handler_dry_run_string(v6);
        v85 = nw_endpoint_handler_copy_endpoint(v6);
        v86 = nw_endpoint_get_logging_description(v85);
        v87 = nw_endpoint_handler_state_string(v6);
        v88 = nw_endpoint_handler_mode_string(v6);
        v89 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        v232 = "nw_flow_connected";
        v233 = 2082;
        v234 = (void *)v83;
        v235 = 2082;
        v236 = v84;
        v237 = 2082;
        v238 = (void *)v86;
        v239 = 2082;
        v240 = v87;
        v241 = 2082;
        v242 = v88;
        v243 = 2114;
        v244 = v89;
        v245 = 2082;
        v246 = __str;
        _os_log_impl( &dword_181A5C000,  logb,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol connected%{public}s",  buf,  0x52u);

        v82 = logb;
      }
    }

    goto LABEL_83;
  }

  v119 = 0LL;
  __nwlog_obj();
  v148 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v232 = "nw_flow_connected";
  v149 = (char *)_os_log_send_and_compose_impl();

  __str[0] = 16;
  LOBYTE(v227) = 0;
  if (__nwlog_fault(v149, __str, &v227))
  {
    if (__str[0] == 17)
    {
      __nwlog_obj();
      v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v151 = __str[0];
      if (os_log_type_enabled(v150, (os_log_type_t)__str[0]))
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl(&dword_181A5C000, v150, v151, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if ((_BYTE)v227)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v153 = __str[0];
      v154 = os_log_type_enabled(v150, (os_log_type_t)__str[0]);
      if (backtrace_string)
      {
        if (v154)
        {
          *(_DWORD *)buf = 136446466;
          v232 = "nw_flow_connected";
          v233 = 2082;
          v234 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v150,  v153,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_163;
      }

      if (v154)
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl(&dword_181A5C000, v150, v153, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v155 = __str[0];
      if (os_log_type_enabled(v150, (os_log_type_t)__str[0]))
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl( &dword_181A5C000,  v150,  v155,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  __break(1u);
  return result;
}

    CFIndex v4 = 0;
    goto LABEL_11;
  }

  if ((_DWORD)result == 1001)
  {
    CFIndex v4 = 1;
    goto LABEL_11;
  }

  if ((_DWORD)result != 1002) {
    goto LABEL_8;
  }
  CFIndex v4 = 2;
LABEL_11:
  *a2 = v4;
  return result;
}

    uint64_t v5 = 0;
    goto LABEL_11;
  }

  if (required_interface_subtype == 1001)
  {
    uint64_t v5 = 1;
    goto LABEL_11;
  }

  uint64_t v5 = 2;
LABEL_11:
  CFURLRef v3 = v5;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 24));
  return sub_181C97660;
}

              if (v12 == v13) {
                return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
              }
            }
          }

        BOOL v12 = 2 * v8;
        if (__n > 2 * v8) {
          BOOL v12 = __n;
        }
        os_log_type_t v13 = (v12 & 0xFFFFFFFFFFFFFFF8LL) + 8;
        if ((v12 | 7) != 0x17) {
          os_log_type_t v13 = v12 | 7;
        }
        if (v12 >= 0x17) {
          id v11 = v13 + 1;
        }
        else {
          id v11 = 23LL;
        }
        goto LABEL_15;
      }

    *(void *)chars = 0LL;
    *(void *)&chars[8] = chars;
    *(void *)&chars[16] = 0x3802000000LL;
    v41 = __Block_byref_object_copy__23;
    v42 = __Block_byref_object_dispose__24;
    v43 = nw_endpoint_copy_cfurl(v6);
    v44 |= 1u;
    if (!*(void *)(*(void *)&chars[8] + 40LL))
    {
      if ((*(_BYTE *)(*(void *)(a1 + 40) + 198LL) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v21 = *(void *)(a1 + 40) + 114LL;
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_copy_endpoint_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v21;
          *(_WORD *)&buf[22] = 2080;
          v36 = (uint64_t (*)(uint64_t, uint64_t))" ";
          _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sfailed to get base URL",  buf,  0x20u);
        }
      }

      goto LABEL_37;
    }

    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3802000000LL;
    v36 = __Block_byref_object_copy__23;
    v37 = __Block_byref_object_dispose__24;
    cf = 0LL;
    v39 = -1;
    v28[0] = MEMORY[0x1895F87A8];
    v28[1] = 0x40000000LL;
    v28[2] = ___ZL30nw_http_redirect_copy_endpointP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke_25;
    v28[3] = &unk_189BB5D88;
    v28[4] = buf;
    v28[5] = chars;
    nw_utilities_get_c_string_from_cfstring(Mutable, 0x600u, v28);
    if (*(void *)(*(void *)&buf[8] + 40LL))
    {
      rangeIncludingSeparators.location = 0LL;
      rangeIncludingSeparators.length = 0LL;
      v26.location = 0LL;
      v26.length = 0LL;
      CFURLGetByteRangeForComponent( *(CFURLRef *)(*(void *)&chars[8] + 40LL),  kCFURLComponentFragment,  &rangeIncludingSeparators);
      CFURLGetByteRangeForComponent(*(CFURLRef *)(*(void *)&buf[8] + 40LL), kCFURLComponentFragment, &v26);
      if (v26.length) {
        BOOL v12 = 1;
      }
      else {
        BOOL v12 = rangeIncludingSeparators.length == 0;
      }
      if (v12) {
        length = 0LL;
      }
      else {
        length = rangeIncludingSeparators.length;
      }
      char v14 = CFURLGetBytes(*(CFURLRef *)(*(void *)&buf[8] + 40LL), 0LL, 0LL);
      if (v14 > 0)
      {
        v15 = v14;
        os_log_type_t v16 = nw_calloc_type<unsigned char>(length + v14 + 1);
        CFURLGetBytes(*(CFURLRef *)(*(void *)&buf[8] + 40LL), (UInt8 *)v16, v15);
        if (length >= 1)
        {
          url = nw_endpoint_get_url((nw_endpoint_t)v6);
          memcpy((void *)(v16 + v15), &url[rangeIncludingSeparators.location], length);
        }

        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = nw_endpoint_create_url((const char *)v16);
        if (v16) {
          free((void *)v16);
        }
        goto LABEL_34;
      }

      if ((*(_BYTE *)(*(void *)(a1 + 40) + 198LL) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v22 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v25 = *(void *)(a1 + 40) + 114LL;
          *(_DWORD *)char v29 = 136446722;
          v30 = "nw_http_redirect_copy_endpoint_block_invoke";
          v31 = 2082;
          v32 = v25;
          __int16 v33 = 2080;
          v34 = " ";
          os_log_type_t v24 = "%{public}s %{public}s%sfailed to get string bytes";
          goto LABEL_33;
        }
      }
    }

    else if ((*(_BYTE *)(*(void *)(a1 + 40) + 198LL) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v22 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v23 = *(void *)(a1 + 40) + 114LL;
        *(_DWORD *)char v29 = 136446722;
        v30 = "nw_http_redirect_copy_endpoint_block_invoke_2";
        v31 = 2082;
        v32 = v23;
        __int16 v33 = 2080;
        v34 = " ";
        os_log_type_t v24 = "%{public}s %{public}s%sfailed to get target URL";
LABEL_33:
        _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_ERROR, v24, v29, 0x20u);
      }
    }

  char v14 = *(void *)(a1 + 32);
  os_log_type_t v13 = v16;
  if (v16) {
    goto LABEL_9;
  }
LABEL_10:

  (*(void (**)(uint64_t, id, void *))(v14 + 16))(v14, v16, v12);
}

    BOOL v12 = v9;
    if (!v6) {
      goto LABEL_25;
    }
  }

  if (*(void *)(v6 + 88)) {
    -[NWConcrete_nw_ethernet_channel closeChannel:](v6, 0);
  }
  if (v9)
  {
    -[NWConcrete_nw_ethernet_channel updateClientState:error:](v6, 2, 0LL);
    os_log_type_t v13 = v9;
    char v14 = v13[4];

    if (v14)
    {
      ethernet_address = nw_endpoint_get_ethernet_address(v14);
      if (ethernet_address)
      {
        objc_storeStrong((id *)(v6 + 88), a3);
        os_log_type_t v16 = *(_DWORD *)ethernet_address;
        *(_WORD *)(v6 + 100) = *((_WORD *)ethernet_address + 2);
        *(_DWORD *)(v6 + 96) = v16;
        if ((-[NWConcrete_nw_ethernet_channel createChannel](v6) & 1) != 0) {
          goto LABEL_24;
        }
        goto LABEL_23;
      }
    }

    BOOL v17 = *(void *)(v6 + 152);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v18 = (os_log_s *)(id)gLogObj;
    os_log_type_t v19 = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (v17)
    {
      if (v19)
      {
        BOOL v20 = *(void *)(v6 + 24);
        v21 = *(_DWORD *)(v6 + 168);
        v57 = 136447234;
        v58 = "-[NWConcrete_nw_ethernet_channel resetFlow:]";
        v59 = 2080;
        v60 = v20;
        v61 = 1042;
        v62 = 16;
        v63 = 2098;
        v64 = (unsigned __int8 *)(v6 + 115);
        v65 = 1024;
        v66 = v21;
        os_log_type_t v22 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] resetFlow failed to set flow, no local ethernet address";
        v23 = v18;
        os_log_type_t v24 = 44;
LABEL_21:
        _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v57, v24);
      }
    }

    else if (v19)
    {
      v57 = 136446466;
      v58 = "-[NWConcrete_nw_ethernet_channel resetFlow:]";
      v59 = 2114;
      v60 = v6;
      os_log_type_t v22 = "%{public}s [%{public}@] resetFlow failed to set flow, no local ethernet address";
      v23 = v18;
      os_log_type_t v24 = 22;
      goto LABEL_21;
    }

LABEL_23:
    -[NWConcrete_nw_ethernet_channel closeChannel:](v6, 53);
LABEL_24:
  }

    free(v9);
    goto LABEL_9;
  }

  if (!(2 * size))
  {
    __nwlog_obj();
    v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v31 = "strict_calloc";
    os_log_type_t v24 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v24);
    if (result) {
      goto LABEL_31;
    }
    free(v24);
  }

  char v14 = (uint8_t *)calloc(1uLL, 2 * size);
  if (v14) {
    goto LABEL_12;
  }
  __nwlog_obj();
  v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v31 = "strict_calloc";
  v32 = 2048;
  __int16 v33 = 1LL;
  v34 = 2048;
  uint64_t v35 = 2 * size;
  v26 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
LABEL_12:
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = ___ZL32nw_txt_record_set_key_data_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPU27objcproto16OS_dispatch_dataS__block_invoke;
    applier[3] = &__block_descriptor_48_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
    applier[4] = size;
    applier[5] = v14;
    dispatch_data_apply(v6, applier);
    os_log_type_t v13 = nw_txt_record_set_key((nw_txt_record_t)v5, a2, v14, 2 * size);
    if (v14) {
      free(v14);
    }
    goto LABEL_14;
  }

  return 1LL;
}

  BOOL v12 = *(void *)(*(void *)(a1 + 48) + 8LL);
  if (!a5)
  {
    if ((*(_BYTE *)(v12 + 232) & 8) != 0) {
      return a3;
    }
LABEL_17:
    BOOL v17 = 0;
    goto LABEL_67;
  }

  os_log_type_t v13 = *(_DWORD *)(v12 + 232);
  if (v13 != 8)
  {
    if (v13 != 10)
    {
      if (v13 == 9)
      {
        char v14 = a5;
        v15 = (nw_framer *)*(id *)(a1 + 32);
        if (v15)
        {
          if (gLogDatapath)
          {
            __nwlog_obj();
            v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
            {
              v82 = *(void *)(v12 + 160);
              v83 = *(void *)(v12 + 136);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_ws_process_ping_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v12 + 275;
              *(_WORD *)&buf[22] = 1040;
              *(_DWORD *)v108 = v82;
              *(_WORD *)&v108[4] = 2096;
              *(void *)&v108[6] = v83;
              _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s got ping frame '%{network:data}.*P'",  buf,  0x26u);
            }
          }

          os_log_type_t v16 = nw_framer_copy_options(v15);
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL24nw_ws_process_ping_frameP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObject_block_invoke;
          *(void *)v108 = &unk_189BC64E8;
          *(void *)&v108[16] = v12 + 48;
          *(void *)&v108[8] = v15;
          nw_protocol_options_access_handle(v16, buf);

LABEL_15:
          BOOL v17 = 0;
          a5 = v14;
          goto LABEL_67;
        }

        __nwlog_obj();
        v73 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_process_ping_frame";
        v74 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(block) = 16;
        LOBYTE(v103) = 0;
        if (__nwlog_fault(v74, &block, &v103))
        {
          if (block == 17)
          {
            __nwlog_obj();
            v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v76 = block;
            if (os_log_type_enabled(v75, (os_log_type_t)block))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_ws_process_ping_frame";
              _os_log_impl(&dword_181A5C000, v75, v76, "%{public}s called with null framer", buf, 0xCu);
            }
          }

          else if ((_BYTE)v103)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v85 = block;
            v86 = os_log_type_enabled(v75, (os_log_type_t)block);
            if (backtrace_string)
            {
              if (v86)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_ws_process_ping_frame";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v75,  v85,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
              goto LABEL_141;
            }

            if (v86)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_ws_process_ping_frame";
              _os_log_impl(&dword_181A5C000, v75, v85, "%{public}s called with null framer, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v91 = block;
            if (os_log_type_enabled(v75, (os_log_type_t)block))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_ws_process_ping_frame";
              _os_log_impl( &dword_181A5C000,  v75,  v91,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

  return v9;
}

    return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  a4,  a5,  a4);
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v9 = *(void *)(a1 + 40);
      BOOL v17 = 136446722;
      __int16 v18 = "nw_endpoint_access_custom_metadata_for_key_block_invoke";
      os_log_type_t v19 = 2048;
      BOOL v20 = a5;
      v21 = 2080;
      os_log_type_t v22 = v9;
      v10 = "%{public}s found value of %zu bytes for key %s in custom metadata";
      id v11 = v8;
      BOOL v12 = OS_LOG_TYPE_DEBUG;
      os_log_type_t v13 = 32;
LABEL_7:
      _os_log_impl(&dword_181A5C000, v11, v12, v10, (uint8_t *)&v17, v13);
      goto LABEL_8;
    }

    goto LABEL_8;
  }

  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  a4,  a5,  a4);
}

  v5->previous_attempt_count = xpc_dictionary_get_uint64(v2, "previous_attempt_count");
  *((_BYTE *)v5 + 84) = *((_BYTE *)v5 + 84) & 0xFE | xpc_dictionary_get_BOOL(v2, "proxy_configured");
  if (xpc_dictionary_get_BOOL(v2, "used_proxy")) {
    v8 = 2;
  }
  else {
    v8 = 0;
  }
  *((_BYTE *)v5 + 84) = *((_BYTE *)v5 + 84) & 0xFD | v8;
  if (object_getClass(v2) != v4)
  {
LABEL_12:
    os_log_type_t v9 = 0LL;
    goto LABEL_13;
  }

  os_log_type_t v19 = xpc_dictionary_get_value(v2, "protocol_reports");
  os_log_type_t v9 = v19;
  if (v19)
  {
    if (object_getClass(v19) == (Class)MEMORY[0x1895F9220])
    {
      os_log_type_t v9 = xpc_retain(v9);
      if (v9)
      {
        BOOL v20 = nw_array_create();
        protocol_reports = v5->protocol_reports;
        v5->protocol_reports = (OS_nw_array *)v20;

        v50[0] = MEMORY[0x1895F87A8];
        v50[1] = 3221225472LL;
        v50[2] = __nw_establishment_report_create_from_dictionary_block_invoke_3;
        v50[3] = &unk_189BC8CB8;
        v51 = v5;
        xpc_array_apply(v9, v50);
      }

      goto LABEL_13;
    }

    goto LABEL_12;
  }

LABEL_9:
    if (!v8) {
      goto LABEL_11;
    }
LABEL_10:
    free(v8);
    goto LABEL_11;
  }

  if (!v19)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    char v14 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v22 = "nw_socks5_connection_inner_connection_read_range_on_queue";
      v23 = 1024;
      *(_DWORD *)os_log_type_t v24 = a2;
      *(_WORD *)&v24[4] = 1024;
      *(_DWORD *)&v24[6] = a3;
      _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s unexpected minBytes %u maxBytes %u, backtrace limit exceeded",  buf,  0x18u);
    }

    goto LABEL_8;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v9 = (os_log_s *)(id)gLogObj;
  BOOL v12 = type;
  os_log_type_t v13 = os_log_type_enabled(v9, type);
  if (!backtrace_string)
  {
    if (v13)
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v22 = "nw_socks5_connection_inner_connection_read_range_on_queue";
      v23 = 1024;
      *(_DWORD *)os_log_type_t v24 = a2;
      *(_WORD *)&v24[4] = 1024;
      *(_DWORD *)&v24[6] = a3;
      _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s unexpected minBytes %u maxBytes %u, no backtrace", buf, 0x18u);
    }

    goto LABEL_8;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446978;
    os_log_type_t v22 = "nw_socks5_connection_inner_connection_read_range_on_queue";
    v23 = 1024;
    *(_DWORD *)os_log_type_t v24 = a2;
    *(_WORD *)&v24[4] = 1024;
    *(_DWORD *)&v24[6] = a3;
    v25 = 2082;
    v26 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s unexpected minBytes %u maxBytes %u, dumping backtrace:%{public}s",  buf,  0x22u);
  }

  free(backtrace_string);
  if (v8) {
    goto LABEL_10;
  }
LABEL_11:
}

  id v6 = 1LL;
LABEL_31:

  return v6;
}

  id v6 = 1LL;
LABEL_31:

  return v6;
}

    xpc_array_set_uuid(v6, 0xFFFFFFFFFFFFFFFFLL, a2);
LABEL_9:

    return;
  }

  __nwlog_obj();
  __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v30 = "strict_calloc";
  v31 = 2048;
  v32 = 1LL;
  __int16 v33 = 2048;
  v34 = 144LL;
  os_log_type_t v19 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v19))
  {
    free(v19);
    goto LABEL_6;
  }

  __break(1u);
}
}

  __break(1u);
  return result;
}

    return;
  }

  os_log_type_t v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = (id)gLogObj;
  *(_DWORD *)buf = 136446978;
  os_log_type_t v24 = "teardownFakeEthernet";
  v25 = 1024;
  *(_DWORD *)v26 = a1;
  *(_WORD *)&v26[4] = 2082;
  *(void *)&v26[6] = a2;
  v27 = 1024;
  BOOL v28 = v9;
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v20 = 0;
  if (__nwlog_fault(v11, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v24 = "teardownFakeEthernet";
        v25 = 1024;
        *(_DWORD *)v26 = a1;
        *(_WORD *)&v26[4] = 2082;
        *(void *)&v26[6] = a2;
        v27 = 1024;
        BOOL v28 = v9;
        char v14 = "%{public}s ioctl(%d, SIOCIFDESTROY, %{public}s) failed %{darwin.errno}d";
LABEL_21:
        __int16 v18 = v12;
        os_log_type_t v19 = v13;
LABEL_22:
        _os_log_impl(&dword_181A5C000, v18, v19, v14, buf, 0x22u);
      }
    }

    else
    {
      if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136447234;
            os_log_type_t v24 = "teardownFakeEthernet";
            v25 = 1024;
            *(_DWORD *)v26 = a1;
            *(_WORD *)&v26[4] = 2082;
            *(void *)&v26[6] = a2;
            v27 = 1024;
            BOOL v28 = v9;
            char v29 = 2082;
            v30 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v12,  v16,  "%{public}s ioctl(%d, SIOCIFDESTROY, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x2Cu);
          }

          free(backtrace_string);
          goto LABEL_24;
        }

        if (!v17) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v24 = "teardownFakeEthernet";
        v25 = 1024;
        *(_DWORD *)v26 = a1;
        *(_WORD *)&v26[4] = 2082;
        *(void *)&v26[6] = a2;
        v27 = 1024;
        BOOL v28 = v9;
        char v14 = "%{public}s ioctl(%d, SIOCIFDESTROY, %{public}s) failed %{darwin.errno}d, no backtrace";
        __int16 v18 = v12;
        os_log_type_t v19 = v16;
        goto LABEL_22;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v24 = "teardownFakeEthernet";
        v25 = 1024;
        *(_DWORD *)v26 = a1;
        *(_WORD *)&v26[4] = 2082;
        *(void *)&v26[6] = a2;
        v27 = 1024;
        BOOL v28 = v9;
        char v14 = "%{public}s ioctl(%d, SIOCIFDESTROY, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

  v15 = (id)v30[5];
  _Block_object_dispose(&v29, 8);

  return v15;
}

  char v14 = (id)v29[5];
  _Block_object_dispose(&v28, 8);

  return v14;
}

  v21 = (id)v38[5];
  _Block_object_dispose(&v37, 8);

  return v21;
}

  os_log_type_t v16 = *(void *)(*(void *)(a1 + 48) + 8LL);
  BOOL v17 = *(void **)(v16 + 40);
  *(void *)(v16 + 40) = v11;

  __int16 v18 = *(void *)(a1 + 32);
  if (v18) {
    os_log_type_t v19 = *(void **)(v18 + 104);
  }
  else {
    os_log_type_t v19 = 0LL;
  }
  [v19 addObject:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];
}

LABEL_9:
    if (!v9) {
      goto LABEL_11;
    }
LABEL_10:
    free(v9);
    goto LABEL_11;
  }

  if (!v17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (os_log_s *)(id)gLogObj;
    os_log_type_t v16 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "nw_ws_create_client_request_block_invoke";
      _os_log_impl( &dword_181A5C000,  v10,  v16,  "%{public}s CFStringCreatewithCString failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_8;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = (os_log_s *)(id)gLogObj;
  char v14 = type;
  v15 = os_log_type_enabled(v10, type);
  if (!backtrace_string)
  {
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "nw_ws_create_client_request_block_invoke";
      _os_log_impl(&dword_181A5C000, v10, v14, "%{public}s CFStringCreatewithCString failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_8;
  }

  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v20 = "nw_ws_create_client_request_block_invoke";
    v21 = 2082;
    os_log_type_t v22 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s CFStringCreatewithCString failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v9) {
    goto LABEL_10;
  }
LABEL_11:

  return v7 != 0LL;
}

    free(v8);
    goto LABEL_9;
  }

  return v11;
}

    v8 = *(id **)(a1 + 32);
    if (v3) {
      goto LABEL_9;
    }
    goto LABEL_22;
  }

  os_log_type_t v13 = v8 ^ 1u;

  return v13;
}

  *(void *)(v5 + 48) = v10;
  BOOL v12 = v8 - (unint64_t)v11;
  if (v8 != (unint64_t)v11)
  {
    os_log_type_t v13 = *((unsigned __int8 *)v9 + v11);
    if (v13 <= 0x3F)
    {
      char v14 = 1;
LABEL_11:
      v11 += v14;
      *(_WORD *)(v5 + 72) = 0;
      v15 = 1;
      *(void *)(v5 + 32) = v13;
      *(void *)(v5 + 40) = v13;
      goto LABEL_25;
    }

    BOOL v17 = v13 >> 6;
    if (v17 == 2)
    {
      if (v12 >= 4)
      {
        os_log_type_t v13 = bswap32(*(_DWORD *)((char *)v9 + v11) & 0xFFFFFF7F);
        char v14 = 4;
        goto LABEL_11;
      }
    }

    else if (v17 == 1)
    {
      if (v12 >= 2)
      {
        os_log_type_t v13 = bswap32(*(_WORD *)((_BYTE *)v9 + v11) & 0xFFBF) >> 16;
        char v14 = 2;
        goto LABEL_11;
      }
    }

    else if (v12 >= 8)
    {
      os_log_type_t v13 = bswap64(*(void *)((_BYTE *)v9 + v11) & 0xFFFFFFFFFFFFFF3FLL);
      char v14 = 8;
      goto LABEL_11;
    }
  }

    free(v4);
    goto LABEL_9;
  }

    goto LABEL_9;
  }

  if (v12)
  {
    v15 = a1[4];
    os_log_type_t v16 = (nw_path *)a1[5];
    BOOL v20 = 136446978;
    v21 = "nwsc_request_start_path_watcher_block_invoke";
    os_log_type_t v22 = 2114;
    v23 = v15;
    os_log_type_t v24 = 2114;
    v25 = v3;
    v26 = 2114;
    v27 = v16;
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ received path update %{public}@ for request %{public}@",  (uint8_t *)&v20,  0x2Au);
  }

  if ((nw_path_get_status(v3) & 0xFFFFFFFD) == 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v18 = a1[4];
      os_log_type_t v19 = (nw_path *)a1[5];
      BOOL v20 = 136446978;
      v21 = "nwsc_request_start_path_watcher_block_invoke";
      os_log_type_t v22 = 2114;
      v23 = v18;
      os_log_type_t v24 = 2114;
      v25 = v19;
      v26 = 2114;
      v27 = v3;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ restarting connection for request %{public}@ due to path update %{public}@",  (uint8_t *)&v20,  0x2Au);
    }

    nwsc_request_create_and_start_connection_inner(a1[4], a1[5], 0LL);
    CFIndex v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    goto LABEL_8;
  }

  free(v5);
LABEL_9:
  id v6 = *(_DWORD *)(a1 + 60);
  v7 = *(_DWORD *)(a1 + 64);
  while (v6 != v7)
  {
    uint64_t v5 = *(_DWORD **)(*(void *)(a1 + 72) + 8LL * v7);
    v7 = (v7 + 1) % *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 64) = v7;
    v8 = v5[2] - 1;
    v5[2] = v8;
    if (!v8) {
      goto LABEL_8;
    }
  }

  free(*(void **)(a1 + 72));
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  os_log_type_t v9 = *(FILE **)(a1 + 48);
  if (v9)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v9);
    fwrite("cleaned up", 0xAuLL, 1uLL, *(FILE **)(a1 + 48));
    fputc(10, *(FILE **)(a1 + 48));
  }

      id v11 = (unsigned __int8 *)&decode_tables
      BOOL v12 = v11[1];
      if ((v12 & 4) != 0) {
        goto LABEL_19;
      }
      v10 = *v11;
      if ((v11[1] & 2) != 0)
      {
        *v8++ = v11[2];
        *(_BYTE *)(a5 + 4) = v10;
        *(_BYTE *)(a5 + 5) = v12 & 1;
        if (v8 == v6) {
          goto LABEL_17;
        }
      }

      else
      {
        *(_BYTE *)(a5 + 4) = v10;
        *(_BYTE *)(a5 + 5) = v12 & 1;
        if (!v8) {
          goto LABEL_19;
        }
        if (v8 == v6)
        {
LABEL_17:
          *(_DWORD *)a5 = 3;
          os_log_type_t v9 = 2LL;
          return v9 | (a4 << 32);
        }
      }
    }

  v64 = v6;
  v59 = a3;
  v8 = 0LL;
  os_log_type_t v9 = 0;
  v65 = 0;
  do
  {
    v10 = (_BYTE *)(a1 + 16 * v8);
    if (!v10[8])
    {
      v15 = 0LL;
      while (1)
      {
        *(_DWORD *)v76 = nw_nat64_copy_prefixes_from_ipv4only_records::prefix_lengths[v15];
        os_log_type_t v16 = *(unsigned int *)v76;
        if (v15 == 5) {
          BOOL v17 = 0LL;
        }
        else {
          BOOL v17 = 12LL - *(unsigned int *)v76;
        }
        bzero(&v76[*(unsigned int *)v76 + 4], v17);
        memcpy(&v76[4], v10, v16);
        v67 = 0;
        if (v67 == -1426063168)
        {
          if (v65 >= v5)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v18 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v69 = "nw_nat64_copy_prefixes_from_ipv4only_records";
              os_log_type_t v19 = v18;
              BOOL v20 = "%{public}s too many valid prefixes for WKA2";
LABEL_32:
              _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0xCu);
            }

  if ((a2 & 1) == 0)
  {
    if (a1) {
      DNSServiceRefDeallocate(a1);
    }
    (*(void (**)(void, void))(*((void *)a8 + 1) + 16LL))(*((void *)a8 + 1), a8[4]);
    os_log_type_t v19 = (void *)*((void *)a8 + 1);
    *((void *)a8 + 1) = 0LL;

    BOOL v20 = (void *)*((void *)a8 + 1);
    *((void *)a8 + 1) = 0LL;

    if (*(void *)a8) {
      free(*(void **)a8);
    }
    free(a8);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v14 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136447234;
    v25 = "nw_nat64_prefixes_resolver_start_dns_query_locked_block_invoke";
    v26 = 2080;
    v27 = (const char *)v34;
    BOOL v28 = 2082;
    char v29 = "ipv4only.arpa";
    v30 = 2082;
    string_for_dns_service_error = nwlog_get_string_for_dns_service_error(v6);
    v32 = 1024;
    __int16 v33 = v6;
    _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s %s for %{public}s failed with error=%{public}s(%d)",  buf,  0x30u);
  }

  v15 = *(void **)(a1 + 32);
  os_log_type_t v16 = (_DNSServiceRef_t *)v15[6];
  if (v16)
  {
    DNSServiceRefDeallocate(v16);
    *(void *)(*(void *)(a1 + 32) + 48LL) = 0LL;
    v15 = *(void **)(a1 + 32);
  }

  BOOL v17 = (dispatch_queue_s *)v15[10];
  if (v17)
  {
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke_89;
    block[3] = &unk_189BC93A0;
    v23 = v15;
    dispatch_async(v17, block);

    v15 = *(void **)(a1 + 32);
  }

  __int16 v18 = (void *)v15[4];
  v15[4] = 0LL;
LABEL_18:

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8LL));
}

    v10 = *(dispatch_data_s **)(a2 + 152);
    if (v10) {
      goto LABEL_9;
    }
    goto LABEL_20;
  }

  v7 = 0LL;
  v10 = *(dispatch_data_s **)(a2 + 152);
  if (v10)
  {
LABEL_9:
    size = dispatch_data_get_size(v10);
    if (size <= 0xFF) {
      BOOL v12 = size;
    }
    else {
      BOOL v12 = 0;
    }
    os_log_type_t v13 = *(const __CFData **)(a2 + 112);
    if (v13) {
      goto LABEL_13;
    }
LABEL_21:
    char v14 = 0LL;
    os_log_type_t v16 = 0;
    goto LABEL_22;
  }

        CFIndex v4 = *a1;
        id v6 = (unint64_t)&a1[v4 + 1];
        BOOL result = 1LL;
      }

      while ((_BYTE *)v6 != v5);
    }
  }

  return result;
}

  *(void *)uint64_t v5 = v11;
  os_log_type_t v13 = v9 - (unint64_t)v12;
  if (v9 != (unint64_t)v12)
  {
    char v14 = *((unsigned __int8 *)v10 + v12);
    if (v14 <= 0x3F)
    {
      v15 = 1;
LABEL_11:
      v12 += v15;
      *(_WORD *)(v5 + 84) = 0;
      os_log_type_t v16 = 1;
      *(void *)(v5 + 8) = v14;
      *(void *)(v5 + 16) = v14;
      goto LABEL_25;
    }

    __int16 v18 = v14 >> 6;
    if (v18 == 2)
    {
      if (v13 >= 4)
      {
        char v14 = bswap32(*(_DWORD *)((char *)v10 + v12) & 0xFFFFFF7F);
        v15 = 4;
        goto LABEL_11;
      }
    }

    else if (v18 == 1)
    {
      if (v13 >= 2)
      {
        char v14 = bswap32(*(_WORD *)((_BYTE *)v10 + v12) & 0xFFBF) >> 16;
        v15 = 2;
        goto LABEL_11;
      }
    }

    else if (v13 >= 8)
    {
      char v14 = bswap64(*(void *)((_BYTE *)v10 + v12) & 0xFFFFFFFFFFFFFF3FLL);
      v15 = 8;
      goto LABEL_11;
    }
  }

          v8 = *(void *)(v6 + 336);
          if (v8)
          {
            os_log_type_t v9 = *(void *)(v8 + 24);
            if (v9)
            {
              v10 = *(void (**)(void, uint64_t, uint64_t, unsigned __int8 *, uint64_t))(v9 + 160);
              if (v10)
              {
                v10(*(void *)(v6 + 336), a2, a3, a4, a5);
                return;
              }
            }

            __nwlog_obj();
            v31 = *(const char **)(v8 + 16);
            if (!v31) {
              v31 = "invalid";
            }
          }

          else
          {
            __nwlog_obj();
            v31 = "invalid";
          }

          *(_DWORD *)buf = 136446466;
          v64 = "nw_protocol_http3_stream_notify";
          v65 = 2082;
          v66 = (void *)v31;
          BOOL v17 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v61 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v43 = (os_log_s *)__nwlog_obj();
            v44 = type;
            if (!os_log_type_enabled(v43, type)) {
              goto LABEL_125;
            }
            v45 = "invalid";
            if (v8)
            {
              if (*(void *)(v8 + 16)) {
                v45 = *(const char **)(v8 + 16);
              }
            }

            *(_DWORD *)buf = 136446466;
            v64 = "nw_protocol_http3_stream_notify";
            v65 = 2082;
            v66 = (void *)v45;
            BOOL v20 = "%{public}s protocol %{public}s has invalid notify callback";
LABEL_123:
            v53 = v43;
            v54 = v44;
            v55 = 22;
            goto LABEL_124;
          }

          if (!v61)
          {
            v43 = (os_log_s *)__nwlog_obj();
            v44 = type;
            if (!os_log_type_enabled(v43, type)) {
              goto LABEL_125;
            }
            v52 = "invalid";
            if (v8 && *(void *)(v8 + 16)) {
              v52 = *(const char **)(v8 + 16);
            }
            *(_DWORD *)buf = 136446466;
            v64 = "nw_protocol_http3_stream_notify";
            v65 = 2082;
            v66 = (void *)v52;
            BOOL v20 = "%{public}s protocol %{public}s has invalid notify callback, backtrace limit exceeded";
            goto LABEL_123;
          }

          v46 = (char *)__nw_create_backtrace_string();
          v43 = (os_log_s *)__nwlog_obj();
          v44 = type;
          v47 = os_log_type_enabled(v43, type);
          if (!v46)
          {
            if (!v47) {
              goto LABEL_125;
            }
            v60 = "invalid";
            if (v8 && *(void *)(v8 + 16)) {
              v60 = *(const char **)(v8 + 16);
            }
            *(_DWORD *)buf = 136446466;
            v64 = "nw_protocol_http3_stream_notify";
            v65 = 2082;
            v66 = (void *)v60;
            BOOL v20 = "%{public}s protocol %{public}s has invalid notify callback, no backtrace";
            goto LABEL_123;
          }

          if (v47)
          {
            v48 = "invalid";
            if (v8 && *(void *)(v8 + 16)) {
              v48 = *(const char **)(v8 + 16);
            }
            *(_DWORD *)buf = 136446722;
            v64 = "nw_protocol_http3_stream_notify";
            v65 = 2082;
            v66 = (void *)v48;
            v67 = 2082;
            v68 = v46;
            _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s protocol %{public}s has invalid notify callback, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v46);
          if (!v17) {
            return;
          }
          goto LABEL_126;
        case 22:
          if ((*(_WORD *)(v6 + 736) & 0x800) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v11 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              BOOL v12 = *(_DWORD *)(*(void *)(v6 + 336) + 1280LL);
              os_log_type_t v13 = *(void *)(v6 + 240);
              *(_DWORD *)buf = 136447234;
              v64 = "nw_protocol_http3_stream_notify";
              v65 = 2082;
              v66 = (void *)(v6 + 636);
              v67 = 2080;
              v68 = " ";
              v69 = 1024;
              v70 = v12;
              v71 = 2048;
              v72 = v13;
              _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u:s%llu> restart received, assuming connection closed",  buf,  0x30u);
            }
          }

          *(_WORD *)(*(void *)(v6 + 336) + 1373LL) |= 8u;
          goto LABEL_16;
        default:
LABEL_16:
          char v14 = *(void *)(a1 + 48);
          if (v14)
          {
            v15 = *(void *)(v14 + 24);
            if (v15)
            {
              os_log_type_t v16 = *(void (**)(void))(v15 + 160);
              if (v16)
              {
                v16();
                return;
              }
            }
          }

          __nwlog_obj();
          v21 = *(void *)(a1 + 48);
          os_log_type_t v22 = "invalid";
          if (v21)
          {
            v23 = *(const char **)(v21 + 16);
            if (v23) {
              os_log_type_t v22 = v23;
            }
          }

          *(_DWORD *)buf = 136446466;
          v64 = "nw_protocol_http3_stream_notify";
          v65 = 2082;
          v66 = (void *)v22;
          os_log_type_t v24 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v61 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v25 = (os_log_s *)__nwlog_obj();
            v26 = type;
            if (!os_log_type_enabled(v25, type)) {
              goto LABEL_116;
            }
            v27 = *(void *)(a1 + 48);
            BOOL v28 = "invalid";
            if (v27)
            {
              char v29 = *(const char **)(v27 + 16);
              if (v29) {
                BOOL v28 = v29;
              }
            }

            *(_DWORD *)buf = 136446466;
            v64 = "nw_protocol_http3_stream_notify";
            v65 = 2082;
            v66 = (void *)v28;
            v30 = "%{public}s protocol %{public}s has invalid notify callback";
LABEL_115:
            _os_log_impl(&dword_181A5C000, v25, v26, v30, buf, 0x16u);
            goto LABEL_116;
          }

          if (!v61)
          {
            v25 = (os_log_s *)__nwlog_obj();
            v26 = type;
            if (!os_log_type_enabled(v25, type)) {
              goto LABEL_116;
            }
            v49 = *(void *)(a1 + 48);
            v50 = "invalid";
            if (v49)
            {
              v51 = *(const char **)(v49 + 16);
              if (v51) {
                v50 = v51;
              }
            }

            *(_DWORD *)buf = 136446466;
            v64 = "nw_protocol_http3_stream_notify";
            v65 = 2082;
            v66 = (void *)v50;
            v30 = "%{public}s protocol %{public}s has invalid notify callback, backtrace limit exceeded";
            goto LABEL_115;
          }

          v38 = (char *)__nw_create_backtrace_string();
          v25 = (os_log_s *)__nwlog_obj();
          v26 = type;
          v39 = os_log_type_enabled(v25, type);
          if (!v38)
          {
            if (!v39) {
              goto LABEL_116;
            }
            v56 = *(void *)(a1 + 48);
            v57 = "invalid";
            if (v56)
            {
              v58 = *(const char **)(v56 + 16);
              if (v58) {
                v57 = v58;
              }
            }

            *(_DWORD *)buf = 136446466;
            v64 = "nw_protocol_http3_stream_notify";
            v65 = 2082;
            v66 = (void *)v57;
            v30 = "%{public}s protocol %{public}s has invalid notify callback, no backtrace";
            goto LABEL_115;
          }

          if (v39)
          {
            v40 = *(void *)(a1 + 48);
            v41 = "invalid";
            if (v40)
            {
              v42 = *(const char **)(v40 + 16);
              if (v42) {
                v41 = v42;
              }
            }

            *(_DWORD *)buf = 136446722;
            v64 = "nw_protocol_http3_stream_notify";
            v65 = 2082;
            v66 = (void *)v41;
            v67 = 2082;
            v68 = v38;
            _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s protocol %{public}s has invalid notify callback, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v38);
LABEL_116:
          if (!v24) {
            return;
          }
          v59 = (char *)v24;
          break;
      }

      goto LABEL_127;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v64 = "nw_protocol_http3_stream_notify";
    BOOL v17 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (__nwlog_fault(v17, &type, &v61))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v18 = (os_log_s *)__nwlog_obj();
        os_log_type_t v19 = type;
        if (!os_log_type_enabled(v18, type)) {
          goto LABEL_125;
        }
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http3_stream_notify";
        BOOL v20 = "%{public}s called with null other_protocol";
        goto LABEL_109;
      }

      if (!v61)
      {
        __int16 v18 = (os_log_s *)__nwlog_obj();
        os_log_type_t v19 = type;
        if (!os_log_type_enabled(v18, type)) {
          goto LABEL_125;
        }
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http3_stream_notify";
        BOOL v20 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_109;
      }

      v34 = (char *)__nw_create_backtrace_string();
      __int16 v18 = (os_log_s *)__nwlog_obj();
      os_log_type_t v19 = type;
      v37 = os_log_type_enabled(v18, type);
      if (!v34)
      {
        if (!v37) {
          goto LABEL_125;
        }
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http3_stream_notify";
        BOOL v20 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_109;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        v64 = "nw_protocol_http3_stream_notify";
        v65 = 2082;
        v66 = v34;
        v36 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
        goto LABEL_59;
      }

      goto LABEL_60;
    }
}

        goto LABEL_9;
      }

      __nwlog_obj();
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      char v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
      os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v26 = 0;
      if (!__nwlog_fault((const char *)v16, &type, &v26))
      {
LABEL_56:
        if (v16) {
          free(v16);
        }
        singleton = 0LL;
        goto LABEL_8;
      }

      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          char v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v19 = "%{public}s called with null messaging_options";
LABEL_54:
          _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
        }
      }

      else
      {
        if (v26)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v18 = type;
          v25 = os_log_type_enabled(v17, type);
          if (backtrace_string)
          {
            if (v25)
            {
              *(_DWORD *)buf = 136446466;
              char v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
              v30 = 2082;
              v31 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null messaging_options, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_56;
          }

          if (!v25) {
            goto LABEL_55;
          }
          *(_DWORD *)buf = 136446210;
          char v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v19 = "%{public}s called with null messaging_options, no backtrace";
          goto LABEL_54;
        }

        __nwlog_obj();
        BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          char v29 = "nw_http_messaging_options_find_or_create_client_metadata_in_parameters";
          os_log_type_t v19 = "%{public}s called with null messaging_options, backtrace limit exceeded";
          goto LABEL_54;
        }
      }

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
  return result;
}

  __break(1u);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
  return result;
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  return a1;
}

LABEL_9:
      BOOL v20 = 1LL;
      os_log_type_t v9 = v293;
      goto LABEL_193;
    }

LABEL_114:
      v63 = 1LL;
      v8 = v147;
      goto LABEL_115;
    }

        *(_BYTE *)v7 = v9 & 0xF | 0x60;
        *((_BYTE *)v7 + 6) = *(_BYTE *)(*(void *)(a1 + 32) + 156LL);
        *((_BYTE *)v7 + 7) = *(_BYTE *)(*(void *)(a1 + 32) + 157LL);
        *(_OWORD *)(v7 + 2) = *(_OWORD *)(*(void *)(a1 + 32) + 56LL);
        *(_OWORD *)(v7 + 6) = *(_OWORD *)(*(void *)(a1 + 32) + 72LL);
        *((_WORD *)v7 + 2) = bswap32((unsigned __int16)v30 - 40) >> 16;
        ++**(void **)(a1 + 32);
        return 1LL;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v34 = "__nw_frame_get_ecn_flag";
      __int16 v18 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v31 = 0;
      if (__nwlog_fault(v18, &type, &v31))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v19 = (os_log_s *)__nwlog_obj();
          BOOL v20 = type;
          if (!os_log_type_enabled(v19, type)) {
            goto LABEL_37;
          }
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_get_ecn_flag";
          v21 = "%{public}s called with null frame";
LABEL_36:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
          goto LABEL_37;
        }

        if (!v31)
        {
          os_log_type_t v19 = (os_log_s *)__nwlog_obj();
          BOOL v20 = type;
          if (!os_log_type_enabled(v19, type)) {
            goto LABEL_37;
          }
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_get_ecn_flag";
          v21 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_36;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v19 = (os_log_s *)__nwlog_obj();
        BOOL v20 = type;
        v23 = os_log_type_enabled(v19, type);
        if (!backtrace_string)
        {
          if (!v23) {
            goto LABEL_37;
          }
          *(_DWORD *)buf = 136446210;
          v34 = "__nw_frame_get_ecn_flag";
          v21 = "%{public}s called with null frame, no backtrace";
          goto LABEL_36;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "__nw_frame_get_ecn_flag";
          uint64_t v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
      }

uint64_t nw_utilities_port_for_string(const char *a1, _WORD *a2)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      if (!strcasecmp(a1, "http"))
      {
        uint64_t v9 = 0LL;
      }

      else if (!strcasecmp(a1, "https"))
      {
        uint64_t v9 = 1LL;
      }

      else if (!strcasecmp(a1, "ws"))
      {
        uint64_t v9 = 2LL;
      }

      else
      {
        if (strcasecmp(a1, "wss"))
        {
          memset(&v38.ai_socktype, 0, 40);
          *(void *)&v38.ai_flags = 0x1E00000600LL;
          v38.ai_sockos_log_type_t type = 1;
          v31 = 0LL;
          int v4 = getaddrinfo(0LL, a1, &v38, &v31);
          if (v4)
          {
            uint64_t v5 = gai_strerror(v4);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v6 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
            {
              v7 = "Unknown error";
              *(_DWORD *)buf = 136446722;
              __int16 v33 = "nw_utilities_port_for_string";
              __int16 v34 = 2082;
              if (v5) {
                v7 = v5;
              }
              uint64_t v35 = a1;
              __int16 v36 = 2082;
              v37 = (void *)v7;
              _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to convert %{public}s to port: %{public}s",  buf,  0x20u);
            }

            return 0LL;
          }

          v10 = v31;
          if (v31)
          {
            ai_addr = v31->ai_addr;
            if (ai_addr)
            {
              if (ai_addr->sa_family == 30)
              {
                *a2 = *(_WORD *)ai_addr->sa_data;
                freeaddrinfo(v10);
                return 1LL;
              }
            }
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v12 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          __int16 v33 = "nw_utilities_port_for_string";
          __int16 v34 = 2082;
          uint64_t v35 = a1;
          os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v29 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v14 = (os_log_s *)(id)gLogObj;
            os_log_type_t v15 = type;
            if (os_log_type_enabled(v14, type))
            {
              *(_DWORD *)buf = 136446466;
              __int16 v33 = "nw_utilities_port_for_string";
              __int16 v34 = 2082;
              uint64_t v35 = a1;
              os_log_type_t v16 = "%{public}s getaddrinfo(NULL, %{public}s, ...) failed";
LABEL_37:
              _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0x16u);
            }
          }

          else if (v29)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v15 = type;
            BOOL v18 = os_log_type_enabled(v14, type);
            if (backtrace_string)
            {
              if (v18)
              {
                *(_DWORD *)buf = 136446722;
                __int16 v33 = "nw_utilities_port_for_string";
                __int16 v34 = 2082;
                uint64_t v35 = a1;
                __int16 v36 = 2082;
                v37 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s getaddrinfo(NULL, %{public}s, ...) failed, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(backtrace_string);
              goto LABEL_39;
            }

            if (v18)
            {
              *(_DWORD *)buf = 136446466;
              __int16 v33 = "nw_utilities_port_for_string";
              __int16 v34 = 2082;
              uint64_t v35 = a1;
              os_log_type_t v16 = "%{public}s getaddrinfo(NULL, %{public}s, ...) failed, no backtrace";
              goto LABEL_37;
            }
          }

          else
          {
            __nwlog_obj();
            char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v15 = type;
            if (os_log_type_enabled(v14, type))
            {
              *(_DWORD *)buf = 136446466;
              __int16 v33 = "nw_utilities_port_for_string";
              __int16 v34 = 2082;
              uint64_t v35 = a1;
              os_log_type_t v16 = "%{public}s getaddrinfo(NULL, %{public}s, ...) failed, backtrace limit exceeded";
              goto LABEL_37;
            }
          }

LABEL_39:
          if (v13) {
            free(v13);
          }
          uint64_t result = (uint64_t)v31;
          if (v31)
          {
            freeaddrinfo(v31);
            return 0LL;
          }

          return result;
        }

        uint64_t v9 = 3LL;
      }

      *a2 = (&kWellKnownSchemes)[2 * v9 + 1];
      return 1LL;
    }

    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    v38.ai_flags = 136446210;
    *(void *)&v38.ai_family = "nw_utilities_port_for_string";
    BOOL v20 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v31) = 0;
    if (__nwlog_fault(v20, buf, &v31))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v38.ai_flags = 136446210;
          *(void *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null out_port";
          goto LABEL_69;
        }

        goto LABEL_70;
      }

      if (!(_BYTE)v31)
      {
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v38.ai_flags = 136446210;
          *(void *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null out_port, backtrace limit exceeded";
          goto LABEL_69;
        }

        goto LABEL_70;
      }

      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = buf[0];
      BOOL v28 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
      if (!v25)
      {
        if (v28)
        {
          v38.ai_flags = 136446210;
          *(void *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null out_port, no backtrace";
          goto LABEL_69;
        }

        goto LABEL_70;
      }

      if (!v28) {
        goto LABEL_60;
      }
      v38.ai_flags = 136446466;
      *(void *)&v38.ai_family = "nw_utilities_port_for_string";
      LOWORD(v38.ai_protocol) = 2082;
      *(void *)((char *)&v38.ai_protocol + 2) = v25;
      v27 = "%{public}s called with null out_port, dumping backtrace:%{public}s";
LABEL_59:
      _os_log_impl(&dword_181A5C000, v21, v22, v27, (uint8_t *)&v38, 0x16u);
LABEL_60:

      free(v25);
    }
  }

  else
  {
    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    v38.ai_flags = 136446210;
    *(void *)&v38.ai_family = "nw_utilities_port_for_string";
    BOOL v20 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v31) = 0;
    if (__nwlog_fault(v20, buf, &v31))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v38.ai_flags = 136446210;
          *(void *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null string";
LABEL_69:
          _os_log_impl(&dword_181A5C000, v21, v22, v23, (uint8_t *)&v38, 0xCu);
        }

LABEL_70:
        goto LABEL_71;
      }

      if (!(_BYTE)v31)
      {
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v38.ai_flags = 136446210;
          *(void *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null string, backtrace limit exceeded";
          goto LABEL_69;
        }

        goto LABEL_70;
      }

      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = buf[0];
      BOOL v26 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
      if (!v25)
      {
        if (v26)
        {
          v38.ai_flags = 136446210;
          *(void *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null string, no backtrace";
          goto LABEL_69;
        }

        goto LABEL_70;
      }

      if (!v26) {
        goto LABEL_60;
      }
      v38.ai_flags = 136446466;
      *(void *)&v38.ai_family = "nw_utilities_port_for_string";
      LOWORD(v38.ai_protocol) = 2082;
      *(void *)((char *)&v38.ai_protocol + 2) = v25;
      v27 = "%{public}s called with null string, dumping backtrace:%{public}s";
      goto LABEL_59;
    }
  }

      if (v18) {
        free(v18);
      }
      goto LABEL_72;
    }
  }

        free(v43);
        goto LABEL_71;
      }

      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_181A5C000, v44, v49, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v54 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl( &dword_181A5C000,  v44,  v54,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      BOOL v18 = (NWConcrete_nw_endpoint_mode_handler *)v120;
      v85 = (char *)v134;
      if (v134) {
LABEL_71:
      }
        free(v85);
LABEL_72:

      *(void *)(a2 + 272) = 0LL;
      *(void *)(a2 + 280) = a2 + 272;
      *(void *)(a2 + 296) = 0LL;
      *(void *)(a2 + 304) = a2 + 296;
LABEL_73:

      goto LABEL_137;
    }

    v93 = (char *)v17;
    __nwlog_obj();
    v94 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v139 = "nw_flow_protocol_initialize";
    v95 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v136 = 0;
    if (__nwlog_fault(v95, &type, &v136))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v96 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v97 = type;
        if (os_log_type_enabled(v96, type))
        {
          *(_DWORD *)buf = 136446210;
          v139 = "nw_flow_protocol_initialize";
          _os_log_impl( &dword_181A5C000,  v96,  v97,  "%{public}s called with null endpoint_flow->initialized_protocol_callbacks",  buf,  0xCu);
        }
      }

      else if (v136)
      {
        v99 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v96 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v100 = type;
        v101 = os_log_type_enabled(v96, type);
        if (v99)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136446466;
            v139 = "nw_flow_protocol_initialize";
            v140 = 2082;
            v141 = v99;
            _os_log_impl( &dword_181A5C000,  v96,  v100,  "%{public}s called with null endpoint_flow->initialized_protocol_callbacks, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v99);
          goto LABEL_144;
        }

        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          v139 = "nw_flow_protocol_initialize";
          _os_log_impl( &dword_181A5C000,  v96,  v100,  "%{public}s called with null endpoint_flow->initialized_protocol_callbacks, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v96 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v115 = type;
        if (os_log_type_enabled(v96, type))
        {
          *(_DWORD *)buf = 136446210;
          v139 = "nw_flow_protocol_initialize";
          _os_log_impl( &dword_181A5C000,  v96,  v115,  "%{public}s called with null endpoint_flow->initialized_protocol_callbacks, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

            v346 = v46;
            v58 = 0;
            v59 = (void *)*((void *)v44 + 117);
            if (v41 && v59 == v14)
            {
              v60 = *v41;
              if (v60 == 1)
              {
                v61 = v41[1];
                if (v61 > 6)
                {
                  v58 = 0;
                  if (a2 != 2) {
                    goto LABEL_97;
                  }
                }

                else
                {
                  v58 = (0x68u >> v61) & 1;
                  if (a2 != 2) {
                    goto LABEL_97;
                  }
                }

                goto LABEL_81;
              }

              if (v60 == 3)
              {
                v58 = v41[1] == 8;
                if (a2 != 2) {
                  goto LABEL_97;
                }
LABEL_81:
                if (v41 && !v59 && *v41 == 3 && v41[1] == 9)
                {
                  v62 = *((void *)v44 + 118);
                  if (!v62)
                  {
                    v63 = nw_array_create();
                    v64 = (void *)*((void *)v44 + 118);
                    *((void *)v44 + 118) = v63;

                    v41 = a4;
                    v62 = *((void *)v44 + 118);
                    v10 = v365;
                  }

                  if (v62 && v10)
                  {
                    v66 = *(id **)(v62 + 16);
                    v65 = *(id **)(v62 + 24);
                    if (v66 != v65)
                    {
                      while (*v66 != v10)
                      {
                        if (++v66 == v65)
                        {
                          v66 = *(id **)(v62 + 24);
                          break;
                        }
                      }
                    }

                    if (v66 != v65)
                    {
                      v353 = 0LL;
                      char v14 = v359;
                      goto LABEL_120;
                    }
                  }

                  nw_array_append(v62, v10);
                  char v14 = v359;
                  goto LABEL_117;
                }

    if (!v25) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }

  v8 = v6;
  uint64_t v9 = v8[30];

  if (v9 == 1)
  {
    v10 = v8;
    id v11 = *((_BYTE *)v10 + 268);
    v93 = v10;

    if ((v11 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v12 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v13 = v93;

        char v14 = v13;
        os_log_type_t v15 = *((_BYTE *)v93 + 268);

        if ((v15 & 1) != 0) {
          os_log_type_t v16 = "dry-run ";
        }
        else {
          os_log_type_t v16 = "";
        }
        BOOL v17 = nw_endpoint_handler_copy_endpoint(v14);
        logging_description = nw_endpoint_get_logging_description(v17);
        v88 = v17;
        v91 = v13 + 168;
        os_log_type_t v19 = v14;
        BOOL v20 = v19;
        v21 = v8[30];
        else {
          os_log_type_t v22 = off_189BBBBF0[v21];
        }

        uint64_t v35 = v20;
        __int16 v36 = v35;
        v37 = v6[29];
        addrinfo v38 = "path";
        switch(v37)
        {
          case 0u:
            break;
          case 1u:
            addrinfo v38 = "resolver";
            break;
          case 2u:
            addrinfo v38 = nw_endpoint_flow_mode_string(v35[31]);
            break;
          case 3u:
            addrinfo v38 = "proxy";
            break;
          case 4u:
            addrinfo v38 = "fallback";
            break;
          case 5u:
            addrinfo v38 = "transform";
            break;
          default:
            addrinfo v38 = "unknown-mode";
            break;
        }

        v40 = v36;
        os_unfair_lock_lock((os_unfair_lock_t)v40 + 28);
        v41 = v40[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v40 + 28);

        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_resolver startWithHandler:]";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v91;
        v102 = 2082;
        v103 = v16;
        v104 = 2082;
        v105 = (void *)logging_description;
        v106 = 2082;
        v107 = v22;
        v108 = 2082;
        v109 = v38;
        v110 = 2114;
        v111 = v41;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);
      }
    }

    v42 = v93;
    os_unfair_lock_lock((os_unfair_lock_t)v42 + 28);
    v92 = *((id *)v42 + 8);
    os_unfair_lock_unlock((os_unfair_lock_t)v42 + 28);

    v43 = v42;
    v44 = (v93[67] & 1) == 0;

    if (v44) {
      nw_path_assert_required_agents(v92);
    }
    v45 = v43;
    v46 = v45[4];

    v47 = v45;
    v48 = (NWConcrete_nw_path *)v92;
    v49 = v46;
    if (v48)
    {
      v50 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_resolver);
      v51 = v48;
      v52 = v51[3];

      v53 = -[NWConcrete_nw_resolver initWithEndpoint:parameters:path:log_str:](v50, v52, v49, v51, (uint64_t)(v47 + 21));
      goto LABEL_56;
    }

    __nwlog_obj();
    v72 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_create_with_path_parameters_and_log_string";
    v73 = (const char *)_os_log_send_and_compose_impl();

    v74 = (char *)v73;
    type[0] = OS_LOG_TYPE_ERROR;
    v100 = 0;
    if (__nwlog_fault(v73, type, &v100))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v76 = type[0];
        if (os_log_type_enabled(v75, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_with_path_parameters_and_log_string";
          _os_log_impl(&dword_181A5C000, v75, v76, "%{public}s called with null path", buf, 0xCu);
        }
      }

      else if (v100)
      {
        v82 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v89 = type[0];
        v83 = os_log_type_enabled(v75, type[0]);
        if (v82)
        {
          if (v83)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_resolver_create_with_path_parameters_and_log_string";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v82;
            _os_log_impl( &dword_181A5C000,  v75,  v89,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v82);
          goto LABEL_118;
        }

        if (v83)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_with_path_parameters_and_log_string";
          _os_log_impl(&dword_181A5C000, v75, v89, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v86 = type[0];
        if (os_log_type_enabled(v75, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_with_path_parameters_and_log_string";
          _os_log_impl( &dword_181A5C000,  v75,  v86,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      if (v27) {
        free(v27);
      }
      id v11 = 0LL;
      goto LABEL_17;
    }

    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v48 = 136446210;
    *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
    v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    v43 = 0;
    if (__nwlog_fault(v21, buf, &v43))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v25 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_181A5C000, v22, v25, "%{public}s called with null protocol_identifier", v48, 0xCu);
        }

    if (v24) {
      free(v24);
    }
    v10 = 0LL;
    goto LABEL_29;
  }

  __nwlog_obj();
  os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
  BOOL v20 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (__nwlog_fault(v20, type, &v40))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v40)
    {
      v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v28 = type[0];
      char v29 = os_log_type_enabled(v21, type[0]);
      if (v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v27;
          _os_log_impl( &dword_181A5C000,  v21,  v28,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v27);
        goto LABEL_58;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl(&dword_181A5C000, v21, v28, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v33 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl( &dword_181A5C000,  v21,  v33,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (!v19) {
      return;
    }
    goto LABEL_71;
  }
    }
  }

  else
  {
    __nwlog_obj();
    v74 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
    BOOL v17 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (__nwlog_fault(v17, type, &v107))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v75 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl(&dword_181A5C000, v18, v75, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v107)
      {
        v76 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v77 = type[0];
        v78 = os_log_type_enabled(v18, type[0]);
        if (v76)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v76;
            _os_log_impl( &dword_181A5C000,  v18,  v77,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v76);
          if (!v17) {
            goto LABEL_73;
          }
          goto LABEL_72;
        }

        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl(&dword_181A5C000, v18, v77, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v79 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl( &dword_181A5C000,  v18,  v79,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }

      goto LABEL_70;
    }
  }

  if (v17) {
LABEL_72:
  }
    free(v17);
LABEL_73:
  char v14 = 0LL;
LABEL_97:

  return v14;
}

    if (v59) {
      free(v59);
    }
    goto LABEL_53;
  }

  uint64_t v5 = v3;
  mode = v5->mode;

  if ((_DWORD)mode == 2)
  {
    if ((*((_WORD *)handle + 166) & 0x100) != 0)
    {
      v25 = v5;
      BOOL v26 = *((_BYTE *)v25 + 268);

      if ((v26 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v12 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          v27 = v25;

          BOOL v28 = v27;
          char v29 = *((_BYTE *)v25 + 268);

          if ((v29 & 1) != 0) {
            v30 = "dry-run ";
          }
          else {
            v30 = "";
          }
          v31 = nw_endpoint_handler_copy_endpoint(v28);
          logging_description = nw_endpoint_get_logging_description(v31);
          v77 = v30;
          id_str = v27->id_str;
          __int16 v33 = v28;
          __int16 v34 = v33;
          uint64_t v35 = v33[30];
          else {
            __int16 v36 = off_189BBBBF0[v35];
          }
          loga = v12;

          v37 = v34;
          addrinfo v38 = v37;
          uint64_t v39 = logging_description;
          v40 = "path";
          switch(v5->mode)
          {
            case 0:
              break;
            case 1:
              v40 = "resolver";
              break;
            case 2:
              v40 = nw_endpoint_flow_mode_string(v37[31]);
              break;
            case 3:
              v40 = "proxy";
              break;
            case 4:
              v40 = "fallback";
              break;
            case 5:
              v40 = "transform";
              break;
            default:
              v40 = "unknown-mode";
              break;
          }

          v45 = v38;
          os_unfair_lock_lock((os_unfair_lock_t)v45 + 28);
          v46 = v45[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v45 + 28);

          *(_DWORD *)buf = 136447746;
          v90 = "nw_flow_disconnected";
          v91 = 2082;
          v92 = id_str;
          v93 = 2082;
          v94 = v77;
          v95 = 2082;
          v96 = v39;
          v97 = 2082;
          v98 = v36;
          v99 = 2082;
          v100 = v40;
          v101 = 2114;
          v102 = v46;
          id v12 = loga;
          _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnecte d for unregistered flow",  buf,  0x48u);
        }

        goto LABEL_49;
      }
    }

    else
    {
      parameters = handle->parameters;
      if (!parameters) {
        goto LABEL_50;
      }
      v8 = parameters;
      uint64_t v9 = *((void *)v8 + 12);

      if ((v9 & 0x4000000000LL) != 0) {
        goto LABEL_50;
      }
      if (nw_endpoint_handler_get_minimize_logging(v5))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v12 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v5);
          v66 = nw_endpoint_handler_dry_run_string(v5);
          v67 = nw_endpoint_handler_copy_endpoint(v5);
          v68 = nw_endpoint_get_logging_description(v67);
          v69 = nw_endpoint_handler_state_string(v5);
          v70 = nw_endpoint_handler_mode_string(v5);
          v71 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136447746;
          v90 = "nw_flow_disconnected";
          v91 = 2082;
          v92 = (void *)id_string;
          v93 = 2082;
          v94 = v66;
          v95 = 2082;
          v96 = v68;
          v97 = 2082;
          v98 = v69;
          v99 = 2082;
          v100 = v70;
          v101 = 2114;
          v102 = v71;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnected",  buf,  0x48u);
        }

        goto LABEL_49;
      }

      v10 = v5;
      id v11 = *((_BYTE *)v10 + 268);

      if ((v11 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v12 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          os_log_type_t v13 = v10;

          char v14 = v13;
          os_log_type_t v15 = *((_BYTE *)v10 + 268);

          if ((v15 & 1) != 0) {
            os_log_type_t v16 = "dry-run ";
          }
          else {
            os_log_type_t v16 = "";
          }
          BOOL v17 = nw_endpoint_handler_copy_endpoint(v14);
          BOOL v18 = nw_endpoint_get_logging_description(v17);
          log = (os_log_t)v13->id_str;
          v76 = v16;
          os_log_type_t v19 = v14;
          BOOL v20 = v19;
          v21 = v19[30];
          else {
            os_log_type_t v22 = off_189BBBBF0[v21];
          }
          v73 = v22;

          v41 = v20;
          v42 = v41;
          v43 = v18;
          v44 = "path";
          switch(v5->mode)
          {
            case 0:
              break;
            case 1:
              v44 = "resolver";
              break;
            case 2:
              v44 = nw_endpoint_flow_mode_string(v41[31]);
              break;
            case 3:
              v44 = "proxy";
              break;
            case 4:
              v44 = "fallback";
              break;
            case 5:
              v44 = "transform";
              break;
            default:
              v44 = "unknown-mode";
              break;
          }

          v47 = v42;
          os_unfair_lock_lock((os_unfair_lock_t)v47 + 28);
          v48 = v47[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v47 + 28);

          *(_DWORD *)buf = 136447746;
          v90 = "nw_flow_disconnected";
          v91 = 2082;
          v92 = log;
          v93 = 2082;
          v94 = v76;
          v95 = 2082;
          v96 = v43;
          v97 = 2082;
          v98 = v73;
          v99 = 2082;
          v100 = v44;
          v101 = 2114;
          v102 = v48;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol disconnected",  buf,  0x48u);
        }

            free(v13);
            goto LABEL_71;
          }

          if (v9 == (void *)MEMORY[0x1895F9198])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v37 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            addrinfo v38 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v102 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v39 = (os_log_s *)(id)gLogObj;
              v40 = type;
              if (os_log_type_enabled(v39, type))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED",  buf,  0xCu);
              }
            }

            else if (v102)
            {
              v56 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v57 = type;
              v58 = os_log_type_enabled(v39, type);
              if (v56)
              {
                if (v58)
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(void *)v107 = v56;
                  _os_log_impl( &dword_181A5C000,  v39,  v57,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v56);
                if (!v38) {
                  goto LABEL_178;
                }
                goto LABEL_177;
              }

              if (v58)
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl( &dword_181A5C000,  v39,  v57,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v73 = type;
              if (os_log_type_enabled(v39, type))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl( &dword_181A5C000,  v39,  v73,  "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

          else
          {
            if (v9 == (void *)MEMORY[0x1895F91A0])
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v55 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_ERROR,  "%{public}s received XPC_ERROR_CONNECTION_INVALID",  buf,  0xCu);
              }

              goto LABEL_178;
            }

            if (v9 != (void *)MEMORY[0x1895F91C8])
            {
              id v11 = (void *)MEMORY[0x186E12534](v9);
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v29 = (id)gLogObj;
              *(_DWORD *)buf = 136446466;
              v105 = "networkd_privileged_set_settings";
              v106 = 2082;
              *(void *)v107 = v11;
              os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t type = OS_LOG_TYPE_ERROR;
              v102 = 0;
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v30 = type;
                if (os_log_type_enabled(v14, type))
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(void *)v107 = v11;
                  _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s received returned unknown XPC error %{public}s",  buf,  0x16u);
                }

                goto LABEL_68;
              }

              if (!v102)
              {
                __nwlog_obj();
                char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v80 = type;
                if (os_log_type_enabled(v14, type))
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(void *)v107 = v11;
                  _os_log_impl( &dword_181A5C000,  v14,  v80,  "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded",  buf,  0x16u);
                }

                goto LABEL_68;
              }

              v61 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v62 = type;
              v63 = os_log_type_enabled(v14, type);
              if (!v61)
              {
                if (v63)
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(void *)v107 = v11;
                  _os_log_impl( &dword_181A5C000,  v14,  v62,  "%{public}s received returned unknown XPC error %{public}s, no backtrace",  buf,  0x16u);
                }

                goto LABEL_68;
              }

              if (v63)
              {
                *(_DWORD *)buf = 136446722;
                v105 = "networkd_privileged_set_settings";
                v106 = 2082;
                *(void *)v107 = v11;
                *(_WORD *)&v107[8] = 2082;
                *(void *)&v107[10] = v61;
                _os_log_impl( &dword_181A5C000,  v14,  v62,  "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(v61);
              if (!v13) {
                goto LABEL_71;
              }
              goto LABEL_70;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v59 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            addrinfo v38 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v102 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v60 = type;
              if (os_log_type_enabled(v39, type))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl( &dword_181A5C000,  v39,  v60,  "%{public}s received XPC_ERROR_TERMINATION_IMMINENT",  buf,  0xCu);
              }
            }

            else if (v102)
            {
              v70 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v71 = type;
              v72 = os_log_type_enabled(v39, type);
              if (v70)
              {
                if (v72)
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(void *)v107 = v70;
                  _os_log_impl( &dword_181A5C000,  v39,  v71,  "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v70);
LABEL_176:
                if (!v38) {
                  goto LABEL_178;
                }
LABEL_177:
                free(v38);
                goto LABEL_178;
              }

              if (v72)
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl( &dword_181A5C000,  v39,  v71,  "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v81 = type;
              if (os_log_type_enabled(v39, type))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl( &dword_181A5C000,  v39,  v81,  "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

          goto LABEL_176;
        }

        xpc_dictionary_get_value(v9, (const char *)networkd_privileged_key_result);
        BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
        v21 = v20;
        if (!v20)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v34 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v105 = "networkd_privileged_set_settings";
          v23 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v102 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v24 = (os_log_s *)(id)gLogObj;
            uint64_t v35 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl(&dword_181A5C000, v24, v35, "%{public}s received response without result code", buf, 0xCu);
            }

            goto LABEL_138;
          }

          if (!v102)
          {
            __nwlog_obj();
            os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v69 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl( &dword_181A5C000,  v24,  v69,  "%{public}s received response without result code, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_138;
          }

          v49 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v53 = type;
          v54 = os_log_type_enabled(v24, type);
          if (!v49)
          {
            if (v54)
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl( &dword_181A5C000,  v24,  v53,  "%{public}s received response without result code, no backtrace",  buf,  0xCu);
            }

            goto LABEL_138;
          }

          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            v105 = "networkd_privileged_set_settings";
            v106 = 2082;
            *(void *)v107 = v49;
            _os_log_impl( &dword_181A5C000,  v24,  v53,  "%{public}s received response without result code, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          goto LABEL_88;
        }

        if (object_getClass(v20) != (Class)MEMORY[0x1895F9280])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v22 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v105 = "networkd_privileged_set_settings";
          v23 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v102 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v24 = (os_log_s *)(id)gLogObj;
            v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s received invalid result type", buf, 0xCu);
            }

    free(v44);
    goto LABEL_71;
  }

  __nwlog_obj(0LL, v32);
  v83 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v83, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v97 = "strict_calloc";
  v98 = 2048;
  v99 = 1LL;
  v100 = 2048;
  v101 = 48LL;
  v84 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v84))
  {
    free(v84);
    os_log_type_t v16 = 0LL;
    goto LABEL_36;
  }

  __break(1u);
}

        if (!gLogDatapath) {
          goto LABEL_71;
        }
        v99 = v25;
        v100 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
          _os_log_impl( &dword_181A5C000,  v100,  OS_LOG_TYPE_DEBUG,  "%{public}s new_input_array is not empty after processing input frames, moving to saved_input_frames for later",  buf,  0xCu);
        }

        v60 = v117;
        v25 = v99;
        if (v117)
        {
LABEL_71:
          **(void **)(a1 + 8) = v60;
          v61 = v118;
          *(void *)(v117 + 40) = *(void *)(a1 + 8);
          *(void *)(a1 + 8) = v61;
        }

        v117 = 0LL;
        v118 = &v117;
        goto LABEL_73;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v35 = *v116;
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = "count";
      *(_WORD *)&buf[22] = 2048;
      v125 = v33;
      *(_WORD *)v126 = 2048;
      *(void *)&v126[2] = v35;
      __int16 v36 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      a8 = v116;
      v119 = 0;
      if (__nwlog_fault(v36, type, &v119))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v37 = (os_log_s *)gLogObj;
          addrinfo v38 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            uint64_t v39 = *v116;
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v125 = v33;
            *(_WORD *)v126 = 2048;
            *(void *)&v126[2] = v39;
            v40 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_65:
            _os_log_impl(&dword_181A5C000, v37, v38, v40, buf, 0x2Au);
          }
        }

        else if (v119)
        {
          v55 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v37 = (os_log_s *)gLogObj;
          addrinfo v38 = type[0];
          v56 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v55)
          {
            if (v56)
            {
              v57 = *v116;
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "count";
              *(_WORD *)&buf[22] = 2048;
              v125 = v33;
              *(_WORD *)v126 = 2048;
              *(void *)&v126[2] = v57;
              *(_WORD *)&v126[10] = 2082;
              *(void *)&v126[12] = v55;
              _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v55);
            goto LABEL_66;
          }

          if (v56)
          {
            v59 = *v116;
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v125 = v33;
            *(_WORD *)v126 = 2048;
            *(void *)&v126[2] = v59;
            v40 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_65;
          }
        }

        else
        {
          v37 = (os_log_s *)__nwlog_obj();
          addrinfo v38 = type[0];
          if (os_log_type_enabled(v37, type[0]))
          {
            v58 = *v116;
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v125 = v33;
            *(_WORD *)v126 = 2048;
            *(void *)&v126[2] = v58;
            v40 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_65;
          }
        }
      }

    goto LABEL_71;
  }

  __nwlog_obj();
  id v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  addrinfo v38 = "nw_framer_protocol_disconnect";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v35 = 0;
  if (__nwlog_fault(v13, &type, &v35))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_framer_protocol_disconnect";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v35)
    {
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      v25 = os_log_type_enabled(v14, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          addrinfo v38 = "nw_framer_protocol_disconnect";
          uint64_t v39 = 2082;
          v40 = v23;
          _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
        goto LABEL_63;
      }

      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_framer_protocol_disconnect";
        _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_framer_protocol_disconnect";
        _os_log_impl( &dword_181A5C000,  v14,  v32,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    goto LABEL_71;
  }

  if (a2)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v65 = "nw_data_transfer_update_path_report_end";
        v66 = 2048;
        v67 = a1;
        v68 = 2048;
        v69 = a2;
        _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_DEBUG,  "%{public}s updating path report %p with ending snapshot %p",  buf,  0x20u);
      }
    }

    var1 = a2->var1;
    if (var1 >= a1->total.received_ip_packet_count) {
      uint64_t v5 = a1->total.received_ip_packet_count + var1 - a1->incremental.received_ip_packet_count;
    }
    else {
      uint64_t v5 = 0LL;
    }
    id v6 = 0LL;
    a1->total.received_ip_packet_count = v5;
    a1->incremental.received_ip_packet_count = 0LL;
    var2 = a2->var2;
    received_ip_ect1_packet_count = a1->total.received_ip_ect1_packet_count;
    if (var2 >= received_ip_ect1_packet_count) {
      id v6 = received_ip_ect1_packet_count + var2 - a1->incremental.received_ip_ect1_packet_count;
    }
    uint64_t v9 = 0LL;
    a1->total.received_ip_ect1_packet_count = v6;
    a1->incremental.received_ip_ect1_packet_count = 0LL;
    var3 = a2->var3;
    received_ip_ect0_packet_count = a1->total.received_ip_ect0_packet_count;
    if (var3 >= received_ip_ect0_packet_count) {
      uint64_t v9 = received_ip_ect0_packet_count + var3 - a1->incremental.received_ip_ect0_packet_count;
    }
    id v12 = 0LL;
    a1->total.received_ip_ect0_packet_count = v9;
    a1->incremental.received_ip_ect0_packet_count = 0LL;
    var4 = a2->var4;
    received_ip_ce_packet_count = a1->total.received_ip_ce_packet_count;
    if (var4 >= received_ip_ce_packet_count) {
      id v12 = received_ip_ce_packet_count + var4 - a1->incremental.received_ip_ce_packet_count;
    }
    os_log_type_t v15 = 0LL;
    a1->total.received_ip_ce_packet_count = v12;
    a1->incremental.received_ip_ce_packet_count = 0LL;
    var5 = a2->var5;
    sent_ip_packet_count = a1->total.sent_ip_packet_count;
    if (var5 >= sent_ip_packet_count) {
      os_log_type_t v15 = sent_ip_packet_count + var5 - a1->incremental.sent_ip_packet_count;
    }
    BOOL v18 = 0LL;
    a1->total.sent_ip_packet_count = v15;
    a1->incremental.sent_ip_packet_count = 0LL;
    var6 = a2->var6;
    received_transport_byte_count = a1->total.received_transport_byte_count;
    if (var6 >= received_transport_byte_count) {
      BOOL v18 = received_transport_byte_count + var6 - a1->incremental.received_transport_byte_count;
    }
    v21 = 0LL;
    a1->total.received_transport_byte_count = v18;
    a1->incremental.received_transport_byte_count = 0LL;
    var7 = a2->var7;
    received_transport_duplicate_byte_count = a1->total.received_transport_duplicate_byte_count;
    if (var7 >= received_transport_duplicate_byte_count) {
      v21 = received_transport_duplicate_byte_count + var7 - a1->incremental.received_transport_duplicate_byte_count;
    }
    os_log_type_t v24 = 0LL;
    a1->total.received_transport_duplicate_byte_count = v21;
    a1->incremental.received_transport_duplicate_byte_count = 0LL;
    var8 = a2->var8;
    received_transport_out_of_order_byte_count = a1->total.received_transport_out_of_order_byte_count;
    if (var8 >= received_transport_out_of_order_byte_count) {
      os_log_type_t v24 = received_transport_out_of_order_byte_count
    }
          + var8
          - a1->incremental.received_transport_out_of_order_byte_count;
    v27 = 0LL;
    a1->total.received_transport_out_of_order_byte_count = v24;
    a1->incremental.received_transport_out_of_order_byte_count = 0LL;
    var9 = a2->var9;
    sent_transport_byte_count = a1->total.sent_transport_byte_count;
    if (var9 >= sent_transport_byte_count) {
      v27 = sent_transport_byte_count + var9 - a1->incremental.sent_transport_byte_count;
    }
    v30 = 0LL;
    a1->total.sent_transport_byte_count = v27;
    a1->incremental.sent_transport_byte_count = 0LL;
    var10 = a2->var10;
    sent_transport_retransmitted_byte_count = a1->total.sent_transport_retransmitted_byte_count;
    if (var10 >= sent_transport_retransmitted_byte_count) {
      v30 = sent_transport_retransmitted_byte_count + var10 - a1->incremental.sent_transport_retransmitted_byte_count;
    }
    __int16 v33 = 0LL;
    a1->total.sent_transport_retransmitted_byte_count = v30;
    a1->incremental.sent_transport_retransmitted_byte_count = 0LL;
    var11 = a2->var11;
    sent_transport_ecn_capable_packet_count = a1->total.sent_transport_ecn_capable_packet_count;
    if (var11 >= sent_transport_ecn_capable_packet_count) {
      __int16 v33 = sent_transport_ecn_capable_packet_count + var11 - a1->incremental.sent_transport_ecn_capable_packet_count;
    }
    __int16 v36 = 0LL;
    a1->total.sent_transport_ecn_capable_packet_count = v33;
    a1->incremental.sent_transport_ecn_capable_packet_count = 0LL;
    var12 = a2->var12;
    sent_transport_ecn_capable_acked_packet_count = a1->total.sent_transport_ecn_capable_acked_packet_count;
    if (var12 >= sent_transport_ecn_capable_acked_packet_count) {
      __int16 v36 = sent_transport_ecn_capable_acked_packet_count
    }
          + var12
          - a1->incremental.sent_transport_ecn_capable_acked_packet_count;
    uint64_t v39 = 0LL;
    a1->total.sent_transport_ecn_capable_acked_packet_count = v36;
    a1->incremental.sent_transport_ecn_capable_acked_packet_count = 0LL;
    var13 = a2->var13;
    sent_transport_ecn_capable_marked_packet_count = a1->total.sent_transport_ecn_capable_marked_packet_count;
    if (var13 >= sent_transport_ecn_capable_marked_packet_count) {
      uint64_t v39 = sent_transport_ecn_capable_marked_packet_count
    }
          + var13
          - a1->incremental.sent_transport_ecn_capable_marked_packet_count;
    v42 = 0LL;
    a1->total.sent_transport_ecn_capable_marked_packet_count = v39;
    a1->incremental.sent_transport_ecn_capable_marked_packet_count = 0LL;
    var14 = a2->var14;
    sent_transport_ecn_capable_lost_packet_count = a1->total.sent_transport_ecn_capable_lost_packet_count;
    if (var14 >= sent_transport_ecn_capable_lost_packet_count) {
      v42 = sent_transport_ecn_capable_lost_packet_count
    }
          + var14
          - a1->incremental.sent_transport_ecn_capable_lost_packet_count;
    v45 = 0LL;
    a1->total.sent_transport_ecn_capable_lost_packet_count = v42;
    a1->incremental.sent_transport_ecn_capable_lost_packet_count = 0LL;
    var21 = a2->var21;
    received_application_byte_count = a1->total.received_application_byte_count;
    if (var21 >= received_application_byte_count) {
      v45 = received_application_byte_count + var21 - a1->incremental.received_application_byte_count;
    }
    v48 = 0LL;
    a1->total.received_application_byte_count = v45;
    a1->incremental.received_application_byte_count = 0LL;
    var22 = a2->var22;
    sent_application_byte_count = a1->total.sent_application_byte_count;
    if (var22 >= sent_application_byte_count) {
      v48 = sent_application_byte_count + var22 - a1->incremental.sent_application_byte_count;
    }
    a1->total.sent_application_byte_count = v48;
    a1->incremental.sent_application_byte_count = 0LL;
    *(_OWORD *)&a1->total.transport_smoothed_rtt_milliseconds = *(_OWORD *)&a2->var15;
    *(_OWORD *)&a1->total.transport_current_rtt_milliseconds = *(_OWORD *)&a2->var17;
    *(_OWORD *)&a1->total.transport_congestion_window = *(_OWORD *)&a2->var19;
    return;
  }

  __nwlog_obj();
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v65 = "nw_data_transfer_update_path_report_end";
  v52 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v62 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v54 = type;
    if (os_log_type_enabled(v53, type))
    {
      *(_DWORD *)buf = 136446210;
      v65 = "nw_data_transfer_update_path_report_end";
      v55 = "%{public}s called with null snapshot";
      goto LABEL_69;
    }

    goto LABEL_70;
  }

  if (!v62)
  {
    __nwlog_obj();
    v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v54 = type;
    if (os_log_type_enabled(v53, type))
    {
      *(_DWORD *)buf = 136446210;
      v65 = "nw_data_transfer_update_path_report_end";
      v55 = "%{public}s called with null snapshot, backtrace limit exceeded";
      goto LABEL_69;
    }

    goto LABEL_70;
  }

  v60 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  v54 = type;
  v61 = os_log_type_enabled(v53, type);
  if (!v60)
  {
    if (v61)
    {
      *(_DWORD *)buf = 136446210;
      v65 = "nw_data_transfer_update_path_report_end";
      v55 = "%{public}s called with null snapshot, no backtrace";
      goto LABEL_69;
    }

    goto LABEL_70;
  }

  if (v61)
  {
    *(_DWORD *)buf = 136446466;
    v65 = "nw_data_transfer_update_path_report_end";
    v66 = 2082;
    v67 = (nw_data_transfer_path_report *)v60;
    _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s called with null snapshot, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v60);
  if (v52) {
    goto LABEL_72;
  }
}

    if (v24) {
      free(v24);
    }
    goto LABEL_7;
  }

  *((_DWORD *)v5 + 13) = 2;
  *((void *)v5 + 2) = xpc_dictionary_get_uint64(v2, "duration_milliseconds");
  if (object_getClass(v2) == v4)
  {
    value = xpc_dictionary_get_value(v2, "primary_path");
    v7 = value;
    if (!value) {
      goto LABEL_6;
    }
    if (object_getClass(value) == v4)
    {
      id v11 = xpc_retain(v7);
      v7 = v11;
      if (v11)
      {
        *((_DWORD *)v6 + 11) = 1;
        *((void *)v6 + 7) = xpc_dictionary_get_uint64(v11, "total_received_ip_packet_count");
        *((void *)v6 + 29) = xpc_dictionary_get_uint64(v7, "incremental_received_ip_packet_count");
        *((void *)v6 + 8) = xpc_dictionary_get_uint64(v7, "total_received_ip_ect1_packet_count");
        *((void *)v6 + 30) = xpc_dictionary_get_uint64(v7, "incremental_received_ip_ect1_packet_count");
        *((void *)v6 + 9) = xpc_dictionary_get_uint64(v7, "total_received_ip_ect0_packet_count");
        *((void *)v6 + 31) = xpc_dictionary_get_uint64(v7, "incremental_received_ip_ect0_packet_count");
        *((void *)v6 + 10) = xpc_dictionary_get_uint64(v7, "total_received_ip_ce_packet_count");
        *((void *)v6 + 32) = xpc_dictionary_get_uint64(v7, "incremental_received_ip_ce_packet_count");
        *((void *)v6 + 11) = xpc_dictionary_get_uint64(v7, "total_sent_ip_packet_count");
        *((void *)v6 + 33) = xpc_dictionary_get_uint64(v7, "incremental_sent_ip_packet_count");
        *((void *)v6 + 12) = xpc_dictionary_get_uint64(v7, "total_received_transport_byte_count");
        *((void *)v6 + 34) = xpc_dictionary_get_uint64(v7, "incremental_received_transport_byte_count");
        *((void *)v6 + 13) = xpc_dictionary_get_uint64(v7, "total_received_transport_duplicate_byte_count");
        *((void *)v6 + 35) = xpc_dictionary_get_uint64(v7, "incremental_received_transport_duplicate_byte_count");
        *((void *)v6 + 14) = xpc_dictionary_get_uint64(v7, "total_received_transport_out_of_order_byte_count");
        *((void *)v6 + 36) = xpc_dictionary_get_uint64(v7, "incremental_received_transport_out_of_order_byte_count");
        *((void *)v6 + 15) = xpc_dictionary_get_uint64(v7, "total_sent_transport_byte_count");
        *((void *)v6 + 37) = xpc_dictionary_get_uint64(v7, "incremental_sent_transport_byte_count");
        *((void *)v6 + 16) = xpc_dictionary_get_uint64(v7, "total_sent_transport_retransmitted_byte_count");
        *((void *)v6 + 38) = xpc_dictionary_get_uint64(v7, "incremental_sent_transport_retransmitted_byte_count");
        *((void *)v6 + 17) = xpc_dictionary_get_uint64(v7, "total_sent_transport_ecn_capable_packet_count");
        *((void *)v6 + 39) = xpc_dictionary_get_uint64(v7, "incremental_sent_transport_ecn_capable_packet_count");
        *((void *)v6 + 18) = xpc_dictionary_get_uint64(v7, "total_sent_transport_ecn_capable_acked_packet_count");
        *((void *)v6 + 40) = xpc_dictionary_get_uint64( v7,  "incremental_sent_transport_ecn_capable_acked_packet_count");
        *((void *)v6 + 19) = xpc_dictionary_get_uint64(v7, "total_sent_transport_ecn_capable_marked_packet_count");
        *((void *)v6 + 41) = xpc_dictionary_get_uint64( v7,  "incremental_sent_transport_ecn_capable_marked_packet_count");
        *((void *)v6 + 20) = xpc_dictionary_get_uint64(v7, "total_sent_transport_ecn_capable_lost_packet_count");
        *((void *)v6 + 42) = xpc_dictionary_get_uint64(v7, "incremental_sent_transport_ecn_capable_lost_packet_count");
        *((void *)v6 + 21) = xpc_dictionary_get_uint64(v7, "total_transport_smoothed_rtt_milliseconds");
        *((void *)v6 + 43) = xpc_dictionary_get_uint64(v7, "incremental_transport_smoothed_rtt_milliseconds");
        *((void *)v6 + 22) = xpc_dictionary_get_uint64(v7, "total_transport_minimum_rtt_milliseconds");
        *((void *)v6 + 44) = xpc_dictionary_get_uint64(v7, "incremental_transport_minimum_rtt_milliseconds");
        *((void *)v6 + 23) = xpc_dictionary_get_uint64(v7, "total_transport_current_rtt_milliseconds");
        *((void *)v6 + 45) = xpc_dictionary_get_uint64(v7, "incremental_transport_current_rtt_milliseconds");
        *((void *)v6 + 24) = xpc_dictionary_get_uint64(v7, "total_transport_rtt_variance");
        *((void *)v6 + 46) = xpc_dictionary_get_uint64(v7, "incremental_transport_rtt_variance");
        *((void *)v6 + 25) = xpc_dictionary_get_uint64(v7, "total_transport_congestion_window");
        *((void *)v6 + 47) = xpc_dictionary_get_uint64(v7, "incremental_transport_congestion_window");
        *((void *)v6 + 26) = xpc_dictionary_get_uint64(v7, "total_transport_slow_start_threshold");
        *((void *)v6 + 48) = xpc_dictionary_get_uint64(v7, "incremental_transport_slow_start_threshold");
        *((void *)v6 + 27) = xpc_dictionary_get_uint64(v7, "total_received_application_byte_count");
        *((void *)v6 + 49) = xpc_dictionary_get_uint64(v7, "incremental_received_application_byte_count");
        *((void *)v6 + 28) = xpc_dictionary_get_uint64(v7, "total_sent_application_byte_count");
        *((void *)v6 + 50) = xpc_dictionary_get_uint64(v7, "incremental_sent_application_byte_count");
        if (object_getClass(v7) == v4
          && (os_log_type_t v13 = xpc_dictionary_get_value(v7, "interface")) != 0LL
          && (char v14 = v13, object_getClass(v13) == v4))
        {
          id v12 = v14;
          os_log_type_t v15 = nw_interface_create_from_dictionary(v12);
          os_log_type_t v16 = (void *)*((void *)v6 + 51);
          *((void *)v6 + 51) = v15;
        }

        else
        {
          id v12 = 0LL;
        }
      }

      goto LABEL_6;
    }
  }

  v7 = 0LL;
LABEL_6:
  v8 = v6;

LABEL_7:
LABEL_8:

  return v6;
}

      goto LABEL_71;
    }

    if (!v152[0])
    {
      __nwlog_obj();
      v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v107 = v154[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v154[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
        _os_log_impl( &dword_181A5C000,  v43,  v107,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_70;
    }

    v104 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v105 = v154[0];
    v106 = os_log_type_enabled(v43, (os_log_type_t)v154[0]);
    if (!v104)
    {
      if (v106)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
        _os_log_impl(&dword_181A5C000, v43, v105, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_70;
    }

    if (v106)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_send_message_internal";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v104;
      _os_log_impl( &dword_181A5C000,  v43,  v105,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v104);
  }

      if (v18) {
        free(v18);
      }
      goto LABEL_19;
    }

    __nwlog_obj();
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v52 = "__nw_protocol_notify";
    v27 = (char *)_os_log_send_and_compose_impl();

    v46[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v27, v46, &type))
    {
      if (v46[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v29 = v46[0];
        if (os_log_type_enabled(v28, v46[0]))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_notify";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null other_protocol", buf, 0xCu);
        }
      }

      else if (type)
      {
        v37 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        addrinfo v38 = v46[0];
        uint64_t v39 = os_log_type_enabled(v28, v46[0]);
        if (v37)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            v52 = "__nw_protocol_notify";
            v53 = 2082;
            v54 = v37;
            _os_log_impl( &dword_181A5C000,  v28,  v38,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v37);
          goto LABEL_86;
        }

        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_notify";
          _os_log_impl( &dword_181A5C000,  v28,  v38,  "%{public}s called with null other_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v44 = v46[0];
        if (os_log_type_enabled(v28, v46[0]))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_notify";
          _os_log_impl( &dword_181A5C000,  v28,  v44,  "%{public}s called with null other_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      if (v18) {
        free(v18);
      }
      goto LABEL_19;
    }

    __nwlog_obj();
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v52 = "__nw_protocol_output_available";
    v27 = (char *)_os_log_send_and_compose_impl();

    v46[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v27, v46, &type))
    {
      if (v46[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v29 = v46[0];
        if (os_log_type_enabled(v28, v46[0]))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_output_available";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null other_protocol", buf, 0xCu);
        }
      }

      else if (type)
      {
        v37 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        addrinfo v38 = v46[0];
        uint64_t v39 = os_log_type_enabled(v28, v46[0]);
        if (v37)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            v52 = "__nw_protocol_output_available";
            v53 = 2082;
            v54 = v37;
            _os_log_impl( &dword_181A5C000,  v28,  v38,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v37);
          goto LABEL_86;
        }

        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_output_available";
          _os_log_impl( &dword_181A5C000,  v28,  v38,  "%{public}s called with null other_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v44 = v46[0];
        if (os_log_type_enabled(v28, v46[0]))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_output_available";
          _os_log_impl( &dword_181A5C000,  v28,  v44,  "%{public}s called with null other_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      if (v18) {
        free(v18);
      }
      goto LABEL_19;
    }

    __nwlog_obj();
    BOOL v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v52 = "__nw_protocol_error";
    v27 = (char *)_os_log_send_and_compose_impl();

    v46[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v27, v46, &type))
    {
      if (v46[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v29 = v46[0];
        if (os_log_type_enabled(v28, v46[0]))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_error";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null other_protocol", buf, 0xCu);
        }
      }

      else if (type)
      {
        v37 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        addrinfo v38 = v46[0];
        uint64_t v39 = os_log_type_enabled(v28, v46[0]);
        if (v37)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            v52 = "__nw_protocol_error";
            v53 = 2082;
            v54 = v37;
            _os_log_impl( &dword_181A5C000,  v28,  v38,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v37);
          goto LABEL_86;
        }

        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_error";
          _os_log_impl( &dword_181A5C000,  v28,  v38,  "%{public}s called with null other_protocol, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v44 = v46[0];
        if (os_log_type_enabled(v28, v46[0]))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "__nw_protocol_error";
          _os_log_impl( &dword_181A5C000,  v28,  v44,  "%{public}s called with null other_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_52);
  }
  v56 = (id)nw_protocol_copy_http_client_definition_definition;
  v57 = nw_parameters_copy_protocol_options_for_definition(a4, v56);
  v58 = (dispatch_object_s *)nw_http_client_options_copy_retry_with_h1_handler(v57);
  v59 = *((_BYTE *)v6 + 616);
  if ((v59 & 1) != 0)
  {
    v60 = v6[76];
    if (v60)
    {
      _Block_release(v60);
      v59 = *((_BYTE *)v6 + 616);
    }
  }

  v6[25] = 0LL;
  v6[76] = v58;
  *((_BYTE *)v6 + 616) = v59 | 1;
  v6[9] = (dispatch_object_s *)(v6 + 25);
  v6[26] = (dispatch_object_s *)(v6 + 25);
  v6[27] = 0LL;
  v6[28] = (dispatch_object_s *)(v6 + 27);
  v6[29] = 0LL;
  v6[30] = (dispatch_object_s *)(v6 + 29);
  *((_BYTE *)v6 + 340) = 2;
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  v61 = (id)nw_protocol_copy_http_definition_http_definition;
  nw_protocol_plugin_metadata_set_callbacks( (uint64_t)v6,  v61,  (uint64_t)nw_protocol_http_authentication_create::$_0::__invoke,  (uint64_t)nw_protocol_http_authentication_create::$_1::__invoke);
  if (v61) {
    os_release(v61);
  }
  v62 = v6[5];
  if (!v62)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
    v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v117 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v69 = (os_log_s *)__nwlog_obj();
      v70 = type[0];
      if (!os_log_type_enabled(v69, type[0])) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
      v71 = "%{public}s called with null protocol->handle";
      goto LABEL_176;
    }

    if (!v117)
    {
      v69 = (os_log_s *)__nwlog_obj();
      v70 = type[0];
      if (!os_log_type_enabled(v69, type[0])) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
      v71 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_176;
    }

    v88 = (char *)__nw_create_backtrace_string();
    v69 = (os_log_s *)__nwlog_obj();
    v70 = type[0];
    v89 = os_log_type_enabled(v69, type[0]);
    if (!v88)
    {
      if (!v89) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
      v71 = "%{public}s called with null protocol->handle, no backtrace";
      goto LABEL_176;
    }

    if (v89)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v88;
      _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s called with null protocol->handle, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v88);
LABEL_177:
    if (!v68) {
      goto LABEL_82;
    }
LABEL_178:
    free(v68);
    goto LABEL_82;
  }

  v63 = *((void *)v62 + 9);
  if (!v63)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
    v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v117 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v69 = (os_log_s *)__nwlog_obj();
      v70 = type[0];
      if (!os_log_type_enabled(v69, type[0])) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
      v71 = "%{public}s called with null metadata_plugin";
      goto LABEL_176;
    }

    if (!v117)
    {
      v69 = (os_log_s *)__nwlog_obj();
      v70 = type[0];
      if (!os_log_type_enabled(v69, type[0])) {
        goto LABEL_177;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
      v71 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_176;
    }

    v90 = (char *)__nw_create_backtrace_string();
    v69 = (os_log_s *)__nwlog_obj();
    v70 = type[0];
    v91 = os_log_type_enabled(v69, type[0]);
    if (v90)
    {
      if (v91)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v90;
        _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v90);
      if (!v68) {
        goto LABEL_82;
      }
      goto LABEL_178;
    }

    if (v91)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_plugin_metadata_set_message_discarded_callback";
      v71 = "%{public}s called with null metadata_plugin, no backtrace";
LABEL_176:
      _os_log_impl(&dword_181A5C000, v69, v70, v71, buf, 0xCu);
      goto LABEL_177;
    }

    goto LABEL_177;
  }

  *(void *)(v63 + 120) = nw_http_authentication_reissue;
LABEL_82:
  v6[11] = (dispatch_object_s *)(v6 + 43);
  nw_protocol_plugin_retry_set_callbacks( (uint64_t)v6,  (uint64_t)nw_protocol_http_authentication_create::$_2::__invoke,  (uint64_t)nw_protocol_http_authentication_create::$_3::__invoke,  (uint64_t)nw_protocol_http_authentication_create::$_4::__invoke,  (uint64_t)nw_protocol_http_authentication_create::$_5::__invoke);
  v6[8] = (dispatch_object_s *)(v6 + 13);
  nw_protocol_plugin_name_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_authentication_create::$_6::__invoke);
  if (v57) {
    os_release(v57);
  }
  if (v56) {
    os_release(v56);
  }
  if (v24) {
    os_release(v24);
  }
  if (v22) {
    os_release(v22);
  }
  return (BOOL)v6;
}

    free(v33);
    if (!v23) {
      return;
    }
LABEL_118:
    free(v23);
    return;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3802000000LL;
  v103 = __Block_byref_object_copy__15685;
  v104 = __Block_byref_object_dispose__15686;
  object = nw_http_metadata_copy_request(a3);
  v106 |= 1u;
  v8 = *(void **)(*(void *)&buf[8] + 40LL);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)os_log_type_t type = 136446210;
    *(void *)&type[4] = "operator()";
    v27 = (char *)_os_log_send_and_compose_impl();
    v107[0] = 16;
    LOBYTE(v111[0]) = 0;
    if (v107[0] == 17)
    {
      BOOL v28 = (os_log_s *)__nwlog_obj();
      char v29 = v107[0];
      if (!os_log_type_enabled(v28, (os_log_type_t)v107[0])) {
        goto LABEL_122;
      }
      *(_DWORD *)os_log_type_t type = 136446210;
      *(void *)&type[4] = "operator()";
      v30 = "%{public}s called with null request";
    }

    else if (LOBYTE(v111[0]))
    {
      addrinfo v38 = (char *)__nw_create_backtrace_string();
      BOOL v28 = (os_log_s *)__nwlog_obj();
      char v29 = v107[0];
      uint64_t v39 = os_log_type_enabled(v28, (os_log_type_t)v107[0]);
      if (v38)
      {
        if (v39)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          *(void *)&type[4] = "operator()";
          *(_WORD *)&type[12] = 2082;
          *(void *)&type[14] = v38;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null request, dumping backtrace:%{public}s",  type,  0x16u);
        }

        free(v38);
        goto LABEL_122;
      }

      if (!v39)
      {
LABEL_122:
        if (v27) {
          free(v27);
        }
        goto LABEL_28;
      }

      *(_DWORD *)os_log_type_t type = 136446210;
      *(void *)&type[4] = "operator()";
      v30 = "%{public}s called with null request, no backtrace";
    }

    else
    {
      BOOL v28 = (os_log_s *)__nwlog_obj();
      char v29 = v107[0];
      if (!os_log_type_enabled(v28, (os_log_type_t)v107[0])) {
        goto LABEL_122;
      }
      *(_DWORD *)os_log_type_t type = 136446210;
      *(void *)&type[4] = "operator()";
      v30 = "%{public}s called with null request, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v28, v29, v30, type, 0xCu);
    goto LABEL_122;
  }

  uint64_t v9 = v8;
  has_method = _nw_http_request_has_method((uint64_t)v9);

  id v11 = (has_method & 1) != 0 || nw_http_request_has_method(*(void **)(*(void *)&buf[8] + 40LL), (uint64_t)"HEAD");
  *(_BYTE *)(v5 + 360) = *(_BYTE *)(v5 + 360) & 0xFE | v11;
  if (!nw_http_fields_have_field_with_name(*(void **)(*(void *)&buf[8] + 40LL), (unint64_t)"Cookie"))
  {
    parameters = (void *)nw_protocol_get_parameters(*(void *)(v5 + 48));
    if (parameters) {
      os_log_type_t v13 = os_retain(parameters);
    }
    else {
      os_log_type_t v13 = 0LL;
    }
    char v14 = nw_parameters_copy_protocol_options_legacy(v13, (nw_protocol *)v5);
    os_log_type_t v15 = nw_http_cookie_options_copy_cookie_storage(v14);
    os_log_type_t v16 = (nw_endpoint *)nw_parameters_copy_url_endpoint(v13);
    BOOL v17 = v16;
    if (!v15)
    {
LABEL_19:
      if (!v17) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }

    v95 = v16;
    BOOL v18 = v14;
    os_log_type_t v19 = v18;
    if (v18)
    {
      BOOL v20 = nw_protocol_options_copy_definition(v18);
      if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
      }
      BOOL v17 = v95;
      is_equal = nw_protocol_definition_is_equal( v20,  (nw_protocol_definition_t)nw_protocol_copy_http_cookie_definition_http_cookie_definition);

      if (is_equal)
      {
        *(void *)v107 = 0LL;
        *(void *)&v107[8] = v107;
        *(void *)&v107[16] = 0x2020000000LL;
        *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
        *(void *)&type[8] = 3221225472LL;
        *(void *)&type[16] = __nw_http_cookie_options_get_should_not_send_cookies_block_invoke;
        v99 = &unk_189BC60A8;
        v100 = v107;
        nw_protocol_options_access_handle(v19, type);
        os_log_type_t v22 = *(_BYTE *)(*(void *)&v107[8] + 24LL) == 0;
        _Block_object_dispose(v107, 8);

        if (!v22) {
          goto LABEL_19;
        }
LABEL_139:
        if (!v17) {
          goto LABEL_22;
        }
        v94 = nw_endpoint_copy_cfurl(v17);
        if (!v94) {
          goto LABEL_20;
        }
        v97[0] = 0LL;
        v97[1] = v97;
        v97[2] = 0x2000000000LL;
        v97[3] = 0LL;
        v91 = nw_parameters_copy_main_document_cfurl(v13);
        cf = (const void *)nw_http_cookie_options_copy_site_for_cookies(v19);
        is_top_level_navigation = nw_http_cookie_options_get_is_top_level_navigation(v19);
        v56 = *(_BYTE *)(v5 + 360);
        cookie_partition_identifier = nw_http_cookie_options_get_cookie_partition_identifier(v19);
        v57 = v19;
        v58 = v57;
        if (v19)
        {
          v59 = nw_protocol_options_copy_definition(v57);
          if (nw_protocol_copy_http_cookie_definition_onceToken != -1) {
            dispatch_once(&nw_protocol_copy_http_cookie_definition_onceToken, &__block_literal_global_13_72893);
          }
          v60 = nw_protocol_definition_is_equal( v59,  (nw_protocol_definition_t)nw_protocol_copy_http_cookie_definition_http_cookie_definition);

          if (v60)
          {
            *(void *)v107 = 0LL;
            *(void *)&v107[8] = v107;
            *(void *)&v107[16] = 0x2020000000LL;
            LOBYTE(v108) = 0;
            *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
            *(void *)&type[8] = 3221225472LL;
            *(void *)&type[16] = __nw_http_cookie_options_get_allow_only_partitioned_cookies_block_invoke;
            v99 = &unk_189BC60A8;
            v100 = v107;
            nw_protocol_options_access_handle(v58, type);
            v61 = *(_BYTE *)(*(void *)&v107[8] + 24LL) != 0;
            _Block_object_dispose(v107, 8);
LABEL_147:

            *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
            *(void *)&type[8] = 0x40000000LL;
            *(void *)&type[16] = ___ZZ30nw_protocol_http_cookie_createENK3__2clEP11nw_protocolS1_P20nw_protocol_metadatabU13block_pointerFv46nw_protocol_plugin_metadata_processor_result_tS3_E_block_invoke;
            v99 = &unk_189BB80A8;
            v100 = v97;
            v101 = buf;
            v84 = (id *)v15;
            v87 = type;
            v96 = v84[1];
            v62 = cf;
            if (cf)
            {
              v63 = v56 & 1;
              v111[0] = cf;
              v110[0] = @"_kCFHTTPCookiePolicyPropertySiteForCookies";
              v110[1] = @"_kCFHTTPCookiePolicyPropertyIsTopLevelNavigation";
              [MEMORY[0x189607968] numberWithBool:is_top_level_navigation];
              v64 = (void *)objc_claimAutoreleasedReturnValue();
              v111[1] = v64;
              v110[2] = @"_kCFHTTPCookiePolicyPropertyIsSafeRequest";
              [MEMORY[0x189607968] numberWithBool:v63];
              v65 = (void *)objc_claimAutoreleasedReturnValue();
              v111[2] = v65;
              v110[3] = @"_kCFHTTPCookiePolicyPropertyAllowOnlyPartitionedCookies";
              [MEMORY[0x189607968] numberWithBool:v61];
              v66 = (void *)objc_claimAutoreleasedReturnValue();
              v111[3] = v66;
              [MEMORY[0x189603F68] dictionaryWithObjects:v111 forKeys:v110 count:4];
              v67 = (void *)objc_claimAutoreleasedReturnValue();

              v62 = cf;
            }

            else
            {
              v67 = 0LL;
            }

            if (cookie_partition_identifier)
            {
              objc_msgSend(NSString, "stringWithUTF8String:");
              v68 = (void *)objc_claimAutoreleasedReturnValue();
            }

            else
            {
              v68 = 0LL;
            }

            *(void *)v107 = MEMORY[0x1895F87A8];
            *(void *)&v107[8] = 3221225472LL;
            *(void *)&v107[16] = __nw_http_cookie_enumerate_block_invoke;
            v108 = &unk_189BC7558;
            v69 = v87;
            v109 = v69;
            [v96 _getCookiesForURL:v94 mainDocumentURL:v91 partition:v68 policyProperties:v67 completionHandler:v107];

            if (v62) {
              CFRelease(cf);
            }
            if (v91) {
              CFRelease(v91);
            }
            _Block_object_dispose(v97, 8);
            CFRelease(v94);
LABEL_20:
            os_release(v17);
LABEL_21:
            if (!v15)
            {
LABEL_23:
              if (v14) {
                os_release(v14);
              }
              if (v13) {
                os_release(v13);
              }
              goto LABEL_27;
            }

  if (v29) {
    free(v29);
  }
  v3 = 0LL;
LABEL_40:

  return v3;
}

        goto LABEL_71;
      }

      if (!v58)
      {
        __nwlog_obj();
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v48 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
          _os_log_impl( &dword_181A5C000,  v31,  v48,  "%{public}s called with null protocol_identifier, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_70;
      }

      uint64_t v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v42 = v59;
      v43 = os_log_type_enabled(v31, v59);
      if (!v39)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
          _os_log_impl( &dword_181A5C000,  v31,  v42,  "%{public}s called with null protocol_identifier, no backtrace",  buf,  0xCu);
        }

        goto LABEL_70;
      }

      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v39;
        _os_log_impl( &dword_181A5C000,  v31,  v42,  "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_50;
    }
  }

  else
  {
    __nwlog_obj();
    char v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
    v30 = (char *)_os_log_send_and_compose_impl();

    v59 = OS_LOG_TYPE_ERROR;
    v58 = 0;
    if (__nwlog_fault(v30, &v59, &v58))
    {
      if (v59 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v32 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
          _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s called with null parameters", buf, 0xCu);
        }

        goto LABEL_70;
      }

      if (!v58)
      {
        __nwlog_obj();
        v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v47 = v59;
        if (os_log_type_enabled(v31, v59))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
          _os_log_impl( &dword_181A5C000,  v31,  v47,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_70;
      }

      uint64_t v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v40 = v59;
      v41 = os_log_type_enabled(v31, v59);
      if (!v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
          _os_log_impl(&dword_181A5C000, v31, v40, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_70;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_parameters_remove_from_protocol_stack";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v39;
        _os_log_impl( &dword_181A5C000,  v31,  v40,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v41);
    }
  }

      flow_id = 0LL;
LABEL_71:

      goto LABEL_72;
    }

    __nwlog_obj();
    BOOL v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_endpoint_flow_get_flow_id";
    char v29 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v29, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_flow_get_flow_id";
          _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v42)
      {
        uint64_t v35 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v36 = type;
        v37 = os_log_type_enabled(v30, type);
        if (v35)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446466;
            v45 = "nw_endpoint_flow_get_flow_id";
            v46 = 2082;
            v47 = v35;
            _os_log_impl( &dword_181A5C000,  v30,  v36,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v35);
          goto LABEL_68;
        }

        if (v37)
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_flow_get_flow_id";
          _os_log_impl(&dword_181A5C000, v30, v36, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v39 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_endpoint_flow_get_flow_id";
          _os_log_impl( &dword_181A5C000,  v30,  v39,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_71:
          if (v14 == ++v15) {
            goto LABEL_149;
          }
        }

        Value = (const __CFString *)CFDictionaryGetValue(v17, @"kCFProxyTypeKey");
        BOOL v20 = Value;
        if (Value && (v21 = CFGetTypeID(Value), v21 == CFStringGetTypeID()))
        {
          if (CFStringCompare(v20, @"kCFProxyTypeNone", 0LL) == kCFCompareEqualTo)
          {
            direct = nw_proxy_config_create_direct();
            goto LABEL_141;
          }

          os_log_type_t v22 = (char *)CFDictionaryGetValue(v17, @"kCFProxyHostNameKey");
          v23 = v22;
          if (v22)
          {
            os_log_type_t v24 = CFGetTypeID(v22);
            if (v24 == CFStringGetTypeID())
            {
              os_log_type_t type = (void *)_CFXPCCreateXPCObjectFromCFObject();
              if (type)
              {
                valuePtr = 0;
                v25 = (const __CFNumber *)CFDictionaryGetValue(v17, @"kCFProxyPortNumberKey");
                BOOL v26 = v25;
                if (v25)
                {
                  v27 = CFGetTypeID(v25);
                  if (v27 == CFNumberGetTypeID()) {
                    CFNumberGetValue(v26, kCFNumberIntType, &valuePtr);
                  }
                }

                if (CFStringCompare(v20, @"kCFProxyTypeSOCKS", 0LL))
                {
                  if (!v5[3]) {
                    goto LABEL_100;
                  }
                  if (CFStringCompare(v20, @"kCFProxyTypeHTTP", 0LL) == kCFCompareEqualTo) {
                    goto LABEL_101;
                  }
                  if (CFStringCompare(v20, @"kCFProxyTypeHTTPS", 0LL))
                  {
                    if (CFStringCompare(v20, @"kCFProxyTypeFTP", 0LL))
                    {
                      BOOL v28 = v5[2];
                      if (!v28 || *(_DWORD *)(v28 + 124) != 4)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                        }
                        char v29 = (os_log_s *)(id)gconnectionLogObj;
                        host_with_numeric_port = v29;
                        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                        {
                          v30 = " dry-run";
                          if ((*((_BYTE *)v5 + 159) & 8) == 0) {
                            v30 = "";
                          }
                          *(_DWORD *)buf = 136446978;
                          v83 = "nw_proxy_resolver_create_parsed_array";
                          v84 = 2082;
                          v85 = (char *)v5 + 84;
                          v86 = 2082;
                          v87 = (void *)v30;
                          v88 = 2114;
                          Domain = v20;
                          _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s%{public}s proxy pac] Unknown proxy type %{public}@",  buf,  0x2Au);
                        }

                        direct = 0LL;
                        goto LABEL_139;
                      }

  PBDataWriterWriteUint32Field();
  has = (__int16)self->_has;
  if ((has & 2) == 0)
  {
LABEL_15:
    if ((has & 0x10) == 0) {
      goto LABEL_16;
    }
    goto LABEL_72;
  }

    count = v216;
    if (v53) {
      free(v53);
    }
    LODWORD(v51) = -1;
    BOOL v28 = (unint64_t)v222;
    goto LABEL_73;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v56 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v267 = 136446210;
    v268 = "nw_authentication_credential_add_to_tlv";
    _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_ERROR,  "%{public}s Unsupported credential type identity",  v267,  0xCu);
  }

  LODWORD(v57) = 2;
  BOOL v28 = (unint64_t)v222;
LABEL_94:
  v75 = count + 4LL;
  v76 = v75 + v57;
  v77 = v76;
  if (HIDWORD(v76))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v78 = (id)gLogObj;
    *(_DWORD *)v267 = 136446978;
    v268 = "nw_authentication_credential_add_to_tlv";
    v269 = 2082;
    *(void *)v270 = "buffer_size";
    *(_WORD *)&v270[8] = 2048;
    *(void *)v271 = count + 4LL;
    *(_WORD *)&v271[8] = 2048;
    *(void *)v272 = v76;
    v79 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v257) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v80 = (os_log_s *)(id)gLogObj;
      v81 = type[0];
      if (os_log_type_enabled(v80, type[0]))
      {
        *(_DWORD *)v267 = 136446978;
        v268 = "nw_authentication_credential_add_to_tlv";
        v269 = 2082;
        *(void *)v270 = "buffer_size";
        *(_WORD *)&v270[8] = 2048;
        *(void *)v271 = v75;
        *(_WORD *)&v271[8] = 2048;
        *(void *)v272 = v76;
        _os_log_impl( &dword_181A5C000,  v80,  v81,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  v267,  0x2Au);
      }
    }

    else
    {
      if ((_BYTE)v257)
      {
        v85 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v86 = (os_log_s *)(id)gLogObj;
        v87 = type[0];
        v88 = os_log_type_enabled(v86, type[0]);
        if (v85)
        {
          if (v88)
          {
            *(_DWORD *)v267 = 136447234;
            v268 = "nw_authentication_credential_add_to_tlv";
            v269 = 2082;
            *(void *)v270 = "buffer_size";
            *(_WORD *)&v270[8] = 2048;
            *(void *)v271 = v75;
            *(_WORD *)&v271[8] = 2048;
            *(void *)v272 = v76;
            *(_WORD *)&v272[8] = 2082;
            *(void *)v273 = v85;
            _os_log_impl( &dword_181A5C000,  v86,  v87,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  v267,  0x34u);
          }

          free(v85);
          BOOL v28 = (unint64_t)v222;
          if (!v79) {
            goto LABEL_117;
          }
          goto LABEL_116;
        }

        if (v88)
        {
          *(_DWORD *)v267 = 136446978;
          v268 = "nw_authentication_credential_add_to_tlv";
          v269 = 2082;
          *(void *)v270 = "buffer_size";
          *(_WORD *)&v270[8] = 2048;
          *(void *)v271 = v75;
          *(_WORD *)&v271[8] = 2048;
          *(void *)v272 = v76;
          _os_log_impl( &dword_181A5C000,  v86,  v87,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace",  v267,  0x2Au);
        }

LABEL_115:
        BOOL v28 = (unint64_t)v222;
        if (!v79)
        {
LABEL_117:
          v77 = 0xFFFFFFFFLL;
          LODWORD(v76) = -1;
LABEL_118:
          count = v216;
          goto LABEL_119;
        }
    v50 = -[NWNetworkDescription dnsSearchDomainOptions](self, "dnsSearchDomainOptions");
    if (!v50) {
      goto LABEL_83;
    }
    [v6 dnsSearchDomains];
    uint64_t v9 = (id)objc_claimAutoreleasedReturnValue();
    v51 = [v6 overrideDNSSearchDomains];
    v52 = (void *)v51;
    if (!v9)
    {
      if (!v51) {
        goto LABEL_79;
      }
      goto LABEL_77;
    }

    -[NWNetworkDescription dnsSearchDomainOptions](self, "dnsSearchDomainOptions");
    v3 = (Class *)objc_claimAutoreleasedReturnValue();
    if (NWUtilsAnyStringsMatchPatternSet(v9, v3))
    {

      goto LABEL_83;
    }

    if (v52)
    {
LABEL_77:
      v53 = -[NWNetworkDescription dnsSearchDomainOptions](self, "dnsSearchDomainOptions");
      v21 = NWUtilsAnyStringsMatchPatternSet(v52, v53);

      if (v9)
      {

        if ((v21 & 1) != 0) {
          goto LABEL_83;
        }
LABEL_79:
        LOBYTE(v21) = 0;
LABEL_84:

        goto LABEL_85;
      }

      if (!v21) {
        goto LABEL_84;
      }
LABEL_83:
      LOBYTE(v21) = 1;
      goto LABEL_84;
    }

    goto LABEL_80;
  }

    goto LABEL_71;
  }

  v10 = (void *)SecKeyCopySubjectPublicKeyInfo();
  v47 = v5;
  CFRelease(v9);
  if (v10)
  {
    v50 = 0u;
    v51 = 0u;
    v48 = 0u;
    v49 = 0u;
    id v11 = v6;
    id v12 = v6;
    os_log_type_t v13 = [v12 countByEnumeratingWithState:&v48 objects:v54 count:16];
    if (v13)
    {
      char v14 = 0;
      os_log_type_t v15 = *(void *)v49;
      while (2)
      {
        os_log_type_t v16 = 0LL;
        BOOL v17 = v14;
        v14 += v13;
        do
        {
          if (*(void *)v49 != v15) {
            objc_enumerationMutation(v12);
          }
          BOOL v18 = *(void **)(*((void *)&v48 + 1) + 8 * v16);
          if ([v18 isEqual:v10])
          {
            if (a3) {
              *a3 = v17;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v22 = (os_log_s *)(id)gLogObj;
            uint64_t v5 = v47;
            id v6 = v11;
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
            {
              v23 = [v18 hash];
              *(_DWORD *)buf = 136446466;
              v56 = "nw_utilities_trust_ref_matches_public_key";
              v57 = 2048;
              v58 = v23;
              _os_log_impl(&dword_181A5C000, v22, OS_LOG_TYPE_DEBUG, "%{public}s Matches key: #0x%lx", buf, 0x16u);
            }

            v21 = 1LL;
            goto LABEL_23;
          }

          ++v17;
          ++v16;
        }

        while (v13 != v16);
        os_log_type_t v13 = [v12 countByEnumeratingWithState:&v48 objects:v54 count:16];
        if (v13) {
          continue;
        }
        break;
      }
    }

    uint64_t v5 = v47;
    id v6 = v11;
    if (a3) {
      *a3 = -1;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      BOOL v20 = [v10 hash];
      *(_DWORD *)buf = 136446466;
      v56 = "nw_utilities_trust_ref_matches_public_key";
      v57 = 2048;
      v58 = v20;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s No match for peer key #0x%lx, returning false",  buf,  0x16u);
    }

    goto LABEL_17;
  }

  __nwlog_obj();
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v56 = "nw_utilities_trust_ref_matches_public_key";
  v32 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v52 = 0;
  if (__nwlog_fault(v32, &type, &v52))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s called with null keyInfo", buf, 0xCu);
      }

    goto LABEL_71;
  }

  os_log_type_t v19 = v16;
  BOOL v20 = *((id *)v19 + 1);

  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_52);
  }
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v20,  nw_protocol_copy_http_client_definition_definition);

  if (is_equal_unsafe)
  {
    *(void *)buf = v18;
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_http_client_metadata_set_sec_metadata_block_invoke;
    v64 = &unk_189BC6260;
    os_log_type_t v22 = v17;
    v65 = v22;
    v23 = *((void *)v19 + 4);
    if (v23)
    {
      __nw_http_client_metadata_set_sec_metadata_block_invoke((uint64_t)buf, v23);
      os_log_type_t v22 = v65;
    }

    goto LABEL_18;
  }

  __nwlog_obj();
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http_client_metadata_set_sec_metadata";
  LODWORD(v59) = 12;
  v58 = buf;
  v45 = (char *)_os_log_send_and_compose_impl();

  v72[0] = OS_LOG_TYPE_ERROR;
  v70[0] = 0;
  if (__nwlog_fault(v45, v72, v70))
  {
    if (v72[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v49 = v72[0];
      if (os_log_type_enabled(v46, v72[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_client_metadata_set_sec_metadata";
        _os_log_impl(&dword_181A5C000, v46, v49, "%{public}s metadata must be http_client", buf, 0xCu);
      }
    }

    else if (v70[0])
    {
      v53 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v54 = v72[0];
      v55 = os_log_type_enabled(v46, v72[0]);
      if (v53)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_client_metadata_set_sec_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v53;
          _os_log_impl( &dword_181A5C000,  v46,  v54,  "%{public}s metadata must be http_client, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v53);
        if (!v45) {
          goto LABEL_18;
        }
        goto LABEL_72;
      }

      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_client_metadata_set_sec_metadata";
        _os_log_impl(&dword_181A5C000, v46, v54, "%{public}s metadata must be http_client, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v57 = v72[0];
      if (os_log_type_enabled(v46, v72[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_client_metadata_set_sec_metadata";
        _os_log_impl( &dword_181A5C000,  v46,  v57,  "%{public}s metadata must be http_client, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_70;
  }

    if (!v13) {
      return 0LL;
    }
    v43 = (char *)v13;
LABEL_72:
    free(v43);
    return 0LL;
  }

  if ((_UNKNOWN *)a2[5] == &nw_protocol_ref_counted_handle)
  {
    v37 = a2[11];
    if (v37)
    {
      addrinfo v38 = v37 - 1;
      a2[11] = v38;
      if (!v38)
      {
        uint64_t v39 = (void (**)(void))a2[8];
        if (v39)
        {
          a2[8] = 0LL;
          v39[2](v39);
          _Block_release(v39);
        }

        if ((a2[9] & 1) != 0)
        {
          v40 = (const void *)a2[8];
          if (v40) {
            _Block_release(v40);
          }
        }

        free(a2);
      }
    }
  }

  a1[6] = 0LL;
  if (a4) {
    (*(void (**)(uint64_t))(a4 + 16))(a4);
  }
  BOOL v18 = a1[4];
  if (v18)
  {
    os_log_type_t v19 = *(void **)(v18 + 40);
    if (v19 == &nw_protocol_ref_counted_handle)
    {
      BOOL v20 = *(void *)(v18 + 88);
      if (v20) {
        *(void *)(v18 + 88) = v20 + 1;
      }
    }

    v21 = (void *)a1[5];
    if (v21 == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v22 = a1[11];
      if (v22) {
        a1[11] = v22 + 1;
      }
    }

    v23 = *(void *)(v18 + 24);
    if (v23)
    {
      os_log_type_t v24 = *(uint64_t (**)(uint64_t, void *, uint64_t))(v23 + 8);
      if (v24)
      {
        v25 = v24(v18, a1, a3);
        if (v21 != &nw_protocol_ref_counted_handle)
        {
LABEL_28:
          if (v19 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v18 + 40) == &nw_protocol_ref_counted_handle)
          {
            BOOL v26 = *(void *)(v18 + 88);
            if (v26)
            {
              v27 = v26 - 1;
              *(void *)(v18 + 88) = v27;
              if (!v27)
              {
                BOOL v28 = *(void (***)(void))(v18 + 64);
                if (v28)
                {
                  *(void *)(v18 + 64) = 0LL;
                  v28[2](v28);
                  _Block_release(v28);
                }

                if ((*(_BYTE *)(v18 + 72) & 1) != 0)
                {
                  char v29 = *(const void **)(v18 + 64);
                  if (v29) {
                    _Block_release(v29);
                  }
                }

                free((void *)v18);
              }
            }
          }

          goto LABEL_60;
        }

  if (v15) {
    free(v15);
  }
  v8 = 0LL;
LABEL_80:

  return v8;
}

    free(v37);
    if (!v27) {
      goto LABEL_40;
    }
    goto LABEL_106;
  }

  *(void *)os_log_type_t type = 0LL;
  v77 = type;
  v78 = 0x2020000000LL;
  v79 = 1;
  v72 = 0LL;
  v73 = &v72;
  v75 = 0;
  v74 = 0x2020000000LL;
  uint64_t v9 = MEMORY[0x1895F87A8];
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = __nw_activity_submit_metrics_block_invoke;
  aBlock[3] = &unk_189BC16A8;
  v10 = v6;
  v68 = v10;
  v69 = type;
  v70 = &v72;
  id v11 = _Block_copy(aBlock);
  v71 = v11;
  nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(v6 + 20, (uint64_t)&v71);

  if (*((_BYTE *)v77 + 24))
  {
    if (*((_DWORD *)v73 + 6) >= 0xBu)
    {
      *(void *)v89 = 0LL;
      *(void *)&v89[8] = v89;
      v90 = 0;
      *(void *)&v89[16] = 0x2020000000LL;
      v63[0] = v9;
      v63[1] = 3221225472LL;
      v63[2] = __nw_activity_submit_metrics_block_invoke_82;
      v63[3] = &unk_189BC9210;
      id v12 = v10;
      v64 = v12;
      v65 = v89;
      os_log_type_t v13 = _Block_copy(v63);
      v66 = v13;
      nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(v6 + 20, (uint64_t)&v66);

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v14 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v15 = *(_DWORD *)(*(void *)&v89[8] + 24LL);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_activity_submit_metrics";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v12;
        v83 = 2080;
        v84 = v5;
        v85 = 1024;
        v86 = v15;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s Activity %{public}@ exceeded max client metric count, dropping metric named %s (%u total quenched)",  buf,  0x26u);
      }

      _Block_object_dispose(v89, 8);
      goto LABEL_39;
    }

    v62 = 0LL;
    if (nw_activity_metric_object_is_valid(v8, 0, (const char **)&v62))
    {
      if (__nwlog_metrics_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_metrics_log::onceToken, &__block_literal_global_36_44343);
      }
      os_log_type_t v16 = (os_log_s *)(id)gmetricsLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138543874;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v5;
        v83 = 2082;
        v84 = v62;
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}@ submitting metrics %{public}s: %{public}s",  buf,  0x20u);
      }

      if ((v10[4]._os_unfair_lock_opaque & 0x100) == 0 || !v62)
      {
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
        }
        v25 = (os_log_s *)(id)gactivityLogObj;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138543362;
          *(void *)&uint8_t buf[4] = v10;
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}@ not selected for reporting, metrics complete",  buf,  0xCu);
        }

        goto LABEL_37;
      }

      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
      }
      BOOL v17 = (os_log_s *)(id)gactivityLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}@ selected for reporting, sending metric report to symptoms",  buf,  0xCu);
      }

      bzero(buf, 0x1498uLL);
      BOOL v18 = (unsigned __int8 *)v62;
      os_log_type_t v19 = v10;
      if (v18)
      {
        BOOL v20 = 0LL;
        *(_OWORD *)buf = *(_OWORD *)&v19[2]._os_unfair_lock_opaque;
        while (1)
        {
          v21 = v5[v20];
          buf[v20 + 16] = v21;
          if (!v21) {
            break;
          }
          if (++v20 == 255)
          {
            v87 = 0;
            break;
          }
        }

        os_log_type_t v22 = &v88;
        v23 = 4999LL;
        while (1)
        {
          os_log_type_t v24 = *v18;
          *(_BYTE *)os_log_type_t v22 = v24;
          if (!v24) {
            goto LABEL_29;
          }
          os_log_type_t v22 = (uint64_t *)((char *)v22 + 1);
          ++v18;
          if (!--v23)
          {
            *(_BYTE *)os_log_type_t v22 = 0;
            goto LABEL_29;
          }
        }
      }

      v49 = v19;
      __nwlog_obj();
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)v89 = 136446210;
      *(void *)&v89[4] = "nw_activity_fill_out_client_metric_report";
      v51 = (char *)_os_log_send_and_compose_impl();

      v81 = OS_LOG_TYPE_ERROR;
      v80 = 0;
      if (__nwlog_fault(v51, &v81, &v80))
      {
        if (v81 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v53 = v81;
          if (os_log_type_enabled(v52, v81))
          {
            *(_DWORD *)v89 = 136446210;
            *(void *)&v89[4] = "nw_activity_fill_out_client_metric_report";
            _os_log_impl(&dword_181A5C000, v52, v53, "%{public}s called with null client_metric", v89, 0xCu);
          }
        }

        else if (v80)
        {
          v57 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v58 = v81;
          v59 = os_log_type_enabled(v52, v81);
          if (v57)
          {
            if (v59)
            {
              *(_DWORD *)v89 = 136446466;
              *(void *)&v89[4] = "nw_activity_fill_out_client_metric_report";
              *(_WORD *)&v89[12] = 2082;
              *(void *)&v89[14] = v57;
              _os_log_impl( &dword_181A5C000,  v52,  v58,  "%{public}s called with null client_metric, dumping backtrace:%{public}s",  v89,  0x16u);
            }

            free(v57);
            goto LABEL_126;
          }

          if (v59)
          {
            *(_DWORD *)v89 = 136446210;
            *(void *)&v89[4] = "nw_activity_fill_out_client_metric_report";
            _os_log_impl( &dword_181A5C000,  v52,  v58,  "%{public}s called with null client_metric, no backtrace",  v89,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v52 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v61 = v81;
          if (os_log_type_enabled(v52, v81))
          {
            *(_DWORD *)v89 = 136446210;
            *(void *)&v89[4] = "nw_activity_fill_out_client_metric_report";
            _os_log_impl( &dword_181A5C000,  v52,  v61,  "%{public}s called with null client_metric, backtrace limit exceeded",  v89,  0xCu);
          }
        }
      }

      if (v10) {
        goto LABEL_71;
      }
      return;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http3_stream_input_available";
    v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v22 = (os_log_s *)__nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http3_stream_input_available";
      os_log_type_t v16 = "%{public}s called with null http3_stream";
      goto LABEL_68;
    }

    if (!v40)
    {
      os_log_type_t v22 = (os_log_s *)__nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http3_stream_input_available";
      os_log_type_t v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_68;
    }

    v30 = (char *)__nw_create_backtrace_string();
    os_log_type_t v22 = (os_log_s *)__nwlog_obj();
    v23 = type;
    __int16 v33 = os_log_type_enabled(v22, type);
    if (!v30)
    {
      if (!v33) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http3_stream_input_available";
      os_log_type_t v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_68;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_http3_stream_input_available";
      v44 = 2082;
      v45 = v30;
      v32 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http3_stream_input_available";
    v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v22 = (os_log_s *)__nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http3_stream_input_available";
      os_log_type_t v16 = "%{public}s called with null protocol";
LABEL_68:
      v37 = v22;
      addrinfo v38 = v23;
      uint64_t v39 = 12;
      goto LABEL_69;
    }

    if (!v40)
    {
      os_log_type_t v22 = (os_log_s *)__nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http3_stream_input_available";
      os_log_type_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_68;
    }

    v30 = (char *)__nw_create_backtrace_string();
    os_log_type_t v22 = (os_log_s *)__nwlog_obj();
    v23 = type;
    v31 = os_log_type_enabled(v22, type);
    if (!v30)
    {
      if (!v31) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http3_stream_input_available";
      os_log_type_t v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_68;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_http3_stream_input_available";
      v44 = 2082;
      v45 = v30;
      v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_51:
      _os_log_impl(&dword_181A5C000, v22, v23, v32, buf, 0x16u);
    }
  }

  free(v30);
  if (v10) {
LABEL_71:
  }
    free(v10);
}

    free(backtrace_string);
    goto LABEL_97;
  }

  if ((*(_DWORD *)&a1[4].flow_id[12] & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v553 = "nw_socket_set_common_sockopts";
    v221 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v556) = 0;
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null socket_handler->fd";
      goto LABEL_96;
    }

    if (!(_BYTE)v556)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null socket_handler->fd, backtrace limit exceeded";
      goto LABEL_96;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (os_log_s *)gLogObj;
    v10 = uu[0];
    BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null socket_handler->fd, no backtrace";
      goto LABEL_96;
    }

    if (!v18) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2082;
    *(void *)v555 = backtrace_string;
    os_log_type_t v19 = "%{public}s called with null socket_handler->fd, dumping backtrace:%{public}s";
LABEL_69:
    _os_log_impl(&dword_181A5C000, v9, v10, v19, buf, 0x16u);
    goto LABEL_70;
  }

  identifier = a1[2].identifier;
  if (!identifier) {
    goto LABEL_25;
  }
  id v6 = *(void *)&identifier->name[24];
  if (!v6) {
    goto LABEL_25;
  }
  v7 = *(uint64_t (**)(void))(v6 + 136);
  if (!v7) {
    goto LABEL_25;
  }
  if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
  {
    id v12 = *(void *)&identifier[2].name[8];
    if (v12) {
      *(void *)&identifier[2].name[8] = v12 + 1;
    }
    v8 = (void *)v7(identifier);
    if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
    {
      v25 = *(void *)&identifier[2].name[8];
      if (v25)
      {
        BOOL v26 = v25 - 1;
        *(void *)&identifier[2].name[8] = v26;
        if (!v26)
        {
          v27 = *(void (***)(void))&identifier[1].name[24];
          if (v27)
          {
            *(void *)&identifier[1].name[24] = 0LL;
            v27[2](v27);
            _Block_release(v27);
          }

          if ((identifier[1].level & 1) != 0)
          {
            BOOL v28 = *(const void **)&identifier[1].name[24];
            if (v28) {
              _Block_release(v28);
            }
          }

          free(identifier);
        }
      }
    }
  }

  else
  {
    v8 = (void *)v7(a1[2].identifier);
  }

  if (!v8)
  {
LABEL_25:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v553 = "nw_socket_set_common_sockopts";
    v221 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v556) = 0;
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null remote_endpoint";
      goto LABEL_96;
    }

    if (!(_BYTE)v556)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null remote_endpoint, backtrace limit exceeded";
      goto LABEL_96;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (os_log_s *)gLogObj;
    v10 = uu[0];
    os_log_type_t v24 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (!backtrace_string)
    {
      if (!v24) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null remote_endpoint, no backtrace";
      goto LABEL_96;
    }

    if (!v24) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2082;
    *(void *)v555 = backtrace_string;
    os_log_type_t v19 = "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s";
    goto LABEL_69;
  }

  os_log_type_t v13 = a1[2].identifier;
  if (!v13) {
    goto LABEL_45;
  }
  char v14 = *(void *)&v13->name[24];
  if (!v14) {
    goto LABEL_45;
  }
  os_log_type_t v15 = *(uint64_t (**)(void))(v14 + 112);
  if (!v15) {
    goto LABEL_45;
  }
  if (*(_UNKNOWN **)v13[1].name == &nw_protocol_ref_counted_handle)
  {
    BOOL v20 = *(void *)&v13[2].name[8];
    if (v20) {
      *(void *)&v13[2].name[8] = v20 + 1;
    }
    os_log_type_t v16 = (void *)v15(v13);
    if (*(_UNKNOWN **)v13[1].name == &nw_protocol_ref_counted_handle)
    {
      __int16 v34 = *(void *)&v13[2].name[8];
      if (v34)
      {
        uint64_t v35 = v34 - 1;
        *(void *)&v13[2].name[8] = v35;
        if (!v35)
        {
          __int16 v36 = *(void (***)(void))&v13[1].name[24];
          if (v36)
          {
            *(void *)&v13[1].name[24] = 0LL;
            v36[2](v36);
            _Block_release(v36);
          }

          if ((v13[1].level & 1) != 0)
          {
            v37 = *(const void **)&v13[1].name[24];
            if (v37) {
              _Block_release(v37);
            }
          }

          free(v13);
        }
      }
    }
  }

  else
  {
    os_log_type_t v16 = (void *)v15(a1[2].identifier);
  }

  if (!v16)
  {
LABEL_45:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v553 = "nw_socket_set_common_sockopts";
    v221 = (char *)_os_log_send_and_compose_impl();
    uu[0] = 16;
    LOBYTE(v556) = 0;
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null parameters";
      goto LABEL_96;
    }

    if (!(_BYTE)v556)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      v10 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_96;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (os_log_s *)gLogObj;
    v10 = uu[0];
    __int16 v33 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (!backtrace_string)
    {
      if (!v33) {
        goto LABEL_97;
      }
      *(_DWORD *)buf = 136446210;
      v553 = "nw_socket_set_common_sockopts";
      id v11 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_96;
    }

    if (!v33) {
      goto LABEL_70;
    }
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2082;
    *(void *)v555 = backtrace_string;
    os_log_type_t v19 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
    goto LABEL_69;
  }

  v541 = (uint64_t)v3;
  path = (void *)nw_socket_get_path(a1);
  v550 = 0;
  v551 = 1;
  identifier_low = LOBYTE(a1[6].identifier);
  if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4130, &v551, 4u)) {
    goto LABEL_106;
  }
  v21 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  os_log_type_t v22 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 2080;
    *(void *)v555 = (char *)a1 + 404;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v21;
    _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d",  buf,  0x1Cu);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v23 = (os_log_s *)gLogObj;
  if (v21 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = 22;
      _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d",  buf,  0x12u);
    }

    goto LABEL_106;
  }

  *(_DWORD *)buf = 136446466;
  v553 = "nw_socket_set_common_sockopts";
  v554 = 1024;
  *(_DWORD *)v555 = v21;
  v532 = 18;
  char v29 = (char *)_os_log_send_and_compose_impl();
  uu[0] = 16;
  LOBYTE(v556) = 0;
  if (__nwlog_fault(v29, uu, &v556))
  {
    if (uu[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (os_log_s *)gLogObj;
      v31 = uu[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0])) {
        goto LABEL_104;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v21;
      v32 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d";
      goto LABEL_103;
    }

    if (!(_BYTE)v556)
    {
      v30 = (os_log_s *)__nwlog_obj();
      v31 = uu[0];
      if (!os_log_type_enabled(v30, (os_log_type_t)uu[0])) {
        goto LABEL_104;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v21;
      v32 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_103;
    }

    v538 = p_output_handler;
    addrinfo v38 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = (os_log_s *)gLogObj;
    v31 = uu[0];
    uint64_t v39 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu[0]);
    if (v38)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446722;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v21;
        *(_WORD *)&v555[4] = 2082;
        *(void *)&v555[6] = v38;
        _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v38);
      p_output_handler = v538;
      goto LABEL_104;
    }

    p_output_handler = v538;
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = v21;
      v32 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, no backtrace";
LABEL_103:
      _os_log_impl(&dword_181A5C000, v30, v31, v32, buf, 0x12u);
    }
  }

        if (v26) {
          free(v26);
        }
        close(v12);
        goto LABEL_73;
      }

      BOOL v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v19 = (id)gLogObj;
      v71 = 136446466;
      *(void *)v72 = "nw_path_open_in_process_flow_divert_socket";
      *(_WORD *)&v72[8] = 1024;
      *(_DWORD *)&v72[10] = v18;
      BOOL v20 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (buf[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (os_log_s *)(id)gLogObj;
        os_log_type_t v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v71 = 136446466;
          *(void *)v72 = "nw_path_open_in_process_flow_divert_socket";
          *(_WORD *)&v72[8] = 1024;
          *(_DWORD *)&v72[10] = v18;
          _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s Cannot create kernel control socket %{darwin.errno}d",  (uint8_t *)&v71,  0x12u);
        }
      }

      else if (type[0])
      {
        v32 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (os_log_s *)(id)gLogObj;
        __int16 v33 = buf[0];
        __int16 v34 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
        if (v32)
        {
          if (v34)
          {
            v71 = 136446722;
            *(void *)v72 = "nw_path_open_in_process_flow_divert_socket";
            *(_WORD *)&v72[8] = 1024;
            *(_DWORD *)&v72[10] = v18;
            *(_WORD *)&v72[14] = 2082;
            *(void *)&v72[16] = v32;
            _os_log_impl( &dword_181A5C000,  v21,  v33,  "%{public}s Cannot create kernel control socket %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)&v71,  0x1Cu);
          }

          free(v32);
          if (!v20) {
            goto LABEL_73;
          }
          goto LABEL_62;
        }

        if (v34)
        {
          v71 = 136446466;
          *(void *)v72 = "nw_path_open_in_process_flow_divert_socket";
          *(_WORD *)&v72[8] = 1024;
          *(_DWORD *)&v72[10] = v18;
          _os_log_impl( &dword_181A5C000,  v21,  v33,  "%{public}s Cannot create kernel control socket %{darwin.errno}d, no backtrace",  (uint8_t *)&v71,  0x12u);
        }
      }

      else
      {
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v41 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v71 = 136446466;
          *(void *)v72 = "nw_path_open_in_process_flow_divert_socket";
          *(_WORD *)&v72[8] = 1024;
          *(_DWORD *)&v72[10] = v18;
          _os_log_impl( &dword_181A5C000,  v21,  v41,  "%{public}s Cannot create kernel control socket %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)&v71,  0x12u);
        }
      }

      goto LABEL_60;
    }

    __nwlog_obj();
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v71 = 136446210;
    *(void *)v72 = "nw_path_create_bridged_flow_director_locked";
    BOOL v20 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v20, buf, type))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v49 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v71 = 136446210;
          *(void *)v72 = "nw_path_create_bridged_flow_director_locked";
          _os_log_impl(&dword_181A5C000, v21, v49, "%{public}s called with null globals", (uint8_t *)&v71, 0xCu);
        }

      if (v23) {
        free(v23);
      }
      uint64_t v9 = 0LL;
      goto LABEL_11;
    }

    __nwlog_obj();
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)length = 136446210;
    *(void *)&length[4] = "nw_path_copy_resolver_config_for_identifier";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v34 = 0;
    if (__nwlog_fault(v11, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(void *)&length[4] = "nw_path_copy_resolver_config_for_identifier";
          _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s called with null is_config_agent_type_dns(agent)",  length,  0xCu);
        }

    free(v39);
    if (!v29) {
      goto LABEL_88;
    }
    goto LABEL_87;
  }

  v21 = getpid();
  os_log_type_t v22 = v18;
  v23 = *(_DWORD *)(v18[13] + 64LL);

  if (v23 >= 1 && v23 != v21) {
    goto LABEL_10;
  }
  __int16 v34 = v22;
  if (uuid_is_null((const unsigned __int8 *)(v18[13] + 24LL)))
  {
    v25 = 8LL;
    goto LABEL_28;
  }

  v56 = uuid_compare((const unsigned __int8 *)(v18[13] + 24LL), (const unsigned __int8 *)(v18[13] + 8LL));

  if (v56)
  {
LABEL_10:
    os_log_type_t v24 = v22;
    v21 = *(_DWORD *)(v18[13] + 64LL);
    v25 = 24LL;
LABEL_28:

    goto LABEL_29;
  }

  v25 = 8LL;
LABEL_29:
  uint64_t v35 = v22;
  v79 = *(_OWORD *)(v18[13] + v25);

  v77 = 0u;
  v78 = 0u;
  memset(buf, 0, sizeof(buf));
  if (proc_pidinfo(v21, 13, 1uLL, buf, 64) != 64)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v37 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v80 = 136446466;
      *(void *)&v80[4] = "nw_connection_report_symptom_internal_on_nw_queue";
      *(_WORD *)&v80[12] = 1024;
      *(_DWORD *)&v80[14] = v21;
      _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to convert from PID (%d) to process name",  v80,  0x12u);
    }

    __int16 v36 = 0LL;
    if (!v17) {
      goto LABEL_48;
    }
    goto LABEL_35;
  }

  __int16 v36 = (const char *)&buf[16];
  if (v17)
  {
LABEL_35:
    addrinfo v38 = (NWConcrete_nw_path *)v17;
    nw_path_network_is_satisfied_update_reason(v38, 0LL);

    symptom_set_qualifier();
    memset(uu, 0, sizeof(uu));
    v43 = v38;
    *(_OWORD *)uu = *(_OWORD *)v43->flow_registration_id;

    if (!uuid_is_null(uu))
    {
      memset(v80, 0, 37);
      uuid_unparse(uu, v80);
      strlen(v80);
      symptom_set_additional_qualifier();
    }

    v44 = v43;
    v45 = v44[2];

    if (v45)
    {
      v46 = (id *)v45;
      v47 = v46[23];

      if (v47)
      {
        *(void *)v80 = 0LL;
        *(void *)&v80[8] = v80;
        *(void *)&v80[16] = 0x2020000000LL;
        v80[24] = 0;
        v73[0] = MEMORY[0x1895F87A8];
        v73[1] = 3221225472LL;
        v73[2] = __nw_connection_report_symptom_internal_on_nw_queue_block_invoke;
        v73[3] = &unk_189BC7198;
        v73[4] = v80;
        v73[5] = v20;
        nw_proxy_config_enumerate_endpoints(v47, v73);
        _Block_object_dispose(v80, 8);
      }
    }
  }

        goto LABEL_71;
      }

      if (!v44)
      {
        __nwlog_obj();
        BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v42 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_agent_send_error_response";
          _os_log_impl( &dword_181A5C000,  v18,  v42,  "%{public}s called with null error, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_70;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v35 = type;
      __int16 v36 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_agent_send_error_response";
          _os_log_impl(&dword_181A5C000, v18, v35, "%{public}s called with null error, no backtrace", buf, 0xCu);
        }

        goto LABEL_70;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "nw_agent_send_error_response";
        v48 = 2082;
        v49 = (uint64_t)backtrace_string;
        _os_log_impl( &dword_181A5C000,  v18,  v35,  "%{public}s called with null error, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_44;
    }

    if (!v35)
    {
LABEL_72:
      registered_endpoint = 0LL;
      goto LABEL_73;
    }

    if (!v33)
    {
LABEL_72:
      registered_endpoint = 0LL;
      goto LABEL_73;
    }

        if (v36) {
          free(v36);
        }
        *(_DWORD *)(v18 + 184) = 0;
        v41 = 0x200000;
        goto LABEL_73;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v93 = "nw_protocol_http2_frame_input_finalizer";
      id v6 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v90 = 0;
      if (__nwlog_fault(v6, &type, &v90))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v7 = (os_log_s *)__nwlog_obj();
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            uint64_t v9 = "%{public}s called with null stream";
            goto LABEL_41;
          }
        }

        else if (v90)
        {
          os_log_type_t v15 = (char *)__nw_create_backtrace_string();
          v7 = (os_log_s *)__nwlog_obj();
          v8 = type;
          v80 = os_log_type_enabled(v7, type);
          if (v15)
          {
            if (v80)
            {
              *(_DWORD *)buf = 136446466;
              v93 = "nw_protocol_http2_frame_input_finalizer";
              v94 = 2082;
              v95 = v15;
              BOOL v17 = "%{public}s called with null stream, dumping backtrace:%{public}s";
              goto LABEL_19;
            }

            goto LABEL_20;
          }

          if (v80)
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            uint64_t v9 = "%{public}s called with null stream, no backtrace";
            goto LABEL_41;
          }
        }

        else
        {
          v7 = (os_log_s *)__nwlog_obj();
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_protocol_http2_frame_input_finalizer";
            uint64_t v9 = "%{public}s called with null stream, backtrace limit exceeded";
            goto LABEL_41;
          }
        }
      }

        if (v20) {
          free(v20);
        }
        uint64_t v35 = (unsigned __int8 *)v9;
        goto LABEL_79;
      }
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_protocol_test_access_options";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v17 = (os_log_s *)__nwlog_obj();
      BOOL v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      os_log_type_t v19 = "%{public}s called with null definition";
      goto LABEL_60;
    }

    if (!v93)
    {
      BOOL v17 = (os_log_s *)__nwlog_obj();
      BOOL v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      os_log_type_t v19 = "%{public}s called with null definition, backtrace limit exceeded";
      goto LABEL_60;
    }

    BOOL v28 = (char *)__nw_create_backtrace_string();
    BOOL v17 = (os_log_s *)__nwlog_obj();
    BOOL v18 = type;
    char v29 = os_log_type_enabled(v17, type);
    if (!v28)
    {
      if (!v29) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      os_log_type_t v19 = "%{public}s called with null definition, no backtrace";
      goto LABEL_60;
    }

    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v96 = "nw_protocol_test_access_options";
      v97 = 2082;
      v98 = (nw_protocol *)v28;
      v30 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_43:
      _os_log_impl(&dword_181A5C000, v17, v18, v30, buf, 0x16u);
      goto LABEL_44;
    }

    goto LABEL_44;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v96 = "nw_protocol_test_access_options";
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v93 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v17 = (os_log_s *)__nwlog_obj();
    BOOL v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      os_log_type_t v19 = "%{public}s called with null parameters";
      goto LABEL_60;
    }

    goto LABEL_61;
  }

  if (!v93)
  {
    BOOL v17 = (os_log_s *)__nwlog_obj();
    BOOL v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      os_log_type_t v19 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_60;
    }

    goto LABEL_61;
  }

  BOOL v28 = (char *)__nw_create_backtrace_string();
  BOOL v17 = (os_log_s *)__nwlog_obj();
  BOOL v18 = type;
  v83 = os_log_type_enabled(v17, type);
  if (!v28)
  {
    if (v83)
    {
      *(_DWORD *)buf = 136446210;
      v96 = "nw_protocol_test_access_options";
      os_log_type_t v19 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_60;
    }

    goto LABEL_61;
  }

  if (v83)
  {
    *(_DWORD *)buf = 136446466;
    v96 = "nw_protocol_test_access_options";
    v97 = 2082;
    v98 = (nw_protocol *)v28;
    v30 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
    goto LABEL_43;
  }

id nw_proxy_copy_http_connect_definition()
{
  if (nw_proxy_copy_http_connect_definition::onceToken != -1) {
    dispatch_once(&nw_proxy_copy_http_connect_definition::onceToken, &__block_literal_global_92);
  }
  return (id)nw_proxy_copy_http_connect_definition::proxy_definition;
}

NWConcrete_nw_protocol_options *nw_proxy_create_options(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  CFIndex v2 = v1;
  if (v1)
  {
    options = nw_protocol_create_options(v1);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_proxy_create_options";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_proxy_create_options";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null proxy_definition", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_proxy_create_options";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null proxy_definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_proxy_create_options";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null proxy_definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_proxy_create_options";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null proxy_definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A7B514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_proxy_options_set_authentication_challenge_handler(void *a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_proxy_options_set_authentication_challenge_handler_block_invoke;
    v14[3] = &unk_189BC6110;
    id v15 = v4;
    nw_protocol_options_access_handle(v3, v14);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_proxy_options_set_authentication_challenge_handler";
  v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_proxy_options_set_authentication_challenge_handler";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_proxy_options_set_authentication_challenge_handler";
          __int16 v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_proxy_options_set_authentication_challenge_handler";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_proxy_options_set_authentication_challenge_handler";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A7B808( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_proxy_options_set_authentication_challenge_handler_block_invoke(uint64_t a1, void **a2)
{
  id v3 = _Block_copy(*(const void **)(a1 + 32));
  id v4 = *a2;
  *a2 = v3;

  return 1LL;
}

void nw_parameters_add_proxy_options(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_parameters_add_proxy_options";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_add_proxy_options";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v26 = "nw_parameters_add_proxy_options";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v10) {
          goto LABEL_6;
        }
LABEL_41:
        free(v10);
        goto LABEL_6;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_add_proxy_options";
        _os_log_impl(&dword_181A5C000, v11, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_add_proxy_options";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }

id nw_protocol_copy_quic_connection_definition()
{
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55123);
  }
  return (id)nw_protocol_copy_quic_connection_definition::quic_definition;
}

void nw_endpoint_add_alternative(void *a1, void *a2, void *a3)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  id v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    addrinfo v38 = "nw_endpoint_add_alternative";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          addrinfo v38 = "nw_endpoint_add_alternative";
          __int16 v39 = 2082;
          v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_66:
        if (!v13) {
          goto LABEL_16;
        }
LABEL_67:
        free(v13);
        goto LABEL_16;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_65:
    goto LABEL_66;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    addrinfo v38 = "nw_endpoint_add_alternative";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null alternative_endpoint", buf, 0xCu);
      }

      goto LABEL_65;
    }

    if (!v35)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s called with null alternative_endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_65;
    }

    char v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null alternative_endpoint, no backtrace",  buf,  0xCu);
      }

      goto LABEL_65;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      addrinfo v38 = "nw_endpoint_add_alternative";
      __int16 v39 = 2082;
      v40 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v24,  "%{public}s called with null alternative_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_46;
  }

  if (v5 == v6)
  {
    __nwlog_obj();
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    addrinfo v38 = "nw_endpoint_add_alternative";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null (endpoint != alternative_endpoint)",  buf,  0xCu);
      }

      goto LABEL_65;
    }

    if (!v35)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl( &dword_181A5C000,  v14,  v30,  "%{public}s called with null (endpoint != alternative_endpoint), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_65;
    }

    char v23 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v26 = type;
    BOOL v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_endpoint_add_alternative";
        _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null (endpoint != alternative_endpoint), no backtrace",  buf,  0xCu);
      }

      goto LABEL_65;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      addrinfo v38 = "nw_endpoint_add_alternative";
      __int16 v39 = 2082;
      v40 = v23;
      _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null (endpoint != alternative_endpoint), dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (v36) {
      free(v36);
    }
    id v3 = 0;
    CFIndex v2 = 0LL;
    goto LABEL_68;
  }

  id v3 = v1[29];

  if (v3 == 2)
  {
    v135 = v2;
    id v4 = v2;
    id v5 = *((_BYTE *)v4 + 268);

    if ((v5 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v6 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        id v7 = v4;

        id v8 = v7;
        id v9 = *((_BYTE *)v4 + 268);

        if ((v9 & 1) != 0) {
          os_log_type_t v10 = "dry-run ";
        }
        else {
          os_log_type_t v10 = "";
        }
        v134 = v4;
        id v11 = nw_endpoint_handler_copy_endpoint(v8);
        logging_description = nw_endpoint_get_logging_description(v11);
        os_log_type_t v13 = v7 + 168;
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v14;
        os_log_type_t v16 = v14[30];
        else {
          os_log_type_t v17 = off_189BBBBF0[v16];
        }

        BOOL v18 = v15;
        os_log_type_t v19 = v18;
        BOOL v20 = "path";
        switch(v135[29])
        {
          case 0:
            break;
          case 1:
            BOOL v20 = "resolver";
            break;
          case 2:
            BOOL v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            BOOL v20 = "proxy";
            break;
          case 4:
            BOOL v20 = "fallback";
            break;
          case 5:
            BOOL v20 = "transform";
            break;
          default:
            BOOL v20 = "unknown-mode";
            break;
        }

        os_log_type_t v21 = v19;
        os_unfair_lock_lock((os_unfair_lock_t)v21 + 28);
        BOOL v22 = v21[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v21 + 28);

        LODWORD(buf[0]) = 136447746;
        *(void *)((char *)buf + 4) = "nw_endpoint_flow_start_child";
        WORD6(buf[0]) = 2082;
        *(void *)((char *)buf + 14) = v13;
        WORD3(buf[1]) = 2082;
        *((void *)&buf[1] + 1) = v10;
        LOWORD(buf[2]) = 2082;
        *(void *)((char *)&buf[2] + 2) = logging_description;
        WORD5(buf[2]) = 2082;
        *(void *)((char *)&buf[2] + 12) = v17;
        WORD2(buf[3]) = 2082;
        *(void *)((char *)&buf[3] + 6) = v20;
        HIWORD(buf[3]) = 2114;
        *(void *)&v142 = v22;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] creating and starting child handler",  (uint8_t *)buf,  0x48u);

        id v4 = v134;
      }
    }

    char v23 = nw_endpoint_handler_copy_flow(v4);
    v136 = nw_endpoint_handler_copy_endpoint(v4);
    os_log_type_t v24 = v4;
    BOOL v25 = v24[4];

    os_log_type_t v26 = v25;
    BOOL v27 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v26,  0,  0);

    os_log_type_t v28 = (void *)*((void *)v23 + 94);
    if (!v28)
    {
LABEL_184:
      nw_parameters_clear_protocol_stack((void *)v27, 5);
      if ((*((_BYTE *)v23 + 35) & 0x20) == 0)
      {
LABEL_190:
        v107 = v24;
        os_unfair_lock_lock((os_unfair_lock_t)v107 + 28);
        v108 = v107[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v107 + 28);

        has_custom_proxy_configs = nw_parameters_has_custom_proxy_configs((void *)v27);
        should_use_proxy = nw_endpoint_proxy_handler_should_use_proxy(v107, v108, has_custom_proxy_configs);

        if (should_use_proxy)
        {
          if (nw_parameters_get_logging_disabled(v27))
          {
            nw_parameters_set_website_attribution((void *)v27, 0LL);
          }

          else
          {
            v111 = v107;
            v112 = v136;
            v113 = (id)v27;
            v114 = v113;
            if (v112 && v113 && (!*((void *)v112 + 11) || !nw_endpoint_hostname_matches_tracker(v112)))
            {
              v115 = v112;
              v116 = -[nw_endpoint type](v115, "type");

              if (v116 == 2)
              {
                v117 = v115;
                v133 = (const char *)-[nw_endpoint hostname](v117, "hostname");

                if (v133)
                {
                  v143 = 0LL;
                  v142 = 0u;
                  memset(buf, 0, sizeof(buf));
                  nw_parameters_to_ne_app_context(v114, (uint64_t)buf);
                  *(void *)os_log_type_t type = 0LL;
                  v140 = OS_LOG_TYPE_DEFAULT;
                  disposition = ne_tracker_get_disposition();
                  if (disposition != 1)
                  {
                    nw_parameters_set_is_known_tracker(v114, 1);
                    nw_endpoint_set_tracker_owner(v117, *(const char **)type);
                    nw_endpoint_set_can_block_request(v117, v140);
                    nw_endpoint_set_known_tracker_name(v117, v133);
                    nw_endpoint_set_is_approved_app_domain(v117, disposition == 3);
                  }

                  if (*(void *)type) {
                    free(*(void **)type);
                  }
                }
              }
            }
          }
        }

        inner = nw_endpoint_handler_create_inner(v136, (void *)v27, nw_endpoint_flow_receive_report, v107, v107, 0, 0);
        v120 = (void *)*((void *)v23 + 116);
        *((void *)v23 + 116) = inner;

        *((_DWORD *)v107 + 20) = 786435;
        nw_endpoint_handler_report(v107, 0LL, (_WORD *)v107 + 40, 0LL);
        nw_endpoint_handler_start(*((void **)v23 + 116));

        v55 = v135;
        goto LABEL_205;
      }

      nw_parameters_set_use_enhanced_privacy_mode((void *)v27, 0);
      v105 = nw_parameters_copy_context(v26);
      if (nw_context_get_privacy_level(v105) != 4)
      {
LABEL_189:

        goto LABEL_190;
      }

      v106 = (id)v27;
      if (v106)
      {
        v106[12] |= 0x100000000000uLL;
LABEL_188:

        goto LABEL_189;
      }

      __nwlog_obj();
      v121 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_parameters_set_inherited_from_silent_context";
      v122 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v140 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v122, type, &v140))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v124 = type[0];
          if (os_log_type_enabled(v123, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_parameters_set_inherited_from_silent_context";
            _os_log_impl(&dword_181A5C000, v123, v124, "%{public}s called with null parameters", (uint8_t *)buf, 0xCu);
          }
        }

        else if (v140)
        {
          v125 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v126 = type[0];
          v127 = os_log_type_enabled(v123, type[0]);
          if (v125)
          {
            if (v127)
            {
              LODWORD(buf[0]) = 136446466;
              *(void *)((char *)buf + 4) = "nw_parameters_set_inherited_from_silent_context";
              WORD6(buf[0]) = 2082;
              *(void *)((char *)buf + 14) = v125;
              _os_log_impl( &dword_181A5C000,  v123,  v126,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
            }

            free(v125);
            goto LABEL_222;
          }

          if (v127)
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_parameters_set_inherited_from_silent_context";
            _os_log_impl( &dword_181A5C000,  v123,  v126,  "%{public}s called with null parameters, no backtrace",  (uint8_t *)buf,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v128 = type[0];
          if (os_log_type_enabled(v123, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_parameters_set_inherited_from_silent_context";
            _os_log_impl( &dword_181A5C000,  v123,  v128,  "%{public}s called with null parameters, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
          }
        }
      }

        protocol_handler = nw_channel_get_protocol_handler(*((void *)v6 + 113));
        if (protocol_handler)
        {
          if (a2)
          {
            v64 = protocol_handler;
            if (protocol_handler != a2)
            {
              v65 = *(void **)(protocol_handler + 24);
              if (v65 && *v65)
              {
                v66 = nw_protocol_add_input_handler(protocol_handler, a2);
                os_log_type_t v15 = v66;
                if (a3 != 1 && (_DWORD)v66) {
                  os_log_type_t v15 = nw_channel_set_path_flow_registration(*((void *)v6 + 113), v110, *((void **)v6 + 104));
                }
                goto LABEL_100;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v71 = (os_log_s *)(id)gLogObj;
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v117 = "nw_protocol_utilities_add_input_handler";
                v118 = 2048;
                v119 = v64;
                _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid",  buf,  0x16u);
              }

LABEL_99:
              os_log_type_t v15 = 0LL;
LABEL_100:

              goto LABEL_101;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v67 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            v117 = "nw_protocol_utilities_add_input_handler";
            v118 = 2048;
            v119 = a2;
            v68 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v114 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v69 = (os_log_s *)(id)gLogObj;
              v70 = type;
              if (os_log_type_enabled(v69, type))
              {
                *(_DWORD *)buf = 136446466;
                v117 = "nw_protocol_utilities_add_input_handler";
                v118 = 2048;
                v119 = a2;
                _os_log_impl(&dword_181A5C000, v69, v70, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
              }
            }

            else
            {
              if (v114)
              {
                v72 = a2;
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v75 = type;
                v76 = os_log_type_enabled(v74, type);
                if (backtrace_string)
                {
                  if (v76)
                  {
                    *(_DWORD *)buf = 136446722;
                    v117 = "nw_protocol_utilities_add_input_handler";
                    v118 = 2048;
                    v119 = v72;
                    v120 = 2082;
                    v121 = backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
                  }

                  free(backtrace_string);
                  if (!v68) {
                    goto LABEL_99;
                  }
                  goto LABEL_98;
                }

                if (v76)
                {
                  *(_DWORD *)buf = 136446466;
                  v117 = "nw_protocol_utilities_add_input_handler";
                  v118 = 2048;
                  v119 = v72;
                  _os_log_impl( &dword_181A5C000,  v74,  v75,  "%{public}s Cannot add input handler %p to itself, no backtrace",  buf,  0x16u);
                }

LABEL_97:
                if (!v68) {
                  goto LABEL_99;
                }
LABEL_98:
                free(v68);
                goto LABEL_99;
              }

              __nwlog_obj();
              v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v82 = type;
              if (os_log_type_enabled(v69, type))
              {
                *(_DWORD *)buf = 136446466;
                v117 = "nw_protocol_utilities_add_input_handler";
                v118 = 2048;
                v119 = a2;
                _os_log_impl( &dword_181A5C000,  v69,  v82,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  buf,  0x16u);
              }
            }

            goto LABEL_97;
          }

          __nwlog_obj();
          v95 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v117 = "nw_protocol_utilities_add_input_handler";
          v92 = (void *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v114 = 0;
          if (!__nwlog_fault((const char *)v92, &type, &v114))
          {
LABEL_143:
            if (v92) {
              free(v92);
            }
            goto LABEL_99;
          }

          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v93 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v96 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              v117 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_181A5C000, v93, v96, "%{public}s called with null input_protocol", buf, 0xCu);
            }

LABEL_66:
      if (v28) {
        free(v28);
      }
      goto LABEL_68;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v39 = buf[0];
      if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v49 = 136446210;
        *(void *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl( &dword_181A5C000,  v29,  v39,  "%{public}s called with null return_stats, backtrace limit exceeded",  v49,  0xCu);
      }

      goto LABEL_65;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v36 = buf[0];
    v37 = os_log_type_enabled(v29, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)v49 = 136446210;
        *(void *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_181A5C000, v29, v36, "%{public}s called with null return_stats, no backtrace", v49, 0xCu);
      }

      goto LABEL_65;
    }

    if (v37)
    {
      *(_DWORD *)v49 = 136446466;
      *(void *)&v49[4] = "nw_path_fillout_route_stats";
      *(_WORD *)&v49[12] = 2082;
      *(void *)&v49[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v29,  v36,  "%{public}s called with null return_stats, dumping backtrace:%{public}s",  v49,  0x16u);
    }

  if (v49) {
    free(v49);
  }
LABEL_43:
}

    if (v13) {
      free(v13);
    }
    id v7 = 1LL;
    goto LABEL_9;
  }

  if ((*((_WORD *)v5 + 44) & 0x60) != 0)
  {
    id v7 = 3LL;
  }

  else if ((*((_BYTE *)v5 + 346) & 0xE) != 0)
  {
    id v7 = 2LL;
  }

  else
  {
    id v7 = 1LL;
  }

  __break(1u);
LABEL_66:
  __break(1u);
LABEL_67:
  __break(1u);
LABEL_68:
  __break(1u);
LABEL_69:
  __break(1u);
LABEL_70:
  uint64_t result = sub_18264F5C4();
  __break(1u);
  return result;
}

    free(v35);
    goto LABEL_95;
  }

  BOOL v25 = (os_log_s *)__nwlog_obj();
  os_log_type_t v26 = v49[0];
  if (os_log_type_enabled(v25, v49[0]))
  {
    *(_DWORD *)buf = 136446210;
    v56 = "nw_protocol_udp_finalize_output_frames";
    BOOL v27 = "%{public}s called with null protocol";
LABEL_94:
    _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0xCu);
  }

    *(void *)uint64_t result = *(void *)v14;
    goto LABEL_66;
  }

  free(v19);
  if (v13) {
LABEL_93:
  }
    free(v13);
}

    return 0LL;
  }

  if ((v14 & 0x40) == 0 && a3)
  {
    __nwlog_obj();
    BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_ws_validate_frame";
      v44 = 2082;
      v45 = (char *)a1 + 227;
      os_log_type_t v19 = "%{public}s %{public}s received compressed data without correct state";
      goto LABEL_64;
    }

    goto LABEL_65;
  }

  if ((a2 & 1) == 0) {
    *((_DWORD *)a1 + 42) = a4;
  }
LABEL_68:
  os_log_type_t v26 = (v14 & 4) == 0;
  BOOL v27 = a5 ^ 1;
LABEL_74:
  if (!v26 && a7 && !a5 || v26 && (a7 & 1) == 0 && !a5) {
    return 0LL;
  }
  return v27 | v26 & a7 ^ 1u;
}

    if (v14) {
      free(v14);
    }
    id v7 = 0LL;
    goto LABEL_9;
  }

  __nwlog_obj();
  id v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v34 = "nw_framer_protocol_get_remote_endpoint";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (__nwlog_fault(v10, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_framer_protocol_get_remote_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v31)
    {
      BOOL v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v11, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          id v34 = "nw_framer_protocol_get_remote_endpoint";
          char v35 = 2082;
          __int16 v36 = v20;
          _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v20);
        goto LABEL_56;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_framer_protocol_get_remote_endpoint";
        _os_log_impl(&dword_181A5C000, v11, v21, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v34 = "nw_framer_protocol_get_remote_endpoint";
        _os_log_impl( &dword_181A5C000,  v11,  v28,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_66:
  if ((v9 & 1) == 0)
  {
    nw_resolver_update_flags_locked( *(NWConcrete_nw_resolver **)(a1 + 40),  *(NWConcrete_nw_resolver_service **)(a1 + 32),  2,  0,  a2,  1,  0);
    os_log_type_t v29 = *(void **)(a1 + 40);
    os_log_type_t v28 = *(void **)(a1 + 48);
    priority = nw_resolver_service_get_priority(*(NWConcrete_nw_resolver_service **)(a1 + 32));
    v31 = nw_resolver_service_copy_ech_config(*(NWConcrete_nw_resolver_service **)(a1 + 32));
    nw_resolver_insert_address(v29, v28, (const sockaddr *)&__dst, priority, v31);

    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
  }

  return 1LL;
}

  if (v19) {
    free(v19);
  }
  os_log_type_t v16 = 0LL;
LABEL_18:

  return v16;
}

        free(v18);
        goto LABEL_66;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_data_transfer_report_create_from_dictionary";
        _os_log_impl( &dword_181A5C000,  v19,  v31,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_data_transfer_report_create_from_dictionary";
        _os_log_impl( &dword_181A5C000,  v19,  v37,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), backtrace limit exceeded",  buf,  0xCu);
      }
    }

    free(backtrace_string);
  }

    _Block_object_dispose(&v91, 8);

    goto LABEL_66;
  }

  if (!nw_parameters_get_logging_disabled(*((void *)v7 + 7)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    v52 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      v53 = *((_DWORD *)v7 + 42);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_reply";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v53;
      _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] Cannot reply on a failed or cancelled group",  buf,  0x12u);
    }
  }

    free(backtrace_string);
    goto LABEL_42;
  }

  switch(v3[2])
  {
    case 0:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_group_descriptor_allows_endpoint";
      id v7 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        id v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_group_descriptor_allows_endpoint";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s Invalid group descriptor type", buf, 0xCu);
        }

        goto LABEL_41;
      }

      if (!v37)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_group_descriptor_allows_endpoint";
          _os_log_impl( &dword_181A5C000,  v8,  v24,  "%{public}s Invalid group descriptor type, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_41;
      }

      os_log_type_t v21 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (os_log_s *)(id)gLogObj;
      BOOL v22 = type;
      char v23 = os_log_type_enabled(v8, type);
      if (!v21)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_group_descriptor_allows_endpoint";
          _os_log_impl(&dword_181A5C000, v8, v22, "%{public}s Invalid group descriptor type, no backtrace", buf, 0xCu);
        }

        goto LABEL_41;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v40 = "nw_group_descriptor_allows_endpoint";
        uint64_t v41 = 2082;
        v42 = v21;
        _os_log_impl( &dword_181A5C000,  v8,  v22,  "%{public}s Invalid group descriptor type, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v21);
      if (v7) {
        goto LABEL_43;
      }
      goto LABEL_44;
    case 1:
      os_log_type_t v10 = v4;
      id v11 = [v10 type];

      if (v11 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_group_descriptor_allows_endpoint";
          uint64_t v41 = 2112;
          v42 = (char *)v10;
          _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Endpoint %@ is not of type address",  buf,  0x16u);
        }

        goto LABEL_15;
      }

      address = nw_endpoint_get_address((nw_endpoint_t)v10);
      sa_family = address->sa_family;
      if (sa_family == 2)
      {
        if ((*(_DWORD *)&address->sa_data[2] & 0xF0) != 0xE0) {
          goto LABEL_13;
        }
      }

      else if (sa_family != 30 || address->sa_data[6] != 255)
      {
LABEL_13:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_group_descriptor_allows_endpoint";
          uint64_t v41 = 2112;
          v42 = (char *)v10;
          _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s Endpoint %@ is not a multicast address",  buf,  0x16u);
        }

    goto LABEL_66;
  }

  if (a2)
  {
    id v5 = v3[30];
    if (v5 && *(_DWORD *)(v5 + 40))
    {
      node = nw_hash_table_get_node(v5, a2, *(unsigned int *)(*(void *)(*((void *)v4 + 1) + 80LL) + 256LL));
      if (node)
      {
        id v7 = node;
        id v8 = v4[405];
        if (*(void *)(node + 16))
        {
          if ((v8 & 0x80000000) == 0 && gLogDatapath)
          {
            __nwlog_obj();
            os_log_type_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
              BOOL v27 = *(char **)(v7 + 32);
              *(_DWORD *)buf = 136447234;
              v37 = "nw_protocol_instance_clear_flow_for_key";
              addrinfo v38 = 2082;
              __int16 v39 = v4 + 407;
              v40 = 2080;
              uint64_t v41 = " ";
              v42 = 2048;
              v43 = a2;
              v44 = 2048;
              v45 = v27;
              _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRemoving custom flow mapping for key %p, flow %llx",  buf,  0x34u);
            }
          }

          nw_hash_table_remove_node(*((void *)v4 + 30), v7);
          goto LABEL_14;
        }

        if (v8 < 0) {
          goto LABEL_14;
        }
        __nwlog_obj();
        BOOL v22 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446978;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        addrinfo v38 = 2082;
        __int16 v39 = v4 + 407;
        v40 = 2080;
        uint64_t v41 = " ";
        v42 = 2048;
        v43 = v7;
        char v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        id v34 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446978;
            v37 = "nw_protocol_instance_clear_flow_for_key";
            addrinfo v38 = 2082;
            __int16 v39 = v4 + 407;
            v40 = 2080;
            uint64_t v41 = " ";
            v42 = 2048;
            v43 = v7;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s %{public}s%sobject not present from node %p",  buf,  0x2Au);
          }
        }

        else if (v34)
        {
          os_log_type_t v30 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v31 = type;
          id v32 = os_log_type_enabled(v24, type);
          if (v30)
          {
            if (v32)
            {
              *(_DWORD *)buf = 136447234;
              v37 = "nw_protocol_instance_clear_flow_for_key";
              addrinfo v38 = 2082;
              __int16 v39 = v4 + 407;
              v40 = 2080;
              uint64_t v41 = " ";
              v42 = 2048;
              v43 = v7;
              v44 = 2082;
              v45 = v30;
              _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s %{public}s%sobject not present from node %p, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v30);
            goto LABEL_74;
          }

          if (v32)
          {
            *(_DWORD *)buf = 136446978;
            v37 = "nw_protocol_instance_clear_flow_for_key";
            addrinfo v38 = 2082;
            __int16 v39 = v4 + 407;
            v40 = 2080;
            uint64_t v41 = " ";
            v42 = 2048;
            v43 = v7;
            _os_log_impl( &dword_181A5C000,  v24,  v31,  "%{public}s %{public}s%sobject not present from node %p, no backtrace",  buf,  0x2Au);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v33 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446978;
            v37 = "nw_protocol_instance_clear_flow_for_key";
            addrinfo v38 = 2082;
            __int16 v39 = v4 + 407;
            v40 = 2080;
            uint64_t v41 = " ";
            v42 = 2048;
            v43 = v7;
            _os_log_impl( &dword_181A5C000,  v24,  v33,  "%{public}s %{public}s%sobject not present from node %p, backtrace limit exceeded",  buf,  0x2Au);
          }
        }

LABEL_74:
        if (v23) {
          free(v23);
        }
        goto LABEL_14;
      }

      if (v4[405] < 0) {
        goto LABEL_14;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        addrinfo v38 = 2082;
        __int16 v39 = v4 + 407;
        v40 = 2080;
        uint64_t v41 = " ";
        v42 = 2048;
        v43 = a2;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNo flow found in custom flow mapping table for key %p",  buf,  0x2Au);
      }
    }

    else
    {
      if (v4[405] < 0) {
        goto LABEL_14;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        addrinfo v38 = 2082;
        __int16 v39 = v4 + 407;
        v40 = 2080;
        uint64_t v41 = " ";
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFlow mapping table is empty",  buf,  0x20u);
      }
    }

    goto LABEL_14;
  }

  __nwlog_obj();
  os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_protocol_instance_clear_flow_for_key";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  id v34 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null key", buf, 0xCu);
    }

    goto LABEL_65;
  }

  if (!v34)
  {
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v29 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_181A5C000, v12, v29, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_65;
  }

  os_log_type_t v19 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v20 = type;
  os_log_type_t v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_181A5C000, v12, v20, "%{public}s called with null key, no backtrace", buf, 0xCu);
    }

    goto LABEL_65;
  }

  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v37 = "nw_protocol_instance_clear_flow_for_key";
    addrinfo v38 = 2082;
    __int16 v39 = v19;
    _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s called with null key, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v19);
  if (v11) {
    goto LABEL_67;
  }
LABEL_14:
}

  if (v8) {
    free(v8);
  }
}

    free(v33);
    if (!v23) {
      goto LABEL_35;
    }
    goto LABEL_90;
  }

  os_log_type_t v10 = *((_WORD *)v8 + 102);
  if ((v10 & 1) != 0)
  {
    if ((*((_WORD *)v8 + 102) & 0x100) == 0
      || !g_channel_check_validity
      || g_channel_check_validity(v8, *((void *)v8 + 11)))
    {
      os_log_type_t v13 = *(void **)(v9 + 112);
      if (v13) {
        free(v13);
      }
    }
  }

  else
  {
    id v11 = *((void *)v8 + 13);
    if (v11)
    {
      if ((*((_WORD *)v8 + 102) & 0x100) != 0
        && g_channel_check_validity
        && !g_channel_check_validity(v8, *((void *)v8 + 11)))
      {
        os_log_type_t v12 = 0LL;
      }

      else
      {
        os_log_type_t v12 = *(void *)(v9 + 112);
      }

      nw_mem_buffer_free(v11, v12);
    }

    else if ((v10 & 2) != 0)
    {
      nw_frame_set_external_data((uint64_t)v8, 0LL, 0LL);
    }
  }

  nw_frame_reset(v9, 0LL, 0, 0LL, 0LL);
  *(_WORD *)(v9 + 204) &= ~1u;
  os_log_type_t v14 = *(void **)(v9 + 24);
  os_log_type_t v15 = (void *)(v9 + 16);
  os_log_type_t v16 = *(void *)(v9 + 16);
  if (v16)
  {
    *(void *)(v16 + 24) = v14;
    os_log_type_t v14 = *(void **)(v9 + 24);
  }

  else
  {
    *(void *)(a4 + 8) = v14;
  }

  os_log_type_t v17 = 0LL;
  *os_log_type_t v14 = v16;
  char *v15 = 0LL;
  *(void *)(v9 + 24) = 0LL;
  if ((*(_WORD *)(v9 + 204) & 4) != 0)
  {
    os_log_type_t v17 = *(void (***)(void, void))(v9 + 216);
    if (v17) {
      *(void *)(v9 + 216) = 0LL;
    }
  }

  BOOL v18 = *((unsigned int *)v7 + 40);
  if (v18 > 0x27)
  {

    if (!v17) {
      goto LABEL_34;
    }
  }

  else
  {
    *(void *)(v9 + 16) = 0LL;
    os_log_type_t v19 = (uint64_t *)v7[22];
    *(void *)(v9 + 24) = v19;
    const char *v19 = v9;
    v7[22] = v15;
    BOOL v20 = v18 + 1;
    os_log_type_t v21 = v20 << 31 >> 31;
    *((_DWORD *)v7 + 40) = v20;
    if (v21 != v20 || v21 < 0)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        addrinfo v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        {
          __int16 v39 = *((unsigned int *)v7 + 40);
          *(_DWORD *)buf = 136446978;
          v46 = "nw_protocol_data_finalizer";
          v47 = 2082;
          v48 = "instance->empty_frame_pool_count";
          v49 = 2048;
          v50 = 1LL;
          v51 = 2048;
          v52 = v39;
          _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
        }
      }

      *((_DWORD *)v7 + 40) = -1;
      if (!v17) {
        goto LABEL_34;
      }
    }

    else if (!v17)
    {
      goto LABEL_34;
    }
  }

  v17[2](v17, a3);
LABEL_34:

LABEL_35:
}

      free(backtrace_string);
      goto LABEL_75;
    }

    addrinfo v38 = (os_log_s *)__nwlog_obj();
    domain = error.domain;
    if (!os_log_type_enabled(v38, error.domain)) {
      goto LABEL_75;
    }
    *(_DWORD *)buf = 136446210;
    v59 = "nw_http_authentication_apply_authorization";
    v40 = "%{public}s called with null protocol";
LABEL_74:
    _os_log_impl(&dword_181A5C000, v38, domain, v40, buf, 0xCu);
LABEL_75:
    if (v37) {
      free(v37);
    }
    return 0LL;
  }

  id v9 = *(void *)(a1 + 40);
  if (!v9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v59 = "nw_http_authentication_apply_authorization";
    v37 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(error.domain) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(error.domain) == 17)
    {
      addrinfo v38 = (os_log_s *)__nwlog_obj();
      domain = error.domain;
      if (!os_log_type_enabled(v38, error.domain)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      v59 = "nw_http_authentication_apply_authorization";
      v40 = "%{public}s called with null http_authentication";
      goto LABEL_74;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      addrinfo v38 = (os_log_s *)__nwlog_obj();
      domain = error.domain;
      if (!os_log_type_enabled(v38, error.domain)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      v59 = "nw_http_authentication_apply_authorization";
      v40 = "%{public}s called with null http_authentication, backtrace limit exceeded";
      goto LABEL_74;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    addrinfo v38 = (os_log_s *)__nwlog_obj();
    domain = error.domain;
    v44 = os_log_type_enabled(v38, error.domain);
    if (backtrace_string)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        v59 = "nw_http_authentication_apply_authorization";
        v60 = 2082;
        v61 = (CFIndex)backtrace_string;
        v43 = "%{public}s called with null http_authentication, dumping backtrace:%{public}s";
        goto LABEL_64;
      }

      goto LABEL_65;
    }

    if (!v44) {
      goto LABEL_75;
    }
    *(_DWORD *)buf = 136446210;
    v59 = "nw_http_authentication_apply_authorization";
    v40 = "%{public}s called with null http_authentication, no backtrace";
    goto LABEL_74;
  }

  if (a4 != 8)
  {
    if (!a3 || (v17 = a3, BOOL v18 = v17[2], v17, !v18))
    {
      os_log_type_t v19 = a7 ? 256 : 0;
      *(_WORD *)(v9 + 1062) = *(_WORD *)(v9 + 1062) & 0xFEFF | v19;
      if (a4 != 4)
      {
        uint64_t result = 1LL;
        if ((*(_BYTE *)(v9 + 198) & 1) == 0 && gLogDatapath)
        {
          id v33 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v59 = "nw_http_authentication_apply_authorization";
            v60 = 2082;
            v61 = v9 + 114;
            v62 = 2080;
            v63 = " ";
            _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%scredential or username was NULL, resending the request without authentication",  buf,  0x20u);
          }

          return 1LL;
        }

        return result;
      }
    }
  }

  _CFHTTPAuthenticationSetPreferredScheme();
  error.domain = 0LL;
  *(void *)&error.error = 0LL;
  if (CFHTTPAuthenticationIsValid(a2, &error))
  {
    if (a4 == 8)
    {
      if ((a6 & 1) == 0)
      {
        nw_http_authentication_ask_pat_for_creds(a1, a8);
        return 1LL;
      }

      if (nw_http_authentication_apply_credentials(*(__CFHTTPMessage **)(v9 + 912), a2, a3))
      {
        id v32 = (__CFHTTPMessage **)(v9 + 912);
        goto LABEL_37;
      }
    }

    else
    {
      if (a4 == 4)
      {
        NegotiateHeaderForRequest = (const __CFString *)_CFHTTPAuthenticationCreateNegotiateHeaderForRequest();
        if (NegotiateHeaderForRequest)
        {
LABEL_14:
          v53[0] = MEMORY[0x1895F87A8];
          v53[1] = 0x40000000LL;
          v53[2] = ___ZL42nw_http_authentication_apply_authorizationP11nw_protocolP21_CFHTTPAuthenticationP28nw_authentication_credential24nw_authentication_type_tbbbU13block_pointerFvP20nw_protocol_metadatabbE_block_invoke;
          v53[3] = &__block_descriptor_tmp_75;
          v53[4] = v9;
          v54 = a6;
          nw_utilities_get_c_string_from_cfstring(NegotiateHeaderForRequest, 0x201u, v53);
          if ((a4 & 0xFFFFFFFE) == 4 || !a5)
          {
LABEL_41:
            CFRelease(NegotiateHeaderForRequest);
            return 1LL;
          }

          os_log_type_t v21 = a3;
          if (v21)
          {
            BOOL v22 = v21;
            char v23 = v21[3] == 0;

            if (!v23)
            {
              os_log_type_t v24 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_authentication_credential_cache_entry);
              nw_authentication_credential_cache_entry_set_http_authentication(v24, a2);
              nw_authentication_credential_cache_entry_set_credential((uint64_t)v24, v22);
              nw_authentication_credential_cache_entry_set_for_proxy((uint64_t)v24, a6);
              BOOL v25 = *(void *)(v9 + 704);
              if (v25 && *(void *)(v25 + 24) - *(void *)(v25 + 16) >= 0x319uLL)
              {
                os_log_type_t v26 = (char *)*(unsigned __int8 *)(v9 + 1061);
                *(_BYTE *)(v9 + 1061) = (_BYTE)v26 + 1;
                nw_array_set_object_at_index(v25, v24, v26);
              }

              else
              {
                nw_array_append(v25, v24);
              }

              if (v24) {
                os_release(v24);
              }
            }

            goto LABEL_41;
          }

          __nwlog_obj();
          v45 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v59 = "nw_authentication_credential_get_persistence";
          v46 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v56 = 0;
          if (__nwlog_fault(v46, &type, &v56))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v48 = type;
              if (os_log_type_enabled(v47, type))
              {
                *(_DWORD *)buf = 136446210;
                v59 = "nw_authentication_credential_get_persistence";
                _os_log_impl(&dword_181A5C000, v47, v48, "%{public}s called with null credential", buf, 0xCu);
              }
            }

            else if (v56)
            {
              v49 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v50 = type;
              v51 = os_log_type_enabled(v47, type);
              if (v49)
              {
                if (v51)
                {
                  *(_DWORD *)buf = 136446466;
                  v59 = "nw_authentication_credential_get_persistence";
                  v60 = 2082;
                  v61 = (CFIndex)v49;
                  _os_log_impl( &dword_181A5C000,  v47,  v50,  "%{public}s called with null credential, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v49);
                goto LABEL_95;
              }

              if (v51)
              {
                *(_DWORD *)buf = 136446210;
                v59 = "nw_authentication_credential_get_persistence";
                _os_log_impl( &dword_181A5C000,  v47,  v50,  "%{public}s called with null credential, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v52 = type;
              if (os_log_type_enabled(v47, type))
              {
                *(_DWORD *)buf = 136446210;
                v59 = "nw_authentication_credential_get_persistence";
                _os_log_impl( &dword_181A5C000,  v47,  v52,  "%{public}s called with null credential, backtrace limit exceeded",  buf,  0xCu);
              }
            }
          }

    BOOL v18 = v21;
    os_log_type_t v19 = v22;
    BOOL v20 = 12;
    goto LABEL_22;
  }

  if (a1->default_input_handler != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    default_input_handler = a1->default_input_handler;
    *(_DWORD *)buf = 136446722;
    v31 = "nw_protocol_default_replace_input_handler";
    id v32 = 2048;
    id v33 = default_input_handler;
    id v34 = 2048;
    char v35 = a2;
    id v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v28 = 0;
    if (__nwlog_fault(v7, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)gLogObj;
        id v9 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          os_log_type_t v10 = a1->default_input_handler;
          *(_DWORD *)buf = 136446722;
          v31 = "nw_protocol_default_replace_input_handler";
          id v32 = 2048;
          id v33 = v10;
          id v34 = 2048;
          char v35 = a2;
          id v11 = "%{public}s Old input handler does not match (%p != %p)";
LABEL_21:
          BOOL v18 = v8;
          os_log_type_t v19 = v9;
          BOOL v20 = 32;
LABEL_22:
          _os_log_impl(&dword_181A5C000, v18, v19, v11, buf, v20);
        }
      }

      else if (v28)
      {
        os_log_type_t v13 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)gLogObj;
        id v9 = type;
        os_log_type_t v14 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v13)
        {
          if (v14)
          {
            os_log_type_t v15 = a1->default_input_handler;
            *(_DWORD *)buf = 136446978;
            v31 = "nw_protocol_default_replace_input_handler";
            id v32 = 2048;
            id v33 = v15;
            id v34 = 2048;
            char v35 = a2;
            __int16 v36 = 2082;
            v37 = v13;
            _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s Old input handler does not match (%p != %p), dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v13);
          goto LABEL_23;
        }

        if (v14)
        {
          os_log_type_t v17 = a1->default_input_handler;
          *(_DWORD *)buf = 136446722;
          v31 = "nw_protocol_default_replace_input_handler";
          id v32 = 2048;
          id v33 = v17;
          id v34 = 2048;
          char v35 = a2;
          id v11 = "%{public}s Old input handler does not match (%p != %p), no backtrace";
          goto LABEL_21;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)gLogObj;
        id v9 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          os_log_type_t v16 = a1->default_input_handler;
          *(_DWORD *)buf = 136446722;
          v31 = "nw_protocol_default_replace_input_handler";
          id v32 = 2048;
          id v33 = v16;
          id v34 = 2048;
          char v35 = a2;
          id v11 = "%{public}s Old input handler does not match (%p != %p), backtrace limit exceeded";
          goto LABEL_21;
        }
      }
    }

    goto LABEL_66;
  }

  id v6 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_listener);
  id v7 = v5;
  id v8 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v7,  0,  0);

  id v9 = -[NWConcrete_nw_listener initWithParameters:multicastDescriptor:](v6, (void *)v8, 0LL);
  if (v9)
  {
    objc_storeStrong((id *)v9 + 6, connection);
    os_log_type_t v10 = v7;
    id v11 = *(id *)(*((void *)v10 + 13) + 136LL);

    v39[0] = MEMORY[0x1895F87A8];
    v39[1] = 3221225472LL;
    v39[2] = __nw_listener_create_with_connection_block_invoke;
    v39[3] = &unk_189BC93A0;
    os_log_type_t v12 = v4;
    v40 = v12;
    nw_queue_context_async(v11, v39);

    os_log_type_t v13 = *((void *)v9 + 2);
    if (v13 && !nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      os_log_type_t v14 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v44 = "nw_listener_create_with_connection";
        v45 = 2082;
        v46 = v9 + 42;
        v47 = 2114;
        v48 = v12;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEBUG,  "%{public}s [%{public}s] created from connection: %{public}@",  buf,  0x20u);
      }
    }

    os_log_type_t v15 = v9;

    goto LABEL_31;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v16 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v44 = "nw_listener_create_with_connection";
  os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v41 = 0;
  if (__nwlog_fault(v17, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v18 = (os_log_s *)(id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_listener_create_with_connection";
        _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s [nw_listener initWithParameters:] failed", buf, 0xCu);
      }
    }

    else if (v41)
    {
      BOOL v20 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v18 = (os_log_s *)(id)gLogObj;
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v18, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_listener_create_with_connection";
          v45 = 2082;
          v46 = v20;
          _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s [nw_listener initWithParameters:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v20);
        if (!v17) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_listener_create_with_connection";
        _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s [nw_listener initWithParameters:] failed, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v18 = (os_log_s *)(id)gLogObj;
      char v23 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_listener_create_with_connection";
        _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s [nw_listener initWithParameters:] failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v17) {
LABEL_30:
  }
    free(v17);
LABEL_31:

LABEL_32:
  return (nw_listener_t)v9;
}

    if (!v7) {
      return;
    }
    goto LABEL_66;
  }

  id v11 = *(void *)(v2 + 16);
  if (v3 > 1)
  {
    if (v11 && !nw_path_parameters_get_logging_disabled(*(void *)(v11 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      os_log_type_t v16 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v17 = nw_listener_get_id_string(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446466;
        uint64_t v41 = "nw_listener_set_advertise_endpoints_block_invoke";
        v42 = 2082;
        v43 = v17;
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s [%{public}s] Ignoring, listener is no longer ready",  buf,  0x16u);
      }
    }

    return;
  }

  if (!v11 || nw_path_parameters_get_logging_disabled(*(void *)(v11 + 104))) {
    return;
  }
  if (__nwlog_listener_log::onceToken != -1) {
    dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
  }
  os_log_type_t v12 = (id)glistenerLogObj;
  os_log_type_t v13 = nw_listener_get_id_string(*(void **)(a1 + 32));
  *(_DWORD *)buf = 136446466;
  uint64_t v41 = "nw_listener_set_advertise_endpoints_block_invoke";
  v42 = 2082;
  v43 = v13;
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  addrinfo v38 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
    }
    id v8 = (os_log_s *)(id)glistenerLogObj;
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v8, type))
    {
      os_log_type_t v15 = nw_listener_get_id_string(*(void **)(a1 + 32));
      *(_DWORD *)buf = 136446466;
      uint64_t v41 = "nw_listener_set_advertise_endpoints_block_invoke";
      v42 = 2082;
      v43 = v15;
      _os_log_impl(&dword_181A5C000, v8, v14, "%{public}s [%{public}s] Called before listener was ready", buf, 0x16u);
    }

    goto LABEL_64;
  }

  if (!v38)
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
    }
    id v8 = (os_log_s *)(id)glistenerLogObj;
    v31 = type;
    if (os_log_type_enabled(v8, type))
    {
      id v32 = nw_listener_get_id_string(*(void **)(a1 + 32));
      *(_DWORD *)buf = 136446466;
      uint64_t v41 = "nw_listener_set_advertise_endpoints_block_invoke";
      v42 = 2082;
      v43 = v32;
      _os_log_impl( &dword_181A5C000,  v8,  v31,  "%{public}s [%{public}s] Called before listener was ready, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_64;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  if (__nwlog_listener_log::onceToken != -1) {
    dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
  }
  id v8 = (os_log_s *)(id)glistenerLogObj;
  os_log_type_t v26 = type;
  BOOL v27 = os_log_type_enabled(v8, type);
  if (!backtrace_string)
  {
    if (v27)
    {
      id v34 = nw_listener_get_id_string(*(void **)(a1 + 32));
      *(_DWORD *)buf = 136446466;
      uint64_t v41 = "nw_listener_set_advertise_endpoints_block_invoke";
      v42 = 2082;
      v43 = v34;
      _os_log_impl( &dword_181A5C000,  v8,  v26,  "%{public}s [%{public}s] Called before listener was ready, no backtrace",  buf,  0x16u);
    }

    goto LABEL_64;
  }

  if (v27)
  {
    os_log_type_t v28 = nw_listener_get_id_string(*(void **)(a1 + 32));
    *(_DWORD *)buf = 136446722;
    uint64_t v41 = "nw_listener_set_advertise_endpoints_block_invoke";
    v42 = 2082;
    v43 = v28;
    v44 = 2082;
    v45 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v8,  v26,  "%{public}s [%{public}s] Called before listener was ready, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  if (v25) {
    free(v25);
  }
  BOOL v20 = 0LL;
LABEL_75:

  return v20;
}

    if (v36) {
      free(v36);
    }
    os_log_type_t v28 = 0LL;
    goto LABEL_15;
  }

  __nwlog_obj();
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_parameters_copy_with_protocol_instances";
  id v32 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v55 = 0;
  if (__nwlog_fault(v32, &type, &v55))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_copy_with_protocol_instances";
        _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v55)
    {
      v43 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v44 = type;
      v45 = os_log_type_enabled(v33, type);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_parameters_copy_with_protocol_instances";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v43;
          _os_log_impl( &dword_181A5C000,  v33,  v44,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        goto LABEL_59;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_copy_with_protocol_instances";
        _os_log_impl(&dword_181A5C000, v33, v44, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v52 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_copy_with_protocol_instances";
        _os_log_impl( &dword_181A5C000,  v33,  v52,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(backtrace_string);
    goto LABEL_79;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_masque_get_parameters";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_masque_get_parameters";
      os_log_type_t v29 = "%{public}s called with null masque";
      goto LABEL_78;
    }

    if (!v45)
    {
      BOOL v27 = (os_log_s *)__nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_masque_get_parameters";
      os_log_type_t v29 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_78;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v27 = (os_log_s *)__nwlog_obj();
    os_log_type_t v28 = type;
    id v33 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v33) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_masque_get_parameters";
      os_log_type_t v29 = "%{public}s called with null masque, no backtrace";
      goto LABEL_78;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446466;
      v48 = "nw_protocol_masque_get_parameters";
      v49 = 2082;
      v50 = backtrace_string;
      id v32 = "%{public}s called with null masque, dumping backtrace:%{public}s";
      goto LABEL_64;
    }

    goto LABEL_65;
  }

  if (handle + 128 == (char *)a1)
  {
    if (*((void *)handle + 53)) {
      return *((void *)handle + 53);
    }
    if (!*((void *)handle + 48) && !*((void *)handle + 56)) {
      return 0LL;
    }
    id v8 = (void *)*((void *)handle + 40);
    if (v8)
    {
      id v9 = v8;
      os_log_type_t v10 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v9,  0,  1);

      *((void *)handle + 53) = v10;
      id v11 = (nw_protocol *)*((void *)handle + 54);
      if (!v11) {
        return *((void *)handle + 53);
      }
      if (nw_protocol_demux_copy_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
      }
      if (nw_protocol_demux_copy_definition::definition) {
        os_log_type_t v12 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
      }
      else {
        os_log_type_t v12 = 0LL;
      }
      os_log_type_t v13 = nw_parameters_copy_protocol_options_legacy(*((void **)handle + 53), v11);
      os_log_type_t v14 = v13;
      if (!v13)
      {
        os_log_type_t v14 = nw_parameters_copy_protocol_options_for_definition(*((void **)handle + 53), v12);
        if (!v14)
        {
LABEL_100:
          if (v12) {
            os_release(v12);
          }
          return *((void *)handle + 53);
        }
      }

      if (nw_protocol_demux_copy_definition::onceToken == -1)
      {
        os_log_type_t v15 = (void *)nw_protocol_demux_copy_definition::definition;
        if (nw_protocol_demux_copy_definition::definition) {
          goto LABEL_33;
        }
      }

      else
      {
        dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
        os_log_type_t v15 = (void *)nw_protocol_demux_copy_definition::definition;
        if (nw_protocol_demux_copy_definition::definition)
        {
LABEL_33:
          os_log_type_t v16 = os_retain(v15);
          os_log_type_t v17 = nw_protocol_options_matches_definition(v14, v16);
          os_log_type_t v19 = v17;
          if (v16)
          {
            os_release(v16);
            if (!v19) {
              goto LABEL_99;
            }
          }

          else if (!v17)
          {
            goto LABEL_99;
          }

          goto LABEL_84;
        }
      }

      if (!nw_protocol_options_matches_definition(v14, 0LL))
      {
LABEL_99:
        os_release(v14);
        goto LABEL_100;
      }

    if (v16) {
      free(v16);
    }
    os_log_type_t v10 = 0LL;
    goto LABEL_9;
  }

  if (a2 && !uuid_is_null(v7 + 232) && ((char)v8[347] & 0x80000000) == 0)
  {
    id v9 = (void *)*((void *)v8 + 25);
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_resolver_get_resolution_provider_block_invoke;
    __int16 v39 = &unk_189BB68D0;
    v40 = v8;
    uint64_t v41 = a2;
    nw_path_enumerate_resolver_configs(v9, buf);
  }

  os_log_type_t v10 = *((unsigned int *)v8 + 63);
LABEL_9:

LABEL_58:
  return v10;
}

    if (v36) {
      free(v36);
    }
    fd = 0;
    goto LABEL_27;
  }

  __nwlog_obj();
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_fillout_tcp_connection_info";
  id v32 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v52[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v32, type, v52))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v34 = type[0];
      if (os_log_type_enabled(v33, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_fillout_tcp_connection_info";
        _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v52[0])
    {
      __int16 v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v40 = type[0];
      uint64_t v41 = os_log_type_enabled(v33, type[0]);
      if (v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_fillout_tcp_connection_info";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v39;
          _os_log_impl( &dword_181A5C000,  v33,  v40,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v39);
        goto LABEL_56;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_fillout_tcp_connection_info";
        _os_log_impl(&dword_181A5C000, v33, v40, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v45 = type[0];
      if (os_log_type_enabled(v33, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_fillout_tcp_connection_info";
        _os_log_impl( &dword_181A5C000,  v33,  v45,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  *(_BYTE *)(v5 + 190) = self->_reuseLocalAddress;
  *(_WORD *)(v5 + 196) |= 0x1000u;
  has = (__int16)self->_has;
  if ((has & 0x200) == 0)
  {
LABEL_14:
    if ((has & 8) == 0) {
      goto LABEL_15;
    }
    goto LABEL_67;
  }

      goto LABEL_66;
    }

    if (!v47)
    {
      __nwlog_obj();
      os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v20 = v48;
      if (os_log_type_enabled(v19, v48))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_socks5_server_register_udp_associate_request";
        os_log_type_t v21 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_64;
      }

      goto LABEL_65;
    }

    v31 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v20 = v48;
    id v34 = os_log_type_enabled(v19, v48);
    if (!v31)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_socks5_server_register_udp_associate_request";
        os_log_type_t v21 = "%{public}s called with null queue, no backtrace";
        goto LABEL_64;
      }

      goto LABEL_65;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v50 = "nw_socks5_server_register_udp_associate_request";
      v51 = 2082;
      v52 = v31;
      id v33 = "%{public}s called with null queue, dumping backtrace:%{public}s";
      goto LABEL_36;
    }

    goto LABEL_37;
  }

  os_log_type_t v15 = MEMORY[0x1895F87A8];
  if (!v10)
  {
    __nwlog_obj();
    os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_socks5_server_register_udp_associate_request";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();

    v48 = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (v48 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v26 = (void *)objc_claimAutoreleasedReturnValue();
      BOOL v27 = v48;
      if (!os_log_type_enabled((os_log_t)v26, v48))
      {
LABEL_54:

LABEL_55:
        if (!v25)
        {
LABEL_57:
          block[0] = v15;
          block[1] = 3221225472LL;
          block[2] = __nw_socks5_server_register_udp_associate_request_block_invoke;
          block[3] = &unk_189BC8740;
          v46 = v14;
          dispatch_async(v12, block);

          goto LABEL_5;
        }

    if (!v29) {
      goto LABEL_93;
    }
    goto LABEL_66;
  }

  if ((*((_BYTE *)self + 108) & 0x20) == 0 && self->fallback_interface)
  {
    id v8 = v6;
    p_lock = &v8->lock;
    os_unfair_lock_lock(&v8->lock);
    os_log_type_t v10 = v8->current_path;
    os_unfair_lock_unlock(&v8->lock);

    v118 = v10;
    fallback_interface_index = nw_path_get_fallback_interface_index((uint64_t)v10);
    if (!fallback_interface_index
      || (fallback_interface = self->fallback_interface) == 0LL
      || fallback_interface_index != *((_DWORD *)fallback_interface + 2))
    {
      fallback_timer = self->fallback_timer;
      if (fallback_timer)
      {
        nw_queue_cancel_source((uint64_t)fallback_timer, v12);
        self->fallback_timer = 0LL;
      }

      if (!self->result && self->fallback_child)
      {
        if (nw_endpoint_handler_get_minimize_logging(v8))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v96 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
          {
            loge = nw_endpoint_handler_get_id_string(v8);
            v97 = nw_endpoint_handler_dry_run_string(v8);
            v98 = nw_endpoint_handler_copy_endpoint(v8);
            logging_description = nw_endpoint_get_logging_description(v98);
            v100 = nw_endpoint_handler_state_string(v8);
            v101 = nw_endpoint_handler_mode_string(v8);
            v102 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v8);
            *(_DWORD *)buf = 136447746;
            v122 = "-[NWConcrete_nw_endpoint_fallback updatePathWithHandler:]";
            v123 = 2082;
            v124 = (void *)loge;
            v125 = 2082;
            v126 = v97;
            v127 = 2082;
            v128 = (void *)logging_description;
            v129 = 2082;
            v130 = v100;
            v131 = 2082;
            v132 = v101;
            v133 = 2114;
            v134 = v102;
            v42 = v96;
            _os_log_impl( &dword_181A5C000,  v96,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fallback advisory removed , cancelling fallback attempt",  buf,  0x48u);
          }

          else
          {
            v42 = v96;
          }
        }

        else
        {
          v40 = v8;
          uint64_t v41 = *((_BYTE *)v40 + 268);

          if ((v41 & 0x20) != 0)
          {
LABEL_51:
            nw_endpoint_handler_cancel(self->fallback_child, 0LL, 1);
            goto LABEL_74;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v42 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
          {
            id_string = nw_endpoint_handler_get_id_string(v40);
            v44 = nw_endpoint_handler_dry_run_string(v40);
            loga = v42;
            v45 = nw_endpoint_handler_copy_endpoint(v40);
            v46 = nw_endpoint_get_logging_description(v45);
            v47 = nw_endpoint_handler_state_string(v40);
            v48 = nw_endpoint_handler_mode_string(v40);
            v49 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v40);
            *(_DWORD *)buf = 136447746;
            v122 = "-[NWConcrete_nw_endpoint_fallback updatePathWithHandler:]";
            v123 = 2082;
            v124 = (void *)id_string;
            v125 = 2082;
            v126 = v44;
            v127 = 2082;
            v128 = (void *)v46;
            v129 = 2082;
            v130 = v47;
            v131 = 2082;
            v132 = v48;
            v133 = 2114;
            v134 = v49;
            v42 = loga;
            _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fallback advisory removed , cancelling fallback attempt",  buf,  0x48u);
          }
        }

        goto LABEL_51;
      }

      if (nw_endpoint_handler_get_minimize_logging(v8))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v17 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          logc = nw_endpoint_handler_get_id_string(v8);
          v84 = nw_endpoint_handler_dry_run_string(v8);
          v85 = nw_endpoint_handler_copy_endpoint(v8);
          v86 = nw_endpoint_get_logging_description(v85);
          v87 = nw_endpoint_handler_state_string(v8);
          v88 = nw_endpoint_handler_mode_string(v8);
          v89 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v8);
          *(_DWORD *)buf = 136447746;
          v122 = "-[NWConcrete_nw_endpoint_fallback updatePathWithHandler:]";
          v123 = 2082;
          v124 = (void *)logc;
          v125 = 2082;
          v126 = v84;
          v127 = 2082;
          v128 = (void *)v86;
          v129 = 2082;
          v130 = v87;
          v131 = 2082;
          v132 = v88;
          v133 = 2114;
          v134 = v89;
          _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fallback advisory removed",  buf,  0x48u);
        }

        goto LABEL_73;
      }

      os_log_type_t v15 = v8;
      os_log_type_t v16 = *((_BYTE *)v15 + 268);

      if ((v16 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v17 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          BOOL v18 = v15;

          os_log_type_t v19 = v18;
          BOOL v20 = *((_BYTE *)v15 + 268);

          if ((v20 & 1) != 0) {
            os_log_type_t v21 = "dry-run ";
          }
          else {
            os_log_type_t v21 = "";
          }
          BOOL v22 = nw_endpoint_handler_copy_endpoint(v19);
          log = nw_endpoint_get_logging_description(v22);
          id_str = v18->id_str;
          v111 = v21;
          char v23 = v19;
          os_log_type_t v24 = v23;
          BOOL v25 = v23[30];
          else {
            os_log_type_t v26 = off_189BBBBF0[v25];
          }

          v50 = v24;
          v51 = v50;
          v52 = v6[29];
          v53 = "path";
          switch(v52)
          {
            case 0u:
              break;
            case 1u:
              v53 = "resolver";
              break;
            case 2u:
              v53 = nw_endpoint_flow_mode_string(v50[31]);
              break;
            case 3u:
              v53 = "proxy";
              break;
            case 4u:
              v53 = "fallback";
              break;
            case 5u:
              v53 = "transform";
              break;
            default:
              v53 = "unknown-mode";
              break;
          }

          v54 = v51;
          os_unfair_lock_lock(p_lock);
          v55 = v8->current_path;
          os_unfair_lock_unlock(p_lock);

          *(_DWORD *)buf = 136447746;
          v122 = "-[NWConcrete_nw_endpoint_fallback updatePathWithHandler:]";
          v123 = 2082;
          v124 = id_str;
          v125 = 2082;
          v126 = v111;
          v127 = 2082;
          v128 = (void *)log;
          v129 = 2082;
          v130 = v26;
          v131 = 2082;
          v132 = v53;
          v133 = 2114;
          v134 = v55;
          _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fallback advisory removed",  buf,  0x48u);
        }

  if (v15) {
LABEL_66:
  }
    free(v15);
LABEL_67:
  if ((*(_DWORD *)(a2 + 32) & 0x80000000) == 0)
  {
    *(_BYTE *)(a2 + 36) &= ~2u;
    if (gLogDatapath)
    {
      v56 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
      {
        v57 = *(_DWORD *)(a2 + 32);
        *(_DWORD *)buf = 136446722;
        v64 = "nw_http2_transport_stream_connect";
        v65 = 2082;
        v66 = a1 + 205;
        v67 = 1024;
        *(_DWORD *)v68 = v57;
        _os_log_impl( &dword_181A5C000,  v56,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s connect complete for stream %d",  buf,  0x1Cu);
      }
    }

    return 1LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v35 = (os_log_s *)gLogObj;
  uint64_t result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    __int16 v36 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)buf = 136446978;
    v64 = "nw_http2_transport_stream_connect";
    v65 = 2082;
    v66 = a1 + 205;
    v67 = 2048;
    *(void *)v68 = a2;
    *(_WORD *)&v68[8] = 1024;
    *(_DWORD *)&v68[10] = v36;
    _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s failed to open stream %p (id still %d)",  buf,  0x26u);
    return 0LL;
  }

  return result;
}

                *(_BYTE *)(v3 + 676) &= ~8u;
LABEL_66:
                _Block_object_dispose(buf, 8);
                if ((v84[16] & 1) != 0)
                {
                  if (*(void *)&v84[8]) {
                    os_release(*(void **)&v84[8]);
                  }
                }

                return 1LL;
              }

              nw_http_messaging_options_create_transaction_in_parameters(*(void **)(*(void *)&buf[8] + 40LL), v3, 3);
              nw_protocol_plugin_metadata_prepare_for_reissue(v3 + 200);
              *(void *)os_log_type_t type = 0LL;
              v71 = (uint64_t)type;
              v72 = 0x3802000000LL;
              v73 = __Block_byref_object_copy__14_41705;
              v74 = __Block_byref_object_dispose__15_41706;
              os_log_type_t v30 = nw_http_metadata_copy_request(v10);
              if (v30)
              {
                v31 = v30;
                id v32 = (void *)_nw_http_fields_copy((uint64_t)v31);

                metadata_for_request = nw_http_create_metadata_for_request(v32);
                if (v32) {
                  os_release(v32);
                }
                os_release(v31);
                goto LABEL_59;
              }

              __nwlog_obj();
              *(_DWORD *)v77 = 136446210;
              *(void *)&v77[4] = "nw_http_retry_copy_metadata";
              v49 = (char *)_os_log_send_and_compose_impl();
              v64[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v63[0]) = 0;
              if (__nwlog_fault(v49, v64, v63))
              {
                if (v64[0] == OS_LOG_TYPE_FAULT)
                {
                  v50 = (os_log_s *)__nwlog_obj();
                  v51 = v64[0];
                  if (os_log_type_enabled(v50, v64[0]))
                  {
                    *(_DWORD *)v77 = 136446210;
                    *(void *)&v77[4] = "nw_http_retry_copy_metadata";
                    v52 = "%{public}s called with null orig_request";
LABEL_143:
                    _os_log_impl(&dword_181A5C000, v50, v51, v52, v77, 0xCu);
                  }
                }

                else if (LOBYTE(v63[0]))
                {
                  v59 = (char *)__nw_create_backtrace_string();
                  v50 = (os_log_s *)__nwlog_obj();
                  v51 = v64[0];
                  v60 = os_log_type_enabled(v50, v64[0]);
                  if (v59)
                  {
                    if (v60)
                    {
                      *(_DWORD *)v77 = 136446466;
                      *(void *)&v77[4] = "nw_http_retry_copy_metadata";
                      *(_WORD *)&v77[12] = 2082;
                      *(void *)&v77[14] = v59;
                      _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s called with null orig_request, dumping backtrace:%{public}s",  v77,  0x16u);
                    }

                    free(v59);
                    goto LABEL_144;
                  }

                  if (v60)
                  {
                    *(_DWORD *)v77 = 136446210;
                    *(void *)&v77[4] = "nw_http_retry_copy_metadata";
                    v52 = "%{public}s called with null orig_request, no backtrace";
                    goto LABEL_143;
                  }
                }

                else
                {
                  v50 = (os_log_s *)__nwlog_obj();
                  v51 = v64[0];
                  if (os_log_type_enabled(v50, v64[0]))
                  {
                    *(_DWORD *)v77 = 136446210;
                    *(void *)&v77[4] = "nw_http_retry_copy_metadata";
                    v52 = "%{public}s called with null orig_request, backtrace limit exceeded";
                    goto LABEL_143;
                  }
                }
              }

          free(v8);
          goto LABEL_66;
        }

        if (!v37) {
          goto LABEL_63;
        }
        *(_DWORD *)v70 = 136446978;
        v71 = "createKernelSocket";
        v72 = 2082;
        *(void *)v73 = &buf[4];
        *(_WORD *)&v73[8] = 1024;
        *(_DWORD *)&v73[10] = v5;
        *(_WORD *)&v73[14] = 1024;
        *(_DWORD *)&v73[16] = v18;
        id v11 = "%{public}s unable to look up socket control name %{public}s on fd %d %{darwin.errno}d, no backtrace";
        v45 = v9;
        v46 = v36;
LABEL_58:
        v47 = 34;
LABEL_62:
        _os_log_impl(&dword_181A5C000, v45, v46, v11, (uint8_t *)v70, v47);
        goto LABEL_63;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (os_log_s *)(id)gLogObj;
      BOOL v20 = v66[0];
      if (!os_log_type_enabled(v9, (os_log_type_t)v66[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)v70 = 136446978;
      v71 = "createKernelSocket";
      v72 = 2082;
      *(void *)v73 = &buf[4];
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v5;
      *(_WORD *)&v73[14] = 1024;
      *(_DWORD *)&v73[16] = v18;
      id v11 = "%{public}s unable to look up socket control name %{public}s on fd %d %{darwin.errno}d, backtrace limit exceeded";
    }

    v45 = v9;
    v46 = v20;
    goto LABEL_58;
  }

  os_log_type_t v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v13 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  *(void *)&uint8_t buf[4] = "createKernelSocket";
  *(_WORD *)&buf[12] = 1024;
  *(_DWORD *)&buf[14] = v12;
  os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

  v70[0] = OS_LOG_TYPE_ERROR;
  v66[0] = 0;
  if (__nwlog_fault(v14, v70, v66))
  {
    if (v70[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = v70[0];
      if (!os_log_type_enabled(v15, v70[0])) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "createKernelSocket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      os_log_type_t v17 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d";
LABEL_43:
      addrinfo v38 = v15;
      __int16 v39 = v16;
      goto LABEL_44;
    }

    if (!v66[0])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = v70[0];
      if (!os_log_type_enabled(v15, v70[0])) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "createKernelSocket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      os_log_type_t v17 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_43;
    }

    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v15 = (os_log_s *)(id)gLogObj;
    BOOL v22 = v70[0];
    char v23 = os_log_type_enabled(v15, v70[0]);
    if (!v21)
    {
      if (!v23)
      {
LABEL_45:

        if (!v14) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }

      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "createKernelSocket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      os_log_type_t v17 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, no backtrace";
      addrinfo v38 = v15;
      __int16 v39 = v22;
LABEL_44:
      _os_log_impl(&dword_181A5C000, v38, v39, v17, buf, 0x12u);
      goto LABEL_45;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "createKernelSocket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v21;
      _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

    free(v21);
  }

  if (v14) {
LABEL_22:
  }
    free(v14);
LABEL_23:
  os_log_type_t v24 = -1004LL;
LABEL_114:

  return v24;
}

        if (!v20)
        {
LABEL_34:
          id v33 = v81;
          if (self) {
            goto LABEL_35;
          }
LABEL_129:
          objc_msgSend(0, "setSecTrust:", v33, v76, v77);
          char v35 = 0LL;
          goto LABEL_130;
        }

    free(v12);
LABEL_66:
    if (v9) {

    }
    goto LABEL_68;
  }

  if (v13) {
    free(v13);
  }
  id v7 = 0LL;
  if (v3 == &nw_protocol_ref_counted_handle)
  {
LABEL_10:
    if (*(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
    {
      id v8 = *(void *)(v2 + 88);
      if (v8)
      {
        id v9 = v8 - 1;
        *(void *)(v2 + 88) = v9;
        if (!v9)
        {
          os_log_type_t v10 = *(void (***)(void))(v2 + 64);
          if (v10)
          {
            *(void *)(v2 + 64) = 0LL;
            v10[2](v10);
            _Block_release(v10);
          }

          if ((*(_BYTE *)(v2 + 72) & 1) != 0)
          {
            id v11 = *(const void **)(v2 + 64);
            if (v11) {
              _Block_release(v11);
            }
          }

          free((void *)v2);
        }
      }
    }
  }

  return v7;
}
  }

      v56 = v56;
      v59 = _nw_http_response_get_status_code();

      if (v55) {
        goto LABEL_68;
      }
LABEL_79:
      ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_38((uint64_t)v64, (uint64_t)"", v59);
      v60 = 0LL;
      if (inbound_message) {
LABEL_69:
      }
        os_release(inbound_message);
LABEL_70:
      if (v54) {
        os_release(v54);
      }
      if (v56) {
        os_release(v56);
      }
      if (v60)
      {
        v42 = v60;
LABEL_76:
        os_release(v42);
      }

      return;
    default:
      return;
  }

        _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0xCu);
        goto LABEL_66;
      }

      *id v11 = 127;
      os_log_type_t v16 = v13 - 63;
      if (v16 < 0x80)
      {
        os_log_type_t v17 = 1LL;
        BOOL v18 = handle + 730;
      }

      else
      {
        handle[731] = v16 | 0x80;
        if (v16 < 0x4000)
        {
          BOOL v18 = handle + 731;
          v16 >>= 7;
          os_log_type_t v17 = 2LL;
        }

        else
        {
          handle[732] = (v16 >> 7) | 0x80;
          if (v16 < 0x200000)
          {
            BOOL v18 = handle + 732;
            v16 >>= 14;
            os_log_type_t v17 = 3LL;
          }

          else
          {
            handle[733] = (v16 >> 14) | 0x80;
            if (v16 >> 28)
            {
              handle[734] = (v16 >> 21) | 0x80;
              if (v16 >> 35)
              {
                handle[735] = (v16 >> 28) | 0x80;
LABEL_46:
                char v23 = *(FILE **)(v10 + 544);
                if (v23)
                {
                  fwrite("qdec: warn: ", 0xCuLL, 1uLL, v23);
                  fprintf( *(FILE **)(v10 + 544),  "cannot generate Cancel Stream instruction for stream %llu; buf size=%zu",
                    v12[5],
                    6uLL);
                  fputc(10, *(FILE **)(v10 + 544));
                }

                goto LABEL_52;
              }

              BOOL v18 = handle + 734;
              os_log_type_t v17 = 5LL;
              LOBYTE(v16) = v16 >> 28;
            }

            else
            {
              BOOL v18 = handle + 733;
              v16 >>= 21;
              os_log_type_t v17 = 4LL;
            }
          }
        }
      }

      os_log_type_t v14 = v18 + 2;
      v11[v17] = v16;
      if (v18 + 2 > v11) {
        goto LABEL_38;
      }
      goto LABEL_46;
    }
  }

  os_log_type_t v15 = *(FILE **)(v10 + 544);
  if (v15)
  {
    fwrite("qdec: info: ", 0xCuLL, 1uLL, v15);
    fwrite("could not find stream to cancel", 0x1FuLL, 1uLL, *(FILE **)(v10 + 544));
    fputc(10, *(FILE **)(v10 + 544));
  }

  handle[635] = 0;
LABEL_68:
  nw_http3_stream_send_stream_cancellation((uint64_t)handle);
  if (*((void *)handle + 66) || handle[634] || handle[635])
  {
    *v3 |= 0x400u;
    return;
  }

  os_log_type_t v30 = *((void *)handle + 4);
  if (v30)
  {
    v31 = *(void *)(v30 + 24);
    if (v31)
    {
      id v32 = *(void (**)(uint64_t, char *))(v31 + 32);
      if (v32)
      {
        v32(v30, handle);
        return;
      }
    }
  }

  __nwlog_obj();
  v47 = *((void *)handle + 4);
  v48 = "invalid";
  if (v47)
  {
    v49 = *(const char **)(v47 + 16);
    if (v49) {
      v48 = v49;
    }
  }

  *(_DWORD *)buf = 136446466;
  v72 = "nw_protocol_http3_stream_disconnect";
  v73 = 2082;
  v74 = (char *)v48;
  v50 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v69 = 0;
  v51 = (char *)v50;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v52 = (os_log_s *)__nwlog_obj();
    v53 = type;
    if (!os_log_type_enabled(v52, type)) {
      goto LABEL_164;
    }
    v54 = *((void *)handle + 4);
    v55 = "invalid";
    if (v54)
    {
      v56 = *(const char **)(v54 + 16);
      if (v56) {
        v55 = v56;
      }
    }

    *(_DWORD *)buf = 136446466;
    v72 = "nw_protocol_http3_stream_disconnect";
    v73 = 2082;
    v74 = (char *)v55;
    v57 = "%{public}s protocol %{public}s has invalid disconnect callback";
    goto LABEL_163;
  }

  if (!v69)
  {
    v52 = (os_log_s *)__nwlog_obj();
    v53 = type;
    if (!os_log_type_enabled(v52, type)) {
      goto LABEL_164;
    }
    v63 = *((void *)handle + 4);
    v64 = "invalid";
    if (v63)
    {
      v65 = *(const char **)(v63 + 16);
      if (v65) {
        v64 = v65;
      }
    }

    *(_DWORD *)buf = 136446466;
    v72 = "nw_protocol_http3_stream_disconnect";
    v73 = 2082;
    v74 = (char *)v64;
    v57 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
    goto LABEL_163;
  }

  v58 = (char *)__nw_create_backtrace_string();
  v52 = (os_log_s *)__nwlog_obj();
  v53 = type;
  v59 = os_log_type_enabled(v52, type);
  if (v58)
  {
    if (v59)
    {
      v60 = *((void *)handle + 4);
      v61 = "invalid";
      if (v60)
      {
        v62 = *(const char **)(v60 + 16);
        if (v62) {
          v61 = v62;
        }
      }

      *(_DWORD *)buf = 136446722;
      v72 = "nw_protocol_http3_stream_disconnect";
      v73 = 2082;
      v74 = (char *)v61;
      v75 = 2082;
      v76 = v58;
      _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v58);
    goto LABEL_164;
  }

  if (v59)
  {
    v66 = *((void *)handle + 4);
    v67 = "invalid";
    if (v66)
    {
      v68 = *(const char **)(v66 + 16);
      if (v68) {
        v67 = v68;
      }
    }

    *(_DWORD *)buf = 136446466;
    v72 = "nw_protocol_http3_stream_disconnect";
    v73 = 2082;
    v74 = (char *)v67;
    v57 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
LABEL_163:
    _os_log_impl(&dword_181A5C000, v52, v53, v57, buf, 0x16u);
  }

    free(backtrace_string);
    goto LABEL_83;
  }

  if (a1->default_input_handler == a2)
  {
    nw_protocol_set_input_handler((uint64_t)a1->handle, (uint64_t)a3);
    nw_protocol_set_input_handler((uint64_t)(handle + 8), (uint64_t)a3);
    os_log_type_t v13 = handle[42];
    if (v13 && *(nw_protocol **)(v13 + 48) == a2)
    {
      nw_protocol_set_input_handler(v13, (uint64_t)a3);
      if (a3->output_handler) {
        return 1LL;
      }
    }

    else if (a3->output_handler)
    {
      return 1LL;
    }

    nw_protocol_set_output_handler((uint64_t)a3, (uint64_t)a1);
    return 1LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  default_input_handler = a1->default_input_handler;
  *(_DWORD *)buf = 136446722;
  id v34 = "nw_protocol_http3_stream_replace_input_handler";
  char v35 = 2048;
  __int16 v36 = default_input_handler;
  v37 = 2048;
  addrinfo v38 = a2;
  id v8 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_27;
    }
    id v11 = a1->default_input_handler;
    *(_DWORD *)buf = 136446722;
    id v34 = "nw_protocol_http3_stream_replace_input_handler";
    char v35 = 2048;
    __int16 v36 = v11;
    v37 = 2048;
    addrinfo v38 = a2;
    os_log_type_t v12 = "%{public}s Old input handler does not match (%p != %p)";
LABEL_26:
    _os_log_impl(&dword_181A5C000, v9, v10, v12, buf, 0x20u);
    goto LABEL_27;
  }

  if (!v31)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (os_log_s *)gLogObj;
    os_log_type_t v10 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_27;
    }
    BOOL v18 = a1->default_input_handler;
    *(_DWORD *)buf = 136446722;
    id v34 = "nw_protocol_http3_stream_replace_input_handler";
    char v35 = 2048;
    __int16 v36 = v18;
    v37 = 2048;
    addrinfo v38 = a2;
    os_log_type_t v12 = "%{public}s Old input handler does not match (%p != %p), backtrace limit exceeded";
    goto LABEL_26;
  }

  os_log_type_t v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v9 = (os_log_s *)gLogObj;
  os_log_type_t v10 = type;
  os_log_type_t v16 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_27;
    }
    os_log_type_t v19 = a1->default_input_handler;
    *(_DWORD *)buf = 136446722;
    id v34 = "nw_protocol_http3_stream_replace_input_handler";
    char v35 = 2048;
    __int16 v36 = v19;
    v37 = 2048;
    addrinfo v38 = a2;
    os_log_type_t v12 = "%{public}s Old input handler does not match (%p != %p), no backtrace";
    goto LABEL_26;
  }

  if (v16)
  {
    os_log_type_t v17 = a1->default_input_handler;
    *(_DWORD *)buf = 136446978;
    id v34 = "nw_protocol_http3_stream_replace_input_handler";
    char v35 = 2048;
    __int16 v36 = v17;
    v37 = 2048;
    addrinfo v38 = a2;
    __int16 v39 = 2082;
    v40 = v15;
    _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s Old input handler does not match (%p != %p), dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v15);
LABEL_27:
  if (v8)
  {
    BOOL v20 = (char *)v8;
LABEL_29:
    free(v20);
  }

  return 0LL;
}

  if (v30) {
    free(v30);
  }
  v47 = 2;
  id v9 = v28;
LABEL_95:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v47;
  v72 = *(void *)(a1 + 48);
  if (!v72 || (*(_WORD *)(v72 + 736) & 0x800) == 0)
  {
    if (*((_BYTE *)v20 + 1537))
    {
      v89 = v9;
      v90 = (os_log_s *)__nwlog_obj();
      v91 = os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG);
      id v9 = v89;
      if (v91)
      {
        v92 = *(void *)(a1 + 48);
        v93 = (const char *)(v92 + 636);
        v94 = "";
        if (v92) {
          v94 = " ";
        }
        else {
          v93 = "";
        }
        v95 = *(_DWORD *)(*(void *)(v92 + 336) + 1280LL);
        v96 = *(void *)(v92 + 240);
        v97 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        v98 = *(_DWORD *)(v92 + 372);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_input_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v93;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = v94;
        LOWORD(v130) = 1024;
        *(_DWORD *)((char *)&v130 + 2) = v95;
        HIWORD(v130) = 2048;
        v131 = v96;
        v132 = 1024;
        *(_DWORD *)v133 = v97;
        *(_WORD *)&v133[4] = 1024;
        *(_DWORD *)&v133[6] = v98;
        _os_log_impl( &dword_181A5C000,  v90,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> status %u http3_stream->input_state %u",  buf,  0x3Cu);
        id v9 = v89;
      }
    }
  }

  if (v9)
  {
    nw_http_transaction_metadata_mark_inbound_message_end(*(void **)(*(void *)(a1 + 48) + 392LL));
    v73 = *(void *)(a1 + 48);
    if (*(_BYTE *)(v73 + 304))
    {
      if (*(void *)(v73 + 296) != *(void *)(v73 + 312))
      {
        if ((*(_WORD *)(v73 + 736) & 0x800) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v74 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v75 = *(void *)(a1 + 48);
            v76 = " ";
            if (v75) {
              v77 = (const char *)(v75 + 636);
            }
            else {
              v77 = "";
            }
            if (!v75) {
              v76 = "";
            }
            v78 = *(_DWORD *)(*(void *)(v75 + 336) + 1280LL);
            v79 = *(void *)(v75 + 240);
            if (*(_BYTE *)(v75 + 304)) {
              v80 = *(void *)(v75 + 296);
            }
            else {
              v80 = -1LL;
            }
            v81 = *(void *)(v75 + 312);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_get_input_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v77;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&buf[24] = v76;
            LOWORD(v130) = 1024;
            *(_DWORD *)((char *)&v130 + 2) = v78;
            HIWORD(v130) = 2048;
            v131 = v79;
            v132 = 2048;
            *(void *)v133 = v80;
            *(_WORD *)&v133[8] = 2048;
            v134 = v81;
            _os_log_impl( &dword_181A5C000,  v74,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:s%llu> Content length header %llu does not equal body size %llu",  buf,  0x44u);
          }
        }

        v82 = *v14;
        if (*v14)
        {
          if (*((_BYTE *)v20 + 1537))
          {
            v103 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_181A5C000, v103, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }

          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60412;
          *(void *)&buf[24] = &__block_descriptor_tmp_26_60413;
          v130 = v82;
          LOBYTE(v131) = 0;
          v83 = *v82;
          do
          {
            if (!v83) {
              break;
            }
            v84 = *(void *)(v83 + 32);
            v85 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            v83 = v84;
          }

          while ((v85 & 1) != 0);
LABEL_117:
          v86 = *(void *)(a1 + 48);
          *(void *)(v86 + 264) = 270LL;
          if (*(void *)(v86 + 312)) {
            v87 = 40;
          }
          else {
            v87 = 91;
          }
          nw_protocol_http3_stream_error((nw_protocol *)v86, (nw_protocol *)v86, v87);
          nw_protocol_http3_stream_disconnect(*(nw_protocol **)(a1 + 48), *(nw_protocol **)(a1 + 48));
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 2;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
          return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        v99 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v127 = 0;
        if (__nwlog_fault(v99, &type, &v127))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v100 = (os_log_s *)__nwlog_obj();
            v101 = type;
            if (!os_log_type_enabled(v100, type)) {
              goto LABEL_148;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            v102 = "%{public}s called with null array";
            goto LABEL_147;
          }

          if (!v127)
          {
            v100 = (os_log_s *)__nwlog_obj();
            v101 = type;
            if (!os_log_type_enabled(v100, type)) {
              goto LABEL_148;
            }
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            v102 = "%{public}s called with null array, backtrace limit exceeded";
            goto LABEL_147;
          }

          v109 = (char *)__nw_create_backtrace_string();
          v100 = (os_log_s *)__nwlog_obj();
          v101 = type;
          v110 = os_log_type_enabled(v100, type);
          if (v109)
          {
            if (v110)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v109;
              _os_log_impl( &dword_181A5C000,  v100,  v101,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v109);
            goto LABEL_148;
          }

          if (v110)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            v102 = "%{public}s called with null array, no backtrace";
LABEL_147:
            _os_log_impl(&dword_181A5C000, v100, v101, v102, buf, 0xCu);
          }
        }

      v56 = v56;
      v59 = _nw_http_response_get_status_code();

      if (v55) {
        goto LABEL_68;
      }
LABEL_79:
      ___ZL34nw_protocol_http3_stream_connectedP11nw_protocolS0__block_invoke_133((uint64_t)v64, (uint64_t)"", v59);
      v60 = 0LL;
      if (inbound_message) {
LABEL_69:
      }
        os_release(inbound_message);
LABEL_70:
      if (v54) {
        os_release(v54);
      }
      if (v56) {
        os_release(v56);
      }
      if (v60)
      {
        v42 = v60;
LABEL_76:
        os_release(v42);
      }

      return;
    default:
      return;
  }

      if (!v9) {
        return;
      }
      goto LABEL_66;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v39 = "nw_socket_error";
    id v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v21 = (os_log_s *)__nwlog_obj();
      BOOL v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_socket_error";
      os_log_type_t v15 = "%{public}s called with null socket_handler";
      goto LABEL_63;
    }

    if (!v36)
    {
      os_log_type_t v21 = (os_log_s *)__nwlog_obj();
      BOOL v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_socket_error";
      os_log_type_t v15 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_63;
    }

    os_log_type_t v26 = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = (os_log_s *)__nwlog_obj();
    BOOL v22 = type;
    os_log_type_t v29 = os_log_type_enabled(v21, type);
    if (!v26)
    {
      if (!v29) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_socket_error";
      os_log_type_t v15 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_63;
    }

    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v39 = "nw_socket_error";
      v40 = 2082;
      uint64_t v41 = v26;
      os_log_type_t v28 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
  }

  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v39 = "nw_socket_error";
    id v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v21 = (os_log_s *)__nwlog_obj();
      BOOL v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_socket_error";
      os_log_type_t v15 = "%{public}s called with null protocol";
LABEL_63:
      id v33 = v21;
      id v34 = v22;
      char v35 = 12;
      goto LABEL_64;
    }

    if (!v36)
    {
      os_log_type_t v21 = (os_log_s *)__nwlog_obj();
      BOOL v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_socket_error";
      os_log_type_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_63;
    }

    os_log_type_t v26 = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = (os_log_s *)__nwlog_obj();
    BOOL v22 = type;
    BOOL v27 = os_log_type_enabled(v21, type);
    if (!v26)
    {
      if (!v27) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_socket_error";
      os_log_type_t v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_63;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v39 = "nw_socket_error";
      v40 = 2082;
      uint64_t v41 = v26;
      os_log_type_t v28 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_46:
      _os_log_impl(&dword_181A5C000, v21, v22, v28, buf, 0x16u);
    }
  }

  free(v26);
  if (v9) {
LABEL_66:
  }
    free(v9);
}

    if (v9)
    {
LABEL_66:
      free((void *)v9);
      goto LABEL_67;
    }

    goto LABEL_67;
  }

  __nwlog_obj();
  *(_DWORD *)&__dst[0].sa_len = 136446210;
  *(void *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
  v31 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  LOBYTE(v42) = 0;
  if (buf[0] == 17)
  {
    id v32 = (os_log_s *)__nwlog_obj();
    id v33 = buf[0];
    if (!os_log_type_enabled(v32, (os_log_type_t)buf[0])) {
      goto LABEL_106;
    }
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(void *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    id v34 = "%{public}s called with null socket_handler";
    goto LABEL_105;
  }

  if (!(_BYTE)v42)
  {
    id v32 = (os_log_s *)__nwlog_obj();
    id v33 = buf[0];
    if (!os_log_type_enabled(v32, (os_log_type_t)buf[0])) {
      goto LABEL_106;
    }
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(void *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    id v34 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_105;
  }

  v37 = (char *)__nw_create_backtrace_string();
  id v32 = (os_log_s *)__nwlog_obj();
  id v33 = buf[0];
  addrinfo v38 = os_log_type_enabled(v32, (os_log_type_t)buf[0]);
  if (!v37)
  {
    if (!v38) {
      goto LABEL_106;
    }
    *(_DWORD *)&__dst[0].sa_len = 136446210;
    *(void *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    id v34 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_105;
  }

  if (v38)
  {
    *(_DWORD *)&__dst[0].sa_len = 136446466;
    *(void *)&__dst[0].sa_data[2] = "nw_socket_fillout_socket_properties";
    *(_WORD *)&__dst[0].sa_data[10] = 2082;
    *(void *)&__dst[0].sa_data[12] = v37;
    _os_log_impl( &dword_181A5C000,  v32,  v33,  "%{public}s called with null socket_handler, dumping backtrace:%{public}s",  &__dst[0].sa_len,  0x16u);
  }

  free(v37);
  if (v31) {
    goto LABEL_107;
  }
}

      free(v37);
      goto LABEL_66;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136447234;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(void *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(void *)v182 = v175;
    *(_WORD *)&v182[8] = 1024;
    *(_DWORD *)&v182[10] = 8;
    *(_WORD *)&v182[14] = 1024;
    *(_DWORD *)&v182[16] = v35;
    v37 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v56 = (os_log_s *)__nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type)) {
        goto LABEL_64;
      }
      *(_DWORD *)buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 8;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v35;
      v40 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }

    else
    {
      if (v176)
      {
        v62 = (char *)__nw_create_backtrace_string();
        v63 = (os_log_s *)__nwlog_obj();
        v64 = type;
        v65 = os_log_type_enabled(v63, type);
        if (v62)
        {
          if (v65)
          {
            *(_DWORD *)buf = 136447490;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(void *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(void *)v182 = v175;
            *(_WORD *)&v182[8] = 1024;
            *(_DWORD *)&v182[10] = 8;
            *(_WORD *)&v182[14] = 1024;
            *(_DWORD *)&v182[16] = v35;
            *(_WORD *)&v182[20] = 2082;
            *(void *)&v182[22] = v62;
            _os_log_impl( &dword_181A5C000,  v63,  v64,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
          }

          free(v62);
          goto LABEL_64;
        }

        if (!v65) {
          goto LABEL_64;
        }
        *(_DWORD *)buf = 136447234;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(void *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(void *)v182 = v175;
        *(_WORD *)&v182[8] = 1024;
        *(_DWORD *)&v182[10] = 8;
        *(_WORD *)&v182[14] = 1024;
        *(_DWORD *)&v182[16] = v35;
        v40 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
        v45 = v63;
        v46 = v64;
LABEL_107:
        v47 = 44;
        goto LABEL_63;
      }

      v56 = (os_log_s *)__nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type)) {
        goto LABEL_64;
      }
      *(_DWORD *)buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(void *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(void *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 8;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v35;
      v40 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }

    v45 = v56;
    v46 = v57;
    goto LABEL_107;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v179 = "nw_necp_append_tlv";
  v52 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v176 = 0;
  if (__nwlog_fault(v52, &type, &v176))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v53 = (os_log_s *)__nwlog_obj();
      v54 = type;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_307;
      }
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v55 = "%{public}s called with null tlv_start";
LABEL_306:
      _os_log_impl(&dword_181A5C000, v53, v54, v55, buf, 0xCu);
      goto LABEL_307;
    }

    if (!v176)
    {
      v53 = (os_log_s *)__nwlog_obj();
      v54 = type;
      os_log_type_t v15 = v172;
      if (!os_log_type_enabled(v53, type)) {
        goto LABEL_307;
      }
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v55 = "%{public}s called with null tlv_start, backtrace limit exceeded";
      goto LABEL_306;
    }

    v60 = (char *)__nw_create_backtrace_string();
    v53 = (os_log_s *)__nwlog_obj();
    v54 = type;
    v61 = os_log_type_enabled(v53, type);
    if (!v60)
    {
      os_log_type_t v15 = v172;
      if (!v61) {
        goto LABEL_307;
      }
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v55 = "%{public}s called with null tlv_start, no backtrace";
      goto LABEL_306;
    }

    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v179 = "nw_necp_append_tlv";
      v180 = 2082;
      *(void *)v181 = v60;
      _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v60);
    os_log_type_t v15 = v172;
  }

    if (v23) {
      free(v23);
    }
LABEL_67:
    memset(buf, 0, sizeof(buf));
    v90 = 128;
    if (!getsockname(sockfd_from_client, buf, &v90))
    {
      address = nw_endpoint_create_address(buf);
      local_endpoint = self->super._local_endpoint;
      self->super._local_endpoint = address;
    }

    v37 = nw_parameters_copy_required_interface(self->super._parameters);
    interface = self->super._interface;
    self->super._interface = v37;

    __int16 v39 = self->super._interface;
    if (v39)
    {
      v40 = self->super._local_endpoint;
      if (v40)
      {
LABEL_71:
        if (!v39 || (nw_endpoint_set_interface(v40, v39), (__int16 v39 = self->super._interface) == 0LL))
        {
LABEL_101:
          v59 = nw_parameters_copy_context(self->super._parameters);
          v60 = sockfd_from_client;
          v85[0] = MEMORY[0x1895F87A8];
          v85[1] = 3221225472LL;
          v85[2] = __33__nw_listener_inbox_socket_start__block_invoke;
          v85[3] = &unk_189BC76E8;
          v85[4] = self;
          v86 = sockfd_from_client;
          v82[0] = MEMORY[0x1895F87A8];
          v82[1] = 3221225472LL;
          v82[2] = __33__nw_listener_inbox_socket_start__block_invoke_2;
          v82[3] = &unk_189BC9238;
          v83 = v6;
          v84 = self;
          self->_source = (void *)nw_queue_context_create_source(v59, v60, 1, 0, v85, v82);

          source = self->_source;
          if (source)
          {
            nw_queue_activate_source((uint64_t)source, v61);
            posix_error = 0LL;
LABEL_129:

            goto LABEL_160;
          }

          posix_error = -[NWConcrete_nw_error initWithDomain:code:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_error),  1,  12);
          v63 = nw_error_get_error_code((nw_error_t)posix_error);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v64 = (id)gLogObj;
          *(_DWORD *)os_log_type_t type = 136446466;
          v94 = "-[nw_listener_inbox_socket start]";
          v95 = 1024;
          v96 = v63;
          v65 = (char *)_os_log_send_and_compose_impl();

          v89[0] = OS_LOG_TYPE_ERROR;
          v88 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v65, v89, &v88))
          {
            if (v89[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v66 = (os_log_s *)(id)gLogObj;
              v67 = v89[0];
              if (os_log_type_enabled(v66, v89[0]))
              {
                *(_DWORD *)os_log_type_t type = 136446466;
                v94 = "-[nw_listener_inbox_socket start]";
                v95 = 1024;
                v96 = v63;
                _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s nw_queue_context_create_source failed %{darwin.errno}d",  (uint8_t *)type,  0x12u);
              }
            }

            else if (v88)
            {
              v68 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v69 = v89[0];
              v70 = os_log_type_enabled(v66, v89[0]);
              if (v68)
              {
                if (v70)
                {
                  *(_DWORD *)os_log_type_t type = 136446722;
                  v94 = "-[nw_listener_inbox_socket start]";
                  v95 = 1024;
                  v96 = v63;
                  v97 = 2082;
                  *(void *)v98 = v68;
                  _os_log_impl( &dword_181A5C000,  v66,  v69,  "%{public}s nw_queue_context_create_source failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)type,  0x1Cu);
                }

                free(v68);
                if (!v65) {
                  goto LABEL_129;
                }
                goto LABEL_128;
              }

              if (v70)
              {
                *(_DWORD *)os_log_type_t type = 136446466;
                v94 = "-[nw_listener_inbox_socket start]";
                v95 = 1024;
                v96 = v63;
                _os_log_impl( &dword_181A5C000,  v66,  v69,  "%{public}s nw_queue_context_create_source failed %{darwin.errno}d, no backtrace",  (uint8_t *)type,  0x12u);
              }
            }

            else
            {
              __nwlog_obj();
              v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v73 = v89[0];
              if (os_log_type_enabled(v66, v89[0]))
              {
                *(_DWORD *)os_log_type_t type = 136446466;
                v94 = "-[nw_listener_inbox_socket start]";
                v95 = 1024;
                v96 = v63;
                _os_log_impl( &dword_181A5C000,  v66,  v73,  "%{public}s nw_queue_context_create_source failed %{darwin.errno}d, backtrace limit exceeded",  (uint8_t *)type,  0x12u);
              }
            }
          }

          if (!v65) {
            goto LABEL_129;
          }
LABEL_128:
          free(v65);
          goto LABEL_129;
        }

        goto LABEL_94;
      }

        goto LABEL_66;
      }

      if (!v44)
      {
        __nwlog_obj();
        os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v43 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_path_flow_registration_get_tfo_cookie";
          _os_log_impl( &dword_181A5C000,  v30,  v43,  "%{public}s called with null len, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_65;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v37 = type;
      addrinfo v38 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_path_flow_registration_get_tfo_cookie";
          _os_log_impl(&dword_181A5C000, v30, v37, "%{public}s called with null len, no backtrace", buf, 0xCu);
        }

        goto LABEL_65;
      }

      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "nw_path_flow_registration_get_tfo_cookie";
        v48 = 2082;
        *(void *)v49 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v30,  v37,  "%{public}s called with null len, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_51;
    }

    goto LABEL_66;
  }

  if (*a4 <= 0xFu)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    os_log_type_t v10 = *a4;
    *(_DWORD *)buf = 136446722;
    v47 = "nw_path_flow_registration_get_tfo_cookie";
    v48 = 1024;
    *(_DWORD *)v49 = v10;
    *(_WORD *)&v49[4] = 1024;
    *(_DWORD *)&v49[6] = 16;
    id v11 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (__nwlog_fault(v11, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          os_log_type_t v14 = *a4;
          *(_DWORD *)buf = 136446722;
          v47 = "nw_path_flow_registration_get_tfo_cookie";
          v48 = 1024;
          *(_DWORD *)v49 = v14;
          *(_WORD *)&v49[4] = 1024;
          *(_DWORD *)&v49[6] = 16;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s cookie buffer invalid, length is %u expected %d",  buf,  0x18u);
        }
      }

      else if (v44)
      {
        os_log_type_t v19 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v20 = type;
        os_log_type_t v21 = os_log_type_enabled(v12, type);
        if (v19)
        {
          if (v21)
          {
            BOOL v22 = *a4;
            *(_DWORD *)buf = 136446978;
            v47 = "nw_path_flow_registration_get_tfo_cookie";
            v48 = 1024;
            *(_DWORD *)v49 = v22;
            *(_WORD *)&v49[4] = 1024;
            *(_DWORD *)&v49[6] = 16;
            v50 = 2082;
            v51 = v19;
            _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s cookie buffer invalid, length is %u expected %d, dumping backtrace:%{public}s",  buf,  0x22u);
          }

          free(v19);
          if (!v11) {
            goto LABEL_30;
          }
LABEL_28:
          os_log_type_t v26 = (char *)v11;
LABEL_29:
          free(v26);
          goto LABEL_30;
        }

        if (v21)
        {
          BOOL v25 = *a4;
          *(_DWORD *)buf = 136446722;
          v47 = "nw_path_flow_registration_get_tfo_cookie";
          v48 = 1024;
          *(_DWORD *)v49 = v25;
          *(_WORD *)&v49[4] = 1024;
          *(_DWORD *)&v49[6] = 16;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s cookie buffer invalid, length is %u expected %d, no backtrace",  buf,  0x18u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        char v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          os_log_type_t v24 = *a4;
          *(_DWORD *)buf = 136446722;
          v47 = "nw_path_flow_registration_get_tfo_cookie";
          v48 = 1024;
          *(_DWORD *)v49 = v24;
          *(_WORD *)&v49[4] = 1024;
          *(_DWORD *)&v49[6] = 16;
          _os_log_impl( &dword_181A5C000,  v12,  v23,  "%{public}s cookie buffer invalid, length is %u expected %d, backtrace limit exceeded",  buf,  0x18u);
        }
      }
    }

    if (!v11)
    {
LABEL_30:
      BOOL v18 = 0LL;
      goto LABEL_31;
    }

    goto LABEL_28;
  }

  os_log_type_t v15 = nw_path_copy_flow_for_registration(v7, v8);
  os_log_type_t v16 = v15;
  if (!v15 || (os_log_type_t v17 = v15[184], !v15[184]))
  {
    BOOL v18 = 0LL;
    goto LABEL_14;
  }

  if (v17 < 0x11)
  {
LABEL_12:
    memcpy(a3, v16 + 108, v17);
    *a4 = v16[184];
    BOOL v18 = 1LL;
LABEL_14:

LABEL_31:
    return v18;
  }

  __nwlog_obj();
  __int16 v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
  v40 = v16[184];
  *(_DWORD *)buf = 136446466;
  v47 = "nw_path_flow_registration_get_tfo_cookie";
  v48 = 1024;
  *(_DWORD *)v49 = v40;
  uint64_t v41 = (void *)_os_log_send_and_compose_impl();

  uint64_t result = __nwlog_abort((uint64_t)v41);
  if (!result)
  {
    free(v41);
    os_log_type_t v17 = v16[184];
    goto LABEL_12;
  }

  __break(1u);
  return result;
}

    if (v29) {
      free(v29);
    }
    os_log_type_t v15 = 0LL;
    goto LABEL_30;
  }

  if (!a3)
  {
    __nwlog_obj();
    id v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_oblivious_http_serialize_options";
    os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (__nwlog_fault(v29, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_oblivious_http_serialize_options";
          id v32 = "%{public}s called with null out_length";
          goto LABEL_63;
        }

        goto LABEL_64;
      }

      if (!v44)
      {
        __nwlog_obj();
        os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v31 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_oblivious_http_serialize_options";
          id v32 = "%{public}s called with null out_length, backtrace limit exceeded";
          goto LABEL_63;
        }

        goto LABEL_64;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = type;
      v43 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_oblivious_http_serialize_options";
          id v32 = "%{public}s called with null out_length, no backtrace";
          goto LABEL_63;
        }

        goto LABEL_64;
      }

      if (!v43) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446466;
      v47 = "nw_oblivious_http_serialize_options";
      v48 = 2082;
      v49 = (uint64_t)backtrace_string;
      v42 = "%{public}s called with null out_length, dumping backtrace:%{public}s";
LABEL_53:
      _os_log_impl(&dword_181A5C000, v30, v31, v42, buf, 0x16u);
LABEL_54:

      free(backtrace_string);
      goto LABEL_65;
    }

    goto LABEL_65;
  }

  id v6 = *(id *)(a2 + 8);
  id v7 = v6;
  if (v6)
  {
    length = xpc_data_get_length(v6);
    id v9 = *(const char **)(a2 + 24);
    if (v9) {
      goto LABEL_5;
    }
LABEL_8:
    os_log_type_t v10 = 0LL;
    id v11 = *(const char **)(a2 + 16);
    if (v11) {
      goto LABEL_6;
    }
    goto LABEL_9;
  }

  length = 0LL;
  id v9 = *(const char **)(a2 + 24);
  if (!v9) {
    goto LABEL_8;
  }
LABEL_5:
  os_log_type_t v10 = strlen(v9) + 1;
  id v11 = *(const char **)(a2 + 16);
  if (v11)
  {
LABEL_6:
    os_log_type_t v12 = strlen(v11) + 1;
    goto LABEL_10;
  }

    if (v34) {
      free(v34);
    }
    os_log_type_t v21 = 0LL;
    goto LABEL_28;
  }

  __nwlog_obj();
  os_log_type_t v29 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
  os_log_type_t v30 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v49 = 0;
  if (__nwlog_fault(v30, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
        _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v49)
    {
      v37 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      addrinfo v38 = type;
      __int16 v39 = os_log_type_enabled(v31, type);
      if (v37)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v37;
          _os_log_impl( &dword_181A5C000,  v31,  v38,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v37);
        goto LABEL_59;
      }

      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
        _os_log_impl(&dword_181A5C000, v31, v38, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
        _os_log_impl( &dword_181A5C000,  v31,  v43,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v45) {
      free(v45);
    }
    mode = 0;
    goto LABEL_68;
  }

  mode = v5->mode;

  if (mode == 2)
  {
    id v8 = nw_endpoint_handler_copy_flow(v6);
    id v9 = v8;
    if ((*((_BYTE *)v8 + 32) & 2) == 0)
    {
      os_unfair_lock_lock((os_unfair_lock_t)v8 + 220);
      os_log_type_t v10 = (void *)*((void *)v9 + 117);
      if (v10)
      {
        id v11 = v10;
        os_log_type_t v12 = v11;
        os_log_type_t v13 = v11[29];
        if (v13 == 4)
        {
          nw_endpoint_fallback_reset_expected_progress_target(v11, a2);
        }

        else if (v13 == 2)
        {
          nw_endpoint_flow_reset_expected_progress_target(v11, a2, a3);
        }
      }

      v31 = (void *)*((void *)v9 + 116);
      if (v31)
      {
        id v32 = v31;
        id v33 = v32;
        id v34 = v32[29];
        if (v34 == 4)
        {
          nw_endpoint_fallback_reset_expected_progress_target(v32, a2);
        }

        else if (v34 == 2)
        {
          nw_endpoint_flow_reset_expected_progress_target(v32, a2, a3);
        }
      }

      os_unfair_lock_unlock((os_unfair_lock_t)v9 + 220);
LABEL_43:

      goto LABEL_102;
    }

    if (nw_endpoint_handler_get_minimize_logging(v6))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v6);
        loga = nw_endpoint_handler_dry_run_string(v6);
        v51 = nw_endpoint_handler_copy_endpoint(v6);
        logging_description = nw_endpoint_get_logging_description(v51);
        v53 = nw_endpoint_handler_state_string(v6);
        v54 = nw_endpoint_handler_mode_string(v6);
        v55 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        v79 = "nw_endpoint_flow_reset_expected_progress_target";
        v80 = 2082;
        v81 = (void *)id_string;
        v82 = 2082;
        v83 = loga;
        v84 = 2082;
        v85 = (void *)logging_description;
        v86 = 2082;
        v87 = v53;
        v88 = 2082;
        v89 = v54;
        v90 = 2114;
        v91 = v55;
        v92 = 2048;
        v93 = a2;
        _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Resetting progress target to %llu",  buf,  0x52u);
      }
    }

    else
    {
      os_log_type_t v14 = v6;
      os_log_type_t v15 = *((_BYTE *)v14 + 268);

      if ((v15 & 0x20) != 0)
      {
LABEL_37:
        *((_BYTE *)v9 + 34) = *((_BYTE *)v9 + 34) & 0xEF | (16 * (a2 != 0));
        *(_OWORD *)((char *)v9 + 1080) = *(_OWORD *)a3;
        v37 = (void *)*((void *)v9 + 1);
        if (v37)
        {
          addrinfo v38 = v37;
          __int16 v39 = v38[3];

          v40 = nw_path_copy_parameters(*((void **)v9 + 1));
          nw_connection_report_symptom_internal_on_nw_queue(421898, v39, v40, *((void **)v9 + 1), a2, a3, 0LL, 0, 0, 0);
        }

        if (*((void *)v9 + 111))
        {
          if (*((char *)v9 + 33) < 0)
          {
            uint64_t v41 = v6;
            state = v41->state;

            if (state == 3)
            {
              v43 = (void *)*((void *)v9 + 111);
              v75[0] = MEMORY[0x1895F87A8];
              v75[1] = 3221225472LL;
              v75[2] = __nw_endpoint_flow_reset_expected_progress_target_block_invoke;
              v75[3] = &__block_descriptor_40_e8_B12__0i8l;
              v75[4] = a2;
              nw_fd_wrapper_get_fd(v43, v75);
            }
          }
        }

        goto LABEL_43;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v16 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v17 = v14;

        BOOL v18 = v17;
        os_log_type_t v19 = *((_BYTE *)v14 + 268);

        if ((v19 & 1) != 0) {
          BOOL v20 = "dry-run ";
        }
        else {
          BOOL v20 = "";
        }
        os_log_type_t v21 = nw_endpoint_handler_copy_endpoint(v18);
        BOOL v22 = nw_endpoint_get_logging_description(v21);
        id_str = v17->id_str;
        char v23 = v18;
        os_log_type_t v24 = v23;
        BOOL v25 = v23[30];
        else {
          os_log_type_t v26 = off_189BBBBF0[v25];
        }
        v70 = v26;
        log = v16;

        BOOL v27 = v24;
        os_log_type_t v28 = v27;
        os_log_type_t v29 = v22;
        os_log_type_t v30 = "path";
        switch(v6->mode)
        {
          case 0:
            break;
          case 1:
            os_log_type_t v30 = "resolver";
            break;
          case 2:
            os_log_type_t v30 = nw_endpoint_flow_mode_string(v27[31]);
            break;
          case 3:
            os_log_type_t v30 = "proxy";
            break;
          case 4:
            os_log_type_t v30 = "fallback";
            break;
          case 5:
            os_log_type_t v30 = "transform";
            break;
          default:
            os_log_type_t v30 = "unknown-mode";
            break;
        }

        char v35 = v28;
        os_unfair_lock_lock((os_unfair_lock_t)v35 + 28);
        __int16 v36 = v35[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v35 + 28);

        *(_DWORD *)buf = 136448002;
        v79 = "nw_endpoint_flow_reset_expected_progress_target";
        v80 = 2082;
        v81 = id_str;
        v82 = 2082;
        v83 = v20;
        v84 = 2082;
        v85 = (void *)v29;
        v86 = 2082;
        v87 = v70;
        v88 = 2082;
        v89 = v30;
        v90 = 2114;
        v91 = v36;
        v92 = 2048;
        v93 = a2;
        os_log_type_t v16 = log;
        _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Resetting progress target to %llu",  buf,  0x52u);
      }
    }

    goto LABEL_37;
  }

    if (!v5)
    {
LABEL_67:
      close(kernel_socket_internal);
      return 0xFFFFFFFFLL;
    }

        _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0xCu);
        goto LABEL_66;
      }
    }

    __nwlog_obj();
    identifier = a1->identifier;
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    if (!identifier) {
      identifier = (nw_protocol_identifier *)"invalid";
    }
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = identifier;
    *(_WORD *)&buf[22] = 2048;
    v68 = a1;
    uint64_t v41 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v66 = 0;
    if (__nwlog_fault(v41, type, &v66))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v42 = (os_log_s *)__nwlog_obj();
        v43 = type[0];
        if (os_log_type_enabled(v42, type[0]))
        {
          v44 = a1->identifier;
          if (!v44) {
            v44 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v44;
          *(_WORD *)&buf[22] = 2048;
          v68 = a1;
          v45 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_150:
          _os_log_impl(&dword_181A5C000, v42, v43, v45, buf, 0x20u);
        }
      }

      else if (v66)
      {
        v49 = (char *)__nw_create_backtrace_string();
        v42 = (os_log_s *)__nwlog_obj();
        v43 = type[0];
        v50 = os_log_type_enabled(v42, type[0]);
        if (v49)
        {
          if (v50)
          {
            v51 = a1->identifier;
            if (!v51) {
              v51 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v51;
            *(_WORD *)&buf[22] = 2048;
            v68 = a1;
            LOWORD(v69[0]) = 2082;
            *(void *)((char *)v69 + 2) = v49;
            _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v49);
          goto LABEL_151;
        }

        if (v50)
        {
          v55 = a1->identifier;
          if (!v55) {
            v55 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v55;
          *(_WORD *)&buf[22] = 2048;
          v68 = a1;
          v45 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
          goto LABEL_150;
        }
      }

      else
      {
        v42 = (os_log_s *)__nwlog_obj();
        v43 = type[0];
        if (os_log_type_enabled(v42, type[0]))
        {
          v54 = a1->identifier;
          if (!v54) {
            v54 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v54;
          *(_WORD *)&buf[22] = 2048;
          v68 = a1;
          v45 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
          goto LABEL_150;
        }
      }
    }

    v40 = *((unsigned __int8 *)v17 + 6);
    if (v40 == *(unsigned __int8 *)(a1 + 156))
    {
      LOBYTE(v41) = 0;
      v42 = 0;
      LOWORD(v43) = 0;
      v44 = 40;
      goto LABEL_112;
    }

    v43 = 0;
    v42 = 0;
    uint64_t v41 = 0;
    v44 = 40;
    a7.n128_u64[0] = 136447490LL;
    v45 = "%{public}s %{public}s%s%p Received IPv6 extension type %u length %u";
    a8.n128_u64[0] = 136447746LL;
    while (1)
    {
      if ((*(_WORD *)(a2 + 204) & 0x80) != 0)
      {
        v124 = a7.n128_u32[0];
        if ((*(_BYTE *)(a1 + 158) & 1) != 0) {
          goto LABEL_112;
        }
        v130 = v42;
        v55 = v41;
        v56 = v43;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_process_input_frame";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 159;
        *(_WORD *)&buf[22] = 2080;
        v146 = " ";
        v147 = 2048;
        v148 = a1;
        v149 = 1024;
        LODWORD(v150) = v133;
        v57 = (const char *)_os_log_send_and_compose_impl();
        v144 = OS_LOG_TYPE_ERROR;
        v58 = (char *)v57;
        v143 = 0;
        if (__nwlog_fault(v57, &v144, &v143))
        {
          if (v144 != OS_LOG_TYPE_FAULT)
          {
            if (v143)
            {
              v62 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v63 = v144;
              v121 = (os_log_s *)gLogObj;
              v64 = os_log_type_enabled((os_log_t)gLogObj, v144);
              if (v62)
              {
                if (v64)
                {
                  *(_DWORD *)buf = v124;
                  *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_process_input_frame";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = a1 + 159;
                  *(_WORD *)&buf[22] = 2080;
                  v146 = " ";
                  v147 = 2048;
                  v148 = a1;
                  v149 = 1024;
                  LODWORD(v150) = v133;
                  WORD2(v150) = 2082;
                  *(void *)((char *)&v150 + 6) = v62;
                  _os_log_impl( &dword_181A5C000,  v121,  v63,  "%{public}s %{public}s%s%p Received IPv6 extension-headers on a super-packet of length %u, dumping ba cktrace:%{public}s",  buf,  0x3Au);
                }

                free(v62);
                goto LABEL_109;
              }

              if (!v64) {
                goto LABEL_109;
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 159;
              *(_WORD *)&buf[22] = 2080;
              v146 = " ";
              v147 = 2048;
              v148 = a1;
              v149 = 1024;
              LODWORD(v150) = v133;
              v61 = "%{public}s %{public}s%s%p Received IPv6 extension-headers on a super-packet of length %u, no backtrace";
              v72 = v121;
              v73 = v63;
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v59 = gLogObj;
              v60 = v144;
              if (!os_log_type_enabled((os_log_t)gLogObj, v144)) {
                goto LABEL_109;
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 159;
              *(_WORD *)&buf[22] = 2080;
              v146 = " ";
              v147 = 2048;
              v148 = a1;
              v149 = 1024;
              LODWORD(v150) = v133;
              v61 = "%{public}s %{public}s%s%p Received IPv6 extension-headers on a super-packet of length %u, backtrace limit exceeded";
LABEL_107:
              v72 = (os_log_s *)v59;
              v73 = v60;
            }

            _os_log_impl(&dword_181A5C000, v72, v73, v61, buf, 0x30u);
            goto LABEL_109;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v59 = gLogObj;
          v60 = v144;
          if (os_log_type_enabled((os_log_t)gLogObj, v144))
          {
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 159;
            *(_WORD *)&buf[22] = 2080;
            v146 = " ";
            v147 = 2048;
            v148 = a1;
            v149 = 1024;
            LODWORD(v150) = v133;
            v61 = "%{public}s %{public}s%s%p Received IPv6 extension-headers on a super-packet of length %u";
            goto LABEL_107;
          }
        }

            free(v46);
            goto LABEL_75;
          }

          if (!v48) {
            goto LABEL_75;
          }
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v40 = (os_log_s *)v47;
          uint64_t v41 = v231;
          v42 = "%{public}s No segment-count set on single-IP aggregate, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          v55 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_75;
          }
          *(_DWORD *)buf = 136446210;
          v254 = "nw_channel_add_input_frames";
          v40 = (os_log_s *)v54;
          uint64_t v41 = v55;
          v42 = "%{public}s No segment-count set on single-IP aggregate, backtrace limit exceeded";
        }
      }

  if (v33) {
    free(v33);
  }
LABEL_48:
}

    free(backtrace_string);
    goto LABEL_32;
  }

  v42 = v3[2];
  memset(__dst, 0, sizeof(__dst));
  address = nw_endpoint_get_address((nw_endpoint_t)v6);
  if (address)
  {
    sa_len = address->sa_len;
    if ((((_DWORD)sa_len - 1) & 0x80) == 0) {
      memcpy(__dst, address, sa_len);
    }
  }

  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  }
  os_log_type_t v10 = (id)nw_context_copy_implicit_context::implicit_context;
  nw_path_shared_necp_fd(v10);

  if (necp_client_action())
  {
    id v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    os_log_type_t v13 = v12;
    if (v11 == 2)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v44 = "nw_interface_copy_local_address_for_remote_address";
        v45 = 1024;
        v46 = 2;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d",  buf,  0x12u);
      }

      goto LABEL_34;
    }

    *(_DWORD *)buf = 136446466;
    v44 = "nw_interface_copy_local_address_for_remote_address";
    v45 = 1024;
    v46 = v11;
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v15, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_interface_copy_local_address_for_remote_address";
          v45 = 1024;
          v46 = v11;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d",  buf,  0x12u);
        }
      }

      else if (v40)
      {
        BOOL v18 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (os_log_s *)(id)gLogObj;
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v16, type);
        if (v18)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446722;
            v44 = "nw_interface_copy_local_address_for_remote_address";
            v45 = 1024;
            v46 = v11;
            v47 = 2082;
            v48 = v18;
            _os_log_impl( &dword_181A5C000,  v16,  v19,  "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v18);
          if (!v15) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }

        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_interface_copy_local_address_for_remote_address";
          v45 = 1024;
          v46 = v11;
          _os_log_impl( &dword_181A5C000,  v16,  v19,  "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, no backtrace",  buf,  0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (os_log_s *)(id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_interface_copy_local_address_for_remote_address";
          v45 = 1024;
          v46 = v11;
          _os_log_impl( &dword_181A5C000,  v16,  v21,  "%{public}s NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

LABEL_16:
}

      if (gLogDatapath)
      {
        __nwlog_obj();
        char v35 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s Querying QUIC for migration status",  buf,  0xCu);
        }
      }

      os_log_type_t v12 = v4[51];
      if (v12)
      {
        os_log_type_t v13 = *(void *)(v12 + 24);
        if (v13)
        {
          os_log_type_t v14 = *(uint64_t (**)(void))(v13 + 224);
          if (v14)
          {
            os_log_type_t v15 = v14();
            os_log_type_t v16 = (void **)v15;
            if (v15)
            {
              *((_BYTE *)v37 + 24) = (*(_BYTE *)(v15 + 12) & 2) != 0;
              nw_array_remove_all_objects(*(void *)v15);
              if (*v16) {
                os_release(*v16);
              }
              free(v16);
            }
          }
        }
      }

      goto LABEL_27;
    }

    __nwlog_obj();
    char v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v24, type, &v40))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type[0];
        if (os_log_type_enabled(v25, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }

      else if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v31 = type[0];
        id v32 = os_log_type_enabled(v25, type[0]);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v25,  v31,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_70;
        }

        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_181A5C000, v25, v31, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v34 = type[0];
        if (os_log_type_enabled(v25, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl( &dword_181A5C000,  v25,  v34,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  id v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
LABEL_23:
  id v7 = *(void *)(a1 + 32);
  id v8 = *(void *)(v7 + *v6);
  id v9 = *(void *)(v7 + 16);
  if (v9 && !nw_path_parameters_get_logging_disabled(*(void *)(v9 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v10 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      id v11 = *(void *)(a1 + 32);
      os_log_type_t v12 = *(void *)(a1 + 40);
      os_log_type_t v13 = *(_DWORD *)(v11 + 448);
      if (*(_BYTE *)(a1 + 49)) {
        os_log_type_t v14 = "Incremented";
      }
      else {
        os_log_type_t v14 = "Decremented";
      }
      os_log_type_t v15 = *(_BYTE *)(a1 + 48) == 0;
      os_log_type_t v16 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
      if (!*(_BYTE *)(a1 + 48)) {
        os_log_type_t v16 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
      }
      os_log_type_t v17 = *(void *)(v11 + *v16);
      BOOL v18 = "receive";
      v47 = 136447490;
      v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      v49 = 1024;
      if (v15) {
        BOOL v18 = "send";
      }
      *(_DWORD *)v50 = v13;
      *(_WORD *)&v50[4] = 2080;
      *(void *)&v50[6] = v14;
      *(_WORD *)&v50[14] = 2080;
      *(void *)&v50[16] = v18;
      *(_WORD *)&v50[24] = 2048;
      *(void *)&v50[26] = v12;
      v51 = 2048;
      v52 = v17;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] %s estimated bytes to %s by %llu, total now %llu",  (uint8_t *)&v47,  0x3Au);
    }
  }

  int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_estimated_byte_threshold_lower,  12582912LL);
  BOOL v20 = networkd_settings_get_int64_with_default((const char *)nw_setting_estimated_byte_threshold_upper, 31457280LL);
  os_log_type_t v21 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v21 && !nw_path_parameters_get_logging_disabled(*(void *)(v21 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v22 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      char v23 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      v47 = 136446978;
      v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      v49 = 1024;
      *(_DWORD *)v50 = v23;
      *(_WORD *)&v50[4] = 2048;
      *(void *)&v50[6] = int64_with_default;
      *(_WORD *)&v50[14] = 2048;
      *(void *)&v50[16] = v20;
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Using lower threshold %llu, upper threshold %llu",  (uint8_t *)&v47,  0x26u);
    }
  }

  os_log_type_t v24 = v4 < int64_with_default && v8 > int64_with_default;
  if (v24 || (v4 > int64_with_default ? (BOOL v25 = v8 >= int64_with_default) : (BOOL v25 = 1), !v25))
  {
    os_log_type_t v26 = *(void *)(*(void *)(a1 + 32) + 16LL);
    if (v26 && !nw_path_parameters_get_logging_disabled(*(void *)(v26 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v27 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v28 = *(void *)(a1 + 32);
        os_log_type_t v29 = *(_DWORD *)(v28 + 448);
        v31 = *(void *)(v28 + 296);
        os_log_type_t v30 = *(void *)(v28 + 304);
        v47 = 136446978;
        v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        v49 = 1024;
        *(_DWORD *)v50 = v29;
        *(_WORD *)&v50[4] = 2048;
        *(void *)&v50[6] = v31;
        *(_WORD *)&v50[14] = 2048;
        *(void *)&v50[16] = v30;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Crossed lower estimated byte threshold, sending notification (down: %llu, up: %llu)",  (uint8_t *)&v47,  0x26u);
      }
    }

    nw_connection_report_estimated_byte_threshold_change_on_queue( *(NWConcrete_nw_connection **)(a1 + 32),  v8,  *(unsigned __int8 *)(a1 + 48),  v8 > int64_with_default,  0);
  }

  if (v4 < v20 && v8 > v20 || v4 > v20 && v8 < v20)
  {
    id v32 = *(void *)(*(void *)(a1 + 32) + 16LL);
    if (v32 && !nw_path_parameters_get_logging_disabled(*(void *)(v32 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v33 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        id v34 = *(void *)(a1 + 32);
        char v35 = *(_DWORD *)(v34 + 448);
        v37 = *(void *)(v34 + 296);
        __int16 v36 = *(void *)(v34 + 304);
        v47 = 136446978;
        v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        v49 = 1024;
        *(_DWORD *)v50 = v35;
        *(_WORD *)&v50[4] = 2048;
        *(void *)&v50[6] = v37;
        *(_WORD *)&v50[14] = 2048;
        *(void *)&v50[16] = v36;
        _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] Crossed upper estimated byte threshold, sending notification (down: %llu, up: %llu)",  (uint8_t *)&v47,  0x26u);
      }
    }

    nw_connection_report_estimated_byte_threshold_change_on_queue( *(NWConcrete_nw_connection **)(a1 + 32),  v8,  *(unsigned __int8 *)(a1 + 48),  v8 > v20,  1);
  }

    goto LABEL_17;
  }

  id v5 = v4;
  if (duration <= v4)
  {
LABEL_17:
    id v7 = 0LL;
    goto LABEL_18;
  }

  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  id v6 = (os_log_s *)(id)gactivityLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543874;
    v31 = (const char *)v2;
    id v32 = 2048;
    id v33 = duration;
    id v34 = 2048;
    char v35 = v5;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}@ over threshold (duration %llums exceeds threshold %llums)",  buf,  0x20u);
  }

  id v7 = 1LL;
LABEL_18:

  return v7;
}

        v61 = v70;
        goto LABEL_17;
      }
    }

    *(void *)(v13 + ((a1 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << a1) - 1;
    uint64_t result = swift_release();
    id v1 = v24;
  }

  else
  {
    *(void *)(v8 + ((a1 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << a1) - 1;
  }

  BOOL v20 = *v1;
  os_log_type_t v21 = *(void *)(*v1 + 16);
  BOOL v22 = __OFSUB__(v21, 1LL);
  char v23 = v21 - 1;
  if (v22)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v20 + 16) = v23;
    ++*(_DWORD *)(v20 + 36);
  }

  return result;
}

  if (a4 != a5)
  {
LABEL_24:
    __break(1u);
    goto LABEL_25;
  }

  return result;
}

  os_log_type_t v12 = (void *)MEMORY[0x18961AFE8];
LABEL_17:
  if (v12[2])
  {
    swift_beginAccess();
    sub_181C20890((uint64_t)v12);
    swift_endAccess();
    swift_bridgeObjectRelease();
    BOOL v18 = *v5;
    swift_beginAccess();
    *(void *)(v18 + 24) = 0LL;
  }

  return swift_bridgeObjectRelease();
}

  char v23 = v6 | (v5 << 32);
  sub_181BBE220();
  swift_allocError();
  if (HIDWORD(v23) <= 0xFE)
  {
    *(_DWORD *)os_log_type_t v24 = v6;
    *(_BYTE *)(v24 + 4) = BYTE4(v23);
  }

  else
  {
    *(_DWORD *)os_log_type_t v24 = 22;
    *(_BYTE *)(v24 + 4) = 0;
  }

  __swift_instantiateConcreteTypeFromMangledName(&qword_18C58E000);
  return sub_18264ED78();
}

  BOOL v25 = v8 | (v7 << 32);
  aBlock = 0LL;
  id v34 = 0LL;
  char v35 = 0LL;
  __int16 v36 = 1LL;
  LOBYTE(v37) = 0;
  if (BYTE4(v25) == 255LL)
  {
    id v32 = 0;
    LODWORD(v25) = 22;
  }

  else
  {
    id v32 = (v8 | (unint64_t)(v7 << 32)) >> 32;
  }

  v31 = v25;
  return ((uint64_t (*)(uint64_t *, int *))a6)(&aBlock, &v31);
}

  os_log_type_t v17 = v8 | (v7 << 32);
  sub_181BBE220();
  swift_allocError();
  if (HIDWORD(v17) <= 0xFE)
  {
    *(_DWORD *)BOOL v18 = v8;
    *(_BYTE *)(v18 + 4) = BYTE4(v17);
  }

  else
  {
    *(_DWORD *)BOOL v18 = 22;
    *(_BYTE *)(v18 + 4) = 0;
  }

  __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_18C58D6A0);
  sub_18264ED90();
  return sub_18264ED78();
}

  os_log_type_t v29 = v20 | (v19 << 32);
  sub_181BBE220();
  os_log_type_t v30 = swift_allocError();
  if (HIDWORD(v29) <= 0xFE)
  {
    *(_DWORD *)v31 = v20;
    *(_BYTE *)(v31 + 4) = BYTE4(v29);
  }

  else
  {
    *(_DWORD *)v31 = 22;
    *(_BYTE *)(v31 + 4) = 0;
  }

  aBlock[0] = v30;
  __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_18C58D6A0);
  sub_18264ED90();
  return sub_18264ED78();
}

              uint64_t result = sub_181C93190(v15, v14, 0);
              os_log_type_t v15 = __clz(__rbit64(v27)) | (v25 << 6);
            }

            BOOL v20 = a5;
            goto LABEL_5;
          }

          uint64_t result = sub_181C93190(v15, v14, 0);
          os_log_type_t v15 = v21;
        }

    os_log_type_t v13 = (void *)MEMORY[0x18961AFE8];
LABEL_17:
    swift_unknownObjectRelease();
    a4 = v23;
LABEL_19:
    uint64_t result = swift_unknownObjectRelease();
    goto LABEL_20;
  }

  __break(1u);
  return result;
}

  if (v1) {
    free(v1);
  }
  nw::object::_class((nw::object *)v2);
  return &nw::object::_class(void)::instance;
}

  if (gLogDatapath)
  {
    BOOL v27 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      id v33 = "decode";
      id v34 = 2048;
      char v35 = a3;
      _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEBUG,  "%{public}s finished processing %zu bytes of compressed data",  buf,  0x16u);
    }
  }

  os_log_type_t v17 = v11 - *(unsigned int *)(a1 + 40) + 0x4000;
  if (v13 != 1) {
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 16))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v18 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      id v33 = "decode";
      _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_ERROR, "%{public}s extra data", buf, 0xCu);
    }
  }

  *a5 = 1;
  return v17;
}

      if ((char)a1->__r_.__value_.__s.__size_ < 0)
      {
        if (a1->__r_.__value_.__l.__size_) {
          return;
        }
      }

      else if (a1->__r_.__value_.__s.__size_)
      {
        return;
      }

      id v7 = *(_BYTE *)(a2 + 519);
      if (v7 < 0)
      {
        if (*(void *)(a2 + 504))
        {
LABEL_22:
          if (v4 != a1)
          {
            if ((a1->__r_.__value_.__s.__size_ & 0x80) != 0)
            {
              if (v7 >= 0) {
                uint64_t v41 = (void *)(a2 + 496);
              }
              else {
                uint64_t v41 = *(void **)(a2 + 496);
              }
              if (v7 >= 0) {
                v42 = *(unsigned __int8 *)(a2 + 519);
              }
              else {
                v42 = *(void *)(a2 + 504);
              }
              std::string::__assign_no_alias<false>((void **)&a1->__r_.__value_.__l.__data_, v41, v42);
            }

            else if ((*(_BYTE *)(a2 + 519) & 0x80) != 0)
            {
              std::string::__assign_no_alias<true>(a1, *(void **)(a2 + 496), *(void *)(a2 + 504));
            }

            else
            {
              *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
              a1->__r_.__value_.__l.__cap_ = *(void *)(a2 + 512);
            }
          }

          return;
        }
      }

      else if (*(_BYTE *)(a2 + 519))
      {
        goto LABEL_22;
      }

      std::string::__assign_external(a1, "application/octet-stream", 0x18uLL);
      return;
    }

    switch(*((_DWORD *)v5 + 10))
    {
      case 0:
        if (*(char *)(a2 + 519) < 0)
        {
          std::string::__init_copy_ctor_external( &v81,  *(const std::string::value_type **)(a2 + 496),  *(void *)(a2 + 504));
        }

        else
        {
          *(_OWORD *)&v81.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
          v81.__r_.__value_.__l.__cap_ = *(void *)(a2 + 512);
        }

        size = v81.__r_.__value_.__s.__size_;
        if ((v81.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          size = v81.__r_.__value_.__l.__size_;
        }
        if (!size) {
          std::string::__assign_external(&v81, (const std::string::value_type *)kNWMIMETypeTextHTML);
        }
        v44 = *(unsigned __int8 **)(a2 + 520);
        v45 = *(unsigned __int8 **)(a2 + 528);
        if (v44 == v45)
        {
          buf = v81;
          memset(&v81, 0, sizeof(v81));
          goto LABEL_191;
        }

        v46 = 0LL;
        memset(&buf, 0, sizeof(buf));
        v47 = v45 - v44;
        if (v47 >= 0x200) {
          v47 = 512LL;
        }
        if (v47 >= 3)
        {
          if (*v44 == 239 && v44[1] == 187)
          {
            if (v44[2] == 191) {
              v46 = 3LL;
            }
            else {
              v46 = 0LL;
            }
          }

          else
          {
            v46 = 0LL;
          }
        }

        if (v46 >= v47) {
          goto LABEL_188;
        }
        v52 = v44 + 2;
        while (2)
        {
          while (2)
          {
            if ((char)v44[v46] <= 0x20 && ((1LL << v44[v46]) & 0x100002600LL) != 0)
            {
              v54 = v46 + 1;
              goto LABEL_147;
            }

            if (v44[v46] != 60 || v46 + 3 >= v47) {
              goto LABEL_188;
            }
            v54 = v46 + 1;
            v56 = &v44[v46 + 1];
            if (*(_WORD *)v56 == 11553 && v56[2] == 45)
            {
              if (v46 + 6 >= v47) {
                goto LABEL_188;
              }
              v61 = v46 + 4;
              while (*(_WORD *)&v44[v61] != 11565 || v44[v61 + 2] != 62)
              {
                v63 = v61 + 3;
                ++v61;
                if (v63 >= v47) {
                  goto LABEL_188;
                }
              }

              v46 = v61 + 3;
LABEL_187:
              if (v46 >= v47) {
                goto LABEL_188;
              }
              continue;
            }

            break;
          }

          v58 = *v56;
          if (v58 == 33)
          {
            while (v46 + 2 < v47)
            {
              v60 = v52[v46++];
              if (v60 == 62)
              {
                v46 += 2LL;
                goto LABEL_187;
              }
            }
          }

          else
          {
            if (v58 == 63)
            {
              while (v46 + 3 < v47)
              {
                v59 = *(unsigned __int16 *)&v52[v46++];
                if (v59 == 15935)
                {
                  v46 += 3LL;
                  goto LABEL_187;
                }
              }

              break;
            }

            if (*(_WORD *)v56 == 29554 && v56[2] == 115)
            {
LABEL_234:
              buf.__r_.__value_.__s.__size_ = 19;
              strcpy((char *)&buf, "application/rss+xml");
              goto LABEL_191;
            }

            if (v46 + 4 < v47)
            {
              if (*(_DWORD *)v56 == 1684366694)
              {
                buf.__r_.__value_.__s.__size_ = 20;
                strcpy((char *)&buf, "application/atom+xml");
                goto LABEL_191;
              }

              if (v46 + 7 < v47)
              {
                v65 = *(_DWORD *)v56;
                v66 = *(_DWORD *)(v56 + 3);
                if (v65 != 979788914 || v66 != 1178882618)
                {
LABEL_147:
                  v46 = v54;
                  if (v54 >= v47) {
                    break;
                  }
                  continue;
                }

                LOBYTE(v78) = 0;
                LOBYTE(v79) = 0;
                while (1)
                {
                  if (v79)
                  {
                    v79 = 1;
                  }

                  else
                  {
                    if (v54 + 23 >= v47) {
                      goto LABEL_188;
                    }
                    v79 = (*(void *)&v44[v54] ^ 0x702F2F3A70747468LL | *(void *)&v44[v54 + 8] ^ 0x2F67726F2E6C7275LL | *(void *)&v44[v54 + 16] ^ 0x2F302E312F737372LL) == 0;
                    if (!(*(void *)&v44[v54] ^ 0x702F2F3A70747468LL | *(void *)&v44[v54 + 8] ^ 0x2F67726F2E6C7275LL | *(void *)&v44[v54 + 16] ^ 0x2F302E312F737372LL)) {
                      v54 += 23LL;
                    }
                  }

                  if (v78)
                  {
                    v78 = 1;
                  }

                  else
                  {
                    if (v54 + 42 >= v47) {
                      goto LABEL_188;
                    }
                    v78 = (*(void *)&v44[v54] ^ 0x772F2F3A70747468LL | *(void *)&v44[v54 + 8] ^ 0x726F2E33772E7777LL | *(void *)&v44[v54 + 16] ^ 0x302F393939312F67LL | *(void *)&v44[v54 + 24] ^ 0x6664722D32322F32LL | *(void *)&v44[v54 + 32] ^ 0x2D7861746E79732DLL | *(void *)&v44[v54 + 35] ^ 0x23736E2D7861746ELL) == 0;
                    if (!(*(void *)&v44[v54] ^ 0x772F2F3A70747468LL | *(void *)&v44[v54 + 8] ^ 0x726F2E33772E7777LL | *(void *)&v44[v54 + 16] ^ 0x302F393939312F67LL | *(void *)&v44[v54 + 24] ^ 0x6664722D32322F32LL | *(void *)&v44[v54 + 32] ^ 0x2D7861746E79732DLL | *(void *)&v44[v54 + 35] ^ 0x23736E2D7861746ELL)) {
                      v54 += 42LL;
                    }
                  }

                  if (v79 && v78) {
                    goto LABEL_234;
                  }
                  if (++v54 >= v47) {
                    goto LABEL_188;
                  }
                }
              }
            }
          }

          break;
        }

  __break(1u);
}

  while (1)
  {
    os_log_type_t v30 = 0LL;
    v31 = &v30;
    nw_protocol_plugin_metadata_get_and_process_frames( a1,  a2,  a2[6],  v36,  &v36,  &v35,  &v34,  &v33,  &v32,  *(void *)(a1 + 96),  &v30);
    if (!v30) {
      break;
    }
    **(void **)(a1 + 24) = v30;
    os_log_type_t v13 = v31;
    *(void *)(v30 + 40) = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v13;
    os_log_type_t v30 = 0LL;
    v31 = &v30;
    id v32 = 0;
  }

  id v3 = *(_BYTE *)(a1 + 142) | 0x10;
  *(_BYTE *)(a1 + 142) = v3;
  return (v3 & 1) == 0 || *(_BYTE *)(a1 + 140) != 2;
}

  return v12;
}

        os_log_type_t v17 = "<NULL>";
        goto LABEL_17;
      }

      if (!*(_DWORD *)&a6->sa_data[6]
        && !*(_DWORD *)&a6->sa_data[10]
        && !*(_DWORD *)&a6[1].sa_len
        && !*(_DWORD *)&a6[1].sa_data[2])
      {
        os_log_type_t v17 = "IN6ADDR_ANY";
        goto LABEL_17;
      }

      os_log_type_t v17 = (const char *)v70;
      __nwlog_salted_hash(&a6->sa_data[6], 16LL, (char *)v70);
      BOOL v18 = "IPv6#";
      if ((*((_BYTE *)v15 + 346) & 0x20) == 0) {
        goto LABEL_27;
      }
    }

    else if ((*((_BYTE *)v15 + 346) & 0x20) == 0)
    {
      if (*((_BYTE *)v15 + 256))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v19 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a4);
          if (a6) {
            sa_len = a6->sa_len;
          }
          else {
            sa_len = 0;
          }
          *(_DWORD *)buf = 136448514;
          v66 = "nw_resolver_host_resolve_callback";
          v67 = 2082;
          *(void *)v68 = v15 + 32;
          *(_WORD *)&v68[8] = 1024;
          *(_DWORD *)&v68[10] = a2;
          *(_WORD *)&v68[14] = 1024;
          *(_DWORD *)&v68[16] = a3;
          *(_WORD *)&v68[20] = 2082;
          *(void *)&v68[22] = string_for_dns_service_error;
          *(_WORD *)&v68[30] = 1024;
          *(_DWORD *)&v68[32] = a4;
          *(_WORD *)&v68[36] = 2082;
          *(void *)&v68[38] = a5;
          *(_WORD *)&v68[46] = 1040;
          *(_DWORD *)&v68[48] = sa_len;
          *(_WORD *)&v68[52] = 2098;
          *(void *)&v68[54] = a6;
          *(_WORD *)&v68[62] = 1024;
          *(_DWORD *)&v68[64] = a7;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s] flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public,networ k:sockaddr}.*P ttl=%d",  buf,  0x52u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v19 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          BOOL v22 = *((_DWORD *)v15 + 85);
          char v23 = nwlog_get_string_for_dns_service_error(a4);
          if (a6) {
            os_log_type_t v24 = a6->sa_len;
          }
          else {
            os_log_type_t v24 = 0;
          }
          *(_DWORD *)buf = 136448514;
          v66 = "nw_resolver_host_resolve_callback";
          v67 = 1024;
          *(_DWORD *)v68 = v22;
          *(_WORD *)&v68[4] = 1024;
          *(_DWORD *)&v68[6] = a2;
          *(_WORD *)&v68[10] = 1024;
          *(_DWORD *)&v68[12] = a3;
          *(_WORD *)&v68[16] = 2082;
          *(void *)&v68[18] = v23;
          *(_WORD *)&v68[26] = 1024;
          *(_DWORD *)&v68[28] = a4;
          *(_WORD *)&v68[32] = 2082;
          *(void *)&v68[34] = a5;
          *(_WORD *)&v68[42] = 1040;
          *(_DWORD *)&v68[44] = v24;
          *(_WORD *)&v68[48] = 2098;
          *(void *)&v68[50] = a6;
          *(_WORD *)&v68[58] = 1024;
          *(_DWORD *)&v68[60] = a7;
          _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_INFO,  "%{public}s [R%u] flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public,network:sockaddr}.*P ttl=%d",  buf,  0x4Eu);
        }
      }

      goto LABEL_42;
    }

  os_log_type_t v13 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v13 + 24))
  {
    *(_BYTE *)(v13 + 24) = 0;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = ___ZL40nw_resolver_should_wait_for_awdl_triggerP22NWConcrete_nw_resolver_block_invoke_243;
    aBlock[3] = &unk_189BC93A0;
    os_log_type_t v16 = v7;
    os_log_type_t v14 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v7 + 3);
    v14[2](v14);
    os_unfair_lock_unlock(v7 + 3);
  }

LABEL_2:
}

  BOOL v18 = *(void (***)(void, void))(a1 + 48);
  if (v18)
  {
    if (*(_BYTE *)(a1 + 64))
    {
      v18[2](v18, *(void *)(a1 + 32));
    }

    else
    {
      os_log_type_t v19 = *(dispatch_queue_s **)(a1 + 40);
      block[0] = v3;
      block[1] = 3221225472LL;
      block[2] = ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_211;
      block[3] = &unk_189BC91E8;
      __int16 v39 = v18;
      addrinfo v38 = *(id *)(a1 + 32);
      dispatch_async(v19, block);
    }
  }

  _Block_object_dispose(&v45, 8);
}

    id v11 = *(void **)(a1 + 32);
    os_log_type_t v12 = *(void **)(a1 + 40);
    os_log_type_t v13 = (uint64_t *)(a1 + 32);
    nw_connection_group_set_state_locked(v11, 2, v12);
    CFIndex v2 = *v13;
    id v6 = *(_BYTE *)(*v13 + 190);
    goto LABEL_17;
  }

  id v6 = *(_BYTE *)(v2 + 190);
  if ((v6 & 0x40) != 0)
  {
    if (!nw_parameters_get_logging_disabled(*(void *)(v2 + 56)))
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      id v7 = (os_log_s *)(id)gconnection_groupLogObj;
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      id v8 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      os_log_type_t v14 = 136446466;
      os_log_type_t v15 = "nw_connection_group_handle_listener_state_change_block_invoke";
      os_log_type_t v16 = 1024;
      os_log_type_t v17 = v8;
      id v9 = "%{public}s [G%u] multiplex group listener ready and first connection ready";
LABEL_14:
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v14, 0x12u);
LABEL_15:

      goto LABEL_16;
    }

    goto LABEL_16;
  }
      }
    }

    else if (!logging_disabled)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      os_log_type_t v13 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v15 = v9[42]._os_unfair_lock_opaque;
        if (v5) {
          os_log_type_t v16 = "true";
        }
        else {
          os_log_type_t v16 = "false";
        }
        os_log_type_t v17 = _Block_copy(v10);
        *(_DWORD *)buf = 136447234;
        addrinfo v38 = "nw_connection_group_set_receive_handler";
        __int16 v39 = 1024;
        *(_DWORD *)v40 = v15;
        *(_WORD *)&v40[4] = 1024;
        *(_DWORD *)&v40[6] = maximum_message_size;
        uint64_t v41 = 2080;
        v42 = v16;
        v43 = 2048;
        v44 = v17;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] set maximum message size: %u, reject oversized messages: %s, handler: %p",  buf,  0x2Cu);
      }

      goto LABEL_16;
    }

    _Block_object_dispose(type, 8);
    goto LABEL_18;
  }

  __nwlog_obj();
  BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  addrinfo v38 = "nw_connection_group_set_receive_handler";
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  __int16 v36 = 0;
  if (__nwlog_fault(v19, type, &v36))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type[0];
      if (os_log_type_enabled(v20, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_connection_group_set_receive_handler";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null group", buf, 0xCu);
      }
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v23 = type[0];
      os_log_type_t v24 = os_log_type_enabled(v20, type[0]);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          addrinfo v38 = "nw_connection_group_set_receive_handler";
          __int16 v39 = 2082;
          *(void *)v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s called with null group, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_connection_group_set_receive_handler";
        _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v25 = type[0];
      if (os_log_type_enabled(v20, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        addrinfo v38 = "nw_connection_group_set_receive_handler";
        _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null group, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

            if (*(_UNKNOWN **)(a3 + 40) == &nw_protocol_ref_counted_handle)
            {
              os_log_type_t v24 = *(void *)(a3 + 88);
              if (v24)
              {
                BOOL v25 = v24 - 1;
                *(void *)(a3 + 88) = v25;
                if (!v25)
                {
                  os_log_type_t v26 = *(void (***)(void))(a3 + 64);
                  if (v26)
                  {
                    *(void *)(a3 + 64) = 0LL;
                    v26[2](v26);
                    _Block_release(v26);
                  }

                  if ((*(_BYTE *)(a3 + 72) & 1) != 0)
                  {
                    BOOL v27 = *(const void **)(a3 + 64);
                    if (v27) {
                      _Block_release(v27);
                    }
                  }

                  free((void *)a3);
                }
              }
            }

            goto LABEL_17;
          }
        }

        __nwlog_obj();
        os_log_type_t v28 = *(const char **)(a1 + 16);
        *(_DWORD *)buf = 136446722;
        v63 = "__nw_protocol_replace_input_handler";
        if (!v28) {
          os_log_type_t v28 = "invalid";
        }
        v64 = 2082;
        v65 = (void *)v28;
        v66 = 2048;
        v67 = a1;
        os_log_type_t v29 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v60 = 0;
        if (__nwlog_fault(v29, &type, &v60))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v30 = (os_log_s *)__nwlog_obj();
            v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_94;
            }
            id v32 = *(const char **)(a1 + 16);
            if (!v32) {
              id v32 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v63 = "__nw_protocol_replace_input_handler";
            v64 = 2082;
            v65 = (void *)v32;
            v66 = 2048;
            v67 = a1;
            id v33 = "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback";
LABEL_92:
            v57 = v30;
LABEL_93:
            _os_log_impl(&dword_181A5C000, v57, v31, v33, buf, 0x20u);
            goto LABEL_94;
          }

          if (!v60)
          {
            os_log_type_t v30 = (os_log_s *)__nwlog_obj();
            v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_94;
            }
            v56 = *(const char **)(a1 + 16);
            if (!v56) {
              v56 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v63 = "__nw_protocol_replace_input_handler";
            v64 = 2082;
            v65 = (void *)v56;
            v66 = 2048;
            v67 = a1;
            id v33 = "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded";
            goto LABEL_92;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          v47 = (os_log_s *)__nwlog_obj();
          v31 = type;
          log = v47;
          v48 = os_log_type_enabled(v47, type);
          if (backtrace_string)
          {
            if (v48)
            {
              v49 = *(const char **)(a1 + 16);
              if (!v49) {
                v49 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              v63 = "__nw_protocol_replace_input_handler";
              v64 = 2082;
              v65 = (void *)v49;
              v66 = 2048;
              v67 = a1;
              v68 = 2082;
              v69 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  log,  v31,  "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
          }

          else if (v48)
          {
            v58 = *(const char **)(a1 + 16);
            if (!v58) {
              v58 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v63 = "__nw_protocol_replace_input_handler";
            v64 = 2082;
            v65 = (void *)v58;
            v66 = 2048;
            v67 = a1;
            id v33 = "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace";
            v57 = log;
            goto LABEL_93;
          }
        }

    free(v10);
    goto LABEL_17;
  }

  id v6 = &OBJC_CLASS___NWStreamConnection;
LABEL_5:
  id v7 = (void *)[[v6 alloc] initWithInternalConnection:v3];
LABEL_18:

  return v7;
}

      os_log_type_t v13 = 0LL;
      goto LABEL_17;
    }

    __nwlog_obj();
    BOOL v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_flow_replay_updated_path";
    char v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault(v23, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_flow_replay_updated_path";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        v31 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_flow_replay_updated_path";
            uint64_t v41 = 2082;
            v42 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v30,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_54;
        }

        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_flow_replay_updated_path";
          _os_log_impl(&dword_181A5C000, v24, v30, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v33 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_flow_replay_updated_path";
          _os_log_impl( &dword_181A5C000,  v24,  v33,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      id v11 = 0LL;
      goto LABEL_17;
    }

    __nwlog_obj();
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v36 = "nw_flow_replay_connect";
    os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v33 = 0;
    if (__nwlog_fault(v21, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v36 = "nw_flow_replay_connect";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        os_log_type_t v29 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v36 = "nw_flow_replay_connect";
            v37 = 2082;
            addrinfo v38 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v22,  v28,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_54;
        }

        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v36 = "nw_flow_replay_connect";
          _os_log_impl(&dword_181A5C000, v22, v28, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v31 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v36 = "nw_flow_replay_connect";
          _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      return;
    }

    __nwlog_obj();
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v34 = "nw_flow_replay_disconnect";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v19, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_flow_replay_disconnect";
          _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        BOOL v27 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            id v34 = "nw_flow_replay_disconnect";
            char v35 = 2082;
            __int16 v36 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v26,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_52;
        }

        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_flow_replay_disconnect";
          _os_log_impl(&dword_181A5C000, v20, v26, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_flow_replay_disconnect";
          _os_log_impl( &dword_181A5C000,  v20,  v29,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      os_log_type_t v17 = 0LL;
      goto LABEL_17;
    }

    __nwlog_obj();
    os_log_type_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_flow_replay_register_notification";
    BOOL v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v27, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v43 = "nw_flow_replay_register_notification";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v34 = type;
        char v35 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            v43 = "nw_flow_replay_register_notification";
            v44 = 2082;
            v45 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v34,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_54;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          v43 = "nw_flow_replay_register_notification";
          _os_log_impl(&dword_181A5C000, v28, v34, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v43 = "nw_flow_replay_register_notification";
          _os_log_impl( &dword_181A5C000,  v28,  v37,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      os_log_type_t v13 = 0LL;
      goto LABEL_17;
    }

    __nwlog_obj();
    BOOL v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v39 = "nw_flow_replay_unregister_notification";
    char v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v36 = 0;
    if (__nwlog_fault(v23, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v39 = "nw_flow_replay_unregister_notification";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        v31 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v39 = "nw_flow_replay_unregister_notification";
            v40 = 2082;
            uint64_t v41 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v30,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_54;
        }

        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v39 = "nw_flow_replay_unregister_notification";
          _os_log_impl(&dword_181A5C000, v24, v30, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v33 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v39 = "nw_flow_replay_unregister_notification";
          _os_log_impl( &dword_181A5C000,  v24,  v33,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  nw_frame_finalize(*(void *)(a1 + 32));
  id v4 = v79;
  id v9 = v77;
LABEL_20:
  os_log_type_t v29 = v7 != v9;

  return v29;
}

    return;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  os_log_type_t v29 = 136446210;
  os_log_type_t v30 = "nw_listener_set_advertise_descriptor_block_invoke";
  LODWORD(v22) = 12;
  os_log_type_t v21 = &v29;
  id v5 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v5))
  {
    free(v5);
    id v3 = *(os_unfair_lock_s **)(a1 + 32);
    goto LABEL_5;
  }

  __break(1u);
}

    domain_for_policy = 0LL;
    goto LABEL_56;
  }

  os_log_type_t v10 = v5;
  id v9 = (const char *)[v10 hostname];

  address = 0LL;
LABEL_7:
  if (strcmp(a2, "*"))
  {
    __dst = 0LL;
    v58 = 0LL;
    v60 = 0;
    v59 = 0LL;
    v54 = 0LL;
    v55[0] = 0LL;
    v56 = 0;
    v55[1] = 0LL;
    v53 = 0;
    *(void *)buf = 0LL;
    if (getaddrinfo(a2, 0LL, &nw_string_is_ip_address::hints, (addrinfo **)buf))
    {
      if (!nw_utilities_cidr_string_to_subnet_and_mask(a2, (uint64_t)&__dst, (uint64_t)&v54, &v53))
      {
        if (v9)
        {
          BOOL v22 = nw_endpoint_proxy_string_matches_pattern(v9, a2);
        }

        else
        {
          if (domain_for_policy) {
            domain_for_policy = nw_endpoint_proxy_string_matches_pattern((const char *)domain_for_policy, a2);
          }
          if ((domain_for_policy & 1) != 0 || !address) {
            goto LABEL_55;
          }
          if (address->sa_family != 2) {
            goto LABEL_54;
          }
          *(void *)buf = 0LL;
          *(void *)&buf[8] = 0LL;
          os_log_type_t v26 = inet_ntop(2, &address->sa_data[2], buf, 0x10u);
          if (!v26) {
            goto LABEL_54;
          }
          BOOL v22 = nw_endpoint_proxy_string_matches_pattern(v26, a2);
        }

        domain_for_policy = v22;
        goto LABEL_55;
      }

      if (address)
      {
        sa_family = address->sa_family;
        if (sa_family == BYTE1(__dst))
        {
          if (sa_family == 30)
          {
            os_log_type_t v12 = &address->sa_data[6];
            os_log_type_t v13 = (unsigned __int8 *)&v58;
            os_log_type_t v14 = (unsigned __int8 *)v55;
            os_log_type_t v15 = 16LL;
LABEL_58:
            os_log_type_t v28 = v15 - 1;
            do
            {
              os_log_type_t v30 = *v12++;
              os_log_type_t v29 = v30;
              id v32 = *v14++;
              v31 = v32;
              id v33 = *v13++;
              id v34 = (v33 ^ v29) & v31;
              domain_for_policy = v34 == 0;
              __int16 v36 = v28-- != 0;
            }

            while (!v34 && v36);
            goto LABEL_55;
          }

          if (sa_family == 2)
          {
            os_log_type_t v12 = &address->sa_data[2];
            os_log_type_t v13 = (unsigned __int8 *)&__dst + 4;
            os_log_type_t v14 = (unsigned __int8 *)&v54 + 4;
            os_log_type_t v15 = 4LL;
            goto LABEL_58;
          }
        }
      }
    }

    else
    {
      os_log_type_t v17 = *(addrinfo **)buf;
      if (*(void *)buf)
      {
        BOOL v18 = *(void *)buf;
        while (1)
        {
          os_log_type_t v19 = *(unsigned __int8 **)(v18 + 32);
          BOOL v20 = v19[1];
          if (v20 == 30 || v20 == 2) {
            break;
          }
          BOOL v18 = *(void *)(v18 + 40);
          if (!v18) {
            goto LABEL_33;
          }
        }

        char v23 = *v19;
        if (v23 <= 0x1C) {
          memcpy(&__dst, v19, v23);
        }
LABEL_33:
        freeaddrinfo(v17);
      }

      if (address)
      {
        os_log_type_t v24 = address->sa_family;
        if (v24 == 2 && BYTE1(__dst) == 2)
        {
          domain_for_policy = *(_DWORD *)&address->sa_data[2] == HIDWORD(__dst);
          goto LABEL_55;
        }

        domain_for_policy = 0LL;
        if (v24 != 30 || BYTE1(__dst) != 30)
        {
LABEL_55:
          if (gLogDatapath)
          {
            __nwlog_obj();
            v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
            {
              v49 = "does not match";
              *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_match_pattern_to_endpoint";
              *(_WORD *)&buf[12] = 2114;
              *(_DWORD *)buf = 136446978;
              *(void *)&buf[14] = v5;
              if ((_DWORD)domain_for_policy) {
                v49 = "matches";
              }
              v62 = 2082;
              v63 = v49;
              v64 = 2082;
              v65 = a2;
              _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s endpoint %{public}@ %{public}s pattern string %{public}s",  buf,  0x2Au);
            }
          }

          goto LABEL_56;
        }

        if (*(_DWORD *)&address[1].sa_data[6] == v60)
        {
          domain_for_policy = *(void *)&address->sa_data[6] == v58 && *(void *)&address[1].sa_len == v59;
          goto LABEL_55;
        }
      }
    }

    os_log_type_t v10 = *(void *)(a1 + 32);
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  v61 = __Block_byref_object_copy__248;
  *(void *)&v62 = __Block_byref_object_dispose__249;
  *((void *)&v62 + 1) = 0LL;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZL52nw_masque_listener_pair_setup_outer_connection_groupP34NWConcrete_nw_masque_listener_pairhPU29objcproto18OS_nw_http_request8NSObject_block_invoke_314;
  aBlock[3] = &unk_189BC9210;
  v55 = buf;
  v54 = (id)v10;
  char v23 = (void (**)(void))_Block_copy(aBlock);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 8));
  v23[2](v23);
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 8));

  os_log_type_t v24 = *(void *)(*(void *)&buf[8] + 40LL);
  if (v24) {
    (*(void (**)(uint64_t, void, void *(*)(uint64_t, uint64_t)))(v24 + 16))( v24,  dword_18272D850[a2 - 1],  v5);
  }

  _Block_object_dispose(buf, 8);
LABEL_20:
}
      }
    }

    else if ((nw_endpoint_handler_get_logging_disabled(v8) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v11 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v19 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 48));
        BOOL v20 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 48));
        os_log_type_t v21 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 48));
        BOOL v22 = nw_endpoint_get_logging_description(v21);
        char v23 = nw_endpoint_handler_state_string(*(void **)(a1 + 48));
        os_log_type_t v24 = nw_endpoint_handler_mode_string(*(void **)(a1 + 48));
        BOOL v25 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 48));
        id v33 = 136448002;
        id v34 = "nw_endpoint_resolver_update_path_resolver_locked_block_invoke";
        char v35 = 2082;
        __int16 v36 = v19;
        v37 = 2082;
        addrinfo v38 = v20;
        __int16 v39 = 2082;
        v40 = v22;
        uint64_t v41 = 2082;
        v42 = v23;
        v43 = 2082;
        v44 = v24;
        v45 = 2114;
        v46 = v25;
        v47 = 2080;
        v48 = out;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to register resolver f low with agent %s",  (uint8_t *)&v33,  0x52u);
      }

      goto LABEL_16;
    }

    free(v16);
    goto LABEL_17;
  }

  __nwlog_obj();
  os_log_type_t v26 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v43 = "nw_pac_resolver_callback";
  BOOL v27 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (__nwlog_fault(v27, &type, &v40))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_pac_resolver_callback";
        _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null pac", buf, 0xCu);
      }
    }

    else if (v40)
    {
      os_log_type_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v31 = type;
      id v32 = os_log_type_enabled(v28, type);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v43 = "nw_pac_resolver_callback";
          v44 = 2082;
          v45 = v30;
          _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null pac, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v30);
        goto LABEL_48;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_pac_resolver_callback";
        _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null pac, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v33 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_pac_resolver_callback";
        _os_log_impl(&dword_181A5C000, v28, v33, "%{public}s called with null pac, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }

    free(v5);
    goto LABEL_17;
  }

  os_unfair_lock_lock(v1 + 30);
  id v3 = (v2[39]._os_unfair_lock_opaque & 0x1000000) != 0 && (v2[39]._os_unfair_lock_opaque & 0x200000) == 0;
  os_unfair_lock_unlock(v2 + 30);
LABEL_18:

  return v3;
}

    free(v5);
    goto LABEL_17;
  }

  os_unfair_lock_lock(v1 + 30);
  id v3 = (v2[39]._os_unfair_lock_opaque & 0x1000000) == 0
    || nw_connection_better_path_available(*(void **)&v2[4]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2 + 30);
LABEL_18:

  return v3;
}

    free(v5);
    goto LABEL_17;
  }

  os_unfair_lock_lock(v1 + 30);
  if (*(void *)&v2[8]._os_unfair_lock_opaque) {
    id v3 = *(void *)&v2[32]._os_unfair_lock_opaque;
  }
  else {
    id v3 = 0LL;
  }
  os_unfair_lock_unlock(v2 + 30);
LABEL_18:

  return v3;
}

LABEL_17:
    if (!v13) {
      goto LABEL_48;
    }
LABEL_18:
    free(v13);
    goto LABEL_48;
  }

  if (!v29)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v14 = (os_log_s *)(id)gLogObj;
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_connection_set_tls";
      _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_16;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v14 = (os_log_s *)(id)gLogObj;
  os_log_type_t v17 = type;
  BOOL v18 = os_log_type_enabled(v14, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "tcp_connection_set_tls";
      _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null connection, no backtrace", buf, 0xCu);
    }

    goto LABEL_16;
  }

  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "tcp_connection_set_tls";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v16;
    _os_log_impl( &dword_181A5C000,  v14,  v17,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v13) {
    goto LABEL_18;
  }
LABEL_48:
}

    free(v6);
    goto LABEL_17;
  }

  os_unfair_lock_lock(v1 + 30);
  id v3 = *(void **)&v2[2]._os_unfair_lock_opaque;
  if (v3) {
    id v4 = xpc_copy(v3);
  }
  else {
    id v4 = 0LL;
  }
  os_unfair_lock_unlock(v2 + 30);
LABEL_18:

  return v4;
}

    free(v6);
    goto LABEL_17;
  }

  os_unfair_lock_lock(v1 + 30);
  id v3 = (nw_error *)*(id *)&v2[6]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2 + 30);
  if (v3) {
    id v4 = nw_error_copy_cf_error(v3);
  }
  else {
    id v4 = 0LL;
  }

LABEL_18:
  return v4;
}

    goto LABEL_17;
  }

  os_log_type_t v14 = v3;
  *(void *)os_log_type_t type = 0LL;
  os_log_type_t v21 = type;
  char v23 = -1;
  BOOL v22 = 0x2020000000LL;
  os_log_type_t v15 = v14 + 34;
  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = __nw_connection_get_connected_socket_block_invoke;
  BOOL v25 = &unk_189BC9210;
  os_log_type_t v16 = v14;
  os_log_type_t v26 = v16;
  BOOL v27 = type;
  os_unfair_lock_lock(v15);
  __nw_connection_get_connected_socket_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v15);
  os_log_type_t v17 = *((_DWORD *)v21 + 6);

  _Block_object_dispose(type, 8);
  if ((v17 & 0x80000000) == 0)
  {
    id v9 = dup(v17);
    goto LABEL_18;
  }

    free(v9);
    goto LABEL_17;
  }

  __nwlog_obj();
  os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v29 = "nw_socks5_server_create";
  BOOL v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v26 = 0;
  if (__nwlog_fault(v20, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_socks5_server_create";
        char v23 = "%{public}s called with null queue";
LABEL_40:
        _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0xCu);
      }
    }

    else
    {
      if (v26)
      {
        os_log_type_t v24 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v22 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (v24)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v29 = "nw_socks5_server_create";
            os_log_type_t v30 = 2082;
            v31 = v24;
            _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v24);
          goto LABEL_42;
        }

        if (!v25) {
          goto LABEL_41;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_socks5_server_create";
        char v23 = "%{public}s called with null queue, no backtrace";
        goto LABEL_40;
      }

      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_socks5_server_create";
        char v23 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_40;
      }
    }

    free(v6);
    goto LABEL_17;
  }

  os_log_type_t v12 = *(nw_framer **)(a1 + 40);
  BytePtr = CFDataGetBytePtr(v2);
  CFIndex Length = CFDataGetLength(v2);
  nw_framer_write_output(v12, BytePtr, Length);
  if (v2) {
    CFRelease(v2);
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v19 = *(void *)(a1 + 56);
      BOOL v20 = (const char *)(v19 + 227);
      if (!v19) {
        BOOL v20 = "";
      }
      os_log_type_t v21 = *(_WORD *)(v19 + 225);
      os_log_type_t v26 = "nw_ws_write_server_response_block_invoke";
      *(_DWORD *)buf = 136446722;
      BOOL v27 = 2082;
      os_log_type_t v28 = (void *)v20;
      if ((v21 & 4) != 0) {
        BOOL v22 = "server";
      }
      else {
        BOOL v22 = "client";
      }
      os_log_type_t v29 = 2082;
      os_log_type_t v30 = v22;
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s %{public}s handshake complete",  buf,  0x20u);
    }
  }

  os_log_type_t v15 = *(void *)(a1 + 56);
  *(_DWORD *)(v15 + 180) = 2;
  *(_DWORD *)(v15 + 188) = 2;
  *(_WORD *)(v15 + 225) &= ~2u;
  nw_framer_mark_ready(*(nw_framer_t *)(a1 + 40));
}

    if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type[0];
      BOOL v22 = os_log_type_enabled(v15, type[0]);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_h3_0rtt_storage_key";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v21,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v12) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }

      if (v22)
      {
        *(_DWORD *)buf = v24;
        *(void *)&uint8_t buf[4] = "nw_h3_0rtt_storage_key";
        _os_log_impl(&dword_181A5C000, v15, v21, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v23 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)buf = v24;
        *(void *)&uint8_t buf[4] = v2;
        _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_27;
  }

  id v6 = v4;
  id v7 = [v6 type];

  id v8 = 0LL;
  if (v7 <= 4 && ((1 << v7) & 0x16) != 0)
  {
    id v9 = (os_unfair_lock_s *)v6;
    *(void *)os_log_type_t type = 0LL;
    BOOL v27 = type;
    os_log_type_t v28 = 0x2020000000LL;
    os_log_type_t v29 = 0LL;
    os_log_type_t v10 = v9 + 45;
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_endpoint_get_description_block_invoke;
    v31 = &unk_189BC9210;
    id v11 = v9;
    id v32 = v11;
    id v33 = type;
    os_unfair_lock_lock(v10);
    __nw_endpoint_get_description_block_invoke((uint64_t)buf);
    os_unfair_lock_unlock(v10);
    os_log_type_t v12 = (char *)*((void *)v27 + 3);

    _Block_object_dispose(type, 8);
    if (!v12)
    {
      __nwlog_obj();
      os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "strict_strdup";
      BOOL v18 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v18))
      {
LABEL_15:
        __break(1u);
        goto LABEL_16;
      }

      free(v18);
    }

    id v8 = strdup(v12);
    if (v8) {
      goto LABEL_6;
    }
    __nwlog_obj();
    os_log_type_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_strdup";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    goto LABEL_15;
  }

  -[NWURLSessionStreamTask checkForCompletion](v19);

LABEL_17:
}

      [(id)v24 error];
      os_log_type_t v26 = (void *)objc_claimAutoreleasedReturnValue();

      os_log_type_t v24 = *(void *)(a1 + 32);
      if (v26)
      {
        BOOL v25 = v8;
        if (!v24) {
          goto LABEL_36;
        }
      }

      else
      {
        [*(id *)(a1 + 32) errorWithResumeData:v8];
        BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();

        os_log_type_t v28 = *(void **)(a1 + 32);
        if (!v28) {
          goto LABEL_36;
        }
        objc_setProperty_atomic_copy(v28, v27, v25, 136LL);
        os_log_type_t v24 = *(void *)(a1 + 32);
        if (!v24) {
          goto LABEL_36;
        }
      }

      goto LABEL_21;
    }
  }

  else
  {
    id v11 = (id *)(a1 + 40);
    if (!*(void *)(a1 + 40))
    {
      os_log_type_t v10 = 0LL;
      if (!a3) {
        goto LABEL_15;
      }
      goto LABEL_5;
    }
  }

              [(id)v7 setUserActivated:1];
              os_log_type_t v13 = v5[52];
              if ((v13 & 0x10) == 0)
              {
LABEL_12:
                if ((v13 & 0x20) == 0)
                {
LABEL_20:
                  if ((v5[52] & 0x40) != 0 && (objc_opt_respondsToSelector() & 1) != 0) {
                    [(id)v7 setNetworkProvider:1];
                  }
                  [*(id *)(a1 + 32) addObject:v7];
                  goto LABEL_24;
                }

      id v11 = 0;
LABEL_17:

      goto LABEL_18;
    }

    switch(v5->_command)
    {
      case 0:
        __nwlog_obj();
        id v7 = (id *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_ERROR)) {
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        id v8 = "%{public}s Invalid command sent to connection receiver";
        goto LABEL_14;
      case 1:
        os_log_type_t v14 = objc_alloc(&OBJC_CLASS___NWPBOpenConnection);
        os_log_type_t v15 = v6->_messageData;
        id v7 = -[PBCodable initWithData:](v14, "initWithData:", v15);

        if (!v7)
        {
          __nwlog_obj();
          v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
            goto LABEL_76;
          }
          *(_DWORD *)buf = 136446210;
          v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
          v64 = "%{public}s Open connection message could not be parsed";
          goto LABEL_60;
        }

        os_log_type_t v16 = objc_alloc(MEMORY[0x189607AB8]);
        os_log_type_t v17 = v7[1];
        BOOL v18 = (void *)[v16 initWithUUIDString:v17];

        if (v18)
        {
          os_log_type_t v19 = v7[2];
          [v19 data];
          BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
          +[NWEndpoint endpointWithProtocolBufferData:]( &OBJC_CLASS___NWEndpoint,  "endpointWithProtocolBufferData:",  v20);
          os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();

          BOOL v22 = v7[3];
          [v22 data];
          char v23 = (void *)objc_claimAutoreleasedReturnValue();
          +[NWParameters parametersWithProtocolBufferData:]( &OBJC_CLASS___NWParameters,  "parametersWithProtocolBufferData:",  v23);
          os_log_type_t v24 = (void *)objc_claimAutoreleasedReturnValue();

          +[NWConnection connectionWithEndpoint:parameters:]( &OBJC_CLASS___NWConnection,  "connectionWithEndpoint:parameters:",  v21,  v24);
          BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v26 = objc_alloc_init(&OBJC_CLASS___NWRemoteConnectionWrapper);
          -[NWRemoteConnectionWrapper setClientID:](v26, "setClientID:", v18);
          -[NWRemoteConnectionWrapper setConnection:](v26, "setConnection:", v25);
          -[NWRemoteConnectionActor connections](self, "connections");
          BOOL v27 = (void *)objc_claimAutoreleasedReturnValue();
          [v27 setObject:v26 forKeyedSubscript:v18];

          [v25 addObserver:self forKeyPath:@"connectionState" options:5 context:v26];
          [v25 addObserver:self forKeyPath:@"currentPath" options:5 context:v26];

          goto LABEL_32;
        }

        __nwlog_obj();
        v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
          v66 = "%{public}s Open connection missing client ID";
          goto LABEL_74;
        }

        goto LABEL_75;
      case 2:
        __nwlog_obj();
        id v7 = (id *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_ERROR)) {
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        id v8 = "%{public}s Update Path command is not valid to send to connection receiver";
        goto LABEL_14;
      case 3:
        os_log_type_t v28 = objc_alloc(&OBJC_CLASS___NWPBCloseConnection);
        os_log_type_t v29 = v6->_messageData;
        id v7 = -[PBCodable initWithData:](v28, "initWithData:", v29);

        if (!v7)
        {
          __nwlog_obj();
          v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
            goto LABEL_76;
          }
          *(_DWORD *)buf = 136446210;
          v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
          v64 = "%{public}s Close connection message could not be parsed";
          goto LABEL_60;
        }

        os_log_type_t v30 = objc_alloc(MEMORY[0x189607AB8]);
        v31 = v7[1];
        BOOL v18 = (void *)[v30 initWithUUIDString:v31];

        if (v18)
        {
          -[NWRemoteConnectionActor connections](self, "connections");
          id v32 = (void *)objc_claimAutoreleasedReturnValue();
          [v32 objectForKeyedSubscript:v18];
          id v33 = (void *)objc_claimAutoreleasedReturnValue();
          [v33 connection];
          os_log_type_t v21 = (void *)objc_claimAutoreleasedReturnValue();

          [v21 removeObserver:self forKeyPath:@"connectionState"];
          [v21 removeObserver:self forKeyPath:@"currentPath"];
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0) {
            [v21 writeCloseWithCompletionHandler:&__block_literal_global_47615];
          }
          [v21 cancel];
          -[NWRemoteConnectionActor connections](self, "connections");
          id v34 = (void *)objc_claimAutoreleasedReturnValue();
          [v34 setObject:0 forKeyedSubscript:v18];

LABEL_32:
          goto LABEL_49;
        }

        __nwlog_obj();
        v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
          goto LABEL_75;
        }
        *(_DWORD *)buf = 136446210;
        v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        v66 = "%{public}s Close connection missing client ID";
        goto LABEL_74;
      case 4:
        char v35 = objc_alloc(&OBJC_CLASS___NWPBSendData);
        __int16 v36 = v6->_messageData;
        id v7 = -[PBCodable initWithData:](v35, "initWithData:", v36);

        if (!v7)
        {
          __nwlog_obj();
          v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
            goto LABEL_76;
          }
          *(_DWORD *)buf = 136446210;
          v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
          v64 = "%{public}s Send data message could not be parsed";
          goto LABEL_60;
        }

        v37 = objc_alloc(MEMORY[0x189607AB8]);
        addrinfo v38 = v7[1];
        __int16 v39 = (char *)[v37 initWithUUIDString:v38];

        if (v39)
        {
          v40 = -[NWRemoteConnectionActor connections](self, "connections");
          [v40 objectForKeyedSubscript:v39];
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue();
          [v41 connection];
          v42 = (void *)objc_claimAutoreleasedReturnValue();

          id v11 = v42 != 0LL;
          if (v42)
          {
            v43 = (os_log_s *)v7[2];
            if (v43)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                [v42 writeData:v43 completionHandler:&__block_literal_global_48_47620];
              }

              else
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  v81 = v43;
                  v69 = (void *)MEMORY[0x189603F18];
                  v70 = v42;
                  [v69 arrayWithObjects:&v81 count:1];
                  v71 = (void *)objc_claimAutoreleasedReturnValue();
                  [v70 writeDatagrams:v71 completionHandler:&__block_literal_global_50_47623];
                }
              }
            }
          }

          else
          {
            __nwlog_obj();
            v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
              v84 = 2114;
              v85 = v39;
              _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s Send data could not find connection for %{public}@",  buf,  0x16u);
            }
          }

          goto LABEL_86;
        }

        __nwlog_obj();
        v42 = (void *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_ERROR)) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446210;
        v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        v67 = "%{public}s Send data missing client ID";
        goto LABEL_71;
      case 5:
        v44 = objc_alloc(&OBJC_CLASS___NWPBStartBrowse);
        v45 = v6->_messageData;
        id v7 = -[PBCodable initWithData:](v44, "initWithData:", v45);

        if (!v7)
        {
          __nwlog_obj();
          v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
            goto LABEL_76;
          }
          *(_DWORD *)buf = 136446210;
          v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
          v64 = "%{public}s Start browse message could not be parsed";
LABEL_60:
          _os_log_impl(&dword_181A5C000, v63, OS_LOG_TYPE_ERROR, v64, buf, 0xCu);
LABEL_76:
          id v11 = 0;

          goto LABEL_17;
        }

        v46 = objc_alloc(MEMORY[0x189607AB8]);
        v47 = v7[1];
        __int16 v39 = (char *)[v46 initWithUUIDString:v47];

        if (!v39)
        {
          __nwlog_obj();
          v42 = (void *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
            v67 = "%{public}s Start browse missing client ID";
LABEL_71:
            _os_log_impl(&dword_181A5C000, (os_log_t)v42, OS_LOG_TYPE_ERROR, v67, buf, 0xCu);
            id v11 = 0;
          }

          else
          {
LABEL_77:
            id v11 = 0;
          }

          goto LABEL_87;
        }

        v48 = v7[2];
        [v48 data];
        v49 = (void *)objc_claimAutoreleasedReturnValue();
        v42 = +[NWBrowseDescriptor descriptorWithProtocolBufferData:]( &OBJC_CLASS___NWBrowseDescriptor,  "descriptorWithProtocolBufferData:",  v49);
        if (v42)
        {
          v50 = v7[3];
          [v50 data];
          v51 = (void *)objc_claimAutoreleasedReturnValue();
          +[NWParameters parametersWithProtocolBufferData:]( &OBJC_CLASS___NWParameters,  "parametersWithProtocolBufferData:",  v51);
          v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();

          if (v43)
          {
            v52 = -[NWBrowser initWithDescriptor:parameters:]( objc_alloc(&OBJC_CLASS___NWBrowser),  "initWithDescriptor:parameters:",  v42,  v43);
            v53 = objc_alloc_init(&OBJC_CLASS___NWRemoteBrowserWrapper);
            -[NWRemoteBrowserWrapper setClientID:](v53, "setClientID:", v39);
            -[NWRemoteBrowserWrapper setBrowser:](v53, "setBrowser:", v52);
            v54 = -[NWRemoteConnectionActor browsers](self, "browsers");
            [v54 setObject:v53 forKeyedSubscript:v39];

            -[NWBrowser addObserver:forKeyPath:options:context:]( v52,  "addObserver:forKeyPath:options:context:",  self,  @"discoveredEndpoints",  5LL,  v53);
            id v11 = 1;
LABEL_86:

LABEL_87:
            goto LABEL_17;
          }

          __nwlog_obj();
          v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
            _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_ERROR,  "%{public}s Start browse missing parameters",  buf,  0xCu);
          }

          v43 = 0LL;
        }

        else
        {
          __nwlog_obj();
          v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
            _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s Start browse missing descriptor",  buf,  0xCu);
          }
        }

        id v11 = 0;
        goto LABEL_86;
      case 6:
        __nwlog_obj();
        id v7 = (id *)objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_ERROR)) {
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
        id v8 = "%{public}s Update Browse command is not valid to send to connection receiver";
        goto LABEL_14;
      case 7:
        v55 = objc_alloc(&OBJC_CLASS___NWPBStopBrowse);
        v56 = v6->_messageData;
        id v7 = -[PBCodable initWithData:](v55, "initWithData:", v56);

        if (!v7)
        {
          __nwlog_obj();
          v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR)) {
            goto LABEL_76;
          }
          *(_DWORD *)buf = 136446210;
          v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
          v64 = "%{public}s Stop browse message could not be parsed";
          goto LABEL_60;
        }

        v57 = objc_alloc(MEMORY[0x189607AB8]);
        v58 = v7[1];
        BOOL v18 = (void *)[v57 initWithUUIDString:v58];

        if (v18)
        {
          v59 = -[NWRemoteConnectionActor browsers](self, "browsers");
          [v59 objectForKeyedSubscript:v18];
          v60 = (void *)objc_claimAutoreleasedReturnValue();
          [v60 browser];
          v61 = (void *)objc_claimAutoreleasedReturnValue();

          [v61 removeObserver:self forKeyPath:@"discoveredEndpoints"];
          [v61 cancel];
          v62 = -[NWRemoteConnectionActor browsers](self, "browsers");
          [v62 setObject:0 forKeyedSubscript:v18];

LABEL_49:
          id v11 = 1;

          goto LABEL_17;
        }

        __nwlog_obj();
        v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v83 = "-[NWRemoteConnectionActor receiveRemoteCommand:]";
          v66 = "%{public}s Stop browse missing client ID";
LABEL_74:
          _os_log_impl(&dword_181A5C000, v65, OS_LOG_TYPE_ERROR, v66, buf, 0xCu);
        }

    goto LABEL_60;
  }

  if (*(void *)(v17 + 8) != *(void *)(a1 + 40))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      os_log_type_t v21 = *(void *)(a1 + 32);
      BOOL v22 = *(void *)(a1 + 40);
      char v23 = *(uint64_t (**)(uint64_t, uint64_t))(v21 + 8);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v21;
      *(_WORD *)&buf[22] = 2048;
      v85 = v23;
      *(_WORD *)v86 = 2048;
      *(void *)&v86[2] = v22;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ Ignoring state update for stale listener (%p != %p)",  buf,  0x2Au);
    }

    goto LABEL_16;
  }

  if (a2 == 4)
  {
    os_log_type_t v30 = 4;
LABEL_59:
    *(_DWORD *)(v17 + 16) = v30;
    goto LABEL_60;
  }

  if (a2 == 3)
  {
    error_code = nw_error_get_error_code(v5);
    os_log_type_t v17 = *(void *)(a1 + 32);
    if (error_code != 48)
    {
LABEL_58:
      os_log_type_t v30 = 3;
      goto LABEL_59;
    }

    id v32 = *(unsigned __int8 *)(v17 + 50);
    if (v32 <= 4)
    {
      *(_BYTE *)(v17 + 50) = v32 + 1;
      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        id v34 = *(void *)(a1 + 32);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v34;
        _os_log_impl( &dword_181A5C000,  v33,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ scheduling a retry as the address is in use",  buf,  0x16u);
      }

      __int16 v36 = *(void **)(a1 + 32);
      v37 = v36[7];
      if (v37)
      {
        nw_queue_cancel_source(v37, v35);
        *(void *)(*(void *)(a1 + 32) + 56LL) = 0LL;
        __int16 v36 = *(void **)(a1 + 32);
      }

      v74[0] = MEMORY[0x1895F87A8];
      v74[1] = 3221225472LL;
      v74[2] = __nw_service_connector_start_block_invoke_99;
      v74[3] = &unk_189BC93A0;
      v75 = v36;
      *(void *)(*(void *)(a1 + 32) + 56LL) = nw_queue_context_create_source(0LL, 2, 3, 0, v74, 0LL);
      addrinfo v38 = *(void *)(a1 + 32);
      __int16 v39 = *(void *)(v38 + 56);
      v40 = dispatch_time(0x8000000000000000LL, 200000000LL * *(unsigned __int8 *)(v38 + 50));
      nw_queue_set_timer_values(v39, v40, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
      nw_queue_activate_source(*(void *)(*(void *)(a1 + 32) + 56LL), v41);

      goto LABEL_60;
    }

    __nwlog_obj();
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    v43 = *(void *)(a1 + 32);
    v44 = *(unsigned __int8 *)(v43 + 50);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke_2";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v43;
    *(_WORD *)&buf[22] = 2114;
    v85 = (uint64_t (*)(uint64_t, uint64_t))v5;
    *(_WORD *)v86 = 1024;
    *(_DWORD *)&v86[2] = v44;
    v45 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v76[0]) = 0;
    if (__nwlog_fault(v45, type, v76))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v47 = type[0];
        if (os_log_type_enabled(v46, type[0]))
        {
          v48 = *(void *)(a1 + 32);
          v49 = *(unsigned __int8 *)(v48 + 50);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v48;
          *(_WORD *)&buf[22] = 2114;
          v85 = (uint64_t (*)(uint64_t, uint64_t))v5;
          *(_WORD *)v86 = 1024;
          *(_DWORD *)&v86[2] = v49;
          _os_log_impl( &dword_181A5C000,  v46,  v47,  "%{public}s %{public}@ Listener failed to become ready due to error %{public}@ after %d retries",  buf,  0x26u);
        }
      }

      else if (LOBYTE(v76[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v51 = type[0];
        v52 = os_log_type_enabled(v46, type[0]);
        if (backtrace_string)
        {
          if (v52)
          {
            v53 = *(void *)(a1 + 32);
            v54 = *(unsigned __int8 *)(v53 + 50);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v53;
            *(_WORD *)&buf[22] = 2114;
            v85 = (uint64_t (*)(uint64_t, uint64_t))v5;
            *(_WORD *)v86 = 1024;
            *(_DWORD *)&v86[2] = v54;
            *(_WORD *)&v86[6] = 2082;
            *(void *)&v86[8] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v46,  v51,  "%{public}s %{public}@ Listener failed to become ready due to error %{public}@ after %d retries, dumping ba cktrace:%{public}s",  buf,  0x30u);
          }

          free(backtrace_string);
          goto LABEL_55;
        }

        if (v52)
        {
          v58 = *(void *)(a1 + 32);
          v59 = *(unsigned __int8 *)(v58 + 50);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v58;
          *(_WORD *)&buf[22] = 2114;
          v85 = (uint64_t (*)(uint64_t, uint64_t))v5;
          *(_WORD *)v86 = 1024;
          *(_DWORD *)&v86[2] = v59;
          _os_log_impl( &dword_181A5C000,  v46,  v51,  "%{public}s %{public}@ Listener failed to become ready due to error %{public}@ after %d retries, no backtrace",  buf,  0x26u);
        }
      }

      else
      {
        __nwlog_obj();
        v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v55 = type[0];
        if (os_log_type_enabled(v46, type[0]))
        {
          v56 = *(void *)(a1 + 32);
          v57 = *(unsigned __int8 *)(v56 + 50);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v56;
          *(_WORD *)&buf[22] = 2114;
          v85 = (uint64_t (*)(uint64_t, uint64_t))v5;
          *(_WORD *)v86 = 1024;
          *(_DWORD *)&v86[2] = v57;
          _os_log_impl( &dword_181A5C000,  v46,  v55,  "%{public}s %{public}@ Listener failed to become ready due to error %{public}@ after %d retries, backtrace limit exceeded",  buf,  0x26u);
        }
      }
    }

    goto LABEL_17;
  }

  if (!v33)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v20 = (os_log_s *)(id)gLogObj;
    BOOL v25 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v36 = "nwsc_send_feedback";
      _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s dispatch_data_create failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_16;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v20 = (os_log_s *)(id)gLogObj;
  char v23 = type;
  os_log_type_t v24 = os_log_type_enabled(v20, type);
  if (!backtrace_string)
  {
    if (v24)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v36 = "nwsc_send_feedback";
      _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s dispatch_data_create failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_16;
  }

  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v36 = "nwsc_send_feedback";
    v37 = 2082;
    addrinfo v38 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s dispatch_data_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (!v19) {
    goto LABEL_19;
  }
LABEL_18:
  free(v19);
LABEL_19:
  if (v13) {
    (*((void (**)(id, uint64_t))v13 + 2))(v13, 12LL);
  }
LABEL_21:
}

    _os_log_impl(&dword_181A5C000, v2, v3, v4, buf, 0xCu);
    goto LABEL_17;
  }

  if (*(void *)(a1 + 48)) {
    return 0LL;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v13 = "nw_protocol_common_supports_external_data";
  id v1 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v10 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFIndex v2 = (os_log_s *)gLogObj;
    id v3 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v13 = "nw_protocol_common_supports_external_data";
    id v4 = "%{public}s supports_external_data requires an input handler";
    goto LABEL_16;
  }

  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFIndex v2 = (os_log_s *)gLogObj;
    id v3 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v13 = "nw_protocol_common_supports_external_data";
    id v4 = "%{public}s supports_external_data requires an input handler, backtrace limit exceeded";
    goto LABEL_16;
  }

  id v5 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  CFIndex v2 = (os_log_s *)gLogObj;
  id v3 = type;
  id v6 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v5)
  {
    if (!v6) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v13 = "nw_protocol_common_supports_external_data";
    id v4 = "%{public}s supports_external_data requires an input handler, no backtrace";
    goto LABEL_16;
  }

  if (v6)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v13 = "nw_protocol_common_supports_external_data";
    os_log_type_t v14 = 2082;
    os_log_type_t v15 = v5;
    _os_log_impl( &dword_181A5C000,  v2,  v3,  "%{public}s supports_external_data requires an input handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v5);
LABEL_17:
  if (v1) {
LABEL_18:
  }
    free(v1);
  return 0LL;
}

    free(v8);
    goto LABEL_17;
  }

  *(void *)a8 = v22;
  v22[a8[2] - 1] = *(sockaddr *)&a6->sa_data[6];
LABEL_8:
  if ((a2 & 1) == 0) {
    *((_BYTE *)a8 + 12) = 1;
  }
}

    free(v21);
    if (!v17) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  v542 = a7;
  v543 = a8;
  v552 = a2;
  v560 = 0;
  v559 = 0;
  v558 = 0;
  v557 = 0;
  if (a11 == 5)
  {
    v548 = 0LL;
    v549 = 0LL;
    v553 = 0LL;
    v554 = 0LL;
    v550 = 0LL;
    v551 = 0LL;
    v544 = 0LL;
    v541 = 0;
    BOOL v20 = 0LL;
    goto LABEL_1124;
  }

  v540 = a6;
  v548 = 0LL;
  v549 = 0LL;
  v541 = 0;
  v544 = 0LL;
  v553 = 0LL;
  v554 = 0LL;
  v550 = 0LL;
  v551 = 0LL;
  BOOL v20 = 0LL;
  while (1)
  {
    os_log_type_t v26 = *(unsigned __int8 *)(a10 + v20);
    BOOL v27 = *(unsigned int *)(a10 + 1 + v20);
    if ((_DWORD)v27)
    {
      if (v27 <= 0xFFFFFFF9 && a11 >= v27 + 5 && a11 - (v27 + 5) >= v20)
      {
        __int16 v36 = (char *)(a10 + 5 + v20);
        goto LABEL_57;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v29 = (id)gLogObj;
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v20;
      *(_WORD *)&buf[22] = 2048;
      *(void *)&buf[24] = a11;
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v27;
      os_log_type_t v30 = (void *)_os_log_send_and_compose_impl();

      uu[0] = 16;
      v561 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault((const char *)v30, uu, &v561))
      {
        if (uu[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = (os_log_s *)(id)gLogObj;
          id v32 = uu[0];
          if (os_log_type_enabled(v31, (os_log_type_t)uu[0]))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v20;
            *(_WORD *)&buf[22] = 2048;
            *(void *)&buf[24] = a11;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v27;
            _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u",  buf,  0x26u);
          }
        }

        else if (v561)
        {
          id v33 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = (os_log_s *)(id)gLogObj;
          id v34 = uu[0];
          char v35 = os_log_type_enabled(v31, (os_log_type_t)uu[0]);
          if (v33)
          {
            if (v35)
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v20;
              *(_WORD *)&buf[22] = 2048;
              *(void *)&buf[24] = a11;
              *(_WORD *)&buf[32] = 1024;
              *(_DWORD *)&buf[34] = v27;
              *(_WORD *)&buf[38] = 2082;
              *(void *)&buf[40] = v33;
              _os_log_impl( &dword_181A5C000,  v31,  v34,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, dumping backtrace:%{public}s",  buf,  0x30u);
            }

            free(v33);
            if (!v30) {
              goto LABEL_56;
            }
LABEL_55:
            free(v30);
            goto LABEL_56;
          }

          if (v35)
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v20;
            *(_WORD *)&buf[22] = 2048;
            *(void *)&buf[24] = a11;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v27;
            _os_log_impl( &dword_181A5C000,  v31,  v34,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, no backtrace",  buf,  0x26u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = (os_log_s *)(id)gLogObj;
          v37 = uu[0];
          if (os_log_type_enabled(v31, (os_log_type_t)uu[0]))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v20;
            *(_WORD *)&buf[22] = 2048;
            *(void *)&buf[24] = a11;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v27;
            _os_log_impl( &dword_181A5C000,  v31,  v37,  "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, backtrace limit exceeded",  buf,  0x26u);
          }
        }
      }

      if (v30) {
        goto LABEL_55;
      }
    }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_17;
  }

  handle = a1->handle;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (!handle)
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_http3_reset";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v4 = (os_log_s *)__nwlog_obj();
      id v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_protocol_http3_reset";
      id v6 = "%{public}s called with null http3";
      goto LABEL_16;
    }

    if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v4 = (os_log_s *)__nwlog_obj();
      id v5 = type;
      os_log_type_t v13 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v13) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v17 = "nw_protocol_http3_reset";
        BOOL v18 = 2082;
        os_log_type_t v19 = backtrace_string;
        os_log_type_t v12 = "%{public}s called with null http3, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v4, v5, v12, buf, 0x16u);
LABEL_37:
        free(backtrace_string);
        if (!v3) {
          return 0LL;
        }
        goto LABEL_18;
      }

      if (!v13) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_protocol_http3_reset";
      id v6 = "%{public}s called with null http3, no backtrace";
    }

    else
    {
      id v4 = (os_log_s *)__nwlog_obj();
      id v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_protocol_http3_reset";
      id v6 = "%{public}s called with null http3, backtrace limit exceeded";
    }

    goto LABEL_16;
  }

  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_protocol_http3_reset";
  id v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)gLogObj;
    id v5 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_http3_reset";
    id v6 = "%{public}s Reset is not supported on http3 connection";
    goto LABEL_16;
  }

  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)gLogObj;
    id v5 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_http3_reset";
    id v6 = "%{public}s Reset is not supported on http3 connection, backtrace limit exceeded";
    goto LABEL_16;
  }

  id v7 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)gLogObj;
  id v5 = type;
  id v8 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v7)
  {
    if (!v8) {
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_http3_reset";
    id v6 = "%{public}s Reset is not supported on http3 connection, no backtrace";
    goto LABEL_16;
  }

  if (v8)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v17 = "nw_protocol_http3_reset";
    BOOL v18 = 2082;
    os_log_type_t v19 = v7;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s Reset is not supported on http3 connection, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v7);
LABEL_17:
  if (v3) {
LABEL_18:
  }
    free(v3);
  return 0LL;
}

    BOOL v27 = (unsigned int *)((char *)msg_control + ((*msg_control + 3LL) & 0x1FFFFFFFCLL));
    if (v27 + 3 <= v26)
    {
      os_log_type_t v28 = v27 == msg_control;
    }

    else
    {
      BOOL v27 = 0LL;
      os_log_type_t v28 = 1;
    }

    msg_control = v27;
  }

  while (!v28);
  if (!v25 || !v24) {
    goto LABEL_54;
  }
  if (![v14 multicast])
  {
    if (v16)
    {
      dataa = dispatch_data_create(&buffer, v16, 0LL, 0LL);

      if (!dataa)
      {
        __nwlog_obj();
        v57 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
        v58 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v283.sa_len = 0;
        if (__nwlog_fault(v58, type, &v283))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v60 = type[0];
            if (os_log_type_enabled(v59, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
              _os_log_impl(&dword_181A5C000, v59, v60, "%{public}s dispatch_data_create failed", buf, 0xCu);
            }
          }

          else if (v283.sa_len)
          {
            v76 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v77 = type[0];
            v78 = os_log_type_enabled(v59, type[0]);
            if (v76)
            {
              if (v78)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v76;
                _os_log_impl( &dword_181A5C000,  v59,  v77,  "%{public}s dispatch_data_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v76);
              goto LABEL_200;
            }

            if (v78)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
              _os_log_impl( &dword_181A5C000,  v59,  v77,  "%{public}s dispatch_data_create failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v120 = type[0];
            if (os_log_type_enabled(v59, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_listener_inbox_accept_udp";
              _os_log_impl( &dword_181A5C000,  v59,  v120,  "%{public}s dispatch_data_create failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

    free(v11);
    goto LABEL_17;
  }

  __nwlog_obj();
  __int16 v39 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v51 = "nw_path_get_estimated_upload_throughput";
  v40 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (__nwlog_fault(v40, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_path_get_estimated_upload_throughput";
        _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v48)
    {
      v43 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v44 = type;
      v45 = os_log_type_enabled(v41, type);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_path_get_estimated_upload_throughput";
          v52 = 2082;
          v53 = v43;
          _os_log_impl( &dword_181A5C000,  v41,  v44,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        goto LABEL_91;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_path_get_estimated_upload_throughput";
        _os_log_impl(&dword_181A5C000, v41, v44, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_path_get_estimated_upload_throughput";
        _os_log_impl( &dword_181A5C000,  v41,  v47,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(v11);
    goto LABEL_17;
  }

  __nwlog_obj();
  __int16 v39 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v51 = "nw_path_get_estimated_download_throughput";
  v40 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (__nwlog_fault(v40, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_path_get_estimated_download_throughput";
        _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s called with null path", buf, 0xCu);
      }
    }

    else if (v48)
    {
      v43 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v44 = type;
      v45 = os_log_type_enabled(v41, type);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_path_get_estimated_download_throughput";
          v52 = 2082;
          v53 = v43;
          _os_log_impl( &dword_181A5C000,  v41,  v44,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        goto LABEL_91;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_path_get_estimated_download_throughput";
        _os_log_impl(&dword_181A5C000, v41, v44, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_path_get_estimated_download_throughput";
        _os_log_impl( &dword_181A5C000,  v41,  v47,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  os_log_type_t v17 = *(void *)(a1 + 32);
  if (!v17)
  {
    os_log_type_t v19 = 0LL;
    goto LABEL_57;
  }

  if (*(_BYTE *)(v17 + 14)) {
    goto LABEL_68;
  }
  BOOL v18 = (id *)*(id *)(v17 + 40);
  os_log_type_t v19 = v18;
  if (!v18) {
    goto LABEL_57;
  }
  if ([v18[4] _explicitlySetCachePolicy])
  {
    if ([v19[4] cachePolicy] != 3)
    {
LABEL_57:
      char v35 = *(void *)(a1 + 32);
      if (v35) {
        __int16 v36 = *(void **)(v35 + 24);
      }
      else {
        __int16 v36 = 0LL;
      }
      [v36 valueForHTTPHeaderField:@"Cache-Control"];
      v37 = (void *)objc_claimAutoreleasedReturnValue();
      [v37 rangeOfString:@"only-if-cached" options:1];
      __int16 v39 = v38;

      if (!v39)
      {
        -[NWURLLoaderHTTP continueLoading](*(void *)(a1 + 32));
        goto LABEL_68;
      }

      goto LABEL_60;
    }
  }

  else if ([v19[2] requestCachePolicy] != 3)
  {
    goto LABEL_57;
  }

LABEL_60:
  v40 = *(id **)(a1 + 32);
  if (v40)
  {
    uint64_t v41 = objc_alloc(&OBJC_CLASS___NWURLError);
    [v40[6] loaderTask];
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    v43 = v40;
    v44 = v42;
    if (v41)
    {
      v45 = *MEMORY[0x189607740];
      v55.receiver = v41;
      v55.super_class = (Class)&OBJC_CLASS___NWURLError;
      v46 = (NWURLError *)objc_msgSendSuper2(&v55, sel_initWithDomain_code_userInfo_, v45, -1008, 0);
      uint64_t v41 = v46;
      if (v46) {
        -[NWURLError fillErrorForLoader:andTask:](v46, "fillErrorForLoader:andTask:", v43, v44);
      }
    }

    v47 = *(void *)(a1 + 32);
    if (v47) {
      objc_storeStrong((id *)(v47 + 88), v41);
    }
  }

  else
  {
    uint64_t v41 = 0LL;
  }

  v48 = *(void *)(a1 + 32);
  if (v48) {
    *(_BYTE *)(v48 + 11) = 1;
  }
LABEL_68:
}

      os_log_type_t v12 = 0;
      goto LABEL_17;
    }

    if (__nwlog_url_log::onceToken != -1) {
      dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
    }
    os_log_type_t v21 = (os_log_s *)(id)gurlLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      BOOL v22 = *(void *)(a1 + 40);
      if (v22 && (char v23 = *(id *)(v22 + 48)) != 0LL)
      {
        os_log_type_t v24 = v23;
        [v23 logDescription];
      }

      else
      {
        os_log_type_t v24 = 0LL;
        v35[0] = 0LL;
        v35[1] = 0LL;
        __int16 v36 = 0;
      }

      BOOL v25 = *(void *)(a1 + 40);
      if (v25 && (os_log_type_t v26 = *(id *)(v25 + 48)) != 0LL)
      {
        BOOL v27 = v26;
        [v26 logDescription];
        os_log_type_t v28 = v34;
      }

      else
      {
        os_log_type_t v28 = 0;
        id v32 = 0LL;
        id v33 = 0LL;
        id v34 = 0;
      }

      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "-[NWURLLoaderHTTP configureAndStartConnection:]_block_invoke";
      *(_WORD *)&buf[12] = 1042;
      *(_DWORD *)&buf[14] = 16;
      addrinfo v38 = 2098;
      __int16 v39 = v35;
      v40 = 1024;
      uint64_t v41 = v28;
      v42 = 1024;
      v43 = a2;
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s Task <%{public,uuid_t}.16P>.<%u> connection viable: %{BOOL}d",  buf,  0x28u);
    }

    if ((a2 & 1) == 0) {
      goto LABEL_6;
    }
  }

  PBDataWriterWriteUint32Field();
  id v5 = (char)self->_has;
  if ((v5 & 8) != 0) {
    goto LABEL_17;
  }
LABEL_11:
  if ((v5 & 0x40) != 0) {
LABEL_12:
  }
    PBDataWriterWriteBOOLField();
LABEL_13:
}

    goto LABEL_17;
  }

  os_log_type_t v13 = *(void *)(a1[4] + 16LL);
  if (v13 && !nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v8 = (id)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
    {
      os_log_type_t v14 = *(_DWORD *)(a1[4] + 448LL);
      os_log_type_t v16 = 136446466;
      os_log_type_t v17 = "nw_connection_stats_fill_in_nw_report_on_nw_queue_block_invoke";
      BOOL v18 = 1024;
      os_log_type_t v19 = v14;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%u] Reached max activities for report, no additional activities will be reported",  (uint8_t *)&v16,  0x12u);
    }

    goto LABEL_16;
  }
  }

  if (v5) {
    free(v5);
  }
  return v3;
}

  if ((*(_BYTE *)(v8 + 64) & 1) == 0) {
    goto LABEL_57;
  }
LABEL_55:
  v37 = *(void *)(v8 + 56);
  if (v37)
  {
    if (*(_UNKNOWN **)(v37 + 40) == &nw_protocol_ref_counted_handle)
    {
      v60 = *(void *)(v37 + 88);
      if (v60)
      {
        v61 = v60 - 1;
        *(void *)(v37 + 88) = v61;
        if (!v61)
        {
          v73 = flow_control_status;
          v62 = *(void (***)(void))(v37 + 64);
          if (v62)
          {
            *(void *)(v37 + 64) = 0LL;
            v62[2](v62);
            _Block_release(v62);
          }

          if ((*(_BYTE *)(v37 + 72) & 1) != 0)
          {
            v63 = *(const void **)(v37 + 64);
            if (v63) {
              _Block_release(v63);
            }
          }

          free((void *)v37);
          os_log_type_t v15 = v73;
        }
      }
    }
  }

void sub_181A7C5C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_add_alternative_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 160);
  if (!v3) {
    goto LABEL_24;
  }
  id v4 = *(void **)(a1 + 40);
  if (v4 == &__block_literal_global_6237)
  {
    while (1)
    {
      os_log_type_t v12 = (void *)*v3;
      if (v3[3] == *(void *)(a1 + 48) && (_UNKNOWN *)v3[2] == &__block_literal_global_6237) {
        return;
      }
      id v3 = (void *)*v3;
      if (!v12) {
        goto LABEL_22;
      }
    }
  }

  while (1)
  {
    id v5 = (void *)*v3;
    if (v4 == &__block_literal_global_6237)
    {
      if (v3[3] == *(void *)(a1 + 48) && (_UNKNOWN *)v3[2] == &__block_literal_global_6237) {
        return;
      }
    }

    else
    {
      uint64_t v6 = *(void *)(a1 + 48);
      if (v6 && (_UNKNOWN *)v3[2] == &__block_literal_global_6237 && v3[3] == v6)
      {
        id v8 = (void *)v3[1];
        if (v5)
        {
          v5[1] = v8;
          id v8 = (void *)v3[1];
        }

        else
        {
          *(void *)(*(void *)(a1 + 32) + 168LL) = v8;
        }

        void *v8 = v5;
        void *v3 = 0LL;
        v3[1] = 0LL;
        if (v3 != (void *)(*(void *)(a1 + 32) + 128LL)) {
          free(v3);
        }
      }

      else if (v3[3] == v6)
      {
        id v7 = (void *)v3[2];
      }
    }

    if (!v5) {
      break;
    }
    id v4 = *(void **)(a1 + 40);
    id v3 = v5;
  }

  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(void *)(v2 + 160))
  {
LABEL_24:
    objc_storeStrong((id *)(v2 + 144), *(id *)(a1 + 40));
    objc_storeStrong((id *)(*(void *)(a1 + 32) + 152LL), *(id *)(a1 + 48));
    *(void *)(*(void *)(a1 + 32) + 128LL) = 0LL;
    *(void *)(*(void *)(a1 + 32) + 136LL) = *(void *)(*(void *)(a1 + 32) + 168LL);
    **(void **)(*(void *)(a1 + 32) + 168LL) = *(void *)(a1 + 32) + 128LL;
    uint64_t v11 = *(void *)(a1 + 32);
    id v9 = (id *)(v11 + 128);
    goto LABEL_25;
  }

nw_connection_t nw_connection_create(nw_endpoint_t endpoint, nw_parameters_t parameters)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = endpoint;
  id v4 = parameters;
  id v5 = v4;
  if (v3)
  {
    if (v4)
    {
      uint64_t v6 = (nw_connection *)nw_connection_create_with_id(v3, v4, 0);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_connection_create";
    id v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_connection_create";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null parameters", buf, 0xCu);
        }

void sub_181A7CD64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_create_with_id(void *a1, void *a2, int a3)
{
  *(void *)&v68[13] = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  nw_allow_use_of_dispatch_internal();
  if (!v5)
  {
    __nwlog_obj();
    v47 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_connection_create_with_id";
    v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_181A5C000, v49, v50, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = type;
      BOOL v55 = os_log_type_enabled(v49, type);
      if (backtrace_string)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_connection_create_with_id";
          __int16 v67 = 2082;
          *(void *)v68 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v49,  v54,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v48) {
          goto LABEL_112;
        }
        goto LABEL_111;
      }

      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_181A5C000, v49, v54, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v59 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl( &dword_181A5C000,  v49,  v59,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_109;
  }

  if (!v6)
  {
    __nwlog_obj();
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_connection_create_with_id";
    v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_181A5C000, v49, v52, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v63)
    {
      v56 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v57 = type;
      BOOL v58 = os_log_type_enabled(v49, type);
      if (v56)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_connection_create_with_id";
          __int16 v67 = 2082;
          *(void *)v68 = v56;
          _os_log_impl( &dword_181A5C000,  v49,  v57,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v56);
LABEL_110:
        if (!v48)
        {
LABEL_112:
          id v27 = 0LL;
          goto LABEL_76;
        }

LABEL_109:
    goto LABEL_110;
  }

  id v7 = v6;
  BOOL v8 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v7,  0,  0);

  if (v8)
  {
    id v9 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_connection);
    id v10 = v5;
    os_log_type_t v11 = (void *)[v10 copyEndpoint];
    nw_endpoint_copy_properties(v10, v11);

    uint64_t v12 = -[NWConcrete_nw_connection initWithEndpoint:parameters:identifier:]( (void **)&v9->super.isa,  v11,  (void *)v8,  a3);
    if (v12)
    {
      uint64_t v13 = *(void *)(v12 + 8);
      uint64_t v14 = *(void *)(v12 + 16);
      nw_allow_use_of_dispatch_internal();
      if (has_modifiers == 1)
      {
        os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_modify_lock);
        os_log_type_t v15 = (void *)g_modifier_list;
        if (g_modifier_list)
        {
          while (1)
          {
            BOOL v16 = (uint64_t (*)(uint64_t, uint64_t))v15[2];
            if (v16)
            {
              if ((v16(v13, v14) & 1) != 0) {
                break;
              }
            }

            os_log_type_t v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_7;
            }
          }

          os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
          uint64_t v17 = *(void *)(v12 + 16);
          if (v17 && !nw_path_parameters_get_logging_disabled(*(void *)(v17 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            BOOL v18 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            {
              int v19 = *(_DWORD *)(v12 + 448);
              *(_DWORD *)buf = 136446466;
              v66 = "nw_connection_create_with_id";
              __int16 v67 = 1024;
              *(_DWORD *)v68 = v19;
              _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Connection parameters were modified",  buf,  0x12u);
            }
          }
        }

        else
        {
LABEL_7:
          os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
        }
      }

      inner = nw_endpoint_handler_create_inner( *(void **)(v12 + 8),  *(void **)(v12 + 16),  nw_connection_endpoint_report_on_nw_queue,  (void *)v12,  0LL,  *(_DWORD *)(v12 + 448),  0);
      char v21 = *(void **)(v12 + 144);
      *(void *)(v12 + 144) = inner;

      uint64_t v22 = *(void *)(v12 + 16);
      if (*(void *)(v12 + 144))
      {
        if (v22 && !nw_path_parameters_get_logging_disabled(*(void *)(v22 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v23 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            int v24 = *(_DWORD *)(v12 + 448);
            logging_description = nw_endpoint_get_logging_description(v10);
            *(_DWORD *)buf = 136446722;
            v66 = "nw_connection_create_with_id";
            __int16 v67 = 1024;
            *(_DWORD *)v68 = v24;
            v68[2] = 2082;
            *(void *)&v68[3] = logging_description;
            _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_INFO,  "%{public}s [C%u] create connection to %{public}s",  buf,  0x1Cu);
          }
        }

        v61[0] = MEMORY[0x1895F87A8];
        v61[1] = 3221225472LL;
        v61[2] = __nw_connection_create_with_id_block_invoke;
        v61[3] = &unk_189BB97C0;
        id v26 = (id)v12;
        id v62 = v26;
        nw_endpoint_enumerate_alternatives(v10, v61);
        id v27 = v26;

        goto LABEL_74;
      }

      if (v22 && !nw_path_parameters_get_logging_disabled(*(void *)(v22 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v39 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          int v40 = *(_DWORD *)(v12 + 448);
          *(_DWORD *)buf = 136446466;
          v66 = "nw_connection_create_with_id";
          __int16 v67 = 1024;
          *(_DWORD *)v68 = v40;
          _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Failed to create parent endpoint handler",  buf,  0x12u);
        }
      }

      if (v86) {
        free(v86);
      }
      goto LABEL_11;
    }

    __nwlog_obj();
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v113 = "nw_flow_passthrough_disconnected";
    v76 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v110 = 0;
    if (__nwlog_fault(v76, &type, &v110))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v78 = type;
        if (os_log_type_enabled(v77, type))
        {
          *(_DWORD *)buf = 136446210;
          v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl(&dword_181A5C000, v77, v78, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v110)
      {
        v82 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v83 = type;
        v84 = os_log_type_enabled(v77, type);
        if (v82)
        {
          if (v84)
          {
            *(_DWORD *)buf = 136446466;
            v113 = "nw_flow_passthrough_disconnected";
            v114 = 2082;
            id_str = v82;
            _os_log_impl( &dword_181A5C000,  v77,  v83,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v82);
          goto LABEL_101;
        }

        if (v84)
        {
          *(_DWORD *)buf = 136446210;
          v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl(&dword_181A5C000, v77, v83, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v93 = type;
        if (os_log_type_enabled(v77, type))
        {
          *(_DWORD *)buf = 136446210;
          v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl( &dword_181A5C000,  v77,  v93,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    __break(1u);
LABEL_110:
    __break(1u);
    swift_bridgeObjectRelease();
    __break(1u);
    uint64_t result = swift_bridgeObjectRelease();
    __break(1u);
  }

  else
  {
LABEL_104:
    swift_release();
    sub_181C54438(2573LL, 0xE200000000000000LL);
    return v72;
  }

  return result;
}

      if (v55) {
        free(v55);
      }
    }
  }

  id v6 = (void *)*((void *)v4 + 5);
  if (v6)
  {
    id v7 = v6;
    BOOL v8 = v7;
    if ((v7[136] & 8) != 0)
    {
      nw_context_purge_all_endpoints(v7);
    }

    else
    {
      v71[0] = MEMORY[0x1895F87A8];
      v71[1] = 3221225472LL;
      v71[2] = ___ZL18nw_context_deallocP21NWConcrete_nw_contextb_block_invoke;
      v71[3] = &unk_189BC93A0;
      v72 = v7;
      nw_queue_context_async(v72, v71);
    }

    if (a2)
    {
      id v9 = v8[4];
      if (v9)
      {
        id v10 = *(void *)(v9 + 68);
        if (v10)
        {
          nw_path_release_globals(v10, 0LL);
          id v9 = v8[4];
          os_log_type_t v11 = *(void **)(v9 + 68);
          if (v11)
          {
            free(v11);
            *(void *)(v8[4] + 68LL) = 0LL;
            id v9 = v8[4];
          }
        }

        uint64_t v12 = *(void **)(v9 + 180);
        if (v12)
        {
          nw_mem_buffer_manager_close(v12);
          *(void *)(v8[4] + 180LL) = 0LL;
          id v9 = v8[4];
        }

        uint64_t v13 = *(void **)(v9 + 172);
        if (v13)
        {
          nw_mem_buffer_manager_close(v13);
          *(void *)(v8[4] + 172LL) = 0LL;
          id v9 = v8[4];
        }

        uint64_t v14 = *(void **)(v9 + 164);
        if (v14)
        {
          nw_mem_buffer_manager_close(v14);
          *(void *)(v8[4] + 164LL) = 0LL;
          id v9 = v8[4];
        }

        os_log_type_t v15 = *(void **)(v9 + 156);
        if (v15)
        {
          nw_mem_buffer_manager_close(v15);
          *(void *)(v8[4] + 156LL) = 0LL;
          id v9 = v8[4];
        }

        BOOL v16 = *(void **)(v9 + 148);
        if (v16)
        {
          nw_mem_buffer_manager_close(v16);
          *(void *)(v8[4] + 148LL) = 0LL;
        }
      }
    }
  }

  BOOL v18 = v4;
  int v19 = *((void *)v18 + 3);
  if (v19)
  {
    if (*(void *)(v19 + 56))
    {
      nw_queue_cancel_source(*(void *)(v19 + 56), v17);
      *(void *)(*((void *)v18 + 3) + 56LL) = 0LL;
      int v19 = *((void *)v18 + 3);
    }

    if (*(void *)(v19 + 32))
    {
      _nw_hash_table_release(*(os_unfair_lock_s **)(v19 + 32), v17);
      *(void *)(*((void *)v18 + 3) + 32LL) = 0LL;
      int v19 = *((void *)v18 + 3);
    }

    if (*(void *)(v19 + 40))
    {
      _nw_hash_table_release(*(os_unfair_lock_s **)(v19 + 40), v17);
      *(void *)(*((void *)v18 + 3) + 40LL) = 0LL;
      int v19 = *((void *)v18 + 3);
    }

    if (!*(void *)(v19 + 48)
      || (_nw_hash_table_release(*(os_unfair_lock_s **)(v19 + 48), v17),
          *(void *)(*((void *)v18 + 3) + 48LL) = 0LL,
          (int v19 = *((void *)v18 + 3)) != 0))
    {
      free((void *)v19);
      *((void *)v18 + 3) = 0LL;
    }
  }

  os_log_type_t v20 = v18;
  char v21 = *((void *)v20 + 4);
  if (v21)
  {
    uint64_t v22 = *(void **)(v21 + 84);
    *(void *)(v21 + 84) = 0LL;

    int v24 = (char *)v20 + 32;
    char v23 = *((void *)v20 + 4);
    __int16 v25 = *(void **)(v23 + 92);
    *(void *)(v23 + 92) = 0LL;

    id v26 = *(void **)(*((void *)v20 + 4) + 100LL);
    *(void *)(*(void *)v24 + 100LL) = 0LL;

    id v27 = *(void **)(*((void *)v20 + 4) + 108LL);
    *(void *)(*(void *)v24 + 108LL) = 0LL;

    id v28 = *(void **)(*((void *)v20 + 4) + 116LL);
    *(void *)(*(void *)v24 + 116LL) = 0LL;

    os_log_type_t v29 = *(void **)(*((void *)v20 + 4) + 124LL);
    *(void *)(*(void *)v24 + 124LL) = 0LL;

    os_log_type_t v31 = *((void *)v20 + 4);
    if (*(void *)v31)
    {
      nw_queue_cancel_source(*(void *)v31, v30);
      **((void **)v20 + 4) = 0LL;
      os_log_type_t v31 = *((void *)v20 + 4);
    }

    id v32 = *(os_unfair_lock_s **)(v31 + 24);
    if (v32)
    {
      _nw_hash_table_release(v32, v30);
      *(void *)(*((void *)v20 + 4) + 24LL) = 0LL;
      os_log_type_t v31 = *((void *)v20 + 4);
    }

    id v33 = *(char **)(v31 + 52);
    if (v33)
    {
      nw_hash_table_apply(v33, (uint64_t)&__block_literal_global_116);
      os_log_type_t v31 = *((void *)v20 + 4);
      os_log_type_t v35 = *(os_unfair_lock_s **)(v31 + 52);
      if (v35)
      {
        _nw_hash_table_release(v35, v34);
        *(void *)(*((void *)v20 + 4) + 52LL) = 0LL;
        os_log_type_t v31 = *((void *)v20 + 4);
      }
    }

    __int16 v36 = *(void *)(v31 + 60);
    if (v36)
    {
      if (*(void *)v36)
      {
        os_release(*(void **)v36);
        *(void *)__int16 v36 = 0LL;
      }

      os_log_type_t v37 = *(void **)(v36 + 8);
      if (v37)
      {
        os_release(v37);
        *(void *)(v36 + 8) = 0LL;
      }

      os_log_type_t v31 = *((void *)v20 + 4);
      BOOL v38 = *(void **)(v31 + 60);
      if (v38)
      {
        free(v38);
        *(void *)(*((void *)v20 + 4) + 60LL) = 0LL;
        os_log_type_t v31 = *((void *)v20 + 4);
      }
    }

    __int16 v39 = *(void *)(v31 + 68);
    if (v39)
    {
      nw_path_release_globals(v39, 0LL);
      os_log_type_t v31 = *((void *)v20 + 4);
      int v40 = *(void **)(v31 + 68);
      if (v40)
      {
        free(v40);
        *(void *)(*((void *)v20 + 4) + 68LL) = 0LL;
        os_log_type_t v31 = *((void *)v20 + 4);
      }
    }

    uint64_t v41 = *(void **)(v31 + 180);
    if (v41)
    {
      nw_mem_buffer_manager_close(v41);
      *(void *)(*((void *)v20 + 4) + 180LL) = 0LL;
      os_log_type_t v31 = *((void *)v20 + 4);
    }

    os_log_type_t v42 = *(void **)(v31 + 172);
    if (v42)
    {
      nw_mem_buffer_manager_close(v42);
      *(void *)(*((void *)v20 + 4) + 172LL) = 0LL;
      os_log_type_t v31 = *((void *)v20 + 4);
    }

    BOOL v43 = *(void **)(v31 + 164);
    if (v43)
    {
      nw_mem_buffer_manager_close(v43);
      *(void *)(*((void *)v20 + 4) + 164LL) = 0LL;
      os_log_type_t v31 = *((void *)v20 + 4);
    }

    os_log_type_t v44 = *(void **)(v31 + 156);
    if (v44)
    {
      nw_mem_buffer_manager_close(v44);
      *(void *)(*((void *)v20 + 4) + 156LL) = 0LL;
      os_log_type_t v31 = *((void *)v20 + 4);
    }

    os_log_type_t v45 = *(void **)(v31 + 148);
    if (!v45
      || (nw_mem_buffer_manager_close(v45),
          *(void *)(*((void *)v20 + 4) + 148LL) = 0LL,
          (os_log_type_t v31 = *((void *)v20 + 4)) != 0))
    {

      free((void *)v31);
      *((void *)v20 + 4) = 0LL;
    }
  }

  if ((*((_BYTE *)v20 + 136) & 8) != 0)
  {
    os_log_type_t v50 = v75;
    v51 = (unint64_t *)((char *)v20 + 112);
    while (1)
    {
      os_log_type_t v52 = __ldaxr(v51);
      if (v52 != v50) {
        break;
      }
      if (!__stlxr(0LL, v51))
      {
        v53 = 1;
        goto LABEL_84;
      }
    }

    v53 = 0;
    __clrex();
LABEL_84:
    if ((v53 & 1) == 0)
    {
      __nwlog_obj();
      BOOL v58 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446722;
      v77 = "nw_context_dealloc";
      v78 = 2048;
      v79 = v75;
      v80 = 2048;
      v81 = v52;
      os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v73 = 0;
      if (__nwlog_fault(v59, &type, &v73))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v61 = type;
          if (os_log_type_enabled(v60, type))
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v52;
            _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s Exiting call, expected inline TID to be %llu but got %llu",  buf,  0x20u);
          }
        }

        else if (v73)
        {
          v65 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v66 = type;
          __int16 v67 = os_log_type_enabled(v60, type);
          if (v65)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446978;
              v77 = "nw_context_dealloc";
              v78 = 2048;
              v79 = v75;
              v80 = 2048;
              v81 = v52;
              v82 = 2082;
              v83 = v65;
              _os_log_impl( &dword_181A5C000,  v60,  v66,  "%{public}s Exiting call, expected inline TID to be %llu but got %llu, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v65);
            goto LABEL_114;
          }

          if (v67)
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v52;
            _os_log_impl( &dword_181A5C000,  v60,  v66,  "%{public}s Exiting call, expected inline TID to be %llu but got %llu, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v69 = type;
          if (os_log_type_enabled(v60, type))
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v52;
            _os_log_impl( &dword_181A5C000,  v60,  v69,  "%{public}s Exiting call, expected inline TID to be %llu but got %llu, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

          free(v20);
          goto LABEL_13;
        }

        if (!v41) {
          goto LABEL_108;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_get_message_properties";
        int v24 = "%{public}s called with null message_properties, no backtrace";
      }

      else
      {
        os_log_type_t v31 = (os_log_s *)__nwlog_obj();
        id v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_108;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_get_message_properties";
        int v24 = "%{public}s called with null message_properties, backtrace limit exceeded";
      }

      os_log_type_t v44 = v31;
      os_log_type_t v45 = v32;
      v46 = 12;
      goto LABEL_107;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v50 = "__nw_protocol_get_message_properties";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_102;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_get_message_properties";
        os_log_type_t v30 = "%{public}s called with null other_protocol";
        goto LABEL_101;
      }

      if (!v47)
      {
        id v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_102;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_get_message_properties";
        os_log_type_t v30 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_101;
      }

      BOOL v38 = (char *)__nw_create_backtrace_string();
      id v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      __int16 v39 = os_log_type_enabled(v28, type);
      if (v38)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v50 = "__nw_protocol_get_message_properties";
          v51 = 2082;
          os_log_type_t v52 = v38;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v38);
        if (v3) {
          goto LABEL_33;
        }
        goto LABEL_15;
      }

      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_get_message_properties";
        os_log_type_t v30 = "%{public}s called with null other_protocol, no backtrace";
LABEL_101:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      }
    }

          free(v20);
          goto LABEL_13;
        }

        if (!v41) {
          goto LABEL_108;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_notify";
        int v24 = "%{public}s called with null type, no backtrace";
      }

      else
      {
        os_log_type_t v31 = (os_log_s *)__nwlog_obj();
        id v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_108;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_notify";
        int v24 = "%{public}s called with null type, backtrace limit exceeded";
      }

      os_log_type_t v44 = v31;
      os_log_type_t v45 = v32;
      v46 = 12;
      goto LABEL_107;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v50 = "__nw_protocol_notify";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_102;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_notify";
        os_log_type_t v30 = "%{public}s called with null other_protocol";
        goto LABEL_101;
      }

      if (!v47)
      {
        id v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_102;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_notify";
        os_log_type_t v30 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_101;
      }

      BOOL v38 = (char *)__nw_create_backtrace_string();
      id v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      __int16 v39 = os_log_type_enabled(v28, type);
      if (v38)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v50 = "__nw_protocol_notify";
          v51 = 2082;
          os_log_type_t v52 = v38;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v38);
        if (v3) {
          goto LABEL_33;
        }
        goto LABEL_15;
      }

      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_notify";
        os_log_type_t v30 = "%{public}s called with null other_protocol, no backtrace";
LABEL_101:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      }
    }

          free(v20);
          goto LABEL_13;
        }

        if (!v41) {
          goto LABEL_108;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_link_state";
        int v24 = "%{public}s called with null link_info, no backtrace";
      }

      else
      {
        os_log_type_t v31 = (os_log_s *)__nwlog_obj();
        id v32 = type;
        if (!os_log_type_enabled(v31, type)) {
          goto LABEL_108;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_link_state";
        int v24 = "%{public}s called with null link_info, backtrace limit exceeded";
      }

      os_log_type_t v44 = v31;
      os_log_type_t v45 = v32;
      v46 = 12;
      goto LABEL_107;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v50 = "__nw_protocol_link_state";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_102;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_link_state";
        os_log_type_t v30 = "%{public}s called with null other_protocol";
        goto LABEL_101;
      }

      if (!v47)
      {
        id v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_102;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_link_state";
        os_log_type_t v30 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_101;
      }

      BOOL v38 = (char *)__nw_create_backtrace_string();
      id v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type;
      __int16 v39 = os_log_type_enabled(v28, type);
      if (v38)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v50 = "__nw_protocol_link_state";
          v51 = 2082;
          os_log_type_t v52 = v38;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null other_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v38);
        if (v3) {
          goto LABEL_33;
        }
        goto LABEL_15;
      }

      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v50 = "__nw_protocol_link_state";
        os_log_type_t v30 = "%{public}s called with null other_protocol, no backtrace";
LABEL_101:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
      }
    }

    if (v50) {
      free(v50);
    }
    goto LABEL_28;
  }

  id v10 = (void *)*(v5 - 8);
  if (!v10) {
    goto LABEL_93;
  }
  os_log_type_t v11 = (void *)v10[5];
  if (v11 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v13 = v10[11];
    if (v13) {
      v10[11] = v13 + 1;
    }
    uint64_t v12 = -1;
  }

  else
  {
    uint64_t v12 = 0;
  }

  *(void *)v64 = v10;
  LOBYTE(v65) = v12;
  uint64_t v14 = (void *)*(v5 - 7);
  if (v14 == &nw_protocol_ref_counted_handle)
  {
    BOOL v16 = *(v5 - 1);
    if (v16) {
      *(v5 - 1) = v16 + 1;
    }
    os_log_type_t v15 = -1;
  }

  else
  {
    os_log_type_t v15 = 0;
  }

  os_log_type_t v60 = v5 - 12;
  LOBYTE(v61) = v15;
  if (!(_DWORD)a2)
  {
    __nwlog_obj();
    id v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "__nw_protocol_notify";
    __int16 v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v58 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v34 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "__nw_protocol_notify";
        _os_log_impl(&dword_181A5C000, v26, v34, "%{public}s called with null type", applier, 0xCu);
      }
    }

    else if (v58)
    {
      uint64_t v41 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = type;
      BOOL v43 = os_log_type_enabled(v26, type);
      if (v41)
      {
        if (v43)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "__nw_protocol_notify";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = v41;
          _os_log_impl( &dword_181A5C000,  v26,  v42,  "%{public}s called with null type, dumping backtrace:%{public}s",  applier,  0x16u);
        }

        free(v41);
        if (!v25) {
          goto LABEL_23;
        }
        goto LABEL_115;
      }

      if (v43)
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "__nw_protocol_notify";
        _os_log_impl(&dword_181A5C000, v26, v42, "%{public}s called with null type, no backtrace", applier, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v48 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "__nw_protocol_notify";
        _os_log_impl( &dword_181A5C000,  v26,  v48,  "%{public}s called with null type, backtrace limit exceeded",  applier,  0xCu);
      }
    }

    goto LABEL_113;
  }

  uint64_t v17 = v10[3];
  if (!v17 || (BOOL v18 = *(void (**)(void *, void *, uint64_t, void *, size_t))(v17 + 160)) == 0LL)
  {
    __nwlog_obj();
    char v23 = (void *)objc_claimAutoreleasedReturnValue();
    int v24 = (const char *)v10[2];
    *(_DWORD *)applier = 136446722;
    *(void *)&applier[4] = "__nw_protocol_notify";
    if (!v24) {
      int v24 = "invalid";
    }
    *(_WORD *)&applier[12] = 2082;
    *(void *)&applier[14] = v24;
    *(_WORD *)&applier[22] = 2048;
    v69 = v10;
    __int16 v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v58 = 0;
    if (__nwlog_fault(v25, &type, &v58))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          id v28 = (const char *)v10[2];
          if (!v28) {
            id v28 = "invalid";
          }
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "__nw_protocol_notify";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = v28;
          *(_WORD *)&applier[22] = 2048;
          v69 = v10;
          _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s protocol %{public}s (%p) has invalid notify callback",  applier,  0x20u);
        }

LABEL_110:
        if (!v21) {
          goto LABEL_112;
        }
LABEL_111:
        free(v21);
        goto LABEL_112;
      }

      if (!(_BYTE)v136)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v45 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl( &dword_181A5C000,  v22,  v45,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_109;
      }

      BOOL v38 = __nw_create_backtrace_string();
      if (!v38)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v57 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl( &dword_181A5C000,  v22,  v57,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, no backtrace",  buf,  0xCu);
        }

        goto LABEL_109;
      }

      os_log_type_t v35 = (nw_protocol *)v38;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v36 = (os_log_s *)(id)gLogObj;
      __int16 v39 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v141 = "nw_protocol_implementation_disconnect";
        v142 = 2082;
        v143 = v35;
        _os_log_impl( &dword_181A5C000,  v36,  v39,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v28 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v141 = "nw_protocol_implementation_disconnect";
      char v21 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s called with null instance->parent_definition->stop",  buf,  0xCu);
        }

        goto LABEL_109;
      }

      if (!(_BYTE)v136)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v22 = (os_log_s *)(id)gLogObj;
        uint64_t v41 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl( &dword_181A5C000,  v22,  v41,  "%{public}s called with null instance->parent_definition->stop, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_109;
      }

      id v34 = __nw_create_backtrace_string();
      if (!v34)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v56 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl( &dword_181A5C000,  v22,  v56,  "%{public}s called with null instance->parent_definition->stop, no backtrace",  buf,  0xCu);
        }

        goto LABEL_109;
      }

      os_log_type_t v35 = (nw_protocol *)v34;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v36 = (os_log_s *)(id)gLogObj;
      os_log_type_t v37 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v141 = "nw_protocol_implementation_disconnect";
        v142 = 2082;
        v143 = v35;
        _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s called with null instance->parent_definition->stop, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    free(v35);
    if (!v21) {
      goto LABEL_112;
    }
    goto LABEL_111;
  }

  __nwlog_obj();
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v141 = "nw_protocol_implementation_disconnect";
  v72 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v136) = 0;
  if (__nwlog_fault(v72, type, &v136))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v74 = type[0];
      if (os_log_type_enabled(v73, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v141 = "nw_protocol_implementation_disconnect";
        _os_log_impl(&dword_181A5C000, v73, v74, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if ((_BYTE)v136)
    {
      v90 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v91 = type[0];
      v92 = os_log_type_enabled(v73, type[0]);
      if (v90)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446466;
          v141 = "nw_protocol_implementation_disconnect";
          v142 = 2082;
          v143 = (nw_protocol *)v90;
          _os_log_impl( &dword_181A5C000,  v73,  v91,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v90);
        goto LABEL_259;
      }

      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        v141 = "nw_protocol_implementation_disconnect";
        _os_log_impl(&dword_181A5C000, v73, v91, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v114 = type[0];
      if (os_log_type_enabled(v73, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v141 = "nw_protocol_implementation_disconnect";
        _os_log_impl( &dword_181A5C000,  v73,  v114,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      if (v18) {
LABEL_110:
      }
        free(v18);
LABEL_111:

      return;
    }

    char v21 = (uint64_t)*(v6 - 8);
    if (!v21)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v27 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v109 = "nw_protocol_implementation_output_finished";
      BOOL v18 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v104) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v19 = (os_log_s *)(id)gLogObj;
        id v28 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v28,  "%{public}s called with null nw_protocol_get_output_handler(&instance->protocol)",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      if (!(_BYTE)v104)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v19 = (os_log_s *)(id)gLogObj;
        v46 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v46,  "%{public}s called with null nw_protocol_get_output_handler(&instance->protocol), backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      int v40 = __nw_create_backtrace_string();
      if (!v40)
      {
        __nwlog_obj();
        int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = type[0];
        if (os_log_type_enabled(v19, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "nw_protocol_implementation_output_finished";
          _os_log_impl( &dword_181A5C000,  v19,  v50,  "%{public}s called with null nw_protocol_get_output_handler(&instance->protocol), no backtrace",  buf,  0xCu);
        }

        goto LABEL_108;
      }

      os_log_type_t v35 = (char *)v40;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v36 = (os_log_s *)(id)gLogObj;
      uint64_t v41 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v109 = "nw_protocol_implementation_output_finished";
        v110 = 2082;
        v111 = v35;
        _os_log_impl( &dword_181A5C000,  v36,  v41,  "%{public}s called with null nw_protocol_get_output_handler(&instance->protocol), dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_82;
    }

    if (gLogDatapath)
    {
      __nwlog_obj();
      v84 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "nw_protocol_implementation_output_finished";
        _os_log_impl( &dword_181A5C000,  v84,  OS_LOG_TYPE_DEBUG,  "%{public}s Passing through output finished to output handler",  buf,  0xCu);
      }

      char v21 = (uint64_t)*(v6 - 8);
      if (!v21)
      {
        __nwlog_obj();
        v85 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v109 = "__nw_protocol_output_finished";
        BOOL v18 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v104) = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v86 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "__nw_protocol_output_finished";
            _os_log_impl(&dword_181A5C000, v19, v86, "%{public}s called with null protocol", buf, 0xCu);
          }

          goto LABEL_108;
        }

        if (!(_BYTE)v104)
        {
          __nwlog_obj();
          int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v101 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "__nw_protocol_output_finished";
            _os_log_impl( &dword_181A5C000,  v19,  v101,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_108;
        }

        v71 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v96 = type[0];
        v97 = os_log_type_enabled(v19, type[0]);
        if (!v71)
        {
          if (v97)
          {
            *(_DWORD *)buf = 136446210;
            v109 = "__nw_protocol_output_finished";
            _os_log_impl(&dword_181A5C000, v19, v96, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }

          goto LABEL_108;
        }

        if (v97)
        {
          *(_DWORD *)buf = 136446466;
          v109 = "__nw_protocol_output_finished";
          v110 = 2082;
          v111 = v71;
          _os_log_impl( &dword_181A5C000,  v19,  v96,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

            __int16 v36 = (uint64_t)(id)v38;

            goto LABEL_187;
          }

          if (nw_hash_table_get_node(v8[29], a3, 8LL))
          {
            uint64_t v17 = v9;
            if (nw_protocol_definition_get_message_is_stream(*((void **)v9 + 1))
              && *((void *)v17 - 6) == a3)
            {
              BOOL v18 = -2LL;
            }

            else
            {
              BOOL v18 = a3;
            }

            if (v9[405] < 0) {
              goto LABEL_82;
            }
          }

          else
          {
            BOOL v18 = -1LL;
            if (v9[405] < 0) {
              goto LABEL_82;
            }
          }

          if (gLogDatapath)
          {
            __nwlog_obj();
            v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_copy_info";
              v100 = 2082;
              v101 = v9 + 407;
              v102 = 2080;
              v103 = " ";
              v104 = 2048;
              v105 = v18;
              _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sCopy metadata for flow %llx",  buf,  0x2Au);
            }
          }

    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
    if ((v34 & 1) != 0) {
      goto LABEL_130;
    }
    goto LABEL_110;
  }

  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v89 = "nw_protocol_implementation_teardown";
      v90 = 2082;
      v91 = (char *)&v3->flow_in_connected + 7;
      v92 = 2080;
      v93 = " ";
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sAlready tearing down protocol",  buf,  0x20u);
    }
  }

        os_log_type_t v31 = 0LL;
LABEL_110:

        goto LABEL_111;
      }
    }

        free(v19);
        goto LABEL_110;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v58 = "nw_parameters_create_webtransport_http";
        _os_log_impl( &dword_181A5C000,  v20,  v44,  "%{public}s called with null (configure_webtransport != (_nw_parameters_configure_protocol_disable)), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v58 = "nw_parameters_create_webtransport_http";
        _os_log_impl( &dword_181A5C000,  v20,  v52,  "%{public}s called with null (configure_webtransport != (_nw_parameters_configure_protocol_disable)), backtrace limit exceeded",  buf,  0xCu);
      }
    }

      free(v48);
      if (!v36) {
        goto LABEL_119;
      }
      goto LABEL_118;
    }

    if (v51)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_create_with_connected_socket_internal";
      _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s [nw_connection initWithEndpoint:parameters:] failed, no backtrace",  buf,  0xCu);
    }

          nw_masque_mark_failed_with_error(a1, 22);
          return;
        }
      }

      if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
        goto LABEL_109;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      __int16 v36 = (os_log_s *)gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_109;
      }
LABEL_102:
      *(_DWORD *)&buf[0].sa_len = 136446466;
      *(void *)&buf[0].sa_data[2] = a1 + 531;
      *(_WORD *)&buf[0].sa_data[10] = 2080;
      *(void *)&buf[0].sa_data[12] = " ";
      v68 = "%{public}s%sProxy endpoint not found";
LABEL_108:
      _os_log_impl(&dword_181A5C000, v36, OS_LOG_TYPE_ERROR, v68, &buf[0].sa_len, 0x16u);
      goto LABEL_109;
    }

    if (*(_DWORD *)(a1 + 504) != 2)
    {
      if ((v22 & 0x10000) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        os_log_type_t v57 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
        {
          BOOL v58 = nw_endpoint_get_logging_description(*(void **)(a1 + 312));
          *(_DWORD *)&buf[0].sa_len = 136446722;
          *(void *)&buf[0].sa_data[2] = a1 + 531;
          *(_WORD *)&buf[0].sa_data[10] = 2080;
          *(void *)&buf[0].sa_data[12] = " ";
          *(_WORD *)&buf[1].sa_data[4] = 2082;
          *(void *)&buf[1].sa_data[6] = v58;
          _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_INFO,  "%{public}s%sCreating CONNECT-UDP request for %{public}s",  &buf[0].sa_len,  0x20u);
        }
      }

      id v26 = nw_http_request_method_connect_udp;
      __int16 v25 = "https";
LABEL_83:
      os_log_type_t v59 = *v26;
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 312)) == nw_endpoint_type_address
        && nw_endpoint_get_address_family(*(void **)(a1 + 312)) == 30)
      {
        os_log_type_t v60 = "[%s]:%u";
      }

      else
      {
        os_log_type_t v60 = "%s:%u";
      }

      hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 312));
      port = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 312));
      asprintf(&v145, v60, hostname, port);
      if ((*v21 & 8) != 0)
      {
        v65 = strdup("/");
        if (!v65)
        {
          v136 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v136, OS_LOG_TYPE_ERROR);
          *(_DWORD *)&buf[0].sa_len = 136446210;
          *(void *)&buf[0].sa_data[2] = "strict_strdup";
          v137 = (void *)_os_log_send_and_compose_impl();
          free(v137);
        }

        char v63 = 0LL;
        v64 = 0;
        v144 = v65;
      }

      else
      {
        char v63 = 0LL;
        v64 = 0;
      }

      v66 = 1;
      __int16 v67 = v145;
      if (!v145)
      {
LABEL_171:
        v87 = (void *)nw_http_request_create((uint64_t)v59, (uint64_t)v25, (uint64_t)v67, (uint64_t)v144);
        if (v145)
        {
          free(v145);
          v145 = 0LL;
        }

        if (v144)
        {
          free(v144);
          v144 = 0LL;
        }

        if ((v66 & 1) != 0)
        {
          if (v64) {
            goto LABEL_177;
          }
        }

        else
        {
          nw_http_request_set_extended_connect_protocol(v87, (uint64_t)v63);
          if (v64)
          {
LABEL_177:
            nw_http_fields_append(v87, (uint64_t)"Proxy-QUIC-Forwarding", (uint64_t)"?1");
            v88 = *(_DWORD *)v21;
            if ((*(_DWORD *)v21 & 0x40000) != 0) {
              goto LABEL_178;
            }
            goto LABEL_182;
          }
        }

        v88 = *(_DWORD *)v21;
        if ((*(_DWORD *)v21 & 0x40000) != 0)
        {
LABEL_178:
          nw_http_fields_append(v87, (uint64_t)"Capsule-Protocol", (uint64_t)"?1");
          if ((*(_DWORD *)v21 & 0x10) == 0)
          {
LABEL_184:
            nw_masque_add_listener_association_header_to_request(a1, v87);
            nw_http_fields_append(v87, (uint64_t)"Priority", (uint64_t)"i");
            if (!nw_masque_add_extra_headers_to_request(a1, v87))
            {
LABEL_275:
              if (v87) {
                os_release(v87);
              }
              return;
            }

            if (*(void *)(a1 + 384) && *(_DWORD *)(a1 + 504) == 1)
            {
              v89 = (dispatch_data_s *)dispatch_data_create_with_transform();
              memset(&buf[0].sa_family, 0, 63);
              buf[0].sa_len = 58;
              if (dispatch_data_get_size(v89) < 0x3E)
              {
                nw_masque_change_base64_to_base64url((char *)buf);
                *(_WORD *)(&buf[0].sa_family + nw_dispatch_data_copyout(v89, (uint64_t)&buf[0].sa_family, 61LL)) = 58;
                nw_http_fields_append(v87, (uint64_t)"Client-Connection-Id", (uint64_t)buf);
              }

              else if ((v21[2] & 1) == 0)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                v90 = (os_log_s *)gprivacy_proxyLogObj;
                if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
                {
                  size = dispatch_data_get_size(v89);
                  *(_DWORD *)address = 136446722;
                  *(void *)&address[4] = a1 + 531;
                  *(_WORD *)&address[12] = 2080;
                  *(void *)&address[14] = " ";
                  *(_WORD *)&address[22] = 2048;
                  v148 = size;
                  _os_log_impl( &dword_181A5C000,  v90,  OS_LOG_TYPE_ERROR,  "%{public}s%sBase64 data is too large: %zu",  address,  0x20u);
                }
              }

              if (v89) {
                dispatch_release(v89);
              }
            }

            metadata_for_request = nw_http_create_metadata_for_request(v87);
            v93 = metadata_for_request;
            if ((*v21 & 0x10) != 0) {
              nw_http_metadata_set_datagram_context_id(metadata_for_request, 2LL);
            }
            if ((nw_masque_send_metadata(a1, (uint64_t)v93, *(void *)(a1 + 32)) & 1) == 0)
            {
              nw_masque_mark_failed_with_error(a1, 12);
LABEL_273:
              if (v93) {
                os_release(v93);
              }
              goto LABEL_275;
            }

            v96 = *(_DWORD *)v21;
            if ((*(_DWORD *)v21 & 0x10000) == 0)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              v97 = (os_log_s *)gprivacy_proxyLogObj;
              v98 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
              v96 = *(_DWORD *)v21;
              if (v98)
              {
                v99 = "-IP";
                if ((v96 & 0x20) == 0) {
                  v99 = "";
                }
                *(_DWORD *)&buf[0].sa_len = 136446978;
                *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
                *(_WORD *)&buf[0].sa_data[10] = 2082;
                *(void *)&buf[0].sa_data[12] = a1 + 531;
                *(_WORD *)&buf[1].sa_data[4] = 2080;
                *(void *)&buf[1].sa_data[6] = " ";
                if ((v96 & 8) != 0) {
                  v100 = "-UDP";
                }
                else {
                  v100 = v99;
                }
                *(_WORD *)&buf[2].sa_len = 2080;
                *(void *)buf[2].sa_data = v100;
                _os_log_impl( &dword_181A5C000,  v97,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSent CONNECT%s request",  &buf[0].sa_len,  0x2Au);
                v96 = *(_DWORD *)v21;
              }
            }

            *(_DWORD *)(a1 + 508) = 2;
            if ((v96 & 8) != 0)
            {
              v101 = *(dispatch_data_s **)(a1 + 384);
              if (v101)
              {
                if (*(_DWORD *)(a1 + 504) == 2 && *(void *)(a1 + 432))
                {
                  if (*(void *)(a1 + 400)) {
                    v102 = *(dispatch_data_s **)(a1 + 400);
                  }
                  else {
                    v102 = *(dispatch_data_s **)(a1 + 384);
                  }
                  virtual_connection_id_capsule = nw_masque_create_virtual_connection_id_capsule(v101, v102, v94, v95);
                  v104 = nw_masque_send_metadata(a1, virtual_connection_id_capsule, *(void *)(a1 + 32));
                  v105 = *(_DWORD *)v21;
                  if ((v104 & 1) != 0)
                  {
                    if ((v105 & 0x10000) == 0)
                    {
                      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                      }
                      v106 = (os_log_s *)gprivacy_proxyLogObj;
                      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)&buf[0].sa_len = 136446722;
                        *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
                        *(_WORD *)&buf[0].sa_data[10] = 2082;
                        *(void *)&buf[0].sa_data[12] = a1 + 531;
                        *(_WORD *)&buf[1].sa_data[4] = 2080;
                        *(void *)&buf[1].sa_data[6] = " ";
                        _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sSent REGISTER_CLIENT_CID capsule",  &buf[0].sa_len,  0x20u);
                      }
                    }

                    *(_DWORD *)v21 |= 0x8000000u;
                  }

                  else if ((v105 & 0x10000) == 0)
                  {
                    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                    }
                    v107 = (os_log_s *)gprivacy_proxyLogObj;
                    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)&buf[0].sa_len = 136446466;
                      *(void *)&buf[0].sa_data[2] = a1 + 531;
                      *(_WORD *)&buf[0].sa_data[10] = 2080;
                      *(void *)&buf[0].sa_data[12] = " ";
                      _os_log_impl( &dword_181A5C000,  v107,  OS_LOG_TYPE_ERROR,  "%{public}s%sFailed to send REGISTER_CLIENT_CID capsule",  &buf[0].sa_len,  0x16u);
                    }
                  }

                  if (virtual_connection_id_capsule) {
                    os_release((void *)virtual_connection_id_capsule);
                  }
                }
              }
            }

            v108 = *(_DWORD *)v21;
            if ((*(_DWORD *)v21 & 0x20) == 0) {
              goto LABEL_273;
            }
            v109 = *(void **)(a1 + 456);
            if (v109)
            {
              next_connect_ip_request_id = nw_http_connection_metadata_get_next_connect_ip_request_id(v109);
              v111 = nw_http_connection_metadata_get_next_connect_ip_request_id(*(void **)(a1 + 456));
              v108 = *(_DWORD *)v21;
            }

            else
            {
              next_connect_ip_request_id = 0LL;
              v111 = 0LL;
            }

            if ((v108 & 0x10000) == 0 && gLogDatapath)
            {
              if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
              }
              v138 = (os_log_s *)gprivacy_proxyLogObj;
              if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)&buf[0].sa_len = 136447234;
                *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
                *(_WORD *)&buf[0].sa_data[10] = 2082;
                *(void *)&buf[0].sa_data[12] = a1 + 531;
                *(_WORD *)&buf[1].sa_data[4] = 2080;
                *(void *)&buf[1].sa_data[6] = " ";
                *(_WORD *)&buf[2].sa_len = 2048;
                *(void *)buf[2].sa_data = next_connect_ip_request_id;
                *(_WORD *)&buf[2].sa_data[8] = 2048;
                *(void *)&buf[2].sa_data[10] = v111;
                _os_log_impl( &dword_181A5C000,  v138,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sADDRESS_REQUEST capsule v4 request ID: %llu, v6 request ID %llu",  &buf[0].sa_len,  0x34u);
              }
            }

            *(void *)address = 0LL;
            if (next_connect_ip_request_id > 0x3F)
            {
              if (next_connect_ip_request_id >> 14)
              {
                if (next_connect_ip_request_id >> 30)
                {
                  if (next_connect_ip_request_id >> 62)
                  {
                    v113 = (os_log_s *)__nwlog_obj();
                    os_log_type_enabled(v113, OS_LOG_TYPE_ERROR);
                    *(_DWORD *)&buf[0].sa_len = 136446466;
                    *(void *)&buf[0].sa_data[2] = "_http_vle_encode";
                    *(_WORD *)&buf[0].sa_data[10] = 2048;
                    *(void *)&buf[0].sa_data[12] = next_connect_ip_request_id;
                    v114 = (void *)_os_log_send_and_compose_impl();
                    free(v114);
                    v112 = 0LL;
                  }

                  else
                  {
                    *(void *)address = bswap64(next_connect_ip_request_id | 0xC000000000000000LL);
                    v112 = 8LL;
                  }
                }

                else
                {
                  *(void *)address = bswap32(next_connect_ip_request_id | 0x80000000);
                  v112 = 4LL;
                }
              }

              else
              {
                *(void *)address = bswap32(next_connect_ip_request_id | 0x4000) >> 16;
                v112 = 2LL;
              }
            }

            else
            {
              *(void *)address = next_connect_ip_request_id;
              v112 = 1LL;
            }

            __src = 0LL;
            if (v111 <= 0x3F)
            {
              __src = v111;
              v115 = 1LL;
              goto LABEL_257;
            }

            if (!(v111 >> 14))
            {
              __src = bswap32(v111 | 0x4000) >> 16;
              v115 = 2LL;
              goto LABEL_257;
            }

            if (!(v111 >> 30))
            {
              __src = bswap32(v111 | 0x80000000);
              v115 = 4LL;
              goto LABEL_257;
            }

            if (!(v111 >> 62))
            {
              __src = bswap64(v111 | 0xC000000000000000LL);
              v115 = 8LL;
              goto LABEL_257;
            }

            v116 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v116, OS_LOG_TYPE_ERROR);
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(void *)&buf[0].sa_data[2] = "_http_vle_encode";
            *(_WORD *)&buf[0].sa_data[10] = 2048;
            *(void *)&buf[0].sa_data[12] = v111;
            v117 = (void *)_os_log_send_and_compose_impl();
            if (!__nwlog_abort((uint64_t)v117))
            {
              free(v117);
              v115 = 0LL;
LABEL_257:
              alloc = (dispatch_object_s *)dispatch_data_create_alloc();
              memcpy(0LL, address, v112);
              *(_BYTE *)v112 = 4;
              *(_DWORD *)(v112 + 1) = 0;
              *(_BYTE *)(v112 + 5) = 32;
              v119 = (char *)(v112 + 6);
              memcpy(v119, &__src, v115);
              v120 = &v119[v115];
              *v120 = 6;
              *(void *)(v120 + 9) = 0LL;
              *(void *)(v120 + 1) = 0LL;
              v120[17] = 0x80;
              metadata_for_capsule = nw_http_create_metadata_for_capsule(2LL, alloc);
              if (alloc) {
                dispatch_release(alloc);
              }
              v122 = nw_masque_send_metadata(a1, (uint64_t)metadata_for_capsule, *(void *)(a1 + 32));
              v123 = *(_DWORD *)v21;
              if ((v122 & 1) != 0)
              {
                if ((v123 & 0x10000) != 0) {
                  goto LABEL_271;
                }
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                v124 = gprivacy_proxyLogObj;
                if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_271;
                }
                *(_DWORD *)&buf[0].sa_len = 136446722;
                *(void *)&buf[0].sa_data[2] = "nw_masque_send_connect";
                *(_WORD *)&buf[0].sa_data[10] = 2082;
                *(void *)&buf[0].sa_data[12] = a1 + 531;
                *(_WORD *)&buf[1].sa_data[4] = 2080;
                *(void *)&buf[1].sa_data[6] = " ";
                v125 = "%{public}s %{public}s%sSent ADDRESS_REQUEST capsule";
                v126 = (os_log_s *)v124;
                v127 = OS_LOG_TYPE_DEBUG;
                v128 = 32;
              }

              else
              {
                if ((v123 & 0x10000) != 0) {
                  goto LABEL_271;
                }
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                v129 = gprivacy_proxyLogObj;
                if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_271;
                }
                *(_DWORD *)&buf[0].sa_len = 136446466;
                *(void *)&buf[0].sa_data[2] = a1 + 531;
                *(_WORD *)&buf[0].sa_data[10] = 2080;
                *(void *)&buf[0].sa_data[12] = " ";
                v125 = "%{public}s%sFailed to send ADDRESS_REQUEST capsule";
                v126 = (os_log_s *)v129;
                v127 = OS_LOG_TYPE_ERROR;
                v128 = 22;
              }

              _os_log_impl(&dword_181A5C000, v126, v127, v125, &buf[0].sa_len, v128);
LABEL_271:
              if (metadata_for_capsule) {
                os_release(metadata_for_capsule);
              }
              goto LABEL_273;
            }

              goto LABEL_92;
            }

            if (!v72)
            {
              __nwlog_obj();
              os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v70 = type;
              if (os_log_type_enabled(v44, type))
              {
                *(_DWORD *)buf = 136446210;
                v75 = "nw_pac_resolver_create_with_script";
                _os_log_impl( &dword_181A5C000,  v44,  v70,  "%{public}s called with null logging_id_str, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_109;
            }

            os_log_type_t v54 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v64 = type;
            v65 = os_log_type_enabled(v55, type);
            if (v54)
            {
              if (v65)
              {
                *(_DWORD *)buf = 136446466;
                v75 = "nw_pac_resolver_create_with_script";
                v76 = 2082;
                v77 = v54;
                _os_log_impl( &dword_181A5C000,  v55,  v64,  "%{public}s called with null logging_id_str, dumping backtrace:%{public}s",  buf,  0x16u);
              }

  if (v58) {
    free(v58);
  }
  uint64_t v13 = 0LL;
LABEL_38:

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v30 = (os_log_s *)(id)gLogObj;
  os_log_type_t v31 = v30;
  if (v13)
  {
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      id v32 = *(void *)(v78 + 32);
      id v33 = nw_connection_copy_endpoint((nw_connection_t)v11);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_socks5_server_start_block_invoke";
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v32;
      *(_WORD *)&buf[22] = 2112;
      v90 = v13;
      LOWORD(v91) = 2112;
      *(void *)((char *)&v91 + 2) = v33;
      _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_DEFAULT,  "%{public}s %@ received new connection %@ from %@",  buf,  0x2Au);
    }

    id v34 = *(os_unfair_lock_s **)(v78 + 32);
    os_log_type_t v35 = MEMORY[0x1895F87A8];
    __int16 v36 = v34 + 6;
    v83[0] = MEMORY[0x1895F87A8];
    v83[1] = 3221225472LL;
    v83[2] = __nw_socks5_server_start_block_invoke_11;
    v83[3] = &unk_189BC9238;
    v84 = v34;
    os_log_type_t v37 = v13;
    v85 = v37;
    os_unfair_lock_lock(v36);
    __nw_socks5_server_start_block_invoke_11((uint64_t)v83);
    os_unfair_lock_unlock(v36);
    v80[0] = v35;
    v80[1] = 3221225472LL;
    v80[2] = __nw_socks5_server_start_block_invoke_2_12;
    v80[3] = &unk_189BC9238;
    v81 = *(id *)(v78 + 32);
    v82 = v37;
    BOOL v38 = v82;
    __int16 v39 = v80;
    uint64_t v41 = v38 + 5;
    int v40 = v38[5];
    *(void *)buf = v35;
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_socks5_connection_set_cancel_handler_block_invoke;
    v90 = &unk_189BC91E8;
    os_log_type_t v42 = v38;
    *(void *)&v91 = v42;
    BOOL v43 = v39;
    *((void *)&v91 + 1) = v43;
    dispatch_async(v40, buf);

    os_log_type_t v44 = v42;
    os_log_type_t v45 = *v41;
    *(void *)buf = v35;
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_socks5_connection_start_block_invoke;
    v90 = &unk_189BC93A0;
    v46 = v44;
    *(void *)&v91 = v46;
    dispatch_async(v45, buf);

    goto LABEL_63;
  }

  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v47 = *(void *)(v78 + 32);
    v48 = nw_connection_copy_endpoint((nw_connection_t)v11);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_socks5_server_start_block_invoke";
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v47;
    *(_WORD *)&buf[22] = 2112;
    v90 = v48;
    _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_ERROR,  "%{public}s %@ failed to create new connection from %@",  buf,  0x20u);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v49 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_socks5_server_start_block_invoke";
  os_log_type_t v50 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v88.receiver) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (LOBYTE(v88.receiver) == 17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (os_log_s *)(id)gLogObj;
    os_log_type_t v52 = (os_log_type_t)v88.receiver;
    if (os_log_type_enabled(v51, (os_log_type_t)v88.receiver))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socks5_server_start_block_invoke";
      _os_log_impl(&dword_181A5C000, v51, v52, "%{public}s nw_socks5_connection_create failed", buf, 0xCu);
    }

      free(v25);
      goto LABEL_115;
    }

    uint64_t v17 = (os_log_s *)__nwlog_obj();
    BOOL v18 = type;
    if (!os_log_type_enabled(v17, type)) {
      goto LABEL_115;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v38 = "nw_protocol_http1_accept";
    int v19 = "%{public}s called with null endpoint";
LABEL_114:
    _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
LABEL_115:
    if (v16) {
      free(v16);
    }
    return 0LL;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v38 = "nw_protocol_http1_accept";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v35 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      BOOL v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v38 = "nw_protocol_http1_accept";
      int v19 = "%{public}s called with null parameters";
      goto LABEL_114;
    }

    if (!v35)
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      BOOL v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v38 = "nw_protocol_http1_accept";
      int v19 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_114;
    }

    __int16 v25 = (char *)__nw_create_backtrace_string();
    uint64_t v17 = (os_log_s *)__nwlog_obj();
    BOOL v18 = type;
    id v28 = os_log_type_enabled(v17, type);
    if (!v25)
    {
      if (!v28) {
        goto LABEL_115;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v38 = "nw_protocol_http1_accept";
      int v19 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_114;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v38 = "nw_protocol_http1_accept";
      __int16 v39 = 2082;
      int v40 = v25;
      id v27 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_108;
    }

    goto LABEL_109;
  }

  if ((*(_BYTE *)(v8 + 376) & 8) != 0)
  {
    if (!(*(_BYTE *)(v8 + 158) & 1 | (gLogDatapath == 0)))
    {
      id v10 = (os_log_s *)__nwlog_obj();
      uint64_t result = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      os_log_type_t v11 = *(_DWORD *)(v8 + 372);
      *(_DWORD *)buf = 136446978;
      BOOL v38 = "nw_protocol_http1_accept";
      __int16 v39 = 2082;
      int v40 = (char *)(v8 + 74);
      uint64_t v41 = 2080;
      os_log_type_t v42 = " ";
      BOOL v43 = 1024;
      os_log_type_t v44 = v11;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> refusing accept because do not reuse is set",  buf,  0x26u);
    }

    return 0LL;
  }

  if (!(*(_BYTE *)(v8 + 158) & 1 | (gLogDatapath == 0)))
  {
    os_log_type_t v30 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v31 = *(_DWORD *)(v8 + 372);
      *(_DWORD *)buf = 136447490;
      BOOL v38 = "nw_protocol_http1_accept";
      __int16 v39 = 2082;
      int v40 = (char *)(v8 + 74);
      uint64_t v41 = 2080;
      os_log_type_t v42 = " ";
      BOOL v43 = 1024;
      os_log_type_t v44 = v31;
      os_log_type_t v45 = 2114;
      v46 = a2;
      v47 = 2114;
      v48 = a3;
      _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> accepting connection to %{public}@ with %{public}@",  buf,  0x3Au);
    }
  }

  return 1LL;
}

        if (v31) {
          free(v31);
        }
        BOOL v8 = &qword_18C45F000;
        if (!v21) {
          goto LABEL_179;
        }
        goto LABEL_178;
      }

      if (v20)
      {
        if (nw_protocol_metadata_is_http(v20))
        {
          if ((*(_BYTE *)(*(void *)(v12 + 248) + 376LL) & 1) != 0)
          {
            BOOL v43 = nw_http_metadata_copy_response(v21);
            if (v43)
            {
              id v28 = v43;
              os_log_type_t v29 = nw_http_response_copy(v43);
              metadata_for_response = nw_http_create_metadata_for_response((void *)v29);
LABEL_72:
              *(void *)buf = metadata_for_response;
              nw::retained_ptr<nw_endpoint *>::operator=(v12 + 384, buf);
              if (v29) {
                os_release((void *)v29);
              }
              os_release(v28);
              if ((*(_BYTE *)(v12 + 158) & 1) == 0)
              {
                if (gLogDatapath)
                {
                  v560 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v560, OS_LOG_TYPE_DEBUG))
                  {
                    v561 = *(void *)(v12 + 256);
                    v562 = *(_DWORD *)(*(void *)(v12 + 248) + 372LL);
                    if (v561) {
                      LODWORD(v561) = *(_DWORD *)(v561 + 860);
                    }
                    v563 = *(_DWORD *)(v12 + 424);
                    *(_DWORD *)buf = 136447490;
                    *(void *)&uint8_t buf[4] = "nw_http1_stream_save_outbound_message";
                    v638 = 2082;
                    *(void *)v639 = v12 + 74;
                    *(_WORD *)&v639[8] = 2080;
                    *(void *)&v639[10] = " ";
                    *(_WORD *)&v639[18] = 1024;
                    *(_DWORD *)v640 = v562;
                    *(_WORD *)&v640[4] = 1024;
                    *(_DWORD *)&v640[6] = v561;
                    *(_WORD *)v641 = 1024;
                    *(_DWORD *)&v641[2] = v563;
                    _os_log_impl( &dword_181A5C000,  v560,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> saved outbound message",  buf,  0x32u);
                  }
                }
              }

              os_log_type_t v44 = *((_DWORD *)a1 + 13);
              if ((!v44 || v44 == *((_DWORD *)a1 + 14) + *((_DWORD *)a1 + 15)) && (os_log_type_t v45 = *((void *)a1 + 8)) != 0) {
                v46 = (*(unsigned __int8 *)(v45 + 66) >> 6) & 1;
              }
              else {
                v46 = 0;
              }
              v47 = *v18;
              if (*v18)
              {
                if ((*(_BYTE *)(*(void *)(v12 + 248) + 376LL) & 1) != 0)
                {
                  v49 = nw_http_metadata_copy_response(v47);
                  status_code = nw_http_response_get_status_code(v49);
                  LODWORD(v52) = status_code == 101;
                  else {
                    os_log_type_t v54 = 2048;
                  }
                  *(_WORD *)(v12 + 428) = v54 | *(_WORD *)(v12 + 428) & 0xF7FF;
                  BOOL v55 = status_code == 101 || (status_code - 200) > 0xFFFFFF9B;
                  os_log_type_t v50 = v55;
                  if (!v49) {
                    goto LABEL_136;
                  }
                  goto LABEL_135;
                }

                v48 = nw_http_metadata_copy_request(v47);
                if (!v48)
                {
                  os_log_type_t v50 = 0;
                  LODWORD(v52) = 0;
                  goto LABEL_136;
                }

                v49 = v48;
                if ((*(_BYTE *)(*(void *)(v12 + 248) + 376LL) & 4) != 0)
                {
                  v68 = (nw_endpoint *)nw_parameters_copy_url_endpoint(*(void **)(v12 + 320));
                  os_log_type_t v52 = v68;
                  if (!v68)
                  {
LABEL_135:
                    os_release(v49);
LABEL_136:
                    v70 = nw_http_metadata_copy_header_fields(*v18);
                    if (!nw_http_fields_have_field_with_name(v70, (unint64_t)"Connection")
                      && (*(_WORD *)(v12 + 428) & 0x800) == 0)
                    {
                      nw_http_fields_append(v70, (uint64_t)"Connection", (uint64_t)"keep-alive");
                    }

                    if (((v46 ^ 1 | v50) & 1) == 0
                      && !nw_http_fields_have_field_with_name(v70, (unint64_t)"Content-Length"))
                    {
                      nw_http_fields_append(v70, (uint64_t)"Content-Length", (uint64_t)"0");
                    }

                    if ((v46 & 1) == 0)
                    {
                      if (v52 | nw_http_fields_have_field_with_name( v70,  (unint64_t)"Content-Length")) {
                        v71 = 0;
                      }
                      else {
                        v71 = 256;
                      }
                      *(_WORD *)(v12 + 428) = *(_WORD *)(v12 + 428) & 0xFEFF | v71;
                      if ((*(_BYTE *)(v12 + 158) & 1) == 0)
                      {
                        if (gLogDatapath)
                        {
                          v586 = (os_log_s *)__nwlog_obj();
                          if (os_log_type_enabled(v586, OS_LOG_TYPE_DEBUG))
                          {
                            v587 = *(void *)(v12 + 256);
                            v588 = *(_DWORD *)(*(void *)(v12 + 248) + 372LL);
                            if (v587) {
                              LODWORD(v587) = *(_DWORD *)(v587 + 860);
                            }
                            v589 = *(_DWORD *)(v12 + 424);
                            v590 = "uses";
                            if ((*(_WORD *)(v12 + 428) & 0x100) == 0) {
                              v590 = "does not use";
                            }
                            *(_DWORD *)buf = 136447746;
                            *(void *)&uint8_t buf[4] = "nw_http1_stream_process_outbound_message";
                            v638 = 2082;
                            *(void *)v639 = v12 + 74;
                            *(_WORD *)&v639[8] = 2080;
                            *(void *)&v639[10] = " ";
                            *(_WORD *)&v639[18] = 1024;
                            *(_DWORD *)v640 = v588;
                            *(_WORD *)&v640[4] = 1024;
                            *(_DWORD *)&v640[6] = v587;
                            *(_WORD *)v641 = 1024;
                            *(_DWORD *)&v641[2] = v589;
                            *(_WORD *)&v641[6] = 2080;
                            *(void *)&v641[8] = v590;
                            _os_log_impl( &dword_181A5C000,  v586,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> outbound data %s chunked encoding",  buf,  0x3Cu);
                          }
                        }
                      }

                      if ((*(_WORD *)(v12 + 428) & 0x100) != 0) {
                        nw_http_fields_set_value_by_name(v70, (uint64_t)"Transfer-Encoding", (uint64_t)"chunked");
                      }
                    }

                    v72 = *(void *)(v12 + 256);
                    if ((_DWORD)v52) {
                      v73 = 512;
                    }
                    else {
                      v73 = 0;
                    }
                    v74 = *(_WORD *)(v72 + 872) & 0xFDFF | (*(unsigned __int8 *)(v72 + 874) << 16);
                    *(_WORD *)(v72 + 872) = *(_WORD *)(v72 + 872) & 0xFDFF | v73;
                    *(_BYTE *)(v72 + 874) = BYTE2(v74);
                    if (v70) {
                      os_release(v70);
                    }
LABEL_155:
                    nw_http_transaction_metadata_set_outbound_message(*(void **)(v12 + 352), *(void **)(v12 + 384));
                    nw::http::content_length_manager::set_outbound_message( (nw::http::content_length_manager *)(v12 + 160),  *(nw_protocol_metadata **)(v12 + 384));
                    os_release(v21);
                    uint64_t v22 = 1;
                    id v6 = v627;
                    BOOL v8 = &qword_18C45F000;
                    goto LABEL_180;
                  }

                  url = nw_endpoint_get_url(v68);
                  nw_http_request_set_path(v49, (uint64_t)url);
                  os_release(v52);
                }

                LODWORD(v52) = 0;
                goto LABEL_135;
              }

              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http1_stream_process_outbound_message";
              v556 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v643) = 16;
              LOBYTE(v647) = 0;
              if (__nwlog_fault(v556, &v643, &v647))
              {
                if (v643 == 17)
                {
                  v557 = (os_log_s *)__nwlog_obj();
                  v558 = v643;
                  if (!os_log_type_enabled(v557, (os_log_type_t)v643)) {
                    goto LABEL_1059;
                  }
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_process_outbound_message";
                  v559 = "%{public}s called with null http1_stream->outbound_message";
LABEL_1057:
                  v601 = v557;
                  v602 = v558;
LABEL_1058:
                  _os_log_impl(&dword_181A5C000, v601, v602, v559, buf, 0xCu);
                  goto LABEL_1059;
                }

                if (!(_BYTE)v647)
                {
                  v557 = (os_log_s *)__nwlog_obj();
                  v558 = v643;
                  if (!os_log_type_enabled(v557, (os_log_type_t)v643)) {
                    goto LABEL_1059;
                  }
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_process_outbound_message";
                  v559 = "%{public}s called with null http1_stream->outbound_message, backtrace limit exceeded";
                  goto LABEL_1057;
                }

                v582 = (char *)__nw_create_backtrace_string();
                v583 = (os_log_s *)__nwlog_obj();
                v584 = v643;
                v585 = os_log_type_enabled(v583, (os_log_type_t)v643);
                if (v582)
                {
                  if (v585)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_http1_stream_process_outbound_message";
                    v638 = 2082;
                    *(void *)v639 = v582;
                    _os_log_impl( &dword_181A5C000,  v583,  v584,  "%{public}s called with null http1_stream->outbound_message, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v582);
                  goto LABEL_1059;
                }

                if (v585)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_stream_process_outbound_message";
                  v559 = "%{public}s called with null http1_stream->outbound_message, no backtrace";
                  v601 = v583;
                  v602 = v584;
                  goto LABEL_1058;
                }
              }

          goto LABEL_110;
        }

    v51 = v163;
    if (v28) {
      free(v28);
    }
    os_log_type_t v35 = 0LL;
    os_log_type_t v50 = v15;
    v49 = v164;
    if (a4 == 0LL || a5 == 0)
    {
LABEL_71:
      if (v49) {
        goto LABEL_72;
      }
LABEL_138:
      if (!v50)
      {
LABEL_73:
        if (v51) {
          goto LABEL_74;
        }
        goto LABEL_140;
      }

    if (v47) {
      free(v47);
    }
    goto LABEL_51;
  }

  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  LODWORD(v75) = 0;
  *(void *)&buf[16] = 0x2000000000LL;
  *(void *)os_log_type_t type = 0LL;
  v69 = type;
  LODWORD(v71) = 0;
  v70 = 0x2000000000LL;
  uint64_t v22 = (nw_frame **)(handle + 104);
  char v21 = *((void *)handle + 13);
  v57[0] = MEMORY[0x1895F87A8];
  v57[1] = 0x40000000LL;
  BOOL v58 = (uint64_t (*)(void *))___ZL45nw_protocol_http3_uni_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2;
  os_log_type_t v59 = &unk_189BC40A0;
  os_log_type_t v60 = buf;
  v61 = type;
  do
  {
    if (!v21) {
      break;
    }
    char v23 = *(void *)(v21 + 32);
    int v24 = v58(v57);
    char v21 = v23;
  }

  while ((v24 & 1) != 0);
  if (a3 <= *(_DWORD *)(*(void *)&buf[8] + 24LL) || a5 <= *((_DWORD *)v69 + 6)) {
    goto LABEL_27;
  }
  __int16 v25 = a1->output_handler;
  if (v25)
  {
    id v26 = v25->callbacks;
    if (v26)
    {
      id v27 = (uint64_t (*)(void))v26->get_input_frames;
      if (v27)
      {
        id v28 = v27();
        if (v28)
        {
          *((_DWORD *)v69 + 6) += v28;
LABEL_27:
          if (*v22)
          {
            *a6->tqh_last = *v22;
            *(void *)(*((void *)handle + 13) + 40LL) = a6->tqh_last;
            a6->tqh_last = (nw_frame **)*((void *)handle + 14);
            *((void *)handle + 13) = 0LL;
            *((void *)handle + 14) = v22;
          }

          os_log_type_t v29 = *((unsigned int *)v69 + 6);
          goto LABEL_30;
        }
      }
    }
  }

  os_log_type_t v29 = 0LL;
LABEL_30:
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  return v29;
}

      if (v36) {
        free(v36);
      }
      goto LABEL_111;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v31 = (id)gLogObj;
    *(_DWORD *)os_log_type_t type = 136446210;
    v77 = "nw_path_create_evaluator_for_client_id";
    id v32 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v75) = 16;
    LOBYTE(obj) = 0;
    if (__nwlog_fault(v32, &v75, &obj))
    {
      if (v75 == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v33 = (os_log_s *)(id)gLogObj;
        id v34 = v75;
        if (os_log_type_enabled(v33, (os_log_type_t)v75))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          v77 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s nw_parameters_create failed", (uint8_t *)type, 0xCu);
        }
      }

      else if ((_BYTE)obj)
      {
        BOOL v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = v75;
        os_log_type_t v45 = os_log_type_enabled(v33, (os_log_type_t)v75);
        if (v43)
        {
          if (v45)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            v77 = "nw_path_create_evaluator_for_client_id";
            v78 = 2082;
            v79[0] = v43;
            _os_log_impl( &dword_181A5C000,  v33,  v44,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
          }

          free(v43);
          if (!v32) {
            goto LABEL_105;
          }
          goto LABEL_104;
        }

        if (v45)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          v77 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl( &dword_181A5C000,  v33,  v44,  "%{public}s nw_parameters_create failed, no backtrace",  (uint8_t *)type,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v52 = v75;
        if (os_log_type_enabled(v33, (os_log_type_t)v75))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          v77 = "nw_path_create_evaluator_for_client_id";
          _os_log_impl( &dword_181A5C000,  v33,  v52,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
        }
      }
    }

    if (!v32)
    {
LABEL_105:
      BOOL v18 = 0LL;
LABEL_113:

      goto LABEL_92;
    }

    if (v46) {
      free(v46);
    }
    return;
  }

  BOOL v43 = " ";
  os_log_type_t v44 = *(_DWORD *)(a1 + 368);
  *(void *)&uint8_t buf[4] = "nw_http2_session_send";
  *(_WORD *)&buf[12] = 2082;
  os_log_type_t v45 = (const char *)(a1 + 390);
  *(_DWORD *)buf = 136446978;
  if (!a1) {
    os_log_type_t v45 = "";
  }
  *(void *)&buf[14] = v45;
  if (!a1) {
    BOOL v43 = "";
  }
  *(_WORD *)&buf[22] = 2080;
  *(void *)&buf[24] = v43;
  *(_WORD *)&buf[32] = 1024;
  *(_DWORD *)&buf[34] = v44;
  _os_log_impl(&dword_181A5C000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
  uint64_t v2 = *(_WORD *)(a1 + 388);
  if ((v2 & 0x100) != 0)
  {
LABEL_83:
    if ((v2 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v39 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v50 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http2_session_send";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = a1 + 390;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v50;
        uint64_t v41 = "%{public}s %{public}s%s<i%u> already in session send, skipping";
        goto LABEL_94;
      }
    }

    return;
  }

    if (!v53) {
      return 1LL;
    }
    char v23 = (char *)v53;
    goto LABEL_34;
  }

  id v6 = *(void *)(object + 24);
  if (v6 && *(void *)(v6 + 56))
  {
    if (v5)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v43 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_7;
      }
      os_log_type_t v45 = *(_DWORD *)(v5 + 176);
      os_log_type_t v44 = *(_DWORD *)(v5 + 180);
      v46 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)buf = 136447746;
      v90 = "nw_protocol_http2_error_block_invoke";
      v91 = 2082;
      v92 = (const char *)(v5 + 191);
      v93 = 2080;
      v94 = " ";
      v95 = 1024;
      v96 = v44;
      v97 = 1024;
      *(_DWORD *)v98 = v45;
      *(_WORD *)&v98[4] = 1024;
      *(_DWORD *)&v98[6] = v46;
      *(_WORD *)&v98[10] = 2048;
      *(void *)&v98[12] = object;
      int v40 = "%{public}s %{public}s%s<i%u:s%d> passing error %d to input protocol %p";
      uint64_t v41 = (os_log_s *)v43;
      os_log_type_t v42 = 60;
    }

    else
    {
      id v32 = *(void *)(a1 + 32);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v33 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_7;
      }
      id v34 = *(void *)(a1 + 32);
      os_log_type_t v35 = "";
      __int16 v36 = *(_DWORD *)(v34 + 368);
      os_log_type_t v37 = v34 == 0;
      if (v34) {
        BOOL v38 = (const char *)(v34 + 390);
      }
      else {
        BOOL v38 = "";
      }
      __int16 v39 = *(_DWORD *)(a1 + 48);
      if (!v37) {
        os_log_type_t v35 = " ";
      }
      *(_DWORD *)buf = 136447490;
      v90 = "nw_protocol_http2_error_block_invoke";
      v91 = 2082;
      v92 = v38;
      v93 = 2080;
      v94 = v35;
      v95 = 1024;
      v96 = v36;
      v97 = 1024;
      *(_DWORD *)v98 = v39;
      *(_WORD *)&v98[4] = 2048;
      *(void *)&v98[6] = object;
      int v40 = "%{public}s %{public}s%s<i%u> passing error %d to input protocol %p";
      uint64_t v41 = (os_log_s *)v33;
      os_log_type_t v42 = 54;
    }

    _os_log_impl(&dword_181A5C000, v41, OS_LOG_TYPE_DEBUG, v40, buf, v42);
LABEL_7:
    (*(void (**)(uint64_t, void, void))(*(void *)(object + 24) + 56LL))( object,  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48));
    return 1LL;
  }

  if (v5)
  {
    if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      __int16 v25 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        id v27 = *(_DWORD *)(v5 + 176);
        id v26 = *(_DWORD *)(v5 + 180);
        id v28 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)buf = 136447746;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = (const char *)(v5 + 191);
        v93 = 2080;
        v94 = " ";
        v95 = 1024;
        v96 = v26;
        v97 = 1024;
        *(_DWORD *)v98 = v27;
        *(_WORD *)&v98[4] = 2048;
        *(void *)&v98[6] = object;
        *(_WORD *)&v98[14] = 1024;
        *(_DWORD *)&v98[16] = v28;
        os_log_type_t v29 = "%{public}s %{public}s%s<i%u:s%d> callbacks on protocol %p not set, cannot pass error %d";
        os_log_type_t v30 = (os_log_s *)v25;
        os_log_type_t v31 = 60;
LABEL_42:
        _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      }
    }
  }

  else
  {
    v79 = *(void *)(a1 + 32);
    if (!v79 || (*(__int16 *)(v79 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v80 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v81 = *(void *)(a1 + 32);
        v82 = "";
        v83 = *(_DWORD *)(v81 + 368);
        v84 = v81 == 0;
        if (v81) {
          v85 = (const char *)(v81 + 390);
        }
        else {
          v85 = "";
        }
        v86 = *(_DWORD *)(a1 + 48);
        if (!v84) {
          v82 = " ";
        }
        *(_DWORD *)buf = 136447490;
        v90 = "nw_protocol_http2_error_block_invoke";
        v91 = 2082;
        v92 = v85;
        v93 = 2080;
        v94 = v82;
        v95 = 1024;
        v96 = v83;
        v97 = 2048;
        *(void *)v98 = object;
        *(_WORD *)&v98[8] = 1024;
        *(_DWORD *)&v98[10] = v86;
        os_log_type_t v29 = "%{public}s %{public}s%s<i%u> callbacks on protocol %p not set, cannot pass error %d";
        os_log_type_t v30 = (os_log_s *)v80;
        os_log_type_t v31 = 54;
        goto LABEL_42;
      }
    }
  }

  return 1LL;
}

    if (v38) {
      free(v38);
    }
    goto LABEL_111;
  }

  if ((v27 & 0x8000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    BOOL v8 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      id v28 = *((_DWORD *)handle + 92);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 390;
      *(_WORD *)&buf[22] = 2080;
      os_log_type_t v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v28;
      id v10 = "%{public}s %{public}s%s<i%u> tunnel already connected or closed, ignoring connected event";
      goto LABEL_69;
    }
  }

        if (v58) {
          free(v58);
        }
        LOWORD(v43) = v56;
        LOBYTE(v41) = v55;
        os_log_type_t v42 = v130;
LABEL_112:
        if (v40 == *(unsigned __int8 *)(a1 + 156))
        {
          v74 = v41;
          v75 = v43;
          v76 = v42;
          *v135 += nw_protocol_ipv6_process_reassembly(a1, v42, v134, 0, 0LL);
          if (v76)
          {
            v78 = *(void *)(a2 + 32);
            v79 = *(void **)(a2 + 40);
            v80 = (void *)(a2 + 32);
            if (v78)
            {
              *(void *)(v78 + 40) = v79;
              v79 = *(void **)(a2 + 40);
            }

            else
            {
              *(void *)(v131 + 8) = v79;
            }

            *v79 = v78;
            *v80 = 0LL;
            *(void *)(a2 + 40) = 0LL;
            if (v75)
            {
              if ((v74 & 1) != 0)
              {
                *(void *)buf = 0LL;
                *(void *)&buf[8] = buf;
                *(void *)&buf[16] = 0x2000000000LL;
                LOBYTE(v146) = 0;
                v136[0] = MEMORY[0x1895F87A8];
                v136[1] = 0x40000000LL;
                v137 = ___ZL36nw_protocol_ipv6_process_input_frameP16nw_protocol_ipv6P8nw_frameP16nw_frame_array_sS4_PjS5__block_invoke;
                v138 = &unk_189BC8AF0;
                v142 = v75;
                v140 = a1;
                v141 = a2;
                v139 = buf;
                v82 = *(void *)(a1 + 88);
                do
                {
                  if (!v82) {
                    break;
                  }
                  v83 = *(void *)(v82 + 32);
                  v84 = ((uint64_t (*)(void *))v137)(v136);
                  v82 = v83;
                }

                while ((v84 & 1) != 0);
                if (!*(_BYTE *)(*(void *)&buf[8] + 24LL))
                {
                  *(void *)(a2 + 32) = 0LL;
                  v85 = *(uint64_t **)(a1 + 96);
                  *(void *)(a2 + 40) = v85;
                  *v85 = a2;
                  *(void *)(a1 + 96) = v80;
                }

                _Block_object_dispose(buf, 8);
              }

              else
              {
                v90 = *(uint64_t **)(a1 + 96);
                *(void *)(a2 + 40) = v90;
                *v90 = a2;
                *(void *)(a1 + 96) = v80;
              }
            }

            else
            {
              v87 = *(void *)(a1 + 88);
              v86 = (uint64_t *)(a1 + 88);
              *(void *)(a2 + 32) = v87;
              v88 = (void *)(v87 + 40);
              if (v87) {
                v89 = v88;
              }
              else {
                v89 = v86 + 1;
              }
              *v89 = v80;
              *v86 = a2;
              *(void *)(a2 + 40) = v86;
            }

            --*v132;
          }

          else
          {
            v81 = *(void *)(a1 + 48);
            if (v81) {
              ++*(void *)(v81 + 104);
            }
            nw_frame_claim(a2, v77, v44, v133 - v22);
            ++*(void *)(a1 + 8);
          }

          return 1LL;
        }

        v111 = *(void *)(a1 + 48);
        if (v111)
        {
          uint64_t result = 0LL;
          ++*(void *)(v111 + 160);
          return result;
        }

        return 0LL;
      }

      if (v40 > 43)
      {
        if (v40 != 60)
        {
          if (v40 != 44) {
            goto LABEL_100;
          }
          if ((unint64_t)v44 + 8 > v22)
          {
            v65 = v42;
            v66 = v41;
            __int16 v67 = v43;
            if ((*(_BYTE *)(a1 + 158) & 1) != 0
              || (v94 = (os_log_s *)__nwlog_obj(), !os_log_type_enabled(v94, OS_LOG_TYPE_ERROR)))
            {
              int v40 = 44;
            }

            else
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 159;
              *(_WORD *)&buf[22] = 2080;
              v146 = " ";
              v147 = 2048;
              v148 = a1;
              v149 = 2048;
              *(void *)&v150 = v22;
              _os_log_impl( &dword_181A5C000,  v94,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p IPv6 fragment header cannot fit in packet length %lu",  buf,  0x34u);
              int v40 = 44;
            }

            goto LABEL_104;
          }

          v46 = (unsigned __int8 *)v17 + v44;
          int v40 = *v46;
          v44 += 8;
          os_log_type_t v42 = *((_DWORD *)v46 + 1);
          v47 = *((unsigned __int16 *)v46 + 1);
          BOOL v43 = bswap32(v47 & 0xFFFFF8FF) >> 16;
          uint64_t v41 = (v47 >> 8) & 1;
          if ((*(_BYTE *)(a1 + 158) & 1) == 0 && gLogDatapath)
          {
            v122 = a7;
            v126 = a8;
            v48 = *((_DWORD *)v46 + 1);
            v49 = v43;
            v128 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = v126.n128_u32[0];
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_process_input_frame";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = a1 + 159;
              *(_WORD *)&buf[22] = 2080;
              v146 = " ";
              v147 = 2048;
              v148 = a1;
              v149 = 1024;
              LODWORD(v150) = v49;
              WORD2(v150) = 1024;
              *(_DWORD *)((char *)&v150 + 6) = (unsigned __int16)(v47 & 0x100) >> 8;
              WORD5(v150) = 1024;
              HIDWORD(v150) = v48;
              _os_log_impl( &dword_181A5C000,  v128,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p Received IPv6 fragment offset %u more %u id %u",  buf,  0x3Cu);
              a7 = v122;
              a8 = v126;
              os_log_type_t v42 = v48;
              BOOL v43 = v49;
              uint64_t v41 = (v47 >> 8) & 1;
            }

            else
            {
              BOOL v43 = v49;
              uint64_t v41 = (v47 >> 8) & 1;
              os_log_type_t v42 = v48;
              a7 = v122;
              a8 = v126;
            }

            os_log_type_t v45 = "%{public}s %{public}s%s%p Received IPv6 extension type %u length %u";
          }

          goto LABEL_69;
        }
      }

      else if (v40 && v40 != 43)
      {
LABEL_100:
        v65 = v42;
        v66 = v41;
        __int16 v67 = v43;
        if ((*(_BYTE *)(a1 + 158) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v68 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv6_process_input_frame";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 159;
            *(_WORD *)&buf[22] = 2080;
            v146 = " ";
            v147 = 2048;
            v148 = a1;
            v149 = 1024;
            LODWORD(v150) = v40;
            v69 = "%{public}s %{public}s%s%p Don't know how to handle IPv6 next protocol %u";
            v70 = (os_log_s *)v68;
            v71 = 48;
            goto LABEL_103;
          }
        }

    if (!v47) {
      return;
    }
    goto LABEL_110;
  }

  id v6 = *((void *)a3 + 35);
  if (v6 && (node = nw_hash_table_get_node(v6, (uint64_t)uu, 16LL)) != 0)
  {
    BOOL v8 = 0;
    id v9 = *(void *)(node + 16);
    id v10 = node + 32;
  }

  else
  {
    id v10 = 0LL;
    id v9 = 0LL;
    BOOL v8 = 1;
  }

  if ((*((_WORD *)a1 + 102) & 4) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v11 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_reclassify_input";
      _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_ERROR, "%{public}s reclassify failed to reset frame", buf, 0xCu);
    }

    nw_frame_finalize((uint64_t)a1);
    return;
  }

  uint64_t v12 = *((_OWORD *)a1 + 14);
  *(_OWORD *)buf = *((_OWORD *)a1 + 13);
  *(_OWORD *)&buf[16] = v12;
  data_offset = os_buflet_get_data_offset();
  uint64_t v14 = os_buflet_get_object_address() + data_offset;
  data_length = os_buflet_get_data_length();
  nw_frame_reset((uint64_t)a1, v14, data_length, (uint64_t)nw_channel_finalize_input_frame, (uint64_t)a3);
  if ((*((_WORD *)a1 + 102) & 4) != 0) {
    BOOL v16 = (_OWORD *)((char *)a1 + 208);
  }
  else {
    BOOL v16 = 0LL;
  }
  uint64_t v17 = *(_OWORD *)&buf[16];
  *BOOL v16 = *(_OWORD *)buf;
  v16[1] = v17;
  if (v9) {
    BOOL v18 = v8;
  }
  else {
    BOOL v18 = 1;
  }
  if ((v18 & 1) != 0 || !v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v25 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_channel_reclassify_input";
      *(_WORD *)&buf[12] = 1042;
      *(_DWORD *)&buf[14] = 16;
      *(_WORD *)&buf[18] = 2098;
      *(void *)&buf[20] = uu;
      _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s reclassify can't find client for slot %{public,uuid_t}.16P, pending",  buf,  0x1Cu);
    }

    if (!uuid_is_null((const unsigned __int8 *)a3 + 352) && uuid_compare((const unsigned __int8 *)a3 + 352, uu))
    {
      v71[0] = MEMORY[0x1895F87A8];
      v71[1] = 0x40000000LL;
      v72 = ___ZL27nw_channel_reclassify_inputP8nw_framePhPv_block_invoke;
      v73 = &__block_descriptor_tmp_45_87392;
      v74 = a3;
      id v33 = *((void *)a3 + 42);
      do
      {
        if (!v33) {
          break;
        }
        id v34 = *(void *)(v33 + 32);
        os_log_type_t v35 = ((uint64_t (*)(void *))v72)(v71);
        id v33 = v34;
      }

      while ((v35 & 1) != 0);
      __int16 v36 = *((void *)a3 + 24);
      if (v36)
      {
        nw_queue_cancel_source(v36, v33);
        *((void *)a3 + 24) = 0LL;
      }
    }

    *((_OWORD *)a3 + 22) = *(_OWORD *)uu;
    *((void *)a1 + 4) = 0LL;
    id v26 = (void *)*((void *)a3 + 43);
    *((void *)a1 + 5) = v26;
    char *v26 = a1;
    *((void *)a3 + 43) = (char *)a1 + 32;
    if (*((void *)a3 + 24)) {
      return;
    }
    id v27 = (void *)*((void *)a3 + 19);
    v70[0] = MEMORY[0x1895F87A8];
    v70[1] = 0x40000000LL;
    v70[2] = ___ZL27nw_channel_reclassify_inputP8nw_framePhPv_block_invoke_2;
    v70[3] = &__block_descriptor_tmp_48_87393;
    v70[4] = a3;
    source = nw_queue_context_create_source(v27, 2, 3, 0, v70, 0LL);
    *((void *)a3 + 24) = source;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v29 = (os_log_s *)gLogObj;
    if (source)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_reclassify_input";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = 2000LL;
        _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s Setting timer to finalize pending reclassify frames in %llums",  buf,  0x16u);
      }

      os_log_type_t v30 = *((void *)a3 + 24);
      os_log_type_t v31 = dispatch_time(0x8000000000000000LL, 2000000000LL);
      nw_queue_set_timer_values(v30, v31, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
      nw_queue_activate_source(*((void *)a3 + 24), v32);
      return;
    }

    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_reclassify_input";
    v47 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = (os_log_s *)gLogObj;
      v49 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_109;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_reclassify_input";
      os_log_type_t v50 = "%{public}s nw_queue_context_create_source(timer) failed";
      goto LABEL_108;
    }

    if (!v75)
    {
      v48 = (os_log_s *)__nwlog_obj();
      v49 = type[0];
      if (!os_log_type_enabled(v48, type[0])) {
        goto LABEL_109;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_reclassify_input";
      os_log_type_t v50 = "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded";
      goto LABEL_108;
    }

    os_log_type_t v59 = (char *)__nw_create_backtrace_string();
    v48 = (os_log_s *)__nwlog_obj();
    v49 = type[0];
    os_log_type_t v60 = os_log_type_enabled(v48, type[0]);
    if (!v59)
    {
      if (!v60) {
        goto LABEL_109;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_reclassify_input";
      os_log_type_t v50 = "%{public}s nw_queue_context_create_source(timer) failed, no backtrace";
      goto LABEL_108;
    }

    if (v60)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_channel_reclassify_input";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v59;
      v61 = "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s";
LABEL_93:
      _os_log_impl(&dword_181A5C000, v48, v49, v61, buf, 0x16u);
      goto LABEL_94;
    }

    goto LABEL_94;
  }

  *((void *)a1 + 4) = 0LL;
  int v19 = *(void **)(v10 + 8);
  *((void *)a1 + 5) = v19;
  const char *v19 = a1;
  *(void *)(v10 + 8) = (char *)a1 + 32;
  os_log_type_t v20 = *(void *)(v9 + 56);
  if (v20 && ((*(_BYTE *)(v20 + 153) & 8) != 0 || (*((_WORD *)a3 + 222) & 0x80) == 0))
  {
    char v21 = *(void *)(v9 + 24);
    if (v21)
    {
      uint64_t v22 = *(void (**)(uint64_t, char *))(v21 + 64);
      if (!v22) {
        goto LABEL_152;
      }
      char v23 = *(void **)(v9 + 40);
      if (v23 == &nw_protocol_ref_counted_handle)
      {
        int v24 = *(void *)(v9 + 88);
        if (v24) {
          *(void *)(v9 + 88) = v24 + 1;
        }
      }

      if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v37 = *((void *)a3 + 14);
        if (v37) {
          *((void *)a3 + 14) = v37 + 1;
        }
        v22(v9, a3 + 24);
        if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
        {
          v51 = *((void *)a3 + 14);
          if (v51)
          {
            os_log_type_t v52 = v51 - 1;
            *((void *)a3 + 14) = v52;
            if (!v52)
            {
              v53 = (void (**)(void))*((void *)a3 + 11);
              if (v53)
              {
                *((void *)a3 + 11) = 0LL;
                v53[2](v53);
                _Block_release(v53);
              }

              if ((a3[96] & 1) != 0)
              {
                os_log_type_t v54 = (const void *)*((void *)a3 + 11);
                if (v54) {
                  _Block_release(v54);
                }
              }

              free(a3 + 24);
            }
          }
        }
      }

      else
      {
        v22(v9, a3 + 24);
      }

      if (v23 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v9 + 40) == &nw_protocol_ref_counted_handle)
      {
        BOOL v55 = *(void *)(v9 + 88);
        if (v55)
        {
          v56 = v55 - 1;
          *(void *)(v9 + 88) = v56;
          if (!v56)
          {
            os_log_type_t v57 = *(void (***)(void))(v9 + 64);
            if (v57)
            {
              *(void *)(v9 + 64) = 0LL;
              v57[2](v57);
              _Block_release(v57);
            }

            if ((*(_BYTE *)(v9 + 72) & 1) != 0)
            {
              BOOL v58 = *(const void **)(v9 + 64);
              if (v58) {
                _Block_release(v58);
              }
            }

            free((void *)v9);
          }
        }
      }

      char v21 = *(void *)(v9 + 24);
      if (v21)
      {
LABEL_152:
        BOOL v38 = *(void (**)(uint64_t, char *))(v21 + 264);
        if (v38)
        {
          __int16 v39 = *(void **)(v9 + 40);
          if (v39 == &nw_protocol_ref_counted_handle)
          {
            int v40 = *(void *)(v9 + 88);
            if (v40) {
              *(void *)(v9 + 88) = v40 + 1;
            }
          }

          if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v41 = *((void *)a3 + 14);
            if (v41) {
              *((void *)a3 + 14) = v41 + 1;
            }
            v38(v9, a3 + 24);
            if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
            {
              id v62 = *((void *)a3 + 14);
              if (v62)
              {
                char v63 = v62 - 1;
                *((void *)a3 + 14) = v63;
                if (!v63)
                {
                  v64 = (void (**)(void))*((void *)a3 + 11);
                  if (v64)
                  {
                    *((void *)a3 + 11) = 0LL;
                    v64[2](v64);
                    _Block_release(v64);
                  }

                  if ((a3[96] & 1) != 0)
                  {
                    v65 = (const void *)*((void *)a3 + 11);
                    if (v65) {
                      _Block_release(v65);
                    }
                  }

                  free(a3 + 24);
                }
              }
            }
          }

          else
          {
            v38(v9, a3 + 24);
          }

          if (v39 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v9 + 40) == &nw_protocol_ref_counted_handle)
          {
            os_log_type_t v42 = *(void *)(v9 + 88);
            if (v42)
            {
              BOOL v43 = v42 - 1;
              *(void *)(v9 + 88) = v43;
              if (!v43)
              {
                os_log_type_t v44 = *(void (***)(void))(v9 + 64);
                if (v44)
                {
                  *(void *)(v9 + 64) = 0LL;
                  v44[2](v44);
                  _Block_release(v44);
                }

                if ((*(_BYTE *)(v9 + 72) & 1) != 0)
                {
                  os_log_type_t v45 = *(const void **)(v9 + 64);
                  if (v45) {
                    _Block_release(v45);
                  }
                }

                v46 = (char *)v9;
                goto LABEL_111;
              }
            }
          }
        }
      }
    }
  }

void sub_181A7DA98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_allow_use_of_dispatch_internal()
{
  if (sNWIsBetweenForkAndExec != 1
    || (sNWParentAllowedDispatch & 1) == 0 && !_dispatch_is_fork_of_multithreaded_parent())
  {
    goto LABEL_6;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  v0 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v0))
  {
    free(v0);
LABEL_6:
    pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
    sNWDispatchAllowedNow = 1;
    networkd_settings_init();
    networkd_settings_setup_notify_watch();
    return;
  }

  __break(1u);
}

void networkd_settings_setup_notify_watch(void)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
  {
    if ((sNWDispatchAllowedNow & 1) == 0)
    {
      if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
        || (getpid(), sandbox_check() == 1))
      {
        sNWDispatchAllowedNow = 1;
      }

      else if (!sNWDispatchAllowedNow)
      {
        return;
      }
    }

    if (!networkd_settings_setup_notify_watch(void)::queue)
    {
      pthread_mutex_lock(&sSettingsMutex);
      id v6 = (const char *)nw_notification_name_settings;
      id v7 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      BOOL v8 = dispatch_queue_create(v6, v7);
      networkd_settings_setup_notify_watch(void)::queue = (uint64_t)v8;
      if (!v8) {
        goto LABEL_11;
      }
      int out_token = 0;
      uint32_t v9 = notify_register_dispatch( (const char *)nw_notification_name_settings,  &out_token,  v8,  &__block_literal_global_88514);
      pthread_mutex_unlock(&sSettingsMutex);
      if (!v9)
      {
LABEL_12:
        uint64_t v0 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v0);
        int out_token = 136446466;
        os_log_type_t v35 = "networkd_settings_setup_notify_watch";
        __int16 v36 = 2082;
        uint64_t v37 = nw_notification_name_settings;
        id v1 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v32 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v2 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v2);
          id v3 = (os_log_s *)gLogObj;
          os_log_type_t v4 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_48;
          }
          int out_token = 136446466;
          os_log_type_t v35 = "networkd_settings_setup_notify_watch";
          __int16 v36 = 2082;
          uint64_t v37 = nw_notification_name_settings;
          id v5 = "%{public}s dispatch_queue_create(%{public}s) failed";
        }

        else if (v32)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v15 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v15);
          id v3 = (os_log_s *)gLogObj;
          os_log_type_t v4 = type;
          BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v16)
            {
              int out_token = 136446722;
              os_log_type_t v35 = "networkd_settings_setup_notify_watch";
              __int16 v36 = 2082;
              uint64_t v37 = nw_notification_name_settings;
              __int16 v38 = 2082;
              *(void *)__int16 v39 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s dispatch_queue_create(%{public}s) failed, dumping backtrace:%{public}s",  (uint8_t *)&out_token,  0x20u);
            }

            free(backtrace_string);
            goto LABEL_48;
          }

          if (!v16)
          {
LABEL_48:
            if (v1) {
              free(v1);
            }
            return;
          }

          int out_token = 136446466;
          os_log_type_t v35 = "networkd_settings_setup_notify_watch";
          __int16 v36 = 2082;
          uint64_t v37 = nw_notification_name_settings;
          id v5 = "%{public}s dispatch_queue_create(%{public}s) failed, no backtrace";
        }

        else
        {
          uint64_t v25 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v25);
          id v3 = (os_log_s *)gLogObj;
          os_log_type_t v4 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_48;
          }
          int out_token = 136446466;
          os_log_type_t v35 = "networkd_settings_setup_notify_watch";
          __int16 v36 = 2082;
          uint64_t v37 = nw_notification_name_settings;
          id v5 = "%{public}s dispatch_queue_create(%{public}s) failed, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v3, v4, v5, (uint8_t *)&out_token, 0x16u);
        goto LABEL_48;
      }

      int v10 = nw_settings_should_be_able_to_use_notify_apis(void)::has_notify_apis;
      uint64_t v11 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v11);
      uint64_t v12 = (os_log_s *)gLogObj;
      if (v10 == 1 && v9 == 1000000)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
        {
          if (sNWIsBetweenForkAndExec) {
            uint64_t v13 = " (forked)";
          }
          else {
            uint64_t v13 = "";
          }
          int out_token = 136446978;
          os_log_type_t v35 = "networkd_settings_setup_notify_watch";
          __int16 v36 = 2082;
          uint64_t v37 = nw_notification_name_settings;
          __int16 v38 = 1024;
          *(_DWORD *)__int16 v39 = 1000000;
          *(_WORD *)&v39[4] = 2082;
          *(void *)&v39[6] = v13;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEFAULT,  "%{public}s [sandboxed: ok] notify_register_dispatch(%{public}s) [status %u]%{public}s failed",  (uint8_t *)&out_token,  0x26u);
        }

LABEL_178:
    if (v96) {
      free(v96);
    }
    goto LABEL_192;
  }

  if (!v7)
  {
    __nwlog_obj();
    v99 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
    v100 = (char *)_os_log_send_and_compose_impl();

    v153 = OS_LOG_TYPE_ERROR;
    v152 = 0;
    if (__nwlog_fault(v100, &v153, &v152))
    {
      if (v153 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v102 = v153;
        if (os_log_type_enabled(v101, v153))
        {
          *(_DWORD *)buf = 136446210;
          v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
          _os_log_impl(&dword_181A5C000, v101, v102, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v152)
      {
        v118 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v119 = v153;
        v120 = os_log_type_enabled(v101, v153);
        if (v118)
        {
          if (v120)
          {
            *(_DWORD *)buf = 136446466;
            v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
            v156 = 2082;
            v157 = (uint64_t)v118;
            _os_log_impl( &dword_181A5C000,  v101,  v119,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v118);
          goto LABEL_183;
        }

        if (v120)
        {
          *(_DWORD *)buf = 136446210;
          v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
          _os_log_impl(&dword_181A5C000, v101, v119, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v101 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v143 = v153;
        if (os_log_type_enabled(v101, v153))
        {
          *(_DWORD *)buf = 136446210;
          v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
          _os_log_impl( &dword_181A5C000,  v101,  v143,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      if (!v73)
      {
LABEL_113:
        os_log_type_t v35 = address;
LABEL_114:
        os_release(v35);
        return;
      }

        goto LABEL_65;
      }

      if (!v81)
      {
        __nwlog_obj();
        id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v78 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl( &dword_181A5C000,  v33,  v78,  "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_178;
      }

      v46 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v62 = type;
      char v63 = os_log_type_enabled(v33, type);
      if (!v46)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl( &dword_181A5C000,  v33,  v62,  "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace",  buf,  0xCu);
        }

        goto LABEL_178;
      }

      if (v63)
      {
        *(_DWORD *)buf = 136446466;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        v85 = 2082;
        *(void *)v86 = v46;
        _os_log_impl( &dword_181A5C000,  v33,  v62,  "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    free(v46);
    if (!v6) {
      goto LABEL_78;
    }
    goto LABEL_66;
  }

  xpc_dictionary_get_value(v4, (const char *)networkd_privileged_key_result);
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v16 = v15;
  if (!v15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v29 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v81 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl(&dword_181A5C000, v19, v30, "%{public}s received response without result code", buf, 0xCu);
      }

      goto LABEL_134;
    }

    if (!v81)
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v61 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl( &dword_181A5C000,  v19,  v61,  "%{public}s received response without result code, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_134;
    }

    __int16 v40 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v43 = type;
    os_log_type_t v44 = os_log_type_enabled(v19, type);
    if (!v40)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl( &dword_181A5C000,  v19,  v43,  "%{public}s received response without result code, no backtrace",  buf,  0xCu);
      }

      goto LABEL_134;
    }

    if (v44)
    {
      *(_DWORD *)buf = 136446466;
      v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
      v85 = 2082;
      *(void *)v86 = v40;
      _os_log_impl( &dword_181A5C000,  v19,  v43,  "%{public}s received response without result code, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_83;
  }

  if (object_getClass(v15) != (Class)MEMORY[0x1895F9280])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v81 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      uint64_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s received invalid result type", buf, 0xCu);
      }

              v48 = 1;
              goto LABEL_179;
            }

        if (v83) {
          free(v83);
        }
        a5 = 0LL;
        BOOL v18 = a6;
        goto LABEL_25;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v94 = "__nw_protocol_get_parameters";
      v92 = OS_LOG_TYPE_ERROR;
      v91 = 0;
      v65 = (char *)_os_log_send_and_compose_impl();
      if (__nwlog_fault(v65, &v92, &v91))
      {
        if (v92 == OS_LOG_TYPE_FAULT)
        {
          v66 = (os_log_s *)__nwlog_obj();
          __int16 v67 = v92;
          if (os_log_type_enabled(v66, v92))
          {
            *(_DWORD *)buf = 136446210;
            v94 = "__nw_protocol_get_parameters";
            v68 = "%{public}s called with null protocol";
LABEL_187:
            v79 = v66;
            v80 = v67;
LABEL_188:
            _os_log_impl(&dword_181A5C000, v79, v80, v68, buf, 0xCu);
          }
        }

        else if (v91)
        {
          v72 = (char *)__nw_create_backtrace_string();
          v73 = (os_log_s *)__nwlog_obj();
          v84 = v92;
          v74 = os_log_type_enabled(v73, v92);
          if (v72)
          {
            if (v74)
            {
              *(_DWORD *)buf = 136446466;
              v94 = "__nw_protocol_get_parameters";
              v95 = 2082;
              v96 = v72;
              _os_log_impl( &dword_181A5C000,  v73,  v84,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v72);
            goto LABEL_189;
          }

          if (v74)
          {
            *(_DWORD *)buf = 136446210;
            v94 = "__nw_protocol_get_parameters";
            v68 = "%{public}s called with null protocol, no backtrace";
            v79 = v73;
            v80 = v84;
            goto LABEL_188;
          }
        }

        else
        {
          v66 = (os_log_s *)__nwlog_obj();
          __int16 v67 = v92;
          if (os_log_type_enabled(v66, v92))
          {
            *(_DWORD *)buf = 136446210;
            v94 = "__nw_protocol_get_parameters";
            v68 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_187;
          }
        }
      }

      if (v69) {
        free(v69);
      }
      goto LABEL_50;
    }

    __nwlog_obj();
    id v62 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
    BOOL v58 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v63 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl( &dword_181A5C000,  v59,  v63,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW)",  buf,  0xCu);
      }
    }

    else if ((_BYTE)v103)
    {
      v73 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v74 = type[0];
      v75 = os_log_type_enabled(v59, type[0]);
      if (v73)
      {
        if (v75)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
          v108 = 2082;
          v109 = v73;
          _os_log_impl( &dword_181A5C000,  v59,  v74,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v73);
        if (!v58) {
          goto LABEL_104;
        }
LABEL_172:
        free(v58);
        goto LABEL_104;
      }

      if (v75)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl( &dword_181A5C000,  v59,  v74,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v81 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        _os_log_impl( &dword_181A5C000,  v59,  v81,  "%{public}s called with null (flow == NW_PROTOCOL_DEFAULT_FLOW), backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_170;
  }

  if (a2 >= 0xFFFFFFFFFFFFFFFELL)
  {
    if ((v5[405] & 0x40) != 0)
    {
      if ((v5[405] & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v26 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
          v108 = 2082;
          v109 = v5 + 407;
          v110 = 2080;
          v111 = " ";
          _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%salready in report done, skipping",  buf,  0x20u);
        }
      }
    }

    else
    {
      v5[405] |= 0x40u;
      v5[404] |= 4u;
      nw_protocol_remove_instance((uint64_t)(v5 - 96));
      int v10 = *((void *)v5 + 3);
      if (v10)
      {
        if (*(void *)v10)
        {
          uint64_t v11 = *(void (**)(void))(*(void *)v10 + 8LL);
          if (v11) {
            v11();
          }
        }

        *((void *)v5 + 3) = 0LL;
      }

      uint64_t v12 = (char *)*((void *)v5 + 29);
      v98[0] = MEMORY[0x1895F87A8];
      v98[1] = 3221225472LL;
      v98[2] = __nw_protocol_instance_report_done_block_invoke;
      v98[3] = &unk_189BB7560;
      v99 = v6;
      v100 = v5;
      nw_hash_table_apply(v12, (uint64_t)v98);
      v5[405] &= ~0x40u;
    }

    goto LABEL_104;
  }

  node = nw_hash_table_get_node(*((void *)v5 + 29), a2, 8LL);
  if (!node)
  {
    if ((v5[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_report_done";
        v108 = 2082;
        v109 = v5 + 407;
        v110 = 2080;
        v111 = " ";
        v112 = 2048;
        v113 = a2;
        _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sCannot report done, flow %llx does not exist",  buf,  0x2Au);
      }
    }

    goto LABEL_104;
  }

  *(_WORD *)(node + 84) |= 0x200u;
  uint64_t v20 = *(const char **)(node + 16);
  if (!v20) {
    goto LABEL_104;
  }
  if (!v6) {
    goto LABEL_88;
  }
  char v21 = *((void *)v20 + 3);
  if (!v21 || !*(void *)(v21 + 56)) {
    goto LABEL_88;
  }
  os_log_type_t v22 = (unsigned int *)v6;
  char v23 = v22[3];

  int v24 = (void *)*((void *)v20 + 5);
  if (v24 == &nw_protocol_ref_counted_handle)
  {
    BOOL v43 = *((void *)v20 + 11);
    if (v43) {
      *((void *)v20 + 11) = v43 + 1;
    }
    uint64_t v25 = -1;
  }

  else
  {
    uint64_t v25 = 0;
  }

  *(void *)os_log_type_t type = v20;
  v106 = v25;
  os_log_type_t v44 = (void *)*((void *)v5 - 7);
  if (v44 == &nw_protocol_ref_counted_handle)
  {
    v46 = *((void *)v5 - 1);
    if (v46) {
      *((void *)v5 - 1) = v46 + 1;
    }
    os_log_type_t v45 = -1;
  }

  else
  {
    os_log_type_t v45 = 0;
  }

  v103 = v5 - 96;
  v104 = v45;
  v47 = *((void *)v20 + 3);
  if (!v47 || (v48 = *(void (**)(const char *, char *, uint64_t))(v47 + 56)) == 0LL)
  {
    __nwlog_obj();
    v82 = (void *)objc_claimAutoreleasedReturnValue();
    v83 = (const char *)*((void *)v20 + 2);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_error";
    if (!v83) {
      v83 = "invalid";
    }
    v108 = 2082;
    v109 = (char *)v83;
    v110 = 2048;
    v111 = v20;
    v84 = (char *)_os_log_send_and_compose_impl();

    v102 = OS_LOG_TYPE_ERROR;
    v101 = 0;
    if (v102 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v86 = v102;
      if (os_log_type_enabled(v85, v102))
      {
        v87 = (const char *)*((void *)v20 + 2);
        if (!v87) {
          v87 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_error";
        v108 = 2082;
        v109 = (char *)v87;
        v110 = 2048;
        v111 = v20;
        _os_log_impl( &dword_181A5C000,  v85,  v86,  "%{public}s protocol %{public}s (%p) has invalid error callback",  buf,  0x20u);
      }
    }

    else if (v101)
    {
      v91 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v92 = v102;
      v93 = os_log_type_enabled(v85, v102);
      if (v91)
      {
        if (v93)
        {
          v94 = (const char *)*((void *)v20 + 2);
          if (!v94) {
            v94 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_protocol_error";
          v108 = 2082;
          v109 = (char *)v94;
          v110 = 2048;
          v111 = v20;
          v112 = 2082;
          v113 = (unint64_t)v91;
          _os_log_impl( &dword_181A5C000,  v85,  v92,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v91);
        goto LABEL_197;
      }

      if (v93)
      {
        v97 = (const char *)*((void *)v20 + 2);
        if (!v97) {
          v97 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_error";
        v108 = 2082;
        v109 = (char *)v97;
        v110 = 2048;
        v111 = v20;
        _os_log_impl( &dword_181A5C000,  v85,  v92,  "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      __nwlog_obj();
      v85 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v95 = v102;
      if (os_log_type_enabled(v85, v102))
      {
        v96 = (const char *)*((void *)v20 + 2);
        if (!v96) {
          v96 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_error";
        v108 = 2082;
        v109 = (char *)v96;
        v110 = 2048;
        v111 = v20;
        _os_log_impl( &dword_181A5C000,  v85,  v95,  "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded",  buf,  0x20u);
      }
    }

LABEL_197:
    if (v84) {
      free(v84);
    }
    goto LABEL_84;
  }

  v48(v20, v5 - 96, v23);
LABEL_84:
  if (v44 == &nw_protocol_ref_counted_handle) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)&v103);
  }
  if (v24 == &nw_protocol_ref_counted_handle) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
  }
LABEL_88:
  v49 = *((void *)v20 + 3);
  if (v49)
  {
    os_log_type_t v50 = *(void (**)(const char *))(v49 + 48);
    if (v50)
    {
      v51 = (void *)*((void *)v20 + 5);
      if (v51 == &nw_protocol_ref_counted_handle)
      {
        v53 = *((void *)v20 + 11);
        if (v53) {
          *((void *)v20 + 11) = v53 + 1;
        }
        os_log_type_t v52 = -1;
      }

      else
      {
        os_log_type_t v52 = 0;
      }

      *(void *)buf = v20;
      buf[8] = v52;
      os_log_type_t v54 = (void *)*((void *)v5 - 7);
      if (v54 == &nw_protocol_ref_counted_handle)
      {
        v56 = *((void *)v5 - 1);
        if (v56) {
          *((void *)v5 - 1) = v56 + 1;
        }
        BOOL v55 = -1;
      }

      else
      {
        BOOL v55 = 0;
      }

      *(void *)os_log_type_t type = v5 - 96;
      v106 = v55;
      v50(v20);
      if (v54 == &nw_protocol_ref_counted_handle) {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      }
      if (v51 == &nw_protocol_ref_counted_handle) {
        goto LABEL_103;
      }
    }
  }

  if (!v62)
  {
    v110 = *((void *)v54 + 18);
    if (v110 && *(void *)(v110 + 24) != *(void *)(v110 + 16))
    {
      id v62 = 0LL;
      nw_listener_set_state_on_queue(v54, 2, 0LL);
      goto LABEL_184;
    }

    id v62 = nw_error_create_posix_error(22);
  }

  nw_listener_set_state_on_queue(v54, 3, v62);
LABEL_184:

LABEL_194:
  if (v35) {
    free(v35);
  }
LABEL_196:

  _Block_object_dispose(&v121, 8);
  _Block_object_dispose(&v125, 8);
  _Block_object_dispose(type, 8);
}

    if (v97) {
      free(v97);
    }
    goto LABEL_98;
  }

  if (nw_parameters_get_is_known_tracker((void *)v29))
  {
    nw_parameters_set_is_known_tracker((void *)v29, 0);
    uint64_t v42 = (id)v29;
    BOOL v43 = v42;
    if (v42)
    {
      *((void *)v42 + 12) |= 0x80000000uLL;
LABEL_48:

      goto LABEL_49;
    }

    __nwlog_obj();
    v124 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v178 = "nw_parameters_set_parent_is_known_tracker";
    v125 = (void *)_os_log_send_and_compose_impl();

    LOBYTE(iterate_block[0]) = 16;
    v176 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault((const char *)v125, iterate_block, &v176))
    {
LABEL_201:
      if (v125) {
        free(v125);
      }
      goto LABEL_48;
    }

    v126 = v15;
    if (LOBYTE(iterate_block[0]) == 17)
    {
      __nwlog_obj();
      v127 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v128 = iterate_block[0];
      if (os_log_type_enabled(v127, iterate_block[0]))
      {
        *(_DWORD *)buf = 136446210;
        v178 = "nw_parameters_set_parent_is_known_tracker";
        _os_log_impl(&dword_181A5C000, v127, v128, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else
    {
      if (v176)
      {
        v144 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v145 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v146 = iterate_block[0];
        v147 = os_log_type_enabled(v145, iterate_block[0]);
        if (v144)
        {
          if (v147)
          {
            *(_DWORD *)buf = 136446466;
            v178 = "nw_parameters_set_parent_is_known_tracker";
            v179 = 2082;
            v180 = v144;
            _os_log_impl( &dword_181A5C000,  v145,  v146,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          uint64_t v15 = v126;
          free(v144);
          goto LABEL_201;
        }

        if (v147)
        {
          *(_DWORD *)buf = 136446210;
          v178 = "nw_parameters_set_parent_is_known_tracker";
          _os_log_impl(&dword_181A5C000, v145, v146, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }

        goto LABEL_200;
      }

      __nwlog_obj();
      v127 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v152 = iterate_block[0];
      if (os_log_type_enabled(v127, iterate_block[0]))
      {
        *(_DWORD *)buf = 136446210;
        v178 = "nw_parameters_set_parent_is_known_tracker";
        _os_log_impl( &dword_181A5C000,  v127,  v152,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_200:
    uint64_t v15 = v126;
    goto LABEL_201;
  }

  if (v34) {
    free(v34);
  }
  return 0LL;
}

        free(v69);
        goto LABEL_179;
      }

      if (v79)
      {
        *(_DWORD *)buf = 136446210;
        v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_181A5C000, v70, v78, "%{public}s called with null (hop_count > 0), no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v81 = type;
      if (os_log_type_enabled(v70, type))
      {
        *(_DWORD *)buf = 136446210;
        v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl( &dword_181A5C000,  v70,  v81,  "%{public}s called with null (hop_count > 0), backtrace limit exceeded",  buf,  0xCu);
      }
    }

      free(v92);
      if (!v84) {
        return;
      }
LABEL_194:
      free(v84);
      return;
    }

    v85 = (os_log_s *)__nwlog_obj();
    v86 = type;
    if (!os_log_type_enabled(v85, type)) {
      goto LABEL_193;
    }
    *(_DWORD *)buf = 136446210;
    v101 = "nw_protocol_http_messaging_connected";
    v87 = "%{public}s called with null http_messaging";
LABEL_192:
    _os_log_impl(&dword_181A5C000, v85, v86, v87, buf, 0xCu);
    goto LABEL_193;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v101 = "nw_protocol_http_messaging_connected";
    v84 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v85 = (os_log_s *)__nwlog_obj();
      v86 = type;
      if (!os_log_type_enabled(v85, type)) {
        goto LABEL_193;
      }
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_http_messaging_connected";
      v87 = "%{public}s called with null other_protocol";
      goto LABEL_192;
    }

    if (!v98)
    {
      v85 = (os_log_s *)__nwlog_obj();
      v86 = type;
      if (!os_log_type_enabled(v85, type)) {
        goto LABEL_193;
      }
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_http_messaging_connected";
      v87 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_192;
    }

    v92 = (char *)__nw_create_backtrace_string();
    v85 = (os_log_s *)__nwlog_obj();
    v86 = type;
    v95 = os_log_type_enabled(v85, type);
    if (!v92)
    {
      if (!v95) {
        goto LABEL_193;
      }
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_http_messaging_connected";
      v87 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_192;
    }

    if (v95)
    {
      *(_DWORD *)buf = 136446466;
      v101 = "nw_protocol_http_messaging_connected";
      v102 = 2082;
      v103 = v92;
      v94 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_177;
    }

    goto LABEL_178;
  }

  if ((handle[272] & 0x10) != 0)
  {
    if ((handle[272] & 2) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      return;
    }
    *(_DWORD *)buf = 136446722;
    v101 = "nw_protocol_http_messaging_connected";
    v102 = 2082;
    v103 = handle + 188;
    v104 = 2080;
    v105 = " ";
    uint64_t v20 = "%{public}s %{public}s%signoring connected";
    char v21 = (os_log_s *)v19;
    os_log_type_t v22 = OS_LOG_TYPE_INFO;
LABEL_29:
    _os_log_impl(&dword_181A5C000, v21, v22, v20, buf, 0x20u);
    return;
  }

  os_log_type_t v4 = (void *)*((void *)handle + 6);
  if (!v4)
  {
    if ((handle[272] & 2) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v23 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446722;
    v101 = "nw_protocol_http_messaging_connected";
    v102 = 2082;
    v103 = handle + 188;
    v104 = 2080;
    v105 = " ";
    uint64_t v20 = "%{public}s %{public}s%sno default input handler, ignoring connected";
    char v21 = (os_log_s *)v23;
    os_log_type_t v22 = OS_LOG_TYPE_ERROR;
    goto LABEL_29;
  }

  nw_protocol_connected(v4, (uint64_t)a2);
  if (*((nw_protocol **)handle + 4) == a2)
  {
    if ((handle[272] & 2) == 0)
    {
      if (gLogDatapath)
      {
        v96 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v101 = "nw_http_messaging_get_http_version_from_alpn";
          v102 = 2082;
          v103 = handle + 188;
          v104 = 2080;
          v105 = " ";
          _os_log_impl(&dword_181A5C000, v96, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }

    id v5 = nw_protocol_copy_info(*((void *)handle + 4), 255);
    id v6 = (void *)v5;
    if (v5
      && (id v7 = *(void *)(v5 + 24) - *(void *)(v5 + 16)) != 0
      && (object_at_index = (nw_protocol_metadata *)nw_array_get_object_at_index(v5, (v7 >> 3) - 1)) != 0LL)
    {
      uint32_t v9 = object_at_index;
      is_tls = nw_protocol_metadata_is_tls(object_at_index);
      uint64_t v11 = v9;
      uint64_t v12 = v11;
      if (is_tls)
      {
        negotiated_protocol = sec_protocol_metadata_get_negotiated_protocol(v11);
        if ((handle[272] & 2) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v14 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446978;
            v101 = "nw_http_messaging_get_http_version_from_alpn";
            v102 = 2082;
            v103 = handle + 188;
            v104 = 2080;
            v105 = " ";
            v106 = 2082;
            v107 = negotiated_protocol;
            _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sFound TLS metadata with ALPN %{public}s",  buf,  0x2Au);
          }
        }

        if (negotiated_protocol)
        {
          if (!strcmp(negotiated_protocol, "h2"))
          {
            v66 = 4;
            goto LABEL_149;
          }

          if (strcmp(negotiated_protocol, "http/1.1"))
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446466;
            v101 = "nw_http_messaging_get_http_version_from_alpn";
            v102 = 2080;
            v103 = (char *)negotiated_protocol;
            uint64_t v15 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v98 = 0;
            if (__nwlog_fault(v15, &type, &v98))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                BOOL v16 = (os_log_s *)__nwlog_obj();
                uint64_t v17 = type;
                if (os_log_type_enabled(v16, type))
                {
                  *(_DWORD *)buf = 136446466;
                  v101 = "nw_http_messaging_get_http_version_from_alpn";
                  v102 = 2080;
                  v103 = (char *)negotiated_protocol;
                  BOOL v18 = "%{public}s Invalid TLS ALPN %s";
LABEL_145:
                  _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0x16u);
                }
              }

              else if (v98)
              {
                v82 = (char *)__nw_create_backtrace_string();
                BOOL v16 = (os_log_s *)__nwlog_obj();
                uint64_t v17 = type;
                v83 = os_log_type_enabled(v16, type);
                if (v82)
                {
                  if (v83)
                  {
                    *(_DWORD *)buf = 136446722;
                    v101 = "nw_http_messaging_get_http_version_from_alpn";
                    v102 = 2080;
                    v103 = (char *)negotiated_protocol;
                    v104 = 2082;
                    v105 = v82;
                    _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s Invalid TLS ALPN %s, dumping backtrace:%{public}s",  buf,  0x20u);
                  }

                  free(v82);
                  goto LABEL_146;
                }

                if (v83)
                {
                  *(_DWORD *)buf = 136446466;
                  v101 = "nw_http_messaging_get_http_version_from_alpn";
                  v102 = 2080;
                  v103 = (char *)negotiated_protocol;
                  BOOL v18 = "%{public}s Invalid TLS ALPN %s, no backtrace";
                  goto LABEL_145;
                }
              }

              else
              {
                BOOL v16 = (os_log_s *)__nwlog_obj();
                uint64_t v17 = type;
                if (os_log_type_enabled(v16, type))
                {
                  *(_DWORD *)buf = 136446466;
                  v101 = "nw_http_messaging_get_http_version_from_alpn";
                  v102 = 2080;
                  v103 = (char *)negotiated_protocol;
                  BOOL v18 = "%{public}s Invalid TLS ALPN %s, backtrace limit exceeded";
                  goto LABEL_145;
                }
              }
            }

LABEL_183:
    if (v100) {
      free(v100);
    }
    goto LABEL_191;
  }

  uint32_t v9 = *(_OWORD *)(v7 + 8);
  *(_OWORD *)(v8 + 24) = *(_OWORD *)(v7 + 24);
  *(_OWORD *)(v8 + 8) = v9;
  int v10 = *(_OWORD *)(v7 + 40);
  uint64_t v11 = *(_OWORD *)(v7 + 56);
  uint64_t v12 = *(_OWORD *)(v7 + 72);
  *(_OWORD *)(v8 + 88) = *(_OWORD *)(v7 + 88);
  *(_OWORD *)(v8 + 72) = v12;
  *(_OWORD *)(v8 + 56) = v11;
  *(_OWORD *)(v8 + 40) = v10;
  uint64_t v13 = (void *)*((void *)v7 + 13);
  if (a4)
  {
    uint64_t v14 = v13;
    uint64_t v15 = a1[13];
    a1[13] = v14;
    goto LABEL_30;
  }

  BOOL v16 = v13;
  if (!v16)
  {
    __nwlog_obj();
    v114 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v155 = "nw_path_parameters_copy";
    v115 = (char *)_os_log_send_and_compose_impl();

    v153 = OS_LOG_TYPE_ERROR;
    v152 = 0;
    if (__nwlog_fault(v115, &v153, &v152))
    {
      if (v153 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v117 = v153;
        if (os_log_type_enabled(v116, v153))
        {
          *(_DWORD *)buf = 136446210;
          v155 = "nw_path_parameters_copy";
          _os_log_impl(&dword_181A5C000, v116, v117, "%{public}s called with null original", buf, 0xCu);
        }
      }

      else if (v152)
      {
        v136 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v137 = v153;
        v138 = os_log_type_enabled(v116, v153);
        if (v136)
        {
          if (v138)
          {
            *(_DWORD *)buf = 136446466;
            v155 = "nw_path_parameters_copy";
            v156 = 2082;
            v157 = (uint64_t)v136;
            _os_log_impl( &dword_181A5C000,  v116,  v137,  "%{public}s called with null original, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v136);
          goto LABEL_202;
        }

        if (v138)
        {
          *(_DWORD *)buf = 136446210;
          v155 = "nw_path_parameters_copy";
          _os_log_impl(&dword_181A5C000, v116, v137, "%{public}s called with null original, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v116 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v145 = v153;
        if (os_log_type_enabled(v116, v153))
        {
          *(_DWORD *)buf = 136446210;
          v155 = "nw_path_parameters_copy";
          _os_log_impl( &dword_181A5C000,  v116,  v145,  "%{public}s called with null original, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v128) {
    free(v128);
  }
  BOOL v43 = 0LL;
LABEL_124:

  return v43;
}

    v47 = 0LL;
    goto LABEL_184;
  }

  uint64_t v25 = nw_endpoint_handler_copy_flow(v10);
  if ((*((_BYTE *)v25 + 34) & 8) != 0)
  {
    if (!nw_endpoint_handler_get_minimize_logging(v10))
    {
      id v26 = v10;
      uint64_t v27 = *((_BYTE *)v26 + 268);

      if ((v27 & 0x20) != 0) {
        goto LABEL_61;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      BOOL v28 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_60;
      }
      loga = v28;
      os_log_type_t v29 = v26;

      os_log_type_t v30 = v29;
      os_log_type_t v31 = *((_BYTE *)v26 + 268);

      if ((v31 & 1) != 0) {
        char v32 = "dry-run ";
      }
      else {
        char v32 = "";
      }
      id v33 = nw_endpoint_handler_copy_endpoint(v30);
      id v34 = nw_endpoint_get_logging_description(v33);
      os_log_type_t v35 = v30;
      __int16 v36 = v35;
      uint64_t v37 = v10->state;
      else {
        __int16 v38 = off_189BBBBF0[v37];
      }
      v143 = v38;
      id_str = v29->id_str;

      uint64_t v42 = v36;
      BOOL v43 = v42;
      v146 = v34;
      os_log_type_t v44 = "path";
      switch(v8[29])
      {
        case 0:
          break;
        case 1:
          os_log_type_t v44 = "resolver";
          break;
        case 2:
          os_log_type_t v44 = nw_endpoint_flow_mode_string(v42[31]);
          break;
        case 3:
          os_log_type_t v44 = "proxy";
          break;
        case 4:
          os_log_type_t v44 = "fallback";
          break;
        case 5:
          os_log_type_t v44 = "transform";
          break;
        default:
          os_log_type_t v44 = "unknown-mode";
          break;
      }

      v48 = v43;
      os_unfair_lock_lock((os_unfair_lock_t)v48 + 28);
      v49 = v48[8];
      os_unfair_lock_unlock((os_unfair_lock_t)v48 + 28);

      os_log_type_t v50 = v49;
      v51 = v155;
      os_log_type_t v52 = (dispatch_data_s *)v51[7];
      v53 = v51[9];
      v139 = v33;
      if (v52)
      {
        if (!v53)
        {
          size = dispatch_data_get_size(v52);
LABEL_54:
          BOOL v55 = v51[14];
          if (size <= v55) {
            BOOL v55 = 0LL;
          }
          v56 = size - v55;
          goto LABEL_57;
        }
      }

      else if (!v53)
      {
        v56 = 0LL;
LABEL_57:

        os_log_type_t v57 = v51;
        BOOL v58 = v57[8];

        os_log_type_t v59 = "not ";
        v159 = "nw_flow_add_write_request";
        *(_DWORD *)buf = 136448258;
        if (v58) {
          os_log_type_t v59 = "";
        }
        v160 = 2082;
        v161 = id_str;
        v162 = 2082;
        v163 = v32;
        v164 = 2082;
        v165 = (void *)v146;
        v166 = 2082;
        v167 = v143;
        v168 = 2082;
        v169 = v44;
        v170 = 2114;
        v171 = v50;
        v172 = 2048;
        v173 = v56;
        v174 = 2080;
        v175 = v59;
        BOOL v28 = loga;
        _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_DEFAULT,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Write request submitted: %zu bytes, context %spresent",  buf,  0x5Cu);

LABEL_60:
        id v6 = v155;
        goto LABEL_61;
      }

      size = v51[12];
      goto LABEL_54;
    }

    if ((nw_endpoint_handler_get_logging_disabled(v10) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v119 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v119, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v10);
        v145 = nw_endpoint_handler_dry_run_string(v10);
        logc = nw_endpoint_handler_copy_endpoint(v10);
        v142 = nw_endpoint_get_logging_description(logc);
        v140 = nw_endpoint_handler_state_string(v10);
        v120 = nw_endpoint_handler_mode_string(v10);
        v121 = nw_endpoint_handler_copy_current_path(v10);
        v122 = nw_write_request_remaining_bytes(v155);
        BOOL v28 = v119;
        v123 = nw_write_request_copy_context(v155);
        *(_DWORD *)buf = 136448258;
        v159 = "nw_flow_add_write_request";
        v124 = "";
        v161 = (char *)id_string;
        v160 = 2082;
        if (!v123) {
          v124 = "not ";
        }
        v162 = 2082;
        v163 = v145;
        v164 = 2082;
        v165 = (void *)v142;
        v166 = 2082;
        v167 = v140;
        v168 = 2082;
        v169 = v120;
        v170 = 2114;
        v171 = v121;
        v172 = 2048;
        v173 = v122;
        v174 = 2080;
        v175 = v124;
        _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Write request submitted: %zu bytes, context %spresent",  buf,  0x5Cu);
      }

      else
      {
        BOOL v28 = v119;
      }

      goto LABEL_60;
    }
  }

        *v74 = 0;
LABEL_184:
        if (!v2)
        {
          __nwlog_obj();
          v121 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v121, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          v140 = "_strict_strlcat";
          v122 = (void *)_os_log_send_and_compose_impl();

          uint64_t result = __nwlog_abort((uint64_t)v122);
          if (result) {
            goto LABEL_268;
          }
          free(v122);
        }

        v83 = 0LL;
        v84 = 107LL;
        while (1)
        {
          v85 = &v2[v83];
          if (!v2[v83]) {
            break;
          }
          ++v83;
          if (!--v84) {
            goto LABEL_196;
          }
        }

        if (v84 < 2)
        {
LABEL_195:
          *v85 = 0;
        }

        else
        {
          v86 = v84 - 2;
          v87 = 106 - v83;
          v88 = 105 - v83;
          if (v88 >= 0x12) {
            v88 = 18LL;
          }
          memcpy(v85, "txt_record_changed", v88 + 1);
          v85 = v2 + 106;
          while (v86 <= 0x11)
          {
            if (!--v87) {
              goto LABEL_195;
            }
          }
        }

        goto LABEL_196;
      }
    }

    goto LABEL_184;
  }

  __nwlog_obj();
  os_log_type_t v57 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_copy_info";
  BOOL v58 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v96 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v58, type, &v96))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v60 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_copy_info";
        _os_log_impl(&dword_181A5C000, v59, v60, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v96)
    {
      v69 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v70 = type[0];
      v71 = os_log_type_enabled(v59, type[0]);
      if (v69)
      {
        if (v71)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_copy_info";
          v100 = 2082;
          v101 = v69;
          _os_log_impl( &dword_181A5C000,  v59,  v70,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v69);
        goto LABEL_172;
      }

      if (v71)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_copy_info";
        _os_log_impl(&dword_181A5C000, v59, v70, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v80 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_copy_info";
        _os_log_impl( &dword_181A5C000,  v59,  v80,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

          nw_http_fields_append(v87, (uint64_t)"Connect-UDP-Bind", (uint64_t)"2");
          goto LABEL_184;
        }

    if (v78) {
      free(v78);
    }
    goto LABEL_64;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
  v68 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v100[0]) = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v69 = (os_log_s *)__nwlog_obj();
    v70 = type[0];
    if (!os_log_type_enabled(v69, type[0])) {
      goto LABEL_178;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
    v71 = "%{public}s called with null parameters";
    goto LABEL_177;
  }

  if (!LOBYTE(v100[0]))
  {
    v69 = (os_log_s *)__nwlog_obj();
    v70 = type[0];
    if (!os_log_type_enabled(v69, type[0])) {
      goto LABEL_178;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
    v71 = "%{public}s called with null parameters, backtrace limit exceeded";
    goto LABEL_177;
  }

  v86 = (char *)__nw_create_backtrace_string();
  v69 = (os_log_s *)__nwlog_obj();
  v70 = type[0];
  v87 = os_log_type_enabled(v69, type[0]);
  if (!v86)
  {
    if (!v87) {
      goto LABEL_178;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
    v71 = "%{public}s called with null parameters, no backtrace";
    goto LABEL_177;
  }

  if (v87)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_add_to_http_messaging";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v86;
    _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v86);
  if (v68) {
LABEL_179:
  }
    free(v68);
LABEL_69:
  if (!*((void *)handle + 4))
  {
    if ((handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v50 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v51 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v108) = 1024;
        *(_DWORD *)((char *)&v108 + 2) = v51;
        _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> failed to get output handler for HTTP/3 CONNECT stream, failing",  buf,  0x26u);
      }
    }

    if (*((_DWORD *)handle + 111) != 5)
    {
      if ((handle[548] & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v54 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          BOOL v55 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v108) = 1024;
          *(_DWORD *)((char *)&v108 + 2) = v55;
          HIWORD(v108) = 1024;
          LODWORD(v109) = 57;
          _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d",  buf,  0x2Cu);
        }
      }

      *((_DWORD *)handle + 111) = 5;
      v56 = (char *)*((void *)handle + 23);
      if (v56)
      {
        *(void *)buf = v10;
        *(void *)&buf[8] = 0x40000000LL;
        *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
        v107 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_tmp_22_33505;
        LODWORD(v108) = 57;
        nw_hash_table_apply(v56, (uint64_t)buf);
      }

      os_log_type_t v57 = *((void *)handle + 53);
      if (v57)
      {
        BOOL v58 = *(void **)(v57 + 48);
        nw_protocol_error(v58, *((void *)handle + 53));
        nw_protocol_disconnected(v58, v57);
      }

      os_log_type_t v59 = *((void *)handle + 41);
      if (v59)
      {
        do
        {
          os_log_type_t v60 = *(void *)(v59 + 112);
          v61 = *(void **)(v59 + 48);
          nw_protocol_error(v61, v59);
          nw_protocol_disconnected(v61, v59);
          os_log_type_t v59 = v60;
        }

        while (v60);
      }

      id v62 = *((void *)handle + 52);
      if (v62)
      {
        char v63 = *(void **)(v62 + 48);
        nw_protocol_error(v63, *((void *)handle + 52));
        nw_protocol_disconnected(v63, v62);
      }

      if (*((void *)handle + 4))
      {
        nw_protocol_remove_instance((uint64_t)handle);
        nw_protocol_disconnect(*((void **)handle + 4), (uint64_t)handle);
      }

      return 0LL;
    }

    if ((handle[548] & 2) != 0) {
      return 0LL;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v52 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      return 0LL;
    }
    v53 = *((_DWORD *)handle + 115);
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = handle + 464;
    *(_WORD *)&buf[22] = 2080;
    v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
    LOWORD(v108) = 1024;
    *(_DWORD *)((char *)&v108 + 2) = v53;
    BOOL v18 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
    uint64_t v19 = (os_log_s *)v52;
    uint64_t v20 = OS_LOG_TYPE_INFO;
LABEL_19:
    _os_log_impl(&dword_181A5C000, v19, v20, v18, buf, 0x26u);
    return 0LL;
  }

  if ((handle[548] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v45 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v46 = *((_DWORD *)handle + 115);
      v47 = (void *)*((void *)handle + 4);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
      LOWORD(v108) = 1024;
      *(_DWORD *)((char *)&v108 + 2) = v46;
      HIWORD(v108) = 2048;
      v109 = v47;
      _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Got output handler from new_flow %p for CONNECT stream, sending async connect and a waiting input for session",  buf,  0x30u);
    }
  }

  *((_DWORD *)handle + 111) = 3;
  v48 = *((void *)handle + 54);
  v49 = (void *)*((void *)handle + 49);
  v90[0] = v10;
  v90[1] = 0x40000000LL;
  v90[2] = ___ZL57nw_protocol_webtransport_session_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke;
  v90[3] = &unk_189BBC7C0;
  v90[4] = v48;
  nw_queue_context_async(v49, v90);
  return 1LL;
}

      free(v85);
      if (!v75) {
        return;
      }
LABEL_205:
      free(v75);
      return;
    }

    v76 = (os_log_s *)__nwlog_obj();
    v77 = type[0];
    if (!os_log_type_enabled(v76, type[0])) {
      goto LABEL_204;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
    v78 = "%{public}s called with null webtransport_session";
    goto LABEL_203;
  }

  if ((handle[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v79 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
      {
        v80 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v152) = 1024;
        *(_DWORD *)((char *)&v152 + 2) = v80;
        _os_log_impl(&dword_181A5C000, v79, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
  }

  if (*((_DWORD *)handle + 112) > 1u) {
    return;
  }
  id v3 = *((void *)handle + 4);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
    v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v109[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v76 = (os_log_s *)__nwlog_obj();
      v77 = type[0];
      if (!os_log_type_enabled(v76, type[0])) {
        goto LABEL_204;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
      v78 = "%{public}s called with null output_handler";
      goto LABEL_203;
    }

    if (!LOBYTE(v109[0]))
    {
      v76 = (os_log_s *)__nwlog_obj();
      v77 = type[0];
      if (!os_log_type_enabled(v76, type[0])) {
        goto LABEL_204;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
      v78 = "%{public}s called with null output_handler, backtrace limit exceeded";
      goto LABEL_203;
    }

    v85 = (char *)__nw_create_backtrace_string();
    v76 = (os_log_s *)__nwlog_obj();
    v77 = type[0];
    v89 = os_log_type_enabled(v76, type[0]);
    if (!v85)
    {
      if (!v89) {
        goto LABEL_204;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
      v78 = "%{public}s called with null output_handler, no backtrace";
      goto LABEL_203;
    }

    if (v89)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v85;
      v87 = "%{public}s called with null output_handler, dumping backtrace:%{public}s";
      goto LABEL_182;
    }

    goto LABEL_183;
  }

  os_log_type_t v4 = *(void *)(v3 + 24);
  if (!v4 || !*(void *)(v4 + 80))
  {
    if ((handle[548] & 2) == 0)
    {
      v81 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
      {
        v82 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v152) = 1024;
        *(_DWORD *)((char *)&v152 + 2) = v82;
        _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback",  buf,  0x26u);
      }
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
    v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v109[0]) = 0;
    if (__nwlog_fault(v75, type, v109))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v76 = (os_log_s *)__nwlog_obj();
        v77 = type[0];
        if (!os_log_type_enabled(v76, type[0])) {
          goto LABEL_204;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
        v78 = "%{public}s output handler has no get_input_frames callback";
        goto LABEL_203;
      }

      if (!LOBYTE(v109[0]))
      {
        v76 = (os_log_s *)__nwlog_obj();
        v77 = type[0];
        if (!os_log_type_enabled(v76, type[0])) {
          goto LABEL_204;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
        v78 = "%{public}s output handler has no get_input_frames callback, backtrace limit exceeded";
        goto LABEL_203;
      }

      v85 = (char *)__nw_create_backtrace_string();
      v76 = (os_log_s *)__nwlog_obj();
      v77 = type[0];
      v88 = os_log_type_enabled(v76, type[0]);
      if (!v85)
      {
        if (!v88) {
          goto LABEL_204;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
        v78 = "%{public}s output handler has no get_input_frames callback, no backtrace";
        goto LABEL_203;
      }

      if (v88)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_webtransport_session_http_get_input";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v85;
        v87 = "%{public}s output handler has no get_input_frames callback, dumping backtrace:%{public}s";
        goto LABEL_182;
      }

      goto LABEL_183;
    }

    if (!v65) {
      goto LABEL_64;
    }
    os_log_type_t v45 = (char *)v65;
    goto LABEL_63;
  }

        free(v95);
        if (!v72) {
          goto LABEL_81;
        }
        goto LABEL_213;
      }

      __nwlog_obj();
      os_log_type_t v45 = *(unsigned int *)(v41 + 368);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = "http1->nonresuable_connections";
      *(_WORD *)&buf[22] = 2048;
      v109 = 1LL;
      *(_WORD *)v110 = 2048;
      *(void *)&v110[2] = v45;
      v46 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v107 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v46, type, &v107))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v47 = (os_log_s *)__nwlog_obj();
          v48 = type[0];
          if (os_log_type_enabled(v47, type[0]))
          {
            v49 = *(unsigned int *)(v41 + 368);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->nonresuable_connections";
            *(_WORD *)&buf[22] = 2048;
            v109 = 1LL;
            *(_WORD *)v110 = 2048;
            *(void *)&v110[2] = v49;
            os_log_type_t v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_94:
            _os_log_impl(&dword_181A5C000, v47, v48, v50, buf, 0x2Au);
          }
        }

        else if (v107)
        {
          os_log_type_t v59 = (char *)__nw_create_backtrace_string();
          v47 = (os_log_s *)__nwlog_obj();
          v48 = type[0];
          os_log_type_t v60 = os_log_type_enabled(v47, type[0]);
          if (v59)
          {
            if (v60)
            {
              v61 = *(unsigned int *)(v41 + 368);
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "http1->nonresuable_connections";
              *(_WORD *)&buf[22] = 2048;
              v109 = 1LL;
              *(_WORD *)v110 = 2048;
              *(void *)&v110[2] = v61;
              *(_WORD *)&v110[10] = 2082;
              v111 = v59;
              _os_log_impl( &dword_181A5C000,  v47,  v48,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v59);
            goto LABEL_95;
          }

          if (v60)
          {
            v71 = *(unsigned int *)(v41 + 368);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->nonresuable_connections";
            *(_WORD *)&buf[22] = 2048;
            v109 = 1LL;
            *(_WORD *)v110 = 2048;
            *(void *)&v110[2] = v71;
            os_log_type_t v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_94;
          }
        }

        else
        {
          v47 = (os_log_s *)__nwlog_obj();
          v48 = type[0];
          if (os_log_type_enabled(v47, type[0]))
          {
            v66 = *(unsigned int *)(v41 + 368);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->nonresuable_connections";
            *(_WORD *)&buf[22] = 2048;
            v109 = 1LL;
            *(_WORD *)v110 = 2048;
            *(void *)&v110[2] = v66;
            os_log_type_t v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_94;
          }
        }
      }

        if (v41) {
          free(v41);
        }
        *((void *)v85 + 3) = 0LL;
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
        v68 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(__src) = 16;
        v89 = OS_LOG_TYPE_DEFAULT;
        if (__src == 17)
        {
          v69 = (os_log_s *)__nwlog_obj();
          v70 = __src;
          if (!os_log_type_enabled(v69, (os_log_type_t)__src)) {
            goto LABEL_220;
          }
          *(_DWORD *)buf = 136446210;
          v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
          v71 = "%{public}s called with null cursor";
          goto LABEL_219;
        }

        if (v89 == OS_LOG_TYPE_DEFAULT)
        {
          v69 = (os_log_s *)__nwlog_obj();
          v70 = __src;
          if (!os_log_type_enabled(v69, (os_log_type_t)__src)) {
            goto LABEL_220;
          }
          *(_DWORD *)buf = 136446210;
          v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
          v71 = "%{public}s called with null cursor, backtrace limit exceeded";
          goto LABEL_219;
        }

        v72 = (char *)__nw_create_backtrace_string();
        v69 = (os_log_s *)__nwlog_obj();
        v70 = __src;
        v75 = os_log_type_enabled(v69, (os_log_type_t)__src);
        if (!v72)
        {
          if (!v75) {
            goto LABEL_220;
          }
          *(_DWORD *)buf = 136446210;
          v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
          v71 = "%{public}s called with null cursor, no backtrace";
          goto LABEL_219;
        }

        if (!v75)
        {
LABEL_193:
          free(v72);
          if (!v68) {
            goto LABEL_222;
          }
          goto LABEL_221;
        }

    _os_log_impl(&dword_181A5C000, v10, sae_srcif, v12, buf, 0xCu);
    goto LABEL_184;
  }

  p_output_handler = &a1[1].output_handler;
  id v5 = &a1[6].flow_id[13];
  id v6 = *(_WORD *)&a1[6].flow_id[13];
  if ((*(_WORD *)&a1[6].flow_id[13] & 1) != 0) {
    goto LABEL_68;
  }
  if (a1[3].identifier)
  {
    if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) != 0) {
      return 0LL;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v7 = (os_log_s *)gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_socket_setup_input_events";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = (char *)a1 + 404;
    BOOL v8 = "%{public}s %{public}s Already set up input event notification";
    goto LABEL_11;
  }

  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v146 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      v147 = *(_DWORD *)&a1[4].flow_id[12];
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_socket_setup_input_events";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = (char *)a1 + 404;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v170) = v147;
      _os_log_impl( &dword_181A5C000,  v146,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Setting up read events on %d",  buf,  0x1Cu);
    }
  }

  BOOL v16 = 0LL;
  v165 = 0LL;
  v166 = &v165;
  v167 = 0x2000000000LL;
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = a1[1].callbacks;
    BOOL v16 = a1;
    if (callbacks)
    {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      BOOL v16 = a1;
    }
  }

  v168 = v16;
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3802000000LL;
  *(void *)&v170 = __Block_byref_object_copy__64064;
  *((void *)&v170 + 1) = __Block_byref_object_dispose__64065;
  output_handler = a1[2].output_handler;
  if (output_handler) {
    output_handler = os_retain(output_handler);
  }
  *(void *)object = output_handler;
  object[8] |= 1u;
  uint64_t v19 = a1[3].output_handler;
  uint64_t v20 = *(_DWORD *)&a1[4].flow_id[12];
  char v21 = MEMORY[0x1895F87A8];
  v160 = MEMORY[0x1895F87A8];
  v161 = 0x40000000LL;
  v162 = ___ZL28nw_socket_setup_input_eventsP9nw_socket_block_invoke;
  v163 = &__block_descriptor_tmp_34_64953;
  v164 = &a1[1].output_handler;
  *(void *)&type.sae_srcif = MEMORY[0x1895F87A8];
  type.sae_srcaddr = (const sockaddr *)0x40000000;
  *(void *)&type.sae_srcaddrlen = ___ZL28nw_socket_setup_input_eventsP9nw_socket_block_invoke_2;
  type.sae_dstaddr = (const sockaddr *)&unk_189BC4E80;
  *(void *)&type.sae_dstaddrlen = buf;
  v159 = &v165;
  char v23 = nw_queue_context_create_source(v19, v20, 1, 0, &v160, &type);
  a1[3].identifier = (nw_protocol_identifier *)v23;
  if (v23)
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_18_64095);
    }
    int v24 = *(unsigned __int16 *)v5;
    uint64_t v25 = v24 & 0xFFFFFBFF | (a1[6].flow_id[15] << 16);
    *(_WORD *)id v5 = v24 & 0xFBFF;
    a1[6].flow_id[15] = BYTE2(v25);
    nw_queue_resume_source((uint64_t)a1[3].identifier->name, v22);
    goto LABEL_37;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)v179 = 136446210;
  v180 = "nw_socket_setup_input_events";
  uint64_t v27 = (char *)_os_log_send_and_compose_impl();
  v157 = OS_LOG_TYPE_ERROR;
  v156 = 0;
  if (__nwlog_fault(v27, &v157, &v156))
  {
    if (v157 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v29 = (os_log_s *)gLogObj;
      os_log_type_t v30 = v157;
      if (os_log_type_enabled((os_log_t)gLogObj, v157))
      {
        *(_DWORD *)v179 = 136446210;
        v180 = "nw_socket_setup_input_events";
        os_log_type_t v31 = "%{public}s nw_queue_context_create_source input_source failed";
LABEL_136:
        _os_log_impl(&dword_181A5C000, v29, v30, v31, v179, 0xCu);
      }
    }

    else if (v156)
    {
      BOOL v55 = (char *)__nw_create_backtrace_string();
      os_log_type_t v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = v157;
      v56 = os_log_type_enabled(v29, v157);
      if (v55)
      {
        if (v56)
        {
          *(_DWORD *)v179 = 136446466;
          v180 = "nw_socket_setup_input_events";
          v181 = 2082;
          v182 = v55;
          _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s nw_queue_context_create_source input_source failed, dumping backtrace:%{public}s",  v179,  0x16u);
        }

        free(v55);
        goto LABEL_137;
      }

      if (v56)
      {
        *(_DWORD *)v179 = 136446210;
        v180 = "nw_socket_setup_input_events";
        os_log_type_t v31 = "%{public}s nw_queue_context_create_source input_source failed, no backtrace";
        goto LABEL_136;
      }
    }

    else
    {
      os_log_type_t v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = v157;
      if (os_log_type_enabled(v29, v157))
      {
        *(_DWORD *)v179 = 136446210;
        v180 = "nw_socket_setup_input_events";
        os_log_type_t v31 = "%{public}s nw_queue_context_create_source input_source failed, backtrace limit exceeded";
        goto LABEL_136;
      }
    }
  }

        if (!v53)
        {
LABEL_24:

          goto LABEL_25;
        }

      uint32_t v9 = v293;
      if (v109) {
        free(v109);
      }
      goto LABEL_185;
    }

    __nwlog_obj();
    v235 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
    v236 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v236, type, &v298))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v237 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v238 = type[0];
        if (os_log_type_enabled(v237, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
          _os_log_impl(&dword_181A5C000, v237, v238, "%{public}s called with null input_protocol", buf, 0xCu);
        }
      }

      else
      {
        if (v298)
        {
          v254 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v255 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v256 = type[0];
          v257 = os_log_type_enabled(v255, type[0]);
          if (v254)
          {
            if (v257)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
              v300 = 2082;
              v301 = (uint64_t)v254;
              _os_log_impl( &dword_181A5C000,  v255,  v256,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v254);
          }

          else
          {
            if (v257)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
              _os_log_impl( &dword_181A5C000,  v255,  v256,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
            }
          }

          goto LABEL_389;
        }

        __nwlog_obj();
        v237 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v267 = type[0];
        if (os_log_type_enabled(v237, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
          _os_log_impl( &dword_181A5C000,  v237,  v267,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v47) {
    free(v47);
  }
  id v7 = 0LL;
LABEL_8:
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v12 = a1[1].callbacks;
    if (v12)
    {
      uint64_t v13 = (nw_protocol_callbacks *)((char *)v12 - 1);
      a1[1].callbacks = v13;
      if (!v13)
      {
        uint64_t v14 = *(void (***)(void))a1[1].flow_id;
        if (v14)
        {
          *(void *)a1[1].flow_id = 0LL;
          v14[2](v14);
          _Block_release(v14);
        }

        if ((a1[1].flow_id[8] & 1) != 0)
        {
          uint64_t v15 = *(const void **)a1[1].flow_id;
          if (v15) {
            _Block_release(v15);
          }
        }

        free(a1);
      }
    }
  }

  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_protocol_test_access_options";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (__nwlog_fault(v16, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v17 = (os_log_s *)__nwlog_obj();
        BOOL v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null parameters";
LABEL_57:
          _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
        }
      }

      else if (v90)
      {
        v74 = (char *)__nw_create_backtrace_string();
        uint64_t v17 = (os_log_s *)__nwlog_obj();
        BOOL v18 = type;
        v75 = os_log_type_enabled(v17, type);
        if (v74)
        {
          if (v75)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "nw_protocol_test_access_options";
            v94 = 2082;
            v95 = (nw_protocol_identifier *)v74;
            _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v74);
        }

        else if (v75)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_57;
        }
      }

      else
      {
        uint64_t v17 = (os_log_s *)__nwlog_obj();
        BOOL v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_57;
        }
      }
    }

      free(v77);
      if (!v64) {
        return;
      }
LABEL_232:
      v51 = (nw_protocol *)v64;
LABEL_111:
      free(v51);
      return;
    }

    v65 = (os_log_s *)__nwlog_obj();
    v66 = type;
    if (!os_log_type_enabled(v65, type)) {
      goto LABEL_231;
    }
    *(_DWORD *)buf = 136446210;
    v96 = "nw_protocol_test_output_finished";
    __int16 v67 = "%{public}s called with null test";
LABEL_230:
    _os_log_impl(&dword_181A5C000, v65, v66, v67, buf, 0xCu);
    goto LABEL_231;
  }

  if (gLogDatapath)
  {
    v68 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v96 = "nw_protocol_test_output_finished";
      v97 = 2082;
      v98 = a1 + 2;
      _os_log_impl(&dword_181A5C000, v68, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s output_finished", buf, 0x16u);
    }
  }

  v88[0] = MEMORY[0x1895F87A8];
  v88[1] = 0x40000000LL;
  v89 = ___ZL32nw_protocol_test_output_finishedP11nw_protocolS0__block_invoke;
  v90 = &__block_descriptor_tmp_41_83981;
  v91 = a1;
  v92 = a2;
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v96 = "nw_protocol_test_access_options";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (__nwlog_fault(v16, &type, &v93))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v17 = (os_log_s *)__nwlog_obj();
        BOOL v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v96 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null test";
LABEL_60:
          _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
        }
      }

      else if (v93)
      {
        v80 = (char *)__nw_create_backtrace_string();
        uint64_t v17 = (os_log_s *)__nwlog_obj();
        BOOL v18 = type;
        v81 = os_log_type_enabled(v17, type);
        if (v80)
        {
          if (v81)
          {
            *(_DWORD *)buf = 136446466;
            v96 = "nw_protocol_test_access_options";
            v97 = 2082;
            v98 = (nw_protocol *)v80;
            _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null test, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v80);
        }

        else if (v81)
        {
          *(_DWORD *)buf = 136446210;
          v96 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null test, no backtrace";
          goto LABEL_60;
        }
      }

      else
      {
        uint64_t v17 = (os_log_s *)__nwlog_obj();
        BOOL v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v96 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null test, backtrace limit exceeded";
          goto LABEL_60;
        }
      }
    }

LABEL_202:
    if (v115) {
      free(v115);
    }
    BOOL v18 = 0LL;
    goto LABEL_29;
  }

  uint64_t v17 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_path_parameters);
  BOOL v18 = v17;
  if (v17)
  {
    uint64_t v19 = *(_OWORD *)(v16 + 8);
    uint64_t v20 = *(_OWORD *)(v16 + 24);
    char v21 = *(_OWORD *)(v16 + 40);
    *(_OWORD *)&v17->process_path_value.delegated_upid = *(_OWORD *)(v16 + 56);
    *(_OWORD *)v17->process_path_value.persona_id = v21;
    *(_OWORD *)v17->process_path_value.e_proc_uuid = v20;
    *(_OWORD *)v17->process_path_value.proc_uuid = v19;
    os_log_type_t v22 = *(_OWORD *)(v16 + 72);
    *(_OWORD *)((char *)&v17->path_value.companion_preference + 2) = *(_OWORD *)(v16 + 86);
    *(_OWORD *)&v17->path_value.traffic_class = v22;
    char v23 = *(void *)(v16 + 102);
    BYTE2(v17->joinable_path_value.multipath_service) = v16[110];
    *(void *)((char *)&v17->path_value + 30) = v23;
    int v24 = (const char *)*((void *)v16 + 14);
    if (v24)
    {
      uint64_t v25 = strdup(v24);
      if (!v25)
      {
        __nwlog_obj();
        v128 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v128, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v155 = "strict_strdup";
        v129 = (void *)_os_log_send_and_compose_impl();

        uint64_t result = __nwlog_abort((uint64_t)v129);
        if (result) {
          goto LABEL_210;
        }
        free(v129);
      }

      *(void *)&v18->joinable_path_value.fallback_mode = v25;
    }

    id v26 = (const char *)*((void *)v16 + 15);
    if (v26)
    {
      uint64_t v27 = strdup(v26);
      if (!v27)
      {
        __nwlog_obj();
        v130 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v130, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v155 = "strict_strdup";
        v131 = (void *)_os_log_send_and_compose_impl();

        uint64_t result = __nwlog_abort((uint64_t)v131);
        if (result) {
          goto LABEL_210;
        }
        free(v131);
      }

      v18->account_id = v27;
    }

    BOOL v28 = (const char *)*((void *)v16 + 16);
    if (v28)
    {
      os_log_type_t v29 = strdup(v28);
      if (!v29)
      {
        __nwlog_obj();
        v132 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v132, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v155 = "strict_strdup";
        v133 = (void *)_os_log_send_and_compose_impl();

        uint64_t result = __nwlog_abort((uint64_t)v133);
        if (result) {
          goto LABEL_210;
        }
        free(v133);
      }

      v18->attribution_context = v29;
    }

    objc_storeStrong((id *)&v18->attributed_bundle, *((id *)v16 + 17));
    os_log_type_t v30 = (void *)*((void *)v16 + 18);
    if (v30)
    {
      os_log_type_t v31 = nw_protocol_options_copy(v30);
      context = v18->context;
      v18->context = (OS_nw_context *)v31;
    }

    id v33 = (void *)*((void *)v16 + 19);
    if (v33)
    {
      id v34 = nw_protocol_options_copy(v33);
      transport_options = v18->transport_options;
      v18->transport_options = (OS_nw_protocol_options *)v34;
    }

    objc_storeStrong((id *)&v18->internet_options, *((id *)v16 + 20));
    objc_storeStrong((id *)&v18->local_address, *((id *)v16 + 21));
    if (*((void *)v16 + 22))
    {
      __int16 v36 = (id *)calloc(1uLL, 0x90uLL);
      if (!v36)
      {
        __nwlog_obj();
        v134 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v134, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        v155 = "strict_calloc";
        v156 = 2048;
        v157 = 1LL;
        v158 = 2048;
        v159 = 144LL;
        v135 = (void *)_os_log_send_and_compose_impl();

        uint64_t result = __nwlog_abort((uint64_t)v135);
        if (result) {
          goto LABEL_210;
        }
        free(v135);
      }

      v18->required_interface = (OS_nw_interface *)v36;
      objc_storeStrong(v36, **((id **)v16 + 22));
      objc_storeStrong((id *)v18->required_interface + 1, *(id *)(*((void *)v16 + 22) + 8LL));
      objc_storeStrong((id *)v18->required_interface + 2, *(id *)(*((void *)v16 + 22) + 16LL));
      objc_storeStrong((id *)v18->required_interface + 3, *(id *)(*((void *)v16 + 22) + 24LL));
      objc_storeStrong((id *)v18->required_interface + 4, *(id *)(*((void *)v16 + 22) + 32LL));
      objc_storeStrong((id *)v18->required_interface + 5, *(id *)(*((void *)v16 + 22) + 40LL));
      objc_storeStrong((id *)v18->required_interface + 6, *(id *)(*((void *)v16 + 22) + 48LL));
      if ((a3 & 1) == 0)
      {
        objc_storeStrong((id *)v18->required_interface + 7, *(id *)(*((void *)v16 + 22) + 56LL));
        objc_storeStrong((id *)v18->required_interface + 8, *(id *)(*((void *)v16 + 22) + 64LL));
        objc_storeStrong((id *)v18->required_interface + 9, *(id *)(*((void *)v16 + 22) + 72LL));
        objc_storeStrong((id *)v18->required_interface + 10, *(id *)(*((void *)v16 + 22) + 80LL));
        objc_storeStrong((id *)v18->required_interface + 11, *(id *)(*((void *)v16 + 22) + 88LL));
        objc_storeStrong((id *)v18->required_interface + 12, *(id *)(*((void *)v16 + 22) + 96LL));
        objc_storeStrong((id *)v18->required_interface + 13, *(id *)(*((void *)v16 + 22) + 104LL));
        objc_storeStrong((id *)v18->required_interface + 14, *(id *)(*((void *)v16 + 22) + 112LL));
        objc_storeStrong((id *)v18->required_interface + 15, *(id *)(*((void *)v16 + 22) + 120LL));
      }

      uint64_t v37 = *(void **)(*((void *)v16 + 22) + 128LL);
      if (v37)
      {
        __int16 v38 = nw_protocol_options_copy(v37);
        required_interface = v18->required_interface;
        __int16 v40 = (void *)*((void *)required_interface + 16);
        *((void *)required_interface + 16) = v38;

        objc_storeStrong((id *)v18->required_interface + 17, *(id *)(*((void *)v16 + 22) + 136LL));
      }
    }

    uint64_t v41 = v18;
    goto LABEL_28;
  }

  __nwlog_obj();
  v121 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v155 = "nw_path_parameters_copy";
  v122 = (char *)_os_log_send_and_compose_impl();

  v153 = OS_LOG_TYPE_ERROR;
  v152 = 0;
  if (__nwlog_fault(v122, &v153, &v152))
  {
    if (v153 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v124 = v153;
      if (os_log_type_enabled(v123, v153))
      {
        *(_DWORD *)buf = 136446210;
        v155 = "nw_path_parameters_copy";
        _os_log_impl(&dword_181A5C000, v123, v124, "%{public}s called with null copy", buf, 0xCu);
      }
    }

    else if (v152)
    {
      v139 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v140 = v153;
      v141 = os_log_type_enabled(v123, v153);
      if (v139)
      {
        if (v141)
        {
          *(_DWORD *)buf = 136446466;
          v155 = "nw_path_parameters_copy";
          v156 = 2082;
          v157 = (uint64_t)v139;
          _os_log_impl( &dword_181A5C000,  v123,  v140,  "%{public}s called with null copy, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v139);
        goto LABEL_208;
      }

      if (v141)
      {
        *(_DWORD *)buf = 136446210;
        v155 = "nw_path_parameters_copy";
        _os_log_impl(&dword_181A5C000, v123, v140, "%{public}s called with null copy, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v123 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v146 = v153;
      if (os_log_type_enabled(v123, v153))
      {
        *(_DWORD *)buf = 136446210;
        v155 = "nw_path_parameters_copy";
        _os_log_impl( &dword_181A5C000,  v123,  v146,  "%{public}s called with null copy, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v154) {
    free(v154);
  }
LABEL_189:
}

  if (v81) {
    free(v81);
  }
  v46 = 0LL;
LABEL_177:

  return v46;
}

            if (v43) {
              free(v43);
            }
            __nwlog_obj();
            v103 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
            v104 = (char *)_os_log_send_and_compose_impl();

            type[0] = 16;
            LOBYTE(v279) = 0;
            if (__nwlog_fault(v104, type, &v279))
            {
              if (type[0] == 17)
              {
                __nwlog_obj();
                v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v106 = type[0];
                if (os_log_type_enabled(v105, (os_log_type_t)type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_set_output_handler";
                  _os_log_impl(&dword_181A5C000, v105, v106, "%{public}s called with null protocol", buf, 0xCu);
                }

    goto LABEL_85;
  }

  __nwlog_obj();
  os_log_type_t v52 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v135 = "nw_protocol_implementation_connected";
  v53 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v129[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v53, type, v129))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v55 = type[0];
      if (os_log_type_enabled(v54, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v135 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v129[0])
    {
      v69 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v70 = type[0];
      v71 = os_log_type_enabled(v54, type[0]);
      if (v69)
      {
        if (v71)
        {
          *(_DWORD *)buf = 136446466;
          v135 = "nw_protocol_implementation_connected";
          v136 = 2082;
          v137 = v69;
          _os_log_impl( &dword_181A5C000,  v54,  v70,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v69);
        goto LABEL_192;
      }

      if (v71)
      {
        *(_DWORD *)buf = 136446210;
        v135 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_181A5C000, v54, v70, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v96 = type[0];
      if (os_log_type_enabled(v54, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v135 = "nw_protocol_implementation_connected";
        _os_log_impl( &dword_181A5C000,  v54,  v96,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

                goto LABEL_203;
              }

              if (!v95)
              {
                __nwlog_obj();
                v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v93 = v96;
                if (os_log_type_enabled(v86, v96))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
                  _os_log_impl( &dword_181A5C000,  v86,  v93,  "%{public}s called with null type, backtrace limit exceeded",  buf,  0xCu);
                }

                goto LABEL_202;
              }

              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v91 = v96;
              v92 = os_log_type_enabled(v86, v96);
              if (!backtrace_string)
              {
                if (v92)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
                  _os_log_impl(&dword_181A5C000, v86, v91, "%{public}s called with null type, no backtrace", buf, 0xCu);
                }

                goto LABEL_202;
              }

              if (v92)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
                v100 = 2082;
                v101 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v86,  v91,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
            }

        if (v85) {
          free(v85);
        }
        os_log_type_t v50 = 0LL;
        goto LABEL_62;
      }

      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v83 = type[0];
        if (os_log_type_enabled(v82, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_storage";
          _os_log_impl(&dword_181A5C000, v82, v83, "%{public}s protocol options are not http_authentication", buf, 0xCu);
        }
      }

      else if (v117)
      {
        v96 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v106 = type[0];
        v97 = os_log_type_enabled(v82, type[0]);
        if (v96)
        {
          if (v97)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_storage";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v96;
            _os_log_impl( &dword_181A5C000,  v82,  v106,  "%{public}s protocol options are not http_authentication, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v96);
          goto LABEL_195;
        }

        if (v97)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_storage";
          _os_log_impl( &dword_181A5C000,  v82,  v106,  "%{public}s protocol options are not http_authentication, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v103 = type[0];
        if (os_log_type_enabled(v82, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_credential_storage";
          _os_log_impl( &dword_181A5C000,  v82,  v103,  "%{public}s protocol options are not http_authentication, backtrace limit exceeded",  buf,  0xCu);
        }
      }

LABEL_195:
      v81 = (char *)v109;
      goto LABEL_196;
    }

    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v79 = type[0];
      if (os_log_type_enabled(v78, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_challenge_queue";
        _os_log_impl(&dword_181A5C000, v78, v79, "%{public}s protocol options are not http authentication", buf, 0xCu);
      }
    }

    else if (v117)
    {
      v94 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v105 = type[0];
      v95 = os_log_type_enabled(v78, type[0]);
      if (v94)
      {
        if (v95)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_challenge_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v94;
          _os_log_impl( &dword_181A5C000,  v78,  v105,  "%{public}s protocol options are not http authentication, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v94);
        goto LABEL_188;
      }

      if (v95)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_challenge_queue";
        _os_log_impl( &dword_181A5C000,  v78,  v105,  "%{public}s protocol options are not http authentication, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v102 = type[0];
      if (os_log_type_enabled(v78, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_authentication_options_copy_challenge_queue";
        _os_log_impl( &dword_181A5C000,  v78,  v102,  "%{public}s protocol options are not http authentication, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_188:
    v77 = (char *)v108;
    goto LABEL_189;
  }

          if (!uuid_is_null((const unsigned __int8 *)(v36 + 272)))
          {
            v92 = *(void **)(v36 + 456);
            if (v92) {
              nw_http_connection_metadata_set_cached_token(v92, 0LL, 0LL);
            }
            if (*((_BYTE *)v185 + 24)) {
              v93 = 1001;
            }
            else {
              v93 = 0;
            }
            nw_path_report_error_to_agent(*(void **)(v36 + 336), (const unsigned __int8 *)(v36 + 272), v93);
          }

          goto LABEL_209;
        }

        v87 = *(void **)(v36 + 328);
        if (v87)
        {
          if (v86 - 0x10000 < 0xFFFF0001 || !*(_WORD *)(v36 + 524)) {
            goto LABEL_201;
          }
          else {
            v88 = 0LL;
          }
          globals_for_protocol = (unsigned __int16 *)nw_context_get_globals_for_protocol(v87, v88);
          if (globals_for_protocol)
          {
            if (*globals_for_protocol && v86 > *globals_for_protocol && v86 > globals_for_protocol[1])
            {
              globals_for_protocol[1] = v86;
              if ((v76[2] & 1) == 0)
              {
                if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
                  dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
                }
                v91 = (os_log_s *)gprivacy_proxyLogObj;
                if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)v192 = 136446722;
                  *(void *)&v192[4] = v36 + 531;
                  *(_WORD *)&v192[12] = 2080;
                  *(void *)&v192[14] = " ";
                  *(_WORD *)&v192[22] = 1024;
                  *(_DWORD *)v193 = v86;
                  _os_log_impl( &dword_181A5C000,  v91,  OS_LOG_TYPE_INFO,  "%{public}s%sReporting new epoch value: %u",  v192,  0x1Cu);
                }
              }

              nw_masque_report_error_to_proxy_agent(v36, v86 | 0xFF0000);
            }

            goto LABEL_201;
          }

          __nwlog_obj();
          *(_DWORD *)v192 = 136446210;
          *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
          v126 = (char *)_os_log_send_and_compose_impl();
          v154[0] = OS_LOG_TYPE_ERROR;
          v191 = 0;
          if (v154[0] == OS_LOG_TYPE_FAULT)
          {
            v127 = (os_log_s *)__nwlog_obj();
            v128 = v154[0];
            if (!os_log_type_enabled(v127, v154[0])) {
              goto LABEL_397;
            }
            *(_DWORD *)v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
            v129 = "%{public}s called with null globals";
            goto LABEL_395;
          }

          if (!v191)
          {
            v127 = (os_log_s *)__nwlog_obj();
            v128 = v154[0];
            if (!os_log_type_enabled(v127, v154[0])) {
              goto LABEL_397;
            }
            *(_DWORD *)v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
            v129 = "%{public}s called with null globals, backtrace limit exceeded";
            goto LABEL_395;
          }

          v140 = (char *)__nw_create_backtrace_string();
          v146 = (os_log_s *)__nwlog_obj();
          v128 = v154[0];
          loga = v146;
          v147 = os_log_type_enabled(v146, v154[0]);
          if (v140)
          {
            if (v147)
            {
              *(_DWORD *)v192 = 136446466;
              *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
              *(_WORD *)&v192[12] = 2082;
              *(void *)&v192[14] = v140;
              v143 = "%{public}s called with null globals, dumping backtrace:%{public}s";
              goto LABEL_373;
            }

            goto LABEL_374;
          }

          if (!v147)
          {
LABEL_397:
            if (v126) {
              free(v126);
            }
            v76 = (_BYTE *)(v36 + 527);
            if ((*(_BYTE *)(v36 + 527) & 2) == 0) {
              goto LABEL_209;
            }
            goto LABEL_202;
          }

          *(_DWORD *)v192 = 136446210;
          *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
          v129 = "%{public}s called with null globals, no backtrace";
        }

        else
        {
          __nwlog_obj();
          *(_DWORD *)v192 = 136446210;
          *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
          v126 = (char *)_os_log_send_and_compose_impl();
          v154[0] = OS_LOG_TYPE_ERROR;
          v191 = 0;
          if (v154[0] == OS_LOG_TYPE_FAULT)
          {
            v127 = (os_log_s *)__nwlog_obj();
            v128 = v154[0];
            if (!os_log_type_enabled(v127, v154[0])) {
              goto LABEL_397;
            }
            *(_DWORD *)v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
            v129 = "%{public}s called with null masque->context";
LABEL_395:
            v149 = v127;
LABEL_396:
            _os_log_impl(&dword_181A5C000, v149, v128, v129, v192, 0xCu);
            goto LABEL_397;
          }

          if (!v191)
          {
            v127 = (os_log_s *)__nwlog_obj();
            v128 = v154[0];
            if (!os_log_type_enabled(v127, v154[0])) {
              goto LABEL_397;
            }
            *(_DWORD *)v192 = 136446210;
            *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
            v129 = "%{public}s called with null masque->context, backtrace limit exceeded";
            goto LABEL_395;
          }

          v140 = (char *)__nw_create_backtrace_string();
          v141 = (os_log_s *)__nwlog_obj();
          v128 = v154[0];
          loga = v141;
          v142 = os_log_type_enabled(v141, v154[0]);
          if (v140)
          {
            if (v142)
            {
              *(_DWORD *)v192 = 136446466;
              *(void *)&v192[4] = "nw_masque_handle_received_epoch_value";
              *(_WORD *)&v192[12] = 2082;
              *(void *)&v192[14] = v140;
              v143 = "%{public}s called with null masque->context, dumping backtrace:%{public}s";
LABEL_373:
              _os_log_impl(&dword_181A5C000, loga, v128, v143, v192, 0x16u);
            }

        free((void *)v111);
        goto LABEL_203;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
      v111 = _os_log_send_and_compose_impl();
      v186 = OS_LOG_TYPE_ERROR;
      v185 = 0;
      if (v186 == OS_LOG_TYPE_FAULT)
      {
        v126 = (os_log_s *)__nwlog_obj();
        v127 = v186;
        if (os_log_type_enabled(v126, v186))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_webtransport_stream_destroy";
          v128 = v126;
          v129 = v127;
          v130 = "%{public}s called with null webtransport_stream";
          goto LABEL_218;
        }

            memmove((void *)(v77 + v98), (const void *)(v77 + 10), __len[0]);
            v99 = 8 - v97;
LABEL_203:
            if (v77)
            {
              v125 = v77 + v98 + __len[0];
              *(_WORD *)v125 = 2573;
              if (!v79) {
                goto LABEL_212;
              }
              *(_BYTE *)(v125 + 6) = 10;
              *(_DWORD *)(v125 + 2) = 218762544;
LABEL_206:
              v126 = v79 ^ 1;
              if ((*v340 & 0x8000) == 0) {
                v126 = 1;
              }
              if ((v126 & 1) == 0)
              {
                if ((*(_BYTE *)(v9 + 158) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    v214 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v214, OS_LOG_TYPE_DEBUG))
                    {
                      v215 = *(void *)(v9 + 488);
                      if (v215) {
                        LODWORD(v215) = *(_DWORD *)(v215 + 424);
                      }
                      uint32_t v9 = v348;
                      v216 = *(_DWORD *)(*(void *)(v348 + 480) + 372LL);
                      v217 = *(_DWORD *)(v348 + 860);
                      *(_DWORD *)buf = 136447746;
                      v364 = "nw_http1_connection_drain_outbound_frames";
                      v365 = 2082;
                      *(void *)v366 = v347;
                      *(_WORD *)&v366[8] = 2080;
                      *(void *)&v366[10] = " ";
                      v367 = 1024;
                      *(_DWORD *)v368 = v216;
                      *(_WORD *)&v368[4] = 1024;
                      *(_DWORD *)&v368[6] = v217;
                      LOWORD(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 2) = v215;
                      HIWORD(v369) = 2048;
                      *(void *)v370 = v89;
                      _os_log_impl( &dword_181A5C000,  v214,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> pending final chunk written to frame %p",  buf,  0x3Cu);
                    }
                  }
                }

                v127 = *v340;
                v128 = v127 & 0xFFFF7FFF | (*((unsigned __int8 *)v340 + 2) << 16);
                *v340 = v127 & 0x7FFF;
                *((_BYTE *)v340 + 2) = BYTE2(v128);
              }

    goto LABEL_203;
  }

  id v6 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_stack);
  if (v5 >> 3 == 2)
  {
    id v7 = nw_array_get_object_at_index((uint64_t)v2, 0LL);
    BOOL v8 = nw_array_get_object_at_index((uint64_t)v2, 1uLL);
    if (nw_protocol_options_is_masque(*(void **)(v7 + 40)))
    {
      is_masque = nw_protocol_options_is_masque(*(void **)(v8 + 40));
      uint64_t v11 = *(void **)(v8 + 40);
      if (is_masque)
      {
        v91 = v8;
        v96 = nw_protocol_options_copy(v11);
        nw_protocol_options_set_proxy_endpoint(v96, *(void **)(v8 + 24), 1);
        uint64_t v12 = nw_protocol_options_copy(*(void **)(v7 + 40));
        nw_protocol_options_set_proxy_endpoint(v12, *(void **)(v7 + 24), 0);
        nw_masque_options_set_forced_protocol(v12, 2);
        nw_masque_options_set_target_endpoint(v12, *(void *)(v8 + 24));
        v94 = v12;
        if (nw_protocol_copy_http3_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_10_72547);
        }
        options = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
        uint64_t v14 = options;
        if ((*(_BYTE *)(v8 + 80) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(options, 1LL);
          nw_http3_set_idle_timeout(v14, 30LL);
          nw_http3_set_keepalive_mode(v14, 2LL);
        }

        else
        {
          nw_http3_set_idle_timeout(options, 900LL);
          nw_http3_set_keepalive_mode(v14, 1LL);
        }

        if (nw_protocol_copy_http3_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_10_72547);
        }
        os_log_type_t v31 = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
        protocol = v31;
        if ((*(_BYTE *)(v7 + 80) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(v31, 1LL);
          nw_http3_set_idle_timeout(protocol, 30LL);
          nw_http3_set_keepalive_mode(protocol, 2LL);
        }

        else
        {
          nw_http3_set_idle_timeout(v31, 60LL);
          nw_http3_set_keepalive_mode(protocol, 1LL);
        }

        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
        }
        char v32 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
        v92 = v32;
        id v33 = nw_quic_stream_copy_shared_connection_options(v32);
        id v34 = v33;
        os_log_type_t v35 = *(_BYTE *)(v8 + 80);
        if ((v35 & 4) != 0)
        {
          nw_quic_connection_set_enable_l4s(v33, 1);
          os_log_type_t v35 = *(_BYTE *)(v8 + 80);
        }

        if ((v35 & 8) != 0) {
          nw_quic_connection_set_enable_multipath(v34, 1);
        }
        nw_quic_connection_set_idle_timeout(v34, 0);
        nw_quic_connection_set_max_datagram_frame_size(v34, 0xFFFF);
        nw_quic_connection_set_max_udp_payload_size(v34, 1472);
        nw_quic_connection_set_datagram_variant_flow_id_enabled(v34, 1);
        if (nw_masque_options_get_version(v96) == 2)
        {
          nw_quic_connection_set_datagram_quarter_stream_id(v34, 1);
          nw_quic_connection_set_datagram_context_id(v34, 1);
        }

        nw_quic_connection_set_source_connection_id_length(v34, 8);
        nw_quic_connection_set_initial_packet_size(v34, 1304);
        __int16 v36 = *(void **)(v8 + 48);
        if (v36)
        {
          uint64_t v37 = v36;
          nw_quic_connection_set_sec_protocol_options(v34, v37);

          char v32 = v92;
        }

        __int16 v38 = *(void *)(v8 + 56);
        if (v38) {
          nw_quic_connection_set_server_raw_public_keys(v34, v38);
        }
        __int16 v39 = *(void *)(v8 + 64);
        if (v39) {
          nw_quic_connection_set_client_identity_reference(v34, v39, *(void *)(v8 + 72));
        }
        if ((*(_BYTE *)(v8 + 80) & 0x10) != 0) {
          nw_quic_connection_set_override_trust_certs_for_tests(v34, 1);
        }
        if ((*(_BYTE *)(v8 + 81) & 4) != 0) {
          nw_quic_connection_set_client_identity_is_raw_public_Key(v34, 1);
        }
        nw_quic_connection_add_h3_alpn(v34, 1);
        nw_quic_connection_set_keepalive_count(v34, 3);
        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
        }
        v90 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
        __int16 v40 = nw_quic_stream_copy_shared_connection_options(v90);
        uint64_t v41 = v40;
        uint64_t v42 = *(_BYTE *)(v7 + 80);
        if ((v42 & 4) != 0)
        {
          nw_quic_connection_set_enable_l4s(v40, 1);
          uint64_t v42 = *(_BYTE *)(v7 + 80);
        }

        if ((v42 & 8) != 0) {
          nw_quic_connection_set_enable_multipath(v41, 1);
        }
        nw_quic_connection_set_idle_timeout(v41, 0);
        nw_quic_connection_set_max_datagram_frame_size(v41, 0xFFFF);
        nw_quic_connection_set_max_udp_payload_size(v41, 1472);
        nw_quic_connection_set_datagram_variant_flow_id_enabled(v41, 1);
        if (nw_masque_options_get_version(v94) == 2)
        {
          nw_quic_connection_set_datagram_quarter_stream_id(v41, 1);
          nw_quic_connection_set_datagram_context_id(v41, 1);
        }

        nw_quic_connection_set_source_connection_id_length(v41, 8);
        nw_quic_connection_set_initial_packet_size(v41, 1350);
        nw_quic_connection_set_pmtud_for_non_transport(v41, 1);
        nw_quic_connection_set_migration_for_non_transport(v41, 1);
        BOOL v43 = *(void **)(v7 + 48);
        if (v43)
        {
          os_log_type_t v44 = v43;
          nw_quic_connection_set_sec_protocol_options(v41, v44);

          char v32 = v92;
        }

        os_log_type_t v45 = *(void *)(v7 + 56);
        if (v45) {
          nw_quic_connection_set_server_raw_public_keys(v41, v45);
        }
        v46 = *(void *)(v7 + 64);
        if (v46) {
          nw_quic_connection_set_client_identity_reference(v41, v46, *(void *)(v7 + 72));
        }
        if ((*(_BYTE *)(v7 + 80) & 0x10) != 0) {
          nw_quic_connection_set_override_trust_certs_for_tests(v41, 1);
        }
        if ((*(_BYTE *)(v7 + 81) & 4) != 0) {
          nw_quic_connection_set_client_identity_is_raw_public_Key(v41, 1);
        }
        nw_quic_connection_add_h3_alpn(v41, 1);
        nw_quic_connection_set_keepalive_count(v41, 3);
        if (nw_protocol_demux_copy_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
        }
        if (nw_protocol_demux_copy_definition::definition)
        {
          v47 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
          v89 = nw_protocol_create_options(v47);
          if (v47) {
            os_release(v47);
          }
          char v32 = v92;
        }

        else
        {
          v89 = nw_protocol_create_options(0LL);
        }

        v56 = nw_protocol_create_options((void *)g_udp_definition);
        nw_udp_options_set_use_quic_stats(v56, 1);
        nw_udp_options_set_no_metadata(v56, 1);
        nw_protocol_stack_append_application_protocol(v6, v96);
        nw_protocol_stack_append_application_protocol(v6, v14);
        nw_protocol_stack_append_application_protocol(v6, v32);
        nw_protocol_stack_append_application_protocol(v6, v94);
        nw_protocol_stack_append_application_protocol(v6, protocol);
        nw_protocol_stack_append_application_protocol(v6, v90);
        nw_protocol_stack_append_application_protocol(v6, v89);
        nw_protocol_stack_set_transport_protocol((nw_protocol_stack_t)v6, (nw_protocol_options_t)v56);
        os_log_type_t v57 = nw_protocol_options_copy_proxy_endpoint_for_stack(v94);
        uint64_t v19 = nw_proxy_config_create_with_stack(v57, v6);

        BOOL v58 = (id)g_udp_definition;
        nw_proxy_config_set_alternate_protocol_stack(v19, 0LL, v58, 4u);

        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
        }
        os_log_type_t v59 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
        nw_proxy_config_set_alternate_protocol_stack(v19, 0LL, v59, 3u);

        os_log_type_t v60 = *(_BYTE *)(v91 + 80);
        if ((v60 & 1) != 0)
        {
          nw_proxy_config_set_alternate_protocol_stack(v19, 0LL, 0LL, 2u);
          os_log_type_t v60 = *(_BYTE *)(v91 + 80);
        }

        if ((v60 & 0x40) != 0)
        {
          v61 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_stack);
          id v62 = nw_masque_options_copy_listener_options(v96);
          nw_protocol_stack_append_application_protocol(v61, v62);

          nw_protocol_stack_append_application_protocol(v61, v14);
          nw_protocol_stack_append_application_protocol(v61, v92);
          nw_protocol_stack_append_application_protocol(v61, v94);
          nw_protocol_stack_append_application_protocol(v61, protocol);
          nw_protocol_stack_append_application_protocol(v61, v90);
          nw_protocol_stack_append_application_protocol(v61, v89);
          nw_protocol_stack_set_transport_protocol((nw_protocol_stack_t)v61, (nw_protocol_options_t)v56);
          char v63 = (id)g_udp_definition;
          nw_proxy_config_set_listener_protocol_stack(v19, v61, v63, 4u);

          char v32 = v92;
        }

        nw_proxy_config_set_is_privacy_proxy(v19, 1, 0);
        nw_proxy_config_set_multipath_service(v19, 1);

        BOOL v8 = v91;
        uint64_t v20 = v94;
LABEL_166:

LABEL_167:
        nw_proxy_config_set_type(v19, 3006);
        goto LABEL_168;
      }

      if (nw_protocol_options_is_oblivious_http(v11))
      {
        v96 = nw_protocol_options_copy(*(void **)(v7 + 40));
        nw_protocol_options_set_proxy_endpoint(v96, *(void **)(v7 + 24), 0);
        uint64_t v20 = nw_protocol_options_copy(*(void **)(v8 + 40));
        if (nw_protocol_copy_http3_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_10_72547);
        }
        char v21 = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
        uint64_t v14 = v21;
        if ((*(_BYTE *)(v7 + 80) & 2) != 0)
        {
          nw_http3_set_0rtt_enabled(v21, 1LL);
          nw_http3_set_idle_timeout(v14, 30LL);
          nw_http3_set_keepalive_mode(v14, 2LL);
        }

        else
        {
          nw_http3_set_idle_timeout(v21, 60LL);
          nw_http3_set_keepalive_mode(v14, 1LL);
        }

        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
        }
        protocol = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
        v64 = (NWConcrete_nw_protocol_options *)nw_quic_stream_copy_shared_connection_options(protocol);
        v65 = v64;
        v66 = *(_BYTE *)(v7 + 80);
        v93 = v64;
        if ((v66 & 4) != 0)
        {
          nw_quic_connection_set_enable_l4s(v64, 1);
          v66 = *(_BYTE *)(v7 + 80);
        }

        if ((v66 & 8) != 0) {
          nw_quic_connection_set_enable_multipath(v65, 1);
        }
        nw_quic_connection_set_idle_timeout(v65, 0);
        nw_quic_connection_set_max_datagram_frame_size(v65, 0xFFFF);
        nw_quic_connection_set_datagram_variant_flow_id_enabled(v65, 1);
        if (nw_masque_options_get_version(v96) == 2)
        {
          nw_quic_connection_set_datagram_quarter_stream_id(v65, 1);
          nw_quic_connection_set_datagram_context_id(v65, 1);
        }

        nw_quic_connection_set_source_connection_id_length(v65, 8);
        nw_quic_connection_set_initial_packet_size(v65, 1350);
        __int16 v67 = *(void **)(v7 + 48);
        if (v67)
        {
          v68 = v67;
          nw_quic_connection_set_sec_protocol_options(v65, v68);
        }

        v69 = *(void *)(v7 + 56);
        if (v69)
        {
          nw_quic_connection_set_server_raw_public_keys(v65, v69);
        }

        else
        {
          v70 = *(void *)(v7 + 64);
          if (v70)
          {
            nw_quic_connection_set_client_identity_reference(v65, v70, *(void *)(v7 + 72));
          }

          else if ((*(_BYTE *)(v7 + 80) & 0x10) != 0)
          {
            nw_quic_connection_set_override_trust_certs_for_tests(v65, 1);
          }
        }

        if ((*(_BYTE *)(v7 + 81) & 4) != 0) {
          nw_quic_connection_set_client_identity_is_raw_public_Key(v65, 1);
        }
        nw_quic_connection_add_h3_alpn(v65, 1);
        nw_quic_connection_set_keepalive_count(v65, 3);
        nw_protocol_stack_append_application_protocol(v6, v20);
        nw_protocol_stack_append_application_protocol(v6, v96);
        nw_protocol_stack_append_application_protocol(v6, v14);
        nw_protocol_stack_set_transport_protocol((nw_protocol_stack_t)v6, (nw_protocol_options_t)protocol);
        v71 = nw_protocol_options_copy_proxy_endpoint_for_stack(v96);
        uint64_t v19 = nw_proxy_config_create_with_stack(v71, v6);

        nw_proxy_config_set_is_privacy_proxy(v19, 1, 0);
        if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72514);
        }
        v72 = (id)nw_protocol_copy_http_messaging_definition_definition;
        nw_proxy_config_add_required_protocol(v19, v72);

        if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72514);
        }
        v73 = (id)nw_protocol_copy_http_messaging_definition_definition;
        nw_proxy_config_add_protocol_to_remove(v19, v73);

        char v32 = v93;
        id v34 = (void *)nw_protocol_boringssl_copy_definition();
        nw_proxy_config_add_protocol_to_remove(v19, v34);
        goto LABEL_166;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v100 = "nw_proxy_config_create_privacy_proxy_internal";
        BOOL v18 = "%{public}s Second hop must be MASQUE or OHTTP";
        goto LABEL_24;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v100 = "nw_proxy_config_create_privacy_proxy_internal";
        BOOL v18 = "%{public}s First hop must be MASQUE";
LABEL_24:
        _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, v18, buf, 0xCu);
      }
    }

    goto LABEL_26;
  }

  if (v5 >> 3 == 1)
  {
    id v7 = nw_array_get_object_at_index((uint64_t)v2, 0LL);
    if (nw_protocol_options_is_masque(*(void **)(v7 + 40)))
    {
      BOOL v8 = (uint64_t)nw_protocol_options_copy(*(void **)(v7 + 40));
      nw_protocol_options_set_proxy_endpoint((void *)v8, *(void **)(v7 + 24), 0);
      if (nw_protocol_copy_http3_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_10_72547);
      }
      uint32_t v9 = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
      v96 = v9;
      if ((*(_BYTE *)(v7 + 80) & 2) != 0)
      {
        nw_http3_set_0rtt_enabled(v9, 1LL);
        nw_http3_set_idle_timeout(v96, 30LL);
        nw_http3_set_keepalive_mode(v96, 2LL);
      }

      else
      {
        nw_http3_set_idle_timeout(v9, 60LL);
        nw_http3_set_keepalive_mode(v96, 1LL);
      }

      if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
      }
      os_log_type_t v22 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
      char v23 = (NWConcrete_nw_protocol_options *)nw_quic_stream_copy_shared_connection_options(v22);
      uint64_t v14 = v23;
      int v24 = *(_BYTE *)(v7 + 80);
      if ((v24 & 4) != 0)
      {
        nw_quic_connection_set_enable_l4s(v23, 1);
        int v24 = *(_BYTE *)(v7 + 80);
      }

      if ((v24 & 8) != 0) {
        nw_quic_connection_set_enable_multipath(v14, 1);
      }
      nw_quic_connection_set_idle_timeout(v14, 0);
      nw_quic_connection_set_max_datagram_frame_size(v14, 0xFFFF);
      nw_quic_connection_set_datagram_variant_flow_id_enabled(v14, 1);
      if (nw_masque_options_get_version((void *)v8) == 2)
      {
        nw_quic_connection_set_datagram_quarter_stream_id(v14, 1);
        nw_quic_connection_set_datagram_context_id(v14, 1);
      }

      nw_quic_connection_set_source_connection_id_length(v14, 8);
      nw_quic_connection_set_initial_packet_size(v14, 1350);
      uint64_t v25 = *(void **)(v7 + 48);
      if (v25)
      {
        id v26 = v25;
        nw_quic_connection_set_sec_protocol_options(v14, v26);
      }

      uint64_t v27 = *(void *)(v7 + 56);
      if (v27) {
        nw_quic_connection_set_server_raw_public_keys(v14, v27);
      }
      BOOL v28 = *(void *)(v7 + 64);
      if (v28) {
        nw_quic_connection_set_client_identity_reference(v14, v28, *(void *)(v7 + 72));
      }
      if ((*(_BYTE *)(v7 + 81) & 4) != 0) {
        nw_quic_connection_set_client_identity_is_raw_public_Key(v14, 1);
      }
      if ((*(_BYTE *)(v7 + 80) & 0x10) != 0) {
        nw_quic_connection_set_override_trust_certs_for_tests(v14, 1);
      }
      nw_quic_connection_add_h3_alpn(v14, 1);
      nw_quic_connection_set_keepalive_count(v14, 3);
      nw_protocol_stack_append_application_protocol(v6, (void *)v8);
      nw_protocol_stack_append_application_protocol(v6, v96);
      if ((*(_BYTE *)(v7 + 81) & 1) != 0)
      {
        nw_protocol_stack_append_application_protocol(v6, v22);
        if (nw_protocol_demux_copy_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25952);
        }
        if (nw_protocol_demux_copy_definition::definition)
        {
          os_log_type_t v29 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
          os_log_type_t v30 = nw_protocol_create_options(v29);
          if (v29) {
            os_release(v29);
          }
        }

        else
        {
          os_log_type_t v30 = nw_protocol_create_options(0LL);
        }

        nw_protocol_stack_append_application_protocol(v6, v30);
        v48 = nw_protocol_create_options((void *)g_udp_definition);
        nw_udp_options_set_use_quic_stats(v48, 1);
        nw_udp_options_set_no_metadata(v48, 1);
        nw_protocol_stack_set_transport_protocol((nw_protocol_stack_t)v6, (nw_protocol_options_t)v48);
      }

      else
      {
        nw_protocol_stack_set_transport_protocol((nw_protocol_stack_t)v6, (nw_protocol_options_t)v22);
      }

      v49 = nw_protocol_options_copy_proxy_endpoint_for_stack((void *)v8);
      uint64_t v19 = nw_proxy_config_create_with_stack(v49, v6);

      os_log_type_t v50 = (id)g_udp_definition;
      nw_proxy_config_set_alternate_protocol_stack(v19, 0LL, v50, 4u);

      if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55294);
      }
      v51 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
      nw_proxy_config_set_alternate_protocol_stack(v19, 0LL, v51, 3u);

      os_log_type_t v52 = *(_BYTE *)(v7 + 80);
      if ((v52 & 1) != 0)
      {
        nw_proxy_config_set_alternate_protocol_stack(v19, 0LL, 0LL, 2u);
        os_log_type_t v52 = *(_BYTE *)(v7 + 80);
      }

      if ((v52 & 0x40) != 0)
      {
        v53 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_stack);
        os_log_type_t v54 = nw_masque_options_copy_listener_options((void *)v8);
        nw_protocol_stack_append_application_protocol(v53, v54);

        nw_protocol_stack_append_application_protocol(v53, v96);
        nw_protocol_stack_set_transport_protocol((nw_protocol_stack_t)v53, (nw_protocol_options_t)v22);
        BOOL v55 = (id)g_udp_definition;
        nw_proxy_config_set_listener_protocol_stack(v19, v53, v55, 4u);
      }

      nw_proxy_config_set_is_privacy_proxy(v19, 1, 0);
      nw_proxy_config_set_multipath_service(v19, 1);
      uint64_t v20 = v22;
      goto LABEL_167;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v16 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v100 = "nw_proxy_config_create_privacy_proxy_internal";
      _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_ERROR, "%{public}s First hop must be MASQUE", buf, 0xCu);
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v100 = "nw_proxy_config_create_privacy_proxy_internal";
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s No more than two hops are currently supported",  buf,  0xCu);
    }
  }

  if (v53) {
    free(v53);
  }
  id v7 = 0LL;
LABEL_10:
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v12 = a1[1].callbacks;
    if (v12)
    {
      uint64_t v13 = (nw_protocol_callbacks *)((char *)v12 - 1);
      a1[1].callbacks = v13;
      if (!v13)
      {
        uint64_t v14 = *(void (***)(void))a1[1].flow_id;
        if (v14)
        {
          *(void *)a1[1].flow_id = 0LL;
          v14[2](v14);
          _Block_release(v14);
        }

        if ((a1[1].flow_id[8] & 1) != 0)
        {
          uint64_t v15 = *(const void **)a1[1].flow_id;
          if (v15) {
            _Block_release(v15);
          }
        }

        free(a1);
      }
    }
  }

  if (v7)
  {
    if (nw_protocol_copy_test_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_83889);
    }
    if (nw_protocol_copy_test_definition::test_definition)
    {
      BOOL v8 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
      if (v8)
      {
        uint32_t v9 = v8;
        int v10 = nw_parameters_copy_protocol_options_for_definition(v7, v8);
        if (v10)
        {
          uint64_t v11 = v10;
          if (nw_protocol_options_is_test_protocol(v10))
          {
            v89((uint64_t)v88, v11);
LABEL_78:
            os_release(v9);
            os_log_type_t v35 = v11;
LABEL_79:
            os_release(v35);
            goto LABEL_80;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446210;
          v96 = "nw_protocol_test_access_options";
          int v24 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v93 = 0;
          if (__nwlog_fault(v24, &type, &v93))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v25 = (os_log_s *)gLogObj;
              id v26 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                goto LABEL_76;
              }
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              uint64_t v27 = "%{public}s Failed to copy test protocol options";
              goto LABEL_75;
            }

            if (!v93)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v25 = (os_log_s *)gLogObj;
              id v26 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                goto LABEL_76;
              }
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              uint64_t v27 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
              goto LABEL_75;
            }

            id v33 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v25 = (os_log_s *)gLogObj;
            id v26 = type;
            id v34 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v33)
            {
              if (v34)
              {
                *(_DWORD *)buf = 136446466;
                v96 = "nw_protocol_test_access_options";
                v97 = 2082;
                v98 = (nw_protocol *)v33;
                _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v33);
              goto LABEL_76;
            }

            if (v34)
            {
              *(_DWORD *)buf = 136446210;
              v96 = "nw_protocol_test_access_options";
              uint64_t v27 = "%{public}s Failed to copy test protocol options, no backtrace";
LABEL_75:
              _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0xCu);
            }
          }

LABEL_208:
  if (v122) {
    free(v122);
  }
LABEL_28:

LABEL_29:
  uint64_t v15 = a1[13];
  a1[13] = v18;
LABEL_30:

  if (!a1[13])
  {
    __nwlog_obj();
    v103 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
    v104 = (char *)_os_log_send_and_compose_impl();

    v153 = OS_LOG_TYPE_ERROR;
    v152 = 0;
    if (__nwlog_fault(v104, &v153, &v152))
    {
      if (v153 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v106 = v153;
        if (os_log_type_enabled(v105, v153))
        {
          *(_DWORD *)buf = 136446210;
          v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
          _os_log_impl(&dword_181A5C000, v105, v106, "%{public}s called with null self->path_parameters", buf, 0xCu);
        }
      }

      else if (v152)
      {
        v125 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v126 = v153;
        v127 = os_log_type_enabled(v105, v153);
        if (v125)
        {
          if (v127)
          {
            *(_DWORD *)buf = 136446466;
            v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
            v156 = 2082;
            v157 = (uint64_t)v125;
            _os_log_impl( &dword_181A5C000,  v105,  v126,  "%{public}s called with null self->path_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v125);
          goto LABEL_189;
        }

        if (v127)
        {
          *(_DWORD *)buf = 136446210;
          v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
          _os_log_impl( &dword_181A5C000,  v105,  v126,  "%{public}s called with null self->path_parameters, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v144 = v153;
        if (os_log_type_enabled(v105, v153))
        {
          *(_DWORD *)buf = 136446210;
          v155 = "-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]";
          _os_log_impl( &dword_181A5C000,  v105,  v144,  "%{public}s called with null self->path_parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v60) {
    free(v60);
  }
  return 0LL;
}

              free(v72);
              goto LABEL_209;
            }

            if (v121 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v73 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v76 = v121;
              if (os_log_type_enabled(v73, v121))
              {
                *(_DWORD *)v132 = 136446210;
                *(void *)&v132[4] = "nw_http_cookie_options_copy_transform_callback";
                _os_log_impl(&dword_181A5C000, v73, v76, "%{public}s protocol options are not http_cookie", v132, 0xCu);
              }

        if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
          goto LABEL_134;
        }
        goto LABEL_209;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
      v238 = (char *)_os_log_send_and_compose_impl();
      v268[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v238, v268, &type))
      {
        if (v268[0] == 17)
        {
          v239 = (os_log_s *)__nwlog_obj();
          v240 = v268[0];
          if (!os_log_type_enabled(v239, (os_log_type_t)v268[0])) {
            goto LABEL_527;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
          v241 = "%{public}s called with null http1_stream";
LABEL_526:
          _os_log_impl(&dword_181A5C000, v239, v240, v241, buf, 0xCu);
          goto LABEL_527;
        }

        if (type == OS_LOG_TYPE_DEFAULT)
        {
          v239 = (os_log_s *)__nwlog_obj();
          v240 = v268[0];
          if (!os_log_type_enabled(v239, (os_log_type_t)v268[0])) {
            goto LABEL_527;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
          v241 = "%{public}s called with null http1_stream, backtrace limit exceeded";
          goto LABEL_526;
        }

        v249 = (char *)__nw_create_backtrace_string();
        v239 = (os_log_s *)__nwlog_obj();
        v240 = v268[0];
        v250 = os_log_type_enabled(v239, (os_log_type_t)v268[0]);
        if (!v249)
        {
          if (!v250) {
            goto LABEL_527;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
          v241 = "%{public}s called with null http1_stream, no backtrace";
          goto LABEL_526;
        }

        if (v250)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http1_recover_incomplete_header";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v249;
          _os_log_impl( &dword_181A5C000,  v239,  v240,  "%{public}s called with null http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v249);
      }

          if (v108) {
            free(v108);
          }
          goto LABEL_72;
        }

        if ((unint64_t)v270 >= 2 && v270 != 5)
        {
LABEL_87:
          if ((v5 & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              v70 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
              {
                v71 = *(_DWORD *)(a1 + 1280);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_http3_control_stream_process_input";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v3;
                *(_WORD *)&buf[22] = 2080;
                v282 = " ";
                v283 = 1024;
                v284 = v71;
                v285 = 2048;
                v286 = v6;
                _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> received unsupported frame %llu",  buf,  0x30u);
              }
            }
          }

            if (!v62) {
              goto LABEL_211;
            }
            os_log_type_t v59 = (char *)v62;
            goto LABEL_210;
          }

          if (!(_BYTE)v84)
          {
            char v63 = (os_log_s *)__nwlog_obj();
            v64 = v85[0];
            if (os_log_type_enabled(v63, v85[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v13;
              v65 = "%{public}s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d, backtrace limit exceeded";
              goto LABEL_207;
            }

            goto LABEL_208;
          }

          v68 = (char *)__nw_create_backtrace_string();
          char v63 = (os_log_s *)__nwlog_obj();
          v64 = v85[0];
          v69 = os_log_type_enabled(v63, v85[0]);
          if (!v68)
          {
            if (v69)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v13;
              v65 = "%{public}s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d, no backtrace";
              goto LABEL_207;
            }

            goto LABEL_208;
          }

          if (v69)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v13;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v68;
            v70 = "%{public}s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_175:
            _os_log_impl(&dword_181A5C000, v63, v64, v70, buf, 0x1Cu);
          }

  v84 = getpid();
  v85 = v67;
  v86 = v85;
  v87 = *(_DWORD *)(*((void *)v67 + 13) + 64LL);
  v89 = v87 > 0 && v87 != v84;

  if (v89)
  {
    v90 = v86;
    v91 = *(_DWORD *)(*((void *)v67 + 13) + 64LL);

    LODWORD(v556) = v91;
    if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4359, &v556, 4u))
    {
      if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v113 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 2082;
          *(void *)v555 = (char *)a1 + 404;
          *(_WORD *)&v555[8] = 1024;
          *(_DWORD *)&v555[10] = v556;
          v105 = "%{public}s %{public}s successfully set source application pid to %d";
          v106 = (os_log_s *)v113;
          v107 = OS_LOG_TYPE_DEBUG;
          v108 = 28;
          goto LABEL_259;
        }
      }

      goto LABEL_222;
    }

    v92 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v93 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446978;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(void *)v555 = (char *)a1 + 404;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v556;
      *(_WORD *)&v555[14] = 1024;
      *(_DWORD *)&v555[16] = v92;
      _os_log_impl( &dword_181A5C000,  v93,  OS_LOG_TYPE_ERROR,  "%{public}s %s set source pid to %d failed %{darwin.errno}d",  buf,  0x22u);
    }
  }

  v94 = v86;
  if (uuid_is_null((const unsigned __int8 *)(*((void *)v67 + 13) + 24LL)))
  {

    goto LABEL_222;
  }

  v100 = uuid_compare( (const unsigned __int8 *)(*((void *)v67 + 13) + 24LL),  (const unsigned __int8 *)(*((void *)v67 + 13) + 8LL)) == 0;

  if (v100) {
    goto LABEL_222;
  }
  v101 = v94;
  v556 = *(_OWORD *)(*((void *)v67 + 13) + 24LL);

  if (setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4360, &v556, 0x10u))
  {
    v102 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v103 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 2080;
      *(void *)v555 = (char *)a1 + 404;
      *(_WORD *)&v555[8] = 1024;
      *(_DWORD *)&v555[10] = v102;
      _os_log_impl( &dword_181A5C000,  v103,  OS_LOG_TYPE_ERROR,  "%{public}s %s set source app uuid failed %{darwin.errno}d",  buf,  0x1Cu);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v104 = gLogObj;
    if (v102 == 22)
    {
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_222;
      }
      *(_DWORD *)buf = 136446466;
      v553 = "nw_socket_set_common_sockopts";
      v554 = 1024;
      *(_DWORD *)v555 = 22;
      v105 = "%{public}s set source app uuid failed %{darwin.errno}d";
      v106 = (os_log_s *)v104;
      v107 = OS_LOG_TYPE_ERROR;
      v108 = 18;
LABEL_259:
      _os_log_impl(&dword_181A5C000, v106, v107, v105, buf, v108);
      goto LABEL_222;
    }

    v120 = p_output_handler;
    *(_DWORD *)buf = 136446466;
    v553 = "nw_socket_set_common_sockopts";
    v554 = 1024;
    *(_DWORD *)v555 = v102;
    v121 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v548[0] = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v122 = (os_log_s *)__nwlog_obj();
      v123 = type[0];
      if (os_log_type_enabled(v122, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v102;
        v124 = "%{public}s set source app uuid failed %{darwin.errno}d";
LABEL_420:
        _os_log_impl(&dword_181A5C000, v122, v123, v124, buf, 0x12u);
      }
    }

    else if (v548[0])
    {
      v536 = v72;
      v147 = (char *)__nw_create_backtrace_string();
      v122 = (os_log_s *)__nwlog_obj();
      v123 = type[0];
      v148 = os_log_type_enabled(v122, type[0]);
      if (v147)
      {
        if (v148)
        {
          *(_DWORD *)buf = 136446722;
          v553 = "nw_socket_set_common_sockopts";
          v554 = 1024;
          *(_DWORD *)v555 = v102;
          *(_WORD *)&v555[4] = 2082;
          *(void *)&v555[6] = v147;
          _os_log_impl( &dword_181A5C000,  v122,  v123,  "%{public}s set source app uuid failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v147);
        v72 = v536;
        goto LABEL_421;
      }

      v72 = v536;
      if (v148)
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v102;
        v124 = "%{public}s set source app uuid failed %{darwin.errno}d, no backtrace";
        goto LABEL_420;
      }
    }

    else
    {
      v122 = (os_log_s *)__nwlog_obj();
      v123 = type[0];
      if (os_log_type_enabled(v122, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v553 = "nw_socket_set_common_sockopts";
        v554 = 1024;
        *(_DWORD *)v555 = v102;
        v124 = "%{public}s set source app uuid failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_420;
      }
    }

  __break(1u);
  return result;
}

  if (v100) {
    free(v100);
  }
  v85 = 0LL;
LABEL_80:

LABEL_81:
  return v85;
}

        os_log_type_t v60 = 0LL;
        goto LABEL_238;
      }

LABEL_189:
    if (v104) {
      free(v104);
    }
LABEL_191:

LABEL_192:
    a1 = 0LL;
LABEL_103:

    return (BOOL)a1;
  }

  uint64_t v42 = (const char *)*((void *)v7 + 14);
  if (v42)
  {
    BOOL v43 = strdup(v42);
    if (!v43)
    {
      __nwlog_obj();
      v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v107, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v155 = "strict_strdup";
      v108 = (void *)_os_log_send_and_compose_impl();

      uint64_t result = __nwlog_abort((uint64_t)v108);
      if (result) {
        goto LABEL_210;
      }
      free(v108);
    }

    a1[14] = v43;
  }

  os_log_type_t v44 = (const char *)*((void *)v7 + 15);
  if (!v44) {
    goto LABEL_37;
  }
  os_log_type_t v45 = strdup(v44);
  if (v45)
  {
LABEL_36:
    a1[15] = v45;
LABEL_37:
    objc_storeStrong(a1 + 16, *((id *)v7 + 16));
    if ((a3 & 1) != 0) {
      *((_DWORD *)a1[13] + 21) = 0;
    }
    else {
      objc_storeStrong(a1 + 22, *((id *)v7 + 22));
    }
    if (*((void *)v7 + 20))
    {
      v46 = nw_array_create();
      v47 = a1[20];
      a1[20] = (id)v46;

      v48 = (unsigned __int8 *)*((void *)v7 + 20);
      v149[0] = MEMORY[0x1895F87A8];
      v149[1] = 3221225472LL;
      v149[2] = __74__NWConcrete_nw_parameters_initWithParameters_stripConnected_shallowCopy___block_invoke;
      v149[3] = &unk_189BC85B0;
      v150 = a1;
      nw_array_apply(v48, (uint64_t)v149);
    }

    objc_storeStrong(a1 + 23, *((id *)v7 + 23));
    objc_storeStrong(a1 + 24, *((id *)v7 + 24));
    objc_storeStrong(a1 + 17, *((id *)v7 + 17));
    objc_storeStrong(a1 + 18, *((id *)v7 + 18));
    v49 = (void *)*((void *)v7 + 19);
    if (v49)
    {
      if (a4)
      {
        os_log_type_t v50 = v49;
        v51 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_stack);
        if (v51)
        {
          os_log_type_t v52 = (OS_nw_array *)*((void *)v50 + 1);
          if (v52)
          {
            v53 = nw_array_create();
            if ((OS_nw_array *)v53 != v52)
            {
              os_log_type_t v54 = (OS_nw_array *)v53;
              std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( v53 + 16,  (void **)&v52[2].super.super.isa->isa,  (void **)&v52[3].super.super.isa->isa,  v52[3].super.super.isa - v52[2].super.super.isa);
              os_log_type_t v52 = v54;
            }

            persistent_application_protocols = v51->persistent_application_protocols;
            v51->persistent_application_protocols = v52;
          }

          v56 = (OS_nw_array *)*((void *)v50 + 2);
          if (v56)
          {
            os_log_type_t v57 = nw_array_create();
            if ((OS_nw_array *)v57 != v56)
            {
              BOOL v58 = (OS_nw_array *)v57;
              std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( v57 + 16,  (void **)&v56[2].super.super.isa->isa,  (void **)&v56[3].super.super.isa->isa,  v56[3].super.super.isa - v56[2].super.super.isa);
              v56 = v58;
            }

            application_protocols = v51->application_protocols;
            v51->application_protocols = v56;
          }

          objc_storeStrong((id *)&v51->transport_protocol, *((id *)v50 + 3));
          objc_storeStrong((id *)&v51->secondary_transport_protocol, *((id *)v50 + 4));
          objc_storeStrong((id *)&v51->original_proxied_transport_protocol, *((id *)v50 + 5));
          objc_storeStrong((id *)&v51->internet_protocol, *((id *)v50 + 6));
          os_log_type_t v60 = v51;
          goto LABEL_80;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v69 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v155 = "nw_protocol_stack_shallow_copy";
        v70 = (void *)_os_log_send_and_compose_impl();

        v153 = OS_LOG_TYPE_ERROR;
        v152 = 0;
        if (__nwlog_fault((const char *)v70, &v153, &v152))
        {
          if (v153 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v71 = (os_log_s *)(id)gLogObj;
            v72 = v153;
            if (os_log_type_enabled(v71, v153))
            {
              *(_DWORD *)buf = 136446210;
              v155 = "nw_protocol_stack_shallow_copy";
              _os_log_impl(&dword_181A5C000, v71, v72, "%{public}s [[nw_protocol_stack alloc] init] failed", buf, 0xCu);
            }
          }

          else if (v152)
          {
            v74 = __nw_create_backtrace_string();
            if (v74)
            {
              v75 = (char *)v74;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v76 = (os_log_s *)(id)gLogObj;
              v77 = v153;
              if (os_log_type_enabled(v76, v153))
              {
                *(_DWORD *)buf = 136446466;
                v155 = "nw_protocol_stack_shallow_copy";
                v156 = 2082;
                v157 = (uint64_t)v75;
                _os_log_impl( &dword_181A5C000,  v76,  v77,  "%{public}s [[nw_protocol_stack alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v75);
              if (!v70)
              {
LABEL_80:

                v80 = a1[19];
                a1[19] = v51;

                id v62 = (void ***)*((void *)v7 + 21);
                if (!v62)
                {
                  v73 = (void *)*((void *)v7 + 25);
                  if (!v73) {
                    goto LABEL_95;
                  }
                  goto LABEL_94;
                }

    if (v70) {
      free(v70);
    }
    uint64_t v13 = 0LL;
    goto LABEL_23;
  }

  uint32_t v9 = default_input_handler->handle;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    int v10 = default_input_handler[1].callbacks;
    if (v10) {
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v10->add_input_handler + 1);
    }
  }

  uint64_t v11 = default_input_handler->callbacks;
  if (v11)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v11->get_parameters;
    if (get_parameters)
    {
      uint64_t v13 = (void *)get_parameters(default_input_handler);
      if (v9 != &nw_protocol_ref_counted_handle) {
        goto LABEL_23;
      }
      goto LABEL_22;
    }
  }

  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
  if (!name) {
    name = "invalid";
  }
  v86 = 2082;
  v87 = (char *)name;
  v88 = 2048;
  v89 = (const char *)default_input_handler;
  v61 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v83 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v62 = (os_log_s *)__nwlog_obj();
    char v63 = type;
    if (!os_log_type_enabled(v62, type)) {
      goto LABEL_180;
    }
    v64 = default_input_handler->identifier->name;
    if (!v64) {
      v64 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v64;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_179:
    _os_log_impl(&dword_181A5C000, v62, v63, v65, buf, 0x20u);
    goto LABEL_180;
  }

  if (!v83)
  {
    id v62 = (os_log_s *)__nwlog_obj();
    char v63 = type;
    if (!os_log_type_enabled(v62, type)) {
      goto LABEL_180;
    }
    v79 = default_input_handler->identifier->name;
    if (!v79) {
      v79 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v79;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
    goto LABEL_179;
  }

  v82 = v9;
  v74 = (char *)__nw_create_backtrace_string();
  id v62 = (os_log_s *)__nwlog_obj();
  char v63 = type;
  v75 = os_log_type_enabled(v62, type);
  if (!v74)
  {
    uint32_t v9 = v82;
    if (!v75) {
      goto LABEL_180;
    }
    v81 = default_input_handler->identifier->name;
    if (!v81) {
      v81 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v81;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
    goto LABEL_179;
  }

  if (v75)
  {
    v76 = default_input_handler->identifier->name;
    if (!v76) {
      v76 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v76;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v90 = 2082;
    p_output_handler = v74;
    _os_log_impl( &dword_181A5C000,  v62,  v63,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v74);
  uint32_t v9 = v82;
LABEL_180:
  if (v61) {
    free(v61);
  }
  uint64_t v13 = 0LL;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
LABEL_22:
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      BOOL v43 = default_input_handler[1].callbacks;
      if (v43)
      {
        os_log_type_t v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
        default_input_handler[1].callbacks = v44;
        if (!v44)
        {
          os_log_type_t v45 = *(void (***)(void))default_input_handler[1].flow_id;
          if (v45)
          {
            *(void *)default_input_handler[1].flow_id = 0LL;
            v45[2](v45);
            _Block_release(v45);
          }

          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v46 = *(const void **)default_input_handler[1].flow_id;
            if (v46) {
              _Block_release(v46);
            }
          }

          free(default_input_handler);
        }
      }
    }
  }

    v70 = v85;
    v71 = v86;
    v72 = 12;
    goto LABEL_112;
  }

  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(packet) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v85 = (os_log_s *)__nwlog_obj();
      v86 = type[0];
      if (!os_log_type_enabled(v85, type[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      BOOL v28 = "%{public}s called with null channel";
      goto LABEL_189;
    }

    if ((_BYTE)packet)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v85 = (os_log_s *)__nwlog_obj();
      v86 = type[0];
      v94 = os_log_type_enabled(v85, type[0]);
      if (backtrace_string)
      {
        if (v94)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          v93 = "%{public}s called with null channel, dumping backtrace:%{public}s";
          goto LABEL_168;
        }

        goto LABEL_169;
      }

      if (!v94) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      BOOL v28 = "%{public}s called with null channel, no backtrace";
    }

    else
    {
      v85 = (os_log_s *)__nwlog_obj();
      v86 = type[0];
      if (!os_log_type_enabled(v85, type[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      BOOL v28 = "%{public}s called with null channel, backtrace limit exceeded";
    }

    goto LABEL_189;
  }

  a6->tqh_first = 0LL;
  a6->tqh_last = &a6->tqh_first;
  if (!*((void *)handle + 17) || !*((void *)handle + 27)) {
    return 0LL;
  }
  uint64_t v11 = (unsigned __int16 *)(handle + 444);
  uint64_t v12 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
  *((_WORD *)handle + 222) = *((_WORD *)handle + 222);
  handle[446] = (v12 & 0xFFF9FFFF | 0x20000) >> 16;
  if ((v12 & 2) == 0 && *((void *)handle + 22))
  {
    uint64_t v13 = v12 & 0xFFF9FFFD | 0x20002;
    *uint64_t v11 = v13;
    handle[446] = BYTE2(v13);
    uint64_t v14 = os_channel_available_slot_count();
    if (*((_DWORD *)handle + 105) - 1 >= v14) {
      BOOL v16 = 0;
    }
    else {
      BOOL v16 = *((_DWORD *)handle + 105);
    }
    uint64_t v17 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
    if (v14 == v16)
    {
      if ((*((_WORD *)handle + 222) & 0x10) != 0)
      {
        BOOL v18 = *((_WORD *)handle + 222) & 0xFFEF | (handle[446] << 16);
        *uint64_t v11 = *((_WORD *)handle + 222) & 0xFFEF;
        handle[446] = BYTE2(v18);
        nw_queue_resume_source(*((void *)handle + 22), v15);
      }
    }

    else if ((*((_WORD *)handle + 222) & 0x10) == 0)
    {
      handle[446] = BYTE2(v17);
      *uint64_t v11 = v17 | 0x10;
      nw_queue_suspend_source(*((void *)handle + 22));
    }

    uint64_t v19 = *v11;
    uint64_t v20 = v19 & 0xFFFFFFFD | (handle[446] << 16);
    *uint64_t v11 = v19 & 0xFFFD;
    handle[446] = BYTE2(v20);
  }

  char v21 = *((_DWORD *)handle + 109);
  os_log_type_t v22 = *((_DWORD *)handle + 110);
  if (!v22) {
    goto LABEL_28;
  }
  char v23 = 0xFFFFFFFF / v21;
  if (0xFFFFFFFF / v21 >= a5) {
    char v23 = a5;
  }
  if (v23 * v21 < a3)
  {
    if (0xFFFFFFFF / v22 >= a5) {
      int v24 = a5;
    }
    else {
      int v24 = 0xFFFFFFFF / v22;
    }
    if (v24 * v22 < a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v22;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = v24 * v22;
      *(_WORD *)&buf[30] = 1024;
      LODWORD(v113) = a3;
      uint64_t v25 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(packet) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v26 = (os_log_s *)gLogObj;
        uint64_t v27 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_113;
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v22;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v24;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v24 * v22;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v113) = a3;
        BOOL v28 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u)";
        goto LABEL_111;
      }

      if (!(_BYTE)packet)
      {
        id v26 = (os_log_s *)__nwlog_obj();
        uint64_t v27 = type[0];
        if (!os_log_type_enabled(v26, type[0])) {
          goto LABEL_113;
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v22;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v24;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v24 * v22;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v113) = a3;
        BOOL v28 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), backtrace limit exceeded";
        goto LABEL_111;
      }

      id v62 = (char *)__nw_create_backtrace_string();
      id v26 = (os_log_s *)__nwlog_obj();
      uint64_t v27 = type[0];
      char v63 = os_log_type_enabled(v26, type[0]);
      if (v62)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v22;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v24;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = v24 * v22;
          *(_WORD *)&buf[30] = 1024;
          LODWORD(v113) = a3;
          WORD2(v113) = 2082;
          *(void *)((char *)&v113 + 6) = v62;
          _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), dumping backtrace:%{public}s",  buf,  0x2Eu);
        }

        free(v62);
        goto LABEL_113;
      }

      if (v63)
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v22;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v24;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v24 * v22;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v113) = a3;
        BOOL v28 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), no backtrace";
LABEL_111:
        v70 = v26;
        v71 = v27;
        v72 = 36;
LABEL_112:
        _os_log_impl(&dword_181A5C000, v70, v71, v28, buf, v72);
      }

          if (!v44) {
            goto LABEL_142;
          }
          goto LABEL_190;
        }

        __nwlog_obj();
        v64 = (void *)objc_claimAutoreleasedReturnValue();
        v65 = networkd_privileged_result_to_string(v42);
        *(_DWORD *)buf = 136446722;
        v105 = "networkd_privileged_set_settings";
        v106 = 2048;
        *(void *)v107 = v42;
        *(_WORD *)&v107[8] = 2082;
        *(void *)&v107[10] = v65;
        os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v102 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v67 = type;
          if (os_log_type_enabled(v66, type))
          {
            *(_DWORD *)buf = 136446722;
            v105 = "networkd_privileged_set_settings";
            v106 = 2048;
            *(void *)v107 = v42;
            *(_WORD *)&v107[8] = 2082;
            *(void *)&v107[10] = v65;
            _os_log_impl( &dword_181A5C000,  v66,  v67,  "%{public}s received internal failure result code: [%lld] %{public}s",  buf,  0x20u);
          }
        }

        else if (v102)
        {
          v78 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v101 = type;
          v79 = os_log_type_enabled(v66, type);
          if (v78)
          {
            if (v79)
            {
              *(_DWORD *)buf = 136446978;
              v105 = "networkd_privileged_set_settings";
              v106 = 2048;
              *(void *)v107 = v42;
              *(_WORD *)&v107[8] = 2082;
              *(void *)&v107[10] = v65;
              v108 = 2082;
              v109 = v78;
              _os_log_impl( &dword_181A5C000,  v66,  v101,  "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v78);
            goto LABEL_189;
          }

          if (v79)
          {
            *(_DWORD *)buf = 136446722;
            v105 = "networkd_privileged_set_settings";
            v106 = 2048;
            *(void *)v107 = v42;
            *(_WORD *)&v107[8] = 2082;
            *(void *)&v107[10] = v65;
            _os_log_impl( &dword_181A5C000,  v66,  v101,  "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          __nwlog_obj();
          v66 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v83 = type;
          if (os_log_type_enabled(v66, type))
          {
            *(_DWORD *)buf = 136446722;
            v105 = "networkd_privileged_set_settings";
            v106 = 2048;
            *(void *)v107 = v42;
            *(_WORD *)&v107[8] = 2082;
            *(void *)&v107[10] = v65;
            _os_log_impl( &dword_181A5C000,  v66,  v83,  "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded",  buf,  0x20u);
          }
        }

        goto LABEL_189;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v16 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v105 = "networkd_privileged_set_settings";
      uint64_t v17 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v102 = 0;
      if (__nwlog_fault(v17, &type, &v102))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v18 = (os_log_s *)(id)gLogObj;
          uint64_t v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s received NULL response", buf, 0xCu);
          }
        }

        else if (v102)
        {
          id v26 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v18 = (os_log_s *)(id)gLogObj;
          uint64_t v27 = type;
          BOOL v28 = os_log_type_enabled(v18, type);
          if (v26)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446466;
              v105 = "networkd_privileged_set_settings";
              v106 = 2082;
              *(void *)v107 = v26;
              _os_log_impl( &dword_181A5C000,  v18,  v27,  "%{public}s received NULL response, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v26);
            if (!v17) {
              goto LABEL_83;
            }
            goto LABEL_82;
          }

          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            _os_log_impl(&dword_181A5C000, v18, v27, "%{public}s received NULL response, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v18 = (os_log_s *)(id)gLogObj;
          __int16 v36 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            _os_log_impl( &dword_181A5C000,  v18,  v36,  "%{public}s received NULL response, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

      if (!v17)
      {
LABEL_83:
        os_log_type_t v52 = 0LL;
LABEL_180:

LABEL_181:
        goto LABEL_182;
      }

      if (v65) {
        free(v65);
      }
      a5 = 0LL;
      BOOL v18 = a6;
      goto LABEL_27;
    }

    a4 = os_retain(v20);
  }

  __int16 v39 = *(_BYTE *)(a1 + 88);
  if ((v39 & 1) != 0)
  {
    __int16 v40 = *(void **)(a1 + 80);
    if (v40)
    {
      os_release(v40);
      __int16 v39 = *(_BYTE *)(a1 + 88);
    }
  }

  *(void *)(a1 + 80) = a4;
  *(_BYTE *)(a1 + 88) = v39 | 1;
  if (!a5) {
    goto LABEL_49;
  }
LABEL_31:
  os_log_type_t v30 = os_retain(a5);
  os_log_type_t v31 = *(_BYTE *)(a1 + 56);
  if ((v31 & 1) != 0) {
    goto LABEL_50;
  }
LABEL_52:
  *(void *)(a1 + 48) = v30;
  *(_BYTE *)(a1 + 56) = v31 | 1;
  *(_DWORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = a7;
  uint64_t v42 = _Block_copy(a8);
  BOOL v43 = *(_BYTE *)(a1 + 120);
  if ((v43 & 1) != 0)
  {
    os_log_type_t v44 = *(const void **)(a1 + 112);
    if (v44)
    {
      _Block_release(v44);
      BOOL v43 = *(_BYTE *)(a1 + 120);
    }
  }

  *(void *)(a1 + 112) = v42;
  *(_BYTE *)(a1 + 120) = v43 | 1;
  os_log_type_t v45 = _Block_copy(a9);
  v46 = *(_BYTE *)(a1 + 168);
  if ((v46 & 1) != 0)
  {
    v47 = *(const void **)(a1 + 160);
    if (v47)
    {
      _Block_release(v47);
      v46 = *(_BYTE *)(a1 + 168);
    }
  }

  *(void *)(a1 + 160) = v45;
  *(_BYTE *)(a1 + 168) = v46 | 1;
  *(_BYTE *)(a1 + 212) |= 0x20u;
  nw_protocol_plugin_retry_begin_async(a1);
  v89[0] = MEMORY[0x1895F87A8];
  v89[1] = 0x40000000LL;
  v89[2] = __nw_protocol_plugin_retry_reissue_output_frames_block_invoke;
  v89[3] = &unk_189BB6348;
  v89[4] = a10;
  v89[5] = a1;
  v90 = v18;
  v89[6] = a2;
  nw_queue_context_async(a3, v89);
}

    goto LABEL_190;
  }

  if (!v12)
  {
    __nwlog_obj();
    BOOL v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v105 = 136446210;
    *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
    __int16 v40 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_181A5C000, v41, v44, "%{public}s called with null data", v105, 0xCu);
      }

      goto LABEL_189;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v52 = buf[0];
      if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v105 = 136446210;
        *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl( &dword_181A5C000,  v41,  v52,  "%{public}s called with null data, backtrace limit exceeded",  v105,  0xCu);
      }

      goto LABEL_189;
    }

    v48 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v49 = buf[0];
    os_log_type_t v50 = os_log_type_enabled(v41, (os_log_type_t)buf[0]);
    if (!v48)
    {
      if (v50)
      {
        *(_DWORD *)v105 = 136446210;
        *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
        _os_log_impl(&dword_181A5C000, v41, v49, "%{public}s called with null data, no backtrace", v105, 0xCu);
      }

      goto LABEL_189;
    }

    if (v50)
    {
      *(_DWORD *)v105 = 136446466;
      *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
      *(_WORD *)&v105[12] = 2082;
      *(void *)&v105[14] = v48;
      _os_log_impl( &dword_181A5C000,  v41,  v49,  "%{public}s called with null data, dumping backtrace:%{public}s",  v105,  0x16u);
    }

    goto LABEL_78;
  }

  uint64_t v14 = v11[15];
  if (v14)
  {
    uint64_t v15 = v14;
    BOOL v16 = v15;
    if (((_BYTE)v15[17] & 8) == 0) {
      dispatch_assert_queue_V2(v15[1]);
    }
  }

  if (*((char ***)v12 + 11) == v11)
  {
    nw_frame_finalize((uint64_t)v12);
    goto LABEL_58;
  }

  if (v13) {
    nw_frame_set_metadata((uint64_t)v12, v13, 1, a5);
  }
  if (a4) {
    *((void *)v12 + 20) = a4;
  }
  if (!v11[37])
  {
    *((void *)v12 + 4) = 0LL;
    int v24 = v11[27];
    *((void *)v12 + 5) = v24;
    *(void *)int v24 = v12;
    v11[27] = v12 + 32;
    if ((*((_BYTE *)v11 + 403) & 0x20) != 0 || !a6 || !v11[26]) {
      goto LABEL_58;
    }
    if ((*((char *)v11 + 405) & 0x80000000) == 0 && gLogDatapath)
    {
      __nwlog_obj();
      v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v105 = 136446722;
        *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
        *(_WORD *)&v105[12] = 2082;
        *(void *)&v105[14] = (char *)v11 + 407;
        *(_WORD *)&v105[22] = 2080;
        v106 = " ";
        _os_log_impl( &dword_181A5C000,  v74,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinalizing outbound frames (one-off)",  v105,  0x20u);
      }
    }

    uint64_t v25 = *(v11 - 8);
    if (!v25)
    {
      __nwlog_obj();
      v72 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)v105 = 136446210;
      *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
      __int16 v40 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (buf[0] == 17)
      {
        __nwlog_obj();
        uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v73 = buf[0];
        if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v105 = 136446210;
          *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v41, v73, "%{public}s called with null protocol", v105, 0xCu);
        }

        goto LABEL_189;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v90 = buf[0];
        if (os_log_type_enabled(v41, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v105 = 136446210;
          *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl( &dword_181A5C000,  v41,  v90,  "%{public}s called with null protocol, backtrace limit exceeded",  v105,  0xCu);
        }

        goto LABEL_189;
      }

      v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v81 = buf[0];
      v82 = os_log_type_enabled(v41, (os_log_type_t)buf[0]);
      if (!v48)
      {
        if (v82)
        {
          *(_DWORD *)v105 = 136446210;
          *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_181A5C000, v41, v81, "%{public}s called with null protocol, no backtrace", v105, 0xCu);
        }

        goto LABEL_189;
      }

      if (v82)
      {
        *(_DWORD *)v105 = 136446466;
        *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
        *(_WORD *)&v105[12] = 2082;
        *(void *)&v105[14] = v48;
        _os_log_impl( &dword_181A5C000,  v41,  v81,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  v105,  0x16u);
      }

      goto LABEL_78;
    }

    id v26 = (void *)*((void *)v25 + 5);
    if (v26 == &nw_protocol_ref_counted_handle)
    {
      __int16 v36 = *((void *)v25 + 11);
      if (v36) {
        *((void *)v25 + 11) = v36 + 1;
      }
      uint64_t v27 = -1;
    }

    else
    {
      uint64_t v27 = 0;
    }

    *(void *)buf = v25;
    buf[8] = v27;
    uint64_t v37 = *((void *)v25 + 3);
    if (v37)
    {
      __int16 v38 = *(void (**)(const char *, char **))(v37 + 96);
      if (v38)
      {
        v38(v25, v11 + 26);
        if (v26 != &nw_protocol_ref_counted_handle) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
    }

    v92 = v26;
    __nwlog_obj();
    os_log_type_t v59 = (void *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v60 = (const char *)*((void *)v25 + 2);
    *(_DWORD *)v105 = 136446722;
    *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
    if (!v60) {
      os_log_type_t v60 = "invalid";
    }
    *(_WORD *)&v105[12] = 2082;
    *(void *)&v105[14] = v60;
    *(_WORD *)&v105[22] = 2048;
    v106 = v25;
    v61 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v63 = type[0];
      if (os_log_type_enabled(v62, type[0]))
      {
        v64 = (const char *)*((void *)v25 + 2);
        if (!v64) {
          v64 = "invalid";
        }
        *(_DWORD *)v105 = 136446722;
        *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
        *(_WORD *)&v105[12] = 2082;
        *(void *)&v105[14] = v64;
        *(_WORD *)&v105[22] = 2048;
        v106 = v25;
        _os_log_impl( &dword_181A5C000,  v62,  v63,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback",  v105,  0x20u);
      }
    }

    else if (v93)
    {
      v75 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v76 = type[0];
      v77 = os_log_type_enabled(v62, type[0]);
      if (v75)
      {
        if (v77)
        {
          v78 = (const char *)*((void *)v25 + 2);
          if (!v78) {
            v78 = "invalid";
          }
          *(_DWORD *)v105 = 136446978;
          *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
          *(_WORD *)&v105[12] = 2082;
          *(void *)&v105[14] = v78;
          *(_WORD *)&v105[22] = 2048;
          v106 = v25;
          LOWORD(v107) = 2082;
          *(void *)((char *)&v107 + 2) = v75;
          _os_log_impl( &dword_181A5C000,  v62,  v76,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  v105,  0x2Au);
        }

        free(v75);
LABEL_174:
        if (v61) {
          free(v61);
        }
        if (v92 == &nw_protocol_ref_counted_handle) {
          goto LABEL_57;
        }
        goto LABEL_58;
      }

      if (v77)
      {
        v88 = (const char *)*((void *)v25 + 2);
        if (!v88) {
          v88 = "invalid";
        }
        *(_DWORD *)v105 = 136446722;
        *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
        *(_WORD *)&v105[12] = 2082;
        *(void *)&v105[14] = v88;
        *(_WORD *)&v105[22] = 2048;
        v106 = v25;
        _os_log_impl( &dword_181A5C000,  v62,  v76,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace",  v105,  0x20u);
      }
    }

    else
    {
      __nwlog_obj();
      id v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v85 = type[0];
      if (os_log_type_enabled(v62, type[0]))
      {
        v86 = (const char *)*((void *)v25 + 2);
        if (!v86) {
          v86 = "invalid";
        }
        *(_DWORD *)v105 = 136446722;
        *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
        *(_WORD *)&v105[12] = 2082;
        *(void *)&v105[14] = v86;
        *(_WORD *)&v105[22] = 2048;
        v106 = v25;
        _os_log_impl( &dword_181A5C000,  v62,  v85,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded",  v105,  0x20u);
      }
    }

    goto LABEL_174;
  }

  uint64_t v17 = v11;
  BOOL v18 = v12;
  *(void *)os_log_type_t type = 0LL;
  v95 = type;
  v96 = 0x2020000000LL;
  v97 = 0LL;
  uint64_t v19 = *((void *)v12 + 11);
  uint64_t v20 = v11[37];
  if (!v19)
  {
    node = nw_hash_table_get_node((uint64_t)v20, *((void *)v17 + 38), 8LL);
    *((void *)v95 + 3) = node;
    if (node) {
      goto LABEL_15;
    }
LABEL_26:
    if ((v17[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v28 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_lookup_path_by_frame";
        v99 = 2082;
        v100 = v17 + 407;
        v101 = 2080;
        v102 = " ";
        v103 = 2048;
        v104 = v19;
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sNo path found for context %p",  buf,  0x2Au);
      }
    }

    os_log_type_t v22 = 0LL;
    extra = 0LL;
    goto LABEL_31;
  }

  *(void *)v105 = MEMORY[0x1895F87A8];
  *(void *)&v105[8] = 3221225472LL;
  *(void *)&v105[16] = ___ZL47nw_protocol_implementation_lookup_path_by_frameP31NWConcrete_nw_protocol_instancePU22objcproto11OS_nw_frame8NSObjectPm_block_invoke;
  v106 = (const char *)&unk_189BB86A0;
  *(void *)&v107 = type;
  *((void *)&v107 + 1) = v19;
  nw_hash_table_apply(v20, (uint64_t)v105);
  node = *((void *)v95 + 3);
  if (!node) {
    goto LABEL_26;
  }
LABEL_15:
  os_log_type_t v22 = *(void *)(node + 16);
  extra = (void *)nw_hash_node_get_extra(node);
LABEL_31:
  _Block_object_dispose(type, 8);

  if (extra)
  {
    *((void *)v18 + 4) = 0LL;
    os_log_type_t v29 = (char **)extra[14];
    *((void *)v18 + 5) = v29;
    *os_log_type_t v29 = v18;
    extra[14] = v18 + 32;
    if ((v17[403] & 0x20) != 0 || !a6 || !extra[13]) {
      goto LABEL_58;
    }
    if ((v17[405] & 0x80000000) == 0 && gLogDatapath)
    {
      __nwlog_obj();
      __int16 v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v105 = 136446978;
        *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
        *(_WORD *)&v105[12] = 2082;
        *(void *)&v105[14] = v17 + 407;
        *(_WORD *)&v105[22] = 2080;
        v106 = " ";
        LOWORD(v107) = 2048;
        *(void *)((char *)&v107 + 2) = v22;
        _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFinalizing outbound frames for %lx (one-off)",  v105,  0x2Au);
      }
    }

    os_log_type_t v30 = extra[4];
    if (v30)
    {
      if (*(_UNKNOWN **)(v30 + 40) == &nw_protocol_ref_counted_handle)
      {
        id v33 = *(void *)(v30 + 88);
        if (v33) {
          *(void *)(v30 + 88) = v33 + 1;
        }
        os_log_type_t v31 = -1;
      }

      else
      {
        os_log_type_t v31 = 0;
      }

      *(void *)buf = v30;
      buf[8] = v31;
      id v34 = *(void *)(v30 + 24);
      if (v34)
      {
        os_log_type_t v35 = *(void (**)(uint64_t, void *))(v34 + 96);
        if (v35)
        {
          v35(v30, extra + 13);
          if ((buf[8] & 1) == 0) {
            goto LABEL_58;
          }
          goto LABEL_57;
        }
      }

      v91 = v31;
      __nwlog_obj();
      v53 = (void *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = *(const char **)(v30 + 16);
      *(_DWORD *)v105 = 136446722;
      *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
      if (!v54) {
        os_log_type_t v54 = "invalid";
      }
      *(_WORD *)&v105[12] = 2082;
      *(void *)&v105[14] = v54;
      *(_WORD *)&v105[22] = 2048;
      v106 = (const char *)v30;
      BOOL v55 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v93 = 0;
      if (__nwlog_fault(v55, type, &v93))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v57 = type[0];
          if (os_log_type_enabled(v56, type[0]))
          {
            BOOL v58 = *(const char **)(v30 + 16);
            if (!v58) {
              BOOL v58 = "invalid";
            }
            *(_DWORD *)v105 = 136446722;
            *(void *)&v105[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&v105[12] = 2082;
            *(void *)&v105[14] = v58;
            *(_WORD *)&v105[22] = 2048;
            v106 = (const char *)v30;
            _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback",  v105,  0x20u);
          }

            if ((v9[405] & 0x80000000) == 0 && gLogDatapath)
            {
              __nwlog_obj();
              v130 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v130, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v9 + 407;
                *(_WORD *)&buf[22] = 2080;
                v166 = " ";
                _os_log_impl( &dword_181A5C000,  v130,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sRemove input handler",  buf,  0x20u);
              }
            }

            if (a1->default_input_handler != a2) {
              goto LABEL_306;
            }
            if (a2)
            {
              if (a2->handle == &nw_protocol_ref_counted_handle)
              {
                v106 = a2[1].callbacks;
                if (v106)
                {
                  v107 = (nw_protocol_callbacks *)((char *)v106 - 1);
                  a2[1].callbacks = v107;
                  if (!v107)
                  {
                    v108 = *(void (***)(void))a2[1].flow_id;
                    if (v108)
                    {
                      *(void *)a2[1].flow_id = 0LL;
                      v108[2](v108);
                      _Block_release(v108);
                    }

                    if ((a2[1].flow_id[8] & 1) != 0)
                    {
                      v109 = *(const void **)a2[1].flow_id;
                      if (v109) {
                        _Block_release(v109);
                      }
                    }

                    free(a2);
                  }
                }
              }

              a1->default_input_handler = 0LL;
            }

            if (gLogDatapath)
            {
              __nwlog_obj();
              v140 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v140, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
                _os_log_impl(&dword_181A5C000, v140, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
              }
            }

            v96 = MEMORY[0x1895F87A8];
            *(void *)buf = MEMORY[0x1895F87A8];
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_11356;
            v166 = (const char *)&__block_descriptor_41_e31_B16__0__NSObject_OS_nw_frame__8l;
            *(void *)v167 = v9 + 208;
            v167[8] = 0;
            v97 = *((void *)v9 + 26);
            do
            {
              if (!v97) {
                break;
              }
              v98 = *(void *)(v97 + 32);
              v99 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
              v97 = v98;
            }

            while ((v99 & 1) != 0);
            if (gLogDatapath)
            {
              __nwlog_obj();
              v141 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
                _os_log_impl(&dword_181A5C000, v141, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
              }
            }

            *(void *)buf = v96;
            *(void *)&buf[8] = 3221225472LL;
            *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_11356;
            v166 = (const char *)&__block_descriptor_41_e31_B16__0__NSObject_OS_nw_frame__8l;
            *(void *)v167 = v9 + 184;
            v167[8] = 0;
            v100 = *((void *)v9 + 23);
            do
            {
              if (!v100) {
                break;
              }
              v101 = *(void *)(v100 + 32);
              v102 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
              v100 = v101;
            }

            while ((v102 & 1) != 0);
            output_handler = a1->output_handler;
            if (!output_handler)
            {
LABEL_253:
              if ((_DWORD)a3) {
                nw_protocol_implementation_teardown((NWConcrete_nw_protocol_instance *)v9);
              }
              goto LABEL_255;
            }

            v104 = output_handler->handle;
            if (v104 == &nw_protocol_ref_counted_handle)
            {
              v110 = output_handler[1].callbacks;
              if (v110) {
                output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v110->add_input_handler + 1);
              }
              v105 = -1;
            }

            else
            {
              v105 = 0;
            }

            *(void *)v170 = output_handler;
            v170[8] = v105;
            v111 = a1->handle;
            if (v111 == &nw_protocol_ref_counted_handle)
            {
              v113 = a1[1].callbacks;
              if (v113) {
                a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v113->add_input_handler + 1);
              }
              v112 = -1;
            }

            else
            {
              v112 = 0;
            }

            v163 = a1;
            v164 = v112;
            v114 = output_handler->callbacks;
            if (v114)
            {
              remove_input_handler = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t))v114->remove_input_handler;
              if (remove_input_handler)
              {
                v116 = remove_input_handler(output_handler, a1, a3);
                if (v111 != &nw_protocol_ref_counted_handle) {
                  goto LABEL_226;
                }
                goto LABEL_225;
              }
            }

            __nwlog_obj();
            v134 = (void *)objc_claimAutoreleasedReturnValue();
            name = output_handler->identifier->name;
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
            if (!name) {
              name = "invalid";
            }
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = name;
            *(_WORD *)&buf[22] = 2048;
            v166 = (const char *)output_handler;
            v136 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v161 = 0;
            if (__nwlog_fault(v136, &type, &v161))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v137 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                v138 = type;
                if (os_log_type_enabled(v137, type))
                {
                  v139 = output_handler->identifier->name;
                  if (!v139) {
                    v139 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v139;
                  *(_WORD *)&buf[22] = 2048;
                  v166 = (const char *)output_handler;
                  _os_log_impl( &dword_181A5C000,  v137,  v138,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback",  buf,  0x20u);
                }

                uint64_t v25 = v16;
                if (v82) {
                  free(v82);
                }
                goto LABEL_191;
              }

              __nwlog_obj();
              v64 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
              os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v115) = 0;
              if (__nwlog_fault(v59, type, &v115))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v65 = type[0];
                  if (os_log_type_enabled(v60, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                    _os_log_impl( &dword_181A5C000,  v60,  v65,  "%{public}s called with null instance->parent_definition->extended_state",  buf,  0xCu);
                  }

      free(v61);
      goto LABEL_190;
    }

    __nwlog_obj();
    os_log_type_t v60 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v116 = "nw_necp_append_tlv";
    v61 = (char *)_os_log_send_and_compose_impl();

    v111 = OS_LOG_TYPE_ERROR;
    v110 = 0;
    if (v111 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v63 = v111;
      if (os_log_type_enabled(v62, v111))
      {
        *(_DWORD *)buf = 136446210;
        v116 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v62, v63, "%{public}s called with null tlv_start", buf, 0xCu);
      }
    }

    else if (v110)
    {
      v77 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v78 = v111;
      v79 = os_log_type_enabled(v62, v111);
      if (v77)
      {
        if (v79)
        {
          *(_DWORD *)buf = 136446466;
          v116 = "nw_necp_append_tlv";
          v117 = 2082;
          v118 = (size_t)v77;
          _os_log_impl( &dword_181A5C000,  v62,  v78,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v77);
        goto LABEL_188;
      }

      if (v79)
      {
        *(_DWORD *)buf = 136446210;
        v116 = "nw_necp_append_tlv";
        _os_log_impl(&dword_181A5C000, v62, v78, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v95 = v111;
      if (os_log_type_enabled(v62, v111))
      {
        *(_DWORD *)buf = 136446210;
        v116 = "nw_necp_append_tlv";
        _os_log_impl( &dword_181A5C000,  v62,  v95,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
      }
    }

          if (v71) {
            free(v71);
          }
          uint64_t v14 = v70;
          if (!gLogDatapath)
          {
LABEL_90:
            *(void *)buf = v4;
            *(void *)&buf[8] = 0x40000000LL;
            *(void *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_39794;
            v140 = (uint64_t)&__block_descriptor_tmp_57_39795;
            v141[0] = 0;
            os_log_type_t v54 = *(void *)(v2 + 664);
            do
            {
              if (!v54) {
                break;
              }
              BOOL v55 = *(void *)(v54 + 16);
              v56 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
              os_log_type_t v54 = v55;
            }

            while ((v56 & 1) != 0);
            if (!*(void *)(v2 + 664))
            {
LABEL_94:
              nw_frame_cache_destroy(v14);
              os_log_type_t v57 = *(void **)(v2 + 528);
              if (v57)
              {
                BOOL v58 = *(void **)(v2 + 544);
                if (v58) {
                  nw_association_unregister(v57, v58);
                }
              }

              os_log_type_t v59 = *(void **)(v2 + 800);
              if (v59)
              {
                free(v59);
                *(void *)(v2 + 800) = 0LL;
              }

              *(_DWORD *)(v2 + 840) = 0;
              os_log_type_t v60 = *(void **)(v2 + 808);
              if (v60)
              {
                free(v60);
                *(void *)(v2 + 808) = 0LL;
              }

              *(_DWORD *)(v2 + 844) = 0;
              v61 = *(void **)(v2 + 816);
              if (v61)
              {
                free(v61);
                *(void *)(v2 + 816) = 0LL;
              }

              *(_DWORD *)(v2 + 848) = 0;
              id v62 = *(void **)(v2 + 824);
              if (v62)
              {
                free(v62);
                *(void *)(v2 + 824) = 0LL;
              }

              *(_DWORD *)(v2 + 852) = 0;
              char v63 = *(void **)(v2 + 832);
              if (v63)
              {
                free(v63);
                *(void *)(v2 + 832) = 0LL;
              }

              *(_DWORD *)(v2 + 856) = 0;
              (*(void (**)(void, void))(*(void *)(v2 + 608) + 16LL))(*(void *)(v2 + 608), 0LL);
              v64 = *(const void **)(v2 + 608);
              if (v64)
              {
                _Block_release(v64);
                *(void *)(v2 + 608) = 0LL;
              }

              nw_http1_connection::~nw_http1_connection((nw_http1_connection *)v2);
              free(v65);
              if (!*(_DWORD *)(v3 + 336) && !*(_DWORD *)(v3 + 344)) {
                nw_protocol_http1_destroy(v3, v3);
              }
              return;
            }

            v75 = v14;
            __nwlog_obj();
            v144 = 136446210;
            v145 = "nw_protocol_finalize_master_frame_array";
            v76 = (char *)_os_log_send_and_compose_impl();
            v134 = OS_LOG_TYPE_ERROR;
            v133 = 0;
            if (__nwlog_fault(v76, &v134, &v133))
            {
              if (v134 == OS_LOG_TYPE_FAULT)
              {
                v77 = (os_log_s *)__nwlog_obj();
                v78 = v134;
                if (os_log_type_enabled(v77, v134))
                {
                  v144 = 136446210;
                  v145 = "nw_protocol_finalize_master_frame_array";
                  v79 = "%{public}s frame array is not empty after finalize";
LABEL_205:
                  _os_log_impl(&dword_181A5C000, v77, v78, v79, (uint8_t *)&v144, 0xCu);
                }
              }

              else if (v133)
              {
                v119 = (char *)__nw_create_backtrace_string();
                v77 = (os_log_s *)__nwlog_obj();
                v78 = v134;
                v120 = os_log_type_enabled(v77, v134);
                if (v119)
                {
                  if (v120)
                  {
                    v144 = 136446466;
                    v145 = "nw_protocol_finalize_master_frame_array";
                    v146 = 2082;
                    v147 = v119;
                    _os_log_impl( &dword_181A5C000,  v77,  v78,  "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s",  (uint8_t *)&v144,  0x16u);
                  }

                  free(v119);
                  goto LABEL_206;
                }

                if (v120)
                {
                  v144 = 136446210;
                  v145 = "nw_protocol_finalize_master_frame_array";
                  v79 = "%{public}s frame array is not empty after finalize, no backtrace";
                  goto LABEL_205;
                }
              }

              else
              {
                v77 = (os_log_s *)__nwlog_obj();
                v78 = v134;
                if (os_log_type_enabled(v77, v134))
                {
                  v144 = 136446210;
                  v145 = "nw_protocol_finalize_master_frame_array";
                  v79 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
                  goto LABEL_205;
                }
              }
            }

    free(backtrace_string);
    goto LABEL_353;
  }

      os_release(v84);
      v48 = v148;
LABEL_190:
      if (v82) {
        os_release(v82);
      }
      type.sae_srcif = v81;
      type.sae_srcaddr = v60;
      if (v60) {
        sa_len = v60->sa_len;
      }
      else {
        sa_len = 0;
      }
      v93 = v152;
      type.sae_srcaddrlen = sa_len;
      type.sae_dstaddr = v41;
      type.sae_dstaddrlen = v41->sa_len;
      if ((*(_WORD *)v5 & 0x100) != 0)
      {
        if ((*(_WORD *)v5 & 0x80) != 0) {
          goto LABEL_207;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v98 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_207;
        }
        v99 = *(_DWORD *)&a1[4].flow_id[12];
        *(_DWORD *)buf = 136448258;
        *(void *)&uint8_t buf[4] = "nw_socket_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v170) = v99;
        WORD2(v170) = 1024;
        *(_DWORD *)((char *)&v170 + 6) = type.sae_srcif;
        WORD5(v170) = 1040;
        HIDWORD(v170) = type.sae_srcaddrlen;
        *(_WORD *)object = 2096;
        *(void *)&object[2] = type.sae_srcaddr;
        LOWORD(v172) = 1040;
        *(_DWORD *)((char *)&v172 + 2) = type.sae_dstaddrlen;
        WORD3(v172) = 2096;
        *((void *)&v172 + 1) = type.sae_dstaddr;
        v173 = 1024;
        LODWORD(sae_dstaddr) = v85;
        v96 = (os_log_s *)v98;
        v97 = OS_LOG_TYPE_DEFAULT;
      }

      else
      {
        if ((*(_WORD *)v5 & 0x80) != 0) {
          goto LABEL_207;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v94 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_207;
        }
        v95 = *(_DWORD *)&a1[4].flow_id[12];
        *(_DWORD *)buf = 136448258;
        *(void *)&uint8_t buf[4] = "nw_socket_connect";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v170) = v95;
        WORD2(v170) = 1024;
        *(_DWORD *)((char *)&v170 + 6) = type.sae_srcif;
        WORD5(v170) = 1040;
        HIDWORD(v170) = type.sae_srcaddrlen;
        *(_WORD *)object = 2096;
        *(void *)&object[2] = type.sae_srcaddr;
        LOWORD(v172) = 1040;
        *(_DWORD *)((char *)&v172 + 2) = type.sae_dstaddrlen;
        WORD3(v172) = 2096;
        *((void *)&v172 + 1) = type.sae_dstaddr;
        v173 = 1024;
        LODWORD(sae_dstaddr) = v85;
        v96 = (os_log_s *)v94;
        v97 = OS_LOG_TYPE_DEBUG;
      }

      _os_log_impl( &dword_181A5C000,  v96,  v97,  "%{public}s %{public}s Calling connectx(%d, [srcif=%d, srcaddr=%{network:sockaddr}.*P, dstaddr=%{network:sockaddr }.*P], SAE_ASSOCID_ANY, %#x, NULL, 0, NULL, SAE_CONNID_ANY)",  buf,  0x48u);
LABEL_207:
      os_log_type_t v57 = connectx(*(_DWORD *)&a1[4].flow_id[12], &type, 0, v85, 0LL, 0, 0LL, 0LL);
      BOOL v58 = 0LL;
      if (v57 < 0)
      {
        BOOL v58 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if ((_DWORD)v58 != 36)
        {
          v100 = a1[2].output_handler;
          v155[0] = MEMORY[0x1895F87A8];
          v155[1] = 0x40000000LL;
          v155[2] = ___ZL17nw_socket_connectP11nw_protocolS0__block_invoke;
          v155[3] = &__block_descriptor_tmp_26_64978;
          v155[4] = v153;
          fd = nw_fd_wrapper_get_fd(v100, v155);
          is_guarded = nw_fd_wrapper_is_guarded(a1[2].output_handler);
          v103 = " (guarded, corrupt)";
          if (fd) {
            v103 = " (guarded)";
          }
          v104 = " (corrupt)";
          if (fd) {
            v104 = "";
          }
          if (is_guarded) {
            v105 = v103;
          }
          else {
            v105 = v104;
          }
          if ((*(_WORD *)v5 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v106 = (os_log_s *)gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
            {
              v107 = *(_DWORD *)&a1[4].flow_id[12];
              *(_DWORD *)buf = 136448771;
              *(void *)&uint8_t buf[4] = "nw_socket_connect";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = (char *)a1 + 404;
              *(_WORD *)&buf[22] = 1024;
              LODWORD(v170) = v107;
              WORD2(v170) = 2082;
              *(void *)((char *)&v170 + 6) = v105;
              HIWORD(v170) = 1024;
              *(_DWORD *)object = type.sae_srcif;
              *(_WORD *)&object[4] = 1040;
              *(_DWORD *)&object[6] = type.sae_srcaddrlen;
              LOWORD(v172) = 2101;
              *(void *)((char *)&v172 + 2) = type.sae_srcaddr;
              WORD5(v172) = 1040;
              HIDWORD(v172) = type.sae_dstaddrlen;
              v173 = 2101;
              sae_dstaddr = type.sae_dstaddr;
              v175 = 1024;
              v176 = v85;
              v177 = 1024;
              v178 = v58;
              _os_log_impl( &dword_181A5C000,  v106,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s connectx(%d%{public}s, [srcif=%d, srcaddr=%{sensitive,network:sockaddr}.*P, dstadd r=%{sensitive,network:sockaddr}.*P], SAE_ASSOCID_ANY, %#x, NULL, 0, NULL, SAE_CONNID_ANY) failed: %{darwin.errno}d",  buf,  0x58u);
            }
          }

          v93 = v152;
        }
      }

      v108 = v150;
      if (!v93) {
        v108 = 1;
      }
      if ((v108 & 1) == 0) {
        os_release(v93);
      }
      if (v151 && (v149 & v48) != 0) {
        os_release(v151);
      }
      os_log_type_t v59 = "connectx";
LABEL_230:
      v109 = a1[6].flow_id[15];
      v110 = *(unsigned __int16 *)v5;
      *(_WORD *)id v5 = v110 | 2;
      if (!v57)
      {
        v115 = v110 | (v109 << 16);
        if ((v115 & 0x8000) == 0)
        {
          a1[6].flow_id[15] = BYTE2(v115);
          *(_WORD *)id v5 = v115 | 6;
        }

        v53 = 1LL;
        nw_socket_add_socket_events((uint64_t)v153, 1, HIDWORD(a1[4].identifier), 1);
        nw_socket_fillout_socket_properties(a1);
        nw_socket_internal_connect(v153);
        return v53;
      }

      goto LABEL_231;
    }

                if (v108) {
                  free(v108);
                }
                goto LABEL_191;
              }

              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              char v63 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
              {
                v99 = nw_endpoint_handler_get_id_string(v45);
                v100 = nw_endpoint_handler_dry_run_string(v45);
                v101 = nw_endpoint_handler_copy_endpoint(v45);
                v102 = nw_endpoint_get_logging_description(v101);
                v103 = v45;
                v104 = nw_endpoint_handler_state_string(v45);
                v105 = nw_endpoint_handler_mode_string(v103);
                v106 = nw_endpoint_handler_copy_current_path(v103);
                *(_DWORD *)buf = 136447746;
                v355 = "nw_endpoint_start_tls_while_connected";
                v356 = 2082;
                v357 = (char *)v99;
                v358 = 2082;
                v359 = v100;
                v360 = 2082;
                v361 = (void *)v102;
                v362 = 2082;
                v363 = v104;
                v364 = 2082;
                v365 = v105;
                v366 = 2114;
                v367 = v106;
                _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find TLS protocol handler",  buf,  0x48u);
              }
            }

            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              char v63 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
              {
                v91 = nw_endpoint_handler_get_id_string(v45);
                v92 = nw_endpoint_handler_dry_run_string(v45);
                v93 = nw_endpoint_handler_copy_endpoint(v45);
                v94 = nw_endpoint_get_logging_description(v93);
                v95 = v45;
                v96 = nw_endpoint_handler_state_string(v45);
                v97 = nw_endpoint_handler_mode_string(v45);
                v98 = nw_endpoint_handler_copy_current_path(v95);
                *(_DWORD *)buf = 136447746;
                v355 = "nw_endpoint_start_tls_while_connected";
                v356 = 2082;
                v357 = (char *)v91;
                v358 = 2082;
                v359 = v92;
                v360 = 2082;
                v361 = (void *)v94;
                v362 = 2082;
                v363 = v96;
                v364 = 2082;
                v365 = v97;
                v366 = 2114;
                v367 = v98;
                _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find TLS pr otocol identifier",  buf,  0x48u);
              }
            }
          }

          else
          {
            v74 = v44;
            v75 = (*((_BYTE *)v74 + 268) & 0x20) == 0;

            if (!v75) {
              goto LABEL_197;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            char v63 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
            {
              v76 = nw_endpoint_handler_get_id_string(v74);
              v77 = nw_endpoint_handler_dry_run_string(v74);
              v78 = nw_endpoint_handler_copy_endpoint(v74);
              v79 = nw_endpoint_get_logging_description(v78);
              v80 = nw_endpoint_handler_state_string(v74);
              v81 = nw_endpoint_handler_mode_string(v74);
              v82 = nw_endpoint_handler_copy_current_path(v74);
              *(_DWORD *)buf = 136447746;
              v355 = "nw_endpoint_start_tls_while_connected";
              v356 = 2082;
              v357 = (char *)v76;
              v358 = 2082;
              v359 = v77;
              v360 = 2082;
              v361 = (void *)v79;
              v362 = 2082;
              v363 = v80;
              v364 = 2082;
              v365 = v81;
              v366 = 2114;
              v367 = v82;
              _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No previous output handler on flow",  buf,  0x48u);
            }
          }
        }

        else
        {
          v61 = v44;
          id v62 = (*((_BYTE *)v61 + 268) & 0x20) == 0;

          if (!v62) {
            goto LABEL_197;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          char v63 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          {
            v64 = v61;

            v65 = v64;
            v66 = (*((_BYTE *)v61 + 268) & 1) == 0;

            if (v66) {
              __int16 v67 = "";
            }
            else {
              __int16 v67 = "dry-run ";
            }
            v68 = nw_endpoint_handler_copy_endpoint(v65);
            v69 = nw_endpoint_get_logging_description(v68);
            v70 = v65;
            v71 = v70;
            v72 = v39->state;
            else {
              v73 = off_189BBBBF0[v72];
            }

            v83 = v71;
            v84 = v83;
            v85 = "path";
            switch(v3[29])
            {
              case 0u:
                break;
              case 1u:
                v85 = "resolver";
                break;
              case 2u:
                v85 = nw_endpoint_flow_mode_string(v83[31]);
                break;
              case 3u:
                v85 = "proxy";
                break;
              case 4u:
                v85 = "fallback";
                break;
              case 5u:
                v85 = "transform";
                break;
              default:
                v85 = "unknown-mode";
                break;
            }

            v116 = v84;
            os_unfair_lock_lock((os_unfair_lock_t)v116 + 28);
            v117 = v116[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v116 + 28);

            *(_DWORD *)buf = 136447746;
            v355 = "nw_endpoint_start_tls_while_connected";
            v356 = 2082;
            v357 = (char *)(v64 + 21);
            v358 = 2082;
            v359 = v67;
            v360 = 2082;
            v361 = (void *)v69;
            v362 = 2082;
            v363 = v73;
            v364 = 2082;
            v365 = v85;
            v366 = 2114;
            v367 = v117;
            _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] TLS is not configured",  buf,  0x48u);
          }
        }

        goto LABEL_197;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v7 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v207 = nw_endpoint_handler_get_id_string(v3);
        v208 = nw_endpoint_handler_dry_run_string(v3);
        v209 = nw_endpoint_handler_copy_endpoint(v3);
        v210 = nw_endpoint_get_logging_description(v209);
        v211 = nw_endpoint_handler_state_string(v3);
        v212 = nw_endpoint_handler_mode_string(v3);
        v213 = nw_endpoint_handler_copy_current_path(v3);
        *(_DWORD *)buf = 136447746;
        v355 = "nw_endpoint_start_tls_while_connected";
        v356 = 2082;
        v357 = (char *)v207;
        v358 = 2082;
        v359 = v208;
        v360 = 2082;
        v361 = (void *)v210;
        v362 = 2082;
        v363 = v211;
        v364 = 2082;
        v365 = v212;
        v366 = 2114;
        v367 = v213;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);
      }
    }

    else
    {
      id v5 = v3;
      id v6 = *((_BYTE *)v5 + 268);

      if ((v6 & 0x20) != 0) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v7 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        BOOL v8 = v5;

        uint32_t v9 = v8;
        int v10 = *((_BYTE *)v5 + 268);

        if ((v10 & 1) != 0) {
          uint64_t v11 = "dry-run ";
        }
        else {
          uint64_t v11 = "";
        }
        uint64_t v12 = nw_endpoint_handler_copy_endpoint(v9);
        uint64_t v13 = nw_endpoint_get_logging_description(v12);
        uint64_t v14 = (char *)(v8 + 42);
        uint64_t v15 = v9;
        BOOL v16 = v15;
        uint64_t v17 = v15[30];
        else {
          BOOL v18 = off_189BBBBF0[v17];
        }

        os_log_type_t v30 = v16;
        os_log_type_t v31 = v30;
        v343 = v12;
        char v32 = "path";
        switch(v3[29])
        {
          case 0u:
            break;
          case 1u:
            char v32 = "resolver";
            break;
          case 2u:
            char v32 = nw_endpoint_flow_mode_string(v30[31]);
            break;
          case 3u:
            char v32 = "proxy";
            break;
          case 4u:
            char v32 = "fallback";
            break;
          case 5u:
            char v32 = "transform";
            break;
          default:
            char v32 = "unknown-mode";
            break;
        }

        __int16 v36 = v31;
        os_unfair_lock_lock((os_unfair_lock_t)v36 + 28);
        uint64_t v37 = v36[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v36 + 28);

        __int16 v38 = v37;
        *(_DWORD *)buf = 136447746;
        v355 = "nw_endpoint_start_tls_while_connected";
        v356 = 2082;
        v357 = v14;
        v358 = 2082;
        v359 = v11;
        v360 = 2082;
        v361 = (void *)v13;
        v362 = 2082;
        v363 = v18;
        v364 = 2082;
        v365 = v32;
        v366 = 2114;
        v367 = v38;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);
      }
    }

    goto LABEL_45;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v19 = (id)gLogObj;
  uint64_t v20 = v2;
  else {
    char v21 = off_189BBBBC0[v4];
  }
  *(_DWORD *)buf = 136446722;
  v355 = "nw_endpoint_start_tls_while_connected";
  v356 = 2082;
  v357 = (char *)v21;
  v358 = 2082;
  v359 = "flow";
  os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v350) = 0;
  if (__nwlog_fault(v22, type, &v350))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v23 = (os_log_s *)(id)gLogObj;
      int v24 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        else {
          uint64_t v25 = off_189BBBBC0[v4];
        }
        *(_DWORD *)buf = 136446722;
        v355 = "nw_endpoint_start_tls_while_connected";
        v356 = 2082;
        v357 = (char *)v25;
        v358 = 2082;
        v359 = "flow";
        _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
      }
    }

    else if ((_BYTE)v350)
    {
      id v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v23 = (os_log_s *)(id)gLogObj;
      uint64_t v27 = type[0];
      BOOL v28 = os_log_type_enabled(v23, type[0]);
      if (v26)
      {
        if (v28)
        {
          else {
            os_log_type_t v29 = off_189BBBBC0[v4];
          }
          *(_DWORD *)buf = 136446978;
          v355 = "nw_endpoint_start_tls_while_connected";
          v356 = 2082;
          v357 = (char *)v29;
          v358 = 2082;
          v359 = "flow";
          v360 = 2082;
          v361 = v26;
          _os_log_impl( &dword_181A5C000,  v23,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v26);
        if (!v22) {
          goto LABEL_95;
        }
        goto LABEL_94;
      }

      if (v28)
      {
        else {
          os_log_type_t v35 = off_189BBBBC0[v4];
        }
        *(_DWORD *)buf = 136446722;
        v355 = "nw_endpoint_start_tls_while_connected";
        v356 = 2082;
        v357 = (char *)v35;
        v358 = 2082;
        v359 = "flow";
        _os_log_impl( &dword_181A5C000,  v23,  v27,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v23 = (os_log_s *)(id)gLogObj;
      id v33 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        else {
          id v34 = off_189BBBBC0[v4];
        }
        *(_DWORD *)buf = 136446722;
        v355 = "nw_endpoint_start_tls_while_connected";
        v356 = 2082;
        v357 = (char *)v34;
        v358 = 2082;
        v359 = "flow";
        _os_log_impl( &dword_181A5C000,  v23,  v33,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

  if (v22) {
LABEL_94:
  }
    free(v22);
LABEL_95:
  started = 0LL;
LABEL_201:

  return started;
}

                  free(v87);
                  if (!v52)
                  {
LABEL_208:
                    if (((*(unsigned __int16 *)(v19 + 188) | (*(unsigned __int8 *)(v19 + 190) << 16)) & 0x80000) == 0
                      && gLogDatapath)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                      }
                      v98 = (os_log_s *)gconnectionLogObj;
                      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                      {
                        v100 = *(_DWORD *)(v19 + 176);
                        v99 = *(_DWORD *)(v19 + 180);
                        *(_DWORD *)buf = 136447490;
                        v111 = "nw_protocol_http2_frame_output_finalizer";
                        v112 = 2082;
                        *(void *)v113 = v19 + 191;
                        *(_WORD *)&v113[8] = 2080;
                        *(void *)&v113[10] = " ";
                        *(_WORD *)&v113[18] = 1024;
                        *(_DWORD *)&v113[20] = v99;
                        *(_WORD *)&v113[24] = 1024;
                        *(_DWORD *)&v113[26] = v100;
                        *(_WORD *)&v113[30] = 2048;
                        *(void *)&v113[32] = a1;
                        _os_log_impl( &dword_181A5C000,  v98,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> cannot send on a new stream without outbound metadata for frame %p",  buf,  0x36u);
                      }
                    }

                    v91 = *(unsigned __int16 *)(v19 + 188);
                    v92 = v91 | (*(unsigned __int8 *)(v19 + 190) << 16);
                    if ((v91 & 0x40) != 0) {
                      return;
                    }
                    *(_BYTE *)(v19 + 190) = BYTE2(v92);
                    *(_WORD *)(v19 + 188) = v92 | 0x40;
                    nw_protocol_error(v17, v11);
                    nw_protocol_disconnected(v17, v11);
                    goto LABEL_142;
                  }

    if (v70) {
      free(v70);
    }
    uint64_t v13 = 0LL;
    goto LABEL_23;
  }

  uint32_t v9 = default_input_handler->handle;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    int v10 = default_input_handler[1].callbacks;
    if (v10) {
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v10->add_input_handler + 1);
    }
  }

  uint64_t v11 = default_input_handler->callbacks;
  if (v11)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v11->get_parameters;
    if (get_parameters)
    {
      uint64_t v13 = (void *)get_parameters(default_input_handler);
      if (v9 != &nw_protocol_ref_counted_handle) {
        goto LABEL_23;
      }
      goto LABEL_22;
    }
  }

  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
  if (!name) {
    name = "invalid";
  }
  v86 = 2082;
  v87 = (char *)name;
  v88 = 2048;
  v89 = (const char *)default_input_handler;
  v61 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v83 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v62 = (os_log_s *)__nwlog_obj();
    char v63 = type;
    if (!os_log_type_enabled(v62, type)) {
      goto LABEL_180;
    }
    v64 = default_input_handler->identifier->name;
    if (!v64) {
      v64 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v64;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_179:
    _os_log_impl(&dword_181A5C000, v62, v63, v65, buf, 0x20u);
    goto LABEL_180;
  }

  if (!v83)
  {
    id v62 = (os_log_s *)__nwlog_obj();
    char v63 = type;
    if (!os_log_type_enabled(v62, type)) {
      goto LABEL_180;
    }
    v79 = default_input_handler->identifier->name;
    if (!v79) {
      v79 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v79;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
    goto LABEL_179;
  }

  v82 = v9;
  v74 = (char *)__nw_create_backtrace_string();
  id v62 = (os_log_s *)__nwlog_obj();
  char v63 = type;
  v75 = os_log_type_enabled(v62, type);
  if (!v74)
  {
    uint32_t v9 = v82;
    if (!v75) {
      goto LABEL_180;
    }
    v81 = default_input_handler->identifier->name;
    if (!v81) {
      v81 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v81;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
    goto LABEL_179;
  }

  if (v75)
  {
    v76 = default_input_handler->identifier->name;
    if (!v76) {
      v76 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_parameters";
    v86 = 2082;
    v87 = (char *)v76;
    v88 = 2048;
    v89 = (const char *)default_input_handler;
    v90 = 2082;
    p_output_handler = v74;
    _os_log_impl( &dword_181A5C000,  v62,  v63,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v74);
  uint32_t v9 = v82;
LABEL_180:
  if (v61) {
    free(v61);
  }
  uint64_t v13 = 0LL;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
LABEL_22:
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      BOOL v43 = default_input_handler[1].callbacks;
      if (v43)
      {
        os_log_type_t v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
        default_input_handler[1].callbacks = v44;
        if (!v44)
        {
          os_log_type_t v45 = *(void (***)(void))default_input_handler[1].flow_id;
          if (v45)
          {
            *(void *)default_input_handler[1].flow_id = 0LL;
            v45[2](v45);
            _Block_release(v45);
          }

          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v46 = *(const void **)default_input_handler[1].flow_id;
            if (v46) {
              _Block_release(v46);
            }
          }

          free(default_input_handler);
        }
      }
    }
  }

LABEL_81:
                v81 = (void ***)nw_array_create();
                if (v81 != v62)
                {
                  v82 = v81;
                  std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( (uint64_t)(v81 + 2),  v62[2],  v62[3],  v62[3] - v62[2]);
                  id v62 = v82;
                }

                v68 = (id *)a1[21];
                a1[21] = v62;
                goto LABEL_84;
              }

    if (v42) {
      free(v42);
    }
    goto LABEL_52;
  }

  if (*((_DWORD *)v3 + 29) != 2 || !nw_endpoint_flow_should_not_use_path(v3[31]))
  {
    if (v4[7])
    {
      nw_path_get_client_id(v4[8], a2);
      goto LABEL_52;
    }

    int v10 = v4;
    uint64_t v11 = v10;
    uint64_t v12 = v10[4];
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = v13[12];

      if ((v14 & 0x4000000000LL) != 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v15 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v11);
          v49 = nw_endpoint_handler_dry_run_string(v11);
          os_log_type_t v50 = nw_endpoint_handler_copy_endpoint(v11);
          logging_description = nw_endpoint_get_logging_description(v50);
          os_log_type_t v52 = nw_endpoint_handler_state_string(v11);
          v53 = nw_endpoint_handler_mode_string(v11);
          os_log_type_t v54 = nw_endpoint_handler_copy_current_path(v11);
          *(_DWORD *)buf = 136447746;
          v69 = "nw_endpoint_handler_get_client_id";
          v70 = 2082;
          v71 = (void *)id_string;
          v72 = 2082;
          v73 = v49;
          v74 = 2082;
          v75 = logging_description;
          v76 = 2082;
          v77 = v52;
          v78 = 2082;
          v79 = v53;
          v80 = 2114;
          v81 = v54;
          _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find association, no client ID",  buf,  0x48u);
        }

        goto LABEL_44;
      }

      if ((*((_BYTE *)v11 + 268) & 0x20) != 0) {
        goto LABEL_52;
      }
    }

    else
    {

      if ((*((_BYTE *)v11 + 268) & 0x20) != 0) {
        goto LABEL_52;
      }
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v15 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      if ((*((_BYTE *)v11 + 268) & 1) != 0) {
        BOOL v16 = "dry-run ";
      }
      else {
        BOOL v16 = "";
      }
      uint64_t v17 = nw_endpoint_handler_copy_endpoint(v11);
      BOOL v18 = nw_endpoint_get_logging_description(v17);
      uint64_t v19 = v11 + 21;
      uint64_t v20 = *((unsigned int *)v11 + 30);
      char v21 = v18;
      else {
        os_log_type_t v22 = off_189BBBBF0[v20];
      }
      v65 = v22;
      os_log_type_t v30 = v11;
      os_log_type_t v31 = v30;
      char v32 = "path";
      switch(*((_DWORD *)v4 + 29))
      {
        case 0:
          break;
        case 1:
          char v32 = "resolver";
          break;
        case 2:
          char v32 = nw_endpoint_flow_mode_string(*(void **)&v30[62]._os_unfair_lock_opaque);
          break;
        case 3:
          char v32 = "proxy";
          break;
        case 4:
          char v32 = "fallback";
          break;
        case 5:
          char v32 = "transform";
          break;
        default:
          char v32 = "unknown-mode";
          break;
      }

      os_log_type_t v35 = v31 + 28;
      __int16 v36 = v31;
      os_unfair_lock_lock(v31 + 28);
      uint64_t v37 = v36[8];
      os_unfair_lock_unlock(v35);

      *(_DWORD *)buf = 136447746;
      v69 = "nw_endpoint_handler_get_client_id";
      v70 = 2082;
      v71 = v19;
      v72 = 2082;
      v73 = v16;
      v74 = 2082;
      v75 = v21;
      v76 = 2082;
      v77 = v65;
      v78 = 2082;
      v79 = v32;
      v80 = 2114;
      v81 = v37;
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find association, no client ID",  buf,  0x48u);
    }

LABEL_17:
    if (!v6)
    {
LABEL_19:
      int v10 = 0LL;
      goto LABEL_20;
    }

        id v26 = (char *)v4 + 33;
        uint64_t v27 = *((_BYTE *)v4 + 33);
        if (((v159 ^ ((v27 & 2) == 0)) & 1) != 0) {
          goto LABEL_82;
        }
        if (!v159)
        {
          v89 = 0;
LABEL_87:
          v88 = 0;
          uint64_t v27 = v27 & 0xFD | v89;
          char *v26 = v27;
          if ((v27 & 4) != 0) {
            goto LABEL_100;
          }
          goto LABEL_88;
        }

      free(v20);
      goto LABEL_82;
    }

    __nwlog_obj();
    v94 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v109 = "networkd_privileged_set_agent_on_interface_internal";
    v95 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (__nwlog_fault(v95, &type, &v106))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v96 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v97 = type;
        if (os_log_type_enabled(v96, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          _os_log_impl(&dword_181A5C000, v96, v97, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }

      else if (v106)
      {
        v101 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v96 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v102 = type;
        v103 = os_log_type_enabled(v96, type);
        if (v101)
        {
          if (v103)
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v110 = 2082;
            *(void *)v111 = v101;
            _os_log_impl( &dword_181A5C000,  v96,  v102,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v101);
          goto LABEL_230;
        }

        if (v103)
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          _os_log_impl(&dword_181A5C000, v96, v102, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v96 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v105 = type;
        if (os_log_type_enabled(v96, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          _os_log_impl( &dword_181A5C000,  v96,  v105,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        free(backtrace_string);
        goto LABEL_107;
      }

      uint64_t v42 = os_channel_attr_set();
      if (v42)
      {
        __nwlog_obj();
        BOOL v43 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446722;
        v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
        v131 = 2112;
        *(void *)v132 = a1;
        *(_WORD *)&v132[8] = 1024;
        *(_DWORD *)&v132[10] = v42;
        uint64_t v37 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v127 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v44 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
            v131 = 2112;
            *(void *)v132 = a1;
            *(_WORD *)&v132[8] = 1024;
            *(_DWORD *)&v132[10] = v42;
            _os_log_impl( &dword_181A5C000,  v38,  v44,  "%{public}s %@: createChannel failed to set user-packet-pool attribute <err %d> ",  buf,  0x1Cu);
          }

          goto LABEL_106;
        }

        if (v127 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v71 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
            v131 = 2112;
            *(void *)v132 = a1;
            *(_WORD *)&v132[8] = 1024;
            *(_DWORD *)&v132[10] = v42;
            _os_log_impl( &dword_181A5C000,  v38,  v71,  "%{public}s %@: createChannel failed to set user-packet-pool attribute <err %d> , backtrace limit exceeded",  buf,  0x1Cu);
          }

          goto LABEL_106;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v62 = type[0];
        char v63 = os_log_type_enabled(v38, type[0]);
        if (!backtrace_string)
        {
          if (v63)
          {
            *(_DWORD *)buf = 136446722;
            v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
            v131 = 2112;
            *(void *)v132 = a1;
            *(_WORD *)&v132[8] = 1024;
            *(_DWORD *)&v132[10] = v42;
            _os_log_impl( &dword_181A5C000,  v38,  v62,  "%{public}s %@: createChannel failed to set user-packet-pool attribute <err %d> , no backtrace",  buf,  0x1Cu);
          }

          goto LABEL_106;
        }

        if (v63)
        {
          *(_DWORD *)buf = 136446978;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 2112;
          *(void *)v132 = a1;
          *(_WORD *)&v132[8] = 1024;
          *(_DWORD *)&v132[10] = v42;
          *(_WORD *)&v132[14] = 2082;
          *(void *)&v132[16] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v38,  v62,  "%{public}s %@: createChannel failed to set user-packet-pool attribute <err %d> , dumping backtrace:%{public}s",  buf,  0x26u);
        }

        goto LABEL_81;
      }

      if (*(_DWORD *)(a1 + 132) < 0x10000u)
      {
        extended = os_channel_create_extended();
        *(void *)(a1 + 152) = extended;
        if (extended)
        {
          fd = os_channel_get_fd();
          *(_DWORD *)(a1 + 168) = fd;
          if ((fd & 0x80000000) == 0)
          {
            v53 = *(void *)(a1 + 152);
            __nwlog_obj();
            os_log_type_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v55 = os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG);
            if (v53)
            {
              if (v55)
              {
                v56 = *(void *)(a1 + 24);
                os_log_type_t v57 = *(_DWORD *)(a1 + 168);
                *(_DWORD *)buf = 136447234;
                v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                v131 = 2080;
                *(void *)v132 = v56;
                *(_WORD *)&v132[8] = 1042;
                *(_DWORD *)&v132[10] = 16;
                *(_WORD *)&v132[14] = 2098;
                *(void *)&v132[16] = a1 + 115;
                *(_WORD *)&v132[24] = 1024;
                *(_DWORD *)&v132[26] = v57;
                BOOL v58 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] createChannel: created channel";
                os_log_type_t v59 = v54;
                os_log_type_t v60 = 44;
LABEL_118:
                _os_log_impl(&dword_181A5C000, v59, OS_LOG_TYPE_DEBUG, v58, buf, v60);
              }
            }

            else if (v55)
            {
              *(_DWORD *)buf = 136446466;
              v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
              v131 = 2114;
              *(void *)v132 = a1;
              BOOL v58 = "%{public}s [%{public}@] createChannel: created channel";
              os_log_type_t v59 = v54;
              os_log_type_t v60 = 22;
              goto LABEL_118;
            }

            *(void *)(a1 + 176) = os_channel_rx_ring();
            v81 = os_channel_tx_ring();
            *(void *)(a1 + 184) = v81;
            if (*(void *)(a1 + 176) && v81)
            {
              os_channel_read_attr();
              *(void *)os_log_type_t type = 0LL;
              os_channel_attr_get();
              *(_WORD *)(a1 + 172) = 0;
              __nwlog_obj();
              v98 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446466;
              v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
              v131 = 2112;
              *(void *)v132 = a1;
              v99 = (char *)_os_log_send_and_compose_impl();

              v127 = OS_LOG_TYPE_ERROR;
              v125 = 0;
              if (__nwlog_fault(v99, &v127, &v125))
              {
                if (v127 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v101 = v127;
                  if (os_log_type_enabled(v100, v127))
                  {
                    *(_DWORD *)buf = 136446466;
                    v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                    v131 = 2112;
                    *(void *)v132 = a1;
                    _os_log_impl( &dword_181A5C000,  v100,  v101,  "%{public}s %@: createChannel: channel slot size 0, clean up channel",  buf,  0x16u);
                  }
                }

                else if (v125)
                {
                  v109 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v110 = v127;
                  v111 = os_log_type_enabled(v100, v127);
                  if (v109)
                  {
                    if (v111)
                    {
                      *(_DWORD *)buf = 136446722;
                      v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                      v131 = 2112;
                      *(void *)v132 = a1;
                      *(_WORD *)&v132[8] = 2082;
                      *(void *)&v132[10] = v109;
                      _os_log_impl( &dword_181A5C000,  v100,  v110,  "%{public}s %@: createChannel: channel slot size 0, clean up channel, dumping backtrace:%{public}s",  buf,  0x20u);
                    }

                    free(v109);
                    goto LABEL_180;
                  }

                  if (v111)
                  {
                    *(_DWORD *)buf = 136446466;
                    v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                    v131 = 2112;
                    *(void *)v132 = a1;
                    _os_log_impl( &dword_181A5C000,  v100,  v110,  "%{public}s %@: createChannel: channel slot size 0, clean up channel, no backtrace",  buf,  0x16u);
                  }
                }

                else
                {
                  __nwlog_obj();
                  v100 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v114 = v127;
                  if (os_log_type_enabled(v100, v127))
                  {
                    *(_DWORD *)buf = 136446466;
                    v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
                    v131 = 2112;
                    *(void *)v132 = a1;
                    _os_log_impl( &dword_181A5C000,  v100,  v114,  "%{public}s %@: createChannel: channel slot size 0, clean up channel, backtrace limit exceeded",  buf,  0x16u);
                  }
                }
              }

    if (v39) {
      free(v39);
    }
    v231 = 0;
    uint64_t v25 = v225;
  }

  __int16 v38 = __CFADD__(v229, v25);
  v229 += v25;
  if (!v38) {
    goto LABEL_102;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v46 = v25;
  LODWORD(buf[0]) = 136446978;
  *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
  WORD2(buf[1]) = 2082;
  *(void *)((char *)&buf[1] + 6) = "received_bytes";
  HIWORD(buf[2]) = 2048;
  v261 = v25;
  LOWORD(v262[0]) = 2048;
  *(void *)((char *)v262 + 2) = v229;
  v47 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v258[0]) = 0;
  if (__nwlog_fault(v47, type, v258))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = gLogObj;
      v49 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = "received_bytes";
        HIWORD(buf[2]) = 2048;
        v261 = v46;
        LOWORD(v262[0]) = 2048;
        *(void *)((char *)v262 + 2) = v229;
        os_log_type_t v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_97:
        v53 = (os_log_s *)v48;
LABEL_98:
        _os_log_impl(&dword_181A5C000, v53, v49, v50, (uint8_t *)buf, 0x2Au);
      }
    }

    else if (LOBYTE(v258[0]))
    {
      v51 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v49 = type[0];
      v222 = (os_log_s *)gLogObj;
      os_log_type_t v52 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v51)
      {
        if (v52)
        {
          LODWORD(buf[0]) = 136447234;
          *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = "received_bytes";
          HIWORD(buf[2]) = 2048;
          v261 = v46;
          LOWORD(v262[0]) = 2048;
          *(void *)((char *)v262 + 2) = v229;
          WORD1(v262[1]) = 2082;
          *(void *)((char *)&v262[1] + 4) = v51;
          _os_log_impl( &dword_181A5C000,  v222,  v49,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x34u);
        }

        free(v51);
        goto LABEL_99;
      }

      if (v52)
      {
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = "received_bytes";
        HIWORD(buf[2]) = 2048;
        v261 = v46;
        LOWORD(v262[0]) = 2048;
        *(void *)((char *)v262 + 2) = v229;
        os_log_type_t v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        v53 = v222;
        goto LABEL_98;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = gLogObj;
      v49 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = "received_bytes";
        HIWORD(buf[2]) = 2048;
        v261 = v46;
        LOWORD(v262[0]) = 2048;
        *(void *)((char *)v262 + 2) = v229;
        os_log_type_t v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_97;
      }
    }
  }

  __nwlog_obj();
  id v62 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
  char v63 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v78 = 0;
  if (__nwlog_fault(v63, type, &v78))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v65 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl( &dword_181A5C000,  v64,  v65,  "%{public}s searching for a protocol to join requires a registered endpoint",  buf,  0xCu);
      }
    }

    else if (v78)
    {
      v66 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v67 = type[0];
      v68 = os_log_type_enabled(v64, type[0]);
      if (v66)
      {
        if (v68)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v66;
          _os_log_impl( &dword_181A5C000,  v64,  v67,  "%{public}s searching for a protocol to join requires a registered endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v66);
        goto LABEL_97;
      }

      if (v68)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl( &dword_181A5C000,  v64,  v67,  "%{public}s searching for a protocol to join requires a registered endpoint, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v69 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_search_for_instance_to_join";
        _os_log_impl( &dword_181A5C000,  v64,  v69,  "%{public}s searching for a protocol to join requires a registered endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

      free(v20);
      goto LABEL_9;
    }

    __nwlog_obj();
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_framer_protocol_connected";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    __int16 v39 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_framer_protocol_connected";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v39)
    {
      BOOL v28 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type[0];
      os_log_type_t v30 = os_log_type_enabled(v21, type[0]);
      if (v28)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v41 = "nw_framer_protocol_connected";
          uint64_t v42 = 2082;
          BOOL v43 = v28;
          _os_log_impl( &dword_181A5C000,  v21,  v29,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v28);
        goto LABEL_80;
      }

      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_framer_protocol_connected";
        _os_log_impl(&dword_181A5C000, v21, v29, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_framer_protocol_connected";
        _os_log_impl( &dword_181A5C000,  v21,  v35,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

        free(v27);
        goto LABEL_82;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl( &dword_181A5C000,  v28,  v40,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = v57;
      if (os_log_type_enabled(v28, v57))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_establishment_report_create_from_dictionary";
        _os_log_impl( &dword_181A5C000,  v28,  v46,  "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), backtrace limit exceeded",  buf,  0xCu);
      }
    }

  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 56LL)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    os_log_type_t v45 = (os_log_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
    {
      v46 = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
      v47 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_connection_group_extract_connection_for_message_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v46;
      *(_WORD *)&buf[18] = 2112;
      *(void *)&buf[20] = v47;
      _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] did not find connection %@, returning error",  buf,  0x1Cu);
    }
  }

  v48 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v13 = *(void **)(v48 + 40);
  *(void *)(v48 + 40) = 0LL;
LABEL_88:
}

    goto LABEL_82;
  }

  if (a2)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      char v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }

    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_11356;
    v66 = (const char *)&__block_descriptor_41_e31_B16__0__NSObject_OS_nw_frame__8l;
    *(void *)__int16 v67 = a2 + 104;
    v67[8] = 0;
    os_log_type_t v4 = *(void *)(a2 + 104);
    do
    {
      if (!v4) {
        break;
      }
      id v5 = *(void *)(v4 + 32);
      id v6 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      os_log_type_t v4 = v5;
    }

    while ((v6 & 1) != 0);
    id v7 = *(const char **)(a2 + 32);
    if (!v7) {
      goto LABEL_117;
    }
    BOOL v8 = (void *)*((void *)v7 + 5);
    if (v8 == &nw_protocol_ref_counted_handle)
    {
      int v10 = *((void *)v7 + 11);
      if (v10) {
        *((void *)v7 + 11) = v10 + 1;
      }
      uint32_t v9 = -1;
    }

    else
    {
      uint32_t v9 = 0;
    }

    *(void *)os_log_type_t type = v7;
    v64 = v9;
    uint64_t v11 = (void *)*((void *)v3 - 7);
    if (v11 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v13 = *((void *)v3 - 1);
      if (v13) {
        *((void *)v3 - 1) = v13 + 1;
      }
      uint64_t v12 = -1;
    }

    else
    {
      uint64_t v12 = 0;
    }

    v61 = v3 - 96;
    id v62 = v12;
    uint64_t v14 = *((void *)v7 + 3);
    if (v14)
    {
      uint64_t v15 = *(uint64_t (**)(const char *, char *, uint64_t))(v14 + 8);
      if (v15)
      {
        BOOL v16 = v15(v7, v3 - 96, 1LL);
        if (v11 != &nw_protocol_ref_counted_handle) {
          goto LABEL_22;
        }
        goto LABEL_92;
      }
    }

    __nwlog_obj();
    int v24 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v25 = (const char *)*((void *)v7 + 2);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
    if (!v25) {
      uint64_t v25 = "invalid";
    }
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v25;
    *(_WORD *)&buf[22] = 2048;
    v66 = v7;
    id v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v60 = OS_LOG_TYPE_ERROR;
    os_log_type_t v59 = 0;
    if (__nwlog_fault(v26, &v60, &v59))
    {
      if (v60 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v28 = v60;
        if (os_log_type_enabled(v27, v60))
        {
          os_log_type_t v29 = (const char *)*((void *)v7 + 2);
          if (!v29) {
            os_log_type_t v29 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2048;
          v66 = v7;
          _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback",  buf,  0x20u);
        }

  if (v23) {
    free(v23);
  }
  return 1LL;
}

  if (v23) {
    free(v23);
  }
  return 1LL;
}

        free(v25);
        goto LABEL_82;
      }

    free(backtrace_string);
    goto LABEL_82;
  }

  __nwlog_obj();
  int v24 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v62 = "nw_protocol_implementation_updated_path";
  uint64_t v25 = (char *)_os_log_send_and_compose_impl();

  type[4] = OS_LOG_TYPE_ERROR;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v25, &type[4], type))
  {
    if (type[4] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v27 = type[4];
      if (os_log_type_enabled(v26, type[4]))
      {
        *(_DWORD *)buf = 136446210;
        id v62 = "nw_protocol_implementation_updated_path";
        _os_log_impl(&dword_181A5C000, v26, v27, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (type[0])
    {
      __int16 v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v40 = type[4];
      uint64_t v41 = os_log_type_enabled(v26, type[4]);
      if (v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          id v62 = "nw_protocol_implementation_updated_path";
          char v63 = 2082;
          v64 = v39;
          _os_log_impl( &dword_181A5C000,  v26,  v40,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v39);
        goto LABEL_103;
      }

      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        id v62 = "nw_protocol_implementation_updated_path";
        _os_log_impl(&dword_181A5C000, v26, v40, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = type[4];
      if (os_log_type_enabled(v26, type[4]))
      {
        *(_DWORD *)buf = 136446210;
        id v62 = "nw_protocol_implementation_updated_path";
        _os_log_impl( &dword_181A5C000,  v26,  v51,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v17) {
    free(v17);
  }
  return 0LL;
}

  if (v23) {
    free(v23);
  }
  return 1LL;
}

    if (v25) {
      free(v25);
    }
    char v21 = 0LL;
    goto LABEL_26;
  }

  if (!*((void *)v5 + 15))
  {
    __nwlog_obj();
    BOOL v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v59 = "nw_protocol_data_copy_outbound_subdata";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();

    type[4] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v25, &type[4], type))
    {
      if (type[4] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type[4];
        if (os_log_type_enabled(v26, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v59 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_181A5C000, v26, v29, "%{public}s called with null instance->context", buf, 0xCu);
        }

          uint64_t v42 = v93;
          goto LABEL_136;
        }

        if (LOBYTE(v110[0]))
        {
          v51 = __nw_create_backtrace_string();
          __nwlog_obj();
          v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v52 = v111[0];
          v53 = os_log_type_enabled(v48, v111[0]);
          v90 = (char *)v51;
          if (v51)
          {
            if (v53)
            {
              *(_DWORD *)v107 = 136446466;
              *(void *)&v107[4] = "nw_http_cookie_options_get_should_not_send_cookies";
              *(_WORD *)&v107[12] = 2082;
              *(void *)&v107[14] = v51;
              _os_log_impl( &dword_181A5C000,  v48,  v52,  "%{public}s protocol options are not http_cookie, dumping backtrace:%{public}s",  v107,  0x16u);
            }

            uint64_t v42 = v93;
            uint64_t v17 = v95;
            free(v90);
            if (!v93) {
              goto LABEL_138;
            }
            goto LABEL_137;
          }

          if (v53)
          {
            *(_DWORD *)v107 = 136446210;
            *(void *)&v107[4] = "nw_http_cookie_options_get_should_not_send_cookies";
            _os_log_impl( &dword_181A5C000,  v48,  v52,  "%{public}s protocol options are not http_cookie, no backtrace",  v107,  0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v55 = v111[0];
          if (os_log_type_enabled(v48, v111[0]))
          {
            *(_DWORD *)v107 = 136446210;
            *(void *)&v107[4] = "nw_http_cookie_options_get_should_not_send_cookies";
            _os_log_impl( &dword_181A5C000,  v48,  v55,  "%{public}s protocol options are not http_cookie, backtrace limit exceeded",  v107,  0xCu);
          }
        }

        goto LABEL_135;
      }

      goto LABEL_87;
    }

    os_log_type_t v50 = v12;
    v50[66] = 1;

    v50[20] = 393220;
    nw_endpoint_handler_report(v50, 0LL, (_WORD *)v50 + 40, 0LL);
    if (nw_endpoint_handler_get_minimize_logging(v50))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v53 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        v88 = nw_endpoint_handler_get_id_string(v50);
        logc = nw_endpoint_handler_dry_run_string(v50);
        v89 = nw_endpoint_handler_copy_endpoint(v50);
        v90 = nw_endpoint_get_logging_description(v89);
        v91 = nw_endpoint_handler_state_string(v50);
        v92 = nw_endpoint_handler_mode_string(v50);
        v93 = nw_endpoint_handler_copy_current_path(v50);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v88;
        *(_WORD *)&buf[22] = 2082;
        v116 = logc;
        *(_WORD *)v117 = 2082;
        *(void *)&v117[2] = v90;
        *(_WORD *)&v117[10] = 2082;
        *(void *)&v117[12] = v91;
        v118 = 2082;
        v119 = v92;
        v120 = 2114;
        v121 = v93;
        _os_log_impl( &dword_181A5C000,  v53,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resetting due to losing proxy settings",  buf,  0x48u);

        uint64_t v14 = 0LL;
      }
    }

    else
    {
      v51 = v50;
      os_log_type_t v52 = *((_BYTE *)v51 + 268);

      if ((v52 & 0x20) != 0)
      {
LABEL_59:
        nw_endpoint_handler_reset_mode(v50, 1);
        goto LABEL_81;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v53 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v54 = nw_endpoint_handler_get_id_string(v51);
        BOOL v55 = nw_endpoint_handler_dry_run_string(v51);
        loga = v53;
        v56 = nw_endpoint_handler_copy_endpoint(v51);
        os_log_type_t v57 = nw_endpoint_get_logging_description(v56);
        BOOL v58 = nw_endpoint_handler_state_string(v51);
        os_log_type_t v59 = nw_endpoint_handler_mode_string(v51);
        os_log_type_t v60 = nw_endpoint_handler_copy_current_path(v51);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_proxy updatePathWithHandler:]";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v54;
        *(_WORD *)&buf[22] = 2082;
        v116 = v55;
        *(_WORD *)v117 = 2082;
        *(void *)&v117[2] = v57;
        *(_WORD *)&v117[10] = 2082;
        *(void *)&v117[12] = v58;
        v118 = 2082;
        v119 = v59;
        v120 = 2114;
        v121 = v60;
        v53 = loga;
        _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resetting due to losing proxy settings",  buf,  0x48u);

        uint64_t v14 = 0LL;
      }
    }

    goto LABEL_59;
  }

  __break(1u);
  return result;
}

    if (v27) {
      free(v27);
    }
    goto LABEL_27;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_context_destroy";
  os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v47 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v22, type, &v47))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v23 = (os_log_s *)__nwlog_obj();
      int v24 = type[0];
      if (!os_log_type_enabled(v23, type[0])) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_context_destroy";
      uint64_t v25 = "%{public}s called with null ohttp_context";
      goto LABEL_75;
    }

    if (v47 == OS_LOG_TYPE_DEFAULT)
    {
      char v23 = (os_log_s *)__nwlog_obj();
      int v24 = type[0];
      if (!os_log_type_enabled(v23, type[0])) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_context_destroy";
      uint64_t v25 = "%{public}s called with null ohttp_context, backtrace limit exceeded";
      goto LABEL_75;
    }

    __int16 v36 = (char *)__nw_create_backtrace_string();
    char v23 = (os_log_s *)__nwlog_obj();
    int v24 = type[0];
    uint64_t v37 = os_log_type_enabled(v23, type[0]);
    if (v36)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_context_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v36;
        _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s called with null ohttp_context, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v36);
      goto LABEL_76;
    }

    if (v37)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ohttp_context_destroy";
      uint64_t v25 = "%{public}s called with null ohttp_context, no backtrace";
LABEL_75:
      _os_log_impl(&dword_181A5C000, v23, v24, v25, buf, 0xCu);
    }
  }

  PBDataWriterWriteUint32Field();
  if ((*(_WORD *)&self->_has & 0x80) != 0) {
LABEL_26:
  }
    PBDataWriterWriteBOOLField();
LABEL_27:
  if (self->_requiredInterface) {
    PBDataWriterWriteSubmessage();
  }
  if (self->_prohibitedInterfaceTypes.count)
  {
    id v6 = 0LL;
    do
    {
      PBDataWriterWriteInt32Field();
      ++v6;
    }

    while (v6 < self->_prohibitedInterfaceTypes.count);
  }

  if (self->_prohibitedInterfaceSubTypes.count)
  {
    id v7 = 0LL;
    do
    {
      PBDataWriterWriteInt32Field();
      ++v7;
    }

    while (v7 < self->_prohibitedInterfaceSubTypes.count);
  }

  uint64_t v42 = 0u;
  BOOL v43 = 0u;
  __int16 v40 = 0u;
  uint64_t v41 = 0u;
  BOOL v8 = self->_prohibitedInterfaces;
  uint32_t v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v40,  v47,  16LL);
  if (v9)
  {
    int v10 = v9;
    uint64_t v11 = *(void *)v41;
    do
    {
      for (i = 0LL; i != v10; ++i)
      {
        if (*(void *)v41 != v11) {
          objc_enumerationMutation(v8);
        }
        PBDataWriterWriteSubmessage();
      }

      int v10 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v40,  v47,  16LL);
    }

    while (v10);
  }

  __int16 v38 = 0u;
  __int16 v39 = 0u;
  __int16 v36 = 0u;
  uint64_t v37 = 0u;
  uint64_t v13 = self->_prohibitedAgents;
  uint64_t v14 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v13,  "countByEnumeratingWithState:objects:count:",  &v36,  v46,  16LL);
  if (v14)
  {
    uint64_t v15 = v14;
    BOOL v16 = *(void *)v37;
    do
    {
      for (j = 0LL; j != v15; ++j)
      {
        if (*(void *)v37 != v16) {
          objc_enumerationMutation(v13);
        }
        PBDataWriterWriteSubmessage();
      }

      uint64_t v15 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v13,  "countByEnumeratingWithState:objects:count:",  &v36,  v46,  16LL);
    }

    while (v15);
  }

  id v34 = 0u;
  os_log_type_t v35 = 0u;
  char v32 = 0u;
  id v33 = 0u;
  BOOL v18 = self->_requiredAgents;
  uint64_t v19 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v18,  "countByEnumeratingWithState:objects:count:",  &v32,  v45,  16LL);
  if (v19)
  {
    uint64_t v20 = v19;
    char v21 = *(void *)v33;
    do
    {
      for (k = 0LL; k != v20; ++k)
      {
        if (*(void *)v33 != v21) {
          objc_enumerationMutation(v18);
        }
        PBDataWriterWriteSubmessage();
      }

      uint64_t v20 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v18,  "countByEnumeratingWithState:objects:count:",  &v32,  v45,  16LL);
    }

    while (v20);
  }

  os_log_type_t v30 = 0u;
  os_log_type_t v31 = 0u;
  BOOL v28 = 0u;
  os_log_type_t v29 = 0u;
  char v23 = self->_preferredAgents;
  int v24 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v23,  "countByEnumeratingWithState:objects:count:",  &v28,  v44,  16LL);
  if (v24)
  {
    uint64_t v25 = v24;
    id v26 = *(void *)v29;
    do
    {
      for (m = 0LL; m != v25; ++m)
      {
        if (*(void *)v29 != v26) {
          objc_enumerationMutation(v23);
        }
        PBDataWriterWriteSubmessage();
      }

      uint64_t v25 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v23,  "countByEnumeratingWithState:objects:count:",  &v28,  v44,  16LL);
    }

    while (v25);
  }

  if (self->_metadata) {
    PBDataWriterWriteDataField();
  }
}

  if (v35) {
    free(v35);
  }
  return 0LL;
}

    free(v33);
    goto LABEL_28;
  }

    free(v33);
    goto LABEL_28;
  }

LABEL_17:
    if (!v6)
    {
LABEL_19:
      int v10 = 0LL;
      goto LABEL_20;
    }

    if (v47) {
      free(v47);
    }
LABEL_17:
    uint64_t v27 = *(void *)(*(void *)(a1 + 32) + 80LL);
    if (v27)
    {
      BOOL v28 = (void *)nw_dictionary_copy(v27);
      v77[0] = v21;
      v77[1] = 3221225472LL;
      v77[2] = __nw_service_connector_cancel_block_invoke_105;
      v77[3] = &unk_189BC5058;
      os_log_type_t v30 = *(void **)(a1 + 32);
      os_log_type_t v29 = a1 + 32;
      v78 = v30;
      nw_dictionary_apply((uint64_t)v28, (uint64_t)v77);

      os_log_type_t v31 = *(void **)(*(void *)v29 + 80LL);
      *(void *)(*(void *)v29 + 80LL) = 0LL;

      return;
    }

    __nwlog_obj();
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v52 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 136446466;
    v86 = "nw_service_connector_cancel_block_invoke_2";
    v87 = 2114;
    v88 = v52;
    id v6 = (char *)_os_log_send_and_compose_impl();

    v84 = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (__nwlog_fault(v6, &v84, &v83))
    {
      if (v84 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v53 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v54 = v84;
        if (os_log_type_enabled(v53, v84))
        {
          BOOL v55 = *(void *)(a1 + 32);
          *(_DWORD *)buf = 136446466;
          v86 = "nw_service_connector_cancel_block_invoke";
          v87 = 2114;
          v88 = v55;
          _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests",  buf,  0x16u);
        }

  if (v35) {
    free(v35);
  }
  os_log_type_t v29 = 0LL;
LABEL_45:

  return v29;
}

  return v20;
}

      goto LABEL_122;
    }

    uint64_t v15 = (void *)v12[5];
    if (v15 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v37 = v12[11];
      if (v37) {
        v12[11] = v37 + 1;
      }
      BOOL v16 = -1;
    }

    else
    {
      BOOL v16 = 0;
    }

    *(void *)buf = v12;
    buf[8] = v16;
    __int16 v38 = (void *)*((void *)v5 + 52);
    if (v38 == &nw_protocol_ref_counted_handle)
    {
      __int16 v40 = *((void *)v5 + 58);
      if (v40) {
        *((void *)v5 + 58) = v40 + 1;
      }
      __int16 v39 = -1;
    }

    else
    {
      __int16 v39 = 0;
    }

    *(void *)os_log_type_t type = (char *)v5 + 376;
    v91 = v39;
    uint64_t v41 = v14();
    if (v38 == &nw_protocol_ref_counted_handle)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v15 != &nw_protocol_ref_counted_handle)
      {
LABEL_52:
        if ((v41 & 1) != 0) {
          goto LABEL_81;
        }
        goto LABEL_56;
      }
    }

    else if (v15 != &nw_protocol_ref_counted_handle)
    {
      goto LABEL_52;
    }

    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    if ((v41 & 1) != 0) {
      goto LABEL_81;
    }
    goto LABEL_56;
  }

      goto LABEL_122;
    }

    uint64_t v15 = (void *)v12[5];
    if (v15 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v37 = v12[11];
      if (v37) {
        v12[11] = v37 + 1;
      }
      BOOL v16 = -1;
    }

    else
    {
      BOOL v16 = 0;
    }

    *(void *)buf = v12;
    buf[8] = v16;
    __int16 v38 = (void *)*((void *)v5 + 52);
    if (v38 == &nw_protocol_ref_counted_handle)
    {
      __int16 v40 = *((void *)v5 + 58);
      if (v40) {
        *((void *)v5 + 58) = v40 + 1;
      }
      __int16 v39 = -1;
    }

    else
    {
      __int16 v39 = 0;
    }

    *(void *)os_log_type_t type = (char *)v5 + 376;
    v91 = v39;
    uint64_t v41 = v14();
    if (v38 == &nw_protocol_ref_counted_handle)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v15 != &nw_protocol_ref_counted_handle)
      {
LABEL_52:
        if ((v41 & 1) != 0) {
          goto LABEL_81;
        }
        goto LABEL_56;
      }
    }

    else if (v15 != &nw_protocol_ref_counted_handle)
    {
      goto LABEL_52;
    }

    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    if ((v41 & 1) != 0) {
      goto LABEL_81;
    }
    goto LABEL_56;
  }

      close(v15);
      return v9;
    }

    *(_DWORD *)buf = 136446978;
    os_log_type_t v35 = "nw_network_agent_add_to_interface_internal";
    __int16 v36 = 1024;
    *(_DWORD *)uint64_t v37 = v15;
    *(_WORD *)&v37[4] = 2082;
    *(void *)&v37[6] = a1;
    *(_WORD *)&v37[14] = 1024;
    *(_DWORD *)&v37[16] = v9;
    char v23 = (char *)_os_log_send_and_compose_impl();
    id v33 = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v23, &v33, &v32))
    {
      if (v33 == OS_LOG_TYPE_FAULT)
      {
        int v24 = (os_log_s *)__nwlog_obj();
        uint64_t v25 = v33;
        if (!os_log_type_enabled(v24, v33)) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v35 = "nw_network_agent_add_to_interface_internal";
        __int16 v36 = 1024;
        *(_DWORD *)uint64_t v37 = v15;
        *(_WORD *)&v37[4] = 2082;
        *(void *)&v37[6] = a1;
        *(_WORD *)&v37[14] = 1024;
        *(_DWORD *)&v37[16] = v9;
        id v26 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=%{public}s failed %{darwin.errno}d";
        goto LABEL_78;
      }

      if (!v32)
      {
        int v24 = (os_log_s *)__nwlog_obj();
        uint64_t v25 = v33;
        if (!os_log_type_enabled(v24, v33)) {
          goto LABEL_79;
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v35 = "nw_network_agent_add_to_interface_internal";
        __int16 v36 = 1024;
        *(_DWORD *)uint64_t v37 = v15;
        *(_WORD *)&v37[4] = 2082;
        *(void *)&v37[6] = a1;
        *(_WORD *)&v37[14] = 1024;
        *(_DWORD *)&v37[16] = v9;
        id v26 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=%{public}s failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_78;
      }

      os_log_type_t v29 = (char *)__nw_create_backtrace_string();
      int v24 = (os_log_s *)__nwlog_obj();
      uint64_t v25 = v33;
      os_log_type_t v30 = os_log_type_enabled(v24, v33);
      if (v29)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136447234;
          os_log_type_t v35 = "nw_network_agent_add_to_interface_internal";
          __int16 v36 = 1024;
          *(_DWORD *)uint64_t v37 = v15;
          *(_WORD *)&v37[4] = 2082;
          *(void *)&v37[6] = a1;
          *(_WORD *)&v37[14] = 1024;
          *(_DWORD *)&v37[16] = v9;
          __int16 v38 = 2082;
          __int16 v39 = v29;
          _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=%{public}s failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x2Cu);
        }

        free(v29);
        goto LABEL_79;
      }

      if (v30)
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v35 = "nw_network_agent_add_to_interface_internal";
        __int16 v36 = 1024;
        *(_DWORD *)uint64_t v37 = v15;
        *(_WORD *)&v37[4] = 2082;
        *(void *)&v37[6] = a1;
        *(_WORD *)&v37[14] = 1024;
        *(_DWORD *)&v37[16] = v9;
        id v26 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=%{public}s failed %{darwin.errno}d, no backtrace";
LABEL_78:
        _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0x22u);
      }
    }

    if (v29) {
      free(v29);
    }
    goto LABEL_83;
  }

  BOOL v8 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  __int16 v39 = "nw_network_agent_remove_from_interface";
  __int16 v40 = 1024;
  *(_DWORD *)uint64_t v41 = v8;
  os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  uint64_t v37 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v22, type, &v37))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v23 = (os_log_s *)gLogObj;
      int v24 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446466;
      __int16 v39 = "nw_network_agent_remove_from_interface";
      __int16 v40 = 1024;
      *(_DWORD *)uint64_t v41 = v8;
      uint64_t v25 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
      goto LABEL_73;
    }

    if (v37 == OS_LOG_TYPE_DEFAULT)
    {
      char v23 = (os_log_s *)__nwlog_obj();
      int v24 = type[0];
      if (!os_log_type_enabled(v23, type[0])) {
        goto LABEL_74;
      }
      *(_DWORD *)buf = 136446466;
      __int16 v39 = "nw_network_agent_remove_from_interface";
      __int16 v40 = 1024;
      *(_DWORD *)uint64_t v41 = v8;
      uint64_t v25 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_73;
    }

    uint64_t v27 = (char *)__nw_create_backtrace_string();
    char v23 = (os_log_s *)__nwlog_obj();
    int v24 = type[0];
    BOOL v28 = os_log_type_enabled(v23, type[0]);
    if (v27)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446722;
        __int16 v39 = "nw_network_agent_remove_from_interface";
        __int16 v40 = 1024;
        *(_DWORD *)uint64_t v41 = v8;
        *(_WORD *)&v41[4] = 2082;
        *(void *)&v41[6] = v27;
        _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(v27);
      goto LABEL_74;
    }

    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v39 = "nw_network_agent_remove_from_interface";
      __int16 v40 = 1024;
      *(_DWORD *)uint64_t v41 = v8;
      uint64_t v25 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
LABEL_73:
      _os_log_impl(&dword_181A5C000, v23, v24, v25, buf, 0x12u);
    }
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v46 = "__nw_protocol_output_available";
  id v3 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v43 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __int16 v38 = (os_log_s *)__nwlog_obj();
    __int16 v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_96;
    }
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_output_available";
    __int16 v40 = "%{public}s called with null protocol";
  }

  else if (v43)
  {
    uint64_t v41 = (char *)__nw_create_backtrace_string();
    __int16 v38 = (os_log_s *)__nwlog_obj();
    __int16 v39 = type;
    uint64_t v42 = os_log_type_enabled(v38, type);
    if (v41)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v46 = "__nw_protocol_output_available";
        v47 = 2082;
        v48 = v41;
        _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v41);
      if (v3) {
        goto LABEL_33;
      }
      return;
    }

    if (!v42) {
      goto LABEL_96;
    }
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_output_available";
    __int16 v40 = "%{public}s called with null protocol, no backtrace";
  }

  else
  {
    __int16 v38 = (os_log_s *)__nwlog_obj();
    __int16 v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_96;
    }
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_output_available";
    __int16 v40 = "%{public}s called with null protocol, backtrace limit exceeded";
  }

  _os_log_impl(&dword_181A5C000, v38, v39, v40, buf, 0xCu);
LABEL_96:
  if (v3) {
LABEL_33:
  }
    free((void *)v3);
}

    goto LABEL_108;
  }

  node = nw_hash_table_get_node(v37, (uint64_t)v5, 0LL);
  if (!node)
  {
    if (nw_path_parameters_get_logging_disabled(*((void *)v3 + 2))) {
      goto LABEL_108;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v45 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
    {
      v47 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446722;
      v71 = "nw_association_mark_flow_disconnected";
      v72 = 2082;
      v73 = (void *)v47;
      v74 = 2048;
      v75 = v5;
      _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_INFO,  "%{public}s <nw_association %{public}s> does not have connected flow %p registered",  buf,  0x20u);
    }

    goto LABEL_81;
  }

  __int16 v39 = node;
  if (nw_hash_table_remove_node(*((void *)v3 + 6), node)
    || nw_path_parameters_get_logging_disabled(*((void *)v3 + 2)))
  {
    goto LABEL_108;
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  __int16 v40 = (id)gconnectionLogObj;
  uint64_t v41 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
  *(_DWORD *)buf = 136446722;
  v71 = "nw_association_mark_flow_disconnected";
  v72 = 2082;
  v73 = (void *)v41;
  v74 = 2048;
  v75 = (char *)v39;
  BOOL v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v68 = 0;
  if (__nwlog_fault(v16, &type, &v68))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v42 = (os_log_s *)(id)gconnectionLogObj;
      BOOL v43 = type;
      if (os_log_type_enabled(v42, type))
      {
        os_log_type_t v44 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v44;
        v74 = 2048;
        v75 = (char *)v39;
        _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s <nw_association %{public}s> failed to remove connected flow for node %p",  buf,  0x20u);
      }
    }

    else if (v68)
    {
      v48 = __nw_create_backtrace_string();
      if (v48)
      {
        v49 = (char *)v48;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v50 = (os_log_s *)(id)gconnectionLogObj;
        v51 = type;
        if (os_log_type_enabled(v50, type))
        {
          os_log_type_t v52 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
          *(_DWORD *)buf = 136446978;
          v71 = "nw_association_mark_flow_disconnected";
          v72 = 2082;
          v73 = (void *)v52;
          v74 = 2048;
          v75 = (char *)v39;
          v76 = 2082;
          v77 = v49;
          _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s <nw_association %{public}s> failed to remove connected flow for node %p, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v49);
        if (v16) {
          goto LABEL_107;
        }
        goto LABEL_108;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v42 = (os_log_s *)(id)gconnectionLogObj;
      BOOL v55 = type;
      if (os_log_type_enabled(v42, type))
      {
        v56 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v56;
        v74 = 2048;
        v75 = (char *)v39;
        _os_log_impl( &dword_181A5C000,  v42,  v55,  "%{public}s <nw_association %{public}s> failed to remove connected flow for node %p, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v42 = (os_log_s *)(id)gconnectionLogObj;
      v53 = type;
      if (os_log_type_enabled(v42, type))
      {
        os_log_type_t v54 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        v71 = "nw_association_mark_flow_disconnected";
        v72 = 2082;
        v73 = (void *)v54;
        v74 = 2048;
        v75 = (char *)v39;
        _os_log_impl( &dword_181A5C000,  v42,  v53,  "%{public}s <nw_association %{public}s> failed to remove connected flow for node %p, backtrace limit exceeded",  buf,  0x20u);
      }
    }
  }

LABEL_96:
          v90 = v86;
          v89 = a1[26];
          a1[26] = v90;
          goto LABEL_97;
        }

        if ((a4 & 1) == 0) {
          goto LABEL_87;
        }
LABEL_94:
        objc_storeStrong(a1 + 25, v73);
LABEL_95:
        v86 = (void *)*((void *)v7 + 26);
        if (!v86) {
          goto LABEL_98;
        }
        goto LABEL_96;
      }

      if (a4) {
        goto LABEL_81;
      }
    }

    v65 = nw_array_create();
    v66 = a1[21];
    a1[21] = (id)v65;

    __int16 v67 = *v61;
    v147[0] = MEMORY[0x1895F87A8];
    v147[1] = 3221225472LL;
    v147[2] = __74__NWConcrete_nw_parameters_initWithParameters_stripConnected_shallowCopy___block_invoke_2;
    v147[3] = &unk_189BC85B0;
    v148 = a1;
    nw_array_apply(v67, (uint64_t)v147);
    v68 = v148;
LABEL_84:

    goto LABEL_85;
  }

  __nwlog_obj();
  v109 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v109, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v155 = "strict_strdup";
  v110 = (void *)_os_log_send_and_compose_impl();

  uint64_t result = __nwlog_abort((uint64_t)v110);
  if (!result)
  {
    free(v110);
    goto LABEL_36;
  }

    goto LABEL_97;
  }

  id v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
  nw_context_assert_queue(v6);
  id v7 = *((void *)v3 + 7);
  if (!v7) {
    goto LABEL_56;
  }
  node = nw_hash_table_get_node(v7, (uint64_t)v5, 0LL);
  if (!node) {
    goto LABEL_56;
  }
  uint32_t v9 = (uint64_t *)node;
  int v10 = time(0LL);
  uint64_t v11 = v9 + 4;
  uint64_t v12 = v9[9];
  if (v10 <= v9[8])
  {
    uint64_t v19 = v6;
    if (v19)
    {
      uint64_t v20 = (dispatch_queue_t *)v19;
      char v21 = v20;
      if (((_BYTE)v20[17] & 8) == 0) {
        dispatch_assert_queue_V2(v20[1]);
      }

      os_log_type_t v22 = nw_context_copy_cache_context(v21);
      char v23 = v9[6];
      if (v23 || v9[7])
      {
        int v24 = *(void *)(v22 + 24);
        uint64_t v25 = *(_DWORD *)(v24 + 64);
        if (v25) {
          *(_DWORD *)(v24 + 64) = v25 - 1;
        }
        id v26 = (uint64_t *)v9[7];
        if (v23)
        {
          *(void *)(v23 + 24) = v26;
          id v26 = (uint64_t *)v9[7];
        }

        else
        {
          *(void *)(v24 + 24) = v26;
        }

        char *v26 = v23;
        v9[6] = 0LL;
        v9[7] = 0LL;
      }

      uint64_t v27 = v9[4];
      BOOL v28 = (uint64_t *)v9[5];
      if (v27)
      {
        *(void *)(v27 + 8) = v28;
        BOOL v28 = (uint64_t *)v9[5];
      }

      else
      {
        *(void *)(*(void *)(v22 + 24) + 8LL) = v28;
      }

      *BOOL v28 = v27;
      os_log_type_t v29 = **(void **)(v22 + 24);
      *uint64_t v11 = v29;
      os_log_type_t v30 = *(void **)(v22 + 24);
      if (v29) {
        os_log_type_t v30 = (void *)*v30;
      }
      v30[1] = v11;
      **(void **)(v22 + 24) = v11;
      v9[5] = *(void *)(v22 + 24);

      goto LABEL_57;
    }

    __nwlog_obj();
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_context_touch_cache_entry";
    os_log_type_t v54 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (__nwlog_fault(v54, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_context_touch_cache_entry";
          _os_log_impl(&dword_181A5C000, v55, v56, "%{public}s called with null context", buf, 0xCu);
        }
      }

      else if (v63)
      {
        os_log_type_t v59 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v60 = type;
        v61 = os_log_type_enabled(v55, type);
        if (v59)
        {
          if (v61)
          {
            *(_DWORD *)buf = 136446466;
            v66 = "nw_context_touch_cache_entry";
            __int16 v67 = 2082;
            v68 = v59;
            _os_log_impl( &dword_181A5C000,  v55,  v60,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v59);
          goto LABEL_111;
        }

        if (v61)
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_context_touch_cache_entry";
          _os_log_impl(&dword_181A5C000, v55, v60, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v62 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_context_touch_cache_entry";
          _os_log_impl( &dword_181A5C000,  v55,  v62,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        BOOL v18 = 0LL;
LABEL_113:
        id v3 = (dispatch_queue_t *)v6;
        goto LABEL_114;
      }

      __nwlog_obj();
      uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_connected_flow_count";
      BOOL v28 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v61 = 0;
      if (__nwlog_fault(v28, type, &v61))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v30 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_connected_flow_count";
            _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null hash_table", buf, 0xCu);
          }
        }

        else if (v61)
        {
          uint64_t v37 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v38 = type[0];
          __int16 v39 = os_log_type_enabled(v29, type[0]);
          if (v37)
          {
            if (v39)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_connected_flow_count";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v37;
              _os_log_impl( &dword_181A5C000,  v29,  v38,  "%{public}s called with null hash_table, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v37);
            goto LABEL_94;
          }

          if (v39)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_connected_flow_count";
            _os_log_impl(&dword_181A5C000, v29, v38, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v53 = type[0];
          if (os_log_type_enabled(v29, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_context_endpoint_get_connected_flow_count";
            _os_log_impl( &dword_181A5C000,  v29,  v53,  "%{public}s called with null hash_table, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

    v97 = v94[12];
    goto LABEL_97;
  }

  if (v96) {
    goto LABEL_96;
  }
  v99 = 0;
LABEL_100:

  *((_DWORD *)v25 + 224) += v99;
  os_unfair_lock_unlock((os_unfair_lock_t)v25 + 220);

  v47 = 1LL;
LABEL_101:
  id v6 = v155;
LABEL_184:

  return v47;
}

  if (v72) {
    free(v72);
  }
}
  }

      os_log_type_t v29 = 0;
      os_log_type_t v30 = 1;
      return v29 | (v30 << 8);
    }

    goto LABEL_103;
  }

  if (v20 != 45)
  {
    if (v18 != v15)
    {
      __int16 v38 = a6 + 87;
      if (a6 > 10)
      {
        __int16 v39 = a6 + 55;
      }

      else
      {
        __int16 v38 = 97;
        __int16 v39 = 65;
      }

      if (a6 <= 10) {
        __int16 v40 = a6 + 48;
      }
      else {
        __int16 v40 = 58;
      }
      if (v19)
      {
        LOBYTE(v41) = 0;
        do
        {
          uint64_t v42 = *v19;
          if (v42 < 0x30 || v42 >= v40)
          {
            if (v42 < 0x41 || v42 >= v39)
            {
              os_log_type_t v29 = 0;
              os_log_type_t v30 = 1;
              if (v42 < 0x61 || v42 >= v38) {
                return v29 | (v30 << 8);
              }
              BOOL v43 = -87;
            }

            else
            {
              BOOL v43 = -55;
            }
          }

          else
          {
            BOOL v43 = -48;
          }

          uint64_t v41 = (v41 * a6) + (v42 + v43);
          if (((v41 >> 8) & 1) != 0) {
            goto LABEL_96;
          }
          ++v19;
          --result;
        }

        while (result);
        os_log_type_t v30 = 0;
        os_log_type_t v29 = v41;
        return v29 | (v30 << 8);
      }

      goto LABEL_95;
    }

    goto LABEL_96;
  }

  if (result >= 1)
  {
    if (result != 1)
    {
      char v21 = a6 + 87;
      if (a6 > 10)
      {
        os_log_type_t v22 = a6 + 55;
      }

      else
      {
        char v21 = 97;
        os_log_type_t v22 = 65;
      }

      if (a6 <= 10) {
        char v23 = a6 + 48;
      }
      else {
        char v23 = 58;
      }
      if (v19)
      {
        LOBYTE(v24) = 0;
        uint64_t v25 = v19 + 1;
        id v26 = result - 1;
        while (1)
        {
          uint64_t v27 = *v25;
          if (v27 < 0x30 || v27 >= v23)
          {
            if (v27 < 0x41 || v27 >= v22)
            {
              os_log_type_t v29 = 0;
              os_log_type_t v30 = 1;
              if (v27 < 0x61 || v27 >= v21) {
                return v29 | (v30 << 8);
              }
              BOOL v28 = -87;
            }

            else
            {
              BOOL v28 = -55;
            }
          }

          else
          {
            BOOL v28 = -48;
          }

          int v24 = (v24 * a6) - (v27 + v28);
          if ((v24 & 0xFFFFFF00) != 0) {
            goto LABEL_96;
          }
          ++v25;
          if (!--v26) {
            goto LABEL_72;
          }
        }
      }

  if (v30) {
    free(v30);
  }
  os_log_type_t v4 = 0LL;
  if (v6 == &nw_protocol_ref_counted_handle)
  {
LABEL_10:
    if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
    {
      char v21 = *(void *)(a2 + 88);
      if (v21)
      {
        os_log_type_t v22 = v21 - 1;
        *(void *)(a2 + 88) = v22;
        if (!v22)
        {
          char v23 = *(void (***)(void))(a2 + 64);
          if (v23)
          {
            *(void *)(a2 + 64) = 0LL;
            v23[2](v23);
            _Block_release(v23);
          }

          if ((*(_BYTE *)(a2 + 72) & 1) != 0)
          {
            int v24 = *(const void **)(a2 + 64);
            if (v24) {
              _Block_release(v24);
            }
          }

          free((void *)a2);
        }
      }
    }
  }

      if (!v16) {
        goto LABEL_11;
      }
LABEL_97:
      free(v16);
      goto LABEL_11;
    }

    __nwlog_obj();
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v58 = "nw_framer_protocol_get_message_properties";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v55 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v58 = "nw_framer_protocol_get_message_properties";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null framer", buf, 0xCu);
      }
    }

    else if (v55)
    {
      id v33 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v34 = type;
      os_log_type_t v35 = os_log_type_enabled(v17, type);
      if (v33)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v58 = "nw_framer_protocol_get_message_properties";
          os_log_type_t v59 = 2082;
          os_log_type_t v60 = v33;
          _os_log_impl( &dword_181A5C000,  v17,  v34,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v33);
        goto LABEL_96;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v58 = "nw_framer_protocol_get_message_properties";
        _os_log_impl(&dword_181A5C000, v17, v34, "%{public}s called with null framer, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v58 = "nw_framer_protocol_get_message_properties";
        _os_log_impl( &dword_181A5C000,  v17,  v46,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
      }
    }

        goto LABEL_97;
      }

      __nwlog_obj();
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v54 = "nw_framer_protocol_output_finished";
      uint64_t v13 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v26 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v54 = "nw_framer_protocol_output_finished";
          _os_log_impl(&dword_181A5C000, v14, v26, "%{public}s called with null framer->parent_definition", buf, 0xCu);
        }

        goto LABEL_96;
      }

      if (!v51)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v54 = "nw_framer_protocol_output_finished";
          _os_log_impl( &dword_181A5C000,  v14,  v50,  "%{public}s called with null framer->parent_definition, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_96;
      }

      __int16 v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v39 = type;
      __int16 v40 = os_log_type_enabled(v14, type);
      if (!v36)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v54 = "nw_framer_protocol_output_finished";
          _os_log_impl( &dword_181A5C000,  v14,  v39,  "%{public}s called with null framer->parent_definition, no backtrace",  buf,  0xCu);
        }

        goto LABEL_96;
      }

      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v54 = "nw_framer_protocol_output_finished";
        BOOL v55 = 2082;
        v56 = v36;
        _os_log_impl( &dword_181A5C000,  v14,  v39,  "%{public}s called with null framer->parent_definition, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    else
    {
      __nwlog_obj();
      char v23 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v54 = "nw_framer_protocol_output_finished";
      uint64_t v13 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v24 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v54 = "nw_framer_protocol_output_finished";
          _os_log_impl(&dword_181A5C000, v14, v24, "%{public}s called with null framer", buf, 0xCu);
        }

        goto LABEL_96;
      }

      if (!v51)
      {
        __nwlog_obj();
        uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v49 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v54 = "nw_framer_protocol_output_finished";
          _os_log_impl( &dword_181A5C000,  v14,  v49,  "%{public}s called with null framer, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_96;
      }

      __int16 v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v37 = type;
      __int16 v38 = os_log_type_enabled(v14, type);
      if (!v36)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v54 = "nw_framer_protocol_output_finished";
          _os_log_impl(&dword_181A5C000, v14, v37, "%{public}s called with null framer, no backtrace", buf, 0xCu);
        }

        goto LABEL_96;
      }

      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v54 = "nw_framer_protocol_output_finished";
        BOOL v55 = 2082;
        v56 = v36;
        _os_log_impl( &dword_181A5C000,  v14,  v37,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
      }
    }

    free(v36);
    if (!v13) {
      goto LABEL_13;
    }
    goto LABEL_98;
  }

  __nwlog_obj();
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v54 = "nw_framer_protocol_output_finished";
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v51 = 0;
  if (__nwlog_fault(v20, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v54 = "nw_framer_protocol_output_finished";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v51)
    {
      id v33 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v34 = type;
      os_log_type_t v35 = os_log_type_enabled(v21, type);
      if (v33)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v54 = "nw_framer_protocol_output_finished";
          BOOL v55 = 2082;
          v56 = v33;
          _os_log_impl( &dword_181A5C000,  v21,  v34,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v33);
        goto LABEL_89;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v54 = "nw_framer_protocol_output_finished";
        _os_log_impl(&dword_181A5C000, v21, v34, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v48 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v54 = "nw_framer_protocol_output_finished";
        _os_log_impl( &dword_181A5C000,  v21,  v48,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_97:
      if (v17) {
        free(v17);
      }
      return 0LL;
    }

    if (!v32)
    {
      __nwlog_obj();
      BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v35 = "nw_endpoint_construct_composite_bonjour_name";
        uint64_t v20 = "%{public}s called with null domain, backtrace limit exceeded";
        goto LABEL_95;
      }

      goto LABEL_96;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v19 = type;
    os_log_type_t v31 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v35 = "nw_endpoint_construct_composite_bonjour_name";
        uint64_t v20 = "%{public}s called with null domain, no backtrace";
        goto LABEL_95;
      }

      goto LABEL_96;
    }

    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v35 = "nw_endpoint_construct_composite_bonjour_name";
      __int16 v36 = 2082;
      uint64_t v37 = backtrace_string;
      uint64_t v27 = "%{public}s called with null domain, dumping backtrace:%{public}s";
      goto LABEL_73;
    }

    a2[2].i64[0] = v5 + (v18 << 8);
    for (j = v410; v18; --v18)
    {
      v81 = a2[1].i64[0];
      v420 = *(void **)(v81 - 8);
      a2[1].i64[0] = v81 - 8;
      std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front( (const void **)a2,  &v420);
    }

    goto LABEL_140;
  }

  os_log_type_t v31 = v10 == v9;
  if (v29 >> 2 <= j + v30) {
    char v32 = j + v30;
  }
  else {
    char v32 = v29 >> 2;
  }
  v407 = v15;
  if (v32)
  {
    id v33 = (uint64_t *)calloc(v32, 8uLL);
    if (!v33) {
      goto LABEL_54;
    }
  }

  else
  {
    id v33 = 0LL;
  }

  v405 = (v27 << 8) - v31;
  uint64_t v15 = (uint64_t)&v33[v32];
  v84 = v33;
  v85 = (char *)v33;
  do
  {
    v86 = calloc(0x100uLL, 0x10uLL);
    if (!v86) {
      goto LABEL_54;
    }
    v87 = v86;
    if (v85 == (char *)v15)
    {
      __src = v33;
      if (v84 <= v33)
      {
        else {
          v94 = (v15 - (uint64_t)v33) >> 2;
        }
        v95 = (uint64_t *)calloc(v94, 8uLL);
        if (!v95) {
          goto LABEL_54;
        }
        v96 = v95;
        v97 = v94 >> 2;
        v98 = (char *)&v95[v94 >> 2];
        v85 = v98;
        v99 = v15 - (void)v84;
        if ((uint64_t *)v15 != v84)
        {
          v85 = &v98[v99 & 0xFFFFFFFFFFFFFFF8LL];
          v100 = v99 - 8;
          if (v100 >= 0x38)
          {
            v102 = v97;
            if ((unint64_t)((char *)&v95[v97] - (char *)v84) < 0x20)
            {
              v101 = (char *)&v95[v94 >> 2];
              goto LABEL_131;
            }

            v103 = (v100 >> 3) + 1;
            v104 = 8 * (v103 & 0x3FFFFFFFFFFFFFFCLL);
            v101 = &v98[v104];
            v105 = (__int128 *)(v84 + 2);
            v106 = &v95[v102 + 2];
            v107 = v103 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v108 = *v105;
              *((_OWORD *)v106 - 1) = *(v105 - 1);
              *(_OWORD *)v106 = v108;
              v105 += 2;
              v106 += 4;
              v107 -= 4LL;
            }

            while (v107);
            if (v103 != (v103 & 0x3FFFFFFFFFFFFFFCLL))
            {
              v84 = (uint64_t *)((char *)v84 + v104);
              goto LABEL_131;
            }
          }

          else
          {
            v101 = (char *)&v95[v94 >> 2];
            do
            {
LABEL_131:
              v109 = *v84++;
              *(void *)v101 = v109;
              v101 += 8;
            }

            while (v101 != v85);
          }
        }

        uint64_t v15 = (uint64_t)&v95[v94];
        if (__src)
        {
          v84 = &v95[v94 >> 2];
          free(__src);
        }

        else
        {
          v84 = (uint64_t *)v98;
        }

        id v33 = v96;
        goto LABEL_108;
      }

      v88 = v84 - v33;
      if (v88 >= -1) {
        v89 = v88 + 1;
      }
      else {
        v89 = v88 + 2;
      }
      v90 = v89 >> 1;
      v91 = (char *)&v84[-(v89 >> 1)];
      v92 = (void *)v15;
      if ((uint64_t *)v15 != v84)
      {
        memmove(v91, v84, v15 - (void)v84);
        v92 = v84;
      }

      v93 = -v90;
      v85 = &v91[v15 - (void)v84];
      v84 = &v92[v93];
    }

    if (v49) {
      free(v49);
    }
    BOOL v18 = 0LL;
    BOOL v28 = 0LL;
    goto LABEL_33;
  }

  __break(1u);
  return result;
}

        if (v82) {
          free(v82);
        }
        *((_WORD *)v33 + 120) = -1;
        goto LABEL_99;
      }

      __int16 v39 = *(void *)(*(void *)(a1 + 48) + 16LL);
      if (!v39 || nw_path_parameters_get_logging_disabled(*(void *)(v39 + 104)))
      {
LABEL_82:

        int v24 = 0LL;
LABEL_83:

        goto LABEL_84;
      }

      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      __int16 v40 = (id)glistenerLogObj;
      uint64_t v41 = nw_listener_get_id_string(*(void **)(a1 + 48));
      *(_DWORD *)buf = 136446722;
      v97 = "nw_listener_reconcile_advertised_endpoints_block_invoke";
      v98 = 2082;
      v99 = v41;
      v100 = 2112;
      v101 = (uint64_t)bonjour_service;
      uint64_t v42 = (char *)_os_log_send_and_compose_impl();

      v89[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v42, v89, &type))
      {
        if (v89[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
          }
          BOOL v43 = (os_log_s *)(id)glistenerLogObj;
          os_log_type_t v44 = v89[0];
          if (os_log_type_enabled(v43, v89[0]))
          {
            os_log_type_t v45 = nw_listener_get_id_string(*(void **)(a1 + 48));
            *(_DWORD *)buf = 136446722;
            v97 = "nw_listener_reconcile_advertised_endpoints_block_invoke";
            v98 = 2082;
            v99 = v45;
            v100 = 2112;
            v101 = (uint64_t)bonjour_service;
            _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s [%{public}s] failed to create advertiser for %@",  buf,  0x20u);
          }
        }

        else if (type)
        {
          v53 = __nw_create_backtrace_string();
          if (v53)
          {
            os_log_type_t v54 = (char *)v53;
            if (__nwlog_listener_log::onceToken != -1) {
              dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
            }
            BOOL v55 = (os_log_s *)(id)glistenerLogObj;
            v56 = v89[0];
            if (os_log_type_enabled(v55, v89[0]))
            {
              os_log_type_t v57 = nw_listener_get_id_string(*(void **)(a1 + 48));
              *(_DWORD *)buf = 136446978;
              v97 = "nw_listener_reconcile_advertised_endpoints_block_invoke";
              v98 = 2082;
              v99 = v57;
              v100 = 2112;
              v101 = (uint64_t)bonjour_service;
              v102 = 2082;
              v103 = v54;
              _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s [%{public}s] failed to create advertiser for %@, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v54);
            goto LABEL_80;
          }

          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
          }
          BOOL v43 = (os_log_s *)(id)glistenerLogObj;
          os_log_type_t v60 = v89[0];
          if (os_log_type_enabled(v43, v89[0]))
          {
            v61 = nw_listener_get_id_string(*(void **)(a1 + 48));
            *(_DWORD *)buf = 136446722;
            v97 = "nw_listener_reconcile_advertised_endpoints_block_invoke";
            v98 = 2082;
            v99 = v61;
            v100 = 2112;
            v101 = (uint64_t)bonjour_service;
            _os_log_impl( &dword_181A5C000,  v43,  v60,  "%{public}s [%{public}s] failed to create advertiser for %@, no backtrace",  buf,  0x20u);
          }
        }

        else
        {
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
          }
          BOOL v43 = (os_log_s *)(id)glistenerLogObj;
          BOOL v58 = v89[0];
          if (os_log_type_enabled(v43, v89[0]))
          {
            os_log_type_t v59 = nw_listener_get_id_string(*(void **)(a1 + 48));
            *(_DWORD *)buf = 136446722;
            v97 = "nw_listener_reconcile_advertised_endpoints_block_invoke";
            v98 = 2082;
            v99 = v59;
            v100 = 2112;
            v101 = (uint64_t)bonjour_service;
            _os_log_impl( &dword_181A5C000,  v43,  v58,  "%{public}s [%{public}s] failed to create advertiser for %@, backtrace limit exceeded",  buf,  0x20u);
          }
        }
      }

    if (v47) {
      free(v47);
    }

    goto LABEL_99;
  }

  uint32_t v9 = v6;
  int v10 = *(id *)(v9[13] + 160LL);

  if (v10)
  {
LABEL_5:
    objc_storeStrong((id *)v8 + 2, a2);
    uint64_t v11 = v9;
    uint64_t v12 = *(id *)(v9[13] + 136LL);

    uint64_t v13 = (void *)*((void *)v8 + 3);
    *((void *)v8 + 3) = v12;

    uint64_t v14 = (uint64_t *)(v8 + 32);
    objc_storeStrong((id *)v8 + 4, a3);
    nw_parameters_set_server_mode(*((void **)v8 + 2), 1);
    do
    {
      uint64_t v15 = __ldaxr(nw_listener_get_next_id(void)::s_last_listener_id);
      BOOL v16 = v15 + 1;
    }

    while (__stlxr(v15 + 1, nw_listener_get_next_id(void)::s_last_listener_id));
    uint64_t v17 = (unsigned __int16)(v15 + 1);
    if (v16 >= 0x10000 && v17 == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        id v62 = "nw_listener_get_next_id";
        char v63 = 1024;
        LODWORD(v64) = v16;
        _os_log_impl(&dword_181A5C000, v19, OS_LOG_TYPE_ERROR, "%{public}s reached %u listeners, wrapping", buf, 0x12u);
      }
    }

    *((_WORD *)v8 + 20) = v16;
    snprintf(v8 + 42, 6uLL, "L%u", v17);
    uint64_t v20 = nw_parameters_copy_description_internal(*((NWConcrete_nw_parameters **)v8 + 2), 0);
    char v21 = *((void *)v8 + 2);
    if (*v14)
    {
      if (!v21 || nw_path_parameters_get_logging_disabled(*(void *)(v21 + 104))) {
        goto LABEL_37;
      }
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      os_log_type_t v22 = (id)glistenerLogObj;
      if (!os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_DEBUG))
      {
LABEL_36:

LABEL_37:
        if (v20) {
          free(v20);
        }
        *((_DWORD *)v8 + 26) = -1;
        os_log_type_t v30 = v8;
        goto LABEL_48;
      }

      char v23 = "<NULL>";
      int v24 = *v14;
      if (v20) {
        char v23 = v20;
      }
      *(_DWORD *)buf = 136446978;
      id v62 = "-[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]";
      char v63 = 2082;
      v64 = v8 + 42;
      v65 = 2082;
      v66 = v23;
      __int16 v67 = 2114;
      v68 = v24;
      uint64_t v25 = "%{public}s [%{public}s] created: <%{public}s, %{public}@>";
      id v26 = (os_log_s *)v22;
      uint64_t v27 = 42;
    }

    else
    {
      if (!v21 || nw_path_parameters_get_logging_disabled(*(void *)(v21 + 104))) {
        goto LABEL_37;
      }
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      os_log_type_t v22 = (id)glistenerLogObj;
      if (!os_log_type_enabled((os_log_t)v22, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_36;
      }
      os_log_type_t v29 = "<NULL>";
      *(_DWORD *)buf = 136446722;
      id v62 = "-[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]";
      char v63 = 2082;
      if (v20) {
        os_log_type_t v29 = v20;
      }
      v64 = v8 + 42;
      v65 = 2082;
      v66 = v29;
      uint64_t v25 = "%{public}s [%{public}s] created: <%{public}s>";
      id v26 = (os_log_s *)v22;
      uint64_t v27 = 32;
    }

    _os_log_impl(&dword_181A5C000, v26, OS_LOG_TYPE_DEBUG, v25, buf, v27);
    goto LABEL_36;
  }

  *(_WORD *)buf = 0;
  if ((nw_utilities_port_for_string("0", buf) & 1) != 0)
  {
    host_with_numeric_port = nw_endpoint_create_host_with_numeric_port("::", bswap32(*(unsigned __int16 *)buf) >> 16);
    if (host_with_numeric_port)
    {
      nw_parameters_set_local_endpoint((nw_parameters_t)v9, (nw_endpoint_t)host_with_numeric_port);

      goto LABEL_5;
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v31 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  id v62 = "-[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]";
  char v32 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v58 = 0;
  if (__nwlog_fault(v32, &type, &v58))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v33 = (os_log_s *)(id)gLogObj;
      id v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        id v62 = "-[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]";
        _os_log_impl(&dword_181A5C000, v33, v34, "%{public}s nw_endpoint_create_host failed", buf, 0xCu);
      }
    }

    else if (v58)
    {
      __int16 v36 = __nw_create_backtrace_string();
      if (v36)
      {
        uint64_t v37 = (char *)v36;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v38 = (os_log_s *)(id)gLogObj;
        __int16 v39 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446466;
          id v62 = "-[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]";
          char v63 = 2082;
          v64 = v37;
          _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s nw_endpoint_create_host failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v37);
        if (!v32) {
          goto LABEL_47;
        }
        goto LABEL_46;
      }

      __nwlog_obj();
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v41 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        id v62 = "-[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]";
        _os_log_impl(&dword_181A5C000, v33, v41, "%{public}s nw_endpoint_create_host failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v33 = (os_log_s *)(id)gLogObj;
      __int16 v40 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        id v62 = "-[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]";
        _os_log_impl( &dword_181A5C000,  v33,  v40,  "%{public}s nw_endpoint_create_host failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v32) {
LABEL_46:
  }
    free(v32);
LABEL_47:
  os_log_type_t v30 = 0LL;
LABEL_48:

LABEL_49:
  return v30;
}

            v96 = 0LL;
            goto LABEL_97;
          }

          if (sa_family == 2)
          {
            v95 = objc_alloc_init(MEMORY[0x189603FB8]);
            buf[0] = 0;
            [v95 appendBytes:buf length:1];
            v130[0] = 4;
            [v95 appendBytes:v130 length:1];
            [v95 appendBytes:&v93->sa_data[2] length:4];
            v124 = 32;
            [v95 appendBytes:&v124 length:1];
            if (v95) {
              goto LABEL_95;
            }
            goto LABEL_96;
          }
        }

        v96 = 0LL;
        goto LABEL_98;
      }

      v85 = (void *)_nw_http_response_create_well_known(405LL);
      nw_http_fields_append(v85, (uint64_t)"Capsule-Protocol", (uint64_t)"?1");
      v81 = (id)[v12 mutableCopy];
      [v81 appendString:@"; error=resource_uses_reverse_proxy"];
      nw_http_fields_append(v85, (uint64_t)"Proxy-Status", [v81 UTF8String]);
      os_log_type_t v30 = v85;
    }

    else
    {
      v76 = (void *)_nw_http_response_create_well_known(200LL);
      os_log_type_t v30 = v76;
      if (*(_BYTE *)(a1 + 48) != 6)
      {
        nw_http_fields_append(v76, (uint64_t)"Capsule-Protocol", (uint64_t)"?1");
        if (*(_BYTE *)(a1 + 48) == 17)
        {
          v77 = *(void *)(a1 + 32);
          if (*(_BYTE *)(v77 + 178))
          {
            nw_http_fields_append(v30, (uint64_t)"Datagram-Flow-Id", v77 + 178);
            v77 = *(void *)(a1 + 32);
          }

          v79 = *(unsigned __int8 *)(v77 + 116);
          v78 = v77 + 116;
          if (v79) {
            nw_http_fields_append(v30, (uint64_t)"Client-Connection-Id", v78);
          }
          nw_http_fields_append(v30, (uint64_t)"Proxy-QUIC-Forwarding", (uint64_t)"?1");
        }
      }

      v80 = *(void *)(a1 + 32);
      if (*(_BYTE *)(v80 + 220)) {
        goto LABEL_83;
      }
      v81 = nw_connection_copy_connected_remote_endpoint(*(void **)(v80 + 48));
      if (v81)
      {
        v82 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:v12];
        [v82 appendFormat:@"; next-hop=%@", v81];
        v83 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithFormat:&stru_189BCAF98];
        v117[0] = MEMORY[0x1895F87A8];
        v117[1] = 3221225472LL;
        v117[2] = ___ZL54nw_masque_connection_pair_setup_outer_connection_innerP36NWConcrete_nw_masque_connection_pairPU25objcproto14OS_nw_endpoint8NSObjecthPU27objcproto16OS_nw_parametersS1__block_invoke_280;
        v117[3] = &unk_189BC5E38;
        v84 = v83;
        v118 = v84;
        nw_endpoint_enumerate_cnames(v81, v117);
        if ([v84 length]) {
          [v82 appendFormat:@"; next-hop-aliases=%@", v84];
        }
        nw_http_fields_append(v30, (uint64_t)"Proxy-Status", [v82 UTF8String]);
      }
    }

LABEL_83:
    os_log_type_t v29 = 0LL;
    goto LABEL_84;
  }

  v46 = (id *)*(id *)(a1 + 32);
  v47 = v46;
  if (!v46)
  {
    __nwlog_obj();
    v105 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_start_waiting_timer";
    v106 = (char *)_os_log_send_and_compose_impl();

    v130[0] = 16;
    v124 = 0;
    if (__nwlog_fault(v106, v130, &v124))
    {
      if (v130[0] == 17)
      {
        __nwlog_obj();
        v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v108 = v130[0];
        if (os_log_type_enabled(v107, (os_log_type_t)v130[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_start_waiting_timer";
          _os_log_impl(&dword_181A5C000, v107, v108, "%{public}s called with null pair", buf, 0xCu);
        }
      }

      else if (v124)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v110 = v130[0];
        v111 = os_log_type_enabled(v107, (os_log_type_t)v130[0]);
        if (backtrace_string)
        {
          if (v111)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_start_waiting_timer";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v107,  v110,  "%{public}s called with null pair, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_130;
        }

        if (v111)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_start_waiting_timer";
          _os_log_impl(&dword_181A5C000, v107, v110, "%{public}s called with null pair, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v107 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v112 = v130[0];
        if (os_log_type_enabled(v107, (os_log_type_t)v130[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_start_waiting_timer";
          _os_log_impl( &dword_181A5C000,  v107,  v112,  "%{public}s called with null pair, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

        free(v49);
        goto LABEL_107;
      }

      uint64_t v20 = *(_DWORD *)(a2 + 8);
      if (gLogDatapath)
      {
        v68 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v93 = "on_begin_headers_callback";
          v94 = 2082;
          v95 = a3 + 205;
          _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s detected new stream initiated from remote side of the connection, allocating new stream",  buf,  0x16u);
        }
      }

      char v21 = calloc(1uLL, 0x28uLL);
      if (v21)
      {
        os_log_type_t v22 = *(void **)(a3 + 88);
        if (v22) {
          goto LABEL_29;
        }
      }

      else
      {
        v69 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        v93 = "strict_calloc";
        v94 = 2048;
        v95 = 1LL;
        v96 = 2048;
        *(void *)v97 = 40LL;
        v70 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort((uint64_t)v70);
        if ((_DWORD)result)
        {
          __break(1u);
          return result;
        }

        free(v70);
        os_log_type_t v22 = *(void **)(a3 + 88);
        if (v22)
        {
LABEL_29:
          char v23 = v22;
          int v24 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v23,  0,  0);

          nw_http2_transport_stream_init((uint64_t)v21);
          v21[8] = v20;
          *((_BYTE *)v21 + 36) |= 8u;
          if (v20 > *(_DWORD *)(a3 + 200) && (*(_BYTE *)(a3 + 204) & 1) == 0) {
            *(_DWORD *)(a3 + 200) = v20;
          }
          if (!nw_http2_transport_add_to_id_table(a3, (uint64_t)v21, 0LL))
          {
            v53 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v93 = "on_begin_headers_callback";
              v94 = 2082;
              v95 = a3 + 205;
              _os_log_impl( &dword_181A5C000,  v53,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s failed to add new stream to the id based hash table",  buf,  0x16u);
            }

            free(v21);
            if (v24) {
              os_release((void *)v24);
            }
            return 4294966775LL;
          }

          nw_parameters_set_server_mode((void *)v24, 1);
          *(void *)os_log_type_t type = 0LL;
          v88 = type;
          v89 = 0x2000000000LL;
          v90 = 0LL;
          if (nw_protocol_http2_transport_identifier::onceToken[0] != -1) {
            dispatch_once(nw_protocol_http2_transport_identifier::onceToken, &__block_literal_global_36918);
          }
          uint64_t v25 = MEMORY[0x1895F87A8];
          v86[0] = MEMORY[0x1895F87A8];
          v86[1] = 0x40000000LL;
          v86[2] = ___ZL25on_begin_headers_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke;
          v86[3] = &unk_189BBCEE8;
          v86[4] = type;
          nw_protocol_parameters_iterate_stack((void *)v24, 4, &g_http2_transport_protocol_identifier, v86);
          if (!*((void *)v88 + 3))
          {
            if (nw_protocol_http2_transport_identifier::onceToken[0] != -1) {
              dispatch_once(nw_protocol_http2_transport_identifier::onceToken, &__block_literal_global_36918);
            }
            v85[0] = v25;
            v85[1] = 0x40000000LL;
            v85[2] = ___ZL25on_begin_headers_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_2;
            v85[3] = &unk_189BBCF10;
            v85[4] = type;
            nw_protocol_parameters_iterate_stack((void *)v24, 3, &g_http2_transport_protocol_identifier, v85);
            if (!*((void *)v88 + 3))
            {
              if (nw_protocol_http2_transport_identifier::onceToken[0] != -1) {
                dispatch_once(nw_protocol_http2_transport_identifier::onceToken, &__block_literal_global_36918);
              }
              v84[0] = v25;
              v84[1] = 0x40000000LL;
              v84[2] = ___ZL25on_begin_headers_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_3;
              v84[3] = &unk_189BBCF38;
              v84[4] = type;
              nw_protocol_parameters_iterate_stack((void *)v24, 2, &g_http2_transport_protocol_identifier, v84);
            }
          }

          id v26 = xpc_int64_create(v20);
          nw_parameters_set_protocol_value(*((void **)v88 + 3), "incomingStreamId", v26);
          if (v26) {
            xpc_release(v26);
          }
          if (gLogDatapath)
          {
            v80 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
            {
              v81 = *((void *)v88 + 3);
              *(_DWORD *)buf = 136446978;
              v93 = "on_begin_headers_callback";
              v94 = 2082;
              v95 = a3 + 205;
              v96 = 2048;
              *(void *)v97 = v24;
              *(_WORD *)&v97[8] = 2048;
              *(void *)&v97[10] = v81;
              _os_log_impl( &dword_181A5C000,  v80,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s using parameters %p, protocol parameters %p on new incoming stream",  buf,  0x2Au);
            }
          }

          uint64_t v27 = v88;
          BOOL v28 = (void *)*((void *)v88 + 3);
          if (v28)
          {
            os_release(v28);
            uint64_t v27 = v88;
            *((void *)v88 + 3) = 0LL;
          }

          *((void *)v27 + 3) = 0LL;
          os_log_type_t v29 = *(void ***)(a3 + 104);
          if (v29 && (os_log_type_t v30 = *v29) != 0LL && *v30)
          {
            if (gLogDatapath)
            {
              v82 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                v93 = "on_begin_headers_callback";
                v94 = 2082;
                v95 = a3 + 205;
                v96 = 1024;
                *(_DWORD *)v97 = v20;
                _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s calling listen handler for new stream %d",  buf,  0x1Cu);
              }
            }

            os_log_type_t v31 = (***(uint64_t (****)(void, void, BOOL))(a3 + 104))( *(void *)(a3 + 104),  *(void *)(a3 + 96),  v24);
            if (gLogDatapath)
            {
              v83 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                v93 = "on_begin_headers_callback";
                v94 = 2082;
                v95 = a3 + 205;
                v96 = 1024;
                *(_DWORD *)v97 = v20;
                _os_log_impl( &dword_181A5C000,  v83,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called into listen handler for new stream %d",  buf,  0x1Cu);
              }
            }

            if ((v31 & 1) == 0)
            {
              char v32 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446722;
                v93 = "on_begin_headers_callback";
                v94 = 2082;
                v95 = a3 + 205;
                v96 = 1024;
                *(_DWORD *)v97 = v20;
                _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s listen handler didn't accept the new flow for stream id %d",  buf,  0x1Cu);
              }

              nw_http2_transport_stream_close(a3, (uint64_t)v21);
            }

            if (!v24) {
              goto LABEL_58;
            }
          }

          else
          {
            __int16 v67 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v93 = "on_begin_headers_callback";
              v94 = 2082;
              v95 = a3 + 205;
              _os_log_impl( &dword_181A5C000,  v67,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s listen handler has no new_flow callback, ignoring incoming flow",  buf,  0x16u);
            }

            nw_http2_transport_stream_close(a3, (uint64_t)v21);
            if (!v24) {
              goto LABEL_58;
            }
          }

          os_release((void *)v24);
LABEL_58:
          _Block_object_dispose(type, 8);
          return 0LL;
        }
      }

      __nwlog_obj();
      v71 = a3 + 205;
      *(_DWORD *)buf = 136446466;
      v93 = "on_begin_headers_callback";
      v94 = 2082;
      v95 = a3 + 205;
      v72 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v91 = 0;
      if (__nwlog_fault(v72, type, &v91))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v73 = (os_log_s *)__nwlog_obj();
          v74 = type[0];
          if (os_log_type_enabled(v73, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            v93 = "on_begin_headers_callback";
            v94 = 2082;
            v95 = v71;
            v75 = "%{public}s %{public}s http2_transport->parameters is NULL when opening responder stream";
LABEL_151:
            _os_log_impl(&dword_181A5C000, v73, v74, v75, buf, 0x16u);
          }
        }

        else if (v91)
        {
          v76 = (char *)__nw_create_backtrace_string();
          v73 = (os_log_s *)__nwlog_obj();
          v74 = type[0];
          v77 = os_log_type_enabled(v73, type[0]);
          if (v76)
          {
            if (v77)
            {
              *(_DWORD *)buf = 136446722;
              v93 = "on_begin_headers_callback";
              v94 = 2082;
              v95 = v71;
              v96 = 2082;
              *(void *)v97 = v76;
              _os_log_impl( &dword_181A5C000,  v73,  v74,  "%{public}s %{public}s http2_transport->parameters is NULL when opening responder stream, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v76);
            goto LABEL_152;
          }

          if (v77)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "on_begin_headers_callback";
            v94 = 2082;
            v95 = v71;
            v75 = "%{public}s %{public}s http2_transport->parameters is NULL when opening responder stream, no backtrace";
            goto LABEL_151;
          }
        }

        else
        {
          v73 = (os_log_s *)__nwlog_obj();
          v74 = type[0];
          if (os_log_type_enabled(v73, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            v93 = "on_begin_headers_callback";
            v94 = 2082;
            v95 = v71;
            v75 = "%{public}s %{public}s http2_transport->parameters is NULL when opening responder stream, backtrace limit exceeded";
            goto LABEL_151;
          }
        }
      }

  os_log_type_t v57 = *(void *)(v9 + 488);
  if (v57)
  {
    if (*(_BYTE *)(v9 + 158) & 1 | (gLogDatapath == 0)) {
      goto LABEL_98;
    }
    v171 = (os_log_s *)__nwlog_obj();
    v172 = os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG);
    os_log_type_t v57 = *(void *)(v9 + 488);
    if (v172)
    {
      v173 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
      v174 = *(_DWORD *)(v9 + 860);
      if (v57) {
        v175 = *(_DWORD *)(v57 + 424);
      }
      else {
        v175 = 0;
      }
      *(_DWORD *)buf = 136448002;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_finished";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v9 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v173;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v174;
      LOWORD(v262) = 1024;
      *(_DWORD *)((char *)&v262 + 2) = v175;
      WORD3(v262) = 2048;
      *((void *)&v262 + 1) = v9;
      v263 = 2048;
      v264 = v57;
      _os_log_impl( &dword_181A5C000,  v171,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> http connection %p sending input_finished to current stream (%p)",  buf,  0x46u);
      os_log_type_t v57 = *(void *)(v9 + 488);
    }

    if (v57) {
LABEL_98:
    }
      nw_protocol_input_finished(*(void **)(v57 + 48), v57);
    else {
      nw_protocol_input_finished(0LL, 0LL);
    }
    return;
  }

  if (!(*(_BYTE *)(v9 + 158) & 1 | (gLogDatapath == 0)))
  {
    v191 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v191, OS_LOG_TYPE_DEBUG))
    {
      v192 = *(void *)(v9 + 488);
      v193 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
      v194 = *(_DWORD *)(v9 + 860);
      if (v192) {
        LODWORD(v192) = *(_DWORD *)(v192 + 424);
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_input_finished";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v9 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v193;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v194;
      LOWORD(v262) = 1024;
      *(_DWORD *)((char *)&v262 + 2) = v192;
      _os_log_impl( &dword_181A5C000,  v191,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> closing http connection on input_finished, no remaining input",  buf,  0x32u);
    }
  }

  BOOL v58 = *v10;
  os_log_type_t v59 = v58 | (*((unsigned __int8 *)v10 + 2) << 16);
  if ((v58 & 0x100) != 0)
  {
    if ((*(_BYTE *)(v9 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v85 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
        {
          v86 = *(void *)(v9 + 488);
          v87 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
          v88 = *(_DWORD *)(v9 + 860);
          if (v86) {
            LODWORD(v86) = *(_DWORD *)(v86 + 424);
          }
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v9 + 74;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v87;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v88;
          LOWORD(v262) = 1024;
          *(_DWORD *)((char *)&v262 + 2) = v86;
          _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> already closed",  buf,  0x32u);
        }
      }
    }
  }

  else
  {
    *((_BYTE *)v10 + 2) = BYTE2(v59);
    os_log_s *v10 = v59 | 0x100;
    if ((*(_BYTE *)(v9 + 158) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v205 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v205, OS_LOG_TYPE_DEBUG))
        {
          v206 = *(void *)(v9 + 488);
          v207 = *(_DWORD *)(*(void *)(v9 + 480) + 372LL);
          v208 = *(_DWORD *)(v9 + 860);
          if (v206) {
            LODWORD(v206) = *(_DWORD *)(v206 + 424);
          }
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v9 + 74;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&buf[24] = " ";
          *(_WORD *)&buf[32] = 1024;
          *(_DWORD *)&buf[34] = v207;
          *(_WORD *)&buf[38] = 1024;
          *(_DWORD *)&buf[40] = v208;
          LOWORD(v262) = 1024;
          *(_DWORD *)((char *)&v262 + 2) = v206;
          _os_log_impl( &dword_181A5C000,  v205,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> http connection closed, increasing pool width",  buf,  0x32u);
        }
      }
    }

    os_log_type_t v60 = *(void *)(v9 + 480);
    if (!v60)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
      v201 = (char *)_os_log_send_and_compose_impl();
      v265[0] = 16;
      v257[0] = OS_LOG_TYPE_DEFAULT;
      if (v265[0] == 17)
      {
        v202 = (os_log_s *)__nwlog_obj();
        v203 = v265[0];
        if (!os_log_type_enabled(v202, (os_log_type_t)v265[0])) {
          goto LABEL_465;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        v204 = "%{public}s called with null http1";
      }

      else if (v257[0])
      {
        v209 = (char *)__nw_create_backtrace_string();
        v202 = (os_log_s *)__nwlog_obj();
        v203 = v265[0];
        v210 = os_log_type_enabled(v202, (os_log_type_t)v265[0]);
        if (v209)
        {
          if (v210)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v209;
            _os_log_impl( &dword_181A5C000,  v202,  v203,  "%{public}s called with null http1, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v209);
          goto LABEL_465;
        }

        if (!v210)
        {
LABEL_465:
          if (!v201) {
            goto LABEL_226;
          }
          goto LABEL_466;
        }

        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        v204 = "%{public}s called with null http1, no backtrace";
      }

      else
      {
        v202 = (os_log_s *)__nwlog_obj();
        v203 = v265[0];
        if (!os_log_type_enabled(v202, (os_log_type_t)v265[0])) {
          goto LABEL_465;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        v204 = "%{public}s called with null http1, backtrace limit exceeded";
      }

      v223 = buf;
      goto LABEL_464;
    }

    v61 = *v10;
    id v62 = v61 | (*((unsigned __int8 *)v10 + 2) << 16);
    if ((v61 & 0x800) == 0)
    {
      *((_BYTE *)v10 + 2) = BYTE2(v62);
      os_log_s *v10 = v62 | 0x800;
      char v63 = *(unsigned int *)(v60 + 368) + 1LL;
      v64 = v63 << 31 >> 31;
      *(_DWORD *)(v60 + 368) = v63;
      if (v64 != v63 || v64 < 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v65 = *(unsigned int *)(v60 + 368);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "http1->nonresuable_connections";
        *(_WORD *)&buf[22] = 2048;
        *(void *)&buf[24] = 1LL;
        *(_WORD *)&buf[32] = 2048;
        *(void *)&buf[34] = v65;
        v66 = (char *)_os_log_send_and_compose_impl();
        v265[0] = 16;
        v257[0] = OS_LOG_TYPE_DEFAULT;
        if (v265[0] != 17)
        {
          if (v257[0])
          {
            v110 = (char *)__nw_create_backtrace_string();
            __int16 v67 = (os_log_s *)__nwlog_obj();
            v68 = v265[0];
            v111 = os_log_type_enabled(v67, (os_log_type_t)v265[0]);
            if (v110)
            {
              if (v111)
              {
                v112 = *(unsigned int *)(v60 + 368);
                *(_DWORD *)buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = "http1->nonresuable_connections";
                *(_WORD *)&buf[22] = 2048;
                *(void *)&buf[24] = 1LL;
                *(_WORD *)&buf[32] = 2048;
                *(void *)&buf[34] = v112;
                *(_WORD *)&buf[42] = 2082;
                *(void *)&v262 = v110;
                _os_log_impl( &dword_181A5C000,  v67,  v68,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v110);
              goto LABEL_218;
            }

            if (!v111) {
              goto LABEL_218;
            }
            v136 = *(unsigned int *)(v60 + 368);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->nonresuable_connections";
            *(_WORD *)&buf[22] = 2048;
            *(void *)&buf[24] = 1LL;
            *(_WORD *)&buf[32] = 2048;
            *(void *)&buf[34] = v136;
            v70 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          }

          else
          {
            __int16 v67 = (os_log_s *)__nwlog_obj();
            v68 = v265[0];
            if (!os_log_type_enabled(v67, (os_log_type_t)v265[0])) {
              goto LABEL_218;
            }
            v135 = *(unsigned int *)(v60 + 368);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_connection_mark_do_not_reuse";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->nonresuable_connections";
            *(_WORD *)&buf[22] = 2048;
            *(void *)&buf[24] = 1LL;
            *(_WORD *)&buf[32] = 2048;
            *(void *)&buf[34] = v135;
            v70 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          }

    if (v59) {
      free(v59);
    }
    *(_DWORD *)(v45 + 336) = 0;
    uint64_t v12 = &qword_18C45F000;
    v47 = MEMORY[0x1895F87A8];
    if ((*(_BYTE *)(v45 + 158) & 1) != 0)
    {
LABEL_100:
      if ((*(_WORD *)(v46 + 872) & 0x800) == 0) {
        goto LABEL_122;
      }
      v69 = *(_DWORD *)(v45 + 368);
      *(_DWORD *)(v45 + 368) = v69 - 1;
      if (v69)
      {
        if ((*(_BYTE *)(v45 + 158) & 1) != 0) {
          goto LABEL_122;
        }
        goto LABEL_121;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v70 = *(unsigned int *)(v45 + 368);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = "http1->nonresuable_connections";
      *(_WORD *)&buf[22] = 2048;
      v209 = 1LL;
      *(_WORD *)v210 = 2048;
      *(void *)&v210[2] = v70;
      v71 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v213) = 16;
      v203 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v71, &v213, &v203))
      {
        if (v213 == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v72 = (os_log_s *)gLogObj;
          v73 = v213;
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v213)) {
            goto LABEL_118;
          }
          v74 = *(unsigned int *)(v45 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          v209 = 1LL;
          *(_WORD *)v210 = 2048;
          *(void *)&v210[2] = v74;
          v75 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_117:
          _os_log_impl(&dword_181A5C000, v72, v73, v75, buf, 0x2Au);
          goto LABEL_118;
        }

        if (v203 == OS_LOG_TYPE_DEFAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v72 = (os_log_s *)gLogObj;
          v73 = v213;
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v213)) {
            goto LABEL_118;
          }
          v79 = *(unsigned int *)(v45 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          v209 = 1LL;
          *(_WORD *)v210 = 2048;
          *(void *)&v210[2] = v79;
          v75 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_117;
        }

        v76 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v72 = (os_log_s *)gLogObj;
        v73 = v213;
        v77 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v213);
        if (!v76)
        {
          if (!v77) {
            goto LABEL_118;
          }
          v80 = *(unsigned int *)(v45 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          v209 = 1LL;
          *(_WORD *)v210 = 2048;
          *(void *)&v210[2] = v80;
          v75 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_117;
        }

        if (v77)
        {
          v78 = *(unsigned int *)(v45 + 368);
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_http1_remove_connection";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "http1->nonresuable_connections";
          *(_WORD *)&buf[22] = 2048;
          v209 = 1LL;
          *(_WORD *)v210 = 2048;
          *(void *)&v210[2] = v78;
          *(_WORD *)&v210[10] = 2082;
          *(void *)&v210[12] = v76;
          _os_log_impl( &dword_181A5C000,  v72,  v73,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
        }

        free(v76);
      }

        *(_DWORD *)buf = 136446466;
        v53 = "nw_storage_flush_block_invoke";
        os_log_type_t v54 = 2082;
        BOOL v55 = backtrace_string;
        os_log_type_t v35 = "%{public}s Failed to bind variable, dumping backtrace:%{public}s";
        goto LABEL_97;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v53 = "nw_storage_flush_block_invoke";
      BOOL v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v49 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = (os_log_s *)(id)gLogObj;
        BOOL v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_storage_flush_block_invoke";
          uint64_t v19 = "%{public}s Failed to bind variable";
LABEL_141:
          _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
          goto LABEL_142;
        }

        goto LABEL_142;
      }

      if (!v49)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_storage_flush_block_invoke";
          uint64_t v19 = "%{public}s Failed to bind variable, backtrace limit exceeded";
          goto LABEL_141;
        }

        goto LABEL_142;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v18 = type;
      os_log_type_t v29 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_storage_flush_block_invoke";
          uint64_t v19 = "%{public}s Failed to bind variable, no backtrace";
          goto LABEL_141;
        }

        goto LABEL_142;
      }

      if (v29) {
        goto LABEL_96;
      }
LABEL_98:

      free(backtrace_string);
      if (!v16) {
        goto LABEL_145;
      }
      goto LABEL_144;
    }

    uint64_t v20 = v12[6];
    if (!v20)
    {
      if (sqlite3_prepare_v2(v12[3], "DELETE FROM network_storage WHERE key = ? AND os_log_type_t type = ?", -1, v12 + 6, 0LL))
      {
        __nwlog_obj();
        os_log_type_t v30 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v53 = "nw_storage_flush_block_invoke";
        os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v49 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          char v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v24 = type;
          if (os_log_type_enabled(v23, type))
          {
            *(_DWORD *)buf = 136446210;
            v53 = "nw_storage_flush_block_invoke";
            uint64_t v25 = "%{public}s Failed to prepare statement";
            goto LABEL_132;
          }

      free(v27);
      goto LABEL_97;
    }

    if (v91 == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_url_log::onceToken != -1) {
        dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
      }
      BOOL v28 = (os_log_s *)(id)gurlLogObj;
      os_log_type_t v29 = v91;
      if (!os_log_type_enabled(v28, v91)) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
      os_log_type_t v30 = "%{public}s SecPolicySetSSLHostname failed";
    }

    else
    {
      if (v90)
      {
        v53 = (char *)__nw_create_backtrace_string();
        if (__nwlog_url_log::onceToken != -1) {
          dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
        }
        os_log_type_t v54 = (os_log_s *)(id)gurlLogObj;
        BOOL v55 = v91;
        v56 = os_log_type_enabled(v54, v91);
        if (v53)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
            v95 = 2082;
            *(void *)v96 = v53;
            _os_log_impl( &dword_181A5C000,  v54,  v55,  "%{public}s SecPolicySetSSLHostname failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v53);
          int v24 = v25;
          if (!v27) {
            goto LABEL_97;
          }
        }

        else
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446210;
            v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
            _os_log_impl( &dword_181A5C000,  v54,  v55,  "%{public}s SecPolicySetSSLHostname failed, no backtrace",  buf,  0xCu);
          }

          int v24 = v25;
          if (!v27) {
            goto LABEL_97;
          }
        }

        goto LABEL_96;
      }

      if (__nwlog_url_log::onceToken != -1) {
        dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
      }
      BOOL v28 = (os_log_s *)(id)gurlLogObj;
      os_log_type_t v29 = v91;
      if (!os_log_type_enabled(v28, v91)) {
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446210;
      v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
      os_log_type_t v30 = "%{public}s SecPolicySetSSLHostname failed, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0xCu);
LABEL_94:

    goto LABEL_95;
  }

              goto LABEL_97;
            }

            if (!v91[0])
            {
              __nwlog_obj();
              BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v65 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl( &dword_181A5C000,  v16,  v65,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_96;
            }

            uint64_t v41 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v60 = type[0];
            v61 = os_log_type_enabled(v16, type[0]);
            if (!v41)
            {
              if (v61)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl( &dword_181A5C000,  v16,  v60,  "%{public}s xpc_dictionary_create failed, no backtrace",  buf,  0xCu);
              }

              goto LABEL_96;
            }

            if (v61)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v41;
              _os_log_impl( &dword_181A5C000,  v16,  v60,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            uint64_t v15 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v91[0] = 0;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v16 = (os_log_s *)(id)gLogObj;
              v49 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_181A5C000, v16, v49, "%{public}s nw_dictionary_create failed", buf, 0xCu);
              }

              goto LABEL_96;
            }

            if (!v91[0])
            {
              __nwlog_obj();
              BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v64 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl( &dword_181A5C000,  v16,  v64,  "%{public}s nw_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_96;
            }

            uint64_t v41 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v57 = type[0];
            BOOL v58 = os_log_type_enabled(v16, type[0]);
            if (!v41)
            {
              if (v58)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl( &dword_181A5C000,  v16,  v57,  "%{public}s nw_dictionary_create failed, no backtrace",  buf,  0xCu);
              }

              goto LABEL_96;
            }

            if (v58)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v41;
              _os_log_impl( &dword_181A5C000,  v16,  v57,  "%{public}s nw_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v39 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_create";
          uint64_t v15 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v91[0] = 0;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v16 = (os_log_s *)(id)gLogObj;
            __int16 v40 = type[0];
            if (os_log_type_enabled(v16, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              _os_log_impl(&dword_181A5C000, v16, v40, "%{public}s nw_dictionary_create failed", buf, 0xCu);
            }

            goto LABEL_96;
          }

          if (!v91[0])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v16 = (os_log_s *)(id)gLogObj;
            os_log_type_t v59 = type[0];
            if (os_log_type_enabled(v16, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              _os_log_impl( &dword_181A5C000,  v16,  v59,  "%{public}s nw_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_96;
          }

          uint64_t v41 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v16 = (os_log_s *)(id)gLogObj;
          v46 = type[0];
          v47 = os_log_type_enabled(v16, type[0]);
          if (!v41)
          {
            if (v47)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              _os_log_impl( &dword_181A5C000,  v16,  v46,  "%{public}s nw_dictionary_create failed, no backtrace",  buf,  0xCu);
            }

            goto LABEL_96;
          }

          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v41;
            _os_log_impl( &dword_181A5C000,  v16,  v46,  "%{public}s nw_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_create";
        uint64_t v15 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v91[0] = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v16 = (os_log_s *)(id)gLogObj;
          uint64_t v17 = type[0];
          if (os_log_type_enabled(v16, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s [nw_service_connector_t init:] failed", buf, 0xCu);
          }

          goto LABEL_96;
        }

        if (!v91[0])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v16 = (os_log_s *)(id)gLogObj;
          os_log_type_t v54 = type[0];
          if (os_log_type_enabled(v16, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            _os_log_impl( &dword_181A5C000,  v16,  v54,  "%{public}s [nw_service_connector_t init:] failed, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_96;
        }

        uint64_t v41 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = (os_log_s *)(id)gLogObj;
        uint64_t v42 = type[0];
        BOOL v43 = os_log_type_enabled(v16, type[0]);
        if (!v41)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            _os_log_impl( &dword_181A5C000,  v16,  v42,  "%{public}s [nw_service_connector_t init:] failed, no backtrace",  buf,  0xCu);
          }

          goto LABEL_96;
        }

        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_service_connector_create";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v41;
          _os_log_impl( &dword_181A5C000,  v16,  v42,  "%{public}s [nw_service_connector_t init:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }
      }

      free(v41);
      if (!v15) {
        goto LABEL_99;
      }
      goto LABEL_98;
    }

    __nwlog_obj();
    v71 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_create";
    v68 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v91[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v72 = type[0];
      if (os_log_type_enabled(v69, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_create";
        _os_log_impl(&dword_181A5C000, v69, v72, "%{public}s called with null queue", buf, 0xCu);
      }
    }

    else if (v91[0])
    {
      v76 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v77 = type[0];
      v78 = os_log_type_enabled(v69, type[0]);
      if (v76)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_service_connector_create";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v76;
          _os_log_impl( &dword_181A5C000,  v69,  v77,  "%{public}s called with null queue, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v76);
LABEL_134:
        if (!v68) {
          goto LABEL_100;
        }
LABEL_135:
        free(v68);
        goto LABEL_100;
      }

      if (v78)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_create";
        _os_log_impl(&dword_181A5C000, v69, v77, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v69 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v80 = type[0];
      if (os_log_type_enabled(v69, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_create";
        _os_log_impl( &dword_181A5C000,  v69,  v80,  "%{public}s called with null queue, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v34) {
      free(v34);
    }
    goto LABEL_98;
  }

        free(v67);
        if (!v50)
        {
LABEL_42:

          *(void *)os_log_type_t type = 0LL;
          __int16 v40 = nw_path_create_assign_message_internal( (size_t *)type,  &v93,  0,  v84,  v90,  *(void **)(a1 + 32),  *(void **)(a1 + 48),  v87);
          if (v40)
          {
            nw_agent_assign( *(NWConcrete_nw_agent **)(a1 + 40),  (unsigned __int8 *)v40,  *(size_t *)type,  (unsigned __int8 *)(*(void *)(a1 + 56) + 8LL),  0);
            uint64_t v41 = (char *)v40;
            goto LABEL_44;
          }

          __nwlog_obj();
          v53 = (void *)objc_claimAutoreleasedReturnValue();
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
          os_log_type_t v54 = (const char *)_os_log_send_and_compose_impl();

          v92 = OS_LOG_TYPE_ERROR;
          v88 = 0;
          if (__nwlog_fault(v54, &v92, &v88))
          {
            if (v92 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v56 = v92;
              if (os_log_type_enabled(v55, v92))
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
                _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s called with null assign_message",  (uint8_t *)buf,  0xCu);
              }
            }

            else if (v88)
            {
              v64 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v65 = v92;
              v66 = os_log_type_enabled(v55, v92);
              if (v64)
              {
                if (v66)
                {
                  LODWORD(buf[0]) = 136446466;
                  *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v64;
                  _os_log_impl( &dword_181A5C000,  v55,  v65,  "%{public}s called with null assign_message, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
                }

                free(v64);
                goto LABEL_135;
              }

              if (v66)
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
                _os_log_impl( &dword_181A5C000,  v55,  v65,  "%{public}s called with null assign_message, no backtrace",  (uint8_t *)buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              BOOL v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v80 = v92;
              if (os_log_type_enabled(v55, v92))
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
                _os_log_impl( &dword_181A5C000,  v55,  v80,  "%{public}s called with null assign_message, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
              }
            }
          }

    if (v63) {
      free(v63);
    }
    mode = 0;
    goto LABEL_99;
  }

  mode = v1->mode;

  if (mode == 2)
  {
    os_log_type_t v4 = nw_endpoint_handler_copy_flow(v2);
    id v5 = (void *)*((void *)v4 + 51);
    if (*((void *)v4 + 129))
    {
      if (!v5) {
        goto LABEL_28;
      }
      id v6 = v5[3];
      if (!v6) {
        goto LABEL_28;
      }
      id v7 = *(uint64_t (**)(void))(v6 + 144);
      if (!v7) {
        goto LABEL_28;
      }
      BOOL v8 = (void *)v5[5];
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v14 = v5[11];
        if (v14) {
          v5[11] = v14 + 1;
        }
        uint32_t v9 = -1;
      }

      else
      {
        uint32_t v9 = 0;
      }

      *(void *)buf = v5;
      buf[8] = v9;
      uint64_t v15 = (void *)*((void *)v4 + 52);
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v17 = *((void *)v4 + 58);
        if (v17) {
          *((void *)v4 + 58) = v17 + 1;
        }
        BOOL v16 = -1;
      }

      else
      {
        BOOL v16 = 0;
      }

      *(void *)os_log_type_t type = (char *)v4 + 376;
      v87 = v16;
      BOOL v18 = v7();
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        if (v8 != &nw_protocol_ref_counted_handle)
        {
LABEL_24:
          if ((v18 & 1) != 0) {
            goto LABEL_79;
          }
LABEL_28:
          uint64_t v19 = v2;
          uint64_t v20 = (*((_BYTE *)v19 + 268) & 0x20) == 0;

          if (v20)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            char v21 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              os_log_type_t v22 = v19;

              char v23 = v22;
              int v24 = (*((_BYTE *)v19 + 268) & 1) == 0;

              if (v24) {
                uint64_t v25 = "";
              }
              else {
                uint64_t v25 = "dry-run ";
              }
              id v26 = nw_endpoint_handler_copy_endpoint(v23);
              logging_description = nw_endpoint_get_logging_description(v26);
              BOOL v28 = v23;
              os_log_type_t v29 = v28;
              os_log_type_t v30 = v28[30];
              else {
                os_log_type_t v31 = off_189BBBBF0[v30];
              }
              v84 = v31;

              char v32 = v29;
              id v33 = "path";
              switch(v2->mode)
              {
                case 0:
                  break;
                case 1:
                  id v33 = "resolver";
                  break;
                case 2:
                  id v33 = nw_endpoint_flow_mode_string(v32[31]);
                  break;
                case 3:
                  id v33 = "proxy";
                  break;
                case 4:
                  id v33 = "fallback";
                  break;
                case 5:
                  id v33 = "transform";
                  break;
                default:
                  id v33 = "unknown-mode";
                  break;
              }

              v83 = v33;

              os_log_type_t v54 = v32;
              BOOL v55 = v22;
              os_unfair_lock_lock((os_unfair_lock_t)v54 + 28);
              v56 = v54[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v54 + 28);

              os_log_type_t v57 = v56;
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
              v90 = 2082;
              id_str = v55->id_str;
              v92 = 2082;
              v93 = v25;
              v94 = 2082;
              v95 = (void *)logging_description;
              v96 = 2082;
              v97 = v84;
              v98 = 2082;
              v99 = v83;
              v100 = 2114;
              v101 = v57;
              v102 = 2082;
              v103 = "keepalive";
              _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] register notification f or %{public}s failed",  buf,  0x52u);
            }

    if (v63) {
      free(v63);
    }
    mode = 0;
    goto LABEL_99;
  }

  mode = v1->mode;

  if (mode == 2)
  {
    os_log_type_t v4 = nw_endpoint_handler_copy_flow(v2);
    id v5 = (void *)*((void *)v4 + 51);
    if (*((void *)v4 + 130))
    {
      if (!v5) {
        goto LABEL_28;
      }
      id v6 = v5[3];
      if (!v6) {
        goto LABEL_28;
      }
      id v7 = *(uint64_t (**)(void))(v6 + 144);
      if (!v7) {
        goto LABEL_28;
      }
      BOOL v8 = (void *)v5[5];
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v14 = v5[11];
        if (v14) {
          v5[11] = v14 + 1;
        }
        uint32_t v9 = -1;
      }

      else
      {
        uint32_t v9 = 0;
      }

      *(void *)buf = v5;
      buf[8] = v9;
      uint64_t v15 = (void *)*((void *)v4 + 52);
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v17 = *((void *)v4 + 58);
        if (v17) {
          *((void *)v4 + 58) = v17 + 1;
        }
        BOOL v16 = -1;
      }

      else
      {
        BOOL v16 = 0;
      }

      *(void *)os_log_type_t type = (char *)v4 + 376;
      v87 = v16;
      BOOL v18 = v7();
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        if (v8 != &nw_protocol_ref_counted_handle)
        {
LABEL_24:
          if ((v18 & 1) != 0) {
            goto LABEL_79;
          }
LABEL_28:
          uint64_t v19 = v2;
          uint64_t v20 = (*((_BYTE *)v19 + 268) & 0x20) == 0;

          if (v20)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            char v21 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              os_log_type_t v22 = v19;

              char v23 = v22;
              int v24 = (*((_BYTE *)v19 + 268) & 1) == 0;

              if (v24) {
                uint64_t v25 = "";
              }
              else {
                uint64_t v25 = "dry-run ";
              }
              id v26 = nw_endpoint_handler_copy_endpoint(v23);
              logging_description = nw_endpoint_get_logging_description(v26);
              BOOL v28 = v23;
              os_log_type_t v29 = v28;
              os_log_type_t v30 = v28[30];
              else {
                os_log_type_t v31 = off_189BBBBF0[v30];
              }
              v84 = v31;

              char v32 = v29;
              id v33 = "path";
              switch(v2->mode)
              {
                case 0:
                  break;
                case 1:
                  id v33 = "resolver";
                  break;
                case 2:
                  id v33 = nw_endpoint_flow_mode_string(v32[31]);
                  break;
                case 3:
                  id v33 = "proxy";
                  break;
                case 4:
                  id v33 = "fallback";
                  break;
                case 5:
                  id v33 = "transform";
                  break;
                default:
                  id v33 = "unknown-mode";
                  break;
              }

              v83 = v33;

              os_log_type_t v54 = v32;
              BOOL v55 = v22;
              os_unfair_lock_lock((os_unfair_lock_t)v54 + 28);
              v56 = v54[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v54 + 28);

              os_log_type_t v57 = v56;
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
              v90 = 2082;
              id_str = v55->id_str;
              v92 = 2082;
              v93 = v25;
              v94 = 2082;
              v95 = (void *)logging_description;
              v96 = 2082;
              v97 = v84;
              v98 = 2082;
              v99 = v83;
              v100 = 2114;
              v101 = v57;
              v102 = 2082;
              v103 = "metadata_changed";
              _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] register notification f or %{public}s failed",  buf,  0x52u);
            }

LABEL_210:
  __break(1u);
  return result;
}

            if (v84) {
              free(v84);
            }
            metadata_for_request = 0LL;
LABEL_60:
            v120 = metadata_for_request;
            v121 |= 1u;
            v48 = *(void *)(*(void *)&buf[8] + 40LL);
            id v33 = v48 != 0;
            if (v48)
            {
              v49 = os_retain(a3);
              os_log_type_t v50 = *(_BYTE *)(v5 + 584);
              if ((v50 & 1) != 0)
              {
                v51 = *(void **)(v5 + 576);
                if (v51)
                {
                  os_release(v51);
                  os_log_type_t v50 = *(_BYTE *)(v5 + 584);
                }
              }

              *(void *)(v5 + 576) = v49;
              *(_BYTE *)(v5 + 584) = v50 | 1;
              if (*(void *)(v5 + 592) && *(void *)(v5 + 608))
              {
                nw_protocol_plugin_retry_begin_async(v5 + 344);
                os_log_type_t v52 = *(dispatch_queue_s **)(v5 + 608);
                block[0] = v16;
                block[1] = 0x40000000LL;
                block[2] = ___ZL24nw_http_redirect_processP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke;
                block[3] = &unk_189BB5D60;
                block[4] = &v99;
                block[5] = buf;
                block[6] = v5;
                dispatch_async(v52, block);
              }

              else
              {
                nw_protocol_plugin_metadata_resume_input(v5 + 200, 3);
                nw_http_redirect_reissue( v5,  (void *)v100[5],  0LL,  *(void *)(v5 + 560),  *(void **)(*(void *)&buf[8] + 40LL));
              }

          if (!v88)
          {
LABEL_212:
            uint64_t v14 = 0LL;
LABEL_13:

            goto LABEL_14;
          }

    if (v93) {
      free(v93);
    }
    os_log_type_t v29 = 0LL;
LABEL_49:

    os_log_type_t v30 = *(void **)(*(void *)(a1 + 32) + 64LL);
    if (!v30) {
      return;
    }
    os_log_type_t v31 = v30;
    char v32 = v31[2];

    if (v32 != 1)
    {
      id v33 = *(void **)(*(void *)(a1 + 32) + 64LL);
      if (!v33) {
        return;
      }
      id v34 = v33;
      os_log_type_t v35 = v34[2];

      if (v35 != 4) {
        return;
      }
    }

    __int16 v36 = (nw_listener_t *)*(id *)(a1 + 32);
    uint64_t v37 = v36;
    if (v36)
    {
      __int16 v38 = v36[11];
      if (v38)
      {
        __int16 v39 = v36;
        __int16 v40 = v39[7];
        uint64_t v41 = v40;
        if (v40)
        {
          uint64_t v42 = v40;
          BOOL v43 = *(id *)(v42[13] + 136LL);

          if (!v43)
          {
            __nwlog_obj();
            v111 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
            v112 = (char *)_os_log_send_and_compose_impl();

            v180[0] = 16;
            handler[0] = 0;
            if (v180[0] == 17)
            {
              __nwlog_obj();
              v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v114 = v180[0];
              if (os_log_type_enabled(v113, (os_log_type_t)v180[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_181A5C000, v113, v114, "%{public}s called with null context", buf, 0xCu);
              }
            }

            else if (handler[0])
            {
              v126 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t type = v180[0];
              v127 = os_log_type_enabled(v113, (os_log_type_t)v180[0]);
              if (v126)
              {
                if (v127)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v126;
                  _os_log_impl( &dword_181A5C000,  v113,  type,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v126);
                if (!v112) {
                  goto LABEL_265;
                }
                goto LABEL_264;
              }

              if (v127)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v113,  type,  "%{public}s called with null context, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              __nwlog_obj();
              v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v143 = v180[0];
              if (os_log_type_enabled(v113, (os_log_type_t)v180[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl( &dword_181A5C000,  v113,  v143,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
              }
            }

            goto LABEL_262;
          }

          os_log_type_t v44 = nw_context_copy_workloop(v43);
          if (v44) {
            goto LABEL_61;
          }
          if (nw_context_copy_implicit_context::onceToken != -1) {
            dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
          }
          os_log_type_t v45 = (id)nw_context_copy_implicit_context::implicit_context;
          os_log_type_t v44 = nw_context_copy_workloop(v45);

          if (v44) {
            goto LABEL_61;
          }
          __nwlog_obj();
          v115 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
          v112 = (char *)_os_log_send_and_compose_impl();

          v180[0] = 16;
          handler[0] = 0;
          if (__nwlog_fault(v112, v180, handler))
          {
            if (v180[0] == 17)
            {
              __nwlog_obj();
              v113 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v116 = v180[0];
              if (os_log_type_enabled(v113, (os_log_type_t)v180[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_group_copy_workloop";
                _os_log_impl(&dword_181A5C000, v113, v116, "%{public}s called with null workloop", buf, 0xCu);
              }

              aBlock = 0LL;
              v110 = 1;
              v66 = cf;
              goto LABEL_211;
            }

            __nwlog_obj();
            v75 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)v132 = 136446210;
            *(void *)&v132[4] = "nw_http_cookie_options_copy_transform_callback";
            LODWORD(v109) = 12;
            v108 = v132;
            v72 = (void *)_os_log_send_and_compose_impl();

            v121 = OS_LOG_TYPE_ERROR;
            v120 = 0;
            if (!__nwlog_fault((const char *)v72, &v121, &v120))
            {
LABEL_207:
              if (!v72)
              {
LABEL_209:

                goto LABEL_210;
              }

    goto LABEL_211;
  }

  BOOL v28 = -[NWConcrete_nw_endpoint_handler initWithEndpoint:parameters:reportCallback:context:parent:identifier:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_endpoint_handler),  v25,  v26,  nw_connection_endpoint_report_on_nw_queue,  v27,  0LL,  v24);
  os_log_type_t v29 = v28;
  if (!v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v39 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_create_with_connected_socket";
    __int16 v40 = (char *)_os_log_send_and_compose_impl();

    v149[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v40, v149, &type) & 1) == 0) {
      goto LABEL_76;
    }
    if (v149[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v41 = (os_log_s *)(id)gLogObj;
      uint64_t v42 = v149[0];
      if (os_log_type_enabled(v41, (os_log_type_t)v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_create_with_connected_socket";
        _os_log_impl( &dword_181A5C000,  v41,  v42,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed",  buf,  0xCu);
      }
    }

    else
    {
      if (type)
      {
        os_log_type_t v52 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v53 = (os_log_s *)(id)gLogObj;
        os_log_type_t v54 = v149[0];
        BOOL v55 = os_log_type_enabled(v53, (os_log_type_t)v149[0]);
        if (v52)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_create_with_connected_socket";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v52;
            _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v52);
          if (!v40) {
            goto LABEL_89;
          }
          goto LABEL_77;
        }

        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_create_with_connected_socket";
          _os_log_impl( &dword_181A5C000,  v53,  v54,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, no backtrace",  buf,  0xCu);
        }

LABEL_76:
        if (!v40)
        {
LABEL_89:
          v47 = 0LL;
          goto LABEL_90;
        }

    if (!v84)
    {
LABEL_212:
      id v26 = 0LL;
      goto LABEL_112;
    }

        v92 = *(void *)(v359 + 32);
        v93 = v92 == v10 || v92 == 0;
        uint64_t v11 = 1;
        if (v93 && v92 != v21)
        {
          if (v92)
          {
            if (*(_UNKNOWN **)(v92 + 40) == &nw_protocol_ref_counted_handle)
            {
              v95 = *(void *)(v92 + 88);
              if (v95)
              {
                v96 = v95 - 1;
                *(void *)(v92 + 88) = v96;
                if (!v96)
                {
                  v97 = *(void (***)(void))(v92 + 64);
                  if (v97)
                  {
                    *(void *)(v92 + 64) = 0LL;
                    v97[2](v97);
                    _Block_release(v97);
                  }

                  if ((*(_BYTE *)(v92 + 72) & 1) != 0)
                  {
                    v98 = *(const void **)(v92 + 64);
                    if (v98) {
                      _Block_release(v98);
                    }
                  }

                  free((void *)v92);
                }
              }
            }
          }

          *(void *)(v359 + 32) = v21;
          if (v21) {
            goto LABEL_219;
          }
        }

        goto LABEL_141;
      case 2:
        if (!identifier)
        {
          if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v214 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
            {
              loga = v214;
              v215 = nw_endpoint_handler_get_id_string(v362);
              v216 = nw_endpoint_handler_dry_run_string(v362);
              v217 = nw_endpoint_handler_copy_endpoint(v362);
              v218 = nw_endpoint_get_logging_description(v217);
              v219 = nw_endpoint_handler_state_string(v362);
              v220 = nw_endpoint_handler_mode_string(v362);
              v221 = nw_endpoint_handler_copy_current_path(v362);
              *(_DWORD *)buf = 136448002;
              v378 = "nw_endpoint_handler_modify_protocol_stack";
              v379 = 2082;
              v380 = (char *)v215;
              v381 = 2082;
              v382 = v216;
              v383 = 2082;
              v384 = (void *)v218;
              v385 = 2082;
              v386 = v219;
              v387 = 2082;
              v388 = v220;
              v389 = 2114;
              v390 = v221;
              v391 = 2082;
              v392 = v12;
              _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot insert NULL prot ocol before %{public}s",  buf,  0x52u);

              goto LABEL_599;
            }

            goto LABEL_600;
          }

          goto LABEL_601;
        }

        os_log_type_t v22 = nw_endpoint_handler_copy_endpoint(v362);
        char v21 = nw_endpoint_handler_create_protocol_for_definition((uint64_t)identifier, v20, v22, v361);

        if (!v21)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v214 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
            goto LABEL_600;
          }
          goto LABEL_541;
        }

        nw_parameters_add_protocol_stack_member(v361, 4, 0xFFFFFFFF, v14);
        nw_endpoint_handler_set_protocol_instance(v362, v14, v20, v21);
        if (!v359)
        {
          __nwlog_obj();
          v321 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v378 = "nw_protocol_utilities_add_input_handler";
          v322 = (char *)_os_log_send_and_compose_impl();

          v375[0] = OS_LOG_TYPE_ERROR;
          v373[0] = OS_LOG_TYPE_DEFAULT;
          if (v375[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v323 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v324 = v375[0];
            if (os_log_type_enabled(v323, v375[0]))
            {
              *(_DWORD *)buf = 136446210;
              v378 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_181A5C000, v323, v324, "%{public}s called with null input_protocol", buf, 0xCu);
            }

            goto LABEL_662;
          }

          if (v373[0])
          {
            v332 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v323 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v333 = v375[0];
            v334 = os_log_type_enabled(v323, v375[0]);
            if (v332)
            {
              if (v334)
              {
                *(_DWORD *)buf = 136446466;
                v378 = "nw_protocol_utilities_add_input_handler";
                v379 = 2082;
                v380 = v332;
                _os_log_impl( &dword_181A5C000,  v323,  v333,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v332);
LABEL_663:
              if (v322) {
                free(v322);
              }
              v359 = 0LL;
LABEL_591:
              v302 = v362;
              v303 = (*((_BYTE *)v302 + 268) & 0x20) == 0;

              if (!v303) {
                goto LABEL_601;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v214 = (os_log_s *)(id)gconnectionLogObj;
              if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
                goto LABEL_600;
              }
              loga = v214;
              v304 = nw_endpoint_handler_get_id_string(v302);
              v305 = nw_endpoint_handler_dry_run_string(v302);
              v306 = nw_endpoint_handler_copy_endpoint(v302);
              v307 = nw_endpoint_get_logging_description(v306);
              v308 = nw_endpoint_handler_state_string(v302);
              v309 = nw_endpoint_handler_mode_string(v302);
              v310 = nw_endpoint_handler_copy_current_path(v302);
              v311 = v310;
              v312 = "invalid";
              if (v359 && *(void *)(v359 + 16)) {
                v312 = *(const char **)(v359 + 16);
              }
              *(_DWORD *)buf = 136448258;
              v378 = "nw_endpoint_handler_modify_protocol_stack";
              v379 = 2082;
              v380 = (char *)v304;
              v381 = 2082;
              v382 = v305;
              v383 = 2082;
              v384 = (void *)v307;
              v385 = 2082;
              v386 = v308;
              v387 = 2082;
              v388 = v309;
              v389 = 2114;
              v390 = v310;
              v391 = 2082;
              v392 = identifier;
              v393 = 2082;
              v394 = (void *)v312;
              _os_log_impl( &dword_181A5C000,  loga,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{public}s below %{public}s",  buf,  0x5Cu);

LABEL_599:
              v214 = loga;
              goto LABEL_600;
            }

            if (v334)
            {
              *(_DWORD *)buf = 136446210;
              v378 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl( &dword_181A5C000,  v323,  v333,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            v323 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v339 = v375[0];
            if (os_log_type_enabled(v323, v375[0]))
            {
              *(_DWORD *)buf = 136446210;
              v378 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl( &dword_181A5C000,  v323,  v339,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
            }
          }

      if (v71) {
        free(v71);
      }
      return 1LL;
    }

    if (handle[194] < 0) {
      return 0LL;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    __int16 v40 = *((_DWORD *)handle + 92);
    *(_DWORD *)buf = 136447234;
    v102 = "nw_protocol_http2_connect";
    v103 = 2082;
    v104 = (char *)(handle + 195);
    v105 = 2080;
    v106 = " ";
    v107 = 1024;
    v108 = v40;
    v109 = 2048;
    *(void *)v110 = a2;
    uint64_t v41 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v99 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v42 = (os_log_s *)gconnectionLogObj;
      BOOL v43 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
LABEL_63:
        os_log_type_t v44 = *((_DWORD *)handle + 92);
        *(_DWORD *)buf = 136447234;
        v102 = "nw_protocol_http2_connect";
        v103 = 2082;
        v104 = (char *)(handle + 195);
        v105 = 2080;
        v106 = " ";
        v107 = 1024;
        v108 = v44;
        v109 = 2048;
        *(void *)v110 = a2;
        os_log_type_t v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra";
LABEL_119:
        _os_log_impl(&dword_181A5C000, v42, v43, v45, buf, 0x30u);
      }

  if (v58) {
    free(v58);
  }
  return 0LL;
}

  if (v59) {
    free(v59);
  }
LABEL_90:
  if (v39 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    BOOL v43 = a1[1].callbacks;
    if (v43)
    {
      os_log_type_t v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
      a1[1].callbacks = v44;
      if (!v44)
      {
        os_log_type_t v45 = *(void (***)(void))a1[1].flow_id;
        if (v45)
        {
          *(void *)a1[1].flow_id = 0LL;
          v45[2](v45);
          _Block_release(v45);
        }

        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v46 = *(const void **)a1[1].flow_id;
          if (v46) {
            _Block_release(v46);
          }
        }

        free(a1);
      }
    }
  }

  if (handle == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
  {
    v47 = output_handler[1].callbacks;
    if (v47)
    {
      v48 = (nw_protocol_callbacks *)((char *)v47 - 1);
      output_handler[1].callbacks = v48;
      if (!v48)
      {
        v49 = *(void (***)(void))output_handler[1].flow_id;
        if (v49)
        {
          *(void *)output_handler[1].flow_id = 0LL;
          v49[2](v49);
          _Block_release(v49);
        }

        if ((output_handler[1].flow_id[8] & 1) != 0)
        {
          os_log_type_t v50 = *(const void **)output_handler[1].flow_id;
          if (v50) {
            _Block_release(v50);
          }
        }

        v51 = output_handler;
        goto LABEL_111;
      }
    }
  }

void sub_181A7FBA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_array_apply(unsigned __int8 *object, uint64_t a2)
{
  if (!object) {
    return 1LL;
  }
  os_log_type_t v4 = object + 40;
  do
    int v5 = __ldxr(v4);
  while (__stxr(v5 + 1, v4));
  if (v5 == 255)
  {
    uint64_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v12);
    if (!result)
    {
      uint64_t v8 = 0LL;
LABEL_18:
      free(v12);
      return v8;
    }
  }

  else
  {
    os_retain(object);
    uint64_t v6 = *((void *)object + 2);
    if (*((void *)object + 3) == v6)
    {
      uint64_t v8 = 1LL;
    }

    else
    {
      unint64_t v7 = 0LL;
      do
      {
        uint64_t v8 = (*(uint64_t (**)(uint64_t, unint64_t, void))(a2 + 16))(a2, v7, *(void *)(v6 + 8 * v7));
        if ((v8 & 1) == 0) {
          break;
        }
        ++v7;
        uint64_t v6 = *((void *)object + 2);
      }

      while (v7 < (*((void *)object + 3) - v6) >> 3);
    }

    do
      int v9 = __ldxr(v4);
    while (__stlxr(v9 - 1, v4));
    os_release(object);
    if (v9) {
      return v8;
    }
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v12);
    if (!result) {
      goto LABEL_18;
    }
  }

  __break(1u);
  return result;
}

NWConcrete_nw_protocol_transform *nw_protocol_transform_copy(void *a1)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1)
  {
    uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_transform);
    id v3 = v2;
    if (v2)
    {
      int v4 = *((_BYTE *)v2 + 8) & 0xFE | v1[8] & 1;
      *((_BYTE *)v2 + 8) = v4;
      unsigned int v5 = v4 & 0xFFFFFFFD | (2 * ((v1[8] >> 1) & 1));
      *((_BYTE *)v2 + 8) = v5;
      unsigned int v6 = v5 & 0xFFFFFFFB | (4 * ((v1[8] >> 2) & 1));
      *((_BYTE *)v2 + 8) = v6;
      unsigned int v7 = v6 & 0xFFFFFFF7 | (8 * ((v1[8] >> 3) & 1));
      *((_BYTE *)v2 + 8) = v7;
      unsigned int v8 = v7 & 0xFFFFFFEF | (16 * ((v1[8] >> 4) & 1));
      *((_BYTE *)v2 + 8) = v8;
      unsigned int v9 = v8 & 0xFFFFFFDF | (32 * ((v1[8] >> 5) & 1));
      *((_BYTE *)v2 + 8) = v9;
      LOBYTE(v9) = v9 & 0xBF | (((v1[8] & 0x40) != 0) << 6);
      *((_BYTE *)v2 + 8) = v9;
      *((_BYTE *)v2 + 8) = v1[8] & 0x80 | v9 & 0x7F;
      int v10 = *((_BYTE *)v2 + 9) & 0xFE | v1[9] & 1;
      *((_BYTE *)v2 + 9) = v10;
      unsigned int v11 = v10 & 0xFFFFFFFD | (2 * ((v1[9] >> 1) & 1));
      *((_BYTE *)v2 + 9) = v11;
      *((_BYTE *)v2 + 9) = v11 & 0xFB | v1[9] & 4;
      *(_OWORD *)&v2->traffic_class = *(_OWORD *)(v1 + 12);
      objc_storeStrong((id *)&v2->replace_endpoint, *((id *)v1 + 4));
      uint64_t v12 = (void *)*((void *)v1 + 5);
      if (v12)
      {
        uint64_t v13 = (OS_xpc_object *)xpc_copy(v12);
        disabled_protocols = v3->disabled_protocols;
        v3->disabled_protocols = v13;
      }

      uint64_t v15 = (void *)*((void *)v1 + 6);
      if (v15)
      {
        BOOL v16 = (OS_xpc_object *)xpc_copy(v15);
        match_url_schemes = v3->match_url_schemes;
        v3->match_url_schemes = v16;
      }

      BOOL v18 = (void *)*((void *)v1 + 7);
      if (v18)
      {
        uint64_t v19 = nw_protocol_stack_copy(v18);
        transform_stack = v3->transform_stack;
        v3->transform_stack = (OS_nw_protocol_stack *)v19;
      }

      char v21 = v3;
      goto LABEL_29;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_protocol_transform_copy";
    char v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault(v23, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v24 = (os_log_s *)(id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_transform_copy";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s [[nw_protocol_stack alloc] init] failed", buf, 0xCu);
        }
      }

      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v24 = (os_log_s *)(id)gLogObj;
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v42 = "nw_protocol_transform_copy";
            __int16 v43 = 2082;
            os_log_type_t v44 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s [[nw_protocol_stack alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v23) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_transform_copy";
          _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s [[nw_protocol_stack alloc] init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v24 = (os_log_s *)(id)gLogObj;
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_transform_copy";
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s [[nw_protocol_stack alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v23)
    {
LABEL_29:

      goto LABEL_30;
    }

LABEL_47:
  if (v32) {
    free(v32);
  }
  id v3 = 0LL;
LABEL_30:

  return v3;
}

    if (!v30) {
      goto LABEL_14;
    }
    BOOL v16 = (char *)v30;
    goto LABEL_13;
  }

  id v3 = v1;
  int v4 = [v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v8 = (id)gLogObj;
    unsigned int v9 = v3;
    int v10 = [v9 type];

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v10;
    LODWORD(v37) = 18;
    unsigned int v11 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v41 = 0;
    if (__nwlog_fault(v11, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          uint64_t v14 = v9;
          uint64_t v15 = objc_msgSend(v14, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v15;
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v41)
      {
        BOOL v18 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v19 = type;
        uint64_t v20 = os_log_type_enabled(v12, type);
        if (v18)
        {
          if (v20)
          {
            char v21 = v9;
            id v22 = objc_msgSend(v21, "type", buf, v37);

            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v22;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v18;
            _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v18);
          if (!v11) {
            goto LABEL_14;
          }
LABEL_12:
          BOOL v16 = (char *)v11;
LABEL_13:
          free(v16);
          goto LABEL_14;
        }

        if (v20)
        {
          os_log_type_t v27 = v9;
          BOOL v28 = objc_msgSend(v27, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v28;
          _os_log_impl(&dword_181A5C000, v12, v19, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (os_log_s *)(id)gLogObj;
        char v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          int v24 = v9;
          os_log_type_t v25 = objc_msgSend(v24, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v25;
          _os_log_impl( &dword_181A5C000,  v12,  v23,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v11)
    {
LABEL_14:
      uint64_t v17 = 0LL;
      goto LABEL_27;
    }

    goto LABEL_12;
  }

  unsigned int v5 = (char *)v3;
  unsigned int v6 = v5;
  if (!v5[288])
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    *(void *)&buf[24] = nw_endpoint_get_sanitized_url(v5);
    if (*(void *)(*(void *)&buf[8] + 24LL))
    {
      v38[0] = MEMORY[0x1895F87A8];
      v38[1] = 3221225472LL;
      v38[2] = __nw_endpoint_get_url_hash_block_invoke;
      v38[3] = &unk_189BC9210;
      char v39 = v6;
      __int16 v40 = buf;
      unsigned int v7 = v39 + 75;
      os_unfair_lock_lock(v39 + 75);
      __nw_endpoint_get_url_hash_block_invoke((BOOL)v38);
      os_unfair_lock_unlock(v7);
    }

    else
    {
      strcpy(v6 + 288, "<null>");
    }

    _Block_object_dispose(buf, 8);
  }

  uint64_t v17 = v6 + 288;
LABEL_27:

  return v17;
}

    goto LABEL_48;
  }

  if (!v4)
  {
    __nwlog_obj();
    id v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
    char v23 = (char *)_os_log_send_and_compose_impl();

    __int16 v43 = OS_LOG_TYPE_ERROR;
    uint64_t v42 = 0;
    if (v43 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = v43;
      if (os_log_type_enabled(v24, v43))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null definition", buf, 0xCu);
      }
    }

    else if (v42)
    {
      os_log_type_t v31 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v32 = v43;
      id v33 = os_log_type_enabled(v24, v43);
      if (v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v31;
          _os_log_impl( &dword_181A5C000,  v24,  v32,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v31);
        if (!v23) {
          goto LABEL_50;
        }
        goto LABEL_49;
      }

      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl(&dword_181A5C000, v24, v32, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = v43;
      if (os_log_type_enabled(v24, v43))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl( &dword_181A5C000,  v24,  v35,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_47;
  }

  unsigned int v6 = (unsigned __int8 *)v3[1];
  unsigned int v7 = MEMORY[0x1895F87A8];
  if (!v6) {
    goto LABEL_53;
  }
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000LL;
  uint64_t v45 = 0;
  v39[0] = MEMORY[0x1895F87A8];
  v39[1] = 3221225472LL;
  v39[2] = __nw_protocol_stack_includes_protocol_block_invoke;
  v39[3] = &unk_189BC7960;
  __int16 v40 = v4;
  uint64_t v41 = buf;
  nw_array_apply(v6, (uint64_t)v39);
  unsigned int v8 = *(_BYTE *)(*(void *)&buf[8] + 24LL) == 0;

  _Block_object_dispose(buf, 8);
  if (v8)
  {
LABEL_53:
    unsigned int v9 = (unsigned __int8 *)v3[2];
    if (!v9) {
      goto LABEL_54;
    }
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v45 = 0;
    v36[0] = v7;
    v36[1] = 3221225472LL;
    v36[2] = __nw_protocol_stack_includes_protocol_block_invoke_2;
    v36[3] = &unk_189BC7960;
    BOOL v37 = v5;
    os_log_type_t v38 = buf;
    nw_array_apply(v9, (uint64_t)v36);
    int v10 = *(_BYTE *)(*(void *)&buf[8] + 24LL) == 0;

    _Block_object_dispose(buf, 8);
    if (v10)
    {
LABEL_54:
      unsigned int v11 = (void *)v3[3];
      if (!v11
        || (uint64_t v12 = v11,
            uint64_t v13 = v12[1],
            v12,
            LOBYTE(v12) = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v13),
            v13,
            (v12 & 1) == 0))
      {
        uint64_t v14 = (void *)v3[4];
        if (!v14
          || (uint64_t v15 = v14,
              BOOL v16 = v15[1],
              v15,
              LOBYTE(v15) = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v16),
              v16,
              (v15 & 1) == 0))
        {
          uint64_t v17 = (void *)v3[6];
          if (!v17) {
            goto LABEL_50;
          }
          BOOL v18 = v17;
          uint64_t v19 = v18[1];

          LOBYTE(v18) = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v19);
        }
      }
    }
  }

  uint64_t v20 = 1LL;
LABEL_14:

  return v20;
}

      id v33 = 1LL;
      if (v12) {
        goto LABEL_22;
      }
      goto LABEL_48;
    default:
      custom_data_length = nw_endpoint_get_custom_data_length(v10);
      if (!custom_data_length) {
        goto LABEL_74;
      }
      if (custom_data_length > 0x400)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v36 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v314 = "nw_path_struct_size_for_endpoint";
        v315 = 1024;
        *(_DWORD *)v316 = 1024;
        LODWORD(v288) = 18;
        v287 = buf;
        BOOL v37 = (char *)_os_log_send_and_compose_impl();

        v312[0] = 16;
        uu[0] = 0;
        if (__nwlog_fault(v37, v312, uu))
        {
          if (v312[0] == 17)
          {
            __nwlog_obj();
            os_log_type_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            char v39 = v312[0];
            if (os_log_type_enabled(v38, (os_log_type_t)v312[0]))
            {
              *(_DWORD *)buf = 136446466;
              v314 = "nw_path_struct_size_for_endpoint";
              v315 = 1024;
              *(_DWORD *)v316 = 1024;
              _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s Custom data size must be no larger than %d",  buf,  0x12u);
            }

    free(backtrace_string);
    goto LABEL_60;
  }

  unsigned int v6 = v4;
  unsigned int v7 = [v6 type];

  if (!nw_path_uses_nexus_internal(v3, 0))
  {
    if (v3->policy_result.routing_result == 4 && v3->policy_result.routing_result_parameter.tunnel_interface_index)
    {
      unsigned int v9 = (v7 - 1) < 2;
      goto LABEL_63;
    }

    int v10 = v7 == 1;
    goto LABEL_25;
  }

  nexus_agent = (_DWORD *)nw_path_get_nexus_agent(v3, 0);
  if (nexus_agent[53] < 0xCCu)
  {
LABEL_62:
    unsigned int v9 = 0LL;
    goto LABEL_63;
  }

  if (nexus_agent[56] == v7
    || nexus_agent[57] == v7
    || nexus_agent[58] == v7
    || nexus_agent[59] == v7
    || nexus_agent[60] == v7
    || nexus_agent[61] == v7
    || nexus_agent[62] == v7
    || nexus_agent[63] == v7
    || nexus_agent[64] == v7
    || nexus_agent[65] == v7
    || nexus_agent[66] == v7
    || nexus_agent[67] == v7
    || nexus_agent[68] == v7
    || nexus_agent[69] == v7
    || nexus_agent[70] == v7)
  {
    unsigned int v9 = 1LL;
    goto LABEL_63;
  }

  int v10 = nexus_agent[71] == v7;
LABEL_25:
  unsigned int v9 = v10;
LABEL_63:

  return v9;
}

LABEL_48:
      if (v10) {
        free(v10);
      }
      goto LABEL_50;
    }

    if (!v23)
    {
      __nwlog_obj();
      unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_parameters_has_delegated_proc_audit_token";
        _os_log_impl( &dword_181A5C000,  v11,  v21,  "%{public}s called with null audit_token, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v18 = type;
    uint64_t v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_parameters_has_delegated_proc_audit_token";
        _os_log_impl(&dword_181A5C000, v11, v18, "%{public}s called with null audit_token, no backtrace", buf, 0xCu);
      }

      goto LABEL_47;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      id v26 = "nw_parameters_has_delegated_proc_audit_token";
      os_log_type_t v27 = 2082;
      BOOL v28 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null audit_token, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (!v19)
    {
LABEL_49:
      os_log_type_t v29 = 0LL;
LABEL_89:

      return v29;
    }

      os_log_type_t v54 = (void *)*((void *)v4 + 1);
      if (v54) {
        LODWORD(v54) = nw_path_is_viable(v54);
      }
      v159 = (int)v54;
      if (!nw_endpoint_handler_get_minimize_logging(v24))
      {
        BOOL v55 = v24;
        v56 = (*((_BYTE *)v5 + 268) & 0x20) == 0;

        if (!v56) {
          goto LABEL_81;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v32 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v57 = v55;

          BOOL v58 = v57;
          os_log_type_t v59 = (*((_BYTE *)v5 + 268) & 1) == 0;

          if (v59) {
            os_log_type_t v60 = "";
          }
          else {
            os_log_type_t v60 = "dry-run ";
          }
          v61 = nw_endpoint_handler_copy_endpoint(v58);
          id v62 = nw_endpoint_get_logging_description(v61);
          char v63 = v58;
          v64 = v63;
          v65 = v24->state;
          v148 = v62;
          logb = (os_log_t)v60;
          else {
            v66 = off_189BBBBF0[v65];
          }
          v144 = v66;

          __int16 v67 = v64;
          v68 = v67;
          v69 = "path";
          switch(v162->mode)
          {
            case 0:
              break;
            case 1:
              v69 = "resolver";
              break;
            case 2:
              v69 = nw_endpoint_flow_mode_string(v67[31]);
              break;
            case 3:
              v69 = "proxy";
              break;
            case 4:
              v69 = "fallback";
              break;
            case 5:
              v69 = "transform";
              break;
            default:
              v69 = "unknown-mode";
              break;
          }

          v82 = v68;
          os_unfair_lock_lock((os_unfair_lock_t)v82 + 28);
          v83 = v82[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v82 + 28);

          v84 = v57 + 168;
          v85 = v83;
          v86 = nw_endpoint_handler_path_status_string(v82);
          *(_DWORD *)buf = 136448258;
          v166 = "nw_endpoint_flow_connected_path_change";
          v87 = "not ";
          if (v159) {
            v87 = "";
          }
          v167 = 2082;
          v168 = v84;
          v169 = 2082;
          v170 = (const char *)logb;
          v171 = 2082;
          v172 = (void *)v148;
          v173 = 2082;
          v174 = (void *)v144;
          v175 = 2082;
          v176 = v69;
          v177 = 2114;
          v178 = v85;
          v179 = 2082;
          v180 = v86;
          v181 = 2082;
          v182 = v87;
          _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{public} s, %{public}sviable",  buf,  0x5Cu);
        }

        goto LABEL_80;
      }

      if ((nw_endpoint_handler_get_logging_disabled(v24) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v32 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          v114 = nw_endpoint_handler_get_id_string(v24);
          logd = nw_endpoint_handler_dry_run_string(v24);
          v115 = nw_endpoint_handler_copy_endpoint(v24);
          v116 = nw_endpoint_get_logging_description(v115);
          v117 = nw_endpoint_handler_state_string(v24);
          v118 = nw_endpoint_handler_mode_string(v24);
          v119 = nw_endpoint_handler_copy_current_path(v24);
          v120 = nw_endpoint_handler_path_status_string(v24);
          *(_DWORD *)buf = 136448258;
          v166 = "nw_endpoint_flow_connected_path_change";
          v121 = "not ";
          v168 = (void *)v114;
          v167 = 2082;
          if (v159) {
            v121 = "";
          }
          v169 = 2082;
          v170 = logd;
          v171 = 2082;
          v172 = (void *)v116;
          v173 = 2082;
          v174 = (void *)v117;
          v175 = 2082;
          v176 = v118;
          v177 = 2114;
          v178 = v119;
          v179 = 2082;
          v180 = v120;
          v181 = 2082;
          v182 = v121;
          _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{public} s, %{public}sviable",  buf,  0x5Cu);
        }

        goto LABEL_80;
      }

      goto LABEL_81;
    }

    uint64_t v42 = (void *)*((void *)v4 + 104);
    if (!v42) {
      goto LABEL_47;
    }
    char v32 = (os_log_s *)nw_path_flow_registration_force_update(v42);
    __int16 v43 = nw_endpoint_handler_get_minimize_logging(v24);
    os_log_type_t v44 = nw_endpoint_handler_get_logging_disabled(v24);
    if (v43)
    {
      if ((v44 & 1) != 0)
      {
LABEL_45:
        if (v32) {
          v53 = nw_path_is_viable(v32);
        }
        else {
          v53 = 0;
        }
        v70 = nw_endpoint_handler_get_minimize_logging(v24);
        v71 = nw_endpoint_handler_get_logging_disabled(v24);
        v159 = v53;
        if (v70)
        {
          if ((v71 & 1) != 0) {
            goto LABEL_80;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v136 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
          {
            logg = nw_endpoint_handler_get_id_string(v24);
            v146 = nw_endpoint_handler_dry_run_string(v24);
            v137 = nw_endpoint_handler_copy_endpoint(v24);
            v138 = nw_endpoint_get_logging_description(v137);
            v139 = nw_endpoint_handler_state_string(v24);
            v140 = nw_endpoint_handler_mode_string(v24);
            v141 = nw_endpoint_handler_copy_current_path(v24);
            v142 = nw_endpoint_handler_path_status_string(v24);
            *(_DWORD *)buf = 136448258;
            v166 = "nw_endpoint_flow_connected_path_change";
            v143 = "not ";
            v168 = (void *)logg;
            v167 = 2082;
            if (v159) {
              v143 = "";
            }
            v169 = 2082;
            v170 = v146;
            v171 = 2082;
            v172 = (void *)v138;
            v173 = 2082;
            v174 = (void *)v139;
            v175 = 2082;
            v176 = v140;
            v177 = 2114;
            v178 = v141;
            v179 = 2082;
            v180 = v142;
            v181 = 2082;
            v182 = v143;
            _os_log_impl( &dword_181A5C000,  v136,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{publi c}s, join flow is %{public}sviable",  buf,  0x5Cu);

            v72 = v136;
          }

          else
          {
            v72 = v136;
          }
        }

        else
        {
          if ((v71 & 1) != 0)
          {
LABEL_80:

            goto LABEL_81;
          }

          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v72 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v72, OS_LOG_TYPE_INFO))
          {
            v73 = nw_endpoint_handler_get_id_string(v24);
            logc = v72;
            v145 = nw_endpoint_handler_dry_run_string(v24);
            v74 = v73;
            v75 = nw_endpoint_handler_copy_endpoint(v24);
            v76 = nw_endpoint_get_logging_description(v75);
            v77 = nw_endpoint_handler_state_string(v24);
            v78 = nw_endpoint_handler_mode_string(v24);
            v79 = nw_endpoint_handler_copy_current_path(v24);
            v80 = nw_endpoint_handler_path_status_string(v24);
            *(_DWORD *)buf = 136448258;
            v166 = "nw_endpoint_flow_connected_path_change";
            v81 = "not ";
            v168 = (void *)v74;
            v167 = 2082;
            if (v159) {
              v81 = "";
            }
            v169 = 2082;
            v170 = v145;
            v171 = 2082;
            v172 = (void *)v76;
            v173 = 2082;
            v174 = (void *)v77;
            v175 = 2082;
            v176 = v78;
            v177 = 2114;
            v178 = v79;
            v179 = 2082;
            v180 = v80;
            v181 = 2082;
            v182 = v81;
            _os_log_impl( &dword_181A5C000,  logc,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{publi c}s, join flow is %{public}sviable",  buf,  0x5Cu);

            v72 = logc;
          }
        }

        goto LABEL_80;
      }

      v149 = v32;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v45 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      {
        v161 = nw_endpoint_handler_get_id_string(v24);
        logf = nw_endpoint_handler_dry_run_string(v24);
        v130 = nw_endpoint_handler_copy_endpoint(v24);
        v131 = nw_endpoint_get_logging_description(v130);
        v132 = nw_endpoint_handler_state_string(v24);
        v133 = nw_endpoint_handler_mode_string(v24);
        v134 = nw_endpoint_handler_copy_current_path(v24);
        v135 = (const char *)*((void *)v4 + 104);
        *(_DWORD *)buf = 136448258;
        v166 = "nw_endpoint_flow_connected_path_change";
        v167 = 2082;
        v168 = (void *)v161;
        v169 = 2082;
        v170 = logf;
        v171 = 2082;
        v172 = (void *)v131;
        v173 = 2082;
        v174 = (void *)v132;
        v175 = 2082;
        v176 = v133;
        v177 = 2114;
        v178 = v134;
        v179 = 2112;
        v180 = v135;
        v181 = 2112;
        char v32 = v149;
        v182 = (const char *)v149;
        _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] registration %@ flow_path %@",  buf,  0x5Cu);
      }
    }

    else
    {
      if ((v44 & 1) != 0) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v45 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
      {
        v46 = nw_endpoint_handler_get_id_string(v24);
        v47 = nw_endpoint_handler_dry_run_string(v24);
        v147 = v32;
        v160 = nw_endpoint_handler_copy_endpoint(v24);
        v48 = nw_endpoint_get_logging_description(v160);
        v49 = nw_endpoint_handler_state_string(v24);
        os_log_type_t v50 = nw_endpoint_handler_mode_string(v24);
        v51 = nw_endpoint_handler_copy_current_path(v24);
        os_log_type_t v52 = (const char *)*((void *)v4 + 104);
        *(_DWORD *)buf = 136448258;
        v166 = "nw_endpoint_flow_connected_path_change";
        v167 = 2082;
        v168 = (void *)v46;
        v169 = 2082;
        v170 = v47;
        v171 = 2082;
        v172 = (void *)v48;
        v173 = 2082;
        v174 = (void *)v49;
        v175 = 2082;
        v176 = v50;
        v177 = 2114;
        v178 = v51;
        v179 = 2112;
        v180 = v52;
        v181 = 2112;
        char v32 = v147;
        v182 = (const char *)v147;
        _os_log_impl( &dword_181A5C000,  v45,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] registration %@ flow_path %@",  buf,  0x5Cu);
      }
    }

    goto LABEL_45;
  }

              if ((nw_flow_handle_send_complete(v291, v296, v295) & 1) != 0) {
                goto LABEL_336;
              }
              goto LABEL_48;
            }
          }

          else if (!v17)
          {

            goto LABEL_43;
          }

          uint64_t v19 = v293;
          size = (size_t)v293[12];
          goto LABEL_25;
        }

        if (!v16)
        {
          if (!v17)
          {
            os_log_type_t v25 = 0;
            char v21 = v293;
            goto LABEL_35;
          }
              }
            }

            if (v52) {
              free(v52);
            }
            id v26 = 0LL;
            goto LABEL_35;
          }

          id v26 = (id *)v45[9];
LABEL_35:

          if (v26)
          {
            os_log_type_t v27 = v44;
            if (v28 < v20) {
              continue;
            }
          }

          goto LABEL_78;
        }

        __nwlog_obj();
        v47 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
        v48 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(v107) = 16;
        LOBYTE(v105) = 0;
        if (__nwlog_fault(v48, &v107, &v105))
        {
          if (v107 == 17)
          {
            __nwlog_obj();
            v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v50 = v107;
            if (os_log_type_enabled(v49, (os_log_type_t)v107))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
              _os_log_impl(&dword_181A5C000, v49, v50, "%{public}s called with null handler", buf, 0xCu);
            }
          }

          else
          {
            if ((_BYTE)v105)
            {
              BOOL v55 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v57 = v107;
              BOOL v58 = os_log_type_enabled(v56, (os_log_type_t)v107);
              if (v55)
              {
                if (v58)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
                  v111 = 2082;
                  v112 = v55;
                  _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v55);
              }

              else
              {
                if (v58)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
                  _os_log_impl( &dword_181A5C000,  v56,  v57,  "%{public}s called with null handler, no backtrace",  buf,  0xCu);
                }
              }

              goto LABEL_67;
            }

            __nwlog_obj();
            v49 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            char v63 = v107;
            if (os_log_type_enabled(v49, (os_log_type_t)v107))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
              _os_log_impl( &dword_181A5C000,  v49,  v63,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

    if (v15) {
      free(v15);
    }
    goto LABEL_5;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v8 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      unsigned int v9 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v29 = "nw_flow_output_available";
    os_log_type_t v30 = 2082;
    os_log_type_t v31 = (void *)v9;
    char v32 = 2082;
    id v33 = "flow";
    _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

LABEL_12:
}

    free(v21);
    goto LABEL_48;
  }

  __nwlog_obj();
  v87 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v87, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v96 = "strict_calloc";
  v97 = 2048;
  v98 = 1LL;
  v99 = 2048;
  v100 = 184LL;
  v88 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v88))
  {
    free(v88);
    goto LABEL_10;
  }

  __break(1u);
}

    goto LABEL_48;
  }

  if (!v53)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    unsigned int v5 = (os_log_s *)(id)gconnectionLogObj;
    uint64_t v19 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446466;
      v56 = "-[NWConcrete_nw_resolver dealloc]";
      os_log_type_t v57 = 2082;
      *(void *)BOOL v58 = (char *)self + 256;
      _os_log_impl( &dword_181A5C000,  v5,  v19,  "%{public}s [C%{public}s] over-release of nw_resolver_t! Object should not be internally retained and deallocatin g, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_47;
  }

  unsigned int v11 = __nw_create_backtrace_string();
  if (!v11)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    unsigned int v5 = (os_log_s *)(id)gconnectionLogObj;
    uint64_t v20 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446466;
      v56 = "-[NWConcrete_nw_resolver dealloc]";
      os_log_type_t v57 = 2082;
      *(void *)BOOL v58 = (char *)self + 256;
      _os_log_impl( &dword_181A5C000,  v5,  v20,  "%{public}s [C%{public}s] over-release of nw_resolver_t! Object should not be internally retained and deallocating, no backtrace",  buf,  0x16u);
    }

    goto LABEL_47;
  }

  uint64_t v12 = (char *)v11;
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  uint64_t v13 = (os_log_s *)(id)gconnectionLogObj;
  uint64_t v14 = type;
  if (os_log_type_enabled(v13, type))
  {
    *(_DWORD *)buf = 136446722;
    v56 = "-[NWConcrete_nw_resolver dealloc]";
    os_log_type_t v57 = 2082;
    *(void *)BOOL v58 = (char *)self + 256;
    *(_WORD *)&v58[8] = 2082;
    *(void *)&v58[10] = v12;
    _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s [C%{public}s] over-release of nw_resolver_t! Object should not be internally retained and deallocating, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v12);
  if (v4) {
    goto LABEL_49;
  }
LABEL_50:
  if (!*((void *)self + 8)) {
    goto LABEL_100;
  }
  if ((*((_BYTE *)self + 346) & 0x20) != 0) {
    goto LABEL_99;
  }
  if (!*((_BYTE *)self + 256))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v28 = (id)gLogObj;
    os_log_type_t v29 = *((_DWORD *)self + 85);
    *(_DWORD *)buf = 136446466;
    v56 = "-[NWConcrete_nw_resolver dealloc]";
    os_log_type_t v57 = 1024;
    *(_DWORD *)BOOL v58 = v29;
    os_log_type_t v50 = 18;
    v49 = buf;
    os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v26 = (os_log_s *)(id)gLogObj;
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v26, type))
      {
        os_log_type_t v31 = *((_DWORD *)self + 85);
        *(_DWORD *)buf = 136446466;
        v56 = "-[NWConcrete_nw_resolver dealloc]";
        os_log_type_t v57 = 1024;
        *(_DWORD *)BOOL v58 = v31;
        _os_log_impl( &dword_181A5C000,  v26,  v30,  "%{public}s [R%u] over-release of nw_resolver_t! Object should not still have a DNS service",  buf,  0x12u);
      }
    }

    else if (v53)
    {
      os_log_type_t v36 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v26 = (os_log_s *)(id)gLogObj;
      BOOL v37 = type;
      os_log_type_t v38 = os_log_type_enabled(v26, type);
      if (v36)
      {
        if (v38)
        {
          char v39 = *((_DWORD *)self + 85);
          *(_DWORD *)buf = 136446722;
          v56 = "-[NWConcrete_nw_resolver dealloc]";
          os_log_type_t v57 = 1024;
          *(_DWORD *)BOOL v58 = v39;
          *(_WORD *)&v58[4] = 2082;
          *(void *)&v58[6] = v36;
          _os_log_impl( &dword_181A5C000,  v26,  v37,  "%{public}s [R%u] over-release of nw_resolver_t! Object should not still have a DNS service, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v36);
        if (!v25) {
          goto LABEL_99;
        }
        goto LABEL_98;
      }

      if (v38)
      {
        os_log_type_t v44 = *((_DWORD *)self + 85);
        *(_DWORD *)buf = 136446466;
        v56 = "-[NWConcrete_nw_resolver dealloc]";
        os_log_type_t v57 = 1024;
        *(_DWORD *)BOOL v58 = v44;
        _os_log_impl( &dword_181A5C000,  v26,  v37,  "%{public}s [R%u] over-release of nw_resolver_t! Object should not still have a DNS service, no backtrace",  buf,  0x12u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v26 = (os_log_s *)(id)gLogObj;
      uint64_t v42 = type;
      if (os_log_type_enabled(v26, type))
      {
        __int16 v43 = *((_DWORD *)self + 85);
        *(_DWORD *)buf = 136446466;
        v56 = "-[NWConcrete_nw_resolver dealloc]";
        os_log_type_t v57 = 1024;
        *(_DWORD *)BOOL v58 = v43;
        _os_log_impl( &dword_181A5C000,  v26,  v42,  "%{public}s [R%u] over-release of nw_resolver_t! Object should not still have a DNS service, backtrace limit exceeded",  buf,  0x12u);
      }
    }

    goto LABEL_96;
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  int v24 = (id)gconnectionLogObj;
  *(_DWORD *)buf = 136446466;
  v56 = "-[NWConcrete_nw_resolver dealloc]";
  os_log_type_t v57 = 2082;
  *(void *)BOOL v58 = (char *)self + 256;
  os_log_type_t v50 = 22;
  v49 = buf;
  os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v53 = 0;
  if (__nwlog_fault(v25, &type, &v53))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v26 = (os_log_s *)(id)gconnectionLogObj;
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446466;
        v56 = "-[NWConcrete_nw_resolver dealloc]";
        os_log_type_t v57 = 2082;
        *(void *)BOOL v58 = (char *)self + 256;
        _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s [C%{public}s] over-release of nw_resolver_t! Object should not still have a DNS service",  buf,  0x16u);
      }
    }

    else if (v53)
    {
      char v32 = __nw_create_backtrace_string();
      if (v32)
      {
        id v33 = (char *)v32;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v34 = (os_log_s *)(id)gconnectionLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446722;
          v56 = "-[NWConcrete_nw_resolver dealloc]";
          os_log_type_t v57 = 2082;
          *(void *)BOOL v58 = (char *)self + 256;
          *(_WORD *)&v58[8] = 2082;
          *(void *)&v58[10] = v33;
          _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s [C%{public}s] over-release of nw_resolver_t! Object should not still have a DNS service, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v33);
        if (!v25) {
          goto LABEL_99;
        }
        goto LABEL_98;
      }

      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v26 = (os_log_s *)(id)gconnectionLogObj;
      uint64_t v41 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446466;
        v56 = "-[NWConcrete_nw_resolver dealloc]";
        os_log_type_t v57 = 2082;
        *(void *)BOOL v58 = (char *)self + 256;
        _os_log_impl( &dword_181A5C000,  v26,  v41,  "%{public}s [C%{public}s] over-release of nw_resolver_t! Object should not still have a DNS service, no backtrace",  buf,  0x16u);
      }
    }

    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v26 = (os_log_s *)(id)gconnectionLogObj;
      __int16 v40 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446466;
        v56 = "-[NWConcrete_nw_resolver dealloc]";
        os_log_type_t v57 = 2082;
        *(void *)BOOL v58 = (char *)self + 256;
        _os_log_impl( &dword_181A5C000,  v26,  v40,  "%{public}s [C%{public}s] over-release of nw_resolver_t! Object should not still have a DNS service, backtrace limit exceeded",  buf,  0x16u);
      }
    }

    __break(1u);
  }

  else
  {
    __nwlog_obj(0LL, a2);
    os_log_type_t v54 = 136446210;
    *(_DWORD *)buf = 136446210;
    uint64_t v2 = (int *)"nw_hash_table_release_all_objects";
    BOOL v58 = "nw_hash_table_release_all_objects";
    id v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v55 = 0;
    unsigned int v11 = __nwlog_fault(v3, &type, &v55);
    if (!(_DWORD)v11) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v22 = (os_log_s *)__nwlog_obj(v11, v12);
      char v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v58 = "nw_hash_table_release_all_objects";
      int v24 = "%{public}s called with null table";
      goto LABEL_71;
    }
  }

  if (!v55)
  {
    id v22 = (os_log_s *)__nwlog_obj(v11, v12);
    char v23 = type;
    if (!os_log_type_enabled(v22, type)) {
      goto LABEL_72;
    }
    *(_DWORD *)buf = v54;
    BOOL v58 = (const char *)v2;
    int v24 = "%{public}s called with null table, backtrace limit exceeded";
    goto LABEL_71;
  }

  uint64_t v41 = (char *)__nw_create_backtrace_string();
  id v22 = (os_log_s *)__nwlog_obj(v41, v42);
  char v23 = type;
  __int16 v43 = os_log_type_enabled(v22, type);
  if (v41)
  {
    if (v43)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v58 = (const char *)v2;
      os_log_type_t v59 = 2082;
      *(void *)os_log_type_t v60 = v41;
      _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null table, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v41);
    goto LABEL_72;
  }

  if (v43)
  {
    *(_DWORD *)buf = v54;
    BOOL v58 = (const char *)v2;
    int v24 = "%{public}s called with null table, no backtrace";
LABEL_71:
    _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
  }

    if (v21) {
      free(v21);
    }
    return 0LL;
  }

  if (a2 && a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  nw_protocol_set_input_handler((uint64_t)a1, 0LL);
  handle = (id *)a1->handle;
  if (!handle)
  {
    uint64_t v12 = 0LL;
    goto LABEL_24;
  }

  unsigned int v6 = handle[20];
  unsigned int v7 = v6;
  if (v6)
  {
    unsigned int v8 = (NWConcrete_nw_endpoint_handler *)v6;
    mode = v8->mode;

    if ((_DWORD)mode == 2)
    {
      int v10 = nw_endpoint_handler_copy_flow(v8);
      unsigned int v11 = v10;
      if (v10 && *((char *)v10 + 35) < 0)
      {
        nw_endpoint_flow_failed_with_error(v8, 1, handle[40]);
        uint64_t v12 = v8;
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      goto LABEL_23;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v14 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v31 = "nw_flow_passthrough_fail_if_needed";
      char v32 = 2082;
      id v33 = (void *)v14;
      os_log_type_t v34 = 2082;
      os_log_type_t v35 = "flow";
      _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }
  }

  uint64_t v12 = 0LL;
LABEL_23:

LABEL_24:
  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      remove_input_handler = (void (*)(void))callbacks->remove_input_handler;
      if (remove_input_handler) {
        remove_input_handler();
      }
    }
  }

  BOOL v18 = a1->handle;
  if (v18)
  {
    uint64_t v19 = (void *)v18[21];
    v18[21] = 0LL;
  }

  return 1LL;
}

      v57[(v50 >> 6) + 8] |= 1LL << v50;
      v71 = (uint64_t *)(v57[6] + 16 * v50);
      *v71 = v48;
      v71[1] = v43;
      v72 = (uint64_t *)(v57[7] + 16 * v50);
      *v72 = v44;
      v72[1] = v45;
      v73 = v57[2];
      v74 = __OFADD__(v73, 1LL);
      v75 = v73 + 1;
      if (v74) {
        goto LABEL_76;
      }
      v57[2] = v75;
      swift_bridgeObjectRetain();
      goto LABEL_5;
    }

    if (v25 == 1)
    {
      v101 = v10;
      v102 = v9;
      swift_bridgeObjectRetain_n();
      id v26 = v103;
      sub_181BDA12C(v103, v24, 1);
      sub_181BDA12C(v26, v24, 1);
      sub_18264EA84();
      os_log_type_t v27 = sub_18264EA60();
      if (v28)
      {
        os_log_type_t v29 = v28;
        os_log_type_t v30 = v27;
        os_log_type_t v31 = swift_isUniquelyReferenced_nonNull_native();
        v104 = (void *)*a2;
        char v32 = v104;
        *a2 = 0x8000000000000000LL;
        os_log_type_t v34 = sub_181C8C01C(v21, v22);
        os_log_type_t v35 = v32[2];
        os_log_type_t v36 = (v33 & 1) == 0;
        BOOL v37 = v35 + v36;
        if (__OFADD__(v35, v36)) {
          goto LABEL_74;
        }
        os_log_type_t v38 = v33;
        if (v32[3] < v37)
        {
          sub_181C8F71C(v37, v31);
          char v39 = sub_181C8C01C(v21, v22);
          if ((v38 & 1) != (v40 & 1)) {
            goto LABEL_80;
          }
          os_log_type_t v34 = v39;
          uint64_t v41 = v104;
          if ((v38 & 1) == 0) {
            goto LABEL_64;
          }
LABEL_56:
          v83 = (uint64_t *)(v41[7] + 16 * v34);
          swift_bridgeObjectRelease();
          *v83 = v30;
          v83[1] = v29;
LABEL_66:
          a2 = v99;
          *v99 = (uint64_t)v41;
          swift_bridgeObjectRelease();
          swift_bridgeObjectRelease();
          v90 = v103;
          sub_181BDA14C(v103, v24, 1);
          swift_bridgeObjectRelease();
          uint64_t v12 = v90;
          uint64_t v13 = v24;
          uint64_t v14 = 1;
          goto LABEL_6;
        }

        if ((v31 & 1) != 0)
        {
          uint64_t v41 = v104;
          if ((v33 & 1) != 0) {
            goto LABEL_56;
          }
        }

        else
        {
          sub_181C926B8();
          uint64_t v41 = v104;
          if ((v38 & 1) != 0) {
            goto LABEL_56;
          }
        }

LABEL_48:
      if (v14) {
        free(v14);
      }
      goto LABEL_14;
    }

    if (!v28)
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_browse_result_insert_interface";
        _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s called with null interface, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    id v22 = type;
    char v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_browse_result_insert_interface";
        _os_log_impl(&dword_181A5C000, v15, v22, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }

      goto LABEL_47;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_browse_result_insert_interface";
      char v32 = 2082;
      id v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null interface, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
    goto LABEL_57;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "nw_protocol_shoes_add_input_handler";
    os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_protocol_shoes_add_input_handler";
        BOOL v28 = "%{public}s called with null shoes";
        goto LABEL_56;
      }

      goto LABEL_57;
    }

    if (!v33)
    {
      id v26 = (os_log_s *)__nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_protocol_shoes_add_input_handler";
        BOOL v28 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_56;
      }

      goto LABEL_57;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v26 = (os_log_s *)__nwlog_obj();
    os_log_type_t v27 = type;
    char v32 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v36 = "nw_protocol_shoes_add_input_handler";
        BOOL v28 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_56;
      }

      goto LABEL_57;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v36 = "nw_protocol_shoes_add_input_handler";
      BOOL v37 = 2082;
      os_log_type_t v38 = backtrace_string;
      os_log_type_t v31 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
      goto LABEL_46;
    }

    goto LABEL_47;
  }

  unsigned int v5 = (nw_endpoint *)((uint64_t (*)(nw_protocol *))a2->callbacks->get_remote_endpoint)(a2);
  unsigned int v6 = nw_endpoint_get_type(v5);
  if (v6 - 1 < 2)
  {
    nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
    *(_OWORD *)handle = *(_OWORD *)a2->flow_id;
    if (a2->output_handler)
    {
      if (v5)
      {
LABEL_6:
        unsigned int v7 = os_retain(v5);
LABEL_11:
        handle[15] = 0LL;
        handle[12] = v7;
        tls = 1;
        *((_BYTE *)handle + 150) = 1;
        handle[16] = handle + 15;
        uint64_t v12 = (void *)((uint64_t (*)(void))a1->default_input_handler->callbacks->get_parameters)();
        if (!nw_parameters_get_tfo(v12)) {
          tls = nw_parameters_get_tls(v12);
        }
        *((_BYTE *)handle + 235) = *((_BYTE *)handle + 235) & 0xFE | tls;
        uint64_t v13 = nw_parameters_copy_protocol_value(v12, (uint64_t)a1, "UDP");
        if (v13)
        {
          uint64_t v14 = v13;
          value = xpc_BOOL_get_value(v13);
          xpc_release(v14);
          if (value) {
            BOOL v16 = 2;
          }
          else {
            BOOL v16 = 0;
          }
        }

        else
        {
          BOOL v16 = 0;
        }

        *((_BYTE *)handle + 235) = *((_BYTE *)handle + 235) & 0xFD | v16;
        uint64_t v17 = nw_parameters_copy_protocol_value(v12, (uint64_t)a1, "UDPAssociateSupported");
        if (v17)
        {
          BOOL v18 = v17;
          uint64_t v19 = xpc_BOOL_get_value(v17);
          xpc_release(v18);
          if (v19) {
            uint64_t v20 = 4;
          }
          else {
            uint64_t v20 = 0;
          }
        }

        else
        {
          uint64_t v20 = 0;
        }

        *((_BYTE *)handle + 235) = *((_BYTE *)handle + 235) & 0xFB | v20;
        char v21 = nw_parameters_copy_protocol_value(v12, (uint64_t)a1, "FixedBundleID");
        if (v21)
        {
          id v22 = v21;
          string_ptr = xpc_string_get_string_ptr(v21);
          xpc_release(v22);
          if (string_ptr) {
            handle[14] = xpc_string_create(string_ptr);
          }
        }

        int v24 = nw_parameters_copy_protocol_options_legacy(v12, a1);
        nw_protocol_options_get_log_id_str(v24, (_BYTE *)handle + 151, 84LL);
        if (v24) {
          os_release(v24);
        }
        return 1LL;
      }
    }

    else
    {
      nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)handle);
      if (v5) {
        goto LABEL_6;
      }
    }

    unsigned int v7 = 0LL;
    goto LABEL_11;
  }

  unsigned int v8 = v6;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v9 = (os_log_s *)gLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136446722;
    os_log_type_t v36 = "nw_protocol_shoes_add_input_handler";
    BOOL v37 = 2082;
    os_log_type_t v38 = (char *)handle + 151;
    char v39 = 1024;
    __int16 v40 = v8;
    _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s protocol_shoes does not support endpoint type %u",  buf,  0x1Cu);
    return 0LL;
  }

  return result;
}

      if (v8) {
        free(v8);
      }
      return 0LL;
    }

    if (!v16)
    {
      unsigned int v9 = (os_log_s *)__nwlog_obj();
      int v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_shoes_get_local_endpoint";
        unsigned int v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_46;
      }

      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v9 = (os_log_s *)__nwlog_obj();
    int v10 = type;
    uint64_t v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_protocol_shoes_get_local_endpoint";
        unsigned int v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_46;
      }

      goto LABEL_47;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v19 = "nw_protocol_shoes_get_local_endpoint";
      uint64_t v20 = 2082;
      char v21 = backtrace_string;
      uint64_t v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_36:
      _os_log_impl(&dword_181A5C000, v9, v10, v14, buf, 0x16u);
    }

            char v21 = v47;
            free(backtrace_string);
            if (!v28) {
              goto LABEL_13;
            }
            goto LABEL_68;
          }

          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_181A5C000, v36, v40, "%{public}s called with null destination, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v45 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl( &dword_181A5C000,  v36,  v45,  "%{public}s called with null destination, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v27 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
      BOOL v28 = (char *)_os_log_send_and_compose_impl();

      char v21 = v47;
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
          _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null candidate_manager", buf, 0xCu);
        }

        goto LABEL_32;
      }

      if (v48)
      {
        os_log_type_t v35 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v37 = type;
        os_log_type_t v38 = os_log_type_enabled(v36, type);
        if (v35)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v35;
            _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s called with null candidate_manager, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          char v21 = v47;
          free(v35);
LABEL_67:
          if (!v28) {
            goto LABEL_13;
          }
LABEL_68:
          free(v28);
          goto LABEL_13;
        }

        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
          _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s called with null candidate_manager, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_candidate_manager_process_bonjour_candidate";
          _os_log_impl( &dword_181A5C000,  v36,  v44,  "%{public}s called with null candidate_manager, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    char v21 = v47;
    goto LABEL_67;
  }

    goto LABEL_48;
  }

  if (!v4)
  {
    __nwlog_obj();
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_framer_write_output_data";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_framer_write_output_data";
        _os_log_impl(&dword_181A5C000, v15, v18, "%{public}s called with null output_data", buf, 0xCu);
      }
    }

    else if (v27)
    {
      id v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v23 = type;
      int v24 = os_log_type_enabled(v15, type);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v30 = "nw_framer_write_output_data";
          os_log_type_t v31 = 2082;
          char v32 = v22;
          _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s called with null output_data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v22);
        if (!v14) {
          goto LABEL_14;
        }
LABEL_49:
        free(v14);
        goto LABEL_14;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_framer_write_output_data";
        _os_log_impl(&dword_181A5C000, v15, v23, "%{public}s called with null output_data, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v26 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_framer_write_output_data";
        _os_log_impl( &dword_181A5C000,  v15,  v26,  "%{public}s called with null output_data, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_47;
  }

  nw_context_assert_queue(*((void **)v3 + 46));
  if (*((void *)v3 + 69))
  {
    if ((*((_BYTE *)v3 + 606) & 2) == 0)
    {
LABEL_5:
      unsigned int v6 = *((void *)v3 + 69);
LABEL_8:
      if (v6)
      {
        unsigned int v9 = *(void *)(v6 + 24) - *(void *)(v6 + 16);
        if (v9)
        {
          int v10 = (dispatch_data_s *)nw_array_remove_object_at_index(v6, (char *)((v9 >> 3) - 1));
          unsigned int v11 = *((void *)v3 + 69);
          concat = dispatch_data_create_concat(v10, v5);
          nw_array_append(v11, concat);

          if ((*((_BYTE *)v3 + 607) & 4) != 0) {
            goto LABEL_14;
          }
          goto LABEL_13;
        }
      }

      goto LABEL_12;
    }
  }

  else
  {
    unsigned int v7 = nw_array_create();
    unsigned int v8 = (void *)*((void *)v3 + 69);
    *((void *)v3 + 69) = v7;

    if ((*((_BYTE *)v3 + 606) & 2) == 0) {
      goto LABEL_5;
    }
  }

  unsigned int v6 = *((void *)v3 + 69);
  if ((*((_BYTE *)v3 + 607) & 4) != 0) {
    goto LABEL_8;
  }
LABEL_12:
  nw_array_append(v6, v5);
  if ((*((_BYTE *)v3 + 607) & 4) == 0) {
LABEL_13:
  }
    nw_framer_flush_output(v3, 0LL);
LABEL_14:
}

    unsigned int v11 = 0;
    uint64_t v12 = 2;
    goto LABEL_48;
  }

  unsigned int v5 = *((_WORD *)v3 + 44);
  if ((v5 & 0x10) == 0)
  {
    if ((v5 & 0x60) == 0 && (v5 & 0xA) != 0 && (v5 & 5) != 0 && (v5 & 0x80) != 0)
    {
      if (*((void *)v3 + 6)
        && (*((_WORD *)v3 + 44) & 0x802) != 0
        && (*((_WORD *)v3 + 44) & 0x401) != 0
        && (v3[347] & 0xE0) == 0x60)
      {
        if ((v3[346] & 0x20) != 0)
        {
LABEL_76:
          *((_DWORD *)v3 + 2) = 1;
          nw_resolver_cancel_query_locked((NWConcrete_nw_resolver *)v3, 0);
          *((_WORD *)v3 + 44) = 0;
          v3[347] |= 0x80u;
          nw_resolver_create_dns_getaddrinfo_locked((NWConcrete_nw_resolver *)v3, 0LL);
          unsigned int v11 = 0;
          goto LABEL_49;
        }

        if (v3[256])
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          unsigned int v6 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO)) {
            goto LABEL_75;
          }
          *(_DWORD *)buf = 136446466;
          v77 = "nw_resolver_update_status_locked";
          v78 = 2082;
          *(void *)v79 = v3 + 256;
          unsigned int v7 = "%{public}s [C%{public}s] Failed to resolve using oblivious configuration, failing over";
          unsigned int v8 = v6;
          unsigned int v9 = 22;
        }

        else
        {
          __nwlog_obj();
          unsigned int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
          {
LABEL_75:

            goto LABEL_76;
          }

          os_log_type_t v25 = *((_DWORD *)v3 + 85);
          *(_DWORD *)buf = 136446466;
          v77 = "nw_resolver_update_status_locked";
          v78 = 1024;
          *(_DWORD *)v79 = v25;
          unsigned int v7 = "%{public}s [R%u] Failed to resolve using oblivious configuration, failing over";
          unsigned int v8 = v6;
          unsigned int v9 = 18;
        }

        _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_INFO, v7, buf, v9);
        goto LABEL_75;
      }

      *((_DWORD *)v3 + 2) = 2;
      if ((v3[348] & 2) != 0)
      {
        uint64_t v19 = *((void *)v3 + 18);
        if (v19)
        {
          if (*(void *)(v19 + 24) != *(void *)(v19 + 16))
          {
            uint64_t v20 = nw_array_copy(v19);
            char v21 = (void *)v20;
            if (v20) {
              id v22 = (uint64_t)(*(void *)(v20 + 24) - *(void *)(v20 + 16)) >> 3;
            }
            else {
              id v22 = 0LL;
            }
            id v26 = nw_array_create();
            nw_array_append(v26, v21);
            os_log_type_t v27 = nw_storage_copy_shared();
            BOOL v28 = (void *)*((void *)v3 + 3);
            os_log_type_t v29 = (void *)*((void *)v3 + 4);
            v69[0] = MEMORY[0x1895F87A8];
            v69[1] = 3221225472LL;
            v69[2] = ___ZL32nw_resolver_update_status_lockedP22NWConcrete_nw_resolverU13block_pointerFvvE_block_invoke;
            v69[3] = &unk_189BC66E8;
            v70 = v3;
            v71 = v22;
            nw_storage_store_items(v27, (uint64_t)"dns_cache", (void *)v26, v28, v29, v69);
          }
        }
      }

      goto LABEL_155;
    }

    *((_DWORD *)v3 + 2) = 1;
    if ((v5 & 0x104) != 0 && (v5 & 0x20) == 0 || (v5 & 0x208) != 0 && (v5 & 0x40) == 0) {
      nw_resolver_start_query_timer((NWConcrete_nw_resolver *)v3);
    }
    uint64_t v13 = v3;
    if ((v5 & 0x20A) != 0 && (v5 & 0x80) != 0
      || (int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_resolver_start_delay,  50LL)) == 0)
    {

      unsigned int v11 = 0;
      goto LABEL_49;
    }

    uint64_t v15 = int64_with_default;
    if ((int64_with_default & 0x8000000000000000LL) != 0)
    {
      if ((v3[346] & 0x20) == 0)
      {
        if (*((_BYTE *)v13 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v16 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446978;
            v77 = "nw_resolver_start_delayed_reporting_timer";
            v78 = 2082;
            *(void *)v79 = v13 + 32;
            *(_WORD *)&v79[8] = 2048;
            *(void *)&v79[10] = v15;
            *(_WORD *)&v79[18] = 2048;
            uint64_t v15 = 50LL;
            *(void *)&v79[20] = 50LL;
            uint64_t v17 = "%{public}s [C%{public}s] Invalid resolver reporting delay %lldms, reverting to default value %llums";
            goto LABEL_71;
          }
        }

        else
        {
          __nwlog_obj();
          BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            os_log_type_t v30 = *((_DWORD *)v13 + 85);
            *(_DWORD *)buf = 136446978;
            v77 = "nw_resolver_start_delayed_reporting_timer";
            v78 = 1024;
            *(_DWORD *)v79 = v30;
            *(_WORD *)&v79[4] = 2048;
            *(void *)&v79[6] = v15;
            *(_WORD *)&v79[14] = 2048;
            uint64_t v15 = 50LL;
            *(void *)&v79[16] = 50LL;
            uint64_t v17 = "%{public}s [R%u] Invalid resolver reporting delay %lldms, reverting to default value %llums";
            goto LABEL_84;
          }
        }

        uint64_t v15 = 50LL;
LABEL_87:

        goto LABEL_88;
      }

      uint64_t v15 = 50LL;
    }

    else
    {
      if ((v3[346] & 0x20) == 0)
      {
        if (*((_BYTE *)v13 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v16 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446978;
            v77 = "nw_resolver_start_delayed_reporting_timer";
            v78 = 2082;
            *(void *)v79 = v13 + 32;
            *(_WORD *)&v79[8] = 2048;
            *(void *)&v79[10] = v15;
            *(_WORD *)&v79[18] = 2048;
            uint64_t v15 = 60000LL;
            *(void *)&v79[20] = 60000LL;
            uint64_t v17 = "%{public}s [C%{public}s] Invalid resolver reporting delay %llums, reverting to max value %llums";
LABEL_71:
            char v23 = v16;
            int v24 = 42;
LABEL_85:
            _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_ERROR, v17, buf, v24);
            goto LABEL_87;
          }

    if (v32) {
      free(v32);
    }
    goto LABEL_14;
  }

      uint64_t v13 = *(void *)(a1 + 32);
      goto LABEL_48;
    }

    if (nw_endpoint_get_type(*(nw_endpoint_t *)(v13 + 24)) == nw_endpoint_type_address
      && nw_parameters_get_resolve_ptr(*(void **)(*(void *)(a1 + 32) + 16LL)))
    {
      char v21 = *(_BYTE **)(a1 + 32);
      if (v21)
      {
        if ((v21[346] & 0x20) != 0)
        {
LABEL_62:
          nw_resolver_ptr_resolve_callback(v3, 0, 0, *(_DWORD *)(a1 + 40), v20, 0, 0, 0, 0LL, 0, v21);
          return;
        }

        if (v21[256])
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          id v22 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v22, OS_LOG_TYPE_INFO)) {
            goto LABEL_61;
          }
          char v23 = *(void *)(a1 + 32);
          int v24 = nwlog_get_string_for_dns_service_error(*(_DWORD *)(a1 + 40));
          *(_DWORD *)buf = 136446722;
          v48 = "nw_resolver_inject_dns_service_error_block_invoke";
          v49 = 2082;
          *(void *)os_log_type_t v50 = v23 + 256;
          *(_WORD *)&v50[8] = 2082;
          *(void *)&v50[10] = v24;
          os_log_type_t v25 = "%{public}s [C%{public}s] Injecting error %{public}s";
          id v26 = v22;
          os_log_type_t v27 = 32;
          goto LABEL_60;
        }

        __nwlog_obj();
        id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          uint64_t v45 = *(_DWORD *)(*(void *)(a1 + 32) + 340LL);
          v46 = nwlog_get_string_for_dns_service_error(*(_DWORD *)(a1 + 40));
          *(_DWORD *)buf = 136446722;
          v48 = "nw_resolver_inject_dns_service_error_block_invoke";
          v49 = 1024;
          *(_DWORD *)os_log_type_t v50 = v45;
          *(_WORD *)&v50[4] = 2082;
          *(void *)&v50[6] = v46;
          os_log_type_t v25 = "%{public}s [R%u] Injecting error %{public}s";
          id v26 = v22;
          os_log_type_t v27 = 28;
          goto LABEL_60;
        }
      }

      else
      {
        __nwlog_obj();
        id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
        {
          uint64_t v42 = nwlog_get_string_for_dns_service_error(*(_DWORD *)(a1 + 40));
          *(_DWORD *)buf = 136446466;
          v48 = "nw_resolver_inject_dns_service_error_block_invoke";
          v49 = 2082;
          *(void *)os_log_type_t v50 = v42;
          os_log_type_t v25 = "%{public}s Injecting error %{public}s";
          id v26 = v22;
          os_log_type_t v27 = 22;
LABEL_60:
          _os_log_impl(&dword_181A5C000, v26, OS_LOG_TYPE_INFO, v25, buf, v27);
        }
      }

  if (v30) {
    free(v30);
  }
LABEL_17:
}

      goto LABEL_48;
    }

    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)(id)gLogObj;
      int v24 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null (flow == (_nw_protocol_default_flow)), backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (os_log_s *)(id)gLogObj;
    uint64_t v20 = type;
    char v21 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null (flow == (_nw_protocol_default_flow)), no backtrace",  buf,  0xCu);
      }

      goto LABEL_47;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
      os_log_type_t v36 = 2082;
      BOOL v37 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null (flow == (_nw_protocol_default_flow)), dumping backtrace:%{public}s",  buf,  0x16u);
    }

LABEL_48:
    if (v10) {
      free(v10);
    }
  }

  return 1LL;
}

    if (v23) {
      free(v23);
    }
    nw_socks5_connection_cancel_on_queue(*(void **)(a1 + 32), 0LL);
    goto LABEL_50;
  }

  uint64_t v12 = *(unsigned __int8 **)(a1 + 32);
LABEL_16:
  uint64_t v13 = v12[56];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v14 = (os_log_s *)(id)gLogObj;
  uint64_t v15 = v14;
  if (v13 == 200)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v16 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 136446722;
      v53 = "nw_socks5_connection_connect_outer_on_queue_block_invoke";
      os_log_type_t v54 = 2114;
      BOOL v55 = v16;
      v56 = 2114;
      v57[0] = v5;
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ ignoring out connection event error %{public}@",  buf,  0x20u);
    }

  if (v15) {
    free(v15);
  }
}

      free(backtrace_string);
      goto LABEL_57;
    }

    uint64_t v17 = (os_log_s *)__nwlog_obj();
    BOOL v18 = type;
    if (!os_log_type_enabled(v17, type)) {
      goto LABEL_57;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_protocol_trainer_remove_input_handler";
    uint64_t v19 = "%{public}s called with null protocol";
LABEL_56:
    _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
LABEL_57:
    if (v16) {
      free(v16);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_protocol_trainer_remove_input_handler";
    BOOL v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      BOOL v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_57;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v27 = "nw_protocol_trainer_remove_input_handler";
      uint64_t v19 = "%{public}s called with null trainer";
      goto LABEL_56;
    }

    if (!v24)
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      BOOL v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_57;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v27 = "nw_protocol_trainer_remove_input_handler";
      uint64_t v19 = "%{public}s called with null trainer, backtrace limit exceeded";
      goto LABEL_56;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v17 = (os_log_s *)__nwlog_obj();
    BOOL v18 = type;
    char v23 = os_log_type_enabled(v17, type);
    if (backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v27 = "nw_protocol_trainer_remove_input_handler";
        BOOL v28 = 2082;
        os_log_type_t v29 = backtrace_string;
        id v22 = "%{public}s called with null trainer, dumping backtrace:%{public}s";
        goto LABEL_46;
      }

      goto LABEL_47;
    }

    if (!v23) {
      goto LABEL_57;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_protocol_trainer_remove_input_handler";
    uint64_t v19 = "%{public}s called with null trainer, no backtrace";
    goto LABEL_56;
  }

  if (a2 && a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  nw_protocol_set_input_handler((uint64_t)a1, 0LL);
  output_handler = a1->output_handler;
  if (output_handler) {
    ((void (*)(void))output_handler->callbacks->remove_input_handler)();
  }
  if (a3)
  {
    while (1)
    {
      unsigned int v9 = (void *)handle[9];
      if (!v9) {
        break;
      }
      int v10 = v9[2];
      unsigned int v11 = (void *)v9[3];
      if (v10)
      {
        *(void *)(v10 + 24) = v11;
        unsigned int v11 = (void *)v9[3];
      }

      else
      {
        handle[10] = v11;
      }

      *unsigned int v11 = v10;
      v9[2] = 0LL;
      v9[3] = 0LL;
      else {
        nw_frame_free_buffer((uint64_t)v9);
      }
      nw_frame_reset((uint64_t)v9, 0LL, 0, 0LL, 0LL);
      os_release(v9);
    }

    uint64_t v12 = (void *)handle[19];
    if (v12)
    {
      os_release(v12);
      handle[19] = 0LL;
    }

    uint64_t v13 = (void *)handle[20];
    if (v13)
    {
      os_release(v13);
      handle[20] = 0LL;
    }

    uint64_t v14 = (void *)handle[21];
    if (v14)
    {
      os_release(v14);
      handle[21] = 0LL;
    }

    uint64_t v15 = (void *)handle[22];
    if (v15) {
      os_release(v15);
    }
    a1->handle = 0LL;
    free(handle);
  }

  return 1LL;
}

    goto LABEL_48;
  }

  if (a3) {
    unsigned int v7 = a3;
  }
  else {
    unsigned int v7 = "0";
  }
  unsigned int v8 = nw_listener_copy_parameters_with_port(v6, v7, 0);
  unsigned int v9 = v8;
  if (v8)
  {
    int v10 = (unsigned __int8 *)v8;
    unsigned int v11 = v10[92];

    if (v11 != 2)
    {
      uint64_t v14 = nw_group_descriptor_copy(v5);
      uint64_t v13 = -[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_listener),  v10,  v14);

      goto LABEL_13;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      id v33 = "nw_listener_create_multicast";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot create multicast listener with stream mode parameters",  buf,  0xCu);
    }
  }

  uint64_t v13 = 0LL;
LABEL_13:

LABEL_14:
  return v13;
}

  free(backtrace_string);
  if (v7) {
LABEL_66:
  }
    free(v7);
}

    goto LABEL_48;
  }

  if (a2 >= 0xFF)
  {
    __nwlog_obj();
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    id v26 = "nw_parameters_set_data_mode";
    int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_parameters_set_data_mode";
        _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX)",  buf,  0xCu);
      }
    }

    else if (v23)
    {
      BOOL v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v19 = type;
      uint64_t v20 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          id v26 = "nw_parameters_set_data_mode";
          os_log_type_t v27 = 2082;
          BOOL v28 = v18;
          _os_log_impl( &dword_181A5C000,  v11,  v19,  "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v18);
        if (!v10) {
          goto LABEL_14;
        }
LABEL_49:
        free(v10);
        goto LABEL_14;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_parameters_set_data_mode";
        _os_log_impl( &dword_181A5C000,  v11,  v19,  "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        id v26 = "nw_parameters_set_data_mode";
        _os_log_impl( &dword_181A5C000,  v11,  v22,  "%{public}s called with null (static_cast<uint32_t>(data_mode) < UINT8_MAX), backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_47;
  }

  *((_BYTE *)v3 + 92) = a2;
  unsigned int v5 = v3[19];
  if (v5 && !*(void *)(v5 + 24))
  {
    if (a2 == 1)
    {
      options = nw_protocol_create_options((void *)g_udp_definition);
      goto LABEL_13;
    }

    if (a2 == 2)
    {
      options = nw_protocol_create_options((void *)g_tcp_definition);
LABEL_13:
      unsigned int v7 = v4[19];
      unsigned int v8 = *(void **)(v7 + 24);
      *(void *)(v7 + 24) = options;
    }
  }

    xpc_dictionary_set_BOOL(v2, "allow_ultra_constrained", 1);
    char v21 = *((void *)v1 + 13);
    if ((*(_WORD *)(v21 + 100) & 8) == 0)
    {
LABEL_42:
      char v23 = *(xpc_object_t **)(v21 + 176);
      if (!v23)
      {
LABEL_50:
        xpc_dictionary_set_value(v2, "extra_parent_ids", *((xpc_object_t *)v1 + 17));
        int v24 = *((void *)v1 + 12);
        if ((v24 & 0x200000000000LL) != 0)
        {
          xpc_dictionary_set_BOOL(v2, "trust_invalid_certs", 1);
          int v24 = *((void *)v1 + 12);
          if ((v24 & 0x400000000000LL) == 0)
          {
LABEL_52:
            if ((v24 & 8) == 0) {
              goto LABEL_54;
            }
            goto LABEL_53;
          }
        }

        else if ((v24 & 0x400000000000LL) == 0)
        {
          goto LABEL_52;
        }

        xpc_dictionary_set_BOOL(v2, "should_skip_probe_sampling", 1);
        if ((*((void *)v1 + 12) & 8) == 0)
        {
LABEL_54:
          os_log_type_t v25 = *(_WORD *)(*((void *)v1 + 13) + 108LL);
          if ((v25 & 8) != 0)
          {
            xpc_dictionary_set_BOOL(v2, "use_awdl", 1);
            if ((*(_WORD *)(*((void *)v1 + 13) + 108LL) & 0x10) == 0)
            {
LABEL_56:
              id v26 = *((void *)v1 + 12);
              if ((v26 & 0x20) == 0) {
                goto LABEL_58;
              }
              goto LABEL_57;
            }
          }

          else if ((v25 & 0x10) == 0)
          {
            goto LABEL_56;
          }

          xpc_dictionary_set_BOOL(v2, "use_p2p", 1);
          id v26 = *((void *)v1 + 12);
          if ((v26 & 0x20) == 0)
          {
LABEL_58:
            if ((~(_BYTE)v26 & 0xC0) == 0) {
              xpc_dictionary_set_BOOL(v2, "indefinite", 1);
            }
            os_log_type_t v27 = *(_WORD *)(*((void *)v1 + 13) + 108LL);
            if ((v27 & 2) != 0)
            {
              xpc_dictionary_set_BOOL(v2, "no_proxy", 1);
              os_log_type_t v27 = *(_WORD *)(*((void *)v1 + 13) + 108LL);
              if ((v27 & 4) == 0)
              {
LABEL_62:
                if ((v27 & 0x20) == 0) {
                  goto LABEL_63;
                }
                goto LABEL_115;
              }
            }

            else if ((v27 & 4) == 0)
            {
              goto LABEL_62;
            }

            xpc_dictionary_set_BOOL(v2, "no_transform", 1);
            if ((*(_WORD *)(*((void *)v1 + 13) + 108LL) & 0x20) == 0)
            {
LABEL_63:
              if ((v1[97] & 0x80) == 0) {
                goto LABEL_65;
              }
              goto LABEL_64;
            }

    if (!v14) {
      goto LABEL_11;
    }
LABEL_48:
    free(v14);
    goto LABEL_11;
  }

  __nwlog_obj();
  char v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  *(_WORD *)&buf[12] = 2048;
  *(void *)&buf[14] = 1LL;
  *(_WORD *)&buf[22] = 2048;
  os_log_type_t v35 = 144LL;
  int v24 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v24))
  {
    free(v24);
    goto LABEL_6;
  }

  __break(1u);
}

  if (v16) {
    free(v16);
  }
  uint64_t v13 = 0LL;
LABEL_14:

  return v13;
}

LABEL_48:
    if (!v5) {
      goto LABEL_50;
    }
    goto LABEL_49;
  }

  if (!v41)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v6 = (os_log_s *)(id)gLogObj;
    id v26 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v45 = "nw_parameters_copy_application_service_identity_block_invoke";
      v46 = 2114;
      v47 = error;
      _os_log_impl( &dword_181A5C000,  v6,  v26,  "%{public}s SecKeyCreateRandomKey failed: %{public}@, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_47;
  }

  uint64_t v17 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v6 = (os_log_s *)(id)gLogObj;
  BOOL v18 = type;
  uint64_t v19 = os_log_type_enabled(v6, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v45 = "nw_parameters_copy_application_service_identity_block_invoke";
      v46 = 2114;
      v47 = error;
      _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s SecKeyCreateRandomKey failed: %{public}@, no backtrace",  buf,  0x16u);
    }

    goto LABEL_47;
  }

  if (v19)
  {
    *(_DWORD *)buf = 136446722;
    uint64_t v45 = "nw_parameters_copy_application_service_identity_block_invoke";
    v46 = 2114;
    v47 = error;
    v48 = 2082;
    v49 = v17;
    _os_log_impl( &dword_181A5C000,  v6,  v18,  "%{public}s SecKeyCreateRandomKey failed: %{public}@, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v17);
  if (v5) {
LABEL_49:
  }
    free(v5);
LABEL_50:
  if (error)
  {
    CFRelease(error);
    error = 0LL;
  }

  if (v2) {
    goto LABEL_53;
  }
}

        _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0x12u);
        goto LABEL_48;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v24 = (os_log_s *)gLogObj;
      os_log_type_t v25 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v35 = "network_config_mptcp_watcher_create_block_invoke";
        os_log_type_t v36 = 1024;
        *(_DWORD *)BOOL v37 = v22;
        id v26 = "%{public}s recv from kernel event socket failed %{darwin.errno}d";
        goto LABEL_47;
      }

    if (v5) {
      goto LABEL_48;
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v21 = "nw_demux_options_add_pattern";
  unsigned int v5 = (char *)_os_log_send_and_compose_impl();
  uint64_t v19 = OS_LOG_TYPE_ERROR;
  BOOL v18 = 0;
  if (v19 == OS_LOG_TYPE_FAULT)
  {
    unsigned int v6 = (os_log_s *)__nwlog_obj();
    unsigned int v7 = v19;
    if (!os_log_type_enabled(v6, v19)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    char v21 = "nw_demux_options_add_pattern";
    unsigned int v8 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH)";
    goto LABEL_46;
  }

  if (!v18)
  {
    unsigned int v6 = (os_log_s *)__nwlog_obj();
    unsigned int v7 = v19;
    if (!os_log_type_enabled(v6, v19)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    char v21 = "nw_demux_options_add_pattern";
    unsigned int v8 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), backtrace limit exceeded";
    goto LABEL_46;
  }

  unsigned int v11 = (char *)__nw_create_backtrace_string();
  unsigned int v6 = (os_log_s *)__nwlog_obj();
  unsigned int v7 = v19;
  uint64_t v12 = os_log_type_enabled(v6, v19);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    char v21 = "nw_demux_options_add_pattern";
    unsigned int v8 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), no backtrace";
    goto LABEL_46;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    char v21 = "nw_demux_options_add_pattern";
    id v22 = 2082;
    char v23 = v11;
    uint64_t v13 = "%{public}s called with null (pattern_length <= NW_DEMUX_MAX_PATTERN_LENGTH), dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v6, v7, v13, buf, 0x16u);
  }

    if (v7) {
      goto LABEL_48;
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v22 = "nw_demux_options_add_pattern_data";
  unsigned int v7 = (char *)_os_log_send_and_compose_impl();
  uint64_t v20 = OS_LOG_TYPE_ERROR;
  uint64_t v19 = 0;
  if (v20 == OS_LOG_TYPE_FAULT)
  {
    unsigned int v8 = (os_log_s *)__nwlog_obj();
    unsigned int v9 = v20;
    if (!os_log_type_enabled(v8, v20)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_demux_options_add_pattern_data";
    int v10 = "%{public}s called with null pattern";
    goto LABEL_46;
  }

  if (!v19)
  {
    unsigned int v8 = (os_log_s *)__nwlog_obj();
    unsigned int v9 = v20;
    if (!os_log_type_enabled(v8, v20)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_demux_options_add_pattern_data";
    int v10 = "%{public}s called with null pattern, backtrace limit exceeded";
    goto LABEL_46;
  }

  uint64_t v13 = (char *)__nw_create_backtrace_string();
  unsigned int v8 = (os_log_s *)__nwlog_obj();
  unsigned int v9 = v20;
  uint64_t v14 = os_log_type_enabled(v8, v20);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_demux_options_add_pattern_data";
    int v10 = "%{public}s called with null pattern, no backtrace";
    goto LABEL_46;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    id v22 = "nw_demux_options_add_pattern_data";
    char v23 = 2082;
    int v24 = v13;
    uint64_t v15 = "%{public}s called with null pattern, dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v8, v9, v15, buf, 0x16u);
  }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
    goto LABEL_48;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_masque_get_remote_endpoint";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v20 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      uint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_masque_get_remote_endpoint";
      uint64_t v15 = "%{public}s called with null masque";
      goto LABEL_47;
    }

    if (!v20)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      uint64_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_masque_get_remote_endpoint";
      uint64_t v15 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_47;
    }

    BOOL v18 = (char *)__nw_create_backtrace_string();
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    uint64_t v14 = type;
    uint64_t v19 = os_log_type_enabled(v13, type);
    if (!v18)
    {
      if (!v19) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      char v23 = "nw_protocol_masque_get_remote_endpoint";
      uint64_t v15 = "%{public}s called with null masque, no backtrace";
      goto LABEL_47;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      char v23 = "nw_protocol_masque_get_remote_endpoint";
      int v24 = 2082;
      os_log_type_t v25 = v18;
      _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v18);
LABEL_48:
    if (!v12) {
      return 0LL;
    }
LABEL_49:
    free(v12);
    return 0LL;
  }

  id v3 = (void *)*((void *)handle + 43);
  if (v3)
  {
    int v4 = v3;
    if (*((void *)v4 + 3))
    {
      unsigned int v5 = v4[152];

      if (v5)
      {
        unsigned int v6 = nw_protocol_options_copy_proxy_endpoint_for_stack(*((void **)handle + 43));
        if (v6)
        {
          unsigned int v7 = v6;
          unsigned int v8 = (void *)*((void *)handle + 38);
          if (v8 != v7)
          {
            if (v8)
            {
              os_release(v8);
              *((void *)handle + 38) = 0LL;
            }

            *((void *)handle + 38) = os_retain(v7);
          }

          os_release(v7);
        }
      }

      BOOL result = (nw_protocol *)*((void *)handle + 38);
      if (result) {
        return result;
      }
    }

    else
    {

      BOOL result = (nw_protocol *)*((void *)handle + 38);
      if (result) {
        return result;
      }
    }
  }

  BOOL result = a1->default_input_handler;
  if (result)
  {
    callbacks = result->callbacks;
    if (callbacks)
    {
      get_remote_endpoint = (uint64_t (*)(void))callbacks->get_remote_endpoint;
    }

    return 0LL;
  }

  return result;
}

    if (v3) {
      goto LABEL_48;
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_masque_options_add_extra_header";
  id v3 = (char *)_os_log_send_and_compose_impl();
  uint64_t v15 = OS_LOG_TYPE_ERROR;
  uint64_t v14 = 0;
  if (v15 == OS_LOG_TYPE_FAULT)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    unsigned int v5 = v15;
    if (!os_log_type_enabled(v4, v15)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_masque_options_add_extra_header";
    unsigned int v6 = "%{public}s called with null header";
    goto LABEL_46;
  }

  if (!v14)
  {
    int v4 = (os_log_s *)__nwlog_obj();
    unsigned int v5 = v15;
    if (!os_log_type_enabled(v4, v15)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_masque_options_add_extra_header";
    unsigned int v6 = "%{public}s called with null header, backtrace limit exceeded";
    goto LABEL_46;
  }

  unsigned int v9 = (char *)__nw_create_backtrace_string();
  int v4 = (os_log_s *)__nwlog_obj();
  unsigned int v5 = v15;
  int v10 = os_log_type_enabled(v4, v15);
  if (!v9)
  {
    if (!v10) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_masque_options_add_extra_header";
    unsigned int v6 = "%{public}s called with null header, no backtrace";
    goto LABEL_46;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v17 = "nw_masque_options_add_extra_header";
    BOOL v18 = 2082;
    uint64_t v19 = v9;
    unsigned int v11 = "%{public}s called with null header, dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v4, v5, v11, buf, 0x16u);
  }

        goto LABEL_48;
      }

      if (!v16)
      {
        __nwlog_obj();
        unsigned int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unsigned int v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_link_get_local_congestion_info";
          unsigned int v7 = "%{public}s called with null pkt_count, backtrace limit exceeded";
          goto LABEL_46;
        }

        goto LABEL_47;
      }

      uint64_t v12 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unsigned int v6 = type;
      uint64_t v15 = os_log_type_enabled(v5, type);
      if (!v12)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_link_get_local_congestion_info";
          unsigned int v7 = "%{public}s called with null pkt_count, no backtrace";
          goto LABEL_46;
        }

        goto LABEL_47;
      }

      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = "nw_link_get_local_congestion_info";
        uint64_t v20 = 2082;
        char v21 = v12;
        uint64_t v14 = "%{public}s called with null pkt_count, dumping backtrace:%{public}s";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    free(backtrace_string);
    goto LABEL_67;
  }

  unsigned int v8 = (os_log_s *)__nwlog_obj();
  unsigned int v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    int v24 = "nw_protocol_webtransport_stream_connect";
    int v10 = "%{public}s called with null session_protocol";
    goto LABEL_66;
  }

      free(v25);
      if (!v15) {
        goto LABEL_67;
      }
      goto LABEL_66;
    }

    *(_DWORD *)(*(void *)v62 + 32LL) = v6;
    if (!nw_http2_transport_add_to_id_table(a1, v7, a3))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v30 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v64 = "nw_http2_transport_send_headers";
        v65 = 2082;
        v66 = a1 + 205;
        _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Failed to add new stream to the id based hash table",  buf,  0x16u);
      }

      *(_DWORD *)(*(void *)v62 + 32LL) = -1;
      goto LABEL_67;
    }

    unsigned int v8 = *(_DWORD *)(*(void *)v62 + 32LL);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v9 = (os_log_s *)gLogObj;
  if (v8 > 0)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v10 = "server";
      unsigned int v11 = *(_DWORD *)(*(void *)v62 + 32LL);
      if ((*(_BYTE *)(a1 + 204) & 0x10) == 0) {
        int v10 = "client";
      }
      *(_DWORD *)buf = 136446978;
      v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      v66 = a1 + 205;
      __int16 v67 = 2082;
      *(void *)v68 = v10;
      *(_WORD *)&v68[8] = 1024;
      *(_DWORD *)&v68[10] = v11;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s %{public}s submitted headers for stream %d",  buf,  0x26u);
    }

    nw_http2_transport_session_send(a1);
    goto LABEL_67;
  }

  *(_DWORD *)buf = 136446466;
  v64 = "nw_http2_transport_send_headers";
  v65 = 2082;
  v66 = a1 + 205;
  uint64_t v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v60 = 0;
  if (__nwlog_fault(v15, &type, &v60))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v23 = (os_log_s *)gLogObj;
      int v24 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446466;
      v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      v66 = a1 + 205;
      uint64_t v19 = "%{public}s %{public}s Stream has invalid id";
LABEL_63:
      char v32 = v23;
      id v33 = v24;
      goto LABEL_64;
    }

    if (!v60)
    {
      char v23 = (os_log_s *)__nwlog_obj();
      int v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446466;
      v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      v66 = a1 + 205;
      uint64_t v19 = "%{public}s %{public}s Stream has invalid id, backtrace limit exceeded";
      goto LABEL_63;
    }

    os_log_type_t v25 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v23 = (os_log_s *)gLogObj;
    int v24 = type;
    id v26 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v25)
    {
      if (!v26) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446466;
      v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      v66 = a1 + 205;
      uint64_t v19 = "%{public}s %{public}s Stream has invalid id, no backtrace";
      goto LABEL_63;
    }

    if (v26)
    {
      *(_DWORD *)buf = 136446722;
      v64 = "nw_http2_transport_send_headers";
      v65 = 2082;
      v66 = a1 + 205;
      __int16 v67 = 2082;
      *(void *)v68 = v25;
      os_log_type_t v27 = "%{public}s %{public}s Stream has invalid id, dumping backtrace:%{public}s";
LABEL_46:
      _os_log_impl(&dword_181A5C000, v23, v24, v27, buf, 0x20u);
      goto LABEL_47;
    }

    goto LABEL_47;
  }

      free(v28);
    }
  }

        goto LABEL_48;
      }

      __nwlog_obj();
      os_log_type_t v54 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v95 = "nw_necp_append_tlv";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();

      v90 = OS_LOG_TYPE_ERROR;
      v89 = 0;
      if (__nwlog_fault(v43, &v90, &v89))
      {
        if (v90 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v55 = v90;
          if (os_log_type_enabled(v44, v90))
          {
            *(_DWORD *)buf = 136446210;
            v95 = "nw_necp_append_tlv";
            _os_log_impl(&dword_181A5C000, v44, v55, "%{public}s called with null beyond", buf, 0xCu);
          }
        }

        else if (v89)
        {
          v68 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v69 = v90;
          v70 = os_log_type_enabled(v44, v90);
          if (v68)
          {
            if (v70)
            {
              *(_DWORD *)buf = 136446466;
              v95 = "nw_necp_append_tlv";
              v96 = 2082;
              v97 = (size_t)v68;
              _os_log_impl( &dword_181A5C000,  v44,  v69,  "%{public}s called with null beyond, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v68);
            if (!v43) {
              goto LABEL_171;
            }
            goto LABEL_170;
          }

          if (v70)
          {
            *(_DWORD *)buf = 136446210;
            v95 = "nw_necp_append_tlv";
            _os_log_impl(&dword_181A5C000, v44, v69, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v80 = v90;
          if (os_log_type_enabled(v44, v90))
          {
            *(_DWORD *)buf = 136446210;
            v95 = "nw_necp_append_tlv";
            _os_log_impl( &dword_181A5C000,  v44,  v80,  "%{public}s called with null beyond, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_168;
      }

        free(v13);
        goto LABEL_48;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        id v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
        BOOL v16 = "%{public}s called with null agentClass, no backtrace";
        goto LABEL_44;
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        id v33 = "-[NWNetworkAgentRegistration initWithNetworkAgentClass:queue:]";
        BOOL v16 = "%{public}s called with null agentClass, backtrace limit exceeded";
        goto LABEL_44;
      }
    }

    goto LABEL_48;
  }

  uint64_t v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  uint64_t v42 = "handleOpportunistic";
  __int16 v43 = 1024;
  *(_DWORD *)os_log_type_t v44 = v12;
  LODWORD(v38) = 18;
  BOOL v37 = buf;
  uint64_t v14 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  __int16 v40 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v14, type, &v40))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (os_log_s *)(id)gLogObj;
      BOOL v16 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)os_log_type_t v44 = v12;
        uint64_t v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_30:
        BOOL v28 = v15;
        os_log_type_t v29 = v16;
LABEL_31:
        _os_log_impl(&dword_181A5C000, v28, v29, v17, buf, 0x12u);
      }
    }

    else
    {
      if (v40)
      {
        char v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v15 = (os_log_s *)(id)gLogObj;
        id v22 = type[0];
        char v23 = os_log_type_enabled(v15, type[0]);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446722;
            uint64_t v42 = "handleOpportunistic";
            __int16 v43 = 1024;
            *(_DWORD *)os_log_type_t v44 = v12;
            *(_WORD *)&v44[4] = 2082;
            *(void *)&v44[6] = v21;
            _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v21);
          goto LABEL_33;
        }

        if (!v23) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)os_log_type_t v44 = v12;
        uint64_t v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        BOOL v28 = v15;
        os_log_type_t v29 = v22;
        goto LABEL_31;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (os_log_s *)(id)gLogObj;
      BOOL v16 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)os_log_type_t v44 = v12;
        uint64_t v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_30;
      }
    }

            goto LABEL_48;
          }

          LODWORD(v6) = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v13 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v6;
          uint64_t v14 = (void *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v50[0]) = 0;
          if (!__nwlog_fault((const char *)v14, type, v50))
          {
LABEL_30:
            if (v14) {
              free(v14);
            }
            goto LABEL_32;
          }

          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v16 = type[0];
            if (os_log_type_enabled(v15, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v6;
              uint64_t v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_28:
              _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0x12u);
            }
          }

          else
          {
            if (LOBYTE(v50[0]))
            {
              BOOL v18 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              BOOL v16 = type[0];
              uint64_t v19 = os_log_type_enabled(v15, type[0]);
              if (v18)
              {
                if (v19)
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v6;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v18;
                  _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
                }

                free(v18);
                goto LABEL_30;
              }

              if (!v19) {
                goto LABEL_29;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v6;
              uint64_t v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
              goto LABEL_28;
            }

            __nwlog_obj();
            uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v16 = type[0];
            if (os_log_type_enabled(v15, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v6;
              uint64_t v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
              goto LABEL_28;
            }
          }

    goto LABEL_48;
  }

  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  os_log_type_t v35 = "handleThroughputEstimates";
  os_log_type_t v36 = 1024;
  *(_DWORD *)BOOL v37 = v10;
  uint64_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (__nwlog_fault(v12, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)(id)gLogObj;
      uint64_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v35 = "handleThroughputEstimates";
        os_log_type_t v36 = 1024;
        *(_DWORD *)BOOL v37 = v10;
        uint64_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_30:
        os_log_type_t v27 = v13;
        BOOL v28 = v14;
LABEL_31:
        _os_log_impl(&dword_181A5C000, v27, v28, v15, buf, 0x12u);
      }
    }

    else
    {
      if (v32)
      {
        uint64_t v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (os_log_s *)(id)gLogObj;
        char v21 = type;
        id v22 = os_log_type_enabled(v13, type);
        if (v20)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v35 = "handleThroughputEstimates";
            os_log_type_t v36 = 1024;
            *(_DWORD *)BOOL v37 = v10;
            *(_WORD *)&v37[4] = 2082;
            *(void *)&v37[6] = v20;
            _os_log_impl( &dword_181A5C000,  v13,  v21,  "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v20);
          goto LABEL_33;
        }

        if (!v22) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v35 = "handleThroughputEstimates";
        os_log_type_t v36 = 1024;
        *(_DWORD *)BOOL v37 = v10;
        uint64_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        os_log_type_t v27 = v13;
        BOOL v28 = v21;
        goto LABEL_31;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)(id)gLogObj;
      uint64_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v35 = "handleThroughputEstimates";
        os_log_type_t v36 = 1024;
        *(_DWORD *)BOOL v37 = v10;
        uint64_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_30;
      }
    }

    goto LABEL_48;
  }

  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  os_log_type_t v35 = "handleRadioType";
  os_log_type_t v36 = 1024;
  *(_DWORD *)BOOL v37 = v10;
  uint64_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (__nwlog_fault(v12, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)(id)gLogObj;
      uint64_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v35 = "handleRadioType";
        os_log_type_t v36 = 1024;
        *(_DWORD *)BOOL v37 = v10;
        uint64_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_30:
        os_log_type_t v27 = v13;
        BOOL v28 = v14;
LABEL_31:
        _os_log_impl(&dword_181A5C000, v27, v28, v15, buf, 0x12u);
      }
    }

    else
    {
      if (v32)
      {
        uint64_t v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (os_log_s *)(id)gLogObj;
        char v21 = type;
        id v22 = os_log_type_enabled(v13, type);
        if (v20)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v35 = "handleRadioType";
            os_log_type_t v36 = 1024;
            *(_DWORD *)BOOL v37 = v10;
            *(_WORD *)&v37[4] = 2082;
            *(void *)&v37[6] = v20;
            _os_log_impl( &dword_181A5C000,  v13,  v21,  "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v20);
          goto LABEL_33;
        }

        if (!v22) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v35 = "handleRadioType";
        os_log_type_t v36 = 1024;
        *(_DWORD *)BOOL v37 = v10;
        uint64_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        os_log_type_t v27 = v13;
        BOOL v28 = v21;
        goto LABEL_31;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)(id)gLogObj;
      uint64_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v35 = "handleRadioType";
        os_log_type_t v36 = 1024;
        *(_DWORD *)BOOL v37 = v10;
        uint64_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_30;
      }
    }

    goto LABEL_48;
  }

  if (a3)
  {
    unsigned int v6 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_storage_provider_obj);
    if (!v6)
    {
LABEL_56:
      unsigned int v8 = 0LL;
      goto LABEL_6;
    }

    v33.receiver = v6;
    v33.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_storage_provider_obj;
    unsigned int v7 = (char *)objc_msgSendSuper2(&v33, sel_init);
    if (v7)
    {
      unsigned int v8 = v7;
      unsigned int v9 = *a3;
      int v10 = a3[1];
      *(_OWORD *)(v7 + 40) = a3[2];
      *(_OWORD *)(v7 + 24) = v10;
      *(_OWORD *)(v7 + 8) = v9;
      unsigned int v11 = a3[3];
      uint64_t v12 = a3[4];
      uint64_t v13 = a3[5];
      *(_OWORD *)(v7 + 104) = a3[6];
      *(_OWORD *)(v7 + 88) = v13;
      *(_OWORD *)(v7 + 72) = v12;
      *(_OWORD *)(v7 + 56) = v11;
LABEL_6:
      nw_dictionary_set_value(v5[7], a2, v8);

      goto LABEL_7;
    }

    __nwlog_obj();
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
    char v21 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v31 = 0;
    if (!__nwlog_fault((const char *)v21, &type, &v31))
    {
LABEL_54:
      if (v21) {
        free(v21);
      }
      goto LABEL_56;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
        int v24 = "%{public}s [super init] failed";
LABEL_52:
        _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
      }
    }

    else
    {
      if (v31)
      {
        os_log_type_t v29 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v23 = type;
        os_log_type_t v30 = os_log_type_enabled(v22, type);
        if (v29)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
            os_log_type_t v36 = 2082;
            BOOL v37 = v29;
            _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v29);
          goto LABEL_54;
        }

        if (!v30) {
          goto LABEL_53;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
        int v24 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_52;
      }

      __nwlog_obj();
      id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
        int v24 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_52;
      }
    }

  if (!__s1[0]) {
    goto LABEL_50;
  }
  os_log_type_t v27 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_storage);
  BOOL v28 = strdup(__s1);
  if (v28)
  {
LABEL_49:
    v27->path = v28;
    goto LABEL_51;
  }

  __nwlog_obj();
  char v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  os_log_type_t v38 = 136446210;
  char v39 = "strict_strdup";
  id v33 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v33))
  {
    free(v33);
    goto LABEL_49;
  }

      if (v26) {
        free(v26);
      }
      LODWORD(v5) = -1;
      goto LABEL_6;
    }

    goto LABEL_95;
  }

  if (v3)
  {
    int v4 = 0LL;
    LODWORD(v38) = 0;
    while (1)
    {
      char v39 = *(_DWORD *)(v3 + 52);
      __int16 v40 = v39 ? v39 - (*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60)) : 0;
      id v3 = *(void *)(v3 + 16);
      uint64_t v41 = (v4 << 31 >> 31) + 1;
      uint64_t v42 = v41 << 31 >> 31;
      if (v42 != v41 || v42 < 0) {
        break;
      }
      int v4 = (v4 << 31 >> 31) + 1;
      unsigned int v11 = __CFADD__((_DWORD)v38, v40);
      os_log_type_t v38 = v38 + v40;
      if (v11) {
        goto LABEL_79;
      }
LABEL_52:
      LODWORD(v5) = v38;
      if (!v3) {
        goto LABEL_96;
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v43 = v42;
    *(_DWORD *)buf = 136446978;
    v79 = "nw_frame_array_get_frame_count";
    v80 = 2082;
    v81 = "frame_count";
    v82 = 2048;
    v83 = 1LL;
    v84 = 2048;
    v85 = v42;
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v76 = 0;
    if (__nwlog_fault(v44, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v45 = gLogObj;
        v46 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_75;
        }
        *(_DWORD *)buf = 136446978;
        v79 = "nw_frame_array_get_frame_count";
        v80 = 2082;
        v81 = "frame_count";
        v82 = 2048;
        v83 = 1LL;
        v84 = 2048;
        v85 = v43;
        v47 = (os_log_s *)v45;
        v48 = v46;
        v49 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_74:
        _os_log_impl(&dword_181A5C000, v47, v48, v49, buf, 0x2Au);
        goto LABEL_75;
      }

      if (!v76)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v54 = gLogObj;
        BOOL v55 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_75;
        }
        *(_DWORD *)buf = 136446978;
        v79 = "nw_frame_array_get_frame_count";
        v80 = 2082;
        v81 = "frame_count";
        v82 = 2048;
        v83 = 1LL;
        v84 = 2048;
        v85 = v43;
        v47 = (os_log_s *)v54;
        v48 = v55;
        v49 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_74;
      }

      os_log_type_t v50 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = (os_log_s *)gLogObj;
      os_log_type_t v52 = type;
      v53 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v50)
      {
        if (!v53) {
          goto LABEL_75;
        }
        *(_DWORD *)buf = 136446978;
        v79 = "nw_frame_array_get_frame_count";
        v80 = 2082;
        v81 = "frame_count";
        v82 = 2048;
        v83 = 1LL;
        v84 = 2048;
        v85 = v42;
        v47 = v51;
        v48 = v52;
        v49 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_74;
      }

      if (v53)
      {
        *(_DWORD *)buf = 136447234;
        v79 = "nw_frame_array_get_frame_count";
        v80 = 2082;
        v81 = "frame_count";
        v82 = 2048;
        v83 = 1LL;
        v84 = 2048;
        v85 = v42;
        v86 = 2082;
        v87 = v50;
        _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
      }

      free(v50);
    }

    if (v13) {
      free(v13);
    }

    return 0LL;
  }

  int v4 = strdup(a2);
  if (v4)
  {
LABEL_5:
    *((void *)v3 + 29) = v4;
    unsigned int v5 = strlen(v4);
    if (v5 >= 7)
    {
      unsigned int v6 = v5;
      if (!strcmp(&v4[v5 - 6], ".local") || v6 >= 8 && !strcmp(&v4[v6 - 7], ".local.")) {
        *((_BYTE *)v3 + 231) |= 1u;
      }
    }

    return (BOOL)v3;
  }

  __nwlog_obj();
  BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v30 = "strict_strdup";
  uint64_t v17 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

                uint64_t v42 = *(unsigned __int8 **)v70;
                if (!*(void *)v70) {
                  return;
                }
                goto LABEL_48;
              }

  *(void *)os_log_type_t type = 0LL;
  if (v4 <= 0x3F)
  {
    *(void *)os_log_type_t type = v4;
    int v24 = 1;
LABEL_74:
    BOOL v28 = (char *)(v23 + v21);
    os_log_type_t v29 = v22 - v19;
    os_log_type_t v30 = v24;
    memcpy(v28, type, v24);
    if (v29 > 0x3F)
    {
      if (v29 >> 14)
      {
        if (v29 >> 30)
        {
          *(void *)os_log_type_t type = bswap64(v29 | 0xC000000000000000LL);
          os_log_type_t v31 = 8;
        }

        else
        {
          *(void *)os_log_type_t type = bswap32(v29 | 0x80000000);
          os_log_type_t v31 = 4;
        }
      }

      else
      {
        *(void *)os_log_type_t type = bswap32(v29 | 0x4000) >> 16;
        os_log_type_t v31 = 2;
      }
    }

    else
    {
      *(void *)os_log_type_t type = v22 - v19;
      os_log_type_t v31 = 1;
    }

    memcpy(&v28[v30], type, v31);
    char v32 = v31 + v30;
    if (v32 < v19)
    {
      memmove(&v28[v32], &v28[v19], v29);
      nw_frame_claim(a2, v33, 0, v19 - v32);
    }

    return 1LL;
  }

  if (!(v4 >> 14))
  {
    *(void *)os_log_type_t type = bswap32(v4 | 0x4000) >> 16;
    int v24 = 2;
    goto LABEL_74;
  }

  if (!(v4 >> 30))
  {
    *(void *)os_log_type_t type = bswap32(v4 | 0x80000000);
    int v24 = 4;
    goto LABEL_74;
  }

  if (!(v4 >> 62))
  {
    *(void *)os_log_type_t type = bswap64(v4 | 0xC000000000000000LL);
    int v24 = 8;
    goto LABEL_74;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  os_log_type_t v38 = "_http_vle_encode";
  char v39 = 2048;
  __int16 v40 = v4;
  os_log_type_t v27 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v27);
  if (!result)
  {
    free(v27);
    int v24 = 0;
    goto LABEL_74;
  }

          free(v23);
          goto LABEL_48;
        }

  if (v15) {
    free(v15);
  }
  return 0LL;
}

  if (v15) {
    free(v15);
  }
  return 0LL;
}

  if (v15) {
    free(v15);
  }
  return 0LL;
}

            goto LABEL_48;
          }

          uint64_t v20 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v17 = type;
          char v21 = os_log_type_enabled(v16, type);
          if (!v20)
          {
            if (v21)
            {
              int v24 = *(_DWORD *)__src;
              *(_DWORD *)buf = 136446466;
              __int16 v40 = "nw_nat64_synthesize_v6";
              uint64_t v41 = 1024;
              *(_DWORD *)uint64_t v42 = v24;
              uint64_t v19 = "%{public}s invalid prefix length %d, no backtrace";
              goto LABEL_46;
            }

            goto LABEL_47;
          }

          if (v21)
          {
            id v22 = *(_DWORD *)__src;
            *(_DWORD *)buf = 136446722;
            __int16 v40 = "nw_nat64_synthesize_v6";
            uint64_t v41 = 1024;
            *(_DWORD *)uint64_t v42 = v22;
            v42[2] = 2082;
            *(void *)&v42[3] = v20;
            _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s invalid prefix length %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v20);
LABEL_48:
          if (v15) {
            free(v15);
          }
          break;
      }

      return 0LL;
    }
  }

  return result;
}

                _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0x1Eu);
                goto LABEL_48;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v17 = gLogObj;
              BOOL v18 = type;
              if (os_log_type_enabled((os_log_t)gLogObj, type))
              {
                uint64_t v19 = *((_DWORD *)v69 + 7);
                *(_DWORD *)buf = 136446978;
                v72 = "copymptcpinfo";
                v73 = 1024;
                *(_DWORD *)v74 = v19;
                *(_WORD *)&v74[4] = 1024;
                *(_DWORD *)&v74[6] = v12;
                LOWORD(v75) = 1024;
                *(_DWORD *)((char *)&v75 + 2) = a1;
                uint64_t v20 = (os_log_s *)v17;
                char v21 = v18;
                id v22 = "%{public}s Unknown conninfo type %u for ifindex %u on fd %d";
                goto LABEL_47;
              }

      free(v13);
      goto LABEL_48;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v36 = "nw_parameters_create_qpod";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v10 = (os_log_s *)(id)gLogObj;
        unsigned int v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v36 = "nw_parameters_create_qpod";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s nw_parameters_create failed", buf, 0xCu);
        }
      }

      else if (v33)
      {
        BOOL v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v10 = (os_log_s *)(id)gLogObj;
        uint64_t v17 = type;
        BOOL v18 = os_log_type_enabled(v10, type);
        if (v16)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v36 = "nw_parameters_create_qpod";
            BOOL v37 = 2082;
            os_log_type_t v38 = v16;
            _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v16);
          if (!v9) {
            goto LABEL_39;
          }
          goto LABEL_38;
        }

        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v36 = "nw_parameters_create_qpod";
          _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v10 = (os_log_s *)(id)gLogObj;
        id v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v36 = "nw_parameters_create_qpod";
          _os_log_impl( &dword_181A5C000,  v10,  v22,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9)
    {
LABEL_39:
      unsigned int v7 = 0LL;
LABEL_50:

      goto LABEL_51;
    }

  if (v6) {
LABEL_48:
  }
    free(v6);
LABEL_49:
}

    free(backtrace_string);
    goto LABEL_61;
  }

  uint64_t v12 = (os_log_s *)__nwlog_obj();
  uint64_t v13 = type;
  if (os_log_type_enabled(v12, type))
  {
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_protocol_http3_connect";
    uint64_t v14 = "%{public}s called with null other_protocol";
    goto LABEL_60;
  }

    if (v22) {
      free(v22);
    }
    char v21 = 0xFFFFFFFFLL;
    a1 = v60;
  }

  if (!(*(unsigned int (**)(uint64_t, void, uint64_t, uint64_t, uint64_t, _DWORD **))(*(void *)(v8 + 24)
                                                                                              + 88LL))( v8,  *(void *)(v7 + 152),  v21,  v21,  0xFFFFFFFFLL,  v78))
  {
LABEL_82:
    uint64_t v45 = 0LL;
LABEL_109:
    _Block_object_dispose(&v69, 8);
    _Block_object_dispose(&v73, 8);
    _Block_object_dispose(&v79, 8);
    return v45;
  }

  nw_http3_framer_claim_http3_frame_header(v16 + v20, v78[0]);
  v63[0] = MEMORY[0x1895F87A8];
  v63[1] = 0x40000000LL;
  v64 = (uint64_t (*)(void *))___ZL37nw_http3_stream_send_pending_capsulesP24nw_protocol_http3_stream_block_invoke_2;
  v65 = &unk_189BC46E8;
  v66 = &v79;
  __int16 v67 = &v69;
  v68 = &v73;
  os_log_type_t v29 = v74[5];
  do
  {
    if (!v29) {
      break;
    }
    os_log_type_t v30 = *(void *)(v29 + 32);
    os_log_type_t v31 = v64(v63);
    os_log_type_t v29 = v30;
  }

  while ((v31 & 1) != 0);
  if (v80[3])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_http3_stream_send_pending_capsules_block_invoke";
    char v32 = (char *)_os_log_send_and_compose_impl();
    v84 = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (v84 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v33 = (os_log_s *)gLogObj;
      os_log_type_t v34 = v84;
      if (!os_log_type_enabled((os_log_t)gLogObj, v84)) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      v86 = "nw_http3_stream_send_pending_capsules_block_invoke";
      os_log_type_t v35 = "%{public}s Not enough space in capsule frames";
    }

    else if (v83)
    {
      __int16 v43 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v33 = (os_log_s *)gLogObj;
      os_log_type_t v34 = v84;
      os_log_type_t v44 = os_log_type_enabled((os_log_t)gLogObj, v84);
      if (v43)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          v86 = "nw_http3_stream_send_pending_capsules_block_invoke";
          v87 = 2082;
          v88 = v43;
          _os_log_impl( &dword_181A5C000,  v33,  v34,  "%{public}s Not enough space in capsule frames, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        goto LABEL_80;
      }

      if (!v44)
      {
LABEL_80:
        if (v32) {
          free(v32);
        }
        goto LABEL_82;
      }

      *(_DWORD *)buf = 136446210;
      v86 = "nw_http3_stream_send_pending_capsules_block_invoke";
      os_log_type_t v35 = "%{public}s Not enough space in capsule frames, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v33 = (os_log_s *)gLogObj;
      os_log_type_t v34 = v84;
      if (!os_log_type_enabled((os_log_t)gLogObj, v84)) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      v86 = "nw_http3_stream_send_pending_capsules_block_invoke";
      os_log_type_t v35 = "%{public}s Not enough space in capsule frames, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v33, v34, v35, buf, 0xCu);
    goto LABEL_80;
  }

  os_log_type_t v36 = *(void *)(a1 + 32);
  BOOL v37 = *(void *)(v36 + 160);
  if (!v37 || (os_log_type_t v38 = *(void *)(v37 + 24)) == 0 || !*(void *)(v38 + 96))
  {
LABEL_106:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v57 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446722;
      v86 = "nw_http3_stream_send_pending_capsules_block_invoke";
      v87 = 2048;
      v88 = (const char *)v62;
      v89 = 2048;
      v90 = size;
      _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_INFO,  "%{public}s Sending capsule type 0x%llx length %zu",  buf,  0x20u);
    }

    nw_array_append(*(void *)(a1 + 40), object);
    uint64_t v45 = 1LL;
    goto LABEL_109;
  }

  char v39 = *((_DWORD *)v70 + 6);
  __int16 v40 = v74;
  if (v62 < 0x40)
  {
    uint64_t v41 = a1;
    uint64_t v42 = 1;
LABEL_87:
    if (v39 >> 30) {
      v48 = 8;
    }
    else {
      v48 = 4;
    }
    if (v39 >= 0x4000) {
      v49 = v48;
    }
    else {
      v49 = 2;
    }
    if (v39 >= 0x40) {
      os_log_type_t v50 = v49;
    }
    else {
      os_log_type_t v50 = 1;
    }
    v51 = v50 + v42;
    os_log_type_t v52 = v50 + v42 + v39;
    if (v52 >> 30) {
      v53 = 9;
    }
    else {
      v53 = 5;
    }
    if (v52 >= 0x4000) {
      os_log_type_t v54 = v53;
    }
    else {
      os_log_type_t v54 = 3;
    }
    if (v52 >= 0x40) {
      BOOL v55 = v54;
    }
    else {
      BOOL v55 = 2;
    }
    v56 = v40[5];
    nw_http3_framer_write_http3_frame_header(v36 + 128, v62, v39, v51, v56);
    nw_http3_framer_write_http3_frame_header(v36 + 128, 0LL, v52, v55, v56);
    (*(void (**)(uint64_t, uint64_t *))(*(void *)(v37 + 24) + 96LL))(v37, v40 + 5);
    a1 = v41;
    goto LABEL_106;
  }

  if (v62 < 0x4000)
  {
    uint64_t v41 = a1;
    uint64_t v42 = 2;
    goto LABEL_87;
  }

  if (!(v62 >> 30))
  {
    uint64_t v41 = a1;
    uint64_t v42 = 4;
    goto LABEL_87;
  }

  if (!(v62 >> 62))
  {
    uint64_t v41 = a1;
    uint64_t v42 = 8;
    goto LABEL_87;
  }

  v46 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v86 = "_http_vle_length";
  v87 = 2048;
  v88 = (const char *)v62;
  v47 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v47);
  if (!result)
  {
    uint64_t v41 = a1;
    free(v47);
    uint64_t v42 = 0;
    goto LABEL_87;
  }

    if (v25) {
      free(v25);
    }
    uint64_t v13 = 0LL;
    goto LABEL_18;
  }

  os_unfair_lock_lock(v1 + 3);
  if ((v2[2]._os_unfair_lock_opaque & 0x80000000) == 0)
  {
    os_unfair_lock_opaque = v2[6]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 3) != 0)
    {
LABEL_17:
      uint64_t v13 = os_unfair_lock_opaque & 1;
      os_unfair_lock_unlock(v2 + 3);
      goto LABEL_18;
    }

    if (!change_fdguard_np())
    {
      os_unfair_lock_opaque = LOBYTE(v2[6]._os_unfair_lock_opaque) | 1;
      LOBYTE(v2[6]._os_unfair_lock_opaque) = os_unfair_lock_opaque;
      goto LABEL_17;
    }

    int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v5 = (id)gLogObj;
    unsigned int v6 = v2[2]._os_unfair_lock_opaque;
    *(_DWORD *)buf = 136446722;
    os_log_type_t v35 = "nw_fd_wrapper_guard";
    os_log_type_t v36 = 1024;
    *(_DWORD *)BOOL v37 = v6;
    *(_WORD *)&v37[4] = 1024;
    *(_DWORD *)&v37[6] = v4;
    unsigned int v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v7, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v8 = (os_log_s *)(id)gLogObj;
        unsigned int v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          int v10 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          os_log_type_t v35 = "nw_fd_wrapper_guard";
          os_log_type_t v36 = 1024;
          *(_DWORD *)BOOL v37 = v10;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s Failed to guard fd %d %{darwin.errno}d", buf, 0x18u);
        }
      }

      else if (v32)
      {
        uint64_t v15 = __nw_create_backtrace_string();
        if (v15)
        {
          BOOL v16 = (char *)v15;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v17 = (os_log_s *)(id)gLogObj;
          BOOL v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            uint64_t v19 = v2[2]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446978;
            os_log_type_t v35 = "nw_fd_wrapper_guard";
            os_log_type_t v36 = 1024;
            *(_DWORD *)BOOL v37 = v19;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = v4;
            os_log_type_t v38 = 2082;
            char v39 = v16;
            _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s Failed to guard fd %d %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
          }

          free(v16);
          if (!v7) {
            goto LABEL_12;
          }
          goto LABEL_11;
        }

        __nwlog_obj();
        unsigned int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v22 = type;
        if (os_log_type_enabled(v8, type))
        {
          char v23 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          os_log_type_t v35 = "nw_fd_wrapper_guard";
          os_log_type_t v36 = 1024;
          *(_DWORD *)BOOL v37 = v23;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl( &dword_181A5C000,  v8,  v22,  "%{public}s Failed to guard fd %d %{darwin.errno}d, no backtrace",  buf,  0x18u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v8 = (os_log_s *)(id)gLogObj;
        uint64_t v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          char v21 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          os_log_type_t v35 = "nw_fd_wrapper_guard";
          os_log_type_t v36 = 1024;
          *(_DWORD *)BOOL v37 = v21;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s Failed to guard fd %d %{darwin.errno}d, backtrace limit exceeded",  buf,  0x18u);
        }
      }
    }

    if (!v7)
    {
LABEL_12:
      os_unfair_lock_opaque = v2[6]._os_unfair_lock_opaque;
      goto LABEL_17;
    }

      free(v16);
      if (!v10) {
        return;
      }
LABEL_65:
      free(v10);
      return;
    }

    unsigned int v11 = (os_log_s *)__nwlog_obj();
    uint64_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_64;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_http_early_data_disconnected";
    uint64_t v13 = "%{public}s called with null http_early_data";
LABEL_63:
    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_64;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_protocol_http_early_data_disconnected";
    int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v11 = (os_log_s *)__nwlog_obj();
      uint64_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_64;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v25 = "nw_protocol_http_early_data_disconnected";
      uint64_t v13 = "%{public}s called with null other_protocol";
      goto LABEL_63;
    }

    if (!v22)
    {
      unsigned int v11 = (os_log_s *)__nwlog_obj();
      uint64_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_64;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v25 = "nw_protocol_http_early_data_disconnected";
      uint64_t v13 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_63;
    }

    BOOL v16 = (char *)__nw_create_backtrace_string();
    unsigned int v11 = (os_log_s *)__nwlog_obj();
    uint64_t v12 = type;
    uint64_t v19 = os_log_type_enabled(v11, type);
    if (!v16)
    {
      if (!v19) {
        goto LABEL_64;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v25 = "nw_protocol_http_early_data_disconnected";
      uint64_t v13 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_63;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_protocol_http_early_data_disconnected";
      id v26 = 2082;
      os_log_type_t v27 = v16;
      BOOL v18 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_46;
    }

    goto LABEL_47;
  }

  if ((handle[256] & 0x10) == 0)
  {
    nw_protocol_disconnected(*((void **)handle + 6), (uint64_t)handle);
    return;
  }

  handle[256] &= ~0x10u;
  id v3 = (nw_protocol *)*((void *)handle + 4);
  parameters = (void *)nw_protocol_get_parameters((uint64_t)handle);
  if (parameters) {
    unsigned int v5 = os_retain(parameters);
  }
  else {
    unsigned int v5 = 0LL;
  }
  unsigned int v6 = nw_parameters_copy_protocol_options_legacy(v5, v3);
  nw_protocol_remove_input_handler(*((void *)handle + 4), (uint64_t)handle);
  if (!v6)
  {
    handle[256] |= 4u;
    nw_protocol_add_input_handler(*((void *)handle + 31), (uint64_t)handle);
    nw_protocol_connect(*((void *)handle + 4), (uint64_t)handle);
    *((void *)handle + 31) = 0LL;
    if (!v5) {
      return;
    }
    goto LABEL_19;
  }

  if ((handle[198] & 1) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        char v21 = *((void *)handle + 31);
        *(_DWORD *)buf = 136447234;
        os_log_type_t v25 = "nw_protocol_http_early_data_disconnected";
        id v26 = 2082;
        os_log_type_t v27 = handle + 114;
        BOOL v28 = 2080;
        os_log_type_t v29 = " ";
        os_log_type_t v30 = 2048;
        os_log_type_t v31 = v3;
        char v32 = 2048;
        id v33 = v21;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sresetting http stream protocol instance %p to connection %p",  buf,  0x34u);
      }
    }
  }

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  unsigned int v7 = (id)nw_protocol_copy_http_definition_http_definition;
  unsigned int v8 = *((void *)handle + 31);
  unsigned int v9 = v6;
  *((void *)v9 + 2) = v8;

  if (v7) {
    os_release(v7);
  }
  handle[256] |= 4u;
  nw_protocol_add_input_handler(*((void *)handle + 31), (uint64_t)handle);
  nw_protocol_connect(*((void *)handle + 4), (uint64_t)handle);
  *((void *)handle + 31) = 0LL;
  os_release(v9);
  if (v5) {
LABEL_19:
  }
    os_release(v5);
}

  if (v7) {
    free((void *)v7);
  }
  return 0LL;
}

  if (v20) {
    free(v20);
  }
  int v4 = 0LL;
LABEL_30:

  return v4;
}

  return v7;
}

    if (v23) {
      free(v23);
    }
    goto LABEL_49;
  }

  __nwlog_obj();
  os_log_type_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v57 = "strict_calloc";
  BOOL v58 = 2048;
  *(void *)os_log_type_t v59 = 1LL;
  *(_WORD *)&v59[8] = 2048;
  *(void *)&v59[10] = 25LL;
  BOOL v37 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v37);
  if (!result)
  {
    free(v37);
    __nwlog_obj();
    os_log_type_t v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v57 = "nw_necp_append_tlv";
    char v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v54 = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (__nwlog_fault(v39, &v54, &v53))
    {
      if (v54 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v41 = v54;
        if (os_log_type_enabled(v40, v54))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v40, v41, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }

      else if (v53)
      {
        __int16 v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v44 = v54;
        uint64_t v45 = os_log_type_enabled(v40, v54);
        if (v43)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v57 = "nw_necp_append_tlv";
            BOOL v58 = 2082;
            *(void *)os_log_type_t v59 = v43;
            _os_log_impl( &dword_181A5C000,  v40,  v44,  "%{public}s called with null tlv_start, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v43);
          goto LABEL_85;
        }

        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "nw_necp_append_tlv";
          _os_log_impl(&dword_181A5C000, v40, v44, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v46 = v54;
        if (os_log_type_enabled(v40, v54))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v57 = "nw_necp_append_tlv";
          _os_log_impl( &dword_181A5C000,  v40,  v46,  "%{public}s called with null tlv_start, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_48;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v32 = "nw_path_enumerate_interfaces";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v30 = OS_LOG_TYPE_ERROR;
    os_log_type_t v29 = 0;
    if (v30 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = v30;
      if (os_log_type_enabled(v14, v30))
      {
        *(_DWORD *)buf = 136446210;
        char v32 = "nw_path_enumerate_interfaces";
        _os_log_impl(&dword_181A5C000, v14, v17, "%{public}s called with null enumerate_block", buf, 0xCu);
      }
    }

    else if (v29)
    {
      char v21 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v22 = v30;
      char v23 = os_log_type_enabled(v14, v30);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          char v32 = "nw_path_enumerate_interfaces";
          id v33 = 2082;
          os_log_type_t v34 = v21;
          _os_log_impl( &dword_181A5C000,  v14,  v22,  "%{public}s called with null enumerate_block, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v21);
        if (!v13) {
          goto LABEL_7;
        }
LABEL_49:
        free(v13);
        goto LABEL_7;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        char v32 = "nw_path_enumerate_interfaces";
        _os_log_impl(&dword_181A5C000, v14, v22, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = v30;
      if (os_log_type_enabled(v14, v30))
      {
        *(_DWORD *)buf = 136446210;
        char v32 = "nw_path_enumerate_interfaces";
        _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s called with null enumerate_block, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_47;
  }

  if (!*((void *)v3 + 12) || (v4[2](v4) & 1) != 0)
  {
    unsigned int v6 = (unsigned __int8 *)*((void *)v3 + 9);
    if (v6)
    {
      v26[0] = MEMORY[0x1895F87A8];
      v26[1] = 3221225472LL;
      v26[2] = __nw_path_enumerate_interfaces_block_invoke;
      v26[3] = &unk_189BC5258;
      os_log_type_t v27 = v3;
      BOOL v28 = v5;
      nw_array_apply(v6, (uint64_t)v26);
    }

    else if (*((_DWORD *)v3 + 86))
    {
      unsigned int v7 = 0LL;
      unsigned int v8 = 0LL;
      while (1)
      {
        unsigned int v9 = *((void *)v3 + 38);
        int v10 = nw_parameters_copy_context(*((void **)v3 + 2));
        unsigned int v11 = nw_path_copy_interface_with_generation(v10, *(_DWORD *)(v9 + v7), *(_DWORD *)(v9 + v7 + 4));

        if (v11)
        {
          if (v11 != *((NWConcrete_nw_interface **)v3 + 12)
            && (((uint64_t (**)(void, NWConcrete_nw_interface *))v5)[2](v5, v11) & 1) == 0)
          {
            break;
          }
        }

        ++v8;
        v7 += 24LL;
      }
    }
  }

  os_log_type_t v25 = 2;
LABEL_48:

  if ((v25 | 2) == 3)
  {
    os_log_type_t v31 = *(void *)(a1 + 32);
    if (v31)
    {
      objc_storeStrong((id *)(v31 + 104), a2);
      char v32 = *(void *)(a1 + 32);
      if (v32) {
        *(_BYTE *)(v32 + 14) = 1;
      }
    }

    if (v25 == 3)
    {
      id v33 = *(void *)(a1 + 32);
      if (v33)
      {
        *(_BYTE *)(v33 + 15) = 1;
        os_log_type_t v34 = *(void *)(a1 + 32);
      }

      else
      {
        os_log_type_t v34 = 0LL;
      }

      -[NWURLLoaderHTTP continueLoading](v34);
    }
  }

      goto LABEL_48;
    }

    if (!v20)
    {
      __nwlog_obj();
      int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      unsigned int v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        char v23 = "nw_oblivious_http_create_options";
        uint64_t v12 = "%{public}s called with null request_path, backtrace limit exceeded";
        goto LABEL_46;
      }

      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v11 = type;
    uint64_t v19 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        char v23 = "nw_oblivious_http_create_options";
        uint64_t v12 = "%{public}s called with null request_path, no backtrace";
        goto LABEL_46;
      }

      goto LABEL_47;
    }

    if (!v19) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    char v23 = "nw_oblivious_http_create_options";
    int v24 = 2082;
    os_log_type_t v25 = backtrace_string;
    uint64_t v17 = "%{public}s called with null request_path, dumping backtrace:%{public}s";
    goto LABEL_32;
  }

      goto LABEL_48;
    }

    if (!v22)
    {
      __nwlog_obj();
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_oblivious_http_create_options_with_context";
        uint64_t v14 = "%{public}s called with null request_path, backtrace limit exceeded";
        goto LABEL_46;
      }

      goto LABEL_47;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v13 = type;
    char v21 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_oblivious_http_create_options_with_context";
        uint64_t v14 = "%{public}s called with null request_path, no backtrace";
        goto LABEL_46;
      }

      goto LABEL_47;
    }

    if (!v21) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v25 = "nw_oblivious_http_create_options_with_context";
    id v26 = 2082;
    os_log_type_t v27 = backtrace_string;
    uint64_t v19 = "%{public}s called with null request_path, dumping backtrace:%{public}s";
    goto LABEL_32;
  }

  if (v17) {
    free(v17);
  }
  return 0LL;
}

    if (v14) {
      free(v14);
    }
    uint64_t v12 = 0;
    goto LABEL_13;
  }

  unsigned int v6 = v5[2];
  if (v6 && !nw_path_parameters_get_logging_disabled(*(void *)(v6 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    unsigned int v7 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      unsigned int v8 = *(_DWORD *)(a1[4] + 448LL);
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_connection_fillout_tcp_connection_info_block_invoke";
      os_log_type_t v30 = 1024;
      LODWORD(v31) = v8;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] MPTCP is currently not supported",  buf,  0x12u);
    }
  }

    if (!v24) {
      goto LABEL_27;
    }
    char v21 = (char *)v24;
    goto LABEL_26;
  }

  if (a3 >= 0xFFFFFFF0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    os_log_type_t v38 = "nw_agent_assign";
    char v39 = 2048;
    __int16 v40 = a3;
    unsigned int v11 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v35 = 0;
    if (__nwlog_fault(v11, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_agent_assign";
          char v39 = 2048;
          __int16 v40 = a3;
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s Invalid data length (%zu)", buf, 0x16u);
        }
      }

      else if (v35)
      {
        uint64_t v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v18 = type;
        uint64_t v19 = os_log_type_enabled(v12, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v38 = "nw_agent_assign";
            char v39 = 2048;
            __int16 v40 = a3;
            uint64_t v41 = 2082;
            uint64_t v42 = v17;
            _os_log_impl( &dword_181A5C000,  v12,  v18,  "%{public}s Invalid data length (%zu), dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v17);
          if (!v11) {
            goto LABEL_27;
          }
LABEL_25:
          char v21 = (char *)v11;
LABEL_26:
          free(v21);
          goto LABEL_27;
        }

        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_agent_assign";
          char v39 = 2048;
          __int16 v40 = a3;
          _os_log_impl(&dword_181A5C000, v12, v18, "%{public}s Invalid data length (%zu), no backtrace", buf, 0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_agent_assign";
          char v39 = 2048;
          __int16 v40 = a3;
          _os_log_impl( &dword_181A5C000,  v12,  v20,  "%{public}s Invalid data length (%zu), backtrace limit exceeded",  buf,  0x16u);
        }
      }
    }

    if (!v11)
    {
LABEL_27:
      fd = 0LL;
LABEL_28:

      return fd;
    }

    goto LABEL_25;
  }

  uint64_t v14 = calloc(1uLL, a3 + 16);
  if (v14)
  {
LABEL_9:
    *uint64_t v14 = *(_OWORD *)a4;
    if (a3) {
      memcpy(v14 + 1, a2, a3);
    }
    uint64_t v15 = (void *)*((void *)v9 + 105);
    v33[0] = MEMORY[0x1895F87A8];
    v33[1] = 3221225472LL;
    v33[2] = ___ZL15nw_agent_assignP19NWConcrete_nw_agentPhmS1_b_block_invoke;
    v33[3] = &__block_descriptor_49_e8_B12__0i8l;
    os_log_type_t v34 = a5;
    v33[4] = v14;
    v33[5] = a3 + 16;
    fd = nw_fd_wrapper_get_fd(v15, v33);
    free(v14);
    goto LABEL_28;
  }

  __nwlog_obj();
  os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v38 = "strict_calloc";
  char v39 = 2048;
  __int16 v40 = 1LL;
  uint64_t v41 = 2048;
  uint64_t v42 = (char *)(a3 + 16);
  BOOL v28 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    goto LABEL_9;
  }

  __break(1u);
  return result;
}

    if (v12)
    {
      id v33 = (char *)v12;
LABEL_56:
      free(v33);
      return 0LL;
    }

    return 0LL;
  }

  unsigned int v9 = v7;
  if ((v8 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v38 = (os_log_s *)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      __int16 v40 = *(_DWORD *)(a2 + 176);
      char v39 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      v49 = "nw_http2_add_to_id_table";
      os_log_type_t v50 = 2082;
      v51 = (char *)(a2 + 191);
      os_log_type_t v52 = 2080;
      v53 = " ";
      os_log_type_t v54 = 1024;
      BOOL v55 = v39;
      v56 = 1024;
      os_log_type_t v57 = v40;
      BOOL v58 = 1024;
      *(_DWORD *)os_log_type_t v59 = v40;
      _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> added stream %d to stream id hash table",  buf,  0x32u);
    }
  }

  if (a3)
  {
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v42 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v44 = *(_DWORD *)(a2 + 176);
        __int16 v43 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136448002;
        v49 = "nw_http2_add_to_id_table";
        os_log_type_t v50 = 2082;
        v51 = (char *)(a2 + 191);
        os_log_type_t v52 = 2080;
        v53 = " ";
        os_log_type_t v54 = 1024;
        BOOL v55 = v43;
        v56 = 1024;
        os_log_type_t v57 = v44;
        BOOL v58 = 2048;
        *(void *)os_log_type_t v59 = a2;
        *(_WORD *)&v59[8] = 2048;
        *(void *)&v59[10] = v9;
        os_log_type_t v60 = 2048;
        v61 = a3;
        _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> connecting stream %p node %p with protocol %p",  buf,  0x4Au);
      }
    }

    *(void *)nw_hash_node_get_extra(v9) = a3;
  }

  return v9;
}

    __int16 v43 = *(void *)(a1 + 48);
    os_log_type_t v44 = *(unsigned __int16 *)(v43 + 188) | (*(unsigned __int8 *)(v43 + 190) << 16);
    if (!*(void *)(v43 + 112))
    {
      if ((v44 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v47 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v48 = *(void *)(a1 + 48);
          v49 = "";
          os_log_type_t v50 = (const char *)(v48 + 191);
          v51 = v48 == 0;
          if (!v48) {
            os_log_type_t v50 = "";
          }
          os_log_type_t v54 = v48 + 176;
          os_log_type_t v52 = *(_DWORD *)(v48 + 176);
          v53 = *(_DWORD *)(v54 + 4);
          if (!v51) {
            v49 = " ";
          }
          *(_DWORD *)buf = 136447746;
          v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          v214 = 2082;
          v215 = v50;
          v216 = 2080;
          v217 = (uint64_t)v49;
          v218 = 1024;
          *(_DWORD *)v219 = v53;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v52;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v52;
          *(_WORD *)&v219[16] = 2048;
          *(void *)&v219[18] = a2;
          BOOL v55 = "%{public}s %{public}s%s<i%u:s%d> stream %d has no metadata to set on frame %p";
          goto LABEL_203;
        }
      }

      if (v11)
      {
        os_log_type_t v31 = (char *)v11;
LABEL_56:
        free(v31);
        return 0LL;
      }

      return 0LL;
    }

    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v49 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136447490;
    v64 = "nw_http2_add_to_protocol_table";
    v65 = 2082;
    v66 = (char *)(a1 + 390);
    __int16 v67 = 2080;
    v68 = " ";
    v69 = 1024;
    v70 = v49;
    v71 = 1042;
    *(_DWORD *)v72 = 16;
    *(_WORD *)&v72[4] = 2098;
    *(void *)&v72[6] = a2;
    os_log_type_t v50 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v60 = 0;
    if (__nwlog_fault(v50, &type, &v60))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v51 = (os_log_s *)gconnectionLogObj;
        os_log_type_t v52 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_107;
        }
        v53 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447490;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a1 + 390);
        __int16 v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v53;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = a2;
        os_log_type_t v54 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P";
        goto LABEL_106;
      }

      if (!v60)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        v51 = (os_log_s *)gconnectionLogObj;
        os_log_type_t v52 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_107;
        }
        BOOL v58 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447490;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a1 + 390);
        __int16 v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v58;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = a2;
        os_log_type_t v54 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, backtrac"
              "e limit exceeded";
        goto LABEL_106;
      }

      BOOL v55 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v51 = (os_log_s *)gconnectionLogObj;
      os_log_type_t v52 = type;
      v56 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v55)
      {
        if (v56)
        {
          os_log_type_t v57 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447746;
          v64 = "nw_http2_add_to_protocol_table";
          v65 = 2082;
          v66 = (char *)(a1 + 390);
          __int16 v67 = 2080;
          v68 = " ";
          v69 = 1024;
          v70 = v57;
          v71 = 1042;
          *(_DWORD *)v72 = 16;
          *(_WORD *)&v72[4] = 2098;
          *(void *)&v72[6] = a2;
          *(_WORD *)&v72[14] = 2082;
          *(void *)&v72[16] = v55;
          _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, dumping ba cktrace:%{public}s",  buf,  0x40u);
        }

        free(v55);
        goto LABEL_107;
      }

      if (v56)
      {
        os_log_type_t v59 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447490;
        v64 = "nw_http2_add_to_protocol_table";
        v65 = 2082;
        v66 = (char *)(a1 + 390);
        __int16 v67 = 2080;
        v68 = " ";
        v69 = 1024;
        v70 = v59;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(void *)&v72[6] = a2;
        os_log_type_t v54 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, no backtrace";
LABEL_106:
        _os_log_impl(&dword_181A5C000, v51, v52, v54, buf, 0x36u);
      }
    }

    if (v6) {
      goto LABEL_48;
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v21 = "nw_protocol_test_options_set_event_handler";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();
  uint64_t v19 = OS_LOG_TYPE_ERROR;
  BOOL v18 = 0;
  if (v19 == OS_LOG_TYPE_FAULT)
  {
    unsigned int v7 = (os_log_s *)__nwlog_obj();
    unsigned int v8 = v19;
    if (!os_log_type_enabled(v7, v19)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    char v21 = "nw_protocol_test_options_set_event_handler";
    unsigned int v9 = "%{public}s called with null event";
    goto LABEL_46;
  }

  if (!v18)
  {
    unsigned int v7 = (os_log_s *)__nwlog_obj();
    unsigned int v8 = v19;
    if (!os_log_type_enabled(v7, v19)) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    char v21 = "nw_protocol_test_options_set_event_handler";
    unsigned int v9 = "%{public}s called with null event, backtrace limit exceeded";
    goto LABEL_46;
  }

  uint64_t v12 = (char *)__nw_create_backtrace_string();
  unsigned int v7 = (os_log_s *)__nwlog_obj();
  unsigned int v8 = v19;
  uint64_t v13 = os_log_type_enabled(v7, v19);
  if (!v12)
  {
    if (!v13) {
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446210;
    char v21 = "nw_protocol_test_options_set_event_handler";
    unsigned int v9 = "%{public}s called with null event, no backtrace";
    goto LABEL_46;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    char v21 = "nw_protocol_test_options_set_event_handler";
    id v22 = 2082;
    char v23 = v12;
    uint64_t v14 = "%{public}s called with null event, dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_181A5C000, v7, v8, v14, buf, 0x16u);
  }

void sub_181A80474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_stack *nw_protocol_stack_copy(void *a1)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_stack);
  if (v2)
  {
    uint64_t v3 = MEMORY[0x1895F87A8];
    if (v1[1])
    {
      BOOL v4 = nw_array_create();
      persistent_application_protocols = v2->persistent_application_protocols;
      v2->persistent_application_protocols = (OS_nw_array *)v4;

      unsigned int v6 = (unsigned __int8 *)v1[1];
      v34[0] = v3;
      v34[1] = 3221225472LL;
      v34[2] = __nw_protocol_stack_copy_block_invoke;
      v34[3] = &unk_189BC85B0;
      os_log_type_t v35 = v2;
      nw_array_apply(v6, (uint64_t)v34);
    }

    if (v1[2])
    {
      BOOL v7 = nw_array_create();
      application_protocols = v2->application_protocols;
      v2->application_protocols = (OS_nw_array *)v7;

      unsigned int v9 = (unsigned __int8 *)v1[2];
      v32[0] = v3;
      v32[1] = 3221225472LL;
      v32[2] = __nw_protocol_stack_copy_block_invoke_2;
      v32[3] = &unk_189BC85B0;
      id v33 = v2;
      nw_array_apply(v9, (uint64_t)v32);
    }

    int v10 = (void *)v1[3];
    if (v10)
    {
      unsigned int v11 = nw_protocol_options_copy(v10);
      transport_protocol = v2->transport_protocol;
      v2->transport_protocol = (OS_nw_protocol_options *)v11;
    }

    uint64_t v13 = (void *)v1[4];
    if (v13)
    {
      uint64_t v14 = nw_protocol_options_copy(v13);
      secondary_transport_protocol = v2->secondary_transport_protocol;
      v2->secondary_transport_protocol = (OS_nw_protocol_options *)v14;
    }

    BOOL v16 = (void *)v1[5];
    if (v16)
    {
      uint64_t v17 = nw_protocol_options_copy(v16);
      original_proxied_transport_protocol = v2->original_proxied_transport_protocol;
      v2->original_proxied_transport_protocol = (OS_nw_protocol_options *)v17;
    }

    uint64_t v19 = (void *)v1[6];
    if (v19)
    {
      uint64_t v20 = nw_protocol_options_copy(v19);
      internet_protocol = v2->internet_protocol;
      v2->internet_protocol = (OS_nw_protocol_options *)v20;
    }

    id v22 = v2;
    goto LABEL_34;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v23 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  char v39 = "nw_protocol_stack_copy";
  int v24 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v37 = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (v37 == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v25 = (os_log_s *)(id)gLogObj;
    os_log_type_t v26 = v37;
    if (os_log_type_enabled(v25, v37))
    {
      *(_DWORD *)buf = 136446210;
      char v39 = "nw_protocol_stack_copy";
      _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s [[nw_protocol_stack alloc] init] failed", buf, 0xCu);
    }

void sub_181A808A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_stack_copy_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 16LL);
  BOOL v4 = nw_protocol_options_copy(a3);
  nw_array_append(v3, v4);

  return 1LL;
}

void nw_synchronize(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_synchronize";
    BOOL v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_synchronize";
      BOOL v7 = "%{public}s called with null lock";
LABEL_31:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      goto LABEL_32;
    }

    if (!v12)
    {
      unsigned int v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_synchronize";
      BOOL v7 = "%{public}s called with null lock, backtrace limit exceeded";
      goto LABEL_31;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v9) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v15 = "nw_synchronize";
      BOOL v7 = "%{public}s called with null lock, no backtrace";
      goto LABEL_31;
    }

    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v15 = "nw_synchronize";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null lock, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_32:
    if (!v4) {
      return;
    }
    goto LABEL_33;
  }

  if (a2)
  {
    os_unfair_lock_lock(a1);
    (*(void (**)(uint64_t))(a2 + 16))(a2);
    os_unfair_lock_unlock(a1);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "nw_synchronize";
  BOOL v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    unsigned int v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_synchronize";
    BOOL v7 = "%{public}s called with null block";
    goto LABEL_31;
  }

  if (!v12)
  {
    unsigned int v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_synchronize";
    BOOL v7 = "%{public}s called with null block, backtrace limit exceeded";
    goto LABEL_31;
  }

  int v10 = (char *)__nw_create_backtrace_string();
  unsigned int v5 = (os_log_s *)__nwlog_obj();
  os_log_type_t v6 = type;
  BOOL v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_32;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v15 = "nw_synchronize";
    BOOL v7 = "%{public}s called with null block, no backtrace";
    goto LABEL_31;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v15 = "nw_synchronize";
    __int16 v16 = 2082;
    uint64_t v17 = v10;
    _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null block, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v10);
  if (v4) {
LABEL_33:
  }
    free(v4);
}

void nw_endpoint_copy_properties(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  BOOL v4 = a2;
  unsigned int v5 = v4;
  if (!v4)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_endpoint_copy_properties";
    char v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v12, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v28 = "nw_endpoint_copy_properties";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null copy", buf, 0xCu);
        }
      }

      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v28 = "nw_endpoint_copy_properties";
            __int16 v29 = 2082;
            os_log_type_t v30 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null copy, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }

        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v28 = "nw_endpoint_copy_properties";
          _os_log_impl(&dword_181A5C000, v13, v20, "%{public}s called with null copy, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v28 = "nw_endpoint_copy_properties";
          _os_log_impl( &dword_181A5C000,  v13,  v22,  "%{public}s called with null copy, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_30:
  __break(1u);
}

    uint64_t v3 = 0LL;
    goto LABEL_31;
  }

  uint64_t v3 = v1->mode_handler;
LABEL_31:

  return v3;
}

    if (v10) {
      free(v10);
    }
    goto LABEL_32;
  }

  uint64_t v3 = v1[19];
  if (!v3) {
    goto LABEL_32;
  }
  BOOL v4 = *(void **)(v3 + 24);
  if (!v4) {
    goto LABEL_32;
  }
  unsigned int v5 = v4;
  char v6 = nw_protocol_options_matches_definition(v5, (void *)g_udp_definition);

  BOOL v7 = *(void **)(v2[19] + 24LL);
  if (!v6)
  {
    if (!nw_protocol_options_is_tcp(v7)
      && !nw_protocol_options_is_custom_ip(*(void **)(v2[19] + 24LL))
      && nw_protocol_options_is_quic(*(nw_protocol_options_t *)(v2[19] + 24LL)))
    {
      unsigned int v8 = -3;
      goto LABEL_33;
    }

    if (v12) {
      free(v12);
    }
    goto LABEL_10;
  }

  uint64_t v3 = *(void **)(v1[19] + 48LL);
  if (v3)
  {
    BOOL v4 = v3;
    unsigned int v5 = v4[1];

    char v6 = (id)g_ip_definition;
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v6);

    if (is_equal_unsafe)
    {
      version = nw_ip_options_get_version(*(void **)(v2[19] + 48LL));
      if (version == 4)
      {
        int v9 = 2LL;
        goto LABEL_12;
      }

      if (version == 6)
      {
        int v9 = 30LL;
LABEL_12:

        goto LABEL_13;
      }
    }
  }

            goto LABEL_72;
          }

          if (!uu[0])
          {
            __nwlog_obj();
            os_log_type_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v50 = v312[0];
            if (os_log_type_enabled(v38, (os_log_type_t)v312[0]))
            {
              *(_DWORD *)buf = 136446466;
              v314 = "nw_path_struct_size_for_endpoint";
              v315 = 1024;
              *(_DWORD *)v316 = 1024;
              _os_log_impl( &dword_181A5C000,  v38,  v50,  "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded",  buf,  0x12u);
            }

            goto LABEL_30;
          }

          v46 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v48 = v312[0];
          v49 = os_log_type_enabled(v47, (os_log_type_t)v312[0]);
          if (v46)
          {
            if (v49)
            {
              *(_DWORD *)buf = 136446722;
              v314 = "nw_path_struct_size_for_endpoint";
              v315 = 1024;
              *(_DWORD *)v316 = 1024;
              *(_WORD *)&v316[4] = 2082;
              *(void *)&v316[6] = v46;
              _os_log_impl( &dword_181A5C000,  v47,  v48,  "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v46);
          }

          else
          {
            if (v49)
            {
              *(_DWORD *)buf = 136446466;
              v314 = "nw_path_struct_size_for_endpoint";
              v315 = 1024;
              *(_DWORD *)v316 = 1024;
              _os_log_impl( &dword_181A5C000,  v47,  v48,  "%{public}s Custom data size must be no larger than %d, no backtrace",  buf,  0x12u);
            }
          }
        }

    if (v12) {
      free(v12);
    }
    goto LABEL_12;
  }

  if ((*((_BYTE *)v1 + 476) & 1) == 0 || (uint64_t v3 = (void *)*((void *)v1 + 11)) == 0LL)
  {
    BOOL v4 = v1;
    unsigned int v5 = v4;
    char v6 = v4[66];
    if (v6 != 6 && v6 != 12)
    {

LABEL_12:
      int v9 = 0LL;
      goto LABEL_13;
    }

    unsigned int v8 = v4[67];

    if (!v8) {
      goto LABEL_12;
    }
    uint64_t v3 = (void *)*((void *)v5 + 12);
    if (!v3) {
      goto LABEL_12;
    }
  }

  int v9 = v3;
LABEL_13:

  return v9;
}

    uint64_t v3 = 0LL;
    goto LABEL_31;
  }

  uint64_t v3 = v1->mode_handler;
LABEL_31:

  return v3;
}

  if (v10) {
    free(v10);
  }
  return 0LL;
}

  uint64_t v18 = a2->handle;
  uint64_t v19 = v18 == &nw_protocol_ref_counted_handle;
  if (v18 == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v20 = a2[1].callbacks;
    if (v20) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v20->add_input_handler + 1);
    }
  }

    free(backtrace_string);
    goto LABEL_43;
  }

  if (v3[13] == a2)
  {
    unsigned int v5 = v3[16];
    goto LABEL_10;
  }

  if (v3[12] == a2)
  {
    unsigned int v5 = v3[15];
    goto LABEL_10;
  }

  if (v3[11] == a2)
  {
    unsigned int v5 = v3[14];
    goto LABEL_10;
  }

  if (v18) {
    free(v18);
  }
}

      *v9 &= ~1u;
    }
  }

LABEL_31:
    if (v5) {
      free(v5);
    }
    return;
  }

  uint64_t v2 = *(dispatch_object_s **)a1;
  if (v2)
  {
    dispatch_suspend(v2);
    return;
  }

  uint64_t v3 = *(void **)(a1 + 16);
  if (*(_BYTE *)(a1 + 48))
  {
    if (v3)
    {
      if (*(_BYTE *)(a1 + 49))
      {
        nw_context_reset_timer_block_with_time(*(void **)(a1 + 8), a1, -1LL, v3);
        *(_BYTE *)(a1 + 49) = 0;
      }

      return;
    }

    goto LABEL_11;
  }

  if (!v3)
  {
LABEL_11:
    if (gLogDatapath)
    {
      __nwlog_obj();
      BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_queue_suspend_source";
        _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not suspending source", buf, 0xCu);
      }
    }

    return;
  }

  if (*(_BYTE *)(a1 + 49))
  {
    nw_context_dequeue_source_block(*(void **)(a1 + 8), *(void **)(a1 + 16));
    *(_BYTE *)(a1 + 49) = 0;
  }

            goto LABEL_44;
          }

          if (!v176)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v24 = (os_log_s *)(id)gLogObj;
            char v32 = type;
            if (os_log_type_enabled(v24, type))
            {
              else {
                id v33 = off_189BBBBC0[v16];
              }
              *(_DWORD *)buf = 136446722;
              v179 = "nw_endpoint_handler_reported_do_not_reuse";
              v180 = 2082;
              v181 = (void *)v33;
              v182 = 2082;
              v183 = "flow";
              _os_log_impl( &dword_181A5C000,  v24,  v32,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
            }

            goto LABEL_30;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v28 = (os_log_s *)(id)gLogObj;
          __int16 v29 = type;
          os_log_type_t v30 = os_log_type_enabled(v28, type);
          if (backtrace_string)
          {
            if (v30)
            {
              else {
                uint64_t v31 = off_189BBBBC0[v16];
              }
              *(_DWORD *)buf = 136446978;
              v179 = "nw_endpoint_handler_reported_do_not_reuse";
              v180 = 2082;
              v181 = (void *)v31;
              v182 = 2082;
              v183 = "flow";
              v184 = 2082;
              v185 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
            if (!v23) {
              goto LABEL_46;
            }
            goto LABEL_45;
          }

          if (v30)
          {
            else {
              os_log_type_t v34 = off_189BBBBC0[v16];
            }
            *(_DWORD *)buf = 136446722;
            v179 = "nw_endpoint_handler_reported_do_not_reuse";
            v180 = 2082;
            v181 = (void *)v34;
            v182 = 2082;
            v183 = "flow";
            _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
          }
        }

    if (v13) {
      free(v13);
    }
    char v12 = -1;
    goto LABEL_33;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v28 = "__nw_frame_set_external_data";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v19, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "__nw_frame_set_external_data";
        os_log_type_t v22 = "%{public}s called with null frame";
LABEL_51:
        _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
      }
    }

    else if (v25)
    {
      id v23 = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      int v24 = os_log_type_enabled(v20, type);
      if (v23)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v28 = "__nw_frame_set_external_data";
          __int16 v29 = 2082;
          *(void *)os_log_type_t v30 = v23;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
        goto LABEL_52;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "__nw_frame_set_external_data";
        os_log_type_t v22 = "%{public}s called with null frame, no backtrace";
        goto LABEL_51;
      }
    }

    else
    {
      os_log_type_t v20 = (os_log_s *)__nwlog_obj();
      BOOL v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "__nw_frame_set_external_data";
        os_log_type_t v22 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_51;
      }
    }
  }
  }

    if (v12) {
      free(v12);
    }
    goto LABEL_9;
  }

  uint64_t v3 = v1;
  if (uuid_is_null((const unsigned __int8 *)(v3[13] + 24LL)))
  {
  }

  else
  {
    int v9 = uuid_compare((const unsigned __int8 *)(v3[13] + 24LL), (const unsigned __int8 *)(v3[13] + 8LL));

    if (v9)
    {
      unsigned int v5 = v3[13];
LABEL_12:
      unsigned int v8 = (*(unsigned __int16 *)(v5 + 100) >> 7) & 1;
      goto LABEL_13;
    }
  }

  BOOL v4 = getpid();
  unsigned int v5 = v3[13];
  char v6 = *(_DWORD *)(v5 + 64);
  if (v6 >= 1 && v6 != v4) {
    goto LABEL_12;
  }
LABEL_9:
  unsigned int v8 = 0LL;
LABEL_13:

  return v8;
}

  swift_unknownObjectRelease();
  swift_unknownObjectRelease_n();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 56))(a2, 1LL, 1LL, v4);
}

  BOOL result = sub_18264F360();
  __break(1u);
  return result;
}

  BOOL result = sub_18264F5C4();
  __break(1u);
  return result;
}

  swift_release();
  if (CFURLRequestCreateHTTPRequest())
  {

    os_log_type_t v60 = v66;
  }

  else
  {
LABEL_33:
    __break(1u);
  }

  v79 = objc_msgSend(*(id *)(v54 + 32), sel_temporaryDirectoryURL);
  if (v79)
  {
    v80 = v79;
    v81 = v114;
    sub_18264E538();

    v82 = 0LL;
    v83 = v122;
    v84 = v115;
  }

  else
  {
    v82 = 1LL;
    v83 = v122;
    v84 = v115;
    v81 = v114;
  }

  v120(v81, v82, 1LL, v13);
  sub_181BE625C(v81, v84, &qword_18C58B040);
  if (v119((char *)v84, 1LL, v13) == 1)
  {
    sub_181BDA0F0(v84, &qword_18C58B040);
    sub_181BF7EF8();
    swift_allocError();
    *v85 = 0xD00000000000002BLL;
    v85[1] = 0x80000001827302B0LL;
    v85[2] = 0x9000000000000000LL;
LABEL_35:
    swift_willThrow();
    return swift_release();
  }

  (*(void (**)(char *, uint64_t, uint64_t))(v83 + 32))(v53, v84, v13);
  v86 = objc_msgSend(*(id *)(v54 + 32), sel_targetID);
  if (v86)
  {
    v87 = v86;
    v88 = sub_18264EA48();
    v90 = v89;

    v129 = v88;
    v130 = v90;
    sub_18264EB74();
    v91 = v107;
    v92 = *(void (**)(char *, void, uint64_t))(v107 + 104);
    v93 = v111;
    v94 = v113;
    v92(v111, *MEMORY[0x189606990], v113);
    sub_181BE46C4();
    v95 = v108;
    sub_18264E55C();
    v96 = *(void (**)(char *, uint64_t))(v91 + 8);
    v96(v93, v94);
    swift_bridgeObjectRelease();
    v129 = v109;
    v130 = v110;
    v92(v93, *MEMORY[0x189606998], v94);
    sub_18264E55C();
    swift_release();
    v96(v93, v94);
    v97 = *(void (**)(char *, uint64_t))(v122 + 8);
    v97(v95, v13);
    return ((uint64_t (*)(char *, uint64_t))v97)(v121, v13);
  }

  else
  {
    sub_181BF7EF8();
    swift_allocError();
    *v98 = 0xD00000000000001FLL;
    v98[1] = 0x80000001827302E0LL;
    v98[2] = 0x9000000000000000LL;
    swift_willThrow();
    swift_release();
    return (*(uint64_t (**)(char *, uint64_t))(v83 + 8))(v53, v13);
  }

    id v10 = (v24 - 1) & v24;
    BOOL v21 = __clz(__rbit64(v24)) + (v13 << 6);
LABEL_31:
    os_log_type_t v30 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v21);
    char v32 = *v30;
    uint64_t v31 = v30[1];
    id v33 = (__int16 *)(*(void *)(v5 + 56) + 4 * v21);
    os_log_type_t v34 = *v33;
    os_log_type_t v35 = v33[1];
    if ((v40 & 1) == 0) {
      swift_bridgeObjectRetain();
    }
    sub_18264F648();
    sub_18264EB44();
    BOOL result = sub_18264F684();
    os_log_type_t v14 = -1LL << *(_BYTE *)(v7 + 32);
    uint64_t v15 = result & ~v14;
    __int16 v16 = v15 >> 6;
    if (((-1LL << v15) & ~*(void *)(v11 + 8 * (v15 >> 6))) != 0)
    {
      uint64_t v17 = __clz(__rbit64((-1LL << v15) & ~*(void *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      os_log_type_t v26 = 0;
      os_log_type_t v27 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (++v16 == v27 && (v26 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }

        os_log_type_t v28 = v16 == v27;
        if (v16 == v27) {
          __int16 v16 = 0LL;
        }
        v26 |= v28;
        __int16 v29 = *(void *)(v11 + 8 * v16);
      }

      while (v29 == -1);
      uint64_t v17 = __clz(__rbit64(~v29)) + (v16 << 6);
    }

    *(void *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v17;
    uint64_t v18 = (void *)(*(void *)(v7 + 48) + 16 * v17);
    *uint64_t v18 = v32;
    v18[1] = v31;
    uint64_t v19 = (_WORD *)(*(void *)(v7 + 56) + 4 * v17);
    void *v19 = v34;
    v19[1] = v35;
    ++*(void *)(v7 + 16);
  }

  swift_release();
  uint64_t v3 = v37;
  id v23 = (void *)(v5 + 64);
  if ((v40 & 1) == 0) {
    goto LABEL_40;
  }
LABEL_36:
  char v36 = 1LL << *(_BYTE *)(v5 + 32);
  if (v36 >= 64) {
    bzero(v23, ((unint64_t)(v36 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    char *v23 = -1LL << v36;
  }
  *(void *)(v5 + 16) = 0LL;
LABEL_40:
  BOOL result = swift_release();
  char *v3 = v7;
  return result;
}

        id v10 = (v23 - 1) & v23;
        BOOL v21 = __clz(__rbit64(v23)) + (v13 << 6);
      }

      __int16 v29 = (uint64_t *)(*(void *)(v5 + 48) + 16 * v21);
      os_log_type_t v30 = *v29;
      uint64_t v31 = v29[1];
      char v32 = *(void *)(v5 + 56) + 24 * v21;
      os_log_type_t v34 = *(void *)v32;
      id v33 = *(void *)(v32 + 8);
      os_log_type_t v35 = *(_BYTE *)(v32 + 16);
      if ((v40 & 1) == 0)
      {
        swift_bridgeObjectRetain();
        sub_181BDA12C(v34, v33, v35);
      }

      sub_18264F648();
      sub_18264EAB4();
      sub_18264EB44();
      swift_bridgeObjectRelease();
      BOOL result = sub_18264F684();
      os_log_type_t v14 = -1LL << *(_BYTE *)(v7 + 32);
      uint64_t v15 = result & ~v14;
      __int16 v16 = v15 >> 6;
      if (((-1LL << v15) & ~*(void *)(v11 + 8 * (v15 >> 6))) != 0)
      {
        uint64_t v17 = __clz(__rbit64((-1LL << v15) & ~*(void *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0LL;
      }

      else
      {
        char v25 = 0;
        os_log_type_t v26 = (unint64_t)(63 - v14) >> 6;
        do
        {
          if (++v16 == v26 && (v25 & 1) != 0)
          {
            __break(1u);
            goto LABEL_39;
          }

          os_log_type_t v27 = v16 == v26;
          if (v16 == v26) {
            __int16 v16 = 0LL;
          }
          v25 |= v27;
          os_log_type_t v28 = *(void *)(v11 + 8 * v16);
        }

        while (v28 == -1);
        uint64_t v17 = __clz(__rbit64(~v28)) + (v16 << 6);
      }

      *(void *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v17;
      uint64_t v18 = (void *)(*(void *)(v7 + 48) + 16 * v17);
      *uint64_t v18 = v30;
      v18[1] = v31;
      uint64_t v19 = *(void *)(v7 + 56) + 24 * v17;
      *(void *)uint64_t v19 = v34;
      *(void *)(v19 + 8) = v33;
      *(_BYTE *)(v19 + 16) = v35;
      ++*(void *)(v7 + 16);
    }
  }

  BOOL result = swift_release();
  char *v3 = v7;
  return result;
}

    id v10 = (v25 - 1) & v25;
    os_log_type_t v22 = __clz(__rbit64(v25)) + (v13 << 6);
LABEL_31:
    uint64_t v31 = 16 * v22;
    char v32 = (uint64_t *)(*(void *)(v5 + 48) + v31);
    os_log_type_t v34 = *v32;
    id v33 = v32[1];
    os_log_type_t v35 = (uint64_t *)(*(void *)(v5 + 56) + v31);
    char v36 = *v35;
    os_log_type_t v37 = v35[1];
    if ((v42 & 1) == 0)
    {
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
    }

    sub_18264F648();
    sub_18264EB44();
    BOOL result = sub_18264F684();
    os_log_type_t v14 = -1LL << *(_BYTE *)(v7 + 32);
    uint64_t v15 = result & ~v14;
    __int16 v16 = v15 >> 6;
    if (((-1LL << v15) & ~*(void *)(v11 + 8 * (v15 >> 6))) != 0)
    {
      uint64_t v17 = __clz(__rbit64((-1LL << v15) & ~*(void *)(v11 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      os_log_type_t v27 = 0;
      os_log_type_t v28 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (++v16 == v28 && (v27 & 1) != 0)
        {
          __break(1u);
          goto LABEL_41;
        }

        __int16 v29 = v16 == v28;
        if (v16 == v28) {
          __int16 v16 = 0LL;
        }
        v27 |= v29;
        os_log_type_t v30 = *(void *)(v11 + 8 * v16);
      }

      while (v30 == -1);
      uint64_t v17 = __clz(__rbit64(~v30)) + (v16 << 6);
    }

    *(void *)(v11 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v17;
    uint64_t v18 = 16 * v17;
    uint64_t v19 = (void *)(*(void *)(v7 + 48) + v18);
    void *v19 = v34;
    v19[1] = v33;
    os_log_type_t v20 = (void *)(*(void *)(v7 + 56) + v18);
    *os_log_type_t v20 = v36;
    v20[1] = v37;
    ++*(void *)(v7 + 16);
  }

  swift_release();
  uint64_t v3 = v39;
  int v24 = (void *)(v5 + 64);
  if ((v42 & 1) == 0) {
    goto LABEL_40;
  }
LABEL_36:
  os_log_type_t v38 = 1LL << *(_BYTE *)(v5 + 32);
  if (v38 >= 64) {
    bzero(v24, ((unint64_t)(v38 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *int v24 = -1LL << v38;
  }
  *(void *)(v5 + 16) = 0LL;
LABEL_40:
  BOOL result = swift_release();
  char *v3 = v7;
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  BOOL result = sub_18264F360();
  __break(1u);
  return result;
}

    free(v17);
    goto LABEL_31;
  }

  -[NWSystemPathMonitor setVpnNotifyToken:](v2, "setVpnNotifyToken:", 0xFFFFFFFFLL);
  -[NWSystemPathMonitor setSymptomsNotifyToken:](v2, "setSymptomsNotifyToken:", 0xFFFFFFFFLL);
  uint64_t v3 = v2;
  objc_sync_enter(v3);
  -[NWSystemPathMonitor registerForVPNNotifications](v3, "registerForVPNNotifications");
  -[NWSystemPathMonitor registerForSymptomsFallbackNotification](v3, "registerForSymptomsFallbackNotification");
  -[NWSystemPathMonitor updateVPNMonitor](v3, "updateVPNMonitor");
  +[NWPathEvaluator sharedDefaultEvaluator](&OBJC_CLASS___NWPathEvaluator, "sharedDefaultEvaluator");
  BOOL v4 = (void *)objc_claimAutoreleasedReturnValue();
  -[NWSystemPathMonitor setPrimaryEvaluator:](v3, "setPrimaryEvaluator:", v4);

  -[NWSystemPathMonitor primaryEvaluator](v3, "primaryEvaluator");
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  [v5 addObserver:v3 forKeyPath:@"path" options:5 context:0];

  objc_initWeak((id *)location, v3);
  if (NWCopyInternalQueue_init_once != -1) {
    dispatch_once(&NWCopyInternalQueue_init_once, &__block_literal_global_62911);
  }
  char v6 = (dispatch_queue_s *)(id)NWCopyInternalQueue_nwQueue;
  BOOL v7 = MEMORY[0x1895F87A8];
  v38[0] = MEMORY[0x1895F87A8];
  v38[1] = 3221225472LL;
  v38[2] = __27__NWSystemPathMonitor_init__block_invoke_4;
  v38[3] = &unk_189BC0AE8;
  objc_copyWeak(&v39, (id *)location);
  -[NWSystemPathMonitor setFallbackWatcher:]( v3,  "setFallbackWatcher:",  tcp_connection_fallback_watcher_create(0, v6, v38));

  if (NWCopyInternalQueue_init_once != -1) {
    dispatch_once(&NWCopyInternalQueue_init_once, &__block_literal_global_62911);
  }
  unsigned int v8 = (id)NWCopyInternalQueue_nwQueue;
  v35[0] = v7;
  v35[1] = 3221225472LL;
  v35[2] = __27__NWSystemPathMonitor_init__block_invoke_2;
  v35[3] = &unk_189BB5490;
  int v9 = v3;
  char v36 = v9;
  objc_copyWeak(&v37, (id *)location);
  network_config_mptcp_watcher_create((uint64_t)v8, (uint64_t)v35);
  id v10 = (void *)objc_claimAutoreleasedReturnValue();
  -[NWSystemPathMonitor setMptcpWatcher:](v9, "setMptcpWatcher:", v10);

  if (NWCopyInternalQueue_init_once != -1) {
    dispatch_once(&NWCopyInternalQueue_init_once, &__block_literal_global_62911);
  }
  BOOL v11 = (id)NWCopyInternalQueue_nwQueue;
  v33[0] = v7;
  v33[1] = 3221225472LL;
  v33[2] = __27__NWSystemPathMonitor_init__block_invoke_7;
  v33[3] = &unk_189BB7F78;
  objc_copyWeak(&v34, (id *)location);
  nw_interface_use_observer_create("com.apple.network.interface_use.airdrop", v11, v33);
  char v12 = (void *)objc_claimAutoreleasedReturnValue();
  -[NWSystemPathMonitor setInterfaceUseObserver:](v9, "setInterfaceUseObserver:", v12);

  -[NWSystemPathMonitor updateFlags](v9, "updateFlags");
  objc_destroyWeak(&v34);
  objc_destroyWeak(&v37);

  objc_destroyWeak(&v39);
  objc_destroyWeak((id *)location);
  objc_sync_exit(v9);

  uint64_t v13 = v9;
LABEL_33:

  return v13;
}

          goto LABEL_31;
        }

        if (!v55)
        {
          __nwlog_obj();
          id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v46 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v59 = "nw_context_cancel";
            _os_log_impl( &dword_181A5C000,  v10,  v46,  "%{public}s called with null globals_context->is_inline, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_30;
        }

        id v33 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        os_log_type_t v35 = os_log_type_enabled(v10, type);
        if (!v33)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v59 = "nw_context_cancel";
            _os_log_impl( &dword_181A5C000,  v10,  v34,  "%{public}s called with null globals_context->is_inline, no backtrace",  buf,  0xCu);
          }

          goto LABEL_30;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_context_cancel";
          os_log_type_t v60 = 2082;
          v61 = (__uint64_t)v33;
          _os_log_impl( &dword_181A5C000,  v10,  v34,  "%{public}s called with null globals_context->is_inline, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v33);
      }

    if (v11) {
      free(v11);
    }
    goto LABEL_13;
  }

  BOOL v7 = *((_BYTE *)v5 + 136);
  if ((v7 & 0x48) == 0x40)
  {
    if (!dispatch_workloop_is_current())
    {
      v18[0] = MEMORY[0x1895F87A8];
      v18[1] = 3221225472LL;
      v18[2] = __nw_context_require_encrypted_name_resolution_block_invoke;
      v18[3] = &unk_189BB6018;
      uint64_t v19 = v5;
      BOOL v21 = a2;
      os_log_type_t v20 = v6;
      nw_queue_context_async(v19, v18);

      goto LABEL_13;
    }

    BOOL v7 = *((_BYTE *)v5 + 136);
  }

  if ((_DWORD)a2) {
    unsigned int v8 = 0x80;
  }
  else {
    unsigned int v8 = 0;
  }
  *((_BYTE *)v5 + 136) = v8 & 0x80 | v7 & 0x7F;
  objc_storeStrong((id *)v5 + 6, a3);
  if ((*((_BYTE *)v5 + 136) & 4) != 0) {
    nw_context_update_default_required_encrypted_name_resolution(a2, v6);
  }
  int v9 = *((void *)v5 + 5);
  if (v9)
  {
    *(_BYTE *)(v9 + 136) = *(_BYTE *)(v9 + 136) & 0x7F | v8;
    objc_storeStrong((id *)(*((void *)v5 + 5) + 48LL), a3);
  }

    if (v9) {
      free(v9);
    }
    unsigned int v5 = 0LL;
    goto LABEL_13;
  }

  uint64_t v3 = v1[136];
  if ((v3 & 0x48) != 0x40) {
    goto LABEL_5;
  }
  if (dispatch_workloop_is_current())
  {
    uint64_t v3 = v2[136];
LABEL_5:
    if (v3 < 0)
    {
      unsigned int v5 = *((id *)v2 + 6);
    }

    else
    {
      BOOL v4 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
      unsigned int v5 = *(id *)(v4 + 48);
    }

    goto LABEL_13;
  }

  os_unfair_lock_lock((os_unfair_lock_t)v2 + 20);
  unsigned int v5 = *((id *)v2 + 6);
  if (!v5)
  {
    if ((char)v2[136] < 0)
    {
      unsigned int v5 = 0LL;
    }

    else
    {
      char v6 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
      unsigned int v5 = *(id *)(v6 + 48);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)v2 + 20);
LABEL_13:

  return v5;
}

  if (v10) {
    free(v10);
  }
  BOOL v4 = 0LL;
LABEL_13:

  return v4;
}

  if (v8) {
    free(v8);
  }
LABEL_13:
}

    free(v23);
    goto LABEL_31;
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    BOOL v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      char v12 = a1[4];
      uint64_t v13 = a1[6];
      *(_DWORD *)buf = 136446722;
      char v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
      __int16 v40 = 2112;
      uint64_t v41 = v12;
      uint64_t v42 = 2048;
      __int16 v43 = v13;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s Registrar %@ already has instance for protocol %p",  buf,  0x20u);
    }
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
    {
      v69 = a1[4];
      if (v69) {
        v70 = (const char *)(v69 + 609);
      }
      else {
        v70 = "";
      }
      v71 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
      *(_DWORD *)buf = 136446722;
      v93 = "nw_framer_flush_output_block_invoke";
      v94 = 2080;
      v95 = (void *)v70;
      v96 = 2048;
      v97[0] = v71;
      _os_log_impl(&dword_181A5C000, v68, OS_LOG_TYPE_DEBUG, "%{public}s %s Set external frame %zu bytes", buf, 0x20u);
    }
  }

  nw_frame_set_external_data(v4, *(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL), 0LL);
  if ((*(_BYTE *)(a1[4] + 607LL) & 0x20) != 0)
  {
    *(_BYTE *)(v4 + 186) |= 0x80u;
    *(_BYTE *)(a1[4] + 607LL) &= ~0x20u;
  }

  nw_frame_claim(v4, v29, *(_DWORD *)(*(void *)(a1[7] + 8LL) + 24LL), 0);
  nw_frame_collapse(v4);
  nw_frame_unclaim(v4, v30, *(_DWORD *)(*(void *)(a1[7] + 8LL) + 24LL), 0);
  uint64_t v31 = *(void *)(a1[6] + 8LL);
  char v32 = *(void **)(v31 + 40);
  *(void *)(v31 + 40) = 0LL;

  *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = 0LL;
  id v33 = a1[5];
  if (v33) {
    goto LABEL_42;
  }
LABEL_55:

  return 1LL;
}

  if (v10) {
    free(v10);
  }
LABEL_13:
}

  if (v13) {
    free(v13);
  }
LABEL_13:
}

            if (!v10)
            {
LABEL_32:
              uint64_t v17 = 0LL;
LABEL_33:

              return v17;
            }

          return v9;
        }

        uint64_t v15 = *(void *)(a1 + 32);
        if (v15)
        {
          __int16 v16 = *(void *)(v15 + 24);
          if (v16)
          {
            uint64_t v17 = *(uint64_t (**)(void))(v16 + 224);
            if (v17)
            {
              int v9 = v17();
              goto LABEL_30;
            }
          }
        }

  nw_resolver_update_client_alternative(v8, v5, v7);

  return 1LL;
}

      nw_resolver_update_status_locked(v18, 0LL);
      goto LABEL_24;
    }

    if ((v18[346] & 0x20) != 0)
    {
LABEL_62:
      nw_resolver_restart_dns_service_locked((NWConcrete_nw_resolver *)v18);
      goto LABEL_24;
    }

    if (v18[256])
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      char v32 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_INFO)) {
        goto LABEL_61;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
      v82 = 2082;
      *(void *)v83 = v18 + 256;
      *(_WORD *)&v83[8] = 2048;
      *(void *)&v83[10] = v18;
      id v33 = "%{public}s [C%{public}s] restarting resolver %p, defunct connection";
      os_log_type_t v34 = v32;
      os_log_type_t v35 = 32;
    }

    else
    {
      __nwlog_obj();
      char v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
LABEL_61:

        goto LABEL_62;
      }

      uint64_t v42 = *((_DWORD *)v18 + 85);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
      v82 = 1024;
      *(_DWORD *)v83 = v42;
      *(_WORD *)&v83[4] = 2048;
      *(void *)&v83[6] = v18;
      id v33 = "%{public}s [R%u] restarting resolver %p, defunct connection";
      os_log_type_t v34 = v32;
      os_log_type_t v35 = 28;
    }

    _os_log_impl(&dword_181A5C000, v34, OS_LOG_TYPE_INFO, v33, buf, v35);
    goto LABEL_61;
  }

  if (a6 != 33)
  {
    if ((v18[346] & 0x20) == 0)
    {
      if (v18[256])
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        char v36 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
          v82 = 2082;
          *(void *)v83 = v18 + 256;
          *(_WORD *)&v83[8] = 1024;
          *(_DWORD *)&v83[10] = a6;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s] Ignore record of type: %u",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        char v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          __int16 v43 = *((_DWORD *)v18 + 85);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
          v82 = 1024;
          *(_DWORD *)v83 = v43;
          *(_WORD *)&v83[4] = 1024;
          *(_DWORD *)&v83[6] = a6;
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_DEBUG,  "%{public}s [R%u] Ignore record of type: %u",  buf,  0x18u);
        }
      }
    }

    goto LABEL_24;
  }

  if (a8 <= 5)
  {
    if ((v18[346] & 0x20) != 0)
    {
LABEL_76:
      *((_DWORD *)v18 + 21) = -65549;
      goto LABEL_24;
    }

    if (v18[256])
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v28 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
      v82 = 2082;
      *(void *)v83 = v18 + 256;
      *(_WORD *)&v83[8] = 1024;
      *(_DWORD *)&v83[10] = a8;
      __int16 v29 = "%{public}s [C%{public}s] Invalid SRV length: %u";
      os_log_type_t v30 = v28;
      uint64_t v31 = 28;
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
LABEL_75:

        goto LABEL_76;
      }

      v48 = *((_DWORD *)v18 + 85);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
      v82 = 1024;
      *(_DWORD *)v83 = v48;
      *(_WORD *)&v83[4] = 1024;
      *(_DWORD *)&v83[6] = a8;
      __int16 v29 = "%{public}s [R%u] Invalid SRV length: %u";
      os_log_type_t v30 = v28;
      uint64_t v31 = 24;
    }

    _os_log_impl(&dword_181A5C000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
    goto LABEL_75;
  }

  v65 = *a9;
  v66 = a9[1];
  os_log_type_t v37 = a9[2];
  os_log_type_t v38 = a8 - 6;
  if ((_WORD)a8 == 6)
  {
    __nwlog_obj();
    v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_calloc";
    id v62 = (void *)_os_log_send_and_compose_impl();

    free(v62);
  }

  char v39 = v38;
  __int16 v40 = (char *)calloc(1uLL, v38);
  uint64_t v41 = v40;
  if (v40)
  {
    *(void *)os_log_type_t type = a9 + 3;
    goto LABEL_55;
  }

  __nwlog_obj();
  char v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  v82 = 2048;
  *(void *)v83 = 1LL;
  *(_WORD *)&v83[8] = 2048;
  *(void *)&v83[10] = v39;
  v64 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v64))
  {
    free(v64);
    *(void *)os_log_type_t type = a9 + 3;
    __int16 v40 = 0LL;
LABEL_55:
    if ((nw_resolver_parse_rdata(v40, v39, (const unsigned __int8 **)type) & 0x80000000) == 0)
    {
      if ((a2 & 2) != 0)
      {
        host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(v41, __rev16(v37));
        os_log_type_t v50 = (void *)host_with_numeric_port;
        if (host_with_numeric_port)
        {
          nw_endpoint_set_parent_endpoint((void *)host_with_numeric_port, *((void **)v18 + 3), 0);
          nw_endpoint_set_weight(v50, __rev16(v66));
          nw_endpoint_set_priority(v50, __rev16(v65));
          *(void *)buf = 0LL;
          ValidationData = (const void *)DNSServiceGetValidationData();
          if (ValidationData && *(void *)buf) {
            nw_endpoint_set_signature(v50, ValidationData, *(size_t *)buf);
          }
          if (nw_resolver_set_interface_on_endpoint(v18, a3, v50))
          {
            v74[0] = MEMORY[0x1895F87A8];
            v74[1] = 3221225472LL;
            v74[2] = ___ZL32nw_resolver_srv_resolve_callbackP16_DNSServiceRef_tjjiPKctttPKvjPv_block_invoke;
            v74[3] = &__block_descriptor_50_e63_B24__0__NSObject_OS_nw_endpoint__8__NSObject_OS_nw_endpoint__16l;
            v74[4] = v41;
            v76 = v65;
            v77 = v66;
            v78 = v37;
            v75 = a3;
            nw_resolver_insert_endpoint_locked(v18, v50, v74);
          }
        }
      }

      else
      {
        v69[0] = MEMORY[0x1895F87A8];
        v69[1] = 3221225472LL;
        v69[2] = ___ZL32nw_resolver_srv_resolve_callbackP16_DNSServiceRef_tjjiPKctttPKvjPv_block_invoke_2;
        v69[3] = &__block_descriptor_50_e63_B24__0__NSObject_OS_nw_endpoint__8__NSObject_OS_nw_endpoint__16l;
        v69[4] = v41;
        v71 = v65;
        v72 = v66;
        v73 = v37;
        v70 = a3;
        nw_resolver_remove_endpoint_locked(v18, v69);
      }

      if (v41) {
        free(v41);
      }
      if ((a2 & 1) != 0) {
        goto LABEL_24;
      }
      goto LABEL_30;
    }

    if ((v18[346] & 0x20) != 0)
    {
LABEL_92:
      *((_DWORD *)v18 + 21) = -65549;
      if (v41) {
        free(v41);
      }
      goto LABEL_24;
    }

    if (v18[256])
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v44 = (os_log_s *)(id)gconnectionLogObj;
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
        goto LABEL_91;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
      v82 = 2082;
      *(void *)v83 = v18 + 256;
      uint64_t v45 = "%{public}s [C%{public}s] Invalid SRV host";
      v46 = v44;
      v47 = 22;
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
LABEL_91:

        goto LABEL_92;
      }

      os_log_type_t v52 = *((_DWORD *)v18 + 85);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_resolver_srv_resolve_callback";
      v82 = 1024;
      *(_DWORD *)v83 = v52;
      uint64_t v45 = "%{public}s [R%u] Invalid SRV host";
      v46 = v44;
      v47 = 18;
    }

    _os_log_impl(&dword_181A5C000, v46, OS_LOG_TYPE_ERROR, v45, buf, v47);
    goto LABEL_91;
  }

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v8) {
    free(v8);
  }
LABEL_13:
}

  if (v8) {
    free(v8);
  }
LABEL_13:
}
}

    free(backtrace_string);
    if (!v11) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }

  if (!v6)
  {
    __nwlog_obj();
    __int16 v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v32 = "nw_protocol_implementation_accept";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        char v32 = "nw_protocol_implementation_accept";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v29)
    {
      id v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v24 = type;
      char v25 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          char v32 = "nw_protocol_implementation_accept";
          id v33 = 2082;
          os_log_type_t v34 = v23;
          _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v23);
LABEL_55:
        if (!v11)
        {
LABEL_57:
          unsigned int v8 = 0LL;
          goto LABEL_5;
        }

    free(backtrace_string);
    goto LABEL_40;
  }

  uint64_t v15 = (os_log_s *)__nwlog_obj();
  __int16 v16 = type[0];
  if (os_log_type_enabled(v15, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_trainer_bottom_get_input_frames";
    uint64_t v17 = "%{public}s called with null protocol";
LABEL_39:
    _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
  }
}

    char v6 = 0LL;
    goto LABEL_31;
  }

  if (!xpc_array_get_count(v4))
  {
    uint64_t v3 = *(void **)(v2[13] + 176LL);
    goto LABEL_6;
  }

    uint64_t v15 = 0LL;
    goto LABEL_31;
  }

  id v10 = 0LL;
  while (1)
  {
    BOOL v11 = xpc_array_get_string(*((xpc_object_t *)v3->path_parameters->required_interface + 10), v10);
    char v12 = xpc_array_get_string(*((xpc_object_t *)v3->path_parameters->required_interface + 11), v10);
    uint64_t v13 = v12;
    os_log_type_t v14 = !v11 || v12 == 0LL;
    if (!v14 && !strcmp("com.apple.networkrelay", v11) && !strcmp("CompanionProxy", v13)) {
      break;
    }
    if (v9 == ++v10) {
      goto LABEL_16;
    }
  }

  uint64_t v15 = 1LL;
LABEL_31:

  return v15;
}

    char v6 = 0LL;
    goto LABEL_31;
  }

  if (!xpc_array_get_count(v4))
  {
    uint64_t v3 = *(void **)(v2[13] + 176LL);
    goto LABEL_6;
  }

  if (v12) {
    free(v12);
  }
  (*((void (**)(id, void))v6 + 2))(v6, 0LL);
LABEL_13:
}

  if (v13) {
    free(v13);
  }
LABEL_13:
}

          return;
        }

        return;
      }

      if (v7 && !nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        int v24 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          char v25 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
          *(_DWORD *)buf = 136446466;
          v97 = "nw_connection_inject_up_block_invoke";
          v98 = 1024;
          *(_DWORD *)v99 = v25;
          _os_log_impl(&dword_181A5C000, v24, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] injecting read close", buf, 0x12u);
        }
      }

      os_log_type_t v26 = *(id *)(*(void *)(a1 + 32) + 144LL);
      os_log_type_t v27 = v26;
      if (v26)
      {
        os_log_type_t v28 = (NWConcrete_nw_endpoint_handler *)v26;
        mode = v28->mode;

        if ((_DWORD)mode == 2)
        {
          os_log_type_t v30 = nw_endpoint_handler_copy_flow(v28);
          uint64_t v31 = v30;
          if (v30)
          {
            if ((*((_BYTE *)v30 + 33) & 4) != 0 && (*((_WORD *)v30 + 354) & 0x10) == 0)
            {
              char v32 = (char *)v30 + 376;
              if (v2)
              {
                id v33 = (char *)*((void *)v31 + 51);
                if (!v33)
                {
LABEL_64:
                  uint64_t v45 = v28;
                  v46 = (*((_BYTE *)v45 + 268) & 0x20) == 0;

                  if (v46)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v47 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v45);
                      v49 = nw_endpoint_handler_dry_run_string(v45);
                      os_log_type_t v50 = id_string;
                      v93 = nw_endpoint_handler_copy_endpoint(v45);
                      logging_description = nw_endpoint_get_logging_description(v93);
                      os_log_type_t v52 = nw_endpoint_handler_state_string(v45);
                      v53 = nw_endpoint_handler_mode_string(v45);
                      os_log_type_t v54 = nw_endpoint_handler_copy_current_path(v45);
                      *(_DWORD *)buf = 136447746;
                      v97 = "nw_endpoint_handler_inject_read_closed";
                      v98 = 2082;
                      *(void *)v99 = v50;
                      *(_WORD *)&v99[8] = 2082;
                      *(void *)&v99[10] = v49;
                      v100 = 2082;
                      v101 = (void *)logging_description;
                      v102 = 2082;
                      v103 = v52;
                      v104 = 2082;
                      v105 = v53;
                      v106 = 2114;
                      v107 = v54;
                      _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Inject read-clo sed failed, could not locate protocol",  buf,  0x48u);
                    }
                  }

                  goto LABEL_148;
                }

                while (1)
                {
                  os_log_type_t v34 = v33;
                  os_log_type_t v35 = (uint64_t *)*((void *)v33 + 2);
                  char v36 = *v35;
                  os_log_type_t v37 = v35[1];
                  os_log_type_t v38 = v35[2];
                  char v39 = v35[3];
                  __int16 v40 = v35[4];
                  uint64_t v41 = *v3 == v36 && v3[1] == v37;
                  uint64_t v42 = v41 && v3[2] == v38;
                  __int16 v43 = v42 && v3[3] == v39;
                  if (v43 && v3[4] == v40) {
                    break;
                  }
                  id v33 = (char *)*((void *)v34 + 4);
                  char v32 = v34;
                  if (!v33) {
                    goto LABEL_64;
                  }
                }
              }

              (*(void (**)(void))(*((void *)v32 + 3) + 184LL))();
            }

  BOOL v21 = (id *)calloc(1uLL, 0x20uLL);
  if (!v21)
  {
    __nwlog_obj();
    uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v38 = "strict_calloc";
    char v39 = 2048;
    __int16 v40 = 1LL;
    uint64_t v41 = 2048;
    uint64_t v42 = 32LL;
    char v32 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v32))
    {
      __break(1u);
      return;
    }

    free(v32);
  }

  objc_storeStrong(v21 + 2, *(id *)(a1 + 40));
  os_log_type_t v22 = _Block_copy(*(const void **)(a1 + 48));
  id v23 = v21[3];
  v21[3] = v22;

  NWConcrete_nw_protocol_transform *v21 = 0LL;
  int v24 = *(id ***)(*(void *)(a1 + 32) + 272LL);
  v21[1] = v24;
  *int v24 = v21;
  *(void *)(*(void *)(a1 + 32) + 272LL) = v21;
LABEL_32:
  char v25 = *(void *)(*(void *)(a1 + 32) + 264LL);
  if (gLogDatapath)
  {
    __nwlog_obj();
    os_log_type_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      __int16 v29 = _Block_copy(*(const void **)(a1 + 48));
      identifier = nw_protocol_definition_get_identifier(*(void **)(a1 + 40));
      *(_DWORD *)buf = 136447234;
      os_log_type_t v38 = "nw_connection_set_metadata_changed_handler_block_invoke";
      char v39 = 2048;
      __int16 v40 = (uint64_t)v29;
      uint64_t v41 = 2082;
      uint64_t v42 = (uint64_t)identifier;
      __int16 v43 = 1024;
      os_log_type_t v44 = v4 == 0;
      uint64_t v45 = 1024;
      v46 = v25 == 0;
      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s Set metadata changed handler: %p for protocol: %{public}s, was empty: %u now empty: %u",  buf,  0x2Cu);
    }
  }

  if (v4 || !v25)
  {
    if (v4)
    {
      if (!v25) {
        nw_endpoint_handler_set_metadata_changed_handler(*(void **)(*(void *)(a1 + 32) + 144LL), 0LL);
      }
    }
  }

  else
  {
    os_log_type_t v26 = *(void **)(a1 + 32);
    os_log_type_t v27 = (void *)v26[18];
    v33[0] = MEMORY[0x1895F87A8];
    v33[1] = 3221225472LL;
    v33[2] = __nw_connection_set_metadata_changed_handler_block_invoke_45;
    v33[3] = &unk_189BB99D0;
    os_log_type_t v34 = v26;
    nw_endpoint_handler_set_metadata_changed_handler(v27, v33);
  }
    }
  }

    int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_proxy_fallback_cache_seconds,  1800LL);
    char v25 = (id)nw_protocol_copy_proxy_definition(void)::proxy_definition;
    os_log_type_t v26 = time(0LL);
    nw_association_set_cached_content_for_protocol( v6,  v25,  (uint64_t)cached_content_for_protocol,  v26 + int64_with_default);

    goto LABEL_33;
  }

  __nwlog_obj();
  os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  char v32 = "strict_calloc";
  id v33 = 2048;
  os_log_type_t v34 = (char *)1;
  os_log_type_t v35 = 2048;
  char v36 = 8LL;
  BOOL v21 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v21))
  {
    free(v21);
    cached_content_for_protocol = 0LL;
    if (a2) {
      goto LABEL_8;
    }
    goto LABEL_26;
  }

  __break(1u);
}

    if (v11) {
      free(v11);
    }
    unsigned int v8 = 0;
    goto LABEL_12;
  }

  unsigned int v8 = 0;
LABEL_13:

  return v8;
}

    if (v11) {
      free(v11);
    }
    unsigned int v8 = 0;
    goto LABEL_12;
  }

  unsigned int v8 = 0;
LABEL_13:

  return v8;
}

    if (v11) {
      free(v11);
    }
    unsigned int v8 = 0;
    goto LABEL_12;
  }

  unsigned int v8 = 0;
LABEL_13:

  return v8;
}

  if (v26) {
    free(v26);
  }
LABEL_13:
}
  }
  }

    uint64_t v3 = 0LL;
    goto LABEL_31;
  }

  uint64_t v3 = v1->mode_handler;
LABEL_31:

  return v3;
}

    uint64_t v3 = 0LL;
    goto LABEL_31;
  }

  uint64_t v3 = v1->mode_handler;
LABEL_31:

  return v3;
}

      free(backtrace_string);
      goto LABEL_40;
    }

    id v10 = (os_log_s *)__nwlog_obj();
    BOOL v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_40;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "nw_protocol_ethernet_remove_input_handler";
    char v12 = "%{public}s called with null protocol";
LABEL_39:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
LABEL_40:
    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "nw_protocol_ethernet_remove_input_handler";
    int v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v20 = "nw_protocol_ethernet_remove_input_handler";
      char v12 = "%{public}s called with null ethernet";
      goto LABEL_39;
    }

    if (!v17)
    {
      id v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v20 = "nw_protocol_ethernet_remove_input_handler";
      char v12 = "%{public}s called with null ethernet, backtrace limit exceeded";
      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v10 = (os_log_s *)__nwlog_obj();
    BOOL v11 = type;
    __int16 v16 = os_log_type_enabled(v10, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "nw_protocol_ethernet_remove_input_handler";
        BOOL v21 = 2082;
        os_log_type_t v22 = backtrace_string;
        uint64_t v15 = "%{public}s called with null ethernet, dumping backtrace:%{public}s";
        goto LABEL_29;
      }

      goto LABEL_30;
    }

    if (!v16) {
      goto LABEL_40;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "nw_protocol_ethernet_remove_input_handler";
    char v12 = "%{public}s called with null ethernet, no backtrace";
    goto LABEL_39;
  }

  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  output_handler = a1->output_handler;
  if (output_handler) {
    ((void (*)(void))output_handler->callbacks->remove_input_handler)();
  }
  nw_protocol_set_input_handler((uint64_t)a1, 0LL);
  if (a3)
  {
    a1->handle = 0LL;
    free(handle);
  }

  return 1LL;
}

    if (v6) {
      goto LABEL_31;
    }
    return;
  }

  handle = (char *)a1->handle;
  if (handle)
  {
    if ((handle[548] & 2) == 0)
    {
      if (gLogDatapath)
      {
        char v32 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          id v33 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          __int16 v40 = " ";
          *(_WORD *)uint64_t v41 = 1024;
          *(_DWORD *)&v41[2] = v33;
          _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> listen protocol is disconnected",  buf,  0x26u);
        }
      }
    }

    if (*((nw_protocol **)handle + 4) != a2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      char v6 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v37 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v7 = (os_log_s *)gLogObj;
        unsigned int v8 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_30;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        int v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler";
        goto LABEL_29;
      }

      if (!v37)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v7 = (os_log_s *)gLogObj;
        unsigned int v8 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_30;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        int v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, backtr"
             "ace limit exceeded";
        goto LABEL_29;
      }

      char v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)gLogObj;
      unsigned int v8 = type;
      uint64_t v13 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v12)
      {
        if (!v13) {
          goto LABEL_30;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        int v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, no backtrace";
        goto LABEL_29;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v12;
        os_log_type_t v14 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, dumpi"
              "ng backtrace:%{public}s";
LABEL_18:
        _os_log_impl(&dword_181A5C000, v7, v8, v14, buf, 0x16u);
        goto LABEL_19;
      }

      goto LABEL_19;
    }

    if (*((_DWORD *)handle + 111) == 5)
    {
      if ((handle[548] & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          BOOL v11 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          __int16 v40 = " ";
          *(_WORD *)uint64_t v41 = 1024;
          *(_DWORD *)&v41[2] = v11;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Session already terminated, ignoring",  buf,  0x26u);
        }
      }

      return;
    }

    if (a3)
    {
      if ((handle[548] & 2) != 0) {
        goto LABEL_36;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_36;
      }
      __int16 v16 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      __int16 v40 = " ";
      *(_WORD *)uint64_t v41 = 1024;
      *(_DWORD *)&v41[2] = v16;
      uint64_t v42 = 1024;
      __int16 v43 = a3;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d";
      uint64_t v18 = (os_log_s *)v15;
      uint64_t v19 = 44;
    }

    else
    {
      if ((handle[548] & 2) != 0) {
        goto LABEL_36;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v20 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_36;
      }
      BOOL v21 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      __int16 v40 = " ";
      *(_WORD *)uint64_t v41 = 1024;
      *(_DWORD *)&v41[2] = v21;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> Closing webtransport session without error";
      uint64_t v18 = (os_log_s *)v20;
      uint64_t v19 = 38;
    }

    _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_INFO, v17, buf, v19);
LABEL_36:
    *((_DWORD *)handle + 111) = 5;
    os_log_type_t v22 = (char *)*((void *)handle + 23);
    if (v22)
    {
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
      __int16 v40 = (const char *)&__block_descriptor_tmp_22_33505;
      *(_DWORD *)uint64_t v41 = a3;
      nw_hash_table_apply(v22, (uint64_t)buf);
    }

    id v23 = *((void *)handle + 53);
    if (v23)
    {
      int v24 = *(void **)(v23 + 48);
      if (a3) {
        nw_protocol_error(*(void **)(v23 + 48), *((void *)handle + 53));
      }
      nw_protocol_disconnected(v24, v23);
    }

    char v25 = *((void *)handle + 41);
    if (v25)
    {
      if (a3)
      {
        do
        {
          os_log_type_t v26 = *(void *)(v25 + 112);
          os_log_type_t v27 = *(void **)(v25 + 48);
          nw_protocol_error(v27, v25);
          os_log_type_t v28 = v25;
          char v25 = v26;
          nw_protocol_disconnected(v27, v28);
        }

        while (v26);
      }

      else
      {
        do
        {
          __int16 v29 = *(void *)(v25 + 112);
          nw_protocol_disconnected(*(void **)(v25 + 48), v25);
          char v25 = v29;
        }

        while (v29);
      }
    }

    os_log_type_t v30 = *((void *)handle + 52);
    if (v30)
    {
      uint64_t v31 = *(void **)(v30 + 48);
      if (a3) {
        nw_protocol_error(*(void **)(v30 + 48), *((void *)handle + 52));
      }
      nw_protocol_disconnected(v31, v30);
    }

    if (*((void *)handle + 4))
    {
      nw_protocol_remove_instance((uint64_t)handle);
      nw_protocol_disconnect(*((void **)handle + 4), (uint64_t)handle);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
  char v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v37 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v7 = (os_log_s *)__nwlog_obj();
    unsigned int v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      int v9 = "%{public}s called with null webtransport_session";
      goto LABEL_29;
    }

    goto LABEL_30;
  }

  if (!v37)
  {
    BOOL v7 = (os_log_s *)__nwlog_obj();
    unsigned int v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      int v9 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_29;
    }

    goto LABEL_30;
  }

  char v12 = (char *)__nw_create_backtrace_string();
  BOOL v7 = (os_log_s *)__nwlog_obj();
  unsigned int v8 = type;
  char v36 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (v36)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      int v9 = "%{public}s called with null webtransport_session, no backtrace";
      goto LABEL_29;
    }

    goto LABEL_30;
  }

  if (v36)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12;
    os_log_type_t v14 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
    goto LABEL_18;
  }

    free(backtrace_string);
    goto LABEL_42;
  }

  unsigned int v8 = (os_log_s *)__nwlog_obj();
  int v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_protocol_webtransport_stream_copy_info";
    id v10 = "%{public}s called with null protocol";
LABEL_41:
    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
  }

  __break(1u);
  return result;
}

    free(backtrace_string);
    goto LABEL_41;
  }

  if (!a2)
  {
    __nwlog_obj();
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socks5_server_fillout_statistics";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socks5_server_fillout_statistics";
        uint64_t v18 = "%{public}s called with null out_stats";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (!v24)
    {
      __nwlog_obj();
      __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socks5_server_fillout_statistics";
        uint64_t v18 = "%{public}s called with null out_stats, backtrace limit exceeded";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v17 = type;
    id v23 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socks5_server_fillout_statistics";
        uint64_t v18 = "%{public}s called with null out_stats, no backtrace";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_socks5_server_fillout_statistics";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      os_log_type_t v22 = "%{public}s called with null out_stats, dumping backtrace:%{public}s";
      goto LABEL_29;
    }

    goto LABEL_30;
  }

  if (a3 != 8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_socks5_server_fillout_statistics";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = a3;
      *(_WORD *)&buf[22] = 2048;
      os_log_type_t v27 = 8LL;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s Unsupported stats size: %zu, expected %zu",  buf,  0x20u);
    }

    if (a3 >= 8) {
      char v12 = 8LL;
    }
    else {
      char v12 = a3;
    }
    bzero(a2, v12);
LABEL_11:
    id v10 = 0LL;
    goto LABEL_12;
  }

  *(void *)buf = MEMORY[0x1895F87A8];
  *(void *)&buf[8] = 3221225472LL;
  *(void *)&buf[16] = __nw_socks5_server_fillout_statistics_block_invoke;
  os_log_type_t v27 = (uint64_t)&unk_189BC8600;
  __int16 v29 = a2;
  int v9 = v7;
  os_log_type_t v28 = v9;
  os_log_type_t v30 = a4;
  os_unfair_lock_lock(v8 + 6);
  __nw_socks5_server_fillout_statistics_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v8 + 6);

  id v10 = 1LL;
LABEL_12:

  return v10;
}

    free(v31);
    goto LABEL_31;
  }

  __nwlog_obj();
  char v39 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v52 = "nw_proxy_config_copy";
  __int16 v40 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v49 = 0;
  if (__nwlog_fault(v40, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "nw_proxy_config_copy";
        _os_log_impl(&dword_181A5C000, v41, v42, "%{public}s called with null existing_config", buf, 0xCu);
      }
    }

    else if (v49)
    {
      __int16 v43 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = type;
      uint64_t v45 = os_log_type_enabled(v41, type);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v52 = "nw_proxy_config_copy";
          v53 = 2082;
          os_log_type_t v54 = v43;
          _os_log_impl( &dword_181A5C000,  v41,  v44,  "%{public}s called with null existing_config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v43);
        goto LABEL_49;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "nw_proxy_config_copy";
        _os_log_impl(&dword_181A5C000, v41, v44, "%{public}s called with null existing_config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v52 = "nw_proxy_config_copy";
        _os_log_impl( &dword_181A5C000,  v41,  v46,  "%{public}s called with null existing_config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(v11);
    goto LABEL_31;
  }

  xpc_dictionary_get_value(v4, string_ptr);
  unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue();
  int v9 = v8;
  if (v8)
  {
    if (object_getClass(v8) == (Class)MEMORY[0x1895F9280])
    {
      value = xpc_int64_get_value(v9);
    }

    else
    {
      if (object_getClass(v9) != (Class)MEMORY[0x1895F92F0])
      {
        if (object_getClass(v9) == (Class)MEMORY[0x1895F9228]) {
          a3 = xpc_BOOL_get_value(v9);
        }
        goto LABEL_22;
      }

      value = xpc_uint64_get_value(v9);
    }

    a3 = value;
  }

        os_release(v10);
      }

        os_release(v10);
      }

        os_release(v10);
      }

        os_release(v10);
      }

    free(backtrace_string);
    goto LABEL_40;
  }

  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "nw_protocol_replicate_copy_info";
    int v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_replicate_copy_info";
        char v12 = "%{public}s called with null replicate";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (!v17)
    {
      id v10 = (os_log_s *)__nwlog_obj();
      BOOL v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_replicate_copy_info";
        char v12 = "%{public}s called with null replicate, backtrace limit exceeded";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v10 = (os_log_s *)__nwlog_obj();
    BOOL v11 = type;
    __int16 v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_protocol_replicate_copy_info";
        char v12 = "%{public}s called with null replicate, no backtrace";
        goto LABEL_39;
      }

      goto LABEL_40;
    }

    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v20 = "nw_protocol_replicate_copy_info";
      BOOL v21 = 2082;
      os_log_type_t v22 = backtrace_string;
      uint64_t v15 = "%{public}s called with null replicate, dumping backtrace:%{public}s";
      goto LABEL_29;
    }

    goto LABEL_30;
  }

  BOOL v4 = *(void *)(a1 + 32);
  if (v4 && (unsigned int v5 = *(uint64_t (**)(void))(*(void *)(v4 + 24) + 224LL)) != 0LL)
  {
    char v6 = v5();
    if (a2 != 255) {
      return v6;
    }
  }

  else
  {
    char v6 = 0LL;
    if (a2 != 255) {
      return v6;
    }
  }

  BOOL v7 = *(void **)(v2 + 64);
  if (v7)
  {
    if (!v6)
    {
      char v6 = nw_array_create();
      BOOL v7 = *(void **)(v2 + 64);
    }

    nw_array_append(v6, v7);
  }

  return v6;
}

        uint64_t v13 = 1;
        __int16 v16 = 3;
        uint64_t v19 = *(void **)(v8 + 208);
        if (v19)
        {
LABEL_20:
          is_equal |= nw_endpoint_is_equal(v19, *(void **)(a1 + 32), 0LL);
          os_log_type_t v20 = *(void **)(v8 + 216);
          if (v20) {
            goto LABEL_21;
          }
          goto LABEL_32;
        }

          free(backtrace_string);
          goto LABEL_51;
        }

        if (!v29)
        {
LABEL_42:

          if (!v18) {
            goto LABEL_53;
          }
          goto LABEL_52;
        }

        os_log_type_t v38 = objc_msgSend(v3, "pid", length, v45);
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        v48 = 1024;
        v49 = v38;
        os_log_type_t v22 = "%{public}s Unable to extract agent UUID bytes from agent request from pid %d, no backtrace";
        char v36 = v19;
        os_log_type_t v37 = v28;
LABEL_41:
        _os_log_impl(&dword_181A5C000, v36, v37, v22, length, 0x12u);
        goto LABEL_42;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      os_log_type_t v20 = uu[0];
      if (!os_log_type_enabled(v19, uu[0])) {
        goto LABEL_42;
      }
      os_log_type_t v35 = objc_msgSend(v3, "pid", length, v45);
      *(_DWORD *)length = 136446466;
      *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
      v48 = 1024;
      v49 = v35;
      os_log_type_t v22 = "%{public}s Unable to extract agent UUID bytes from agent request from pid %d, backtrace limit exceeded";
    }

    char v36 = v19;
    os_log_type_t v37 = v20;
    goto LABEL_41;
  }

  [v3 request];
  char v6 = (void *)objc_claimAutoreleasedReturnValue();
  string = xpc_dictionary_get_string(v6, (const char *)networkd_privileged_key_interface_name);

  if (!string)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v23 = (id)gLogObj;
    *(_DWORD *)length = 136446466;
    *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
    v48 = 1024;
    v49 = [v3 pid];
    LODWORD(v45) = 18;
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    uu[0] = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (uu[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      int v24 = uu[0];
      if (os_log_type_enabled(v19, uu[0]))
      {
        char v25 = objc_msgSend(v3, "pid", length, v45);
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        v48 = 1024;
        v49 = v25;
        os_log_type_t v26 = "%{public}s Unable to extract interface name from agent request from pid %d";
LABEL_48:
        __int16 v40 = v19;
        uint64_t v41 = v24;
LABEL_49:
        _os_log_impl(&dword_181A5C000, v40, v41, v26, length, 0x12u);
        goto LABEL_50;
      }

      goto LABEL_50;
    }

    if (!v46)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = (os_log_s *)(id)gLogObj;
      int v24 = uu[0];
      if (os_log_type_enabled(v19, uu[0]))
      {
        char v39 = objc_msgSend(v3, "pid", length, v45);
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        v48 = 1024;
        v49 = v39;
        os_log_type_t v26 = "%{public}s Unable to extract interface name from agent request from pid %d, backtrace limit exceeded";
        goto LABEL_48;
      }

LABEL_31:
    if (v16) {
      free(v16);
    }
    goto LABEL_40;
  }

  v30.receiver = self;
  v30.super_class = (Class)&OBJC_CLASS___NWUDPSession;
  unsigned int v5 = -[NWUDPSession init](&v30, sel_init);
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v34 = "-[NWUDPSession initWithConnection:]";
    BOOL v21 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v31 = 0;
    if (!__nwlog_fault((const char *)v21, &type, &v31))
    {
LABEL_37:
      if (v21) {
        free(v21);
      }
      self = 0LL;
      goto LABEL_40;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "-[NWUDPSession initWithConnection:]";
        int v24 = "%{public}s [super init] failed";
LABEL_35:
        _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
      }
    }

    else
    {
      if (v31)
      {
        os_log_type_t v27 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v23 = type;
        os_log_type_t v28 = os_log_type_enabled(v22, type);
        if (v27)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v34 = "-[NWUDPSession initWithConnection:]";
            os_log_type_t v35 = 2082;
            char v36 = v27;
            _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v27);
          goto LABEL_37;
        }

        if (!v28) {
          goto LABEL_36;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "-[NWUDPSession initWithConnection:]";
        int v24 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_35;
      }

      __nwlog_obj();
      os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v34 = "-[NWUDPSession initWithConnection:]";
        int v24 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_35;
      }
    }

    free(backtrace_string);
    if (!v6) {
      return 0LL;
    }
    goto LABEL_57;
  }

  BOOL v4 = sec_identity_create(v3);
  CFRelease(v3);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
    char v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)(id)gLogObj;
      unsigned int v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s sec_identity_create failed", buf, 0xCu);
      }
    }

    else if (v27)
    {
      uint64_t v18 = __nw_create_backtrace_string();
      if (v18)
      {
        uint64_t v19 = (char *)v18;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v20 = (os_log_s *)(id)gLogObj;
        BOOL v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
          uint64_t v31 = 2082;
          char v32 = v19;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s sec_identity_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v19);
        if (!v6) {
          return 0LL;
        }
        goto LABEL_57;
      }

      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v25 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_181A5C000, v7, v25, "%{public}s sec_identity_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)(id)gLogObj;
      int v24 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl( &dword_181A5C000,  v7,  v24,  "%{public}s sec_identity_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_55;
  }

  return v4;
}

  __break(1u);
  return result;
}

      free(backtrace_string);
    }

          if (!v3) {
            return;
          }
LABEL_22:
          free(v3);
          return;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        if (__nwlog_url_log::onceToken != -1) {
          dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
        }
        BOOL v4 = (os_log_s *)(id)gurlLogObj;
        int v9 = type;
        id v10 = os_log_type_enabled(v4, type);
        if (!backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v17 = "-[NWURLSessionTask performNextServerTrustChallenge]";
            uint64_t v18 = 2112;
            uint64_t v19 = a1;
            char v6 = "%{public}s Already performing server trust challenge %@, no backtrace";
            BOOL v11 = v4;
            char v12 = v9;
            goto LABEL_29;
          }

          goto LABEL_30;
        }

        if (v10)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v17 = "-[NWURLSessionTask performNextServerTrustChallenge]";
          uint64_t v18 = 2112;
          uint64_t v19 = a1;
          os_log_type_t v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s Already performing server trust challenge %@, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(backtrace_string);
      }

      if (!v3) {
        return;
      }
      goto LABEL_22;
    }

    [*(id *)(a1 + 384) firstObject];
    BOOL v7 = (void (**)(void))objc_claimAutoreleasedReturnValue();
    if (v7)
    {
      uint64_t v13 = v7;
      [*(id *)(a1 + 384) removeObjectAtIndex:0];
      v13[2](v13);
      BOOL v7 = v13;
    }
  }
  }
  }
  }
  }

    if (v15) {
      free(v15);
    }
    goto LABEL_32;
  }

  uint64_t v3 = v2;
  memset(out, 0, sizeof(out));
  uuid_unparse(v2->uuid, out);
  connection = v3->connection;
  if (connection) {
    unsigned int v5 = nw_service_connector_copy_connection_description(connection);
  }
  else {
    unsigned int v5 = 0LL;
  }
  *(void *)os_log_type_t type = 0LL;
  uniqueID = v3->uniqueID;
  BOOL v7 = *((_BYTE *)v3 + 500);
  description = nw_endpoint_get_description(v3->endpoint);
  int v9 = "incoming";
  if ((v7 & 1) == 0) {
    int v9 = "outgoing";
  }
  id v10 = " ";
  BOOL v11 = "";
  if (v5) {
    BOOL v11 = v5;
  }
  else {
    id v10 = "";
  }
  asprintf( (char **)type,  "[SCU%llu %s %s %s %s recv seq %llu [socket%d]%s%s]",  uniqueID,  v9,  description,  v3->service,  out,  v3->receivedSequenceNumber,  v3->dupedSocketFD,  v10,  v11);
  if (v5) {
    free(v5);
  }
  char v12 = *(const char **)type;

  if (!v12)
  {
LABEL_32:
    uint64_t v13 = 0LL;
    return (NSString *)v13;
  }

  uint64_t v13 = (__CFString *)CFStringCreateWithCStringNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  v12,  0x8000100u,  (CFAllocatorRef)*MEMORY[0x189604DB8]);
  return (NSString *)v13;
}

    __int16 v29 = v220;
    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
LABEL_267:

    goto LABEL_268;
  }

  __nwlog_obj();
  v215 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v215, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446466;
  *(void *)&applier[4] = "strict_malloc";
  *(_WORD *)&applier[12] = 2048;
  *(void *)&applier[14] = v131 + 2;
  v216 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v216))
  {
    free(v216);
    LODWORD(v131) = *(unsigned __int16 *)(a1 + 48);
    v132 = 0LL;
    v121 = (NWConcrete_nw_unique_connection_request *)v222;
    goto LABEL_177;
  }

  __break(1u);
}

    goto LABEL_31;
  }

  if (!v83)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)(id)gLogObj;
    char v36 = v84;
    if (os_log_type_enabled(v7, v84))
    {
      os_log_type_t v37 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 136446466;
      v86 = "nw_service_connector_cancel_block_invoke";
      v87 = 2114;
      v88 = v37;
      _os_log_impl( &dword_181A5C000,  v7,  v36,  "%{public}s %{public}@ already cancelled, backtrace limit exceeded",  buf,  0x16u);
    }

    goto LABEL_30;
  }

  char v32 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v7 = (os_log_s *)(id)gLogObj;
  id v33 = v84;
  os_log_type_t v34 = os_log_type_enabled(v7, v84);
  if (!v32)
  {
    if (v34)
    {
      os_log_type_t v38 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 136446466;
      v86 = "nw_service_connector_cancel_block_invoke";
      v87 = 2114;
      v88 = v38;
      _os_log_impl(&dword_181A5C000, v7, v33, "%{public}s %{public}@ already cancelled, no backtrace", buf, 0x16u);
    }

    goto LABEL_30;
  }

  if (v34)
  {
    os_log_type_t v35 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 136446722;
    v86 = "nw_service_connector_cancel_block_invoke";
    v87 = 2114;
    v88 = v35;
    v89 = 2082;
    v90 = v32;
    _os_log_impl( &dword_181A5C000,  v7,  v33,  "%{public}s %{public}@ already cancelled, dumping backtrace:%{public}s",  buf,  0x20u);
  }

  free(v32);
  if (v6) {
LABEL_32:
  }
    free(v6);
}

      free(v13);
      goto LABEL_31;
    }
  }

    if (v18) {
      free(v18);
    }
    os_log_type_t v14 = v12;
    goto LABEL_11;
  }

        goto LABEL_109;
      }

      if (!v165)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v29 = (os_log_s *)(id)gLogObj;
        v64 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(void *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(void *)&v173[10] = 7LL;
          *(_WORD *)&v173[18] = 2048;
          *(void *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 101;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 2;
          _os_log_impl( &dword_181A5C000,  v29,  v64,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  buf,  0x36u);
        }

        goto LABEL_30;
      }

      char v36 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v37 = (os_log_s *)(id)gLogObj;
      os_log_type_t v38 = type;
      char v39 = os_log_type_enabled(v37, type);
      if (v36)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136447746;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(void *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(void *)&v173[10] = 7LL;
          *(_WORD *)&v173[18] = 2048;
          *(void *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 101;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 2;
          v176 = 2082;
          v177 = v36;
          _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
        }

        free(v36);
      }

      else
      {
        if (v39)
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(void *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(void *)&v173[10] = 7LL;
          *(_WORD *)&v173[18] = 2048;
          *(void *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 101;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 2;
          _os_log_impl( &dword_181A5C000,  v37,  v38,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  buf,  0x36u);
        }
      }
    }
  }
  }

        free(backtrace_string);
        if (!v17) {
          return 0LL;
        }
        goto LABEL_55;
      }

      if (!v47)
      {
LABEL_54:
        if (!v17) {
          return 0LL;
        }
LABEL_55:
        free(v17);
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      v56 = "nw_http3_framer_write_http3_frame_header";
      os_log_type_t v20 = "%{public}s called with null http3_framer, no backtrace";
    }

    else
    {
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      uint64_t v19 = type[0];
      if (!os_log_type_enabled(v18, type[0])) {
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      v56 = "nw_http3_framer_write_http3_frame_header";
      os_log_type_t v20 = "%{public}s called with null http3_framer, backtrace limit exceeded";
    }

      while (1)
      {
        BOOL v21 = *(void *)(a1 + 960);
        if (!v21) {
          break;
        }
        os_log_type_t v22 = *(void *)(v21 + 608);
        id v23 = *(void **)(v21 + 616);
        if (v22)
        {
          *(void *)(v22 + 616) = v23;
          id v23 = *(void **)(v21 + 616);
        }

        else
        {
          *(void *)(a1 + 968) = v23;
        }

        char *v23 = v22;
        *(void *)(v21 + 608) = 0LL;
        *(void *)(v21 + 616) = 0LL;
        int v24 = *(_DWORD *)(v21 + 372);
        if (v24 > 8)
        {
LABEL_50:
          v65 = 0LL;
          v66 = &v65;
          v68 = 0;
          __int16 v67 = 0x2000000000LL;
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___ZL40nw_http3_stream_fields_process_unblockedP24nw_protocol_http3_stream_block_invoke;
          *(void *)&buf[24] = &unk_189BC4238;
          v74 = &v65;
          v75 = v21;
          uint64_t v42 = *(nw_protocol **)(v21 + 216);
          do
          {
            if (!v42) {
              break;
            }
            output_handler = v42->output_handler;
            os_log_type_t v44 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
            uint64_t v42 = output_handler;
          }

          while ((v44 & 1) != 0);
          if (!*((_DWORD *)v66 + 6)) {
            nw_protocol_http3_stream_input_available((nw_protocol *)v21, v42);
          }
          if ((*(_WORD *)(v21 + 736) & 0x100) != 0)
          {
            uint64_t v45 = *(void *)(v21 + 328);
            v46 = *(void **)(*(void *)(v21 + 336) + 1256LL);
            *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
            os_log_type_t v60 = 0x40000000LL;
            v61 = ___ZL40nw_http3_stream_fields_process_unblockedP24nw_protocol_http3_stream_block_invoke_2;
            id v62 = &unk_189BC4260;
            char v63 = v45;
            v64 = v21;
            nw_queue_context_async(v46, type);
          }

          _Block_object_dispose(&v65, 8);
        }

        else
        {
          if (((1 << v24) & 0x1BB) == 0)
          {
            if (v24 == 2)
            {
              *(_DWORD *)(v21 + 372) = 1;
              os_log_type_t v38 = nw_http3_encoder_stream_get_and_reset_received_size(*(void *)(v21 + 336));
              nw_http_transaction_metadata_increment_inbound_header_size(*(void **)(v21 + 392), v38);
            }

            else
            {
              *(_DWORD *)(v21 + 372) = 5;
            }

            goto LABEL_50;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v25 = *(_DWORD *)(v21 + 372);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http3_stream_fields_process_unblocked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v25;
          os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v65) = 0;
          if (__nwlog_fault(v26, type, &v65))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v27 = gLogObj;
              os_log_type_t v28 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                __int16 v29 = *(_DWORD *)(v21 + 372);
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_fields_process_unblocked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v29;
                os_log_type_t v30 = (os_log_s *)v27;
                uint64_t v31 = v28;
                char v32 = "%{public}s Unexpected input state %d";
LABEL_59:
                _os_log_impl(&dword_181A5C000, v30, v31, v32, buf, 0x12u);
              }
            }

            else if ((_BYTE)v65)
            {
              id v33 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v34 = (os_log_s *)gLogObj;
              os_log_type_t v35 = type[0];
              char v36 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
              if (v33)
              {
                if (v36)
                {
                  os_log_type_t v37 = *(_DWORD *)(v21 + 372);
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_http3_stream_fields_process_unblocked";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v37;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v33;
                  _os_log_impl( &dword_181A5C000,  v34,  v35,  "%{public}s Unexpected input state %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
                }

                free(v33);
              }

              else if (v36)
              {
                v47 = *(_DWORD *)(v21 + 372);
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_fields_process_unblocked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v47;
                os_log_type_t v30 = v34;
                uint64_t v31 = v35;
                char v32 = "%{public}s Unexpected input state %d, no backtrace";
                goto LABEL_59;
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v39 = gLogObj;
              __int16 v40 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                uint64_t v41 = *(_DWORD *)(v21 + 372);
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http3_stream_fields_process_unblocked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v41;
                os_log_type_t v30 = (os_log_s *)v39;
                uint64_t v31 = v40;
                char v32 = "%{public}s Unexpected input state %d, backtrace limit exceeded";
                goto LABEL_59;
              }
            }
          }

          if (v26) {
            free(v26);
          }
        }
      }

      if (*(_DWORD *)(a1 + 528) != *(_DWORD *)(a1 + 532))
      {
        nw_http3_start_decoder_stream_if_needed(a1);
        nw_http3_decoder_stream_process_output(a1);
      }

      _Block_object_dispose(v69, 8);
    }
  }

  __nwlog_obj();
  *(_DWORD *)v69 = 136446210;
  *(void *)&v69[4] = "nw_http3_encoder_stream_process_input";
  v48 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v48, buf, type))
  {
    if (buf[0] == 17)
    {
      v49 = (os_log_s *)__nwlog_obj();
      os_log_type_t v50 = buf[0];
      if (!os_log_type_enabled(v49, (os_log_type_t)buf[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)v69 = 136446210;
      *(void *)&v69[4] = "nw_http3_encoder_stream_process_input";
      v51 = "%{public}s called with null http3";
      goto LABEL_79;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v49 = (os_log_s *)__nwlog_obj();
      os_log_type_t v50 = buf[0];
      if (!os_log_type_enabled(v49, (os_log_type_t)buf[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)v69 = 136446210;
      *(void *)&v69[4] = "nw_http3_encoder_stream_process_input";
      v51 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_79;
    }

    os_log_type_t v52 = (char *)__nw_create_backtrace_string();
    v49 = (os_log_s *)__nwlog_obj();
    os_log_type_t v50 = buf[0];
    v53 = os_log_type_enabled(v49, (os_log_type_t)buf[0]);
    if (v52)
    {
      if (v53)
      {
        *(_DWORD *)v69 = 136446466;
        *(void *)&v69[4] = "nw_http3_encoder_stream_process_input";
        *(_WORD *)&v69[12] = 2082;
        *(void *)&v69[14] = v52;
        _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s called with null http3, dumping backtrace:%{public}s",  v69,  0x16u);
      }

      free(v52);
      goto LABEL_80;
    }

    if (v53)
    {
      *(_DWORD *)v69 = 136446210;
      *(void *)&v69[4] = "nw_http3_encoder_stream_process_input";
      v51 = "%{public}s called with null http3, no backtrace";
LABEL_79:
      _os_log_impl(&dword_181A5C000, v49, v50, v51, v69, 0xCu);
    }
  }

          int v24 = v23 == *(void *)(a1 + 928);
          id v23 = *(void *)(a1 + 928);
          if (v24) {
            return;
          }
        }

        if (v25) {
          goto LABEL_56;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v26 = *(_DWORD *)(v23 + 368);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v26;
        os_log_type_t v27 = (const char *)_os_log_send_and_compose_impl();
        v118[0] = OS_LOG_TYPE_ERROR;
        v122[0] = 0;
        if (__nwlog_fault(v27, v118, v122))
        {
          if (v118[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v28 = gLogObj;
            __int16 v29 = v118[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, v118[0])) {
              goto LABEL_53;
            }
            os_log_type_t v30 = *(_DWORD *)(v23 + 368);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v30;
            uint64_t v31 = (os_log_s *)v28;
            char v32 = v29;
            id v33 = "%{public}s Unexpected output state %d";
LABEL_52:
            _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0x12u);
            goto LABEL_53;
          }

          if (!v122[0])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v43 = gLogObj;
            os_log_type_t v44 = v118[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, v118[0])) {
              goto LABEL_53;
            }
            uint64_t v45 = *(_DWORD *)(v23 + 368);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v45;
            uint64_t v31 = (os_log_s *)v43;
            char v32 = v44;
            id v33 = "%{public}s Unexpected output state %d, backtrace limit exceeded";
            goto LABEL_52;
          }

          os_log_type_t v38 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v39 = (os_log_s *)gLogObj;
          __int16 v40 = v118[0];
          uint64_t v41 = os_log_type_enabled((os_log_t)gLogObj, v118[0]);
          if (!v38)
          {
            if (!v41) {
              goto LABEL_53;
            }
            v46 = *(_DWORD *)(v23 + 368);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v46;
            uint64_t v31 = v39;
            char v32 = v40;
            id v33 = "%{public}s Unexpected output state %d, no backtrace";
            goto LABEL_52;
          }

          if (v41)
          {
            uint64_t v42 = *(_DWORD *)(v23 + 368);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http3_stream_encoder_stream_output_available";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v42;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v38;
            _os_log_impl( &dword_181A5C000,  v39,  v40,  "%{public}s Unexpected output state %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v38);
        }
  }

    free(v26);
    if (!v79) {
      return 0LL;
    }
    char v39 = v79;
LABEL_32:
    free(v39);
    return 0LL;
  }

  *a6 = v79;
  *v75 = 96LL;
  uint64_t v41 = v27;
  if (!v27)
  {
    v71 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v83 = "strict_calloc";
    v72 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_175;
    }
    free(v72);
    uint64_t v41 = 0LL;
  }

  uint64_t v42 = calloc(1uLL, v41);
  __int16 v43 = a10;
  if (v42)
  {
LABEL_37:
    *v76 = v42;
    memcpy(v42, v26 + 7, v41);
    *a9 = v41;
    *__int16 v43 = v77;
    return (BOOL)v26;
  }

  v73 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v83 = "strict_calloc";
  v84 = 2048;
  v85 = 1LL;
  v86 = 2048;
  v87 = v41;
  v74 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v74);
  if (!result)
  {
    free(v74);
    __int16 v43 = a10;
    uint64_t v41 = v27;
    goto LABEL_37;
  }

  __break(1u);
  return result;
}

  os_log_type_t v22 = 0LL;
LABEL_142:

LABEL_143:
  return v22;
}

  return v6;
}

    if (v8) {
      free(v8);
    }
    goto LABEL_32;
  }

  __nwlog_obj();
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v28 = "nw_path_watch_necp_changes";
  __int16 v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v16, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_path_watch_necp_changes";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null context", buf, 0xCu);
      }
    }

    else if (v25)
    {
      uint64_t v19 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v28 = "nw_path_watch_necp_changes";
          __int16 v29 = 2082;
          os_log_type_t v30 = v19;
          _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v19);
        goto LABEL_51;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_path_watch_necp_changes";
        _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_path_watch_necp_changes";
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(backtrace_string);
    goto LABEL_43;
  }

  memset(__s1, 0, 20);
  *(void *)os_log_type_t type = 0LL;
  __int16 v29 = 0LL;
  os_log_type_t v30 = 0;
  __n = 5140;
  __s2[0] = 0LL;
  __s2[1] = 0LL;
  os_log_type_t v27 = 0;
  os_log_type_t v22 = 20;
  __n_2[0] = 0LL;
  __n_2[1] = 0LL;
  char v25 = 0;
  BOOL v21 = 20;
  nw_path_get_ipv4_network_signature(v4, __s1, (_BYTE *)&__n + 1);
  nw_path_get_ipv6_network_signature(v5, type, &__n);
  nw_path_get_ipv4_network_signature(v3, __s2, &v22);
  nw_path_get_ipv6_network_signature(v3, __n_2, &v21);
  if (HIBYTE(__n) != v22
    || (char v6 = __n, __n != v21)
    || HIBYTE(__n) && memcmp(__s1, __s2, HIBYTE(__n)))
  {
LABEL_7:
    char v6 = 1LL;
    goto LABEL_8;
  }

  if ((_DWORD)v6) {
    char v6 = memcmp(type, __n_2, v6) != 0;
  }
LABEL_8:

  return v6;
}

      free(backtrace_string);
    }
  }
  }

  if (!v20 || [v20 statusCode] != 301 && objc_msgSend(v20, "statusCode") != 308)
  {
    if ((v11 & 0xFFFFFFFFFFFFFFFELL) == 2)
    {
      char v25 = 1;
    }

    else if (_CFURLResponseMustRevalidate() == 1)
    {
      char v25 = 3;
    }

    else
    {
      CFURLResponseGetExpirationTime();
      char v25 = 3;
      if (v26 - CFAbsoluteTimeGetCurrent() >= 1.0)
      {
        v53 = [v13 valueForHTTPHeaderField:@"Must-Revalidate"];

        v51 = [v13 valueForHTTPHeaderField:@"Proxy-Revalidate"];

        os_log_type_t v27 = [v13 valueForHTTPHeaderField:@"If-Modified-Since"];

        os_log_type_t v28 = [v13 valueForHTTPHeaderField:@"Cache-Control"];
        __int16 v29 = v28 | v27;

        if (v29 | v51 | v53) {
          os_log_type_t v30 = 3;
        }
        else {
          os_log_type_t v30 = 1;
        }
        if (v11 == 5) {
          char v25 = 3;
        }
        else {
          char v25 = v30;
        }
      }
    }

    goto LABEL_48;
  }

    goto LABEL_31;
  }

  BOOL v4 = calloc(1uLL, 0x30uLL);
  if (v4)
  {
    unsigned int v5 = *(NWConcrete_nw_protocol_options **)a2;
    if (!*(void *)a2)
    {
LABEL_5:
      char v6 = *(void **)v4;
      *(void *)BOOL v4 = v5;

      BOOL v7 = *(void **)(a2 + 8);
      if (v7)
      {
        unsigned int v8 = nw_protocol_options_copy(v7);
        int v9 = (void *)*((void *)v4 + 1);
        *((void *)v4 + 1) = v8;
      }

      else
      {
        int v9 = (void *)*((void *)v4 + 1);
        *((void *)v4 + 1) = 0LL;
      }

      id v10 = *(void **)(a2 + 16);
      if (v10)
      {
        BOOL v11 = nw_protocol_options_copy(v10);
        char v12 = (void *)*((void *)v4 + 2);
        *((void *)v4 + 2) = v11;
      }

      else
      {
        char v12 = (void *)*((void *)v4 + 2);
        *((void *)v4 + 2) = 0LL;
      }

      objc_storeStrong((id *)v4 + 3, *(id *)(a2 + 24));
      uint64_t v13 = _Block_copy(*(const void **)(a2 + 32));
      os_log_type_t v14 = (void *)*((void *)v4 + 4);
      *((void *)v4 + 4) = v13;

      uint64_t v15 = _Block_copy(*(const void **)(a2 + 40));
      __int16 v16 = (void *)*((void *)v4 + 5);
      *((void *)v4 + 5) = v15;

LABEL_12:
      return (BOOL)v4;
    }

  __break(1u);
  return result;
}

  if (v15) {
    free(v15);
  }
  int v9 = 0LL;
  char v12 = 0LL;
LABEL_13:

  return v12;
}

  __break(1u);
  return result;
}

        ++v22;
        v21 += 16LL;
        if (v22 >= used_timestamps) {
          goto LABEL_94;
        }
      }

      os_log_type_t v26 = v1;
      nw_context_assert_queue(v1->context);
      if (*(unsigned __int16 *)((char *)&timestamps->var1.event + v21) == 3)
      {
        if ((_WORD)v4)
        {
        }

        else
        {
          LOWORD(v4) = *(unsigned __int16 *)((char *)&timestamps->var2.var0.var0 + v21);
        }

        id v33 = nw_delta_nanos(v1->start_time, *(unint64_t *)((char *)&timestamps->var0 + v21));
        os_log_type_t v34 = v33 / 0xF4240;
        if (v33 > 0xF423FFFFFFFFFLL) {
          LODWORD(v34) = -1;
        }
        v382 = v34;
      }

  if (v13) {
    free(v13);
  }
  fd = 0LL;
LABEL_13:

  return fd;
}
  }

    __break(1u);
    return result;
  }

  uint64_t v13 = v12;
  memcpy(v12 + 1, v9, v8);
  uint64_t v15 = nw_frame_create(0, (uint64_t)v13, v11, (uint64_t)__nw_frame_custom_finalizer, 0LL);
  if (v15)
  {
LABEL_16:
    *(_WORD *)(v15 + 204) |= 1u;
    nw_frame_claim(v15, v14, 1, 0);
    goto LABEL_18;
  }

  free(v13);
LABEL_18:
  if (gLogDatapath)
  {
    BOOL v21 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v22 = a1[6];
      *(_DWORD *)buf = 136446978;
      os_log_type_t v27 = "nw_protocol_test_get_input_frames_block_invoke";
      if (v22) {
        id v23 = (const char *)(v22 + 32);
      }
      else {
        id v23 = "";
      }
      os_log_type_t v28 = 2082;
      __int16 v29 = (size_t)v23;
      os_log_type_t v30 = 2048;
      uint64_t v31 = v15;
      char v32 = 2048;
      id v33 = a2;
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Created new frame %p from frame %p",  buf,  0x2Au);
    }
  }

  nw_frame_finalize(a2);
  __int16 v16 = a1[7];
  *(void *)(v15 + 32) = 0LL;
  uint64_t v17 = *(uint64_t **)(v16 + 8);
  *(void *)(v15 + 40) = v17;
  os_log_s *v17 = v15;
  *(void *)(v16 + 8) = v15 + 32;
  ++*(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL);
  return 1LL;
}

  if (v20) {
    free(v20);
  }
LABEL_13:
}

  BYTE4(a1[3].output_handler_context) = nw_parameters_get_ip_protocol(v16);
  uint64_t v17 = a2->handle;
  if (v17 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v18 = a2[1].callbacks;
    if (v18) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
    }
  }

  uint64_t v19 = a2->callbacks;
  if (v19)
  {
    get_local_endpoint = (uint64_t (*)(nw_protocol *))v19->get_local_endpoint;
    if (get_local_endpoint)
    {
      BOOL v21 = (nw_endpoint *)get_local_endpoint(a2);
      if (v17 != &nw_protocol_ref_counted_handle) {
        goto LABEL_36;
      }
      goto LABEL_221;
    }
  }

  __nwlog_obj();
  id v62 = a2->identifier;
  if (!v62) {
    id v62 = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)buf = 136446722;
  v157 = "__nw_protocol_get_local_endpoint";
  v158 = 2082;
  v159 = v62;
  v160 = 2048;
  v161 = a2;
  char v63 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v154 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v63, type, &v154))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v64 = (os_log_s *)__nwlog_obj();
      v65 = type[0];
      if (!os_log_type_enabled(v64, type[0])) {
        goto LABEL_218;
      }
      v66 = a2->identifier;
      if (!v66) {
        v66 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_local_endpoint";
      v158 = 2082;
      v159 = v66;
      v160 = 2048;
      v161 = a2;
      __int16 v67 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback";
LABEL_217:
      _os_log_impl(&dword_181A5C000, v64, v65, v67, buf, 0x20u);
      goto LABEL_218;
    }

    if (v154 == OS_LOG_TYPE_DEFAULT)
    {
      v64 = (os_log_s *)__nwlog_obj();
      v65 = type[0];
      if (!os_log_type_enabled(v64, type[0])) {
        goto LABEL_218;
      }
      v85 = a2->identifier;
      if (!v85) {
        v85 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_local_endpoint";
      v158 = 2082;
      v159 = v85;
      v160 = 2048;
      v161 = a2;
      __int16 v67 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, backtrace limit exceeded";
      goto LABEL_217;
    }

    v75 = (char *)__nw_create_backtrace_string();
    v64 = (os_log_s *)__nwlog_obj();
    v65 = type[0];
    v76 = os_log_type_enabled(v64, type[0]);
    if (!v75)
    {
      if (!v76) {
        goto LABEL_218;
      }
      v87 = a2->identifier;
      if (!v87) {
        v87 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v157 = "__nw_protocol_get_local_endpoint";
      v158 = 2082;
      v159 = v87;
      v160 = 2048;
      v161 = a2;
      __int16 v67 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, no backtrace";
      goto LABEL_217;
    }

    if (v76)
    {
      v77 = a2->identifier;
      if (!v77) {
        v77 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446978;
      v157 = "__nw_protocol_get_local_endpoint";
      v158 = 2082;
      v159 = v77;
      v160 = 2048;
      v161 = a2;
      v162 = 2082;
      v163 = v75;
      _os_log_impl( &dword_181A5C000,  v64,  v65,  "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(v75);
  }

    if (v12) {
      free(v12);
    }
    *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL) = 0;
  }

    if (v10) {
      free(v10);
    }
    *(_DWORD *)(*(void *)(a1[6] + 8LL) + 24LL) = 0;
  }

    free(backtrace_string);
    goto LABEL_44;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v5 = (os_log_s *)gLogObj;
  char v6 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_channel_get_nexus_instance";
    BOOL v7 = "%{public}s called with null port";
    goto LABEL_43;
  }
    }

void sub_181A8194C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_device_id(void *a1, const char *a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "nw_endpoint_set_device_id";
    unsigned int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_endpoint_set_device_id";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v20 = "nw_endpoint_set_device_id";
            __int16 v21 = 2082;
            os_log_type_t v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_endpoint_set_device_id";
          _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_endpoint_set_device_id";
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

id nw_endpoint_copy_public_keys(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  uint64_t v18 = 0LL;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x3032000000LL;
  __int16 v21 = __Block_byref_object_copy__6408;
  os_log_type_t v22 = __Block_byref_object_dispose__6409;
  id v23 = 0LL;
  if (v1)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_endpoint_copy_public_keys_block_invoke;
    v13[3] = &unk_189BC9210;
    BOOL v15 = &v18;
    os_log_type_t v14 = v1;
    os_unfair_lock_lock(v2 + 44);
    __nw_endpoint_copy_public_keys_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 44);
    id v3 = (id)v19[5];

    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v25 = "nw_endpoint_copy_public_keys";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v25 = "nw_endpoint_copy_public_keys";
          __int16 v26 = 2082;
          os_log_type_t v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_endpoint_copy_public_keys_block_invoke(uint64_t a1)
{
}

void nw_endpoint_set_public_keys(void *a1, void *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  unsigned int v5 = v4;
  if (v3)
  {
    if ((unint64_t)[v4 count] > 0x10)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      id v33 = "nw_endpoint_set_public_keys";
      BOOL v7 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v30 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          id v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s Setting too many keys", buf, 0xCu);
        }

void sub_181A82868(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_set_public_keys_block_invoke(uint64_t a1)
{
}

void nw_endpoint_enumerate_alternatives(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  unsigned int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    id v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v26 = "nw_endpoint_enumerate_alternatives";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v24;
      BOOL v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v26 = "nw_endpoint_enumerate_alternatives";
          __int16 v27 = 2082;
          os_log_type_t v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_40:
        free(v7);
        goto LABEL_5;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_181A82DA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_enumerate_alternatives_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = (void *)(*(void *)(result + 32) + 160LL);
  do
  {
    uint64_t v2 = (void *)*v2;
    if (!v2) {
      break;
    }
    BOOL result = (*(uint64_t (**)(void))(*(void *)(v1 + 40) + 16LL))();
  }

  while ((result & 1) != 0);
  return result;
}

uint64_t __nw_endpoint_copy_properties_block_invoke(uint64_t a1, void *a2, void *a3)
{
  return 1LL;
}

void sub_181A83580(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_get_sensitive_redacted(void *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "nw_parameters_get_sensitive_redacted";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v10, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_parameters_get_sensitive_redacted";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v20 = "nw_parameters_get_sensitive_redacted";
            __int16 v21 = 2082;
            id v22 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_34;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_parameters_get_sensitive_redacted";
          _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_parameters_get_sensitive_redacted";
          _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_34:
    if (v10) {
      free(v10);
    }
    goto LABEL_16;
  }

  id v3 = *(id *)(v1[13] + 136LL);
  id v4 = v3;
  if (!v3 || (int v5 = v3[31], (v5 - 2) < 2))
  {
    if (nwlog_get_sensitive_redacted::onceToken != -1) {
      dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
    }
    int v6 = nwlog_get_sensitive_redacted::sensitiveRedacted;

    if (!v6) {
      goto LABEL_10;
    }
LABEL_16:
    BOOL v7 = 1LL;
    goto LABEL_17;
  }

  if (v5 != 1)
  {

    goto LABEL_16;
  }

LABEL_10:
  if (*(unsigned __int8 *)(v2[13] + 102LL) - 1 > 1)
  {
    BOOL v7 = 0LL;
  }

  else
  {
    if (nwlog_get_sensitive_redacted::onceToken != -1) {
      dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
    }
    BOOL v7 = nwlog_get_sensitive_redacted::sensitiveRedacted != 0;
  }

    free(v9);
    goto LABEL_35;
  }

  os_log_type_t v13 = a2[1];
  if (v13 != 30)
  {
    os_log_type_t v14 = *a2;
    if (v13 != 2) {
      goto LABEL_43;
    }
    if (v6 >= 0x11)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = 16;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v57 = "-[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]";
        BOOL v58 = 1024;
        *(_DWORD *)os_log_type_t v59 = v6;
        v59[2] = 2048;
        os_log_type_t v14 = 16;
        *(void *)&v59[3] = 16LL;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s Changing endpoint address length from %u to %lu, too long for family AF_INET",  buf,  0x1Cu);
      }

        nw_parameters_clear_protocol_stack(v6, 3);
        if ((v3[8] & 4) == 0) {
          goto LABEL_22;
        }
        goto LABEL_21;
      }

                if (v128[1] == 2)
                {
                  uint64_t v41 = bswap32(*(unsigned int *)&v128[4]);
                  __int16 v27 = (v41 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v41) == 127;
                  os_log_type_t v26 = 14;
                }

                else
                {
                  if (v128[1] != 30)
                  {
                    os_log_type_t v26 = 0;
                    goto LABEL_70;
                  }

                  if (v128[8] == 255)
                  {
                    v66 = (v128[9] & 0xF) - 1;
                    if (v66 >= 5) {
                      os_log_type_t v26 = 14;
                    }
                    else {
                      os_log_type_t v26 = dword_18272C8C8[v66];
                    }
                    goto LABEL_70;
                  }

                  if (v128[8] == 254)
                  {
                    if (v128[9] <= 0xBFu) {
                      os_log_type_t v26 = 14;
                    }
                    else {
                      os_log_type_t v26 = 5;
                    }
                    __int16 v27 = (v128[9] & 0xC0) == 128;
                  }

                  else
                  {
                    os_log_type_t v26 = 14;
                    if (*(void *)&v128[8] | *(void *)&v128[15]) {
                      goto LABEL_70;
                    }
                    __int16 v27 = v128[23] == 1;
                  }
                }

                if (v27) {
                  os_log_type_t v26 = 2;
                }
LABEL_70:
                if (v128[37] == 2)
                {
                  os_log_type_t v44 = bswap32(*(unsigned int *)&v128[40]);
                  __int16 v43 = (v44 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v44) == 127;
                  uint64_t v42 = 14;
                }

                else
                {
                  if (v128[37] != 30)
                  {
                    uint64_t v42 = 0;
                    goto LABEL_86;
                  }

                  if (v128[44] == 255)
                  {
                    __int16 v67 = (v128[45] & 0xF) - 1;
                    if (v67 >= 5) {
                      uint64_t v42 = 14;
                    }
                    else {
                      uint64_t v42 = dword_18272C8C8[v67];
                    }
                    goto LABEL_86;
                  }

                  if (v128[44] == 254)
                  {
                    if (v128[45] <= 0xBFu) {
                      uint64_t v42 = 14;
                    }
                    else {
                      uint64_t v42 = 5;
                    }
                    __int16 v43 = (v128[45] & 0xC0) == 128;
                  }

                  else
                  {
                    uint64_t v42 = 14;
                    if (*(void *)&v128[44] | *(void *)&v128[51]) {
                      goto LABEL_86;
                    }
                    __int16 v43 = v128[59] == 1;
                  }
                }

                if (v43) {
                  uint64_t v42 = 2;
                }
LABEL_86:
                if (v26 != v42) {
                  goto LABEL_123;
                }
                if (type[1] == 2)
                {
                  v47 = bswap32(*(unsigned int *)&type[4]);
                  v46 = (v47 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v47) == 127;
                  uint64_t v45 = 14;
                }

                else
                {
                  if (type[1] != 30)
                  {
                    uint64_t v45 = 0;
                    goto LABEL_106;
                  }

                  if (type[8] == 255)
                  {
                    v74 = (type[9] & 0xF) - 1;
                    if (v74 >= 5) {
                      uint64_t v45 = 14;
                    }
                    else {
                      uint64_t v45 = dword_18272C8C8[v74];
                    }
                    goto LABEL_106;
                  }

                  if (type[8] == 254)
                  {
                    if (type[9] <= 0xBFu) {
                      uint64_t v45 = 14;
                    }
                    else {
                      uint64_t v45 = 5;
                    }
                    v46 = (type[9] & 0xC0) == 128;
                  }

                  else
                  {
                    uint64_t v45 = 14;
                    if (*(void *)&type[8] | *(void *)&type[15]) {
                      goto LABEL_106;
                    }
                    v46 = type[23] == 1;
                  }
                }

                if (v46) {
                  uint64_t v45 = 2;
                }
LABEL_106:
                if (type[37] == 2)
                {
                  os_log_type_t v50 = bswap32(*(unsigned int *)&type[40]);
                  v49 = (v50 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v50) == 127;
                  v48 = 14;
                }

                else
                {
                  if (type[37] != 30)
                  {
                    v48 = 0;
                    goto LABEL_122;
                  }

                  if (type[44] == 255)
                  {
                    v75 = (type[45] & 0xF) - 1;
                    if (v75 >= 5) {
                      v48 = 14;
                    }
                    else {
                      v48 = dword_18272C8C8[v75];
                    }
                    goto LABEL_122;
                  }

                  if (type[44] == 254)
                  {
                    if (type[45] <= 0xBFu) {
                      v48 = 14;
                    }
                    else {
                      v48 = 5;
                    }
                    v49 = (type[45] & 0xC0) == 128;
                  }

                  else
                  {
                    v48 = 14;
                    if (*(void *)&type[44] | *(void *)&type[51]) {
                      goto LABEL_122;
                    }
                    v49 = type[59] == 1;
                  }
                }

                if (v49) {
                  v48 = 2;
                }
LABEL_122:
                if (v45 == v48) {
                  goto LABEL_200;
                }
LABEL_123:
                if (v128[1] == 2)
                {
                  v53 = bswap32(*(unsigned int *)&v128[4]);
                  os_log_type_t v52 = (v53 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v53) == 127;
                  v51 = 14;
                }

                else
                {
                  if (v128[1] != 30)
                  {
                    v51 = 0;
                    goto LABEL_139;
                  }

                  if (v128[8] == 255)
                  {
                    v69 = (v128[9] & 0xF) - 1;
                    if (v69 >= 5) {
                      v51 = 14;
                    }
                    else {
                      v51 = dword_18272C8C8[v69];
                    }
                    goto LABEL_139;
                  }

                  if (v128[8] == 254)
                  {
                    if (v128[9] <= 0xBFu) {
                      v51 = 14;
                    }
                    else {
                      v51 = 5;
                    }
                    os_log_type_t v52 = (v128[9] & 0xC0) == 128;
                  }

                  else
                  {
                    v51 = 14;
                    if (*(void *)&v128[8] | *(void *)&v128[15]) {
                      goto LABEL_139;
                    }
                    os_log_type_t v52 = v128[23] == 1;
                  }
                }

                if (v52) {
                  v51 = 2;
                }
LABEL_139:
                if (v128[37] == 2)
                {
                  v56 = bswap32(*(unsigned int *)&v128[40]);
                  BOOL v55 = (v56 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v56) == 127;
                  os_log_type_t v54 = 14;
                }

                else
                {
                  if (v128[37] != 30)
                  {
                    os_log_type_t v54 = 0;
                    goto LABEL_155;
                  }

                  if (v128[44] == 255)
                  {
                    v70 = (v128[45] & 0xF) - 1;
                    if (v70 >= 5) {
                      os_log_type_t v54 = 14;
                    }
                    else {
                      os_log_type_t v54 = dword_18272C8C8[v70];
                    }
                    goto LABEL_155;
                  }

                  if (v128[44] == 254)
                  {
                    if (v128[45] <= 0xBFu) {
                      os_log_type_t v54 = 14;
                    }
                    else {
                      os_log_type_t v54 = 5;
                    }
                    BOOL v55 = (v128[45] & 0xC0) == 128;
                  }

                  else
                  {
                    os_log_type_t v54 = 14;
                    if (*(void *)&v128[44] | *(void *)&v128[51]) {
                      goto LABEL_155;
                    }
                    BOOL v55 = v128[59] == 1;
                  }
                }

                if (v55) {
                  os_log_type_t v54 = 2;
                }
LABEL_155:
                if (v51 == v54)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v16 = (os_log_s *)gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_rfc6724";
                    char v17 = "%{public}s Rule 2, prefer d1, d2 dst scope does not match src scope";
                    goto LABEL_384;
                  }

                  goto LABEL_386;
                }

                if (type[1] == 2)
                {
                  id v62 = bswap32(*(unsigned int *)&type[4]);
                  BOOL v58 = (v62 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v62) == 127;
                  os_log_type_t v57 = 14;
                }

                else
                {
                  if (type[1] != 30)
                  {
                    os_log_type_t v57 = 0;
                    goto LABEL_181;
                  }

                  if (type[8] == 255)
                  {
                    v77 = (type[9] & 0xF) - 1;
                    if (v77 >= 5) {
                      os_log_type_t v57 = 14;
                    }
                    else {
                      os_log_type_t v57 = dword_18272C8C8[v77];
                    }
                    goto LABEL_181;
                  }

                  if (type[8] == 254)
                  {
                    if (type[9] <= 0xBFu) {
                      os_log_type_t v57 = 14;
                    }
                    else {
                      os_log_type_t v57 = 5;
                    }
                    BOOL v58 = (type[9] & 0xC0) == 128;
                  }

                  else
                  {
                    os_log_type_t v57 = 14;
                    if (*(void *)&type[8] | *(void *)&type[15]) {
                      goto LABEL_181;
                    }
                    BOOL v58 = type[23] == 1;
                  }
                }

                if (v58) {
                  os_log_type_t v57 = 2;
                }
LABEL_181:
                if (type[37] == 2)
                {
                  v65 = bswap32(*(unsigned int *)&type[40]);
                  v64 = (v65 & 0xFFFF0000) == 0xA9FE0000 || HIBYTE(v65) == 127;
                  char v63 = 14;
                }

                else
                {
                  if (type[37] != 30)
                  {
                    char v63 = 0;
                    goto LABEL_197;
                  }

                  if (type[44] == 255)
                  {
                    v78 = (type[45] & 0xF) - 1;
                    if (v78 >= 5) {
                      char v63 = 14;
                    }
                    else {
                      char v63 = dword_18272C8C8[v78];
                    }
                    goto LABEL_197;
                  }

                  if (type[44] == 254)
                  {
                    if (type[45] <= 0xBFu) {
                      char v63 = 14;
                    }
                    else {
                      char v63 = 5;
                    }
                    v64 = (type[45] & 0xC0) == 128;
                  }

                  else
                  {
                    char v63 = 14;
                    if (*(void *)&type[44] | *(void *)&type[51]) {
                      goto LABEL_197;
                    }
                    v64 = type[59] == 1;
                  }
                }

                if (v64) {
                  char v63 = 2;
                }
LABEL_197:
                if (v57 == v63)
                {
                  os_log_type_t v24 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    v132 = "sa_dst_compare_rfc6724";
                    char v25 = "%{public}s Rule 2, prefer d2, d1 dst scope does not match src scope";
                    goto LABEL_352;
                  }

  protocol_for_definition = 0LL;
LABEL_35:

  return protocol_for_definition;
}

    if (v13) {
      free(v13);
    }
    goto LABEL_13;
  }

  id v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      else {
        os_log_type_t v8 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      uint64_t v23 = "nw_flow_get_local";
      os_log_type_t v24 = 2082;
      char v25 = (void *)v8;
      os_log_type_t v26 = 2082;
      __int16 v27 = "flow";
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

LABEL_13:
    int v6 = 0LL;
    goto LABEL_17;
  }

  int v5 = nw_endpoint_handler_copy_flow(v3);
  if (*((void *)v5 + 120))
  {
    int v6 = 0LL;
  }

  else
  {
    os_log_type_t v9 = (nw_path *)nw_endpoint_flow_copy_path(v3);
    os_log_type_t v10 = v9;
    if (v9) {
      int v6 = nw_path_copy_effective_local_endpoint(v9);
    }
    else {
      int v6 = 0LL;
    }
  }

LABEL_17:
  return v6;
}

    if (v7) {
      free(v7);
    }
    goto LABEL_36;
  }

  if ((*((_BYTE *)v1 + 140) & 8) == 0)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
    }
    os_log_type_t v10 = (os_log_s *)(id)gactivityLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "Activity not yet complete, returning duration 0", buf, 2u);
    }

    goto LABEL_17;
  }

  if ((*((_BYTE *)v1 + 140) & 2) != 0)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
    }
    os_log_type_t v10 = (os_log_s *)(id)gactivityLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEBUG, "Activity is lightweight, returning duration 0", buf, 2u);
    }

  if (v25) {
    free(v25);
  }
  id v3 = 0LL;
LABEL_17:

  return v3;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  __break(1u);
  return result;
}

  swift_release();
  BOOL result = swift_bridgeObjectRelease();
  char v17 = v3[3];
  if (v17 < 2) {
    return (uint64_t)v3;
  }
  os_log_type_t v18 = v17 >> 1;
  os_log_type_t v16 = __OFSUB__(v18, v6);
  os_log_type_t v19 = v18 - v6;
  if (!v16)
  {
    v3[2] = v19;
    return (uint64_t)v3;
  }

    os_log_type_t v19 = v55;
    BOOL v20 = v68;
    sub_181BCECA4(v55, v68);
    __int16 v21 = v56;
    id v22 = v71;
LABEL_50:
    sub_181BCECE0(v21, v22);
    BOOL v15 = v19;
    os_log_type_t v16 = v20;
    goto LABEL_51;
  }

  if (!v68)
  {
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    goto LABEL_34;
  }

  if (v65 == v62 && v67 == v63)
  {
  }

  else
  {
    uint64_t v23 = sub_18264F4EC();
    BOOL result = 0LL;
  }

  if (v60 == v59 && v66 == v58) {
    goto LABEL_40;
  }
  os_log_type_t v24 = sub_18264F4EC();
  BOOL result = 0LL;
  if ((v24 & 1) != 0) {
    goto LABEL_40;
  }
  return result;
}

LABEL_35:
    if (!v17) {
      goto LABEL_37;
    }
LABEL_36:
    free(v17);
    goto LABEL_37;
  }

  if (!v24)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v18 = (os_log_s *)(id)gLogObj;
    uint64_t v23 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "-[NWSystemPathMonitor updateVPNMonitor]";
      _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s monitorWithNetworkDescription:endpoint:parameters: failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_34;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v18 = (os_log_s *)(id)gLogObj;
  __int16 v21 = type;
  id v22 = os_log_type_enabled(v18, type);
  if (!backtrace_string)
  {
    if (v22)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "-[NWSystemPathMonitor updateVPNMonitor]";
      _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s monitorWithNetworkDescription:endpoint:parameters: failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_34;
  }

  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "-[NWSystemPathMonitor updateVPNMonitor]";
    os_log_type_t v28 = 2082;
    uint64_t v29 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s monitorWithNetworkDescription:endpoint:parameters: failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v17) {
    goto LABEL_36;
  }
LABEL_37:

  objc_sync_exit(v2);
}

          free(backtrace_string);
          if (!default_input_handler) {
            return;
          }
          goto LABEL_50;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_udp_error";
          os_log_type_t v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_udp_error";
          os_log_type_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    BOOL v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_udp_error";
    os_log_type_t v16 = "%{public}s called with null protocol";
LABEL_48:
    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
    goto LABEL_49;
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_udp_error";
    default_input_handler = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v38 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        __int16 v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v41 = "nw_protocol_udp_error";
            uint64_t v42 = 2082;
            __int16 v43 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null udp, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

          goto LABEL_34;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_udp_error";
          os_log_type_t v16 = "%{public}s called with null udp, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_udp_error";
          os_log_type_t v16 = "%{public}s called with null udp, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    BOOL v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_udp_error";
    os_log_type_t v16 = "%{public}s called with null udp";
    goto LABEL_48;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_udp_error";
    default_input_handler = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v38 = 0;
    if (__nwlog_fault((const char *)default_input_handler, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_udp_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_48;
        }
      }

      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        unint64_t v35 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v41 = "nw_protocol_udp_error";
            uint64_t v42 = 2082;
            __int16 v43 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

          goto LABEL_34;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_udp_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_udp_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }

    _Block_object_dispose(buf, 8);
    if ((v39 & 1) != 0 && cf) {
      CFRelease(cf);
    }
LABEL_37:
    _Block_object_dispose(chars, 8);
    if ((v44 & 1) != 0 && v43) {
      CFRelease(v43);
    }
    if (Mutable) {
      os_release(Mutable);
    }
    os_release(v6);
    return;
  }

  if ((*(_BYTE *)(*(void *)(a1 + 40) + 198LL) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v18 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v19 = *(void *)(a1 + 40) + 114LL;
      *(_DWORD *)chars = 136446722;
      *(void *)&chars[4] = "nw_http_redirect_copy_endpoint_block_invoke";
      *(_WORD *)&chars[12] = 2082;
      *(void *)&chars[14] = v19;
      *(_WORD *)&chars[22] = 2080;
      uint64_t v41 = (uint64_t (*)(uint64_t, uint64_t))" ";
      _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sfailed to get URL endpoint from parameters",  chars,  0x20u);
    }
  }

  os_log_type_t v24 = *(char **)(v7 + 32);
  char v25 = v6;
  os_log_type_t v26 = v25;
  if (v24)
  {
    __int16 v27 = MEMORY[0x1895F87A8];
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke;
    *(void *)&v135 = &unk_189BB6060;
    *((void *)&v135 + 1) = v25;
    v136 = (os_log_type_t *)v24;
    v137 = "address";
    nw_hash_table_apply(v24, (uint64_t)buf);

    goto LABEL_36;
  }

  __int16 v27 = MEMORY[0x1895F87A8];
  __nwlog_obj();
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
  __int16 v67 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v133 = 0;
  if (__nwlog_fault(v67, type, &v133))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v69 = type[0];
      if (os_log_type_enabled(v68, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_181A5C000, v68, v69, "%{public}s called with null hash_table", buf, 0xCu);
      }
    }

    else if (v133)
    {
      v96 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v97 = type[0];
      v98 = os_log_type_enabled(v68, type[0]);
      if (v96)
      {
        if (v98)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v96;
          _os_log_impl( &dword_181A5C000,  v68,  v97,  "%{public}s called with null hash_table, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v96);
        goto LABEL_186;
      }

      if (v98)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_181A5C000, v68, v97, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v113 = type[0];
      if (os_log_type_enabled(v68, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl( &dword_181A5C000,  v68,  v113,  "%{public}s called with null hash_table, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v13) {
    free(v13);
  }
LABEL_4:
}

  if (v13) {
    free(v13);
  }
LABEL_4:
}

  return 1LL;
}

    if (v11) {
      free(v11);
    }

    goto LABEL_42;
  }

  v26.receiver = self;
  v26.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_candidate_manager;
  int v6 = -[NWConcrete_nw_candidate_manager init](&v26, sel_init);
  if (!v6)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v30 = "-[NWConcrete_nw_candidate_manager init:]";
    BOOL v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (__nwlog_fault(v15, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          char v30 = "-[NWConcrete_nw_candidate_manager init:]";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v27)
      {
        __int16 v21 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v22 = type;
        uint64_t v23 = os_log_type_enabled(v16, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            char v30 = "-[NWConcrete_nw_candidate_manager init:]";
            uint64_t v31 = 2082;
            char v32 = v21;
            _os_log_impl( &dword_181A5C000,  v16,  v22,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v21);
          goto LABEL_40;
        }

        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          char v30 = "-[NWConcrete_nw_candidate_manager init:]";
          _os_log_impl(&dword_181A5C000, v16, v22, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v25 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          char v30 = "-[NWConcrete_nw_candidate_manager init:]";
          _os_log_impl( &dword_181A5C000,  v16,  v25,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    free(backtrace_string);
    goto LABEL_47;
  }

  if ((nw_protocol_metadata_supports_replies(v3) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      id v33 = "nw_framer_message_create_reply";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s Protocol does not support replies, cannot create a reply",  buf,  0xCu);
    }

LABEL_10:
    message = 0LL;
    goto LABEL_14;
  }

  int v6 = v3;
  BOOL v7 = (nw_protocol_definition *)v3[1];

  message = nw_framer_protocol_create_message(v7);
  if (message)
  {
    v28[0] = MEMORY[0x1895F87A8];
    v28[1] = 3221225472LL;
    v28[2] = __nw_framer_message_create_reply_block_invoke;
    v28[3] = &unk_189BC6260;
    os_log_type_t v9 = v6;
    uint64_t v29 = v9;
    os_log_type_t v10 = *((void *)message + 4);
    if (v10)
    {
      __nw_framer_message_create_reply_block_invoke((uint64_t)v28, v10);
      os_log_type_t v11 = v29;
    }

    else
    {
      os_log_type_t v11 = v9;
    }

    os_log_type_t v13 = message;
  }

LABEL_14:
  return message;
}
          }
        }

        if (!v24) {
          goto LABEL_37;
        }
LABEL_36:
        free(v24);
        goto LABEL_37;
      }

      v46 = 0;
      memset(buf, 0, sizeof(buf));
      nw_nat64_write_prefix_to_string(a3, (char *)buf, 0x32u);
      os_log_type_t v19 = *(void *)(a1 + 32);
      if (v19)
      {
        if ((*(_BYTE *)(v19 + 346) & 0x20) != 0) {
          goto LABEL_19;
        }
        if (*(_BYTE *)(v19 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          BOOL v20 = (os_log_s *)(id)gconnectionLogObj;
          if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            goto LABEL_18;
          }
          __int16 v21 = *(void *)(a1 + 32);
          logging_description = nw_endpoint_get_logging_description(*(void **)(v21 + 24));
          *(_DWORD *)uint64_t v41 = 136446978;
          uint64_t v42 = "nw_resolver_create_dns_service_locked_block_invoke";
          __int16 v43 = 2082;
          *(void *)os_log_type_t v44 = v21 + 256;
          *(_WORD *)&v44[8] = 2082;
          *(void *)&v44[10] = logging_description;
          *(_WORD *)&v44[18] = 2082;
          *(void *)&v44[20] = buf;
          os_log_type_t v14 = v20;
          BOOL v15 = "%{public}s [C%{public}s] failed to synthesize IPv4 address %{public}s with prefix %{public}s";
          os_log_type_t v16 = 42;
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v20 = (os_log_s *)(id)gLogObj;
          if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            goto LABEL_18;
          }
          os_log_type_t v28 = *(void *)(a1 + 32);
          uint64_t v29 = *(_DWORD *)(v28 + 340);
          char v30 = nw_endpoint_get_logging_description(*(void **)(v28 + 24));
          *(_DWORD *)uint64_t v41 = 136446978;
          uint64_t v42 = "nw_resolver_create_dns_service_locked_block_invoke";
          __int16 v43 = 1024;
          *(_DWORD *)os_log_type_t v44 = v29;
          *(_WORD *)&v44[4] = 2082;
          *(void *)&v44[6] = v30;
          *(_WORD *)&v44[14] = 2082;
          *(void *)&v44[16] = buf;
          os_log_type_t v14 = v20;
          BOOL v15 = "%{public}s [R%u] failed to synthesize IPv4 address %{public}s with prefix %{public}s";
          os_log_type_t v16 = 38;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (os_log_s *)(id)gLogObj;
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          goto LABEL_18;
        }
        __int16 v27 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 32) + 24LL));
        *(_DWORD *)uint64_t v41 = 136446722;
        uint64_t v42 = "nw_resolver_create_dns_service_locked_block_invoke";
        __int16 v43 = 2082;
        *(void *)os_log_type_t v44 = v27;
        *(_WORD *)&v44[8] = 2082;
        *(void *)&v44[10] = buf;
        os_log_type_t v14 = v20;
        BOOL v15 = "%{public}s failed to synthesize IPv4 address %{public}s with prefix %{public}s";
        os_log_type_t v16 = 32;
      }

      _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_ERROR, v15, v41, v16);
LABEL_18:

LABEL_19:
      a3 += 4;
      if (!--v13)
      {
        int v6 = *(void *)(a1 + 32);
        break;
      }
    }
  }

  nw_array_append(*(void *)(v6 + 144), *(void **)(v6 + 24));
  os_log_type_t v37 = *(void *)(a1 + 32);
  uint64_t v36 = (void **)(a1 + 32);
  *(_DWORD *)(v37 + 84) = 0;
  nw_resolver_update_status_locked(*v36, 0LL);
  dispatch_group_leave(*((dispatch_group_t *)*v36 + 5));
  os_unfair_lock_unlock((os_unfair_lock_t)*v36 + 3);
}
}

          if (!v22)
          {
LABEL_36:
            os_log_type_t v9 = 0LL;
            goto LABEL_37;
          }

              goto LABEL_35;
            }

            if (!v53)
            {
              __nwlog_obj();
              uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v38 = type;
              if (os_log_type_enabled(v23, type))
              {
                char v39 = nw_group_descriptor_get_type(v3[8]);
                if (v39 > 4) {
                  __int16 v40 = "unknown";
                }
                else {
                  __int16 v40 = off_189BB74C8[v39];
                }
                *(_DWORD *)buf = 136446466;
                v56 = "nw_connection_group_copy_local_endpoint_for_message";
                os_log_type_t v57 = 2080;
                BOOL v58 = (void *)v40;
                _os_log_impl( &dword_181A5C000,  v23,  v38,  "%{public}s Unsupported group descriptor type: %s, backtrace limit exceeded",  buf,  0x16u);
              }

              goto LABEL_34;
            }

            id v33 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            __int16 v34 = type;
            unint64_t v35 = os_log_type_enabled(v23, type);
            if (!v33)
            {
              if (v35)
              {
                uint64_t v41 = nw_group_descriptor_get_type(v3[8]);
                if (v41 > 4) {
                  uint64_t v42 = "unknown";
                }
                else {
                  uint64_t v42 = off_189BB74C8[v41];
                }
                *(_DWORD *)buf = 136446466;
                v56 = "nw_connection_group_copy_local_endpoint_for_message";
                os_log_type_t v57 = 2080;
                BOOL v58 = (void *)v42;
                _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s Unsupported group descriptor type: %s, no backtrace",  buf,  0x16u);
              }

              goto LABEL_34;
            }

            if (v35)
            {
              uint64_t v36 = nw_group_descriptor_get_type(v3[8]);
              if (v36 > 4) {
                os_log_type_t v37 = "unknown";
              }
              else {
                os_log_type_t v37 = off_189BB74C8[v36];
              }
              *(_DWORD *)buf = 136446722;
              v56 = "nw_connection_group_copy_local_endpoint_for_message";
              os_log_type_t v57 = 2080;
              BOOL v58 = (void *)v37;
              os_log_type_t v59 = 2082;
              os_log_type_t v60 = v33;
              _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s Unsupported group descriptor type: %s, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v33);
          }

    free(backtrace_string);
    if (!v35) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }

  int v6 = (void *)*((void *)v3 + 8);
  if (!v6) {
    goto LABEL_25;
  }
  BOOL v7 = v6;
  os_log_type_t v8 = v7[2];

  if (v8 == 1)
  {
    os_log_type_t v9 = (nw_connection *)nw_connection_group_copy_connection_for_message(v3, v5);
    os_log_type_t v10 = v9;
    if (v9)
    {
      os_log_type_t v11 = nw_connection_copy_current_path(v9);
LABEL_48:

      goto LABEL_49;
    }

    *(void *)os_log_type_t type = 0LL;
    v70 = type;
    v71 = 0x3032000000LL;
    v72 = __Block_byref_object_copy__8579;
    v73 = __Block_byref_object_dispose__8580;
    v74 = 0LL;
    aBlock[0] = MEMORY[0x1895F87A8];
    aBlock[1] = 3221225472LL;
    aBlock[2] = __nw_connection_group_copy_path_for_message_block_invoke;
    aBlock[3] = &unk_189BC9210;
    v68 = type;
    __int16 v67 = v3;
    BOOL v20 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 43);
    v20[2](v20);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 43);

    __int16 v21 = (void *)nw_content_context_copy_local_endpoint(v5);
    id v22 = (void *)nw_content_context_copy_remote_endpoint(v5);
    uint64_t v23 = nw_content_context_copy_interface(v5);
    os_log_type_t v24 = (void *)v23;
    char v25 = (nw_parameters *)*((void *)v70 + 5);
    if (v25 && v21 && v22 && v23)
    {
      os_log_type_t v26 = (nw_interface *)nw_content_context_copy_interface(v5);
      nw_parameters_require_interface(v25, v26);

      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v22, *((void **)v70 + 5));
      if (evaluator_for_endpoint)
      {
        os_log_type_t v28 = (os_unfair_lock_s *)((char *)evaluator_for_endpoint + 96);
        uint64_t v29 = evaluator_for_endpoint;
        os_unfair_lock_lock(v28);
        os_log_type_t v11 = (nw_path *)v29[6];
        os_unfair_lock_unlock(v28);

LABEL_47:
        _Block_object_dispose(type, 8);

        goto LABEL_48;
      }

      uint64_t v29 = 0LL;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v29 = (id *)(id)gLogObj;
      if (os_log_type_enabled((os_log_t)v29, OS_LOG_TYPE_ERROR))
      {
        char v30 = (void *)*((void *)v70 + 5);
        *(_DWORD *)buf = 136447234;
        v77 = "nw_connection_group_copy_path_for_message";
        v78 = 2112;
        v79 = v30;
        v80 = 2112;
        v81 = (char *)v21;
        v82 = 2112;
        v83 = v22;
        v84 = 2112;
        v85 = v24;
        _os_log_impl( &dword_181A5C000,  (os_log_t)v29,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to set up parameters %@ for local %@, remote %@, interface %@",  buf,  0x34u);
      }
    }

    os_log_type_t v11 = 0LL;
    goto LABEL_47;
  }

  os_log_type_t v12 = (void *)*((void *)v3 + 8);
  if (!v12) {
    goto LABEL_25;
  }
  os_log_type_t v13 = v12;
  os_log_type_t v14 = v13[2];

  if (v14 == 2) {
    goto LABEL_11;
  }
  BOOL v15 = (void *)*((void *)v3 + 8);
  if (!v15)
  {
LABEL_25:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v34 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v77 = "nw_connection_group_copy_path_for_message";
    unint64_t v35 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v36 = (os_log_s *)(id)gLogObj;
      os_log_type_t v37 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl(&dword_181A5C000, v36, v37, "%{public}s Group descriptor is not set", buf, 0xCu);
      }

      goto LABEL_41;
    }

    if (!v75)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v36 = (os_log_s *)(id)gLogObj;
      uint64_t v41 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl( &dword_181A5C000,  v36,  v41,  "%{public}s Group descriptor is not set, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_41;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v36 = (os_log_s *)(id)gLogObj;
    char v39 = type[0];
    __int16 v40 = os_log_type_enabled(v36, type[0]);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        v77 = "nw_connection_group_copy_path_for_message";
        _os_log_impl(&dword_181A5C000, v36, v39, "%{public}s Group descriptor is not set, no backtrace", buf, 0xCu);
      }

      goto LABEL_41;
    }

    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      v77 = "nw_connection_group_copy_path_for_message";
      v78 = 2082;
      v79 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v36,  v39,  "%{public}s Group descriptor is not set, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_34;
  }

  os_log_type_t v16 = v15;
  char v17 = v16[2];

  if (v17 != 4)
  {
    if (*((void *)v3 + 8))
    {
      __nwlog_obj();
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue();
      char v32 = nw_group_descriptor_get_type(*((void **)v3 + 8));
      if (v32 > 4) {
        id v33 = "unknown";
      }
      else {
        id v33 = off_189BB74C8[v32];
      }
      *(_DWORD *)buf = 136446466;
      v77 = "nw_connection_group_copy_path_for_message";
      v78 = 2080;
      v79 = (void *)v33;
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v75 = 0;
      if (__nwlog_fault(v35, type, &v75))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          uint64_t v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v43 = type[0];
          if (os_log_type_enabled(v36, type[0]))
          {
            os_log_type_t v44 = nw_group_descriptor_get_type(*((void **)v3 + 8));
            if (v44 > 4) {
              uint64_t v45 = "unknown";
            }
            else {
              uint64_t v45 = off_189BB74C8[v44];
            }
            *(_DWORD *)buf = 136446466;
            v77 = "nw_connection_group_copy_path_for_message";
            v78 = 2080;
            v79 = (void *)v45;
            _os_log_impl(&dword_181A5C000, v36, v43, "%{public}s Unsupported group descriptor type: %s", buf, 0x16u);
          }

  if (v13) {
    free(v13);
  }
  BOOL v7 = 0LL;
  if (v5 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v9 = *(void *)(a1 + 88);
      if (v9)
      {
        os_log_type_t v10 = v9 - 1;
        *(void *)(a1 + 88) = v10;
        if (!v10)
        {
          os_log_type_t v11 = *(void (***)(void))(a1 + 64);
          if (v11)
          {
            *(void *)(a1 + 64) = 0LL;
            v11[2](v11);
            _Block_release(v11);
          }

          if ((*(_BYTE *)(a1 + 72) & 1) != 0)
          {
            os_log_type_t v12 = *(const void **)(a1 + 64);
            if (v12) {
              _Block_release(v12);
            }
          }

          free((void *)a1);
        }
      }
    }
  }

  return v7;
}

  if (v5) {
LABEL_35:
  }
    free(v5);
}

  if (http_authentication) {
    os_release(http_authentication);
  }
  return 1LL;
}

  if (v8) {
    free(v8);
  }
  return 1LL;
}
}

        goto LABEL_35;
      }

      if (!v15)
      {
        __nwlog_obj();
        BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_flow_replay_add_input_handler";
          os_log_type_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_33;
        }

        goto LABEL_34;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      os_log_type_t v12 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_flow_replay_add_input_handler";
          os_log_type_t v9 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_33;
        }

        goto LABEL_34;
      }

      if (!v12) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v18 = "nw_flow_replay_add_input_handler";
      os_log_type_t v19 = 2082;
      BOOL v20 = backtrace_string;
      os_log_type_t v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_23;
    }
  }

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_35;
  }

  id v3 = a3[5];
  if (v3)
  {
    nw_frame_free_buffer((uint64_t)a1);
    nw_frame_reset((uint64_t)a1, 0LL, 0, 0LL, 0LL);
    int v5 = *((void *)a1 + 2);
    int v6 = (void *)*((void *)a1 + 3);
    if (v5)
    {
      *(void *)(v5 + 24) = v6;
      int v6 = (void *)*((void *)a1 + 3);
    }

    else
    {
      *(void *)(v3 + 80) = v6;
    }

    void *v6 = v5;
    *((void *)a1 + 2) = 0LL;
    *((void *)a1 + 3) = 0LL;
    os_release(a1);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_protocol_trainer_frame_finalizer";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v15 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_trainer_frame_finalizer";
    os_log_type_t v10 = "%{public}s called with null trainer";
    goto LABEL_34;
  }

  if (!v15)
  {
    os_log_type_t v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_trainer_frame_finalizer";
    os_log_type_t v10 = "%{public}s called with null trainer, backtrace limit exceeded";
    goto LABEL_34;
  }

  os_log_type_t v13 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = (os_log_s *)__nwlog_obj();
  os_log_type_t v9 = type;
  os_log_type_t v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_trainer_frame_finalizer";
    os_log_type_t v10 = "%{public}s called with null trainer, no backtrace";
    goto LABEL_34;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v18 = "nw_protocol_trainer_frame_finalizer";
    os_log_type_t v19 = 2082;
    BOOL v20 = v13;
    _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null trainer, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v13);
  if (v7) {
LABEL_36:
  }
    free(v7);
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (!v4 && *((_WORD *)v3 + 120))
  {
    char v25 = *((void *)v3 + 2);
    if (v25 && !nw_path_parameters_get_logging_disabled(*(void *)(v25 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      os_log_type_t v26 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
      {
        __int16 v27 = v3;

        *(_DWORD *)buf = 136446466;
        v49 = "nw_listener_adjust_awdl_usage_on_queue";
        os_log_type_t v50 = 2082;
        v51 = (char *)v27 + 42;
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_INFO,  "%{public}s [%{public}s] Start advertising over AWDL",  buf,  0x16u);
      }
    }

    os_log_type_t v28 = v3;
    nw_context_assert_queue(*((void **)v3 + 3));
    if (*((_DWORD *)v28 + 32) != 2 || (*((_BYTE *)v28 + 302) & 1) != 0) {
      goto LABEL_58;
    }
    goto LABEL_57;
  }

  if (v4 && !*((_WORD *)v3 + 120))
  {
    uint64_t v29 = *((void *)v3 + 2);
    if (v29 && !nw_path_parameters_get_logging_disabled(*(void *)(v29 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
      }
      char v30 = (os_log_s *)(id)glistenerLogObj;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
      {
        uint64_t v31 = v3;

        *(_DWORD *)buf = 136446466;
        v49 = "nw_listener_adjust_awdl_usage_on_queue";
        os_log_type_t v50 = 2082;
        v51 = (char *)v31 + 42;
        _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_INFO,  "%{public}s [%{public}s] Stop advertising over AWDL",  buf,  0x16u);
      }
    }

    os_log_type_t v28 = v3;
    nw_context_assert_queue(*((void **)v3 + 3));
    if (*((_DWORD *)v28 + 32) != 2 || (*((_BYTE *)v28 + 302) & 1) != 0) {
      goto LABEL_58;
    }
LABEL_57:
    nw_listener_stop_advertising_on_queue(v28);
    nw_listener_start_advertising_on_queue(v28);
LABEL_58:
  }
}

  if (v17) {
    free(v17);
  }
  os_log_type_t v10 = 0LL;
LABEL_17:

  return v10;
}

                  goto LABEL_85;
                }

                if (!v147)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v36 = (os_log_s *)(id)gLogObj;
                  id v62 = type;
                  if (os_log_type_enabled(v36, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                    _os_log_impl( &dword_181A5C000,  v36,  v62,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  buf,  0xCu);
                  }

                  goto LABEL_34;
                }

                uint64_t v42 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                __int16 v43 = (os_log_s *)(id)gLogObj;
                os_log_type_t v44 = type;
                uint64_t v45 = os_log_type_enabled(v43, type);
                if (v42)
                {
                  if (v45)
                  {
                    *(_DWORD *)buf = 136446466;
                    v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                    v151 = 2082;
                    v152 = v42;
                    _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(v42);
                  if (!v35) {
                    goto LABEL_87;
                  }
                  goto LABEL_86;
                }

                if (v45)
                {
                  *(_DWORD *)buf = 136446210;
                  v150 = "nw_parameters_create_quic_stream_with_tls_fallback";
                  _os_log_impl( &dword_181A5C000,  v43,  v44,  "%{public}s nw_parameters_create failed, no backtrace",  buf,  0xCu);
                }
              }

      free(backtrace_string);
    }
  }

  if (v8) {
    free(v8);
  }
  int v6 = 0LL;
LABEL_44:

  return v6;
}

  if (v8) {
    free(v8);
  }
  return 0LL;
}

    if (v17) {
      free(v17);
    }
    goto LABEL_36;
  }

  nw_context_assert_queue(*((void **)v10 + 3));
  os_log_type_t v12 = *((void *)v10 + 55);
  if (!v12)
  {
    os_log_type_t v13 = nw_array_create();
    os_log_type_t v14 = (void *)*((void *)v10 + 55);
    *((void *)v10 + 55) = v13;

    os_log_type_t v12 = *((void *)v10 + 55);
    if (!v12)
    {
      LOBYTE(v15) = 0;
      goto LABEL_17;
    }
  }

  if (*(void *)(v12 + 24) - *(void *)(v12 + 16) > 0x7F7uLL)
  {
LABEL_36:
    LOBYTE(v15) = -1;
    goto LABEL_37;
  }

  BOOL v15 = (uint64_t)(*(void *)(v12 + 24) - *(void *)(v12 + 16)) >> 3;
LABEL_17:
  nw_array_append(v12, v11);
LABEL_37:

LABEL_38:
  *(void *)buf = v3;
  *(_DWORD *)&buf[8] = **(_DWORD **)(a1 + 56);
  os_log_type_t v24 = *(void **)(a1 + 32);
  char v25 = *(void *)(a1 + 40);
  if (v25) {
    os_log_type_t v26 = WORD1(v25) ^ WORD2(v25) ^ HIWORD(v25) ^ v25;
  }
  else {
    os_log_type_t v26 = 0;
  }
  *(_WORD *)&buf[12] = v26;
  *(_WORD *)&buf[14] = v15;
  nw_connection_add_timestamp_locked_on_nw_queue(v24, buf);
  __int16 v27 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
  if (v27)
  {
    os_log_type_t v28 = *(void *)(*(void *)(a1 + 32) + 328LL);
    if (!v28)
    {
      uint64_t v29 = nw_array_create();
      char v30 = *(void *)(a1 + 32);
      uint64_t v31 = *(void **)(v30 + 328);
      *(void *)(v30 + 328) = v29;

      os_log_type_t v28 = *(void *)(*(void *)(a1 + 32) + 328LL);
      if (!v28) {
        goto LABEL_49;
      }
    }

    id v33 = *(nw_endpoint_t **)(v28 + 16);
    char v32 = *(nw_endpoint_t **)(v28 + 24);
    if (v33 != v32)
    {
      while (*v33 != v27)
      {
        if (++v33 == v32)
        {
          id v33 = *(nw_endpoint_t **)(v28 + 24);
          break;
        }
      }
    }

    if (v33 == v32) {
LABEL_49:
    }
      nw_array_append(v28, v27);
  }

LABEL_51:
  __int16 v34 = *(void **)(a1 + 40);
  if (!v34) {
    goto LABEL_155;
  }
  unint64_t v35 = *(_WORD **)(a1 + 56);
  if (*(void *)(a1 + 48))
  {
    if (v35 && *v35 == 1 && v35[1] != 1)
    {
      *(void *)aBlock = 0LL;
      *(void *)&aBlock[8] = 0LL;
      nw_endpoint_handler_get_client_id(v34, aBlock);
      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v38 = (os_log_s *)(id)gconnectionLogObj;
        else {
          is_dry_run = nw_endpoint_handler_is_dry_run(*(void **)(a1 + 40));
        }
        if (os_log_type_enabled(v38, is_dry_run))
        {
          id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
          v74 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
          v75 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
          v516 = v74;
          logging_description = nw_endpoint_get_logging_description(v75);
          v77 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
          v78 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
          v79 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          v80 = *(unsigned __int16 **)(a1 + 56);
          if (v80)
          {
            v81 = *v80;
            else {
              v82 = off_189BBC170[v81 - 1];
            }
            v94 = nw_endpoint_event_event_string(v81, v80[1]);
          }

          else
          {
            v82 = "null";
            v94 = "null";
          }

          v95 = *(void *)(a1 + 48);
          *(_DWORD *)buf = 136449282;
          *(void *)&uint8_t buf[4] = id_string;
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v516;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = logging_description;
          *(_WORD *)v524 = 2082;
          *(void *)&v524[2] = v77;
          *(_WORD *)&v524[10] = 2082;
          *(void *)&v524[12] = v78;
          *(_WORD *)&v524[20] = 2114;
          *(void *)&v524[22] = v79;
          v525 = 2082;
          v526 = v82;
          v527 = 2082;
          v528 = v94;
          v529 = 1024;
          v530 = v519 / 1000;
          v531 = 1024;
          v532 = v519 % 1000;
          v533 = 2114;
          *(void *)v534 = v95;
          *(_WORD *)&v534[8] = 1042;
          *(_DWORD *)&v534[10] = 16;
          v535 = 2098;
          v536 = aBlock;
          _os_log_impl( &dword_181A5C000,  v38,  is_dry_run,  "[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] event: %{public}s:%{public}s @%u.%03us , error %{public}@, uuid: %{public,uuid_t}.16P",  buf,  0x78u);
        }

        goto LABEL_145;
      }
    }

    else
    {
      uint64_t v36 = v34;
      os_log_type_t v37 = (v36[268] & 0x20) == 0;

      if (v37)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v38 = (os_log_s *)(id)gconnectionLogObj;
        else {
          char v39 = nw_endpoint_handler_is_dry_run(*(void **)(a1 + 40));
        }
        if (os_log_type_enabled(v38, v39))
        {
          __int16 v43 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
          os_log_type_t v44 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
          uint64_t v45 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
          v46 = nw_endpoint_get_logging_description(v45);
          v47 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
          v48 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
          v49 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          os_log_type_t v50 = v49;
          v51 = *(unsigned __int16 **)(a1 + 56);
          if (v51)
          {
            os_log_type_t v52 = *v51 - 1;
            if (v52 > 6) {
              v53 = "unknown";
            }
            else {
              v53 = off_189BBC170[v52];
            }
            __int16 v67 = v51[1];
            switch(v52)
            {
              case 0u:
                v68 = off_189BBC1A8;
                goto LABEL_121;
              case 1u:
                LOWORD(v67) = v67 - 1;
                v68 = off_189BBC1F8;
                goto LABEL_121;
              case 2u:
                v68 = off_189BBC238;
                goto LABEL_121;
              case 3u:
                v68 = off_189BBC2B0;
                goto LABEL_121;
              case 4u:
                v68 = off_189BBC2E0;
                goto LABEL_121;
              case 5u:
                v68 = off_189BBC320;
                goto LABEL_121;
              case 6u:
                v68 = off_189BBC308;
LABEL_121:
                v65 = v68[(unsigned __int16)v67];
                break;
              default:
LABEL_122:
                v65 = "unknown";
                break;
            }
          }

          else
          {
            v53 = "null";
            v65 = "null";
          }

          v93 = *(void *)(a1 + 48);
          *(_DWORD *)buf = 136448770;
          *(void *)&uint8_t buf[4] = v43;
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v44;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = v46;
          *(_WORD *)v524 = 2082;
          *(void *)&v524[2] = v47;
          *(_WORD *)&v524[10] = 2082;
          *(void *)&v524[12] = v48;
          *(_WORD *)&v524[20] = 2114;
          *(void *)&v524[22] = v49;
          v525 = 2082;
          v526 = v53;
          v527 = 2082;
          v528 = v65;
          v529 = 1024;
          v530 = v519 / 1000;
          v531 = 1024;
          v532 = v519 % 1000;
          v533 = 2114;
          *(void *)v534 = v93;
          _os_log_impl( &dword_181A5C000,  v38,  v39,  "[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] event: %{public}s:%{public}s @%u.%03us , error %{public}@",  buf,  0x68u);
        }

      free(v21);
      if (!v13) {
        goto LABEL_7;
      }
      goto LABEL_51;
    }

    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_authentication_credential_storage_set_default_credential";
    os_log_type_t v16 = "%{public}s called with null challenge";
LABEL_48:
    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
    goto LABEL_49;
  }

  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "nw_authentication_credential_storage_set_default_credential";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v28 = "nw_authentication_credential_storage_set_default_credential";
        os_log_type_t v16 = "%{public}s called with null credential";
        goto LABEL_48;
      }

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  if (v16) {
    free(v16);
  }
}

  if (v14) {
    free(v14);
  }
  return 0LL;
}

    free(v16);
    goto LABEL_35;
  }

  *a2 = 0LL;
  a2[1] = 0LL;
  *((_DWORD *)a2 + 6) = 0;
  a2[2] = 0LL;
  int v5 = nw_connection_copy_connected_local_endpoint(v3[2]);
  int v6 = v5;
  if (v5)
  {
    BOOL v7 = v5;
    os_log_type_t v8 = [v7 type];

    if (v8 == 1)
    {
      address = nw_endpoint_get_address((nw_endpoint_t)v7);
      if (address)
      {
        os_log_type_t v10 = address;
        sa_len = address->sa_len;
        if (sa_len < 0x1D)
        {
          memcpy(a2, address, sa_len);
          os_log_type_t v14 = 1LL;
          goto LABEL_12;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          os_log_type_t v13 = v10->sa_len;
          *(_DWORD *)buf = 136446466;
          __int16 v34 = "tcp_connection_get_local";
          unint64_t v35 = 1024;
          LODWORD(v36) = v13;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s Local address length (%u) too long",  buf,  0x12u);
        }
      }
    }
  }

  os_log_type_t v14 = 0LL;
LABEL_12:

LABEL_36:
  return v14;
}

    free(v16);
    goto LABEL_35;
  }

  *a2 = 0LL;
  a2[1] = 0LL;
  *((_DWORD *)a2 + 6) = 0;
  a2[2] = 0LL;
  int v5 = nw_connection_copy_connected_remote_endpoint(v3[2]);
  int v6 = v5;
  if (v5)
  {
    BOOL v7 = v5;
    os_log_type_t v8 = [v7 type];

    if (v8 == 1)
    {
      address = nw_endpoint_get_address((nw_endpoint_t)v7);
      if (address)
      {
        os_log_type_t v10 = address;
        sa_len = address->sa_len;
        if (sa_len < 0x1D)
        {
          memcpy(a2, address, sa_len);
          os_log_type_t v14 = 1LL;
          goto LABEL_12;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          os_log_type_t v13 = v10->sa_len;
          *(_DWORD *)buf = 136446466;
          __int16 v34 = "tcp_connection_get_remote";
          unint64_t v35 = 1024;
          LODWORD(v36) = v13;
          _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s Remote address length (%u) too long",  buf,  0x12u);
        }
      }
    }
  }

  os_log_type_t v14 = 0LL;
LABEL_12:

LABEL_36:
  return v14;
}

    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_35;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v8 = handle[115];
        *(_DWORD *)buf = 136446978;
        __int16 v21 = "nw_protocol_webtransport_session_get_input_frames";
        id v22 = 2082;
        uint64_t v23 = (char *)(handle + 116);
        os_log_type_t v24 = 2080;
        char v25 = " ";
        os_log_type_t v26 = 1024;
        __int16 v27 = v8;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> called, ignoring",  buf,  0x26u);
      }
    }

    return 0LL;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v21 = "nw_protocol_webtransport_session_get_input_frames";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v18 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_webtransport_session_get_input_frames";
    os_log_type_t v13 = "%{public}s called with null webtransport_session";
    goto LABEL_34;
  }

  if (!v18)
  {
    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_webtransport_session_get_input_frames";
    os_log_type_t v13 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_34;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  os_log_type_t v11 = (os_log_s *)__nwlog_obj();
  os_log_type_t v12 = type;
  char v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (!v17) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_webtransport_session_get_input_frames";
    os_log_type_t v13 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_34;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v21 = "nw_protocol_webtransport_session_get_input_frames";
    id v22 = 2082;
    uint64_t v23 = v16;
    _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v10) {
    goto LABEL_36;
  }
  return 0LL;
}

    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_35;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v8 = handle[115];
        *(_DWORD *)buf = 136446978;
        __int16 v21 = "nw_protocol_webtransport_session_get_output_frames";
        id v22 = 2082;
        uint64_t v23 = (char *)(handle + 116);
        os_log_type_t v24 = 2080;
        char v25 = " ";
        os_log_type_t v26 = 1024;
        __int16 v27 = v8;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> called, ignoring",  buf,  0x26u);
      }
    }

    return 0LL;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v21 = "nw_protocol_webtransport_session_get_output_frames";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v18 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_webtransport_session_get_output_frames";
    os_log_type_t v13 = "%{public}s called with null webtransport_session";
    goto LABEL_34;
  }

  if (!v18)
  {
    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_webtransport_session_get_output_frames";
    os_log_type_t v13 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_34;
  }

  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  os_log_type_t v11 = (os_log_s *)__nwlog_obj();
  os_log_type_t v12 = type;
  char v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (!v17) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_webtransport_session_get_output_frames";
    os_log_type_t v13 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_34;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v21 = "nw_protocol_webtransport_session_get_output_frames";
    id v22 = 2082;
    uint64_t v23 = v16;
    _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v10) {
    goto LABEL_36;
  }
  return 0LL;
}

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_35;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        id v4 = handle[115];
        *(_DWORD *)buf = 136446978;
        char v17 = "nw_protocol_webtransport_session_finalize_output_frames";
        os_log_type_t v18 = 2082;
        os_log_type_t v19 = (char *)(handle + 116);
        BOOL v20 = 2080;
        __int16 v21 = " ";
        id v22 = 1024;
        uint64_t v23 = v4;
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> called, ignoring",  buf,  0x26u);
      }
    }

    return 0LL;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v17 = "nw_protocol_webtransport_session_finalize_output_frames";
  int v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    os_log_type_t v9 = "%{public}s called with null webtransport_session";
    goto LABEL_34;
  }

  if (!v14)
  {
    BOOL v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    os_log_type_t v9 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_34;
  }

  os_log_type_t v12 = (char *)__nw_create_backtrace_string();
  BOOL v7 = (os_log_s *)__nwlog_obj();
  os_log_type_t v8 = type;
  os_log_type_t v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    os_log_type_t v9 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_34;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    char v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    os_log_type_t v18 = 2082;
    os_log_type_t v19 = v12;
    _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v12);
  if (v6) {
    goto LABEL_36;
  }
  return 0LL;
}

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_35;
  }

  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        id v4 = handle[115];
        *(_DWORD *)buf = 136446978;
        os_log_type_t v16 = "nw_protocol_webtransport_session_output_finished";
        char v17 = 2082;
        os_log_type_t v18 = (char *)(handle + 116);
        os_log_type_t v19 = 2080;
        BOOL v20 = " ";
        __int16 v21 = 1024;
        id v22 = v4;
        _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_webtransport_session_output_finished";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v6 = (os_log_s *)__nwlog_obj();
    BOOL v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_protocol_webtransport_session_output_finished";
    os_log_type_t v8 = "%{public}s called with null webtransport_session";
    goto LABEL_34;
  }

  if (!v13)
  {
    int v6 = (os_log_s *)__nwlog_obj();
    BOOL v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_protocol_webtransport_session_output_finished";
    os_log_type_t v8 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_34;
  }

  os_log_type_t v11 = (char *)__nw_create_backtrace_string();
  int v6 = (os_log_s *)__nwlog_obj();
  BOOL v7 = type;
  os_log_type_t v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_35;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_protocol_webtransport_session_output_finished";
    os_log_type_t v8 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_34;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v16 = "nw_protocol_webtransport_session_output_finished";
    char v17 = 2082;
    os_log_type_t v18 = v11;
    _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null webtransport_session, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v5) {
    goto LABEL_36;
  }
}

      BOOL v15 = 2;
      *((_DWORD *)handle + 46) = 2;
      if (a2)
      {
LABEL_21:
        default_input_handler = (uint64_t)a2[2].default_input_handler;
        if (default_input_handler == -1)
        {
          if ((v7 & 8) != 0)
          {
            default_input_handler = -2LL;
            goto LABEL_40;
          }

          if (v14 == 3)
          {
            default_input_handler = -1LL;
            goto LABEL_40;
          }

          uint64_t v45 = BYTE4(a2[8].output_handler);
          v46 = v45 & 1;
          if (v15 == 3)
          {
            output_handler = a2[4].output_handler;
            default_input_handler = v46 | (4LL * (void)output_handler) | 2;
            a2[4].output_handler = (nw_protocol *)&output_handler->flow_id[1];
            a2[4].handle = (void *)default_input_handler;
            if ((v45 & 2) != 0) {
              goto LABEL_40;
            }
            char v17 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_40;
            }
            v48 = *(_DWORD *)&a2[7].flow_id[12];
            *(_DWORD *)buf = 136447234;
            v92 = "nw_webtransport_stream_allocate_new_id";
            v93 = 2082;
            p_identifier = (char *)&a2[7].identifier;
            v95 = 2080;
            v96 = " ";
            v97 = 1024;
            v98 = v48;
            v99 = 2048;
            v100 = default_input_handler;
            os_log_type_t v19 = "%{public}s %{public}s%s<i%u> allocated new stream id %llu for unidirectional stream";
          }

          else
          {
            v53 = a2[3].output_handler;
            default_input_handler = (4 * (_DWORD)v53) | v46;
            a2[3].output_handler = (nw_protocol *)&v53->flow_id[1];
            a2[3].handle = (void *)default_input_handler;
            if ((v45 & 2) != 0) {
              goto LABEL_40;
            }
            char v17 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_40;
            }
            os_log_type_t v54 = *(_DWORD *)&a2[7].flow_id[12];
            *(_DWORD *)buf = 136447234;
            v92 = "nw_webtransport_stream_allocate_new_id";
            v93 = 2082;
            p_identifier = (char *)&a2[7].identifier;
            v95 = 2080;
            v96 = " ";
            v97 = 1024;
            v98 = v54;
            v99 = 2048;
            v100 = default_input_handler;
            os_log_type_t v19 = "%{public}s %{public}s%s<i%u> allocated new stream id %llu for bidirectional stream";
          }
        }

        else
        {
          if ((BYTE4(a2[8].output_handler) & 2) != 0) {
            goto LABEL_40;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v17 = (os_log_s *)gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_40;
          }
          os_log_type_t v18 = *(_DWORD *)&a2[7].flow_id[12];
          *(_DWORD *)buf = 136447234;
          v92 = "nw_webtransport_stream_allocate_new_id";
          v93 = 2082;
          p_identifier = (char *)&a2[7].identifier;
          v95 = 2080;
          v96 = " ";
          v97 = 1024;
          v98 = v18;
          v99 = 2048;
          v100 = default_input_handler;
          os_log_type_t v19 = "%{public}s %{public}s%s<i%u> new incoming stream id %llu";
        }

        _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, v19, buf, 0x30u);
LABEL_40:
        *((void *)handle + 8) = default_input_handler;
        goto LABEL_41;
      }

    if (v13) {
      free(v13);
    }
    goto LABEL_36;
  }

  if (gLogDatapath)
  {
    int v6 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v28 = "nw_http2_transport_session_send";
      uint64_t v29 = 2082;
      *(void *)char v30 = a1 + 205;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s already in session send, skipping",  buf,  0x16u);
    }
  }

        if ((*(_BYTE *)(v3 + 158) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v27 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v28 = *(_DWORD *)(v580 + 372);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_match_idle_connection_with_pending_stream";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v580 + 74;
            *(_WORD *)&buf[22] = 2080;
            v608 = (uint64_t)" ";
            *(_WORD *)v609 = 1024;
            *(_DWORD *)&v609[2] = v28;
            uint64_t v29 = "%{public}s %{public}s%s<i%u> cannot make new connection, waiting for other requests to finish";
LABEL_40:
            _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_DEBUG, v29, buf, 0x26u);
            return;
          }
        }

        return;
      }

      if ((*(_BYTE *)(v5 + 158) & 1) == 0)
      {
        if (*((_BYTE *)v4 + 1537))
        {
          v464 = v4;
          v465 = (os_log_s *)__nwlog_obj();
          v466 = os_log_type_enabled(v465, OS_LOG_TYPE_DEBUG);
          id v4 = v464;
          id v3 = v580;
          if (v466)
          {
            v467 = v5 + 74;
            v468 = *(void *)(v5 + 256);
            v469 = *(_DWORD *)(*(void *)(v5 + 248) + 372LL);
            if (v468) {
              LODWORD(v468) = *(_DWORD *)(v468 + 860);
            }
            int v5 = v579;
            v470 = *(_DWORD *)(v579 + 424);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_http1_create_connection_for_stream_if_allowed";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v467;
            *(_WORD *)&buf[22] = 2080;
            v608 = (uint64_t)" ";
            *(_WORD *)v609 = 1024;
            *(_DWORD *)&v609[2] = v469;
            *(_WORD *)&v609[6] = 1024;
            *(_DWORD *)&v609[8] = v468;
            *(_WORD *)&v609[12] = 1024;
            *(_DWORD *)&v609[14] = v470;
            _os_log_impl( &dword_181A5C000,  v465,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> width allows new connection, creating",  buf,  0x32u);
            id v3 = v580;
            id v4 = v464;
          }
        }
      }

      if ((*(_WORD *)(v5 + 428) & 0x1000) == 0)
      {
LABEL_376:
        if (*(void *)(v5 + 32))
        {
          if ((*(_BYTE *)(v5 + 158) & 1) == 0)
          {
            if (*((_BYTE *)v4 + 1537))
            {
              v481 = (os_log_s *)__nwlog_obj();
              if (os_log_type_enabled(v481, OS_LOG_TYPE_DEBUG))
              {
                v482 = v5 + 74;
                v483 = *(void *)(v5 + 256);
                v484 = *(_DWORD *)(*(void *)(v5 + 248) + 372LL);
                if (v483) {
                  LODWORD(v483) = *(_DWORD *)(v483 + 860);
                }
                int v5 = v579;
                v485 = *(_DWORD *)(v579 + 424);
                v486 = *(void *)(v579 + 32);
                *(_DWORD *)buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_http1_establish_new_connection_for_stream";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v482;
                *(_WORD *)&buf[22] = 2080;
                v608 = (uint64_t)" ";
                *(_WORD *)v609 = 1024;
                *(_DWORD *)&v609[2] = v484;
                *(_WORD *)&v609[6] = 1024;
                *(_DWORD *)&v609[8] = v483;
                *(_WORD *)&v609[12] = 1024;
                *(_DWORD *)&v609[14] = v485;
                *(_WORD *)&v609[18] = 2048;
                *(void *)&v609[20] = v486;
                _os_log_impl( &dword_181A5C000,  v481,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> using already established output handler %p",  buf,  0x3Cu);
              }
            }
          }

          v575 = *(_OWORD **)(v5 + 32);
          if (v575)
          {
            v259 = *(void **)(v5 + 336);
            if (v259)
            {
              v260 = *(void **)(v5 + 320);
              if (v260)
              {
                v261 = calloc(1uLL, 0x370uLL);
                if (v261) {
                  goto LABEL_383;
                }
                v492 = (os_log_s *)__nwlog_obj();
                os_log_type_enabled(v492, OS_LOG_TYPE_ERROR);
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "strict_calloc";
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = 1LL;
                *(_WORD *)&buf[22] = 2048;
                v608 = 880LL;
                v493 = (void *)_os_log_send_and_compose_impl();
                if (!__nwlog_abort((uint64_t)v493))
                {
                  free(v493);
LABEL_383:
                  bzero(v261, 0x370uLL);
                  if (nw_protocol_http1_identifier::onceToken != -1) {
                    dispatch_once(&nw_protocol_http1_identifier::onceToken, &__block_literal_global_39881);
                  }
                  v262 = v580;
                  *((void *)v261 + 2) = &nw_protocol_http1_identifier::http1_protocol_identifier;
                  if (nw_protocol_http1_get_callbacks(void)::onceToken != -1)
                  {
                    dispatch_once(&nw_protocol_http1_get_callbacks(void)::onceToken, &__block_literal_global_17_39683);
                    v262 = v580;
                  }

                  *((void *)v261 + 3) = &nw_protocol_http1_get_callbacks(void)::http1_protocol_callbacks;
                  *((_DWORD *)v261 + 46) = 3;
                  *((void *)v261 + 22) = v261;
                  *((void *)v261 + 5) = v261 + 10;
                  *((void *)v261 + 60) = v262;
                  nw_protocol_set_output_handler((uint64_t)v261, (uint64_t)v575);
                  *(void *)buf = os_retain(v259);
                  nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v261 + 47), buf);
                  *(void *)buf = os_retain(v260);
                  nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v261 + 46), buf);
                  *(void *)buf = nw_parameters_copy_context(v260);
                  nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v261 + 31), buf);
                  *((void *)v261 + 24) = *(void *)(v262 + 192);
                  v263 = MEMORY[0x1895F87A8];
                  v264 = (void *)*((void *)v261 + 62);
                  *(void *)os_log_type_t type = MEMORY[0x1895F87A8];
                  v592 = 0x40000000LL;
                  v593 = (uint64_t)___ZL26nw_http1_connection_createP11nw_protocolP17nw_protocol_http1P11nw_endpointP13nw_parameters_block_invoke;
                  v594 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_tmp_40_39882;
                  v595 = (void (*)(uint64_t))v261;
                  *(void *)buf = nw_http_connection_create_metadata(v264, type, 0LL);
                  nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(v261 + 48), buf);
                  nw_http_connection_metadata_set_version(*((void **)v261 + 96), 3);
                  nw_http_connection_metadata_set_shared_connection_pool_metadata( *((void **)v261 + 96),  *(void **)(v262 + 312));
                  *((void *)v261 + 77) = 0LL;
                  *((void *)v261 + 78) = (char *)v261 + 616;
                  *((void *)v261 + 79) = 0LL;
                  *((void *)v261 + 80) = (char *)v261 + 632;
                  *((void *)v261 + 81) = 0LL;
                  *((void *)v261 + 82) = (char *)v261 + 648;
                  *((void *)v261 + 83) = 0LL;
                  *((void *)v261 + 84) = (char *)v261 + 664;
                  *((void *)v261 + 86) = (char *)v261 + 680;
                  *((void *)v261 + 85) = 0LL;
                  nw_frame_cache_init((uint64_t)v261 + 696, (uint64_t)v261, 256, 0x40000, 16);
                  v265 = *((void *)v261 + 60);
                  if (v265)
                  {
                    *(_OWORD *)((char *)v261 + 360) = 0u;
                    *(_OWORD *)((char *)v261 + 376) = 0u;
                    *(_OWORD *)((char *)v261 + 392) = 0u;
                    *(_OWORD *)((char *)v261 + 408) = 0u;
                    *(_OWORD *)((char *)v261 + 424) = 0u;
                    *(_OWORD *)((char *)v261 + 440) = 0u;
                    *(_OWORD *)((char *)v261 + 328) = 0u;
                    *(_OWORD *)((char *)v261 + 344) = 0u;
                    *((void *)v261 + 59) = nw_http1_on_reset;
                    *((void *)v261 + 37) = nw_http1_on_message_begin;
                    *((void *)v261 + 38) = nw_http1_on_url;
                    *((void *)v261 + 48) = nw_http1_on_message_complete;
                    *((void *)v261 + 49) = nw_http1_on_url_complete;
                    *((void *)v261 + 39) = nw_http1_on_status;
                    *((void *)v261 + 40) = nw_http1_on_method;
                    *((void *)v261 + 50) = nw_http1_on_status_complete;
                    *((void *)v261 + 51) = nw_http1_on_method_complete;
                    *((void *)v261 + 42) = nw_http1_on_header_field;
                    *((void *)v261 + 43) = nw_http1_on_header_value;
                    *((void *)v261 + 53) = nw_http1_on_header_field_complete;
                    *((void *)v261 + 54) = nw_http1_on_header_value_complete;
                    *((void *)v261 + 46) = nw_http1_on_headers_complete;
                    *((void *)v261 + 47) = nw_http1_on_body;
                    *((void *)v261 + 57) = nw_http1_on_chunk_header;
                    *((void *)v261 + 58) = nw_http1_on_chunk_complete;
                    v266 = *(_BYTE *)(v265 + 376);
                    *(_OWORD *)((char *)v261 + 248) = 0u;
                    *(_OWORD *)((char *)v261 + 200) = 0u;
                    *(_OWORD *)((char *)v261 + 264) = 0u;
                    *(_OWORD *)((char *)v261 + 232) = 0u;
                    *(_OWORD *)((char *)v261 + 216) = 0u;
                    if ((v266 & 1) != 0) {
                      v267 = 1;
                    }
                    else {
                      v267 = 2;
                    }
                    *((_BYTE *)v261 + 272) = v267;
                    *((void *)v261 + 35) = 0LL;
                    *((void *)v261 + 36) = (char *)v261 + 296;
                    *((_WORD *)v261 + 139) = 16131;
                    *((void *)v261 + 31) = v261;
                    *((void *)v261 + 32) = 238LL;
                    if ((*((_BYTE *)v261 + 158) & 1) == 0)
                    {
                      v268 = (os_log_s *)__nwlog_obj();
                      if (os_log_type_enabled(v268, OS_LOG_TYPE_DEBUG))
                      {
                        v269 = *((void *)v261 + 61);
                        v270 = *(_DWORD *)(*((void *)v261 + 60) + 372LL);
                        v271 = *((_DWORD *)v261 + 215);
                        if (v269) {
                          LODWORD(v269) = *(_DWORD *)(v269 + 424);
                        }
                        *(_DWORD *)buf = 136448258;
                        *(void *)&uint8_t buf[4] = "nw_http1_connection_log_parser_version";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = (char *)v261 + 74;
                        *(_WORD *)&buf[22] = 2080;
                        v608 = (uint64_t)" ";
                        *(_WORD *)v609 = 1024;
                        *(_DWORD *)&v609[2] = v270;
                        *(_WORD *)&v609[6] = 1024;
                        *(_DWORD *)&v609[8] = v271;
                        *(_WORD *)&v609[12] = 1024;
                        *(_DWORD *)&v609[14] = v269;
                        *(_WORD *)&v609[18] = 1024;
                        *(_DWORD *)&v609[20] = 9;
                        *(_WORD *)&v609[24] = 1024;
                        *(_DWORD *)&v609[26] = 2;
                        *(_WORD *)&v609[30] = 1024;
                        *(_DWORD *)&v609[32] = 1;
                        _os_log_impl( &dword_181A5C000,  v268,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> using http parser v%u.%u.%u",  buf,  0x44u);
                      }
                    }

                    goto LABEL_396;
                  }

                  __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                  v494 = (char *)_os_log_send_and_compose_impl();
                  v602[0] = 16;
                  LOBYTE(v583[0]) = 0;
                  if (__nwlog_fault(v494, v602, v583))
                  {
                    if (v602[0] == 17)
                    {
                      v495 = (os_log_s *)__nwlog_obj();
                      v496 = v602[0];
                      if (!os_log_type_enabled(v495, (os_log_type_t)v602[0])) {
                        goto LABEL_901;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                      v497 = "%{public}s called with null http1_connection->protocol_http1";
                      goto LABEL_900;
                    }

                    if (!LOBYTE(v583[0]))
                    {
                      v495 = (os_log_s *)__nwlog_obj();
                      v496 = v602[0];
                      if (!os_log_type_enabled(v495, (os_log_type_t)v602[0])) {
                        goto LABEL_901;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                      v497 = "%{public}s called with null http1_connection->protocol_http1, backtrace limit exceeded";
                      goto LABEL_900;
                    }

                    v535 = (char *)__nw_create_backtrace_string();
                    v495 = (os_log_s *)__nwlog_obj();
                    v496 = v602[0];
                    v536 = os_log_type_enabled(v495, (os_log_type_t)v602[0]);
                    if (v535)
                    {
                      if (v536)
                      {
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v535;
                        _os_log_impl( &dword_181A5C000,  v495,  v496,  "%{public}s called with null http1_connection->protocol_http1, dumping backtrace:%{public}s",  buf,  0x16u);
                      }

                      free(v535);
                      goto LABEL_901;
                    }

                    if (v536)
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_http1_connection_parser_init";
                      v497 = "%{public}s called with null http1_connection->protocol_http1, no backtrace";
LABEL_900:
                      _os_log_impl(&dword_181A5C000, v495, v496, v497, buf, 0xCu);
                    }
                  }

    free(backtrace_string);
    goto LABEL_44;
  }

  char v17 = (os_log_s *)__nwlog_obj();
  os_log_type_t v18 = type[0];
  if (os_log_type_enabled(v17, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_replicate_add_input_handler";
    os_log_type_t v19 = "%{public}s called with null protocol";
LABEL_43:
    _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
  }

  if (v3) {
    free(v3);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

        if (!is_equal)
        {
          os_log_type_t v16 = 7;
LABEL_39:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v27 = (os_log_s *)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
          {
            os_log_type_t v28 = *(void *)(a1 + 32);
            uint64_t v29 = 136446466;
            char v30 = "nw_replicate_metadata_add_endpoint_on_queue_block_invoke";
            uint64_t v31 = 2112;
            char v32 = v28;
            _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_DEFAULT,  "%{public}s Adding endpoint %@ for replication",  (uint8_t *)&v29,  0x16u);
          }

          nw_protocol_replicate_add_secondary_endpoint( v8,  *(void *)(a1 + 32),  v16,  *(void *)(a1 + 40),  *(void *)(a1 + 48));
          goto LABEL_4;
        }

        _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0x16u);
        goto LABEL_35;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        char v25 = "nw_protocol_register_extended";
        os_log_type_t v26 = 2082;
        __int16 v27 = (uint64_t)a1;
        os_log_type_t v12 = "%{public}s Protocol identifier %{public}s is already registered";
        goto LABEL_34;
      }

          if (v8 - 1 == ++v25) {
            goto LABEL_12;
          }
          break;
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
          __int16 v27 = 0LL;
          if (v13 || v15 <= v26) {
            return v27;
          }
          os_log_type_t v13 = 0;
          ++v12;
          goto LABEL_34;
        default:
          goto LABEL_34;
      }
    }
  }

  os_log_type_t v13 = 0;
  os_log_type_t v14 = 0;
  BOOL v15 = 1LL;
LABEL_12:
  if (v15 >= v8) {
    return 0LL;
  }
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 16) = 0LL;
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0LL;
  os_log_type_t v16 = a4;
  char v17 = v15 + 1;
  BOOL v58 = v16;
  *os_log_type_t v16 = 0;
  os_log_type_t v18 = strtol(&a1[v15 + 1], 0LL, 0);
  if (v18 < 1) {
    return 0LL;
  }
  os_log_type_t v19 = v18;
  if (v12 | v11)
  {
    *(_BYTE *)(a3 + 1) = 30;
    *(_BYTE *)(a2 + 1) = 30;
    *(_BYTE *)a3 = 28;
    *(_BYTE *)a2 = 28;
    if (v15 > 0x26) {
      return 0LL;
    }
    memcpy(&__dst, a1, v15);
    if (!(v14 & 1 | (v11 > 6)))
    {
      if (v15 - 37 < 0xFFFFFFFFFFFFFFD8LL) {
        return 0LL;
      }
      *((_BYTE *)&__dst + v15) = 58;
      *((_BYTE *)&__dst + v17) = 58;
      v15 += 2LL;
    }

    *((_BYTE *)&__dst + v15) = 0;
    uint64_t v29 = inet_pton(30, (const char *)&__dst, (void *)(a2 + 8));
    __int16 v27 = 0LL;
    id v22 = v58;
    if (v29 != 1) {
      return v27;
    }
    BOOL v20 = (_BYTE *)(a3 + 8);
    goto LABEL_77;
  }

  *(_BYTE *)(a3 + 1) = 2;
  *(_BYTE *)(a2 + 1) = 2;
  *(_BYTE *)a3 = 16;
  *(_BYTE *)a2 = 16;
  if (v15 > 0xE) {
    return 0LL;
  }
  BOOL v20 = (_BYTE *)(a3 + 4);
  memcpy(&__dst, a1, v15);
  if (v13 > 2 || v15 == 14)
  {
    id v22 = v58;
    goto LABEL_76;
  }

  __int16 v21 = v15 + 2;
  *((_BYTE *)&__dst + v15) = 46;
  *((_BYTE *)&__dst + v17) = 48;
  if (v13 <= 1)
  {
    id v22 = v58;
    if (v15 <= 0xB)
    {
      uint64_t v23 = v15 + 4;
      *((_BYTE *)&__dst + v21) = 46;
      *((_BYTE *)&__dst + v15 + 3) = 48;
      if (v13 > 0 || v15 > 9) {
        goto LABEL_74;
      }
      __int16 v21 = v15 + 6;
      *((_BYTE *)&__dst + v23) = 46;
      *((_BYTE *)&__dst + v15 + 5) = 48;
      if ((v13 & 0x80000000) == 0 || v15 > 7) {
        goto LABEL_73;
      }
      uint64_t v23 = v15 + 8;
      *((_BYTE *)&__dst + v21) = 46;
      *((_BYTE *)&__dst + v15 + 7) = 48;
      if (v13 > -2 || v15 > 5)
      {
LABEL_74:
        BOOL v15 = v23;
        goto LABEL_76;
      }

      __int16 v21 = v15 + 10;
      *((_BYTE *)&__dst + v23) = 46;
      *((_BYTE *)&__dst + v15 + 9) = 48;
      if (v13 <= -3 && v15 <= 3)
      {
        uint64_t v23 = v15 + 12;
        *((_BYTE *)&__dst + v21) = 46;
        *((_BYTE *)&__dst + v15 + 11) = 48;
        if (v13 <= -4 && v15 <= 1)
        {
          os_log_type_t v24 = (char *)&__dst + v15;
          v15 += 14LL;
          *((_BYTE *)&__dst + v23) = 46;
          v24[13] = 48;
          goto LABEL_76;
        }

        goto LABEL_74;
      }
    }

            free(v27);
            goto LABEL_44;
          }

          if (!v31) {
            goto LABEL_43;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v52 = "nw_storage_load_canvases_for_key";
          os_log_type_t v18 = "%{public}s Failed to prepare statement, no backtrace";
LABEL_54:
          char v32 = v16;
          id v33 = v28;
          goto LABEL_42;
        }

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  os_log_type_t v44 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_unique_connection_request);
  uint64_t v45 = (char *)v44;
  if (!v44)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v58 = (id)gLogObj;
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
    os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    v131 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v59, type, &v131))
    {
      if (type[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v60 = (os_log_s *)(id)gLogObj;
        v61 = type[0];
        if (os_log_type_enabled(v60, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl( &dword_181A5C000,  v60,  v61,  "%{public}s [nw_unique_connection_request init:] failed",  (uint8_t *)buf,  0xCu);
        }
      }

      else if (v131)
      {
        v69 = __nw_create_backtrace_string();
        if (v69)
        {
          v70 = (char *)v69;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v71 = (os_log_s *)(id)gLogObj;
          v72 = type[0];
          if (os_log_type_enabled(v71, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
            WORD6(buf[0]) = 2082;
            *(void *)((char *)buf + 14) = v70;
            _os_log_impl( &dword_181A5C000,  v71,  v72,  "%{public}s [nw_unique_connection_request init:] failed, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
          }

          free(v70);
          if (!v59) {
            goto LABEL_92;
          }
          goto LABEL_91;
        }

        __nwlog_obj();
        os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v82 = type[0];
        if (os_log_type_enabled(v60, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl( &dword_181A5C000,  v60,  v82,  "%{public}s [nw_unique_connection_request init:] failed, no backtrace",  (uint8_t *)buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v77 = type[0];
        if (os_log_type_enabled(v60, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl( &dword_181A5C000,  v60,  v77,  "%{public}s [nw_unique_connection_request init:] failed, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
        }
      }
    }

    if (!v59)
    {
LABEL_92:
      nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 40), 0LL, *(void **)(a1 + 64), 0LL, 12);
      v83 = 0LL;
LABEL_139:

      __int16 v27 = v125;
LABEL_140:

LABEL_141:
      return;
    }

        os_log_type_t v38 = **(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        goto LABEL_35;
      }

      goto LABEL_10;
    }

    [MEMORY[0x189604030] fileURLWithPath:v17 isDirectory:0];
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    -[NWURLSessionResponseConsumerDownload setFileURL:]((uint64_t)self, v16);
  }

  else
  {
    char v17 = 0LL;
  }

    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
    goto LABEL_35;
  }

  id v3 = (unsigned __int8 *)(a1 + 40);
  do
    id v4 = __ldxr(v3);
  while (__stxr(0xFFu, v3));
  if (v4)
  {
    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_array_remove_all_objects";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v10))
    {
      free(v10);
      do
        __ldxr(v3);
      while (__stlxr(v4, v3));
      return;
    }

    os_log_type_t v10 = 0LL;
    if (v6 < 0x20) {
      goto LABEL_12;
    }
    goto LABEL_35;
  }

  if ((v6 & 0x80000000) == 0)
  {
    id v22 = 0;
    goto LABEL_22;
  }

  __int16 v40 = (unsigned __int8 *)(a1 + a4);
  if ((v40 & 1) != 0)
  {
    __int16 v43 = (uint32x2_t *)(v40 + 1);
    uint64_t v41 = (unint64_t)*v40 << 8;
    uint64_t v42 = ~v6;
  }

  else
  {
    uint64_t v41 = 0LL;
    uint64_t v42 = a3 - a4;
    __int16 v43 = (uint32x2_t *)(a1 + a4);
  }

  if ((v43 & 2) != 0)
  {
    if (v42 < 2)
    {
      char v63 = 0LL;
      if ((v42 & 1) == 0) {
        goto LABEL_105;
      }
      goto LABEL_104;
    }

    v64 = v43->u16[0];
    __int16 v43 = (uint32x2_t *)((char *)v43 + 2);
    v41 += v64;
    v42 -= 2;
  }

  if (v42 < 0x40)
  {
    char v63 = 0LL;
  }

  else
  {
    char v63 = 0LL;
    _X13 = v43;
    if ((v40 & 1) != 0)
    {
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }

        __int16 v43 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }

        v41 += vaddvq_s64( vaddq_s64( vaddq_s64((int64x2_t)vaddl_u32(*_X13, _X13[4]), (int64x2_t)vaddl_u32(_X13[2], _X13[6])),  vaddq_s64( (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13->i8, *(uint32x4_t *)_X13[4].i8),  (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13[2].i8, *(uint32x4_t *)_X13[6].i8))));
        v42 -= 64;
        v71 = __ROR8__(v41, 56);
        v72 = v63 + HIDWORD(v71) + v71;
        if (v41 >> 62)
        {
          uint64_t v41 = 0LL;
          char v63 = v72;
        }

        _X13 += 8;
      }

      while (v42 > 0x3F);
    }

    else
    {
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }

        __int16 v43 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }

        v41 += vaddvq_s64( vaddq_s64( vaddq_s64((int64x2_t)vaddl_u32(*_X13, _X13[4]), (int64x2_t)vaddl_u32(_X13[2], _X13[6])),  vaddq_s64( (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13->i8, *(uint32x4_t *)_X13[4].i8),  (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13[2].i8, *(uint32x4_t *)_X13[6].i8))));
        v42 -= 64;
        v68 = v63 + HIDWORD(v41) + v41;
        if (v41 >> 62)
        {
          uint64_t v41 = 0LL;
          char v63 = v68;
        }

        _X13 += 8;
      }

      while (v42 > 0x3F);
    }
  }

  if (v42 >= 0x20)
  {
    v75 = *(uint32x4_t *)v43->i8;
    v76 = *(uint32x4_t *)v43[2].i8;
    v43 += 4;
    v41 += vaddvq_s64( vaddq_s64( (int64x2_t)vaddl_u32(*(uint32x2_t *)v75.i8, *(uint32x2_t *)v76.i8),  (int64x2_t)vaddl_high_u32(v75, v76)));
    if ((v42 & 0x10) == 0)
    {
LABEL_100:
      if ((v42 & 8) == 0) {
        goto LABEL_101;
      }
      goto LABEL_110;
    }
  }

  else if ((v42 & 0x10) == 0)
  {
    goto LABEL_100;
  }

  v77 = *(uint32x4_t *)v43->i8;
  v43 += 2;
  v41 += vaddlvq_u32(v77);
  if ((v42 & 8) == 0)
  {
LABEL_101:
    if ((v42 & 4) == 0) {
      goto LABEL_102;
    }
    goto LABEL_111;
  }

  if (v6) {
    free(v6);
  }
  return 0LL;
}

      if (v12) {
        free(v12);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v13 = (os_log_s *)gLogObj;
    os_log_type_t v14 = type;
    char v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v36 = "nw_protocol_common_finalize_output_frames";
        BOOL v15 = "%{public}s finalize_output_frames requires an output handler, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (!v17)
    {
LABEL_28:
      free(backtrace_string);
      goto LABEL_34;
    }

    *(_DWORD *)buf = 136446466;
    uint64_t v36 = "nw_protocol_common_finalize_output_frames";
    os_log_type_t v37 = 2082;
    os_log_type_t v38 = backtrace_string;
    os_log_type_t v18 = "%{public}s finalize_output_frames requires an output handler, dumping backtrace:%{public}s";
LABEL_27:
    _os_log_impl(&dword_181A5C000, v13, v14, v18, buf, 0x16u);
    goto LABEL_28;
  }

  id v3 = *(void **)(v2 + 40);
  if (v3 == &nw_protocol_ref_counted_handle)
  {
    id v4 = *(void *)(v2 + 88);
    if (v4) {
      *(void *)(v2 + 88) = v4 + 1;
    }
  }

  int v5 = *(void *)(v2 + 24);
  if (v5)
  {
    int v6 = *(uint64_t (**)(uint64_t))(v5 + 96);
    if (v6)
    {
      BOOL v7 = v6(v2);
      if (v3 != &nw_protocol_ref_counted_handle) {
        return v7;
      }
      goto LABEL_10;
    }
  }

  __nwlog_obj();
  BOOL v20 = *(const char **)(v2 + 16);
  *(_DWORD *)buf = 136446722;
  uint64_t v36 = "__nw_protocol_finalize_output_frames";
  if (!v20) {
    BOOL v20 = "invalid";
  }
  os_log_type_t v37 = 2082;
  os_log_type_t v38 = (void *)v20;
  char v39 = 2048;
  __int16 v40 = v2;
  __int16 v21 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  id v33 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v22 = (os_log_s *)__nwlog_obj();
    uint64_t v23 = type;
    if (!os_log_type_enabled(v22, type)) {
      goto LABEL_82;
    }
    os_log_type_t v24 = *(const char **)(v2 + 16);
    if (!v24) {
      os_log_type_t v24 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v36 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v37 = 2082;
    os_log_type_t v38 = (void *)v24;
    char v39 = 2048;
    __int16 v40 = v2;
    char v25 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_81:
    _os_log_impl(&dword_181A5C000, v22, v23, v25, buf, 0x20u);
    goto LABEL_82;
  }

  if (!v33)
  {
    id v22 = (os_log_s *)__nwlog_obj();
    uint64_t v23 = type;
    if (!os_log_type_enabled(v22, type)) {
      goto LABEL_82;
    }
    uint64_t v31 = *(const char **)(v2 + 16);
    if (!v31) {
      uint64_t v31 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v36 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v37 = 2082;
    os_log_type_t v38 = (void *)v31;
    char v39 = 2048;
    __int16 v40 = v2;
    char v25 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
    goto LABEL_81;
  }

  os_log_type_t v26 = (char *)__nw_create_backtrace_string();
  id v22 = (os_log_s *)__nwlog_obj();
  uint64_t v23 = type;
  __int16 v27 = os_log_type_enabled(v22, type);
  if (!v26)
  {
    if (!v27) {
      goto LABEL_82;
    }
    char v32 = *(const char **)(v2 + 16);
    if (!v32) {
      char v32 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v36 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v37 = 2082;
    os_log_type_t v38 = (void *)v32;
    char v39 = 2048;
    __int16 v40 = v2;
    char v25 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
    goto LABEL_81;
  }

  if (v27)
  {
    os_log_type_t v28 = *(const char **)(v2 + 16);
    if (!v28) {
      os_log_type_t v28 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    uint64_t v36 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v37 = 2082;
    os_log_type_t v38 = (void *)v28;
    char v39 = 2048;
    __int16 v40 = v2;
    uint64_t v41 = 2082;
    uint64_t v42 = v26;
    _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v26);
LABEL_82:
  if (v21) {
    free(v21);
  }
  BOOL v7 = 0LL;
  if (v3 == &nw_protocol_ref_counted_handle)
  {
LABEL_10:
    if (*(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v8 = *(void *)(v2 + 88);
      if (v8)
      {
        os_log_type_t v9 = v8 - 1;
        *(void *)(v2 + 88) = v9;
        if (!v9)
        {
          os_log_type_t v10 = *(void (***)(void))(v2 + 64);
          if (v10)
          {
            *(void *)(v2 + 64) = 0LL;
            v10[2](v10);
            _Block_release(v10);
          }

          if ((*(_BYTE *)(v2 + 72) & 1) != 0)
          {
            os_log_type_t v11 = *(const void **)(v2 + 64);
            if (v11) {
              _Block_release(v11);
            }
          }

          free((void *)v2);
        }
      }
    }
  }

  return v7;
}

          free(backtrace_string);
          if (!v4) {
            return;
          }
          goto LABEL_50;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_common_link_state";
          char v17 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_common_link_state";
          char v17 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    BOOL v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_protocol_common_link_state";
    char v17 = "%{public}s called with null protocol";
LABEL_48:
    _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
    goto LABEL_49;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_protocol_common_link_state";
    id v4 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        unint64_t v35 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v42 = "nw_protocol_common_link_state";
            __int16 v43 = 2082;
            os_log_type_t v44 = backtrace_string;
            BOOL v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

          goto LABEL_34;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_common_link_state";
          char v17 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_common_link_state";
          char v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    BOOL v15 = (os_log_s *)__nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_protocol_common_link_state";
    char v17 = "%{public}s called with null other_protocol";
    goto LABEL_48;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_protocol_common_link_state";
    id v4 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault((const char *)v4, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_common_link_state";
          char v17 = "%{public}s called with null link_info";
          goto LABEL_48;
        }
      }

      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        uint64_t v36 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v42 = "nw_protocol_common_link_state";
            __int16 v43 = 2082;
            os_log_type_t v44 = backtrace_string;
            BOOL v20 = "%{public}s called with null link_info, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

          goto LABEL_34;
        }

        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_common_link_state";
          char v17 = "%{public}s called with null link_info, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        BOOL v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_common_link_state";
          char v17 = "%{public}s called with null link_info, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }

    free(v15);
LABEL_35:
    BOOL v15 = 0LL;
LABEL_36:

    return (BOOL)v15;
  }

  __nwlog_obj();
  uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446722;
  *(void *)&applier[4] = "strict_calloc";
  *(_WORD *)&applier[12] = 2048;
  *(void *)&applier[14] = 1LL;
  *(_WORD *)&applier[22] = 2048;
  os_log_type_t v60 = (void *)v14;
  __int16 v43 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v43);
  if (!result)
  {
    free(v43);
    goto LABEL_14;
  }

        if (v16) {
          free(v16);
        }
        nw_protocol_http3_stream_destroy(v12);
        os_log_type_t v12 = v13;
      }

      while (v13);
    }

    if (((*v3 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v197 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v197, OS_LOG_TYPE_DEBUG))
        {
          v198 = *(_DWORD *)(v2 + 1280);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v2 + 1289;
          *(_WORD *)&buf[22] = 2080;
          v309 = " ";
          LOWORD(v310) = 1024;
          *(_DWORD *)((char *)&v310 + 2) = v198;
          _os_log_impl(&dword_181A5C000, v197, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }

    nw_protocol_remove_instance(v2);
    uint64_t v29 = *v3;
    if ((v29 & 0x800) == 0)
    {
LABEL_52:
      os_log_type_t v38 = MEMORY[0x1895F87A8];
      char v39 = (void *)&unk_182665000;
      if (!*(void *)(v2 + 1048)) {
        goto LABEL_71;
      }
      __int16 v40 = *(void *)(v2 + 216);
      while (v40)
      {
        uint64_t v41 = (_DWORD *)v40;
        __int16 v40 = *(void *)(v40 + 32);
        if (gLogDatapath)
        {
          log = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v42 = nw_frame_unclaimed_length(v41);
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_http3_framer_cleanup_block_invoke";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v41;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v309) = v42;
            _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s input frames unprocessed still has frames in it: frame %p (%u bytes)",  buf,  0x1Cu);
          }
        }
      }

      if (gLogDatapath)
      {
        v231 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v231, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
          _os_log_impl(&dword_181A5C000, v231, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }

      *(void *)buf = v38;
      char v39 = &unk_182665000;
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60412;
      v309 = (const char *)&__block_descriptor_tmp_26_60413;
      v310 = (void *)(v2 + 216);
      LOBYTE(v311) = 0;
      __int16 v43 = *(void *)(v2 + 216);
      uint64_t v2 = v305;
      do
      {
        if (!v43) {
          break;
        }
        os_log_type_t v44 = *(void *)(v43 + 32);
        uint64_t v45 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        __int16 v43 = v44;
      }

      while ((v45 & 1) != 0);
      *(_DWORD *)(v305 + 232) = 0;
      v46 = (void *)(*(void *)(v305 + 1048) + 104LL);
      if (gLogDatapath)
      {
        v232 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v232, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
          _os_log_impl(&dword_181A5C000, v232, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }

      *(void *)buf = v38;
      *(void *)&buf[8] = 0x40000000LL;
      *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60412;
      v309 = (const char *)&__block_descriptor_tmp_26_60413;
      v310 = v46;
      LOBYTE(v311) = 0;
      v47 = *v46;
      do
      {
        if (!v47) {
          break;
        }
        v48 = *(void *)(v47 + 32);
        v49 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v47 = v48;
      }

      while ((v49 & 1) != 0);
      os_log_type_t v50 = *(void *)(v305 + 1048);
      v51 = *(void *)(v50 + 32);
      if (v51)
      {
        os_log_type_t v52 = *(void *)(v51 + 24);
        if (v52)
        {
          v53 = *(void (**)(uint64_t, uint64_t))(v52 + 8);
          if (v53)
          {
            v53(v51, v50);
LABEL_70:
            nw_protocol_http3_uni_stream_destroy(*(void *)(v2 + 1048));
            *(void *)(v2 + 1048) = 0LL;
LABEL_71:
            os_log_type_t v54 = *(void *)(v2 + 1056);
            if (!v54) {
              goto LABEL_77;
            }
            BOOL v55 = *(void *)(v54 + 32);
            if (v55)
            {
              v56 = *(void *)(v55 + 24);
              if (v56)
              {
                os_log_type_t v57 = *(void (**)(uint64_t, uint64_t))(v56 + 8);
                if (v57)
                {
                  v57(v55, v54);
LABEL_76:
                  nw_protocol_http3_uni_stream_destroy(*(void *)(v2 + 1056));
                  *(void *)(v2 + 1056) = 0LL;
LABEL_77:
                  BOOL v58 = *(void *)(v2 + 1064);
                  if (!v58) {
                    goto LABEL_87;
                  }
                  os_log_type_t v59 = (void *)(v58 + 104);
                  if (gLogDatapath)
                  {
                    v233 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v233, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
                      _os_log_impl(&dword_181A5C000, v233, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
                    }
                  }

                  *(void *)buf = v38;
                  *(void *)&buf[8] = v39[397];
                  *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60412;
                  v309 = (const char *)&__block_descriptor_tmp_26_60413;
                  v310 = v59;
                  LOBYTE(v311) = 0;
                  os_log_type_t v60 = *v59;
                  do
                  {
                    if (!v60) {
                      break;
                    }
                    v61 = *(void *)(v60 + 32);
                    id v62 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                    os_log_type_t v60 = v61;
                  }

                  while ((v62 & 1) != 0);
                  char v63 = *(void *)(v2 + 1064);
                  v64 = *(void *)(v63 + 32);
                  if (v64)
                  {
                    v65 = *(void *)(v64 + 24);
                    if (v65)
                    {
                      v66 = *(void (**)(uint64_t, uint64_t))(v65 + 8);
                      if (v66)
                      {
                        v66(v64, v63);
LABEL_86:
                        nw_protocol_http3_uni_stream_destroy(*(void *)(v2 + 1064));
                        *(void *)(v2 + 1064) = 0LL;
LABEL_87:
                        __int16 v67 = *(void *)(v2 + 1072);
                        if (!v67) {
                          goto LABEL_93;
                        }
                        v68 = *(void *)(v67 + 32);
                        if (v68)
                        {
                          v69 = *(void *)(v68 + 24);
                          if (v69)
                          {
                            v70 = *(void (**)(uint64_t, uint64_t))(v69 + 8);
                            if (v70)
                            {
                              v70(v68, v67);
LABEL_92:
                              nw_protocol_http3_uni_stream_destroy(*(void *)(v2 + 1072));
                              *(void *)(v2 + 1072) = 0LL;
LABEL_93:
                              v71 = *(void *)(v2 + 1080);
                              if (!v71)
                              {
LABEL_103:
                                v80 = *(void **)(v2 + 896);
                                if (v80)
                                {
                                  v81 = v39[397];
                                  while (1)
                                  {
                                    v83 = (void *)v80[10];
                                    if (gLogDatapath)
                                    {
                                      v101 = (os_log_s *)__nwlog_obj();
                                      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
                                      {
                                        *(_DWORD *)buf = 136446210;
                                        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
                                        _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s called",  buf,  0xCu);
                                      }
                                    }

                                    *(void *)buf = v38;
                                    *(void *)&buf[8] = v81;
                                    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60412;
                                    v309 = (const char *)&__block_descriptor_tmp_26_60413;
                                    v310 = v80 + 13;
                                    LOBYTE(v311) = 0;
                                    v84 = v80[13];
                                    do
                                    {
                                      if (!v84) {
                                        break;
                                      }
                                      v85 = *(void *)(v84 + 32);
                                      v86 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                                      v84 = v85;
                                    }

                                    while ((v86 & 1) != 0);
                                    v87 = v80[4];
                                    if (!v87) {
                                      break;
                                    }
                                    v88 = *(void *)(v87 + 24);
                                    if (!v88) {
                                      break;
                                    }
                                    v89 = *(void (**)(uint64_t, void *))(v88 + 8);
                                    if (!v89) {
                                      break;
                                    }
                                    v89(v87, v80);
LABEL_115:
                                    v90 = v80[10];
                                    v82 = (void *)v80[11];
                                    if (v90)
                                    {
                                      *(void *)(v90 + 88) = v82;
                                      v82 = (void *)v80[11];
                                    }

                                    else
                                    {
                                      *(void *)(v305 + 904) = v82;
                                    }

                                    *v82 = v90;
                                    v80[10] = 0LL;
                                    v80[11] = 0LL;
                                    nw_protocol_http3_uni_stream_destroy((uint64_t)v80);
                                    v80 = v83;
                                    if (!v83) {
                                      goto LABEL_160;
                                    }
                                  }

                                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                  networkd_settings_init();
                                  v91 = v80[4];
                                  if (v91)
                                  {
                                    v92 = *(const char **)(v91 + 16);
                                    if (!v92) {
                                      v92 = "invalid";
                                    }
                                  }

                                  else
                                  {
                                    v92 = "invalid";
                                  }

                                  *(_DWORD *)buf = 136446466;
                                  *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                                  *(_WORD *)&buf[12] = 2082;
                                  *(void *)&buf[14] = v92;
                                  v93 = (char *)_os_log_send_and_compose_impl();
                                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                                  v306 = 0;
                                  if (__nwlog_fault(v93, &type, &v306))
                                  {
                                    if (type == OS_LOG_TYPE_FAULT)
                                    {
                                      v301 = (os_log_s *)__nwlog_obj();
                                      v298 = type;
                                      if (!os_log_type_enabled(v301, type)) {
                                        goto LABEL_158;
                                      }
                                      v94 = v80[4];
                                      if (v94)
                                      {
                                        v95 = *(const char **)(v94 + 16);
                                        if (!v95) {
                                          v95 = "invalid";
                                        }
                                      }

                                      else
                                      {
                                        v95 = "invalid";
                                      }

                                      *(_DWORD *)buf = 136446466;
                                      *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                                      *(_WORD *)&buf[12] = 2082;
                                      *(void *)&buf[14] = v95;
                                      v106 = v301;
                                      v107 = v298;
                                      v108 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
                                      goto LABEL_157;
                                    }

                                    if (!v306)
                                    {
                                      v303 = (os_log_s *)__nwlog_obj();
                                      v300 = type;
                                      if (!os_log_type_enabled(v303, type)) {
                                        goto LABEL_158;
                                      }
                                      v102 = v80[4];
                                      if (v102)
                                      {
                                        v103 = *(const char **)(v102 + 16);
                                        if (!v103) {
                                          v103 = "invalid";
                                        }
                                      }

                                      else
                                      {
                                        v103 = "invalid";
                                      }

                                      *(_DWORD *)buf = 136446466;
                                      *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                                      *(_WORD *)&buf[12] = 2082;
                                      *(void *)&buf[14] = v103;
                                      v106 = v303;
                                      v107 = v300;
                                      v108 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, b"
                                             "acktrace limit exceeded";
                                      goto LABEL_157;
                                    }

                                    v302 = v93;
                                    v96 = __nw_create_backtrace_string();
                                    v299 = (os_log_s *)__nwlog_obj();
                                    v297 = type;
                                    v97 = os_log_type_enabled(v299, type);
                                    if (v96)
                                    {
                                      v98 = (char *)v96;
                                      v93 = v302;
                                      if (v97)
                                      {
                                        v99 = v80[4];
                                        if (v99)
                                        {
                                          v100 = *(const char **)(v99 + 16);
                                          if (!v100) {
                                            v100 = "invalid";
                                          }
                                        }

                                        else
                                        {
                                          v100 = "invalid";
                                        }

                                        *(_DWORD *)buf = 136446722;
                                        *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                                        *(_WORD *)&buf[12] = 2082;
                                        *(void *)&buf[14] = v100;
                                        *(_WORD *)&buf[22] = 2082;
                                        v309 = v98;
                                        v109 = v98;
                                        _os_log_impl( &dword_181A5C000,  v299,  v297,  "%{public}s protocol %{public}s has invalid remove_input_handler callback, dump ing backtrace:%{public}s",  buf,  0x20u);
                                        v98 = v109;
                                        v93 = v302;
                                      }

                                      free(v98);
                                      goto LABEL_158;
                                    }

                                    v93 = v302;
                                    if (v97)
                                    {
                                      v104 = v80[4];
                                      if (v104)
                                      {
                                        v105 = *(const char **)(v104 + 16);
                                        if (!v105) {
                                          v105 = "invalid";
                                        }
                                      }

                                      else
                                      {
                                        v105 = "invalid";
                                      }

                                      v106 = v299;
                                      v107 = v297;
                                      *(_DWORD *)buf = 136446466;
                                      *(void *)&uint8_t buf[4] = "nw_http3_teardown_uni_streams";
                                      *(_WORD *)&buf[12] = 2082;
                                      *(void *)&buf[14] = v105;
                                      v108 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_157:
                                      _os_log_impl(&dword_181A5C000, v106, v107, v108, buf, 0x16u);
                                    }
                                  }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = v4;
    __int16 v21 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v22 = (os_log_s *)__nwlog_obj();
      uint64_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v4;
      os_log_type_t v24 = v22;
      char v25 = v23;
      os_log_type_t v26 = "%{public}s Failed to generate ici";
      goto LABEL_47;
    }

    if (!v91)
    {
      id v33 = (os_log_s *)__nwlog_obj();
      __int16 v34 = type;
      if (!os_log_type_enabled(v33, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v4;
      os_log_type_t v24 = v33;
      char v25 = v34;
      os_log_type_t v26 = "%{public}s Failed to generate ici, backtrace limit exceeded";
      goto LABEL_47;
    }

    __int16 v27 = v3;
    os_log_type_t v28 = v4;
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v30 = (os_log_s *)__nwlog_obj();
    uint64_t v31 = type;
    char v32 = os_log_type_enabled(v30, type);
    if (backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = v28;
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s Failed to generate ici, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      id v4 = v28;
      id v3 = v27;
      goto LABEL_48;
    }

    id v4 = v28;
    id v3 = v27;
    if (v32)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = v4;
      os_log_type_t v24 = v30;
      char v25 = v31;
      os_log_type_t v26 = "%{public}s Failed to generate ici, no backtrace";
LABEL_47:
      _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
    }

  if (v8) {
    free(v8);
  }
  return 0LL;
}

    *(void *)(a1 + 264) = 270LL;
    nw_protocol_http3_stream_error((nw_protocol *)a1, (nw_protocol *)a1, 94);
    nw_protocol_http3_stream_disconnect((nw_protocol *)a1, (nw_protocol *)a1);
    return 2LL;
  }

  os_log_type_t v10 = *(void *)(a1 + 336);
  if (!v10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v56 = "nw_http3_stream_received_fields_done";
    __int16 v43 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (__nwlog_fault(v43, &type, &v53))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        uint64_t v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          v56 = "nw_http3_stream_received_fields_done";
          v46 = "%{public}s called with null http3";
LABEL_73:
          _os_log_impl(&dword_181A5C000, v44, v45, v46, buf, 0xCu);
        }
      }

      else if (v53)
      {
        v47 = (char *)__nw_create_backtrace_string();
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        uint64_t v45 = type;
        v48 = os_log_type_enabled(v44, type);
        if (v47)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            v56 = "nw_http3_stream_received_fields_done";
            os_log_type_t v57 = 2082;
            *(void *)BOOL v58 = v47;
            _os_log_impl( &dword_181A5C000,  v44,  v45,  "%{public}s called with null http3, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v47);
          goto LABEL_74;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          v56 = "nw_http3_stream_received_fields_done";
          v46 = "%{public}s called with null http3, no backtrace";
          goto LABEL_73;
        }
      }

      else
      {
        os_log_type_t v44 = (os_log_s *)__nwlog_obj();
        uint64_t v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          v56 = "nw_http3_stream_received_fields_done";
          v46 = "%{public}s called with null http3, backtrace limit exceeded";
          goto LABEL_73;
        }
      }
    }

          _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0x16u);
          goto LABEL_35;
        }

        v10(v5, v5, 12LL, 0LL, 0LL);
      }
    }

    while (v1);
  }
}

  if (v7) {
    free(v7);
  }
  return 0LL;
}

      free(backtrace_string);
      goto LABEL_44;
    }

    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_44;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_recorder_remove_input_handler";
    os_log_type_t v13 = "%{public}s called with null protocol";
LABEL_43:
    _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
LABEL_44:
    if (v10) {
      free(v10);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_recorder_remove_input_handler";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_44;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_recorder_remove_input_handler";
      os_log_type_t v13 = "%{public}s called with null recorder";
      goto LABEL_43;
    }

    if (!v18)
    {
      os_log_type_t v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_44;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v21 = "nw_protocol_recorder_remove_input_handler";
      os_log_type_t v13 = "%{public}s called with null recorder, backtrace limit exceeded";
      goto LABEL_43;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    char v17 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v21 = "nw_protocol_recorder_remove_input_handler";
        id v22 = 2082;
        uint64_t v23 = backtrace_string;
        os_log_type_t v16 = "%{public}s called with null recorder, dumping backtrace:%{public}s";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (!v17) {
      goto LABEL_44;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_protocol_recorder_remove_input_handler";
    os_log_type_t v13 = "%{public}s called with null recorder, no backtrace";
    goto LABEL_43;
  }

  if (a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0LL);
  }
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  nw_protocol_set_input_handler((uint64_t)a1, 0LL);
  output_handler = a1->output_handler;
  if (output_handler) {
    ((void (*)(void))output_handler->callbacks->remove_input_handler)();
  }
  if (a3)
  {
    if (handle[10])
    {
      pcap_ng_dump_close_delayInitStub(v8);
      handle[10] = 0LL;
    }

    if (handle[9]) {
      pcap_close_delayInitStub(v8);
    }
    a1->handle = 0LL;
    free(handle);
  }

  return 1LL;
}

  if (v13) {
    free(v13);
  }
  return 0LL;
}

        goto LABEL_35;
      }

      if (!LOBYTE(v101[0]))
      {
        __nwlog_obj();
        os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v80 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v113 = "nw_path_group_member_action";
          _os_log_impl( &dword_181A5C000,  v13,  v80,  "%{public}s called with null path, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_34;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v63 = type[0];
      v64 = os_log_type_enabled(v13, type[0]);
      if (!backtrace_string)
      {
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          v113 = "nw_path_group_member_action";
          _os_log_impl(&dword_181A5C000, v13, v63, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }

        goto LABEL_34;
      }

      if (v64)
      {
        *(_DWORD *)buf = 136446466;
        v113 = "nw_path_group_member_action";
        v114 = 2082;
        *(void *)v115 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v63,  "%{public}s called with null path, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    free(v11);
    goto LABEL_35;
  }

  return 0LL;
}

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v7 = v17;
      os_log_type_t v14 = os_log_type_enabled(v6, v17);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v19 = "nw_endpoint_create_unix";
          os_log_type_t v8 = "%{public}s called with null (length < sizeof(storage) - __builtin_offsetof(struct sockaddr_un, sun_path)), no backtrace";
          goto LABEL_32;
        }

        goto LABEL_34;
      }

      if (!v14) {
        goto LABEL_22;
      }
      *(_DWORD *)os_log_type_t type = 136446466;
      os_log_type_t v19 = "nw_endpoint_create_unix";
      BOOL v20 = 2082;
      __int16 v21 = backtrace_string;
      os_log_type_t v12 = "%{public}s called with null (length < sizeof(storage) - __builtin_offsetof(struct sockaddr_un, sun_path)), d"
            "umping backtrace:%{public}s";
      os_log_type_t v13 = (uint8_t *)type;
      goto LABEL_21;
    }
  }

  else
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)&address[0].sa_len = 136446210;
    *(void *)&address[0].sa_data[2] = "nw_endpoint_create_unix";
    int v5 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v17 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v5, type, &v17))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v7 = type[0];
        if (!os_log_type_enabled(v6, type[0])) {
          goto LABEL_34;
        }
        *(_DWORD *)&address[0].sa_len = 136446210;
        *(void *)&address[0].sa_data[2] = "nw_endpoint_create_unix";
        os_log_type_t v8 = "%{public}s called with null path";
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v7 = type[0];
        os_log_type_t v11 = os_log_type_enabled(v6, type[0]);
        if (backtrace_string)
        {
          if (!v11)
          {
LABEL_22:

            free(backtrace_string);
            goto LABEL_35;
          }

          *(_DWORD *)&address[0].sa_len = 136446466;
          *(void *)&address[0].sa_data[2] = "nw_endpoint_create_unix";
          *(_WORD *)&address[0].sa_data[10] = 2082;
          *(void *)&address[0].sa_data[12] = backtrace_string;
          os_log_type_t v12 = "%{public}s called with null path, dumping backtrace:%{public}s";
          os_log_type_t v13 = (uint8_t *)address;
LABEL_21:
          _os_log_impl(&dword_181A5C000, v6, v7, v12, v13, 0x16u);
          goto LABEL_22;
        }

        if (!v11) {
          goto LABEL_34;
        }
        *(_DWORD *)&address[0].sa_len = 136446210;
        *(void *)&address[0].sa_data[2] = "nw_endpoint_create_unix";
        os_log_type_t v8 = "%{public}s called with null path, no backtrace";
      }

      else
      {
        __nwlog_obj();
        int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v7 = type[0];
        if (!os_log_type_enabled(v6, type[0])) {
          goto LABEL_34;
        }
        *(_DWORD *)&address[0].sa_len = 136446210;
        *(void *)&address[0].sa_data[2] = "nw_endpoint_create_unix";
        os_log_type_t v8 = "%{public}s called with null path, backtrace limit exceeded";
      }

      BOOL v15 = (uint8_t *)address;
LABEL_33:
      _os_log_impl(&dword_181A5C000, v6, v7, v8, v15, 0xCu);
      goto LABEL_34;
    }
  }

  if (v6) {
LABEL_20:
  }
    free(v6);
LABEL_21:
  os_log_type_t v13 = CFURLGetBytes((CFURLRef)v2, 0LL, 0LL);
  if (v13 == -3)
  {
    __nwlog_obj();
    BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v28 = "strict_calloc";
    __int16 v21 = (void *)_os_log_send_and_compose_impl();

    BOOL result = (CFURLRef)__nwlog_abort((uint64_t)v21);
    if ((_DWORD)result) {
      goto LABEL_42;
    }
    free(v21);
  }

  os_log_type_t v14 = (UInt8 *)calloc(v13 + 3, 1uLL);
  if (v14)
  {
LABEL_23:
    CFURLGetBytes((CFURLRef)v2, v14, v13);
    BOOL v15 = &v14[rangeIncludingSeparators.length + rangeIncludingSeparators.location];
    if (*v15 == 47) {
      os_log_type_t v16 = 1LL;
    }
    else {
      os_log_type_t v16 = 2LL;
    }
    memmove( &v15[v16],  &v14[rangeIncludingSeparators.length + rangeIncludingSeparators.location],  v13 - (rangeIncludingSeparators.length + rangeIncludingSeparators.location) + 1);
    memset(v15, 47, v16);
    id v4 = CFURLCreateAbsoluteURLWithBytes((CFAllocatorRef)*MEMORY[0x189604DB0], v14, v16 + v13, 0x600u, 0LL, 0);
    free(v14);
    goto LABEL_27;
  }

  __nwlog_obj();
  id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v28 = "strict_calloc";
  uint64_t v29 = 2048;
  char v30 = (id)(v13 + 3);
  uint64_t v31 = 2048;
  char v32 = 1LL;
  uint64_t v23 = (void *)_os_log_send_and_compose_impl();

  BOOL result = (CFURLRef)__nwlog_abort((uint64_t)v23);
  if (!(_DWORD)result)
  {
    free(v23);
    goto LABEL_23;
  }

      nw_http_messaging_options_set_http1_options(v24, 0LL);
      if ((v21 & 2) != 0)
      {
LABEL_22:
        if (v21 > 3) {
          goto LABEL_27;
        }
        goto LABEL_23;
      }

      free(v20);
    }
  }

  if (v4) {
    free(v4);
  }
  return 0LL;
}
  }

        free(backtrace_string);
      }
    }

      if (v11) {
        free(v11);
      }
      goto LABEL_36;
    }
  }

  if (a1)
  {
LABEL_5:
    uint64_t v2 = *(_WORD *)(a1 + 388);
    if ((v2 & 1) != 0) {
      goto LABEL_53;
    }
    goto LABEL_6;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v51 = "nw_http2_send_goaway";
  __int16 v21 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (__nwlog_fault(v21, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v22 = (os_log_s *)__nwlog_obj();
      uint64_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http2_send_goaway";
      os_log_type_t v24 = "%{public}s called with null http2";
      goto LABEL_82;
    }

    if (!v48)
    {
      id v22 = (os_log_s *)__nwlog_obj();
      uint64_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http2_send_goaway";
      os_log_type_t v24 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_82;
    }

    uint64_t v29 = (char *)__nw_create_backtrace_string();
    id v22 = (os_log_s *)__nwlog_obj();
    uint64_t v23 = type;
    char v30 = os_log_type_enabled(v22, type);
    if (v29)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "nw_http2_send_goaway";
        os_log_type_t v52 = 2082;
        v53 = (uint64_t)v29;
        _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s called with null http2, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v29);
      goto LABEL_83;
    }

    if (v30)
    {
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http2_send_goaway";
      os_log_type_t v24 = "%{public}s called with null http2, no backtrace";
LABEL_82:
      _os_log_impl(&dword_181A5C000, v22, v23, v24, buf, 0xCu);
    }
  }

  if (v13) {
    free(v13);
  }
}

          free(backtrace_string);
          if (!default_input_handler) {
            return;
          }
          goto LABEL_50;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv6_error";
          os_log_type_t v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv6_error";
          os_log_type_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    BOOL v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_ipv6_error";
    os_log_type_t v16 = "%{public}s called with null protocol";
LABEL_48:
    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
    goto LABEL_49;
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_ipv6_error";
    default_input_handler = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v38 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        __int16 v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v41 = "nw_protocol_ipv6_error";
            uint64_t v42 = 2082;
            __int16 v43 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null ipv6, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

          goto LABEL_34;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv6_error";
          os_log_type_t v16 = "%{public}s called with null ipv6, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv6_error";
          os_log_type_t v16 = "%{public}s called with null ipv6, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    BOOL v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_ipv6_error";
    os_log_type_t v16 = "%{public}s called with null ipv6";
    goto LABEL_48;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_ipv6_error";
    default_input_handler = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v38 = 0;
    if (__nwlog_fault((const char *)default_input_handler, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv6_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_48;
        }
      }

      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        unint64_t v35 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v41 = "nw_protocol_ipv6_error";
            uint64_t v42 = 2082;
            __int16 v43 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

          goto LABEL_34;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv6_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv6_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }

          free(backtrace_string);
          if (!default_input_handler) {
            return;
          }
          goto LABEL_50;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv4_error";
          os_log_type_t v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv4_error";
          os_log_type_t v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    BOOL v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_ipv4_error";
    os_log_type_t v16 = "%{public}s called with null protocol";
LABEL_48:
    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
    goto LABEL_49;
  }

  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_ipv4_error";
    default_input_handler = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v38 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        __int16 v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v41 = "nw_protocol_ipv4_error";
            uint64_t v42 = 2082;
            __int16 v43 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

          goto LABEL_34;
        }

        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv4_error";
          os_log_type_t v16 = "%{public}s called with null ipv4, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv4_error";
          os_log_type_t v16 = "%{public}s called with null ipv4, backtrace limit exceeded";
          goto LABEL_48;
        }
      }

      goto LABEL_49;
    }

    os_log_type_t v14 = (os_log_s *)__nwlog_obj();
    BOOL v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_ipv4_error";
    os_log_type_t v16 = "%{public}s called with null ipv4";
    goto LABEL_48;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_ipv4_error";
    default_input_handler = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v38 = 0;
    if (__nwlog_fault((const char *)default_input_handler, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv4_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol";
          goto LABEL_48;
        }
      }

      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        unint64_t v35 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v41 = "nw_protocol_ipv4_error";
            uint64_t v42 = 2082;
            __int16 v43 = backtrace_string;
            os_log_type_t v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

          goto LABEL_34;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv4_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_48;
        }
      }

      else
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_protocol_ipv4_error";
          os_log_type_t v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }

LABEL_17:
  return v7;
}

  return v6;
}

        int v6 = 1LL;
        goto LABEL_18;
      }
    }

    int v6 = 0LL;
  }

  if (v2) {
    free(v2);
  }
}

  if (v2) {
    free(v2);
  }
  return 0LL;
}

LABEL_36:
    id v4 = 0LL;
    goto LABEL_7;
  }

  id v3 = nw_delta_nanos(v1[4], v1[5]);
  if (v3 <= 0xF423FFFFFFFFFLL) {
    id v4 = (v3 / 0xF4240);
  }
  else {
    id v4 = 0xFFFFFFFFLL;
  }
LABEL_7:

  return v4;
}
  }

  int v6 = *a1;
  BOOL v7 = v6 >= 6;
  os_log_type_t v8 = v6 - 6;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  int v6 = *a1;
  BOOL v7 = v6 >= 0xC;
  os_log_type_t v8 = v6 - 12;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  int v6 = *a1;
  BOOL v7 = v6 >= 2;
  os_log_type_t v8 = v6 - 2;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  int v6 = *a1;
  BOOL v7 = v6 >= 3;
  os_log_type_t v8 = v6 - 3;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

        __break(1u);
        goto LABEL_18;
      }

      __break(1u);
    }

    else
    {
      os_log_type_t v12 = *(void *)(v4 + 16);
      swift_retain();
      swift_retain();
      os_log_type_t v13 = sub_18264E484();
      if (!v13)
      {
LABEL_19:
        sub_18264E49C();
        __break(1u);
        JUMPOUT(0x181BDB61CLL);
      }

      os_log_type_t v14 = v13;
      BOOL v15 = sub_18264E4A8();
      os_log_type_t v16 = __OFSUB__(v12, v15);
      char v17 = v12 - v15;
      if (!v16)
      {
        sub_18264E49C();
        os_log_type_t v9 = *(_DWORD *)(v14 + v17);
        swift_release();
        swift_release();
        goto LABEL_13;
      }
    }

    __break(1u);
    goto LABEL_17;
  }

  sub_181BCD4F0(v4, v3);
  BOOL result = sub_181BC69C8(v2);
  os_log_type_t v11 = 0LL;
  uint64_t v2 = 2LL;
LABEL_14:
  void *v1 = v11;
  v1[1] = v2;
  return result;
}

        __break(1u);
        goto LABEL_18;
      }

      __break(1u);
    }

    else
    {
      os_log_type_t v16 = *(void *)(v3 + 16);
      swift_retain();
      swift_retain();
      char v17 = sub_18264E484();
      if (!v17)
      {
LABEL_19:
        sub_18264E49C();
        __break(1u);
        JUMPOUT(0x181BDCDA0LL);
      }

      os_log_type_t v18 = v17;
      os_log_type_t v19 = sub_18264E4A8();
      BOOL v20 = __OFSUB__(v16, v19);
      __int16 v21 = v16 - v19;
      if (!v20)
      {
        sub_18264E49C();
        id v22 = v18 + v21;
        os_log_type_t v9 = *(_BYTE *)(v18 + v21);
        v23.i32[0] = *(_DWORD *)(v22 + 1);
        os_log_type_t v28 = vmovl_u8(v23);
        os_log_type_t v11 = *(unsigned __int8 *)(v22 + 5);
        swift_release();
        swift_release();
        goto LABEL_13;
      }
    }

    __break(1u);
    goto LABEL_17;
  }

  BOOL result = sub_181BCD4F0(v3, v2);
  os_log_type_t v13 = 0LL;
  os_log_type_t v14 = 1;
LABEL_14:
  *(_DWORD *)uint64_t v1 = v13;
  *(_WORD *)(v1 + 4) = WORD2(v13);
  *(_BYTE *)(v1 + 6) = v14;
  return result;
}

  int v6 = *a1;
  BOOL v7 = v6 >= 5;
  os_log_type_t v8 = v6 - 5;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  int v6 = *a1;
  BOOL v7 = v6 >= 7;
  os_log_type_t v8 = v6 - 7;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  int v6 = *(unsigned __int8 *)a1;
  BOOL v7 = v6 >= 3;
  os_log_type_t v8 = v6 - 3;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  int v6 = ((*a1 >> 2) & 2 | (*a1 >> 4) & 1) ^ 3;
  if (v6 >= 2) {
    int v6 = -1;
  }
  return v6 + 1;
}

  int v6 = ((*a1 >> 5) & 0xFFFFFF87 | (8 * ((*a1 >> 1) & 0xF))) ^ 0x7F;
  if (v6 >= 0x7B) {
    int v6 = -1;
  }
  return v6 + 1;
}

  *(void *)(a1 + a3[13]) = *(void *)(a2 + a3[13]);
  swift_unknownObjectRetain();
  swift_unknownObjectRelease();
  return a1;
}

  int v6 = *a1;
  BOOL v7 = v6 >= 4;
  os_log_type_t v8 = v6 - 4;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  os_log_type_t v11 = *v0;
  os_log_type_t v12 = v0[1];
  BOOL result = v0[2];
  os_log_type_t v14 = ((unint64_t)*v0 >> 59) & 1;
  if ((v12 & 0x1000000000000000LL) == 0) {
    LOBYTE(v14) = 1;
  }
  if ((v0[2] & 0xC) == 4LL << v14)
  {
    BOOL result = sub_181C23710(result, *v0, v0[1]);
    if ((v12 & 0x1000000000000000LL) == 0) {
      goto LABEL_21;
    }
  }

  else if ((v12 & 0x1000000000000000LL) == 0)
  {
LABEL_21:
    BOOL v15 = (result & 0xFFFFFFFFFFFF0000LL) + 65540;
LABEL_22:
    v0[2] = v15;
    os_log_type_t v16 = (void (*)(uint64_t *__return_ptr, void *))v0[3];
    LOBYTE(v18[0]) = v10;
    v16(&v19, v18);
    int v6 = v19;
    return v6 | ((v5 == 4 * v4) << 8);
  }

  char v17 = HIBYTE(v12) & 0xF;
  if ((v12 & 0x2000000000000000LL) == 0) {
    char v17 = v11 & 0xFFFFFFFFFFFFLL;
  }
  if (v17 > result >> 16)
  {
    BOOL v15 = sub_18264EB98();
    goto LABEL_22;
  }

  __break(1u);
  return result;
}

  int v6 = *a1;
  BOOL v7 = v6 >= 0xF;
  os_log_type_t v8 = v6 - 15;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  *(_BYTE *)(v0 + 69) = v13;
  *(void *)(v0 + 472) = v16;
  *(void *)(v0 + 480) = v17;
  *(void *)(v0 + 464) = v14;
  return swift_task_switch();
}

  int v6 = *a1;
  BOOL v7 = v6 >= 8;
  os_log_type_t v8 = v6 - 8;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  int v6 = *a1;
  BOOL v7 = v6 >= 2;
  os_log_type_t v8 = (v6 + 2147483646) & 0x7FFFFFFF;
  if (!v7) {
    os_log_type_t v8 = -1;
  }
  return (v8 + 1);
}

  if (v2 >> 60 == 15)
  {
    if (v4 >> 60 == 15) {
      return 1LL;
    }
    goto LABEL_21;
  }

  if (v4 >> 60 == 15)
  {
LABEL_21:
    sub_181BE61C8(v3, v2);
    sub_181BE61C8(v5, v4);
    return 0LL;
  }

  sub_181BCD4AC(v3, v2);
  sub_181C05AD4(v3, v2);
  os_log_type_t v11 = v10;
  sub_181BE61C8(v5, v4);
  sub_181BE61C8(v3, v2);
  sub_181BE61C8(v3, v2);
  return v11 & 1;
}

              if (output_handler->handle == &nw_protocol_ref_counted_handle)
              {
                os_log_type_t v14 = output_handler[1].callbacks;
                if (v14)
                {
                  BOOL v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
                  output_handler[1].callbacks = v15;
                  if (!v15)
                  {
                    os_log_type_t v16 = *(void (***)(void))output_handler[1].flow_id;
                    if (v16)
                    {
                      *(void *)output_handler[1].flow_id = 0LL;
                      v16[2](v16);
                      _Block_release(v16);
                    }

                    if ((output_handler[1].flow_id[8] & 1) != 0)
                    {
                      char v17 = *(const void **)output_handler[1].flow_id;
                      if (v17) {
                        _Block_release(v17);
                      }
                    }

                    free(output_handler);
                  }
                }
              }

              goto LABEL_18;
            }
          }

          __nwlog_obj();
          name = output_handler->identifier->name;
          *(_DWORD *)buf = 136446722;
          v56 = "__nw_protocol_finalize_output_frames";
          if (!name) {
            name = "invalid";
          }
          os_log_type_t v57 = 2082;
          BOOL v58 = (void *)name;
          os_log_type_t v59 = 2048;
          os_log_type_t v60 = output_handler;
          os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v53 = 0;
          if (__nwlog_fault(v19, &type, &v53))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              BOOL v20 = (os_log_s *)__nwlog_obj();
              __int16 v21 = type;
              if (!os_log_type_enabled(v20, type)) {
                goto LABEL_80;
              }
              id v22 = output_handler->identifier->name;
              if (!v22) {
                id v22 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v56 = "__nw_protocol_finalize_output_frames";
              os_log_type_t v57 = 2082;
              BOOL v58 = (void *)v22;
              os_log_type_t v59 = 2048;
              os_log_type_t v60 = output_handler;
              uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_79:
              _os_log_impl(&dword_181A5C000, v20, v21, v23, buf, 0x20u);
              goto LABEL_80;
            }

            if (!v53)
            {
              BOOL v20 = (os_log_s *)__nwlog_obj();
              __int16 v21 = type;
              if (!os_log_type_enabled(v20, type)) {
                goto LABEL_80;
              }
              uint64_t v41 = output_handler->identifier->name;
              if (!v41) {
                uint64_t v41 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v56 = "__nw_protocol_finalize_output_frames";
              os_log_type_t v57 = 2082;
              BOOL v58 = (void *)v41;
              os_log_type_t v59 = 2048;
              os_log_type_t v60 = output_handler;
              uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
              goto LABEL_79;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            BOOL v20 = (os_log_s *)__nwlog_obj();
            __int16 v21 = type;
            uint64_t v29 = os_log_type_enabled(v20, type);
            if (!backtrace_string)
            {
              if (!v29) {
                goto LABEL_80;
              }
              uint64_t v42 = output_handler->identifier->name;
              if (!v42) {
                uint64_t v42 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v56 = "__nw_protocol_finalize_output_frames";
              os_log_type_t v57 = 2082;
              BOOL v58 = (void *)v42;
              os_log_type_t v59 = 2048;
              os_log_type_t v60 = output_handler;
              uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
              goto LABEL_79;
            }

            if (v29)
            {
              char v30 = output_handler->identifier->name;
              if (!v30) {
                char v30 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              v56 = "__nw_protocol_finalize_output_frames";
              os_log_type_t v57 = 2082;
              BOOL v58 = (void *)v30;
              os_log_type_t v59 = 2048;
              os_log_type_t v60 = output_handler;
              v61 = 2082;
              id v62 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
          }

  char v25 = 0u;
  os_log_type_t v26 = 0u;
  uint64_t v23 = 0u;
  os_log_type_t v24 = 0u;
  os_log_type_t v19 = v16;
  BOOL v20 = [v19 countByEnumeratingWithState:&v23 objects:buf count:16];
  if (v20)
  {
    __int16 v21 = *(void *)v24;
    do
    {
      for (i = 0LL; i != v20; ++i)
      {
        if (*(void *)v24 != v21) {
          objc_enumerationMutation(v19);
        }
        nw_candidate_manager_remove_hostname_resolver(v11, *(void **)(*((void *)&v23 + 1) + 8 * i));
      }

      BOOL v20 = [v19 countByEnumeratingWithState:&v23 objects:buf count:16];
    }

    while (v20);
  }
}

  if (v4) {
    free(v4);
  }
}

    if (v4) {
      free(v4);
    }
    *(_DWORD *)(a1 + 208) = 0;
    return (*(_BYTE *)(a1 + 212) & 0x40) == 0;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v24 = "nw_protocol_plugin_retry_end_async";
  BOOL v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v21 = 0;
  if (__nwlog_fault(v15, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      char v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_plugin_retry_end_async";
        os_log_type_t v18 = "%{public}s called with null retry";
LABEL_35:
        _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
      }
    }

    else if (v21)
    {
      os_log_type_t v19 = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      char v17 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (v19)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v24 = "nw_protocol_plugin_retry_end_async";
          char v25 = 2082;
          os_log_type_t v26 = v19;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null retry, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v19);
        goto LABEL_36;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_plugin_retry_end_async";
        os_log_type_t v18 = "%{public}s called with null retry, no backtrace";
        goto LABEL_35;
      }
    }

    else
    {
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      char v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_protocol_plugin_retry_end_async";
        os_log_type_t v18 = "%{public}s called with null retry, backtrace limit exceeded";
        goto LABEL_35;
      }
    }
  }

LABEL_18:
          if (!v12) {
            continue;
          }
LABEL_19:
          free(v12);
          continue;
        }

        if (!v28)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v13 = (os_log_s *)(id)gLogObj;
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v13, type))
          {
            buf = 136446210;
            uint64_t v36 = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata_block_invoke";
            _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s failed to get UTF8 string from DNS name, backtrace limit exceeded",  (uint8_t *)&buf,  0xCu);
          }

          goto LABEL_17;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v16 = type;
        char v17 = os_log_type_enabled(v13, type);
        if (!backtrace_string)
        {
          if (v17)
          {
            buf = 136446210;
            uint64_t v36 = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata_block_invoke";
            _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s failed to get UTF8 string from DNS name, no backtrace",  (uint8_t *)&buf,  0xCu);
          }

          goto LABEL_17;
        }

        if (v17)
        {
          buf = 136446466;
          uint64_t v36 = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata_block_invoke";
          os_log_type_t v37 = 2082;
          os_log_type_t v38 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s failed to get UTF8 string from DNS name, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x16u);
        }

        free(backtrace_string);
        if (v12) {
          goto LABEL_19;
        }
      }

      id v4 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
    }

    while (v4);
  }

  if (cf) {
    CFRelease(cf);
  }
}
      }

      external = external;
      external[2] = 0LL;
      os_log_type_t v18 = *(void **)(a4 + 8);
      external[3] = v18;
      *os_log_type_t v18 = external;
      *(void *)(a4 + 8) = external + 2;
      goto LABEL_18;
    }
  }

  os_log_type_t v16 = malloc(a2);
  if (v16)
  {
    BOOL v15 = (BOOL)v16;
    os_log_type_t v14 = 0LL;
    goto LABEL_11;
  }

  __nwlog_obj();
  uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  os_log_type_t v38 = "strict_malloc";
  char v39 = 2048;
  __int16 v40 = (char *)a2;
  char v32 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v32);
  if (!result)
  {
    free(v32);
    os_log_type_t v14 = 0LL;
    BOOL v15 = 0LL;
    goto LABEL_11;
  }

  __break(1u);
  return result;
}

  if (v1) {
LABEL_11:
  }
    free(v1);
}

  *(_BYTE *)(v2 + 190) = v6 | 0x10;
}

    if (v13 == ++v17)
    {
      uint64_t v36 = 0LL;
      os_log_type_t v37 = 2LL;
      goto LABEL_37;
    }
  }

  if (v2)
  {
    if (*(_BYTE *)(a1 + 56))
    {
      [v28 setState:1];
      uint64_t v36 = v28;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v42 = (os_log_s *)(id)v26[131];
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      {
        __int16 v43 = [*(id *)(a1 + 40) mID];
        [v2 UUIDString];
        os_log_type_t v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446722;
        v78 = "-[NWMonitor evaluateStartingAtIndex:probeUUID:probeWasSuccessful:]_block_invoke";
        v79 = 1024;
        v80 = v43;
        v81 = 2114;
        v82 = v44;
        _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEBUG,  "%{public}s %u received successful probe %{public}@",  buf,  0x1Cu);
      }

      uint64_t v2 = 0LL;
      goto LABEL_36;
    }

    [v28 setState:3];
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v30 = (os_log_s *)(id)v26[131];
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v31 = [*(id *)(a1 + 40) mID];
      [v2 UUIDString];
      char v32 = v26;
      id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446722;
      v78 = "-[NWMonitor evaluateStartingAtIndex:probeUUID:probeWasSuccessful:]_block_invoke";
      v79 = 1024;
      v80 = v31;
      v81 = 2114;
      v82 = v33;
      _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %u received unsuccessful probe %{public}@",  buf,  0x1Cu);

      os_log_type_t v26 = v32;
      int v6 = v68;
    }

LABEL_27:
    uint64_t v2 = 0LL;
    goto LABEL_17;
  }

  __int16 v34 = [v28 probeURL];
  if (!v34)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (id)v26[131];
    if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
    {
      unint64_t v35 = [*(id *)(a1 + 40) mID];
      *(_DWORD *)buf = 136446466;
      v78 = "-[NWMonitor evaluateStartingAtIndex:probeUUID:probeWasSuccessful:]_block_invoke";
      v79 = 1024;
      v80 = v35;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v2,  OS_LOG_TYPE_ERROR,  "%{public}s %u ERROR: NWNDShouldProbe but nil probeURL",  buf,  0x12u);
    }

    goto LABEL_27;
  }

  v48 = (void *)v34;
  [*(id *)(a1 + 40) lastProbeURL];
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v50 = [v48 isEqual:v49];

  if (v50)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v52 = [*(id *)(a1 + 40) mID];
        *(_DWORD *)buf = 136446466;
        v78 = "-[NWMonitor evaluateStartingAtIndex:probeUUID:probeWasSuccessful:]_block_invoke";
        v79 = 1024;
        v80 = v52;
        _os_log_impl(&dword_181A5C000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %u already sent probe out", buf, 0x12u);
      }

      int v6 = v68;
      goto LABEL_52;
    }
  }

  else
  {
    [MEMORY[0x189607AB8] UUID];
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    [*(id *)(a1 + 40) setLastProbeUUID:v53];
    [*(id *)(a1 + 40) setLastProbeURL:v48];
    __nwlog_obj();
    os_log_type_t v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
    {
      BOOL v55 = [*(id *)(a1 + 40) mID];
      [v53 UUIDString];
      v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136447234;
      v78 = "-[NWMonitor evaluateStartingAtIndex:probeUUID:probeWasSuccessful:]_block_invoke";
      v79 = 1024;
      v80 = v55;
      v81 = 2114;
      v82 = v56;
      v83 = 2114;
      v84 = v48;
      v85 = 2048;
      v86 = v17;
      _os_log_impl( &dword_181A5C000,  v54,  OS_LOG_TYPE_DEBUG,  "%{public}s %u sending out probe %{public}@ to %{public}@ for description %lu",  buf,  0x30u);
    }

    os_log_type_t v57 = (void *)MEMORY[0x189601EF8];
    [MEMORY[0x189601F00] defaultSessionConfiguration];
    BOOL v58 = (void *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v59 = *(void *)(a1 + 40);
    [(id)objc_opt_class() mainOperationQueue];
    os_log_type_t v60 = (void *)objc_claimAutoreleasedReturnValue();
    [v57 sessionWithConfiguration:v58 delegate:v59 delegateQueue:v60];
    v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();

    v73[0] = MEMORY[0x1895F87A8];
    v73[1] = 3221225472LL;
    v73[2] = __66__NWMonitor_evaluateStartingAtIndex_probeUUID_probeWasSuccessful___block_invoke_28;
    v73[3] = &unk_189BB7428;
    v73[4] = *(void *)(a1 + 40);
    v74 = v53;
    v75 = v48;
    v76 = v17;
    v61 = v53;
    -[os_log_s dataTaskWithURL:completionHandler:](v51, "dataTaskWithURL:completionHandler:", v75, v73);
    id v62 = (void *)objc_claimAutoreleasedReturnValue();
    [v62 resume];
    -[os_log_s finishTasksAndInvalidate](v51, "finishTasksAndInvalidate");

LABEL_52:
    BOOL v15 = v67;
  }

  uint64_t v2 = 0LL;
  uint64_t v36 = 0LL;
LABEL_42:

LABEL_43:
}
  }

LABEL_18:
    int v6 = 0;
    goto LABEL_19;
  }

  nw_array_append(*((void *)v3 + 4), v5);
  int v6 = 1;
LABEL_19:

  return v6;
}

  if (v1) {
LABEL_11:
  }
    free(v1);
}

        goto LABEL_18;
      }

      goto LABEL_18;
    }

    v185 = node + 32;
    is_null = uuid_is_null((const unsigned __int8 *)(node + 32));
    os_log_type_t v12 = *(void **)(v7 + 152);
    if (v12)
    {
      os_log_type_t v13 = v12;
LABEL_43:
      v183 = (void **)(v4 + 40);
      goto LABEL_44;
    }

    if (!*((void *)v4 + 45) && !*((void *)v4 + 46))
    {
LABEL_49:
      id v33 = *((id *)v4 + 44);
      v183 = (void **)(v4 + 40);
      if (!v33)
      {
        char v25 = (nw_endpoint *)*((id *)v4 + 5);
        v186 = 0LL;
        __int16 v27 = 0LL;
        if (!v25) {
          goto LABEL_65;
        }
        goto LABEL_45;
      }

      os_log_type_t v13 = v33;
LABEL_44:
      char v25 = (nw_endpoint *)v13;
      v186 = v25;
LABEL_45:
      endpoint = v25;
      os_log_type_t v26 = -[nw_endpoint type](endpoint, "type");

      if (v26 == 1)
      {
        __int16 v27 = endpoint;
        os_log_type_t v28 = nw_parameters_create();
        nw_parameters_require_interface(v28, *(nw_interface_t *)(v7 + 48));
        evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0LL, v28);
        char v30 = (os_unfair_lock_s *)evaluator_for_endpoint;
        if (evaluator_for_endpoint)
        {
          uint64_t v31 = evaluator_for_endpoint;
          os_unfair_lock_lock(v30 + 24);
          char v32 = v31[6];
          os_unfair_lock_unlock(v30 + 24);
        }

        else
        {
          char v32 = 0LL;
        }

        is_eligible_for_CrazyIvan46 = nw_path_is_eligible_for_CrazyIvan46(v32);

        if (is_eligible_for_CrazyIvan46)
        {
          unint64_t v35 = *(void *)(v7 + 48);
          if (v35) {
            LODWORD(v35) = *(_DWORD *)(v35 + 8);
          }
          LODWORD(v202[0]) = v35;
          address = nw_endpoint_get_address(endpoint);
          *(void *)&v219 = 0LL;
          os_log_type_t v37 = nw_nat64_copy_prefixes((unsigned int *)v202, &v219);
          if (v37 >= 1)
          {
            v181 = is_null;
            os_log_type_t v38 = 0LL;
            char v39 = 16LL * v37;
            while (1)
            {
              __dst = 0uLL;
              if (nw_nat64_synthesize_v6( (void *)(v219 + v38),  (__int16 *)&address->sa_data[2],  (char *)&__dst)) {
                break;
              }
              v38 += 16LL;
              if (v39 == v38)
              {
                is_null = v181;
                goto LABEL_61;
              }
            }

            *(_WORD *)buf = 7708;
            *(_WORD *)&buf[2] = *(_WORD *)address->sa_data;
            *(_OWORD *)&buf[8] = __dst;
            *(_DWORD *)&uint8_t buf[4] = 0;
            LODWORD(v208) = 0;
            __int16 v40 = nw_endpoint_create_address((const sockaddr *)buf);

            is_null = v181;
            v186 = v40;
          }
  }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v15 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v16 = *(_DWORD *)(a1 + 48);
      os_log_type_t v18 = 136446722;
      os_log_type_t v19 = "nw_protocol_outbound_data_finalizer_block_invoke";
      BOOL v20 = 1024;
      __int16 v21 = v16;
      id v22 = 1024;
      uint64_t v23 = v7;
      _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s Could not get frame for %u bytes (%u bytes)",  (uint8_t *)&v18,  0x18u);
    }

    nw_frame_finalize(v4);
    goto LABEL_20;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v9 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    os_log_type_t v10 = *(_DWORD *)(a1 + 48);
    os_log_type_t v18 = 136446466;
    os_log_type_t v19 = "nw_protocol_outbound_data_finalizer_block_invoke";
    BOOL v20 = 1024;
    __int16 v21 = v10;
    _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Could not get frame for %u bytes",  (uint8_t *)&v18,  0x12u);
  }

LABEL_20:
  nw_protocol_data_finalizer( *(void **)(a1 + 40),  *(void **)(a1 + 32),  *(unsigned __int8 *)(a1 + 52),  *(void *)(a1 + 40) + 144LL);
}

    os_log_type_t v11 = 0LL;
    if (a3) {
      goto LABEL_10;
    }
LABEL_18:
    os_log_type_t v13 = 0LL;
    os_log_type_t v14 = 0LL;
LABEL_19:
    BOOL v20 = nw_frame_create(16, v14, a3, (uint64_t)nw_protocol_outbound_data_finalizer, (uint64_t)v5);
    if (v20)
    {
      os_log_type_t v18 = (void *)v20;
      if (v13)
      {
        *(void *)(v20 + 104) = v13;
      }

      else if (v14)
      {
        *(_WORD *)(v20 + 204) |= 1u;
      }

      goto LABEL_24;
    }

    __nwlog_obj();
    os_log_type_t v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v59 = "nw_protocol_data_copy_outbound_subdata";
    os_log_type_t v38 = (char *)_os_log_send_and_compose_impl();

    type[4] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (type[4] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v40 = type[4];
      if (os_log_type_enabled(v39, type[4]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_protocol_data_copy_outbound_subdata";
        _os_log_impl(&dword_181A5C000, v39, v40, "%{public}s nw_frame_create failed", buf, 0xCu);
      }
    }

    else if (type[0])
    {
      v46 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type[4];
      v48 = os_log_type_enabled(v39, type[4]);
      if (v46)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v59 = "nw_protocol_data_copy_outbound_subdata";
          os_log_type_t v60 = 2082;
          v61 = (size_t)v46;
          _os_log_impl( &dword_181A5C000,  v39,  v47,  "%{public}s nw_frame_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v46);
        goto LABEL_99;
      }

      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_protocol_data_copy_outbound_subdata";
        _os_log_impl(&dword_181A5C000, v39, v47, "%{public}s nw_frame_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v54 = type[4];
      if (os_log_type_enabled(v39, type[4]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v59 = "nw_protocol_data_copy_outbound_subdata";
        _os_log_impl( &dword_181A5C000,  v39,  v54,  "%{public}s nw_frame_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }

LABEL_99:
    if (v38) {
      free(v38);
    }
LABEL_101:
    __int16 v21 = 0LL;
    goto LABEL_25;
  }

  if (v1) {
LABEL_11:
  }
    free(v1);
}
  }
  }

      return;
    }

    __nwlog_obj();
    BOOL v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_flow_replay_get_message_properties";
    __int16 v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v33 = 0;
    if (__nwlog_fault(v21, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_flow_replay_get_message_properties";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        uint64_t v29 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v36 = "nw_flow_replay_get_message_properties";
            os_log_type_t v37 = 2082;
            os_log_type_t v38 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v22,  v28,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }

        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_flow_replay_get_message_properties";
          _os_log_impl(&dword_181A5C000, v22, v28, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v31 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_flow_replay_get_message_properties";
          _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      return;
    }

    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v38 = "nw_flow_replay_disconnected";
    BOOL v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unint64_t v35 = 0;
    if (__nwlog_fault(v20, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_flow_replay_disconnected";
          _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v27 = type;
        os_log_type_t v28 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v38 = "nw_flow_replay_disconnected";
            char v39 = 2082;
            __int16 v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v21,  v27,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_flow_replay_disconnected";
          _os_log_impl(&dword_181A5C000, v21, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v30 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_flow_replay_disconnected";
          _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

            is_equal = 0LL;
          }
        }
      }
    }
  }

          free(v7);
          if (!v3) {
            return;
          }
LABEL_25:
          free(v3);
          return;
        }

        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
          int v6 = "%{public}s called with null existing_protocol, no backtrace";
          goto LABEL_23;
        }
      }

      else
      {
        id v4 = (os_log_s *)__nwlog_obj();
        int v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
          int v6 = "%{public}s called with null existing_protocol, backtrace limit exceeded";
          goto LABEL_23;
        }
      }

      goto LABEL_24;
    }

    id v4 = (os_log_s *)__nwlog_obj();
    int v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_24;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
    int v6 = "%{public}s called with null existing_protocol";
    goto LABEL_23;
  }

  handle = (nw_protocol **)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v15 = 0;
    if (__nwlog_fault(v3, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v4 = (os_log_s *)__nwlog_obj();
        int v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
          int v6 = "%{public}s called with null http_client_bottom";
          goto LABEL_23;
        }
      }

      else if (v15)
      {
        BOOL v7 = (char *)__nw_create_backtrace_string();
        id v4 = (os_log_s *)__nwlog_obj();
        int v5 = type;
        os_log_type_t v13 = os_log_type_enabled(v4, type);
        if (v7)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
            os_log_type_t v19 = 2082;
            BOOL v20 = v7;
            os_log_type_t v9 = "%{public}s called with null http_client_bottom, dumping backtrace:%{public}s";
            goto LABEL_16;
          }

          goto LABEL_17;
        }

        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
          int v6 = "%{public}s called with null http_client_bottom, no backtrace";
          goto LABEL_23;
        }
      }

      else
      {
        id v4 = (os_log_s *)__nwlog_obj();
        int v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_protocol_http_client_bottom_listen_protocol_disconnected";
          int v6 = "%{public}s called with null http_client_bottom, backtrace limit exceeded";
          goto LABEL_23;
        }
      }
    }

      *(void *)handle[3].flow_id = v8;
      char v17 = (unsigned __int16)WORD2(handle[4].output_handler)++ + 1;
      if ((v17 & 0x10000) != 0)
      {
        if (gLogDatapath)
        {
          v47 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            v48 = WORD2(handle[4].output_handler);
            *(_DWORD *)buf = 136446978;
            os_log_type_t v52 = "nw_protocol_http_client_bottom_remove_input_handler";
            v53 = 2082;
            os_log_type_t v54 = (nw_protocol *)"http_client_bottom->stream_stall_count";
            BOOL v55 = 2048;
            v56 = 1LL;
            os_log_type_t v57 = 2048;
            BOOL v58 = v48;
            _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s Overflow: %{public}s, increment %llu, result %llu",  buf,  0x2Au);
          }
        }

        WORD2(handle[4].output_handler) = -1;
      }

      if ((BYTE6(handle[4].output_handler) & 4) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v19 = WORD2(handle[4].output_handler);
          *(_DWORD *)buf = 136446978;
          os_log_type_t v52 = "nw_protocol_http_client_bottom_remove_input_handler";
          v53 = 2082;
          os_log_type_t v54 = (nw_protocol *)((char *)handle + 208);
          BOOL v55 = 2080;
          v56 = (uint64_t)" ";
          os_log_type_t v57 = 1024;
          LODWORD(v58) = v19;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%sstream setup stalls incremented to %u",  buf,  0x26u);
        }
      }

      goto LABEL_44;
    }

          os_log_type_t v14 = v643 + 1;
          os_log_type_t v13 = v644;
        }

        while (v642 != v643 + 1);
        v642 = [obj countByEnumeratingWithState:&v653 objects:v657 count:16];
        if (!v642)
        {

          a1 = v637;
          id v4 = v638;
          os_log_type_t v12 = v639;
          break;
        }
      }
    }

    [MEMORY[0x189603F50] date];
    v624 = (void *)objc_claimAutoreleasedReturnValue();
    [*(id *)(a1 + 40) setObject:v624 forKeyedSubscript:@"LastAttempt"];
    [v12 setObject:v624 forKeyedSubscript:@"LastSuccess"];
    v625 = [v12 writeToFile:@"/Library/Preferences/com.apple.networkd.networknomicon.plist" atomically:1];
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v626 = (os_log_s *)(id)v5[131];
    v627 = v626;
    if (v625)
    {
      if (os_log_type_enabled(v626, OS_LOG_TYPE_DEFAULT))
      {
        buf = 136446210;
        v659 = "nwphCheckMobileAsset_block_invoke";
        _os_log_impl( &dword_181A5C000,  v627,  OS_LOG_TYPE_DEFAULT,  "%{public}s Saved successful mobile asset load date to disk",  (uint8_t *)&buf,  0xCu);
      }

LABEL_693:
      goto LABEL_694;
    }

    buf = 136446722;
    v659 = "nwphCheckMobileAsset_block_invoke";
    v660 = 2114;
    v661 = (uint64_t)v12;
    v662 = 2114;
    v663 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
    v628 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v646 = 0;
    if (!__nwlog_fault((const char *)v628, &type, &v646))
    {
LABEL_691:
      if (v628) {
        free(v628);
      }
      goto LABEL_693;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v629 = (os_log_s *)(id)v5[131];
      v630 = type;
      if (os_log_type_enabled(v629, type))
      {
        buf = 136446722;
        v659 = "nwphCheckMobileAsset_block_invoke";
        v660 = 2114;
        v661 = (uint64_t)v12;
        v662 = 2114;
        v663 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
        v631 = "%{public}s Failed to save mobile asset networknomicon success %{public}@ to %{public}@";
LABEL_688:
        v635 = v629;
        v636 = v630;
LABEL_689:
        _os_log_impl(&dword_181A5C000, v635, v636, v631, (uint8_t *)&buf, 0x20u);
      }
    }

    else
    {
      if (v646)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v629 = (os_log_s *)(id)v5[131];
        v633 = type;
        v634 = os_log_type_enabled(v629, type);
        if (backtrace_string)
        {
          if (v634)
          {
            buf = 136446978;
            v659 = "nwphCheckMobileAsset_block_invoke";
            v660 = 2114;
            v661 = (uint64_t)v12;
            v662 = 2114;
            v663 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
            v664 = 2082;
            v665 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v629,  v633,  "%{public}s Failed to save mobile asset networknomicon success %{public}@ to %{public}@, dumping backtrace:%{public}s",  (uint8_t *)&buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_691;
        }

        if (!v634) {
          goto LABEL_690;
        }
        buf = 136446722;
        v659 = "nwphCheckMobileAsset_block_invoke";
        v660 = 2114;
        v661 = (uint64_t)v12;
        v662 = 2114;
        v663 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
        v631 = "%{public}s Failed to save mobile asset networknomicon success %{public}@ to %{public}@, no backtrace";
        v635 = v629;
        v636 = v633;
        goto LABEL_689;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v629 = (os_log_s *)(id)v5[131];
      v630 = type;
      if (os_log_type_enabled(v629, type))
      {
        buf = 136446722;
        v659 = "nwphCheckMobileAsset_block_invoke";
        v660 = 2114;
        v661 = (uint64_t)v12;
        v662 = 2114;
        v663 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
        v631 = "%{public}s Failed to save mobile asset networknomicon success %{public}@ to %{public}@, backtrace limit exceeded";
        goto LABEL_688;
      }
    }

  if (v1) {
LABEL_11:
  }
    free(v1);
}

  return experimental_probe != 0LL;
}

  os_log_type_t v8 = !v7;
  os_log_type_t v9 = a1;
  do
  {
    os_log_type_t v9 = *(void *)(v9 + 32);
    if (!v9)
    {
      os_log_type_t v11 = 0LL;
      goto LABEL_27;
    }

    os_log_type_t v10 = *(void **)(v9 + 16);
    if (nw_protocol_http3_identifier::onceToken != -1) {
      dispatch_once(&nw_protocol_http3_identifier::onceToken, &__block_literal_global_10);
    }
  }

  while (!nw_protocols_are_equal(v10, &nw_protocol_http3_identifier::http3_protocol_identifier));
  if ((*(_BYTE *)(a1 + 529) & 1) == 0 && gLogDatapath)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    __int16 v43 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_masque_setup_reverse_proxy";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 531;
      *(_WORD *)&buf[22] = 2080;
      v53 = " ";
      os_log_type_t v54 = 2048;
      BOOL v55 = v9;
      _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sFound HTTP protocol %p",  buf,  0x2Au);
    }
  }

  os_log_type_t v11 = v9;
LABEL_27:
  os_log_type_t v12 = *(void **)(a1 + 320);
  if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72514);
  }
  os_log_type_t v13 = nw_parameters_copy_protocol_options_for_definition( v12,  (id)nw_protocol_copy_http_messaging_definition_definition);
  os_log_type_t v14 = v13;
  if (v9) {
    BOOL v15 = v8;
  }
  else {
    BOOL v15 = 1;
  }
  if ((v15 & 1) == 0 && v13)
  {
    os_log_type_t v16 = *(void **)(a1 + 312);
    if (!v16)
    {
      if ((*(_BYTE *)(a1 + 529) & 1) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        uint64_t v36 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = a1 + 531;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = " ";
          _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s%sNo target endpoint, not attempting to reverse proxy",  buf,  0x16u);
        }
      }

      id v4 = 0LL;
      goto LABEL_74;
    }

    char v17 = v16;
    os_log_type_t v18 = (const char *)[v17 hostname];

    port = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 304));
    host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(v18, port);
    *(void *)buf = 0LL;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000LL;
    LOBYTE(v53) = 0;
    __int16 v21 = *(void **)(a1 + 456);
    id v22 = MEMORY[0x1895F87A8];
    v45[0] = MEMORY[0x1895F87A8];
    v45[1] = 0x40000000LL;
    v45[2] = ___ZL29nw_masque_setup_reverse_proxyP9nw_masque_block_invoke;
    v45[3] = &unk_189BBA578;
    v45[5] = a1;
    v45[6] = host_with_numeric_port;
    v45[4] = buf;
    nw_http_connection_metadata_enumerate_secondary_certificates(v21, v45);
    if (host_with_numeric_port) {
      os_release((void *)host_with_numeric_port);
    }
    os_log_type_t v24 = *(_DWORD *)(a1 + 527);
    if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
    {
      if ((v24 & 0x10000) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
        }
        char v25 = (os_log_s *)gprivacy_proxyLogObj;
        if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v26 = v17;
          __int16 v27 = [v26 hostname];

          *(_DWORD *)v46 = 136446722;
          v47 = a1 + 531;
          v48 = 2080;
          v49 = " ";
          os_log_type_t v50 = 2080;
          v51 = v27;
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_INFO,  "%{public}s%sFound secondary certificate for %s, attempting TLS termination and restart for reverse proxy",  v46,  0x20u);
        }
      }

      os_log_type_t v28 = *(void *)(a1 + 352);
      if (v28)
      {
        nw_queue_cancel_source(v28, v23);
        *(void *)(a1 + 352) = 0LL;
      }

      uint64_t v29 = nw_protocol_copy_info(v11, 253);
      if (nw_http_messaging_options_override_version_specific_protocol(v14, v11, *(void **)(a1 + 456)) || v29)
      {
        char v39 = *(void *)(a1 + 496);
        __int16 v40 = *(void **)(a1 + 328);
        v44[0] = v22;
        v44[1] = 0x40000000LL;
        v44[2] = ___ZL29nw_masque_setup_reverse_proxyP9nw_masque_block_invoke_67;
        v44[3] = &unk_189BBA5A0;
        v44[4] = v39;
        nw_queue_context_async(v40, v44);
        id v4 = 1LL;
        goto LABEL_73;
      }

      if ((*(_BYTE *)(a1 + 529) & 1) != 0) {
        goto LABEL_71;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      char v30 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
LABEL_71:
        id v4 = 0LL;
LABEL_73:
        _Block_object_dispose(buf, 8);
LABEL_74:
        os_release(v14);
        return v4;
      }

      *(_DWORD *)v46 = 136446466;
      v47 = a1 + 531;
      v48 = 2080;
      v49 = " ";
      uint64_t v31 = "%{public}s%sFailed to override persistent stack HTTP with reverse-proxying HTTP";
      char v32 = (os_log_s *)v30;
      id v33 = OS_LOG_TYPE_ERROR;
      __int16 v34 = 22;
    }

    else
    {
      if ((v24 & 0x10000) != 0) {
        goto LABEL_71;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
      }
      os_log_type_t v37 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_71;
      }
      hostname = nw_endpoint_get_hostname((nw_endpoint_t)v17);
      *(_DWORD *)v46 = 136446722;
      v47 = a1 + 531;
      v48 = 2080;
      v49 = " ";
      os_log_type_t v50 = 2080;
      v51 = (uint64_t)hostname;
      uint64_t v31 = "%{public}s%sNo matching secondary certificates found for %s, not reverse-proxying";
      char v32 = (os_log_s *)v37;
      id v33 = OS_LOG_TYPE_INFO;
      __int16 v34 = 32;
    }

    _os_log_impl(&dword_181A5C000, v32, v33, v31, v46, v34);
    goto LABEL_71;
  }

  if ((*(_BYTE *)(a1 + 529) & 1) == 0)
  {
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
    }
    unint64_t v35 = (os_log_s *)gprivacy_proxyLogObj;
    if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = a1 + 531;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = " ";
      _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s%sFailed to find HTTP protocol, proceeding without attempting to reverse proxy",  buf,  0x16u);
    }
  }

  id v4 = 0LL;
  if (v14) {
    goto LABEL_74;
  }
  return v4;
}

    goto LABEL_18;
  }

  int v6 = v5;
  nw_dictionary_set_value(*(void *)(a1 + 40), out, v5);
LABEL_18:
}

  if (v5) {
LABEL_11:
  }
    free(v5);
}

    free(v9);
    goto LABEL_18;
  }

  if (a1 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "tcp_connection_create_with_connected_fd";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "tcp_connection_create_with_connected_fd";
      os_log_type_t v12 = "%{public}s called with null fd";
LABEL_22:
      os_log_type_t v18 = v10;
      os_log_type_t v19 = v11;
      goto LABEL_23;
    }

    if (!v26)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "tcp_connection_create_with_connected_fd";
      os_log_type_t v12 = "%{public}s called with null fd, backtrace limit exceeded";
      goto LABEL_22;
    }

    os_log_type_t v13 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v10, type);
    if (!v13)
    {
      if (!v15)
      {
LABEL_24:

        if (!v9) {
          goto LABEL_18;
        }
        goto LABEL_17;
      }

      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "tcp_connection_create_with_connected_fd";
      os_log_type_t v12 = "%{public}s called with null fd, no backtrace";
      os_log_type_t v18 = v10;
      os_log_type_t v19 = v14;
LABEL_23:
      _os_log_impl(&dword_181A5C000, v18, v19, v12, buf, 0xCu);
      goto LABEL_24;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v29 = "tcp_connection_create_with_connected_fd";
      char v30 = 2082;
      uint64_t v31 = v13;
      _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s called with null fd, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    os_log_type_t v16 = (char *)v13;
    goto LABEL_15;
  }

  int v5 = tcp_connection_create_with_connected_fd_inner(a1, 0);
  int v6 = v5;
  if (v5)
  {
    objc_storeStrong((id *)v5 + 7, a2);
    nw_connection_set_queue(*((nw_connection_t *)v6 + 2), *((dispatch_queue_t *)v6 + 7));
    v6[157] = 6;
    BOOL v7 = v6;
  }

LABEL_19:
  return v6;
}

    free(v6);
    goto LABEL_18;
  }

  id v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "tcp_connection_did_fallback";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_18;
  }

  id v4 = nw_connection_used_fallback(v3);
LABEL_19:

  return v4;
}

    free(v6);
    goto LABEL_18;
  }

  id v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "tcp_connection_is_sleep_proxied";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_18;
  }

  id v4 = nw_connection_uses_sleep_proxy(v3);
LABEL_19:

  return v4;
}

    free(v6);
    goto LABEL_18;
  }

  id v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "tcp_connection_is_multipath";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_18;
  }

  id v4 = nw_connection_uses_multipath(v3);
LABEL_19:

  return v4;
}

    free(v5);
    goto LABEL_18;
  }

  if (!v1[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_18;
  }

  interface = tcp_connection_get_interface(v1);
LABEL_19:

  return interface;
}

    free(v6);
    goto LABEL_18;
  }

  id v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_18;
  }

  id v4 = nw_connection_multipath_copy_subflow_counts(v3);
LABEL_19:

  return v4;
}

    free(v6);
    goto LABEL_18;
  }

  id v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v10 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v20 = "tcp_connection_copy_tcp_info";
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_18;
  }

  id v4 = nw_connection_copy_tcp_info(v3);
LABEL_19:

  return v4;
}

  if (v1) {
LABEL_11:
  }
    free(v1);
}

  if (v1) {
LABEL_11:
  }
    free(v1);
}

    free(v10);
    goto LABEL_18;
  }

  if (!v4)
  {
    os_unfair_lock_lock(v3 + 30);
    os_log_type_t v14 = *(void **)&v3[2]._os_unfair_lock_opaque;
    *(void *)&v3[2]._os_unfair_lock_opaque = 0LL;

    os_log_type_t v8 = v3 + 30;
    goto LABEL_10;
  }

  int v6 = (uint64_t)xpc_copy(v4);
  if (v6)
  {
    os_unfair_lock_lock(v3 + 30);
    BOOL v7 = *(void **)&v3[2]._os_unfair_lock_opaque;
    *(void *)&v3[2]._os_unfair_lock_opaque = v6;

    os_log_type_t v8 = v3 + 30;
LABEL_10:
    os_unfair_lock_unlock(v8);
    int v6 = 1LL;
  }

  os_log_type_t v9 = 0xFFFFFFFFLL;
LABEL_18:

  return v9;
}

    free(backtrace_string);
    if (!v12) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v15 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "tcp_connection_read";
    _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
  }

LABEL_27:
}

LABEL_26:
    os_log_type_t v16 = 0LL;
    goto LABEL_27;
  }

  if (!a3)
  {
    __nwlog_obj();
    char v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v39 = "tcp_connection_get_statistics";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        char v39 = "tcp_connection_get_statistics";
        id v33 = "%{public}s called with null statistics";
LABEL_49:
        _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
        goto LABEL_50;
      }

      goto LABEL_50;
    }

    if (!v36)
    {
      __nwlog_obj();
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        char v39 = "tcp_connection_get_statistics";
        id v33 = "%{public}s called with null statistics, backtrace limit exceeded";
        goto LABEL_49;
      }

  if (v2) {
    free(v2);
  }
}

  if (v1) {
    free(v1);
  }
}

  if (v1) {
    free(v1);
  }
}

    if (v4) {
      free(v4);
    }
    *(_DWORD *)(a1 + 276) = 0;
    return (*(_WORD *)(a1 + 368) & 0x40) == 0;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v24 = "nw_http_connect_end_async";
  BOOL v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v21 = 0;
  if (__nwlog_fault(v15, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      char v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_http_connect_end_async";
        os_log_type_t v18 = "%{public}s called with null http_connect";
LABEL_35:
        _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
      }
    }

    else if (v21)
    {
      os_log_type_t v19 = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      char v17 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (v19)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v24 = "nw_http_connect_end_async";
          char v25 = 2082;
          os_log_type_t v26 = v19;
          _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null http_connect, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v19);
        goto LABEL_36;
      }

      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_http_connect_end_async";
        os_log_type_t v18 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_35;
      }
    }

    else
    {
      os_log_type_t v16 = (os_log_s *)__nwlog_obj();
      char v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_http_connect_end_async";
        os_log_type_t v18 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_35;
      }
    }
  }

  char v17 = -[NWPBEndpoint copyWithZone:](self->_localEndpoint, "copyWithZone:", a3);
  os_log_type_t v18 = *(void **)(v5 + 96);
  *(void *)(v5 + 96) = v17;

  os_log_type_t v19 = -[NWPBInterface copyWithZone:](self->_requiredInterface, "copyWithZone:", a3);
  BOOL v20 = *(void **)(v5 + 160);
  *(void *)(v5 + 160) = v19;

  PBRepeatedInt32Copy();
  PBRepeatedInt32Copy();
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  __int16 v21 = self->_prohibitedInterfaces;
  id v22 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v73,  v80,  16LL);
  if (v22)
  {
    uint64_t v23 = v22;
    os_log_type_t v24 = *(void *)v74;
    do
    {
      for (i = 0LL; i != v23; ++i)
      {
        if (*(void *)v74 != v24) {
          objc_enumerationMutation(v21);
        }
        os_log_type_t v26 = (id)[*(id *)(*((void *)&v73 + 1) + 8 * i) copyWithZone:a3];
        __int16 v27 = *(void **)(v5 + 136);
        if (!v27)
        {
          os_log_type_t v28 = objc_alloc_init(MEMORY[0x189603FA8]);
          uint64_t v29 = *(void **)(v5 + 136);
          *(void *)(v5 + 136) = v28;

          __int16 v27 = *(void **)(v5 + 136);
        }

        [v27 addObject:v26];
      }

      uint64_t v23 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v73,  v80,  16LL);
    }

    while (v23);
  }

  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  char v30 = self->_prohibitedAgents;
  uint64_t v31 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v30,  "countByEnumeratingWithState:objects:count:",  &v69,  v79,  16LL);
  if (v31)
  {
    char v32 = v31;
    id v33 = *(void *)v70;
    do
    {
      for (j = 0LL; j != v32; ++j)
      {
        if (*(void *)v70 != v33) {
          objc_enumerationMutation(v30);
        }
        unint64_t v35 = (id)[*(id *)(*((void *)&v69 + 1) + 8 * j) copyWithZone:a3];
        uint64_t v36 = *(void **)(v5 + 128);
        if (!v36)
        {
          os_log_type_t v37 = objc_alloc_init(MEMORY[0x189603FA8]);
          os_log_type_t v38 = *(void **)(v5 + 128);
          *(void *)(v5 + 128) = v37;

          uint64_t v36 = *(void **)(v5 + 128);
        }

        [v36 addObject:v35];
      }

      char v32 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v30,  "countByEnumeratingWithState:objects:count:",  &v69,  v79,  16LL);
    }

    while (v32);
  }

  __int16 v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  char v39 = self->_requiredAgents;
  __int16 v40 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v65,  v78,  16LL);
  if (v40)
  {
    uint64_t v41 = v40;
    uint64_t v42 = *(void *)v66;
    do
    {
      for (k = 0LL; k != v41; ++k)
      {
        if (*(void *)v66 != v42) {
          objc_enumerationMutation(v39);
        }
        os_log_type_t v44 = (id)[*(id *)(*((void *)&v65 + 1) + 8 * k) copyWithZone:a3];
        uint64_t v45 = *(void **)(v5 + 152);
        if (!v45)
        {
          v46 = objc_alloc_init(MEMORY[0x189603FA8]);
          v47 = *(void **)(v5 + 152);
          *(void *)(v5 + 152) = v46;

          uint64_t v45 = *(void **)(v5 + 152);
        }

        [v45 addObject:v44];
      }

      uint64_t v41 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v65,  v78,  16LL);
    }

    while (v41);
  }

  char v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  id v62 = 0u;
  v48 = self->_preferredAgents;
  v49 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v61,  v77,  16LL);
  if (v49)
  {
    os_log_type_t v50 = v49;
    v51 = *(void *)v62;
    if (v5)
    {
      do
      {
        for (m = 0LL; m != v50; ++m)
        {
          if (*(void *)v62 != v51) {
            objc_enumerationMutation(v48);
          }
          v53 = (id)objc_msgSend(*(id *)(*((void *)&v61 + 1) + 8 * m), "copyWithZone:", a3, (void)v61);
          os_log_type_t v54 = *(void **)(v5 + 120);
          if (!v54)
          {
            BOOL v55 = objc_alloc_init(MEMORY[0x189603FA8]);
            v56 = *(void **)(v5 + 120);
            *(void *)(v5 + 120) = v55;

            os_log_type_t v54 = *(void **)(v5 + 120);
          }

          [v54 addObject:v53];
        }

        os_log_type_t v50 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v61,  v77,  16LL);
      }

      while (v50);
    }

    else
    {
      do
      {
        for (n = 0LL; n != v50; ++n)
        {
          if (*(void *)v62 != v51) {
            objc_enumerationMutation(v48);
          }
        }

        os_log_type_t v50 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v61,  v77,  16LL);
      }

      while (v50);
    }
  }

  BOOL v58 = -[NSData copyWithZone:](self->_metadata, "copyWithZone:", a3);
  os_log_type_t v59 = *(void **)(v5 + 104);
  *(void *)(v5 + 104) = v58;

  return (id)v5;
}
  }

LABEL_18:
    if (!v19) {
      goto LABEL_20;
    }
LABEL_19:
    free(v19);
    goto LABEL_20;
  }

  if (!v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v20 = (os_log_s *)(id)gLogObj;
    char v25 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      char v32 = "nw_endpoint_fallback_start_post_transport_timer";
      _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v20 = (os_log_s *)(id)gLogObj;
  uint64_t v23 = type;
  os_log_type_t v24 = os_log_type_enabled(v20, type);
  if (!backtrace_string)
  {
    if (v24)
    {
      *(_DWORD *)buf = 136446210;
      char v32 = "nw_endpoint_fallback_start_post_transport_timer";
      _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s nw_queue_context_create_source(timer) failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_17;
  }

  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    char v32 = "nw_endpoint_fallback_start_post_transport_timer";
    id v33 = 2082;
    __int16 v34 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v20,  v23,  "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v19) {
    goto LABEL_19;
  }
LABEL_20:
}

  free(v15);
  if (v3) {
LABEL_39:
  }
    free(v3);
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

      privacy_proxy_internal = 0LL;
      goto LABEL_20;
    }

    if (v4)
    {
      BOOL v15 = v4;
      os_log_type_t v16 = *((_BYTE *)v15 + 80);

      if ((v16 & 0x20) == 0)
      {
        char v17 = v15;
        os_log_type_t v18 = v17[4];

        if (!v18)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v19 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            __int16 v34 = "nw_proxy_config_create_relay";
            _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s Second hop proxy does not support HTTP/2 fallback",  buf,  0xCu);
          }

          goto LABEL_17;
        }
      }

      nw_array_append(v7, v15);
    }

    privacy_proxy_internal = nw_proxy_config_create_fallback_privacy_proxy((void *)v7);
    nw_proxy_config_set_is_privacy_proxy(privacy_proxy_internal, 0, 0);
    *((_BYTE *)privacy_proxy_internal + 170) |= 0xCu;
    *((_BYTE *)privacy_proxy_internal + 171) |= 0x80u;
    goto LABEL_20;
  }

  __nwlog_obj();
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v34 = "nw_proxy_config_create_relay";
  os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v31 = 0;
  if (__nwlog_fault(v24, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "nw_proxy_config_create_relay";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null first_hop", buf, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      uint64_t v29 = os_log_type_enabled(v25, type);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v34 = "nw_proxy_config_create_relay";
          unint64_t v35 = 2082;
          uint64_t v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s called with null first_hop, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_41;
      }

      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "nw_proxy_config_create_relay";
        _os_log_impl(&dword_181A5C000, v25, v28, "%{public}s called with null first_hop, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v30 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v34 = "nw_proxy_config_create_relay";
        _os_log_impl( &dword_181A5C000,  v25,  v30,  "%{public}s called with null first_hop, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v1) {
LABEL_11:
  }
    free(v1);
}

  if (v1) {
LABEL_11:
  }
    free(v1);
}

  if (v1) {
LABEL_11:
  }
    free(v1);
}

  if (v1) {
LABEL_11:
  }
    free(v1);
}
  }

  __int16 v21 = 0LL;
LABEL_23:

LABEL_24:
  return v21;
}

    free(v8);
    goto LABEL_18;
  }

  os_log_type_t v8 = (void *)nw_utilities_create_c_string_from_cfstring(a2);
  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      char v25 = "nw_ws_copy_headers_into_ws_response";
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s failed to get selected_subprotocol from websocket response",  buf,  0xCu);
    }

    goto LABEL_18;
  }

  os_log_type_t v9 = v5;
  if (!v9)
  {
    __nwlog_obj();
    os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v25 = "nw_ws_response_set_selected_subprotocol";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          char v25 = "nw_ws_response_set_selected_subprotocol";
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null response", buf, 0xCu);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            char v25 = "nw_ws_response_set_selected_subprotocol";
            os_log_type_t v26 = 2082;
            __int16 v27 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s called with null response, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          char v25 = "nw_ws_response_set_selected_subprotocol";
          _os_log_impl(&dword_181A5C000, v14, v19, "%{public}s called with null response, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          char v25 = "nw_ws_response_set_selected_subprotocol";
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null response, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

LABEL_18:
    if (v2) {
      free(v2);
    }
  }

LABEL_18:
    if (v2) {
      free(v2);
    }
  }

  mkdir(__s1, 0x1C0u);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle
    && (Identifier = CFBundleGetIdentifier(MainBundle)) != 0LL
    && (CStringPtr = CFStringGetCStringPtr(Identifier, 0x600u)) != 0LL)
  {
    os_log_type_t v12 = CStringPtr;
  }

  else
  {
    os_log_type_t v12 = *(const char **)_CFGetProgname();
    if (!v12)
    {
      __nwlog_obj();
      char v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
      os_log_type_t v38 = 136446210;
      char v39 = "_strict_strlcat";
      uint64_t v31 = (void *)_os_log_send_and_compose_impl();

      free(v31);
      os_log_type_t v12 = 0LL;
      os_log_type_t v13 = 1;
      goto LABEL_23;
    }
  }

  os_log_type_t v13 = 0;
LABEL_23:
  os_log_type_t v14 = 0LL;
  BOOL v15 = 1024LL;
  do
  {
    if (!__s1[v14])
    {
      if (v13)
      {
        __nwlog_obj();
        __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
        os_log_type_t v38 = 136446210;
        char v39 = "_strict_strlcpy";
        unint64_t v35 = (void *)_os_log_send_and_compose_impl();

        free(v35);
        if (v15 >= 2)
        {
LABEL_31:
          os_log_type_t v18 = 0LL;
          while (1)
          {
            os_log_type_t v19 = v12[v18];
            __s1[v18 + v14] = v19;
            if (!v19) {
              goto LABEL_36;
            }
            BOOL v20 = v14 + v18++;
            if (v20 == 1022)
            {
              os_log_type_t v14 = 1023LL;
              break;
            }
          }
        }
      }

      else if (v15 >= 2)
      {
        goto LABEL_31;
      }

      __s1[v14] = 0;
      goto LABEL_36;
    }

    ++v14;
    --v15;
  }

  while (v15);
  if (v13)
  {
    __nwlog_obj();
    os_log_type_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    os_log_type_t v38 = 136446210;
    char v39 = "_strict_strlcpy";
    char v17 = (void *)_os_log_send_and_compose_impl();

    free(v17);
  }
  }

              [(id)v7 setVoluntary:1];
              if ((v5[52] & 0x20) == 0) {
                goto LABEL_20;
              }
              goto LABEL_18;
            }

    -[NWRemoteConnectionActor updatePathForConnection:](self, "updatePathForConnection:", v12);
    goto LABEL_18;
  }

  if ([v9 isEqualToString:@"discoveredEndpoints"])
  {
    os_log_type_t v18 = v10;
    os_log_type_t v19 = a6;
    [v19 browser];
    BOOL v20 = (id)objc_claimAutoreleasedReturnValue();

    if (v20 == v18)
    {
      -[NWRemoteConnectionActor updateEndpointsForBrowser:](self, "updateEndpointsForBrowser:", v19);
      goto LABEL_18;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v14 = (os_log_s *)(id)gLogObj;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    [v19 browser];
    BOOL v15 = (void *)objc_claimAutoreleasedReturnValue();
    __int16 v21 = 136446722;
    id v22 = "-[NWRemoteConnectionActor observeValueForKeyPath:ofObject:change:context:]";
    uint64_t v23 = 2048;
    os_log_type_t v24 = v15;
    char v25 = 2048;
    os_log_type_t v26 = v18;
    os_log_type_t v16 = "%{public}s Browser wrapper invalid: %p != %p";
    goto LABEL_13;
  }

          *(void *)(a2 + 168) = v6;
          if (!v6)
          {
            *(_DWORD *)(a2 + 104) |= 1u;
            *(_DWORD *)(a2 + 136) = 2;
LABEL_22:
            __src = v8;
            if (v8 >= v4) {
              goto LABEL_26;
            }
LABEL_23:
            *(_DWORD *)(a2 + 176) = *__src >> 7;
            *(_DWORD *)(a2 + 144) = 0;
            *(_DWORD *)(a2 + 136) = 3;
            os_log_type_t v13 = 7;
            goto LABEL_24;
          }
  }

        v8 += v9->u8[0];
        goto LABEL_18;
      }

  return v15;
}

    free(v13);
    goto LABEL_18;
  }

  if (v11 - v10 <= 0x48)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    v46 = "nw_necp_append_tlv";
    v47 = 2048;
    v48 = (char *)v10;
    v49 = 2048;
    os_log_type_t v50 = 73LL;
    v51 = 2048;
    *(void *)os_log_type_t v52 = v11;
    *(_WORD *)&v52[8] = 1024;
    *(_DWORD *)v53 = 251;
    *(_WORD *)&v53[4] = 1024;
    *(_DWORD *)&v53[6] = 68;
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v14 = (os_log_s *)(id)gLogObj;
      BOOL v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = (char *)v10;
      v49 = 2048;
      os_log_type_t v50 = 73LL;
      v51 = 2048;
      *(void *)os_log_type_t v52 = v11;
      *(_WORD *)&v52[8] = 1024;
      *(_DWORD *)v53 = 251;
      *(_WORD *)&v53[4] = 1024;
      *(_DWORD *)&v53[6] = 68;
      os_log_type_t v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
      goto LABEL_24;
    }

    if (!v39)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v14 = (os_log_s *)(id)gLogObj;
      BOOL v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = (char *)v10;
      v49 = 2048;
      os_log_type_t v50 = 73LL;
      v51 = 2048;
      *(void *)os_log_type_t v52 = v11;
      *(_WORD *)&v52[8] = 1024;
      *(_DWORD *)v53 = 251;
      *(_WORD *)&v53[4] = 1024;
      *(_DWORD *)&v53[6] = 68;
      os_log_type_t v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_24;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v14 = (os_log_s *)(id)gLogObj;
    BOOL v15 = type;
    __int16 v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v21) {
        goto LABEL_25;
      }
      *(_DWORD *)buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = (char *)v10;
      v49 = 2048;
      os_log_type_t v50 = 73LL;
      v51 = 2048;
      *(void *)os_log_type_t v52 = v11;
      *(_WORD *)&v52[8] = 1024;
      *(_DWORD *)v53 = 251;
      *(_WORD *)&v53[4] = 1024;
      *(_DWORD *)&v53[6] = 68;
      os_log_type_t v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
LABEL_24:
      _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0x36u);
LABEL_25:

      if (!v13) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }

    if (!v21) {
      goto LABEL_15;
    }
    *(_DWORD *)buf = 136447746;
    v46 = "nw_necp_append_tlv";
    v47 = 2048;
    v48 = (char *)v10;
    v49 = 2048;
    os_log_type_t v50 = 73LL;
    v51 = 2048;
    *(void *)os_log_type_t v52 = v11;
    *(_WORD *)&v52[8] = 1024;
    *(_DWORD *)v53 = 251;
    *(_WORD *)&v53[4] = 1024;
    *(_DWORD *)&v53[6] = 68;
    os_log_type_t v54 = 2082;
    BOOL v55 = backtrace_string;
    id v22 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s";
    uint64_t v23 = v14;
    os_log_type_t v24 = v15;
    char v25 = 64;
    goto LABEL_14;
  }

  char v17 = v42;
  *(_OWORD *)(v10 + 9) = __dst;
  *(_OWORD *)(v10 + 25) = v17;
  os_log_type_t v18 = v44;
  *(_OWORD *)(v10 + 41) = v43;
  *(_BYTE *)os_log_type_t v10 = -5;
  *(_DWORD *)(v10 + 1) = 68;
  *(_WORD *)(v10 + 5) = a3;
  *(_WORD *)(v10 + 7) = v7;
  os_log_type_t v19 = v10 + 73;
  *(_OWORD *)(v10 + 57) = v18;
LABEL_19:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v19;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

      free(v12);
      goto LABEL_18;
    }

    __nwlog_obj();
    __int16 v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v23, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
          os_log_type_t v26 = "%{public}s called with null interfaceName";
          goto LABEL_55;
        }

        goto LABEL_56;
      }

      if (!v32)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
          os_log_type_t v26 = "%{public}s called with null interfaceName, backtrace limit exceeded";
          goto LABEL_55;
        }

        goto LABEL_56;
      }

      os_log_type_t v28 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v25 = type;
      uint64_t v31 = os_log_type_enabled(v24, type);
      if (!v28)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
          os_log_type_t v26 = "%{public}s called with null interfaceName, no backtrace";
          goto LABEL_55;
        }

        goto LABEL_56;
      }

      if (!v31) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446466;
      unint64_t v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
      uint64_t v36 = 2082;
      *(void *)os_log_type_t v37 = v28;
      char v30 = "%{public}s called with null interfaceName, dumping backtrace:%{public}s";
LABEL_45:
      _os_log_impl(&dword_181A5C000, v24, v25, v30, buf, 0x16u);
LABEL_46:

      free(v28);
    }
  }

  else
  {
    __nwlog_obj();
    id v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    unint64_t v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v23, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        char v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v35 = "-[NWInterface(Private) initWithInterfaceIndex:interfaceName:]";
          os_log_type_t v26 = "%{public}s called with null interfaceIndex";
LABEL_55:
          _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
        }

    int v5 = 35;
    goto LABEL_26;
  }

  if ((unsigned __int16)v3 == 544)
  {
    int v5 = 30;
    goto LABEL_26;
  }

  if ((unsigned __int16)v3 != 288 || v3 >= 0x10000)
  {
    if ((v3 & 0xFE) == 0xFC)
    {
      int v5 = 3;
      goto LABEL_26;
    }

    if ((v3 & 0xC0FF) == 0xC0FE) {
      goto LABEL_22;
    }
    goto LABEL_23;
  }

  int v5 = 5;
LABEL_26:
  os_log_type_t v8 = *(unsigned __int8 *)(a2 + 1);
  if (v8 == 2) {
    goto LABEL_52;
  }
  if (v8 != 30)
  {
    os_log_type_t v11 = 0;
    if (!v5) {
      goto LABEL_35;
    }
    goto LABEL_53;
  }

  os_log_type_t v9 = *(_DWORD *)(a2 + 8);
  os_log_type_t v10 = (unsigned __int16)v9;
  if (v9)
  {
    if ((unsigned __int16)v9 == 544)
    {
      os_log_type_t v11 = 30;
      if (v5 > 0x1E) {
        goto LABEL_53;
      }
      goto LABEL_35;
    }

    if ((unsigned __int16)v9 == 288 && v9 < 0x10000)
    {
      os_log_type_t v11 = 5;
      if (v5 <= 5) {
        goto LABEL_35;
      }
LABEL_53:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v21 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v47 = "sa_dst_compare_no_dependencies";
        v48 = 1024;
        *(_DWORD *)v49 = v5;
        v49[2] = 1024;
        *(_DWORD *)&v49[3] = v11;
        id v22 = "%{public}s ND Rule 6, prefer d1, d1 precedence %d > d2 precedence %d";
LABEL_85:
        _os_log_impl(&dword_181A5C000, v21, OS_LOG_TYPE_DEBUG, v22, buf, 0x18u);
        return 1LL;
      }

      return 1LL;
    }

    if ((v9 & 0xFE) == 0xFC)
    {
      os_log_type_t v11 = 3;
      if (v5 > 3) {
        goto LABEL_53;
      }
      goto LABEL_35;
    }

    if ((v9 & 0xC0FF) == 0xC0FE) {
      goto LABEL_95;
    }
    goto LABEL_97;
  }

  if (*(_DWORD *)(a2 + 12)) {
    goto LABEL_97;
  }
  os_log_type_t v19 = *(_DWORD *)(a2 + 16);
  if (v19 == -65536)
  {
LABEL_52:
    os_log_type_t v11 = 35;
    if (v5 <= 0x23) {
      goto LABEL_35;
    }
    goto LABEL_53;
  }

  if (!v19)
  {
    BOOL v20 = *(_DWORD *)(a2 + 20);
    if (v20)
    {
      if (v20 == 0x1000000)
      {
        os_log_type_t v11 = 50;
        goto LABEL_35;
      }

                if ((*v2 & 0x800) == 0 && gLogDatapath)
                {
                  char v30 = (os_log_s *)__nwlog_obj();
                  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v31 = *(_DWORD *)(*(void *)(a1 + 336) + 1280LL);
                    char v32 = *(void *)(a1 + 240);
                    id v33 = *(void *)(a1 + 248);
                    *(_DWORD *)buf = 136447490;
                    v64 = "nw_protocol_http3_stream_start_datagram_flow";
                    v65 = 2082;
                    v66 = (void *)(a1 + 636);
                    __int16 v67 = 2080;
                    v68 = " ";
                    v69 = 1024;
                    v70 = v31;
                    v71 = 2048;
                    v72 = v32;
                    v73 = 2048;
                    v74 = v33;
                    _os_log_impl( &dword_181A5C000,  v30,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> Opened datagram flow %llu",  buf,  0x3Au);
                  }
                }

                return;
              }
            }

            __nwlog_obj();
            uint64_t v23 = 0;
            goto LABEL_91;
          }

          if (!v42) {
            goto LABEL_87;
          }
          uint64_t v45 = "invalid";
          if (v6 && *(void *)(v6 + 16)) {
            uint64_t v45 = *(const char **)(v6 + 16);
          }
          *(_DWORD *)buf = 136446466;
          v64 = "nw_protocol_http3_stream_start_datagram_flow";
          v65 = 2082;
          v66 = (void *)v45;
          __int16 v40 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        }

        else
        {
          os_log_type_t v37 = (os_log_s *)__nwlog_obj();
          os_log_type_t v38 = type;
          if (!os_log_type_enabled(v37, type)) {
            goto LABEL_87;
          }
          os_log_type_t v44 = "invalid";
          if (v6 && *(void *)(v6 + 16)) {
            os_log_type_t v44 = *(const char **)(v6 + 16);
          }
          *(_DWORD *)buf = 136446466;
          v64 = "nw_protocol_http3_stream_start_datagram_flow";
          v65 = 2082;
          v66 = (void *)v44;
          __int16 v40 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        }

        _os_log_impl(&dword_181A5C000, v37, v38, v40, buf, 0x16u);
        goto LABEL_87;
      }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_18;
  }

  if (!a1->handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_http3_output_finished";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v4 = (os_log_s *)__nwlog_obj();
      int v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v17 = "nw_protocol_http3_output_finished";
      int v6 = "%{public}s called with null http3";
      goto LABEL_17;
    }

    if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v4 = (os_log_s *)__nwlog_obj();
      int v5 = type;
      os_log_type_t v12 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (!v12) {
          goto LABEL_46;
        }
        *(_DWORD *)buf = 136446466;
        char v17 = "nw_protocol_http3_output_finished";
        os_log_type_t v18 = 2082;
        os_log_type_t v19 = backtrace_string;
        os_log_type_t v11 = "%{public}s called with null http3, dumping backtrace:%{public}s";
        goto LABEL_45;
      }

      if (!v12) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v17 = "nw_protocol_http3_output_finished";
      int v6 = "%{public}s called with null http3, no backtrace";
    }

    else
    {
      id v4 = (os_log_s *)__nwlog_obj();
      int v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v17 = "nw_protocol_http3_output_finished";
      int v6 = "%{public}s called with null http3, backtrace limit exceeded";
    }

    goto LABEL_17;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2)
  {
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_http3_output_finished";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v4 = (os_log_s *)gLogObj;
      int v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v17 = "nw_protocol_http3_output_finished";
      int v6 = "%{public}s http3 should not get output_finished";
      goto LABEL_17;
    }

    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v4 = (os_log_s *)gLogObj;
      int v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v17 = "nw_protocol_http3_output_finished";
      int v6 = "%{public}s http3 should not get output_finished, backtrace limit exceeded";
      goto LABEL_17;
    }

    BOOL v7 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (os_log_s *)gLogObj;
    int v5 = type;
    os_log_type_t v8 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v7)
    {
      if (!v8) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      char v17 = "nw_protocol_http3_output_finished";
      int v6 = "%{public}s http3 should not get output_finished, no backtrace";
      goto LABEL_17;
    }

    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      char v17 = "nw_protocol_http3_output_finished";
      os_log_type_t v18 = 2082;
      os_log_type_t v19 = v7;
      _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s http3 should not get output_finished, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v7);
LABEL_18:
    if (!v3) {
      return;
    }
    goto LABEL_19;
  }

  *(_DWORD *)buf = 136446210;
  char v17 = "nw_protocol_http3_output_finished";
  id v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    id v4 = (os_log_s *)__nwlog_obj();
    int v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_http3_output_finished";
    int v6 = "%{public}s called with null other_protocol";
    goto LABEL_17;
  }

  if (!v14)
  {
    id v4 = (os_log_s *)__nwlog_obj();
    int v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_http3_output_finished";
    int v6 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_17;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  id v4 = (os_log_s *)__nwlog_obj();
  int v5 = type;
  os_log_type_t v13 = os_log_type_enabled(v4, type);
  if (!backtrace_string)
  {
    if (!v13) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 136446210;
    char v17 = "nw_protocol_http3_output_finished";
    int v6 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_17;
  }

  if (!v13) {
    goto LABEL_46;
  }
  *(_DWORD *)buf = 136446466;
  char v17 = "nw_protocol_http3_output_finished";
  os_log_type_t v18 = 2082;
  os_log_type_t v19 = backtrace_string;
  os_log_type_t v11 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_45:
  _os_log_impl(&dword_181A5C000, v4, v5, v11, buf, 0x16u);
LABEL_46:
  free(backtrace_string);
  if (v3) {
LABEL_19:
  }
    free(v3);
}

  if (v5) {
    free(v5);
  }
  if (v4) {
    goto LABEL_20;
  }
LABEL_21:
  if (v1) {
    os_release(v1);
  }
  if (v2) {
    os_release(v2);
  }
}

  if (v7) {
    free(v7);
  }
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 22LL;
}

  if (v3) {
    free(v3);
  }
  return 22LL;
}

          free(v6);
          goto LABEL_18;
        }

        *(_DWORD *)buf = 136446722;
        char v32 = "NWUtilsCurrentProcessHasEntitlement";
        id v33 = 2114;
        __int16 v34 = v1;
        unint64_t v35 = 2114;
        uint64_t v36 = error;
        os_log_type_t v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, no backtrace";
        os_log_type_t v24 = v7;
        char v25 = v16;
LABEL_39:
        _os_log_impl(&dword_181A5C000, v24, v25, v9, buf, 0x20u);
        goto LABEL_40;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446978;
        char v32 = "NWUtilsCurrentProcessHasEntitlement";
        id v33 = 2114;
        __int16 v34 = v1;
        unint64_t v35 = 2114;
        uint64_t v36 = error;
        os_log_type_t v37 = 2082;
        os_log_type_t v38 = v15;
        _os_log_impl( &dword_181A5C000,  v7,  v16,  "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v15);
    }

    if (!v6) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }

    free(backtrace_string);
    if (!v9) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }

  objc_storeStrong((id *)&v6->parameters, a2);
LABEL_10:
  if (v4) {
    objc_storeStrong((id *)&v7->endpoint, a1);
  }
  os_log_type_t v14 = v7;
LABEL_44:

  return v14;
}

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v7 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446210;
    v109 = "nw_path_get_sysctls_region_block_invoke";
    os_log_type_t v9 = "%{public}s synthesizing sysctls_region from sysctlbyname";
    os_log_type_t v10 = v7;
    os_log_type_t v11 = OS_LOG_TYPE_DEBUG;
    os_log_type_t v12 = 12;
LABEL_19:
    _os_log_impl(&dword_181A5C000, v10, v11, v9, buf, v12);
  }

      nw_http_messaging_options_set_http2_options(v24, 0LL);
      if (v21 > 3) {
        goto LABEL_27;
      }
LABEL_23:
      if (nw_get_http3_override_onceToken != -1) {
        dispatch_once(&nw_get_http3_override_onceToken, &__block_literal_global_8_72852);
      }
      if (nw_get_http3_override_value != 1) {
        nw_http_messaging_options_set_http3_options(v24, 0LL);
      }
      goto LABEL_27;
    }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }
  }

  if (v1) {
    free(v1);
  }
}

          free(v9);
          if (!v4) {
            return;
          }
LABEL_25:
          free(v4);
          return;
        }

        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
          BOOL v7 = "%{public}s called with null existing_protocol, no backtrace";
          goto LABEL_23;
        }
      }

      else
      {
        int v5 = (os_log_s *)__nwlog_obj();
        int v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
          BOOL v7 = "%{public}s called with null existing_protocol, backtrace limit exceeded";
          goto LABEL_23;
        }
      }

      goto LABEL_24;
    }

    int v5 = (os_log_s *)__nwlog_obj();
    int v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_24;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
    BOOL v7 = "%{public}s called with null existing_protocol";
    goto LABEL_23;
  }

  handle = (nw_protocol **)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v4, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v5 = (os_log_s *)__nwlog_obj();
        int v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
          BOOL v7 = "%{public}s called with null http_messaging";
          goto LABEL_23;
        }
      }

      else if (v17)
      {
        os_log_type_t v9 = (char *)__nw_create_backtrace_string();
        int v5 = (os_log_s *)__nwlog_obj();
        int v6 = type;
        BOOL v15 = os_log_type_enabled(v5, type);
        if (v9)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
            __int16 v21 = 2082;
            id v22 = v9;
            os_log_type_t v11 = "%{public}s called with null http_messaging, dumping backtrace:%{public}s";
            goto LABEL_16;
          }

          goto LABEL_17;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
          BOOL v7 = "%{public}s called with null http_messaging, no backtrace";
          goto LABEL_23;
        }
      }

      else
      {
        int v5 = (os_log_s *)__nwlog_obj();
        int v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_protocol_http_messaging_listen_protocol_disconnected";
          BOOL v7 = "%{public}s called with null http_messaging, backtrace limit exceeded";
          goto LABEL_23;
        }
      }
    }

    nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
    return 1LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v51 = "nw_protocol_http_messaging_add_input_handler";
  os_log_type_t v52 = 2048;
  v53 = a2;
  os_log_type_t v18 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (__nwlog_fault(v18, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v19 = (os_log_s *)gLogObj;
      BOOL v20 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_http_messaging_add_input_handler";
      os_log_type_t v52 = 2048;
      v53 = a2;
      __int16 v21 = "%{public}s Adding the same input handler more than once to messaging %p";
LABEL_47:
      _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0x16u);
      goto LABEL_48;
    }

    if (!v48)
    {
      os_log_type_t v19 = (os_log_s *)__nwlog_obj();
      BOOL v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_http_messaging_add_input_handler";
      os_log_type_t v52 = 2048;
      v53 = a2;
      __int16 v21 = "%{public}s Adding the same input handler more than once to messaging %p, backtrace limit exceeded";
      goto LABEL_47;
    }

    id v33 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v19 = (os_log_s *)gLogObj;
    BOOL v20 = type;
    __int16 v34 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_http_messaging_add_input_handler";
      os_log_type_t v52 = 2048;
      v53 = a2;
      __int16 v21 = "%{public}s Adding the same input handler more than once to messaging %p, no backtrace";
      goto LABEL_47;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446722;
      v51 = "nw_protocol_http_messaging_add_input_handler";
      os_log_type_t v52 = 2048;
      v53 = a2;
      os_log_type_t v54 = 2082;
      BOOL v55 = v33;
      _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s Adding the same input handler more than once to messaging %p, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v33);
  }

      handle[2].handle = v8;
      goto LABEL_52;
    }
  }

  return v7 != 50;
}

  if (v7) {
    free(v7);
  }
  uint64_t v2 = *(void *)(a1 + 32);
LABEL_20:
  *(_BYTE *)(v2 + 856) |= 8u;
  *(_DWORD *)(*(void *)(a1 + 32) + 256LL) = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(*(void *)(a1 + 32) + 260LL) = *(_DWORD *)(a1 + 60);
  *(_BYTE *)(*(void *)(a1 + 32) + 856LL) = *(_BYTE *)(*(void *)(a1 + 32) + 856LL) & 0xFD | (2 * *(_BYTE *)(a1 + 64));
  os_log_type_t v16 = _Block_copy(*(const void **)(a1 + 40));
  char v17 = *(void *)(a1 + 32);
  os_log_type_t v18 = *(void **)(v17 + 776);
  *(void *)(v17 + 776) = v16;

  os_log_type_t v19 = _Block_copy(*(const void **)(a1 + 48));
  BOOL v20 = *(void *)(a1 + 32);
  __int16 v21 = *(void **)(v20 + 784);
  *(void *)(v20 + 784) = v19;
}

  if (v2) {
    free(v2);
  }
}

  if (v4) {
    free(v4);
  }
  return 0LL;
}

  free(v14);
  if (v3) {
LABEL_43:
  }
    free(v3);
}

uint64_t nw_endpoint_handler_get_next_top_id()
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  do
    unsigned int v0 = __ldaxr((unsigned int *)&nw_endpoint_handler_get_next_top_id::s_last_top_level_id);
  while (__stlxr(v0 + 1, (unsigned int *)&nw_endpoint_handler_get_next_top_id::s_last_top_level_id));
  uint64_t result = v0 + 1;
  if (v0 == -1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446466;
      id v4 = "nw_endpoint_handler_get_next_top_id";
      __int16 v5 = 1024;
      int v6 = 0;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s reached %u endpoint top ids, wrapping",  (uint8_t *)&v3,  0x12u);
    }

    return nw_endpoint_handler_get_next_top_id();
  }

  return result;
}

id nw_parameters_copy_context(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = *(id *)(*((void *)v1 + 13) + 136LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  __int16 v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_copy_context";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_context";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_copy_context";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_context";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_context";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_parameters_get_pid(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned int *)(*((void *)v1 + 13) + 64LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  __int16 v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_get_pid";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_pid";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_get_pid";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_pid";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_pid";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_parameters_get_effective_bundle_id(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 14);
    goto LABEL_3;
  }

  __nwlog_obj();
  __int16 v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_get_effective_bundle_id";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_get_effective_bundle_id";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_endpoint_get_agent_identifier(void *a1, _OWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *a2 = *(_OWORD *)(v3 + 28);
    goto LABEL_3;
  }

  __nwlog_obj();
  __int16 v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_get_agent_identifier";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_get_agent_identifier";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

id *nw_endpoint_handler_create_inner( void *a1, void *a2, void *a3, void *a4, void *a5, unsigned int a6, int a7)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  id v13 = a1;
  id v14 = a2;
  id v84 = a4;
  v85 = v13;
  id v86 = a5;
  if (!v13)
  {
    __nwlog_obj();
    os_log_type_t v57 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_handler_create_inner";
    BOOL v58 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v60 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_181A5C000, v59, v60, "%{public}s called with null endpoint", address, 0xCu);
      }

      goto LABEL_112;
    }

    if (!v90)
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v77 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl( &dword_181A5C000,  v59,  v77,  "%{public}s called with null endpoint, backtrace limit exceeded",  address,  0xCu);
      }

      goto LABEL_112;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v66 = type;
    BOOL v67 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v67)
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_181A5C000, v59, v66, "%{public}s called with null endpoint, no backtrace", address, 0xCu);
      }

      goto LABEL_112;
    }

    if (v67)
    {
      *(_DWORD *)address = 136446466;
      *(void *)&address[4] = "nw_endpoint_handler_create_inner";
      *(_WORD *)&address[12] = 2082;
      *(void *)&address[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v59,  v66,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  address,  0x16u);
    }

    goto LABEL_78;
  }

  if (!v14)
  {
    __nwlog_obj();
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_handler_create_inner";
    BOOL v58 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_181A5C000, v59, v62, "%{public}s called with null parameters", address, 0xCu);
      }

      goto LABEL_112;
    }

    if (!v90)
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v78 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl( &dword_181A5C000,  v59,  v78,  "%{public}s called with null parameters, backtrace limit exceeded",  address,  0xCu);
      }

      goto LABEL_112;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v68 = type;
    BOOL v69 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v69)
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_181A5C000, v59, v68, "%{public}s called with null parameters, no backtrace", address, 0xCu);
      }

      goto LABEL_112;
    }

    if (v69)
    {
      *(_DWORD *)address = 136446466;
      *(void *)&address[4] = "nw_endpoint_handler_create_inner";
      *(_WORD *)&address[12] = 2082;
      *(void *)&address[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v59,  v68,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  address,  0x16u);
    }

LABEL_78:
    free(backtrace_string);
    if (!v58) {
      goto LABEL_115;
    }
    goto LABEL_114;
  }

  if (!a3)
  {
    __nwlog_obj();
    char v63 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_handler_create_inner";
    BOOL v58 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_181A5C000, v59, v64, "%{public}s called with null report_callback", address, 0xCu);
      }
    }

    else if (v90)
    {
      v70 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v71 = type;
      BOOL v72 = os_log_type_enabled(v59, type);
      if (v70)
      {
        if (v72)
        {
          *(_DWORD *)address = 136446466;
          *(void *)&address[4] = "nw_endpoint_handler_create_inner";
          *(_WORD *)&address[12] = 2082;
          *(void *)&address[14] = v70;
          _os_log_impl( &dword_181A5C000,  v59,  v71,  "%{public}s called with null report_callback, dumping backtrace:%{public}s",  address,  0x16u);
        }

        free(v70);
LABEL_113:
        if (!v58)
        {
LABEL_115:
          id v33 = 0LL;
          goto LABEL_53;
        }

LABEL_79:
      if (v24) {
        free(v24);
      }
      goto LABEL_18;
    }

    if (!v68)
    {
      __nwlog_obj(v30, v31);
      id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v63 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v71 = "nw_queue_context_create_source";
        _os_log_impl( &dword_181A5C000,  v27,  v63,  "%{public}s called with null block, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj(backtrace_string, v59);
    id v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v60 = type;
    v61 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v71 = "nw_queue_context_create_source";
        _os_log_impl(&dword_181A5C000, v27, v60, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v71 = "nw_queue_context_create_source";
      BOOL v72 = 2082;
      v73 = (uint64_t)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v27,  v60,  "%{public}s called with null block, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  LOBYTE(v64) = 0;
LABEL_107:

  _Block_object_dispose(v346, 8);
  _Block_object_dispose(v348, 8);
  _Block_object_dispose(v377, 8);
  _Block_object_dispose(&v352, 8);

  _Block_object_dispose(&v356, 8);
  _Block_object_dispose(type, 8);

LABEL_209:
  return v64 & 1;
}

LABEL_28:
      if (!v13) {
        goto LABEL_30;
      }
LABEL_29:
      free(v13);
      goto LABEL_30;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v35 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl( &dword_181A5C000,  v21,  v35,  "%{public}s called with null ecn_cache_buffer, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v31 = v37[0];
    char v32 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_ecn_cache";
        _os_log_impl( &dword_181A5C000,  v21,  v31,  "%{public}s called with null ecn_cache_buffer, no backtrace",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v41 = "nw_path_flow_registration_set_ecn_cache";
      id v42 = 2082;
      *(void *)__int16 v43 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v21,  v31,  "%{public}s called with null ecn_cache_buffer, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  __break(1u);
  return result;
}

          alloc = (uint64_t)data;
          handle = v251;
          id v44 = v49;
          os_log_type_t v41 = v249;
          goto LABEL_79;
        }

        __nwlog_obj();
        v147 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
        v148 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v270 = 0;
        if (__nwlog_fault(v148, &type, &v270))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v149 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v150 = type;
            if (os_log_type_enabled(v149, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
              _os_log_impl(&dword_181A5C000, v149, v150, "%{public}s called with null context", buf, 0xCu);
            }
          }

          else
          {
            if (v270)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v167 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v168 = type;
              v169 = os_log_type_enabled(v167, type);
              if (backtrace_string)
              {
                if (v169)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v167,  v168,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(backtrace_string);
              }

              else
              {
                if (v169)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
                  _os_log_impl( &dword_181A5C000,  v167,  v168,  "%{public}s called with null context, no backtrace",  buf,  0xCu);
                }
              }

              goto LABEL_303;
            }

            __nwlog_obj();
            v149 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v170 = type;
            if (os_log_type_enabled(v149, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
              _os_log_impl( &dword_181A5C000,  v149,  v170,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

    if (v30) {
      free(v30);
    }
    __nwlog_obj();
    id v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)os_log_type_t type = 136446210;
    v51 = "nw_ip_metadata_set_hop_limit";
    id v38 = (char *)_os_log_send_and_compose_impl();

    v46 = OS_LOG_TYPE_ERROR;
    id v45 = 0;
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v40 = v46;
      if (os_log_type_enabled(v39, v46))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl(&dword_181A5C000, v39, v40, "%{public}s called with null metadata", (uint8_t *)type, 0xCu);
      }
    }

    else if (v45)
    {
      os_log_type_t v41 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v42 = v46;
      __int16 v43 = os_log_type_enabled(v39, v46);
      if (v41)
      {
        if (v43)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          v51 = "nw_ip_metadata_set_hop_limit";
          os_log_type_t v52 = 2082;
          os_log_type_t v53 = v41;
          _os_log_impl( &dword_181A5C000,  v39,  v42,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  (uint8_t *)type,  0x16u);
        }

        free(v41);
        goto LABEL_96;
      }

      if (v43)
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl( &dword_181A5C000,  v39,  v42,  "%{public}s called with null metadata, no backtrace",  (uint8_t *)type,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v44 = v46;
      if (os_log_type_enabled(v39, v46))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl( &dword_181A5C000,  v39,  v44,  "%{public}s called with null metadata, backtrace limit exceeded",  (uint8_t *)type,  0xCu);
      }
    }

LABEL_96:
    if (v38) {
      free(v38);
    }
    goto LABEL_29;
  }

    if (!v24) {
      goto LABEL_80;
    }
LABEL_79:
    free(v24);
    goto LABEL_80;
  }

  os_log_type_t v8 = (unsigned int *)v6;
  os_log_type_t v9 = v8[29];

  if ((_DWORD)v9 == 2)
  {
    if ((*((_BYTE *)self + 32) & 1) != 0) {
      goto LABEL_5;
    }
    if (self->multiplexed_message_definition) {
      goto LABEL_5;
    }
    default_input_handler = (nw_flow_protocol *)self->shared_protocol.protocol.default_input_handler;
    if (!default_input_handler) {
      goto LABEL_5;
    }
    name = default_input_handler->protocol.identifier->name;
    if (name)
    {
    }

    output_handler = (nw_flow_protocol *)self->shared_protocol.protocol.output_handler;
    if (!output_handler) {
      goto LABEL_5;
    }
    callbacks = output_handler->protocol.callbacks;
    if (!callbacks) {
      goto LABEL_5;
    }
    replace_input_handler = (uint64_t (*)(nw_flow_protocol *, nw_flow_protocol *, nw_flow_protocol *))callbacks->replace_input_handler;
    if (!replace_input_handler
      || (nw_flow_protocol *)default_input_handler->protocol.output_handler != &self->shared_protocol)
    {
      goto LABEL_5;
    }

    handle = output_handler->protocol.handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      BOOL v54 = (char *)output_handler->listen_protocol.handle;
      if (v54) {
        output_handler->listen_protocol.handle = v54 + 1;
      }
      id v42 = -1;
    }

    else
    {
      id v42 = 0;
    }

    *(void *)buf = output_handler;
    buf[8] = v42;
    os_log_type_t v55 = self->shared_protocol.protocol.handle;
    if (v55 == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v57 = (char *)self->shared_protocol.listen_protocol.handle;
      if (v57) {
        self->shared_protocol.listen_protocol.handle = v57 + 1;
      }
      v56 = -1;
    }

    else
    {
      v56 = 0;
    }

    *(void *)os_log_type_t type = &self->shared_protocol;
    v135 = v56;
    BOOL v58 = default_input_handler->protocol.handle;
    log = handle;
    v122 = v55;
    if (v58 == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v60 = (char *)default_input_handler->listen_protocol.handle;
      if (v60) {
        default_input_handler->listen_protocol.handle = v60 + 1;
      }
      os_log_type_t v59 = -1;
    }

    else
    {
      os_log_type_t v59 = 0;
    }

    p_shared_protocol = default_input_handler;
    v133 = v59;
    v61 = replace_input_handler(output_handler, &self->shared_protocol, default_input_handler);
    if (v58 == &nw_protocol_ref_counted_handle) {
      nw::release_if_needed<nw_protocol *>((uint64_t *)&p_shared_protocol);
    }
    if (v122 == &nw_protocol_ref_counted_handle) {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
    }
    if (log == &nw_protocol_ref_counted_handle) {
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    }
    if (!v61)
    {
      if ((nw_endpoint_handler_get_logging_disabled(v8) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v71 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
        {
          id_string = nw_endpoint_handler_get_id_string(v8);
          v73 = nw_endpoint_handler_dry_run_string(v8);
          logb = v71;
          v74 = id_string;
          v123 = nw_endpoint_handler_copy_endpoint(v8);
          logging_description = nw_endpoint_get_logging_description(v123);
          os_log_type_t v76 = nw_endpoint_handler_state_string(v8);
          os_log_type_t v77 = nw_endpoint_handler_mode_string(v8);
          os_log_type_t v78 = nw_endpoint_handler_copy_current_path(v8);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_flow cancelWithHandler:forced:]";
          v137 = 2082;
          v138 = (void *)v74;
          v139 = 2082;
          v140 = v73;
          v141 = 2082;
          v142 = (void *)logging_description;
          v143 = 2082;
          v144 = v76;
          v145 = 2082;
          v146 = v77;
          v147 = 2114;
          v148 = v78;
          os_log_type_t v71 = logb;
          _os_log_impl( &dword_181A5C000,  logb,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to remove passthroug h protocol from the stack on cancellation",  buf,  0x48u);
        }

        goto LABEL_123;
      }

    free(v40);
    goto LABEL_115;
  }

  uint64_t v31 = (os_log_s *)__nwlog_obj();
  char v32 = type;
  if (os_log_type_enabled(v31, type))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v69 = "nw_protocol_udp_get_output_frames";
    id v33 = "%{public}s called with null protocol";
LABEL_114:
    _os_log_impl(&dword_181A5C000, v31, v32, v33, buf, 0xCu);
  }

          v51 = 1LL;
LABEL_79:
          os_log_type_t v53 = v50 + v49 + v51;
          if (v53 >= 0x100)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v54 = gLogObj;
            uint64_t v2 = endpoint;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              bonjour_fullname = nw_endpoint_get_bonjour_fullname(endpoint);
              *(_DWORD *)buf = 136447234;
              v100 = "nw_shoes_create_request";
              v101 = 2082;
              v102 = a1 + 151;
              v103 = 2082;
              v104 = (const char *)bonjour_fullname;
              v105 = 2048;
              *(void *)v106 = v53;
              *(_WORD *)&v106[8] = 2048;
              v107 = 255LL;
              __int16 v43 = "%{public}s %{public}s Bonjour service too long: %{public}s %zu > %zu";
              id v44 = (os_log_s *)v54;
              goto LABEL_82;
            }

            free(v9);
            goto LABEL_136;
          }

    free(v11);
    goto LABEL_79;
  }

  __nwlog_obj();
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v91 = "networkd_privileged_reload_managed_network_settings";
  BOOL v81 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  id v88 = 0;
  if (__nwlog_fault(v81, &type, &v88))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v83 = type;
      if (os_log_type_enabled(v82, type))
      {
        *(_DWORD *)buf = 136446210;
        v91 = "networkd_privileged_reload_managed_network_settings";
        _os_log_impl(&dword_181A5C000, v82, v83, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
      }
    }

    else if (v88)
    {
      id v84 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v85 = type;
      id v86 = os_log_type_enabled(v82, type);
      if (v84)
      {
        if (v86)
        {
          *(_DWORD *)buf = 136446466;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v92 = 2082;
          *(void *)int v93 = v84;
          _os_log_impl( &dword_181A5C000,  v82,  v85,  "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v84);
        goto LABEL_202;
      }

      if (v86)
      {
        *(_DWORD *)buf = 136446210;
        v91 = "networkd_privileged_reload_managed_network_settings";
        _os_log_impl(&dword_181A5C000, v82, v85, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v87 = type;
      if (os_log_type_enabled(v82, type))
      {
        *(_DWORD *)buf = 136446210;
        v91 = "networkd_privileged_reload_managed_network_settings";
        _os_log_impl( &dword_181A5C000,  v82,  v87,  "%{public}s xpc_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v24) {
      free(v24);
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = -1;
LABEL_81:
    if (*(_BYTE *)(a1 + 80))
    {
      v65 = *(void *)(a2 + 32);
      os_log_type_t v66 = *(void **)(a2 + 40);
      os_log_type_t v64 = (void *)(a2 + 32);
      if (v65)
      {
        *(void *)(v65 + 40) = v66;
        **(void **)(a2 + 40) = v65;
LABEL_90:
        *os_log_type_t v64 = 0LL;
        v64[1] = 0LL;
        if (gLogDatapath)
        {
          v103 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            v112 = 1024;
            *(_DWORD *)v113 = v6;
            _os_log_impl( &dword_181A5C000,  v103,  OS_LOG_TYPE_DEBUG,  "%{public}s Moving entire frame (%u bytes)",  buf,  0x12u);
          }
        }

        BOOL v67 = *(void *)(*(void *)(a1 + 32) + 8LL);
        os_log_type_t v68 = *(unsigned int *)(v67 + 24) + 1LL;
        BOOL v69 = v68 << 31 >> 31;
        *(_DWORD *)(v67 + 24) = v68;
        if (v69 == v68 && (v69 & 0x8000000000000000LL) == 0) {
          goto LABEL_110;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v70 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        *(_DWORD *)buf = 136446978;
        v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
        v112 = 2082;
        *(void *)v113 = "frame_count";
        *(_WORD *)&v113[8] = 2048;
        v114 = 1LL;
        *(_WORD *)v115 = 2048;
        *(void *)&v115[2] = v70;
        os_log_type_t v71 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v109 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v71, type, &v109))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v72 = (os_log_s *)v8[131];
            v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              v74 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
              *(_DWORD *)buf = 136446978;
              v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
              v112 = 2082;
              *(void *)v113 = "frame_count";
              *(_WORD *)&v113[8] = 2048;
              v114 = 1LL;
              *(_WORD *)v115 = 2048;
              *(void *)&v115[2] = v74;
              v75 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_106:
              _os_log_impl(&dword_181A5C000, v72, v73, v75, buf, 0x2Au);
            }
          }

          else if (v109)
          {
            os_log_type_t v76 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v72 = (os_log_s *)v8[131];
            v73 = type[0];
            os_log_type_t v77 = os_log_type_enabled(v72, type[0]);
            if (v76)
            {
              if (v77)
              {
                os_log_type_t v78 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
                *(_DWORD *)buf = 136447234;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 2082;
                *(void *)v113 = "frame_count";
                *(_WORD *)&v113[8] = 2048;
                v114 = 1LL;
                *(_WORD *)v115 = 2048;
                *(void *)&v115[2] = v78;
                v116 = 2082;
                v117 = v76;
                _os_log_impl( &dword_181A5C000,  v72,  v73,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
              }

              free(v76);
              goto LABEL_107;
            }

            if (v77)
            {
              v80 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
              *(_DWORD *)buf = 136446978;
              v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
              v112 = 2082;
              *(void *)v113 = "frame_count";
              *(_WORD *)&v113[8] = 2048;
              v114 = 1LL;
              *(_WORD *)v115 = 2048;
              *(void *)&v115[2] = v80;
              v75 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_106;
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v72 = (os_log_s *)v8[131];
            v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              os_log_type_t v79 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
              *(_DWORD *)buf = 136446978;
              v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
              v112 = 2082;
              *(void *)v113 = "frame_count";
              *(_WORD *)&v113[8] = 2048;
              v114 = 1LL;
              *(_WORD *)v115 = 2048;
              *(void *)&v115[2] = v79;
              v75 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_106;
            }
          }
        }

                  goto LABEL_22;
                }

                if (!nw_parameters_are_compatible( *(void **)(a1 + 56),  *(void *)(a1 + 80),  v8,  v4,  *(unsigned __int8 *)(a1 + 98)))
                {
                  if (gLogDatapath)
                  {
                    __nwlog_obj();
                    id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                    {
                      char v32 = *(void *)(a1 + 32);
                      id v33 = *(void *)(a1 + 72);
                      *(_DWORD *)buf = 136446978;
                      os_log_type_t v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
                      v61 = 2112;
                      os_log_type_t v62 = v32;
                      char v63 = 2048;
                      os_log_type_t v64 = v4;
                      v65 = 2080;
                      os_log_type_t v66 = v33;
                      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s not eligible, parameters are not compatible",  buf,  0x2Au);
                    }

                    goto LABEL_78;
                  }

                  goto LABEL_22;
                }

                if (((*(uint64_t (**)(uint64_t, void, void))(a1 + 88))( v4,  *(void *)(a1 + 40),  *(void *)(a1 + 56)) & 1) == 0)
                {
                  if (gLogDatapath)
                  {
                    __nwlog_obj();
                    id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                    {
                      BOOL v35 = *(void *)(a1 + 32);
                      uint64_t v36 = *(void *)(a1 + 72);
                      *(_DWORD *)buf = 136446978;
                      os_log_type_t v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
                      v61 = 2112;
                      os_log_type_t v62 = v35;
                      char v63 = 2048;
                      os_log_type_t v64 = v4;
                      v65 = 2080;
                      os_log_type_t v66 = v36;
                      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s not eligible, new input handler rejected",  buf,  0x2Au);
                    }

                    goto LABEL_78;
                  }

                  goto LABEL_22;
                }

                *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = v4;
                uint64_t v3 = 2;
              }

              else
              {
                if ((nw_endpoint_is_equal(v7, *(void **)(a1 + 40), v9) & 1) == 0)
                {
                  if (nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 40)) == nw_endpoint_type_address)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v28 = (os_log_s *)(id)gLogObj;
                    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v29 = *(void *)(a1 + 72);
                      char v30 = *(void *)(a1 + 32);
                      uint64_t v31 = *(void *)(a1 + 40);
                      *(_DWORD *)buf = 136447490;
                      os_log_type_t v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
                      v61 = 2112;
                      os_log_type_t v62 = v30;
                      char v63 = 2048;
                      os_log_type_t v64 = v4;
                      v65 = 2080;
                      os_log_type_t v66 = v29;
                      BOOL v67 = 2112;
                      os_log_type_t v68 = v7;
                      BOOL v69 = 2112;
                      v70 = v31;
                      _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s not eligible, endpoints (candidate %@, endpoint %@) do not match",  buf,  0x3Eu);
                    }

                    goto LABEL_78;
                  }

                  __int16 v34 = (os_log_s *)nw_endpoint_copy_parent_endpoint(v7);
                  if (!nw_endpoint_is_equal(v34, *(void **)(a1 + 40), v9))
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v37 = (os_log_s *)(id)gLogObj;
                    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                    {
                      id v38 = *(void *)(a1 + 72);
                      char v39 = *(void *)(a1 + 32);
                      __int16 v40 = *(void *)(a1 + 40);
                      *(_DWORD *)buf = 136447490;
                      os_log_type_t v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
                      v61 = 2112;
                      os_log_type_t v62 = v39;
                      char v63 = 2048;
                      os_log_type_t v64 = v4;
                      v65 = 2080;
                      os_log_type_t v66 = v38;
                      BOOL v67 = 2112;
                      os_log_type_t v68 = v34;
                      BOOL v69 = 2112;
                      v70 = v40;
                      _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s not eligible, endpoints (candidate parent %@, endpoint %@) do not match",  buf,  0x3Eu);
                    }

                    goto LABEL_22;
                  }
                }

                int v20 = *(void **)(a1 + 48);
                if (!v20) {
                  goto LABEL_19;
                }
                __int16 v21 = v20;
                int v22 = [v21 type];

                if (v22 != 1) {
                  goto LABEL_19;
                }
                uint64_t v23 = v4;
                do
                {
                  os_log_type_t v24 = v23;
                  uint64_t v23 = *(void *)(v23 + 32);
                  if (!v23) {
                    break;
                  }
                  char v25 = *(void *)(v23 + 24);
                  if (!v25) {
                    break;
                  }
                }

                while (*(void *)(v25 + 136));
                id v26 = *(void *)(v24 + 24);
                if (v26 && (id v27 = *(void (**)(void))(v26 + 136)) != 0LL)
                {
                  v27();
                  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (gLogDatapath)
                  {
                    __nwlog_obj();
                    os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
                    {
                      v56 = *(void *)(a1 + 32);
                      os_log_type_t v57 = *(void *)(a1 + 72);
                      BOOL v58 = *(void *)(a1 + 48);
                      *(_DWORD *)buf = 136447490;
                      os_log_type_t v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
                      v61 = 2112;
                      os_log_type_t v62 = v56;
                      char v63 = 2048;
                      os_log_type_t v64 = v4;
                      v65 = 2080;
                      os_log_type_t v66 = v57;
                      BOOL v67 = 2112;
                      os_log_type_t v68 = v10;
                      BOOL v69 = 2112;
                      v70 = v58;
                      _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s not eligible, transport endpoints (candidate %@, endpoint %@) do not match",  buf,  0x3Eu);
                    }
                  }
                }

                else if (gLogDatapath)
                {
                  __nwlog_obj();
                  id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
                  {
                    os_log_type_t v53 = *(void *)(a1 + 32);
                    BOOL v54 = *(void *)(a1 + 72);
                    *(_DWORD *)buf = 136446978;
                    os_log_type_t v60 = "nw_protocol_instance_registrar_find_instance_to_join_block_invoke";
                    v61 = 2112;
                    os_log_type_t v62 = v53;
                    char v63 = 2048;
                    os_log_type_t v64 = v4;
                    v65 = 2080;
                    os_log_type_t v66 = v54;
                    _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s %@ instance %p of %s not eligible, transport protocol does not support get endpoint",  buf,  0x2Au);
                  }

                  goto LABEL_78;
                }

  if (v28) {
    free(v28);
  }
  return 0LL;
}

    id v42 = dispatch_group_create();
    __int16 v43 = (void *)*((void *)v1 + 5);
    *((void *)v1 + 5) = v42;

    dispatch_group_enter(*((dispatch_group_t *)v1 + 5));
    id v44 = *((void *)v1 + 8);
    id v45 = (dispatch_group_s *)*((void *)v1 + 5);
    v46 = nw_context_copy_workloop(*((void **)v1 + 4));
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZL37nw_resolver_create_dns_service_lockedP22NWConcrete_nw_resolver_block_invoke;
    block[3] = &unk_189BC66E8;
    v230 = v44;
    v47 = v10;
    v229 = v47;
    dispatch_group_notify(v45, (dispatch_queue_t)v46, block);

    *v224 = (DNSServiceRef)*((void *)v1 + 8);
    scoped_interface_index = nw_resolver_get_scoped_interface_index(v47, &flags);
    if (nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3)) == nw_endpoint_type_host)
    {
      *((void *)v1 + 9) = *((void *)v1 + 8);
      nw_endpoint_t v49 = flags;
      os_log_type_t v50 = *((unsigned int *)v1 + 20);
      hostname = nw_endpoint_get_hostname(*((nw_endpoint_t *)v1 + 3));
      os_log_type_t v52 = MEMORY[0x186E0F960]( v224,  v49,  scoped_interface_index,  v50,  hostname,  attr,  nw_resolver_host_resolve_callback,  v47,  context);
      if (v52 != -65569)
      {
        __int16 v5 = v52;
        v219 = "host";
        v221 = "DNSServiceGetAddrInfo";
        goto LABEL_277;
      }

      nw_resolver_cancel_query_locked(v47, 0);
      v219 = "host";
      uint64_t v7 = "DNSServiceGetAddrInfo";
      goto LABEL_14;
    }

    if (nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3)) == nw_endpoint_type_bonjour_service)
    {
      os_log_type_t v53 = v47;
      if (nw_endpoint_get_type(*((nw_endpoint_t *)v1 + 3)) != nw_endpoint_type_bonjour_service
        || (nw_parameters_get_use_awdl(*((void **)v1 + 2)) & 1) == 0
        || (bonjour_service_domain = nw_endpoint_get_bonjour_service_domain(*((nw_endpoint_t *)v1 + 3)),
            (os_log_type_t v55 = bonjour_service_domain) != 0LL)
        && strcasecmp(bonjour_service_domain, "local")
        && strcasecmp(v55, "local."))
      {

        goto LABEL_88;
      }

      v114 = *((id *)v1 + 2);
      v115 = v114;
      if (!v114 || (v116 = v114, v117 = (v116[12] & 0x10000000000LL) == 0, v116, v117))
      {

        goto LABEL_88;
      }

      v238 = 0LL;
      v239 = &v238;
      v241 = 1;
      v240 = 0x2020000000LL;
      v118 = nw_parameters_copy_preferred_interface_subtypes(*((void **)v1 + 2));
      v119 = v118;
      if (v118)
      {
        *(void *)applier = MEMORY[0x1895F87A8];
        *(void *)&applier[8] = 3221225472LL;
        *(void *)&applier[16] = ___ZL38nw_resolver_get_awdl_trigger_heuristicP22NWConcrete_nw_resolver_block_invoke;
        *(void *)&applier[24] = &unk_189BBC908;
        *(void *)&applier[32] = &v238;
        xpc_array_apply(v118, applier);
      }

      v120 = *((_DWORD *)v239 + 6);

      _Block_object_dispose(&v238, 8);
      if (!v120 || *((void *)v1 + 15) || (v121 = nw_interface_create_with_name("awdl0")) == 0LL)
      {
LABEL_88:

        goto LABEL_89;
      }

      v222 = v121;
      bonjour_service_os_log_type_t type = nw_endpoint_get_bonjour_service_type(*((nw_endpoint_t *)v1 + 3));
      v123 = nw_endpoint_get_bonjour_service_domain(*((nw_endpoint_t *)v1 + 3));
      bonjour_service = nw_browse_descriptor_create_bonjour_service(bonjour_service_type, v123);
      v124 = nw_parameters_copy(*((nw_parameters_t *)v1 + 2));
      v125 = (nw_interface *)v121;
      v126 = v124;
      v220 = v124;
      nw_parameters_require_interface(v124, v125);
      v127 = nw_browser_create(bonjour_service, v126);
      v128 = (void *)*((void *)v1 + 15);
      *((void *)v1 + 15) = v127;

      if (*((void *)v1 + 15))
      {
        v238 = 0LL;
        v239 = &v238;
        v240 = 0x2020000000LL;
        LOBYTE(v241) = 0;
        v234 = 0LL;
        v235 = &v234;
        v236 = 0x2020000000LL;
        v237 = v120 == 2;
        objc_initWeak(&location, v53);
        v129 = (nw_browser *)*((void *)v1 + 15);
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&buf[8] = 3221225472LL;
        *(void *)&buf[16] = ___ZL40nw_resolver_should_wait_for_awdl_triggerP22NWConcrete_nw_resolver_block_invoke;
        *(void *)&buf[24] = &unk_189BB6C68;
        *(void *)&buf[32] = &v238;
        objc_copyWeak((id *)&buf[48], &location);
        *(void *)&buf[40] = &v234;
        nw_browser_set_state_changed_handler(v129, buf);
        v130 = (nw_browser *)*((void *)v1 + 15);
        *(void *)handler = MEMORY[0x1895F87A8];
        *(void *)&handler[8] = 3221225472LL;
        *(void *)&handler[16] = ___ZL40nw_resolver_should_wait_for_awdl_triggerP22NWConcrete_nw_resolver_block_invoke_245;
        v246 = &unk_189BB6C90;
        v247 = &v238;
        objc_copyWeak(v249, &location);
        v248 = &v234;
        nw_browser_set_browse_results_changed_handler(v130, handler);
        if ((*((_BYTE *)v1 + 346) & 0x20) == 0)
        {
          if (*v225)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v131 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v131, OS_LOG_TYPE_INFO))
            {
              v132 = *((void *)v1 + 15);
              v133 = "?";
              if (v120 == 1) {
                v133 = "parallel";
              }
              *(_DWORD *)applier = 136446978;
              if (v120 == 2) {
                v133 = "blocking";
              }
              *(void *)&applier[4] = "nw_resolver_should_wait_for_awdl_trigger";
              *(_WORD *)&applier[12] = 2082;
              *(void *)&applier[14] = (char *)v1 + 256;
              *(_WORD *)&applier[22] = 2082;
              *(void *)&applier[24] = v133;
              *(_WORD *)&applier[32] = 2112;
              *(void *)&applier[34] = v132;
              v134 = v131;
              v135 = "%{public}s [C%{public}s] Starting %{public}s AWDL trigger browser %@";
              v136 = 42;
              goto LABEL_182;
            }
          }

          else
          {
            __nwlog_obj();
            v131 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v131, OS_LOG_TYPE_INFO))
            {
              v141 = *((_DWORD *)v1 + 85);
              v142 = "?";
              if (v120 == 1) {
                v142 = "parallel";
              }
              v143 = *((void *)v1 + 15);
              if (v120 == 2) {
                v142 = "blocking";
              }
              *(_DWORD *)applier = 136446978;
              *(void *)&applier[4] = "nw_resolver_should_wait_for_awdl_trigger";
              *(_WORD *)&applier[12] = 1024;
              *(_DWORD *)&applier[14] = v141;
              *(_WORD *)&applier[18] = 2082;
              *(void *)&applier[20] = v142;
              *(_WORD *)&applier[28] = 2112;
              *(void *)&applier[30] = v143;
              v134 = v131;
              v135 = "%{public}s [R%u] Starting %{public}s AWDL trigger browser %@";
              v136 = 38;
LABEL_182:
              _os_log_impl(&dword_181A5C000, v134, OS_LOG_TYPE_INFO, v135, applier, v136);
            }
          }
        }

        v144 = (nw_browser *)*((void *)v1 + 15);
        v145 = nw_context_copy_workloop(*((void **)v1 + 4));
        nw_browser_set_queue(v144, (dispatch_queue_t)v145);

        nw_browser_start(*((nw_browser_t *)v1 + 15));
        LOBYTE(v144) = *((_BYTE *)v235 + 24) == 0;
        objc_destroyWeak(v249);
        objc_destroyWeak((id *)&buf[48]);
        objc_destroyWeak(&location);
        _Block_object_dispose(&v234, 8);
        _Block_object_dispose(&v238, 8);

        if ((v144 & 1) == 0)
        {
          if ((*((_BYTE *)v1 + 346) & 0x20) == 0)
          {
            if (*v225)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              v212 = (os_log_s *)(id)gconnectionLogObj;
              if (os_log_type_enabled(v212, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = (char *)v1 + 256;
                v213 = "%{public}s [C%{public}s] Blocking resolve on AWDL trigger browser";
                v214 = v212;
                v215 = 22;
                goto LABEL_314;
              }
            }

            else
            {
              __nwlog_obj();
              v212 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v212, OS_LOG_TYPE_INFO))
              {
                v216 = *((_DWORD *)v1 + 85);
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_service_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v216;
                v213 = "%{public}s [R%u] Blocking resolve on AWDL trigger browser";
                v214 = v212;
                v215 = 18;
LABEL_314:
                _os_log_impl(&dword_181A5C000, v214, OS_LOG_TYPE_INFO, v213, buf, v215);
              }
            }
          }

  id v26 = v49;
  if (v37) {
    free(v37);
  }
LABEL_27:
}

    free(v48);
    if (!v40) {
      goto LABEL_58;
    }
    goto LABEL_191;
  }

  if ((v17[405] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v32 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v105 = 136446978;
      *(void *)&v105[4] = "nw_protocol_instance_add_outbound";
      *(_WORD *)&v105[12] = 2082;
      *(void *)&v105[14] = v17 + 407;
      *(_WORD *)&v105[22] = 2080;
      v106 = " ";
      LOWORD(v107) = 2048;
      *(void *)((char *)&v107 + 2) = v18;
      _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%sNo path found for frame %p",  v105,  0x2Au);
    }
  }

          char v39 = 0LL;
LABEL_132:

          return v39;
        }

        id v27 = a1->output_handler;
        if (v27)
        {
          id v28 = v27->handle;
          if (v28 == &nw_protocol_ref_counted_handle)
          {
            char v32 = v27[1].callbacks;
            if (v32) {
              v27[1].callbacks = (nw_protocol_callbacks *)((char *)&v32->add_input_handler + 1);
            }
            uint64_t v29 = -1;
          }

          else
          {
            uint64_t v29 = 0;
          }

          *(void *)os_log_type_t type = v27;
          v167 = v29;
          id v33 = a1->handle;
          if (v33 == &nw_protocol_ref_counted_handle)
          {
            BOOL v35 = a1[1].callbacks;
            if (v35) {
              a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v35->add_input_handler + 1);
            }
            __int16 v34 = -1;
          }

          else
          {
            __int16 v34 = 0;
          }

          *(void *)v163 = a1;
          v164 = v34;
          uint64_t v36 = v27->callbacks;
          if (v36)
          {
            id v37 = (void (*)(nw_protocol *, nw_protocol *))v36->connect;
            if (v37)
            {
              v37(v27, a1);
LABEL_64:
              if (v33 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)v163);
              }
              if (v28 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              }
              goto LABEL_131;
            }
          }

          __nwlog_obj();
          v96 = (void *)objc_claimAutoreleasedReturnValue();
          v97 = v27->identifier->name;
          *(_DWORD *)buf = 136446722;
          v169 = "__nw_protocol_connect";
          if (!v97) {
            v97 = "invalid";
          }
          v170 = 2082;
          v171 = (char *)v97;
          v172 = 2048;
          v173 = v27;
          v98 = (char *)_os_log_send_and_compose_impl();

          v165 = OS_LOG_TYPE_ERROR;
          v162 = 0;
          if (__nwlog_fault(v98, &v165, &v162))
          {
            if (v165 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v100 = v165;
              if (os_log_type_enabled(v99, v165))
              {
                v101 = v27->identifier->name;
                if (!v101) {
                  v101 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                v169 = "__nw_protocol_connect";
                v170 = 2082;
                v171 = (char *)v101;
                v172 = 2048;
                v173 = v27;
                _os_log_impl( &dword_181A5C000,  v99,  v100,  "%{public}s protocol %{public}s (%p) has invalid connect callback",  buf,  0x20u);
              }
            }

            else if (v162)
            {
              v115 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v116 = v165;
              v117 = os_log_type_enabled(v99, v165);
              if (v115)
              {
                if (v117)
                {
                  v118 = v27->identifier->name;
                  if (!v118) {
                    v118 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  v169 = "__nw_protocol_connect";
                  v170 = 2082;
                  v171 = (char *)v118;
                  v172 = 2048;
                  v173 = v27;
                  v174 = 2082;
                  v175 = (nw_protocol *)v115;
                  _os_log_impl( &dword_181A5C000,  v99,  v116,  "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                }

                free(v115);
                goto LABEL_317;
              }

              if (v117)
              {
                v143 = v27->identifier->name;
                if (!v143) {
                  v143 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                v169 = "__nw_protocol_connect";
                v170 = 2082;
                v171 = (char *)v143;
                v172 = 2048;
                v173 = v27;
                _os_log_impl( &dword_181A5C000,  v99,  v116,  "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace",  buf,  0x20u);
              }
            }

            else
            {
              __nwlog_obj();
              v99 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              v138 = v165;
              if (os_log_type_enabled(v99, v165))
              {
                v139 = v27->identifier->name;
                if (!v139) {
                  v139 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                v169 = "__nw_protocol_connect";
                v170 = 2082;
                v171 = (char *)v139;
                v172 = 2048;
                v173 = v27;
                _os_log_impl( &dword_181A5C000,  v99,  v138,  "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded",  buf,  0x20u);
              }
            }
          }

  if (v22) {
    free(v22);
  }
  return 1LL;
}

  if (v22) {
    free(v22);
  }
  return 1LL;
}

    if (v31) {
      free(v31);
    }
    os_nexus_controller_destroy();
    return 0LL;
  }

  BOOL v11 = (void *)v10;
  os_log_type_t v12 = 0LL;
  id v13 = v10 + 24;
  id v14 = 64LL;
  while (1)
  {
    id v15 = *(unsigned __int8 *)(a1 + v12);
    *(_BYTE *)(v13 + v12) = v15;
    if (!v15) {
      break;
    }
    --v14;
    ++v12;
    if (v14 <= 1)
    {
      *(_BYTE *)(v13 + v12) = 0;
      break;
    }
  }

  *(void *)(v10 + 16) = v9;
  if (!os_nexus_attr_create())
  {
    id v38 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v51 = "nw_nexus_create_with_options";
    os_log_type_t v52 = 1024;
    *(_DWORD *)os_log_type_t v53 = v38;
    int v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v27 = (os_log_s *)gLogObj;
      id v28 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_nexus_create_with_options";
      os_log_type_t v52 = 1024;
      *(_DWORD *)os_log_type_t v53 = v38;
      char v25 = "%{public}s os_nexus_attr_create() %{darwin.errno}d";
      goto LABEL_91;
    }

    if (!v48)
    {
      id v27 = (os_log_s *)__nwlog_obj();
      id v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_nexus_create_with_options";
      os_log_type_t v52 = 1024;
      *(_DWORD *)os_log_type_t v53 = v38;
      char v25 = "%{public}s os_nexus_attr_create() %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_91;
    }

    BOOL v35 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v27 = (os_log_s *)gLogObj;
    id v28 = type;
    __int16 v43 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v35)
    {
      if (!v43) {
        goto LABEL_93;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_nexus_create_with_options";
      os_log_type_t v52 = 1024;
      *(_DWORD *)os_log_type_t v53 = v38;
      char v25 = "%{public}s os_nexus_attr_create() %{darwin.errno}d, no backtrace";
      goto LABEL_91;
    }

    if (v43)
    {
      *(_DWORD *)buf = 136446722;
      v51 = "nw_nexus_create_with_options";
      os_log_type_t v52 = 1024;
      *(_DWORD *)os_log_type_t v53 = v38;
      v53[2] = 2082;
      *(void *)&v53[3] = v35;
      id v37 = "%{public}s os_nexus_attr_create() %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_61;
    }

    goto LABEL_62;
  }

  if (a2) {
    os_nexus_attr_set();
  }
  if (a3) {
    os_nexus_attr_set();
  }
  if (a4) {
    os_nexus_attr_set();
  }
  os_nexus_attr_set();
  int v16 = os_nexus_controller_register_provider();
  os_nexus_attr_destroy();
  if (v16)
  {
    __int16 v17 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v51 = "nw_nexus_create_with_options";
    os_log_type_t v52 = 1024;
    *(_DWORD *)os_log_type_t v53 = v17;
    id v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v18, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (os_log_s *)gLogObj;
        int v20 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_nexus_create_with_options";
          os_log_type_t v52 = 1024;
          *(_DWORD *)os_log_type_t v53 = v17;
          __int16 v21 = "%{public}s os_nexus_controller_register_provider() %{darwin.errno}d";
LABEL_85:
          _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0x12u);
        }
      }

      else if (v48)
      {
        os_log_type_t v41 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (os_log_s *)gLogObj;
        int v20 = type;
        id v42 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v41)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446722;
            v51 = "nw_nexus_create_with_options";
            os_log_type_t v52 = 1024;
            *(_DWORD *)os_log_type_t v53 = v17;
            v53[2] = 2082;
            *(void *)&v53[3] = v41;
            _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s os_nexus_controller_register_provider() %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v41);
          goto LABEL_86;
        }

        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_nexus_create_with_options";
          os_log_type_t v52 = 1024;
          *(_DWORD *)os_log_type_t v53 = v17;
          __int16 v21 = "%{public}s os_nexus_controller_register_provider() %{darwin.errno}d, no backtrace";
          goto LABEL_85;
        }
      }

      else
      {
        id v19 = (os_log_s *)__nwlog_obj();
        int v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_nexus_create_with_options";
          os_log_type_t v52 = 1024;
          *(_DWORD *)os_log_type_t v53 = v17;
          __int16 v21 = "%{public}s os_nexus_controller_register_provider() %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_85;
        }
      }
    }
      }

      break;
    default:
      return;
  }

    if (v36) {
      free(v36);
    }
    goto LABEL_37;
  }

  os_log_type_t v12 = (NWConcrete_nw_endpoint_handler *)v10;
  mode = v12->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v22 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v23 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_flow_replay_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v23;
      *(_WORD *)&buf[22] = 2082;
      char v63 = "flow";
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

    goto LABEL_37;
  }

  if (*((void *)handle + 37))
  {
    if (*((_DWORD *)handle + 82))
    {
      if (*((void *)handle + 16))
      {
        id v14 = (char *)*((void *)handle + 36);
        if (v14)
        {
          *(void *)os_log_type_t type = 0LL;
          os_log_type_t v59 = type;
          os_log_type_t v60 = 0x2020000000LL;
          v61 = 0;
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 3221225472LL;
          *(void *)&buf[16] = ___ZL56nw_flow_replay_selected_candidate_has_early_data_to_sendP16nw_flow_protocol_block_invoke;
          char v63 = (const char *)&unk_189BB86A0;
          os_log_type_t v64 = type;
          v65 = handle;
          nw_hash_table_apply(v14, (uint64_t)buf);
          id v15 = *((unsigned __int8 *)v59 + 24);
          _Block_object_dispose(type, 8);
          if (v15)
          {
            nw_flow_replay_send_initial_data_to_candidates(v12, (nw_flow_protocol *)handle);
            if (*((void *)handle + 37))
            {
              if (*((_DWORD *)handle + 82))
              {
                if (*((void *)handle + 16))
                {
                  int v16 = (char *)*((void *)handle + 36);
                  if (v16)
                  {
                    *(void *)os_log_type_t type = 0LL;
                    os_log_type_t v59 = type;
                    os_log_type_t v60 = 0x2020000000LL;
                    v61 = 0;
                    *(void *)buf = MEMORY[0x1895F87A8];
                    *(void *)&buf[8] = 3221225472LL;
                    *(void *)&buf[16] = ___ZL56nw_flow_replay_selected_candidate_has_early_data_to_sendP16nw_flow_protocol_block_invoke;
                    char v63 = (const char *)&unk_189BB86A0;
                    os_log_type_t v64 = type;
                    v65 = handle;
                    nw_hash_table_apply(v16, (uint64_t)buf);
                    __int16 v17 = *((unsigned __int8 *)v59 + 24);
                    _Block_object_dispose(type, 8);
                    id v18 = 0LL;
                    if (v17) {
                      goto LABEL_38;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      get_output_frames = (uint64_t (*)(void))callbacks->get_output_frames;
      if (get_output_frames)
      {
        id v18 = get_output_frames();
LABEL_38:

        return v18;
      }
    }

    __nwlog_obj();
    char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_flow_replay_get_output_frames";
      _os_log_impl( &dword_181A5C000,  v39,  OS_LOG_TYPE_INFO,  "%{public}s Output protocol handler does not support get_output_frames",  buf,  0xCu);
    }

LABEL_37:
    id v18 = 0LL;
    goto LABEL_38;
  }

  *(_DWORD *)os_log_type_t type = 0;
  id v18 = 0LL;
  else {
    uint64_t v7 = (2000 - *(_DWORD *)type);
  }
  if (!(_DWORD)v7) {
    goto LABEL_30;
  }
  os_log_type_t v24 = calloc(1uLL, v7);
  if (v24) {
    goto LABEL_31;
  }
  __nwlog_obj();
  char v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  *(_WORD *)&buf[12] = 2048;
  *(void *)&buf[14] = 1LL;
  *(_WORD *)&buf[22] = 2048;
  char v63 = (const char *)v7;
  id v26 = (void *)_os_log_send_and_compose_impl();

  uint64_t result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
LABEL_30:
    os_log_type_t v24 = 0LL;
LABEL_31:
    id v28 = (char *)(id)nw_frame_create( 0,  (uint64_t)v24,  v7,  (uint64_t)nw_flow_replay_frame_finalizer,  (uint64_t)handle);
    if (v28)
    {
      *((_WORD *)v28 + 102) |= 1u;
      *((void *)v28 + 2) = 0LL;
      uint64_t v29 = (void *)*((void *)handle + 38);
      *((void *)v28 + 3) = v29;
      *uint64_t v29 = v28;
      *((void *)handle + 38) = v28 + 16;
      *((void *)v28 + 4) = 0LL;
      tqh_last = a6->tqh_last;
      *((void *)v28 + 5) = tqh_last;
      *tqh_last = (nw_frame *)v28;
      a6->tqh_last = (nw_frame **)(v28 + 32);
      id v18 = 1LL;
LABEL_33:

      goto LABEL_38;
    }

    __nwlog_obj();
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_flow_replay_get_output_frames";
    nw_endpoint_t v49 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v57 = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (__nwlog_fault(v49, &v57, &v56))
    {
      if (v57 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v51 = v57;
        if (os_log_type_enabled(v50, v57))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_replay_get_output_frames";
          _os_log_impl(&dword_181A5C000, v50, v51, "%{public}s called with null additional_reference", buf, 0xCu);
        }
      }

      else if (v56)
      {
        os_log_type_t v52 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v53 = v57;
        BOOL v54 = os_log_type_enabled(v50, v57);
        if (v52)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_flow_replay_get_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v52;
            _os_log_impl( &dword_181A5C000,  v50,  v53,  "%{public}s called with null additional_reference, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v52);
          goto LABEL_96;
        }

        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_replay_get_output_frames";
          _os_log_impl( &dword_181A5C000,  v50,  v53,  "%{public}s called with null additional_reference, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v55 = v57;
        if (os_log_type_enabled(v50, v57))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_flow_replay_get_output_frames";
          _os_log_impl( &dword_181A5C000,  v50,  v55,  "%{public}s called with null additional_reference, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

      if (v31) {
        free(v31);
      }
      goto LABEL_24;
    }

    __nwlog_obj();
    id v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_for_definition";
    char v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v51 = 0;
    if (__nwlog_fault(v25, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v29 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_for_definition";
          _os_log_impl(&dword_181A5C000, v26, v29, "%{public}s called with null definition", buf, 0xCu);
        }

LABEL_79:
            char v25 = v81;
          }

          if (v80) {
            free(v80);
          }
          os_log_type_t v50 = v78;
          goto LABEL_83;
        }

    if (v26) {
      free(v26);
    }
    goto LABEL_51;
  }

  if (nw_parameters_get_is_probe(v1->parameters))
  {
    parameters = v2->parameters;
    if (!parameters || nw_path_parameters_get_logging_disabled(*((void *)parameters + 13))) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      top_id = v2->top_id;
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_connection_should_run_probe_locked";
      id v37 = 1024;
      *(_DWORD *)id v38 = top_id;
      _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Not probing a probe", buf, 0x12u);
    }

    if (v49) {
      free(v49);
    }
    return 0LL;
  }

  __int16 v5 = (void *)*((void *)a2 + 1);
  if (v5)
  {
    count = xpc_array_get_count(v5);
    uint64_t v7 = (void *)*((void *)a2 + 2);
    if (!v7) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }

  count = 0LL;
  uint64_t v7 = (void *)*((void *)a2 + 2);
  if (v7) {
LABEL_4:
  }
    uint64_t v7 = (void *)xpc_array_get_count(v7);
LABEL_5:
  if (count) {
    os_log_type_t v8 = count == (void)v7;
  }
  else {
    os_log_type_t v8 = 0;
  }
  os_log_type_t v9 = v8;
  if (v8)
  {
    os_log_type_t v10 = 0LL;
    BOOL v11 = 0LL;
    do
    {
      string = xpc_array_get_string(*((xpc_object_t *)a2 + 1), v11);
      id v13 = xpc_array_get_string(*((xpc_object_t *)a2 + 2), v11);
      id v14 = strlen(string);
      id v15 = v10 + v14 + strlen(v13);
      os_log_type_t v10 = v15 + 2;
      ++v11;
    }

    while (count != v11);
    id v19 = v15 + 78;
    if (v15 == -78LL)
    {
      int v16 = (os_log_s *)__nwlog_obj();
      os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      os_log_type_t v62 = "strict_calloc";
      __int16 v17 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort((uint64_t)v17);
      if (result) {
        goto LABEL_81;
      }
      free(v17);
      id v19 = 0LL;
    }
  }

  else
  {
    id v19 = 76LL;
  }

  int v20 = (char *)calloc(1uLL, v19);
  if (v20) {
    goto LABEL_19;
  }
  os_log_type_t v53 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v62 = "strict_calloc";
  char v63 = 2048;
  os_log_type_t v64 = 1LL;
  v65 = 2048;
  os_log_type_t v66 = v19;
  BOOL v54 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v54);
  if (!result)
  {
    free(v54);
LABEL_19:
    *(void *)int v20 = *((void *)a2 + 3);
    *((_WORD *)v20 + 37) = *((_WORD *)a2 + 16);
    if (*(void *)a2)
    {
      __int16 v21 = *(id *)a2;
      int v22 = [v21 port];

      *((_WORD *)v20 + 4) = __rev16(v22);
      hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)a2);
      if (hostname)
      {
        os_log_type_t v24 = hostname;
        if (strlen(hostname) - 1 <= 0x3E)
        {
          char v25 = v20 + 10;
          id v26 = 64LL;
          while (1)
          {
            id v27 = *(unsigned __int8 *)v24;
            nw_endpoint *v25 = v27;
            if (!v27) {
              break;
            }
            ++v25;
            ++v24;
            if ((unint64_t)--v26 <= 1)
            {
              nw_endpoint *v25 = 0;
              break;
            }
          }
        }
      }
    }

    if (v9)
    {
      id v28 = 0LL;
      uint64_t v29 = v20 + 76;
      do
      {
        char v30 = xpc_array_get_string(*((xpc_object_t *)a2 + 1), v28);
        uint64_t v31 = strlen(v30);
        if (v29)
        {
          if (v30) {
            goto LABEL_31;
          }
        }

        else
        {
          __int16 v43 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v43, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "_strict_strlcpy";
          id v44 = (void *)_os_log_send_and_compose_impl();
          uint64_t result = __nwlog_abort((uint64_t)v44);
          if (result) {
            goto LABEL_81;
          }
          free(v44);
          if (v30) {
            goto LABEL_31;
          }
        }

        id v45 = (os_log_s *)__nwlog_obj();
        os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "_strict_strlcpy";
        v46 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort((uint64_t)v46);
        if (result) {
          goto LABEL_81;
        }
        free(v46);
LABEL_31:
        char v32 = v31 + 1;
        id v33 = v29;
        __int16 v34 = v31 + 1;
        if (v31 + 1 < 2)
        {
LABEL_36:
          if (v31 != -1LL && v34) {
            *id v33 = 0;
          }
        }

        else
        {
          BOOL v35 = v31 + 1;
          id v33 = v29;
          while (1)
          {
            uint64_t v36 = *(unsigned __int8 *)v30;
            *id v33 = v36;
            if (!v36) {
              break;
            }
            ++v33;
            ++v30;
            if (--v35 <= 1)
            {
              __int16 v34 = 1LL;
              goto LABEL_36;
            }
          }
        }

        id v37 = xpc_array_get_string(*((xpc_object_t *)a2 + 2), v28);
        id v38 = strlen(v37);
        if (v29)
        {
          if (!v37) {
            goto LABEL_56;
          }
        }

        else
        {
          v47 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          os_log_type_t v62 = "_strict_strlcpy";
          os_log_type_t v57 = (void *)_os_log_send_and_compose_impl();
          uint64_t result = __nwlog_abort((uint64_t)v57);
          if (result) {
            goto LABEL_81;
          }
          free(v57);
          if (!v37)
          {
LABEL_56:
            v48 = (os_log_s *)__nwlog_obj();
            os_log_type_enabled(v48, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446210;
            os_log_type_t v62 = "_strict_strlcpy";
            BOOL v58 = (void *)_os_log_send_and_compose_impl();
            uint64_t result = __nwlog_abort((uint64_t)v58);
            if (result) {
              goto LABEL_81;
            }
            free(v58);
          }
        }

        if (v38 + 1 < 2)
        {
          __int16 v40 = &v29[v32];
          id v42 = v38 + 1;
          if (v38 != -1LL)
          {
LABEL_48:
            if (v42) {
              os_log_s *v40 = 0;
            }
          }
        }

        else
        {
          char v39 = v38 + 1;
          __int16 v40 = &v29[v32];
          while (1)
          {
            os_log_type_t v41 = *(unsigned __int8 *)v37;
            os_log_s *v40 = v41;
            if (!v41) {
              break;
            }
            ++v40;
            ++v37;
            if (--v39 <= 1)
            {
              id v42 = 1LL;
              if (v38 != -1LL) {
                goto LABEL_48;
              }
              break;
            }
          }
        }

        v29 += v32 + v38 + 1;
        ++v28;
      }

      while (v28 != count);
    }

    *a3 = v19;
    return (BOOL)v20;
  }

                os_release(v34);
                goto LABEL_79;
              }

  if (v45) {
    free(v45);
  }
  id v19 = 0LL;
LABEL_41:

  return v19;
}

  PBDataWriterWriteBOOLField();
  has = (__int16)self->_has;
  if ((has & 0x1000) == 0)
  {
LABEL_23:
    if ((has & 0x200) == 0) {
      goto LABEL_24;
    }
    goto LABEL_80;
  }

        goto LABEL_79;
      }

      if (!v61)
      {
        __nwlog_obj();
        __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v57 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v64 = "nw_endpoint_host_endpoint_matches_hostname";
          _os_log_impl( &dword_181A5C000,  v40,  v57,  "%{public}s called with null hostname, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_78;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = type;
      os_log_type_t v52 = os_log_type_enabled(v40, type);
      if (!backtrace_string)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v64 = "nw_endpoint_host_endpoint_matches_hostname";
          _os_log_impl(&dword_181A5C000, v40, v51, "%{public}s called with null hostname, no backtrace", buf, 0xCu);
        }

        goto LABEL_78;
      }

      if (v52)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v64 = "nw_endpoint_host_endpoint_matches_hostname";
        v65 = 2082;
        *(void *)os_log_type_t v66 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v40,  v51,  "%{public}s called with null hostname, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_61;
    }

    goto LABEL_79;
  }

  BOOL v11 = v9;
  os_log_type_t v12 = [v11 type];

  if (v12 == 2)
  {
    id v13 = (unsigned __int16 *)v11;
    id v14 = (const char *)*((void *)v13 + 29);
    if (v14)
    {
      if (a5)
      {
        id v15 = v13;
        int v16 = *((id *)v15 + 2);

        if (v16) {
          __int16 v17 = v16[2];
        }
        else {
          __int16 v17 = 0;
        }

        id v14 = (const char *)*((void *)v15 + 29);
      }

      else
      {
        __int16 v17 = 0;
      }

      if (!strcmp(v14, a2) && v13[120] == a3)
      {
        if (v17 == a4) {
          uint64_t v31 = 1LL;
        }
        else {
          uint64_t v31 = a5 ^ 1u;
        }
        goto LABEL_90;
      }

    if (v40) {
      free(v40);
    }
LABEL_74:

LABEL_86:
    char v25 = 0LL;
    goto LABEL_17;
  }

  v65.receiver = self;
  v65.super_class = (Class)&OBJC_CLASS___NWUDPListener;
  os_log_type_t v9 = -[NWUDPListener init](&v65, sel_init);
  if (!v9)
  {
    __nwlog_obj();
    __int16 v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v68 = "-[NWUDPListener initWithParameters:delegate:]";
    id v44 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(location) = 16;
    os_log_type_t v66 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v44, &location, &v66))
    {
      if (location == 17)
      {
        __nwlog_obj();
        id v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v46 = location;
        if (os_log_type_enabled(v45, (os_log_type_t)location))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v68 = "-[NWUDPListener initWithParameters:delegate:]";
          _os_log_impl(&dword_181A5C000, v45, v46, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v66)
      {
        os_log_type_t v53 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v54 = location;
        os_log_type_t v55 = os_log_type_enabled(v45, (os_log_type_t)location);
        if (v53)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v68 = "-[NWUDPListener initWithParameters:delegate:]";
            BOOL v69 = 2082;
            v70 = v53;
            _os_log_impl( &dword_181A5C000,  v45,  v54,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v53);
          goto LABEL_84;
        }

        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v68 = "-[NWUDPListener initWithParameters:delegate:]";
          _os_log_impl(&dword_181A5C000, v45, v54, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v58 = location;
        if (os_log_type_enabled(v45, (os_log_type_t)location))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v68 = "-[NWUDPListener initWithParameters:delegate:]";
          _os_log_impl( &dword_181A5C000,  v45,  v58,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v45) {
    free(v45);
  }
  id v19 = 0LL;
LABEL_41:

  return v19;
}

  v61 = v38->i32[0];
  id v38 = (uint32x2_t *)((char *)v38 + 4);
  v37 += v61;
  if ((v23 & 2) != 0) {
    goto LABEL_79;
  }
LABEL_67:
  if ((v23 & 1) != 0) {
LABEL_68:
  }
    v37 += v38->u8[0];
LABEL_69:
  os_log_type_t v50 = __ROR8__(v37, 56);
  _ZF = (v36 & 1) == 0LL;
  else {
    os_log_type_t v52 = v37;
  }
  os_log_type_t v53 = ((unint64_t)(v39 + v52 + HIDWORD(v52)) >> 32) + (v39 + v52 + HIDWORD(v52));
  BOOL v54 = v53 + WORD1(v53);
  os_log_type_t v55 = bswap32(v54) >> 16;
  if (!_ZF) {
    LOWORD(v54) = v55;
  }
  int v22 = ((v22 + (unsigned __int16)v54) >> 16) + (unsigned __int16)(v22 + v54);
LABEL_23:
  os_log_type_t v24 = a6 - v22;
  if (a6 <= v22) {
    os_log_type_t v24 = (unsigned __int16)(a6 + ~(_WORD)v22);
  }
  if (v22) {
    char v25 = v24;
  }
  else {
    char v25 = a6;
  }
  return (unsigned __int16)(((HIWORD(v25) + (unsigned __int16)v25) >> 16)
                          + HIWORD(v25)
                          + v25
}

    goto LABEL_324;
  }

  if (a5)
  {
    if (v23 != *((_DWORD *)a5 + 14)
      || (char v25 = a5[1], v25 != __src[0].sa_family)
      || (id v26 = *a5, (_DWORD)v26 != __src[0].sa_len))
    {
LABEL_321:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v175 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v175, OS_LOG_TYPE_INFO))
      {
        v176 = *((_DWORD *)a5 + 14);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v23;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v176;
        _os_log_impl( &dword_181A5C000,  v175,  OS_LOG_TYPE_INFO,  "%{public}s Invalid fragment ID being dropped %u (expecting %u)",  buf,  0x18u);
      }

      goto LABEL_324;
    }

    if (v25 == 30)
    {
      if (*((void *)a5 + 1) != *(void *)&__src[0].sa_data[6] || *((void *)a5 + 2) != *(void *)&__src[1].sa_len) {
        goto LABEL_321;
      }
    }

    else if (v25 != 2 || *((_DWORD *)a5 + 1) != *(_DWORD *)&__src[0].sa_data[2])
    {
      goto LABEL_321;
    }

    v123 = a5[29];
    if (v123 != __dst[0].sa_family) {
      goto LABEL_321;
    }
    v124 = a5[28];
    if ((_DWORD)v124 != __dst[0].sa_len) {
      goto LABEL_321;
    }
    if (v123 == 30)
    {
      if (*(void *)(a5 + 36) != *(void *)&__dst[0].sa_data[6]
        || *(void *)(a5 + 44) != *(void *)&__dst[1].sa_len)
      {
        goto LABEL_321;
      }
    }

    else if (v123 != 2 || *((_DWORD *)a5 + 8) != *(_DWORD *)&__dst[0].sa_data[2])
    {
      goto LABEL_321;
    }

    v224 = a5[60];
    memcpy(__src, a5, v26);
    memcpy(__dst, a5 + 28, v124);
    if (!object) {
      goto LABEL_151;
    }
    goto LABEL_149;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v45 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v23;
    _os_log_impl(&dword_181A5C000, v45, OS_LOG_TYPE_INFO, "%{public}s Invalid fragment ID being dropped %u", buf, 0x12u);
  }

LABEL_148:
  if (object)
  {
LABEL_149:
    if (*((void *)object + 3) != *((void *)object + 2))
    {
      v236[0] = MEMORY[0x1895F87A8];
      v236[1] = 3221225472LL;
      v236[2] = ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke;
      v236[3] = &unk_189BC0B78;
      *(sockaddr *)v238 = __src[0];
      *(sockaddr *)&v238[12] = *(sockaddr *)&__src[0].sa_data[10];
      *(sockaddr *)v239 = __dst[0];
      *(sockaddr *)&v239[12] = *(sockaddr *)&__dst[0].sa_data[10];
      v237 = v10;
      id v86 = nw_array_apply(object, (uint64_t)v236);

      if (!v86) {
        goto LABEL_325;
      }
    }
  }

        os_log_type_t v8 = 0LL;
LABEL_79:

        goto LABEL_80;
      }

      __nwlog_obj();
      int v20 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      id v44 = "nw_quic_is_above_failure_threshold";
      __int16 v21 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v41 = 0;
      if (__nwlog_fault(v21, &type, &v41))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            id v44 = "nw_quic_is_above_failure_threshold";
            _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s called with null definition", buf, 0xCu);
          }
        }

        else if (v41)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v30 = type;
          uint64_t v31 = os_log_type_enabled(v22, type);
          if (backtrace_string)
          {
            if (v31)
            {
              *(_DWORD *)buf = 136446466;
              id v44 = "nw_quic_is_above_failure_threshold";
              id v45 = 2082;
              *(void *)v46 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v22,  v30,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_76;
          }

          if (v31)
          {
            *(_DWORD *)buf = 136446210;
            id v44 = "nw_quic_is_above_failure_threshold";
            _os_log_impl(&dword_181A5C000, v22, v30, "%{public}s called with null definition, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v34 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)buf = 136446210;
            id v44 = "nw_quic_is_above_failure_threshold";
            _os_log_impl( &dword_181A5C000,  v22,  v34,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

    goto LABEL_79;
  }

  uint64_t v3 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_activity);
  id v4 = v2;
  if (!v3)
  {
LABEL_29:

LABEL_30:
    return (BOOL)v3;
  }

  v41.receiver = v3;
  v41.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_activity;
  uint64_t v3 = (NWConcrete_nw_activity *)objc_msgSendSuper2(&v41, sel_init);
  if (!v3)
  {
    __nwlog_obj();
    __int16 v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v43 = "-[NWConcrete_nw_activity initWithXPCObject:]";
    int v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if ((__nwlog_fault(v22, &type, &v39) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v43 = "-[NWConcrete_nw_activity initWithXPCObject:]";
          _os_log_impl(&dword_181A5C000, v23, v24, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v39)
      {
        id v33 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v34 = type;
        BOOL v35 = os_log_type_enabled(v23, type);
        if (v33)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v43 = "-[NWConcrete_nw_activity initWithXPCObject:]";
            id v44 = 2082;
            id v45 = v33;
            _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v33);
          goto LABEL_85;
        }

        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v43 = "-[NWConcrete_nw_activity initWithXPCObject:]";
          _os_log_impl(&dword_181A5C000, v23, v34, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v38 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v43 = "-[NWConcrete_nw_activity initWithXPCObject:]";
          _os_log_impl( &dword_181A5C000,  v23,  v38,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v45) {
    free(v45);
  }
  id v19 = 0LL;
LABEL_41:

  return v19;
}

    free(backtrace_string);
    goto LABEL_108;
  }

  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  BOOL v11 = cchpke_params_sizeof_aead_tag() + a2;
  if (!v11)
  {
    __int16 v21 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    id v37 = "strict_calloc";
    int v22 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v22);
    if (result) {
      goto LABEL_111;
    }
    free(v22);
  }

  os_log_type_t v12 = calloc(1uLL, v11);
  if (v12) {
    goto LABEL_10;
  }
  uint64_t v23 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  id v37 = "strict_calloc";
  id v38 = 2048;
  char v39 = 1LL;
  __int16 v40 = 2048;
  os_log_type_t v41 = v11;
  os_log_type_t v24 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v24);
  if (!result)
  {
    free(v24);
LABEL_10:
    memcpy(v12, a1, a2);
    id v13 = cchpke_initiator_encrypt();
    if (v13)
    {
      id v14 = v13;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v15 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        id v37 = "nw_http_encrypt_chunked_oblivious_request_chunk";
        id v38 = 1024;
        LODWORD(v39) = v14;
        _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_ERROR, "%{public}s Encrypt: %d", buf, 0x12u);
      }

      if (v12)
      {
        free(v12);
        return 0LL;
      }
    }

    else
    {
      *a8 = v11;
    }

    return (BOOL)v12;
  }

LABEL_28:
      if (!v13) {
        goto LABEL_30;
      }
LABEL_29:
      free(v13);
      goto LABEL_30;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v35 = v37[0];
      if (os_log_type_enabled(v21, v37[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl( &dword_181A5C000,  v21,  v35,  "%{public}s called with null tfo_cache_buffer, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v31 = v37[0];
    char v32 = os_log_type_enabled(v21, v37[0]);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
        _os_log_impl( &dword_181A5C000,  v21,  v31,  "%{public}s called with null tfo_cache_buffer, no backtrace",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v41 = "nw_path_flow_registration_set_tfo_cache";
      id v42 = 2082;
      *(void *)__int16 v43 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v21,  v31,  "%{public}s called with null tfo_cache_buffer, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    if (v45) {
      free(v45);
    }
    goto LABEL_80;
  }

  id v18 = nw_parameters_copy_context(*((void **)v16 + 1));
  nw_context_assert_queue(v18);

  if (nw_path_endpoint_is_always_satisfied(*((void **)v16 + 2)))
  {
    uuid_generate_random(out);
    id v19 = nw_path_flow_registration_create((NWConcrete_nw_path_evaluator *)v16, out);
    int v20 = v19;
    if (v19) {
      *((_BYTE *)v19 + 148) |= 1u;
    }
    goto LABEL_81;
  }

  __int16 v21 = nw_parameters_copy_context(*((void **)v16 + 1));
  int v22 = nw_path_shared_necp_fd(v21);

  if (v22 < 0)
  {
LABEL_80:
    int v20 = 0LL;
    goto LABEL_81;
  }

  os_log_type_t v62 = 0u;
  memset(v63, 0, sizeof(v63));
  v61 = 0u;
  memset(out, 0, sizeof(out));
  if (!a3)
  {
    uint64_t v23 = 0;
    if (!a4) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }

  uint64_t v23 = 1;
  LOWORD(v61) = 1;
  if (a4)
  {
LABEL_10:
    v23 |= 4u;
    LOWORD(v61) = v23;
  }

    goto LABEL_27;
  }

  __int16 v5 = v3;
  int v6 = *((id *)v5 + 1);

  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
  }
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe( (uint64_t)v6,  nw_protocol_copy_http_definition_http_definition);

  if (!is_equal_unsafe)
  {
    __nwlog_obj();
    id v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_http_metadata_set_endpoint";
    id v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v50 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v34 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_http_metadata_set_endpoint";
        _os_log_impl(&dword_181A5C000, v31, v34, "%{public}s metadata must be http", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (!v50)
    {
      __nwlog_obj();
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_http_metadata_set_endpoint";
        _os_log_impl( &dword_181A5C000,  v31,  v46,  "%{public}s metadata must be http, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    __int16 v40 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v41 = type;
    id v42 = os_log_type_enabled(v31, type);
    if (!v40)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_http_metadata_set_endpoint";
        _os_log_impl(&dword_181A5C000, v31, v41, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v53 = "nw_http_metadata_set_endpoint";
      BOOL v54 = 2082;
      *(void *)os_log_type_t v55 = v40;
      _os_log_impl( &dword_181A5C000,  v31,  v41,  "%{public}s metadata must be http, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_59;
  }

  if (!v4)
  {
    __nwlog_obj();
    BOOL v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_http_metadata_set_endpoint";
    id v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v50 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v36 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_http_metadata_set_endpoint";
        _os_log_impl(&dword_181A5C000, v31, v36, "%{public}s called with null endpoint", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (!v50)
    {
      __nwlog_obj();
      uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_http_metadata_set_endpoint";
        _os_log_impl( &dword_181A5C000,  v31,  v47,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_78;
    }

    __int16 v40 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v43 = type;
    id v44 = os_log_type_enabled(v31, type);
    if (!v40)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_http_metadata_set_endpoint";
        _os_log_impl(&dword_181A5C000, v31, v43, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }

      goto LABEL_78;
    }

    if (v44)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v53 = "nw_http_metadata_set_endpoint";
      BOOL v54 = 2082;
      *(void *)os_log_type_t v55 = v40;
      _os_log_impl( &dword_181A5C000,  v31,  v43,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
    }

      free(backtrace_string);
      goto LABEL_100;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http_messaging_add_input_handler";
    id v37 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v48)
      {
        id v38 = (os_log_s *)__nwlog_obj();
        char v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_http_messaging_add_input_handler";
        __int16 v40 = "%{public}s called with null parameters, backtrace limit exceeded";
        goto LABEL_99;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v38 = (os_log_s *)__nwlog_obj();
      char v39 = type;
      v46 = os_log_type_enabled(v38, type);
      if (!backtrace_string)
      {
        if (!v46) {
          goto LABEL_100;
        }
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_http_messaging_add_input_handler";
        __int16 v40 = "%{public}s called with null parameters, no backtrace";
        goto LABEL_99;
      }

      if (!v46) {
        goto LABEL_78;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_http_messaging_add_input_handler";
      os_log_type_t v52 = 2082;
      os_log_type_t v53 = (nw_protocol *)backtrace_string;
      __int16 v43 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_77;
    }

    id v38 = (os_log_s *)__nwlog_obj();
    char v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_100;
    }
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http_messaging_add_input_handler";
    __int16 v40 = "%{public}s called with null parameters";
LABEL_99:
    _os_log_impl(&dword_181A5C000, v38, v39, v40, buf, 0xCu);
    goto LABEL_100;
  }

  if (v6 != a2)
  {
    os_log_type_t v8 = (char *)*((void *)handle + 21);
    uint64_t v7 = *((void *)handle + 22);
    if ((unint64_t)v8 >= v7)
    {
      int v22 = (char *)*((void *)handle + 20);
      uint64_t v23 = (v8 - v22) >> 4;
      os_log_type_t v24 = v23 + 1;
      char v25 = v7 - (void)v22;
      if (v25 >> 3 > v24) {
        os_log_type_t v24 = v25 >> 3;
      }
      id v26 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFF0LL;
      id v27 = 0xFFFFFFFFFFFFFFFLL;
      if (!v26) {
        id v27 = v24;
      }
      if (v27 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      id v28 = 16 * v27;
      uint64_t v29 = (char *)operator new(16 * v27);
      char v30 = &v29[16 * v23];
      uint64_t v31 = &v29[v28];
      *(void *)char v30 = a2;
      *((_DWORD *)v30 + 2) = 0;
      os_log_type_t v9 = v30 + 16;
      if (v8 == v22)
      {
        char v32 = &v29[16 * v23];
      }

      else
      {
        do
        {
          char v32 = v30 - 16;
          *((_OWORD *)v30 - 1) = *((_OWORD *)v8 - 1);
          v8 -= 16;
          v30 -= 16;
        }

        while (v8 != v22);
      }

      *((void *)handle + 20) = v32;
      *((void *)handle + 21) = v9;
      *((void *)handle + 22) = v31;
      if (v22) {
        operator delete(v22);
      }
    }

    else
    {
      *(void *)os_log_type_t v8 = a2;
      *((_DWORD *)v8 + 2) = 0;
      os_log_type_t v9 = v8 + 16;
    }

    *((void *)handle + 21) = v9;
    if (a2->output_handler)
    {
LABEL_40:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v35 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_http_messaging_add_input_handler";
        _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_ERROR,  "%{public}s Output handler already exists for protocol being added as input handler",  buf,  0xCu);
      }

      return 1LL;
    }

        free(v16);
        goto LABEL_79;
      }

      id v14 = v4;
      if (v13 != 0xFFFF)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v44 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v129 = "nw_connection_add_activity_on_nw_queue";
          v130 = 2114;
          v131 = v12;
          _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s Activity %{public}@ is already present, not adding to connection array",  buf,  0x16u);
        }

        uint64_t v23 = *(unsigned __int16 *)(*(void *)&v132[8] + 24LL);
        goto LABEL_80;
      }

      v51 = v12;
      os_log_type_t v52 = (v51[17] & 1) == 0;

      if (!v52)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v53 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v129 = "nw_connection_add_activity_on_nw_queue";
          v130 = 2114;
          v131 = v51;
          _os_log_impl( &dword_181A5C000,  v53,  OS_LOG_TYPE_DEBUG,  "%{public}s Activity %{public}@ selected, connection will report activity metrics",  buf,  0x16u);
        }

        *((_BYTE *)v7 + 108) |= 0x20u;
      }

      BOOL v54 = *((void *)v7 + 49);
      if (!v54)
      {
        LOWORD(v65) = 0;
LABEL_73:
        nw_array_append(v54, v51);
        uint64_t v23 = (unsigned __int16)v65;
        goto LABEL_80;
      }

      os_log_type_t v55 = *(void *)(v54 + 24) - *(void *)(v54 + 16);
      if ((unint64_t)v55 <= 0x7FFF0)
      {
        v65 = v55 >> 3;
        goto LABEL_73;
      }

      uint64_t v23 = 0xFFFF;
LABEL_80:

      _Block_object_dispose(v132, 8);
      id v4 = v14;
      __int16 v5 = (void *)&unk_182665000;
      if (v23 != 0xFFFF) {
        goto LABEL_120;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v70 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v71 = *(void *)(a1 + 48);
        *(_DWORD *)v134 = 136446466;
        *(void *)&v134[4] = "nw_connection_add_client_event_internal_block_invoke";
        *(_WORD *)&v134[12] = 2114;
        *(void *)&v134[14] = v71;
        _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot add activity %{public}@, nw_connection_add_activity_on_nw_queue failed",  v134,  0x16u);
      }

      return;
    default:
      LOWORD(v23) = -1;
      goto LABEL_120;
  }

    if (!v45)
    {
LABEL_80:
      int v20 = 0LL;
      goto LABEL_81;
    }

            goto LABEL_79;
          }

          goto LABEL_79;
        }
      }

      else if (v8 != &nw_protocol_ref_counted_handle)
      {
        goto LABEL_24;
      }

      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      if ((v18 & 1) != 0) {
        goto LABEL_79;
      }
      goto LABEL_28;
    }

    if (!v5 || (v10 = v5[3]) == 0 || (BOOL v11 = *(uint64_t (**)(void))(v10 + 152)) == 0LL)
    {
LABEL_54:
      char v39 = v2;
      __int16 v40 = (*((_BYTE *)v39 + 268) & 0x20) == 0;

      if (v40)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v21 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v41 = v39;

          id v42 = v41;
          __int16 v43 = (*((_BYTE *)v39 + 268) & 1) == 0;

          if (v43) {
            id v44 = "";
          }
          else {
            id v44 = "dry-run ";
          }
          id v45 = nw_endpoint_handler_copy_endpoint(v42);
          v46 = nw_endpoint_get_logging_description(v45);
          v47 = v42;
          v48 = v47;
          nw_endpoint_t v49 = v47[30];
          else {
            os_log_type_t v50 = off_189BBBBF0[v49];
          }
          v85 = v50;

          v51 = v48;
          os_log_type_t v52 = v51;
          os_log_type_t v53 = "path";
          switch(v2->mode)
          {
            case 0:
              break;
            case 1:
              os_log_type_t v53 = "resolver";
              break;
            case 2:
              os_log_type_t v53 = nw_endpoint_flow_mode_string(v51[31]);
              break;
            case 3:
              os_log_type_t v53 = "proxy";
              break;
            case 4:
              os_log_type_t v53 = "fallback";
              break;
            case 5:
              os_log_type_t v53 = "transform";
              break;
            default:
              os_log_type_t v53 = "unknown-mode";
              break;
          }

          BOOL v58 = v52;
          os_unfair_lock_lock((os_unfair_lock_t)v58 + 28);
          os_log_type_t v59 = v58[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v58 + 28);

          os_log_type_t v60 = v41->id_str;
          v61 = v59;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
          char v90 = 2082;
          id_str = v60;
          v92 = 2082;
          int v93 = v44;
          uint64_t v94 = 2082;
          v95 = (void *)v46;
          v96 = 2082;
          v97 = v85;
          v98 = 2082;
          v99 = v53;
          v100 = 2114;
          v101 = v61;
          v102 = 2082;
          v103 = "keepalive";
          _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unregister notification for %{public}s failed",  buf,  0x52u);
        }

        goto LABEL_78;
      }

            goto LABEL_79;
          }

          goto LABEL_79;
        }
      }

      else if (v8 != &nw_protocol_ref_counted_handle)
      {
        goto LABEL_24;
      }

      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      if ((v18 & 1) != 0) {
        goto LABEL_79;
      }
      goto LABEL_28;
    }

    if (!v5 || (v10 = v5[3]) == 0 || (BOOL v11 = *(uint64_t (**)(void))(v10 + 152)) == 0LL)
    {
LABEL_54:
      char v39 = v2;
      __int16 v40 = (*((_BYTE *)v39 + 268) & 0x20) == 0;

      if (v40)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v21 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v41 = v39;

          id v42 = v41;
          __int16 v43 = (*((_BYTE *)v39 + 268) & 1) == 0;

          if (v43) {
            id v44 = "";
          }
          else {
            id v44 = "dry-run ";
          }
          id v45 = nw_endpoint_handler_copy_endpoint(v42);
          v46 = nw_endpoint_get_logging_description(v45);
          v47 = v42;
          v48 = v47;
          nw_endpoint_t v49 = v47[30];
          else {
            os_log_type_t v50 = off_189BBBBF0[v49];
          }
          v85 = v50;

          v51 = v48;
          os_log_type_t v52 = v51;
          os_log_type_t v53 = "path";
          switch(v2->mode)
          {
            case 0:
              break;
            case 1:
              os_log_type_t v53 = "resolver";
              break;
            case 2:
              os_log_type_t v53 = nw_endpoint_flow_mode_string(v51[31]);
              break;
            case 3:
              os_log_type_t v53 = "proxy";
              break;
            case 4:
              os_log_type_t v53 = "fallback";
              break;
            case 5:
              os_log_type_t v53 = "transform";
              break;
            default:
              os_log_type_t v53 = "unknown-mode";
              break;
          }

          BOOL v58 = v52;
          os_unfair_lock_lock((os_unfair_lock_t)v58 + 28);
          os_log_type_t v59 = v58[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v58 + 28);

          os_log_type_t v60 = v41->id_str;
          v61 = v59;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
          char v90 = 2082;
          id_str = v60;
          v92 = 2082;
          int v93 = v44;
          uint64_t v94 = 2082;
          v95 = (void *)v46;
          v96 = 2082;
          v97 = v85;
          v98 = 2082;
          v99 = v53;
          v100 = 2114;
          v101 = v61;
          v102 = 2082;
          v103 = "metadata_changed";
          _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unregister notification for %{public}s failed",  buf,  0x52u);
        }

        goto LABEL_78;
      }

    if (!v6) {
      return 0LL;
    }
LABEL_79:
    free((void *)v6);
    return 0LL;
  }

  os_log_type_t v12 = HIDWORD(v58);
  if (HIDWORD(v58) >= 0x10E9)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v61 = "nw_network_agent_ctl_copy_received_agent_message";
    os_log_type_t v62 = 1024;
    *(_DWORD *)char v63 = v12;
    *(_WORD *)&v63[4] = 1024;
    *(_DWORD *)&v63[6] = 4328;
    int v6 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = gLogObj;
      id v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)buf = 136446722;
      v61 = "nw_network_agent_ctl_copy_received_agent_message";
      os_log_type_t v62 = 1024;
      *(_DWORD *)char v63 = v12;
      *(_WORD *)&v63[4] = 1024;
      *(_DWORD *)&v63[6] = 4328;
      os_log_type_t v9 = "%{public}s kernel returned invalid message payload length %u > %u";
LABEL_76:
      id v38 = (os_log_s *)v13;
      char v39 = v14;
      __int16 v40 = 24;
      goto LABEL_77;
    }

    if (!v56)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = gLogObj;
      id v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_78;
      }
      *(_DWORD *)buf = 136446722;
      v61 = "nw_network_agent_ctl_copy_received_agent_message";
      os_log_type_t v62 = 1024;
      *(_DWORD *)char v63 = v12;
      *(_WORD *)&v63[4] = 1024;
      *(_DWORD *)&v63[6] = 4328;
      os_log_type_t v9 = "%{public}s kernel returned invalid message payload length %u > %u, backtrace limit exceeded";
      goto LABEL_76;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v13 = gLogObj;
    id v14 = type;
    uint64_t v31 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v31) {
        goto LABEL_78;
      }
      *(_DWORD *)buf = 136446722;
      v61 = "nw_network_agent_ctl_copy_received_agent_message";
      os_log_type_t v62 = 1024;
      *(_DWORD *)char v63 = v12;
      *(_WORD *)&v63[4] = 1024;
      *(_DWORD *)&v63[6] = 4328;
      os_log_type_t v9 = "%{public}s kernel returned invalid message payload length %u > %u, no backtrace";
      goto LABEL_76;
    }

    if (!v31) {
      goto LABEL_64;
    }
    *(_DWORD *)buf = 136446978;
    v61 = "nw_network_agent_ctl_copy_received_agent_message";
    os_log_type_t v62 = 1024;
    *(_DWORD *)char v63 = v12;
    *(_WORD *)&v63[4] = 1024;
    *(_DWORD *)&v63[6] = 4328;
    *(_WORD *)&v63[10] = 2082;
    *(void *)&v63[12] = backtrace_string;
    char v32 = "%{public}s kernel returned invalid message payload length %u > %u, dumping backtrace:%{public}s";
    id v33 = (os_log_s *)v13;
    __int16 v34 = v14;
    BOOL v35 = 34;
LABEL_63:
    _os_log_impl(&dword_181A5C000, v33, v34, v32, buf, v35);
    goto LABEL_64;
  }

  __int16 v21 = HIDWORD(v58) + 16LL;
  int v6 = nw_calloc_type<unsigned char>(v21);
  int v22 = recv(a1, (void *)v6, v12 + 16, 0);
  if (v22 < v21)
  {
    uint64_t v23 = v22;
    if ((v22 & 0x8000000000000000LL) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446722;
      v61 = "nw_network_agent_ctl_copy_received_agent_message";
      os_log_type_t v62 = 2048;
      *(void *)char v63 = v23;
      *(_WORD *)&v63[8] = 2048;
      *(void *)&v63[10] = v21;
      os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v56 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v25 = (os_log_s *)gLogObj;
        id v26 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_104;
        }
        *(_DWORD *)buf = 136446722;
        v61 = "nw_network_agent_ctl_copy_received_agent_message";
        os_log_type_t v62 = 2048;
        *(void *)char v63 = v23;
        *(_WORD *)&v63[8] = 2048;
        *(void *)&v63[10] = v21;
        id v27 = "%{public}s Not enough bytes available to read network agent message (%zd < %zd)";
LABEL_97:
        os_log_type_t v50 = v25;
        v51 = v26;
        os_log_type_t v52 = 32;
LABEL_103:
        _os_log_impl(&dword_181A5C000, v50, v51, v27, buf, v52);
        goto LABEL_104;
      }

      if (!v56)
      {
        char v25 = (os_log_s *)__nwlog_obj();
        id v26 = type;
        if (!os_log_type_enabled(v25, type)) {
          goto LABEL_104;
        }
        *(_DWORD *)buf = 136446722;
        v61 = "nw_network_agent_ctl_copy_received_agent_message";
        os_log_type_t v62 = 2048;
        *(void *)char v63 = v23;
        *(_WORD *)&v63[8] = 2048;
        *(void *)&v63[10] = v21;
        id v27 = "%{public}s Not enough bytes available to read network agent message (%zd < %zd), backtrace limit exceeded";
        goto LABEL_97;
      }

      id v45 = (char *)__nw_create_backtrace_string();
      char v25 = (os_log_s *)__nwlog_obj();
      id v26 = type;
      v46 = os_log_type_enabled(v25, type);
      if (!v45)
      {
        if (!v46) {
          goto LABEL_104;
        }
        *(_DWORD *)buf = 136446722;
        v61 = "nw_network_agent_ctl_copy_received_agent_message";
        os_log_type_t v62 = 2048;
        *(void *)char v63 = v23;
        *(_WORD *)&v63[8] = 2048;
        *(void *)&v63[10] = v21;
        id v27 = "%{public}s Not enough bytes available to read network agent message (%zd < %zd), no backtrace";
        goto LABEL_97;
      }

      if (v46)
      {
        *(_DWORD *)buf = 136446978;
        v61 = "nw_network_agent_ctl_copy_received_agent_message";
        os_log_type_t v62 = 2048;
        *(void *)char v63 = v23;
        *(_WORD *)&v63[8] = 2048;
        *(void *)&v63[10] = v21;
        *(_WORD *)&v63[18] = 2082;
        *(void *)&v63[20] = v45;
        _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Not enough bytes available to read network agent message (%zd < %zd), dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v45);
LABEL_104:
      if (!v24) {
        goto LABEL_106;
      }
      goto LABEL_105;
    }

    os_log_type_t v41 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v61 = "nw_network_agent_ctl_copy_received_agent_message";
    os_log_type_t v62 = 2048;
    *(void *)char v63 = v12 + 16;
    *(_WORD *)&v63[8] = 1024;
    *(_DWORD *)&v63[10] = v41;
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v56 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v42 = (os_log_s *)__nwlog_obj();
      __int16 v43 = type;
      if (!os_log_type_enabled(v42, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)buf = 136446722;
      v61 = "nw_network_agent_ctl_copy_received_agent_message";
      os_log_type_t v62 = 2048;
      *(void *)char v63 = v21;
      *(_WORD *)&v63[8] = 1024;
      *(_DWORD *)&v63[10] = v41;
      id v27 = "%{public}s Received read error when reading network agent message (%zd bytes) %{darwin.errno}d";
    }

    else if (v56)
    {
      v48 = (char *)__nw_create_backtrace_string();
      id v42 = (os_log_s *)__nwlog_obj();
      __int16 v43 = type;
      nw_endpoint_t v49 = os_log_type_enabled(v42, type);
      if (v48)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446978;
          v61 = "nw_network_agent_ctl_copy_received_agent_message";
          os_log_type_t v62 = 2048;
          *(void *)char v63 = v21;
          *(_WORD *)&v63[8] = 1024;
          *(_DWORD *)&v63[10] = v41;
          *(_WORD *)&v63[14] = 2082;
          *(void *)&v63[16] = v48;
          _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s Received read error when reading network agent message (%zd bytes) %{darwin.errno}d, dumping back trace:%{public}s",  buf,  0x26u);
        }

        free(v48);
        if (!v24)
        {
LABEL_106:
          if (!v6) {
            return v6;
          }
          goto LABEL_79;
        }

  if (v22) {
    free(v22);
  }
  int v16 = 0LL;
LABEL_21:

  return v16;
}

LABEL_114:
        free(v58);
        goto LABEL_115;
      }

      if (v72)
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl( &dword_181A5C000,  v59,  v71,  "%{public}s called with null report_callback, no backtrace",  address,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v59 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v79 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl( &dword_181A5C000,  v59,  v79,  "%{public}s called with null report_callback, backtrace limit exceeded",  address,  0xCu);
      }
    }

      if (v59) {
        free(v59);
      }
    }
  }
}
      }
    }

    BOOL v67 = v3[4];
    os_log_type_t v68 = (void *)v3[5];
    if (v67)
    {
      *(void *)(v67 + 40) = v68;
      os_log_type_t v68 = (void *)v3[5];
    }

    else
    {
      *(void *)(a1[4] + 576LL) = v68;
    }

    *os_log_type_t v68 = v67;
    v3[4] = 0LL;
    v3[5] = 0LL;
    nw_frame_finalize((uint64_t)v3);
    BOOL v81 = HIDWORD(size);
    *(_DWORD *)(a1[4] + 600LL) += HIDWORD(size);
    *(void *)(*(void *)(a1[5] + 8LL) + 24LL) -= v81;
    if (!gLogDatapath) {
      goto LABEL_55;
    }
    __nwlog_obj();
    os_log_type_t v64 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_95;
    }
    v65 = a1[4];
    os_log_type_t v66 = (const char *)(v65 + 609);
    if (!v65) {
      os_log_type_t v66 = "";
    }
    goto LABEL_94;
  }

  os_log_type_t v8 = dispatch_data_create(v7, *(void *)(*(void *)(a1[5] + 8LL) + 24LL), 0LL, 0LL);
  os_log_type_t v9 = *(void *)(a1[6] + 8LL);
  os_log_type_t v12 = *(dispatch_data_s **)(v9 + 40);
  os_log_type_t v10 = (id *)(v9 + 40);
  BOOL v11 = v12;
  if (v12)
  {
    id v13 = dispatch_data_create_concat(v11, v8);
    id v14 = *(void *)(a1[6] + 8LL);
    id v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = v13;

    if (!gLogDatapath) {
      goto LABEL_38;
    }
    __nwlog_obj();
    __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_107;
    }
    id v18 = a1[4];
    if (v18) {
      id v19 = (const char *)(v18 + 609);
    }
    else {
      id v19 = "";
    }
    int v20 = dispatch_data_get_size(*(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL));
    __int16 v21 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
    int v22 = *(_DWORD *)(v18 + 600);
    *(_DWORD *)buf = 136447234;
    v132 = "nw_framer_write_output_no_copy_block_invoke";
    v133 = 2080;
    v134 = v19;
    v135 = 2048;
    *(void *)v136 = v20;
    *(_WORD *)&v136[8] = 2048;
    *(void *)&v136[10] = v21;
    *(_WORD *)&v136[18] = 1024;
    v137 = v22;
    uint64_t v23 = "%{public}s %s Appending message data to output data, now %zu bytes, %zu bytes from offset %u";
    goto LABEL_106;
  }

  objc_storeStrong(v10, v8);
  if (!gLogDatapath) {
    goto LABEL_38;
  }
  __nwlog_obj();
  __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    v111 = a1[4];
    if (v111) {
      v112 = (const char *)(v111 + 609);
    }
    else {
      v112 = "";
    }
    v113 = dispatch_data_get_size(*(dispatch_data_t *)(*(void *)(a1[6] + 8LL) + 40LL));
    v114 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
    v115 = *(_DWORD *)(v111 + 600);
    *(_DWORD *)buf = 136447234;
    v132 = "nw_framer_write_output_no_copy_block_invoke";
    v133 = 2080;
    v134 = v112;
    v135 = 2048;
    *(void *)v136 = v113;
    *(_WORD *)&v136[8] = 2048;
    *(void *)&v136[10] = v114;
    *(_WORD *)&v136[18] = 1024;
    v137 = v115;
    uint64_t v23 = "%{public}s %s Setting message data to output data, now %zu bytes, %zu bytes from offset %u";
LABEL_106:
    _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_DEBUG, v23, buf, 0x30u);
  }

    if (v53) {
      free(v53);
    }
    goto LABEL_7;
  }

  __nwlog_obj();
  id v42 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)aBlock = 136446210;
  *(void *)&aBlock[4] = "nw_connection_group_handle_listener_state_change";
  __int16 v43 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  LOBYTE(v62) = 0;
  if (__nwlog_fault(v43, buf, &v62))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      id v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v45 = buf[0];
      if (os_log_type_enabled(v44, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_connection_group_handle_listener_state_change";
        _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s called with null group", aBlock, 0xCu);
      }
    }

    else if ((_BYTE)v62)
    {
      v46 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v47 = buf[0];
      v48 = os_log_type_enabled(v44, (os_log_type_t)buf[0]);
      if (v46)
      {
        if (v48)
        {
          *(_DWORD *)aBlock = 136446466;
          *(void *)&aBlock[4] = "nw_connection_group_handle_listener_state_change";
          *(_WORD *)&aBlock[12] = 2082;
          *(void *)&aBlock[14] = v46;
          _os_log_impl( &dword_181A5C000,  v44,  v47,  "%{public}s called with null group, dumping backtrace:%{public}s",  aBlock,  0x16u);
        }

        free(v46);
        goto LABEL_101;
      }

      if (v48)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_connection_group_handle_listener_state_change";
        _os_log_impl(&dword_181A5C000, v44, v47, "%{public}s called with null group, no backtrace", aBlock, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v51 = buf[0];
      if (os_log_type_enabled(v44, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_connection_group_handle_listener_state_change";
        _os_log_impl( &dword_181A5C000,  v44,  v51,  "%{public}s called with null group, backtrace limit exceeded",  aBlock,  0xCu);
      }
    }
  }

      os_log_type_t v52 = *(_BYTE *)(a2 + 40);
      if ((v52 & 1) != 0)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)(a2 + 32));
        os_log_type_t v52 = *(_BYTE *)(a2 + 40);
      }

      *(void *)(a2 + 32) = 0LL;
      *(_BYTE *)(a2 + 40) = v52 | 1;
LABEL_117:
      os_log_type_t v53 = *(void **)(a2 + 24);
      if (v53)
      {
        nw_path_flow_registration_close(v53);
        BOOL v54 = *(void **)(a2 + 24);
        *(void *)(a2 + 24) = 0LL;
      }

      os_log_type_t v55 = *(void **)(a2 + 48);
      *(void *)(a2 + 48) = 0LL;

      *(void *)(a2 + 56) = 0LL;
      v56 = *(void **)(a2 + 120);
      *(void *)(a2 + 120) = 0LL;

      os_log_type_t v57 = *(void **)(a2 + 88);
      *(void *)(a2 + 88) = 0LL;

      goto LABEL_120;
    }

    if (!v25) {
      goto LABEL_23;
    }
LABEL_115:
    free(v25);
    goto LABEL_23;
  }

  v18(v10, v5 - 12, a2, v8, size);
LABEL_23:
  if (v14 == &nw_protocol_ref_counted_handle)
  {
    nw::release_if_needed<nw_protocol *>((uint64_t *)&v60);
    if (v11 != &nw_protocol_ref_counted_handle) {
      goto LABEL_28;
    }
  }

  else if (v11 != &nw_protocol_ref_counted_handle)
  {
    goto LABEL_28;
  }

  nw::release_if_needed<nw_protocol *>((uint64_t *)v64);
LABEL_28:
  if (v8) {
    free(v8);
  }
}

          goto LABEL_115;
        }

        if (!(_BYTE)v104)
        {
          __nwlog_obj();
          os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          id v45 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v45,  "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        id v38 = __nw_create_backtrace_string();
        if (!v38)
        {
          __nwlog_obj();
          os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v50 = type[0];
          if (os_log_type_enabled(v12, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "nw_protocol_implementation_input_finished";
            _os_log_impl( &dword_181A5C000,  v12,  v50,  "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, no backtrace",  buf,  0xCu);
          }

          goto LABEL_114;
        }

        uint64_t v31 = (char *)v38;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v32 = (os_log_s *)(id)gLogObj;
        char v39 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v109 = "nw_protocol_implementation_input_finished";
          v110 = 2082;
          v111 = v31;
          _os_log_impl( &dword_181A5C000,  v32,  v39,  "%{public}s Cannot defer stop of NW_PROTOCOL_ALL_FLOWS, dumping backtrace:%{public}s",  buf,  0x16u);
        }

  if (v24) {
    free(v24);
  }
  return 0LL;
}

  if (v24) {
    free(v24);
  }
  return 0LL;
}

  if (v25) {
    free(v25);
  }
  return 0LL;
}

    if (v31) {
      free(v31);
    }
    int v16 = 0LL;
    goto LABEL_12;
  }

  nw_protocol_stack_prepend_application_protocol(v14, (nw_protocol_options_t)options);
  int v16 = secure_http_messaging;
LABEL_12:

LABEL_13:
  return v16;
}
}

  if (v43) {
    free(v43);
  }
  id v19 = 4;
LABEL_30:
  int v20 = handle + 527;
  *(_DWORD *)(handle + 527) = *(_DWORD *)(handle + 527) & 0xFFFFFFFB | v19;
  __int16 v21 = (void *)*((void *)handle + 40);
  if (nw_protocol_http_messaging_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_76181);
  }
  if (nw_parameters_has_protocol_in_stack(v21, nw_protocol_http_messaging_identifier::protocol_identifier)) {
    int v22 = 0x1000000;
  }
  else {
    int v22 = 0;
  }
  *(_DWORD *)int v20 = *(_DWORD *)v20 & 0xFEFFFFFF | v22;
  if (nw_masque_options_get_forced_protocol(*((nw_protocol_options **)handle + 43)) == 1)
  {
    *(_DWORD *)v20 &= ~8u;
    goto LABEL_145;
  }

  if (a2)
  {
    uint64_t v31 = (void *)*((void *)handle + 43);
    if (v31)
    {
      if (nw_protocol_options_access_handle(v31, &__block_literal_global_49))
      {
        identifier = a2->identifier;
        if (nw_protocol_ip_identifier::onceToken[0] != -1) {
          dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
        }
        if (nw_protocols_are_equal(identifier, &nw_protocol_ip_identifier::identifier))
        {
          *(_DWORD *)v20 |= 0x20u;
          id v33 = nw_parameters_copy_default_protocol_stack(*((nw_parameters_t *)handle + 40));
          if (!v33) {
            goto LABEL_145;
          }
          __int16 v34 = v33;
          BOOL v35 = (nw_protocol_options *)nw_protocol_stack_copy_original_proxied_transport_protocol(v33);
          if (!v35) {
            goto LABEL_144;
          }
          uint64_t v36 = v35;
          if (nw_protocol_options_is_custom_ip(v35)) {
            handle[526] = nw_custom_ip_options_get_protocol(v36);
          }
          goto LABEL_143;
        }
      }

      goto LABEL_130;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_masque_options_get_allow_connect_ip";
    nw_endpoint_t v49 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v111) = 0;
    if (__nwlog_fault(v49, type, &v111))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v50 = (os_log_s *)__nwlog_obj();
        v51 = type[0];
        if (os_log_type_enabled(v50, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_options_get_allow_connect_ip";
          os_log_type_t v52 = "%{public}s called with null options";
LABEL_126:
          _os_log_impl(&dword_181A5C000, v50, v51, v52, buf, 0xCu);
        }
      }

      else if ((_BYTE)v111)
      {
        os_log_type_t v53 = (char *)__nw_create_backtrace_string();
        os_log_type_t v50 = (os_log_s *)__nwlog_obj();
        v51 = type[0];
        BOOL v54 = os_log_type_enabled(v50, type[0]);
        if (v53)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_masque_options_get_allow_connect_ip";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v53;
            _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v53);
          goto LABEL_127;
        }

        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_options_get_allow_connect_ip";
          os_log_type_t v52 = "%{public}s called with null options, no backtrace";
          goto LABEL_126;
        }
      }

      else
      {
        os_log_type_t v50 = (os_log_s *)__nwlog_obj();
        v51 = type[0];
        if (os_log_type_enabled(v50, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_masque_options_get_allow_connect_ip";
          os_log_type_t v52 = "%{public}s called with null options, backtrace limit exceeded";
          goto LABEL_126;
        }
      }
    }

        if (v69) {
          free(v69);
        }
        id v37 = 0;
        goto LABEL_13;
      }

      if (strstr((const char *)[v24 UTF8String], "tc=video"))
      {
        os_log_type_t v66 = 700;
      }

      else if (strstr((const char *)[v24 UTF8String], "tc=voice"))
      {
        os_log_type_t v66 = 800;
      }

      else if (strstr((const char *)[v24 UTF8String], "tc=oam"))
      {
        os_log_type_t v66 = 400;
      }

      else if (strstr((const char *)[v24 UTF8String], "tc=best-effort"))
      {
        os_log_type_t v66 = 0;
      }

      else if (strstr((const char *)[v24 UTF8String], "tc=background-user"))
      {
        os_log_type_t v66 = 200;
      }

      else if (strstr((const char *)[v24 UTF8String], "tc=background-system"))
      {
        os_log_type_t v66 = 100;
      }

      else if (strstr((const char *)[v24 UTF8String], "tc=responsive-data"))
      {
        os_log_type_t v66 = 300;
      }

      else if (strstr((const char *)[v24 UTF8String], "tc=responsive-av"))
      {
        os_log_type_t v66 = 600;
      }

      else if (strstr((const char *)[v24 UTF8String], "tc=av-streaming"))
      {
        os_log_type_t v66 = 500;
      }

      else
      {
        if (!strstr((const char *)[v24 UTF8String], "tc=network-control"))
        {
LABEL_89:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v74 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
          {
            v75 = v22[63];
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_priority_header";
            *(_WORD *)&buf[12] = 2112;
            *(void *)&buf[14] = v23;
            *(_WORD *)&buf[22] = 2112;
            v97 = v24;
            LOWORD(v98) = 1024;
            *(_DWORD *)((char *)&v98 + 2) = v75;
            _os_log_impl(&dword_181A5C000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %@ : %@  traffic class:%u", buf, 0x26u);
          }

          goto LABEL_59;
        }

        os_log_type_t v66 = 900;
      }

      v22[63] = v66;
      goto LABEL_89;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v64 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_client_application_header";
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v19;
      *(_WORD *)&buf[22] = 2112;
      v97 = v20;
      _os_log_impl(&dword_181A5C000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %@ : %@", buf, 0x20u);
    }

    v65 = (void *)v18[34];
    v18[34] = v20;
  }

  else
  {
    v85 = v14;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v57 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_multipath_header";
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v15;
      *(_WORD *)&buf[22] = 2112;
      v97 = v16;
      _os_log_impl(&dword_181A5C000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %@ : %@", buf, 0x20u);
    }

    [v16 componentsSeparatedByString:@"port="];
    BOOL v58 = (void *)objc_claimAutoreleasedReturnValue();
    if ((unint64_t)[v58 count] >= 2)
    {
      [v58 objectAtIndex:1];
      os_log_type_t v59 = (void *)objc_claimAutoreleasedReturnValue();
      [v59 componentsSeparatedByString:@","];
      os_log_type_t v60 = (void *)objc_claimAutoreleasedReturnValue();

      [v60 objectAtIndex:0];
      v61 = (void *)objc_claimAutoreleasedReturnValue();
      *((_WORD *)v85 + 132) = [v61 integerValue];

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v62 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
      {
        char v63 = *((unsigned __int16 *)v85 + 132);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_masque_connection_pair_handle_multipath_header";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v63;
        _os_log_impl(&dword_181A5C000, v62, OS_LOG_TYPE_DEBUG, "%{public}s port: %u", buf, 0x12u);
      }
    }
  }

    if (v66) {
      free(v66);
    }
    goto LABEL_116;
  }

  do
    os_log_type_t v9 = __ldaxr(&s_last_server_id);
  while (__stlxr(v9 + 1, &s_last_server_id));
  v7[1] = v9;
  *((_DWORD *)v7 + 6) = 0;
  strcpy(label, "com.apple.networking.nw_socks5_server");
  dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  os_log_type_t v10 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
  BOOL v11 = dispatch_queue_create(label, v10);
  os_log_type_t v12 = (void *)*((void *)v8 + 4);
  *((void *)v8 + 4) = v11;

  if (*((void *)v8 + 4))
  {
    id v13 = nw_parameters_create();
    id v14 = v13;
    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v42 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
      __int16 v43 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v73 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v44 = (os_log_s *)(id)gLogObj;
        id v45 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
          _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s nw_parameters_create failed", buf, 0xCu);
        }

        goto LABEL_91;
      }

      if (!v73)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v44 = (os_log_s *)(id)gLogObj;
        v61 = type;
        if (os_log_type_enabled(v44, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
          _os_log_impl( &dword_181A5C000,  v44,  v61,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_91;
      }

      nw_endpoint_t v49 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v44 = (os_log_s *)(id)gLogObj;
      os_log_type_t v50 = type;
      v51 = os_log_type_enabled(v44, type);
      if (!v49)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
          _os_log_impl(&dword_181A5C000, v44, v50, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
        }

        goto LABEL_91;
      }

      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
        os_log_type_t v78 = 2082;
        os_log_type_t v79 = v49;
        _os_log_impl( &dword_181A5C000,  v44,  v50,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_66;
    }

    nw_parameters_set_data_mode(v13, 2u);
    nw_parameters_set_tfo(v14, 1);
    nw_parameters_set_fast_open_force_enable(v14, 1);
    if (v5)
    {
      id v15 = v5;
      int v16 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v15,  0,  0);

      __int16 v17 = (void *)*((void *)v8 + 5);
      *((void *)v8 + 5) = v16;

      if (!*((void *)v8 + 5))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v54 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
        __int16 v43 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v73 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v44 = (os_log_s *)(id)gLogObj;
          os_log_type_t v55 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
            _os_log_impl(&dword_181A5C000, v44, v55, "%{public}s nw_parameters_copy failed", buf, 0xCu);
          }

          goto LABEL_91;
        }

        if (!v73)
        {
          __nwlog_obj();
          id v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          char v63 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
            _os_log_impl( &dword_181A5C000,  v44,  v63,  "%{public}s nw_parameters_copy failed, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_91;
        }

        nw_endpoint_t v49 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v44 = (os_log_s *)(id)gLogObj;
        os_log_type_t v59 = type;
        os_log_type_t v60 = os_log_type_enabled(v44, type);
        if (!v49)
        {
          if (v60)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
            _os_log_impl(&dword_181A5C000, v44, v59, "%{public}s nw_parameters_copy failed, no backtrace", buf, 0xCu);
          }

          goto LABEL_91;
        }

        if (v60)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
          os_log_type_t v78 = 2082;
          os_log_type_t v79 = v49;
          _os_log_impl( &dword_181A5C000,  v44,  v59,  "%{public}s nw_parameters_copy failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_66;
      }

      id v18 = v15;
      id v19 = (nw_endpoint *)*(id *)(v18[13] + 160LL);

      if (v19) {
        nw_parameters_set_local_endpoint(v14, v19);
      }
      int v20 = v18;
      __int16 v21 = (nw_interface *)*(id *)(v18[13] + 168LL);

      if (v21) {
        nw_parameters_require_interface(v14, v21);
      }
      int v22 = v20;
      uint64_t v23 = *(_DWORD *)(v18[13] + 80LL);

      if (v23)
      {
        os_log_type_t v24 = v14;
        char v25 = *((void *)v24 + 13);
        id v26 = 96LL;
        if ((*(_WORD *)(v25 + 100) & 0x100) == 0) {
          id v26 = 80LL;
        }
        *(_DWORD *)(v25 + v26) = v23;
      }

      id v27 = v22;
      id v28 = (v27[12] & 0x8000000LL) == 0;

      if (!v28)
      {
        uint64_t v29 = v14;
        *((void *)v29 + 12) |= 0x8000000uLL;
      }

      char v30 = v27;
      uint64_t v31 = (*(_WORD *)(v18[13] + 108LL) & 8) == 0;

      if (!v31)
      {
        char v32 = v14;
        *(_WORD *)(*((void *)v32 + 13) + 108LL) |= 8u;
      }
    }

    id v33 = nw_listener_create(v14);
    __int16 v34 = (void *)*((void *)v8 + 9);
    *((void *)v8 + 9) = v33;

    if (*((void *)v8 + 9))
    {
      objc_storeStrong((id *)v8 + 6, a3);
      BOOL v35 = nw_array_create();
      uint64_t v36 = (void *)*((void *)v8 + 10);
      *((void *)v8 + 10) = v35;

      id v37 = v8;
LABEL_95:

      goto LABEL_96;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v52 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v77 = "-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]";
    __int16 v43 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v73 = 0;
    if (!__nwlog_fault(v43, &type, &v73))
    {
LABEL_92:
      if (!v43)
      {
LABEL_94:
        id v37 = 0LL;
        goto LABEL_95;
      }

            v85 = *(unsigned int *)(v67 + 336) + 1LL;
            id v86 = v85 << 31 >> 31;
            *(_DWORD *)(v67 + 336) = v85;
            v87 = v579;
            if (v86 == v85 && (v86 & 0x8000000000000000LL) == 0) {
              goto LABEL_266;
            }
            id v88 = v67;
            __nwlog_obj();
            v89 = *(unsigned int *)(v88 + 336);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http1->connections_count";
            *(_WORD *)&buf[22] = 2048;
            v608 = 1LL;
            *(_WORD *)v609 = 2048;
            *(void *)&v609[2] = v89;
            char v90 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(aBlock) = 0;
            if (__nwlog_fault(v90, type, &aBlock))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                v91 = (os_log_s *)__nwlog_obj();
                v92 = type[0];
                if (os_log_type_enabled(v91, type[0]))
                {
                  int v93 = *(unsigned int *)(v580 + 336);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http1->connections_count";
                  *(_WORD *)&buf[22] = 2048;
                  v608 = 1LL;
                  *(_WORD *)v609 = 2048;
                  *(void *)&v609[2] = v93;
                  uint64_t v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_262:
                  _os_log_impl(&dword_181A5C000, v91, v92, v94, buf, 0x2Au);
                }
              }

              else if ((_BYTE)aBlock)
              {
                v120 = v38;
                v121 = (char *)__nw_create_backtrace_string();
                v91 = (os_log_s *)__nwlog_obj();
                v92 = type[0];
                v122 = os_log_type_enabled(v91, type[0]);
                if (v121)
                {
                  if (v122)
                  {
                    v123 = *(unsigned int *)(v580 + 336);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = "http1->connections_count";
                    *(_WORD *)&buf[22] = 2048;
                    v608 = 1LL;
                    *(_WORD *)v609 = 2048;
                    *(void *)&v609[2] = v123;
                    *(_WORD *)&v609[10] = 2082;
                    *(void *)&v609[12] = v121;
                    _os_log_impl( &dword_181A5C000,  v91,  v92,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                  }

                  free(v121);
                  id v38 = v120;
                  goto LABEL_263;
                }

                id v38 = v120;
                if (v122)
                {
                  v189 = *(unsigned int *)(v580 + 336);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http1->connections_count";
                  *(_WORD *)&buf[22] = 2048;
                  v608 = 1LL;
                  *(_WORD *)v609 = 2048;
                  *(void *)&v609[2] = v189;
                  uint64_t v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                  goto LABEL_262;
                }
              }

              else
              {
                v91 = (os_log_s *)__nwlog_obj();
                v92 = type[0];
                if (os_log_type_enabled(v91, type[0]))
                {
                  v179 = *(unsigned int *)(v580 + 336);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http1_add_connection_for_output_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http1->connections_count";
                  *(_WORD *)&buf[22] = 2048;
                  v608 = 1LL;
                  *(_WORD *)v609 = 2048;
                  *(void *)&v609[2] = v179;
                  uint64_t v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_262;
                }
              }
            }

            v74 = *(_DWORD *)(a1 + 20);
            if (v74)
            {
              v75 = 2 * v74;
              os_log_type_t v76 = ((int)v16 + *(_DWORD *)(a2 + 68) + 1) % v75;
              v74 = (v75 - v76 + *(_DWORD *)(a1 + 32)) % v75;
              os_log_type_t v77 = *(_DWORD *)(a1 + 56);
              if (!v77) {
                goto LABEL_227;
              }
            }

            else
            {
              os_log_type_t v76 = 0;
              os_log_type_t v77 = *(_DWORD *)(a1 + 56);
              if (!v77)
              {
LABEL_227:
                v161 = 3792;
                goto LABEL_348;
              }
            }

            os_log_type_t v78 = *(_DWORD *)(a1 + 60);
            os_log_type_t v79 = *(_DWORD *)(a1 + 64);
            os_log_type_t v57 = v78 >= v79;
            v80 = v78 - v79;
            if (v57) {
              BOOL v81 = 0;
            }
            else {
              BOOL v81 = v77;
            }
            if (v80 + v81 <= v74) {
              goto LABEL_227;
            }
            os_log_type_t v82 = *(unsigned int **)(*(void *)(a1 + 72) + 8LL * ((v77 + ~v74 + v78) % v77));
            if (!v82) {
              goto LABEL_227;
            }
            os_log_type_t v83 = *(_DWORD *)(a2 + 104);
            if ((v83 & 2) != 0) {
              id v84 = v83 | (32 * (*(_DWORD *)(a2 + 64) == v76));
            }
            else {
              id v84 = v83 | 0x40;
            }
            *(_DWORD *)(a2 + 104) = v84;
            if (header_out_begin_dynamic_nameref( (unsigned int *)a1,  (void *)a2,  v82,  *(_DWORD *)(a2 + 148)))
            {
              v161 = 3796;
              goto LABEL_348;
            }

  __break(1u);
  return result;
}

                  if (v47) {
                    free(v47);
                  }
                  if ((v23 & 1) != 0) {
                    goto LABEL_17;
                  }
                  goto LABEL_13;
                }

                v48 = (os_log_s *)__nwlog_obj();
                nw_endpoint_t v49 = type;
                if (!os_log_type_enabled(v48, type)) {
                  goto LABEL_114;
                }
                os_log_type_t v57 = "invalid";
                if (v6 && *(void *)(v6 + 16)) {
                  os_log_type_t v57 = *(const char **)(v6 + 16);
                }
                *(_DWORD *)buf = 136446466;
                os_log_type_t v64 = "nw_protocol_http3_stream_start_datagram_flow";
                v65 = 2082;
                os_log_type_t v66 = (void *)v57;
                v51 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
              }

              _os_log_impl(&dword_181A5C000, v48, v49, v51, buf, 0x16u);
              goto LABEL_114;
            }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (NWConcrete_nw_endpoint_mode_handler *)(id)gLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5) {
      v74 = "unknown-mode";
    }
    else {
      v74 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_connected";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v74;
    *(_WORD *)&buf[22] = 2082;
    v95 = "flow";
    _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

LABEL_112:
    goto LABEL_113;
  }

  id v15 = v13;
  int v16 = [v15 type];

  if (v16 == 1)
  {
    __int16 v17 = v14;
    id v18 = *(id *)(v17[13] + 160LL);

    if (v18)
    {
      id v19 = v18;
      int v20 = [v19 type];

      if (v20 == 1)
      {
        int address_family = nw_endpoint_get_address_family(v15);
        int v22 = nw_endpoint_get_address_family(v19);
        uint64_t v23 = nw_endpoint_get_address((nw_endpoint_t)v19);
        if (address_family != v22)
        {
          if (v23)
          {
            if (v22 == 30)
            {
              if (!*(_DWORD *)&v23->sa_data[6]
                && !*(_DWORD *)&v23->sa_data[10]
                && !*(_DWORD *)&v23[1].sa_len
                && !*(_DWORD *)&v23[1].sa_data[2])
              {
                *(_WORD *)address = 528;
                *(_WORD *)&address[2] = *(_WORD *)v23->sa_data;
                *(_DWORD *)&address[12] = 0;
                *(void *)&address[4] = 0LL;
                char v25 = nw_endpoint_create_address((const sockaddr *)address);
                nw_parameters_set_local_endpoint((nw_parameters_t)v17, v25);
              }
            }

            else if (v22 == 2 && !*(_DWORD *)&v23->sa_data[2])
            {
              int v93 = 0;
              *(void *)&address[8] = 0LL;
              *(void *)&address[16] = 0LL;
              *(void *)address = 7708LL;
              *(_WORD *)&address[2] = *(_WORD *)v23->sa_data;
              os_log_type_t v24 = nw_endpoint_create_address((const sockaddr *)address);
              nw_parameters_set_local_endpoint((nw_parameters_t)v17, v24);
            }
          }
        }
      }
    }
  }

  id v26 = v15;
  id v27 = nw_endpoint_copy_public_keys(v26);
  if (v27)
  {
    id v28 = v26;
    uint64_t v29 = (void *)[v28 copyEndpoint];
    nw_endpoint_copy_properties(v28, v29);

    nw_endpoint_set_public_keys(v29, 0LL);
    char v30 = (id *)v14;
    uint64_t v31 = (nw_protocol_stack *)v30[19];

    iterate_block[0] = MEMORY[0x1895F87A8];
    iterate_block[1] = 3221225472LL;
    iterate_block[2] = ___ZL32nw_endpoint_handler_create_innerPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS_PFbP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS_ESD_S5_jb_block_invoke;
    iterate_block[3] = &unk_189BC5C38;
    id v88 = v27;
    v89 = v30;
    nw_protocol_stack_iterate_application_protocols(v31, iterate_block);

    id v26 = v29;
  }

  char v32 = -[NWConcrete_nw_endpoint_handler initWithEndpoint:parameters:reportCallback:context:parent:identifier:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_endpoint_handler),  v26,  v14,  a3,  v84,  v86,  a6);
  id v33 = v32;
  if (!v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v38 = (id)gLogObj;
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_handler_create_inner";
    char v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (__nwlog_fault(v39, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v40 = (os_log_s *)(id)gLogObj;
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed",  address,  0xCu);
        }
      }

      else if (v90)
      {
        os_log_type_t v52 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v40 = (os_log_s *)(id)gLogObj;
        os_log_type_t v53 = type;
        BOOL v54 = os_log_type_enabled(v40, type);
        if (v52)
        {
          if (v54)
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[4] = "nw_endpoint_handler_create_inner";
            *(_WORD *)&address[12] = 2082;
            *(void *)&address[14] = v52;
            _os_log_impl( &dword_181A5C000,  v40,  v53,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s",  address,  0x16u);
          }

          free(v52);
          if (!v39) {
            goto LABEL_52;
          }
          goto LABEL_51;
        }

        if (v54)
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl( &dword_181A5C000,  v40,  v53,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, no backtrace",  address,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v40 = (os_log_s *)(id)gLogObj;
        os_log_type_t v55 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl( &dword_181A5C000,  v40,  v55,  "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, backtrace limit exceeded",  address,  0xCu);
        }
      }
    }

    if (!v39) {
      goto LABEL_52;
    }
LABEL_51:
    free(v39);
    goto LABEL_52;
  }

  if (a7) {
    *((_BYTE *)v32 + 268) |= 1u;
  }
  __int16 v34 = v14;
  BOOL v35 = (v34[12] & 0x800LL) == 0;

  if (v35)
  {
    if (v86 || (*((_BYTE *)v33 + 268) & 1) != 0)
    {
      *((_DWORD *)v33 + 29) = 0;
    }

    else
    {
      *((_DWORD *)v33 + 29) = 2;
      uint64_t v36 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
      *((_BYTE *)v36 + 32) = *((_BYTE *)v36 + 32) & 0xFC | 1;
      id v37 = v33[31];
      v33[31] = v36;
    }

    goto LABEL_37;
  }

  *((_DWORD *)v33 + 29) = 2;
  id v42 = v33[9];
  __int16 v43 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_endpoint_flow);
  *((_BYTE *)v43 + 32) = *((_BYTE *)v43 + 32) & 0xFC | (v42 == 0LL) | 2;
  id v44 = v33[31];
  v33[31] = v43;

  id v45 = v33[31];
  v46 = v33;
  v47 = v45;
  v48 = v47;
  if (!v47)
  {
    __nwlog_obj();
    v73 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
    v74 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (__nwlog_fault(v74, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v76 = type;
        if (os_log_type_enabled(v75, type))
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl(&dword_181A5C000, v75, v76, "%{public}s called with null endpoint_flow", address, 0xCu);
        }
      }

      else if (v90)
      {
        v80 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v83 = type;
        BOOL v81 = os_log_type_enabled(v75, type);
        if (v80)
        {
          if (v81)
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
            *(_WORD *)&address[12] = 2082;
            *(void *)&address[14] = v80;
            _os_log_impl( &dword_181A5C000,  v75,  v83,  "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s",  address,  0x16u);
          }

          free(v80);
          goto LABEL_122;
        }

        if (v81)
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl( &dword_181A5C000,  v75,  v83,  "%{public}s called with null endpoint_flow, no backtrace",  address,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v82 = type;
        if (os_log_type_enabled(v75, type))
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl( &dword_181A5C000,  v75,  v82,  "%{public}s called with null endpoint_flow, backtrace limit exceeded",  address,  0xCu);
        }
      }
    }

  *((_BYTE *)self + 34) |= 8u;
LABEL_113:

  uint64_t v7 = v229;
LABEL_114:
  v96 = v7;
  v230[30] = 2;

  clone_from_flow = self->clone_from_flow;
  if (!clone_from_flow || (*((_BYTE *)self + 32) & 0x40) != 0)
  {
    if ((*((_BYTE *)self + 32) & 0x42) == 2 && (*((_BYTE *)self + 33) & 0x40) != 0)
    {
    }

    else
    {
      v157 = nw_endpoint_flow_expected_to_join(v96, self);
      nw_endpoint_flow_setup_protocols(v96, 0LL, 0LL, 1, v157);
    }

    goto LABEL_233;
  }

  v98 = v96;
  v218 = clone_from_flow;
  v99 = v98;
  v100 = v3[29];
  v228 = v99;

  if ((_DWORD)v100 != 2)
  {
    __nwlog_obj();
    v158 = (void *)objc_claimAutoreleasedReturnValue();
    else {
      v159 = off_189BBBBC0[v100];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_setup_cloned_protocols";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v159;
    *(_WORD *)&buf[22] = 2082;
    v240 = "flow";
    v169 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v234 = 0;
    if (__nwlog_fault(v169, type, &v234))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v171 = type[0];
        if (os_log_type_enabled(v170, type[0]))
        {
          else {
            v172 = off_189BBBBC0[v100];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_setup_cloned_protocols";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v172;
          *(_WORD *)&buf[22] = 2082;
          v240 = "flow";
          _os_log_impl( &dword_181A5C000,  v170,  v171,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v234)
      {
        v173 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v174 = type[0];
        v175 = os_log_type_enabled(v170, type[0]);
        if (v173)
        {
          if (v175)
          {
            else {
              v176 = off_189BBBBC0[v100];
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_setup_cloned_protocols";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v176;
            *(_WORD *)&buf[22] = 2082;
            v240 = "flow";
            *(_WORD *)v241 = 2082;
            *(void *)&v241[2] = v173;
            _os_log_impl( &dword_181A5C000,  v170,  v174,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v173);
          goto LABEL_230;
        }

        if (v175)
        {
          else {
            v179 = off_189BBBBC0[v100];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_setup_cloned_protocols";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v179;
          *(_WORD *)&buf[22] = 2082;
          v240 = "flow";
          _os_log_impl( &dword_181A5C000,  v170,  v174,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        __nwlog_obj();
        v170 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v177 = type[0];
        if (os_log_type_enabled(v170, type[0]))
        {
          else {
            v178 = off_189BBBBC0[v100];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_setup_cloned_protocols";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v178;
          *(_WORD *)&buf[22] = 2082;
          v240 = "flow";
          _os_log_impl( &dword_181A5C000,  v170,  v177,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }
    }

    free(backtrace_string);
    goto LABEL_299;
  }

  a1->default_input_handler = a2;
  if (a2->handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = a2[1].callbacks;
    if (callbacks) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
  }

  *(_OWORD *)a1->flow_id = *(_OWORD *)a2->flow_id;
  if (a2->output_handler)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v6 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v134 = "nw_protocol_ipv4_add_input_handler";
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s Output handler already exists for protocol being added as input handler",  buf,  0xCu);
    }
  }

  else
  {
    a2->output_handler = a1;
    uint64_t v7 = a1[1].callbacks;
    if (v7) {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
    }
  }

  handle = a2->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v9 = a2[1].callbacks;
    if (v9) {
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v9->add_input_handler + 1);
    }
  }

  os_log_type_t v10 = a2->callbacks;
  if (v10)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v10->get_parameters;
    if (get_parameters)
    {
      os_log_type_t v12 = (void *)get_parameters(a2);
      if (handle != &nw_protocol_ref_counted_handle) {
        goto LABEL_24;
      }
      goto LABEL_23;
    }
  }

  __nwlog_obj();
  char v25 = a2->identifier;
  if (!v25) {
    char v25 = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)buf = 136446722;
  v134 = "__nw_protocol_get_parameters";
  v135 = 2082;
  v136 = v25;
  v137 = 2048;
  v138 = a2;
  id v26 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v131 = 0;
  if (__nwlog_fault(v26, &type, &v131))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v27 = (os_log_s *)__nwlog_obj();
      id v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_126;
      }
      uint64_t v29 = a2->identifier;
      if (!v29) {
        uint64_t v29 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_parameters";
      v135 = 2082;
      v136 = v29;
      v137 = 2048;
      v138 = a2;
      char v30 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_125:
      _os_log_impl(&dword_181A5C000, v27, v28, v30, buf, 0x20u);
      goto LABEL_126;
    }

    if (!v131)
    {
      id v27 = (os_log_s *)__nwlog_obj();
      id v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_126;
      }
      BOOL v54 = a2->identifier;
      if (!v54) {
        BOOL v54 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_parameters";
      v135 = 2082;
      v136 = v54;
      v137 = 2048;
      v138 = a2;
      char v30 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
      goto LABEL_125;
    }

    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    id v27 = (os_log_s *)__nwlog_obj();
    id v28 = type;
    id v42 = os_log_type_enabled(v27, type);
    if (!v41)
    {
      if (!v42) {
        goto LABEL_126;
      }
      v56 = a2->identifier;
      if (!v56) {
        v56 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      v134 = "__nw_protocol_get_parameters";
      v135 = 2082;
      v136 = v56;
      v137 = 2048;
      v138 = a2;
      char v30 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
      goto LABEL_125;
    }

    if (v42)
    {
      __int16 v43 = a2->identifier;
      if (!v43) {
        __int16 v43 = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446978;
      v134 = "__nw_protocol_get_parameters";
      v135 = 2082;
      v136 = v43;
      v137 = 2048;
      v138 = a2;
      v139 = 2082;
      v140 = v41;
      _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
    }

    free(v41);
  }

          id v14 = 0LL;
          goto LABEL_96;
        }

        request = nw_endpoint_handler_add_read_request(v21, v4);
      }

      else
      {
        if (*((void *)v7 + 96))
        {
          if (*((void *)v7 + 108))
          {
            os_log_type_t v9 = (id *)v4;
            os_log_type_t v10 = v9;
            if (v9)
            {
              BOOL v11 = (os_log_s *)v9[18];

              if (v11)
              {
                if (v11 == (os_log_s *)&__block_literal_global_5_41854)
                {
                  *(void *)buf = 0LL;
                  *(void *)&buf[8] = buf;
                  *(void *)&buf[16] = 0x2020000000LL;
                  LOBYTE(v109) = 0;
                  *(void *)os_log_type_t type = 0LL;
                  v104 = type;
                  v105 = 0x2020000000LL;
                  v106 = 0;
                  BOOL v58 = (char *)*((void *)v8 + 108);
                  v97[0] = MEMORY[0x1895F87A8];
                  v97[1] = 3221225472LL;
                  v97[2] = __nw_endpoint_handler_add_read_request_block_invoke;
                  v97[3] = &unk_189BB83D8;
                  v98 = v5;
                  os_log_type_t v59 = v10;
                  v99 = v59;
                  v101 = buf;
                  v102 = type;
                  os_log_type_t v60 = v8;
                  v100 = v60;
                  nw_hash_table_apply(v58, (uint64_t)v97);
                  if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
                  {
                    id v14 = *((_BYTE *)v104 + 24) != 0;
                  }

                  else
                  {
                    request_list_append = nw_read_request_list_append(v60[89], v59);
                    os_log_type_t v68 = v60[89];
                    v60[89] = (void *)request_list_append;

                    id v14 = 1LL;
                  }

                  _Block_object_dispose(type, 8);
                  _Block_object_dispose(buf, 8);
                  BOOL v11 = (os_log_s *)&__block_literal_global_5_41854;
                  goto LABEL_95;
                }

                node = nw_hash_table_get_node(*((void *)v8 + 108), (uint64_t)v11, 0LL);
                if (node
                  || (repliable_metadata = nw_content_context_copy_first_repliable_metadata(v11)) != 0LL
                  && (os_log_type_t v66 = repliable_metadata,
                      node = nw_hash_table_get_node(*((void *)v8 + 108), (uint64_t)repliable_metadata, 1LL),
                      v66,
                      node))
                {
                  id v13 = *(nw_flow_protocol **)(node + 16);
                  id v14 = nw_flow_add_read_request(v5, (uint64_t)v13, v10);
                  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                    }
                    v87 = (os_log_s *)(id)gconnectionLogObj;
                    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v5);
                      v92 = nw_endpoint_handler_dry_run_string(v5);
                      v96 = nw_endpoint_handler_copy_endpoint(v5);
                      *(_DWORD *)buf = 136448514;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = id_string;
                      *(_WORD *)&buf[22] = 2082;
                      v109 = v92;
                      v110 = 2082;
                      v111 = nw_endpoint_get_logging_description(v96);
                      v112 = 2082;
                      v113 = nw_endpoint_handler_state_string(v5);
                      v114 = 2082;
                      v115 = nw_endpoint_handler_mode_string(v5);
                      v116 = 2114;
                      id v88 = nw_endpoint_handler_copy_current_path(v5);
                      v117 = v88;
                      v118 = 2112;
                      v119 = v10;
                      v120 = 2048;
                      v121 = v13;
                      v122 = 1024;
                      v123 = v14;
                      _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added read requ est %@ to flow protocol %p: %u",  buf,  0x62u);
                    }
                  }

                  nw_flow_service_reads(v5, (NWConcrete_nw_endpoint_flow *)v8, v13, 0);
                  goto LABEL_95;
                }

                nw_read_request_fail(v10, 2);
                goto LABEL_94;
              }

        goto LABEL_113;
      }

      if (!v69)
      {
        __nwlog_obj();
        char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v59 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl( &dword_181A5C000,  v39,  v59,  "%{public}s protocol options are not http redirect, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = type[0];
      BOOL v54 = os_log_type_enabled(v39, type[0]);
      if (!backtrace_string)
      {
        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl( &dword_181A5C000,  v39,  v62,  "%{public}s protocol options are not http redirect, no backtrace",  buf,  0xCu);
        }

        goto LABEL_112;
      }

      if (v54)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_redirect_options_copy_handler";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v39,  v62,  "%{public}s protocol options are not http redirect, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    if (v62) {
      free(v62);
    }
    goto LABEL_53;
  }

  __nwlog_obj();
  os_log_type_t v57 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
  BOOL v54 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v110 = 0;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v58 = type[0];
    if (os_log_type_enabled(v55, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
      _os_log_impl(&dword_181A5C000, v55, v58, "%{public}s called with null protocol->identifier", buf, 0xCu);
    }

    goto LABEL_103;
  }

  if (!v110)
  {
    __nwlog_obj();
    os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v75 = type[0];
    if (os_log_type_enabled(v55, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
      _os_log_impl( &dword_181A5C000,  v55,  v75,  "%{public}s called with null protocol->identifier, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_103;
  }

  os_log_type_t v68 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v69 = type[0];
  v70 = os_log_type_enabled(v55, type[0]);
  if (!v68)
  {
    if (v70)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
      _os_log_impl( &dword_181A5C000,  v55,  v69,  "%{public}s called with null protocol->identifier, no backtrace",  buf,  0xCu);
    }

    goto LABEL_103;
  }

  if (v70)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_add_edges_for_instance";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v68;
    _os_log_impl( &dword_181A5C000,  v55,  v69,  "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v68);
  if (v54) {
    goto LABEL_105;
  }
LABEL_55:
}

    os_log_type_t v78 = 0LL;
    goto LABEL_167;
  }

  v111 = v7;
  if (v6)
  {
    os_log_type_t v9 = v6;
    os_log_type_t v10 = (void *)-[nw_endpoint copyEndpoint](v9, "copyEndpoint");
    nw_endpoint_copy_properties(v9, v10);
  }

  else
  {
    os_log_type_t v10 = (void *)nw_group_descriptor_copy_member(*((void **)v5 + 8));
  }

  BOOL v11 = *((id *)v5 + 7);
  os_log_type_t v12 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v11,  0,  0);

  id v13 = v5;
  id v14 = v10;
  id v15 = (id)v12;
  v113 = v8;
  if (!v14)
  {
    __nwlog_obj();
    os_log_type_t v53 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)aBlock = 136446210;
    *(void *)&aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
    BOOL v54 = (char *)_os_log_send_and_compose_impl();

    iterate_block[0] = 16;
    LOBYTE(v124) = 0;
    if (iterate_block[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v56 = iterate_block[0];
      if (os_log_type_enabled(v55, (os_log_type_t)iterate_block[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl(&dword_181A5C000, v55, v56, "%{public}s called with null remote_endpoint", aBlock, 0xCu);
      }
    }

    else if ((_BYTE)v124)
    {
      os_log_type_t v62 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v63 = iterate_block[0];
      os_log_type_t v64 = os_log_type_enabled(v55, (os_log_type_t)iterate_block[0]);
      if (v62)
      {
        if (v64)
        {
          *(_DWORD *)aBlock = 136446466;
          *(void *)&aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
          *(_WORD *)&aBlock[12] = 2082;
          *(void *)&aBlock[14] = v62;
          _os_log_impl( &dword_181A5C000,  v55,  v63,  "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s",  aBlock,  0x16u);
        }

        free(v62);
        if (!v54) {
          goto LABEL_121;
        }
        goto LABEL_120;
      }

      if (v64)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl( &dword_181A5C000,  v55,  v63,  "%{public}s called with null remote_endpoint, no backtrace",  aBlock,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v73 = iterate_block[0];
      if (os_log_type_enabled(v55, (os_log_type_t)iterate_block[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        _os_log_impl( &dword_181A5C000,  v55,  v73,  "%{public}s called with null remote_endpoint, backtrace limit exceeded",  aBlock,  0xCu);
      }
    }

    goto LABEL_118;
  }

  if (v15)
  {
    v118 = 0LL;
    v119 = &v118;
    v120 = 0x3032000000LL;
    v121 = __Block_byref_object_copy__8579;
    v122 = __Block_byref_object_dispose__8580;
    v123 = 0LL;
    v114 = 0LL;
    v115 = &v114;
    v116 = 0x2020000000LL;
    v117 = 0;
    *(void *)aBlock = MEMORY[0x1895F87A8];
    *(void *)&aBlock[8] = 3221225472LL;
    *(void *)&aBlock[16] = ___ZL63nw_connection_group_copy_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU33objcproto22OS_nw_protocol_optionsS1_bb_block_invoke;
    *(void *)&aBlock[24] = &unk_189BB7300;
    int v16 = v13;
    *(void *)&aBlock[32] = v16;
    v134 = &v114;
    v109 = v15;
    v132 = v109;
    v110 = v14;
    v133 = v110;
    v135 = &v118;
    __int16 v17 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v13 + 43);
    v17[2](v17);
    os_unfair_lock_unlock(v13 + 43);

    if (*((_BYTE *)v115 + 24))
    {
      id v18 = 0LL;
LABEL_146:

      _Block_object_dispose(&v114, 8);
      _Block_object_dispose(&v118, 8);

      goto LABEL_147;
    }

    if (v119[5])
    {
      id v19 = *(void **)&v16[16]._os_unfair_lock_opaque;
      if (!v19 || (int v20 = v19, v21 = v20[2], v20, v21 != 2))
      {
LABEL_145:
        id v18 = (id)v119[5];
        goto LABEL_146;
      }
    }

    if (!nw_parameters_get_logging_disabled(*((void *)v5 + 7)) && gLogDatapath)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      os_log_type_t v68 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
      {
        os_unfair_lock_opaque = v16[42]._os_unfair_lock_opaque;
        *(_DWORD *)iterate_block = 136446978;
        *(void *)&void iterate_block[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
        *(_WORD *)&iterate_block[12] = 1024;
        *(_DWORD *)&iterate_block[14] = os_unfair_lock_opaque;
        *(_WORD *)&iterate_block[18] = 2112;
        *(void *)&iterate_block[20] = v110;
        *(_WORD *)&iterate_block[28] = 2112;
        *(void *)&iterate_block[30] = v109;
        _os_log_impl( &dword_181A5C000,  v68,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Did not find connection for (remote: %@, parameters: %@), creating new connection",  iterate_block,  0x26u);
      }
    }

    int v22 = (void *)v119[5];
    v108 = v16;
    v104 = v22;
    endpointa = (nw_endpoint *)v110;
    uint64_t v23 = v109;
    v106 = v113;
    v124 = 0LL;
    v125 = &v124;
    v126 = 0x3032000000LL;
    v127 = __Block_byref_object_copy__8579;
    v128 = __Block_byref_object_dispose__8580;
    v129 = 0LL;
    v103 = v23;
    parameters = (nw_parameters *)-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v103,  0,  0);

    nw_parameters_set_reuse_local_address(parameters, 1);
    if (!nw_parameters_get_logging_disabled(*((void *)v5 + 7)) && gLogDatapath)
    {
      if (__nwlog_connection_group_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
      }
      v70 = (os_log_s *)(id)gconnection_groupLogObj;
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v71 = v108[42]._os_unfair_lock_opaque;
        *(_DWORD *)iterate_block = 136446978;
        *(void *)&void iterate_block[4] = "nw_connection_group_create_connection_for_endpoint_and_parameters";
        *(_WORD *)&iterate_block[12] = 1024;
        *(_DWORD *)&iterate_block[14] = v71;
        *(_WORD *)&iterate_block[18] = 2112;
        *(void *)&iterate_block[20] = endpointa;
        *(_WORD *)&iterate_block[28] = 2112;
        *(void *)&iterate_block[30] = parameters;
        _os_log_impl( &dword_181A5C000,  v70,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Creating connection for endpoint (%@) and parameters (%@)",  iterate_block,  0x26u);
      }
    }

    if (!v106)
    {
LABEL_33:
      id v37 = *(void **)&v108[16]._os_unfair_lock_opaque;
      if (v37 && (id v38 = v37, v39 = v38[2], v38, v39 == 2)) {
        __int16 v40 = nw_connection_create_with_connection(v104, parameters);
      }
      else {
        __int16 v40 = nw_connection_create(endpointa, parameters);
      }
      os_log_type_t v41 = (void *)v125[5];
      v125[5] = (uint64_t)v40;

      if (v125[5])
      {
        *(void *)iterate_block = MEMORY[0x1895F87A8];
        *(void *)&iterate_block[8] = 3221225472LL;
        *(void *)&iterate_block[16] = ___ZL65nw_connection_group_create_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS3_PU33objcproto22OS_nw_protocol_optionsS3_b_block_invoke_2;
        *(void *)&iterate_block[24] = &unk_189BC9210;
        v141 = &v124;
        *(void *)&iterate_block[32] = v108;
        id v42 = (void (**)(void))_Block_copy(iterate_block);
        os_unfair_lock_lock(v13 + 43);
        v42[2](v42);
        os_unfair_lock_unlock(v13 + 43);

        __int16 v43 = *(os_log_s **)&iterate_block[32];
      }

      else
      {
        if (nw_parameters_get_logging_disabled(*((void *)v5 + 7)))
        {
LABEL_45:
          v46 = (id)v125[5];
          goto LABEL_137;
        }

        if (__nwlog_connection_group_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
        }
        __int16 v43 = (os_log_s *)(id)gconnection_groupLogObj;
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          id v44 = v108[42]._os_unfair_lock_opaque;
          id v45 = *((void *)v5 + 7);
          *(_DWORD *)iterate_block = 136446722;
          *(void *)&void iterate_block[4] = "nw_connection_group_create_connection_for_endpoint_and_parameters";
          *(_WORD *)&iterate_block[12] = 1024;
          *(_DWORD *)&iterate_block[14] = v44;
          *(_WORD *)&iterate_block[18] = 2112;
          *(void *)&iterate_block[20] = v45;
          _os_log_impl( &dword_181A5C000,  v43,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] failed to create connection with parameters %@",  iterate_block,  0x1Cu);
        }
      }

      goto LABEL_45;
    }

    v102 = v108;
    os_log_type_t v24 = parameters;
    char v25 = v106;
    if (v24)
    {
      id v26 = v24;
      id v27 = v26[19];
      v100 = v26;

      id v28 = v25;
      uint64_t v29 = v28[1];

      *(void *)v144 = 0LL;
      *(void *)&v144[8] = v144;
      *(void *)&v144[16] = 0x2020000000LL;
      v144[24] = 0;
      *(void *)iterate_block = MEMORY[0x1895F87A8];
      *(void *)&iterate_block[8] = 3221225472LL;
      *(void *)&iterate_block[16] = ___ZL37nw_connection_group_modify_parametersP30NWConcrete_nw_connection_groupPU27objcproto16OS_nw_parameters8NSObjectPU33objcproto22OS_nw_protocol_optionsS1__block_invoke;
      *(void *)&iterate_block[24] = &unk_189BB7328;
      v143 = v144;
      char v30 = v29;
      *(void *)&iterate_block[32] = v30;
      uint64_t v31 = (uint64_t *)v27;
      v141 = v31;
      char v32 = v28;
      v142 = v32;
      nw_protocol_stack_iterate_application_protocols((nw_protocol_stack_t)v31, iterate_block);
      if (*(_BYTE *)(*(void *)&v144[8] + 24LL))
      {
        id v33 = 1;
      }

      else
      {
        __int16 v34 = nw_protocol_stack_copy_transport_protocol((nw_protocol_stack_t)v31);
        v99 = nw_protocol_options_copy_definition(v34);
        os_log_type_t type = v34;
        if (nw_protocol_definition_is_equal_unsafe((uint64_t)v99, (uint64_t)v30))
        {
          nw_protocol_stack_set_transport_protocol((nw_protocol_stack_t)v31, (nw_protocol_options_t)v32);
          *(_BYTE *)(*(void *)&v144[8] + 24LL) = 1;
        }

        else if (!*(_BYTE *)(*(void *)&v144[8] + 24LL) && !nw_parameters_get_logging_disabled(*((void *)v5 + 7)))
        {
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          BOOL v35 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            uint64_t v36 = v102[42]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446466;
            v137 = "nw_connection_group_modify_parameters";
            v138 = 1024;
            v139 = v36;
            _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_INFO,  "%{public}s [G%u] Failed to find matching protocol definition",  buf,  0x12u);
          }
        }

        id v33 = *(_BYTE *)(*(void *)&v144[8] + 24LL) != 0;
      }

      _Block_object_dispose(v144, 8);
      if (v33) {
        goto LABEL_33;
      }
LABEL_136:
      v46 = 0LL;
LABEL_137:

      _Block_object_dispose(&v124, 8);
      os_log_type_t v82 = (void *)v119[5];
      v119[5] = (uint64_t)v46;

      if (v119[5])
      {
        v124 = 0LL;
        v125 = &v124;
        v126 = 0x2020000000LL;
        LOBYTE(v127) = 0;
        *(void *)iterate_block = MEMORY[0x1895F87A8];
        *(void *)&iterate_block[8] = 3221225472LL;
        *(void *)&iterate_block[16] = ___ZL63nw_connection_group_copy_connection_for_endpoint_and_parametersP30NWConcrete_nw_connection_groupPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS1_PU33objcproto22OS_nw_protocol_optionsS1_bb_block_invoke_154;
        *(void *)&iterate_block[24] = &unk_189BC9210;
        v141 = &v124;
        os_log_type_t v83 = v108;
        *(void *)&iterate_block[32] = v83;
        id v84 = (void (**)(void))_Block_copy(iterate_block);
        os_unfair_lock_lock(v13 + 43);
        v84[2](v84);
        os_unfair_lock_unlock(v13 + 43);

        if (!nw_parameters_get_logging_disabled(*((void *)v5 + 7)))
        {
          if (__nwlog_connection_group_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
          }
          v85 = (os_log_s *)(id)gconnection_groupLogObj;
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
          {
            id v86 = v83[42]._os_unfair_lock_opaque;
            v87 = v119[5];
            *(_DWORD *)v144 = 136446722;
            *(void *)&v144[4] = "nw_connection_group_copy_connection_for_endpoint_and_parameters";
            *(_WORD *)&v144[12] = 1024;
            *(_DWORD *)&v144[14] = v86;
            *(_WORD *)&v144[18] = 2112;
            *(void *)&v144[20] = v87;
            _os_log_impl( &dword_181A5C000,  v85,  OS_LOG_TYPE_DEBUG,  "%{public}s [G%u] Deferring start of connection %@ until group start",  v144,  0x1Cu);
          }
        }

        _Block_object_dispose(&v124, 8);
      }

      goto LABEL_145;
    }

    __nwlog_obj();
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v144 = 136446210;
    *(void *)&v144[4] = "nw_connection_group_modify_parameters";
    v101 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    v130 = 0;
    if (__nwlog_fault(v101, buf, &v130))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        os_log_type_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v77 = buf[0];
        if (os_log_type_enabled(v76, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v144 = 136446210;
          *(void *)&v144[4] = "nw_connection_group_modify_parameters";
          _os_log_impl(&dword_181A5C000, v76, v77, "%{public}s called with null parameters", v144, 0xCu);
        }
      }

      else if (v130)
      {
        os_log_type_t v79 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        typea = buf[0];
        v80 = os_log_type_enabled(v76, (os_log_type_t)buf[0]);
        if (v79)
        {
          if (v80)
          {
            *(_DWORD *)v144 = 136446466;
            *(void *)&v144[4] = "nw_connection_group_modify_parameters";
            *(_WORD *)&v144[12] = 2082;
            *(void *)&v144[14] = v79;
            _os_log_impl( &dword_181A5C000,  v76,  typea,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  v144,  0x16u);
          }

          free(v79);
          goto LABEL_133;
        }

        if (v80)
        {
          *(_DWORD *)v144 = 136446210;
          *(void *)&v144[4] = "nw_connection_group_modify_parameters";
          _os_log_impl(&dword_181A5C000, v76, typea, "%{public}s called with null parameters, no backtrace", v144, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v76 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v81 = buf[0];
        if (os_log_type_enabled(v76, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v144 = 136446210;
          *(void *)&v144[4] = "nw_connection_group_modify_parameters";
          _os_log_impl( &dword_181A5C000,  v76,  v81,  "%{public}s called with null parameters, backtrace limit exceeded",  v144,  0xCu);
        }
      }
    }

      if (a2)
      {
        if (a2->handle == &nw_protocol_ref_counted_handle)
        {
          os_log_type_t v59 = a2[1].callbacks;
          if (v59) {
            a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v59->add_input_handler + 1);
          }
          BOOL v58 = -1;
        }

        else
        {
          BOOL v58 = 0;
        }

        *(void *)os_log_type_t type = a2;
        v139 = v58;
        if (*(v6 - 7) == &nw_protocol_ref_counted_handle)
        {
          os_log_type_t v60 = (uint64_t)*(v6 - 1);
          if (v60) {
            *(v6 - 1) = (void *)(v60 + 1);
          }
          os_log_type_t v52 = -1;
        }

        else
        {
          os_log_type_t v52 = 0;
        }

        v136 = v6 - 12;
        v137 = v52;
        v61 = a2->callbacks;
        if (v61)
        {
          os_log_type_t v62 = (void (*)(nw_protocol *, void **))v61->disconnected;
          if (v62)
          {
            v62(a2, v6 - 12);
            if ((v137 & 1) == 0) {
              goto LABEL_127;
            }
            goto LABEL_126;
          }
        }

        __nwlog_obj();
        v65 = (void *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v66 = a2->identifier;
        *(_DWORD *)buf = 136446722;
        v141 = "__nw_protocol_disconnected";
        if (!v66) {
          os_log_type_t v66 = (nw_protocol_identifier *)"invalid";
        }
        v142 = 2082;
        v143 = (nw_protocol *)v66;
        v144 = 2048;
        v145 = a2;
        BOOL v67 = (void *)_os_log_send_and_compose_impl();

        v135 = OS_LOG_TYPE_ERROR;
        v134 = 0;
        if (v135 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          BOOL v69 = v135;
          if (os_log_type_enabled(v68, v135))
          {
            v70 = a2->identifier;
            if (!v70) {
              v70 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446722;
            v141 = "__nw_protocol_disconnected";
            v142 = 2082;
            v143 = (nw_protocol *)v70;
            v144 = 2048;
            v145 = a2;
            _os_log_impl( &dword_181A5C000,  v68,  v69,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback",  buf,  0x20u);
          }

          goto LABEL_293;
        }

        if (!v134)
        {
          __nwlog_obj();
          os_log_type_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v107 = v135;
          if (os_log_type_enabled(v68, v135))
          {
            v108 = a2->identifier;
            if (!v108) {
              v108 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446722;
            v141 = "__nw_protocol_disconnected";
            v142 = 2082;
            v143 = (nw_protocol *)v108;
            v144 = 2048;
            v145 = a2;
            _os_log_impl( &dword_181A5C000,  v68,  v107,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded",  buf,  0x20u);
          }

          goto LABEL_293;
        }

        id v86 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v87 = v135;
        id v88 = os_log_type_enabled(v68, v135);
        if (!v86)
        {
          if (v88)
          {
            v118 = a2->identifier;
            if (!v118) {
              v118 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446722;
            v141 = "__nw_protocol_disconnected";
            v142 = 2082;
            v143 = (nw_protocol *)v118;
            v144 = 2048;
            v145 = a2;
            _os_log_impl( &dword_181A5C000,  v68,  v87,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace",  buf,  0x20u);
          }

          goto LABEL_293;
        }

        if (v88)
        {
          v89 = a2->identifier;
          if (!v89) {
            v89 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446978;
          v141 = "__nw_protocol_disconnected";
          v142 = 2082;
          v143 = (nw_protocol *)v89;
          v144 = 2048;
          v145 = a2;
          v146 = 2082;
          v147 = v86;
          _os_log_impl( &dword_181A5C000,  v68,  v87,  "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        goto LABEL_235;
      }

      __nwlog_obj();
      id v84 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v141 = "__nw_protocol_disconnected";
      os_log_type_t v76 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v85 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v141 = "__nw_protocol_disconnected";
          _os_log_impl(&dword_181A5C000, v77, v85, "%{public}s called with null protocol", buf, 0xCu);
        }

        goto LABEL_306;
      }

      if (!(_BYTE)v136)
      {
        __nwlog_obj();
        os_log_type_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v119 = type[0];
        if (os_log_type_enabled(v77, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v141 = "__nw_protocol_disconnected";
          _os_log_impl( &dword_181A5C000,  v77,  v119,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_306;
      }

      v96 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v105 = type[0];
      v106 = os_log_type_enabled(v77, type[0]);
      if (!v96)
      {
        if (v106)
        {
          *(_DWORD *)buf = 136446210;
          v141 = "__nw_protocol_disconnected";
          _os_log_impl(&dword_181A5C000, v77, v105, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }

        goto LABEL_306;
      }

      if (v106)
      {
        *(_DWORD *)buf = 136446466;
        v141 = "__nw_protocol_disconnected";
        v142 = 2082;
        v143 = (nw_protocol *)v96;
        _os_log_impl( &dword_181A5C000,  v77,  v105,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_274;
    }

    id v19 = *(uint64_t (**)(void **, uint64_t, uint64_t))(v7[10] + 128LL);
    if (v19)
    {
      if ((v19(v6, -1LL, 3LL) & 1) != 0) {
        goto LABEL_112;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v20 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v141 = "nw_protocol_implementation_disconnect";
      __int16 v21 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v136) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v22 = (os_log_s *)(id)gLogObj;
        uint64_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v141 = "nw_protocol_implementation_disconnect";
          _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s Cannot defer stop of NW_PROTOCOL_DEFAULT_FLOW",  buf,  0xCu);
        }

      if (!v91)
      {
LABEL_114:
        if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v135 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
          {
            v136 = nw_endpoint_handler_get_id_string(v5);
            v137 = nw_endpoint_handler_dry_run_string(v5);
            v138 = nw_endpoint_handler_copy_endpoint(v5);
            logh = v47;
            v139 = nw_endpoint_get_logging_description(v138);
            v140 = nw_endpoint_handler_state_string(v5);
            v141 = nw_endpoint_handler_mode_string(v5);
            v142 = nw_endpoint_handler_copy_current_path(v5);
            v143 = (char *)v6[2];
            v144 = *(char **)(v207 + 16);
            *(_DWORD *)buf = 136448258;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_context_internal";
            v215 = 2082;
            v216 = (uint64_t)v136;
            v217 = 2082;
            v218 = (uint64_t)v137;
            v219 = 2082;
            v220 = v139;
            v221 = 2082;
            v222 = v140;
            v223 = 2082;
            v224 = v141;
            v225 = 2114;
            v226 = v142;
            v227 = 2082;
            v228 = v143;
            v229 = 2082;
            v230 = v144;
            _os_log_impl( &dword_181A5C000,  v135,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{ public}s to %{public}s",  buf,  0x5Cu);

            v47 = logh;
          }
        }

        nw_hash_table_remove_node(*((void *)v210 + 108), v47);
        goto LABEL_121;
      }

        goto LABEL_113;
      }

      if (!v55)
      {
        __nwlog_obj();
        char v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v30, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v58 = "nw_parameters_create_quic";
          _os_log_impl( &dword_181A5C000,  v30,  v50,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_default_configuration)), b acktrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v42 = type;
      __int16 v43 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v58 = "nw_parameters_create_quic";
          _os_log_impl( &dword_181A5C000,  v30,  v42,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_default_configuration)), no backtrace",  buf,  0xCu);
        }

        goto LABEL_112;
      }

      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v58 = "nw_parameters_create_quic";
        os_log_type_t v59 = 2082;
        os_log_type_t v60 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v30,  v42,  "%{public}s called with null (configure_quic != (_nw_parameters_configure_protocol_default_configuration)), dum ping backtrace:%{public}s",  buf,  0x16u);
      }

  nw_protocol_remove_instance((uint64_t)handle);
  os_log_type_t v66 = (_BYTE *)*((void *)handle + 23);
  v65 = (_BYTE *)*((void *)handle + 24);
  if (v66 == v65)
  {
    nw_http_client_bottom_destroy((uint64_t)handle);
  }

  else
  {
    BOOL v67 = v65 - v66;
    if (v65 - v66 < 0) {
LABEL_159:
    }
      abort();
    os_log_type_t v68 = operator new(v65 - v66);
    BOOL v69 = v67 & 0xFFFFFFFFFFFFFFF0LL;
    memcpy(v68, v66, v69);
    if (v69)
    {
      v70 = v68 + 2;
      do
      {
        if (*v70 != 2) {
          nw_protocol_notify(*((void **)v70 - 1), (uint64_t)handle, 22);
        }
        v70 += 4;
        v69 -= 16LL;
      }

      while (v69);
    }

    operator delete(v68);
  }

              goto LABEL_131;
            }

            if (!v80)
            {
              __nwlog_obj();
              BOOL v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v77 = type;
              if (os_log_type_enabled(v54, type))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v83 = "nw_pac_resolver_create_with_url";
                _os_log_impl( &dword_181A5C000,  v54,  v77,  "%{public}s called with null logging_id_str, backtrace limit exceeded",  buf,  0xCu);
              }

              goto LABEL_112;
            }

            v70 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            BOOL v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v71 = type;
            BOOL v72 = os_log_type_enabled(v67, type);
            if (v70)
            {
              if (v72)
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v83 = "nw_pac_resolver_create_with_url";
                id v84 = 2082;
                v85 = v70;
                _os_log_impl( &dword_181A5C000,  v67,  v71,  "%{public}s called with null logging_id_str, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v70);
              if (!v53) {
                goto LABEL_133;
              }
              goto LABEL_132;
            }

            if (v72)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v83 = "nw_pac_resolver_create_with_url";
              _os_log_impl( &dword_181A5C000,  v67,  v71,  "%{public}s called with null logging_id_str, no backtrace",  buf,  0xCu);
            }

            goto LABEL_130;
          }
        }

        else
        {
          __nwlog_obj();
          os_log_type_t v52 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_pac_resolver_create_with_url";
          os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          v80 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            BOOL v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v55 = type;
            if (os_log_type_enabled(v54, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v83 = "nw_pac_resolver_create_with_url";
              _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s called with null context", buf, 0xCu);
            }

            goto LABEL_112;
          }

          if (!v80)
          {
            __nwlog_obj();
            BOOL v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v76 = type;
            if (os_log_type_enabled(v54, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v83 = "nw_pac_resolver_create_with_url";
              _os_log_impl( &dword_181A5C000,  v54,  v76,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
            }

            goto LABEL_112;
          }

          os_log_type_t v66 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v68 = type;
          BOOL v69 = os_log_type_enabled(v67, type);
          if (!v66)
          {
            if (v69)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v83 = "nw_pac_resolver_create_with_url";
              _os_log_impl(&dword_181A5C000, v67, v68, "%{public}s called with null context, no backtrace", buf, 0xCu);
            }

    _Block_object_dispose(&v78, 8);
LABEL_113:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v56 = (char *)handle + 205;
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = (char *)handle + 205;
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)v91 = v9;
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    v82[0] = 16;
    LOBYTE(v78) = 0;
    if (v82[0] == 17)
    {
      BOOL v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = v82[0];
      if (!os_log_type_enabled(v58, (os_log_type_t)v82[0])) {
        goto LABEL_127;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v56;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v91 = v9;
      os_log_type_t v60 = "%{public}s %{public}s failed to create/reuse output frame of length %u";
    }

    else if ((_BYTE)v78)
    {
      v61 = (char *)__nw_create_backtrace_string();
      BOOL v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = v82[0];
      os_log_type_t v62 = os_log_type_enabled(v58, (os_log_type_t)v82[0]);
      if (v61)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v56;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)v91 = v9;
          *(_WORD *)&v91[4] = 2082;
          *(void *)&v91[6] = v61;
          _os_log_impl( &dword_181A5C000,  v58,  v59,  "%{public}s %{public}s failed to create/reuse output frame of length %u, dumping backtrace:%{public}s",  buf,  0x26u);
        }

        free(v61);
        goto LABEL_127;
      }

      if (!v62)
      {
LABEL_127:
        if (v57) {
          free(v57);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v56;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v91 = v9;
      os_log_type_t v60 = "%{public}s %{public}s failed to create/reuse output frame of length %u, no backtrace";
    }

    else
    {
      BOOL v58 = (os_log_s *)__nwlog_obj();
      os_log_type_t v59 = v82[0];
      if (!os_log_type_enabled(v58, (os_log_type_t)v82[0])) {
        goto LABEL_127;
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_transport_get_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v56;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)v91 = v9;
      os_log_type_t v60 = "%{public}s %{public}s failed to create/reuse output frame of length %u, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v58, v59, v60, buf, 0x1Cu);
    goto LABEL_127;
  }

  if (!gLogDatapath) {
    goto LABEL_36;
  }
  uint64_t v31 = (os_log_s *)__nwlog_obj();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)os_log_type_t v82 = 136446722;
    os_log_type_t v83 = "http2_transport_create_output_frame";
    id v84 = 2082;
    v85 = (uint64_t)handle + 205;
    id v86 = 1024;
    LODWORD(v87) = v9;
    _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s allocated new output frame of length %u",  v82,  0x1Cu);
  }

          free(v9);
          goto LABEL_25;
        }

        if (v48)
        {
          *(_DWORD *)buf = 136446722;
          BOOL v54 = "nw_http2_transport_send_goaway";
          os_log_type_t v55 = 2082;
          v56 = a1 + 205;
          os_log_type_t v57 = 1024;
          *(_DWORD *)BOOL v58 = v8;
          os_log_type_t v12 = "%{public}s %{public}s Last stream value %d is even, but we are the server, no backtrace";
LABEL_110:
          _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0x1Cu);
        }
      }
    }

    else
    {
      if ((v8 & 1) == 0) {
        goto LABEL_25;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446722;
      BOOL v54 = "nw_http2_transport_send_goaway";
      os_log_type_t v55 = 2082;
      v56 = a1 + 205;
      os_log_type_t v57 = 1024;
      *(_DWORD *)BOOL v58 = v8;
      os_log_type_t v9 = (void *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v51 = 0;
      if (__nwlog_fault((const char *)v9, &type, &v51))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v10 = (os_log_s *)__nwlog_obj();
          BOOL v11 = type;
          if (!os_log_type_enabled(v10, type)) {
            goto LABEL_111;
          }
          *(_DWORD *)buf = 136446722;
          BOOL v54 = "nw_http2_transport_send_goaway";
          os_log_type_t v55 = 2082;
          v56 = a1 + 205;
          os_log_type_t v57 = 1024;
          *(_DWORD *)BOOL v58 = v8;
          os_log_type_t v12 = "%{public}s %{public}s Last stream value %d is odd, but we are the client";
          goto LABEL_110;
        }

        if (!v51)
        {
          os_log_type_t v10 = (os_log_s *)__nwlog_obj();
          BOOL v11 = type;
          if (!os_log_type_enabled(v10, type)) {
            goto LABEL_111;
          }
          *(_DWORD *)buf = 136446722;
          BOOL v54 = "nw_http2_transport_send_goaway";
          os_log_type_t v55 = 2082;
          v56 = a1 + 205;
          os_log_type_t v57 = 1024;
          *(_DWORD *)BOOL v58 = v8;
          os_log_type_t v12 = "%{public}s %{public}s Last stream value %d is odd, but we are the client, backtrace limit exceeded";
          goto LABEL_110;
        }

        id v45 = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = (os_log_s *)__nwlog_obj();
        BOOL v11 = type;
        v46 = os_log_type_enabled(v10, type);
        if (!v45)
        {
          if (!v46) {
            goto LABEL_111;
          }
          *(_DWORD *)buf = 136446722;
          BOOL v54 = "nw_http2_transport_send_goaway";
          os_log_type_t v55 = 2082;
          v56 = a1 + 205;
          os_log_type_t v57 = 1024;
          *(_DWORD *)BOOL v58 = v8;
          os_log_type_t v12 = "%{public}s %{public}s Last stream value %d is odd, but we are the client, no backtrace";
          goto LABEL_110;
        }

        if (v46)
        {
          *(_DWORD *)buf = 136446978;
          BOOL v54 = "nw_http2_transport_send_goaway";
          os_log_type_t v55 = 2082;
          v56 = a1 + 205;
          os_log_type_t v57 = 1024;
          *(_DWORD *)BOOL v58 = v8;
          *(_WORD *)&v58[4] = 2082;
          *(void *)&v58[6] = v45;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s %{public}s Last stream value %d is odd, but we are the client, dumping backtrace:%{public}s",  buf,  0x26u);
        }

        free(v45);
      }
    }

    if (v37) {
      free(v37);
    }
    return 0LL;
  }

  if (gLogDatapath)
  {
    os_log_type_t v41 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      id v42 = *(_DWORD *)(a2 + 32);
      *(_DWORD *)buf = 136446978;
      os_log_type_t v64 = "nw_http2_transport_stream_connect";
      v65 = 2082;
      os_log_type_t v66 = a1 + 205;
      BOOL v67 = 1024;
      *(_DWORD *)os_log_type_t v68 = v42;
      *(_WORD *)&v68[4] = 2048;
      *(void *)&v68[6] = a2;
      _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s called for stream %d (%p)",  buf,  0x26u);
    }
  }

  if ((*(_BYTE *)(a2 + 36) & 1) != 0)
  {
    if (gLogDatapath)
    {
      nw_endpoint_t v49 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v50 = *(_DWORD *)(a2 + 32);
        *(_DWORD *)buf = 136446722;
        os_log_type_t v64 = "nw_http2_transport_stream_connect";
        v65 = 2082;
        os_log_type_t v66 = a1 + 205;
        BOOL v67 = 1024;
        *(_DWORD *)os_log_type_t v68 = v50;
        _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s stream %d is already connected",  buf,  0x1Cu);
      }
    }

    os_log_type_t v12 = *(void *)(a3 + 24);
    if (v12)
    {
      id v13 = *(void (**)(uint64_t, uint64_t))(v12 + 40);
      if (v13)
      {
        v13(a3, a1);
        return 1LL;
      }
    }

    __nwlog_obj();
    __int16 v43 = *(const char **)(a3 + 16);
    if (!v43) {
      __int16 v43 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v64 = "nw_http2_transport_stream_connect";
    v65 = 2082;
    os_log_type_t v66 = (uint64_t)v43;
    id v44 = (char *)_os_log_send_and_compose_impl();
    v62[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v44, v62, &type))
    {
      if (v62[0] == OS_LOG_TYPE_FAULT)
      {
        id v45 = (os_log_s *)__nwlog_obj();
        v46 = v62[0];
        if (!os_log_type_enabled(v45, v62[0])) {
          goto LABEL_120;
        }
        v47 = *(const char **)(a3 + 16);
        if (!v47) {
          v47 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v64 = "nw_http2_transport_stream_connect";
        v65 = 2082;
        os_log_type_t v66 = (uint64_t)v47;
        v48 = "%{public}s protocol %{public}s has invalid connected callback";
        goto LABEL_119;
      }

      if (type == OS_LOG_TYPE_DEFAULT)
      {
        id v45 = (os_log_s *)__nwlog_obj();
        v46 = v62[0];
        if (!os_log_type_enabled(v45, v62[0])) {
          goto LABEL_120;
        }
        BOOL v58 = *(const char **)(a3 + 16);
        if (!v58) {
          BOOL v58 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v64 = "nw_http2_transport_stream_connect";
        v65 = 2082;
        os_log_type_t v66 = (uint64_t)v58;
        v48 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_119;
      }

      os_log_type_t v53 = (char *)__nw_create_backtrace_string();
      id v45 = (os_log_s *)__nwlog_obj();
      v46 = v62[0];
      BOOL v54 = os_log_type_enabled(v45, v62[0]);
      if (v53)
      {
        if (v54)
        {
          os_log_type_t v55 = *(const char **)(a3 + 16);
          if (!v55) {
            os_log_type_t v55 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v64 = "nw_http2_transport_stream_connect";
          v65 = 2082;
          os_log_type_t v66 = (uint64_t)v55;
          BOOL v67 = 2082;
          *(void *)os_log_type_t v68 = v53;
          _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v53);
        goto LABEL_120;
      }

      if (v54)
      {
        os_log_type_t v59 = *(const char **)(a3 + 16);
        if (!v59) {
          os_log_type_t v59 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v64 = "nw_http2_transport_stream_connect";
        v65 = 2082;
        os_log_type_t v66 = (uint64_t)v59;
        v48 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_119:
        _os_log_impl(&dword_181A5C000, v45, v46, v48, buf, 0x16u);
      }
    }

  v73 = *(void *)(v12 + 488);
  if (!v73)
  {
    if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v77 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    os_log_type_t v78 = *(void *)(v12 + 488);
    os_log_type_t v79 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
    v80 = *(_DWORD *)(v12 + 860);
    if (v78) {
      LODWORD(v78) = *(_DWORD *)(v78 + 424);
    }
    *(_DWORD *)buf = 136447746;
    *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v12 + 74;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&buf[24] = " ";
    *(_WORD *)&buf[32] = 1024;
    *(_DWORD *)&buf[34] = v79;
    *(_WORD *)&buf[38] = 1024;
    *(_DWORD *)&buf[40] = v80;
    *(_WORD *)v236 = 1024;
    *(_DWORD *)&v236[2] = v78;
    *(_WORD *)&v236[6] = 1024;
    *(_DWORD *)&v236[8] = a3;
    id v18 = "%{public}s %{public}s%s<i%u:c%u:s%u> not passing up error %d, no stream";
    id v19 = (os_log_s *)v77;
    int v20 = OS_LOG_TYPE_DEBUG;
    __int16 v21 = 56;
    goto LABEL_27;
  }

  if (((*v26 | (*((unsigned __int8 *)v26 + 2) << 16)) & 0x10004) != 0)
  {
    if ((*(_BYTE *)(v12 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v22 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        v74 = *(void *)(v12 + 488);
        v75 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
        os_log_type_t v76 = *(_DWORD *)(v12 + 860);
        if (v74) {
          LODWORD(v74) = *(_DWORD *)(v74 + 424);
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v12 + 74;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = " ";
        *(_WORD *)&buf[32] = 1024;
        *(_DWORD *)&buf[34] = v75;
        *(_WORD *)&buf[38] = 1024;
        *(_DWORD *)&buf[40] = v76;
        *(_WORD *)v236 = 1024;
        *(_DWORD *)&v236[2] = v74;
        id v18 = "%{public}s %{public}s%s<i%u:c%u:s%u> not passing up error because stream finished";
        goto LABEL_119;
      }
    }
  }

  else
  {
    if ((*(_BYTE *)(v12 + 158) & 1) != 0) {
      goto LABEL_145;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v95 = (os_log_s *)gLogObj;
    v96 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
    v73 = *(void *)(v12 + 488);
    if (v96)
    {
      v97 = *(_DWORD *)(*(void *)(v12 + 480) + 372LL);
      v98 = *(_DWORD *)(v12 + 860);
      if (v73) {
        LODWORD(v73) = *(_DWORD *)(v73 + 424);
      }
      *(_DWORD *)buf = 136447746;
      *(void *)&uint8_t buf[4] = "nw_protocol_http1_error";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v12 + 74;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = " ";
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v97;
      *(_WORD *)&buf[38] = 1024;
      *(_DWORD *)&buf[40] = v98;
      *(_WORD *)v236 = 1024;
      *(_DWORD *)&v236[2] = v73;
      *(_WORD *)&v236[6] = 1024;
      *(_DWORD *)&v236[8] = a3;
      _os_log_impl( &dword_181A5C000,  v95,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> passing up error: %d",  buf,  0x38u);
      v73 = *(void *)(v12 + 488);
    }

    if (v73) {
LABEL_145:
    }
      v99 = *(void **)(v73 + 48);
    else {
      v99 = 0LL;
    }
    nw_protocol_error(v99, (uint64_t)v5);
  }

    if (v27) {
      free(v27);
    }
LABEL_114:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_protocol_http1_copy_info";
    BOOL v35 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v36 = (os_log_s *)gLogObj;
      id v37 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_129;
      }
      *(_DWORD *)buf = 136446210;
      v47 = "nw_protocol_http1_copy_info";
      id v38 = "%{public}s called with null http1_stream";
      goto LABEL_128;
    }

    if (!v44)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v36 = (os_log_s *)gLogObj;
      id v37 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_129;
      }
      *(_DWORD *)buf = 136446210;
      v47 = "nw_protocol_http1_copy_info";
      id v38 = "%{public}s called with null http1_stream, backtrace limit exceeded";
      goto LABEL_128;
    }

    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v36 = (os_log_s *)gLogObj;
    id v37 = type;
    id v42 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v41)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "nw_protocol_http1_copy_info";
        v48 = 2082;
        nw_endpoint_t v49 = v41;
        _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s called with null http1_stream, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v41);
      if (!v35) {
        return 0LL;
      }
      goto LABEL_130;
    }

    if (v42)
    {
      *(_DWORD *)buf = 136446210;
      v47 = "nw_protocol_http1_copy_info";
      id v38 = "%{public}s called with null http1_stream, no backtrace";
LABEL_128:
      _os_log_impl(&dword_181A5C000, v36, v37, v38, buf, 0xCu);
      goto LABEL_129;
    }

    goto LABEL_129;
  }

  os_log_type_t v10 = (uint64_t *)(v2 + 8);
LABEL_16:
  BOOL v11 = *v10;
  if (!*v10) {
    goto LABEL_114;
  }
  if (a2 == 253) {
    return *(void *)(v8 + 328);
  }
  id v13 = *(void *)(v11 + 256);
  if (v13)
  {
    id v14 = nw_protocol_common_copy_info(v13, a2);
    os_log_type_t v12 = v14;
    if (a2 != 255) {
      return v12;
    }
    if (v14) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  if (a2 != 255) {
    return 0LL;
  }
LABEL_24:
  os_log_type_t v12 = nw_array_create();
LABEL_25:
  id v15 = *(void *)(v11 + 256);
  if (v15)
  {
    int v16 = *(void **)(v15 + 768);
    if (v16) {
      nw_array_append(v12, v16);
    }
  }

  __int16 v17 = *(void **)(v11 + 352);
  if (v17) {
    nw_array_append(v12, v17);
  }
  return v12;
}

        free(v68);
        if (!v51)
        {
LABEL_48:
          if (!*(void *)(v2 + 488))
          {
            __int16 v40 = *(void *)(v2 + 784);
            if (v40)
            {
              if (*(void *)v40)
              {
                dispatch_source_set_timer( *(dispatch_source_t *)v40,  0x8000000000000000LL,  0xFFFFFFFFFFFFFFFFLL,  0x3B9ACA00uLL);
              }

              else
              {
                *(_OWORD *)(v40 + 32) = xmmword_18272D790;
                if (*(_BYTE *)(v40 + 48) && *(_BYTE *)(v40 + 49)) {
                  nw_queue_source_run_timer(v40, a2);
                }
              }
            }

            else
            {
              if ((*(_BYTE *)(v2 + 158) & 1) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v41 = (os_log_s *)gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  id v42 = *(void *)(v2 + 488);
                  __int16 v43 = *(_DWORD *)(*(void *)(v2 + 480) + 372LL);
                  id v44 = *(_DWORD *)(v2 + 860);
                  if (v42) {
                    LODWORD(v42) = *(_DWORD *)(v42 + 424);
                  }
                  *(_DWORD *)buf = 136447490;
                  *(void *)&uint8_t buf[4] = "nw_http1_connection_close";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = v2 + 74;
                  *(_WORD *)&buf[22] = 2080;
                  os_log_type_t v76 = (uint64_t)" ";
                  *(_WORD *)os_log_type_t v77 = 1024;
                  *(_DWORD *)&v77[2] = v43;
                  *(_WORD *)&v77[6] = 1024;
                  *(_DWORD *)&v77[8] = v44;
                  LOWORD(v78) = 1024;
                  *(_DWORD *)((char *)&v78 + 2) = v42;
                  _os_log_impl( &dword_181A5C000,  v41,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u:c%u:s%u> No destroy timer on HTTP/1 connection when closing",  buf,  0x32u);
                }
              }

              id v45 = *(void *)(v2 + 608);
              v46 = *(void **)(v2 + 496);
              *(void *)buf = MEMORY[0x1895F87A8];
              *(void *)&buf[8] = 0x40000000LL;
              *(void *)&buf[16] = ___ZL25nw_http1_connection_closeP19nw_http1_connection_block_invoke;
              os_log_type_t v76 = (uint64_t)&unk_189BBD518;
              *(void *)os_log_type_t v77 = v45;
              nw_queue_context_async(v46, buf);
            }
          }

        if (v23) {
          free(v23);
        }
        id v13 = 0LL;
        goto LABEL_13;
      }

      if (!v48)
      {
        os_log_type_t v24 = (os_log_s *)__nwlog_obj();
        char v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      char v25 = type;
      uint64_t v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "_http_safe_append";
        os_log_type_t v52 = 2082;
        os_log_type_t v53 = backtrace_string;
        id v37 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_181A5C000, v24, v25, v37, buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_112;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v51 = "_http_vle_encode";
  os_log_type_t v52 = 2048;
  os_log_type_t v53 = (const char *)v5;
  __int16 v17 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v17))
  {
    __break(1u);
    return;
  }

  free(v17);
  id v18 = *(void *)(a1 + 32);
  uint64_t v7 = (void *)(a1 + 32);
  id v13 = *(char **)(*(void *)(v18 + 8) + 24LL);
  os_log_type_t v10 = v7 + 1;
LABEL_13:
  *(void *)(*(void *)(*v7 + 8LL) + 24LL) = v13;
  id v14 = *(char **)(*(void *)(*v7 + 8LL) + 24LL);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_http_fillout_binary_message_inner_block_invoke";
    id v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      __int16 v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      int v22 = "%{public}s called with null cursor";
    }

    else
    {
      if (!v48)
      {
        int v20 = (os_log_s *)__nwlog_obj();
        __int16 v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        v51 = "nw_http_fillout_binary_message_inner_block_invoke";
        int v22 = "%{public}s called with null cursor, backtrace limit exceeded";
        goto LABEL_100;
      }

      uint64_t v31 = (char *)__nw_create_backtrace_string();
      int v20 = (os_log_s *)__nwlog_obj();
      __int16 v21 = type;
      char v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_http_fillout_binary_message_inner_block_invoke";
          os_log_type_t v52 = 2082;
          os_log_type_t v53 = v31;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v31);
        if (v19) {
          goto LABEL_102;
        }
        return;
      }

      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      int v22 = "%{public}s called with null cursor, no backtrace";
    }

        if (v23) {
          free(v23);
        }
        id v13 = 0LL;
        goto LABEL_13;
      }

      if (!v48)
      {
        os_log_type_t v24 = (os_log_s *)__nwlog_obj();
        char v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      char v25 = type;
      uint64_t v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "_http_safe_append";
        os_log_type_t v52 = 2082;
        os_log_type_t v53 = backtrace_string;
        id v37 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_181A5C000, v24, v25, v37, buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_112;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v51 = "_http_vle_encode";
  os_log_type_t v52 = 2048;
  os_log_type_t v53 = (const char *)v5;
  __int16 v17 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v17))
  {
    __break(1u);
    return;
  }

  free(v17);
  id v18 = *(void *)(a1 + 32);
  uint64_t v7 = (void *)(a1 + 32);
  id v13 = *(char **)(*(void *)(v18 + 8) + 24LL);
  os_log_type_t v10 = v7 + 1;
LABEL_13:
  *(void *)(*(void *)(*v7 + 8LL) + 24LL) = v13;
  id v14 = *(char **)(*(void *)(*v7 + 8LL) + 24LL);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_http_fillout_binary_message_inner_block_invoke";
    id v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      __int16 v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      int v22 = "%{public}s called with null cursor";
    }

    else
    {
      if (!v48)
      {
        int v20 = (os_log_s *)__nwlog_obj();
        __int16 v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        v51 = "nw_http_fillout_binary_message_inner_block_invoke";
        int v22 = "%{public}s called with null cursor, backtrace limit exceeded";
        goto LABEL_100;
      }

      uint64_t v31 = (char *)__nw_create_backtrace_string();
      int v20 = (os_log_s *)__nwlog_obj();
      __int16 v21 = type;
      char v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_http_fillout_binary_message_inner_block_invoke";
          os_log_type_t v52 = 2082;
          os_log_type_t v53 = v31;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v31);
        if (v19) {
          goto LABEL_102;
        }
        return;
      }

      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      int v22 = "%{public}s called with null cursor, no backtrace";
    }

        if (v23) {
          free(v23);
        }
        id v13 = 0LL;
        goto LABEL_13;
      }

      if (!v48)
      {
        os_log_type_t v24 = (os_log_s *)__nwlog_obj();
        char v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      char v25 = type;
      uint64_t v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "_http_safe_append";
        os_log_type_t v52 = 2082;
        os_log_type_t v53 = backtrace_string;
        id v37 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_181A5C000, v24, v25, v37, buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_112;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v51 = "_http_vle_encode";
  os_log_type_t v52 = 2048;
  os_log_type_t v53 = (const char *)v5;
  __int16 v17 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v17))
  {
    __break(1u);
    return;
  }

  free(v17);
  id v18 = *(void *)(a1 + 32);
  uint64_t v7 = (void *)(a1 + 32);
  id v13 = *(char **)(*(void *)(v18 + 8) + 24LL);
  os_log_type_t v10 = v7 + 1;
LABEL_13:
  *(void *)(*(void *)(*v7 + 8LL) + 24LL) = v13;
  id v14 = *(char **)(*(void *)(*v7 + 8LL) + 24LL);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_http_fillout_binary_message_inner_block_invoke";
    id v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      __int16 v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      int v22 = "%{public}s called with null cursor";
    }

    else
    {
      if (!v48)
      {
        int v20 = (os_log_s *)__nwlog_obj();
        __int16 v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        v51 = "nw_http_fillout_binary_message_inner_block_invoke";
        int v22 = "%{public}s called with null cursor, backtrace limit exceeded";
        goto LABEL_100;
      }

      uint64_t v31 = (char *)__nw_create_backtrace_string();
      int v20 = (os_log_s *)__nwlog_obj();
      __int16 v21 = type;
      char v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_http_fillout_binary_message_inner_block_invoke";
          os_log_type_t v52 = 2082;
          os_log_type_t v53 = v31;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v31);
        if (v19) {
          goto LABEL_102;
        }
        return;
      }

      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      int v22 = "%{public}s called with null cursor, no backtrace";
    }

        if (v23) {
          free(v23);
        }
        id v13 = 0LL;
        goto LABEL_13;
      }

      if (!v48)
      {
        os_log_type_t v24 = (os_log_s *)__nwlog_obj();
        char v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v24 = (os_log_s *)__nwlog_obj();
      char v25 = type;
      uint64_t v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "_http_safe_append";
        os_log_type_t v52 = 2082;
        os_log_type_t v53 = backtrace_string;
        id v37 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_181A5C000, v24, v25, v37, buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_112;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v51 = "_http_vle_encode";
  os_log_type_t v52 = 2048;
  os_log_type_t v53 = (const char *)v5;
  __int16 v17 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v17))
  {
    __break(1u);
    return;
  }

  free(v17);
  id v18 = *(void *)(a1 + 32);
  uint64_t v7 = (void *)(a1 + 32);
  id v13 = *(char **)(*(void *)(v18 + 8) + 24LL);
  os_log_type_t v10 = v7 + 1;
LABEL_13:
  *(void *)(*(void *)(*v7 + 8LL) + 24LL) = v13;
  id v14 = *(char **)(*(void *)(*v7 + 8LL) + 24LL);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_http_fillout_binary_message_inner_block_invoke";
    id v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v20 = (os_log_s *)__nwlog_obj();
      __int16 v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      int v22 = "%{public}s called with null cursor";
    }

    else
    {
      if (!v48)
      {
        int v20 = (os_log_s *)__nwlog_obj();
        __int16 v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        v51 = "nw_http_fillout_binary_message_inner_block_invoke";
        int v22 = "%{public}s called with null cursor, backtrace limit exceeded";
        goto LABEL_100;
      }

      uint64_t v31 = (char *)__nw_create_backtrace_string();
      int v20 = (os_log_s *)__nwlog_obj();
      __int16 v21 = type;
      char v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_http_fillout_binary_message_inner_block_invoke";
          os_log_type_t v52 = 2082;
          os_log_type_t v53 = v31;
          _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v31);
        if (v19) {
          goto LABEL_102;
        }
        return;
      }

      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      int v22 = "%{public}s called with null cursor, no backtrace";
    }

          int v6 = 3LL;
          if (!a2) {
            goto LABEL_114;
          }
          goto LABEL_113;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v59 = 0;
        if (__nwlog_fault(v23, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v24 = (os_log_s *)(id)gLogObj;
            char v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s nw_path_evaluator_copy_path failed", buf, 0xCu);
            }
          }

          else if (v59)
          {
            id v38 = __nw_create_backtrace_string();
            if (v38)
            {
              char v39 = (char *)v38;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v40 = (os_log_s *)(id)gLogObj;
              os_log_type_t v41 = type;
              if (os_log_type_enabled(v40, type))
              {
                *(_DWORD *)buf = 136446466;
                os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
                char v63 = 2082;
                *(void *)os_log_type_t v64 = v39;
                _os_log_impl( &dword_181A5C000,  v40,  v41,  "%{public}s nw_path_evaluator_copy_path failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v39);
              if (!v23) {
                goto LABEL_93;
              }
              goto LABEL_92;
            }

            __nwlog_obj();
            os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v55 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl( &dword_181A5C000,  v24,  v55,  "%{public}s nw_path_evaluator_copy_path failed, no backtrace",  buf,  0xCu);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v24 = (os_log_s *)(id)gLogObj;
            os_log_type_t v52 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl( &dword_181A5C000,  v24,  v52,  "%{public}s nw_path_evaluator_copy_path failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

        if (!v23)
        {
LABEL_93:
          int v6 = 4LL;
LABEL_116:

          return v6;
        }

        free(v47);
        goto LABEL_57;
      }

      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_181A5C000, v48, v54, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v61 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl( &dword_181A5C000,  v48,  v61,  "%{public}s called with null definition, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    if (v35)
    {
      if (v22)
      {
        if (v35 < v22)
        {
          if (v22 - v35 < (unint64_t)a5 + 5)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v68 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            v171 = "nw_necp_append_tlv";
            v172 = 2048;
            *(void *)v173 = v35;
            *(_WORD *)&v173[8] = 2048;
            *(void *)&v173[10] = a5 + 5LL;
            *(_WORD *)&v173[18] = 2048;
            *(void *)v174 = v22;
            *(_WORD *)&v174[8] = 1024;
            *(_DWORD *)v175 = 102;
            *(_WORD *)&v175[4] = 1024;
            *(_DWORD *)&v175[6] = a5;
            BOOL v69 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            v165 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v70 = (os_log_s *)(id)gLogObj;
              os_log_type_t v71 = type;
              if (os_log_type_enabled(v70, type))
              {
                *(_DWORD *)buf = 136447490;
                v171 = "nw_necp_append_tlv";
                v172 = 2048;
                *(void *)v173 = v35;
                *(_WORD *)&v173[8] = 2048;
                *(void *)&v173[10] = a5 + 5LL;
                *(_WORD *)&v173[18] = 2048;
                *(void *)v174 = v22;
                *(_WORD *)&v174[8] = 1024;
                *(_DWORD *)v175 = 102;
                *(_WORD *)&v175[4] = 1024;
                *(_DWORD *)&v175[6] = a5;
                _os_log_impl( &dword_181A5C000,  v70,  v71,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
              }
            }

            else
            {
              if (v165)
              {
                BOOL v72 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v73 = (os_log_s *)(id)gLogObj;
                v74 = type;
                v75 = os_log_type_enabled(v73, type);
                if (v72)
                {
                  if (v75)
                  {
                    *(_DWORD *)buf = 136447746;
                    v171 = "nw_necp_append_tlv";
                    v172 = 2048;
                    *(void *)v173 = v35;
                    *(_WORD *)&v173[8] = 2048;
                    *(void *)&v173[10] = __n + 5;
                    *(_WORD *)&v173[18] = 2048;
                    *(void *)v174 = v22;
                    *(_WORD *)&v174[8] = 1024;
                    *(_DWORD *)v175 = 102;
                    *(_WORD *)&v175[4] = 1024;
                    *(_DWORD *)&v175[6] = v161;
                    v176 = 2082;
                    v177 = v72;
                    _os_log_impl( &dword_181A5C000,  v73,  v74,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping bac ktrace:%{public}s",  buf,  0x40u);
                  }

                  free(v72);
                  if (!v69)
                  {
LABEL_137:
                    BOOL v35 = 0LL;
                    os_log_type_t v50 = v15;
                    nw_endpoint_t v49 = v164;
                    v51 = v163;
                    if (!v164) {
                      goto LABEL_138;
                    }
                    goto LABEL_72;
                  }

  __break(1u);
  return result;
}

          if (!*((void *)v305 + 3)) {
            goto LABEL_147;
          }
          v97 = http2_create_input_frame((uint64_t)handle, v14, 0LL);
          metadata_for_capsule = nw_http_create_metadata_for_capsule(v290[3], *((void **)v305 + 3));
          nw_frame_set_metadata(v97, (nw_protocol_metadata *)metadata_for_capsule, 1, 1);
          if (metadata_for_capsule) {
            os_release(metadata_for_capsule);
          }
          *(void *)(v97 + 32) = 0LL;
          v99 = a6->tqh_last;
          *(void *)(v97 + 40) = v99;
          *v99 = (nw_frame *)v97;
          a6->tqh_last = (nw_frame **)(v97 + 32);
          v100 = *((unsigned int *)v313 + 6) + 1LL;
          v101 = v100 << 31 >> 31;
          *((_DWORD *)v313 + 6) = v100;
          if (v101 != v100 || v101 < 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v102 = *((unsigned int *)v313 + 6);
            *(_DWORD *)buf = 136446978;
            v317 = "nw_protocol_http2_get_input_frames";
            v318 = 2082;
            v319 = "return_frame_count";
            v320 = 2048;
            v321 = 1LL;
            v322 = 2048;
            *(void *)v323 = v102;
            v103 = (char *)_os_log_send_and_compose_impl();
            v265[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v261) = 0;
            if (v265[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v104 = gLogObj;
              v105 = v265[0];
              if (os_log_type_enabled((os_log_t)gLogObj, v265[0]))
              {
                v106 = *((unsigned int *)v313 + 6);
                *(_DWORD *)buf = 136446978;
                v317 = "nw_protocol_http2_get_input_frames";
                v318 = 2082;
                v319 = "return_frame_count";
                v320 = 2048;
                v321 = 1LL;
                v322 = 2048;
                *(void *)v323 = v106;
                v107 = (os_log_s *)v104;
                v108 = v105;
                v109 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
                goto LABEL_137;
              }

              goto LABEL_138;
            }

            if ((_BYTE)v261)
            {
              v110 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v111 = (os_log_s *)gLogObj;
              v112 = v265[0];
              v113 = os_log_type_enabled((os_log_t)gLogObj, v265[0]);
              if (v110)
              {
                if (v113)
                {
                  v114 = *((unsigned int *)v313 + 6);
                  *(_DWORD *)buf = 136447234;
                  v317 = "nw_protocol_http2_get_input_frames";
                  v318 = 2082;
                  v319 = "return_frame_count";
                  v320 = 2048;
                  v321 = 1LL;
                  v322 = 2048;
                  *(void *)v323 = v114;
                  *(_WORD *)&v323[8] = 2082;
                  *(void *)&v323[10] = v110;
                  _os_log_impl( &dword_181A5C000,  v111,  v112,  "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
                }

                free(v110);
                goto LABEL_138;
              }

              if (!v113)
              {
LABEL_138:
                if (v103) {
                  free(v103);
                }
                *((_DWORD *)v313 + 6) = -1;
                id v15 = MEMORY[0x1895F87A8];
                goto LABEL_141;
              }

              v126 = *((unsigned int *)v313 + 6);
              *(_DWORD *)buf = 136446978;
              v317 = "nw_protocol_http2_get_input_frames";
              v318 = 2082;
              v319 = "return_frame_count";
              v320 = 2048;
              v321 = 1LL;
              v322 = 2048;
              *(void *)v323 = v126;
              v107 = v111;
              v108 = v112;
              v109 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v120 = gLogObj;
              v121 = v265[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, v265[0])) {
                goto LABEL_138;
              }
              v122 = *((unsigned int *)v313 + 6);
              *(_DWORD *)buf = 136446978;
              v317 = "nw_protocol_http2_get_input_frames";
              v318 = 2082;
              v319 = "return_frame_count";
              v320 = 2048;
              v321 = 1LL;
              v322 = 2048;
              *(void *)v323 = v122;
              v107 = (os_log_s *)v120;
              v108 = v121;
              v109 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            }

LABEL_122:
    if (v74) {
      free(v74);
    }
    goto LABEL_35;
  }

  *((_BYTE *)v47 + 34) |= 2u;
  nw_endpoint_t v49 = nw_endpoint_handler_copy_endpoint(v46);
  os_log_type_t v50 = (void *)v48[121];
  v48[121] = v49;

LABEL_35:
LABEL_37:
  v51 = v33;
LABEL_52:

LABEL_53:
  return v33;
}

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v101 = (id)gLogObj;
  v92 = v2;
  if (mode > 5) {
    v102 = "unknown-mode";
  }
  else {
    v102 = off_189BBBBC0[mode];
  }
  *(_DWORD *)buf = 136446722;
  v166 = "nw_endpoint_flow_connected_path_change";
  v167 = 2082;
  v168 = (void *)v102;
  v169 = 2082;
  v170 = "flow";
  v103 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  v163 = 0;
  if (!__nwlog_fault((const char *)v103, &type, &v163))
  {
LABEL_154:
    if (!v103) {
      goto LABEL_156;
    }
LABEL_155:
    free(v103);
    goto LABEL_156;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v104 = (os_log_s *)(id)gLogObj;
    v105 = type;
    if (os_log_type_enabled(v104, type))
    {
      if (mode > 5) {
        v106 = "unknown-mode";
      }
      else {
        v106 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      v166 = "nw_endpoint_flow_connected_path_change";
      v167 = 2082;
      v168 = (void *)v106;
      v169 = 2082;
      v170 = "flow";
      _os_log_impl( &dword_181A5C000,  v104,  v105,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

LABEL_123:
      if (v45) {
        free(v45);
      }
      goto LABEL_18;
    }

    if (!v69)
    {
      __nwlog_obj();
      v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v72 = "nw_write_request_create";
        _os_log_impl( &dword_181A5C000,  v46,  v62,  "%{public}s called with null context, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_122;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    v56 = type;
    os_log_type_t v57 = os_log_type_enabled(v46, type);
    if (!backtrace_string)
    {
      if (v57)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v72 = "nw_write_request_create";
        _os_log_impl(&dword_181A5C000, v46, v56, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }

      goto LABEL_122;
    }

    if (v57)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v72 = "nw_write_request_create";
      v73 = 2082;
      v74 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v46,  v56,  "%{public}s called with null context, dumping backtrace:%{public}s",  buf,  0x16u);
    }

  if (v46) {
    free(v46);
  }
LABEL_18:
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  output_handler = a1->output_handler;
  if (output_handler)
  {
    id v14 = output_handler->callbacks;
    if (v14)
    {
      remove_input_handler = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v14->remove_input_handler;
      if (remove_input_handler)
      {
        int v16 = output_handler->handle;
        if (v16 == &nw_protocol_ref_counted_handle)
        {
          __int16 v17 = output_handler[1].callbacks;
          if (v17) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v17->add_input_handler + 1);
          }
        }

        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          id v18 = a1[1].callbacks;
          if (v18) {
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
          }
          remove_input_handler(output_handler, a1, a3);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            id v33 = a1[1].callbacks;
            if (v33)
            {
              __int16 v34 = (nw_protocol_callbacks *)((char *)v33 - 1);
              a1[1].callbacks = v34;
              if (!v34)
              {
                BOOL v35 = *(void (***)(void))a1[1].flow_id;
                if (v35)
                {
                  *(void *)a1[1].flow_id = 0LL;
                  v35[2](v35);
                  _Block_release(v35);
                }

                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  uint64_t v36 = *(const void **)a1[1].flow_id;
                  if (v36) {
                    _Block_release(v36);
                  }
                }

                free(a1);
              }
            }
          }
        }

        else
        {
          remove_input_handler(output_handler, a1, a3);
        }

        if (v16 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          id v37 = output_handler[1].callbacks;
          if (v37)
          {
            id v38 = (nw_protocol_callbacks *)((char *)v37 - 1);
            output_handler[1].callbacks = v38;
            if (!v38)
            {
              char v39 = *(void (***)(void))output_handler[1].flow_id;
              if (v39)
              {
                *(void *)output_handler[1].flow_id = 0LL;
                v39[2](v39);
                _Block_release(v39);
              }

              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                __int16 v40 = *(const void **)output_handler[1].flow_id;
                if (v40) {
                  _Block_release(v40);
                }
              }

              free(output_handler);
            }
          }
        }
      }
    }
  }

  nw_protocol_ip_register_segmentation_offload_notification(a1, 0);
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v29 = default_input_handler[1].callbacks;
      if (v29)
      {
        char v30 = (nw_protocol_callbacks *)((char *)v29 - 1);
        default_input_handler[1].callbacks = v30;
        if (!v30)
        {
          uint64_t v31 = *(void (***)(void))default_input_handler[1].flow_id;
          if (v31)
          {
            *(void *)default_input_handler[1].flow_id = 0LL;
            v31[2](v31);
            _Block_release(v31);
          }

          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            char v32 = *(const void **)default_input_handler[1].flow_id;
            if (v32) {
              _Block_release(v32);
            }
          }

          free(default_input_handler);
        }
      }
    }

    a1->default_input_handler = 0LL;
  }

  if ((_DWORD)a3)
  {
    while (1)
    {
      int v20 = a1[2].output_handler;
      if (!v20) {
        break;
      }
      __int16 v21 = v20->output_handler;
      int v22 = v20->handle;
      if (v21)
      {
        v21->handle = v22;
        int v22 = v20->handle;
      }

      else
      {
        a1[2].handle = v22;
      }

      *int v22 = v21;
      v20->output_handler = 0LL;
      v20->handle = 0LL;
      nw_frame_finalize((uint64_t)v20);
    }

    while (1)
    {
      uint64_t v23 = p_output_handler[10];
      if (!v23) {
        break;
      }
      identifier = v23->identifier;
      char v25 = (nw_protocol *)v23->callbacks;
      if (identifier)
      {
        *(void *)&identifier->name[24] = v25;
        char v25 = (nw_protocol *)v23->callbacks;
      }

      else
      {
        p_output_handler[11] = v25;
      }

      *(void *)v25->flow_id = identifier;
      v23->identifier = 0LL;
      v23->callbacks = 0LL;
      nw_frame_free_buffer((uint64_t)v23);
      os_release(v23);
    }

    while (1)
    {
      id v26 = p_output_handler[12];
      if (!v26) {
        break;
      }
      id v27 = v26->identifier;
      id v28 = (nw_protocol *)v26->callbacks;
      if (v27)
      {
        *(void *)&v27->name[24] = v28;
        id v28 = (nw_protocol *)v26->callbacks;
      }

      else
      {
        p_output_handler[13] = v28;
      }

      *(void *)v28->flow_id = v27;
      v26->identifier = 0LL;
      v26->callbacks = 0LL;
      nw_frame_free_buffer((uint64_t)v26);
      os_release(v26);
    }

    nw_protocol_destroy((uint64_t)p_output_handler, 0LL);
  }

  return 1LL;
}

        if (v44) {
          free(v44);
        }
        return 0LL;
      }
    }

    *(void *)(*(void *)(a1 + 64) + 8LL) = v20;
    goto LABEL_44;
  }

  if (!gLogDatapath) {
    return 0LL;
  }
  uint64_t v29 = (os_log_s *)__nwlog_obj();
  uint64_t result = os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *(_DWORD *)buf = 136446210;
    v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
    _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s skipping partial frame, split frames not allowed",  buf,  0xCu);
    return 0LL;
  }

  return result;
}

  if (v26) {
    free(v26);
  }

LABEL_125:
  if (!nw_parameters_get_logging_disabled(*((void *)v6 + 7)))
  {
    if (__nwlog_connection_group_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
    }
    os_log_type_t v10 = (dispatch_queue_s *)(id)gconnection_groupLogObj;
    if (os_log_type_enabled((os_log_t)v10, OS_LOG_TYPE_ERROR))
    {
      char v63 = *((_DWORD *)v6 + 42);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_group_add_connection_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v63;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v10,  OS_LOG_TYPE_ERROR,  "%{public}s [G%u] Cannot copy workloop, cannot add connection",  buf,  0x12u);
    }

    goto LABEL_130;
  }

                return;
              case 0x15u:
                if (a4 && a5 == 1)
                {
                  os_log_type_t v41 = *a4;
                  if (v41 || (unint64_t)(*((void *)v13 + 48) + 1LL) < 2)
                  {
                    id v42 = *((void *)v13 + 1);
                    __int16 v43 = *(void *)(v42 + 80);
                    if (v43 && *(void *)(v43 + 112))
                    {
                      if ((v13[405] & 0x80000000) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        id v44 = (os_log_s *)(id)gLogObj;
                        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
                        {
                          id v45 = " not";
                          *(_DWORD *)buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_notify";
                          v137 = v13 + 407;
                          v138 = 2080;
                          v139 = " ";
                          v136 = 2082;
                          if (v41) {
                            id v45 = "";
                          }
                          v140 = 2082;
                          v141 = v45;
                          _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sOutbound data is%{public}s pending",  buf,  0x2Au);
                        }

                        id v42 = *((void *)v13 + 1);
                      }

                      v13[403] &= ~0x80u;
                      (*(void (**)(char *, BOOL))(*(void *)(v42 + 80) + 112LL))(v13, v41 != 0);
                    }
                  }

                  else
                  {
                    if ((v13[405] & 0x80000000) == 0)
                    {
                      __nwlog_obj();
                      char v63 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_notify";
                        v136 = 2082;
                        v137 = v13 + 407;
                        v138 = 2080;
                        v139 = " ";
                        _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sOutbound data is not pending, deferring until current flow is done with connected",  buf,  0x20u);
                      }
                    }

                    os_log_type_t v64 = v13[403] | 0x80;
LABEL_121:
                    v13[403] = v64;
                  }
                }

                goto LABEL_122;
              default:
                if (a3 != 20 || !a4 || a5 != 8) {
                  goto LABEL_77;
                }
                id v33 = (void *)a1[5];
                if (v33 == &nw_protocol_ref_counted_handle) {
                  __int16 v34 = v10;
                }
                else {
                  __int16 v34 = 0LL;
                }
                BOOL v35 = v34;
                uint64_t v36 = v35;
                if (v33 == &nw_protocol_ref_counted_handle)
                {
                  parent_definition = v35->parent_definition;
                  if (parent_definition)
                  {
                    if (parent_definition->extended_state)
                    {
                      *(void *)buf = 0LL;
                      id v38 = nw_protocol_implementation_lookup_path_by_protocol(v35, a2, (unint64_t *)buf);
                      var18 = (void (*)(NWConcrete_nw_protocol_instance *, uint64_t, unsigned __int8 *))v36->parent_definition->extended_state->var18;
                      if (v38)
                      {
                        if (var18)
                        {
                          __int16 v40 = *(void *)buf;
LABEL_75:
                          var18(v36, v40, a4);
                        }
                      }

                      else if (var18)
                      {
                        __int16 v40 = 0LL;
                        goto LABEL_75;
                      }

    if (v54) {
      free(v54);
    }
    v46 = 0LL;
LABEL_125:

    return (nw_endpoint_t)v46;
  }

  v95.receiver = v24;
  v95.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_bonjour_service_endpoint;
  char v25 = objc_msgSendSuper2(&v95, sel_init);
  if (!v25)
  {
    __nwlog_obj();
    os_log_type_t v76 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
    os_log_type_t v77 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    uint64_t v94 = OS_LOG_TYPE_DEFAULT;
    if ((__nwlog_fault(v77, typea, &v94) & 1) != 0)
    {
      if (typea[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v79 = typea[0];
        if (os_log_type_enabled(v78, typea[0]))
        {
          *(_DWORD *)buf = 136446210;
          v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
          _os_log_impl(&dword_181A5C000, v78, v79, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v94)
      {
        v87 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        id v88 = typea[0];
        v89 = os_log_type_enabled(v78, typea[0]);
        if (v87)
        {
          if (v89)
          {
            *(_DWORD *)buf = 136446466;
            v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
            v108 = 2082;
            v109 = v87;
            _os_log_impl( &dword_181A5C000,  v78,  v88,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v87);
          goto LABEL_198;
        }

        if (v89)
        {
          *(_DWORD *)buf = 136446210;
          v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
          _os_log_impl(&dword_181A5C000, v78, v88, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v78 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v92 = typea[0];
        if (os_log_type_enabled(v78, typea[0]))
        {
          *(_DWORD *)buf = 136446210;
          v107 = "-[NWConcrete_nw_bonjour_service_endpoint initWithName:type:domain:]";
          _os_log_impl( &dword_181A5C000,  v78,  v92,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v47) {
      free(v47);
    }
    goto LABEL_124;
  }

  *(void *)v119 = 0LL;
  *(void *)&v119[8] = v119;
  *(void *)&v119[16] = 0x3032000000LL;
  v120 = __Block_byref_object_copy__16053;
  v121 = __Block_byref_object_dispose__16054;
  v122 = 0LL;
  __src = 0;
  if ((a2 & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v5;
      _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ sending SHOES success reply",  buf,  0x16u);
    }

    os_log_type_t v9 = (nw_path *)nw_connection_copy_connected_path(v5->sc_out_connection);
    os_log_type_t v10 = v9;
    if (v9)
    {
      is_expensive = nw_path_is_expensive(v9);
      os_log_type_t v12 = nw_path_uses_interface_type(v10, nw_interface_type_wifi);
      id v13 = nw_path_uses_interface_type(v10, nw_interface_type_cellular);
      is_constrained = nw_path_is_constrained(v10);
      if (is_expensive || v12 || v13 || is_constrained)
      {
        if (is_expensive) {
          id v15 = 0x80;
        }
        else {
          id v15 = 0;
        }
        if (v12) {
          v15 |= 0x20u;
        }
        if (v13) {
          v15 |= 0x40u;
        }
        if (is_constrained) {
          int v16 = v15 | 0x10;
        }
        else {
          int v16 = v15;
        }
        __src = v16;
      }

      else
      {
        int v16 = 0;
      }

      if ((*((_BYTE *)v5 + 160) & 0x40) != 0) {
        nw_socks5_connection_add_prefer_wifi_request(v5);
      }
      BYTE4(v101) = v16;
      if ((*((_BYTE *)v5 + 161) & 2) != 0)
      {
        os_log_type_t v59 = (nw_endpoint *)nw_connection_copy_connected_remote_endpoint(v5->sc_out_connection);
        os_log_type_t v60 = v59;
        if (v59) {
          address = nw_endpoint_get_address(v59);
        }
        else {
          address = 0LL;
        }

        BOOL v58 = 4 * (BYTE4(v101) != 0);
        os_log_type_t v57 = address;
        if (address)
        {
          v102 = 0;
          id v45 = 0;
          BOOL v58 = (v58 | 3) + address->sa_len;
          LODWORD(v101) = 1;
        }

        else
        {
          LODWORD(v101) = 0;
          v102 = 0;
          id v45 = 0;
        }

        goto LABEL_131;
      }

      if (v16)
      {
        LODWORD(v101) = 0;
        os_log_type_t v57 = 0LL;
        v102 = 0;
        id v45 = 0;
LABEL_130:
        BOOL v58 = 4;
        goto LABEL_131;
      }
    }

    else
    {

      BYTE4(v101) = 0;
    }

    LODWORD(v101) = 0;
    os_log_type_t v57 = 0LL;
    v102 = 0;
    id v45 = 0;
    BOOL v58 = 0;
  }

  else
  {
    uint64_t v31 = v5->sc_error;
    char v32 = v31;
    if (v31)
    {
      id v33 = v31;
      __int16 v34 = *((_DWORD *)v33 + 3);

      BOOL v35 = v33;
      uint64_t v36 = *((_DWORD *)v35 + 2);

      id v37 = v34 + 71;
      if (v34 + 10055 <= 0xFF)
      {
        id v38 = 4;
      }

      else
      {
        id v37 = 3;
        id v38 = 1;
      }

      if ((v34 & 0xFFFFFF00) == 0xFFFEFF00) {
        char v39 = v34;
      }
      else {
        char v39 = 2;
      }
      if ((v34 & 0xFFFFFF00) == 0xFFFEFF00) {
        __int16 v40 = 3;
      }
      else {
        __int16 v40 = 1;
      }
      if (v34 >= 0x100) {
        os_log_type_t v41 = 1;
      }
      else {
        os_log_type_t v41 = v34;
      }
      if (v34 >= 0x100) {
        id v42 = 1;
      }
      else {
        id v42 = 2;
      }
      if (v36 == 1)
      {
        __int16 v43 = v42;
      }

      else
      {
        os_log_type_t v41 = 0;
        __int16 v43 = 1;
      }

      if (v36 == 2) {
        id v44 = v39;
      }
      else {
        id v44 = v41;
      }
      if (v36 == 2) {
        __int16 v43 = v40;
      }
      if (v36 == 3) {
        id v45 = v37;
      }
      else {
        id v45 = v44;
      }
      if (v36 == 3) {
        __int16 v43 = v38;
      }
    }

    else
    {
      id v45 = 0;
      __int16 v43 = 1;
    }

    v102 = v43;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_socks5_connection_send_reply_on_queue";
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v5;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v124) = v102;
      WORD2(v124) = 1024;
      *(_DWORD *)((char *)&v124 + 6) = v45;
      _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ sending SHOES failure reply domain %u code %u",  buf,  0x22u);
    }

    sc_out_connection = (nw_connection *)v5->sc_out_connection;
    if (sc_out_connection)
    {
      os_log_type_t v53 = nw_connection_copy_current_path(sc_out_connection);
      BOOL v54 = v53;
      if (v53 && nw_path_get_status(v53) == nw_path_status_unsatisfied)
      {
        switch(nw_path_get_reason(v54))
        {
          case 5u:
            os_log_type_t v55 = 0x80;
            v56 = 0x80;
            break;
          case 6u:
            os_log_type_t v55 = 64;
            v56 = 64;
            break;
          case 0x1Au:
            os_log_type_t v55 = 16;
            v56 = 16;
            break;
          case 0x1Bu:
            os_log_type_t v55 = 72;
            v56 = 72;
            break;
          case 0x1Cu:
            os_log_type_t v55 = 40;
            v56 = 40;
            break;
          default:
            goto LABEL_88;
        }

        BYTE4(v101) = v56;
        __src = v55;

        LODWORD(v101) = 0;
        os_log_type_t v57 = 0LL;
        goto LABEL_130;
      }
}

  if (v45) {
    free(v45);
  }
  __int16 v21 = 0LL;
LABEL_46:

  return v21;
}

  if (!*((void *)handle + 11)) {
    *((void *)handle + 11) = os_retain(v11);
  }
  if (gLogDatapath)
  {
    v104 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
    {
      v106 = nw_hash_table_count(*((void *)handle + 14), v105);
      *(_DWORD *)buf = 136446978;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v117 = 2048;
      *(void *)v118 = a2;
      *(_WORD *)&v118[8] = 1024;
      *(_DWORD *)&v118[10] = v106;
      _os_log_impl( &dword_181A5C000,  v104,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s added input handler %p, have %u input handlers",  buf,  0x26u);
    }
  }

  return 1LL;
}

            free(v42);
            goto LABEL_128;
          }

          if (!v43) {
            goto LABEL_128;
          }
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v49 = "nw_protocol_http1_updated_path";
          os_log_type_t v41 = "%{public}s called with null http1, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v39 = (os_log_s *)gLogObj;
          __int16 v40 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_128;
          }
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v49 = "nw_protocol_http1_updated_path";
          os_log_type_t v41 = "%{public}s called with null http1, backtrace limit exceeded";
        }

    if (v41) {
      free(v41);
    }
    goto LABEL_124;
  }

  uint64_t v31 = calloc(1uLL, 0x28uLL);
  if (v31)
  {
    if (LODWORD(__size[1])) {
      goto LABEL_54;
    }
LABEL_52:
    if (__size[0])
    {
      free((void *)__size[0]);
      __size[0] = 0LL;
    }

      _os_log_impl(&dword_181A5C000, v40, v41, v42, block, 0xCu);
      goto LABEL_123;
    }
  }

  os_log_type_t v12 = (nw_protocol *)*((void *)handle + 110);
  if (v12)
  {
    do
    {
      output_handler = v12[8].output_handler;
      nw_protocol_http3_stream_error(v12, a2, a3);
      os_log_type_t v12 = output_handler;
    }

    while (output_handler);
  }

        if (a3) {
          *a3 = *(unsigned int *)v86;
        }
        return (void *)v4;
      }

      if ((*(_WORD *)(a1 + 397) & 0x80) != 0) {
        return 0LL;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      int v16 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
        return 0LL;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = a1 + 404;
      __int16 v17 = "%{public}s %{public}s Can't get TCP_CONNECTION_INFO on a multipath socket";
      goto LABEL_106;
    case 3:
      if (*(_DWORD *)(a1 + 272) != 2)
      {
        if ((*(_WORD *)(a1 + 397) & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          int v16 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 404;
            __int16 v17 = "%{public}s %{public}s Can't get MPTCP_INFO on a non-stream socket";
            goto LABEL_106;
          }
        }

        return 0LL;
      }

      if (((*(unsigned __int16 *)(a1 + 397) | (*(unsigned __int8 *)(a1 + 399) << 16)) & 0x20000) == 0)
      {
        if ((*(_WORD *)(a1 + 397) & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          int v16 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = a1 + 404;
            __int16 v17 = "%{public}s %{public}s Can't get MPTCP_INFO on a TCP socket";
            goto LABEL_106;
          }
        }

        return 0LL;
      }

      if (!copymptcpinfo(*(_DWORD *)(a1 + 268), v86))
      {
        if (a3) {
          *a3 = 24LL;
        }
        return *(void **)v86;
      }

      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
      id v4 = _os_log_send_and_compose_impl();
      LOBYTE(v85[0]) = 16;
      LOBYTE(v84) = 0;
      if (LOBYTE(v85[0]) == 17)
      {
        char v32 = (os_log_s *)__nwlog_obj();
        id v33 = v85[0];
        if (!os_log_type_enabled(v32, v85[0])) {
          goto LABEL_211;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
        __int16 v34 = "%{public}s copymptcpinfo failed";
        goto LABEL_181;
      }

      if ((_BYTE)v84)
      {
        backtrace_string = __nw_create_backtrace_string();
        char v32 = (os_log_s *)__nwlog_obj();
        id v33 = v85[0];
        os_log_type_t v57 = os_log_type_enabled(v32, v85[0]);
        if (backtrace_string)
        {
          if (!v57) {
            goto LABEL_145;
          }
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          BOOL v58 = "%{public}s copymptcpinfo failed, dumping backtrace:%{public}s";
          goto LABEL_144;
        }

        if (!v57) {
          goto LABEL_211;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
        __int16 v34 = "%{public}s copymptcpinfo failed, no backtrace";
      }

      else
      {
        char v32 = (os_log_s *)__nwlog_obj();
        id v33 = v85[0];
        if (!os_log_type_enabled(v32, v85[0])) {
          goto LABEL_211;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
        __int16 v34 = "%{public}s copymptcpinfo failed, backtrace limit exceeded";
      }

      goto LABEL_181;
    case 4:
      return (void *)v4;
    case 5:
      if (*(_DWORD *)(a1 + 272) == 1)
      {
        id v4 = (uint64_t)calloc(1uLL, 0xB8uLL);
        if (!v4)
        {
          v74 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "strict_calloc";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = 1LL;
          *(_WORD *)&buf[22] = 2048;
          *(void *)&buf[24] = 184LL;
          v75 = (void *)_os_log_send_and_compose_impl();
          free(v75);
        }

        *(void *)(v4 + 48) = *(void *)(a1 + 96);
        *(void *)(v4 + 72) = *(void *)(a1 + 104);
        *(void *)(v4 + 8) = *(void *)(a1 + 112);
        *(void *)(v4 + 40) = *(void *)(a1 + 120);
LABEL_197:
        if (a3) {
          *a3 = 184LL;
        }
        return (void *)v4;
      }

      *(void *)v85 = 0LL;
      if (((*(unsigned __int16 *)(a1 + 397) | (*(unsigned __int8 *)(a1 + 399) << 16)) & 0x20000) != 0
        && !copymptcpinfo(*(_DWORD *)(a1 + 268), v85))
      {
        id v4 = nw_calloc_type<nw_data_transfer_snapshot>(*(unsigned int *)(*(void *)v85 + 16LL));
        v47 = *(void **)v85;
        v48 = *(_DWORD *)(*(void *)v85 + 16LL);
        if (v48)
        {
          nw_endpoint_t v49 = *(void *)(*(void *)v85 + 8LL);
          os_log_type_t v50 = (void *)(v4 + 72);
          v51 = *(unsigned int *)(*(void *)v85 + 16LL);
          do
          {
            if (*(void *)v49)
            {
              os_log_type_t v52 = *(void *)(*(void *)v49 + 32LL);
              *(v50 - 9) = *(int *)(v52 + 60);
              *os_log_type_t v50 = *(void *)(v52 + 76);
              *(_OWORD *)(v50 - 3) = *(_OWORD *)(v52 + 108);
              *(v50 - 1) = *(void *)(v52 + 124);
              v50[1] = *(void *)(v52 + 84);
              *(v50 - 8) = *(void *)(v52 + 100);
              *(v50 - 4) = *(void *)(v52 + 68);
              v50[6] = *(unsigned int *)(v52 + 24);
              v50[7] = *(unsigned int *)(v52 + 32);
              v50[8] = *(unsigned int *)(v52 + 20);
              v50[9] = *(unsigned int *)(v52 + 28);
            }

            v49 += 8LL;
            v50 += 23;
            --v51;
          }

          while (v51);
        }

        if (a3) {
          *a3 = 184LL * v48;
        }
        freemptcpinfo(v47);
        return (void *)v4;
      }

      id v28 = *(unsigned __int8 *)(a1 + 400);
      if (v28 != 30 && v28 != 2)
      {
        id v4 = (uint64_t)calloc(1uLL, 0xB8uLL);
        if (!v4)
        {
          id v37 = (os_log_s *)__nwlog_obj();
          os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "strict_calloc";
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = 1LL;
          *(_WORD *)&buf[22] = 2048;
          *(void *)&buf[24] = 184LL;
          id v38 = (char *)_os_log_send_and_compose_impl();
          goto LABEL_195;
        }

  if (v57) {
    free(v57);
  }
  id v44 = 0LL;
LABEL_87:

  return v44;
}

            a2 = 0LL;
            goto LABEL_123;
          }

          if (nw_parameters_get_prohibit_constrained((nw_parameters_t)v14[2]) && nw_path_is_constrained((nw_path_t)v41))
          {
            if (a2)
            {
              v73 = "Constrained path prohibited";
              v74 = 26;
LABEL_113:
              nw_path_set_reason(v41, v74, v73, v68, v69, v70, v71, v72, v84);
              goto LABEL_122;
            }

            goto LABEL_122;
          }

          if ((nw_parameters_get_allow_ultra_constrained(v14[2]) & 1) == 0
            && nw_path_is_ultra_constrained(v41))
          {
            if ((nw_path_is_ultra_constrained_allowed(void)::is_allowed & 1) == 0)
            {
              if (!a2) {
                goto LABEL_122;
              }
              v73 = "Ultra constrained path not allowed";
              v74 = 31;
              goto LABEL_113;
            }
          }

          if (a2)
          {
            v73 = "Roaming path prohibited";
            goto LABEL_112;
          }

  if (v27) {
    free(v27);
  }
  return 0xFFFFFFFFLL;
}

  if (v46) {
    free(v46);
  }
LABEL_18:
  if (a1->default_input_handler != a2) {
    return 0LL;
  }
  nw_protocol_ip_register_segmentation_offload_notification(a1, 0);
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      id v19 = default_input_handler[1].callbacks;
      if (v19)
      {
        int v20 = (nw_protocol_callbacks *)((char *)v19 - 1);
        default_input_handler[1].callbacks = v20;
        if (!v20)
        {
          __int16 v21 = *(void (***)(void))default_input_handler[1].flow_id;
          if (v21)
          {
            *(void *)default_input_handler[1].flow_id = 0LL;
            v21[2](v21);
            _Block_release(v21);
          }

          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            int v22 = *(const void **)default_input_handler[1].flow_id;
            if (v22) {
              _Block_release(v22);
            }
          }

          free(default_input_handler);
        }
      }
    }

    a1->default_input_handler = 0LL;
  }

  output_handler = a1->output_handler;
  if (output_handler)
  {
    id v15 = output_handler->callbacks;
    if (v15)
    {
      remove_input_handler = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v15->remove_input_handler;
      if (remove_input_handler)
      {
        __int16 v17 = output_handler->handle;
        if (v17 == &nw_protocol_ref_counted_handle)
        {
          id v18 = output_handler[1].callbacks;
          if (v18) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
          }
        }

        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          uint64_t v23 = a1[1].callbacks;
          if (v23) {
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v23->add_input_handler + 1);
          }
          remove_input_handler(output_handler, a1, a3);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            id v33 = a1[1].callbacks;
            if (v33)
            {
              __int16 v34 = (nw_protocol_callbacks *)((char *)v33 - 1);
              a1[1].callbacks = v34;
              if (!v34)
              {
                BOOL v35 = *(void (***)(void))a1[1].flow_id;
                if (v35)
                {
                  *(void *)a1[1].flow_id = 0LL;
                  v35[2](v35);
                  _Block_release(v35);
                }

                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  uint64_t v36 = *(const void **)a1[1].flow_id;
                  if (v36) {
                    _Block_release(v36);
                  }
                }

                free(a1);
              }
            }
          }
        }

        else
        {
          remove_input_handler(output_handler, a1, a3);
        }

        if (v17 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          id v37 = output_handler[1].callbacks;
          if (v37)
          {
            id v38 = (nw_protocol_callbacks *)((char *)v37 - 1);
            output_handler[1].callbacks = v38;
            if (!v38)
            {
              char v39 = *(void (***)(void))output_handler[1].flow_id;
              if (v39)
              {
                *(void *)output_handler[1].flow_id = 0LL;
                v39[2](v39);
                _Block_release(v39);
              }

              if ((output_handler[1].flow_id[8] & 1) != 0)
              {
                __int16 v40 = *(const void **)output_handler[1].flow_id;
                if (v40) {
                  _Block_release(v40);
                }
              }

              free(output_handler);
            }
          }
        }
      }
    }
  }

  if ((_DWORD)a3)
  {
    while (1)
    {
      output_handler_context = a1[2].output_handler_context;
      if (!output_handler_context) {
        break;
      }
      char v25 = output_handler_context[4];
      id v26 = (void *)output_handler_context[5];
      if (v25)
      {
        *(void *)(v25 + 40) = v26;
        id v26 = (void *)output_handler_context[5];
      }

      else
      {
        *(void *)a1[3].flow_id = v26;
      }

      const char *v26 = v25;
      output_handler_context[4] = 0LL;
      output_handler_context[5] = 0LL;
      nw_frame_finalize((uint64_t)output_handler_context);
    }

    while (1)
    {
      id v27 = p_output_handler[13];
      if (!v27) {
        break;
      }
      identifier = v27->identifier;
      uint64_t v29 = (nw_protocol *)v27->callbacks;
      if (identifier)
      {
        *(void *)&identifier->name[24] = v29;
        uint64_t v29 = (nw_protocol *)v27->callbacks;
      }

      else
      {
        p_output_handler[14] = v29;
      }

      *(void *)v29->flow_id = identifier;
      v27->identifier = 0LL;
      v27->callbacks = 0LL;
      nw_frame_free_buffer((uint64_t)v27);
      os_release(v27);
    }

    while (1)
    {
      char v30 = p_output_handler[15];
      if (!v30) {
        break;
      }
      uint64_t v31 = v30->identifier;
      char v32 = (nw_protocol *)v30->callbacks;
      if (v31)
      {
        *(void *)&v31->name[24] = v32;
        char v32 = (nw_protocol *)v30->callbacks;
      }

      else
      {
        p_output_handler[16] = v32;
      }

      *(void *)v32->flow_id = v31;
      v30->identifier = 0LL;
      v30->callbacks = 0LL;
      nw_frame_free_buffer((uint64_t)v30);
      os_release(v30);
    }

    nw_protocol_destroy((uint64_t)p_output_handler, 0LL);
  }

  return 1LL;
}

void sub_181A85308( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_181A85754(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_get_logging_disabled(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1) {
    return nw_path_parameters_get_logging_disabled(*(void *)(a1 + 104));
  }
  __nwlog_obj();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v13 = "nw_parameters_get_logging_disabled";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        id v13 = "nw_parameters_get_logging_disabled";
        _os_log_impl(&dword_181A5C000, v4, v5, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          id v13 = "nw_parameters_get_logging_disabled";
          __int16 v14 = 2082;
          id v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v7,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        id v13 = "nw_parameters_get_logging_disabled";
        _os_log_impl(&dword_181A5C000, v4, v7, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        id v13 = "nw_parameters_get_logging_disabled";
        _os_log_impl( &dword_181A5C000,  v4,  v9,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL nw_path_parameters_get_logging_disabled(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v14 = "nw_path_parameters_get_logging_disabled";
    id v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v4, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null path_parameters", buf, 0xCu);
        }
      }

      else if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v14 = "nw_path_parameters_get_logging_disabled";
            __int16 v15 = 2082;
            uint64_t v16 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v5,  v8,  "%{public}s called with null path_parameters, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v9)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl(&dword_181A5C000, v5, v8, "%{public}s called with null path_parameters, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl( &dword_181A5C000,  v5,  v10,  "%{public}s called with null path_parameters, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void nw_endpoint_handler_inherit_from_parent( NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_handler *a2, unsigned int next_top_id)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  os_log_type_t v5 = a1;
  os_log_type_t v6 = a2;
  if (v6)
  {
    objc_storeStrong((id *)&v5->parent_handler, a2);
    v5->top_id = v6->top_id;
    *((_BYTE *)v5 + 268) = *((_BYTE *)v5 + 268) & 0xFE | *((_BYTE *)v6 + 268) & 1;
    if (v6->id_chain[0])
    {
      if (v6->id_chain[1])
      {
        if (v6->id_chain[2])
        {
          if (v6->id_chain[3])
          {
            if (v6->id_chain[4])
            {
              if (v6->id_chain[5])
              {
                if (v6->id_chain[6])
                {
                  if (v6->id_chain[7])
                  {
                    if (v6->id_chain[8])
                    {
                      if (v6->id_chain[9])
                      {
                        if (v6->id_chain[10])
                        {
                          if (v6->id_chain[11])
                          {
                            if (v6->id_chain[12])
                            {
                              if (v6->id_chain[13])
                              {
                                if (v6->id_chain[14])
                                {
                                  if (v6->id_chain[15])
                                  {
                                    __nwlog_obj();
                                    os_log_type_t v7 = (void *)objc_claimAutoreleasedReturnValue();
                                    *(_DWORD *)buf = 136446210;
                                    int v20 = "nw_endpoint_handler_inherit_from_parent";
                                    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

                                    os_log_type_t type = OS_LOG_TYPE_ERROR;
                                    char v17 = 0;
                                    if (__nwlog_fault(v8, &type, &v17))
                                    {
                                      if (type == OS_LOG_TYPE_FAULT)
                                      {
                                        __nwlog_obj();
                                        BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                        os_log_type_t v10 = type;
                                        if (os_log_type_enabled(v9, type))
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          int v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s reached maximum endpoint handler depth",  buf,  0xCu);
                                        }
                                      }

                                      else if (v17)
                                      {
                                        backtrace_string = (char *)__nw_create_backtrace_string();
                                        __nwlog_obj();
                                        BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                        os_log_type_t v14 = type;
                                        BOOL v15 = os_log_type_enabled(v9, type);
                                        if (backtrace_string)
                                        {
                                          if (v15)
                                          {
                                            *(_DWORD *)buf = 136446466;
                                            int v20 = "nw_endpoint_handler_inherit_from_parent";
                                            __int16 v21 = 2082;
                                            int v22 = backtrace_string;
                                            _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s reached maximum endpoint handler depth, dumping backtrace:%{public}s",  buf,  0x16u);
                                          }

                                          free(backtrace_string);
                                          goto LABEL_56;
                                        }

                                        if (v15)
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          int v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s reached maximum endpoint handler depth, no backtrace",  buf,  0xCu);
                                        }
                                      }

                                      else
                                      {
                                        __nwlog_obj();
                                        BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                                        os_log_type_t v16 = type;
                                        if (os_log_type_enabled(v9, type))
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          int v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s reached maximum endpoint handler depth, backtrace limit exceeded",  buf,  0xCu);
                                        }
                                      }
                                    }

const char *nw_endpoint_get_logging_description(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1;
    id v4 = (os_unfair_lock_s *)v3;
    if ((*((_BYTE *)v3 + 231) & 0x20) == 0)
    {
      os_log_type_t v5 = *((id *)v3 + 1);
      if (!v5 || (int v6 = v5[31], (v6 - 2) < 2))
      {
        if (nwlog_get_sensitive_redacted::onceToken != -1)
        {
          id v13 = v5;
          dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
          os_log_type_t v5 = v13;
        }

        int v7 = nwlog_get_sensitive_redacted::sensitiveRedacted;

        if (!v7) {
          goto LABEL_13;
        }
LABEL_15:
        uint64_t v17 = 0LL;
        uint64_t v18 = (uint64_t)&v17;
        uint64_t v19 = 0x2020000000LL;
        int v20 = 0LL;
        v14[0] = MEMORY[0x1895F87A8];
        v14[1] = 3221225472LL;
        v14[2] = __nw_endpoint_get_logging_description_block_invoke;
        v14[3] = &unk_189BC9210;
        BOOL v15 = v4;
        os_log_type_t v16 = &v17;
        os_unfair_lock_lock(v4 + 45);
        __nw_endpoint_get_logging_description_block_invoke((uint64_t)v14);
        os_unfair_lock_unlock(v4 + 45);
        os_log_type_t v8 = *(const char **)(v18 + 24);

        _Block_object_dispose(&v17, 8);
        goto LABEL_16;
      }

      if (v6 != 1)
      {

        goto LABEL_15;
      }
    }

LABEL_13:
    BOOL v9 = v4;
    uint64_t v23 = 0LL;
    os_log_type_t v24 = &v23;
    uint64_t v25 = 0x2020000000LL;
    uint64_t v26 = 0LL;
    os_log_type_t v10 = v9 + 45;
    uint64_t v17 = MEMORY[0x1895F87A8];
    uint64_t v18 = 3221225472LL;
    uint64_t v19 = (uint64_t)__nw_endpoint_get_description_block_invoke;
    int v20 = &unk_189BC9210;
    uint64_t v11 = v9;
    __int16 v21 = v11;
    int v22 = &v23;
    os_unfair_lock_lock(v10);
    __nw_endpoint_get_description_block_invoke((uint64_t)&v17);
    os_unfair_lock_unlock(v10);
    os_log_type_t v8 = (const char *)v24[3];

    _Block_object_dispose(&v23, 8);
    goto LABEL_16;
  }

  os_log_type_t v8 = "<NULL>";
LABEL_16:

  return v8;
}

void *__nw_endpoint_get_logging_description_block_invoke(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 32);
  uint64_t v3 = result[10];
  if (!v3)
  {
    uint64_t result = (void *)[result createDescription:1];
    *(void *)(*(void *)(a1 + 32) + 80LL) = result;
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 80LL);
  }

  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v3;
  *(_BYTE *)(*(void *)(a1 + 32) + 231LL) |= 0x10u;
  return result;
}

void sub_181A86768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_copy_interface(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[2];
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_copy_interface";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_copy_interface";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_copy_interface";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_copy_interface";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_copy_interface";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

const char *__nwlog_salted_hostname_hash(const char *a1, char *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    size_t v4 = strlen(a1);
    uint64_t v5 = v4;
    if (v4 >= 2 && a1[v4 - 1] == 46) {
      uint64_t v5 = v4 - 1;
    }
    __nwlog_salted_hash(a1, v5, a2);
    return a2;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "__nwlog_salted_hostname_hash";
  int v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "__nwlog_salted_hostname_hash";
        os_log_type_t v10 = "%{public}s called with null hostname";
LABEL_20:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "__nwlog_salted_hostname_hash";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null hostname, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "__nwlog_salted_hostname_hash";
        os_log_type_t v10 = "%{public}s called with null hostname, no backtrace";
        goto LABEL_20;
      }
    }

    else
    {
      os_log_type_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "__nwlog_salted_hostname_hash";
        os_log_type_t v10 = "%{public}s called with null hostname, backtrace limit exceeded";
        goto LABEL_20;
      }
    }
  }

BOOL __nwlog_salted_hash(const void *a1, uint64_t a2, char *a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    CC_LONG v4 = a2;
    if (a2)
    {
      if (__nwlog_salted_hash::onceToken != -1) {
        dispatch_once(&__nwlog_salted_hash::onceToken, &__block_literal_global_67);
      }
      memset(&c, 0, sizeof(c));
      CC_SHA256_Init(&c);
      CC_SHA256_Update(&c, &__nwlog_salted_hash::salt, 0x40u);
      CC_SHA256_Update(&c, a1, v4);
      CC_SHA256_Final(&md, &c);
      unsigned __int8 v6 = md;
      int v7 = md >> 4;
      char v8 = v7 + 87;
      char v9 = v7 | 0x30;
      if (md > 0x9Fu) {
        char v9 = v8;
      }
      *a3 = v9;
      if ((v6 & 0xFu) <= 9) {
        char v10 = v6 & 0xF | 0x30;
      }
      else {
        char v10 = (v6 & 0xF) + 87;
      }
      a3[1] = v10;
      unsigned __int8 v11 = v30;
      int v12 = v30 >> 4;
      char v13 = v12 + 87;
      char v14 = v12 | 0x30;
      if (v30 > 0x9Fu) {
        char v14 = v13;
      }
      a3[2] = v14;
      if ((v11 & 0xFu) <= 9) {
        char v15 = v11 & 0xF | 0x30;
      }
      else {
        char v15 = (v11 & 0xF) + 87;
      }
      a3[3] = v15;
      unsigned __int8 v16 = v31;
      int v17 = v31 >> 4;
      char v18 = v17 + 87;
      char v19 = v17 | 0x30;
      if (v31 > 0x9Fu) {
        char v19 = v18;
      }
      a3[4] = v19;
      if ((v16 & 0xFu) <= 9) {
        char v20 = v16 & 0xF | 0x30;
      }
      else {
        char v20 = (v16 & 0xF) + 87;
      }
      a3[5] = v20;
      unsigned __int8 v21 = v32;
      int v22 = v32 >> 4;
      char v23 = v22 + 87;
      char v24 = v22 | 0x30;
      if (v32 > 0x9Fu) {
        char v24 = v23;
      }
      a3[6] = v24;
      if ((v21 & 0xFu) <= 9) {
        char v25 = v21 & 0xF | 0x30;
      }
      else {
        char v25 = (v21 & 0xF) + 87;
      }
      a3[7] = v25;
      a3[8] = 0;
      return (BOOL)a3;
    }
  }

  if (a3)
  {
LABEL_27:
    strcpy(a3, "<null>");
    return (BOOL)a3;
  }

  id v27 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  c.count[0] = 136446210;
  *(void *)&c.count[1] = "_strict_strlcpy";
  id v28 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    goto LABEL_27;
  }

  __break(1u);
  return result;
}

uint64_t __nw_connection_create_with_id_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  unsigned __int8 v6 = a3;
  if (!v6)
  {
    if (v5 == &__block_literal_global_6237) {
      goto LABEL_25;
    }
    uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 16LL);
    if (!v13 || nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104))) {
      goto LABEL_25;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v8 = (os_log_s *)(id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_24;
    }
    int v14 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    int v17 = 136446722;
    char v18 = "nw_connection_create_with_id_block_invoke";
    __int16 v19 = 1024;
    int v20 = v14;
    __int16 v21 = 2082;
    logging_description = nw_endpoint_get_logging_description(v5);
    char v10 = "%{public}s [C%u] has alternative %{public}s";
LABEL_22:
    unsigned __int8 v11 = v8;
    uint32_t v12 = 28;
    goto LABEL_23;
  }

  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v5 == &__block_literal_global_6237)
  {
    if (!v7 || nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104))) {
      goto LABEL_25;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v8 = (os_log_s *)(id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_24;
    }
    int v15 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    int v17 = 136446722;
    char v18 = "nw_connection_create_with_id_block_invoke";
    __int16 v19 = 1024;
    int v20 = v15;
    __int16 v21 = 2114;
    logging_description = v6;
    char v10 = "%{public}s [C%u] has alternative UNKNOWN for %{public}@";
    goto LABEL_22;
  }

  if (v7 && !nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    char v8 = (os_log_s *)(id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_24;
    }
    int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
    int v17 = 136446978;
    char v18 = "nw_connection_create_with_id_block_invoke";
    __int16 v19 = 1024;
    int v20 = v9;
    __int16 v21 = 2082;
    logging_description = nw_endpoint_get_logging_description(v5);
    __int16 v23 = 2114;
    char v24 = v6;
    char v10 = "%{public}s [C%u] has alternative %{public}s for %{public}@";
    unsigned __int8 v11 = v8;
    uint32_t v12 = 38;
LABEL_23:
    _os_log_impl(&dword_181A5C000, v11, OS_LOG_TYPE_INFO, v10, (uint8_t *)&v17, v12);
LABEL_24:
  }

void sub_181A871B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_get_id(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[112];
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  unsigned __int8 v16 = "nw_connection_get_id";
  unsigned __int8 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned __int8 v16 = "nw_connection_get_id";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          unsigned __int8 v16 = "nw_connection_get_id";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        unsigned __int8 v16 = "nw_connection_get_id";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned __int8 v16 = "nw_connection_get_id";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_connection_set_queue(nw_connection_t connection, dispatch_queue_t queue)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v3 = connection;
  CC_LONG v4 = queue;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_connection_set_queue";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v24;
      if (os_log_type_enabled(v10, v24))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_connection_set_queue";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v24;
      BOOL v16 = os_log_type_enabled(v10, v24);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_connection_set_queue";
          __int16 v27 = 2082;
          id v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9) {
          goto LABEL_4;
        }
LABEL_39:
        free(v9);
        goto LABEL_4;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_connection_set_queue";
        _os_log_impl(&dword_181A5C000, v10, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = v24;
      if (os_log_type_enabled(v10, v24))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_connection_set_queue";
        _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void __nw_connection_set_queue_block_invoke(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x10) != 0)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      if (!nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        id v4 = (id)gconnectionLogObj;
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        *(_DWORD *)buf = 136446466;
        uint64_t v26 = "nw_connection_set_queue_block_invoke";
        __int16 v27 = 1024;
        int v28 = v5;
        unsigned __int8 v6 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v23 = 0;
        if (!__nwlog_fault(v6, &type, &v23))
        {
LABEL_13:
          if (!v6) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }

        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          uint64_t v7 = (os_log_s *)(id)gconnectionLogObj;
          os_log_type_t v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
            *(_DWORD *)buf = 136446466;
            uint64_t v26 = "nw_connection_set_queue_block_invoke";
            __int16 v27 = 1024;
            int v28 = v9;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s [C%u] Error in client: nw_connection_set_queue called after nw_connection_start",  buf,  0x12u);
          }

LABEL_15:
  if (!nw_context_is_inline(*(void **)(*(void *)(a1 + 32) + 24LL)))
  {
    uint64_t v14 = a1 + 32;
    uint64_t v13 = *(void *)(a1 + 32);
    id v15 = *(id *)(v14 + 8);
    id v11 = *(id *)(v13 + 200);
    *(void *)(v13 + 200) = v15;
LABEL_23:

    return;
  }

  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16LL);
  if (v10 && !nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    id v11 = (id)gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = "nw_connection_set_queue_block_invoke";
      __int16 v27 = 1024;
      int v28 = v12;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v11,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Connection client queue will be ignored for inline contexts",  buf,  0x12u);
    }

    goto LABEL_23;
  }

  __break(1u);
}

  return v5;
}

  return v8;
}

  id v15 = *((void *)a1 + 2);
  BOOL v16 = (void *)*((void *)a1 + 3);
  uint64_t v14 = (void *)((char *)a1 + 16);
  if (v15)
  {
    *(void *)(v15 + 24) = v16;
    BOOL v16 = (void *)*((void *)a1 + 3);
  }

  else
  {
    *((void *)a3 + 39) = v16;
  }

  *BOOL v16 = v15;
  *uint64_t v14 = 0LL;
  *((void *)a1 + 3) = 0LL;
  --*((_DWORD *)a3 + 105);
  if (v7 && *v7)
  {
    os_log_s *v7 = 0LL;
    v7[1] = 0LL;
  }

  *((void *)a1 + 2) = 0LL;
  os_log_type_t v17 = (void *)*((void *)a3 + 37);
  *((void *)a1 + 3) = v17;
  char *v17 = a1;
  *((void *)a3 + 37) = v14;
  if (*((void *)a3 + 38)) {
    return;
  }
  if (*((void *)a3 + 51) && *((void *)a3 + 27))
  {
    BOOL v18 = os_channel_advance_slot();
    if (!v18 || (v139 = v18, (nw_channel_check_defunct((uint64_t)a3) & 1) != 0))
    {
LABEL_25:
      *((void *)a3 + 51) = 0LL;
      goto LABEL_26;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    v221 = 1024;
    *(_DWORD *)v222 = v139;
    v140 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v140, &v223, type))
    {
      if (v223 == 17)
      {
        v141 = (os_log_s *)__nwlog_obj();
        v142 = v223;
        if (!os_log_type_enabled(v141, (os_log_type_t)v223)) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        v221 = 1024;
        *(_DWORD *)v222 = v139;
        v143 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d";
        goto LABEL_395;
      }

      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v141 = (os_log_s *)__nwlog_obj();
        v142 = v223;
        if (!os_log_type_enabled(v141, (os_log_type_t)v223)) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        v221 = 1024;
        *(_DWORD *)v222 = v139;
        v143 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_395;
      }

      v161 = (char *)__nw_create_backtrace_string();
      v141 = (os_log_s *)__nwlog_obj();
      v142 = v223;
      v162 = os_log_type_enabled(v141, (os_log_type_t)v223);
      if (v161)
      {
        if (v162)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          v221 = 1024;
          *(_DWORD *)v222 = v139;
          *(_WORD *)&v222[4] = 2082;
          *(void *)&v222[6] = v161;
          _os_log_impl( &dword_181A5C000,  v141,  v142,  "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v161);
        goto LABEL_396;
      }

      if (v162)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        v221 = 1024;
        *(_DWORD *)v222 = v139;
        v143 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, no backtrace";
LABEL_395:
        _os_log_impl(&dword_181A5C000, v141, v142, v143, buf, 0x12u);
      }
    }

    v111 = 0;
    goto LABEL_103;
  }

  v124 = 0LL;
  callbacks = output_handler->callbacks;
  v113 = output_handler;
  if (callbacks)
  {
    get_message_properties = (void (*)(void))callbacks->get_message_properties;
    if (get_message_properties) {
      get_message_properties();
    }
  }

  if ((_DWORD)v4) {
    LODWORD(v4) = nw_endpoint_handler_get_state(v118) != 5 && (v124 & 0x100000000LL) == 0;
  }
  BOOL v18 = *((_WORD *)a3 + 166);
  v111 = (v18 & 4) == 0;
  if ((v18 & 4) == 0)
  {
    *((_WORD *)a3 + 166) = v18 | 4;
    request_list_report = (OS_nw_read_request *)nw_read_request_list_report(a3->read_requests);
    read_requests = a3->read_requests;
    a3->read_requests = request_list_report;

    v110 = (char)v4;
    if (!a3->read_requests && gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      v101 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
      {
        v102 = nw_endpoint_handler_get_id_string(v118);
        v103 = nw_endpoint_handler_dry_run_string(v118);
        v104 = nw_endpoint_handler_copy_endpoint(v118);
        v105 = nw_endpoint_get_logging_description(v104);
        v106 = nw_endpoint_handler_state_string(v118);
        v107 = nw_endpoint_handler_mode_string(v118);
        v108 = nw_endpoint_handler_copy_current_path(v118);
        *(_DWORD *)buf = 136448002;
        v126 = "nw_flow_service_reads";
        v127 = 2082;
        v128 = v102;
        v129 = 2082;
        v130 = v103;
        v131 = 2082;
        v132 = v105;
        v133 = 2082;
        v134 = v106;
        v135 = 2082;
        v136 = v107;
        v137 = 2114;
        v138 = v108;
        v139 = 2048;
        *(void *)v140 = a3;
        _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %p No read requests, skipping read",  buf,  0x52u);
      }

      LOBYTE(v4) = v110;
    }

    p_pending_input_frames = &a3->pending_input_frames;
    while (1)
    {
      if (a3->read_requests) {
        int v21 = 1;
      }
      else {
        int v21 = (char)v4;
      }
      if ((v21 & 1) == 0 && (*((_WORD *)a3 + 166) & 0x40) == 0)
      {
LABEL_95:
        if ((v4 & 1) != 0 || (os_log_type_t v78 = *((_WORD *)a3 + 166), (v78 & 0x40) != 0))
        {
          if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            v92 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
            {
              int v93 = nw_endpoint_handler_get_id_string(v118);
              uint64_t v94 = nw_endpoint_handler_dry_run_string(v118);
              v95 = nw_endpoint_handler_copy_endpoint(v118);
              v96 = nw_endpoint_get_logging_description(v95);
              v97 = nw_endpoint_handler_state_string(v118);
              v98 = nw_endpoint_handler_mode_string(v118);
              v99 = nw_endpoint_handler_copy_current_path(v118);
              *(_DWORD *)buf = 136447746;
              v126 = "nw_flow_service_reads";
              v127 = 2082;
              v128 = v93;
              v129 = 2082;
              v130 = v94;
              v131 = 2082;
              v132 = v96;
              v133 = 2082;
              v134 = v97;
              v135 = 2082;
              v136 = v98;
              v137 = 2114;
              v138 = v99;
              _os_log_impl( &dword_181A5C000,  v92,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Handling remaining read requests",  buf,  0x48u);
            }
          }

          last_error = a3->last_error;
          v80 = a3->read_requests;
          if (last_error)
          {
            nw_read_request_report_error_with_override(a3->read_requests, 0LL, last_error);
          }

          else
          {
            BOOL v81 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 96);
            nw_read_request_report_error_with_override(v80, 0LL, v81);
          }

          os_log_type_t v82 = a3->read_requests;
          a3->read_requests = 0LL;

          os_log_type_t v78 = *((_WORD *)a3 + 166);
        }

        *((_WORD *)a3 + 166) = v78 & 0xFFFB;
        goto LABEL_103;
      }

      if ((v4 & 1) != 0 || (*((_WORD *)a3 + 166) & 0x40) != 0)
      {
        int v22 = BYTE4(v124) & 4;
        if ((v124 & 0x400000000LL) != 0) {
          char v23 = 1LL;
        }
        else {
          char v23 = 0xFFFFFFFFLL;
        }
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
          }
          v48 = (os_log_s *)(id)gconnectionLogObj;
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
          {
            nw_endpoint_t v49 = nw_endpoint_handler_get_id_string(v118);
            id v4 = nw_endpoint_handler_dry_run_string(v118);
            os_log_type_t v50 = nw_endpoint_handler_copy_endpoint(v118);
            v51 = nw_endpoint_get_logging_description(v50);
            v117 = nw_endpoint_handler_state_string(v118);
            os_log_type_t v52 = nw_endpoint_handler_mode_string(v118);
            os_log_type_t v53 = nw_endpoint_handler_copy_current_path(v118);
            *(_DWORD *)buf = 136448002;
            v126 = "nw_flow_service_reads";
            v127 = 2082;
            v128 = v49;
            v129 = 2082;
            v130 = v4;
            v131 = 2082;
            v132 = v51;
            v133 = 2082;
            v134 = v117;
            v135 = 2082;
            v136 = v52;
            v137 = 2114;
            v138 = v53;
            v139 = 2048;
            *(void *)v140 = v23;
            _os_log_impl( &dword_181A5C000,  v48,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Setting min_length on fin al data read to %zu",  buf,  0x52u);

            LOBYTE(v4) = v110;
          }
        }

        v120[0] = MEMORY[0x1895F87A8];
        v120[1] = 3221225472LL;
        v120[2] = ___ZL21nw_flow_service_readsP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP16nw_flow_protocolb_block_invoke;
        v120[3] = &unk_189BB8440;
        v121 = v118;
        v122 = a3;
        v123 = v22 >> 2;
        os_log_type_t v24 = nw_read_request_create(v23, 0xFFFFFFFFuLL, 0LL, 0LL, v120);
        request_list_append = nw_read_request_list_append(a3->read_requests, v24);
        uint64_t v26 = a3->read_requests;
        a3->read_requests = (OS_nw_read_request *)request_list_append;
      }

      if (p_pending_input_frames->tqh_first)
      {
        nw_flow_process_input_frames( v118,  v115,  &a3->protocol,  p_pending_input_frames,  BYTE4(v124) & 1,  (v124 & 0x400000000LL) != 0,  0);
        __int16 v27 = a3->read_requests;
        if (!v27) {
          goto LABEL_95;
        }
      }

      else
      {
        __int16 v27 = a3->read_requests;
      }

      int v28 = v27;
      __int16 v29 = v28;
      v116 = v28;
      if ((v124 & 0x100000000LL) != 0)
      {
        maximum_datagram_count = nw_read_request_get_maximum_datagram_count(v28);
        if (!maximum_datagram_count)
        {
          v70 = -1;
LABEL_88:
          if ((nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            os_log_type_t v71 = (os_log_s *)(id)gconnectionLogObj;
            if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
            {
              BOOL v72 = nw_endpoint_handler_get_id_string(v118);
              v73 = nw_endpoint_handler_dry_run_string(v118);
              id v4 = v72;
              v114 = nw_endpoint_handler_copy_endpoint(v118);
              v74 = nw_endpoint_get_logging_description(v114);
              v75 = nw_endpoint_handler_state_string(v118);
              os_log_type_t v76 = nw_endpoint_handler_mode_string(v118);
              os_log_type_t v77 = nw_endpoint_handler_copy_current_path(v118);
              *(_DWORD *)buf = 136448258;
              v126 = "nw_flow_service_reads";
              v127 = 2082;
              v128 = v4;
              v129 = 2082;
              v130 = v73;
              v131 = 2082;
              v132 = v74;
              v133 = 2082;
              v134 = v75;
              v135 = 2082;
              v136 = v76;
              v137 = 2114;
              v138 = v77;
              v139 = 1024;
              *(_DWORD *)v140 = maximum_datagram_count;
              *(_WORD *)&v140[4] = 1024;
              *(_DWORD *)&v140[6] = v70;
              _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Read request has %u fra me count, %u byte count",  buf,  0x54u);

              LOBYTE(v4) = v110;
            }
          }

          goto LABEL_95;
        }
      }

      else if (nw_read_request_get_next_max_size(a3->read_requests))
      {
        maximum_datagram_count = -1;
      }

      else
      {
        v70 = 0;
        maximum_datagram_count = -1;
        if (!nw_read_request_is_metadata_only(v29)) {
          goto LABEL_88;
        }
      }

      uint64_t v31 = v116;
      if (nw_read_request_is_metadata_only(v116)) {
        unsigned __int8 v32 = 1;
      }
      else {
        unsigned __int8 v32 = maximum_datagram_count;
      }
      type.tqh_first = 0LL;
      type.tqh_last = (nw_frame **)&type;
      id v33 = ((uint64_t (*)(void))v113->callbacks->get_input_frames)();
      if (v32 == -1)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v34 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          BOOL v54 = nw_endpoint_handler_get_id_string(v118);
          id v4 = nw_endpoint_handler_dry_run_string(v118);
          os_log_type_t v55 = nw_endpoint_handler_copy_endpoint(v118);
          v56 = nw_endpoint_get_logging_description(v55);
          os_log_type_t v57 = nw_endpoint_handler_state_string(v118);
          BOOL v58 = nw_endpoint_handler_mode_string(v118);
          os_log_type_t v59 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448002;
          v126 = "nw_flow_service_reads";
          v127 = 2082;
          v128 = v54;
          v129 = 2082;
          v130 = v4;
          v131 = 2082;
          v132 = v56;
          v133 = 2082;
          v134 = v57;
          v135 = 2082;
          v136 = v58;
          v137 = 2114;
          v138 = v59;
          v139 = 1024;
          *(_DWORD *)v140 = v33;
          _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler has %u frames to read",  buf,  0x4Eu);

          LOBYTE(v4) = v110;
        }
      }

      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v34 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          BOOL v35 = nw_endpoint_handler_get_id_string(v118);
          id v4 = nw_endpoint_handler_dry_run_string(v118);
          uint64_t v36 = nw_endpoint_handler_copy_endpoint(v118);
          id v37 = nw_endpoint_get_logging_description(v36);
          v109 = nw_endpoint_handler_state_string(v118);
          id v38 = nw_endpoint_handler_mode_string(v118);
          char v39 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448258;
          v126 = "nw_flow_service_reads";
          v127 = 2082;
          v128 = v35;
          v129 = 2082;
          v130 = v4;
          v131 = 2082;
          v132 = v37;
          v133 = 2082;
          v134 = v109;
          v135 = 2082;
          v136 = v38;
          v137 = 2114;
          v138 = v39;
          v139 = 1024;
          *(_DWORD *)v140 = v33;
          *(_WORD *)&v140[4] = 1024;
          *(_DWORD *)&v140[6] = v32;
          _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler has %u frame s to read, request wants %u frames",  buf,  0x54u);

          LOBYTE(v4) = v110;
        }
      }

      uint64_t v31 = v116;
LABEL_54:
      if (!type.tqh_first && v33 && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        __int16 v40 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          id v4 = nw_endpoint_handler_get_id_string(v118);
          os_log_type_t v41 = nw_endpoint_handler_dry_run_string(v118);
          id v42 = nw_endpoint_handler_copy_endpoint(v118);
          __int16 v43 = nw_endpoint_get_logging_description(v42);
          id v44 = nw_endpoint_handler_state_string(v118);
          id v45 = nw_endpoint_handler_mode_string(v118);
          v46 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448002;
          v126 = "nw_flow_service_reads";
          v127 = 2082;
          v128 = v4;
          v129 = 2082;
          v130 = v41;
          v131 = 2082;
          v132 = v43;
          v133 = 2082;
          v134 = v44;
          v135 = 2082;
          v136 = v45;
          v137 = 2114;
          v138 = v46;
          v139 = 1024;
          *(_DWORD *)v140 = v33;
          _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_ERROR,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler reported %u frames to read, but array is empty",  buf,  0x4Eu);

          LOBYTE(v4) = v110;
        }

        uint64_t v31 = v116;
      }

      v47 = nw_flow_process_input_frames( v118,  v115,  &a3->protocol,  &type,  BYTE4(v124) & 1,  (v124 & 0x400000000LL) != 0,  1);

      if (!v47) {
        goto LABEL_95;
      }
    }
  }

  if ((v18 & 0x40) == 0)
  {
    if ((_DWORD)v4) {
      os_log_type_t v60 = 64;
    }
    else {
      os_log_type_t v60 = 0;
    }
    *((_WORD *)a3 + 166) = v18 & 0xFFBF | v60;
  }

  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    v61 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v62 = nw_endpoint_handler_get_id_string(v118);
      char v63 = nw_endpoint_handler_dry_run_string(v118);
      os_log_type_t v64 = nw_endpoint_handler_copy_endpoint(v118);
      v65 = nw_endpoint_get_logging_description(v64);
      os_log_type_t v66 = nw_endpoint_handler_state_string(v118);
      BOOL v67 = nw_endpoint_handler_mode_string(v118);
      os_log_type_t v68 = nw_endpoint_handler_copy_current_path(v118);
      BOOL v69 = (*((unsigned __int16 *)a3 + 166) >> 6) & 1;
      *(_DWORD *)buf = 136448002;
      v126 = "nw_flow_service_reads";
      v127 = 2082;
      v128 = v62;
      v129 = 2082;
      v130 = v63;
      v131 = 2082;
      v132 = v65;
      v133 = 2082;
      v134 = v66;
      v135 = 2082;
      v136 = v67;
      v137 = 2114;
      v138 = v68;
      v139 = 1024;
      *(_DWORD *)v140 = v69;
      _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Already servicing reads, ignore read (deferred final read is %{BOOL}d)",  buf,  0x4Eu);
    }
  }

  os_log_type_t v17 = v11;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v18 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v72 = "nw_write_request_create";
    _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot send a reply for a protocol that does not support replies",  buf,  0xCu);
  }

LABEL_18:
  int v19 = 0LL;
LABEL_63:

  return v19;
}

LABEL_16:
      if (!v9) {
        goto LABEL_5;
      }
LABEL_17:
      free(v9);
      goto LABEL_5;
    }

    if (!v19)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      id v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446466;
        int v22 = "-[NWConcrete_nw_path_evaluator dealloc]";
        char v23 = 1024;
        os_log_type_t v24 = v6;
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
      }

      goto LABEL_15;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    uint64_t v13 = type;
    uint64_t v14 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        int v22 = "-[NWConcrete_nw_path_evaluator dealloc]";
        char v23 = 1024;
        os_log_type_t v24 = v6;
        _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, no backtrace",  buf,  0x12u);
      }

      goto LABEL_15;
    }

    if (v14)
    {
      *(_DWORD *)buf = 136446722;
      int v22 = "-[NWConcrete_nw_path_evaluator dealloc]";
      char v23 = 1024;
      os_log_type_t v24 = v6;
      uint64_t v25 = 2082;
      uint64_t v26 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

    free(backtrace_string);
    if (v9) {
      goto LABEL_17;
    }
  }

    ((void (*)(uint64_t, uint64_t))v21[1])(v29, v30);
LABEL_16:
    ++v20;
    if (v23 == MEMORY[0x186E0E8E0](v19, *(void *)(v0 + 80))) {
      goto LABEL_32;
    }
  }

  BOOL result = sub_18264F1A4();
  if (v54 != 8) {
    goto LABEL_34;
  }
  os_log_type_t v50 = result;
  v51 = *(void *)(v0 + 120);
  os_log_type_t v52 = *(void *)(v0 + 80);
  *(void *)(v0 + 24) = v50;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v22 + 16))(v51, v0 + 24, v52);
  swift_unknownObjectRelease();
  char v23 = v20 + 1;
  if (!__OFADD__(v20, 1LL)) {
    goto LABEL_19;
  }
LABEL_31:
  __break(1u);
LABEL_32:
  os_log_type_t v53 = *(uint64_t **)(v0 + 32);
  swift_bridgeObjectRelease();
  *os_log_type_t v53 = v60;
  v53[1] = v61;
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  return (*(uint64_t (**)(void))(v0 + 8))();
}

    __break(1u);
LABEL_16:
    __break(1u);
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }

  __break(1u);
  return result;
}

  BOOL result = sub_18264F5C4();
  __break(1u);
  return result;
}

  if (v5 == v2 && v6 == v3) {
    os_log_type_t v8 = 1;
  }
  else {
    os_log_type_t v8 = sub_18264F4EC();
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v8 & 1;
}

  if (v5 == v3 && v6 == v2) {
    os_log_type_t v8 = 1;
  }
  else {
    os_log_type_t v8 = sub_18264F4EC();
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v8 & 1;
}

          uint64_t v13 = nw_parameters_copy_context(v12);
          a1[1].output_handler_context = nw_path_copy_flow_registration(v13, (uint64_t)a1);
          if (output_handler_context) {
            os_release(output_handler_context);
          }
          if (v13) {
            os_release(v13);
          }
          uint64_t v14 = a1[1].output_handler_context;
          if (!v14
            || !nw_path_flow_registration_get_ctl_command( a1[1].default_input_handler,  v14,  type,  &v103,  0LL))
          {
            goto LABEL_72;
          }

          if (gLogDatapath)
          {
            v87 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
            {
              id v88 = LOWORD(a1[2].output_handler_context);
              v89 = WORD1(a1[2].output_handler_context);
              *(_DWORD *)buf = 136447490;
              v108 = "nw_protocol_udp_updated_path";
              v109 = 2082;
              v110 = a1 + 3;
              v111 = 1024;
              *(_DWORD *)v112 = v88;
              *(_WORD *)&v112[4] = 1024;
              *(_DWORD *)&v112[6] = v89;
              LOWORD(v113) = 1024;
              *(_DWORD *)((char *)&v113 + 2) = *(_DWORD *)type;
              HIWORD(v113) = 1024;
              v114 = v103;
              _os_log_impl( &dword_181A5C000,  v87,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s udp[%u,%u] Protocol event %d=%d",  buf,  0x2Eu);
            }
          }

          id v15 = *(unsigned int *)type;
          output_handler_context_high = HIWORD(a1[2].output_handler_context);
          if ((output_handler_context_high & 4) != 0)
          {
            if (LODWORD(a1[2].identifier)) {
              goto LABEL_31;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v18 = (os_log_s *)gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
              goto LABEL_72;
            }
            *(_DWORD *)buf = 136446466;
            v108 = "udp_ctlinput";
            v109 = 2082;
            v110 = a1 + 3;
            int v19 = "%{public}s %{public}s Protocol event reported for socket with faddr INADDR_ANY";
          }

          else
          {
            if (a1[2].identifier != (nw_protocol_identifier *)*MEMORY[0x1895FB7E8]
              || a1[2].callbacks != *(nw_protocol_callbacks **)(MEMORY[0x1895FB7E8] + 8LL))
            {
LABEL_31:
              if (*(_DWORD *)type <= 0x15u
                && (*(_DWORD *)type - 14) >= 4
                && ((0xFC01FuLL >> type[0]) & 1) == 0
                && ((output_handler_context_high & 0x80) == 0 || *(_DWORD *)type != 5 && *(_DWORD *)type != 12))
              {
                os_log_type_t v20 = a1->default_input_handler;
                if (v20)
                {
                  int v21 = v20->callbacks;
                  if (v21)
                  {
                    if (v21->error)
                    {
                      HIWORD(a1[2].output_handler_context) = output_handler_context_high | 0x200;
                      int v22 = udpctlerrmap[v15];
                      char v23 = v20->handle;
                      if (v23 == &nw_protocol_ref_counted_handle)
                      {
                        os_log_type_t v24 = v20[1].callbacks;
                        if (v24) {
                          v20[1].callbacks = (nw_protocol_callbacks *)((char *)&v24->add_input_handler + 1);
                        }
                      }

                      uint64_t v25 = a1->handle;
                      if (v25 == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v26 = a1[1].callbacks;
                        if (v26) {
                          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v26->add_input_handler + 1);
                        }
                      }

                      __int16 v27 = v20->callbacks;
                      if (v27)
                      {
                        error = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v27->error;
                        if (error)
                        {
                          error(v20, a1, v22);
LABEL_49:
                          if (v25 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
                          {
                            os_log_type_t v53 = a1[1].callbacks;
                            if (v53)
                            {
                              BOOL v54 = (nw_protocol_callbacks *)((char *)v53 - 1);
                              a1[1].callbacks = v54;
                              if (!v54)
                              {
                                os_log_type_t v55 = *(void (***)(void))a1[1].flow_id;
                                if (v55)
                                {
                                  *(void *)a1[1].flow_id = 0LL;
                                  v55[2](v55);
                                  _Block_release(v55);
                                }

                                if ((a1[1].flow_id[8] & 1) != 0)
                                {
                                  v56 = *(const void **)a1[1].flow_id;
                                  if (v56) {
                                    _Block_release(v56);
                                  }
                                }

                                free(a1);
                              }
                            }
                          }

                          if (v23 == &nw_protocol_ref_counted_handle && v20->handle == &nw_protocol_ref_counted_handle)
                          {
                            __int16 v29 = v20[1].callbacks;
                            if (v29)
                            {
                              unsigned __int8 v30 = (nw_protocol_callbacks *)((char *)v29 - 1);
                              v20[1].callbacks = v30;
                              if (!v30)
                              {
                                uint64_t v31 = *(void (***)(void))v20[1].flow_id;
                                if (v31)
                                {
                                  *(void *)v20[1].flow_id = 0LL;
                                  v31[2](v31);
                                  _Block_release(v31);
                                }

                                if ((v20[1].flow_id[8] & 1) != 0)
                                {
                                  unsigned __int8 v32 = *(const void **)v20[1].flow_id;
                                  if (v32) {
                                    _Block_release(v32);
                                  }
                                }

                                free(v20);
                              }
                            }
                          }

                          goto LABEL_72;
                        }
                      }

                      __nwlog_obj();
                      name = v20->identifier->name;
                      *(_DWORD *)buf = 136446722;
                      v108 = "__nw_protocol_error";
                      if (!name) {
                        name = "invalid";
                      }
                      v109 = 2082;
                      v110 = (nw_protocol *)name;
                      v111 = 2048;
                      *(void *)v112 = v20;
                      v92 = (char *)_os_log_send_and_compose_impl();
                      v106 = OS_LOG_TYPE_ERROR;
                      v105 = 0;
                      if (__nwlog_fault(v92, &v106, &v105))
                      {
                        if (v106 == OS_LOG_TYPE_FAULT)
                        {
                          int v93 = (os_log_s *)__nwlog_obj();
                          uint64_t v94 = v106;
                          if (!os_log_type_enabled(v93, v106)) {
                            goto LABEL_227;
                          }
                          v95 = v20->identifier->name;
                          if (!v95) {
                            v95 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          v108 = "__nw_protocol_error";
                          v109 = 2082;
                          v110 = (nw_protocol *)v95;
                          v111 = 2048;
                          *(void *)v112 = v20;
                          v96 = "%{public}s protocol %{public}s (%p) has invalid error callback";
                          goto LABEL_226;
                        }

                        if (!v105)
                        {
                          int v93 = (os_log_s *)__nwlog_obj();
                          uint64_t v94 = v106;
                          if (!os_log_type_enabled(v93, v106)) {
                            goto LABEL_227;
                          }
                          v100 = v20->identifier->name;
                          if (!v100) {
                            v100 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          v108 = "__nw_protocol_error";
                          v109 = 2082;
                          v110 = (nw_protocol *)v100;
                          v111 = 2048;
                          *(void *)v112 = v20;
                          v96 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
                          goto LABEL_226;
                        }

                        v97 = (char *)__nw_create_backtrace_string();
                        int v93 = (os_log_s *)__nwlog_obj();
                        uint64_t v94 = v106;
                        v98 = os_log_type_enabled(v93, v106);
                        if (v97)
                        {
                          if (v98)
                          {
                            v99 = v20->identifier->name;
                            if (!v99) {
                              v99 = "invalid";
                            }
                            *(_DWORD *)buf = 136446978;
                            v108 = "__nw_protocol_error";
                            v109 = 2082;
                            v110 = (nw_protocol *)v99;
                            v111 = 2048;
                            *(void *)v112 = v20;
                            *(_WORD *)&v112[8] = 2082;
                            v113 = v97;
                            _os_log_impl( &dword_181A5C000,  v93,  v94,  "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s",  buf,  0x2Au);
                          }

                          free(v97);
                          goto LABEL_227;
                        }

                        if (v98)
                        {
                          v101 = v20->identifier->name;
                          if (!v101) {
                            v101 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          v108 = "__nw_protocol_error";
                          v109 = 2082;
                          v110 = (nw_protocol *)v101;
                          v111 = 2048;
                          *(void *)v112 = v20;
                          v96 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
LABEL_226:
                          _os_log_impl(&dword_181A5C000, v93, v94, v96, buf, 0x20u);
                        }
                      }

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

  if (v0) {
    free(v0);
  }
  return 0LL;
}

    id v15 = 0LL;
    goto LABEL_148;
  }

  BOOL v16 = (uint64_t *)(v14 + 16);
  if (!*(void *)(v14 + 16))
  {
    id v15 = 0LL;
    goto LABEL_108;
  }

  v228 = 0;
  if (gLogDatapath)
  {
    v170 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v170, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 136446978;
      *(void *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = a3;
      WORD1(buf[2]) = 1024;
      HIDWORD(buf[2]) = a4;
      LOWORD(v261) = 1024;
      *(_DWORD *)((char *)&v261 + 2) = a5;
      _os_log_impl( &dword_181A5C000,  v170,  OS_LOG_TYPE_DEBUG,  "%{public}s called with minimum bytes: %u, maximum bytes: %u, maximum frames: %u",  (uint8_t *)buf,  0x1Eu);
    }
  }

  if (a4 >= a3 && a5)
  {
    *(void *)os_log_type_t type = 0LL;
    v243 = type;
    v244 = 0x3802000000LL;
    v245 = __Block_byref_object_copy__3159;
    v246 = __Block_byref_object_dispose__3160;
    v247[0] = 0LL;
    v247[1] = v247;
    v238 = 0LL;
    v239 = &v238;
    v241 = 0;
    v240 = 0x2000000000LL;
    v234 = 0LL;
    v235 = &v234;
    v237 = 0;
    v236 = 0x2000000000LL;
    os_log_type_t v17 = MEMORY[0x1895F87A8];
    buf[0] = MEMORY[0x1895F87A8];
    buf[1] = 0x40000000LL;
    buf[2] = ___ZL35__nw_protocol_fulfill_frame_requestP16nw_frame_array_sS0_bbjjjPjPb_block_invoke;
    v261 = (unint64_t)&unk_189BB6370;
    v262[0] = &v238;
    v262[1] = &v234;
    v265 = __PAIR64__(a4, a5);
    v263 = (unsigned int *)&v228;
    v264 = v14 + 16;
    LOWORD(v266) = 257;
    v262[2] = type;
    BOOL v18 = *v16;
    do
    {
      if (!v18) {
        break;
      }
      int v19 = *(void *)(v18 + 32);
      os_log_type_t v20 = ((uint64_t (*)(void *))buf[2])(buf);
      BOOL v18 = v19;
    }

    while ((v20 & 1) != 0);
    int v21 = *((void *)v243 + 5);
    int v22 = *((_DWORD *)v235 + 6);
    if (v22 < a3 && (v21 ? (char v23 = v228 == 0) : (char v23 = 0), v23))
    {
      if (gLogDatapath)
      {
        v208 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v208, OS_LOG_TYPE_DEBUG))
        {
          v209 = *((_DWORD *)v235 + 6);
          LODWORD(v258[0]) = 136446722;
          *(void *)((char *)v258 + 4) = "__nw_protocol_fulfill_frame_request";
          WORD2(v258[1]) = 1024;
          *(_DWORD *)((char *)&v258[1] + 6) = a3;
          WORD1(v258[2]) = 1024;
          HIDWORD(v258[2]) = v209;
          _os_log_impl( &dword_181A5C000,  v208,  OS_LOG_TYPE_DEBUG,  "%{public}s could not meet minimum byte count %u with %u bytes from source array",  (uint8_t *)v258,  0x18u);
        }
      }

      uint64_t v34 = v243;
      BOOL v35 = v243 + 40;
      if (*v16)
      {
        **((void **)v243 + 6) = *v16;
        *(void *)(*(void *)(v14 + 16) + 40LL) = *((void *)v34 + 6);
        *((void *)v34 + 6) = *(void *)(v14 + 24);
        *(void *)(v14 + 16) = 0LL;
        *(void *)(v14 + 24) = v16;
      }

      if (*v35)
      {
        **(void **)(v14 + 24) = *v35;
        *(void *)(*((void *)v34 + 5) + 40LL) = *(void *)(v14 + 24);
        *(void *)(v14 + 24) = *((void *)v34 + 6);
        *((void *)v34 + 5) = 0LL;
        *((void *)v34 + 6) = v35;
      }

      uint64_t v25 = 0;
      uint64_t v36 = v243;
      *((void *)v243 + 5) = 0LL;
      *((void *)v36 + 6) = v36 + 40;
      *((_DWORD *)v239 + 6) = 0;
      *((_DWORD *)v235 + 6) = 0;
    }

    else if (v21)
    {
      v258[0] = v17;
      v258[1] = 0x40000000LL;
      v258[2] = ___ZL35__nw_protocol_fulfill_frame_requestP16nw_frame_array_sS0_bbjjjPjPb_block_invoke_25;
      v258[3] = &unk_189BB6398;
      v259 = 1;
      v258[4] = type;
      v258[5] = a6;
      os_log_type_t v24 = *((void *)v243 + 5);
      uint64_t v25 = v22;
      do
      {
        if (!v24) {
          break;
        }
        uint64_t v26 = *(void *)(v24 + 32);
        __int16 v27 = ((uint64_t (*)(void *))v258[2])(v258);
        os_log_type_t v24 = v26;
      }

      while ((v27 & 1) != 0);
    }

    else
    {
      uint64_t v25 = *((_DWORD *)v235 + 6);
    }

    if (gLogDatapath)
    {
      v186 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v186, OS_LOG_TYPE_DEBUG))
      {
        v187 = *((_DWORD *)v239 + 6);
        v188 = *((_DWORD *)v235 + 6);
        v248 = 136447234;
        v249 = "__nw_protocol_fulfill_frame_request";
        v250 = 1024;
        v251 = v187;
        v252 = 1024;
        v253 = v188;
        v254 = 2048;
        v255 = v14 + 16;
        v256 = 2048;
        v257 = a6;
        _os_log_impl( &dword_181A5C000,  v186,  OS_LOG_TYPE_DEBUG,  "%{public}s moved (%u frames, %u bytes) from %p to %p",  (uint8_t *)&v248,  0x2Cu);
      }
    }

    id v15 = *((unsigned int *)v239 + 6);
    _Block_object_dispose(&v234, 8);
    _Block_object_dispose(&v238, 8);
    _Block_object_dispose(type, 8);
    goto LABEL_61;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  LODWORD(buf[0]) = 136446978;
  *(void *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
  WORD2(buf[1]) = 1024;
  *(_DWORD *)((char *)&buf[1] + 6) = a4;
  WORD1(buf[2]) = 1024;
  HIDWORD(buf[2]) = a3;
  LOWORD(v261) = 1024;
  *(_DWORD *)((char *)&v261 + 2) = a5;
  int v28 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v258[0]) = 0;
  if (__nwlog_fault(v28, type, v258))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v29 = gLogObj;
      unsigned __int8 v30 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = a4;
        WORD1(buf[2]) = 1024;
        HIDWORD(buf[2]) = a3;
        LOWORD(v261) = 1024;
        *(_DWORD *)((char *)&v261 + 2) = a5;
        uint64_t v31 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u";
LABEL_56:
        id v37 = (os_log_s *)v29;
LABEL_57:
        _os_log_impl(&dword_181A5C000, v37, v30, v31, (uint8_t *)buf, 0x1Eu);
      }
    }

    else if (LOBYTE(v258[0]))
    {
      unsigned __int8 v32 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned __int8 v30 = type[0];
      log = (os_log_s *)gLogObj;
      id v33 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v32)
      {
        if (v33)
        {
          LODWORD(buf[0]) = 136447234;
          *(void *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
          WORD2(buf[1]) = 1024;
          *(_DWORD *)((char *)&buf[1] + 6) = a4;
          WORD1(buf[2]) = 1024;
          HIDWORD(buf[2]) = a3;
          LOWORD(v261) = 1024;
          *(_DWORD *)((char *)&v261 + 2) = a5;
          HIWORD(v261) = 2082;
          v262[0] = v32;
          _os_log_impl( &dword_181A5C000,  log,  v30,  "%{public}s invalid values for frame request, max %u, min %u, max frame %u, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x28u);
        }

        free(v32);
        goto LABEL_58;
      }

      if (v33)
      {
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = a4;
        WORD1(buf[2]) = 1024;
        HIDWORD(buf[2]) = a3;
        LOWORD(v261) = 1024;
        *(_DWORD *)((char *)&v261 + 2) = a5;
        uint64_t v31 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u, no backtrace";
        id v37 = log;
        goto LABEL_57;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v29 = gLogObj;
      unsigned __int8 v30 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = a4;
        WORD1(buf[2]) = 1024;
        HIDWORD(buf[2]) = a3;
        LOWORD(v261) = 1024;
        *(_DWORD *)((char *)&v261 + 2) = a5;
        uint64_t v31 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u, backtrace limit exceeded";
        goto LABEL_56;
      }
    }
  }

  int v12 = a3;
  if (!a3)
  {
    v266 = v278;
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(v278 + 32) + 12LL));
    goto LABEL_456;
  }

  uint64_t v13 = a2;
  do
  {
    uint64_t v14 = *v13;
    address = (unsigned __int8 *)dnssd_getaddrinfo_result_get_address();
    tracker_hostname = dnssd_getaddrinfo_result_get_tracker_hostname();
    if (nw_parameters_get_sensitive_redacted(*(void **)(*(void *)(v278 + 32) + 16LL)))
    {
      if (address)
      {
        os_log_type_t v17 = address[1];
        if (v17 == 30)
        {
          if (*((_DWORD *)address + 2)
            || *((_DWORD *)address + 3)
            || *((_DWORD *)address + 4)
            || *((_DWORD *)address + 5))
          {
            os_log_type_t v20 = v299;
            __nwlog_salted_hash(address + 8, 16LL, v299);
            int v21 = "IPv6#";
          }

          else
          {
            int v21 = "";
            os_log_type_t v20 = "IN6ADDR_ANY";
          }

  *(void *)buf = dnssd_getaddrinfo_result_get_tracker_hostname();
  *(void *)os_log_type_t type = 0LL;
  *(void *)os_log_type_t type = dnssd_getaddrinfo_result_get_tracker_owner();
  uint64_t v25 = *(const char **)buf;
  if (*(void *)buf) {
    goto LABEL_19;
  }
  uint64_t v26 = nw_context_copy_tracker_lookup_callback(v9[4]);
  __int16 v27 = v26;
  if (v26)
  {
    id v44 = 0;
    (*((void (**)(void *, nw_endpoint_t, _BYTE *, os_log_type_t *, unsigned __int8 *))v26 + 2))( v26,  address,  buf,  type,  &v44);
    nw_endpoint_set_can_block_request(address, v44);
    nw_endpoint_set_can_block_request(v9[3], v44);
  }

  uint64_t v25 = *(const char **)buf;
  if (*(void *)buf | *(void *)type)
  {
LABEL_19:
    nw_endpoint_set_known_tracker_name(address, v25);
    nw_endpoint_set_known_tracker_name(v9[3], *(const char **)buf);
    nw_endpoint_set_tracker_owner(address, *(const char **)type);
    nw_endpoint_set_tracker_owner(v9[3], *(const char **)type);
  }

  interface_index = dnssd_getaddrinfo_result_get_interface_index();
  if (interface_index && (__int16 v29 = nw_endpoint_get_address(address), nw_resolver_should_scope_address(v29)))
  {
    unsigned __int8 v30 = nw_resolver_set_interface_on_endpoint(v9, interface_index, address);

    if (!v30) {
      goto LABEL_30;
    }
  }

  else
  {
  }

    os_log_type_t v8 = a3;
LABEL_16:
    if (a3)
    {
      if (v8) {
        *a2 = 0;
      }
    }

    goto LABEL_3;
  }

LABEL_16:
    if (!v16) {
      return;
    }
    goto LABEL_17;
  }

  if (v41[0] == OS_LOG_TYPE_DEFAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (os_log_s *)(id)gLogObj;
    int v22 = type[0];
    if (os_log_type_enabled(v17, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      v47 = "nw_endpoint_add_edge_block_invoke";
      _os_log_impl(&dword_181A5C000, v17, v22, "%{public}s nw_array_create failed, backtrace limit exceeded", buf, 0xCu);
    }

    goto LABEL_15;
  }

  int v19 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v17 = (os_log_s *)(id)gLogObj;
  os_log_type_t v20 = type[0];
  int v21 = os_log_type_enabled(v17, type[0]);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      v47 = "nw_endpoint_add_edge_block_invoke";
      _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s nw_array_create failed, no backtrace", buf, 0xCu);
    }

    goto LABEL_15;
  }

  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v47 = "nw_endpoint_add_edge_block_invoke";
    v48 = 2082;
    nw_endpoint_t v49 = v19;
    _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s nw_array_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v19);
  if (v16) {
LABEL_17:
  }
    free(v16);
}

            if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
            {
              id v11 = *(void *)(v4 + 88);
              if (v11)
              {
                int v12 = v11 - 1;
                *(void *)(v4 + 88) = v12;
                if (!v12)
                {
                  uint64_t v13 = *(void (***)(void))(v4 + 64);
                  if (v13)
                  {
                    *(void *)(v4 + 64) = 0LL;
                    v13[2](v13);
                    _Block_release(v13);
                  }

                  if ((*(_BYTE *)(v4 + 72) & 1) != 0)
                  {
                    uint64_t v14 = *(const void **)(v4 + 64);
                    if (v14) {
                      _Block_release(v14);
                    }
                  }

                  goto LABEL_25;
                }
              }
            }

            return;
          }

            if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
            {
              id v11 = *(void *)(v4 + 88);
              if (v11)
              {
                int v12 = v11 - 1;
                *(void *)(v4 + 88) = v12;
                if (!v12)
                {
                  uint64_t v13 = *(void (***)(void))(v4 + 64);
                  if (v13)
                  {
                    *(void *)(v4 + 64) = 0LL;
                    v13[2](v13);
                    _Block_release(v13);
                  }

                  if ((*(_BYTE *)(v4 + 72) & 1) != 0)
                  {
                    uint64_t v14 = *(const void **)(v4 + 64);
                    if (v14) {
                      _Block_release(v14);
                    }
                  }

                  goto LABEL_25;
                }
              }
            }

            return;
          }

            if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
            {
              id v11 = *(void *)(v4 + 88);
              if (v11)
              {
                int v12 = v11 - 1;
                *(void *)(v4 + 88) = v12;
                if (!v12)
                {
                  uint64_t v13 = *(void (***)(void))(v4 + 64);
                  if (v13)
                  {
                    *(void *)(v4 + 64) = 0LL;
                    v13[2](v13);
                    _Block_release(v13);
                  }

                  if ((*(_BYTE *)(v4 + 72) & 1) != 0)
                  {
                    uint64_t v14 = *(const void **)(v4 + 64);
                    if (v14) {
                      _Block_release(v14);
                    }
                  }

                  goto LABEL_25;
                }
              }
            }

            return;
          }

        goto LABEL_44;
      }

      os_log_type_t v17 = 1LL;
      break;
    case 2:
      id v15 = v4;
      BOOL v16 = [v15 type];

      os_log_type_t v17 = v16 != 3 && v16 != 0;
      if (v16 == 3 || !v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          __int16 v40 = "nw_group_descriptor_allows_endpoint";
          os_log_type_t v41 = 2112;
          id v42 = (char *)v15;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s Endpoint %@ is of invalid type for multiplex group",  buf,  0x16u);
        }
      }

      break;
    case 3:
      int v19 = v4;
      os_log_type_t v20 = [v19 type];

      os_log_type_t v17 = v20 == 6;
      break;
    default:
      goto LABEL_44;
  }

                int v12 = MEMORY[0x1895F87A8];
                *(void *)buf = MEMORY[0x1895F87A8];
                *(void *)&buf[8] = 3221225472LL;
                *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_11356;
                v166 = (const char *)&__block_descriptor_41_e31_B16__0__NSObject_OS_nw_frame__8l;
                uint64_t v13 = output_handler_context[6];
                *(void *)v167 = output_handler_context + 6;
                v167[8] = 0;
                do
                {
                  if (!v13) {
                    break;
                  }
                  uint64_t v14 = *(void *)(v13 + 32);
                  id v15 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                  uint64_t v13 = v14;
                }

                while ((v15 & 1) != 0);
                BOOL v16 = (void *)output_handler_context[5];
                output_handler_context[4] = 0LL;
                output_handler_context[5] = 0LL;

                BOOL v18 = nw_hash_table_remove_node(*((void *)v9 + 29), (uint64_t)output_handler_context);
                int v19 = *(void (**)(void))(*(void *)(*((void *)v9 + 1) + 80LL) + 24LL);
                if (v19) {
                  v19();
                }
                if (v18)
                {
                  a2->output_handler_context = 0LL;
                  os_log_type_t v20 = nw_hash_table_count(*((void *)v9 + 29), v17);
                  if (!v20) {
                    goto LABEL_24;
                  }
                  int v21 = v20;
                  *(void *)buf = 0LL;
                  *(void *)&buf[8] = buf;
                  *(void *)&buf[16] = 0x2020000000LL;
                  LOBYTE(v166) = 1;
                  int v22 = (char *)*((void *)v9 + 29);
                  v160[0] = v12;
                  v160[1] = 3221225472LL;
                  v160[2] = ___ZL47nw_protocol_implementation_remove_input_handlerP11nw_protocolS0_b_block_invoke;
                  v160[3] = &unk_189BB76C0;
                  v160[4] = buf;
                  nw_hash_table_apply(v22, (uint64_t)v160);
                  char v23 = *(unsigned __int8 *)(*(void *)&buf[8] + 24LL);
                  _Block_object_dispose(buf, 8);
                  if (!v23)
                  {
                    if ((v9[405] & 0x80000000) == 0 && gLogDatapath)
                    {
                      __nwlog_obj();
                      v151 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136447234;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v9 + 407;
                        *(_WORD *)&buf[22] = 2080;
                        v166 = " ";
                        *(_WORD *)v167 = 2048;
                        *(void *)&v167[2] = v9;
                        v168 = 1024;
                        LODWORD(v169) = v21;
                        _os_log_impl( &dword_181A5C000,  v151,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNot destroying instance %p, still have %u input handlers",  buf,  0x30u);
                      }
                    }

                    if (a1->default_input_handler == a2)
                    {
                      v47 = (char *)*((void *)v9 + 29);
                      v155[0] = v12;
                      v155[1] = 3221225472LL;
                      v155[2] = ___ZL47nw_protocol_implementation_remove_input_handlerP11nw_protocolS0_b_block_invoke_270;
                      v155[3] = &unk_189BB8550;
                      v157 = a1;
                      v156 = v9;
                      nw_hash_table_apply(v47, (uint64_t)v155);
                    }
                  }

                  else
                  {
LABEL_24:
                    if ((v9[405] & 0x80000000) == 0 && gLogDatapath)
                    {
                      __nwlog_obj();
                      id v88 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)buf = 136446722;
                        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v9 + 407;
                        *(_WORD *)&buf[22] = 2080;
                        v166 = " ";
                        _os_log_impl( &dword_181A5C000,  v88,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNo more input handlers on multiplexing connections, scheduling destroy",  buf,  0x20u);
                      }
                    }

                    default_input_handler = a1->default_input_handler;
                    if (default_input_handler)
                    {
                      if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
                      {
                        nw_endpoint_t v49 = default_input_handler[1].callbacks;
                        if (v49)
                        {
                          os_log_type_t v50 = (nw_protocol_callbacks *)((char *)v49 - 1);
                          default_input_handler[1].callbacks = v50;
                          if (!v50)
                          {
                            v51 = *(void (***)(void))default_input_handler[1].flow_id;
                            if (v51)
                            {
                              *(void *)default_input_handler[1].flow_id = 0LL;
                              v51[2](v51);
                              _Block_release(v51);
                            }

                            if ((default_input_handler[1].flow_id[8] & 1) != 0)
                            {
                              os_log_type_t v52 = *(const void **)default_input_handler[1].flow_id;
                              if (v52) {
                                _Block_release(v52);
                              }
                            }

                            free(default_input_handler);
                          }
                        }
                      }

                      a1->default_input_handler = 0LL;
                    }

                    if ((v9[405] & 0x80000000) == 0 && gLogDatapath)
                    {
                      __nwlog_obj();
                      v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                      if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
                      {
                        char v90 = *((_DWORD *)v9 + 40);
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_protocol_purge_frame_pool";
                        *(_WORD *)&buf[12] = 2082;
                        *(void *)&buf[14] = v9 + 407;
                        *(_WORD *)&buf[22] = 2080;
                        v166 = " ";
                        *(_WORD *)v167 = 1024;
                        *(_DWORD *)&v167[2] = v90;
                        _os_log_impl( &dword_181A5C000,  v89,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sPurging %u empty frames",  buf,  0x26u);
                      }
                    }

                    *(void *)buf = v12;
                    *(void *)&buf[8] = 3221225472LL;
                    *(void *)&buf[16] = ___ZL28nw_protocol_purge_frame_poolP31NWConcrete_nw_protocol_instance_block_invoke;
                    v166 = (const char *)&unk_189BC7910;
                    *(void *)v167 = v9;
                    uint64_t v25 = *((void *)v9 + 21);
                    do
                    {
                      if (!v25) {
                        break;
                      }
                      uint64_t v26 = *(void *)(v25 + 16);
                      __int16 v27 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                      uint64_t v25 = v26;
                    }

                    while ((v27 & 1) != 0);
                    if ((v9[404] & 8) != 0)
                    {
                      nw_protocol_implementation_destroy((NWConcrete_nw_protocol_instance *)v9);
                    }

                    else if ((~v9[402] & 0x18) != 0 || !*((void *)v9 + 3))
                    {
                      if ((v9[405] & 0x80000000) == 0 && gLogDatapath)
                      {
                        __nwlog_obj();
                        v150 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v150, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)buf = 136446978;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v9 + 407;
                          *(_WORD *)&buf[22] = 2080;
                          v166 = " ";
                          *(_WORD *)v167 = 2048;
                          *(void *)&v167[2] = v9;
                          _os_log_impl( &dword_181A5C000,  v150,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDestroying instance %p immediately",  buf,  0x2Au);
                        }
                      }

                      nw_protocol_implementation_teardown((NWConcrete_nw_protocol_instance *)v9);
                    }

                    else
                    {
                      int v28 = *((void *)v9 + 4);
                      if (v28)
                      {
                        nw_queue_cancel_source(v28, v25);
                        *((void *)v9 + 4) = 0LL;
                      }

                      __int16 v29 = (void *)*((void *)v9 + 15);
                      v158[0] = v12;
                      v158[1] = 3221225472LL;
                      v158[2] = ___ZL47nw_protocol_implementation_remove_input_handlerP11nw_protocolS0_b_block_invoke_269;
                      v158[3] = &unk_189BC93A0;
                      unsigned __int8 v30 = v9;
                      v159 = v30;
                      *((void *)v9 + 4) = nw_queue_context_create_source(v29, 2, 3, 0, v158, 0LL);
                      int64_with_default = networkd_settings_get_int64_with_default( (const char *)nw_setting_multiplexing_teardown_delay,  10LL);
                      unsigned __int8 v32 = *((void *)v9 + 4);
                      id v33 = dispatch_time(0x8000000000000000LL, 1000000000 * int64_with_default);
                      nw_queue_set_timer_values(v32, v33, 0xFFFFFFFFFFFFFFFFLL, 1000000 * int64_with_default);
                      nw_queue_activate_source(*((void *)v9 + 4), v34);
                      if ((v9[405] & 0x80000000) == 0 && gLogDatapath)
                      {
                        __nwlog_obj();
                        v153 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        if (os_log_type_enabled(v153, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)buf = 136447234;
                          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_remove_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(void *)&buf[14] = v30 + 407;
                          *(_WORD *)&buf[22] = 2080;
                          v166 = " ";
                          *(_WORD *)v167 = 2048;
                          *(void *)&v167[2] = v30;
                          v168 = 2048;
                          v169 = (char *)int64_with_default;
                          _os_log_impl( &dword_181A5C000,  v153,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sDestroying instance %p after delay of %lld seconds",  buf,  0x34u);
                        }
                      }
                    }
                  }

  evaluator = self->evaluator;
  if (evaluator) {
    nw_path_evaluator_cancel(evaluator);
  }
  v22.receiver = self;
  v22.super_class = (Class)&OBJC_CLASS____NWAdvertiser;
  -[_NWAdvertiser dealloc](&v22, sel_dealloc, v20, v21);
}

      v221[0] = 0;
LABEL_16:
      id v11 = v3;
      int v12 = *((unsigned __int8 *)&v11->path_parameters->path_value + 30);

      attributed_bundle = v11->path_parameters->attributed_bundle;
      if (v12)
      {
        uint64_t v14 = attributed_bundle;
        id v15 = v14;
        if (v14 && (BOOL v16 = *((_DWORD *)v14 + 31), (v16 - 2) >= 2))
        {
          private_redacted = v16 != 1;
        }

        else
        {
          if (nwlog_get_sensitive_redacted::onceToken != -1) {
            dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
          }
          private_redacted = nwlog_get_sensitive_redacted::sensitiveRedacted != 0;
        }
      }

      else
      {
        private_redacted = nw_context_get_private_redacted(attributed_bundle);
      }

      BOOL v18 = v11;
      multipath_service = v11->path_parameters->joinable_path_value.multipath_service;

      if ((multipath_service & 0x2000) == 0)
      {
        url_endpoint = v11->url_endpoint;
        if (private_redacted)
        {
          nw_endpoint_get_url_hash(url_endpoint);
          snprintf(v220, 0x80uLL, ", url hash: %s");
        }

        else
        {
          nw_endpoint_get_sanitized_url(url_endpoint);
          snprintf(v220, 0x80uLL, ", url: %s");
        }

  int v9 = (const char *)*((void *)v4 + 14);
  if (!v9) {
    goto LABEL_23;
  }
  if (!v7)
  {
    *(void *)buf = 0LL;
    *(void *)&buf[8] = 0LL;
    uint64_t v7 = (id)-[NWConcrete_nw_application_id initWithUUID:auditToken:pid:bundleID:isBundleIDExternal:systemService:]( objc_alloc(&OBJC_CLASS___NWConcrete_nw_application_id),  buf,  0LL,  v9,  0);
    if (gLogDatapath)
    {
LABEL_32:
      __nwlog_obj();
      BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_parameters_copy_application_id";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v7;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = v9;
        _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s getting application ID %@ from parameters bundle ID: %s",  buf,  0x20u);
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "nw_protocol_http_client_bottom_disconnect";
    int v28 = 2048;
    __int16 v29 = a2;
    uint64_t v7 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      int v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "nw_protocol_http_client_bottom_disconnect";
        int v28 = 2048;
        __int16 v29 = a2;
        uint64_t v10 = "%{public}s Protocol %p isn't an input handler of http client bottom";
LABEL_28:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0x16u);
      }
    }

    else if (v24)
    {
      id v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      int v9 = type;
      int v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v11)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          __int16 v27 = "nw_protocol_http_client_bottom_disconnect";
          int v28 = 2048;
          __int16 v29 = a2;
          unsigned __int8 v30 = 2082;
          uint64_t v31 = v11;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s Protocol %p isn't an input handler of http client bottom, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v11);
        goto LABEL_29;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "nw_protocol_http_client_bottom_disconnect";
        int v28 = 2048;
        __int16 v29 = a2;
        uint64_t v10 = "%{public}s Protocol %p isn't an input handler of http client bottom, no backtrace";
        goto LABEL_28;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      int v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "nw_protocol_http_client_bottom_disconnect";
        int v28 = 2048;
        __int16 v29 = a2;
        uint64_t v10 = "%{public}s Protocol %p isn't an input handler of http client bottom, backtrace limit exceeded";
        goto LABEL_28;
      }
    }

      goto LABEL_16;
    }

    if (!v27)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v15 = (os_log_s *)(id)gconnectionLogObj;
      char v23 = type;
      if (os_log_type_enabled(v15, type))
      {
        os_log_type_t v24 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446466;
        unsigned __int8 v30 = "__nw_connection_async_on_queue";
        uint64_t v31 = 1024;
        unsigned __int8 v32 = v24;
        _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s [C%u] unable to dispatch block, backtrace limit exceeded",  buf,  0x12u);
      }

      goto LABEL_15;
    }

    backtrace_string = __nw_create_backtrace_string();
    if (!backtrace_string)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      id v15 = (os_log_s *)(id)gconnectionLogObj;
      uint64_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        uint64_t v26 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446466;
        unsigned __int8 v30 = "__nw_connection_async_on_queue";
        uint64_t v31 = 1024;
        unsigned __int8 v32 = v26;
        _os_log_impl(&dword_181A5C000, v15, v25, "%{public}s [C%u] unable to dispatch block, no backtrace", buf, 0x12u);
      }

      goto LABEL_15;
    }

    int v19 = (char *)backtrace_string;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    os_log_type_t v20 = (os_log_s *)(id)gconnectionLogObj;
    int v21 = type;
    if (os_log_type_enabled(v20, type))
    {
      int v22 = *((_DWORD *)v7 + 112);
      *(_DWORD *)buf = 136446722;
      unsigned __int8 v30 = "__nw_connection_async_on_queue";
      uint64_t v31 = 1024;
      unsigned __int8 v32 = v22;
      id v33 = 2082;
      uint64_t v34 = v19;
      _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s [C%u] unable to dispatch block, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

    free(v19);
    if (v14) {
      goto LABEL_17;
    }
  }

  v17.receiver = self;
  v17.super_class = (Class)&OBJC_CLASS___NWConcrete_tcp_connection;
  -[NWConcrete_tcp_connection dealloc](&v17, sel_dealloc, v15, v16);
}

  if (gLogDatapath)
  {
    __int16 v27 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_master_frame_array";
      _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }

  *(void *)buf = v2;
  *(void *)&buf[8] = 0x40000000LL;
  *(void *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_33155;
  v48 = (const char *)&__block_descriptor_tmp_56_33156;
  nw_endpoint_t v49 = 0;
  int v9 = *(void *)(v1 + 624);
  do
  {
    if (!v9) {
      break;
    }
    uint64_t v10 = *(void *)(v9 + 16);
    id v11 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    int v9 = v10;
  }

  while ((v11 & 1) != 0);
  if (!*(void *)(v1 + 624)) {
    goto LABEL_20;
  }
  __nwlog_obj();
  *(_DWORD *)__int16 v43 = 136446210;
  id v44 = "nw_protocol_finalize_master_frame_array";
  int v28 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v41 = 0;
  if (__nwlog_fault(v28, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v29 = (os_log_s *)__nwlog_obj();
      unsigned __int8 v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_95;
      }
      *(_DWORD *)__int16 v43 = 136446210;
      id v44 = "nw_protocol_finalize_master_frame_array";
      uint64_t v31 = "%{public}s frame array is not empty after finalize";
      goto LABEL_94;
    }

    if (!v41)
    {
      __int16 v29 = (os_log_s *)__nwlog_obj();
      unsigned __int8 v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_95;
      }
      *(_DWORD *)__int16 v43 = 136446210;
      id v44 = "nw_protocol_finalize_master_frame_array";
      uint64_t v31 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
      goto LABEL_94;
    }

    char v39 = (char *)__nw_create_backtrace_string();
    __int16 v29 = (os_log_s *)__nwlog_obj();
    unsigned __int8 v30 = type;
    __int16 v40 = os_log_type_enabled(v29, type);
    if (v39)
    {
      if (v40)
      {
        *(_DWORD *)__int16 v43 = 136446466;
        id v44 = "nw_protocol_finalize_master_frame_array";
        id v45 = 2082;
        v46 = v39;
        _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s",  v43,  0x16u);
      }

      free(v39);
      goto LABEL_95;
    }

    if (v40)
    {
      *(_DWORD *)__int16 v43 = 136446210;
      id v44 = "nw_protocol_finalize_master_frame_array";
      uint64_t v31 = "%{public}s frame array is not empty after finalize, no backtrace";
LABEL_94:
      _os_log_impl(&dword_181A5C000, v29, v30, v31, v43, 0xCu);
    }
  }

  uint64_t v14 = v6 + v8 + 5;
LABEL_32:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v14;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

  uint64_t v14 = v6 + v8 + 5;
LABEL_32:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v14;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

      unsigned __int8 v6 = *v4 & 0xFFF7 | (*(unsigned __int8 *)(v2 + 874) << 16);
LABEL_27:
      *id v4 = v6;
      *(_BYTE *)(v2 + 874) = BYTE2(v6);
      nw_http_transaction_metadata_mark_inbound_message_end(*(void **)(*(void *)(v2 + 488) + 352LL));
      if (v3) {
        os_release((void *)v3);
      }
      return 0LL;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned __int8 v30 = "nw_http1_on_message_complete";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = (os_log_s *)__nwlog_obj();
      int v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned __int8 v30 = "nw_http1_on_message_complete";
        uint64_t v13 = "%{public}s called with null http1_connection";
        goto LABEL_70;
      }

      goto LABEL_71;
    }

    if (!v27)
    {
      id v11 = (os_log_s *)__nwlog_obj();
      int v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned __int8 v30 = "nw_http1_on_message_complete";
        uint64_t v13 = "%{public}s called with null http1_connection, backtrace limit exceeded";
        goto LABEL_70;
      }

      goto LABEL_71;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v11 = (os_log_s *)__nwlog_obj();
    int v12 = type;
    uint64_t v25 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        unsigned __int8 v30 = "nw_http1_on_message_complete";
        uint64_t v13 = "%{public}s called with null http1_connection, no backtrace";
        goto LABEL_70;
      }

      goto LABEL_71;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      unsigned __int8 v30 = "nw_http1_on_message_complete";
      uint64_t v31 = 2082;
      unsigned __int8 v32 = backtrace_string;
      os_log_type_t v24 = "%{public}s called with null http1_connection, dumping backtrace:%{public}s";
      goto LABEL_58;
    }

    goto LABEL_59;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned __int8 v30 = "nw_http1_on_message_complete";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v27 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v27)
    {
      id v11 = (os_log_s *)__nwlog_obj();
      int v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned __int8 v30 = "nw_http1_on_message_complete";
        uint64_t v13 = "%{public}s called with null parser, backtrace limit exceeded";
        goto LABEL_70;
      }

      goto LABEL_71;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v11 = (os_log_s *)__nwlog_obj();
    int v12 = type;
    char v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        unsigned __int8 v30 = "nw_http1_on_message_complete";
        uint64_t v13 = "%{public}s called with null parser, no backtrace";
        goto LABEL_70;
      }

      goto LABEL_71;
    }

    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      unsigned __int8 v30 = "nw_http1_on_message_complete";
      uint64_t v31 = 2082;
      unsigned __int8 v32 = backtrace_string;
      os_log_type_t v24 = "%{public}s called with null parser, dumping backtrace:%{public}s";
LABEL_58:
      _os_log_impl(&dword_181A5C000, v11, v12, v24, buf, 0x16u);
    }

      id v1 = 0LL;
      goto LABEL_44;
    }

    [v1 originalRequest];
    int v12 = (void *)objc_claimAutoreleasedReturnValue();
    [v12 valueForHTTPHeaderField:@"Range"];
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();

    if (v7
      && (-[os_log_s componentsSeparatedByString:](v7, "componentsSeparatedByString:", @"-"),
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(),
          uint64_t v14 = [v13 count],
          v13,
          v14 >= 3))
    {
      if (__nwlog_url_log::onceToken != -1) {
        dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
      }
      id v15 = (os_log_s *)(id)gurlLogObj;
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_40;
      }
      unsigned __int8 v30 = 0;
      BOOL v16 = "Cannot create download resume data because original request has multiple ranges";
      os_log_type_t v17 = (uint8_t *)&v30;
    }

    else
    {
      [v1 response];
      BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v18)
      {
        if (__nwlog_url_log::onceToken != -1) {
          dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
        }
        os_log_type_t v24 = (os_log_s *)(id)gurlLogObj;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int16 v29 = 0;
          _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEBUG,  "Creating download resume data with nil response",  v29,  2u);
        }

        +[NWURLSessionDownloadResumeInfo infoWithTask:]((uint64_t)&OBJC_CLASS___NWURLSessionDownloadResumeInfo, v1);
        id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        -[NWURLSessionDownloadResumeInfo serialize]((uint64_t)v15);
        id v1 = (id)objc_claimAutoreleasedReturnValue();
        goto LABEL_43;
      }

      [v1 response];
      int v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        [v1 response];
        id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        int v21 = -[os_log_s valueForHTTPHeaderField:](v15, "valueForHTTPHeaderField:", @"ETag");
        int v22 = -[os_log_s valueForHTTPHeaderField:](v15, "valueForHTTPHeaderField:", @"Last-Modified");
        if (v21 | v22)
        {
          +[NWURLSessionDownloadResumeInfo infoWithTask:]((uint64_t)&OBJC_CLASS___NWURLSessionDownloadResumeInfo, v1);
          uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue();
          -[NWURLSessionDownloadResumeInfo serialize]((uint64_t)v25);
          id v1 = (id)objc_claimAutoreleasedReturnValue();
        }

        else
        {
          if (__nwlog_url_log::onceToken != -1) {
            dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
          }
          char v23 = (os_log_s *)(id)gurlLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int16 v27 = 0;
            _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "Cannot create download resume data without ETag or Last-Modified",  v27,  2u);
          }

          id v1 = 0LL;
        }

        goto LABEL_43;
      }

      if (__nwlog_url_log::onceToken != -1) {
        dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
      }
      id v15 = (os_log_s *)(id)gurlLogObj;
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
LABEL_40:
        id v1 = 0LL;
LABEL_43:

        goto LABEL_44;
      }

      *(_WORD *)int v28 = 0;
      BOOL v16 = "Cannot create download resume data with non-HTTP response";
      os_log_type_t v17 = v28;
    }

    _os_log_impl(&dword_181A5C000, v15, OS_LOG_TYPE_DEBUG, v16, v17, 2u);
    goto LABEL_40;
  }

  return v1;
}

      char v23 = v8 != 0LL;
      os_log_type_t v24 = *(void *)(a1 + 32);
      if (!v8)
      {
LABEL_11:
        uint64_t v25 = 0LL;
        if (!v24)
        {
LABEL_36:
          unsigned __int8 v32 = 0LL;
          goto LABEL_37;
        }

    free(v7);
    goto LABEL_16;
  }

  uint64_t v3 = nw_parameters_create();
  internalParameters = v2->_internalParameters;
  v2->_internalParameters = v3;

  if (!v2->_internalParameters)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned __int8 v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    int v28 = "-[NWParameters init]";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      int v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "-[NWParameters init]";
      uint64_t v10 = "%{public}s nw_parameters_create failed";
LABEL_20:
      BOOL v16 = v8;
      os_log_type_t v17 = v9;
      goto LABEL_21;
    }

    if (!v24)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      int v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "-[NWParameters init]";
      uint64_t v10 = "%{public}s nw_parameters_create failed, backtrace limit exceeded";
      goto LABEL_20;
    }

    id v11 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)(id)gLogObj;
    int v12 = type;
    uint64_t v13 = os_log_type_enabled(v8, type);
    if (!v11)
    {
      if (!v13)
      {
LABEL_22:

        if (!v7) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }

      *(_DWORD *)buf = 136446210;
      int v28 = "-[NWParameters init]";
      uint64_t v10 = "%{public}s nw_parameters_create failed, no backtrace";
      BOOL v16 = v8;
      os_log_type_t v17 = v12;
LABEL_21:
      _os_log_impl(&dword_181A5C000, v16, v17, v10, buf, 0xCu);
      goto LABEL_22;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      int v28 = "-[NWParameters init]";
      __int16 v29 = 2082;
      unsigned __int8 v30 = v11;
      _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    uint64_t v14 = (char *)v11;
    goto LABEL_13;
  }

  int v5 = v2;
LABEL_17:

  return v5;
}

          free(v8);
          if (!v3) {
            return;
          }
LABEL_23:
          free(v3);
          return;
        }

        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v18 = "__nw_frame_empty_finalizer";
          unsigned __int8 v6 = "%{public}s called with null context, no backtrace";
          goto LABEL_21;
        }
      }

      else
      {
        id v4 = (os_log_s *)__nwlog_obj();
        int v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v18 = "__nw_frame_empty_finalizer";
          unsigned __int8 v6 = "%{public}s called with null context, backtrace limit exceeded";
          goto LABEL_21;
        }
      }
    }

    goto LABEL_22;
  }

  if (gLogDatapath)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      BOOL v18 = "__nw_frame_empty_finalizer";
      int v19 = 2048;
      os_log_type_t v20 = a1;
      _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_DEBUG, "%{public}s finalizing empty frame %p", buf, 0x16u);
    }
  }

  nw_frame_reset((uint64_t)a1, 0LL, 0, 0LL, 0LL);
  os_release(a1);
}

                    *(_BYTE *)(a1 + 81) = 2;
                    uint64_t v14 = *(uint64_t (***)(uint64_t))(a1 + 88);
                    if (v14)
                    {
                      id v15 = *v14;
                      if (v15)
                      {
                        BOOL v16 = v15(a1);
                        if (v16)
                        {
                          if (v16 != 21)
                          {
                            BOOL result = 0LL;
                            *(_DWORD *)(a1 + 24) = 16;
                            goto LABEL_2272;
                          }

                          BOOL result = 0LL;
                          *(_DWORD *)(a1 + 24) = 21;
                          *(void *)(a1 + 32) = "on_message_begin pause";
                          *(void *)(a1 + 40) = a2;
                          *(void *)(a1 + 56) = 236LL;
                          return result;
                        }
                      }
                    }

  if (a5 < 0x4000)
  {
    int v9 = 2LL;
    goto LABEL_23;
  }

  if (!(a5 >> 30))
  {
    int v9 = 4LL;
    goto LABEL_23;
  }

  if (!(a5 >> 62))
  {
    int v9 = 8LL;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  int v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    int v9 = 0LL;
    goto LABEL_23;
  }

  if (a5 < 0x4000)
  {
    int v9 = 2LL;
    goto LABEL_23;
  }

  if (!(a5 >> 30))
  {
    int v9 = 4LL;
    goto LABEL_23;
  }

  if (!(a5 >> 62))
  {
    int v9 = 8LL;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  int v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    int v9 = 0LL;
    goto LABEL_23;
  }

  if (a5 < 0x4000)
  {
    int v9 = 2LL;
    goto LABEL_23;
  }

  if (!(a5 >> 30))
  {
    int v9 = 4LL;
    goto LABEL_23;
  }

  if (!(a5 >> 62))
  {
    int v9 = 8LL;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  int v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    int v9 = 0LL;
    goto LABEL_23;
  }

  if (a5 < 0x4000)
  {
    int v9 = 2LL;
    goto LABEL_23;
  }

  if (!(a5 >> 30))
  {
    int v9 = 4LL;
    goto LABEL_23;
  }

  if (!(a5 >> 62))
  {
    int v9 = 8LL;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  int v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    int v9 = 0LL;
    goto LABEL_23;
  }

  if (a5 < 0x4000)
  {
    int v9 = 2LL;
    goto LABEL_23;
  }

  if (!(a5 >> 30))
  {
    int v9 = 4LL;
    goto LABEL_23;
  }

  if (!(a5 >> 62))
  {
    int v9 = 8LL;
    goto LABEL_23;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  int v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    int v9 = 0LL;
    goto LABEL_23;
  }

  free(v4);
  int address_family = nw_endpoint_get_address_family(v3);
  id v11 = 436LL;
  int v12 = (char *)a2;
  if (address_family == 30)
  {
    while (*v12)
    {
      ++v12;
      if (!--v11) {
        goto LABEL_28;
      }
    }

    if (v11 < 2) {
      goto LABEL_27;
    }
    uint64_t v13 = 46;
    goto LABEL_26;
  }

  while (*v12)
  {
    ++v12;
    if (!--v11) {
      goto LABEL_28;
    }
  }

  if (v11 >= 2)
  {
    uint64_t v13 = 58;
LABEL_26:
    *v12++ = v13;
  }

      if ((v12 & 0x10) != 0) {
        goto LABEL_18;
      }
      int v19 = malloc(0xC0uLL);
      if (v19)
      {
        os_log_type_t v20 = *((_OWORD *)v9 + 9);
        v19[8] = *((_OWORD *)v9 + 8);
        v19[9] = v20;
        int v21 = *((_OWORD *)v9 + 11);
        v19[10] = *((_OWORD *)v9 + 10);
        v19[11] = v21;
        int v22 = *((_OWORD *)v9 + 5);
        v19[4] = *((_OWORD *)v9 + 4);
        v19[5] = v22;
        char v23 = *((_OWORD *)v9 + 7);
        v19[6] = *((_OWORD *)v9 + 6);
        v19[7] = v23;
        os_log_type_t v24 = *((_OWORD *)v9 + 1);
        void *v19 = *(_OWORD *)v9;
        v19[1] = v24;
        uint64_t v25 = *((_OWORD *)v9 + 3);
        v19[2] = *((_OWORD *)v9 + 2);
        v19[3] = v25;
        uint64_t v26 = *(void **)(a1 + 88);
        *(void *)int v19 = 0LL;
        *((void *)v19 + 1) = v26;
        const char *v26 = v19;
        *(void *)(a1 + 88) = v19;
        int v12 = *((_DWORD *)v19 + 26) | 0x10;
        *((_DWORD *)v19 + 26) = v12;
        int v9 = v19;
LABEL_18:
        if (!v16)
        {
          *a3 += v9[16];
          unsigned __int8 v32 = *(FILE **)(a1 + 48);
          if (v32)
          {
            fwrite("qdec: debug: ", 0xDuLL, 1uLL, v32);
            fprintf(*(FILE **)(a1 + 48), "header block for stream %llu needs more bytes", v9[5]);
            fputc(10, *(FILE **)(a1 + 48));
          }

          return 2LL;
        }

        __int16 v27 = *(_DWORD *)(a1 + 224);
        if (v27 < *(_DWORD *)(a1 + 16))
        {
          int v28 = v9[8] & 7;
          v9[2] = 0LL;
          __int16 v29 = a1 + 16 * v28;
          v9[3] = *(void *)(v29 + 104);
          **(void **)(v29 + 104) = v9;
          *(void *)(v29 + 104) = v9 + 2;
          *(_DWORD *)(a1 + 224) = v27 + 1;
          *((_DWORD *)v9 + 26) = v12 | 4;
          *a3 += v9[16];
          unsigned __int8 v30 = *(FILE **)(a1 + 48);
          uint64_t v31 = 1LL;
          if (v30)
          {
            fwrite("qdec: debug: ", 0xDuLL, 1uLL, v30);
            fprintf(*(FILE **)(a1 + 48), "header block for stream %llu is blocked", v9[5]);
            fputc(10, *(FILE **)(a1 + 48));
          }

          return v31;
        }

        BOOL v18 = (FILE **)(a1 + 48);
        id v33 = *(FILE **)(a1 + 48);
        if (v33)
        {
          fwrite("qdec: info: ", 0xCuLL, 1uLL, v33);
          fprintf(*(FILE **)(a1 + 48), "cannot block another header: reached maximum of %u");
LABEL_27:
          uint64_t v31 = 3LL;
LABEL_28:
          fputc(10, *v18);
          goto LABEL_63;
        }
      }

  if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    int v12 = *(void *)(v4 + 88);
    if (v12)
    {
      uint64_t v13 = v12 - 1;
      *(void *)(v4 + 88) = v13;
      if (!v13)
      {
        uint64_t v14 = *(void (***)(void))(v4 + 64);
        if (v14)
        {
          *(void *)(v4 + 64) = 0LL;
          v14[2](v14);
          _Block_release(v14);
        }

        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          id v15 = *(const void **)(v4 + 64);
          if (v15) {
            _Block_release(v15);
          }
        }

        free((void *)v4);
      }
    }
  }

  return v11;
}

      if ((*((_BYTE *)v3 + 140) & 8) == 0) {
        goto LABEL_35;
      }
      if (*((void *)v10 + 9))
      {
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
        }
        BOOL v16 = (os_log_s *)(id)gactivityLogObj;
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_34;
        }
        os_log_type_t v17 = *((void *)v10 + 9);
        BOOL v18 = *((_DWORD *)v10 + 32);
        *(_DWORD *)buf = 138412802;
        BOOL v54 = (const char *)v10;
        os_log_type_t v55 = 2080;
        *(void *)v56 = v17;
        *(_WORD *)&v56[8] = 1024;
        os_log_type_t v57 = v18;
        int v19 = "Original activity %@ was completed, ignoring underlying error domain: %s, code: %d";
        os_log_type_t v20 = v16;
        int v21 = 28;
      }

      else
      {
        if (!*((_DWORD *)v10 + 31) && !*((_DWORD *)v10 + 32)) {
          goto LABEL_35;
        }
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
        }
        BOOL v16 = (os_log_s *)(id)gactivityLogObj;
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_34;
        }
        uint64_t v25 = *((_DWORD *)v10 + 31);
        uint64_t v26 = *((_DWORD *)v10 + 32);
        *(_DWORD *)buf = 138412802;
        BOOL v54 = (const char *)v10;
        os_log_type_t v55 = 1024;
        *(_DWORD *)v56 = v25;
        *(_WORD *)&v56[4] = 1024;
        *(_DWORD *)&v56[6] = v26;
        int v19 = "Original activity %@ was completed, ignoring underlying error domain: %d, code: %d";
        os_log_type_t v20 = v16;
        int v21 = 24;
      }

      _os_log_impl(&dword_181A5C000, v20, OS_LOG_TYPE_DEBUG, v19, buf, v21);
LABEL_34:

LABEL_35:
      __int16 v27 = v10;
      int v28 = v27[17];

      __int16 v29 = v5;
      uuid_generate_random((unsigned __int8 *)v29 + 8);
      *((_BYTE *)v29 + 17) = *((_BYTE *)v29 + 17) & 0xFE | v28 & 1;
      os_unfair_lock_lock((os_unfair_lock_t)v29 + 26);
      unsigned __int8 v30 = (void *)v29[11];
      if ((v29[12] & 1) != 0 && v30)
      {
        v29[11] = 0LL;

        unsigned __int8 v30 = (void *)v29[11];
      }

      v29[11] = 0LL;

      os_unfair_lock_unlock((os_unfair_lock_t)v29 + 26);
      if (nw_activity_should_log(v29))
      {
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
        }
        uint64_t v31 = (os_log_s *)(id)gactivityLogObj;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          BOOL v54 = (const char *)v29;
          _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEFAULT, "Create activity %{public}@", buf, 0xCu);
        }
      }

      goto LABEL_44;
    }

    __nwlog_obj();
    id v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v54 = "-[NWConcrete_nw_activity initWithOriginal:]";
    char v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v50 = 0;
    if ((__nwlog_fault(v39, &type, &v50) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v54 = "-[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl(&dword_181A5C000, v40, v41, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v50)
      {
        id v45 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v46 = type;
        v47 = os_log_type_enabled(v40, type);
        if (v45)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v54 = "-[NWConcrete_nw_activity initWithOriginal:]";
            os_log_type_t v55 = 2082;
            *(void *)v56 = v45;
            _os_log_impl( &dword_181A5C000,  v40,  v46,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v45);
          goto LABEL_87;
        }

        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v54 = "-[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl(&dword_181A5C000, v40, v46, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        nw_endpoint_t v49 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v54 = "-[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl( &dword_181A5C000,  v40,  v49,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    free(v7);
    goto LABEL_16;
  }

  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_protocol_transform);
  internalTransform = v2->_internalTransform;
  v2->_internalTransform = (OS_nw_protocol_transform *)v3;

  if (!v2->_internalTransform)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned __int8 v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    int v28 = "-[NWProtocolTransform init]";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      int v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "-[NWProtocolTransform init]";
      uint64_t v10 = "%{public}s nw_protocol_transform_create failed";
LABEL_20:
      BOOL v16 = v8;
      os_log_type_t v17 = v9;
      goto LABEL_21;
    }

    if (!v24)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      int v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      int v28 = "-[NWProtocolTransform init]";
      uint64_t v10 = "%{public}s nw_protocol_transform_create failed, backtrace limit exceeded";
      goto LABEL_20;
    }

    id v11 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)(id)gLogObj;
    int v12 = type;
    uint64_t v13 = os_log_type_enabled(v8, type);
    if (!v11)
    {
      if (!v13)
      {
LABEL_22:

        if (!v7) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }

      *(_DWORD *)buf = 136446210;
      int v28 = "-[NWProtocolTransform init]";
      uint64_t v10 = "%{public}s nw_protocol_transform_create failed, no backtrace";
      BOOL v16 = v8;
      os_log_type_t v17 = v12;
LABEL_21:
      _os_log_impl(&dword_181A5C000, v16, v17, v10, buf, 0xCu);
      goto LABEL_22;
    }

    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      int v28 = "-[NWProtocolTransform init]";
      __int16 v29 = 2082;
      unsigned __int8 v30 = v11;
      _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s nw_protocol_transform_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    uint64_t v14 = (char *)v11;
    goto LABEL_13;
  }

  int v5 = v2;
LABEL_17:

  return v5;
}

        goto LABEL_49;
      default:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v9 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        id v33 = "nw_protocol_transform_clear_protocols_at_level";
        uint64_t v34 = 1024;
        *(_DWORD *)BOOL v35 = a2;
        unsigned __int8 v6 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        unsigned __int8 v30 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v10 = (os_log_s *)(id)gLogObj;
          id v11 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            id v33 = "nw_protocol_transform_clear_protocols_at_level";
            uint64_t v34 = 1024;
            *(_DWORD *)BOOL v35 = a2;
            _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s Invalid protocol level %u", buf, 0x12u);
          }

    os_log_type_t v17 = *(void *)(v14 + 24);
    if (v17)
    {
      BOOL v18 = *(void (**)(uint64_t, char *, uint64_t))(v17 + 8);
      if (v18)
      {
        v18(v14, handle + 64, 1LL);
LABEL_18:
        nw_protocol_set_output_handler((uint64_t)(handle + 64), 0LL);
        if ((*v11 & 0x800) == 0)
        {
          if (gLogDatapath)
          {
            v101 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
            {
              v102 = *(_DWORD *)(*((void *)handle + 42) + 1280LL);
              v103 = *((void *)handle + 30);
              v104 = (nw_protocol *)*((void *)handle + 31);
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = handle + 636;
              *(_WORD *)&buf[22] = 2080;
              v151 = (uint64_t)" ";
              LOWORD(v152) = 1024;
              *(_DWORD *)((char *)&v152 + 2) = v102;
              WORD3(v152) = 2048;
              *((void *)&v152 + 1) = v103;
              v153 = 2048;
              v154 = v104;
              _os_log_impl( &dword_181A5C000,  v101,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> Closed datagram flow %llu",  buf,  0x3Au);
            }
          }
        }

        goto LABEL_20;
      }
    }

    __nwlog_obj();
    v75 = *(const char **)(v14 + 16);
    if (!v75) {
      v75 = "invalid";
    }
LABEL_176:
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v75;
    v114 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v115 = (char *)v114;
    v148 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v116 = (os_log_s *)__nwlog_obj();
      v117 = type;
      v145 = v116;
      if (!os_log_type_enabled(v116, type)) {
        goto LABEL_198;
      }
      v118 = "invalid";
      if (v14 && *(void *)(v14 + 16)) {
        v118 = *(const char **)(v14 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v118;
      v119 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
    }

    else
    {
      if (v148)
      {
        v120 = (char *)__nw_create_backtrace_string();
        v146 = (os_log_s *)__nwlog_obj();
        logb = type;
        v121 = os_log_type_enabled(v146, type);
        if (v120)
        {
          if (v121)
          {
            v122 = "invalid";
            if (v14 && *(void *)(v14 + 16)) {
              v122 = *(const char **)(v14 + 16);
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v122;
            *(_WORD *)&buf[22] = 2082;
            v151 = (uint64_t)v120;
            _os_log_impl( &dword_181A5C000,  v146,  logb,  "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(v120);
          goto LABEL_198;
        }

        if (!v121)
        {
LABEL_198:
          if (v115) {
            free(v115);
          }
          goto LABEL_18;
        }

        v132 = "invalid";
        if (v14 && *(void *)(v14 + 16)) {
          v132 = *(const char **)(v14 + 16);
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v132;
        v119 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
        v125 = v146;
        v126 = logb;
LABEL_197:
        _os_log_impl(&dword_181A5C000, v125, v126, v119, buf, 0x16u);
        goto LABEL_198;
      }

      v123 = (os_log_s *)__nwlog_obj();
      v117 = type;
      v145 = v123;
      if (!os_log_type_enabled(v123, type)) {
        goto LABEL_198;
      }
      v124 = "invalid";
      if (v14 && *(void *)(v14 + 16)) {
        v124 = *(const char **)(v14 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http3_stream_stop_datagram_flow";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v124;
      v119 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
    }

    v125 = v145;
    v126 = v117;
    goto LABEL_197;
  }

    if (v6 == 4287504053) {
      goto LABEL_16;
    }
    if ((*(_WORD *)(v4 + 736) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        unsigned __int8 v32 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          id v33 = *(_DWORD *)(*(void *)(v4 + 336) + 1280LL);
          uint64_t v34 = *(void *)(v4 + 240);
          *(_DWORD *)buf = 136447234;
          id v45 = "nw_http3_stream_frame_received_for_capsule";
          v46 = 2082;
          v47 = (char *)(v4 + 636);
          v48 = 2080;
          nw_endpoint_t v49 = " ";
          os_log_type_t v50 = 1024;
          v51 = v33;
          os_log_type_t v52 = 2048;
          os_log_type_t v53 = v34;
          _os_log_impl( &dword_181A5C000,  v32,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%llu> dropping unknown frame type",  buf,  0x30u);
        }
      }
    }

    nw_frame_finalize(a2);
  }

  os_log_type_t v41 = 0;
  uint64_t v13 = (const void *)nw_frame_unclaimed_bytes(a2, &v41);
  if (v13)
  {
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
      return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
    }
    BOOL v16 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    else {
      os_log_type_t v17 = 16 - v16;
    }
    memcpy((void *)(*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) + v16), v13, v17);
    *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v17;
    BOOL v18 = *(_DWORD **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    if (v18)
    {
      int v19 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      if (*(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
      {
        os_log_type_t v20 = *(unsigned __int8 *)v18;
        if (v20 > 0x3F)
        {
          uint64_t v26 = v20 >> 6;
          if (v26 == 2)
          {
            os_log_type_t v20 = bswap32(*v18 & 0xFFFFFF7F);
            int v21 = 4;
          }

          else if (v26 == 1)
          {
            os_log_type_t v20 = bswap32(*(_WORD *)v18 & 0xFFBF) >> 16;
            int v21 = 2;
          }

          else
          {
            os_log_type_t v20 = bswap64(*(void *)v18 & 0xFFFFFFFFFFFFFF3FLL);
            int v21 = 8;
          }
        }

        else
        {
          int v21 = 1;
        }

        *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = v20;
        int v22 = v21;
        *(_WORD *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = v21;
        char v23 = v19 - v21;
        if (v23)
        {
          os_log_type_t v24 = *((unsigned __int8 *)v18 + v22);
          if (v24 > 0x3F)
          {
            __int16 v27 = v24 >> 6;
            if (v27 == 2)
            {
              if (v23 < 4) {
                return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
              }
              os_log_type_t v24 = bswap32(*(_DWORD *)((char *)v18 + v22) & 0xFFFFFF7F);
              uint64_t v25 = 4;
            }

            else if (v27 == 1)
            {
              if (v23 < 2) {
                return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
              }
              os_log_type_t v24 = bswap32(*(_WORD *)((_BYTE *)v18 + v22) & 0xFFBF) >> 16;
              uint64_t v25 = 2;
            }

            else
            {
              if (v23 < 8) {
                return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
              }
              os_log_type_t v24 = bswap64(*(void *)((_BYTE *)v18 + v22) & 0xFFFFFFFFFFFFFF3FLL);
              uint64_t v25 = 8;
            }
          }

          else
          {
            uint64_t v25 = 1;
          }

          uint64_t v7 = 0LL;
          *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = v24;
          *(_WORD *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) += v25;
          *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
          *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
          return v7;
        }
      }

      return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v45 = "_http_vle_decode";
    BOOL v35 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v42 = 0;
    if (__nwlog_fault(v35, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v36 = (os_log_s *)__nwlog_obj();
        id v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_74;
        }
        *(_DWORD *)buf = 136446210;
        id v45 = "_http_vle_decode";
        id v38 = "%{public}s called with null *buffer";
        goto LABEL_73;
      }

      if (!v42)
      {
        uint64_t v36 = (os_log_s *)__nwlog_obj();
        id v37 = type;
        if (!os_log_type_enabled(v36, type)) {
          goto LABEL_74;
        }
        *(_DWORD *)buf = 136446210;
        id v45 = "_http_vle_decode";
        id v38 = "%{public}s called with null *buffer, backtrace limit exceeded";
        goto LABEL_73;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v36 = (os_log_s *)__nwlog_obj();
      id v37 = type;
      __int16 v40 = os_log_type_enabled(v36, type);
      if (backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446466;
          id v45 = "_http_vle_decode";
          v46 = 2082;
          v47 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s called with null *buffer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_74;
      }

      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        id v45 = "_http_vle_decode";
        id v38 = "%{public}s called with null *buffer, no backtrace";
LABEL_73:
        _os_log_impl(&dword_181A5C000, v36, v37, v38, buf, 0xCu);
      }
    }

    __break(1u);
    return;
  }

  return a1;
}

    free(backtrace_string);
    if (!v9) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }

  objc_storeStrong((id *)&v6->parameters, a2);
LABEL_10:
  objc_storeStrong((id *)&v7->browse_descriptor, a1);
  uint64_t v14 = v7;
LABEL_42:

  return v14;
}

  return v13;
}

  if (v9)
  {
    if (v16)
    {
      os_log_type_t v17 = *(void **)(v16 + 96);
      BOOL v18 = v9;
      if (v17)
      {
        int v19 = (void *)v17[3];
        if (v19)
        {
          os_log_type_t v20 = v18;
          int v21 = v19;
          concat = dispatch_data_create_concat(v21, v20);
          char v23 = (void *)v17[3];
          v17[3] = concat;

          os_log_type_t v24 = (dispatch_data_s *)v17[3];
          if (dispatch_data_get_size(v24) > v17[4])
          {
            v17[3] = 0LL;

            uint64_t v25 = (void *)v17[5];
            v17[4] = 0LL;
            v17[5] = 0LL;
          }
        }
      }
    }

    else
    {
      os_log_type_t v52 = v9;
    }

    BOOL v16 = *(void *)(a1 + 32);
  }

  if (v16)
  {
    if (*(void *)(v16 + 88))
    {
      uint64_t v26 = *(void **)(v16 + 96);
      if (v26)
      {
        __int16 v27 = (void *)v26[3];
        v26[3] = 0LL;

        int v28 = (void *)v26[5];
        v26[4] = 0LL;
        v26[5] = 0LL;
      }
    }
  }

  if (!(_DWORD)a4) {
    goto LABEL_71;
  }
  __int16 v29 = *(void *)(a1 + 32);
  if (!v29)
  {
    uint64_t v31 = 0LL;
LABEL_57:
    id v38 = 0LL;
    goto LABEL_58;
  }

  unsigned __int8 v30 = (id *)*(id *)(v29 + 96);
  uint64_t v31 = v30;
  if (!v30) {
    goto LABEL_57;
  }
  unsigned __int8 v32 = v30[5];
  if (!v32) {
    goto LABEL_57;
  }
  id v33 = v31[3] == 0LL;

  if (v33) {
    goto LABEL_57;
  }
  uint64_t v34 = objc_alloc(MEMORY[0x189601E88]);
  BOOL v35 = v31[3];
  uint64_t v36 = v31[2];
  id v37 = v31[5];
  id v38 = (void *)[v34 initWithResponse:v37 data:v35 userInfo:0 storagePolicy:v36];

  char v39 = v31[3];
  v31[3] = 0LL;

LABEL_58:
  os_log_type_t v53 = *(void *)(a1 + 32);
  if (v53) {
    objc_storeStrong((id *)(v53 + 112), v38);
  }

  if (context)
  {
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72879);
    }
    BOOL v54 = (nw_protocol_definition *)(id)nw_protocol_copy_http_definition_http_definition;
    os_log_type_t v55 = nw_content_context_copy_protocol_metadata(context, v54);

    if (v55)
    {
      v56 = nw_http_metadata_copy_trailer_fields(v55);
      os_log_type_t v57 = *(void *)(a1 + 32);
      if (v57) {
        objc_storeStrong((id *)(v57 + 160), v56);
      }
    }
  }

  BOOL v58 = *(void *)(a1 + 32);
  if (!v58) {
    goto LABEL_137;
  }
  os_log_type_t v59 = (NWURLError *)*(id *)(v58 + 88);
  if (v59)
  {
LABEL_70:

    goto LABEL_71;
  }

  os_log_type_t v62 = *(void *)(a1 + 32);
  if (v62) {
    char v63 = *(void **)(v62 + 48);
  }
  else {
LABEL_137:
  }
    char v63 = 0LL;
  [v63 clientMetadata];
  os_log_type_t v64 = (void *)objc_claimAutoreleasedReturnValue();
  v65 = v64 == 0LL;

  if (v65) {
    goto LABEL_71;
  }
  os_log_type_t v66 = *(void *)(a1 + 32);
  if (v66) {
    BOOL v67 = *(void **)(v66 + 48);
  }
  else {
    BOOL v67 = 0LL;
  }
  [v67 clientMetadata];
  os_log_type_t v68 = (nw_protocol_metadata *)(id)objc_claimAutoreleasedReturnValue();
  os_log_type_t v59 = (NWURLError *)v68;
  if (!v68)
  {
    __nwlog_obj();
    v87 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v115 = 136446210;
    *(void *)&v115[4] = "nw_http_client_metadata_get_client_error";
    id v88 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v103 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v90 = type;
      if (os_log_type_enabled(v89, type))
      {
        *(_DWORD *)v115 = 136446210;
        *(void *)&v115[4] = "nw_http_client_metadata_get_client_error";
        _os_log_impl(&dword_181A5C000, v89, v90, "%{public}s called with null metadata", v115, 0xCu);
      }
    }

    else if (v103)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v89 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v94 = type;
      v95 = os_log_type_enabled(v89, type);
      if (backtrace_string)
      {
        if (v95)
        {
          *(_DWORD *)v115 = 136446466;
          *(void *)&v115[4] = "nw_http_client_metadata_get_client_error";
          *(_WORD *)&v115[12] = 2082;
          *(void *)&v115[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v89,  v94,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  v115,  0x16u);
        }

        free(backtrace_string);
LABEL_133:
        if (!v88)
        {
LABEL_135:

          goto LABEL_70;
        }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "nw_protocol_http_messaging_disconnect";
    int v28 = 2048;
    __int16 v29 = a2;
    uint64_t v7 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      int v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "nw_protocol_http_messaging_disconnect";
        int v28 = 2048;
        __int16 v29 = a2;
        uint64_t v10 = "%{public}s Protocol %p isn't an input handler of http messaging";
LABEL_28:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0x16u);
      }
    }

    else if (v24)
    {
      id v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      int v9 = type;
      int v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v11)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          __int16 v27 = "nw_protocol_http_messaging_disconnect";
          int v28 = 2048;
          __int16 v29 = a2;
          unsigned __int8 v30 = 2082;
          uint64_t v31 = v11;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s Protocol %p isn't an input handler of http messaging, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v11);
        goto LABEL_29;
      }

      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "nw_protocol_http_messaging_disconnect";
        int v28 = 2048;
        __int16 v29 = a2;
        uint64_t v10 = "%{public}s Protocol %p isn't an input handler of http messaging, no backtrace";
        goto LABEL_28;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      int v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "nw_protocol_http_messaging_disconnect";
        int v28 = 2048;
        __int16 v29 = a2;
        uint64_t v10 = "%{public}s Protocol %p isn't an input handler of http messaging, backtrace limit exceeded";
        goto LABEL_28;
      }
    }
}

    goto LABEL_16;
  }

  __nwlog_obj();
  id v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v26 = "nw_connection_report_symptom_on_nw_queue";
  BOOL v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_connection_report_symptom_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      int v21 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_connection_report_symptom_on_nw_queue";
          __int16 v27 = 2082;
          *(void *)int v28 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v20,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_33;
      }

      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_connection_report_symptom_on_nw_queue";
        _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_connection_report_symptom_on_nw_queue";
        _os_log_impl( &dword_181A5C000,  v17,  v22,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }
}

        output_handler = a2->output_handler;
        if (!output_handler) {
          goto LABEL_46;
        }
        handle = output_handler->handle;
        if (handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          uint64_t v25 = -1;
        }

        else
        {
          uint64_t v25 = 0;
        }

        *(void *)os_log_type_t type = output_handler;
        v217 = v25;
        v46 = a2->handle;
        if (v46 == &nw_protocol_ref_counted_handle)
        {
          v48 = a2[1].callbacks;
          if (v48) {
            a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v48->add_input_handler + 1);
          }
          v47 = -1;
        }

        else
        {
          v47 = 0;
        }

        v214 = a2;
        v215 = v47;
        nw_endpoint_t v49 = output_handler->callbacks;
        if (v49)
        {
          remove_input_handler = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t))v49->remove_input_handler;
          if (remove_input_handler)
          {
            v51 = remove_input_handler(output_handler, a2, 1LL);
            if (v46 != &nw_protocol_ref_counted_handle) {
              goto LABEL_44;
            }
            goto LABEL_213;
          }
        }

        __nwlog_obj();
        v130 = (void *)objc_claimAutoreleasedReturnValue();
        name = output_handler->identifier->name;
        *(_DWORD *)buf = 136446722;
        v219 = "__nw_protocol_remove_input_handler";
        if (!name) {
          name = "invalid";
        }
        v220 = 2082;
        v221 = (char *)name;
        v222 = 2048;
        v223 = output_handler;
        logb = (const char *)_os_log_send_and_compose_impl();

        v213 = OS_LOG_TYPE_ERROR;
        v212 = 0;
        v132 = (char *)logb;
        if (!__nwlog_fault(logb, &v213, &v212))
        {
LABEL_210:
          if (v132) {
            free(v132);
          }
          v51 = 0;
          if (v46 != &nw_protocol_ref_counted_handle)
          {
LABEL_44:
            if (handle != &nw_protocol_ref_counted_handle) {
              goto LABEL_45;
            }
            goto LABEL_214;
          }

  uint64_t v14 = *(void *)(a3 + 24);
  if (v14)
  {
    id v15 = *(void (**)(uint64_t, uint64_t))(v14 + 184);
    if (v15)
    {
      v15(a3, a1);
      goto LABEL_18;
    }
  }

  __nwlog_obj();
  os_log_type_t v20 = *(const char **)(a3 + 16);
  if (!v20) {
    os_log_type_t v20 = "invalid";
  }
  *(_DWORD *)buf = 136446466;
  BOOL v72 = "nw_http2_protocol_close";
  v73 = 2082;
  v74 = (void *)v20;
  int v21 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  BOOL v69 = 0;
  if (__nwlog_fault(v21, &type, &v69))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v22 = (os_log_s *)__nwlog_obj();
      char v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_124;
      }
      os_log_type_t v24 = *(const char **)(a3 + 16);
      if (!v24) {
        os_log_type_t v24 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      BOOL v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = (void *)v24;
      uint64_t v25 = "%{public}s protocol %{public}s has invalid input_finished callback";
      goto LABEL_123;
    }

    if (!v69)
    {
      int v22 = (os_log_s *)__nwlog_obj();
      char v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_124;
      }
      os_log_type_t v57 = *(const char **)(a3 + 16);
      if (!v57) {
        os_log_type_t v57 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      BOOL v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = (void *)v57;
      uint64_t v25 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      goto LABEL_123;
    }

    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    int v22 = (os_log_s *)__nwlog_obj();
    char v23 = type;
    id v42 = os_log_type_enabled(v22, type);
    if (v41)
    {
      if (v42)
      {
        __int16 v43 = *(const char **)(a3 + 16);
        if (!v43) {
          __int16 v43 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        BOOL v72 = "nw_http2_protocol_close";
        v73 = 2082;
        v74 = (void *)v43;
        v75 = 2082;
        os_log_type_t v76 = v41;
        _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s",  buf,  0x20u);
      }

      free(v41);
      goto LABEL_124;
    }

    if (v42)
    {
      os_log_type_t v64 = *(const char **)(a3 + 16);
      if (!v64) {
        os_log_type_t v64 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      BOOL v72 = "nw_http2_protocol_close";
      v73 = 2082;
      v74 = (void *)v64;
      uint64_t v25 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
LABEL_123:
      _os_log_impl(&dword_181A5C000, v22, v23, v25, buf, 0x16u);
    }
  }

        *(void *)buf = 0LL;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x3802000000LL;
        BOOL v81 = __Block_byref_object_copy__24;
        os_log_type_t v82 = __Block_byref_object_dispose__25;
        v83[0] = 0LL;
        v83[1] = v83;
        os_log_type_t v17 = *p_output_handler;
        BOOL v18 = a6;
        if ((*p_output_handler & 8) != 0)
        {
          if (gLogDatapath)
          {
            os_log_type_t v60 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              *(void *)&type[4] = "nw_protocol_test_get_output_frames";
              *(_WORD *)&type[12] = 2082;
              *(void *)&type[14] = a1 + 2;
              _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Splitting outgoing frames",  type,  0x16u);
            }
          }

          BOOL v18 = (nw_frame_array_s *)(*(void *)&buf[8] + 40LL);
          os_log_type_t v17 = *p_output_handler;
          if ((*p_output_handler & 0x2000) == 0)
          {
LABEL_17:
            BOOL v67 = a6;
            if ((v17 & 0x10000) == 0) {
              goto LABEL_31;
            }
            goto LABEL_29;
          }
        }

        else if ((v17 & 0x2000) == 0)
        {
          goto LABEL_17;
        }

        if (gLogDatapath)
        {
          v61 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            *(void *)&type[4] = "nw_protocol_test_get_output_frames";
            *(_WORD *)&type[12] = 2082;
            *(void *)&type[14] = a1 + 2;
            _os_log_impl( &dword_181A5C000,  v61,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s Capping send size at 1300",  type,  0x16u);
          }
        }

        else {
          a4 = a4;
        }
        else {
          a3 = a3;
        }
        BOOL v67 = a6;
        if ((*p_output_handler & 0x10000) == 0)
        {
LABEL_31:
          int v19 = type;
          *(void *)os_log_type_t type = 0LL;
          *(void *)&type[8] = type;
          os_log_type_t v79 = 0;
          *(void *)&type[16] = 0x2000000000LL;
          os_log_type_t v20 = a1->output_handler;
          if (!v20)
          {
            int v22 = 0;
            goto LABEL_36;
          }

          handle = v20->handle;
          if (handle == &nw_protocol_ref_counted_handle)
          {
            callbacks = v20[1].callbacks;
            if (callbacks) {
              v20[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
            }
            int v22 = -1;
            char v23 = v20->callbacks;
            if (!v23) {
              goto LABEL_106;
            }
          }

          else
          {
            int v22 = 0;
            char v23 = v20->callbacks;
            if (!v23) {
              goto LABEL_106;
            }
          }

          get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))v23->get_output_frames;
          if (!get_output_frames)
          {
LABEL_106:
            int v19 = type;
LABEL_36:
            os_log_type_t v24 = v67;
            if ((*(_BYTE *)p_output_handler & 8) == 0)
            {
LABEL_64:
              uint64_t v34 = *((unsigned int *)v19 + 6);
              if ((v22 & 1) != 0)
              {
                if (v20)
                {
                  if (v20->handle == &nw_protocol_ref_counted_handle)
                  {
                    BOOL v35 = v20[1].callbacks;
                    if (v35)
                    {
                      uint64_t v36 = (nw_protocol_callbacks *)((char *)v35 - 1);
                      v20[1].callbacks = v36;
                      if (!v36)
                      {
                        id v37 = *(void (***)(void, void))v20[1].flow_id;
                        if (v37)
                        {
                          *(void *)v20[1].flow_id = 0LL;
                          ((void (**)(void, nw_protocol *))v37)[2](v37, a2);
                          _Block_release(v37);
                        }

                        if ((v20[1].flow_id[8] & 1) != 0)
                        {
                          id v38 = *(const void **)v20[1].flow_id;
                          if (v38) {
                            _Block_release(v38);
                          }
                        }

                        free(v20);
                      }
                    }
                  }
                }
              }

              _Block_object_dispose(type, 8);
              _Block_object_dispose(buf, 8);
              return v34;
            }

    free(v15);
    goto LABEL_16;
  }

  unsigned __int8 v6 = [v4 endpoint];
  endpoint = v5->_endpoint;
  v5->_endpoint = (NWEndpoint *)v6;

  os_log_type_t v8 = [v4 parameters];
  parameters = v5->_parameters;
  v5->_parameters = (NWParameters *)v8;

  [v4 internalPath];
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  id v11 = nw_resolver_create_with_path(v10);
  internalResolver = v5->_internalResolver;
  v5->_internalResolver = (OS_nw_resolver *)v11;

  if (!v5->_internalResolver)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "-[NWResolver initWithPath:]";
    id v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    unsigned __int8 v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v16 = (os_log_s *)(id)gLogObj;
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "-[NWResolver initWithPath:]";
      BOOL v18 = "%{public}s nw_resolver_create_with_path failed";
LABEL_20:
      os_log_type_t v24 = v16;
      uint64_t v25 = v17;
      goto LABEL_21;
    }

    if (!v32)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v16 = (os_log_s *)(id)gLogObj;
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "-[NWResolver initWithPath:]";
      BOOL v18 = "%{public}s nw_resolver_create_with_path failed, backtrace limit exceeded";
      goto LABEL_20;
    }

    int v19 = __nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v16 = (os_log_s *)(id)gLogObj;
    os_log_type_t v20 = type;
    int v21 = os_log_type_enabled(v16, type);
    if (!v19)
    {
      if (!v21)
      {
LABEL_22:

        if (!v15) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }

      *(_DWORD *)buf = 136446210;
      uint64_t v36 = "-[NWResolver initWithPath:]";
      BOOL v18 = "%{public}s nw_resolver_create_with_path failed, no backtrace";
      os_log_type_t v24 = v16;
      uint64_t v25 = v20;
LABEL_21:
      _os_log_impl(&dword_181A5C000, v24, v25, v18, buf, 0xCu);
      goto LABEL_22;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "-[NWResolver initWithPath:]";
      id v37 = 2082;
      id v38 = v19;
      _os_log_impl( &dword_181A5C000,  v16,  v20,  "%{public}s nw_resolver_create_with_path failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    int v22 = (char *)v19;
    goto LABEL_13;
  }

  -[NWResolver setUpdateHandler](v5, "setUpdateHandler");
  uint64_t v13 = v5;
LABEL_17:

  return v13;
}

  int v9 = MEMORY[0x1895F87A8];
  if (v14 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v8 + 40) == &nw_protocol_ref_counted_handle)
  {
    v46 = *(void *)(v8 + 88);
    if (v46)
    {
      v47 = v46 - 1;
      *(void *)(v8 + 88) = v47;
      if (!v47)
      {
        v48 = *(void (***)(void))(v8 + 64);
        if (v48)
        {
          *(void *)(v8 + 64) = 0LL;
          v48[2](v48);
          _Block_release(v48);
        }

        if ((*(_BYTE *)(v8 + 72) & 1) != 0)
        {
          nw_endpoint_t v49 = *(const void **)(v8 + 64);
          if (v49) {
            _Block_release(v49);
          }
        }

        free((void *)v8);
      }
    }
  }

  uint64_t v10 = &unk_182665000;
  if (!v20)
  {
LABEL_27:
    if ((*((_BYTE *)a3 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v28 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        v117 = "nw_protocol_ipv6_frame_output_finalizer";
        v118 = 2082;
        v119 = (char *)a3 + 159;
        v120 = 2080;
        v121 = " ";
        v122 = 2048;
        v123 = (char *)a3;
        v124 = 1024;
        v125 = v113;
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s%p Not enough bytes to fragment %u",  buf,  0x30u);
      }
    }

    v106[0] = v9;
    v106[1] = v10[397];
    v107 = ___ZL39nw_protocol_ipv6_frame_output_finalizerP8nw_framebPv_block_invoke;
    v108 = &__block_descriptor_tmp_46_85712;
    v109 = v110;
    __int16 v29 = v110[0];
    do
    {
      if (!v29) {
        break;
      }
      unsigned __int8 v30 = *(void *)(v29 + 32);
      uint64_t v31 = ((uint64_t (*)(void *))v107)(v106);
      __int16 v29 = v30;
    }

    while ((v31 & 1) != 0);
    goto LABEL_48;
  }

  int v21 = 0;
  int v22 = v113;
  char v23 = v110[0];
  while (v23)
  {
    __int16 v27 = *(_DWORD *)(v23 + 52);
    if (v27) {
      v27 -= *(_DWORD *)(v23 + 56) + *(_DWORD *)(v23 + 60);
    }
    char v23 = *(void *)(v23 + 32);
    os_log_type_t v24 = __CFADD__(v21, v27);
    uint64_t v25 = v21 + v27;
    v21 += v27;
    if (v24) {
      uint64_t v26 = -1;
    }
    else {
      uint64_t v26 = v25;
    }
    if (v26 >= v113) {
      goto LABEL_34;
    }
  }

  if (v21 < v113) {
    goto LABEL_27;
  }
LABEL_34:
  if ((*((_BYTE *)a3 + 158) & 1) == 0 && gLogDatapath)
  {
    v75 = (os_log_s *)__nwlog_obj();
    os_log_type_t v76 = os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG);
    int v22 = v113;
    if (v76)
    {
      *(_DWORD *)buf = 136447490;
      v117 = "nw_protocol_ipv6_frame_output_finalizer";
      v118 = 2082;
      v119 = (char *)a3 + 159;
      v120 = 2080;
      v121 = " ";
      v122 = 2048;
      v123 = (char *)a3;
      v124 = 1024;
      v125 = v20;
      v126 = 1024;
      v127 = v113;
      _os_log_impl( &dword_181A5C000,  v75,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s%p Got %u packets to fragment %u bytes",  buf,  0x36u);
      int v22 = v113;
    }

    uint64_t v10 = (void *)&unk_182665000;
    int v9 = MEMORY[0x1895F87A8];
  }

  v96[0] = v9;
  v96[1] = v10[397];
  v97 = ___ZL39nw_protocol_ipv6_frame_output_finalizerP8nw_framebPv_block_invoke_47;
  v98 = &unk_189BC8BC8;
  v99 = v111;
  v100 = v110;
  v101 = a3;
  v102 = a1;
  v104 = v22;
  v105 = v11;
  v103 = v6;
  unsigned __int8 v32 = v110[0];
  do
  {
    if (!v32) {
      break;
    }
    id v33 = *(void *)(v32 + 32);
    uint64_t v34 = ((uint64_t (*)(void *))v97)(v96);
    unsigned __int8 v32 = v33;
  }

  while ((v34 & 1) != 0);
  BOOL v35 = *(a3 - 8);
  if (v35)
  {
    uint64_t v36 = *(void **)(v35 + 40);
    if (v36 == &nw_protocol_ref_counted_handle)
    {
      id v37 = *(void *)(v35 + 88);
      if (v37) {
        *(void *)(v35 + 88) = v37 + 1;
      }
    }

    id v38 = *(void *)(v35 + 24);
    if (v38)
    {
      char v39 = *(void (**)(uint64_t, void *))(v38 + 96);
      if (v39)
      {
        v39(v35, v110);
LABEL_46:
        if (v36 != &nw_protocol_ref_counted_handle) {
          goto LABEL_48;
        }
        if (*(_UNKNOWN **)(v35 + 40) != &nw_protocol_ref_counted_handle) {
          goto LABEL_48;
        }
        os_log_type_t v50 = *(void *)(v35 + 88);
        if (!v50) {
          goto LABEL_48;
        }
        v51 = v50 - 1;
        *(void *)(v35 + 88) = v51;
        if (v51) {
          goto LABEL_48;
        }
        os_log_type_t v52 = *(void (***)(void))(v35 + 64);
        if (v52)
        {
          *(void *)(v35 + 64) = 0LL;
          v52[2](v52);
          _Block_release(v52);
        }

        if ((*(_BYTE *)(v35 + 72) & 1) != 0)
        {
          os_log_type_t v53 = *(const void **)(v35 + 64);
          if (v53) {
            _Block_release(v53);
          }
        }

        goto LABEL_76;
      }
    }

    __nwlog_obj();
    BOOL v67 = *(const char **)(v35 + 16);
    *(_DWORD *)buf = 136446722;
    v117 = "__nw_protocol_finalize_output_frames";
    if (!v67) {
      BOOL v67 = "invalid";
    }
    v118 = 2082;
    v119 = (char *)v67;
    v120 = 2048;
    v121 = (const char *)v35;
    os_log_type_t v68 = (char *)_os_log_send_and_compose_impl();
    v115 = OS_LOG_TYPE_ERROR;
    v114 = 0;
    if (__nwlog_fault(v68, &v115, &v114))
    {
      if (v115 == OS_LOG_TYPE_FAULT)
      {
        BOOL v69 = (os_log_s *)__nwlog_obj();
        v70 = v115;
        if (!os_log_type_enabled(v69, v115)) {
          goto LABEL_159;
        }
        os_log_type_t v71 = *(const char **)(v35 + 16);
        if (!v71) {
          os_log_type_t v71 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v117 = "__nw_protocol_finalize_output_frames";
        v118 = 2082;
        v119 = (char *)v71;
        v120 = 2048;
        v121 = (const char *)v35;
        BOOL v72 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
        goto LABEL_158;
      }

      if (!v114)
      {
        BOOL v69 = (os_log_s *)__nwlog_obj();
        v70 = v115;
        if (!os_log_type_enabled(v69, v115)) {
          goto LABEL_159;
        }
        char v90 = *(const char **)(v35 + 16);
        if (!v90) {
          char v90 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v117 = "__nw_protocol_finalize_output_frames";
        v118 = 2082;
        v119 = (char *)v90;
        v120 = 2048;
        v121 = (const char *)v35;
        BOOL v72 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_158;
      }

      v80 = (char *)__nw_create_backtrace_string();
      BOOL v69 = (os_log_s *)__nwlog_obj();
      v70 = v115;
      BOOL v81 = os_log_type_enabled(v69, v115);
      if (v80)
      {
        if (v81)
        {
          os_log_type_t v82 = *(const char **)(v35 + 16);
          if (!v82) {
            os_log_type_t v82 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          v117 = "__nw_protocol_finalize_output_frames";
          v118 = 2082;
          v119 = (char *)v82;
          v120 = 2048;
          v121 = (const char *)v35;
          v122 = 2082;
          v123 = v80;
          _os_log_impl( &dword_181A5C000,  v69,  v70,  "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(v80);
        goto LABEL_159;
      }

      if (v81)
      {
        v91 = *(const char **)(v35 + 16);
        if (!v91) {
          v91 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v117 = "__nw_protocol_finalize_output_frames";
        v118 = 2082;
        v119 = (char *)v91;
        v120 = 2048;
        v121 = (const char *)v35;
        BOOL v72 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
LABEL_158:
        _os_log_impl(&dword_181A5C000, v69, v70, v72, buf, 0x20u);
      }
    }

  BOOL v18 = *(void *)(a2 + 32);
  int v19 = *(void **)(a2 + 40);
  if (v18)
  {
    *(void *)(v18 + 40) = v19;
    int v19 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(a1[8] + 8LL) = v19;
  }

  void *v19 = v18;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

  BOOL v16 = *(void *)(a2 + 32);
  os_log_type_t v17 = *(void **)(a2 + 40);
  if (v16)
  {
    *(void *)(v16 + 40) = v17;
    os_log_type_t v17 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(a1[8] + 8LL) = v17;
  }

  char *v17 = v16;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

      goto LABEL_45;
    }

    if (!v72)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v22 = (os_log_s *)(id)gLogObj;
      id v44 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
        _os_log_impl( &dword_181A5C000,  v22,  v44,  "%{public}s Delegate does not conform to NWTCPListenerDelegate protocol, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_15;
    }

    os_log_type_t v24 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v25 = (os_log_s *)(id)gLogObj;
    uint64_t v26 = type;
    __int16 v27 = os_log_type_enabled(v25, type);
    if (v24)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
        os_log_type_t v76 = 2082;
        os_log_type_t v77 = v24;
        _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Delegate does not conform to NWTCPListenerDelegate protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v24);
      if (!v21) {
        goto LABEL_47;
      }
      goto LABEL_46;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446210;
      v75 = "-[NWTCPListener initWithParameters:delegate:launchdKey:bonjourEndpoint:]";
      _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s Delegate does not conform to NWTCPListenerDelegate protocol, no backtrace",  buf,  0xCu);
    }
  }

void nw_connection_set_state_changed_handler( nw_connection_t connection, nw_connection_state_changed_handler_t handler)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = connection;
  nw_connection_state_changed_handler_t v4 = handler;
  if (v3)
  {
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_connection_set_state_changed_handler_block_invoke;
    v15[3] = &unk_189BC91E8;
    int v5 = v3;
    v15[4] = v5;
    id v6 = v4;
    v15[5] = v6;
    os_unfair_lock_lock(v3 + 34);
    __nw_connection_set_state_changed_handler_block_invoke((uint64_t)v15);
    os_unfair_lock_unlock(v3 + 34);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v19 = "nw_connection_set_state_changed_handler";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      if (os_log_type_enabled(v9, v17))
      {
        *(_DWORD *)buf = 136446210;
        int v19 = "nw_connection_set_state_changed_handler";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      BOOL v13 = os_log_type_enabled(v9, v17);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          int v19 = "nw_connection_set_state_changed_handler";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        int v19 = "nw_connection_set_state_changed_handler";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v17;
      if (os_log_type_enabled(v9, v17))
      {
        *(_DWORD *)buf = 136446210;
        int v19 = "nw_connection_set_state_changed_handler";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_connection_set_state_changed_handler_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 80) == 5)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_connection_state_changed_handler_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448LL);
        int v9 = 136446466;
        os_log_type_t v10 = "nw_connection_set_state_changed_handler_block_invoke";
        __int16 v11 = 1024;
        int v12 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s [C%u] Cannot set state changed handler after cancel",  (uint8_t *)&v9,  0x12u);
      }
    }
  }

  else
  {
    id v6 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v7 = *(void *)(a1 + 32);
    os_log_type_t v8 = *(void **)(v7 + 208);
    *(void *)(v7 + 208) = v6;
  }

void nw_connection_set_read_close_handler(void *a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_set_read_close_handler_block_invoke;
    v13[3] = &unk_189BC91E8;
    id v14 = v3;
    id v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  int v19 = "nw_connection_set_read_close_handler";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        int v19 = "nw_connection_set_read_close_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v19 = "nw_connection_set_read_close_handler";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v19 = "nw_connection_set_read_close_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        int v19 = "nw_connection_set_read_close_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A88554( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_read_close_handler_block_invoke(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v1 = *(void **)(a1 + 40);
  id v2 = *(id *)(*(void *)(a1 + 32) + 144LL);
  id v3 = v1;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_endpoint_handler_set_read_close_handler";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl(&dword_181A5C000, v12, v23, "%{public}s called with null handler", buf, 0xCu);
        }

        goto LABEL_35;
      }

      if (!v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl(&dword_181A5C000, v12, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_35;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v31 = "nw_endpoint_handler_set_read_close_handler";
        __int16 v32 = 2082;
        id v33 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v12,  v25,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

void sub_181A88C24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_mode_handler *nw_endpoint_handler_copy_flow(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v34 = "nw_endpoint_handler_copy_flow";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v23, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl(&dword_181A5C000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v34 = "nw_endpoint_handler_copy_flow";
            __int16 v35 = 2082;
            id_str = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v27,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl(&dword_181A5C000, v24, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl( &dword_181A5C000,  v24,  v29,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_181A89150(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_write_close_handler(void *a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_set_write_close_handler_block_invoke;
    v13[3] = &unk_189BC91E8;
    id v14 = v3;
    id v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_connection_set_write_close_handler";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_write_close_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v19 = "nw_connection_set_write_close_handler";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_write_close_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_write_close_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A89468( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_write_close_handler_block_invoke(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v1 = *(void **)(a1 + 40);
  id v2 = *(id *)(*(void *)(a1 + 32) + 144LL);
  id v3 = v1;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v31 = "nw_endpoint_handler_set_write_close_handler";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl(&dword_181A5C000, v12, v23, "%{public}s called with null handler", buf, 0xCu);
        }

        goto LABEL_35;
      }

      if (!v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl( &dword_181A5C000,  v12,  v27,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)(id)gLogObj;
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl(&dword_181A5C000, v12, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }

        goto LABEL_35;
      }

      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        char v31 = "nw_endpoint_handler_set_write_close_handler";
        __int16 v32 = 2082;
        id v33 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v12,  v25,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

void sub_181A89B38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_set_alternate_path_state_handler(void *a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_set_alternate_path_state_handler_block_invoke;
    v13[3] = &unk_189BC91E8;
    id v14 = v3;
    id v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_connection_set_alternate_path_state_handler";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_alternate_path_state_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v19 = "nw_connection_set_alternate_path_state_handler";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_alternate_path_state_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_alternate_path_state_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A89E44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_alternate_path_state_handler_block_invoke(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 248);
  *(void *)(v3 + 248) = v2;
}

void nw_connection_set_viability_changed_handler( nw_connection_t connection, nw_connection_BOOLean_event_handler_t handler)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = connection;
  nw_connection_BOOLean_event_handler_t v4 = handler;
  if (v3)
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_connection_set_viability_changed_handler_block_invoke;
    v13[3] = &unk_189BC91E8;
    id v14 = v3;
    id v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_connection_set_viability_changed_handler";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_viability_changed_handler";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v19 = "nw_connection_set_viability_changed_handler";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_viability_changed_handler";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_connection_set_viability_changed_handler";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A8A194( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_viability_changed_handler_block_invoke(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  nw_connection_BOOLean_event_handler_t v4 = *(void **)(v3 + 232);
  *(void *)(v3 + 232) = v2;
}

uint64_t nw_parameters_get_traffic_class(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned int *)(*((void *)v1 + 13) + 72LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_traffic_class";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_traffic_class";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_traffic_class";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_traffic_class";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_traffic_class";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_connection_start(nw_connection_t connection)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  nw_connection_t v1 = connection;
  if (v1)
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_229);
    }
    if (_os_feature_enabled_impl() && !nw_parameters_get_logging_disabled(*((void *)v1 + 2)))
    {
      id v2 = nw_parameters_copy_description_internal(*((NWConcrete_nw_parameters **)v1 + 2), 1);
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      nw_connection_BOOLean_event_handler_t v4 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *((_DWORD *)v1 + 112);
        logging_description = nw_endpoint_get_logging_description(*((void **)v1 + 1));
        *(_DWORD *)buf = 67110402;
        *(_DWORD *)uint64_t v22 = v5;
        *(_WORD *)&v22[4] = 1042;
        *(_DWORD *)&void v22[6] = 16;
        *(_WORD *)os_log_type_t v23 = 2098;
        *(void *)&v23[2] = (char *)v1 + 452;
        __int16 v24 = 2082;
        os_log_type_t v25 = logging_description;
        __int16 v26 = 2082;
        os_log_type_t v27 = v2;
        __int16 v28 = 2080;
        os_log_type_t v29 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "[C%u %{public,uuid_t}.16P %{public}s %{public}s] started by:\n%s",  buf,  0x36u);
      }

      if (v2) {
        free(v2);
      }
      if (backtrace_string) {
        free(backtrace_string);
      }
    }

    qos_class_t v7 = qos_class_self();
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = __nw_connection_start_block_invoke;
    v16[3] = &unk_189BC76E8;
    __int16 v17 = v1;
    qos_class_t v18 = v7;
    nw_connection_async_if_needed(v17, v16);

    goto LABEL_18;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(void *)uint64_t v22 = "nw_connection_start";
  id v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)uint64_t v22 = "nw_connection_start";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
      }
    }

    else if (v19)
    {
      os_log_type_t v12 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)uint64_t v22 = "nw_connection_start";
          *(_WORD *)&v22[8] = 2082;
          *(void *)os_log_type_t v23 = v12;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v12);
        goto LABEL_35;
      }

      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)uint64_t v22 = "nw_connection_start";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)uint64_t v22 = "nw_connection_start";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_181A8A8DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_start_block_invoke(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 16LL)))
  {
    id v2 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)(*(void *)(a1 + 32) + 16LL), 1);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v3 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      int v5 = *(_DWORD *)(v4 + 448);
      logging_description = nw_endpoint_get_logging_description(*(void **)(v4 + 8));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v5;
      *(_WORD *)&buf[8] = 1042;
      *(_DWORD *)&buf[10] = 16;
      *(_WORD *)&buf[14] = 2098;
      *(void *)&buf[16] = v4 + 452;
      *(_WORD *)&buf[24] = 2082;
      *(void *)&buf[26] = logging_description;
      *(_WORD *)&buf[34] = 2082;
      *(void *)&buf[36] = v2;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEFAULT,  "[C%u %{public,uuid_t}.16P %{public}s %{public}s] start",  buf,  0x2Cu);
    }

    if (v2) {
      free(v2);
    }
  }

  qos_class_t v7 = *(os_unfair_lock_s **)(a1 + 32);
  os_log_type_t v8 = v7 + 34;
  uint64_t v9 = MEMORY[0x1895F87A8];
  v46[0] = MEMORY[0x1895F87A8];
  v46[1] = 3221225472LL;
  v46[2] = __nw_connection_start_block_invoke_15;
  v46[3] = &unk_189BC93A0;
  __int16 v47 = v7;
  os_unfair_lock_lock(v8);
  __nw_connection_start_block_invoke_15((uint64_t)v46);
  os_unfair_lock_unlock(v8);
  uint64_t v10 = *(void *)(a1 + 32);
  if (*(void *)(v10 + 72))
  {
    unsigned int v11 = *(_DWORD *)(v10 + 80);
    os_log_type_t v12 = (void **)(id)v10;
    nw_context_assert_queue(v12[3]);
    nw_connection_report_state_with_handler_on_nw_queue(v12, v11, v12[26], v12[25]);
    goto LABEL_33;
  }

  if (*(void *)(v10 + 144))
  {
    if (*(void *)(v10 + 200))
    {
LABEL_14:
      objc_storeStrong((id *)(v10 + 48), (id)v10);
      uint64_t v13 = *(void *)(a1 + 32);
      int v14 = *(_DWORD *)(v13 + 80);
      *(_DWORD *)(v13 + 192) = *(_DWORD *)(a1 + 40);
      os_log_type_t v15 = *(os_unfair_lock_s **)(a1 + 32);
      char v16 = v15 + 34;
      v44[0] = v9;
      v44[1] = 3221225472LL;
      v44[2] = __nw_connection_start_block_invoke_16;
      v44[3] = &unk_189BC93A0;
      __int16 v45 = v15;
      os_unfair_lock_lock(v16);
      __nw_connection_start_block_invoke_16((uint64_t)v44);
      os_unfair_lock_unlock(v16);
      if (nw_parameters_get_attribution(*(nw_parameters_t *)(*(void *)(a1 + 32) + 16LL)) != nw_parameters_attribution_developer
        || !ne_tracker_should_save_stacktrace())
      {
        goto LABEL_20;
      }

      __int16 v17 = *(id *)(*(void *)(a1 + 32) + 16LL);
      if (v17)
      {
        BOOL v18 = (v17[12] & 0x8000000000LL) == 0;

        if (v18)
        {
LABEL_18:
          *(void *)buf = 0LL;
          char v19 = (const void *)ne_tracker_copy_current_stacktrace();
          if (v19)
          {
            dispatch_data_t v20 = dispatch_data_create(v19, *(size_t *)buf, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A88]);
            uint64_t v21 = *(void *)(a1 + 32);
            uint64_t v22 = *(void **)(v21 + 88);
            *(void *)(v21 + 88) = v20;
          }
        }

LABEL_50:
      if (v36) {
        free(v36);
      }
      int v14 = v43;
      goto LABEL_18;
    }

    if (nw_context_is_inline(*(void **)(v10 + 24)))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      goto LABEL_14;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (void **)(id)gLogObj;
    if (!os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_start_block_invoke";
    __int16 v32 = "%{public}s Cannot start nw_connection without first setting the queue.";
    id v33 = (os_log_s *)v12;
    uint32_t v34 = 12;
LABEL_32:
    _os_log_impl(&dword_181A5C000, v33, OS_LOG_TYPE_ERROR, v32, buf, v34);
    goto LABEL_33;
  }

  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  os_log_type_t v12 = (void **)(id)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_ERROR))
  {
    uint64_t v26 = *(void *)(a1 + 32);
    int v27 = *(_DWORD *)(v26 + 448);
    uint64_t v29 = *(void *)(v26 + 8);
    uint64_t v28 = *(void *)(v26 + 16);
    uint64_t v30 = *(unsigned int *)(v26 + 80);
    else {
      char v31 = off_189BB9C00[v30];
    }
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v27;
    *(_WORD *)&buf[8] = 2112;
    *(void *)&buf[10] = v29;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = v28;
    *(_WORD *)&buf[28] = 2082;
    *(void *)&buf[30] = v31;
    __int16 v32 = "[C%u %@ %@] cannot start after being torn down, in state %{public}s";
    id v33 = (os_log_s *)v12;
    uint32_t v34 = 38;
    goto LABEL_32;
  }

    if (!v32) {
      goto LABEL_32;
    }
    uint64_t v29 = (char *)v32;
    goto LABEL_31;
  }

  uint64_t v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v11 = (id)gLogObj;
    os_log_type_t v12 = v3;
    uint64_t v13 = [v12 type];

    *(_DWORD *)buf = 136446466;
    id v44 = "nw_endpoint_get_sanitized_url";
    __int16 v45 = 1024;
    *(_DWORD *)id v46 = v13;
    LODWORD(v39) = 18;
    int v14 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    if (__nwlog_fault(v14, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v15 = (os_log_s *)(id)gLogObj;
        char v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          __int16 v17 = v12;
          BOOL v18 = objc_msgSend(v17, "type", buf, v39);

          *(_DWORD *)buf = 136446466;
          id v44 = "nw_endpoint_get_sanitized_url";
          __int16 v45 = 1024;
          *(_DWORD *)id v46 = v18;
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v41)
      {
        char v19 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v15 = (os_log_s *)(id)gLogObj;
        dispatch_data_t v20 = type;
        uint64_t v21 = os_log_type_enabled(v15, type);
        if (v19)
        {
          if (v21)
          {
            uint64_t v22 = v12;
            os_log_type_t v23 = objc_msgSend(v22, "type", buf, v39);

            *(_DWORD *)buf = 136446722;
            id v44 = "nw_endpoint_get_sanitized_url";
            __int16 v45 = 1024;
            *(_DWORD *)id v46 = v23;
            v46[2] = 2082;
            *(void *)&v46[3] = v19;
            _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v19);
          if (!v14) {
            goto LABEL_32;
          }
LABEL_30:
          uint64_t v29 = (char *)v14;
LABEL_31:
          free(v29);
          goto LABEL_32;
        }

        if (v21)
        {
          int v27 = v12;
          uint64_t v28 = objc_msgSend(v27, "type", buf, v39);

          *(_DWORD *)buf = 136446466;
          id v44 = "nw_endpoint_get_sanitized_url";
          __int16 v45 = 1024;
          *(_DWORD *)id v46 = v28;
          _os_log_impl(&dword_181A5C000, v15, v20, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v15 = (os_log_s *)(id)gLogObj;
        unsigned int v24 = type;
        if (os_log_type_enabled(v15, type))
        {
          os_log_type_t v25 = v12;
          uint64_t v26 = objc_msgSend(v25, "type", buf, v39);

          *(_DWORD *)buf = 136446466;
          id v44 = "nw_endpoint_get_sanitized_url";
          __int16 v45 = 1024;
          *(_DWORD *)id v46 = v26;
          _os_log_impl( &dword_181A5C000,  v15,  v24,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v14)
    {
LABEL_32:
      qos_class_t v7 = 0LL;
      goto LABEL_33;
    }

    goto LABEL_30;
  }

  int v5 = v3;
  nw_endpoint_t v6 = v5;
  qos_class_t v7 = v5[35];
  if (!v7)
  {
    if (v5[29])
    {
      v40[0] = MEMORY[0x1895F87A8];
      v40[1] = 3221225472LL;
      v40[2] = __nw_endpoint_get_sanitized_url_block_invoke;
      v40[3] = &unk_189BC93A0;
      os_log_type_t v8 = v5;
      v40[4] = v8;
      os_unfair_lock_lock(v8 + 75);
      __nw_endpoint_get_sanitized_url_block_invoke((uint64_t)v40);
      os_unfair_lock_unlock(v8 + 75);
      if (!*(void *)&v8[70]._os_unfair_lock_opaque)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v10 = *(void *)&v8[62]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446467;
          id v44 = "nw_endpoint_get_sanitized_url";
          __int16 v45 = 2085;
          *(void *)id v46 = v10;
          _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s Failed to sanitize url: %{sensitive}s",  buf,  0x16u);
        }
      }

      qos_class_t v7 = *(void *)&v8[70]._os_unfair_lock_opaque;
    }

    else
    {
      qos_class_t v7 = 0LL;
    }
  }

LABEL_33:
  return v7;
}

      if (v14) {
        free(v14);
      }
      if ((a1[12]._os_unfair_lock_opaque & 2) != 0)
      {
        os_unfair_lock_unlock(a1 + 13);
        return 0LL;
      }

      return 0LL;
    }

    if (v17) {
      free(v17);
    }
LABEL_8:
    uint64_t v9 = 0LL;
    goto LABEL_13;
  }

  __nwlog_obj();
  os_log_type_t v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v31 = "nw_parameters_clear_protocol_stack";
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v28 = 0;
  if (__nwlog_fault(v13, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "nw_parameters_clear_protocol_stack";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
      }
    }

    else if (v28)
    {
      dispatch_data_t v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v21 = type;
      uint64_t v22 = os_log_type_enabled(v14, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          char v31 = "nw_parameters_clear_protocol_stack";
          __int16 v32 = 2082;
          id v33 = v20;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v20);
        goto LABEL_44;
      }

      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "nw_parameters_clear_protocol_stack";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v26 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "nw_parameters_clear_protocol_stack";
        _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    if (v13) {
      free(v13);
    }
    goto LABEL_7;
  }

  if (!*((void *)v3 + 3)) {
    goto LABEL_7;
  }
  if (*((void *)v3 + 30) || *((void *)v3 + 29) || a2)
  {
    if (!*((void *)v3 + 12)
      || (nw_parameters_get_proxy_applied(*((void **)v3 + 2)) & 1) != 0
      || nw_path_get_dns_service_id(v4, 0))
    {
      goto LABEL_7;
    }

    nw_endpoint_t v6 = nw_endpoint_get_type(v4[3]);
    if (v6 - 2 < 2)
    {
LABEL_15:
      a2 = nw_interface_get_type(v4[12]) != nw_interface_type_loopback;
      goto LABEL_8;
    }

    if (v6 != nw_endpoint_type_address)
    {
      if (v6 == 6) {
        goto LABEL_15;
      }
      goto LABEL_7;
    }

    address = nw_endpoint_get_address(v4[3]);
    sa_family = address->sa_family;
    if (sa_family != 2)
    {
      if (sa_family == 30)
      {
        uint64_t v9 = address->sa_data[6];
        if (v9 == 255)
        {
          unsigned int v11 = address->sa_data[7];
          if ((v11 & 0xF0) != 0x30 && (v11 & 0xF) == 2) {
            goto LABEL_7;
          }
        }

        else if (v9 == 254 && (address->sa_data[7] & 0xC0) == 0x80)
        {
          goto LABEL_7;
        }

        if (*(_DWORD *)&address->sa_data[6]
          || *(_DWORD *)&address->sa_data[10]
          || *(_DWORD *)&address[1].sa_len
          || (*(_DWORD *)&address[1].sa_data[2] | 0x1000000) != 0x1000000)
        {
          goto LABEL_15;
        }
      }

    if (v35) {
      free(v35);
    }
LABEL_31:
    dispatch_data_t v20 = 0LL;
LABEL_34:
    os_unfair_lock_unlock((os_unfair_lock_t)&cache_lock);
    return v20;
  }

  return result;
}

    if (!v30) {
      goto LABEL_32;
    }
    int v27 = (char *)v30;
    goto LABEL_31;
  }

  uint64_t v3 = v1;
  uint64_t v4 = [v3 type];

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (id)gLogObj;
    uint64_t v9 = v3;
    uint64_t v10 = [v9 type];

    *(_DWORD *)buf = 136446466;
    BOOL v41 = "nw_endpoint_is_multicast";
    os_log_type_t v42 = 1024;
    *(_DWORD *)int v43 = v10;
    LODWORD(v37) = 18;
    unsigned int v11 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v38 = 0;
    if (__nwlog_fault(v11, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          int v14 = v9;
          os_log_type_t v15 = objc_msgSend(v14, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          BOOL v41 = "nw_endpoint_is_multicast";
          os_log_type_t v42 = 1024;
          *(_DWORD *)int v43 = v15;
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }

      else if (v38)
      {
        char v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        __int16 v17 = type;
        BOOL v18 = os_log_type_enabled(v12, type);
        if (v16)
        {
          if (v18)
          {
            char v19 = v9;
            dispatch_data_t v20 = objc_msgSend(v19, "type", buf, v37);

            *(_DWORD *)buf = 136446722;
            BOOL v41 = "nw_endpoint_is_multicast";
            os_log_type_t v42 = 1024;
            *(_DWORD *)int v43 = v20;
            v43[2] = 2082;
            *(void *)&v43[3] = v16;
            _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(v16);
          if (!v11) {
            goto LABEL_32;
          }
LABEL_30:
          int v27 = (char *)v11;
LABEL_31:
          free(v27);
          goto LABEL_32;
        }

        if (v18)
        {
          os_log_type_t v25 = v9;
          uint64_t v26 = objc_msgSend(v25, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          BOOL v41 = "nw_endpoint_is_multicast";
          os_log_type_t v42 = 1024;
          *(_DWORD *)int v43 = v26;
          _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          os_log_type_t v23 = v9;
          unsigned int v24 = objc_msgSend(v23, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          BOOL v41 = "nw_endpoint_is_multicast";
          os_log_type_t v42 = 1024;
          *(_DWORD *)int v43 = v24;
          _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s incorrect endpoint type %u, backtrace limit exceeded",  buf,  0x12u);
        }
      }
    }

    if (!v11)
    {
LABEL_32:
      uint64_t v21 = 0LL;
      goto LABEL_33;
    }

    goto LABEL_30;
  }

  int v5 = v3;
  nw_endpoint_t v6 = *((unsigned __int8 *)v5 + 233);
  if (v6 == 30)
  {
    qos_class_t v7 = *((unsigned __int8 *)v5 + 240) == 255;
LABEL_18:
    uint64_t v21 = v7;
    goto LABEL_22;
  }

  if (v6 == 2)
  {
    qos_class_t v7 = (v5[59] & 0xF0) == 224;
    goto LABEL_18;
  }

  uint64_t v21 = 0LL;
LABEL_22:

LABEL_33:
  return v21;
}

            if (v23) {
              free(v23);
            }
            goto LABEL_52;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v26 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v87 = "nw_context_get_globals_for_protocol";
          int v27 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          os_log_type_t v83 = 0;
          if (__nwlog_fault(v27, &type, &v83))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v28 = (os_log_s *)(id)gLogObj;
              uint64_t v29 = type;
              if (os_log_type_enabled(v28, type))
              {
                *(_DWORD *)buf = 136446210;
                v87 = "nw_context_get_globals_for_protocol";
                _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s nw_hash_table_add_object failed", buf, 0xCu);
              }

        if ((v31 & 0x80) == 0) {
          goto LABEL_51;
        }
LABEL_93:
        *(_BYTE *)(a2 + 185) = v15->i8[8];
LABEL_51:
        if ((*(_WORD *)(a2 + 204) & 8) != 0) {
          goto LABEL_115;
        }
        __int16 v32 = a2 + 120;
        id v33 = *(void **)(a2 + 168);
        if (v33)
        {
          os_release(v33);
          *(void *)(a2 + 168) = 0LL;
        }

        uint32_t v34 = *(void *)(a2 + 64);
        *(_BYTE *)(a2 + 186) |= 0x40u;
        if (!v34)
        {
          *(void *)(a2 + 64) = v32;
          *(void *)(a2 + 72) = v32;
          *(void *)(a2 + 120) = 0LL;
          *(void *)(a2 + 128) = a2 + 64;
          goto LABEL_115;
        }

        if (v34 == v32) {
          goto LABEL_115;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v34;
        *(_WORD *)&buf[22] = 2048;
        v149 = (const char *)(a2 + 120);
        __int16 v35 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v147 = 0;
        if (__nwlog_fault(v35, type, &v147))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v36 = (os_log_s *)gLogObj;
            __int16 v37 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
              goto LABEL_113;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v34;
            *(_WORD *)&buf[22] = 2048;
            v149 = (const char *)(a2 + 120);
            os_log_type_t v38 = "%{public}s Existing metadata %p doesn't match expected %p";
LABEL_111:
            BOOL v69 = v36;
LABEL_112:
            _os_log_impl(&dword_181A5C000, v69, v37, v38, buf, 0x20u);
            goto LABEL_113;
          }

          if (!v147)
          {
            __int16 v36 = (os_log_s *)__nwlog_obj();
            __int16 v37 = type[0];
            if (!os_log_type_enabled(v36, type[0])) {
              goto LABEL_113;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v34;
            *(_WORD *)&buf[22] = 2048;
            v149 = (const char *)(a2 + 120);
            os_log_type_t v38 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
            goto LABEL_111;
          }

          os_log_type_t v66 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v37 = type[0];
          log = (os_log_s *)gLogObj;
          BOOL v67 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v66)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v34;
              *(_WORD *)&buf[22] = 2048;
              v149 = (const char *)(a2 + 120);
              v150 = 2082;
              v151 = (uint64_t)v66;
              _os_log_impl( &dword_181A5C000,  log,  v37,  "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(v66);
            goto LABEL_113;
          }

          if (v67)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v34;
            *(_WORD *)&buf[22] = 2048;
            v149 = (const char *)(a2 + 120);
            os_log_type_t v38 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
            BOOL v69 = log;
            goto LABEL_112;
          }
        }

    *((_WORD *)handle + 166) |= 0x210u;
    uint64_t v49 = nw_endpoint_handler_copy_flow(v5);
    os_log_type_t v50 = *((unsigned __int16 *)handle + 166);
    uint64_t v51 = handle->output_context;
    if ((v50 & 0x100) == 0) {
      nw_flow_service_reads(v5, (NWConcrete_nw_endpoint_flow *)v49, handle, 1);
    }
    os_log_type_t v52 = (v50 >> 8) & 1;
    os_log_type_t v53 = handle->last_error;
    context = handle->context;
    v79[0] = MEMORY[0x1895F87A8];
    v79[1] = 3221225472LL;
    v79[2] = ___ZL20nw_flow_disconnectedP11nw_protocolS0__block_invoke;
    v79[3] = &unk_189BB85E8;
    v80 = v5;
    id v84 = handle;
    os_log_type_t v55 = v49;
    BOOL v81 = v55;
    os_log_type_t v82 = v53;
    id v86 = v52;
    v56 = v51;
    os_log_type_t v83 = v56;
    v85 = handle;
    os_log_type_t v57 = v53;
    nw_queue_context_async(context, v79);

    goto LABEL_53;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v23 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    else {
      unsigned int v24 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    char v90 = "nw_flow_disconnected";
    v91 = 2082;
    v92 = (void *)v24;
    int v93 = 2082;
    uint64_t v94 = "flow";
    _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
  }

LABEL_53:
}

  if (v14) {
    free(v14);
  }
  unsigned int v11 = 0LL;
LABEL_17:

  return v11;
}

  __break(1u);
  return result;
}

  id v46 = a3;
  __int16 v47 = v18;
  char v48 = sub_181C94200;
  uint64_t v49 = 0LL;
  __swift_instantiateConcreteTypeFromMangledName(&qword_18C58D498);
  sub_181C02894((unint64_t *)&unk_18C58D4A0, &qword_18C58D498, MEMORY[0x189619618]);
  sub_18264EB14();
  a3 = 0LL;
  uint64_t v22 = 0xE000000000000000LL;
LABEL_51:
LABEL_52:
  id v44 = v11;
  __int16 v45 = v9;
  if (!a4)
  {
    int v27 = 0LL;
    goto LABEL_65;
  }

  os_log_type_t v23 = strlen(a4);
  if (!v23) {
    goto LABEL_61;
  }
  if ((*a4 & 0x80000000) == 0)
  {
    if (v23 == 1) {
      goto LABEL_61;
    }
    if ((a4[1] & 0x80000000) == 0)
    {
      unsigned int v24 = v23 - 2;
      if (v23 != 2)
      {
        os_log_type_t v25 = a4 + 2;
        while ((*v25 & 0x80000000) == 0)
        {
          ++v25;
          if (!--v24) {
            goto LABEL_61;
          }
        }

        goto LABEL_63;
      }

    if (v26) {
      free(v26);
    }
    goto LABEL_32;
  }

  if (init_onceToken != -1) {
    dispatch_once(&init_onceToken, &__block_literal_global);
  }
  if (!init_hasDelegateEntitlement)
  {
    int v14 = (objc_class *)objc_opt_class();
    NSStringFromClass(v14);
    os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v16 = (id)gLogObj;
    *(_DWORD *)location = 136446722;
    *(void *)&location[4] = "-[NWSystemPathMonitor init]";
    id v44 = 2114;
    __int16 v45 = @"com.apple.private.network.socket-delegate";
    id v46 = 2114;
    __int16 v47 = v15;
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v40 = 0;
    if (__nwlog_fault(v17, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        char v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)location = 136446722;
          *(void *)&location[4] = "-[NWSystemPathMonitor init]";
          id v44 = 2114;
          __int16 v45 = @"com.apple.private.network.socket-delegate";
          id v46 = 2114;
          __int16 v47 = v15;
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s This process does not have the %{public}@ entitlement required to use the %{public}@ API",  location,  0x20u);
        }
      }

      else if (v40)
      {
        dispatch_data_t v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        uint64_t v21 = type;
        uint64_t v22 = os_log_type_enabled(v18, type);
        if (v20)
        {
          if (v22)
          {
            *(_DWORD *)location = 136446978;
            *(void *)&location[4] = "-[NWSystemPathMonitor init]";
            id v44 = 2114;
            __int16 v45 = @"com.apple.private.network.socket-delegate";
            id v46 = 2114;
            __int16 v47 = v15;
            char v48 = 2082;
            uint64_t v49 = v20;
            _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s This process does not have the %{public}@ entitlement required to use the %{public}@ API, dumpi ng backtrace:%{public}s",  location,  0x2Au);
          }

          free(v20);
          if (!v17) {
            goto LABEL_31;
          }
          goto LABEL_30;
        }

        if (v22)
        {
          *(_DWORD *)location = 136446722;
          *(void *)&location[4] = "-[NWSystemPathMonitor init]";
          id v44 = 2114;
          __int16 v45 = @"com.apple.private.network.socket-delegate";
          id v46 = 2114;
          __int16 v47 = v15;
          _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s This process does not have the %{public}@ entitlement required to use the %{public}@ API, no backtrace",  location,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)location = 136446722;
          *(void *)&location[4] = "-[NWSystemPathMonitor init]";
          id v44 = 2114;
          __int16 v45 = @"com.apple.private.network.socket-delegate";
          id v46 = 2114;
          __int16 v47 = v15;
          _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s This process does not have the %{public}@ entitlement required to use the %{public}@ API, backtra ce limit exceeded",  location,  0x20u);
        }
      }
    }

    if (!v17)
    {
LABEL_31:

LABEL_32:
      uint64_t v13 = 0LL;
      goto LABEL_33;
    }

        free((void *)default_input_handler);
      }
    }
  }

LABEL_54:
      return;
    default:
      goto LABEL_54;
  }

    free(v30);
    if (!v20) {
      goto LABEL_20;
    }
    goto LABEL_71;
  }

  if (v2->awdl_service_resolver)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1) {
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    }
    uint64_t v3 = (os_log_s *)(id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      log_id = (char *)v2->log_id;
      *(_DWORD *)buf = 136446466;
      int v43 = "nw_candidate_manager_start_awdl_resolver";
      id v44 = 2048;
      __int16 v45 = log_id;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s [CM%zu] AWDL service resolver already running",  buf,  0x16u);
    }
  }

  else
  {
    int v5 = nw_interface_create_with_name("awdl0");
    if (v5)
    {
      nw_endpoint_t v6 = v2->parameters;
      qos_class_t v7 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v6,  0,  0);

      nw_parameters_require_interface((nw_parameters_t)v7, (nw_interface_t)v5);
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v2->service, (void *)v7);
      uint64_t v9 = (os_unfair_lock_s *)evaluator_for_endpoint;
      if (evaluator_for_endpoint)
      {
        uint64_t v10 = evaluator_for_endpoint;
        os_unfair_lock_lock(v9 + 24);
        unsigned int v11 = v10[6];
        os_unfair_lock_unlock(v9 + 24);
      }

      else
      {
        unsigned int v11 = 0LL;
      }

      os_log_type_t v12 = nw_resolver_create_with_path(v11);
      awdl_service_resolver = v2->awdl_service_resolver;
      v2->awdl_service_resolver = (OS_nw_resolver *)v12;

      if (__nwlog_candidate_manager_log::onceToken != -1) {
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      }
      int v14 = (os_log_s *)(id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        os_log_type_t v15 = (char *)v2->log_id;
        char v16 = v2->awdl_service_resolver;
        service = v2->service;
        *(_DWORD *)buf = 136446978;
        int v43 = "nw_candidate_manager_start_awdl_resolver";
        id v44 = 2048;
        __int16 v45 = v15;
        id v46 = 2112;
        __int16 v47 = v16;
        char v48 = 2112;
        uint64_t v49 = service;
        _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_DEFAULT,  "%{public}s [CM%zu] Created AWDL service resolver %@ for %@",  buf,  0x2Au);
      }

      BOOL v18 = v2->awdl_service_resolver;
      v38[0] = MEMORY[0x1895F87A8];
      v38[1] = 3221225472LL;
      v38[2] = ___ZL40nw_candidate_manager_start_awdl_resolverP31NWConcrete_nw_candidate_manager_block_invoke;
      v38[3] = &unk_189BB6218;
      __int16 v39 = v2;
      nw_resolver_set_update_handler(v18, 0LL, v38);
    }
  }

    goto LABEL_51;
  }

  if (v1[5])
  {
    if (v1[6])
    {
      if (__nwlog_candidate_manager_log::onceToken != -1) {
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      }
      uint64_t v3 = (os_log_s *)(id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = (char *)v2[1];
        *(_DWORD *)buf = 136446466;
        __int16 v37 = "nw_candidate_manager_start_bonjour_service_resolve";
        os_log_type_t v38 = 2048;
        __int16 v39 = v4;
        _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s [CM%zu] service resolver already running",  buf,  0x16u);
      }
    }

    else
    {
      int v5 = v1[10];
      nw_endpoint_t v6 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v5,  0,  0);

      nw_parameters_set_include_peer_to_peer((nw_parameters_t)v6, 0);
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v2[5], (void *)v6);
      os_log_type_t v8 = (os_unfair_lock_s *)evaluator_for_endpoint;
      if (evaluator_for_endpoint)
      {
        uint64_t v9 = evaluator_for_endpoint;
        os_unfair_lock_lock(v8 + 24);
        uint64_t v10 = v9[6];
        os_unfair_lock_unlock(v8 + 24);
      }

      else
      {
        uint64_t v10 = 0LL;
      }

      unsigned int v11 = nw_resolver_create_with_path(v10);
      os_log_type_t v12 = v2[6];
      v2[6] = v11;

      if (__nwlog_candidate_manager_log::onceToken != -1) {
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      }
      uint64_t v13 = (os_log_s *)(id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        int v14 = (char *)v2[1];
        char v16 = v2[5];
        os_log_type_t v15 = v2[6];
        *(_DWORD *)buf = 136446978;
        __int16 v37 = "nw_candidate_manager_start_bonjour_service_resolve";
        os_log_type_t v38 = 2048;
        __int16 v39 = v14;
        os_log_type_t v40 = 2112;
        BOOL v41 = v15;
        os_log_type_t v42 = 2112;
        int v43 = v16;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_INFO,  "%{public}s [CM%zu] Created service resolver %@ for %@",  buf,  0x2Au);
      }

      __int16 v17 = v2[6];
      v32[0] = MEMORY[0x1895F87A8];
      v32[1] = 3221225472LL;
      v32[2] = __nw_candidate_manager_start_bonjour_service_resolve_block_invoke;
      v32[3] = &unk_189BB6218;
      id v33 = v2;
      nw_resolver_set_update_handler(v17, 0LL, v32);
    }

    goto LABEL_17;
  }

  __nwlog_obj();
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v37 = "nw_candidate_manager_start_bonjour_service_resolve";
  char v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint32_t v34 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    dispatch_data_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v37 = "nw_candidate_manager_start_bonjour_service_resolve";
      _os_log_impl(&dword_181A5C000, v20, v23, "%{public}s called with null manager->service", buf, 0xCu);
    }

    goto LABEL_50;
  }

  if (!v34)
  {
    __nwlog_obj();
    dispatch_data_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v31 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v37 = "nw_candidate_manager_start_bonjour_service_resolve";
      _os_log_impl( &dword_181A5C000,  v20,  v31,  "%{public}s called with null manager->service, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_50;
  }

  int v27 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  dispatch_data_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  uint64_t v28 = type;
  uint64_t v29 = os_log_type_enabled(v20, type);
  if (!v27)
  {
    if (v29)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v37 = "nw_candidate_manager_start_bonjour_service_resolve";
      _os_log_impl(&dword_181A5C000, v20, v28, "%{public}s called with null manager->service, no backtrace", buf, 0xCu);
    }

    goto LABEL_50;
  }

  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v37 = "nw_candidate_manager_start_bonjour_service_resolve";
    os_log_type_t v38 = 2082;
    __int16 v39 = v27;
    _os_log_impl( &dword_181A5C000,  v20,  v28,  "%{public}s called with null manager->service, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v27);
  if (v19) {
    goto LABEL_52;
  }
LABEL_17:
}

  free(v11);
  if (v5) {
LABEL_74:
  }
    free(v5);
}

    free(backtrace_string);
    goto LABEL_69;
  }

  nw_context_assert_queue(*((void **)v7 + 46));
  if (*((void *)v7 + 63))
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_framer_deliver_input_no_copy";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = (char *)v7 + 609;
        _os_log_impl( &dword_181A5C000,  v29,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Cannot start a new parse with an outstanding parse",  buf,  0x16u);
      }
    }

  if (v15) {
    free(v15);
  }
  os_log_type_t v12 = 0;
LABEL_9:

  return v12;
}

          id v44 = *(void *)(v278 + 32);
          if (v44)
          {
            if ((*(_BYTE *)(v44 + 346) & 0x20) != 0) {
              goto LABEL_95;
            }
            if (*(_BYTE *)(v44 + 256))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
              }
              __int16 v45 = (os_log_s *)(id)gconnectionLogObj;
              if (!os_log_type_enabled(v45, OS_LOG_TYPE_INFO)) {
                goto LABEL_74;
              }
              v272 = v20;
              id v46 = *(void *)(v278 + 32);
              __int16 v47 = dnssd_getaddrinfo_result_get_type() - 1;
              char v48 = "?";
              if (v47 <= 4) {
                char v48 = off_189BB6D78[v47];
              }
              interface_index = dnssd_getaddrinfo_result_get_interface_index();
              hostname = dnssd_getaddrinfo_result_get_hostname();
              actual_hostname = dnssd_getaddrinfo_result_get_actual_hostname();
              *(_DWORD *)&buf[0].sa_len = 136448259;
              os_log_type_t v52 = "";
              if (tracker_hostname) {
                os_log_type_t v52 = " tracker";
              }
              *(void *)&buf[0].sa_data[2] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
              *(_WORD *)&buf[0].sa_data[10] = 2082;
              *(void *)&buf[0].sa_data[12] = v46 + 256;
              *(_WORD *)&buf[1].sa_data[4] = 2080;
              *(void *)&buf[1].sa_data[6] = v48;
              *(_WORD *)&buf[2].sa_len = 1024;
              *(_DWORD *)buf[2].sa_data = interface_index;
              *(_WORD *)&buf[2].sa_data[4] = 2085;
              *(void *)&buf[2].sa_data[6] = hostname;
              *(_WORD *)&buf[3].sa_len = 2085;
              *(void *)buf[3].sa_data = actual_hostname;
              *(_WORD *)&buf[3].sa_data[8] = 2082;
              *(void *)&buf[3].sa_data[10] = v21;
              *(_WORD *)&buf[4].sa_data[2] = 2082;
              *(void *)&buf[4].sa_data[4] = v272;
              *(_WORD *)&buf[4].sa_data[12] = 2082;
              *(void *)&buf[5].sa_len = v52;
              os_log_type_t v53 = v45;
              BOOL v54 = "%{public}s [C%{public}s] Got DNS result type %s ifindex=%u %{sensitive}s %{sensitive}s %{public}s%{p"
                    "ublic}s%{public}s";
              os_log_type_t v55 = 88;
              goto LABEL_73;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v45 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
            {
              v273 = v20;
              os_log_type_t v62 = *(_DWORD *)(*(void *)(v278 + 32) + 340LL);
              char v63 = dnssd_getaddrinfo_result_get_type() - 1;
              os_log_type_t v64 = "?";
              if (v63 <= 4) {
                os_log_type_t v64 = off_189BB6D78[v63];
              }
              v65 = dnssd_getaddrinfo_result_get_interface_index();
              os_log_type_t v66 = dnssd_getaddrinfo_result_get_hostname();
              BOOL v67 = dnssd_getaddrinfo_result_get_actual_hostname();
              *(_DWORD *)&buf[0].sa_len = 136448259;
              os_log_type_t v68 = "";
              if (tracker_hostname) {
                os_log_type_t v68 = " tracker";
              }
              *(void *)&buf[0].sa_data[2] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
              *(_WORD *)&buf[0].sa_data[10] = 1024;
              *(_DWORD *)&buf[0].sa_data[12] = v62;
              *(_WORD *)buf[1].sa_data = 2080;
              *(void *)&buf[1].sa_data[2] = v64;
              *(_WORD *)&buf[1].sa_data[10] = 1024;
              *(_DWORD *)&buf[1].sa_data[12] = v65;
              *(_WORD *)buf[2].sa_data = 2085;
              *(void *)&buf[2].sa_data[2] = v66;
              *(_WORD *)&buf[2].sa_data[10] = 2085;
              *(void *)&buf[2].sa_data[12] = v67;
              *(_WORD *)&buf[3].sa_data[4] = 2082;
              *(void *)&buf[3].sa_data[6] = v21;
              *(_WORD *)&buf[4].sa_len = 2082;
              *(void *)buf[4].sa_data = v273;
              *(_WORD *)&buf[4].sa_data[8] = 2082;
              *(void *)&buf[4].sa_data[10] = v68;
              os_log_type_t v53 = v45;
              BOOL v54 = "%{public}s [R%u] Got DNS result type %s ifindex=%u %{sensitive}s %{sensitive}s %{public}s%{public}s%{public}s";
              os_log_type_t v55 = 84;
LABEL_73:
              _os_log_impl(&dword_181A5C000, v53, OS_LOG_TYPE_INFO, v54, &buf[0].sa_len, v55);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v45 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
            {
              v56 = dnssd_getaddrinfo_result_get_type() - 1;
              os_log_type_t v57 = "?";
              if (v56 <= 4) {
                os_log_type_t v57 = off_189BB6D78[v56];
              }
              BOOL v58 = dnssd_getaddrinfo_result_get_interface_index();
              os_log_type_t v59 = dnssd_getaddrinfo_result_get_hostname();
              os_log_type_t v60 = dnssd_getaddrinfo_result_get_actual_hostname();
              *(_DWORD *)&buf[0].sa_len = 136448003;
              v61 = "";
              if (tracker_hostname) {
                v61 = " tracker";
              }
              *(void *)&buf[0].sa_data[2] = "nw_resolver_create_dns_getaddrinfo_locked_block_invoke";
              *(_WORD *)&buf[0].sa_data[10] = 2080;
              *(void *)&buf[0].sa_data[12] = v57;
              *(_WORD *)&buf[1].sa_data[4] = 1024;
              *(_DWORD *)&buf[1].sa_data[6] = v58;
              *(_WORD *)&buf[1].sa_data[10] = 2085;
              *(void *)&buf[1].sa_data[12] = v59;
              *(_WORD *)&buf[2].sa_data[4] = 2085;
              *(void *)&buf[2].sa_data[6] = v60;
              *(_WORD *)&buf[3].sa_len = 2082;
              *(void *)buf[3].sa_data = v21;
              *(_WORD *)&buf[3].sa_data[8] = 2082;
              *(void *)&buf[3].sa_data[10] = v20;
              *(_WORD *)&buf[4].sa_data[2] = 2082;
              *(void *)&buf[4].sa_data[4] = v61;
              os_log_type_t v53 = v45;
              BOOL v54 = "%{public}s Got DNS result type %s ifindex=%u %{sensitive}s %{sensitive}s %{public}s%{public}s%{public}s";
              os_log_type_t v55 = 78;
              goto LABEL_73;
            }
          }

LABEL_51:
      if (v16) {
        free(v16);
      }
      goto LABEL_16;
    }

    if (!v28)
    {
      __nwlog_obj();
      __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v27 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "nw_endpoint_hostname_matches_tracker";
        _os_log_impl( &dword_181A5C000,  v17,  v27,  "%{public}s called with null endpoint->known_tracker_name, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_50;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v24 = type;
    os_log_type_t v25 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "nw_endpoint_hostname_matches_tracker";
        _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null endpoint->known_tracker_name, no backtrace",  buf,  0xCu);
      }

      goto LABEL_50;
    }

    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      char v31 = "nw_endpoint_hostname_matches_tracker";
      __int16 v32 = 2082;
      id v33 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v17,  v24,  "%{public}s called with null endpoint->known_tracker_name, dumping backtrace:%{public}s",  buf,  0x16u);
    }

                __int16 v47 = (os_log_s *)v103;
LABEL_51:

LABEL_52:
LABEL_53:

LABEL_54:
                goto LABEL_55;
              }

              __int16 v37 = v101;
              os_log_type_t v38 = -[os_log_s port](v37, "port");

              __int16 v39 = v28;
              object = v98;
              v97 = v39;
              if (nw_protocol_metadata_is_tls((nw_protocol_metadata_t)object))
              {
                os_log_type_t v40 = nw_array_create();
                BOOL v41 = object;
                os_log_type_t v42 = MEMORY[0x1895F87A8];
                *(void *)buf = MEMORY[0x1895F87A8];
                *(void *)&buf[8] = 3221225472LL;
                *(void *)&buf[16] = ___ZL62nw_protocol_instance_registrar_copy_san_list_from_tls_metadataP41NWConcrete_nw_protocol_instance_registrarP11nw_protocolPU34objcproto23OS_nw_protocol_metadata8NSObjectt_block_invoke;
                v112 = (unsigned __int8 *)&unk_189BB6720;
                *(void *)v113 = v39;
                v114 = a2;
                int v43 = (sec_protocol_metadata *)v41;
                *(void *)&v113[8] = v43;
                v115 = __rev16(v38);
                id v44 = (unsigned __int8 *)(id)v40;
                *(void *)&v113[16] = v44;
                sec_protocol_metadata_access_peer_certificate_chain(v43, buf);
                __int16 v45 = nw_array_create();
                *(void *)os_log_type_t type = v42;
                v105 = 3221225472LL;
                v106 = (uint64_t)___ZL62nw_protocol_instance_registrar_copy_san_list_from_tls_metadataP41NWConcrete_nw_protocol_instance_registrarP11nw_protocolPU34objcproto23OS_nw_protocol_metadata8NSObjectt_block_invoke_70;
                v107 = (uint64_t (*)(uint64_t, uint64_t))&unk_189BC85B0;
                id v46 = (uint64_t)(id)v45;
                v108 = (void (*)(uint64_t))v46;
                nw_array_apply(v44, (uint64_t)type);

                uint64_t v10 = v99;
LABEL_36:

                goto LABEL_45;
              }

              __nwlog_obj();
              id v84 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata";
              v85 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              v110 = 0;
              if ((__nwlog_fault(v85, type, &v110) & 1) != 0)
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  id v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v87 = type[0];
                  if (os_log_type_enabled(v86, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata";
                    _os_log_impl(&dword_181A5C000, v86, v87, "%{public}s provided metadata is not tls", buf, 0xCu);
                  }
                }

                else if (v110)
                {
                  v91 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  id v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v92 = type[0];
                  int v93 = os_log_type_enabled(v86, type[0]);
                  if (v91)
                  {
                    if (v93)
                    {
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = v91;
                      _os_log_impl( &dword_181A5C000,  v86,  v92,  "%{public}s provided metadata is not tls, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v91);
                    goto LABEL_154;
                  }

                  if (v93)
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata";
                    _os_log_impl( &dword_181A5C000,  v86,  v92,  "%{public}s provided metadata is not tls, no backtrace",  buf,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  id v86 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  v95 = type[0];
                  if (os_log_type_enabled(v86, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_copy_san_list_from_tls_metadata";
                    _os_log_impl( &dword_181A5C000,  v86,  v95,  "%{public}s provided metadata is not tls, backtrace limit exceeded",  buf,  0xCu);
                  }
                }
              }

    free(v28);
    goto LABEL_51;
  }

    if (v20) {
      free(v20);
    }
    os_log_type_t v12 = 0LL;
    goto LABEL_7;
  }

  if (!v10)
  {
    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v39 = "nw_connection_group_create_request";
    dispatch_data_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v36 = 0;
    if (__nwlog_fault(v20, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unsigned int v24 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v39 = "nw_connection_group_create_request";
          _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null completion", buf, 0xCu);
        }

      uint64_t v26 = 0LL;
      goto LABEL_51;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
    char v16 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    id v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (os_log_s *)(id)gLogObj;
      BOOL v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_copy_path";
        _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null (flow == (_nw_protocol_default_flow))",  buf,  0xCu);
      }

          goto LABEL_51;
        }

        if (!v53)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v12 = (os_log_s *)(id)gLogObj;
          uint64_t v26 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446210;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl( &dword_181A5C000,  v12,  v26,  "%{public}s Outbound data limit updates is not opted in, backtrace limit exceeded",  buf,  0xCu);
          }

          goto LABEL_50;
        }

        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        unsigned int v24 = type;
        os_log_type_t v25 = os_log_type_enabled(v12, type);
        if (!backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446210;
            v56 = "nw_protocol_instance_update_outbound_data_limit";
            _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s Outbound data limit updates is not opted in, no backtrace",  buf,  0xCu);
          }

          goto LABEL_50;
        }

        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v56 = "nw_protocol_instance_update_outbound_data_limit";
          os_log_type_t v57 = 2082;
          *(void *)BOOL v58 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v24,  "%{public}s Outbound data limit updates is not opted in, dumping backtrace:%{public}s",  buf,  0x16u);
        }

              goto LABEL_51;
            }

            if (!v33)
            {
              __nwlog_obj();
              dispatch_data_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              int v27 = type;
              if (os_log_type_enabled(v20, type))
              {
                uint64_t v28 = (const char *)v18[2];
                if (!v28) {
                  uint64_t v28 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                os_log_type_t v40 = "__nw_protocol_output_available";
                BOOL v41 = 2082;
                os_log_type_t v42 = v28;
                int v43 = 2048;
                id v44 = v18;
                _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded",  buf,  0x20u);
              }

              goto LABEL_50;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            dispatch_data_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            unsigned int v24 = type;
            os_log_type_t v25 = os_log_type_enabled(v20, type);
            if (!backtrace_string)
            {
              if (v25)
              {
                uint64_t v29 = (const char *)v18[2];
                if (!v29) {
                  uint64_t v29 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                os_log_type_t v40 = "__nw_protocol_output_available";
                BOOL v41 = 2082;
                os_log_type_t v42 = v29;
                int v43 = 2048;
                id v44 = v18;
                _os_log_impl( &dword_181A5C000,  v20,  v24,  "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace",  buf,  0x20u);
              }

              goto LABEL_50;
            }

            if (v25)
            {
              uint64_t v26 = (const char *)v18[2];
              if (!v26) {
                uint64_t v26 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              os_log_type_t v40 = "__nw_protocol_output_available";
              BOOL v41 = 2082;
              os_log_type_t v42 = v26;
              int v43 = 2048;
              id v44 = v18;
              __int16 v45 = 2082;
              id v46 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v20,  v24,  "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s",  buf,  0x2Au);
            }

            free(backtrace_string);
          }

    if (v16) {
      free(v16);
    }
LABEL_52:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v31 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    int v43 = "nw_advertise_descriptor_create_application_service_with_bundle_id";
    __int16 v32 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v41.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v32, &v41, &type))
    {
      if (LOBYTE(v41.receiver) == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v33 = (os_log_s *)(id)gLogObj;
        receiver = (os_log_type_t)v41.receiver;
        if (os_log_type_enabled(v33, (os_log_type_t)v41.receiver))
        {
          *(_DWORD *)buf = 136446210;
          int v43 = "nw_advertise_descriptor_create_application_service_with_bundle_id";
          _os_log_impl(&dword_181A5C000, v33, receiver, "%{public}s [nw_advertise_descriptor_t init] failed", buf, 0xCu);
        }
      }

      else if (type)
      {
        __int16 v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v33 = (os_log_s *)(id)gLogObj;
        __int16 v36 = (os_log_type_t)v41.receiver;
        __int16 v37 = os_log_type_enabled(v33, (os_log_type_t)v41.receiver);
        if (v35)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446466;
            int v43 = "nw_advertise_descriptor_create_application_service_with_bundle_id";
            id v44 = 2082;
            __int16 v45 = v35;
            _os_log_impl( &dword_181A5C000,  v33,  v36,  "%{public}s [nw_advertise_descriptor_t init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v35);
          goto LABEL_68;
        }

        if (v37)
        {
          *(_DWORD *)buf = 136446210;
          int v43 = "nw_advertise_descriptor_create_application_service_with_bundle_id";
          _os_log_impl( &dword_181A5C000,  v33,  v36,  "%{public}s [nw_advertise_descriptor_t init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v33 = (os_log_s *)(id)gLogObj;
        os_log_type_t v38 = (os_log_type_t)v41.receiver;
        if (os_log_type_enabled(v33, (os_log_type_t)v41.receiver))
        {
          *(_DWORD *)buf = 136446210;
          int v43 = "nw_advertise_descriptor_create_application_service_with_bundle_id";
          _os_log_impl( &dword_181A5C000,  v33,  v38,  "%{public}s [nw_advertise_descriptor_t init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

  if (v7) {
LABEL_51:
  }
    free(v7);
  return 0LL;
}

    if (v18) {
      free(v18);
    }
    goto LABEL_14;
  }

  __nwlog_obj();
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  __int16 v32 = "nw_flow_replay_output_available";
  int v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v29 = 0;
  if (__nwlog_fault(v14, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_flow_replay_output_available";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null protocol", buf, 0xCu);
      }
    }

    else if (v29)
    {
      uint64_t v21 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v22 = type;
      os_log_type_t v23 = os_log_type_enabled(v15, type);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v32 = "nw_flow_replay_output_available";
          id v33 = 2082;
          uint32_t v34 = v21;
          _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v21);
        goto LABEL_45;
      }

      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_flow_replay_output_available";
        _os_log_impl(&dword_181A5C000, v15, v22, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v27 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_flow_replay_output_available";
        _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s called with null protocol, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

          int v14 = 1LL;
          goto LABEL_51;
        }

  uint64_t v9 = obj;
LABEL_51:
  obja = v9;
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 264LL), v9);
  if (v2) {
}
  }

      free(v14);
      goto LABEL_51;
    }

    __nwlog_obj();
    os_log_type_t v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v67 = "nw_parameters_create_quic_stream";
    id v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v64 = 0;
    if (__nwlog_fault(v33, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint32_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v41 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v67 = "nw_parameters_create_quic_stream";
          _os_log_impl( &dword_181A5C000,  v34,  v41,  "%{public}s called with null (configure_quic_connection != (_nw_parameters_configure_protocol_disable))",  buf,  0xCu);
        }

      int v5 = 0LL;
LABEL_51:

      goto LABEL_52;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
    unsigned int v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v37 = 0;
    if (__nwlog_fault(v11, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
          _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s nw_tcp_create_options failed", buf, 0xCu);
        }
      }

      else if (v37)
      {
        __int16 v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        BOOL v18 = type;
        char v19 = os_log_type_enabled(v12, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
            BOOL v41 = 2082;
            os_log_type_t v42 = v17;
            _os_log_impl( &dword_181A5C000,  v12,  v18,  "%{public}s nw_tcp_create_options failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v17);
          if (!v11) {
            goto LABEL_50;
          }
          goto LABEL_49;
        }

        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
          _os_log_impl(&dword_181A5C000, v12, v18, "%{public}s nw_tcp_create_options failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
          _os_log_impl( &dword_181A5C000,  v12,  v21,  "%{public}s nw_tcp_create_options failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v11) {
      goto LABEL_50;
    }
LABEL_49:
    free(v11);
    goto LABEL_50;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  nw_endpoint_t v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
  qos_class_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v37 = 0;
  if (__nwlog_fault(v7, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      uint64_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
    }

    else if (v37)
    {
      int v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      char v16 = os_log_type_enabled(v8, type);
      if (v14)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
          BOOL v41 = 2082;
          os_log_type_t v42 = v14;
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v14);
        if (!v7) {
          goto LABEL_41;
        }
        goto LABEL_40;
      }

      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl(&dword_181A5C000, v8, v15, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)(id)gLogObj;
      dispatch_data_t v20 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v40 = "nw_parameters_create_legacy_tcp_socket";
        _os_log_impl( &dword_181A5C000,  v8,  v20,  "%{public}s nw_parameters_create failed, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

  if (v7) {
LABEL_40:
  }
    free(v7);
LABEL_41:
  int v5 = 0LL;
LABEL_52:

LABEL_53:
  return v5;
}

      free(v39);
    }
  }

        _os_log_impl(&dword_181A5C000, v15, v16, v17, applier, 0x12u);
        goto LABEL_51;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v15 = (os_log_s *)gLogObj;
      char v16 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)applier = 136446466;
        *(void *)&applier[4] = "network_config_setup_policy_event_watcher_block_invoke";
        *(_WORD *)&applier[12] = 1024;
        *(_DWORD *)&applier[14] = v13;
        __int16 v17 = "%{public}s recv from kernel event socket failed %{darwin.errno}d";
        goto LABEL_50;
      }

LABEL_51:
    char v19 = 0LL;
    goto LABEL_52;
  }

  if (nw_context_is_inline(v2->context))
  {
    nw_endpoint_t v6 = v2->parameters;
    if (!v6 || nw_path_parameters_get_logging_disabled(*((void *)v6 + 13))) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      qos_class_t v7 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      __int16 v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)os_log_type_t v38 = v7;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Not probing when context is inline",  buf,  0x12u);
    }

    goto LABEL_50;
  }

  os_log_type_t v8 = (uint64_t *)v2->parameters;
  if (v2->state == 5)
  {
    if (!v8 || nw_path_parameters_get_logging_disabled(v8[13])) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      __int16 v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)os_log_type_t v38 = v9;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Not probing a cancelled connection",  buf,  0x12u);
    }

    goto LABEL_50;
  }

  if (nw_parameters_get_data_mode(v8) != 2 && nw_parameters_get_data_mode(v2->parameters))
  {
    uint64_t v10 = v2->parameters;
    if (!v10 || nw_path_parameters_get_logging_disabled(*((void *)v10 + 13))) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v11 = v2->top_id;
      data_uint64_t mode = nw_parameters_get_data_mode(v2->parameters);
      *(_DWORD *)buf = 136446722;
      __int16 v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)os_log_type_t v38 = v11;
      v38[2] = 1024;
      *(_DWORD *)&v38[3] = data_mode;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Not probing a connection that was specified yet not streaming: %d",  buf,  0x18u);
    }

    goto LABEL_50;
  }

  server_uint64_t mode = nw_parameters_get_server_mode(v2->parameters);
  int v14 = (uint64_t *)v2->parameters;
  if (server_mode)
  {
    if (!v14 || nw_path_parameters_get_logging_disabled(v14[13])) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v15 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      __int16 v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)os_log_type_t v38 = v15;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Not probing a connection that was not a client",  buf,  0x12u);
    }

    goto LABEL_50;
  }

  https_proxy_over_tls = nw_parameters_get_https_proxy_over_tls(v14);
  __int16 v17 = (uint64_t *)v2->parameters;
  if (https_proxy_over_tls)
  {
    if (!v17 || nw_path_parameters_get_logging_disabled(v17[13])) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    uint64_t v4 = (os_log_s *)(id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      BOOL v18 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      __int16 v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)os_log_type_t v38 = v18;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Not probing a connection for an HTTPS proxy over TLS",  buf,  0x12u);
    }

    goto LABEL_50;
  }

  uint64_t v21 = v17;
  char v19 = v21 != 0LL;
  if (!v21)
  {
    uint64_t v22 = v2->parameters;
    if (v22)
    {
      if (!nw_path_parameters_get_logging_disabled(*((void *)v22 + 13)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v23 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          unsigned int v24 = v2->top_id;
          *(_DWORD *)buf = 136446466;
          __int16 v36 = "nw_connection_should_run_probe_locked";
          __int16 v37 = 1024;
          *(_DWORD *)os_log_type_t v38 = v24;
          _os_log_impl( &dword_181A5C000,  v23,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Not probing a connection for which we cannot get the parameters",  buf,  0x12u);
        }
      }
    }
  }

LABEL_52:
  return v19;
}

      (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1LL, a3);
      return;
    }

    uint64_t v28 = (char *)v42;
LABEL_46:
    free(v28);
    goto LABEL_47;
  }

  __nwlog_obj();
  *(_DWORD *)block = 136446210;
  *(void *)&block[4] = "operator()";
  uint64_t v29 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v81) = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (v81 == 17)
  {
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    char v31 = v81;
    if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
      goto LABEL_119;
    }
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "operator()";
    __int16 v32 = "%{public}s called with null completion";
    goto LABEL_118;
  }

  if (type[0] == OS_LOG_TYPE_DEFAULT)
  {
    uint64_t v30 = (os_log_s *)__nwlog_obj();
    char v31 = v81;
    if (!os_log_type_enabled(v30, (os_log_type_t)v81)) {
      goto LABEL_119;
    }
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "operator()";
    __int16 v32 = "%{public}s called with null completion, backtrace limit exceeded";
    goto LABEL_118;
  }

  __int16 v35 = (char *)__nw_create_backtrace_string();
  uint64_t v30 = (os_log_s *)__nwlog_obj();
  char v31 = v81;
  os_log_type_t v40 = os_log_type_enabled(v30, (os_log_type_t)v81);
  if (!v35)
  {
    if (!v40) {
      goto LABEL_119;
    }
    *(_DWORD *)block = 136446210;
    *(void *)&block[4] = "operator()";
    __int16 v32 = "%{public}s called with null completion, no backtrace";
    goto LABEL_118;
  }

  if (v40)
  {
    *(_DWORD *)block = 136446466;
    *(void *)&block[4] = "operator()";
    *(_WORD *)&block[12] = 2082;
    *(void *)&block[14] = v35;
    __int16 v37 = "%{public}s called with null completion, dumping backtrace:%{public}s";
    goto LABEL_93;
  }

    if (!v16) {
      goto LABEL_17;
    }
LABEL_51:
    free(v16);
    goto LABEL_17;
  }

  uint64_t v13 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  int v27 = "strict_calloc";
  uint64_t v28 = 2048;
  uint64_t v29 = 1LL;
  uint64_t v30 = 2048;
  char v31 = 592LL;
  int v14 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_2;
  }

  __break(1u);
  return result;
}
}

    if (v12) {
      free(v12);
    }
    int v5 = 0LL;
    goto LABEL_11;
  }

  __nwlog_obj();
  qos_class_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v26 = "nw_endpoint_handler_uses_sleep_proxy";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (__nwlog_fault(v8, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_endpoint_handler_uses_sleep_proxy";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
      }
    }

    else if (v23)
    {
      os_log_type_t v15 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v16 = type;
      __int16 v17 = os_log_type_enabled(v9, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_endpoint_handler_uses_sleep_proxy";
          int v27 = 2082;
          uint64_t v28 = v15;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v15);
        goto LABEL_41;
      }

      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_endpoint_handler_uses_sleep_proxy";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v21 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_endpoint_handler_uses_sleep_proxy";
        _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s called with null handler, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

LABEL_24:
      if (!v18) {
        goto LABEL_26;
      }
LABEL_25:
      free(v18);
      goto LABEL_26;
    }

    uint32_t v34 = __nw_create_backtrace_string();
    __nwlog_obj();
    char v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v32 = type;
    __int16 v35 = os_log_type_enabled(v31, type);
    if (!v34)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v39 = "tcp_connection_get_statistics";
        id v33 = "%{public}s called with null statistics, no backtrace";
        goto LABEL_49;
      }

      goto LABEL_50;
    }

    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v39 = "tcp_connection_get_statistics";
      os_log_type_t v40 = 2082;
      *(void *)BOOL v41 = v34;
      _os_log_impl( &dword_181A5C000,  v31,  v32,  "%{public}s called with null statistics, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    uint64_t v26 = (char *)v34;
LABEL_23:
    free(v26);
    goto LABEL_24;
  }

  qos_class_t v7 = nw_connection_fillout_tcp_statistics(v6, (uint64_t)a3);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v8 = (os_log_s *)(id)gLogObj;
  uint64_t v9 = v8;
  if (!v7)
  {
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "tcp_connection_get_statistics";
      uint64_t v22 = "%{public}s Failed to get statistics from connection";
      goto LABEL_16;
    }

    goto LABEL_17;
  }

  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = *a3;
    unsigned int v11 = a3[1];
    os_log_type_t v12 = a3[2];
    uint64_t v13 = a3[3];
    int v14 = a3[4];
    os_log_type_t v15 = a3[5];
    *(_DWORD *)buf = 136447746;
    __int16 v39 = "tcp_connection_get_statistics";
    os_log_type_t v40 = 1024;
    *(_DWORD *)BOOL v41 = v10;
    *(_WORD *)&v41[4] = 1024;
    *(_DWORD *)&v41[6] = v11;
    os_log_type_t v42 = 1024;
    int v43 = v12;
    id v44 = 1024;
    __int16 v45 = v13;
    id v46 = 1024;
    __int16 v47 = v14;
    char v48 = 1024;
    uint64_t v49 = v15;
    _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s DNS: %ums/%ums since start, TCP: %ums/%ums since start, TLS: %ums/%ums since start",  buf,  0x30u);
  }

  char v16 = 1LL;
LABEL_27:

  return v16;
}

  if (v11) {
    free(v11);
  }
  return 4294966394LL;
}

            goto LABEL_51;
          }

          if (!v110)
          {
            __nwlog_obj();
            int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            v100 = v111;
            if (os_log_type_enabled(v27, v111))
            {
              *(_DWORD *)buf = 136447234;
              v116 = "nw_necp_append_tlv";
              v117 = 2048;
              v118 = (size_t)v24;
              v119 = 2048;
              v120 = a3;
              v121 = 1024;
              *(_DWORD *)v122 = 5;
              *(_WORD *)&v122[4] = 1024;
              *(_DWORD *)&v122[6] = 42;
              _os_log_impl( &dword_181A5C000,  v27,  v100,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  buf,  0x2Cu);
            }

            goto LABEL_50;
          }

          v92 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v93 = v111;
          uint64_t v94 = os_log_type_enabled(v27, v111);
          if (!v92)
          {
            if (v94)
            {
              *(_DWORD *)buf = 136447234;
              v116 = "nw_necp_append_tlv";
              v117 = 2048;
              v118 = (size_t)v24;
              v119 = 2048;
              v120 = a3;
              v121 = 1024;
              *(_DWORD *)v122 = 5;
              *(_WORD *)&v122[4] = 1024;
              *(_DWORD *)&v122[6] = 42;
              _os_log_impl( &dword_181A5C000,  v27,  v93,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  buf,  0x2Cu);
            }

            goto LABEL_50;
          }

          if (v94)
          {
            *(_DWORD *)buf = 136447490;
            v116 = "nw_necp_append_tlv";
            v117 = 2048;
            v118 = (size_t)v24;
            v119 = 2048;
            v120 = a3;
            v121 = 1024;
            *(_DWORD *)v122 = 5;
            *(_WORD *)&v122[4] = 1024;
            *(_DWORD *)&v122[6] = 42;
            *(_WORD *)v123 = 2082;
            *(void *)&v123[2] = v92;
            _os_log_impl( &dword_181A5C000,  v27,  v93,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
          }

          free(v92);
        }

    if (v19) {
      free(v19);
    }
    goto LABEL_13;
  }

  __nwlog_obj();
  int v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v33 = "nw_proxy_config_create_http_connect";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v30 = 0;
  if (__nwlog_fault(v15, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        id v33 = "nw_proxy_config_create_http_connect";
        _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null proxy_endpoint", buf, 0xCu);
      }
    }

    else if (v30)
    {
      uint64_t v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      unsigned int v24 = os_log_type_enabled(v16, type);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          id v33 = "nw_proxy_config_create_http_connect";
          uint32_t v34 = 2082;
          __int16 v35 = v22;
          _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s called with null proxy_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v22);
        goto LABEL_44;
      }

      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        id v33 = "nw_proxy_config_create_http_connect";
        _os_log_impl(&dword_181A5C000, v16, v23, "%{public}s called with null proxy_endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v28 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        id v33 = "nw_proxy_config_create_http_connect";
        _os_log_impl( &dword_181A5C000,  v16,  v28,  "%{public}s called with null proxy_endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

    free(backtrace_string);
    goto LABEL_68;
  }

  unsigned int v11 = (os_log_s *)__nwlog_obj();
  os_log_type_t v12 = type;
  if (os_log_type_enabled(v11, type))
  {
    *(_DWORD *)buf = 136446210;
    uint64_t v29 = "nw_http1_on_url_complete";
    uint64_t v13 = "%{public}s called with null parsed_fields";
    goto LABEL_67;
  }

    if ((*(_BYTE *)(a1 + 158) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v44 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        __int16 v45 = *(void *)(a1 + 488);
        id v46 = *(_DWORD *)(*(void *)(a1 + 480) + 372LL);
        __int16 v47 = *(_DWORD *)(a1 + 860);
        if (v45) {
          LODWORD(v45) = *(_DWORD *)(v45 + 424);
        }
        *(_DWORD *)buf = 136447746;
        v65 = "nw_http1_connection_execute_parser";
        os_log_type_t v66 = 2082;
        BOOL v67 = (char *)(a1 + 74);
        os_log_type_t v68 = 2080;
        BOOL v69 = " ";
        v70 = 1024;
        os_log_type_t v71 = v46;
        BOOL v72 = 1024;
        v73 = v47;
        v74 = 1024;
        v75 = v45;
        os_log_type_t v76 = 1024;
        LODWORD(v77) = v7;
        _os_log_impl( &dword_181A5C000,  v44,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> parsed %u bytes",  buf,  0x38u);
      }
    }

    *a4 = v7;
    if ((v10 & 1) == 0) {
      goto LABEL_56;
    }
LABEL_68:
    if (v11) {
      nw_http_transaction_metadata_increment_inbound_body_transfer_size(*(void **)(*(void *)(a1 + 488) + 352LL), v11);
    }
    return 1LL;
  }

  uint64_t v29 = *(void *)(a1 + 240);
  uint64_t v30 = v29 - (_DWORD)a2;
  *a4 = v29 - (_DWORD)a2;
  if ((*(_BYTE *)(a1 + 158) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v31 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      __int16 v32 = *(void *)(a1 + 488);
      id v33 = *(_DWORD *)(*(void *)(a1 + 480) + 372LL);
      uint32_t v34 = *(_DWORD *)(a1 + 860);
      if (v32) {
        LODWORD(v32) = *(_DWORD *)(v32 + 424);
      }
      __int16 v35 = *a4;
      *(_DWORD *)buf = 136447746;
      v65 = "nw_http1_connection_execute_parser";
      os_log_type_t v66 = 2082;
      BOOL v67 = (char *)(a1 + 74);
      os_log_type_t v68 = 2080;
      BOOL v69 = " ";
      v70 = 1024;
      os_log_type_t v71 = v33;
      BOOL v72 = 1024;
      v73 = v34;
      v74 = 1024;
      v75 = v32;
      os_log_type_t v76 = 1024;
      LODWORD(v77) = v35;
      _os_log_impl( &dword_181A5C000,  v31,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> paused parser after processing %u bytes",  buf,  0x38u);
    }

    uint64_t v30 = *a4;
  }

  unsigned int v11 = v30;
  __int16 v36 = *v13;
  if ((v10 & 1) == 0)
  {
    if ((v36 & 4) != 0)
    {
LABEL_56:
      if (v11) {
        nw_http_transaction_metadata_increment_inbound_header_size(*(void **)(*(void *)(a1 + 488) + 352LL), v11);
      }
      return 1LL;
    }

    __int16 v37 = *(void *)(a1 + 488);
    if ((_DWORD)v11)
    {
      nw_http_transaction_metadata_increment_inbound_header_size(*(void **)(v37 + 352), v11);
      __int16 v37 = *(void *)(a1 + 488);
    }

    os_log_type_t v38 = *(_WORD *)(v37 + 428);
    __int16 v39 = *(_BYTE *)(a1 + 158);
    if ((v38 & 1) != 0)
    {
      if ((*(_BYTE *)(a1 + 158) & 1) == 0)
      {
        os_log_type_t v40 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
        {
          BOOL v41 = *(void *)(a1 + 488);
          os_log_type_t v42 = *(_DWORD *)(*(void *)(a1 + 480) + 372LL);
          int v43 = *(_DWORD *)(a1 + 860);
          if (v41) {
            LODWORD(v41) = *(_DWORD *)(v41 + 424);
          }
          *(_DWORD *)buf = 136447490;
          v65 = "nw_http1_connection_execute_parser";
          os_log_type_t v66 = 2082;
          BOOL v67 = (char *)(a1 + 74);
          os_log_type_t v68 = 2080;
          BOOL v69 = " ";
          v70 = 1024;
          os_log_type_t v71 = v42;
          BOOL v72 = 1024;
          v73 = v43;
          v74 = 1024;
          v75 = v41;
          _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:c%u:s%u> resuming after processing headers",  buf,  0x32u);
        }
      }

      if (*(_DWORD *)(a1 + 224) == 21) {
        *(_DWORD *)(a1 + 224) = 0;
      }
      *(_DWORD *)buf = 0;
      BOOL result = nw_http1_connection_execute_parser(a1, v29, v7 - *a4, buf, a5);
      *a4 += *(_DWORD *)buf;
      return result;
    }

LABEL_51:
      if (!v18)
      {
LABEL_53:
        char v16 = 22LL;
        goto LABEL_61;
      }

  if (v22) {
    free(v22);
  }
  char v19 = 0LL;
LABEL_9:

  return v19;
}

  if (v22) {
    free(v22);
  }
  char v19 = 0LL;
LABEL_9:

  return v19;
}

  if ((_BYTE)v4) {
    goto LABEL_54;
  }
  os_log_type_t v12 = 1LL;
  if (!a4) {
    goto LABEL_52;
  }
LABEL_58:
  *(_WORD *)a1 = 0;
  a1[2] = 0;
  return v12;
}

    free(v26);
    if (!v16) {
      goto LABEL_7;
    }
    goto LABEL_75;
  }

  int v14 = (dispatch_queue_s *)v9[2];
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __nw_storage_lookup_items_block_invoke;
  block[3] = &unk_189BBECD8;
  id v33 = v9;
  os_log_type_t v38 = a2;
  uint32_t v34 = v10;
  __int16 v35 = 0LL;
  __int16 v36 = v11;
  __int16 v37 = v13;
  dispatch_async(v14, block);

LABEL_7:
}

            free(v13);
            goto LABEL_51;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v17 = (id)gLogObj;
          LODWORD(buffer[0]) = 136446466;
          *(void *)((char *)buffer + 4) = "nwsc_get_remote_pub_key";
          WORD2(buffer[1]) = 2114;
          *(void *)((char *)&buffer[1] + 6) = v9;
          BOOL v18 = (char *)_os_log_send_and_compose_impl();

          buf[0] = 16;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v18, buf, &type))
          {
            if (buf[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              char v19 = (os_log_s *)(id)gLogObj;
              dispatch_data_t v20 = buf[0];
              if (os_log_type_enabled(v19, (os_log_type_t)buf[0]))
              {
                LODWORD(buffer[0]) = 136446466;
                *(void *)((char *)buffer + 4) = "nwsc_get_remote_pub_key";
                WORD2(buffer[1]) = 2114;
                *(void *)((char *)&buffer[1] + 6) = v9;
                _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s Could not get identifier for endpoint %{public}@",  (uint8_t *)buffer,  0x16u);
              }

      free(backtrace_string);
      goto LABEL_71;
    }

    if (!v22) {
      goto LABEL_71;
    }
    *(_DWORD *)buf = 136446210;
    int v27 = "nw_protocol_common_add_input_handler";
    unsigned int v11 = "%{public}s Default input handler already exists, common add input handler does not support multiplexing protoc"
          "ols, no backtrace";
LABEL_70:
    _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
LABEL_71:
    if (v8)
    {
      os_log_type_t v23 = (char *)v8;
      goto LABEL_73;
    }

    return 0LL;
  }

  *(void *)(a1 + 48) = a2;
  if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v4 = *(void *)(a2 + 88);
    if (v4) {
      *(void *)(a2 + 88) = v4 + 1;
    }
  }

  if (*(void *)(a2 + 32))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v5 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      int v27 = "nw_protocol_common_add_input_handler";
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s Output handler already exists for protocol being added as input handler",  buf,  0xCu);
    }
  }

  else
  {
    *(void *)(a2 + 32) = a1;
    if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
    {
      nw_endpoint_t v6 = *(void *)(a1 + 88);
      if (v6) {
        *(void *)(a1 + 88) = v6 + 1;
      }
    }
  }

  *(_OWORD *)a1 = *(_OWORD *)a2;
  return 1LL;
}

        free((void *)v4);
      }
    }
  }

    free(v18);
    goto LABEL_51;
  }

  __nwlog_obj();
  v56 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  BOOL v69 = "strict_calloc";
  v70 = 2048;
  os_log_type_t v71 = (char *)1;
  BOOL v72 = 2048;
  v73 = 48LL;
  os_log_type_t v57 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v57))
  {
    free(v57);
    __nwlog_obj();
    BOOL v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    BOOL v69 = "nw_quic_report_application_result_on_queue";
    __int16 v47 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v66 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v59 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl(&dword_181A5C000, v48, v59, "%{public}s called with null association_cache", buf, 0xCu);
      }
    }

    else if (v66)
    {
      os_log_type_t v62 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v63 = type;
      os_log_type_t v64 = os_log_type_enabled(v48, type);
      if (v62)
      {
        if (v64)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v69 = "nw_quic_report_application_result_on_queue";
          v70 = 2082;
          os_log_type_t v71 = v62;
          _os_log_impl( &dword_181A5C000,  v48,  v63,  "%{public}s called with null association_cache, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v62);
        if (!v47) {
          goto LABEL_57;
        }
        goto LABEL_112;
      }

      if (v64)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl( &dword_181A5C000,  v48,  v63,  "%{public}s called with null association_cache, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v65 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v69 = "nw_quic_report_application_result_on_queue";
        _os_log_impl( &dword_181A5C000,  v48,  v65,  "%{public}s called with null association_cache, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_110;
  }

  __break(1u);
}

  if (v9) {
    free(v9);
  }
LABEL_7:
}

        goto LABEL_51;
      }

      if (!v36)
      {
        __nwlog_obj();
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v32 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          os_log_type_t v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl( &dword_181A5C000,  v22,  v32,  "%{public}s called with null old_endpoint, backtrace limit exceeded",  (uint8_t *)__s,  0xCu);
        }

        goto LABEL_50;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = buf[0];
      uint64_t v30 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)__s = 136446210;
          os_log_type_t v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s called with null old_endpoint, no backtrace",  (uint8_t *)__s,  0xCu);
        }

        goto LABEL_50;
      }

      if (v30)
      {
        *(_DWORD *)__s = 136446466;
        os_log_type_t v42 = "nw_browser_check_and_remove_endpoints_locked";
        int v43 = 2082;
        id v44 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s called with null old_endpoint, dumping backtrace:%{public}s",  (uint8_t *)__s,  0x16u);
      }

      goto LABEL_38;
    }

    goto LABEL_51;
  }

  v33[0] = MEMORY[0x1895F87A8];
  v33[1] = 3221225472LL;
  v33[2] = ___ZL44nw_browser_check_and_remove_endpoints_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS1_PU26objcproto15OS_nw_interfaceS1__block_invoke;
  v33[3] = &unk_189BC5030;
  unsigned int v11 = v9;
  uint32_t v34 = v11;
  os_log_type_t v12 = v10;
  __int16 v35 = v12;
  if (nw_array_apply(v8, (uint64_t)v33))
  {
    bzero(__s, 0x3F1uLL);
    domain_for_policy = nw_endpoint_get_domain_for_policy(v11);
    if (domain_for_policy)
    {
      int v14 = 0LL;
      while (1)
      {
        os_log_type_t v15 = *(unsigned __int8 *)(domain_for_policy + v14);
        __s[v14] = v15;
        if (!v15) {
          break;
        }
        if (++v14 == 1008)
        {
          __int16 v45 = 0;
          break;
        }
      }

      for (i = 0LL; i < strlen(__s); ++i)
        __s[i] = __tolower(__s[i]);
    }

    else
    {
      nw_browser_copy_key_for_application_service_endpoint(v11, __s);
    }

    if ((nw_browser_remove_result_locked(v7, __s, v12) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v38 = "nw_browser_check_and_remove_endpoints_locked";
        __int16 v39 = 2080;
        os_log_type_t v40 = __s;
        _os_log_impl(&dword_181A5C000, v17, OS_LOG_TYPE_ERROR, "%{public}s Failed to remove result for %s", buf, 0x16u);
      }
    }
  }

  BOOL v18 = 1LL;
LABEL_18:

  return v18;
}

  if (v13) {
    free(v13);
  }
  uint64_t v10 = 0LL;
LABEL_9:

  return v10;
}

        free(v24);
        goto LABEL_51;
      }

      if (v139)
      {
        *(_DWORD *)buf = 136446722;
        v171 = "nw_necp_append_tlv";
        v172 = 1024;
        *(_DWORD *)v173 = 100;
        *(_WORD *)&v173[4] = 1024;
        *(_DWORD *)&v173[6] = 16;
        _os_log_impl( &dword_181A5C000,  v32,  v138,  "%{public}s type=%u length=%u but value is NULL, no backtrace",  buf,  0x18u);
      }

      goto LABEL_48;
    }

    *(_OWORD *)(v20 + 5) = *a2;
    if (v19 <= 0x15)
    {
      __nwlog_obj();
      v121 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136447234;
      v171 = "nw_necp_append_tlv";
      v172 = 2048;
      *(void *)v173 = v21 + 21;
      *(_WORD *)&v173[8] = 2048;
      *(void *)&v173[10] = &v21[v19];
      *(_WORD *)&v173[18] = 1024;
      *(_DWORD *)v174 = 101;
      *(_WORD *)&v174[4] = 1024;
      *(_DWORD *)&v174[6] = 2;
      os_log_type_t v42 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v165 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v122 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136447234;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(void *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(void *)&v173[10] = &v21[v19];
          *(_WORD *)&v173[18] = 1024;
          *(_DWORD *)v174 = 101;
          *(_WORD *)&v174[4] = 1024;
          *(_DWORD *)&v174[6] = 2;
          _os_log_impl( &dword_181A5C000,  v43,  v122,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u",  buf,  0x2Cu);
        }
      }

      else
      {
        if (v165)
        {
          v144 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v145 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          v146 = type;
          v147 = os_log_type_enabled(v145, type);
          if (v144)
          {
            if (v147)
            {
              *(_DWORD *)buf = 136447490;
              v171 = "nw_necp_append_tlv";
              v172 = 2048;
              *(void *)v173 = v21 + 21;
              *(_WORD *)&v173[8] = 2048;
              *(void *)&v173[10] = &v21[v19];
              *(_WORD *)&v173[18] = 1024;
              *(_DWORD *)v174 = 101;
              *(_WORD *)&v174[4] = 1024;
              *(_DWORD *)&v174[6] = 2;
              *(_WORD *)v175 = 2082;
              *(void *)&v175[2] = v144;
              _os_log_impl( &dword_181A5C000,  v145,  v146,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x36u);
            }

            free(v144);
          }

          else
          {
            if (v147)
            {
              *(_DWORD *)buf = 136447234;
              v171 = "nw_necp_append_tlv";
              v172 = 2048;
              *(void *)v173 = v21 + 21;
              *(_WORD *)&v173[8] = 2048;
              *(void *)&v173[10] = &v21[v19];
              *(_WORD *)&v173[18] = 1024;
              *(_DWORD *)v174 = 101;
              *(_WORD *)&v174[4] = 1024;
              *(_DWORD *)&v174[6] = 2;
              _os_log_impl( &dword_181A5C000,  v145,  v146,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace",  buf,  0x2Cu);
            }
          }

          goto LABEL_67;
        }

        __nwlog_obj();
        int v43 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v158 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136447234;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(void *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(void *)&v173[10] = &v21[v19];
          *(_WORD *)&v173[18] = 1024;
          *(_DWORD *)v174 = 101;
          *(_WORD *)&v174[4] = 1024;
          *(_DWORD *)&v174[6] = 2;
          _os_log_impl( &dword_181A5C000,  v43,  v158,  "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded",  buf,  0x2Cu);
        }
      }

      goto LABEL_66;
    }

    if (v19 - 21 > 6)
    {
      v20[21] = 101;
      *(_DWORD *)(v20 + 22) = 2;
      *((_WORD *)v20 + 13) = a3;
      __int16 v35 = (unint64_t)(v20 + 28);
      goto LABEL_70;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v27 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    v171 = "nw_necp_append_tlv";
    v172 = 2048;
    *(void *)v173 = v21 + 21;
    *(_WORD *)&v173[8] = 2048;
    *(void *)&v173[10] = 7LL;
    *(_WORD *)&v173[18] = 2048;
    *(void *)v174 = &v21[v19];
    *(_WORD *)&v174[8] = 1024;
    *(_DWORD *)v175 = 101;
    *(_WORD *)&v175[4] = 1024;
    *(_DWORD *)&v175[6] = 2;
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (__nwlog_fault(v28, &type, &v165))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v29 = (os_log_s *)(id)gLogObj;
        uint64_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(void *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(void *)&v173[10] = 7LL;
          *(_WORD *)&v173[18] = 2048;
          *(void *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 101;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 2;
          _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  buf,  0x36u);
        }

        id v33 = *(void *)(a1 + 32);
        if (v33)
        {
          uint32_t v34 = *(void *)(v33 + 24);
          if (v34)
          {
            os_log_type_t v12 = *(void (**)(void))(v34 + 160);
            if (v12) {
LABEL_53:
            }
              v12();
          }
        }

        return;
      }

      uint64_t v13 = *(void *)(v6 + 880);
      if (!v13)
      {
LABEL_24:
        int v14 = *(unsigned __int16 *)(v6 + 1373) | (*(unsigned __int8 *)(v6 + 1375) << 16);
        if ((v14 & 0x200000) == 0 && *(void *)(v6 + 1240) && *(_DWORD *)(v6 + 1276) == 2)
        {
          os_log_type_t v15 = (void **)(v6 + 1240);
          if ((v14 & 0x400000) == 0)
          {
            char v16 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
            {
              __int16 v17 = *(_DWORD *)(v6 + 1280);
              *(_DWORD *)buf = 136446978;
              os_log_type_t v50 = "nw_protocol_http3_notify";
              uint64_t v51 = 2082;
              os_log_type_t v52 = (char *)(v6 + 1289);
              os_log_type_t v53 = 2080;
              BOOL v54 = " ";
              os_log_type_t v55 = 1024;
              v56 = v17;
              _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> disabling QUIC keepalives due to idleness",  buf,  0x26u);
            }
          }

          BOOL v18 = 0;
          *(_BYTE *)(v6 + 1375) |= 0x20u;
LABEL_49:
          nw_quic_connection_set_keepalive(*v15, v18);
          goto LABEL_50;
        }

        goto LABEL_50;
      }

      while ((*(_WORD *)(v13 + 736) & 0x2000) != 0)
      {
        uint64_t v13 = *(void *)(v13 + 544);
        if (!v13) {
          goto LABEL_24;
        }
      }

      return;
    case 18:
      char v19 = (_WORD *)(v6 + 1373);
      dispatch_data_t v20 = *(unsigned __int16 *)(v6 + 1373);
      uint64_t v21 = v20 | (*(unsigned __int8 *)(v6 + 1375) << 16);
      if ((v20 & 8) == 0 && a4 && a5 == 1)
      {
        if (*a4)
        {
          if ((v21 & 0x400000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v22 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              os_log_type_t v23 = *(_DWORD *)(v6 + 1280);
              *(_DWORD *)buf = 136446978;
              os_log_type_t v50 = "nw_protocol_http3_notify";
              uint64_t v51 = 2082;
              os_log_type_t v52 = (char *)(v6 + 1289);
              os_log_type_t v53 = 2080;
              BOOL v54 = " ";
              os_log_type_t v55 = 1024;
              v56 = v23;
              _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Path recovered from lower protocol, recommending that new flows join",  buf,  0x26u);
            }
          }

          unsigned int v24 = ((unsigned __int16)*v19 | (*(unsigned __int8 *)(v6 + 1375) << 16)) & 0xFFF7FFFF;
        }

        else
        {
          if ((v21 & 0x400000) == 0)
          {
            __int16 v35 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
            {
              __int16 v36 = *(_DWORD *)(v6 + 1280);
              *(_DWORD *)buf = 136446978;
              os_log_type_t v50 = "nw_protocol_http3_notify";
              uint64_t v51 = 2082;
              os_log_type_t v52 = (char *)(v6 + 1289);
              os_log_type_t v53 = 2080;
              BOOL v54 = " ";
              os_log_type_t v55 = 1024;
              v56 = v36;
              _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> Bad path from lower protocol, recommending that new flows not join",  buf,  0x26u);
            }
          }

          unsigned int v24 = (unsigned __int16)*v19 | (*(unsigned __int8 *)(v6 + 1375) << 16) | 0x80000;
        }

        const void *v19 = v24;
        *(_BYTE *)(v6 + 1375) = BYTE2(v24);
      }

      return;
    case 22:
      if (((*(unsigned __int16 *)(v6 + 1373) | (*(unsigned __int8 *)(v6 + 1375) << 16)) & 0x400000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v25 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          uint64_t v26 = *(_DWORD *)(v6 + 1280);
          *(_DWORD *)buf = 136446978;
          os_log_type_t v50 = "nw_protocol_http3_notify";
          uint64_t v51 = 2082;
          os_log_type_t v52 = (char *)(v6 + 1289);
          os_log_type_t v53 = 2080;
          BOOL v54 = " ";
          os_log_type_t v55 = 1024;
          v56 = v26;
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> restart received, assuming connection closed",  buf,  0x26u);
        }
      }

      *(_WORD *)(v6 + 1373) |= 8u;
      return;
    default:
      return;
  }

  if (v21) {
    free(v21);
  }
LABEL_21:
}

    free(v23);
    goto LABEL_51;
  }

        goto LABEL_51;
      }

      if (!v110)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v28 = (os_log_s *)(id)gLogObj;
        __int16 v39 = v111;
        if (os_log_type_enabled(v28, v111))
        {
          *(_DWORD *)buf = 136447490;
          v113 = "nw_necp_append_tlv";
          v114 = 2048;
          *(void *)v115 = v24;
          *(_WORD *)&v115[8] = 2048;
          *(void *)&v115[10] = (v19 + 18) + 5LL;
          v116 = 2048;
          *(void *)v117 = v90;
          *(_WORD *)&v117[8] = 1024;
          *(_DWORD *)v118 = a3;
          *(_WORD *)&v118[4] = 1024;
          *(_DWORD *)&v118[6] = v19 + 18;
          _os_log_impl( &dword_181A5C000,  v28,  v39,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  buf,  0x36u);
        }

        goto LABEL_50;
      }

      __int16 v36 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v28 = (os_log_s *)(id)gLogObj;
      __int16 v37 = v111;
      os_log_type_t v38 = os_log_type_enabled(v28, v111);
      if (!v36)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136447490;
          v113 = "nw_necp_append_tlv";
          v114 = 2048;
          *(void *)v115 = v24;
          *(_WORD *)&v115[8] = 2048;
          *(void *)&v115[10] = v20 + 5LL;
          v116 = 2048;
          *(void *)v117 = v90;
          *(_WORD *)&v117[8] = 1024;
          *(_DWORD *)v118 = a3;
          *(_WORD *)&v118[4] = 1024;
          *(_DWORD *)&v118[6] = v20;
          _os_log_impl( &dword_181A5C000,  v28,  v37,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  buf,  0x36u);
        }

        goto LABEL_50;
      }

      if (v38)
      {
        *(_DWORD *)buf = 136447746;
        v113 = "nw_necp_append_tlv";
        v114 = 2048;
        *(void *)v115 = v24;
        *(_WORD *)&v115[8] = 2048;
        *(void *)&v115[10] = v20 + 5LL;
        v116 = 2048;
        *(void *)v117 = v90;
        *(_WORD *)&v117[8] = 1024;
        *(_DWORD *)v118 = a3;
        *(_WORD *)&v118[4] = 1024;
        *(_DWORD *)&v118[6] = v20;
        v119 = 2082;
        v120 = v36;
        _os_log_impl( &dword_181A5C000,  v28,  v37,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  buf,  0x40u);
      }

      free(v36);
      if (v27)
      {
LABEL_52:
        os_log_type_t v40 = (char *)v27;
LABEL_53:
        free(v40);
      }
    }

                        uint64_t v29 = 1LL;
LABEL_51:
                        _Block_object_dispose(buf, 8);
                        goto LABEL_52;
                      }

                      v67[0] = MEMORY[0x1895F87A8];
                      v67[1] = 3221225472LL;
                      v67[2] = __nw_path_interface_prohibited_by_parameters_block_invoke_377;
                      v67[3] = &unk_189BC52A8;
                      os_log_type_t v68 = v5;
                      BOOL v69 = buf;
                      xpc_array_apply(v37, v67);
                      os_log_type_t v40 = v68;
                    }

                    else
                    {
                      __int16 v37 = 0LL;
                    }

                    goto LABEL_48;
                  }

                  uint64_t v30 = v20;
                  char v31 = *(void *)(v8[13] + 176LL);
                  if (v31)
                  {
                    __int16 v32 = *(id *)(v31 + 8);

                    if (!v32)
                    {
LABEL_38:

                      goto LABEL_39;
                    }

                    id v33 = v5;
                    uint32_t v34 = v33[25];

                    v70[0] = MEMORY[0x1895F87A8];
                    v70[1] = 3221225472LL;
                    v70[2] = __nw_path_interface_prohibited_by_parameters_block_invoke_376;
                    v70[3] = &unk_189BC5280;
                    v73 = v34;
                    os_log_type_t v71 = v33;
                    BOOL v72 = buf;
                    xpc_array_apply(v32, v70);
                    uint64_t v30 = v71;
                  }

                  else
                  {
                    __int16 v32 = 0LL;
                  }

                  goto LABEL_38;
                }

                uint64_t v26 = v5;
                int v27 = v26[24];

                applier[0] = MEMORY[0x1895F87A8];
                applier[1] = 3221225472LL;
                applier[2] = __nw_path_interface_prohibited_by_parameters_block_invoke;
                applier[3] = &unk_189BC5280;
                os_log_type_t v77 = v27;
                v75 = v26;
                os_log_type_t v76 = buf;
                xpc_array_apply(v22, applier);
                unsigned int v24 = v75;
              }

              else
              {
                uint64_t v22 = 0LL;
              }

              goto LABEL_30;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v28 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v18;
              _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEBUG,  "%{public}s Ultra constrained not allowed, cannot use interface option %@",  buf,  0x16u);
            }
          }
        }

        uint64_t v29 = 1LL;
LABEL_52:

        goto LABEL_53;
      }

      __nwlog_obj();
      os_log_type_t v52 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
      os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

      v79[0] = 16;
      os_log_type_t v78 = 0;
      if (__nwlog_fault(v53, v79, &v78))
      {
        if (v79[0] == 17)
        {
          __nwlog_obj();
          BOOL v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v55 = v79[0];
          if (os_log_type_enabled(v54, (os_log_type_t)v79[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl(&dword_181A5C000, v54, v55, "%{public}s called with null parameters", buf, 0xCu);
          }
        }

        else if (v78)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v62 = v79[0];
          char v63 = os_log_type_enabled(v54, (os_log_type_t)v79[0]);
          if (backtrace_string)
          {
            if (v63)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v54,  v62,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            goto LABEL_111;
          }

          if (v63)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl(&dword_181A5C000, v54, v62, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          BOOL v54 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v66 = v79[0];
          if (os_log_type_enabled(v54, (os_log_type_t)v79[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl( &dword_181A5C000,  v54,  v66,  "%{public}s called with null parameters, backtrace limit exceeded",  buf,  0xCu);
          }
        }
      }

    free(v27);
    if (!v15) {
      goto LABEL_10;
    }
    goto LABEL_77;
  }

  v38[0] = MEMORY[0x1895F87A8];
  v38[1] = 3221225472LL;
  v38[2] = __nw_http_connection_metadata_set_connection_closed_handler_block_invoke;
  v38[3] = &unk_189BC6710;
  unsigned int v11 = v6;
  v38[5] = v11;
  os_log_type_t v12 = v7;
  v38[4] = v12;
  uint64_t v13 = (os_unfair_lock_s *)*((void *)v8 + 4);
  if (v13) {
    __nw_http_connection_metadata_set_connection_closed_handler_block_invoke((uint64_t)v38, v13);
  }

LABEL_10:
}

        goto LABEL_51;
      }

      if (!v41)
      {
        __nwlog_obj();
        uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        __int16 v39 = type[0];
        if (os_log_type_enabled(v29, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl( &dword_181A5C000,  v29,  v39,  "%{public}s called with null statistics, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_50;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      __int16 v36 = type[0];
      __int16 v37 = os_log_type_enabled(v29, type[0]);
      if (!backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_181A5C000, v29, v36, "%{public}s called with null statistics, no backtrace", buf, 0xCu);
        }

        goto LABEL_50;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_statistics";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v29,  v36,  "%{public}s called with null statistics, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      goto LABEL_38;
    }
  }

  else
  {
    __nwlog_obj();
    int v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_statistics";
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    BOOL v41 = 0;
    if (__nwlog_fault(v28, type, &v41))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v30 = type[0];
        if (os_log_type_enabled(v29, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null connection", buf, 0xCu);
        }

        goto LABEL_50;
      }

      if (!v41)
      {
        __nwlog_obj();
        uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = type[0];
        if (os_log_type_enabled(v29, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl( &dword_181A5C000,  v29,  v38,  "%{public}s called with null connection, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_50;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint32_t v34 = type[0];
      __int16 v35 = os_log_type_enabled(v29, type[0]);
      if (!backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_statistics";
          _os_log_impl(&dword_181A5C000, v29, v34, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }

        goto LABEL_50;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_statistics";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null connection, dumping backtrace:%{public}s",  buf,  0x16u);
      }

    free(v26);
    goto LABEL_51;
  }

  qos_class_t v7 = v3[2];
  if (v7 && !nw_path_parameters_get_logging_disabled(v7[13]))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
    }
    nw_endpoint_t v6 = (os_log_s *)(id)gconnectionLogObj;
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_25;
    }
LABEL_15:
    os_log_type_t v8 = *((_DWORD *)v3 + 112);
    *(_DWORD *)buf = 136446466;
    os_log_type_t v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
    BOOL v72 = 1024;
    *(_DWORD *)v73 = v8;
    _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%u] Cancelled, cannot check for shares protocol stack",  buf,  0x12u);
LABEL_25:
    LODWORD(v13) = 0;
    goto LABEL_26;
  }

    free(v17);
    goto LABEL_51;
  }

  int v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v5->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v15 = (id)gLogObj;
    else {
      char v16 = off_189BBBBC0[mode];
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
    int v43 = 2082;
    id v44 = (void *)v16;
    __int16 v45 = 2082;
    id v46 = "flow";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    __int16 v39 = 0;
    if (__nwlog_fault(v17, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        char v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          else {
            dispatch_data_t v20 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          int v43 = 2082;
          id v44 = (void *)v20;
          __int16 v45 = 2082;
          id v46 = "flow";
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
        }
      }

      else if (v39)
      {
        uint64_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        uint64_t v22 = type;
        os_log_type_t v23 = os_log_type_enabled(v18, type);
        if (v21)
        {
          if (v23)
          {
            else {
              unsigned int v24 = off_189BBBBC0[mode];
            }
            *(_DWORD *)buf = 136446978;
            os_log_type_t v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
            int v43 = 2082;
            id v44 = (void *)v24;
            __int16 v45 = 2082;
            id v46 = "flow";
            __int16 v47 = 2082;
            char v48 = v21;
            _os_log_impl( &dword_181A5C000,  v18,  v22,  "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v21);
          if (!v17) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }

        if (v23)
        {
          else {
            char v31 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          int v43 = 2082;
          id v44 = (void *)v31;
          __int16 v45 = 2082;
          id v46 = "flow";
          _os_log_impl( &dword_181A5C000,  v18,  v22,  "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        uint64_t v29 = type;
        if (os_log_type_enabled(v18, type))
        {
          else {
            uint64_t v30 = off_189BBBBC0[mode];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          int v43 = 2082;
          id v44 = (void *)v30;
          __int16 v45 = 2082;
          id v46 = "flow";
          _os_log_impl( &dword_181A5C000,  v18,  v29,  "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded",  buf,  0x20u);
        }
      }

  if (v22 < 0x4000)
  {
    unsigned int v24 = 2;
    goto LABEL_58;
  }

  if (!(v22 >> 30))
  {
    unsigned int v24 = 4;
    goto LABEL_58;
  }

  if (!(v22 >> 62))
  {
    unsigned int v24 = 8;
    goto LABEL_58;
  }

  BOOL v67 = v23;
  os_log_type_t v68 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  BOOL v72 = "_http_vle_length";
  v73 = 2048;
  v74 = v22;
  uint32_t v34 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v34);
  if (!(_DWORD)result)
  {
    free(v34);
    unsigned int v24 = 0;
    os_log_type_t v23 = v67;
LABEL_58:
    if (capsule_type) {
      __int16 v35 = size;
    }
    else {
      __int16 v35 = size + 1;
    }
    int v14 = v35 + v23 + v24;
    if (v19) {
      dispatch_release(v19);
    }
LABEL_63:
    os_release(v16);
    goto LABEL_64;
  }

  if (v6)
  {
LABEL_51:
    os_log_type_t v23 = (char *)v6;
LABEL_52:
    free(v23);
  }

  return 0LL;
}

        id v33 = *(int *)(v18 + 184) - (unint64_t)v21;
        *(_DWORD *)(v18 + 184) = v33;
        if (v33 == (uint64_t)(v33 << 31) >> 31 && (v33 & 0x1FFFFFFFFLL) == ((int)v33 & 0x1FFFFFFFFLL))
        {
          if ((int)v33 > 1597151)
          {
LABEL_111:
            if (((*(unsigned __int16 *)(v18 + 188) | (*(unsigned __int8 *)(v18 + 190) << 16)) & 0x80000) != 0
              || !gLogDatapath)
            {
              goto LABEL_113;
            }

            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            id v84 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_113;
            }
            id v86 = *(_DWORD *)(v18 + 176);
            v85 = *(_DWORD *)(v18 + 180);
            *(_DWORD *)buf = 136447746;
            int v93 = "nw_protocol_http2_frame_input_finalizer";
            uint64_t v94 = 2082;
            v95 = (const char *)(v18 + 191);
            v96 = 2080;
            v97 = " ";
            v98 = 1024;
            *(_DWORD *)v99 = v85;
            *(_WORD *)&v99[4] = 1024;
            *(_DWORD *)&v99[6] = v86;
            *(_WORD *)&v99[10] = 1024;
            *(_DWORD *)&v99[12] = (_DWORD)v21;
            *(_WORD *)&v99[16] = 1024;
            *(_DWORD *)&v99[18] = v86;
            int v27 = "%{public}s %{public}s%s<i%u:s%d> consumed %u bytes on stream %d";
            uint64_t v28 = (os_log_s *)v84;
            uint64_t v29 = 56;
LABEL_176:
            _os_log_impl(&dword_181A5C000, v28, OS_LOG_TYPE_DEBUG, v27, buf, v29);
LABEL_113:
            if (a2)
            {
              http2_input_frame_metadata_reset((uint64_t)a1, 0LL, 0LL, 0);
              nw_frame_cache_return_frame(v12 + 200, (uint64_t)a1);
            }

            else
            {
              if (((*(unsigned __int16 *)(v18 + 188) | (*(unsigned __int8 *)(v18 + 190) << 16)) & 0x80000) == 0
                && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
                }
                BOOL v81 = (os_log_s *)gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  os_log_type_t v83 = *(_DWORD *)(v18 + 176);
                  os_log_type_t v82 = *(_DWORD *)(v18 + 180);
                  *(_DWORD *)buf = 136447234;
                  int v93 = "nw_protocol_http2_frame_input_finalizer";
                  uint64_t v94 = 2082;
                  v95 = (const char *)(v18 + 191);
                  v96 = 2080;
                  v97 = " ";
                  v98 = 1024;
                  *(_DWORD *)v99 = v82;
                  *(_WORD *)&v99[4] = 1024;
                  *(_DWORD *)&v99[6] = v83;
                  _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u:s%d> disposing of input frame, finalizer called with success == false",  buf,  0x2Cu);
                }
              }

              if ((*((_WORD *)a1 + 102) & 0x100) == 0
                || !g_channel_check_validity
                || g_channel_check_validity(a1, *((void *)a1 + 11)))
              {
                BOOL v72 = (void *)*((void *)a1 + 14);
                if (v72) {
                  free(v72);
                }
              }

              nw_frame_reset((uint64_t)a1, 0LL, 0, 0LL, 0LL);
              os_release(a1);
            }

            nw_http2_session_send(v12);
            return;
          }

          BOOL v41 = 0x200000 - v33;
LABEL_73:
          id v88 = (int)v21;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v47 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          int v93 = "nw_protocol_http2_frame_input_finalizer";
          uint64_t v94 = 2082;
          v95 = (const char *)v47;
          char v48 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v90 = 0;
          if (__nwlog_fault(v48, &type, &v90))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v49 = (os_log_s *)gLogObj;
              os_log_type_t v50 = type;
              if (os_log_type_enabled((os_log_t)gLogObj, type))
              {
                uint64_t v51 = nghttp2_strerror();
                *(_DWORD *)buf = 136446466;
                int v93 = "nw_protocol_http2_frame_input_finalizer";
                uint64_t v94 = 2082;
                v95 = (const char *)v51;
                os_log_type_t v52 = "%{public}s nghttp2_submit_window_update: %{public}s failed";
LABEL_85:
                BOOL v58 = v49;
LABEL_86:
                _os_log_impl(&dword_181A5C000, v58, v50, v52, buf, 0x16u);
              }
            }

            else if (v90)
            {
              os_log_type_t v53 = (char *)__nw_create_backtrace_string();
              BOOL v54 = (os_log_s *)__nwlog_obj();
              os_log_type_t v50 = type;
              log = v54;
              os_log_type_t v55 = os_log_type_enabled(v54, type);
              if (v53)
              {
                if (v55)
                {
                  v56 = nghttp2_strerror();
                  *(_DWORD *)buf = 136446722;
                  int v93 = "nw_protocol_http2_frame_input_finalizer";
                  uint64_t v94 = 2082;
                  v95 = (const char *)v56;
                  v96 = 2082;
                  v97 = v53;
                  _os_log_impl( &dword_181A5C000,  log,  v50,  "%{public}s nghttp2_submit_window_update: %{public}s failed, dumping backtrace:%{public}s",  buf,  0x20u);
                }

                free(v53);
                goto LABEL_87;
              }

              if (v55)
              {
                v70 = nghttp2_strerror();
                *(_DWORD *)buf = 136446466;
                int v93 = "nw_protocol_http2_frame_input_finalizer";
                uint64_t v94 = 2082;
                v95 = (const char *)v70;
                os_log_type_t v52 = "%{public}s nghttp2_submit_window_update: %{public}s failed, no backtrace";
                BOOL v58 = log;
                goto LABEL_86;
              }
            }

            else
            {
              uint64_t v49 = (os_log_s *)__nwlog_obj();
              os_log_type_t v50 = type;
              if (os_log_type_enabled(v49, type))
              {
                os_log_type_t v57 = nghttp2_strerror();
                *(_DWORD *)buf = 136446466;
                int v93 = "nw_protocol_http2_frame_input_finalizer";
                uint64_t v94 = 2082;
                v95 = (const char *)v57;
                os_log_type_t v52 = "%{public}s nghttp2_submit_window_update: %{public}s failed, backtrace limit exceeded";
                goto LABEL_85;
              }
            }
          }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_51;
  }

  handle = a1->handle;
  if (handle)
  {
    if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      uint64_t v9 = (os_log_s *)gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v10 = handle[92];
        *(_DWORD *)buf = 136446978;
        dispatch_data_t v20 = "nw_protocol_http2_output_available";
        uint64_t v21 = 2082;
        uint64_t v22 = (char *)handle + 390;
        os_log_type_t v23 = 2080;
        unsigned int v24 = " ";
        os_log_type_t v25 = 1024;
        uint64_t v26 = v10;
        _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }

    if (nghttp2_session_want_write())
    {
      if (((__int16)handle[97] & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        uint64_t v3 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          uint64_t v4 = handle[92];
          *(_DWORD *)buf = 136446978;
          dispatch_data_t v20 = "nw_protocol_http2_output_available";
          uint64_t v21 = 2082;
          uint64_t v22 = (char *)handle + 390;
          os_log_type_t v23 = 2080;
          unsigned int v24 = " ";
          os_log_type_t v25 = 1024;
          uint64_t v26 = v4;
          _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s<i%u> session send wanted by nghttp2 library",  buf,  0x26u);
        }
      }

      nw_http2_session_send((uint64_t)handle);
      if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        unsigned int v11 = (os_log_s *)gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v12 = handle[92];
          *(_DWORD *)buf = 136446978;
          dispatch_data_t v20 = "nw_protocol_http2_output_available";
          uint64_t v21 = 2082;
          uint64_t v22 = (char *)handle + 390;
          os_log_type_t v23 = 2080;
          unsigned int v24 = " ";
          os_log_type_t v25 = 1024;
          uint64_t v26 = v12;
          _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> called session send for nghttp2 session",  buf,  0x26u);
        }
      }
    }

    nw_http2_drain_output_frames((uint64_t)handle);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  dispatch_data_t v20 = "nw_protocol_http2_output_available";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  __int16 v17 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_51;
    }
    *(_DWORD *)buf = 136446210;
    dispatch_data_t v20 = "nw_protocol_http2_output_available";
    os_log_type_t v8 = "%{public}s called with null http2";
    goto LABEL_50;
  }

  if (!v17)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_51;
    }
    *(_DWORD *)buf = 136446210;
    dispatch_data_t v20 = "nw_protocol_http2_output_available";
    os_log_type_t v8 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_50;
  }

  os_log_type_t v15 = (char *)__nw_create_backtrace_string();
  nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
  qos_class_t v7 = type;
  char v16 = os_log_type_enabled(v6, type);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_51;
    }
    *(_DWORD *)buf = 136446210;
    dispatch_data_t v20 = "nw_protocol_http2_output_available";
    os_log_type_t v8 = "%{public}s called with null http2, no backtrace";
    goto LABEL_50;
  }

  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    dispatch_data_t v20 = "nw_protocol_http2_output_available";
    uint64_t v21 = 2082;
    uint64_t v22 = v15;
    _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null http2, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v15);
  if (v5) {
    goto LABEL_52;
  }
}

    if (v24) {
      free(v24);
    }
    goto LABEL_22;
  }

  __break(1u);
  return result;
}

    if (v19) {
      free(v19);
    }
    return 0LL;
  }

  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_browse_descriptor);
  int v5 = v4;
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    id v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          id v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s [nw_browse_descriptor init] failed", buf, 0xCu);
        }
      }

      else if (v30)
      {
        int v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v15 = type;
        char v16 = os_log_type_enabled(v11, type);
        if (v14)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            id v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
            uint32_t v34 = 2082;
            __int16 v35 = v14;
            _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s [nw_browse_descriptor init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v14);
          if (!v10) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }

        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          id v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s [nw_browse_descriptor init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v11 = (os_log_s *)(id)gLogObj;
        __int16 v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          id v33 = "nw_browse_descriptor_create_application_service_with_bundle_id";
          _os_log_impl( &dword_181A5C000,  v11,  v17,  "%{public}s [nw_browse_descriptor init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v10) {
      goto LABEL_15;
    }
LABEL_14:
    free(v10);
    goto LABEL_15;
  }

  *((_DWORD *)v4 + 2) = 2;
  nw_endpoint_t v6 = strdup(a1);
  if (v6)
  {
    *((void *)v5 + 9) = v6;
    if (!a2)
    {
LABEL_7:
      os_log_type_t v8 = v5;
LABEL_15:

      return (BOOL)v5;
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    id v33 = "strict_strdup";
    os_log_type_t v23 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v23);
    if (result) {
      goto LABEL_53;
    }
    free(v23);
    *((void *)v5 + 9) = 0LL;
    if (!a2) {
      goto LABEL_7;
    }
  }

  qos_class_t v7 = strdup(a2);
  if (v7)
  {
LABEL_6:
    *((void *)v5 + 10) = v7;
    goto LABEL_7;
  }

  __nwlog_obj();
  int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  id v33 = "strict_strdup";
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    goto LABEL_6;
  }

        free((void *)default_input_handler);
      }
    }
  }

    if (v39) {
      free(v39);
    }
    __int16 v17 = 0;
    os_log_type_t v15 = *v8;
    goto LABEL_17;
  }

  if (!v9 || (*(_BYTE *)(v9 + 158) & 1) == 0)
  {
    uint64_t v22 = (os_log_s *)__nwlog_obj();
    os_log_type_t v23 = os_log_type_enabled(v22, OS_LOG_TYPE_INFO);
    uint64_t v9 = *(void *)(a1 + 48);
    if (v23)
    {
      unsigned int v24 = (const char *)(v9 + 159);
      if (!v9) {
        unsigned int v24 = "";
      }
      *(_DWORD *)buf = 136446978;
      id v44 = "nw_protocol_ipv6_frame_output_finalizer_block_invoke";
      __int16 v45 = 2082;
      id v46 = (void *)v24;
      os_log_type_t v25 = " ";
      if (!v9) {
        os_log_type_t v25 = "";
      }
      __int16 v47 = 2080;
      char v48 = v25;
      uint64_t v49 = 2048;
      os_log_type_t v50 = v9;
      _os_log_impl( &dword_181A5C000,  v22,  OS_LOG_TYPE_INFO,  "%{public}s %{public}s%s%p Fragment frame is no longer valid",  buf,  0x2Au);
      uint64_t v9 = *(void *)(a1 + 48);
    }
  }

  *(void *)(v9 + 48) = 0LL;
  return 1LL;
}

        free((void *)default_input_handler);
      }
    }
  }

LABEL_33:
}

    if (v14) {
      free(v14);
    }
    goto LABEL_13;
  }

  uint64_t v3 = (NWConcrete_nw_endpoint_handler *)v1;
  uint64_t mode = v3->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v10 = off_189BBBBC0[mode];
      }
      *(_DWORD *)buf = 136446722;
      unsigned int v24 = "nw_flow_get_remote";
      os_log_type_t v25 = 2082;
      uint64_t v26 = (void *)v10;
      int v27 = 2082;
      uint64_t v28 = "flow";
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}s Handler is in mode %{public}s, expected %{public}s",  buf,  0x20u);
    }

LABEL_13:
    os_log_type_t v8 = 0LL;
    goto LABEL_16;
  }

  int v5 = nw_endpoint_handler_copy_flow(v3);
  nw_endpoint_t v6 = v5;
  qos_class_t v7 = (void *)*((void *)v5 + 121);
  if (v7)
  {
    os_log_type_t v8 = v7;
  }

  else
  {
    os_log_type_t v8 = (nw_endpoint_t)*((void *)v5 + 120);
    if (v8)
    {
      nw_flow_copy_flow_divert_endpoint(*((NWConcrete_nw_endpoint_flow **)v5 + 120));
    }

    else
    {
      unsigned int v11 = (nw_path *)nw_endpoint_flow_copy_path(v3);
      os_log_type_t v8 = nw_path_copy_effective_remote_endpoint(v11);
    }
  }

LABEL_16:
  return v8;
}

        nw_parameters_clear_protocol_stack(v6, 5);
        nw_parameters_clear_protocol_stack(v6, 4);
        os_log_type_t v12 = v3[8];
        if ((v12 & 2) == 0)
        {
LABEL_20:
          if ((v12 & 4) == 0)
          {
LABEL_22:
            uint64_t v13 = (void *)*((void *)v3 + 5);
            int v14 = MEMORY[0x1895F87A8];
            if (v13)
            {
              applier[0] = MEMORY[0x1895F87A8];
              applier[1] = 3221225472LL;
              applier[2] = __nw_protocol_transform_modify_parameters_block_invoke;
              applier[3] = &unk_189BC8CB8;
              BOOL v41 = v6;
              xpc_array_apply(v13, applier);
            }

            if (*((void *)v3 + 7))
            {
              os_log_type_t v15 = v6;
              char v16 = v15[19];

              __int16 v17 = (nw_protocol_stack *)*((void *)v3 + 7);
              iterate_block[0] = v14;
              iterate_block[1] = 3221225472LL;
              iterate_block[2] = __nw_protocol_transform_modify_parameters_block_invoke_2;
              iterate_block[3] = &unk_189BC5C80;
              BOOL v18 = v16;
              __int16 v39 = v18;
              nw_protocol_stack_iterate_application_protocols(v17, iterate_block);
              char v19 = nw_protocol_stack_copy_transport_protocol(*((nw_protocol_stack_t *)v3 + 7));
              if (v19) {
                nw_protocol_stack_set_transport_protocol((nw_protocol_stack_t)v18, v19);
              }
              dispatch_data_t v20 = nw_protocol_stack_copy_internet_protocol(*((nw_protocol_stack_t *)v3 + 7));
              if (v20) {
                nw_protocol_stack_set_internet_protocol(v18, v20);
              }
            }

            goto LABEL_30;
          }

    if (v3) {
      free(v3);
    }
    os_release(v1);
    return 0LL;
  }

  return v1;
}

  if (v13) {
    free(v13);
  }
}

    os_log_type_t v55 = v6;
    goto LABEL_34;
  }

  dispatch_data_t v20 = 24 * v19;
  uint64_t v21 = (necp_client_interface_option *)malloc(24 * v19);
  if (v21)
  {
LABEL_15:
    v6->policy_result.interface_options = v21;
    memcpy(v21, *((const void **)v3 + 38), v20);
    goto LABEL_16;
  }

  __nwlog_obj();
  os_log_type_t v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v80 = "strict_malloc";
  BOOL v81 = 2048;
  os_log_type_t v82 = v20;
  v73 = buf;
  BOOL v72 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v72);
  if (!result)
  {
    free(v72);
    dispatch_data_t v20 = 24LL * *((unsigned int *)v3 + 86);
    uint64_t v21 = 0LL;
    goto LABEL_15;
  }

              goto LABEL_34;
            }

            goto LABEL_34;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v28 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          char v63 = "nw_protocol_utilities_add_input_handler";
          os_log_type_t v64 = 2048;
          v65 = a7;
          uint64_t v29 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          os_log_type_t v60 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v30 = (os_log_s *)(id)gLogObj;
            char v31 = type;
            if (os_log_type_enabled(v30, type))
            {
              *(_DWORD *)buf = 136446466;
              char v63 = "nw_protocol_utilities_add_input_handler";
              os_log_type_t v64 = 2048;
              v65 = a7;
              _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
            }
          }

          else
          {
            if (v60)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v42 = (os_log_s *)(id)gLogObj;
              int v43 = type;
              id v44 = os_log_type_enabled(v42, type);
              if (backtrace_string)
              {
                if (v44)
                {
                  *(_DWORD *)buf = 136446722;
                  char v63 = "nw_protocol_utilities_add_input_handler";
                  os_log_type_t v64 = 2048;
                  v65 = a7;
                  os_log_type_t v66 = 2082;
                  BOOL v67 = backtrace_string;
                  _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
                }

                free(backtrace_string);
                if (!v29) {
                  goto LABEL_28;
                }
LABEL_24:
                free(v29);
                goto LABEL_28;
              }

              if (v44)
              {
                *(_DWORD *)buf = 136446466;
                char v63 = "nw_protocol_utilities_add_input_handler";
                os_log_type_t v64 = 2048;
                v65 = a7;
                _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s Cannot add input handler %p to itself, no backtrace",  buf,  0x16u);
              }

LABEL_23:
              if (!v29) {
                goto LABEL_28;
              }
              goto LABEL_24;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v30 = (os_log_s *)(id)gLogObj;
            __int16 v45 = type;
            if (os_log_type_enabled(v30, type))
            {
              *(_DWORD *)buf = 136446466;
              char v63 = "nw_protocol_utilities_add_input_handler";
              os_log_type_t v64 = 2048;
              v65 = a7;
              _os_log_impl( &dword_181A5C000,  v30,  v45,  "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded",  buf,  0x16u);
            }
          }

          goto LABEL_23;
        }

        __nwlog_obj();
        id v46 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        char v63 = "nw_protocol_utilities_add_input_handler";
        __int16 v47 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v60 = 0;
        if (__nwlog_fault(v47, &type, &v60))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            char v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint64_t v49 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              char v63 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_181A5C000, v48, v49, "%{public}s called with null input_protocol", buf, 0xCu);
            }
          }

          else
          {
            if (v60)
            {
              os_log_type_t v50 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              uint64_t v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v52 = type;
              os_log_type_t v53 = os_log_type_enabled(v51, type);
              if (v50)
              {
                if (v53)
                {
                  *(_DWORD *)buf = 136446466;
                  char v63 = "nw_protocol_utilities_add_input_handler";
                  os_log_type_t v64 = 2082;
                  v65 = (uint64_t)v50;
                  _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v50);
              }

              else
              {
                if (v53)
                {
                  *(_DWORD *)buf = 136446210;
                  char v63 = "nw_protocol_utilities_add_input_handler";
                  _os_log_impl( &dword_181A5C000,  v51,  v52,  "%{public}s called with null input_protocol, no backtrace",  buf,  0xCu);
                }
              }

              goto LABEL_64;
            }

            __nwlog_obj();
            char v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            BOOL v54 = type;
            if (os_log_type_enabled(v48, type))
            {
              *(_DWORD *)buf = 136446210;
              char v63 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl( &dword_181A5C000,  v48,  v54,  "%{public}s called with null input_protocol, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

    goto LABEL_34;
  }

  if (!a2)
  {
    __nwlog_obj();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_metadata_access_handle";
    int v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      qos_class_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_metadata_access_handle";
        os_log_type_t v8 = "%{public}s called with null access_block";
        goto LABEL_32;
      }
    }

    else
    {
      if (v14)
      {
        os_log_type_t v12 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_endpoint_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        qos_class_t v7 = type;
        uint64_t v13 = os_log_type_enabled(v6, type);
        if (v12)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_protocol_metadata_access_handle";
            BOOL v18 = 2082;
            char v19 = v12;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null access_block, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v12);
          if (!v5) {
            return 0LL;
          }
          goto LABEL_35;
        }

        if (!v13) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_metadata_access_handle";
        os_log_type_t v8 = "%{public}s called with null access_block, no backtrace";
        goto LABEL_32;
      }

      __nwlog_obj();
      nw_endpoint_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      qos_class_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_metadata_access_handle";
        os_log_type_t v8 = "%{public}s called with null access_block, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

    goto LABEL_33;
  }

  id v2 = *(void *)(a1 + 32);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  }
  return 0LL;
}

  if (v4) {
LABEL_34:
  }
    free(v4);
  return 0LL;
}

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_34;
  }

  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      input_available = (void (*)(void))callbacks->input_available;
      if (input_available) {
        input_available();
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_protocol_default_input_available";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_input_available";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_33;
  }

  if (!v13)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_input_available";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
    goto LABEL_33;
  }

  unsigned int v11 = (char *)__nw_create_backtrace_string();
  nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
  qos_class_t v7 = type;
  os_log_type_t v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_input_available";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler, no backtrace";
    goto LABEL_33;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    char v16 = "nw_protocol_default_input_available";
    __int16 v17 = 2082;
    BOOL v18 = v11;
    _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v5) {
LABEL_35:
  }
    free(v5);
}

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_34;
  }

  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      output_available = (void (*)(void))callbacks->output_available;
      if (output_available) {
        output_available();
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_protocol_default_output_available";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_output_available";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_33;
  }

  if (!v13)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_output_available";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
    goto LABEL_33;
  }

  unsigned int v11 = (char *)__nw_create_backtrace_string();
  nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
  qos_class_t v7 = type;
  os_log_type_t v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_output_available";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler, no backtrace";
    goto LABEL_33;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    char v16 = "nw_protocol_default_output_available";
    __int16 v17 = 2082;
    BOOL v18 = v11;
    _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v5) {
LABEL_35:
  }
    free(v5);
}

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_34;
  }

  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      input_finished = (void (*)(void))callbacks->input_finished;
      if (input_finished) {
        input_finished();
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_protocol_default_input_finished";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v13 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_input_finished";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_33;
  }

  if (!v13)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_input_finished";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
    goto LABEL_33;
  }

  unsigned int v11 = (char *)__nw_create_backtrace_string();
  nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
  qos_class_t v7 = type;
  os_log_type_t v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_protocol_default_input_finished";
    os_log_type_t v8 = "%{public}s called with null protocol->default_input_handler, no backtrace";
    goto LABEL_33;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    char v16 = "nw_protocol_default_input_finished";
    __int16 v17 = 2082;
    BOOL v18 = v11;
    _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v5) {
LABEL_35:
  }
    free(v5);
}

            LOBYTE(v5) = 0;
            goto LABEL_34;
          }
        }

        goto LABEL_31;
      }

      BOOL result = 0LL;
LABEL_34:
      LOBYTE(v5) = 1;
      goto LABEL_37;
    }

    if (v5)
    {
      if (v5 != 1)
      {
        uint64_t v10 = BYTE1(result) - 48;
        if ((BYTE1(result) - 48) <= 9u)
        {
          BOOL result = 0LL;
          unsigned int v11 = v10 == 0;
          os_log_type_t v12 = -v10;
          if (!v11) {
            goto LABEL_34;
          }
          if (v5 == 2)
          {
            LOBYTE(v5) = 0;
            BOOL result = v12;
LABEL_37:
            LODWORD(v5) = v5 & 1;
            goto LABEL_38;
          }

          uint64_t v21 = BYTE2(v8) - 48;
          if ((BYTE2(v8) - 48) <= 9u)
          {
            uint64_t v22 = 10LL * v12;
            if ((v22 & 0xFFFFFFFF00000000LL) == 0)
            {
              BOOL result = v22 - v21;
              if (v22 >= v21)
              {
                os_log_type_t v23 = v5 - 3;
                if (v5 != 3)
                {
                  unsigned int v24 = (unsigned __int8 *)v28 + 3;
                  while (1)
                  {
                    os_log_type_t v25 = *v24 - 48;
                    if (v25 > 9) {
                      goto LABEL_33;
                    }
                    uint64_t v26 = 10LL * result;
                    if ((v26 & 0xFFFFFFFF00000000LL) != 0) {
                      goto LABEL_33;
                    }
                    BOOL result = v26 - v25;
                    LOBYTE(v5) = 0;
                    ++v24;
                    if (!--v23) {
                      goto LABEL_37;
                    }
                  }
                }

    os_log_type_t v12 = 0LL;
LABEL_34:
    int v14 = 1;
    goto LABEL_37;
  }

  __break(1u);
LABEL_64:
  __break(1u);
  return result;
}

  swift_release();
  __int16 v39 = v49;
  os_unfair_lock_lock(v49);
  os_log_type_t v40 = (uint64_t)v50;
  sub_181BF787C(v41, (uint64_t (*)(void))sub_181C4F1C0);
  os_unfair_lock_unlock(v39);
  os_log_type_t v42 = v51;
  sub_181BE48BC(v40, v51, (uint64_t *)&unk_18C58D5A0);
  int v43 = __swift_instantiateConcreteTypeFromMangledName(&qword_18C58A1E0);
  id v44 = *(void *)(v43 - 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v44 + 48))(v42, 1LL, v43) == 1)
  {
    sub_181BDA0F0(v40, (uint64_t *)&unk_18C58D5A0);
    sub_181BDA0F0(v42, (uint64_t *)&unk_18C58D5A0);
  }

  else
  {
    sub_181BF7EF8();
    __int16 v45 = swift_allocError();
    *(_OWORD *)id v46 = v53;
    *(void *)(v46 + 16) = 0xB000000000000000LL;
    os_log_type_t v55 = v45;
    sub_18264ED78();
    sub_181BDA0F0(v40, (uint64_t *)&unk_18C58D5A0);
    (*(void (**)(uint64_t, uint64_t))(v44 + 8))(v42, v43);
  }

    goto LABEL_34;
  }

  if (v9)
  {
    p_kvo_lock = &self->_kvo_lock;
    v24[0] = MEMORY[0x1895F87A8];
    v24[1] = 3221225472LL;
    v24[2] = __71__NWAccumulator_registerObserverForKeyPath_ofObject_alreadyRegistered___block_invoke;
    v24[3] = &unk_189BBB680;
    os_log_type_t v25 = a5;
    os_log_type_t v12 = v9;
    v24[4] = v12;
    v24[5] = self;
    uint64_t v13 = v8;
    v24[6] = v13;
    os_unfair_lock_lock(p_kvo_lock);
    __71__NWAccumulator_registerObserverForKeyPath_ofObject_alreadyRegistered___block_invoke((uint64_t)v24);
    os_unfair_lock_unlock(p_kvo_lock);

    goto LABEL_4;
  }

  __nwlog_obj();
  char v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v29 = "-[NWAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  int v27 = OS_LOG_TYPE_ERROR;
  uint64_t v26 = 0;
  if (v27 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = v27;
    if (os_log_type_enabled(v16, v27))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "-[NWAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
      BOOL v18 = "%{public}s called with null object";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (!v26)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = v27;
    if (os_log_type_enabled(v16, v27))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "-[NWAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
      BOOL v18 = "%{public}s called with null object, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  uint64_t v22 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = v27;
  os_log_type_t v23 = os_log_type_enabled(v16, v27);
  if (!v22)
  {
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "-[NWAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
      BOOL v18 = "%{public}s called with null object, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v23)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v29 = "-[NWAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
    uint64_t v30 = 2082;
    char v31 = v22;
    _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null object, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v22);
  if (v15) {
    goto LABEL_35;
  }
LABEL_4:
}

    goto LABEL_34;
  }

  if (v7)
  {
    -[NWNumericAccumulator aggregatedStates](self, "aggregatedStates");
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    p_lock = &self->_lock;
    v24[0] = MEMORY[0x1895F87A8];
    v24[1] = 3221225472LL;
    v24[2] = __48__NWNumericAccumulator_addCount_toAccumulation___block_invoke;
    v24[3] = &unk_189BC7848;
    v24[4] = self;
    v24[5] = v9;
    unsigned int v11 = v8;
    v24[6] = v11;
    os_log_type_t v12 = v6;
    v24[7] = v12;
    uint64_t v13 = v9;
    os_unfair_lock_lock(p_lock);
    __48__NWNumericAccumulator_addCount_toAccumulation___block_invoke((uint64_t)v24);
    os_unfair_lock_unlock(p_lock);

    goto LABEL_4;
  }

  __nwlog_obj();
  char v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v28 = "-[NWNumericAccumulator addCount:toAccumulation:]";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  uint64_t v26 = OS_LOG_TYPE_ERROR;
  os_log_type_t v25 = 0;
  if (v26 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = v26;
    if (os_log_type_enabled(v16, v26))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "-[NWNumericAccumulator addCount:toAccumulation:]";
      BOOL v18 = "%{public}s called with null name";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (!v25)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = v26;
    if (os_log_type_enabled(v16, v26))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "-[NWNumericAccumulator addCount:toAccumulation:]";
      BOOL v18 = "%{public}s called with null name, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  uint64_t v22 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = v26;
  os_log_type_t v23 = os_log_type_enabled(v16, v26);
  if (!v22)
  {
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "-[NWNumericAccumulator addCount:toAccumulation:]";
      BOOL v18 = "%{public}s called with null name, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v23)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v28 = "-[NWNumericAccumulator addCount:toAccumulation:]";
    uint64_t v29 = 2082;
    uint64_t v30 = v22;
    _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null name, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v22);
  if (v15) {
    goto LABEL_35;
  }
LABEL_4:
}

    goto LABEL_34;
  }

  if (v9)
  {
    p_kvo_lock = &self->_kvo_lock;
    v24[0] = MEMORY[0x1895F87A8];
    v24[1] = 3221225472LL;
    v24[2] = __78__NWNumericAccumulator_registerObserverForKeyPath_ofObject_alreadyRegistered___block_invoke;
    v24[3] = &unk_189BBB680;
    os_log_type_t v25 = a5;
    os_log_type_t v12 = v9;
    v24[4] = v12;
    v24[5] = self;
    uint64_t v13 = v8;
    v24[6] = v13;
    os_unfair_lock_lock(p_kvo_lock);
    __78__NWNumericAccumulator_registerObserverForKeyPath_ofObject_alreadyRegistered___block_invoke((uint64_t)v24);
    os_unfair_lock_unlock(p_kvo_lock);

    goto LABEL_4;
  }

  __nwlog_obj();
  char v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v29 = "-[NWNumericAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  int v27 = OS_LOG_TYPE_ERROR;
  uint64_t v26 = 0;
  if (v27 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = v27;
    if (os_log_type_enabled(v16, v27))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "-[NWNumericAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
      BOOL v18 = "%{public}s called with null object";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (!v26)
  {
    __nwlog_obj();
    char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v17 = v27;
    if (os_log_type_enabled(v16, v27))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "-[NWNumericAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
      BOOL v18 = "%{public}s called with null object, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  uint64_t v22 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  char v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v17 = v27;
  os_log_type_t v23 = os_log_type_enabled(v16, v27);
  if (!v22)
  {
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v29 = "-[NWNumericAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
      BOOL v18 = "%{public}s called with null object, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v23)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v29 = "-[NWNumericAccumulator registerObserverForKeyPath:ofObject:alreadyRegistered:]";
    uint64_t v30 = 2082;
    char v31 = v22;
    _os_log_impl( &dword_181A5C000,  v16,  v17,  "%{public}s called with null object, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v22);
  if (v15) {
    goto LABEL_35;
  }
LABEL_4:
}

      return 0LL;
    }

    *(_OWORD *)(a1 + 115) = *((_OWORD *)v7 + 8);

    if ((nw_path_flow_get_id(*(void **)(a1 + 88), (_OWORD *)(a1 + 136)) & 1) == 0)
    {
      uint64_t v26 = *(void *)(a1 + 152);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)(id)gLogObj;
      int v27 = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
      if (v26)
      {
        if (v27)
        {
          uint64_t v28 = *(void *)(a1 + 24);
          uint64_t v29 = *(_DWORD *)(a1 + 168);
          *(_DWORD *)buf = 136447234;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 2080;
          *(void *)v132 = v28;
          *(_WORD *)&v132[8] = 1042;
          *(_DWORD *)&v132[10] = 16;
          *(_WORD *)&v132[14] = 2098;
          *(void *)&v132[16] = a1 + 115;
          *(_WORD *)&v132[24] = 1024;
          *(_DWORD *)&v132[26] = v29;
          _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] createChannel: no flow id",  buf,  0x2Cu);
        }
      }

      else if (v27)
      {
        *(_DWORD *)buf = 136446466;
        v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
        v131 = 2114;
        *(void *)v132 = a1;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}@] createChannel: no flow id",  buf,  0x16u);
      }

      goto LABEL_33;
    }

    nexus_key = nw_path_flow_get_nexus_key(*(void **)(a1 + 88), &v128);
    os_log_type_t v15 = v128;
    char v16 = *(void *)(a1 + 152);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v17 = (os_log_s *)(id)gLogObj;
    BOOL v18 = v17;
    if (!nexus_key || !v15)
    {
      uint64_t v30 = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
      if (v16)
      {
        if (v30)
        {
          char v31 = *(void *)(a1 + 24);
          __int16 v32 = *(_DWORD *)(a1 + 168);
          *(_DWORD *)buf = 136447234;
          v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
          v131 = 2080;
          *(void *)v132 = v31;
          *(_WORD *)&v132[8] = 1042;
          *(_DWORD *)&v132[10] = 16;
          *(_WORD *)&v132[14] = 2098;
          *(void *)&v132[16] = a1 + 115;
          *(_WORD *)&v132[24] = 1024;
          *(_DWORD *)&v132[26] = v32;
          _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] createChannel: no flow key or key length",  buf,  0x2Cu);
        }
      }

      else if (v30)
      {
        *(_DWORD *)buf = 136446466;
        v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
        v131 = 2114;
        *(void *)v132 = a1;
        _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_ERROR,  "%{public}s [%{public}@] createChannel: no flow key or key length",  buf,  0x16u);
      }

      return 0LL;
    }

    char v19 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
    if (v16)
    {
      if (!v19) {
        goto LABEL_37;
      }
      dispatch_data_t v20 = *(void *)(a1 + 24);
      uint64_t v21 = *(_DWORD *)(a1 + 168);
      uint64_t v22 = *(_DWORD *)(a1 + 132);
      *(_DWORD *)buf = 136448514;
      v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
      v131 = 2080;
      *(void *)v132 = v20;
      *(_WORD *)&v132[8] = 1042;
      *(_DWORD *)&v132[10] = 16;
      *(_WORD *)&v132[14] = 2098;
      *(void *)&v132[16] = a1 + 115;
      *(_WORD *)&v132[24] = 1024;
      *(_DWORD *)&v132[26] = v21;
      LOWORD(v133) = 1042;
      *(_DWORD *)((char *)&v133 + 2) = 16;
      WORD3(v133) = 2098;
      *((void *)&v133 + 1) = a1 + 136;
      v134 = 1042;
      *(_DWORD *)v135 = 16;
      *(_WORD *)&v135[4] = 2098;
      *(void *)&v135[6] = a1 + 115;
      v136 = 1024;
      v137 = v22;
      os_log_type_t v23 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Establishing channel for flow id %{public, uuid"
            "_t}.16P nexus instance %{public, uuid_t}.16P port %d";
      unsigned int v24 = v18;
      os_log_type_t v25 = 82;
    }

    else
    {
      if (!v19) {
        goto LABEL_37;
      }
      id v33 = *(_DWORD *)(a1 + 132);
      *(_DWORD *)buf = 136447746;
      v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
      v131 = 2114;
      *(void *)v132 = a1;
      *(_WORD *)&v132[8] = 1042;
      *(_DWORD *)&v132[10] = 16;
      *(_WORD *)&v132[14] = 2098;
      *(void *)&v132[16] = a1 + 136;
      *(_WORD *)&v132[24] = 1042;
      *(_DWORD *)&v132[26] = 16;
      LOWORD(v133) = 2098;
      *(void *)((char *)&v133 + 2) = a1 + 115;
      WORD5(v133) = 1024;
      HIDWORD(v133) = v33;
      os_log_type_t v23 = "%{public}s [%{public}@] Establishing channel for flow id %{public, uuid_t}.16P nexus instance %{public, uuid_t}.16P port %d";
      unsigned int v24 = v18;
      os_log_type_t v25 = 60;
    }

    _os_log_impl(&dword_181A5C000, v24, OS_LOG_TYPE_DEBUG, v23, buf, v25);
LABEL_37:

    uint32_t v34 = os_channel_attr_create();
    *(void *)(a1 + 160) = v34;
    if (v34)
    {
      __int16 v35 = os_channel_attr_set_key();
      if (v35)
      {
        __nwlog_obj();
        __int16 v36 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446722;
        v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
        v131 = 2112;
        *(void *)v132 = a1;
        *(_WORD *)&v132[8] = 1024;
        *(_DWORD *)&v132[10] = v35;
        __int16 v37 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v127 = OS_LOG_TYPE_DEFAULT;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          os_log_type_t v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v39 = type[0];
          if (os_log_type_enabled(v38, type[0]))
          {
            *(_DWORD *)buf = 136446722;
            v130 = "-[NWConcrete_nw_ethernet_channel createChannel]";
            v131 = 2112;
            *(void *)v132 = a1;
            *(_WORD *)&v132[8] = 1024;
            *(_DWORD *)&v132[10] = v35;
            _os_log_impl( &dword_181A5C000,  v38,  v39,  "%{public}s %@: createChannel failed to set key <err %d> ",  buf,  0x1Cu);
          }

  if (v12) {
    free(v12);
  }
LABEL_16:
}

    _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
    goto LABEL_34;
  }

  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    int v5 = a2;
    if (a3 == 15)
    {
      nw_protocol_plugins_handle_reset(v4 + 64, a1, a2);
      a1 = v3;
      a2 = v5;
      a3 = 15;
    }

    nw_protocol_common_notify(a1, a2, a3);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_plugins_notify";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  int v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    qos_class_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_plugins_notify";
    uint64_t v9 = "%{public}s called with null protocol->handle";
    goto LABEL_33;
  }

  if (!v14)
  {
    qos_class_t v7 = (os_log_s *)__nwlog_obj();
    os_log_type_t v8 = type;
    if (!os_log_type_enabled(v7, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_plugins_notify";
    uint64_t v9 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
    goto LABEL_33;
  }

  os_log_type_t v12 = (char *)__nw_create_backtrace_string();
  qos_class_t v7 = (os_log_s *)__nwlog_obj();
  os_log_type_t v8 = type;
  uint64_t v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_plugins_notify";
    uint64_t v9 = "%{public}s called with null protocol->handle, no backtrace";
    goto LABEL_33;
  }

  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v17 = "nw_protocol_plugins_notify";
    BOOL v18 = 2082;
    char v19 = v12;
    _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null protocol->handle, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v12);
  if (v6) {
LABEL_35:
  }
    free(v6);
}

            if (a1->handle == &nw_protocol_ref_counted_handle)
            {
              os_log_type_t v42 = a1[1].callbacks;
              if (v42)
              {
                int v43 = (nw_protocol_callbacks *)((char *)v42 - 1);
                a1[1].callbacks = v43;
                if (!v43)
                {
                  id v44 = *(void (***)(void))a1[1].flow_id;
                  if (v44)
                  {
                    *(void *)a1[1].flow_id = 0LL;
                    v44[2](v44);
                    _Block_release(v44);
                  }

                  if ((a1[1].flow_id[8] & 1) != 0)
                  {
                    __int16 v45 = *(const void **)a1[1].flow_id;
                    if (v45) {
                      _Block_release(v45);
                    }
                  }

                  free(a1);
                }
              }
            }

            goto LABEL_34;
          }
        }

        __nwlog_obj();
        name = output_handler->identifier->name;
        *(_DWORD *)buf = 136446722;
        v102 = "__nw_protocol_connect";
        if (!name) {
          name = "invalid";
        }
        v103 = 2082;
        v104 = (nw_protocol *)name;
        v105 = 2048;
        v106 = output_handler;
        os_log_type_t v66 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        v99 = 0;
        if (__nwlog_fault(v66, &type, &v99))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            BOOL v67 = (os_log_s *)__nwlog_obj();
            os_log_type_t v68 = type;
            if (!os_log_type_enabled(v67, type)) {
              goto LABEL_220;
            }
            BOOL v69 = output_handler->identifier->name;
            if (!v69) {
              BOOL v69 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v102 = "__nw_protocol_connect";
            v103 = 2082;
            v104 = (nw_protocol *)v69;
            v105 = 2048;
            v106 = output_handler;
            v70 = "%{public}s protocol %{public}s (%p) has invalid connect callback";
LABEL_219:
            _os_log_impl(&dword_181A5C000, v67, v68, v70, buf, 0x20u);
            goto LABEL_220;
          }

          if (!v99)
          {
            BOOL v67 = (os_log_s *)__nwlog_obj();
            os_log_type_t v68 = type;
            if (!os_log_type_enabled(v67, type)) {
              goto LABEL_220;
            }
            uint64_t v94 = output_handler->identifier->name;
            if (!v94) {
              uint64_t v94 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v102 = "__nw_protocol_connect";
            v103 = 2082;
            v104 = (nw_protocol *)v94;
            v105 = 2048;
            v106 = output_handler;
            v70 = "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded";
            goto LABEL_219;
          }

          id v86 = (char *)__nw_create_backtrace_string();
          BOOL v67 = (os_log_s *)__nwlog_obj();
          os_log_type_t v68 = type;
          v87 = os_log_type_enabled(v67, type);
          if (!v86)
          {
            if (!v87) {
              goto LABEL_220;
            }
            v95 = output_handler->identifier->name;
            if (!v95) {
              v95 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v102 = "__nw_protocol_connect";
            v103 = 2082;
            v104 = (nw_protocol *)v95;
            v105 = 2048;
            v106 = output_handler;
            v70 = "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace";
            goto LABEL_219;
          }

          if (v87)
          {
            id v88 = output_handler->identifier->name;
            if (!v88) {
              id v88 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            v102 = "__nw_protocol_connect";
            v103 = 2082;
            v104 = (nw_protocol *)v88;
            v105 = 2048;
            v106 = output_handler;
            v107 = 2082;
            v108 = v86;
            _os_log_impl( &dword_181A5C000,  v67,  v68,  "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v86);
        }

  if (v14) {
    free(v14);
  }
  nw_endpoint_t v6 = 0;
LABEL_3:

  if (*(unsigned __int8 *)(a1 + 80) != v6)
  {
LABEL_12:
    unsigned int v11 = 1LL;
    goto LABEL_13;
  }

  nw_endpoint_edge_get_endpoint(v5);
  qos_class_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  os_log_type_t v8 = v7;
  if (!v7)
  {
LABEL_11:

    goto LABEL_12;
  }

  uint64_t v9 = nw_endpoint_copy_registrar_for_identifier(v7, *(__int128 **)(a1 + 64), 0);
  if (v9)
  {
    accept_function_for_identifier = nw_protocol_registrar_get_accept_function_for_identifier(*(void **)(a1 + 64));
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = nw_protocol_instance_registrar_find_instance_to_join( v9,  *(void **)(a1 + 64),  *(void *)(a1 + 72),  *(unsigned __int8 *)(a1 + 81),  1,  *(_BYTE *)(a1 + 80),  *(void **)(a1 + 32),  *(void **)(a1 + 40),  *(void **)(a1 + 48),  accept_function_for_identifier);
  }

  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL))
  {

    goto LABEL_11;
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    dispatch_data_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = *(char **)(a1 + 40);
      uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
      os_log_type_t v23 = *(void *)(v22 + 16);
      *(_DWORD *)buf = 136447234;
      uint64_t v28 = "nw_protocol_instance_registrar_search_edges_for_instance_to_join_inner_block_invoke";
      uint64_t v29 = 2112;
      uint64_t v30 = v21;
      char v31 = 2080;
      __int16 v32 = v23;
      id v33 = 2048;
      uint32_t v34 = v22;
      __int16 v35 = 2112;
      __int16 v36 = v8;
      _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s destination %@ found protocol to join %s (%p) in endpoint %@",  buf,  0x34u);
    }
  }

  unsigned int v11 = 0LL;
LABEL_13:

  return v11;
}

    free(backtrace_string);
    if (!v12) {
      goto LABEL_63;
    }
    goto LABEL_62;
  }

  if (!v6)
  {
    __nwlog_obj();
    __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v37 = "nw_endpoint_access_custom_metadata_for_key";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    __int16 v35 = OS_LOG_TYPE_ERROR;
    uint32_t v34 = 0;
    if (v35 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v18 = v35;
      if (os_log_type_enabled(v13, v35))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v37 = "nw_endpoint_access_custom_metadata_for_key";
        _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null access_block", buf, 0xCu);
      }
    }

    else if (v34)
    {
      unsigned int v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = v35;
      uint64_t v26 = os_log_type_enabled(v13, v35);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v37 = "nw_endpoint_access_custom_metadata_for_key";
          os_log_type_t v38 = 2082;
          __int16 v39 = v24;
          _os_log_impl( &dword_181A5C000,  v13,  v25,  "%{public}s called with null access_block, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v24);
LABEL_61:
        if (!v12)
        {
LABEL_63:
          uint64_t v9 = 0LL;
          goto LABEL_8;
        }

              goto LABEL_34;
            }

            if (!v53)
            {
              __nwlog_obj();
              os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v38 = type;
              if (os_log_type_enabled(v23, type))
              {
                __int16 v39 = nw_group_descriptor_get_type(v3[8]);
                if (v39 > 4) {
                  os_log_type_t v40 = "unknown";
                }
                else {
                  os_log_type_t v40 = off_189BB74C8[v39];
                }
                *(_DWORD *)buf = 136446466;
                v56 = "nw_connection_group_copy_remote_endpoint_for_message";
                os_log_type_t v57 = 2080;
                BOOL v58 = (void *)v40;
                _os_log_impl( &dword_181A5C000,  v23,  v38,  "%{public}s Unsupported group descriptor type: %s, backtrace limit exceeded",  buf,  0x16u);
              }

              goto LABEL_33;
            }

            id v33 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            uint32_t v34 = type;
            __int16 v35 = os_log_type_enabled(v23, type);
            if (!v33)
            {
              if (v35)
              {
                BOOL v41 = nw_group_descriptor_get_type(v3[8]);
                if (v41 > 4) {
                  os_log_type_t v42 = "unknown";
                }
                else {
                  os_log_type_t v42 = off_189BB74C8[v41];
                }
                *(_DWORD *)buf = 136446466;
                v56 = "nw_connection_group_copy_remote_endpoint_for_message";
                os_log_type_t v57 = 2080;
                BOOL v58 = (void *)v42;
                _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s Unsupported group descriptor type: %s, no backtrace",  buf,  0x16u);
              }

              goto LABEL_33;
            }

            if (v35)
            {
              __int16 v36 = nw_group_descriptor_get_type(v3[8]);
              if (v36 > 4) {
                __int16 v37 = "unknown";
              }
              else {
                __int16 v37 = off_189BB74C8[v36];
              }
              *(_DWORD *)buf = 136446722;
              v56 = "nw_connection_group_copy_remote_endpoint_for_message";
              os_log_type_t v57 = 2080;
              BOOL v58 = (void *)v37;
              os_log_type_t v59 = 2082;
              os_log_type_t v60 = v33;
              _os_log_impl( &dword_181A5C000,  v23,  v34,  "%{public}s Unsupported group descriptor type: %s, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v33);
          }

    goto LABEL_40;
  }

  if (!v45)
  {
    __nwlog_obj();
    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    __int16 v35 = v46;
    if (os_log_type_enabled(v23, v46))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_send_message";
      _os_log_impl( &dword_181A5C000,  v23,  v35,  "%{public}s called with null completion, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_33;
  }

  char v31 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  __int16 v32 = v46;
  id v33 = os_log_type_enabled(v28, v46);
  if (!v31)
  {
    if (v33)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_connection_group_send_message";
      _os_log_impl(&dword_181A5C000, v28, v32, "%{public}s called with null completion, no backtrace", buf, 0xCu);
    }

    goto LABEL_39;
  }

  if (v33)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_connection_group_send_message";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v31;
    _os_log_impl( &dword_181A5C000,  v28,  v32,  "%{public}s called with null completion, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v31);
  if (v22) {
    goto LABEL_41;
  }
LABEL_6:
}

      if (v25) {
LABEL_34:
      }
        free(v25);
LABEL_35:
      dispatch_data_t v20 = 0LL;
      goto LABEL_36;
    }

    goto LABEL_16;
  }

                  free((void *)v3);
                }
              }
            }

                  free((void *)v3);
                }
              }
            }

                  free((void *)v3);
                }
              }
            }

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v11)
  {
    uint64_t v10 = (char *)v11;
LABEL_18:
    free(v10);
  }

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

    free(backtrace_string);
    goto LABEL_46;
  }

  members = (uint64_t)v2->members;
  if (!members || *(void *)(members + 24) - *(void *)(members + 16) != 8LL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v5 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      nw_endpoint_t v6 = v2->type;
      else {
        qos_class_t v7 = off_189BB74C8[v6];
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_group_descriptor_copy_member";
      uint64_t v26 = 2080;
      int v27 = (void *)v7;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s Group descriptor of type %s does not have exactly one member",  buf,  0x16u);
    }

LABEL_12:
    uint64_t v4 = 0LL;
    goto LABEL_13;
  }

  uint64_t v4 = nw_array_get_object_at_index(members, 0LL);
LABEL_13:

  return v4;
}

          free(v19);
          goto LABEL_34;
        }

        if (v28)
        {
          __int16 v45 = *(void *)&self[-1].log_str[25];
          id v46 = "invalid";
          if (v45 && *(void *)(v45 + 16)) {
            id v46 = *(const char **)(v45 + 16);
          }
          *(_DWORD *)buf = 136447490;
          id v84 = "-[NWConcrete_nw_protocol_instance destroy]";
          v85 = 2082;
          *(void *)id v86 = (char *)&self->flow_in_connected + 7;
          *(_WORD *)&v86[8] = 2080;
          *(void *)&v86[10] = " ";
          *(_WORD *)&v86[18] = 2080;
          *(void *)&v86[20] = v46;
          v87 = 2048;
          id v88 = v45;
          v89 = 2048;
          char v90 = self;
          _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s %{public}s%sOutput handler %s:%p is not null when protocol instance %p is deallocated, no backtrace",  buf,  0x3Eu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        dispatch_data_t v20 = (os_log_s *)(id)gLogObj;
        BOOL v41 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          os_log_type_t v42 = *(void *)&self[-1].log_str[25];
          int v43 = "invalid";
          if (v42 && *(void *)(v42 + 16)) {
            int v43 = *(const char **)(v42 + 16);
          }
          *(_DWORD *)buf = 136447490;
          id v84 = "-[NWConcrete_nw_protocol_instance destroy]";
          v85 = 2082;
          *(void *)id v86 = (char *)&self->flow_in_connected + 7;
          *(_WORD *)&v86[8] = 2080;
          *(void *)&v86[10] = " ";
          *(_WORD *)&v86[18] = 2080;
          *(void *)&v86[20] = v43;
          v87 = 2048;
          id v88 = v42;
          v89 = 2048;
          char v90 = self;
          _os_log_impl( &dword_181A5C000,  v20,  v41,  "%{public}s %{public}s%sOutput handler %s:%p is not null when protocol instance %p is deallocated, backtrace limit exceeded",  buf,  0x3Eu);
        }
      }
    }

    if (!v19) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }

    goto LABEL_34;
  }

  if (!a2)
  {
    __nwlog_obj();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_instance_access_state";
    int v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    int v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      nw_endpoint_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      qos_class_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_access_state";
        os_log_type_t v8 = "%{public}s called with null access_block";
        goto LABEL_32;
      }
    }

    else
    {
      if (v14)
      {
        os_log_type_t v12 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        nw_endpoint_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        qos_class_t v7 = type;
        uint64_t v13 = os_log_type_enabled(v6, type);
        if (v12)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_protocol_instance_access_state";
            BOOL v18 = 2082;
            char v19 = v12;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null access_block, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v12);
          if (!v5) {
            return 0LL;
          }
          goto LABEL_35;
        }

        if (!v13) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_access_state";
        os_log_type_t v8 = "%{public}s called with null access_block, no backtrace";
        goto LABEL_32;
      }

      __nwlog_obj();
      nw_endpoint_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      qos_class_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_instance_access_state";
        os_log_type_t v8 = "%{public}s called with null access_block, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

    goto LABEL_33;
  }

  id v2 = *(void *)(a1 + 112);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v2);
  }
  return 0LL;
}

      free(backtrace_string);
    }
  }

    if (v13) {
      free(v13);
    }
    return 0LL;
  }

  if (!LODWORD(a1->outbound_frames.tqh_first)) {
    return 0LL;
  }
  *(void *)buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000LL;
  __int16 v37 = __Block_byref_object_copy__11696;
  os_log_type_t v38 = __Block_byref_object_dispose__11697;
  __int16 v39 = 0LL;
  v22[0] = MEMORY[0x1895F87A8];
  v22[1] = 3221225472LL;
  os_log_type_t v23 = ___ZL33nw_protocol_create_data_from_poolP31NWConcrete_nw_protocol_instanceb_block_invoke;
  unsigned int v24 = &unk_189BB7950;
  uint64_t v26 = a2;
  os_log_type_t v25 = buf;
  tqh_last = a1->outbound_frames.tqh_last;
  do
  {
    if (!tqh_last) {
      break;
    }
    uint64_t v4 = (nw_frame **)tqh_last[2];
    int v5 = ((uint64_t (*)(void *))v23)(v22);
    tqh_last = v4;
  }

  while ((v5 & 1) != 0);
  nw_endpoint_t v6 = *(void *)(*(void *)&buf[8] + 40LL);
  if (v6)
  {
    qos_class_t v7 = *(void *)(v6 + 16);
    os_log_type_t v8 = *(void **)(v6 + 24);
    if (v7)
    {
      *(void *)(v7 + 24) = v8;
      os_log_type_t v8 = *(void **)(v6 + 24);
    }

    else
    {
      *(void *)&a1->empty_frame_pool_count = v8;
    }

    os_unfair_lock_s *v8 = v7;
    *(void *)(v6 + 16) = 0LL;
    *(void *)(v6 + 24) = 0LL;
    tqh_first = (int)a1->outbound_frames.tqh_first;
    LODWORD(a1->outbound_frames.tqh_first) = tqh_first - 1;
    if (!tqh_first)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        dispatch_data_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          tqh_first_low = LODWORD(a1->outbound_frames.tqh_first);
          *(_DWORD *)os_log_type_t type = 136446978;
          uint64_t v29 = "nw_protocol_create_data_from_pool";
          uint64_t v30 = 2082;
          char v31 = "instance->empty_frame_pool_count";
          __int16 v32 = 2048;
          id v33 = 1LL;
          uint32_t v34 = 2048;
          __int16 v35 = tqh_first_low;
          _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  (uint8_t *)type,  0x2Au);
        }
      }

      LODWORD(a1->outbound_frames.tqh_first) = 0;
    }
  }

  uint64_t v10 = *(id *)(*(void *)&buf[8] + 40LL);
  _Block_object_dispose(buf, 8);

  return v10;
}

      goto LABEL_34;
    }

    if (!v14)
    {
      __nwlog_obj();
      nw_endpoint_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      qos_class_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_identifier_copy";
        os_log_type_t v8 = "%{public}s called with null destination, backtrace limit exceeded";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    uint64_t v10 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    nw_endpoint_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    qos_class_t v7 = type;
    unsigned int v11 = os_log_type_enabled(v6, type);
    if (!v10)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_protocol_identifier_copy";
        os_log_type_t v8 = "%{public}s called with null destination, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v17 = "nw_protocol_identifier_copy";
      BOOL v18 = 2082;
      char v19 = v10;
      _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null destination, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v10);
  }

    return 0LL;
  }

  if (!type)
  {
    __nwlog_obj();
    os_log_type_t v66 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v107 = "nw_endpoint_create_bonjour_service";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      BOOL v67 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_181A5C000, v10, v67, "%{public}s called with null type", buf, 0xCu);
      }

      goto LABEL_92;
    }

    if (!LOBYTE(v95.receiver))
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v73 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl( &dword_181A5C000,  v10,  v73,  "%{public}s called with null type, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_92;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    BOOL v69 = typea[0];
    v70 = os_log_type_enabled(v10, typea[0]);
    if (!backtrace_string)
    {
      if (v70)
      {
        *(_DWORD *)buf = 136446210;
        v107 = "nw_endpoint_create_bonjour_service";
        _os_log_impl(&dword_181A5C000, v10, v69, "%{public}s called with null type, no backtrace", buf, 0xCu);
      }

      goto LABEL_92;
    }

    if (v70)
    {
      *(_DWORD *)buf = 136446466;
      v107 = "nw_endpoint_create_bonjour_service";
      v108 = 2082;
      v109 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v10,  v69,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_164;
  }

  os_log_type_t v12 = strlen(type);
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v16 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v107 = "nw_endpoint_create_bonjour_service";
    v108 = 2082;
    v109 = "type";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    typea[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v95.receiver) = 0;
    if (typea[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (os_log_s *)(id)gLogObj;
      __int16 v17 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        v108 = 2082;
        v109 = "type";
        _os_log_impl(&dword_181A5C000, v10, v17, "%{public}s invalid empty string %{public}s", buf, 0x16u);
      }

      goto LABEL_92;
    }

    if (!LOBYTE(v95.receiver))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (os_log_s *)(id)gLogObj;
      os_log_type_t v40 = typea[0];
      if (os_log_type_enabled(v10, typea[0]))
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        v108 = 2082;
        v109 = "type";
        _os_log_impl( &dword_181A5C000,  v10,  v40,  "%{public}s invalid empty string %{public}s, backtrace limit exceeded",  buf,  0x16u);
      }

      goto LABEL_92;
    }

    uint64_t v13 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = (os_log_s *)(id)gLogObj;
    dispatch_data_t v20 = typea[0];
    uint64_t v21 = os_log_type_enabled(v10, typea[0]);
    if (!v13)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        v107 = "nw_endpoint_create_bonjour_service";
        v108 = 2082;
        v109 = "type";
        _os_log_impl(&dword_181A5C000, v10, v20, "%{public}s invalid empty string %{public}s, no backtrace", buf, 0x16u);
      }

      goto LABEL_92;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446722;
      v107 = "nw_endpoint_create_bonjour_service";
      v108 = 2082;
      v109 = "type";
      v110 = 2082;
      v111 = v13;
      _os_log_impl( &dword_181A5C000,  v10,  v20,  "%{public}s invalid empty string %{public}s, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(backtrace_string);
    if (!v7) {
      return 0LL;
    }
    goto LABEL_51;
  }

  if (!(a3 | a4) && (!a5 || !a6))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_nexus_bind_client_port";
    qos_class_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_nexus_bind_client_port";
      uint64_t v10 = "%{public}s called with null process_uuid_ptr, pid_ptr, key";
      goto LABEL_48;
    }

    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_nexus_bind_client_port";
      uint64_t v10 = "%{public}s called with null process_uuid_ptr, pid_ptr, key, backtrace limit exceeded";
      goto LABEL_48;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v11 = (os_log_s *)gLogObj;
    os_log_type_t v12 = type;
    char v19 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v19) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_nexus_bind_client_port";
      uint64_t v10 = "%{public}s called with null process_uuid_ptr, pid_ptr, key, no backtrace";
      goto LABEL_48;
    }

    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = "nw_nexus_bind_client_port";
      int v27 = 2082;
      *(void *)uint64_t v28 = backtrace_string;
      os_log_type_t v15 = "%{public}s called with null process_uuid_ptr, pid_ptr, key, dumping backtrace:%{public}s";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  nw_endpoint_t v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  uint64_t v26 = "nw_nexus_bind_client_port";
  int v27 = 1024;
  *(_DWORD *)uint64_t v28 = v6;
  qos_class_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v23 = 0;
  if (__nwlog_fault(v7, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      uint64_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = "nw_nexus_bind_client_port";
      int v27 = 1024;
      *(_DWORD *)uint64_t v28 = v6;
      uint64_t v10 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d";
LABEL_43:
      dispatch_data_t v20 = v8;
      uint64_t v21 = v9;
      uint64_t v22 = 18;
LABEL_49:
      _os_log_impl(&dword_181A5C000, v20, v21, v10, buf, v22);
      goto LABEL_50;
    }

    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (os_log_s *)gLogObj;
      uint64_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = "nw_nexus_bind_client_port";
      int v27 = 1024;
      *(_DWORD *)uint64_t v28 = v6;
      uint64_t v10 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_43;
    }

    __int16 v17 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (os_log_s *)gLogObj;
    uint64_t v9 = type;
    BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v17)
    {
      if (!v18) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = "nw_nexus_bind_client_port";
      int v27 = 1024;
      *(_DWORD *)uint64_t v28 = v6;
      uint64_t v10 = "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, no backtrace";
      goto LABEL_43;
    }

    if (v18)
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v26 = "nw_nexus_bind_client_port";
      int v27 = 1024;
      *(_DWORD *)uint64_t v28 = v6;
      v28[2] = 2082;
      *(void *)&v28[3] = v17;
      _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s os_nexus_controller_bind_provider_instance(SERVER) %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
    }

    free(v17);
  }

        uint64_t v3 = 0LL;
LABEL_34:

        goto LABEL_35;
      }
    }

    goto LABEL_21;
  }

  __nwlog_obj();
  unsigned int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
  *(_DWORD *)dest = 136446466;
  char v31 = "strict_malloc";
  __int16 v32 = 2048;
  id v33 = 2 * v6;
  LODWORD(v27) = 22;
  os_log_type_t v25 = (void *)_os_log_send_and_compose_impl();

  BOOL result = (id)__nwlog_abort((uint64_t)v25);
  if (!(_DWORD)result)
  {
    free(v25);
    objc_msgSend(v4, "getCharacters:range:", 0, 0, v6, dest, v27);
    if (v6) {
      goto LABEL_7;
    }
LABEL_22:
    char v16 = (void *)objc_msgSend(v4, "copy", v26, v27);

    if (!v16) {
      goto LABEL_33;
    }
    goto LABEL_23;
  }

  if (v3) {
LABEL_34:
  }
    free(v3);
}

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_34;
  }

  handle = a1->handle;
  if (handle)
  {
    if (a1->output_handler == a2) {
      handle[196] |= 1u;
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v14 = "nw_protocol_trainer_connected";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unsigned int v11 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    int v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_trainer_connected";
    nw_endpoint_t v6 = "%{public}s called with null trainer";
    goto LABEL_33;
  }

  if (!v11)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    int v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_trainer_connected";
    nw_endpoint_t v6 = "%{public}s called with null trainer, backtrace limit exceeded";
    goto LABEL_33;
  }

  uint64_t v9 = (char *)__nw_create_backtrace_string();
  uint64_t v4 = (os_log_s *)__nwlog_obj();
  int v5 = type;
  uint64_t v10 = os_log_type_enabled(v4, type);
  if (!v9)
  {
    if (!v10) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_trainer_connected";
    nw_endpoint_t v6 = "%{public}s called with null trainer, no backtrace";
    goto LABEL_33;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    int v14 = "nw_protocol_trainer_connected";
    os_log_type_t v15 = 2082;
    char v16 = v9;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null trainer, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v9);
  if (v3) {
    goto LABEL_35;
  }
}

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_34;
  }

  handle = a1->handle;
  if (handle)
  {
    if (a1->output_handler == a2) {
      handle[196] |= 2u;
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v14 = "nw_protocol_trainer_disconnected";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  unsigned int v11 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    int v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_trainer_disconnected";
    nw_endpoint_t v6 = "%{public}s called with null trainer";
    goto LABEL_33;
  }

  if (!v11)
  {
    uint64_t v4 = (os_log_s *)__nwlog_obj();
    int v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_trainer_disconnected";
    nw_endpoint_t v6 = "%{public}s called with null trainer, backtrace limit exceeded";
    goto LABEL_33;
  }

  uint64_t v9 = (char *)__nw_create_backtrace_string();
  uint64_t v4 = (os_log_s *)__nwlog_obj();
  int v5 = type;
  uint64_t v10 = os_log_type_enabled(v4, type);
  if (!v9)
  {
    if (!v10) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    int v14 = "nw_protocol_trainer_disconnected";
    nw_endpoint_t v6 = "%{public}s called with null trainer, no backtrace";
    goto LABEL_33;
  }

  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    int v14 = "nw_protocol_trainer_disconnected";
    os_log_type_t v15 = 2082;
    char v16 = v9;
    _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null trainer, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v9);
  if (v3) {
    goto LABEL_35;
  }
}

  if (v15) {
    free(v15);
  }
LABEL_18:
  v23.receiver = self;
  v23.super_class = (Class)&OBJC_CLASS___OS_nw_parallel_array;
  -[OS_nw_parallel_array dealloc](&v23, sel_dealloc, v21, v22);
}

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v52 = "nw_protocol_http_client_bottom_remove_input_handler";
    os_log_type_t v53 = 2048;
    BOOL v54 = a2;
    int v27 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v49 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v28 = (os_log_s *)gLogObj;
      uint64_t v29 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v52 = "nw_protocol_http_client_bottom_remove_input_handler";
        os_log_type_t v53 = 2048;
        BOOL v54 = a2;
        uint64_t v30 = "%{public}s Protocol %p isn't an input handler of http client bottom";
LABEL_61:
        _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0x16u);
      }
    }

    else if (v49)
    {
      char v31 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v28 = (os_log_s *)gLogObj;
      uint64_t v29 = type;
      __int16 v32 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v52 = "nw_protocol_http_client_bottom_remove_input_handler";
          os_log_type_t v53 = 2048;
          BOOL v54 = a2;
          os_log_type_t v55 = 2082;
          v56 = (uint64_t)v31;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s Protocol %p isn't an input handler of http client bottom, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v31);
        goto LABEL_62;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v52 = "nw_protocol_http_client_bottom_remove_input_handler";
        os_log_type_t v53 = 2048;
        BOOL v54 = a2;
        uint64_t v30 = "%{public}s Protocol %p isn't an input handler of http client bottom, no backtrace";
        goto LABEL_61;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v28 = (os_log_s *)gLogObj;
      uint64_t v29 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v52 = "nw_protocol_http_client_bottom_remove_input_handler";
        os_log_type_t v53 = 2048;
        BOOL v54 = a2;
        uint64_t v30 = "%{public}s Protocol %p isn't an input handler of http client bottom, backtrace limit exceeded";
        goto LABEL_61;
      }
    }

      free(v8);
      goto LABEL_34;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    int v27 = "nw_endpoint_flow_uses_multipath_block_invoke";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          int v27 = "nw_endpoint_flow_uses_multipath_block_invoke";
          int v14 = "%{public}s Didn't get a CIAUX_MPTCP";
LABEL_22:
          BOOL v18 = v12;
          char v19 = v13;
LABEL_23:
          _os_log_impl(&dword_181A5C000, v18, v19, v14, buf, 0xCu);
          goto LABEL_24;
        }

        goto LABEL_24;
      }

      if (!v23)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          int v27 = "nw_endpoint_flow_uses_multipath_block_invoke";
          int v14 = "%{public}s Didn't get a CIAUX_MPTCP, backtrace limit exceeded";
          goto LABEL_22;
        }

      free(v8);
      goto LABEL_34;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    int v27 = "nw_endpoint_flow_get_multipath_subflow_count_block_invoke";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          int v27 = "nw_endpoint_flow_get_multipath_subflow_count_block_invoke";
          int v14 = "%{public}s Didn't get a CIAUX_MPTCP";
LABEL_22:
          BOOL v18 = v12;
          char v19 = v13;
LABEL_23:
          _os_log_impl(&dword_181A5C000, v18, v19, v14, buf, 0xCu);
          goto LABEL_24;
        }

        goto LABEL_24;
      }

      if (!v23)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (os_log_s *)(id)gLogObj;
        uint64_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          int v27 = "nw_endpoint_flow_get_multipath_subflow_count_block_invoke";
          int v14 = "%{public}s Didn't get a CIAUX_MPTCP, backtrace limit exceeded";
          goto LABEL_22;
        }

  if (v2) {
LABEL_34:
  }
    free(v2);
}
            }

    if (v14) {
      free(v14);
    }
    *(_DWORD *)(a1 + 24) = -1;
LABEL_36:
    if (gLogDatapath)
    {
      v65 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v76 = "nw_frame_cache_return_frame";
        os_log_type_t v77 = 1024;
        *(_DWORD *)os_log_type_t v78 = v5;
        _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_DEBUG,  "%{public}s reset frame of length %u, eligible for reuse",  buf,  0x12u);
      }

      if (gLogDatapath)
      {
        os_log_type_t v66 = (os_log_s *)__nwlog_obj();
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
        {
          BOOL v67 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)buf = 136446466;
          os_log_type_t v76 = "frame_cache_purge_if_necessary";
          os_log_type_t v77 = 1024;
          *(_DWORD *)os_log_type_t v78 = v67;
          _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_DEBUG,  "%{public}s total %u empty frames in cache (initial)",  buf,  0x12u);
        }
      }
    }

    if (*(_DWORD *)(a1 + 24) > *(_DWORD *)(a1 + 28))
    {
      while (1)
      {
        if (gLogDatapath)
        {
          os_log_type_t v25 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v26 = *(_DWORD *)(a1 + 24);
            int v27 = *(_DWORD *)(a1 + 28);
            *(_DWORD *)buf = 136446722;
            os_log_type_t v76 = "frame_cache_purge_if_necessary";
            os_log_type_t v77 = 1024;
            *(_DWORD *)os_log_type_t v78 = v26;
            *(_WORD *)&v78[4] = 1024;
            *(_DWORD *)&v78[6] = v27;
            _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s too many frames in frame cache (%u > %u), pruning",  buf,  0x18u);
          }
        }

        unsigned int v24 = **(void ***)(*(void *)v9 + 8LL);
        if (!v24) {
          break;
        }
        frame_cache_remove_from_cache(a1, v24);
        if (*(_DWORD *)(a1 + 24) <= *(_DWORD *)(a1 + 28)) {
          goto LABEL_44;
        }
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v34 = *(_DWORD *)(a1 + 24);
      *(_DWORD *)buf = 136446466;
      os_log_type_t v76 = "frame_cache_purge_if_necessary";
      os_log_type_t v77 = 1024;
      *(_DWORD *)os_log_type_t v78 = v34;
      __int16 v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      v73 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v36 = gLogObj;
        __int16 v37 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          os_log_type_t v38 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)buf = 136446466;
          os_log_type_t v76 = "frame_cache_purge_if_necessary";
          os_log_type_t v77 = 1024;
          *(_DWORD *)os_log_type_t v78 = v38;
          __int16 v39 = "%{public}s no more frames in frame cache, we thought we had %u frames";
LABEL_78:
          v56 = (os_log_s *)v36;
          os_log_type_t v57 = v37;
          BOOL v58 = 18;
LABEL_82:
          _os_log_impl(&dword_181A5C000, v56, v57, v39, buf, v58);
          goto LABEL_83;
        }

        goto LABEL_83;
      }

      if (!v73)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v36 = gLogObj;
        __int16 v37 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          os_log_type_t v53 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)buf = 136446466;
          os_log_type_t v76 = "frame_cache_purge_if_necessary";
          os_log_type_t v77 = 1024;
          *(_DWORD *)os_log_type_t v78 = v53;
          __int16 v39 = "%{public}s no more frames in frame cache, we thought we had %u frames, backtrace limit exceeded";
          goto LABEL_78;
        }

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_masque_get_output_local_endpoint";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_masque_get_output_local_endpoint";
      qos_class_t v7 = "%{public}s called with null masque";
      goto LABEL_33;
    }

    if (!v12)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_masque_get_output_local_endpoint";
      qos_class_t v7 = "%{public}s called with null masque, backtrace limit exceeded";
      goto LABEL_33;
    }

    uint64_t v10 = (char *)__nw_create_backtrace_string();
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    unsigned int v11 = os_log_type_enabled(v5, type);
    if (!v10)
    {
      if (!v11) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_masque_get_output_local_endpoint";
      qos_class_t v7 = "%{public}s called with null masque, no backtrace";
      goto LABEL_33;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v15 = "nw_protocol_masque_get_output_local_endpoint";
      char v16 = 2082;
      __int16 v17 = v10;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null masque, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v10);
LABEL_34:
    if (!v4) {
      return 0LL;
    }
LABEL_35:
    free(v4);
    return 0LL;
  }

  id v2 = handle[45];
  if (v2) {
    return v2;
  }
  return nw_protocol_get_output_local_endpoint((uint64_t)a1->output_handler);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

    _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    goto LABEL_34;
  }

  if (a1->handle)
  {
    if (a1->default_input_handler == a2) {
      nw_protocol_disconnect(a1->output_handler->flow_id, (uint64_t)a1);
    }
    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v13 = "nw_protocol_ohttp_disconnect";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v10 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    uint64_t v4 = type;
    if (!os_log_type_enabled(v3, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_ohttp_disconnect";
    int v5 = "%{public}s called with null ohttp";
    goto LABEL_33;
  }

  if (!v10)
  {
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    uint64_t v4 = type;
    if (!os_log_type_enabled(v3, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_ohttp_disconnect";
    int v5 = "%{public}s called with null ohttp, backtrace limit exceeded";
    goto LABEL_33;
  }

  os_log_type_t v8 = (char *)__nw_create_backtrace_string();
  uint64_t v3 = (os_log_s *)__nwlog_obj();
  uint64_t v4 = type;
  uint64_t v9 = os_log_type_enabled(v3, type);
  if (!v8)
  {
    if (!v9) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_protocol_ohttp_disconnect";
    int v5 = "%{public}s called with null ohttp, no backtrace";
    goto LABEL_33;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v13 = "nw_protocol_ohttp_disconnect";
    int v14 = 2082;
    os_log_type_t v15 = v8;
    _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v8);
  if (v2) {
    goto LABEL_35;
  }
}

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_34;
  }

  handle = a1->handle;
  if (handle)
  {
    nw_protocol_disconnected(a1->default_input_handler->flow_id, (uint64_t)a1);
    uint64_t v4 = (char *)*((void *)handle + 37);
    if (v4)
    {
      v13[0] = MEMORY[0x1895F87A8];
      v13[1] = 0x40000000LL;
      v13[2] = ___ZL30nw_protocol_ohttp_disconnectedP11nw_protocolS0__block_invoke;
      v13[3] = &__block_descriptor_tmp_43_28615;
      void v13[4] = a1;
      nw_hash_table_apply(v4, (uint64_t)v13);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_protocol_ohttp_disconnected";
  int v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v15 = OS_LOG_TYPE_ERROR;
  int v14 = 0;
  if (v15 == OS_LOG_TYPE_FAULT)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = v15;
    if (!os_log_type_enabled(v6, v15)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_ohttp_disconnected";
    os_log_type_t v8 = "%{public}s called with null ohttp";
    goto LABEL_33;
  }

  if (!v14)
  {
    nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
    qos_class_t v7 = v15;
    if (!os_log_type_enabled(v6, v15)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_ohttp_disconnected";
    os_log_type_t v8 = "%{public}s called with null ohttp, backtrace limit exceeded";
    goto LABEL_33;
  }

  unsigned int v11 = (char *)__nw_create_backtrace_string();
  nw_endpoint_t v6 = (os_log_s *)__nwlog_obj();
  qos_class_t v7 = v15;
  os_log_type_t v12 = os_log_type_enabled(v6, v15);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_protocol_ohttp_disconnected";
    os_log_type_t v8 = "%{public}s called with null ohttp, no backtrace";
    goto LABEL_33;
  }

  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v17 = "nw_protocol_ohttp_disconnected";
    BOOL v18 = 2082;
    char v19 = v11;
    _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v11);
  if (v5) {
    goto LABEL_35;
  }
}

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_34;
  }

  handle = a1->handle;
  if (handle)
  {
    nw_protocol_error(a1->default_input_handler->flow_id, (uint64_t)a2);
    nw_endpoint_t v6 = (char *)*((void *)handle + 37);
    if (v6)
    {
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 0x40000000LL;
      v15[2] = ___ZL23nw_protocol_ohttp_errorP11nw_protocolS0_i_block_invoke;
      v15[3] = &__block_descriptor_tmp_44_28603;
      v15[4] = a2;
      char v16 = a3;
      nw_hash_table_apply(v6, (uint64_t)v15);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  dispatch_data_t v20 = "nw_protocol_ohttp_error";
  qos_class_t v7 = (char *)_os_log_send_and_compose_impl();
  BOOL v18 = OS_LOG_TYPE_ERROR;
  __int16 v17 = 0;
  if (v18 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = (os_log_s *)__nwlog_obj();
    uint64_t v9 = v18;
    if (!os_log_type_enabled(v8, v18)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    dispatch_data_t v20 = "nw_protocol_ohttp_error";
    uint64_t v10 = "%{public}s called with null ohttp";
    goto LABEL_33;
  }

  if (!v17)
  {
    os_log_type_t v8 = (os_log_s *)__nwlog_obj();
    uint64_t v9 = v18;
    if (!os_log_type_enabled(v8, v18)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    dispatch_data_t v20 = "nw_protocol_ohttp_error";
    uint64_t v10 = "%{public}s called with null ohttp, backtrace limit exceeded";
    goto LABEL_33;
  }

  uint64_t v13 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = (os_log_s *)__nwlog_obj();
  uint64_t v9 = v18;
  int v14 = os_log_type_enabled(v8, v18);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    dispatch_data_t v20 = "nw_protocol_ohttp_error";
    uint64_t v10 = "%{public}s called with null ohttp, no backtrace";
    goto LABEL_33;
  }

  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    dispatch_data_t v20 = "nw_protocol_ohttp_error";
    uint64_t v21 = 2082;
    uint64_t v22 = v13;
    _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null ohttp, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v13);
  if (v7) {
    goto LABEL_35;
  }
}

  flow_id = 0LL;
LABEL_72:

  return flow_id;
}

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }

  if (*(void *)(a1 + 40))
  {
    if (a3)
    {
      uint64_t v3 = a3[1] & 0xFFFFFFF8 | 1;
      *a3 = 4000;
      a3[1] = v3;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_ethernet_get_message_properties";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ethernet_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ethernet";
    goto LABEL_33;
  }

  if (!v12)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ethernet_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ethernet, backtrace limit exceeded";
    goto LABEL_33;
  }

  uint64_t v10 = (char *)__nw_create_backtrace_string();
  int v5 = (os_log_s *)__nwlog_obj();
  nw_endpoint_t v6 = type;
  unsigned int v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ethernet_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ethernet, no backtrace";
    goto LABEL_33;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v15 = "nw_protocol_ethernet_get_message_properties";
    char v16 = 2082;
    __int16 v17 = v10;
    _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null ethernet, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v10);
  if (v4) {
    goto LABEL_35;
  }
}

    free(v9);
    goto LABEL_34;
  }

  uint64_t v3 = (void *)*((void *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "tcp_connection_get_interface";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s API Misuse: Function must be called after tcp_connection_start",  buf,  0xCu);
    }

    goto LABEL_34;
  }

  uint64_t v4 = nw_connection_copy_connected_path(v3);
  int v5 = v4;
  if (v4)
  {
    nw_endpoint_t v6 = (NWConcrete_nw_path *)v4;
    if (nw_path_network_is_satisfied_update_reason(v6, 0LL)) {
      routed_interface_index = v6->policy_result.routed_interface_index;
    }
    else {
      routed_interface_index = 0LL;
    }
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v16 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "tcp_connection_get_interface";
      _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_ERROR, "%{public}s No connected path", buf, 0xCu);
    }

    routed_interface_index = 0LL;
  }

LABEL_35:
  return routed_interface_index;
}

    if (!v16)
    {
LABEL_35:
      int v14 = 0LL;
      goto LABEL_36;
    }

    if (!v16)
    {
LABEL_35:
      int v14 = 0LL;
      goto LABEL_36;
    }

      free(backtrace_string);
      goto LABEL_46;
    }

    uint64_t v10 = (os_log_s *)__nwlog_obj();
    unsigned int v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
    os_log_type_t v12 = "%{public}s called with null protocol";
LABEL_45:
    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
LABEL_46:
    if (v9) {
      free(v9);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      unsigned int v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
      os_log_type_t v12 = "%{public}s called with null webtransport_session";
      goto LABEL_45;
    }

    if (!v21)
    {
      uint64_t v10 = (os_log_s *)__nwlog_obj();
      unsigned int v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
      os_log_type_t v12 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_45;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v10 = (os_log_s *)__nwlog_obj();
    unsigned int v11 = type;
    BOOL v18 = os_log_type_enabled(v10, type);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
        os_log_type_t v25 = 2082;
        uint64_t v26 = backtrace_string;
        __int16 v17 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v18) {
      goto LABEL_46;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
    os_log_type_t v12 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_45;
  }

  if ((handle[137] & 2) == 0)
  {
    if (gLogDatapath)
    {
      uint64_t v13 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        int v14 = handle[115];
        *(_DWORD *)buf = 136446978;
        unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
        os_log_type_t v25 = 2082;
        uint64_t v26 = (char *)(handle + 116);
        int v27 = 2080;
        uint64_t v28 = " ";
        uint64_t v29 = 1024;
        uint64_t v30 = v14;
        _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
  }

  if (*((void *)handle + 50))
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_endpoint_t v6 = (os_log_s *)gLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        os_log_type_t v8 = handle[115];
        *(_DWORD *)buf = 136446978;
        unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
        os_log_type_t v25 = 2082;
        uint64_t v26 = (char *)(handle + 116);
        int v27 = 2080;
        uint64_t v28 = " ";
        uint64_t v29 = 1024;
        uint64_t v30 = v8;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s%s<i%u> Already have a listen handler, ignoring add",  buf,  0x26u);
        return 0LL;
      }

      return result;
    }

    return 0LL;
  }

  *((void *)handle + 50) = a2;
  a2->protocol_handler = (nw_protocol *)handle;
  if ((a3 & 1) != 0)
  {
    *((_BYTE *)handle + 548) |= 8u;
    nw_protocol_remove_instance((uint64_t)handle);
  }

  BOOL result = 1LL;
  if ((handle[137] & 2) == 0 && gLogDatapath)
  {
    char v19 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      dispatch_data_t v20 = handle[115];
      *(_DWORD *)buf = 136447234;
      unsigned int v24 = "nw_protocol_webtransport_session_add_listen_handler";
      os_log_type_t v25 = 2082;
      uint64_t v26 = (char *)(handle + 116);
      int v27 = 2080;
      uint64_t v28 = " ";
      uint64_t v29 = 1024;
      uint64_t v30 = v20;
      char v31 = 2048;
      __int16 v32 = a2;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%s<i%u> added protocol listen handler %p",  buf,  0x30u);
    }

    return 1LL;
  }

  return result;
}

      free(backtrace_string);
      goto LABEL_43;
    }

    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    if (!os_log_type_enabled(v14, type)) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_protocol_http_connect_get_output_frames";
    char v16 = "%{public}s called with null protocol";
LABEL_42:
    _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
LABEL_43:
    if (v13) {
      free(v13);
    }
    return 0LL;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_protocol_http_connect_get_output_frames";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_protocol_http_connect_get_output_frames";
      char v16 = "%{public}s called with null http_connect";
      goto LABEL_42;
    }

    if (!v21)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_protocol_http_connect_get_output_frames";
      char v16 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_42;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    dispatch_data_t v20 = os_log_type_enabled(v14, type);
    if (backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v24 = "nw_protocol_http_connect_get_output_frames";
        os_log_type_t v25 = 2082;
        uint64_t v26 = backtrace_string;
        char v19 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v20) {
      goto LABEL_43;
    }
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_protocol_http_connect_get_output_frames";
    char v16 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_42;
  }

  if (*((_DWORD *)handle + 70) == 2)
  {
    BOOL result = handle[7];
    if (!result) {
      return result;
    }
    uint64_t v9 = *(void *)(result + 24);
    if (v9)
    {
      uint64_t v10 = *(uint64_t (**)(void))(v9 + 88);
      if (v10) {
        return v10();
      }
    }
  }

  else if ((handle[46] & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v11 = (os_log_s *)gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)result) {
      return result;
    }
    *(_DWORD *)buf = 136446722;
    unsigned int v24 = "nw_protocol_http_connect_get_output_frames";
    os_log_type_t v25 = 2082;
    uint64_t v26 = (char *)handle + 284;
    int v27 = 2080;
    uint64_t v28 = " ";
    _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s %{public}s%sNot yet connected, returning 0 output frames",  buf,  0x20u);
  }

  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

    goto LABEL_34;
  }

  if (v4)
  {
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    v18[2] = __nw_socks5_server_set_error_handler_block_invoke;
    v18[3] = &unk_189BC91E8;
    nw_endpoint_t v6 = v3;
    v18[4] = v6;
    qos_class_t v7 = v5;
    v18[5] = v7;
    os_unfair_lock_lock(v3 + 6);
    __nw_socks5_server_set_error_handler_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v3 + 6);

    goto LABEL_4;
  }

  __nwlog_obj();
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_socks5_server_set_error_handler";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  dispatch_data_t v20 = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (v20 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v11 = v20;
    if (os_log_type_enabled(v10, v20))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_socks5_server_set_error_handler";
      os_log_type_t v12 = "%{public}s called with null handler";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (!v19)
  {
    __nwlog_obj();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v11 = v20;
    if (os_log_type_enabled(v10, v20))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_socks5_server_set_error_handler";
      os_log_type_t v12 = "%{public}s called with null handler, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  char v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  unsigned int v11 = v20;
  __int16 v17 = os_log_type_enabled(v10, v20);
  if (!v16)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_socks5_server_set_error_handler";
      os_log_type_t v12 = "%{public}s called with null handler, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_socks5_server_set_error_handler";
    os_log_type_t v23 = 2082;
    unsigned int v24 = v16;
    _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v9) {
    goto LABEL_35;
  }
LABEL_4:
}

    goto LABEL_34;
  }

  if (v4)
  {
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    v18[2] = __nw_socks5_server_set_state_changed_handler_block_invoke;
    v18[3] = &unk_189BC91E8;
    nw_endpoint_t v6 = v3;
    v18[4] = v6;
    qos_class_t v7 = v5;
    v18[5] = v7;
    os_unfair_lock_lock(v3 + 6);
    __nw_socks5_server_set_state_changed_handler_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v3 + 6);

    goto LABEL_4;
  }

  __nwlog_obj();
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_socks5_server_set_state_changed_handler";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  dispatch_data_t v20 = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (v20 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v11 = v20;
    if (os_log_type_enabled(v10, v20))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_socks5_server_set_state_changed_handler";
      os_log_type_t v12 = "%{public}s called with null handler";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (!v19)
  {
    __nwlog_obj();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    unsigned int v11 = v20;
    if (os_log_type_enabled(v10, v20))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_socks5_server_set_state_changed_handler";
      os_log_type_t v12 = "%{public}s called with null handler, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  char v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  unsigned int v11 = v20;
  __int16 v17 = os_log_type_enabled(v10, v20);
  if (!v16)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_socks5_server_set_state_changed_handler";
      os_log_type_t v12 = "%{public}s called with null handler, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_socks5_server_set_state_changed_handler";
    os_log_type_t v23 = 2082;
    unsigned int v24 = v16;
    _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null handler, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v16);
  if (v9) {
    goto LABEL_35;
  }
LABEL_4:
}

    free(v27);
    goto LABEL_34;
  }

  os_log_type_t v8 = v6;
  uint64_t v9 = v8[30];

  if (v9 == 1)
  {
    v239 = v5;
    v243 = v8;
    uint64_t v10 = v8;
    unsigned int v11 = *((_BYTE *)v10 + 268);
    v248 = v10;

    if ((v11 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
      }
      os_log_type_t v12 = (os_log_s *)(id)gconnectionLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v13 = v248;

        int v14 = v13;
        os_log_type_t v15 = *((_BYTE *)v248 + 268);

        if ((v15 & 1) != 0) {
          char v16 = "dry-run ";
        }
        else {
          char v16 = "";
        }
        __int16 v17 = nw_endpoint_handler_copy_endpoint(v14);
        logging_description = nw_endpoint_get_logging_description(v17);
        char v19 = v13 + 168;
        dispatch_data_t v20 = v14;
        uint64_t v21 = v20;
        uint64_t v22 = v8[30];
        else {
          os_log_type_t v23 = off_189BBBBF0[v22];
        }
        v253 = self;

        __int16 v37 = v21;
        os_log_type_t v38 = v37;
        __int16 v39 = logging_description;
        os_log_type_t v40 = "path";
        switch(v6[29])
        {
          case 0u:
            break;
          case 1u:
            os_log_type_t v40 = "resolver";
            break;
          case 2u:
            os_log_type_t v40 = nw_endpoint_flow_mode_string(v37[31]);
            break;
          case 3u:
            os_log_type_t v40 = "proxy";
            break;
          case 4u:
            os_log_type_t v40 = "fallback";
            break;
          case 5u:
            os_log_type_t v40 = "transform";
            break;
          default:
            os_log_type_t v40 = "unknown-mode";
            break;
        }

        os_log_type_t v42 = v38;
        os_unfair_lock_lock((os_unfair_lock_t)v42 + 28);
        int v43 = v42[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v42 + 28);

        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_fallback startWithHandler:]";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v19;
        *(_WORD *)&buf[22] = 2082;
        *(void *)&buf[24] = v16;
        *(_WORD *)&buf[32] = 2082;
        *(void *)&buf[34] = v39;
        *(_WORD *)&buf[42] = 2082;
        *(void *)&_BYTE buf[44] = v23;
        *(_WORD *)&buf[52] = 2082;
        *(void *)&buf[54] = v40;
        *(_WORD *)&buf[62] = 2114;
        *(void *)v277 = v43;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ",  buf,  0x48u);

        self = v253;
      }
    }

    primary_child = self->primary_child;
    self->primary_child = 0LL;

    fallback_child = self->fallback_child;
    self->fallback_child = 0LL;

    primary_interface = self->primary_interface;
    self->primary_interface = 0LL;

    fallback_interface = self->fallback_interface;
    self->fallback_interface = 0LL;

    v244 = nw_endpoint_handler_copy_endpoint(v248);
    char v48 = v248;
    os_unfair_lock_lock((os_unfair_lock_t)v48 + 28);
    v254 = (id *)*((id *)v48 + 8);
    lock = (os_unfair_lock_s *)(v48 + 112);
    os_unfair_lock_unlock((os_unfair_lock_t)v48 + 28);

    uint64_t v49 = (char *)self + 108;
    else {
      os_log_type_t v50 = 0;
    }
    os_log_s *v49 = *((_BYTE *)self + 108) & 0xFD | v50;
    else {
      uint64_t v51 = 0;
    }
    os_log_s *v49 = *v49 & 0xFB | v51;
    else {
      os_log_type_t v52 = 0;
    }
    os_log_s *v49 = *v49 & 0xF7 | v52;
    else {
      os_log_type_t v53 = 0;
    }
    os_log_s *v49 = *v49 & 0xEF | v53;
    BOOL v54 = v48;
    v242 = v54[4];
    v252 = v54;

    if ((*v49 & 2) != 0) {
      goto LABEL_94;
    }
    os_log_type_t v55 = v242;
    if (v55)
    {
      v56 = *(_DWORD *)(v55[13] + 72LL);

      if (v56 != 200 && v56 != 100) {
        goto LABEL_94;
      }
      *((_BYTE *)self + 108) |= 2u;
      if (!nw_endpoint_handler_get_minimize_logging(v54))
      {
        os_log_type_t v57 = v54;
        BOOL v58 = (v248[67] & 0x20) == 0;

        if (!v58) {
          goto LABEL_94;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v59 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_INFO))
        {
          os_log_type_t v60 = v57;

          v61 = v60;
          os_log_type_t v62 = (v248[67] & 1) == 0;

          if (v62) {
            char v63 = "";
          }
          else {
            char v63 = "dry-run ";
          }
          os_log_type_t v64 = nw_endpoint_handler_copy_endpoint(v61);
          v65 = nw_endpoint_get_logging_description(v64);
          os_log_type_t v66 = v61;
          BOOL v67 = v66;
          os_log_type_t v68 = v243[30];
          v249 = v65;
          else {
            BOOL v69 = off_189BBBBF0[v68];
          }
          v245 = v69;

          v70 = v67;
          os_log_type_t v71 = "path";
          switch(v6[29])
          {
            case 0u:
              break;
            case 1u:
              os_log_type_t v71 = "resolver";
              break;
            case 2u:
              os_log_type_t v71 = nw_endpoint_flow_mode_string(v70[31]);
              break;
            case 3u:
              os_log_type_t v71 = "proxy";
              break;
            case 4u:
              os_log_type_t v71 = "fallback";
              break;
            case 5u:
              os_log_type_t v71 = "transform";
              break;
            default:
              os_log_type_t v71 = "unknown-mode";
              break;
          }

          v240 = v71;

          BOOL v72 = v60;
          v73 = v64;
          v74 = v70;
          os_unfair_lock_lock(lock);
          v75 = *((id *)v48 + 8);
          os_unfair_lock_unlock(lock);

          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_fallback startWithHandler:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v72 + 21;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = v63;
          *(_WORD *)&buf[32] = 2082;
          *(void *)&buf[34] = v249;
          *(_WORD *)&buf[42] = 2082;
          *(void *)&_BYTE buf[44] = v245;
          *(_WORD *)&buf[52] = 2082;
          *(void *)&buf[54] = v240;
          *(_WORD *)&buf[62] = 2114;
          *(void *)v277 = v75;
          _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_INFO,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Overriding strong fallback to weak fallback for background traffic",  buf,  0x48u);
        }

        goto LABEL_93;
      }

      if ((nw_endpoint_handler_get_logging_disabled(v54) & 1) == 0)
      {
        v212 = v48;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
        }
        os_log_type_t v59 = (os_log_s *)(id)gconnectionLogObj;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v54);
          v247 = nw_endpoint_handler_dry_run_string(v54);
          v213 = nw_endpoint_handler_copy_endpoint(v54);
          v214 = nw_endpoint_get_logging_description(v213);
          v215 = nw_endpoint_handler_state_string(v252);
          v216 = nw_endpoint_handler_mode_string(v252);
          v217 = nw_endpoint_handler_copy_current_path(v252);
          *(_DWORD *)buf = 136447746;
          *(void *)&uint8_t buf[4] = "-[NWConcrete_nw_endpoint_fallback startWithHandler:]";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = id_string;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&buf[24] = v247;
          *(_WORD *)&buf[32] = 2082;
          *(void *)&buf[34] = v214;
          *(_WORD *)&buf[42] = 2082;
          *(void *)&_BYTE buf[44] = v215;
          *(_WORD *)&buf[52] = 2082;
          *(void *)&buf[54] = v216;
          *(_WORD *)&buf[62] = 2114;
          *(void *)v277 = v217;
          _os_log_impl( &dword_181A5C000,  v59,  OS_LOG_TYPE_DEBUG,  "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Overriding strong fallback to weak fallback for background traffic",  buf,  0x48u);

          char v48 = v212;
        }

LABEL_34:
    if (!v22) {
      goto LABEL_36;
    }
LABEL_35:
    free(v22);
    goto LABEL_36;
  }

  if (!v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v23 = (os_log_s *)(id)gLogObj;
    uint64_t v28 = type;
    if (os_log_type_enabled(v23, type))
    {
      *(_DWORD *)buf = 136446210;
      int v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      _os_log_impl( &dword_181A5C000,  v23,  v28,  "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded",  buf,  0xCu);
    }

    goto LABEL_33;
  }

  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v23 = (os_log_s *)(id)gLogObj;
  uint64_t v26 = type;
  int v27 = os_log_type_enabled(v23, type);
  if (!backtrace_string)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446210;
      int v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      _os_log_impl( &dword_181A5C000,  v23,  v26,  "%{public}s nw_queue_context_create_source(timer) failed, no backtrace",  buf,  0xCu);
    }

    goto LABEL_33;
  }

  if (v27)
  {
    *(_DWORD *)buf = 136446466;
    int v43 = "nw_endpoint_fallback_start_usage_cap_timer";
    id v44 = 2082;
    __int16 v45 = backtrace_string;
    _os_log_impl( &dword_181A5C000,  v23,  v26,  "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(backtrace_string);
  if (v22) {
    goto LABEL_35;
  }
LABEL_36:
}

        if (v10) {
          free(v10);
        }
        return 4294966394LL;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type[0];
      os_log_type_t v15 = os_log_type_enabled(v11, type[0]);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          uint32_t v34 = "before_frame_send_callback";
          __int16 v35 = 2082;
          *(void *)__int16 v36 = v9;
          uint64_t v13 = "%{public}s %{public}s id based hash table has not yet been created, failing connection, no backtrace";
          goto LABEL_31;
        }

        goto LABEL_33;
      }

      if (!v15)
      {
LABEL_23:
        free(backtrace_string);
        goto LABEL_33;
      }

      *(_DWORD *)buf = 136446722;
      uint32_t v34 = "before_frame_send_callback";
      __int16 v35 = 2082;
      *(void *)__int16 v36 = v9;
      *(_WORD *)&v36[8] = 2082;
      *(void *)&v36[10] = backtrace_string;
      char v16 = "%{public}s %{public}s id based hash table has not yet been created, failing connection, dumping backtrace:%{public}s";
      __int16 v17 = v11;
      BOOL v18 = v12;
      char v19 = 32;
LABEL_22:
      _os_log_impl(&dword_181A5C000, v17, v18, v16, buf, v19);
      goto LABEL_23;
    }

    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v34 = "before_frame_send_callback";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    __int16 v32 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      uint64_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v34 = "before_frame_send_callback";
      uint64_t v13 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      uint64_t v29 = type[0];
      uint64_t v30 = os_log_type_enabled(v28, type[0]);
      if (backtrace_string)
      {
        if (!v30) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446466;
        uint32_t v34 = "before_frame_send_callback";
        __int16 v35 = 2082;
        *(void *)__int16 v36 = backtrace_string;
        char v16 = "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s";
        __int16 v17 = v28;
        BOOL v18 = v29;
        char v19 = 22;
        goto LABEL_22;
      }

      if (!v30) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v34 = "before_frame_send_callback";
      uint64_t v13 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }

    else
    {
      uint64_t v28 = (os_log_s *)__nwlog_obj();
      uint64_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v34 = "before_frame_send_callback";
      uint64_t v13 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }

    uint64_t v21 = v28;
    uint64_t v22 = v29;
    os_log_type_t v23 = 12;
    goto LABEL_32;
  }

  if (!gLogDatapath) {
    return 0LL;
  }
  int v27 = (os_log_s *)__nwlog_obj();
  BOOL result = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    *(_DWORD *)buf = 136446210;
    uint32_t v34 = "before_frame_send_callback";
    _os_log_impl(&dword_181A5C000, v27, OS_LOG_TYPE_DEBUG, "%{public}s ignoring frame on stream 0", buf, 0xCu);
    return 0LL;
  }

  return result;
}

    if (v15) {
      goto LABEL_34;
    }
LABEL_35:
    uint64_t v22 = 0LL;
LABEL_36:
    v10 += v12 + 5;
    if (v10 > v6)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v162 = (id)gLogObj;
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_proxy_config_create_with_agent_data_extended";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v10;
      *(_WORD *)&buf[28] = 2048;
      *(void *)&buf[30] = v6;
      v163 = (void *)_os_log_send_and_compose_impl();

      v245[0] = 16;
      v244 = 0;
      if (__nwlog_fault((const char *)v163, v245, &v244))
      {
        if (v245[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v164 = (os_log_s *)(id)gLogObj;
          v165 = v245[0];
          if (os_log_type_enabled(v164, (os_log_type_t)v245[0]))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_proxy_config_create_with_agent_data_extended";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v12;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v10;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v6;
            _os_log_impl( &dword_181A5C000,  v164,  v165,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu)",  buf,  0x26u);
          }
        }

        else if (v244)
        {
          v169 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v164 = (os_log_s *)(id)gLogObj;
          v170 = v245[0];
          v171 = os_log_type_enabled(v164, (os_log_type_t)v245[0]);
          if (v169)
          {
            if (v171)
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_proxy_config_create_with_agent_data_extended";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v12;
              *(_WORD *)&buf[18] = 2048;
              *(void *)&buf[20] = v10;
              *(_WORD *)&buf[28] = 2048;
              *(void *)&buf[30] = v6;
              *(_WORD *)&buf[38] = 2082;
              *(void *)&buf[40] = v169;
              _os_log_impl( &dword_181A5C000,  v164,  v170,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), dumping backtrace:%{public}s",  buf,  0x30u);
            }

            free(v169);
            if (!v163) {
              break;
            }
LABEL_426:
            free(v163);
            break;
          }

          if (v171)
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_proxy_config_create_with_agent_data_extended";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v12;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v10;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v6;
            _os_log_impl( &dword_181A5C000,  v164,  v170,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), no backtrace",  buf,  0x26u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v164 = (os_log_s *)(id)gLogObj;
          v174 = v245[0];
          if (os_log_type_enabled(v164, (os_log_type_t)v245[0]))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_proxy_config_create_with_agent_data_extended";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v12;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v10;
            *(_WORD *)&buf[28] = 2048;
            *(void *)&buf[30] = v6;
            _os_log_impl( &dword_181A5C000,  v164,  v174,  "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), backtrace limit exceeded",  buf,  0x26u);
          }
        }
      }

      if (!v163) {
        break;
      }
      goto LABEL_426;
    }

    if ((_DWORD)v12) {
      unsigned int v24 = v22 == 0LL;
    }
    else {
      unsigned int v24 = 1;
    }
    if (v24) {
      continue;
    }
    switch(v11)
    {
      case 1:
        __int16 v45 = nw_path_copy_endpoint_from_tlv(1, v12, v22);

        v234 = v45;
        continue;
      case 2:
      case 3:
      case 10:
        if (!__s1) {
          goto LABEL_146;
        }
        if (stack)
        {
          if ((v223 & 1) != 0) {
            goto LABEL_145;
          }
        }

        else
        {
          stack = v225;
          if ((v223 & 1) != 0) {
            goto LABEL_145;
          }
        }

        if (v235) {
          nw_dictionary_set_value(v235[1], __s1, stack);
        }
        else {
          v235 = nw_proxy_config_create_with_stack_internal(v234, stack, __s1);
        }
        if (!strcmp(__s1, (const char *)nw_proxy_config_default_transport(void)::default_transport_string))
        {
          BOOL v69 = stack;

          v225 = v69;
        }

  if (v4) {
LABEL_34:
  }
    free(v4);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v2) {
LABEL_34:
  }
    free(v2);
}

  if (v8) {
LABEL_34:
  }
    free(v8);
}

        uint64_t v13 = 1;
        char v16 = 6;
        uint64_t v22 = *(void **)(v8 + 232);
        if (v22)
        {
LABEL_23:
          if (((nw_endpoint_is_equal(v22, *(void **)(a1 + 32), 0LL) | is_equal) & 1) == 0)
          {
            if (!v13)
            {
              os_log_type_t v23 = (os_log_s *)__nwlog_obj();
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
                goto LABEL_4;
              }
              unsigned int v24 = *(void *)(a1 + 32);
              uint64_t v29 = 136446466;
              uint64_t v30 = "nw_replicate_metadata_add_endpoint_on_queue_block_invoke";
              char v31 = 2112;
              __int16 v32 = v24;
              os_log_type_t v25 = "%{public}s Will not add endpoint %@ for replication, no room for more endpoints";
LABEL_37:
              _os_log_impl(&dword_181A5C000, v23, OS_LOG_TYPE_ERROR, v25, (uint8_t *)&v29, 0x16u);
              goto LABEL_4;
            }

            goto LABEL_39;
          }

          goto LABEL_35;
        }

  if (v4) {
LABEL_34:
  }
    free(v4);
}

  unsigned int v11 = v12;
  if (v14) {
    free(v14);
  }
  os_log_type_t v8 = 0LL;
LABEL_52:
  objc_msgSend(v1, "reply", v37, v38);
  __int16 v35 = (void *)objc_claimAutoreleasedReturnValue();
  xpc_dictionary_set_uint64(v35, (const char *)networkd_privileged_key_opportunistic_inuse, v8);

  return v11;
}

  uint64_t v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_51:

  return v4;
}

  uint64_t v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_51:

  return v4;
}

      *a2 = v4 >> 1;
      return (BOOL)v5;
    }

    __nwlog_obj();
    uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    char v31 = "strict_calloc";
    __int16 v32 = 2048;
    id v33 = 1LL;
    uint32_t v34 = 2048;
    __int16 v35 = v4 >> 1;
    os_log_type_t v23 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v23);
    if (!result)
    {
      free(v23);
      if (v4) {
        goto LABEL_6;
      }
      goto LABEL_33;
    }

    goto LABEL_58;
  }

  __nwlog_obj();
  BOOL v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  char v31 = "nw_utilities_convert_hex_string_to_bytes";
  int v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v28 = 0;
  if (__nwlog_fault(v14, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "nw_utilities_convert_hex_string_to_bytes";
        __int16 v17 = "%{public}s called with null output_buffer_length";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (!v28)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      char v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "nw_utilities_convert_hex_string_to_bytes";
        __int16 v17 = "%{public}s called with null output_buffer_length, backtrace limit exceeded";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    char v16 = type;
    int v27 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        char v31 = "nw_utilities_convert_hex_string_to_bytes";
        __int16 v17 = "%{public}s called with null output_buffer_length, no backtrace";
        goto LABEL_53;
      }

      goto LABEL_54;
    }

    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      char v31 = "nw_utilities_convert_hex_string_to_bytes";
      __int16 v32 = 2082;
      id v33 = (uint64_t)backtrace_string;
      uint64_t v26 = "%{public}s called with null output_buffer_length, dumping backtrace:%{public}s";
      goto LABEL_43;
    }

    goto LABEL_44;
  }

    goto LABEL_34;
  }

  if (v8)
  {
    objc_storeStrong(v7 + 1, a2);
    *((_BYTE *)v7 + 16) = 1;
    goto LABEL_4;
  }

  __nwlog_obj();
  char v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  unsigned int v24 = "nw_dns_cache_storage_canvas_store";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v21 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    int v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_dns_cache_storage_canvas_store";
      os_log_type_t v15 = "%{public}s called with null item";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (!v21)
  {
    __nwlog_obj();
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    int v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_dns_cache_storage_canvas_store";
      os_log_type_t v15 = "%{public}s called with null item, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  char v19 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  int v14 = type;
  dispatch_data_t v20 = os_log_type_enabled(v13, type);
  if (!v19)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_dns_cache_storage_canvas_store";
      os_log_type_t v15 = "%{public}s called with null item, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    unsigned int v24 = "nw_dns_cache_storage_canvas_store";
    os_log_type_t v25 = 2082;
    uint64_t v26 = v19;
    _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null item, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v19);
  if (v12) {
    goto LABEL_35;
  }
LABEL_4:
}

    goto LABEL_34;
  }

  if (v8)
  {
    unsigned int v11 = nw_array_get_object_at_index((uint64_t)v8, 0LL);
    os_log_type_t v12 = (void *)v7[1];
    v7[1] = v11;

    uint64_t v13 = nw_array_get_object_at_index((uint64_t)v8, 1uLL);
    int v14 = (void *)v7[2];
    v7[2] = v13;

    os_log_type_t v15 = nw_array_get_object_at_index((uint64_t)v8, 2uLL);
    char v16 = (void *)v7[3];
    v7[3] = v15;

    *((_BYTE *)v7 + 32) = 1;
    goto LABEL_4;
  }

  __nwlog_obj();
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v30 = "nw_h3_0rtt_storage_canvas_store";
  BOOL v18 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  int v27 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    dispatch_data_t v20 = type;
    if (os_log_type_enabled(v19, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_h3_0rtt_storage_canvas_store";
      uint64_t v21 = "%{public}s called with null item";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (!v27)
  {
    __nwlog_obj();
    char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    dispatch_data_t v20 = type;
    if (os_log_type_enabled(v19, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_h3_0rtt_storage_canvas_store";
      uint64_t v21 = "%{public}s called with null item, backtrace limit exceeded";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  os_log_type_t v25 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  dispatch_data_t v20 = type;
  uint64_t v26 = os_log_type_enabled(v19, type);
  if (!v25)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_h3_0rtt_storage_canvas_store";
      uint64_t v21 = "%{public}s called with null item, no backtrace";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (v26)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v30 = "nw_h3_0rtt_storage_canvas_store";
    char v31 = 2082;
    __int16 v32 = v25;
    _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null item, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v25);
  if (v18) {
    goto LABEL_35;
  }
LABEL_4:
}

        free(v20);
        goto LABEL_34;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_url_log::onceToken != -1) {
        dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
      }
      uint64_t v21 = (os_log_s *)(id)gurlLogObj;
      uint64_t v22 = v91;
      __int16 v32 = os_log_type_enabled(v21, v91);
      if (!backtrace_string)
      {
        if (!v32) {
          goto LABEL_65;
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
        v95 = 1024;
        *(_DWORD *)v96 = v18;
        os_log_type_t v23 = "%{public}s SecTrustCopyPolicies failed %d, no backtrace";
        goto LABEL_64;
      }

      if (v32)
      {
        *(_DWORD *)buf = 136446722;
        uint64_t v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
        v95 = 1024;
        *(_DWORD *)v96 = v18;
        *(_WORD *)&v96[4] = 2082;
        *(void *)&v96[6] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s SecTrustCopyPolicies failed %d, dumping backtrace:%{public}s",  buf,  0x1Cu);
      }

      free(backtrace_string);
    }

    if (!v20) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }

  unsigned int v24 = policies;
  if (-[__CFArray count](policies, "count") != 1)
  {
    os_log_type_t v78 = v8;
    if (__nwlog_url_log::onceToken != -1) {
      dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
    }
    os_log_type_t v40 = (id)gurlLogObj;
    BOOL v41 = -[__CFArray count](v24, "count");
    *(_DWORD *)buf = 136446466;
    uint64_t v94 = "-[NWURLSessionTask loaderDidReceiveServerTrustChallenge:secProtocolMetadata:completionHandler:]";
    v95 = 2048;
    *(void *)v96 = v41;
    LODWORD(v77) = 22;
    os_log_type_t v76 = buf;
    os_log_type_t v42 = (void *)_os_log_send_and_compose_impl();

    v91 = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (!__nwlog_fault((const char *)v42, &v91, &v90))
    {
LABEL_81:
      if (!v42)
      {
LABEL_83:
        os_log_type_t v8 = v78;
        goto LABEL_128;
      }

    _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    goto LABEL_34;
  }

  if (a2)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0)
    {
      if (g_channel_set_flow_handler) {
        g_channel_set_flow_handler(a1, a2);
      }
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v13 = "nw_frame_set_flow_id";
  id v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v10 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    uint64_t v4 = type;
    if (!os_log_type_enabled(v3, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_frame_set_flow_id";
    int v5 = "%{public}s called with null flow_id";
    goto LABEL_33;
  }

  if (!v10)
  {
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    uint64_t v4 = type;
    if (!os_log_type_enabled(v3, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_frame_set_flow_id";
    int v5 = "%{public}s called with null flow_id, backtrace limit exceeded";
    goto LABEL_33;
  }

  os_log_type_t v8 = (char *)__nw_create_backtrace_string();
  uint64_t v3 = (os_log_s *)__nwlog_obj();
  uint64_t v4 = type;
  uint64_t v9 = os_log_type_enabled(v3, type);
  if (!v8)
  {
    if (!v9) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v13 = "nw_frame_set_flow_id";
    int v5 = "%{public}s called with null flow_id, no backtrace";
    goto LABEL_33;
  }

  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v13 = "nw_frame_set_flow_id";
    int v14 = 2082;
    os_log_type_t v15 = v8;
    _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null flow_id, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v8);
  if (v2) {
LABEL_35:
  }
    free(v2);
}

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }

  if (a2)
  {
    id v2 = *(unsigned __int16 *)(a1 + 204);
    uint64_t v3 = v2 | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v2 & 8) == 0)
    {
      *(_OWORD *)(a1 + 136) = *a2;
      *(_BYTE *)(a1 + 206) = BYTE2(v3);
      *(_WORD *)(a1 + 204) = v3 | 0x20;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "__nw_frame_set_packet_id";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "__nw_frame_set_packet_id";
    qos_class_t v7 = "%{public}s called with null packet_id";
    goto LABEL_33;
  }

  if (!v12)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "__nw_frame_set_packet_id";
    qos_class_t v7 = "%{public}s called with null packet_id, backtrace limit exceeded";
    goto LABEL_33;
  }

  uint64_t v10 = (char *)__nw_create_backtrace_string();
  int v5 = (os_log_s *)__nwlog_obj();
  nw_endpoint_t v6 = type;
  unsigned int v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "__nw_frame_set_packet_id";
    qos_class_t v7 = "%{public}s called with null packet_id, no backtrace";
    goto LABEL_33;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v15 = "__nw_frame_set_packet_id";
    char v16 = 2082;
    __int16 v17 = v10;
    _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null packet_id, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v10);
  if (v4) {
    goto LABEL_35;
  }
}
}

      if (v11) {
        free(v11);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)gLogObj;
    uint64_t v13 = type;
    char v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v34 = "nw_protocol_common_get_parameters";
        int v14 = "%{public}s get_parameters requires a default input handler, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }

    *(_DWORD *)buf = 136446466;
    uint32_t v34 = "nw_protocol_common_get_parameters";
    __int16 v35 = 2082;
    __int16 v36 = backtrace_string;
    __int16 v17 = "%{public}s get_parameters requires a default input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }

  id v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v3 = *(void *)(v1 + 88);
    if (v3) {
      *(void *)(v1 + 88) = v3 + 1;
    }
  }

  uint64_t v4 = *(void *)(v1 + 24);
  if (v4)
  {
    int v5 = *(uint64_t (**)(uint64_t))(v4 + 112);
    if (v5)
    {
      nw_endpoint_t v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle) {
        return v6;
      }
      goto LABEL_9;
    }
  }

  __nwlog_obj();
  char v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  uint32_t v34 = "__nw_protocol_get_parameters";
  if (!v19) {
    char v19 = "invalid";
  }
  __int16 v35 = 2082;
  __int16 v36 = (void *)v19;
  __int16 v37 = 2048;
  os_log_type_t v38 = v1;
  dispatch_data_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    os_log_type_t v23 = *(const char **)(v1 + 16);
    if (!v23) {
      os_log_type_t v23 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_parameters";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v23;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_70:
    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }

  if (!v31)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    uint64_t v29 = *(const char **)(v1 + 16);
    if (!v29) {
      uint64_t v29 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_parameters";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v29;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
    goto LABEL_70;
  }

  os_log_type_t v25 = (char *)__nw_create_backtrace_string();
  uint64_t v21 = (os_log_s *)__nwlog_obj();
  uint64_t v22 = type;
  uint64_t v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26) {
      goto LABEL_71;
    }
    uint64_t v30 = *(const char **)(v1 + 16);
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_parameters";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v30;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
    goto LABEL_70;
  }

  if (v26)
  {
    int v27 = *(const char **)(v1 + 16);
    if (!v27) {
      int v27 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    uint32_t v34 = "__nw_protocol_get_parameters";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v27;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    __int16 v39 = 2082;
    os_log_type_t v40 = v25;
    _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v25);
LABEL_71:
  if (v20) {
    free(v20);
  }
  nw_endpoint_t v6 = 0LL;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      qos_class_t v7 = *(void *)(v1 + 88);
      if (v7)
      {
        os_log_type_t v8 = v7 - 1;
        *(void *)(v1 + 88) = v8;
        if (!v8)
        {
          uint64_t v9 = *(void (***)(void))(v1 + 64);
          if (v9)
          {
            *(void *)(v1 + 64) = 0LL;
            v9[2](v9);
            _Block_release(v9);
          }

          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            uint64_t v10 = *(const void **)(v1 + 64);
            if (v10) {
              _Block_release(v10);
            }
          }

          free((void *)v1);
        }
      }
    }
  }

  return v6;
}

      if (v11) {
        free(v11);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)gLogObj;
    uint64_t v13 = type;
    char v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v34 = "nw_protocol_common_get_path";
        int v14 = "%{public}s get_path requires a default input handler, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }

    *(_DWORD *)buf = 136446466;
    uint32_t v34 = "nw_protocol_common_get_path";
    __int16 v35 = 2082;
    __int16 v36 = backtrace_string;
    __int16 v17 = "%{public}s get_path requires a default input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }

  id v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v3 = *(void *)(v1 + 88);
    if (v3) {
      *(void *)(v1 + 88) = v3 + 1;
    }
  }

  uint64_t v4 = *(void *)(v1 + 24);
  if (v4)
  {
    int v5 = *(uint64_t (**)(uint64_t))(v4 + 120);
    if (v5)
    {
      nw_endpoint_t v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle) {
        return v6;
      }
      goto LABEL_9;
    }
  }

  __nwlog_obj();
  char v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  uint32_t v34 = "__nw_protocol_get_path";
  if (!v19) {
    char v19 = "invalid";
  }
  __int16 v35 = 2082;
  __int16 v36 = (void *)v19;
  __int16 v37 = 2048;
  os_log_type_t v38 = v1;
  dispatch_data_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    os_log_type_t v23 = *(const char **)(v1 + 16);
    if (!v23) {
      os_log_type_t v23 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_path";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v23;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_path callback";
LABEL_70:
    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }

  if (!v31)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    uint64_t v29 = *(const char **)(v1 + 16);
    if (!v29) {
      uint64_t v29 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_path";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v29;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, backtrace limit exceeded";
    goto LABEL_70;
  }

  os_log_type_t v25 = (char *)__nw_create_backtrace_string();
  uint64_t v21 = (os_log_s *)__nwlog_obj();
  uint64_t v22 = type;
  uint64_t v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26) {
      goto LABEL_71;
    }
    uint64_t v30 = *(const char **)(v1 + 16);
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_path";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v30;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, no backtrace";
    goto LABEL_70;
  }

  if (v26)
  {
    int v27 = *(const char **)(v1 + 16);
    if (!v27) {
      int v27 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    uint32_t v34 = "__nw_protocol_get_path";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v27;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    __int16 v39 = 2082;
    os_log_type_t v40 = v25;
    _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid get_path callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v25);
LABEL_71:
  if (v20) {
    free(v20);
  }
  nw_endpoint_t v6 = 0LL;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      qos_class_t v7 = *(void *)(v1 + 88);
      if (v7)
      {
        os_log_type_t v8 = v7 - 1;
        *(void *)(v1 + 88) = v8;
        if (!v8)
        {
          uint64_t v9 = *(void (***)(void))(v1 + 64);
          if (v9)
          {
            *(void *)(v1 + 64) = 0LL;
            v9[2](v9);
            _Block_release(v9);
          }

          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            uint64_t v10 = *(const void **)(v1 + 64);
            if (v10) {
              _Block_release(v10);
            }
          }

          free((void *)v1);
        }
      }
    }
  }

  return v6;
}

      if (v11) {
        free(v11);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)gLogObj;
    uint64_t v13 = type;
    char v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v34 = "nw_protocol_common_get_remote_endpoint";
        int v14 = "%{public}s get_remote_endpoint requires a default input handler, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }

    *(_DWORD *)buf = 136446466;
    uint32_t v34 = "nw_protocol_common_get_remote_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = backtrace_string;
    __int16 v17 = "%{public}s get_remote_endpoint requires a default input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }

  id v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v3 = *(void *)(v1 + 88);
    if (v3) {
      *(void *)(v1 + 88) = v3 + 1;
    }
  }

  uint64_t v4 = *(void *)(v1 + 24);
  if (v4)
  {
    int v5 = *(uint64_t (**)(uint64_t))(v4 + 136);
    if (v5)
    {
      nw_endpoint_t v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle) {
        return v6;
      }
      goto LABEL_9;
    }
  }

  __nwlog_obj();
  char v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  uint32_t v34 = "__nw_protocol_get_remote_endpoint";
  if (!v19) {
    char v19 = "invalid";
  }
  __int16 v35 = 2082;
  __int16 v36 = (void *)v19;
  __int16 v37 = 2048;
  os_log_type_t v38 = v1;
  dispatch_data_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    os_log_type_t v23 = *(const char **)(v1 + 16);
    if (!v23) {
      os_log_type_t v23 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_remote_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v23;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback";
LABEL_70:
    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }

  if (!v31)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    uint64_t v29 = *(const char **)(v1 + 16);
    if (!v29) {
      uint64_t v29 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_remote_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v29;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded";
    goto LABEL_70;
  }

  os_log_type_t v25 = (char *)__nw_create_backtrace_string();
  uint64_t v21 = (os_log_s *)__nwlog_obj();
  uint64_t v22 = type;
  uint64_t v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26) {
      goto LABEL_71;
    }
    uint64_t v30 = *(const char **)(v1 + 16);
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_remote_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v30;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace";
    goto LABEL_70;
  }

  if (v26)
  {
    int v27 = *(const char **)(v1 + 16);
    if (!v27) {
      int v27 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    uint32_t v34 = "__nw_protocol_get_remote_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v27;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    __int16 v39 = 2082;
    os_log_type_t v40 = v25;
    _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v25);
LABEL_71:
  if (v20) {
    free(v20);
  }
  nw_endpoint_t v6 = 0LL;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      qos_class_t v7 = *(void *)(v1 + 88);
      if (v7)
      {
        os_log_type_t v8 = v7 - 1;
        *(void *)(v1 + 88) = v8;
        if (!v8)
        {
          uint64_t v9 = *(void (***)(void))(v1 + 64);
          if (v9)
          {
            *(void *)(v1 + 64) = 0LL;
            v9[2](v9);
            _Block_release(v9);
          }

          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            uint64_t v10 = *(const void **)(v1 + 64);
            if (v10) {
              _Block_release(v10);
            }
          }

          free((void *)v1);
        }
      }
    }
  }

  return v6;
}

      if (v11) {
        free(v11);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)gLogObj;
    uint64_t v13 = type;
    char v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v34 = "nw_protocol_common_get_local_endpoint";
        int v14 = "%{public}s get_local_endpoint requires a default input handler, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }

    *(_DWORD *)buf = 136446466;
    uint32_t v34 = "nw_protocol_common_get_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = backtrace_string;
    __int16 v17 = "%{public}s get_local_endpoint requires a default input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }

  id v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v3 = *(void *)(v1 + 88);
    if (v3) {
      *(void *)(v1 + 88) = v3 + 1;
    }
  }

  uint64_t v4 = *(void *)(v1 + 24);
  if (v4)
  {
    int v5 = *(uint64_t (**)(uint64_t))(v4 + 128);
    if (v5)
    {
      nw_endpoint_t v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle) {
        return v6;
      }
      goto LABEL_9;
    }
  }

  __nwlog_obj();
  char v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  uint32_t v34 = "__nw_protocol_get_local_endpoint";
  if (!v19) {
    char v19 = "invalid";
  }
  __int16 v35 = 2082;
  __int16 v36 = (void *)v19;
  __int16 v37 = 2048;
  os_log_type_t v38 = v1;
  dispatch_data_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    os_log_type_t v23 = *(const char **)(v1 + 16);
    if (!v23) {
      os_log_type_t v23 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v23;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback";
LABEL_70:
    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }

  if (!v31)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    uint64_t v29 = *(const char **)(v1 + 16);
    if (!v29) {
      uint64_t v29 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v29;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, backtrace limit exceeded";
    goto LABEL_70;
  }

  os_log_type_t v25 = (char *)__nw_create_backtrace_string();
  uint64_t v21 = (os_log_s *)__nwlog_obj();
  uint64_t v22 = type;
  uint64_t v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26) {
      goto LABEL_71;
    }
    uint64_t v30 = *(const char **)(v1 + 16);
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v30;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, no backtrace";
    goto LABEL_70;
  }

  if (v26)
  {
    int v27 = *(const char **)(v1 + 16);
    if (!v27) {
      int v27 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    uint32_t v34 = "__nw_protocol_get_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v27;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    __int16 v39 = 2082;
    os_log_type_t v40 = v25;
    _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v25);
LABEL_71:
  if (v20) {
    free(v20);
  }
  nw_endpoint_t v6 = 0LL;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      qos_class_t v7 = *(void *)(v1 + 88);
      if (v7)
      {
        os_log_type_t v8 = v7 - 1;
        *(void *)(v1 + 88) = v8;
        if (!v8)
        {
          uint64_t v9 = *(void (***)(void))(v1 + 64);
          if (v9)
          {
            *(void *)(v1 + 64) = 0LL;
            v9[2](v9);
            _Block_release(v9);
          }

          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            uint64_t v10 = *(const void **)(v1 + 64);
            if (v10) {
              _Block_release(v10);
            }
          }

          free((void *)v1);
        }
      }
    }
  }

  return v6;
}

      if (v11) {
        free(v11);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)gLogObj;
    uint64_t v13 = type;
    char v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v34 = "nw_protocol_common_get_output_local_endpoint";
        int v14 = "%{public}s get_output_local_endpoint requires an output handler, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }

    *(_DWORD *)buf = 136446466;
    uint32_t v34 = "nw_protocol_common_get_output_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = backtrace_string;
    __int16 v17 = "%{public}s get_output_local_endpoint requires an output handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }

  id v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v3 = *(void *)(v1 + 88);
    if (v3) {
      *(void *)(v1 + 88) = v3 + 1;
    }
  }

  uint64_t v4 = *(void *)(v1 + 24);
  if (v4)
  {
    int v5 = *(uint64_t (**)(uint64_t))(v4 + 200);
    if (v5)
    {
      nw_endpoint_t v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle) {
        return v6;
      }
      goto LABEL_9;
    }
  }

  __nwlog_obj();
  char v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  uint32_t v34 = "__nw_protocol_get_output_local_endpoint";
  if (!v19) {
    char v19 = "invalid";
  }
  __int16 v35 = 2082;
  __int16 v36 = (void *)v19;
  __int16 v37 = 2048;
  os_log_type_t v38 = v1;
  dispatch_data_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    os_log_type_t v23 = *(const char **)(v1 + 16);
    if (!v23) {
      os_log_type_t v23 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_output_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v23;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback";
LABEL_70:
    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }

  if (!v31)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    uint64_t v29 = *(const char **)(v1 + 16);
    if (!v29) {
      uint64_t v29 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_output_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v29;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, backtrace limit exceeded";
    goto LABEL_70;
  }

  os_log_type_t v25 = (char *)__nw_create_backtrace_string();
  uint64_t v21 = (os_log_s *)__nwlog_obj();
  uint64_t v22 = type;
  uint64_t v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26) {
      goto LABEL_71;
    }
    uint64_t v30 = *(const char **)(v1 + 16);
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_output_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v30;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, no backtrace";
    goto LABEL_70;
  }

  if (v26)
  {
    int v27 = *(const char **)(v1 + 16);
    if (!v27) {
      int v27 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    uint32_t v34 = "__nw_protocol_get_output_local_endpoint";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v27;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    __int16 v39 = 2082;
    os_log_type_t v40 = v25;
    _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v25);
LABEL_71:
  if (v20) {
    free(v20);
  }
  nw_endpoint_t v6 = 0LL;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      qos_class_t v7 = *(void *)(v1 + 88);
      if (v7)
      {
        os_log_type_t v8 = v7 - 1;
        *(void *)(v1 + 88) = v8;
        if (!v8)
        {
          uint64_t v9 = *(void (***)(void))(v1 + 64);
          if (v9)
          {
            *(void *)(v1 + 64) = 0LL;
            v9[2](v9);
            _Block_release(v9);
          }

          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            uint64_t v10 = *(const void **)(v1 + 64);
            if (v10) {
              _Block_release(v10);
            }
          }

          free((void *)v1);
        }
      }
    }
  }

  return v6;
}

      if (v11) {
        free(v11);
      }
      return 0LL;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (os_log_s *)gLogObj;
    uint64_t v13 = type;
    char v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v34 = "nw_protocol_common_get_output_interface";
        int v14 = "%{public}s get_output_interface requires an output handler, no backtrace";
        goto LABEL_32;
      }

      goto LABEL_33;
    }

    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }

    *(_DWORD *)buf = 136446466;
    uint32_t v34 = "nw_protocol_common_get_output_interface";
    __int16 v35 = 2082;
    __int16 v36 = backtrace_string;
    __int16 v17 = "%{public}s get_output_interface requires an output handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_181A5C000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }

  id v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v3 = *(void *)(v1 + 88);
    if (v3) {
      *(void *)(v1 + 88) = v3 + 1;
    }
  }

  uint64_t v4 = *(void *)(v1 + 24);
  if (v4)
  {
    int v5 = *(uint64_t (**)(uint64_t))(v4 + 208);
    if (v5)
    {
      nw_endpoint_t v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle) {
        return v6;
      }
      goto LABEL_9;
    }
  }

  __nwlog_obj();
  char v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  uint32_t v34 = "__nw_protocol_get_output_interface";
  if (!v19) {
    char v19 = "invalid";
  }
  __int16 v35 = 2082;
  __int16 v36 = (void *)v19;
  __int16 v37 = 2048;
  os_log_type_t v38 = v1;
  dispatch_data_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    os_log_type_t v23 = *(const char **)(v1 + 16);
    if (!v23) {
      os_log_type_t v23 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_output_interface";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v23;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback";
LABEL_70:
    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }

  if (!v31)
  {
    uint64_t v21 = (os_log_s *)__nwlog_obj();
    uint64_t v22 = type;
    if (!os_log_type_enabled(v21, type)) {
      goto LABEL_71;
    }
    uint64_t v29 = *(const char **)(v1 + 16);
    if (!v29) {
      uint64_t v29 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_output_interface";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v29;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, backtrace limit exceeded";
    goto LABEL_70;
  }

  os_log_type_t v25 = (char *)__nw_create_backtrace_string();
  uint64_t v21 = (os_log_s *)__nwlog_obj();
  uint64_t v22 = type;
  uint64_t v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26) {
      goto LABEL_71;
    }
    uint64_t v30 = *(const char **)(v1 + 16);
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    uint32_t v34 = "__nw_protocol_get_output_interface";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v30;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    unsigned int v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, no backtrace";
    goto LABEL_70;
  }

  if (v26)
  {
    int v27 = *(const char **)(v1 + 16);
    if (!v27) {
      int v27 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    uint32_t v34 = "__nw_protocol_get_output_interface";
    __int16 v35 = 2082;
    __int16 v36 = (void *)v27;
    __int16 v37 = 2048;
    os_log_type_t v38 = v1;
    __int16 v39 = 2082;
    os_log_type_t v40 = v25;
    _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, dumping backtrace:%{public}s",  buf,  0x2Au);
  }

  free(v25);
LABEL_71:
  if (v20) {
    free(v20);
  }
  nw_endpoint_t v6 = 0LL;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      qos_class_t v7 = *(void *)(v1 + 88);
      if (v7)
      {
        os_log_type_t v8 = v7 - 1;
        *(void *)(v1 + 88) = v8;
        if (!v8)
        {
          uint64_t v9 = *(void (***)(void))(v1 + 64);
          if (v9)
          {
            *(void *)(v1 + 64) = 0LL;
            v9[2](v9);
            _Block_release(v9);
          }

          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            uint64_t v10 = *(const void **)(v1 + 64);
            if (v10) {
              _Block_release(v10);
            }
          }

          free((void *)v1);
        }
      }
    }
  }

  return v6;
}

          free(backtrace_string);
          if (!v3) {
            return;
          }
          goto LABEL_49;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnect";
          char v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnect";
          char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

          free(backtrace_string);
          if (!v3) {
            return;
          }
          goto LABEL_49;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnected";
          char v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_disconnected";
          char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

          free(backtrace_string);
          if (!v3) {
            return;
          }
          goto LABEL_49;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_available";
          char v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_available";
          char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

          free(backtrace_string);
          if (!v3) {
            return;
          }
          goto LABEL_49;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_available";
          char v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_available";
          char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

          free(backtrace_string);
          if (!v3) {
            return;
          }
          goto LABEL_49;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_finished";
          char v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_finished";
          char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

          free(backtrace_string);
          if (!v3) {
            return;
          }
          goto LABEL_49;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_finished";
          char v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_output_finished";
          char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

          free(backtrace_string);
          if (!v3) {
            return;
          }
          goto LABEL_49;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_flush";
          char v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_input_flush";
          char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

          free(backtrace_string);
          if (!v3) {
            return;
          }
          goto LABEL_49;
        }

        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_error";
          char v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }

      else
      {
        int v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v40 = "nw_protocol_common_error";
          char v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }

            goto LABEL_18;
          }

          v7[v65++] = *(_OWORD *)v76;
        }

        else if (v67 == -1442840384)
        {
          if (v9 >= v5)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v18 = (os_log_s *)(id)gLogObj;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              BOOL v69 = "nw_nat64_copy_prefixes_from_ipv4only_records";
              char v19 = v18;
              dispatch_data_t v20 = "%{public}s too many valid prefixes for WKA1";
              goto LABEL_32;
            }

            goto LABEL_33;
          }

          *(_OWORD *)&v6[16 * v9++] = *(_OWORD *)v76;
        }

    if (v27) {
      free(v27);
    }
    uint64_t v4 = 0LL;
    goto LABEL_14;
  }

  uint64_t v4 = (char *)calloc(1uLL, 0xE0uLL);
  if (v4)
  {
LABEL_3:
    objc_storeStrong((id *)v4 + 12, *(id *)(a2 + 96));
    *((_WORD *)v4 + 102) = *(_WORD *)(a2 + 204);
    *((_DWORD *)v4 + 48) = *(_DWORD *)(a2 + 192);
    *((_OWORD *)v4 + 2) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
    *((_OWORD *)v4 + 1) = *(_OWORD *)(a2 + 16);
    *((_OWORD *)v4 + 3) = *(_OWORD *)(a2 + 48);
    *((_OWORD *)v4 + 4) = *(_OWORD *)(a2 + 64);
    *((_OWORD *)v4 + 5) = *(_OWORD *)(a2 + 80);
    int v5 = *(const __CFArray **)(a2 + 104);
    nw_endpoint_t v6 = (CFAllocatorRef *)MEMORY[0x189604DB0];
    if (v5) {
      *((void *)v4 + 13) = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v5);
    }
    qos_class_t v7 = *(const void **)(a2 + 112);
    if (v7) {
      *((void *)v4 + 14) = CFRetain(v7);
    }
    os_log_type_t v8 = *(const __CFArray **)(a2 + 120);
    if (v8) {
      *((void *)v4 + 15) = CFArrayCreateCopy(*v6, v8);
    }
    uint64_t v9 = *(const void **)(a2 + 128);
    if (v9) {
      *((void *)v4 + 16) = CFRetain(v9);
    }
    objc_storeStrong((id *)v4 + 17, *(id *)(a2 + 136));
    objc_storeStrong((id *)v4 + 18, *(id *)(a2 + 144));
    uint64_t v10 = _Block_copy(*(const void **)(a2 + 160));
    unsigned int v11 = (void *)*((void *)v4 + 20);
    *((void *)v4 + 20) = v10;

    objc_storeStrong((id *)v4 + 21, *(id *)(a2 + 168));
    os_log_type_t v12 = _Block_copy(*(const void **)(a2 + 176));
    uint64_t v13 = (void *)*((void *)v4 + 22);
    *((void *)v4 + 22) = v12;

    objc_storeStrong((id *)v4 + 23, *(id *)(a2 + 184));
    int v14 = *(unsigned __int16 *)(v4 + 215);
    v4[214] = *(_BYTE *)(a2 + 214);
    os_log_type_t v15 = v14 & 0xFFFFFFFE | (v4[217] << 16) | *(_WORD *)(a2 + 215) & 1;
    *(_WORD *)(v4 + 215) = v15;
    char v16 = v15 & 0xFFFE7F11 | (*(unsigned __int16 *)(a2 + 215) | (*(unsigned __int8 *)(a2 + 217) << 16)) & 0x180EE;
    *(_WORD *)(v4 + 215) = v15 & 0x7F11 | *(_WORD *)(a2 + 215) & 0x80EE;
    __int16 v17 = HIWORD(v16);
    v4[217] = BYTE2(v16);
    BOOL v18 = *(_DWORD *)(a2 + 206);
    *((_WORD *)v4 + 105) = *(_WORD *)(a2 + 210);
    *(_DWORD *)(v4 + 206) = v18;
    LOWORD(v16) = *(_WORD *)(a2 + 215) & 0x10 | v16 & 0xFFEF;
    v4[217] = v17;
    *(_WORD *)(v4 + 215) = v16;
    v4[212] = *(_BYTE *)(a2 + 212);
    objc_storeStrong((id *)v4 + 19, *(id *)(a2 + 152));
    char v19 = *(unsigned __int16 *)(v4 + 215);
    dispatch_data_t v20 = v19 & 0xFFFFFCFF | (v4[217] << 16) | ((HIBYTE(*(unsigned __int16 *)(a2 + 215)) & 3) << 8);
    *(_WORD *)(v4 + 215) = v19 & 0xFCFF | ((HIBYTE(*(_WORD *)(a2 + 215)) & 3) << 8);
    *((_DWORD *)v4 + 50) = *(_DWORD *)(a2 + 200);
    *(_WORD *)(v4 + 215) = *(_WORD *)(a2 + 215) & 0x7800 | v20 & 0x87FF;
    uint64_t v21 = os_variant_allows_internal_security_policies();
    uint64_t v22 = *(unsigned __int16 *)(v4 + 215) | (v4[217] << 16);
    if (v21)
    {
      os_log_type_t v23 = HIWORD(v22);
      uint64_t v22 = *(_WORD *)(v4 + 215) & 0xFBFF | (v4[217] << 16) | (((*(unsigned __int16 *)(a2 + 215) >> 10) & 1) << 10);
      v4[217] = v23;
      *(_WORD *)(v4 + 215) = v22;
    }

    unsigned int v24 = *(unsigned __int8 *)(a2 + 217) >> 1;
    *(_WORD *)(v4 + 215) = v22;
    v4[217] = (v22 & 0xFFC1FFFF | ((v24 & 0x1F) << 17)) >> 16;
LABEL_14:

    return (BOOL)v4;
  }

  __nwlog_obj();
  uint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v39 = "strict_calloc";
  os_log_type_t v40 = 2048;
  BOOL v41 = 1LL;
  os_log_type_t v42 = 2048;
  int v43 = 224LL;
  char v31 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v31);
  if (!result)
  {
    free(v31);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

        if (Mutable) {
          CFRelease(Mutable);
        }
      }

      else
      {
        uint64_t v22 = v23;
      }
    }
  }

  if ((*(_WORD *)(a1[4] + 16LL) & 0x800) != 0)
  {
    __int16 v35 = v22 + 2;
    __int16 v36 = a1[5] + a1[6];
    if ((unint64_t)(v22 + 2) < v36)
    {
      __int16 v37 = *(unsigned __int16 *)v22;
      uint64_t v22 = &v35[v37];
      if ((unint64_t)&v35[v37] <= v36)
      {
        *(void *)(a2 + 128) = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v35, v37);
        goto LABEL_61;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v38 = (id)gLogObj;
      *(_DWORD *)buffer = 136446210;
      *(void *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
      __int16 v39 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v55 = 0;
      if (__nwlog_fault(v39, &type, &v55))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v40 = (os_log_s *)(id)gLogObj;
          BOOL v41 = type;
          if (os_log_type_enabled(v40, type))
          {
            *(_DWORD *)buffer = 136446210;
            *(void *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
            _os_log_impl(&dword_181A5C000, v40, v41, "%{public}s expected more bytes", buffer, 0xCu);
          }
        }

        else if (v55)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v40 = (os_log_s *)(id)gLogObj;
          int v43 = type;
          id v44 = os_log_type_enabled(v40, type);
          if (backtrace_string)
          {
            if (v44)
            {
              *(_DWORD *)buffer = 136446466;
              *(void *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
              *(_WORD *)&buffer[12] = 2082;
              *(void *)&buffer[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v40,  v43,  "%{public}s expected more bytes, dumping backtrace:%{public}s",  buffer,  0x16u);
            }

            free(backtrace_string);
            if (!v39) {
              goto LABEL_60;
            }
            goto LABEL_59;
          }

          if (v44)
          {
            *(_DWORD *)buffer = 136446210;
            *(void *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
            _os_log_impl(&dword_181A5C000, v40, v43, "%{public}s expected more bytes, no backtrace", buffer, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v40 = (os_log_s *)(id)gLogObj;
          __int16 v45 = type;
          if (os_log_type_enabled(v40, type))
          {
            *(_DWORD *)buffer = 136446210;
            *(void *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
            _os_log_impl( &dword_181A5C000,  v40,  v45,  "%{public}s expected more bytes, backtrace limit exceeded",  buffer,  0xCu);
          }
        }
      }

      if (!v39)
      {
LABEL_60:
        uint64_t v22 = (const UInt8 *)(a1[5] + a1[6]);
        goto LABEL_61;
      }

    if (v11) {
      free(v11);
    }
    goto LABEL_35;
  }

  if ((*((_BYTE *)v3 + 36) & 1) == 0)
  {
    __nwlog_obj();
    int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__dst = 136446210;
      *(void *)&__dst[4] = "nw_txt_record_remove_key";
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_ERROR,  "%{public}s txt_record is not of type dictionary",  __dst,  0xCu);
    }

    goto LABEL_18;
  }

  if ((nw_txt_record_key_is_valid((uint64_t)key) & 1) == 0)
  {
    __nwlog_obj();
    int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__dst = 136446210;
      *(void *)&__dst[4] = "nw_txt_record_remove_key";
      _os_log_impl(&dword_181A5C000, v14, OS_LOG_TYPE_ERROR, "%{public}s invalid key", __dst, 0xCu);
    }

    if (v9) {
      free(v9);
    }
    goto LABEL_5;
  }

  if ((*((_BYTE *)v1 + 36) & 1) == 0)
  {
    __nwlog_obj();
    os_log_type_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      dispatch_data_t v20 = "nw_txt_record_get_key_count";
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s txt_record is not of type dictionary",  buf,  0xCu);
    }

    goto LABEL_5;
  }

  os_unfair_lock_lock((os_unfair_lock_t)v1 + 8);
  uint64_t v3 = *((void *)v2 + 2);
  if (v3 == 1)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)v2 + 8);
LABEL_5:
    uint64_t v4 = 0LL;
    goto LABEL_13;
  }

  if (v3 >= 1)
  {
    uint64_t v4 = 0LL;
    int v5 = (unsigned __int8 *)*((void *)v2 + 1);
    nw_endpoint_t v6 = &v5[v3];
    while (1)
    {
      v5 += *v5 + 1;
      if (v5 > v6) {
        goto LABEL_5;
      }
      ++v4;
      if (v5 >= v6) {
        goto LABEL_12;
      }
    }
  }

  uint64_t v4 = 0LL;
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)v2 + 8);
LABEL_13:

  return v4;
}

    free(v7);
    goto LABEL_34;
  }

  if (nw_connection_get_symptom_reporter_handle::once != -1) {
    dispatch_once(&nw_connection_get_symptom_reporter_handle::once, &__block_literal_global_78285);
  }
  symptom_new();
  symptom_set_qualifier();
  symptom_set_additional_qualifier();
  symptom_send();
LABEL_39:
}

    free(v18);
    if (!v6) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }

  __nwlog_obj();
  os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v33 = "nw_protocol_transform_clear_protocols_at_level";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  uint64_t v30 = 0;
  if (__nwlog_fault(v6, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      qos_class_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v26 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v33 = "nw_protocol_transform_clear_protocols_at_level";
        _os_log_impl(&dword_181A5C000, v7, v26, "%{public}s called with null transform", buf, 0xCu);
      }
    }

    else if (v30)
    {
      BOOL v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      qos_class_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      int v27 = type;
      uint64_t v28 = os_log_type_enabled(v7, type);
      if (v18)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          id v33 = "nw_protocol_transform_clear_protocols_at_level";
          uint32_t v34 = 2082;
          *(void *)__int16 v35 = v18;
          _os_log_impl( &dword_181A5C000,  v7,  v27,  "%{public}s called with null transform, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        goto LABEL_33;
      }

      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        id v33 = "nw_protocol_transform_clear_protocols_at_level";
        _os_log_impl(&dword_181A5C000, v7, v27, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      qos_class_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      uint64_t v29 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v33 = "nw_protocol_transform_clear_protocols_at_level";
        _os_log_impl( &dword_181A5C000,  v7,  v29,  "%{public}s called with null transform, backtrace limit exceeded",  buf,  0xCu);
      }
    }

      os_release(v28);
      return 0LL;
    }
  }

  return result;
}

    if (v32) {
      free(v32);
    }
    return 0LL;
  }

  *(_DWORD *)(v8 + 24) = v9 + v7;
  int v27 = *(void *)(a1 + 56);
  *(void *)(a2 + 32) = 0LL;
  uint64_t v28 = *(uint64_t **)(v27 + 8);
  *(void *)(a2 + 40) = v28;
  *uint64_t v28 = a2;
  *(void *)(v27 + 8) = v6;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  uint64_t v29 = *(void *)(a1 + 48);
  BOOL result = 1LL;
  char v31 = *(void *)(v29 + 16) - v13;
  *(void *)(v29 + 16) = v31;
  if (v31) {
    return result;
  }
  **(_BYTE **)(a1 + 64) = 1;
  return 0LL;
}

  if (v3) {
    free(v3);
  }
  return 0LL;
}

    if (v7) {
      free(v7);
    }
    return 0LL;
  }

  offset = 0;
  nw_frame_set_external_data(a2, *(dispatch_data_t *)(*(void *)(a1[4] + 8LL) + 24LL), &offset);
  uint64_t v4 = *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL);
  int v5 = *(dispatch_data_s **)(*(void *)(a1[4] + 8LL) + 24LL);
  nw_endpoint_t v6 = offset < v4;
  if (offset < v4)
  {
    if (v5)
    {
      dispatch_release(*(dispatch_object_t *)(*(void *)(a1[4] + 8LL) + 24LL));
      *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = 0LL;
      *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = dispatch_data_create_subrange(v5, offset, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v5);
    }

    else
    {
      *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = dispatch_data_create_subrange(0LL, offset, 0xFFFFFFFFFFFFFFFFLL);
    }

    *(_DWORD *)(*(void *)(a1[5] + 8LL) + 24LL) -= offset;
    return v6;
  }

  if (v5)
  {
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1[4] + 8LL) + 24LL));
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = 0LL;
  }

  if (**(void **)(*(void *)(*(void *)(a1[6] + 8LL) + 48LL) + 8LL) != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_http3_stream_send_pending_capsules_block_invoke";
    unsigned int v11 = (char *)_os_log_send_and_compose_impl();
    offset_7 = OS_LOG_TYPE_ERROR;
    dispatch_data_t v20 = 0;
    if (offset_7 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_http3_stream_send_pending_capsules_block_invoke";
      int v14 = "%{public}s Too much space in capsule frames";
    }

    else if (v20)
    {
      __int16 v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, offset_7);
      if (v17)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v24 = "nw_http3_stream_send_pending_capsules_block_invoke";
          os_log_type_t v25 = 2082;
          uint64_t v26 = v17;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s Too much space in capsule frames, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v17);
        goto LABEL_42;
      }

      if (!v18)
      {
LABEL_42:
        if (v11) {
          free(v11);
        }
        return v6;
      }

      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_http3_stream_send_pending_capsules_block_invoke";
      int v14 = "%{public}s Too much space in capsule frames, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (os_log_s *)gLogObj;
      uint64_t v13 = offset_7;
      if (!os_log_type_enabled((os_log_t)gLogObj, offset_7)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      unsigned int v24 = "nw_http3_stream_send_pending_capsules_block_invoke";
      int v14 = "%{public}s Too much space in capsule frames, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
    goto LABEL_42;
  }

  return v6;
}

    char v16 = *(void *)(v13 + 24);
    if (v16)
    {
      __int16 v17 = *(void (**)(uint64_t, uint64_t))(v16 + 24);
      if (v17)
      {
        v17(v13, a1);
LABEL_36:
        nw_http3_control_stream_process_output(a1, v18);
        return;
      }
    }

    __nwlog_obj();
    char v31 = *(const char **)(v13 + 16);
    if (!v31) {
      char v31 = "invalid";
    }
LABEL_103:
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v31;
    uint64_t v49 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v62 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v50 = (os_log_s *)__nwlog_obj();
      uint64_t v51 = type[0];
      if (!os_log_type_enabled(v50, type[0])) {
        goto LABEL_129;
      }
      os_log_type_t v52 = "invalid";
      if (v13 && *(void *)(v13 + 16)) {
        os_log_type_t v52 = *(const char **)(v13 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v52;
      os_log_type_t v53 = "%{public}s protocol %{public}s has invalid connect callback";
    }

    else if (v62)
    {
      BOOL v54 = (char *)__nw_create_backtrace_string();
      os_log_type_t v50 = (os_log_s *)__nwlog_obj();
      uint64_t v51 = type[0];
      os_log_type_t v55 = os_log_type_enabled(v50, type[0]);
      if (v54)
      {
        if (v55)
        {
          v56 = "invalid";
          if (v13 && *(void *)(v13 + 16)) {
            v56 = *(const char **)(v13 + 16);
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v56;
          *(_WORD *)&buf[22] = 2082;
          os_log_type_t v64 = v54;
          _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v54);
        goto LABEL_129;
      }

      if (!v55)
      {
LABEL_129:
        if (v49) {
          free(v49);
        }
        goto LABEL_36;
      }

      BOOL v58 = "invalid";
      if (v13 && *(void *)(v13 + 16)) {
        BOOL v58 = *(const char **)(v13 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v58;
      os_log_type_t v53 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }

    else
    {
      os_log_type_t v50 = (os_log_s *)__nwlog_obj();
      uint64_t v51 = type[0];
      if (!os_log_type_enabled(v50, type[0])) {
        goto LABEL_129;
      }
      os_log_type_t v57 = "invalid";
      if (v13 && *(void *)(v13 + 16)) {
        os_log_type_t v57 = *(const char **)(v13 + 16);
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v57;
      os_log_type_t v53 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v50, v51, v53, buf, 0x16u);
    goto LABEL_129;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
  uint64_t v26 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v62 = 0;
  if (__nwlog_fault(v26, type, &v62))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v27 = (os_log_s *)__nwlog_obj();
      uint64_t v28 = type[0];
      if (!os_log_type_enabled(v27, type[0])) {
        goto LABEL_134;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      uint64_t v29 = "%{public}s called with null http3";
      goto LABEL_133;
    }

    if (!v62)
    {
      int v27 = (os_log_s *)__nwlog_obj();
      uint64_t v28 = type[0];
      if (!os_log_type_enabled(v27, type[0])) {
        goto LABEL_134;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      uint64_t v29 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_133;
    }

    __int16 v32 = (char *)__nw_create_backtrace_string();
    int v27 = (os_log_s *)__nwlog_obj();
    uint64_t v28 = type[0];
    id v33 = os_log_type_enabled(v27, type[0]);
    if (v32)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = v32;
        _os_log_impl( &dword_181A5C000,  v27,  v28,  "%{public}s called with null http3, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v32);
      goto LABEL_134;
    }

    if (v33)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http3_setup_connection_if_needed";
      uint64_t v29 = "%{public}s called with null http3, no backtrace";
LABEL_133:
      _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0xCu);
    }
  }

        free(v17);
        if (!v13) {
          return;
        }
LABEL_41:
        free(v13);
        return;
      }

      if (!v22)
      {
LABEL_40:
        if (!v13) {
          return;
        }
        goto LABEL_41;
      }

      *(_DWORD *)buf = 136446210;
      int v27 = "nw_protocol_http_early_data_connected";
      char v16 = "%{public}s called with null http_early_data, no backtrace";
    }

    else
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      int v27 = "nw_protocol_http_early_data_connected";
      char v16 = "%{public}s called with null http_early_data, backtrace limit exceeded";
    }

  if (v6) {
LABEL_34:
  }
    free(v6);
  return 0LL;
}

  if (!setsockopt(*(_DWORD *)(a1 + 172), 0xFFFF, 4099, &v34, 4u))
  {
    *(_DWORD *)(a1 + 156) = v34;
    return;
  }

  int v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  os_log_type_t v15 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    char v16 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)buf = 136447234;
    __int16 v36 = "nw_socket_set_send_low_water_mark";
    __int16 v37 = 2080;
    *(void *)&os_log_type_t v38 = a1 + 308;
    WORD4(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 10) = v34;
    HIWORD(v38) = 1024;
    *(_DWORD *)__int16 v39 = v16;
    *(_WORD *)&v39[4] = 1024;
    *(_DWORD *)&v39[6] = v14;
    _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d",  buf,  0x28u);
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v17 = (os_log_s *)gLogObj;
  if (v14 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      BOOL v18 = *(_DWORD *)(a1 + 172);
      *(_DWORD *)buf = 136446978;
      __int16 v36 = "nw_socket_set_send_low_water_mark";
      __int16 v37 = 1024;
      LODWORD(v38) = v34;
      WORD2(v38) = 1024;
      *(_DWORD *)((char *)&v38 + 6) = v18;
      WORD5(v38) = 1024;
      HIDWORD(v38) = 22;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d",  buf,  0x1Eu);
    }

    return;
  }

  char v19 = *(_DWORD *)(a1 + 172);
  *(_DWORD *)buf = 136446978;
  __int16 v36 = "nw_socket_set_send_low_water_mark";
  __int16 v37 = 1024;
  LODWORD(v38) = v34;
  WORD2(v38) = 1024;
  *(_DWORD *)((char *)&v38 + 6) = v19;
  WORD5(v38) = 1024;
  HIDWORD(v38) = v14;
  dispatch_data_t v20 = (char *)_os_log_send_and_compose_impl();
  v33[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v32) = 0;
  if (v33[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v21 = (os_log_s *)gLogObj;
    uint64_t v22 = v33[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, v33[0])) {
      goto LABEL_56;
    }
    os_log_type_t v23 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)buf = 136446978;
    __int16 v36 = "nw_socket_set_send_low_water_mark";
    __int16 v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 6) = v23;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    unsigned int v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d";
    goto LABEL_55;
  }

  if (!(_BYTE)v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v21 = (os_log_s *)gLogObj;
    uint64_t v22 = v33[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, v33[0])) {
      goto LABEL_56;
    }
    uint64_t v28 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)buf = 136446978;
    __int16 v36 = "nw_socket_set_send_low_water_mark";
    __int16 v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 6) = v28;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    unsigned int v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, backtrace limit exceeded";
    goto LABEL_55;
  }

  os_log_type_t v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v21 = (os_log_s *)gLogObj;
  uint64_t v22 = v33[0];
  uint64_t v26 = os_log_type_enabled((os_log_t)gLogObj, v33[0]);
  if (v25)
  {
    if (v26)
    {
      int v27 = *(_DWORD *)(a1 + 172);
      *(_DWORD *)buf = 136447234;
      __int16 v36 = "nw_socket_set_send_low_water_mark";
      __int16 v37 = 1024;
      LODWORD(v38) = v34;
      WORD2(v38) = 1024;
      *(_DWORD *)((char *)&v38 + 6) = v27;
      WORD5(v38) = 1024;
      HIDWORD(v38) = v14;
      *(_WORD *)__int16 v39 = 2082;
      *(void *)&v39[2] = v25;
      _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x28u);
    }

    free(v25);
    goto LABEL_56;
  }

  if (v26)
  {
    uint64_t v29 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)buf = 136446978;
    __int16 v36 = "nw_socket_set_send_low_water_mark";
    __int16 v37 = 1024;
    LODWORD(v38) = v34;
    WORD2(v38) = 1024;
    *(_DWORD *)((char *)&v38 + 6) = v29;
    WORD5(v38) = 1024;
    HIDWORD(v38) = v14;
    unsigned int v24 = "%{public}s setsockopt SO_SNDLOWAT %u fd %d failed %{darwin.errno}d, no backtrace";
LABEL_55:
    _os_log_impl(&dword_181A5C000, v21, v22, v24, buf, 0x1Eu);
  }

    free(v11);
    goto LABEL_34;
  }

  uint64_t v3 = v2;
  error = 0LL;
  uint64_t v4 = SecTaskCopyValueForEntitlement(v2, v1, &error);
  if (error)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    __int16 v32 = "NWUtilsCurrentProcessHasEntitlement";
    id v33 = 2114;
    uint32_t v34 = v1;
    __int16 v35 = 2114;
    __int16 v36 = error;
    nw_endpoint_t v6 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v28 = 0;
    if (__nwlog_fault((const char *)v6, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        qos_class_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v32 = "NWUtilsCurrentProcessHasEntitlement";
        id v33 = 2114;
        uint32_t v34 = v1;
        __int16 v35 = 2114;
        __int16 v36 = error;
        uint64_t v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed";
LABEL_38:
        unsigned int v24 = v7;
        os_log_type_t v25 = v8;
        goto LABEL_39;
      }

      if (!v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        qos_class_t v7 = (os_log_s *)(id)gLogObj;
        os_log_type_t v8 = type;
        if (!os_log_type_enabled(v7, type)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v32 = "NWUtilsCurrentProcessHasEntitlement";
        id v33 = 2114;
        uint32_t v34 = v1;
        __int16 v35 = 2114;
        __int16 v36 = error;
        uint64_t v9 = "%{public}s SecTaskCopyValueForEntitlement %{public}@ error %{public}@ failed, backtrace limit exceeded";
        goto LABEL_38;
      }

      os_log_type_t v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      qos_class_t v7 = (os_log_s *)(id)gLogObj;
      char v16 = type;
      __int16 v17 = os_log_type_enabled(v7, type);
      if (!v15)
      {
        if (!v17)
        {
LABEL_40:

          if (!v6)
          {
LABEL_18:
            if (error)
            {
              CFRelease(error);
              error = 0LL;
            }

            goto LABEL_20;
          }

    if (v8) {
      free(v8);
    }
    goto LABEL_35;
  }

  if ((nw_path_can_use_channel_syscalls(void)::can_use_channel_syscalls & 1) == 0
    || (nw_parameters_get_allow_socket_access(v3->parameters) & 1) != 0
    || nw_parameters_get_ip_protocol(v3->parameters) == 6 && nw_parameters_get_multipath(v3->parameters)
    || v3->policy_result.flow_divert_aggregate_unit
    || v3->policy_result.routing_result == 4
    || (*((_BYTE *)v3 + 473) & 0x10) != 0)
  {
LABEL_35:
    nw_endpoint_t v6 = 0LL;
    goto LABEL_36;
  }

  uint64_t v4 = v3->endpoint;
  int v5 = v4;

LABEL_36:
  return v6;
}

    xpc_dictionary_set_uint64(v27, "generation", a3);
    xpc_dictionary_set_uint64(xdict, out, v17);
    xpc_dictionary_set_value(v15, out, v27);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v32 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
      os_log_type_t v66 = 1042;
      *(_DWORD *)BOOL v67 = 16;
      *(_WORD *)&v67[4] = 2098;
      *(void *)&v67[6] = a2;
      id v33 = "%{public}s Saved agent %{public,uuid_t}.16P to the cache";
      goto LABEL_35;
    }

        free(v28);
        if (!v16) {
          goto LABEL_67;
        }
        goto LABEL_66;
      }
    }

    else
    {
      browse = nw_path_create(*(void **)v79, v13);
      if (!browse)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v38 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        BOOL v81 = "nw_path_copy_path_for_tlv";
        char v16 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        os_log_type_t v71 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v17 = (os_log_s *)(id)gLogObj;
          __int16 v39 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_181A5C000, v17, v39, "%{public}s nw_path_create failed", buf, 0xCu);
          }
        }

        else if (v71)
        {
          id v46 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          __int16 v47 = type;
          char v48 = os_log_type_enabled(v17, type);
          if (v46)
          {
            if (v48)
            {
              *(_DWORD *)buf = 136446466;
              BOOL v81 = "nw_path_copy_path_for_tlv";
              os_log_type_t v82 = 2082;
              os_log_type_t v83 = v46;
              _os_log_impl( &dword_181A5C000,  v17,  v47,  "%{public}s nw_path_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v46);
            if (!v16) {
              goto LABEL_67;
            }
            goto LABEL_66;
          }

          if (v48)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl(&dword_181A5C000, v17, v47, "%{public}s nw_path_create failed, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          uint64_t v51 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v81 = "nw_path_copy_path_for_tlv";
            _os_log_impl( &dword_181A5C000,  v17,  v51,  "%{public}s nw_path_create failed, backtrace limit exceeded",  buf,  0xCu);
          }
        }

    if (!v11)
    {
LABEL_35:
      uint64_t v9 = 0LL;
      goto LABEL_36;
    }

    free(v13);
    goto LABEL_34;
  }

  unsigned int v11 = size + 5LL;
  if (v10 - v8 < v11)
  {
    os_log_type_t v57 = a1;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v12 = (id)gLogObj;
    *(_DWORD *)applier = 136447490;
    *(void *)&applier[4] = "nw_necp_append_tlv";
    *(_WORD *)&applier[12] = 2048;
    *(void *)&applier[14] = v8;
    *(_WORD *)&applier[22] = 2048;
    *(void *)os_log_type_t v64 = size + 5LL;
    *(_WORD *)&v64[8] = 2048;
    *(void *)&v64[10] = v10;
    *(_WORD *)&v64[18] = 1024;
    *(_DWORD *)&v64[20] = 2;
    *(_WORD *)&v64[24] = 1024;
    *(_DWORD *)&v64[26] = size;
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)applier = 136447490;
        *(void *)&applier[4] = "nw_necp_append_tlv";
        *(_WORD *)&applier[12] = 2048;
        *(void *)&applier[14] = v8;
        *(_WORD *)&applier[22] = 2048;
        *(void *)os_log_type_t v64 = size + 5LL;
        *(_WORD *)&v64[8] = 2048;
        *(void *)&v64[10] = v10;
        *(_WORD *)&v64[18] = 1024;
        *(_DWORD *)&v64[20] = 2;
        *(_WORD *)&v64[24] = 1024;
        *(_DWORD *)&v64[26] = size;
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u",  applier,  0x36u);
      }
    }

    else if (LOBYTE(v58[0]))
    {
      __int16 v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)(id)gLogObj;
      BOOL v18 = type[0];
      char v19 = os_log_type_enabled(v14, type[0]);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)applier = 136447746;
          *(void *)&applier[4] = "nw_necp_append_tlv";
          *(_WORD *)&applier[12] = 2048;
          *(void *)&applier[14] = v8;
          *(_WORD *)&applier[22] = 2048;
          *(void *)os_log_type_t v64 = size + 5LL;
          *(_WORD *)&v64[8] = 2048;
          *(void *)&v64[10] = v10;
          *(_WORD *)&v64[18] = 1024;
          *(_DWORD *)&v64[20] = 2;
          *(_WORD *)&v64[24] = 1024;
          *(_DWORD *)&v64[26] = size;
          *(_WORD *)&v64[30] = 2082;
          v65 = v17;
          _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s",  applier,  0x40u);
        }

        free(v17);
        if (!v13) {
          goto LABEL_34;
        }
        goto LABEL_33;
      }

      if (v19)
      {
        *(_DWORD *)applier = 136447490;
        *(void *)&applier[4] = "nw_necp_append_tlv";
        *(_WORD *)&applier[12] = 2048;
        *(void *)&applier[14] = v8;
        *(_WORD *)&applier[22] = 2048;
        *(void *)os_log_type_t v64 = size + 5LL;
        *(_WORD *)&v64[8] = 2048;
        *(void *)&v64[10] = v10;
        *(_WORD *)&v64[18] = 1024;
        *(_DWORD *)&v64[20] = 2;
        *(_WORD *)&v64[24] = 1024;
        *(_DWORD *)&v64[26] = size;
        _os_log_impl( &dword_181A5C000,  v14,  v18,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace",  applier,  0x36u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v14 = (os_log_s *)(id)gLogObj;
      dispatch_data_t v20 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)applier = 136447490;
        *(void *)&applier[4] = "nw_necp_append_tlv";
        *(_WORD *)&applier[12] = 2048;
        *(void *)&applier[14] = v8;
        *(_WORD *)&applier[22] = 2048;
        *(void *)os_log_type_t v64 = size + 5LL;
        *(_WORD *)&v64[8] = 2048;
        *(void *)&v64[10] = v10;
        *(_WORD *)&v64[18] = 1024;
        *(_DWORD *)&v64[20] = 2;
        *(_WORD *)&v64[24] = 1024;
        *(_DWORD *)&v64[26] = size;
        _os_log_impl( &dword_181A5C000,  v14,  v20,  "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded",  applier,  0x36u);
      }
    }

    goto LABEL_31;
  }

  *(_BYTE *)os_log_type_t v8 = 2;
  *(_DWORD *)(v8 + 1) = size;
  if ((_DWORD)size)
  {
    if (v6)
    {
      memcpy((void *)(v8 + 5), v6, size);
      goto LABEL_19;
    }

    __int16 v45 = a1;
    __nwlog_obj();
    id v46 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446722;
    *(void *)&applier[4] = "nw_necp_append_tlv";
    *(_WORD *)&applier[12] = 1024;
    *(_DWORD *)&applier[14] = 2;
    *(_WORD *)&applier[18] = 1024;
    *(_DWORD *)&applier[20] = size;
    __int16 v47 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v58[0]) = 0;
    if (__nwlog_fault(v47, type, v58))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        uint64_t v49 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_necp_append_tlv";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = 2;
          *(_WORD *)&applier[18] = 1024;
          *(_DWORD *)&applier[20] = size;
          _os_log_impl(&dword_181A5C000, v48, v49, "%{public}s type=%u length=%u but value is NULL", applier, 0x18u);
        }
      }

      else if (LOBYTE(v58[0]))
      {
        os_log_type_t v53 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        BOOL v54 = type[0];
        os_log_type_t v55 = os_log_type_enabled(v48, type[0]);
        if (v53)
        {
          if (v55)
          {
            *(_DWORD *)applier = 136446978;
            *(void *)&applier[4] = "nw_necp_append_tlv";
            *(_WORD *)&applier[12] = 1024;
            *(_DWORD *)&applier[14] = 2;
            *(_WORD *)&applier[18] = 1024;
            *(_DWORD *)&applier[20] = size;
            *(_WORD *)os_log_type_t v64 = 2082;
            *(void *)&v64[2] = v53;
            _os_log_impl( &dword_181A5C000,  v48,  v54,  "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s",  applier,  0x22u);
          }

          free(v53);
          goto LABEL_110;
        }

        if (v55)
        {
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_necp_append_tlv";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = 2;
          *(_WORD *)&applier[18] = 1024;
          *(_DWORD *)&applier[20] = size;
          _os_log_impl( &dword_181A5C000,  v48,  v54,  "%{public}s type=%u length=%u but value is NULL, no backtrace",  applier,  0x18u);
        }
      }

      else
      {
        __nwlog_obj();
        char v48 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v56 = type[0];
        if (os_log_type_enabled(v48, type[0]))
        {
          *(_DWORD *)applier = 136446722;
          *(void *)&applier[4] = "nw_necp_append_tlv";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = 2;
          *(_WORD *)&applier[18] = 1024;
          *(_DWORD *)&applier[20] = size;
          _os_log_impl( &dword_181A5C000,  v48,  v56,  "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded",  applier,  0x18u);
        }
      }
    }

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }

  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_http_alt_svc_get_remote_endpoint";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_http_alt_svc_get_remote_endpoint";
      qos_class_t v7 = "%{public}s called with null http_alt_svc";
      goto LABEL_33;
    }

    if (!v12)
    {
      int v5 = (os_log_s *)__nwlog_obj();
      nw_endpoint_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_http_alt_svc_get_remote_endpoint";
      qos_class_t v7 = "%{public}s called with null http_alt_svc, backtrace limit exceeded";
      goto LABEL_33;
    }

    uint64_t v10 = (char *)__nw_create_backtrace_string();
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    unsigned int v11 = os_log_type_enabled(v5, type);
    if (!v10)
    {
      if (!v11) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_http_alt_svc_get_remote_endpoint";
      qos_class_t v7 = "%{public}s called with null http_alt_svc, no backtrace";
      goto LABEL_33;
    }

    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v15 = "nw_protocol_http_alt_svc_get_remote_endpoint";
      char v16 = 2082;
      __int16 v17 = v10;
      _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null http_alt_svc, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(v10);
LABEL_34:
    if (!v4) {
      return 0LL;
    }
LABEL_35:
    free(v4);
    return 0LL;
  }

  id v2 = handle[25];
  if (v2) {
    return v2;
  }
  return nw_protocol_get_remote_endpoint((uint64_t)a1->default_input_handler);
}

    uint64_t v21 = 0LL;
    goto LABEL_34;
  }

  nw_http_messaging_options_set_http2_options(v24, 0LL);
  nw_http_messaging_options_set_http3_options(v24, 0LL);
  os_log_type_t v23 = *(void *)(a1 + 32);
  if (v23) {
    *(_BYTE *)(v23 + 17) = 0;
  }
LABEL_27:
}

    CFDataGetBytePtr(*(CFDataRef *)(a2 + 8));
    CFDataGetLength(*(CFDataRef *)(a2 + 8));
    dispatch_data_t v20 = (void *)NEHelperCopyXPCEndpointForIdentityProxy();
    if (v20)
    {
      uint64_t v21 = objc_alloc_init(MEMORY[0x189607B58]);
      [v21 _setEndpoint:v20];
      char v31 = 0LL;
      uint64_t v22 = (__SecIdentity *)[MEMORY[0x18960AFC0] createIdentityFromEndpoint:v21 error:&v31];
      os_log_type_t v23 = (__SecIdentity *)v31;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v24 = (os_log_s *)(id)gLogObj;
      os_log_type_t v25 = v24;
      if (v23)
      {
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          id v33 = "nw_tls_create_options_from_serializable_block_invoke";
          uint32_t v34 = 2112;
          __int16 v35 = v23;
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to fetch identity from NEHelper: %@",  buf,  0x16u);
        }

        *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
      }

      else
      {
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          id v33 = "nw_tls_create_options_from_serializable_block_invoke";
          uint32_t v34 = 2112;
          __int16 v35 = v22;
          _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_DEBUG,  "%{public}s Fetched identity %@ from NEHelper",  buf,  0x16u);
        }
      }

      if (v22)
      {
        if (Mutable) {
          uint64_t v28 = sec_identity_create_with_certificates(v22, Mutable);
        }
        else {
          uint64_t v28 = sec_identity_create(v22);
        }
        uint64_t v29 = v28;
        sec_protocol_options_set_local_identity(*(sec_protocol_options_t *)(a1 + 32), v28);

        CFRelease(v22);
      }

      if (Mutable) {
        CFRelease(Mutable);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        int v27 = *(__SecIdentity **)(a2 + 8);
        *(_DWORD *)buf = 136446466;
        id v33 = "nw_tls_create_options_from_serializable_block_invoke";
        uint32_t v34 = 2112;
        __int16 v35 = v27;
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to copy xpc endpoint for client identity %@",  buf,  0x16u);
      }

      if (Mutable) {
        CFRelease(Mutable);
      }
      *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
    }
  }

  return 1LL;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v12) {
    free(v12);
  }
  uint64_t v9 = 0LL;
LABEL_4:

  return v9;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

  if (v10) {
    free(v10);
  }
  qos_class_t v7 = 0LL;
LABEL_4:

  return v7;
}

    free(backtrace_string);
    goto LABEL_43;
  }

  if (!__s)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v25 = "nw_string_find_c_string";
    int v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = (os_log_s *)__nwlog_obj();
      char v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_string_find_c_string";
        __int16 v17 = "%{public}s called with null substring";
        goto LABEL_42;
      }

      goto LABEL_43;
    }

    if (!v22)
    {
      os_log_type_t v15 = (os_log_s *)__nwlog_obj();
      char v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_string_find_c_string";
        __int16 v17 = "%{public}s called with null substring, backtrace limit exceeded";
        goto LABEL_42;
      }

      goto LABEL_43;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v15 = (os_log_s *)__nwlog_obj();
    char v16 = type;
    uint64_t v21 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v25 = "nw_string_find_c_string";
        __int16 v17 = "%{public}s called with null substring, no backtrace";
        goto LABEL_42;
      }

      goto LABEL_43;
    }

    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v25 = "nw_string_find_c_string";
      uint64_t v26 = 2082;
      int v27 = backtrace_string;
      dispatch_data_t v20 = "%{public}s called with null substring, dumping backtrace:%{public}s";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  uint64_t v4 = *(char **)(a1 + 24);
  BOOL result = strlen(__s);
  if (result)
  {
    nw_endpoint_t v6 = result;
    qos_class_t v7 = *(void *)(a1 + 32);
    os_log_type_t v8 = &v4[v7];
    if (v7 >= result)
    {
      uint64_t v10 = *__s;
      unsigned int v11 = v4;
      do
      {
        os_log_type_t v12 = v7 - v6;
        if (v12 == -1) {
          break;
        }
        uint64_t v13 = (char *)memchr(v11, v10, v12 + 1);
        if (!v13) {
          break;
        }
        uint64_t v9 = v13;
        if (!memcmp(v13, __s, v6)) {
          goto LABEL_6;
        }
        unsigned int v11 = v9 + 1;
        qos_class_t v7 = v8 - (v9 + 1);
      }

      while (v7 >= v6);
    }

    uint64_t v9 = v8;
LABEL_6:
    if (v9 == v8) {
      return -1LL;
    }
    else {
      return v9 - v4;
    }
  }

  return result;
}

  if (v5) {
    free(v5);
  }
  return 0LL;
}

  if (v16) {
    free(v16);
  }
LABEL_16:
}

  if (v7) {
    free(v7);
  }
}

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }

  if (*(void *)(a1 + 40))
  {
    if (a3)
    {
      uint64_t v3 = a3[1] & 0xFFFFFFF8;
      *a3 = -1;
      a3[1] = v3;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_http2_stream_get_message_properties";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_http2_stream_get_message_properties";
    qos_class_t v7 = "%{public}s called with null http2";
    goto LABEL_33;
  }

  if (!v12)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_http2_stream_get_message_properties";
    qos_class_t v7 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_33;
  }

  uint64_t v10 = (char *)__nw_create_backtrace_string();
  int v5 = (os_log_s *)__nwlog_obj();
  nw_endpoint_t v6 = type;
  unsigned int v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_http2_stream_get_message_properties";
    qos_class_t v7 = "%{public}s called with null http2, no backtrace";
    goto LABEL_33;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v15 = "nw_protocol_http2_stream_get_message_properties";
    char v16 = 2082;
    __int16 v17 = v10;
    _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null http2, dumping backtrace:%{public}s",  buf,  0x16u);
  }

  free(v10);
  if (v4) {
    goto LABEL_35;
  }
}

    free(backtrace_string);
    goto LABEL_51;
  }

  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v32 = "nw_protocol_http2_copy_info";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    uint64_t v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_http2_copy_info";
        char v16 = "%{public}s called with null http2";
        goto LABEL_50;
      }

      goto LABEL_51;
    }

    if (!v29)
    {
      int v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_http2_copy_info";
        char v16 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_50;
      }

      goto LABEL_51;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = (os_log_s *)__nwlog_obj();
    os_log_type_t v15 = type;
    dispatch_data_t v20 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_http2_copy_info";
        char v16 = "%{public}s called with null http2, no backtrace";
        goto LABEL_50;
      }

      goto LABEL_51;
    }

    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v32 = "nw_protocol_http2_copy_info";
      id v33 = 2082;
      uint32_t v34 = backtrace_string;
      char v19 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  if (a2 == 253) {
    return *(void *)(v3 + 144);
  }
  qos_class_t v7 = nw_protocol_common_copy_info(a1, a2);
  int v5 = v7;
  if (a2 == 255)
  {
    if (!v7) {
      int v5 = nw_array_create();
    }
    os_log_type_t v8 = *(void **)(v3 + 256);
    if (v8) {
      nw_array_append(v5, v8);
    }
    if (a3)
    {
      uint64_t v9 = *(void *)(a3 + 56);
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 + 32);
        if (v10)
        {
          unsigned int v11 = *(void **)(v10 + 96);
          if (v11) {
            nw_array_append(v5, v11);
          }
          return v5;
        }

        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_http2_copy_info";
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        uint64_t v29 = 0;
        uint64_t v28 = (char *)_os_log_send_and_compose_impl();
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v21 = (os_log_s *)__nwlog_obj();
          uint64_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_73;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v32 = "nw_protocol_http2_copy_info";
          os_log_type_t v23 = "%{public}s called with null stream";
          goto LABEL_72;
        }

        if (!v29)
        {
          uint64_t v21 = (os_log_s *)__nwlog_obj();
          uint64_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_73;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v32 = "nw_protocol_http2_copy_info";
          os_log_type_t v23 = "%{public}s called with null stream, backtrace limit exceeded";
          goto LABEL_72;
        }

        unsigned int v24 = (char *)__nw_create_backtrace_string();
        uint64_t v21 = (os_log_s *)__nwlog_obj();
        uint64_t v22 = type;
        int v27 = os_log_type_enabled(v21, type);
        if (v24)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v32 = "nw_protocol_http2_copy_info";
            id v33 = 2082;
            uint32_t v34 = v24;
            uint64_t v26 = "%{public}s called with null stream, dumping backtrace:%{public}s";
            goto LABEL_62;
          }

          goto LABEL_63;
        }

        if (!v27) {
          goto LABEL_73;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_http2_copy_info";
        os_log_type_t v23 = "%{public}s called with null stream, no backtrace";
      }

      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        __int16 v32 = "nw_protocol_http2_copy_info";
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        uint64_t v29 = 0;
        uint64_t v28 = (char *)_os_log_send_and_compose_impl();
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v29)
          {
            uint64_t v21 = (os_log_s *)__nwlog_obj();
            uint64_t v22 = type;
            if (!os_log_type_enabled(v21, type)) {
              goto LABEL_73;
            }
            *(_DWORD *)buf = 136446210;
            __int16 v32 = "nw_protocol_http2_copy_info";
            os_log_type_t v23 = "%{public}s called with null node, backtrace limit exceeded";
            goto LABEL_72;
          }

          unsigned int v24 = (char *)__nw_create_backtrace_string();
          uint64_t v21 = (os_log_s *)__nwlog_obj();
          uint64_t v22 = type;
          os_log_type_t v25 = os_log_type_enabled(v21, type);
          if (!v24)
          {
            if (!v25) {
              goto LABEL_73;
            }
            *(_DWORD *)buf = 136446210;
            __int16 v32 = "nw_protocol_http2_copy_info";
            os_log_type_t v23 = "%{public}s called with null node, no backtrace";
            goto LABEL_72;
          }

          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v32 = "nw_protocol_http2_copy_info";
            id v33 = 2082;
            uint32_t v34 = v24;
            uint64_t v26 = "%{public}s called with null node, dumping backtrace:%{public}s";
LABEL_62:
            _os_log_impl(&dword_181A5C000, v21, v22, v26, buf, 0x16u);
          }

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }

  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    if (a3)
    {
      uint64_t v3 = a3[1] & 0xFFFFFFF8 | 1;
      *a3 = *(_DWORD *)(a1 + 248);
      a3[1] = v3;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_ipv6_get_message_properties";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ipv6_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ipv6";
    goto LABEL_33;
  }

  if (!v12)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ipv6_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ipv6, backtrace limit exceeded";
    goto LABEL_33;
  }

  uint64_t v10 = (char *)__nw_create_backtrace_string();
  int v5 = (os_log_s *)__nwlog_obj();
  nw_endpoint_t v6 = type;
  unsigned int v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ipv6_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ipv6, no backtrace";
    goto LABEL_33;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v15 = "nw_protocol_ipv6_get_message_properties";
    char v16 = 2082;
    __int16 v17 = v10;
    _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null ipv6, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v10);
  if (v4) {
    goto LABEL_35;
  }
}

    _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }

  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    if (a3)
    {
      uint64_t v3 = a3[1] & 0xFFFFFFF8 | 1;
      *a3 = *(_DWORD *)(a1 + 208);
      a3[1] = v3;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_ipv4_get_message_properties";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v12 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ipv4_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ipv4";
    goto LABEL_33;
  }

  if (!v12)
  {
    int v5 = (os_log_s *)__nwlog_obj();
    nw_endpoint_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ipv4_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ipv4, backtrace limit exceeded";
    goto LABEL_33;
  }

  uint64_t v10 = (char *)__nw_create_backtrace_string();
  int v5 = (os_log_s *)__nwlog_obj();
  nw_endpoint_t v6 = type;
  unsigned int v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v15 = "nw_protocol_ipv4_get_message_properties";
    qos_class_t v7 = "%{public}s called with null ipv4, no backtrace";
    goto LABEL_33;
  }

  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v15 = "nw_protocol_ipv4_get_message_properties";
    char v16 = 2082;
    __int16 v17 = v10;
    _os_log_impl(&dword_181A5C000, v5, v6, "%{public}s called with null ipv4, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v10);
  if (v4) {
    goto LABEL_35;
  }
}

        if (!v5) {
          return v3;
        }
LABEL_34:
        free(v5);
        return v3;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v33 = (os_log_s *)__nwlog_obj();
      uint32_t v34 = v46;
      os_log_type_t v40 = os_log_type_enabled(v33, v46);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)os_log_type_t type = 136446978;
          os_log_type_t v53 = "nw_create_control_socket";
          BOOL v54 = 1024;
          os_log_type_t v55 = v3;
          v56 = 1024;
          os_log_type_t v57 = v31;
          BOOL v58 = 1024;
          LODWORD(v59[0]) = v32;
          os_log_type_t v8 = "%{public}s fcntl(%d, F_SETFL, %d) %{darwin.errno}d, no backtrace";
          goto LABEL_76;
        }

        goto LABEL_33;
      }

      if (!v40)
      {
LABEL_25:
        free(backtrace_string);
        if (!v5) {
          return v3;
        }
        goto LABEL_34;
      }

      *(_DWORD *)os_log_type_t type = 136447234;
      os_log_type_t v53 = "nw_create_control_socket";
      BOOL v54 = 1024;
      os_log_type_t v55 = v3;
      v56 = 1024;
      os_log_type_t v57 = v31;
      BOOL v58 = 1024;
      LODWORD(v59[0]) = v32;
      WORD2(v59[0]) = 2082;
      *(void *)((char *)v59 + 6) = backtrace_string;
      BOOL v18 = "%{public}s fcntl(%d, F_SETFL, %d) %{darwin.errno}d, dumping backtrace:%{public}s";
      char v19 = (uint8_t *)type;
      dispatch_data_t v20 = v33;
      uint64_t v21 = v34;
      uint64_t v22 = 40;
LABEL_24:
      _os_log_impl(&dword_181A5C000, v20, v21, v18, v19, v22);
      goto LABEL_25;
    }

    __int16 v35 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)os_log_type_t type = 136446722;
    os_log_type_t v53 = "nw_create_control_socket";
    BOOL v54 = 1024;
    os_log_type_t v55 = v3;
    v56 = 1024;
    os_log_type_t v57 = v35;
    int v5 = (char *)_os_log_send_and_compose_impl();
    id v46 = OS_LOG_TYPE_ERROR;
    __int16 v45 = 0;
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      __int16 v36 = (os_log_s *)__nwlog_obj();
      __int16 v37 = v46;
      if (!os_log_type_enabled(v36, v46)) {
        goto LABEL_33;
      }
      *(_DWORD *)os_log_type_t type = 136446722;
      os_log_type_t v53 = "nw_create_control_socket";
      BOOL v54 = 1024;
      os_log_type_t v55 = v3;
      v56 = 1024;
      os_log_type_t v57 = v35;
      os_log_type_t v8 = "%{public}s fcntl(%d, F_GETFL, 0) %{darwin.errno}d";
    }

    else if (v45)
    {
      os_log_type_t v38 = (char *)__nw_create_backtrace_string();
      __int16 v36 = (os_log_s *)__nwlog_obj();
      __int16 v37 = v46;
      __int16 v39 = os_log_type_enabled(v36, v46);
      if (v38)
      {
        if (v39)
        {
          *(_DWORD *)os_log_type_t type = 136446978;
          os_log_type_t v53 = "nw_create_control_socket";
          BOOL v54 = 1024;
          os_log_type_t v55 = v3;
          v56 = 1024;
          os_log_type_t v57 = v35;
          BOOL v58 = 2082;
          v59[0] = v38;
          _os_log_impl( &dword_181A5C000,  v36,  v37,  "%{public}s fcntl(%d, F_GETFL, 0) %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)type,  0x22u);
        }

        free(v38);
        goto LABEL_33;
      }

      if (!v39) {
        goto LABEL_33;
      }
      *(_DWORD *)os_log_type_t type = 136446722;
      os_log_type_t v53 = "nw_create_control_socket";
      BOOL v54 = 1024;
      os_log_type_t v55 = v3;
      v56 = 1024;
      os_log_type_t v57 = v35;
      os_log_type_t v8 = "%{public}s fcntl(%d, F_GETFL, 0) %{darwin.errno}d, no backtrace";
    }

    else
    {
      __int16 v36 = (os_log_s *)__nwlog_obj();
      __int16 v37 = v46;
      if (!os_log_type_enabled(v36, v46)) {
        goto LABEL_33;
      }
      *(_DWORD *)os_log_type_t type = 136446722;
      os_log_type_t v53 = "nw_create_control_socket";
      BOOL v54 = 1024;
      os_log_type_t v55 = v3;
      v56 = 1024;
      os_log_type_t v57 = v35;
      os_log_type_t v8 = "%{public}s fcntl(%d, F_GETFL, 0) %{darwin.errno}d, backtrace limit exceeded";
    }

    os_log_type_t v23 = (uint8_t *)type;
    unsigned int v24 = v36;
    os_log_type_t v25 = v37;
    uint64_t v26 = 24;
    goto LABEL_32;
  }

  BOOL v41 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
  *(_DWORD *)os_log_type_t type = 136446210;
  os_log_type_t v53 = "_strict_strlcpy";
  int v43 = 12;
  os_log_type_t v42 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v42);
  if (!(_DWORD)result)
  {
    free(v42);
    goto LABEL_9;
  }

  __break(1u);
  return result;
}

    free(v15);
    goto LABEL_34;
  }

  int v14 = nw_endpoint_create_address(__dst);
LABEL_35:

  return v14;
}