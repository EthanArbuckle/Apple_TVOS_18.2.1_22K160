uint64_t ___Z33cf_nghttp2_on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke@<X0>( uint64_t a1@<X8>)
{
  _opaque_pthread_t *v2;
  uint64_t result;
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 53LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_invalid_frame_recv_callback(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_5, 2);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v7 + 16LL))(v7, "h2 frame", 0LL))
    {
      HTTP2Diagnostic::LOG_FRAME(v8, a2, 2LL, *(void *)(a4 + 72), a3);
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
  }

  return 0LL;
}

uint64_t ___Z41cf_nghttp2_on_invalid_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_frameiPv_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 88LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

void HTTP2ServerPushStream::safe_data_deleter(dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
}

void ___ZN15HTTP2Connection31submitWindowUpdateForPushStreamEii_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  v1 = *(HTTP2Connection **)(a1 + 32);
  if (*((void *)v1 + 20))
  {
    int v2 = nghttp2_submit_window_update();
    if (v2 < 0)
    {
      int v3 = v2;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      v4 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        v5 = (const __CFString *)(*(uint64_t (**)(HTTP2Connection *))(*(void *)v1 + 24LL))(v1);
        int v6 = 136315394;
        v7 = _cfnAutoreleaseInDebug(v5);
        __int16 v8 = 1024;
        int v9 = v3;
        _os_log_error_impl( &dword_18298D000,  v4,  OS_LOG_TYPE_ERROR,  "Could not submit window update on [%s], error code: %d",  (uint8_t *)&v6,  0x12u);
      }
    }

    HTTP2Connection::_onqueue_scheduleIO(v1);
  }

  CFRelease((char *)v1 - 16);
}

void *std::string::basic_string[abi:nn180100](void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    int v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000LL;
    *__dst = v6;
  }

  else
  {
    *((_BYTE *)__dst + 23) = __len;
    int v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }

  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

void std::string::__init_copy_ctor_external( std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    size_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__l.__cap_ = v7 | 0x8000000000000000LL;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }

  else
  {
    this->__r_.__value_.__s.__size_ = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

uint64_t ___Z33cf_nghttp2_on_frame_send_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_2@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 215LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___Z33cf_nghttp2_on_frame_send_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 194LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_frame_not_send_callback(int a1, uint64_t a2, int a3, uint64_t a4)
{
  size_t v8 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_9, 2);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v8 + 16LL))(v8, "h2 frame", 0LL))
    {
      HTTP2Diagnostic::LOG_FRAME(v9, a2, 3LL, *(void *)(a4 + 72), a3);
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    }
  }

  int v10 = *(unsigned __int8 *)(a2 + 12);
  if (a3 == -522 && v10 == 1)
  {
    uint64_t stream_user_data = nghttp2_session_get_stream_user_data();
    if (stream_user_data)
    {
      v13 = *(HTTP2Stream **)stream_user_data;
      v12 = *(std::__shared_weak_count **)(stream_user_data + 8);
      v14 = *(HTTP2Stream **)stream_user_data;
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          unint64_t v16 = __ldxr(p_shared_owners);
        while (__stxr(v16 + 1, p_shared_owners));
        v14 = *(HTTP2Stream **)stream_user_data;
      }

      HTTP2Connection::flushBatchedDataForStream((uint64_t **)a4, v14);
      HTTP2Stream::cleanUpInUserDataResetCallback(v13, a1, *(_DWORD *)(a2 + 8), (HTTP2Connection *)6, a4);
      if (v12)
      {
        v17 = (unint64_t *)&v12->__shared_owners_;
        do
          unint64_t v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
    }

    int v10 = *(unsigned __int8 *)(a2 + 12);
  }

  if (v10 == 3)
  {
    uint64_t v19 = nghttp2_session_get_stream_user_data();
    if (v19)
    {
      v21 = *(HTTP2Stream **)v19;
      v20 = *(std::__shared_weak_count **)(v19 + 8);
      v22 = *(HTTP2Stream **)v19;
      if (v20)
      {
        v23 = (unint64_t *)&v20->__shared_owners_;
        do
          unint64_t v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
        v22 = *(HTTP2Stream **)v19;
      }

      HTTP2Connection::flushBatchedDataForStream((uint64_t **)a4, v22);
      HTTP2Stream::cleanUpInUserDataResetCallback( v21,  a1,  *(_DWORD *)(a2 + 8),  (HTTP2Connection *)*(unsigned int *)(a2 + 16),  a4);
      if (v20)
      {
        v25 = (unint64_t *)&v20->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }
  }

  return 0LL;
}

void sub_182A003D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ___Z37cf_nghttp2_on_frame_not_send_callbackP15nghttp2_sessionPK13nghttp2_frameiPv_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + 32) = 248LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t cf_nghttp2_on_invalid_header_callback(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  else {
    return 4294966775LL;
  }
}

uint64_t cf_nghttp2_error_callback2(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  size_t v8 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = *(void *)(a5 + 72);
    int v11 = 134218498;
    uint64_t v12 = v10;
    __int16 v13 = 1024;
    int v14 = a2;
    __int16 v15 = 2080;
    uint64_t v16 = a3;
    _os_log_error_impl( &dword_18298D000,  v8,  OS_LOG_TYPE_ERROR,  "HTTP/2 error encountered on Connection %llu (Code %d): %s",  (uint8_t *)&v11,  0x1Cu);
  }

  return 0LL;
}

double CFNA::_CFNetworkAgentGetTTL(CFNA *this)
{
  v1 = getenv("CFNETWORKAGENT_TTL");
  if (v1) {
    return (double)strtol(v1, 0LL, 10);
  }
  else {
    return 86400.0;
  }
}

const __CFString *CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore( CFNA *this, const __CFString *a2, const char *a3)
{
  values[2] = *(void **)MEMORY[0x1895F89C0];
  v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (!CFNA::sQueryResultsCache) {
    CFNA::sQueryResultsCache = (uint64_t)CFDictionaryCreateMutable(v5, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  }
  std::string::size_type v6 = getenv("CFNETWORKAGENT_KEY_SPACE_ROOT");
  if (v6) {
    std::string::size_type v7 = v6;
  }
  else {
    std::string::size_type v7 = "com.apple.CFNetwork.netcompat";
  }
  CFStringRef v8 = CFStringCreateWithCString(v5, v7, 0x600u);
  if (v8)
  {
    CFStringRef v9 = v8;
    CFStringRef v10 = CFStringCreateWithFormat(v5, 0LL, @"%@.%s", v8, a2);
    if (v10)
    {
      CFStringRef v11 = v10;
      values[0] = (void *)v10;
      values[1] = this;
      uint64_t v12 = CFArrayCreate(v5, (const void **)values, 2LL, MEMORY[0x189605228]);
      CFRelease(v11);
      CFRelease(v9);
      if (v12)
      {
        CFStringRef v13 = CFStringCreateByCombiningStrings(v5, v12, @":");
        if (!v13)
        {
          v23 = 0LL;
LABEL_34:
          CFRelease(v12);
          return v23;
        }

        int v14 = v13;
        Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)CFNA::sQueryResultsCache, v13);
        if (Value)
        {
          uint64_t v16 = Value;
          if (CFArrayGetCount(Value) == 2)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v16, 1LL);
            if (ValueAtIndex)
            {
              unint64_t v18 = ValueAtIndex;
              double Current = CFAbsoluteTimeGetCurrent();
              double v20 = Current - CFStringGetDoubleValue(v18);
              if (v20 <= CFNA::_CFNetworkAgentGetTTL(v21))
              {
                v22 = (const __CFString *)CFArrayGetValueAtIndex(v16, 0LL);
                v23 = v22;
                if (v22) {
                  CFRetain(v22);
                }
                goto LABEL_33;
              }
            }
          }

          goto LABEL_28;
        }

        memset(&context, 0, sizeof(context));
        unint64_t v24 = SCDynamicStoreCreate(v5, @"CFNETWORK_AGENT__STORE__", 0LL, &context);
        if (!v24)
        {
LABEL_28:
          v23 = 0LL;
LABEL_33:
          CFRelease(v14);
          goto LABEL_34;
        }

        v25 = v24;
        unint64_t v26 = SCDynamicStoreCopyKeyList(v24, v14);
        if (!v26)
        {
          v23 = 0LL;
          goto LABEL_32;
        }

        v27 = v26;
        if (CFArrayGetCount(v26) < 1
          || (v28 = (const __CFString *)CFArrayGetValueAtIndex(v27, 0LL),
              (v29 = (const __CFArray *)SCDynamicStoreCopyValue(v25, v28)) == 0LL))
        {
          v23 = 0LL;
          goto LABEL_30;
        }

        v30 = v29;
        if (CFArrayGetCount(v29) == 2)
        {
          v23 = (const __CFString *)CFArrayGetValueAtIndex(v30, 1LL);
          if (!v23)
          {
LABEL_27:
            CFRelease(v30);
LABEL_30:
            CFRelease(v27);
LABEL_32:
            CFRelease(v25);
            goto LABEL_33;
          }

          double v31 = CFAbsoluteTimeGetCurrent();
          double v32 = v31 - CFStringGetDoubleValue(v23);
          if (v32 <= CFNA::_CFNetworkAgentGetTTL(v33))
          {
            v35 = (const __CFString *)CFArrayGetValueAtIndex(v30, 0LL);
            v23 = v35;
            if (v35) {
              CFRetain(v35);
            }
            CFDictionarySetValue((CFMutableDictionaryRef)CFNA::sQueryResultsCache, v14, v30);
            goto LABEL_27;
          }
        }

        v23 = 0LL;
        goto LABEL_27;
      }
    }

    else
    {
      CFRelease(v9);
    }
  }

  return 0LL;
}

__n128 __Block_byref_object_copy__131(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  return result;
}

uint64_t __Block_byref_object_dispose__132(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

CFTypeRef std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>( void *a1, const void *a2)
{
  v4 = operator new(0x48uLL);
  v4[1] = 0LL;
  v4[2] = 0LL;
  void *v4 = off_189C06B88;
  v4[3] = off_189C11C38;
  *((_WORD *)v4 + 28) = 0;
  if (a2) {
    CFTypeRef result = CFRetain(a2);
  }
  else {
    CFTypeRef result = 0LL;
  }
  v4[5] = 0LL;
  v4[6] = 0LL;
  v4[4] = result;
  *a1 = v4 + 3;
  a1[1] = v4;
  return result;
}

void sub_182A0094C(_Unwind_Exception *a1)
{
  v1[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C19AE8;
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void ___ZN14StrictSecurity33performSystemTrustEvaluationAsyncEPK8__CFDataNS_21SessionStrengthPolicyEN14CFNetworkTrust26SignatureAlgorithmStrengthEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFviE_block_invoke( uint64_t a1, int a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  v4 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v9) = 67109120;
    DWORD1(v9) = a2;
    _os_log_impl( &dword_18298D000,  v4,  OS_LOG_TYPE_DEFAULT,  "System Trust Evaluation yielded status(%d)",  (uint8_t *)&v9,  8u);
  }

  if (a2)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    v5 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9) = 0;
      _os_log_error_impl(&dword_18298D000, v5, OS_LOG_TYPE_ERROR, "ATS failed system trust", (uint8_t *)&v9, 2u);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  __int128 v9 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL, &v9);
  std::string::size_type v6 = (std::__shared_weak_count *)*((void *)&v9 + 1);
  if (*((void *)&v9 + 1))
  {
    std::string::size_type v7 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void std::__shared_ptr_emplace<CFNetworkTrust>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C06B88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<CFNetworkTrust>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C06B88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void __performStrictTrustEvaluationAsync_block_invoke(uint64_t a1, int a2)
{
  if (a2)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    int v3 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v7) = 0;
      _os_log_error_impl(&dword_18298D000, v3, OS_LOG_TYPE_ERROR, "StrictTrustEvaluate failed", (uint8_t *)&v7, 2u);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  __int128 v7 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL, &v7);
  v4 = (std::__shared_weak_count *)*((void *)&v7 + 1);
  if (*((void *)&v7 + 1))
  {
    v5 = (unint64_t *)(*((void *)&v7 + 1) + 8LL);
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

BOOL HTTPRequestParserClient::completeFirstLine(HTTPRequestParserClient *this, const UInt8 *a2, uint64_t a3)
{
  if ((*((void *)this + 3)
     || *(void *)((*(uint64_t (**)(HTTPRequestParserClient *))(*(void *)this + 32LL))(this) + 8))
    && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v27[0]) = 0;
    _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "shouldn't be", (uint8_t *)v27, 2u);
  }

  unint64_t v6 = (const char *)&a2[a3];
  v28 = 0LL;
  v27[0] = a2;
  v30 = (const char *)&a2[a3];
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v7 = MEMORY[0x1895F8770];
  unint64_t v8 = a2;
  while (1)
  {
    unsigned int v9 = *(char *)v8;
    if ((v9 & 0x80000000) != 0) {
      break;
    }
    if ((*(_DWORD *)(v7 + 4LL * v9 + 60) & 0x4000) != 0) {
      goto LABEL_14;
    }
LABEL_11:
    if (++v8 >= (const UInt8 *)v6) {
      return 0LL;
    }
  }

  if (!__maskrune(v9, 0x4000uLL)) {
    goto LABEL_11;
  }
LABEL_14:
  v27[1] = v8;
  CFStringRef v11 = (const char *)(v8 + 1);
  while (v11 < v6)
  {
    uint64_t v12 = v11;
    unsigned int v13 = *v11;
    if ((v13 & 0x80000000) != 0) {
      int v14 = __maskrune(v13, 0x4000uLL);
    }
    else {
      int v14 = *(_DWORD *)(v7 + 4LL * v13 + 60) & 0x4000;
    }
    CFStringRef v11 = v12 + 1;
    if (!v14)
    {
      v27[2] = v12;
      __int16 v15 = v6;
      while (v15 > v12)
      {
        unsigned int v17 = *--v15;
        unsigned int v16 = v17;
        if ((v17 & 0x80000000) != 0)
        {
          if (__maskrune(v16, 0x4000uLL))
          {
LABEL_26:
            unint64_t v18 = (const UInt8 *)(v15 + 1);
            v29 = v18;
            uint64_t v19 = v18;
            while (v19 > (const UInt8 *)v12)
            {
              unsigned int v21 = *(char *)--v19;
              unsigned int v20 = v21;
              if ((v21 & 0x80000000) != 0)
              {
                if (!__maskrune(v20, 0x4000uLL))
                {
LABEL_32:
                  v22 = (const char *)(v19 + 1);
                  v28 = v19 + 1;
                  BOOL result = FirstLineFieldsBase::checkFields( (uint64_t)v27,  3LL,  (unint64_t)a2,  (unint64_t)v6);
                  if ((_DWORD)result)
                  {
                    CFIndex v23 = v8 - a2;
                    unint64_t v24 = (const __CFAllocator *)*MEMORY[0x189604DB0];
                    *((void *)this + 3) = CFStringCreateWithBytes( (CFAllocatorRef)*MEMORY[0x189604DB0],  a2,  v23,  0x201u,  0);
                    uint64_t v25 = (*(uint64_t (**)(HTTPRequestParserClient *))(*(void *)this + 32LL))(this);
                    *(void *)(v25 + 8) = CFStringCreateWithBytes(v24, v18, v6 - (const char *)v18, 0x201u, 0);
                    if (v22 == v12) {
                      unint64_t v26 = 0LL;
                    }
                    else {
                      unint64_t v26 = strndup(v12, v22 - v12);
                    }
                    *((void *)this + 4) = v26;
                    return v26 != 0LL;
                  }

                  return result;
                }
              }

              else if ((*(_DWORD *)(v7 + 4LL * v20 + 60) & 0x4000) == 0)
              {
                goto LABEL_32;
              }
            }

            return 0LL;
          }
        }

        else if ((*(_DWORD *)(v7 + 4LL * v16 + 60) & 0x4000) != 0)
        {
          goto LABEL_26;
        }
      }

      return 0LL;
    }
  }

  return 0LL;
}

void HTTPRequestParserClient::addHeader( HTTPRequestParserClient *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  v5 = (CFDictionaryRef *)(*(uint64_t (**)(HTTPRequestParserClient *))(*(void *)this + 40LL))(this);
  HTTPHeaderDict::addValue(v5, a2, a3);
}

void HTTPRequestParserClient::HTTPRequestParserClient(HTTPRequestParserClient *this, CFTypeRef cf)
{
  *(void *)this = off_189C02128;
  *((void *)this + 2) = off_189C15730;
  *((void *)this + 3) = 0LL;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0LL;
  }
  *((void *)this + 1) = v3;
  *((void *)this + 4) = 0LL;
}

void sub_182A00F24(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 16) = off_189C16E38;
  CFTypeRef v3 = *(const void **)(v1 + 24);
  if (v3) {
    CFRelease(v3);
  }
  _Unwind_Resume(exception_object);
}

void HTTPMethodMixedValue::~HTTPMethodMixedValue(HTTPMethodMixedValue *this)
{
  *(void *)this = off_189C16E38;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C16E38;
  int v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

void HTTPHeaderKeyMixedValue::~HTTPHeaderKeyMixedValue(HTTPHeaderKeyMixedValue *this)
{
  *(void *)this = off_189C16E38;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C16E38;
  int v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

void sub_182A02134( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
}

void sub_182A023DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, void (*a23)(char *))
{
}

void CoreStreamImplementation::_streamImpl_Read( CoreStreamImplementation *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4, unsigned __int8 *a5)
{
}

void CoreStreamImplementation::_streamImpl_CanRead(CoreStreamImplementation *this)
{
}

void CoreStreamImplementation::_streamImpl_Write( CoreStreamImplementation *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
}

void CoreStreamImplementation::_streamImpl_CanWrite(CoreStreamImplementation *this)
{
}

uint64_t CoreStreamImplementation::_streamImpl_workQueue(CoreStreamImplementation *this)
{
  return 0LL;
}

void CoreStreamImplementation::_streamImpl_openAsync()
{
}

void CoreStreamImplementation::_streamImpl_UpdateScheduling( CoreStreamImplementation *this, const CoreSchedulingSet *a2, const CoreSchedulingSet *a3)
{
  v5 = (void (*)(void, void, void))MEMORY[0x1895F87A8];
  v7[0] = (void (*)(void, void, void))MEMORY[0x1895F87A8];
  v7[1] = (void (*)(void, void, void))3221225472LL;
  v7[2] = (void (*)(void, void, void))___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke;
  v7[3] = (void (*)(void, void, void))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v7[4] = (void (*)(void, void, void))this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)a2, v7);
  v6[0] = v5;
  v6[1] = (void (*)(void, void, void))3221225472LL;
  v6[2] = (void (*)(void, void, void))___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke_2;
  v6[3] = (void (*)(void, void, void))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v6[4] = (void (*)(void, void, void))this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)a3, v6);
}

void CoreStreamImplementation::_streamImpl_deprecated_Schedule( CoreStreamImplementation *this, __CFRunLoop *a2, const __CFString *a3)
{
}

void CoreStreamImplementation::_streamImpl_deprecated_Unschedule( CoreStreamImplementation *this, __CFRunLoop *a2, const __CFString *a3)
{
}

uint64_t ___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 160LL))(*(void *)(a1 + 32));
}

uint64_t ___ZN24CoreStreamImplementation28_streamImpl_UpdateSchedulingEPK17CoreSchedulingSetS2__block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 152LL))(*(void *)(a1 + 32));
}

uint64_t CoreReadStreamScheduleWithRunLoop( CoreStreamBase *a1, CoreSchedulingSet *this, const __CFString *cf1)
{
  v5 = a1;
  if (a1)
  {
    v5 = (CoreStreamBase *)((char *)v5 + 16);
  }

  unint64_t v6 = (const CoreSchedulingSet *)CoreSchedulingSet::create(this, cf1, cf1);
  CoreStreamBase::_streamInterface_UpdateScheduling(v5, v6);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v6 + 48LL))(v6);
}

void CoreReadStreamUnscheduleFromRunLoop(CoreStreamBase *this)
{
  uint64_t v1 = this;
  if (this)
  {
    uint64_t v1 = (CoreStreamBase *)((char *)v1 + 16);
  }

  CoreStreamBase::_streamInterface_UpdateScheduling( v1,  (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet);
}

uint64_t CoreWriteStreamScheduleWithRunLoop( CoreStreamBase *a1, CoreSchedulingSet *this, const __CFString *cf1)
{
  v5 = a1;
  if (a1)
  {
    v5 = (CoreStreamBase *)((char *)v5 + 16);
  }

  unint64_t v6 = (const CoreSchedulingSet *)CoreSchedulingSet::create(this, cf1, cf1);
  CoreStreamBase::_streamInterface_UpdateScheduling(v5, v6);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v6 + 48LL))(v6);
}

void CoreWriteStreamUnscheduleFromRunLoop(CoreStreamBase *this)
{
  uint64_t v1 = this;
  if (this)
  {
    uint64_t v1 = (CoreStreamBase *)((char *)v1 + 16);
  }

  CoreStreamBase::_streamInterface_UpdateScheduling( v1,  (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet);
}

void CFStreamCreatePairWithSocketToCFHost( CFAllocatorRef alloc, CFHostRef host, SInt32 port, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
}

void __CFStreamCreatePairWithSocketToCFHost( const __CFAllocator *a1, __CFHost *a2, const __CFAllocator *a3, __CFReadStream **a4, __CFWriteStream **a5, int a6)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v13 = Instance;
    int v14 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B0uLL);
    SocketStream::SocketStream(v14, v15);
    SocketStream::initialize(v16, a2, a3);
    if ((*(unsigned int (**)(SocketStream *, __CFReadStream **, __CFWriteStream **))(*(void *)(v13 + 16)
                                                                                               + 64LL))( v14,  a4,  a5))
    {
      unint64_t v17 = (*(unsigned int *)(v13 + 264) | ((unint64_t)*(unsigned __int16 *)(v13 + 268) << 32)) & 0xFFFFFF7FFFFFFFFFLL;
      __int16 v18 = 128;
      if (!a6) {
        __int16 v18 = 0;
      }
      *(_DWORD *)(v13 + 264) = *(_DWORD *)(v13 + 264);
      *(_WORD *)(v13 + 268) = WORD2(v17) | v18;
    }

    CFRelease((CFTypeRef)v13);
  }

  else
  {
    SocketStream::SocketStream(0LL, v12);
  }

void SocketStream::SocketStream(SocketStream *this, const char *a2)
{
  *(void *)this = &off_189C19F60;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C19AE8;
  *((void *)this + 2) = &unk_189C0A1F0;
  *((void *)this + 3) = off_189C0A0F8;
  _CoreLockable::_CoreLockable((SocketStream *)((char *)this + 32), 1);
  *CFTypeRef v3 = off_189C12688;
  NotificationStation::NotificationStation( (SocketStream *)((char *)this + 104),  (CFTypeRef)SocketStream::observableProperties(void)::observableProps);
  *(void *)this = &off_189C19C20;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C19D20;
  *((void *)this + 2) = &unk_189C19DB8;
  *((void *)this + 3) = &unk_189C19EB8;
  *((void *)this + 4) = &unk_189C19F40;
  *((_DWORD *)this + 62) = 0;
  *((_WORD *)this + 126) = 0;
  *((void *)this + 80) = 0LL;
  *((_OWORD *)this + 4__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  *((void *)this + 85) = 0LL;
  *((_DWORD *)this + 106) = 0;
  *((void *)this + 52) = 0LL;
}

void sub_182A029FC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 32) = off_189C12668;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]( void *****a1, void ****a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::destroy(v2[1]);
    operator delete(v2);
  }

void std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>::reset[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  *a1 = 0LL;
  if (v1)
  {
    uint64_t v2 = (char *)*v1;
    if (*v1)
    {
      CFTypeRef v3 = (char *)v1[1];
      v4 = *v1;
      if (v3 != v2)
      {
        do
        {
          v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
          if (v5) {
            std::__shared_weak_count::__release_weak(v5);
          }
          v3 -= 16;
        }

        while (v3 != v2);
        v4 = *v1;
      }

      v1[1] = v2;
      operator delete(v4);
    }

    operator delete(v1);
  }

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke()
{
  v0 = (CFClass *)operator new(0x68uLL);
  dword_18C5B2D48 = 1835099506;
  _PNAME<SocketStream>::GET(void)::p = *(void *)"SocketStream>::GET() [OBJTYPE = SocketStream]";
  CFClass::CFClass(v0, (const char *)&_PNAME<SocketStream>::GET(void)::p);
  TCFObject<SocketStream>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182A02B3C(_Unwind_Exception *a1)
{
}

void CFStreamCreatePairWithSocketToNetService( CFAllocatorRef alloc, CFNetServiceRef service, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v9 = Instance;
    uint64_t v10 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B0uLL);
    SocketStream::SocketStream(v10, v11);
    SocketStream::initialize(v12, service);
    if ((*(unsigned int (**)(SocketStream *, CFReadStreamRef *, CFWriteStreamRef *))(*(void *)(v9 + 16)
                                                                                               + 64LL))( v10,  readStream,  writeStream))
    {
      *(_WORD *)(v9 + 268) = (*(unsigned int *)(v9 + 264) | ((unint64_t)*(unsigned __int16 *)(v9 + 268) << 32) | 0x8000000000LL) >> 32;
    }

    CFRelease((CFTypeRef)v9);
  }

  else
  {
    SocketStream::SocketStream(0LL, v8);
  }

void _CFStreamCreatePairWithNativeSocket( const __CFAllocator *a1, int a2, __CFReadStream **a3, __CFWriteStream **a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v9 = Instance;
    uint64_t v10 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B0uLL);
    SocketStream::SocketStream(v10, v11);
    *(_DWORD *)bytes = a2;
    SocketStream::commonInitialization(v12);
    *(_DWORD *)(v9 + 264) |= 0x100u;
    uint64_t v13 = CFGetAllocator((CFTypeRef)v9);
    CFDataRef v14 = CFDataCreate(v13, bytes, 4LL);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v9 + 352), &unk_18C5ADD70, v14);
    if (v14) {
      CFRelease(v14);
    }
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v9 + 352), &unk_18C5ADD00, (const void *)*MEMORY[0x189604DE0]);
    if (*(void *)(v9 + 232)) {
      SocketStream::setLoggerPrefixWithNativeHandle(v10, *(unsigned int *)bytes);
    }
    if ((*(unsigned int (**)(SocketStream *, __CFReadStream **, __CFWriteStream **))(*(void *)v10 + 64LL))( v10,  a3,  a4))
    {
      *(_WORD *)(v9 + 268) = (*(unsigned int *)(v9 + 264) | ((unint64_t)*(unsigned __int16 *)(v9 + 268) << 32) | 0x8000000000LL) >> 32;
    }

    CFRelease((CFTypeRef)v9);
  }

  else
  {
    SocketStream::SocketStream(0LL, v8);
  }

void _CFSocketStreamCreatePair( __CFAllocator *a1, const __CFString *a2, const __CFAllocator *a3, int a4, const __CFData **a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  if (a2)
  {
    uint64_t v12 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(a1, a2, (const __CFAllocator *)(unsigned __int16)a3);
    if (v12 || (uint64_t v12 = CFHostCreateWithName(a1, a2)) != 0LL)
    {
      __CFStreamCreatePairWithSocketToCFHost(a1, v12, a3, a6, a7, 1);
      CFRelease(v12);
    }

    else
    {
      if (a6) {
        *a6 = 0LL;
      }
      if (a7) {
        *a7 = 0LL;
      }
    }
  }

  else if (a5)
  {
    _CFStreamCreatePairWithCFSocketSignaturePieces(a1, a5[2], (uint64_t)a6, (uint64_t)a7, (const __CFData *)a5, a6, a7);
  }

  else
  {
    _CFStreamCreatePairWithNativeSocket(a1, a4, a6, a7);
  }

void _CFStreamCreatePairWithCFSocketSignaturePieces( const __CFAllocator *a1, const __CFData *a2, uint64_t a3, uint64_t a4, const __CFData *a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v12 = Instance;
    uint64_t v13 = (SocketStream *)(Instance + 16);
    bzero((void *)(Instance + 16), 0x2B0uLL);
    SocketStream::SocketStream(v13, v14);
    SocketStream::commonInitialization(v15);
    unsigned int v16 = CFGetAllocator((CFTypeRef)v12);
    CFHostRef v17 = CFHostCreateWithAddress(v16, a2);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v12 + 352), &unk_18C5ADDA8, v17);
    CFRelease(v17);
    CFRelease((CFTypeRef)v12);
  }

  else
  {
    SocketStream::SocketStream(0LL, v11);
  }

BOOL _CFHTTPReadStreamIsAtMark(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = a1 + 16;
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  CFTypeRef v3 = (pthread_mutex_t *)(v2 + 136);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 136));
  BOOL v4 = (~(*(unsigned __int16 *)(v2 + 232) | (*(unsigned __int8 *)(v2 + 234) << 16)) & 0x201) == 0;
  pthread_mutex_unlock(v3);
  return v4;
}

uint64_t CFReadStreamCreateHTTPStream(const __CFAllocator *a1, __CFReadStream *a2, int a3)
{
  HTTPStreamWithConnInfo = __CoreReadStreamCreateHTTPStreamWithConnInfo(a1, a2, a3, 0LL);
  uint64_t v5 = _CFReadStreamCreateWithCoreStream((uint64_t)a1, (uint64_t)HTTPStreamWithConnInfo);
  if (HTTPStreamWithConnInfo) {
    CFRelease(HTTPStreamWithConnInfo);
  }
  return v5;
}

_OWORD *__CoreReadStreamCreateHTTPStreamWithConnInfo( const __CFAllocator *a1, __CFReadStream *a2, int a3, HTTPNetConnection *a4)
{
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  unint64_t v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    unint64_t v8 = Instance + 1;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  *((void *)v8 + 15) = &unk_189C18190;
  *((_DWORD *)v8 + 26) = 0;
  *((void *)v8 + 3) = (char *)v8 + 120;
  *(void *)unint64_t v8 = &off_189C18108;
  *((void *)v8 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C18170;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v8 + 8), 1);
  *((void *)v8 + 25) = a4;
  *(void *)unint64_t v8 = &off_189C09798;
  *((void *)v8 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C09838;
  *((void *)v8 + 15) = &unk_189C09858;
  *((void *)v8 + 16) = &unk_189C09910;
  *((_WORD *)v8 + 116) = 0;
  *((_BYTE *)v8 + 234) = 0;
  if (a2) {
    CFTypeRef v9 = CFRetain(a2);
  }
  else {
    CFTypeRef v9 = 0LL;
  }
  *((void *)v8 + 26) = v9;
  uint64_t v10 = CFGetAllocator(v8 - 1);
  *((void *)v8 + 28) = CFHTTPMessageCreateEmpty(v10, a3 == 0);
  *((void *)v8 + 30) = -2LL;
  *((void *)v8 + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *((void *)v8 + 32) = 0LL;
  *((void *)v8 + 33) = 0LL;
  return v8 - 1;
}

void sub_182A031F0(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = &off_189C18298;
  *((void *)v1 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C18300;
  *((void *)v1 + 15) = &unk_189C18320;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

const void *CFWriteStreamCreateHTTPStream( const __CFAllocator *a1, __CFHTTPMessage *a2, int a3, __CFWriteStream *a4)
{
  BOOL result = (const void *)__CoreWriteStreamCreateHTTPStreamWithConnInfo(a1, a2, a3, a4, 0LL);
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = _CFWriteStreamCreateWithCoreStream();
    CFRelease(v5);
    return (const void *)v6;
  }

  return result;
}

uint64_t __CoreWriteStreamCreateHTTPStreamWithConnInfo( const __CFAllocator *a1, __CFHTTPMessage *a2, int a3, __CFWriteStream *a4, HTTPNetConnection *a5)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v10 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v10 = Instance + 16;
    *(void *)(Instance + 304) = 0LL;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 288) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 208) = 0u;
    *(_OWORD *)(Instance + 224) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
  }

  *(void *)(v10 + 120) = &unk_189C04EC8;
  *(_DWORD *)(v10 + 104) = 0;
  *(void *)(v10 + 24) = v10 + 120;
  *(void *)uint64_t v10 = &off_189C04E40;
  *(void *)(v10 + 8) = &unk_189C04EA8;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v10 + 128), 1);
  *(void *)(v10 + 200) = a5;
  *(void *)uint64_t v10 = &off_189C09930;
  *(void *)(v10 + 8) = &unk_189C099D0;
  *(void *)(v10 + 120) = &unk_189C099F0;
  *(void *)(v10 + 128) = &unk_189C09AA8;
  *(_WORD *)(v10 + 224) = 0;
  if (a4)
  {
    CFTypeRef v11 = CFRetain(a4);
    __int16 v12 = *(_WORD *)(v10 + 224);
  }

  else
  {
    __int16 v12 = 0;
    CFTypeRef v11 = 0LL;
  }

  *(void *)(v10 + 208) = v11;
  *(void *)(v10 + 216) = 0LL;
  *(_OWORD *)(v10 + 232) = 0u;
  *(_OWORD *)(v10 + 248) = 0u;
  *(void *)(v10 + 264) = 0LL;
  *(void *)(v10 + 280) = 0LL;
  *(void *)(v10 + 288) = 0LL;
  if (a3)
  {
    v12 |= 0x200u;
    *(_WORD *)(v10 + 224) = v12;
  }

  *(_WORD *)(v10 + 224) = v12 | 4;
  if (a2)
  {
    ++*(void *)(v10 + 80);
    (*(void (**)(void, uint64_t, __CFHTTPMessage *))(**(void **)(v10 + 24) + 32LL))( *(void *)(v10 + 24),  0x18C5B03B8LL,  a2);
    --*(void *)(v10 + 80);
  }

  return v10 - 16;
}

void sub_182A0343C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 128) = off_189C12668;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 136));
  CoreStreamBase::~CoreStreamBase((CoreStreamBase *)v1);
  _Unwind_Resume(a1);
}

CFStringRef HSTSPolicy::copyDebugDesc(HSTSPolicy *this)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<HSTSPolicy@%p <%p>> { HSTSCache=%p }",  (char *)this - 16,  this,  *((void *)this + 2));
}

void non-virtual thunk to'HSTSPolicy::~HSTSPolicy(HSTSPolicy *this)
{
}

{
  HSTSPolicy::~HSTSPolicy((HSTSPolicy *)((char *)this - 8));
}

void HSTSPolicy::~HSTSPolicy(HSTSPolicy *this)
{
  *(void *)this = &off_189C02418;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C02460;
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    if (!*(_BYTE *)(v2 + 73)
      || !os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT)
      || (*(_WORD *)CFTypeRef v3 = 0,
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "Non-private, global HSTS policy is being destroyed.",  v3,  2u),  (uint64_t v2 = *((void *)this + 2)) != 0))
    {
      CFRelease((CFTypeRef)(v2 - 16));
    }
  }

  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C19AE8;
}

void sub_182A03574(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

void ___ZN10HSTSPolicy5ClassEv_block_invoke()
{
  v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "CFHSTSPolicy");
  HSTSPolicy::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182A035BC(_Unwind_Exception *a1)
{
}

void *_CFHSTSPolicyCreateWithProperties(uint64_t a1, CFDictionaryRef theDict)
{
  if (!theDict || CFDictionaryGetValue(theDict, @"hsts_persistent") == (const void *)*MEMORY[0x189604DE0])
  {
    uint64_t Instance = (void *)_CFRuntimeCreateInstance();
    CFTypeRef v3 = Instance;
    if (Instance)
    {
      Instance[2] = 0LL;
      Instance[3] = 0LL;
      CFTypeRef v3 = Instance + 2;
      Instance[4] = 0LL;
    }

    CFTypeRef cf = 0LL;
    HSTSPolicy::HSTSPolicy(v3, a1, 0, (uint64_t *)&cf);
    if (cf) {
      CFRelease(cf);
    }
  }

  else
  {
    CFTypeRef v3 = (void *)HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy;
    CFRetain((CFTypeRef)(HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy - 16));
  }

  if (!v3 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "Must have a valid HSTS Policy now",  v6,  2u);
  }

  return v3 - 2;
}

void sub_182A03720( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void *HSTSPolicy::HSTSPolicy(void *a1, uint64_t a2, int a3, uint64_t *a4)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  *a1 = &off_189C02418;
  a1[1] = &unk_189C02460;
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  unint64_t v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    unint64_t v8 = Instance + 1;
    Instance[5] = 0u;
    Instance[6] = 0u;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }

  CFTypeRef v9 = 0LL;
  uint64_t v10 = *a4;
  *a4 = 0LL;
  *(void *)unint64_t v8 = &off_189C15A10;
  *((void *)v8 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C15A58;
  v8[1] = 0u;
  v8[2] = 0u;
  v8[3] = 0u;
  *((void *)v8 + 8) = v10;
  *((_BYTE *)v8 + 72) = 0;
  *((_BYTE *)v8 + 73) = a3;
  *((void *)v8 + 10) = 0LL;
  char v11 = 1;
  *((_BYTE *)v8 + 88) = 0;
  if (!a3 || !v10)
  {
LABEL_53:
    v28 = CFGetAllocator(v8 - 1);
    Mutable = CFDictionaryCreateMutable(v28, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    if ((v11 & 1) != 0) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  __int16 v12 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v24 = *((void *)v8 + 8);
    *(_DWORD *)propertyValueTypeRefPtr = 134218242;
    *(void *)&propertyValueTypeRefPtr[4] = v8;
    __int16 v46 = 2112;
    uint64_t v47 = v24;
    _os_log_debug_impl( &dword_18298D000,  v12,  OS_LOG_TYPE_DEBUG,  "Using HSTS %p path %@",  propertyValueTypeRefPtr,  0x16u);
  }

  CFErrorRef v42 = 0LL;
  CFErrorRef error = 0LL;
  uint64_t v13 = (const __CFURL *)*((void *)v8 + 8);
  if (!CFURLCopyResourcePropertyForKey(v13, (CFStringRef)*MEMORY[0x189605340], propertyValueTypeRefPtr, &error)) {
    goto LABEL_25;
  }
  CFDataRef v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (!*(void *)propertyValueTypeRefPtr)
  {
    CFErrorRef error = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x189604F50], 1LL, 0LL);
LABEL_25:
    unsigned int v20 = 0LL;
LABEL_26:
    CFTypeRef v9 = 0LL;
    char v22 = 1;
    goto LABEL_43;
  }

  if (!CFNumberGetValue(*(CFNumberRef *)propertyValueTypeRefPtr, kCFNumberCFIndexType, &valuePtr))
  {
    CFIndex v23 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x189604F58], 27LL, 0LL);
LABEL_30:
    unsigned int v20 = 0LL;
    CFErrorRef error = v23;
    goto LABEL_37;
  }

  if (!valuePtr)
  {
    unsigned int v20 = CFDataCreate(v14, 0LL, 0LL);
    goto LABEL_37;
  }

  if (v14) {
    __int16 v15 = v14;
  }
  else {
    __int16 v15 = (const __CFAllocator *)*MEMORY[0x189604DD0];
  }
  unsigned int v16 = CFReadStreamCreateWithFile(v14, v13);
  CFHostRef v17 = v16;
  if (!v16)
  {
    CFIndex v23 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x189604F50], 1LL, 0LL);
    goto LABEL_30;
  }

  if (CFReadStreamOpen(v16))
  {
    __int16 v18 = (UInt8 *)MEMORY[0x186E12804](v15, valuePtr, 0LL);
    if (v18)
    {
      CFIndex v19 = CFReadStreamRead(v17, v18, valuePtr);
      if (v19 < 0)
      {
        unsigned int v21 = CFReadStreamCopyError(v17);
        goto LABEL_34;
      }

      unsigned int v20 = CFDataCreateWithBytesNoCopy(v15, v18, v19, v15);
      if (!v20)
      {
        unsigned int v21 = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x189604F58], 12LL, 0LL);
LABEL_34:
        CFErrorRef error = v21;
        CFAllocatorDeallocate(v15, v18);
        unsigned int v20 = 0LL;
      }
    }

    else
    {
      unsigned int v20 = 0LL;
      CFErrorRef error = CFErrorCreate(v14, (CFErrorDomain)*MEMORY[0x189604F58], 12LL, 0LL);
    }

    CFReadStreamClose(v17);
    goto LABEL_36;
  }

  unsigned int v20 = 0LL;
  CFErrorRef error = CFReadStreamCopyError(v17);
LABEL_36:
  CFRelease(v17);
LABEL_37:
  CFRelease(*(CFTypeRef *)propertyValueTypeRefPtr);
  if (!v20) {
    goto LABEL_26;
  }
  CFPropertyListRef v25 = CFPropertyListCreateWithData(v14, v20, 1uLL, 0LL, &v42);
  CFTypeRef v9 = v25;
  if (v42 || (CFTypeID v26 = CFGetTypeID(v25), v26 == CFDictionaryGetTypeID()) || !v9)
  {
    char v22 = 0;
  }

  else
  {
    CFRelease(v9);
    char v22 = 0;
    CFTypeRef v9 = 0LL;
  }

void sub_182A03CA4(_Unwind_Exception *a1)
{
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v6 = (const void *)v2[8];
  v2[8] = 0LL;
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)v2[7];
  v2[7] = 0LL;
  if (v7) {
    CFRelease(v7);
  }
  unint64_t v8 = (const void *)v2[6];
  v2[6] = 0LL;
  if (v8) {
    CFRelease(v8);
  }
  v2[1] = off_189C19AE8;
  *(void *)(v1 + 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

void ___ZN10HSTSPolicy16getDefaultPolicyEv_block_invoke()
{
  uint64_t v0 = *MEMORY[0x189604DB0];
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  uint64_t v2 = Instance;
  if (Instance)
  {
    Instance[2] = 0LL;
    Instance[3] = 0LL;
    uint64_t v2 = Instance + 2;
    Instance[4] = 0LL;
  }

  CFTypeRef v3 = (CFTypeRef)HSTSCache::defaultStoreURL(void)::cacheFileURL;
  CFTypeRef cf = v3;
  HSTSPolicy::HSTSPolicy(v2, v0, 1, (uint64_t *)&cf);
  HSTSPolicy::getDefaultPolicy(void)::sHSTSPolicy = (uint64_t)v2;
  if (cf) {
    CFRelease(cf);
  }
}

void sub_182A03E40( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void *_CFHSTSPolicyCreateWithStorageLocation(CFURLRef url)
{
  uint64_t v2 = *MEMORY[0x189604DB0];
  if (url) {
    CFURLRef v3 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x189604DB0], url, @"HSTS.plist", 0);
  }
  else {
    CFURLRef v3 = 0LL;
  }
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  uint64_t v5 = Instance;
  if (Instance)
  {
    Instance[2] = 0LL;
    Instance[3] = 0LL;
    uint64_t v5 = Instance + 2;
    Instance[4] = 0LL;
  }

  CFTypeRef cf = v3;
  HSTSPolicy::HSTSPolicy(v5, v2, url != 0LL, (uint64_t *)&cf);
  if (cf) {
    CFRelease(cf);
  }
  return v5 - 2;
}

void sub_182A03F38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

CFDictionaryRef HSTSPolicy::copyExternalRepresentationOfHSTSPolicies(HSTSPolicy *this)
{
  uint64_t v2 = (char *)this - 16;
  CFURLRef v3 = CFGetAllocator((char *)this - 16);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v3, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  uint64_t v5 = *((void *)this + 2);
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  uint64_t v15 = 0LL;
  uint64_t v6 = *(dispatch_queue_s **)(v5 + 16);
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  v11[2] = ___ZNK9HSTSCache40copyInternalRepresentationOfHSTSPoliciesEv_block_invoke;
  v11[3] = &unk_189C19850;
  v11[4] = &v12;
  v11[5] = v5;
  dispatch_sync(v6, v11);
  uint64_t v7 = (const __CFDictionary *)v13[3];
  _Block_object_dispose(&v12, 8);
  if (v7)
  {
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)mapToExternalRepresentation, Mutable);
    CFRelease(v7);
  }

  unint64_t v8 = CFGetAllocator(v2);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(v8, Mutable);
  CFRelease(Mutable);
  return Copy;
}

void mapToExternalRepresentation(const __CFString *a1, CFDictionaryRef theDict, __CFDictionary *a3)
{
  if (a1)
  {
    if (theDict)
    {
      Value = CFDictionaryGetValue(theDict, @"HSTS Host");
      if (Value)
      {
        uint64_t v7 = Value;
        CFTypeID v8 = CFGetTypeID(Value);
        if (v8 == CFBooleanGetTypeID() && v7 == (const void *)*MEMORY[0x189604DE8])
        {
          CFTypeRef v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
          double valuePtr = HSTSParser::getTimeForKey(theDict, (const __CFDictionary *)@"Expiry", v11);
          if (valuePtr > 0.0)
          {
            CFNumberRef v12 = CFNumberCreate(v9, kCFNumberDoubleType, &valuePtr);
            if (v12)
            {
              CFNumberRef v13 = v12;
              CFDictionarySetValue(Mutable, @"_kCFNetworkHSTSExpiry", v12);
              CFRelease(v13);
            }
          }

          uint64_t v14 = CFDictionaryGetValue(theDict, @"Include Subdomains");
          if (v14)
          {
            uint64_t v15 = v14;
            CFTypeID v16 = CFGetTypeID(v14);
            if (v16 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  buf,  2u);
            }

            if (v7 == v15) {
              CFDictionarySetValue(Mutable, @"_kCFNetworkHSTSIncludeSubDomains", v7);
            }
          }

          if (Mutable)
          {
            CFDictionaryRef Copy = CFDictionaryCreateCopy(v9, Mutable);
            CFRelease(Mutable);
            if (Copy)
            {
              CFStringRef v18 = CFStringCreateCopy(v9, a1);
              if (v18)
              {
                CFStringRef v19 = v18;
                CFDictionarySetValue(a3, v18, Copy);
                CFRelease(v19);
              }

              CFRelease(Copy);
            }
          }
        }
      }
    }
  }

void ___ZL15_HSTSIsDisabledv_block_invoke()
{
  CFPropertyListRef v0 = CFPreferencesCopyValue( @"com.apple.CFNetwork.HSTS.DisableHSTS",  (CFStringRef)*MEMORY[0x189605170],  (CFStringRef)*MEMORY[0x189605198],  (CFStringRef)*MEMORY[0x189605178]);
  if (v0)
  {
    uint64_t v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    BOOL v4 = v2 == CFBooleanGetTypeID() && v1 == (const void *)*MEMORY[0x189604DE8];
    _HSTSIsDisabled(void)::sHSTSIsDisabled = v4;
    CFRelease(v1);
  }

const char *HSTSPolicy::isKnownHSTSHost(HSTSPolicy *this, NSString *a2, unsigned __int8 *a3)
{
  BOOL result = -[NSString UTF8String](a2, "UTF8String");
  if (result)
  {
    uint64_t v6 = (unsigned __int8 *)result;
    size_t v7 = strlen(result);
    return (const char *)HSTSPolicy::isKnownHSTSHost(this, v6, v7, a3);
  }

  return result;
}

uint64_t HSTSPolicy::updateHSTSInfoForHost(HSTSPolicy *this, const __CFString *a2, const __CFDictionary *a3)
{
  if (!a3 || HSTSParser::getTimeForKey(a3, (const __CFDictionary *)@"Expiry", v6) == 0.0)
  {
    CFTypeID v8 = (HSTSCache *)*((void *)this + 2);
    CFTypeRef v9 = a2;
    uint64_t v10 = 0LL;
LABEL_10:
    HSTSCache::modifyHSTSStore(v8, v9, v10, 0LL);
    return 1LL;
  }

  if (CFStringGetLength(a2) < 2) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(a2);
  if (CFStringGetCharacterAtIndex(a2, Length - 1) != 46)
  {
    CFTypeID v8 = (HSTSCache *)*((void *)this + 2);
    CFTypeRef v9 = a2;
    uint64_t v10 = a3;
    goto LABEL_10;
  }

  v13.length = CFStringGetLength(a2) - 1;
  v13.location = 0LL;
  uint64_t result = (uint64_t)CFStringCreateWithSubstring(0LL, a2, v13);
  if (result)
  {
    CFNumberRef v12 = (const void *)result;
    HSTSCache::modifyHSTSStore(*((HSTSCache **)this + 2), (CFTypeRef)result, a3, 0LL);
    CFRelease(v12);
    return 1LL;
  }

  return result;
}

uint64_t HSTSPolicy::handleSTSHeader(HSTSPolicy *this, const __CFString *a2, const __CFURL *a3)
{
  CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
  if (!a2) {
    return 1LL;
  }
  v72 = v6;
  v73 = a3;
  v74 = this;
  CFIndex Length = CFStringGetLength(a2);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  CFStringRef theString = a2;
  uint64_t v94 = 0LL;
  CFIndex v95 = Length;
  int64_t v80 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a2);
  CStringPtr = 0LL;
  v92 = (UniChar *)CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a2, 0x600u);
  }
  CFTypeRef cf1 = 0LL;
  CFIndex v11 = 0LL;
  int v79 = 0;
  int64_t v96 = 0LL;
  int64_t v97 = 0LL;
  v93 = CStringPtr;
  CFTypeRef cf2 = (CFTypeRef)*MEMORY[0x189604DE8];
  alloc = (const __CFAllocator *)*MEMORY[0x189604DB0];
  double DoubleValue = -1.0;
  v77 = a2;
  do
  {
    if (v11 >= v80)
    {
      int v33 = 0;
      int64_t v18 = v11;
LABEL_47:
      int64_t v35 = v18;
      goto LABEL_48;
    }

    BOOL v13 = 0;
    int v14 = 0;
    CFIndex v15 = -v11;
    CFIndex v16 = v11 + 64;
    uint64_t v17 = -1LL;
    int64_t v18 = v11;
    while (1)
    {
      else {
        uint64_t v19 = v18;
      }
      if (v18 < 0 || (CFIndex v20 = v95, v95 <= v18))
      {
        UniChar v21 = 0;
        BOOL v22 = !v13;
        goto LABEL_15;
      }

      if (v92)
      {
        UniChar v21 = v92[v18 + v94];
      }

      else if (v93)
      {
        UniChar v21 = v93[v94 + v18];
      }

      else
      {
        if (v97 <= v18 || (int64_t v28 = v96, v96 > v18))
        {
          uint64_t v29 = v19 + v15;
          CFIndex v30 = v16 - v19;
          int64_t v31 = v18 - v19;
          CFIndex v32 = v31 + 64;
          if (v31 + 64 >= v95) {
            CFIndex v32 = v95;
          }
          int64_t v96 = v31;
          int64_t v97 = v32;
          if (v95 >= v30) {
            CFIndex v20 = v30;
          }
          v98.length = v20 + v29;
          v98.location = v31 + v94;
          CFStringGetCharacters(theString, v98, buffer);
          int64_t v28 = v96;
        }

        UniChar v21 = buffer[v18 - v28];
      }

      BOOL v22 = !v13;
      if (!v13 && v21 == 59) {
        break;
      }
      if (!v13 && v21 == 44)
      {
        int v33 = 1;
        goto LABEL_45;
      }

LABEL_107:
            if (v50 == 34) {
              int64_t v55 = v35 - 1;
            }
            else {
              int64_t v55 = v35;
            }
            int64_t v35 = v55 - (v52 == 34);
            v105.length = v35 - v38;
            v105.location = v38;
            CFStringRef v56 = CFStringCreateWithSubstring(alloc, a2, v105);
            v85[0] = MEMORY[0x1895F87A8];
            v85[1] = 3221225472LL;
            v86 = ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke;
            v87 = &__block_descriptor_40_e5_v8__0l;
            CFStringRef v88 = v56;
            if (v56)
            {
              v57 = v56;
              v58 = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
              InvertedSet = CFCharacterSetCreateInvertedSet(0LL, v58);
              v81[0] = MEMORY[0x1895F87A8];
              v81[1] = 3221225472LL;
              v82 = ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke_2;
              v83 = &__block_descriptor_40_e5_v8__0l;
              v84 = InvertedSet;
              v106.length = CFStringGetLength(v57);
              v106.location = 0LL;
              if (!CFStringFindCharacterFromSet(v57, InvertedSet, v106, 0LL, 0LL))
              {
                double DoubleValue = CFStringGetDoubleValue(v57);
                if (DoubleValue > 1.79769313e308) {
                  double DoubleValue = 1.79769313e308;
                }
              }

              v82((uint64_t)v81);
              v86((uint64_t)v85);
            }

            else
            {
              ___ZN10HSTSParser27createHSTSInfoFromSTSHeaderEPK13__CFAllocatorPK10__CFString_block_invoke((uint64_t)v85);
            }

            goto LABEL_64;
          }
        }

        if (!CFCharacterSetIsCharacterMember(Predefined, v42)) {
          goto LABEL_132;
        }
LABEL_64:
        ++v38;
        continue;
      }
    }

    v37 = cf1;
    if (!cf1)
    {
      CFTypeRef cf1 = cf2;
      goto LABEL_134;
    }

    CFTypeRef cf1 = cf2;
    if (CFEqual(v37, cf2)) {
      return 1LL;
    }
LABEL_134:
    if (v18 == v80) {
      break;
    }
    CFIndex v11 = v18 + 1;
  }

  while (!v33);
  if (DoubleValue < 0.0) {
    return 1LL;
  }
  if (cf1)
  {
    CFTypeID v66 = CFGetTypeID(cf1);
    if (v66 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      buffer[0] = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)buffer,  2u);
    }

    BOOL v67 = cf2 == cf1;
  }

  else
  {
    BOOL v67 = 0LL;
  }

  uint64_t updated = 1LL;
  CFDictionaryRef HSTSInfo = HSTSParser::createHSTSInfo(v72, (const __CFAllocator *)v67, DoubleValue, 1, 0LL, v36);
  if (HSTSInfo)
  {
    v69 = HSTSInfo;
    v70 = CFURLCopyHostName(v73);
    if (v70)
    {
      v71 = v70;
      uint64_t updated = HSTSPolicy::updateHSTSInfoForHost(v74, v70, v69);
      CFRelease(v71);
    }

    else
    {
      uint64_t updated = 0LL;
    }

    CFRelease(v69);
  }

  return updated;
}

  v74 = v116;
  v75 = (std::__shared_weak_count *)v116->__shared_weak_owners_;
  if (!v75 || (shared_owners = v116->__shared_owners_, (v77 = std::__shared_weak_count::lock(v75)) == 0LL))
  {
    std::__throw_bad_weak_ptr[abi:nn180100]();
    __break(1u);
    return;
  }

  v78 = v77;
  int v79 = (unint64_t *)&v77->__shared_weak_owners_;
  do
    int64_t v80 = __ldxr(v79);
  while (__stxr(v80 + 1, v79));
  v81 = (std::__shared_weak_count *)v74[1].__shared_owners_;
  v74[1].__vftable = (std::__shared_weak_count_vtbl *)shared_owners;
  v74[1].__shared_owners_ = (uint64_t)v78;
  if (v81) {
    std::__shared_weak_count::__release_weak(v81);
  }
  v82 = (unint64_t *)&v78->__shared_owners_;
  do
    v83 = __ldaxr(v82);
  while (__stlxr(v83 - 1, v82));
  if (!v83)
  {
    ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
    std::__shared_weak_count::__release_weak(v78);
  }

  v84 = *v42;
  v86 = v116;
  v85 = v117;
  v120 = (uint64_t)v116;
  v121 = v117;
  if (v117)
  {
    v87 = (unint64_t *)&v117->__shared_owners_;
    do
      CFStringRef v88 = __ldxr(v87);
    while (__stxr(v88 + 1, v87));
  }

  v89 = (uint64_t *)*((void *)v84 + 6);
  v90 = operator new(0x30uLL);
  v90[2] = v86;
  v90[3] = v85;
  if (v85)
  {
    v91 = (unint64_t *)&v85->__shared_owners_;
    do
      v92 = __ldxr(v91);
    while (__stxr(v92 + 1, v91));
  }

  v90[4] = 0LL;
  v90[5] = 0LL;
  v90[1] = v89;
  v93 = *v89;
  *v90 = *v89;
  *(void *)(v93 + 8) = v90;
  *v89 = (uint64_t)v90;
  ++v89[2];
  TLSCallbackQueue::_invokeNextCallback(v84);
  if (v85)
  {
    uint64_t v94 = (unint64_t *)&v85->__shared_owners_;
    do
      CFIndex v95 = __ldaxr(v94);
    while (__stlxr(v95 - 1, v94));
    if (!v95)
    {
      ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
      std::__shared_weak_count::__release_weak(v85);
    }
  }

  int64_t v96 = v117;
  if (v117)
  {
    int64_t v97 = (unint64_t *)&v117->__shared_owners_;
    do
      CFRange v98 = __ldaxr(v97);
    while (__stlxr(v98 - 1, v97));
    if (!v98)
    {
      ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
      std::__shared_weak_count::__release_weak(v96);
    }
  }

  if (v119) {
    std::__shared_weak_count::__release_weak(v119);
  }
  CFRange v99 = v130;
  if (v130)
  {
    CFRange v100 = (unint64_t *)&v130->__shared_owners_;
    do
      CFRange v101 = __ldaxr(v100);
    while (__stlxr(v101 - 1, v100));
    if (!v101)
    {
      ((void (*)(std::__shared_weak_count *))v99->__on_zero_shared)(v99);
      std::__shared_weak_count::__release_weak(v99);
    }
  }

  CFRange v102 = v128;
  if (v128)
  {
    CFRange v103 = (unint64_t *)&v128->__shared_owners_;
    do
      CFRange v104 = __ldaxr(v103);
    while (__stlxr(v104 - 1, v103));
    if (!v104)
    {
      ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
      std::__shared_weak_count::__release_weak(v102);
    }
  }

  if (v126) {
    std::__shared_weak_count::__release_weak(v126);
  }
  if (v47) {
    std::__shared_weak_count::__release_weak(v47);
  }
  do
LABEL_43:
    int v33 = __ldaxr(v18);
  while (__stlxr(v33 - 1, v18));
  if (!v33)
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }

  if (v108)
  {
    BOOL v34 = (unint64_t *)&v108->__shared_owners_;
    do
      int64_t v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
      std::__shared_weak_count::__release_weak(v108);
    }
  }

  CFMutableDictionaryRef v36 = v111;
  if (v111)
  {
    v37 = (unint64_t *)&v111->__shared_owners_;
    do
      CFIndex v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }

  int64_t v39 = v113;
  if (v113)
  {
    dispatch_queue_t v40 = (unint64_t *)&v113->__shared_owners_;
    do
      CFIndex v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }

  uint64_t v10 = v115;
  if (v115) {
    goto LABEL_9;
  }
}

void sub_182A04CBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, void (*a28)(char *))
{
}

void NotificationStation::notifyPropertyChanged( NotificationStation *this, const __CFString *value, const void *a3)
{
  if (*((_BYTE *)this + 88) || (int v23 = (const __CFSet *)*((void *)this + 9)) != 0LL && CFSetContainsValue(v23, value))
  {
    CFAllocatorRef v6 = (std::mutex *)((char *)this + 8);
    std::mutex::lock((std::mutex *)((char *)this + 8));
    uint64_t v7 = *(void *)this;
    if (!*(void *)this) {
      goto LABEL_31;
    }
    if (value) {
      CFRetain(value);
    }
    CFStringRef v24 = value;
    int64_t v25 = CFTypeRefRelease<__CFString const*>;
    uint64_t v8 = std::__tree<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,std::__map_value_compare<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>,CFStringRefComp,true>,std::allocator<std::__value_type<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>::find<std::unique_ptr<__CFString const,void (*)(__CFString const*)>>( v7,  &v24);
    if (value) {
      CFTypeRefRelease<__CFString const*>(value);
    }
    if (*(void *)this + 8LL == v8)
    {
LABEL_31:
      std::mutex::unlock(v6);
      return;
    }

    CFTypeRef v9 = *(__int128 ***)(v8 + 48);
    uint64_t v10 = *v9;
    while (1)
    {
      if (v10 == v9[1]) {
        goto LABEL_31;
      }
      CFStringRef v24 = 0LL;
      int64_t v25 = 0LL;
      CFIndex v11 = (std::__shared_weak_count *)*((void *)v10 + 1);
      if (v11)
      {
        CFNumberRef v12 = std::__shared_weak_count::lock(v11);
        int64_t v25 = (void (*)(CFTypeRef))v12;
        if (v12)
        {
          BOOL v13 = *(const __CFString **)v10;
          CFStringRef v24 = v13;
          if (v13)
          {
            (*((void (**)(const __CFString *, const __CFString *, const void *))v13->isa + 2))( v13,  value,  a3);
            ++v10;
LABEL_26:
            p_shared_owners = (unint64_t *)&v12->__shared_owners_;
            do
              unint64_t v22 = __ldaxr(p_shared_owners);
            while (__stlxr(v22 - 1, p_shared_owners));
            if (!v22)
            {
              ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
              std::__shared_weak_count::__release_weak(v12);
            }

            goto LABEL_30;
          }
        }
      }

      else
      {
        CFNumberRef v12 = 0LL;
      }

      uint64_t v14 = *(void *)(v8 + 48);
      CFIndex v15 = v10 + 1;
      CFIndex v16 = *(__int128 **)(v14 + 8);
      if (v10 + 1 == v16)
      {
        uint64_t v17 = v10;
      }

      else
      {
        do
        {
          uint64_t v17 = v15;
          __int128 v18 = *v15;
          *(void *)CFIndex v15 = 0LL;
          *((void *)v15 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
          uint64_t v19 = (std::__shared_weak_count *)*((void *)v15 - 1);
          *(v15 - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v18;
          if (v19) {
            std::__shared_weak_count::__release_weak(v19);
          }
          ++v15;
        }

        while (v17 + 1 != v16);
        CFIndex v15 = *(__int128 **)(v14 + 8);
      }

      while (v15 != v17)
      {
        CFIndex v20 = (std::__shared_weak_count *)*((void *)v15 - 1);
        if (v20) {
          std::__shared_weak_count::__release_weak(v20);
        }
        --v15;
      }

      *(void *)(v14 + 8) = v17;
      if (v12) {
        goto LABEL_26;
      }
LABEL_30:
      CFTypeRef v9 = *(__int128 ***)(v8 + 48);
    }
  }

void sub_182A04ECC(_Unwind_Exception *a1)
{
}

CFTypeID CFHTTPMessageGetTypeID(void)
{
  return *(void *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96);
}

CFHTTPMessageRef CFHTTPMessageCreateRequest( CFAllocatorRef alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = (HTTPRequestMessage *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v8 = (HTTPRequestMessage *)(Instance + 16);
    *(void *)(Instance + 192) = 0LL;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }

  HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)&v12, requestMethod);
  HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v10, httpVersion);
  HTTPRequestMessage::HTTPRequestMessage(v8, (CFTypeRef *)&v12, url, cf);
  uint64_t v10 = off_189C16E38;
  if (cf) {
    CFRelease(cf);
  }
  CFNumberRef v12 = off_189C16E38;
  if (v13) {
    CFRelease(v13);
  }
  return (HTTPRequestMessage *)((char *)v8 - 16);
}

void sub_182A05044( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, CFTypeRef a12)
{
  if (cf) {
    CFRelease(cf);
  }
  if (a12) {
    CFRelease(a12);
  }
  _Unwind_Resume(exception_object);
}

CFHTTPMessageRef CFHTTPMessageCreateResponse( CFAllocatorRef alloc, CFIndex statusCode, CFStringRef statusDescription, CFStringRef httpVersion)
{
  __int16 v6 = statusCode;
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v8 = (uint64_t)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v8 = (uint64_t)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v10, httpVersion);
  HTTPResponseMessage::HTTPResponseMessage(v8, v6 & 0x3FF, statusDescription, cf);
  uint64_t v10 = off_189C16E38;
  if (cf) {
    CFRelease(cf);
  }
  return (CFHTTPMessageRef)(v8 - 16);
}

void sub_182A05178( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

char *_CFHTTPMessageCreateResponseNoParser(uint64_t a1, __int16 a2, const void *a3, const __CFString *a4)
{
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v8 = (HTTPMessage *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v8 = (HTTPMessage *)(Instance + 1);
    Instance[18] = 0u;
    Instance[19] = 0u;
    Instance[16] = 0u;
    Instance[17] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v10, a4);
  HTTPResponseMessage::HTTPResponseMessage((uint64_t)v8, a2 & 0x3FF, a3, cf);
  uint64_t v10 = off_189C16E38;
  if (cf) {
    CFRelease(cf);
  }
  if (!v8) {
    return 0LL;
  }
  HTTPMessage::ensureParserFinished(v8);
  return (char *)v8 - 16;
}

void sub_182A052A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

Boolean CFHTTPMessageIsRequest(CFHTTPMessageRef message)
{
  CFTypeID v2 = (char *)message + 16;
  if (!message) {
    CFTypeID v2 = 0LL;
  }
  return v2[24] == 0;
}

void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData)
{
  if (!bodyData || (CFTypeID v4 = CFGetTypeID(bodyData), v4 == CFDataGetTypeID()))
  {
    if (message) {
      uint64_t v5 = (char *)message + 16;
    }
    else {
      uint64_t v5 = 0LL;
    }
    (*(void (**)(char *, CFDataRef))(*(void *)v5 + 64LL))(v5, bodyData);
  }

void CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef value)
{
  if (message) {
    __int16 v6 = (CFHTTPMessageRef)((char *)message + 16);
  }
  else {
    __int16 v6 = 0LL;
  }
  HTTPMessage::setHeaderFieldStringValue(v6, headerField, value);
}

void _CFHTTPMessageAddHeaderFieldValue(uint64_t a1, __CFString *a2, __CFString *a3)
{
  if (a1) {
    __int16 v6 = (HTTPMessage *)(a1 + 16);
  }
  else {
    __int16 v6 = 0LL;
  }
  HTTPMessage::addHeaderFieldStringValue(v6, a2, a3);
}

Boolean CFHTTPMessageIsHeaderComplete(CFHTTPMessageRef message)
{
  CFTypeID v2 = (char *)message + 16;
  if (!message) {
    CFTypeID v2 = 0LL;
  }
  return *((void *)v2 + 11) == 0LL;
}

CFDataRef CFHTTPMessageCopySerializedMessage(CFHTTPMessageRef message)
{
  if (message) {
    CFTypeID v2 = (CFHTTPMessageRef)((char *)message + 16);
  }
  else {
    CFTypeID v2 = 0LL;
  }
  CFURLRef v3 = HTTPMessage::copySerializedHeaders(v2, 0LL);
  if (v3)
  {
    uint64_t v5 = v3;
    __int16 v6 = (const __CFData **)*((void *)v2 + 6);
    if (!v6) {
      return v5;
    }
    CFIndex Length = HTTPBodyData::getLength(v6, v4);
    uint64_t v8 = CFGetAllocator((char *)v2 - 16);
    CFIndex v9 = CFDataGetLength(v5);
    CFMutableDictionaryRef MutableCopy = CFDataCreateMutableCopy(v8, (CFIndex)Length + v9, v5);
    CFRelease(v5);
    CFIndex v11 = (HTTPBodyData *)*((void *)v2 + 6);
    HTTPBodyData::logit(v11, v12);
    CFTypeRef v13 = (const __CFData *)*((void *)v11 + 2);
    if (v13 || (CFTypeRef v13 = (const __CFData *)*((void *)v11 + 3)) != 0LL) {
      BytePtr = CFDataGetBytePtr(v13);
    }
    else {
      BytePtr = 0LL;
    }
    CFDataAppendBytes(MutableCopy, BytePtr, (CFIndex)Length);
    if (!message) {
      return MutableCopy;
    }
  }

  else
  {
    CFMutableDictionaryRef MutableCopy = 0LL;
    if (!message) {
      return MutableCopy;
    }
  }

  if (MutableCopy) {
    return MutableCopy;
  }
  if (!*((_BYTE *)message + 40)) {
    return 0LL;
  }
  if (*((void *)message + 38)) {
    return 0LL;
  }
  if (*((_BYTE *)message + 176)) {
    return 0LL;
  }
  int v16 = *((_DWORD *)message + 36);
  if (v16 != 200 && v16 != -1) {
    return 0LL;
  }
  uint64_t v17 = CFGetAllocator(message);
  return CFDataCreate(v17, (const UInt8 *)"\r\n\r\n", 4LL);
}

CFStringRef CFHTTPMessageCopyResponseStatusLine(CFHTTPMessageRef response)
{
  if (!response) {
    return 0LL;
  }
  if (!*((_BYTE *)response + 40)) {
    return 0LL;
  }
  uint64_t v2 = *((void *)response + 38);
  if (v2 || *((_BYTE *)response + 176))
  {
    if (v2) {
      CFURLRef v3 = (const char *)*((void *)response + 38);
    }
    else {
      CFURLRef v3 = (char *)response + 176;
    }
  }

  else
  {
    CFURLRef v3 = (const char *)(*(uint64_t (**)(char *, void))(*((void *)response + 2) + 88LL))( (char *)response + 16,  0LL);
  }

  if (v3) {
    CFTypeID v4 = v3;
  }
  else {
    CFTypeID v4 = "";
  }
  uint64_t v5 = CFGetAllocator(response);
  return CFStringCreateWithCString(v5, v4, 0x201u);
}

void _CFHTTPMessageSetMultipleHeaderFields(__CFHTTPMessage *a1, CFDictionaryRef theDict)
{
  if (a1) {
    CFTypeID v4 = (__CFHTTPMessage *)((char *)a1 + 16);
  }
  else {
    CFTypeID v4 = 0LL;
  }
  HTTPMessage::setMultipleHeaderFields(v4, theDict);
}

void _CFHTTPMessageSetResponseProxyURL(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 40)) {
      HTTPResponseMessage::setResponseURL((HTTPResponseMessage *)(a1 + 16), cf, 1);
    }
  }

uint64_t _CFHTTPMessageGetAuthentication(__CFHTTPMessage *a1, int a2)
{
  CFTypeID v4 = (char *)a1 + 16;
  if (!a1) {
    CFTypeID v4 = 0LL;
  }
  uint64_t v5 = 80LL;
  if (!a2) {
    uint64_t v5 = 72LL;
  }
  return *(void *)&v4[v5];
}

CFTypeRef _CFHTTPMessageSetAuthentication(__CFHTTPMessage *a1, CFTypeRef cf, int a3)
{
  if (a1) {
    __int16 v6 = (char *)a1 + 16;
  }
  else {
    __int16 v6 = 0LL;
  }
  if (a3) {
    uint64_t v7 = 80LL;
  }
  else {
    uint64_t v7 = 72LL;
  }
  CFTypeRef result = *(CFTypeRef *)&v6[v7];
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0LL;
    }
    *(void *)&v6[v7] = result;
  }

  return result;
}

void sub_182A05E80(_Unwind_Exception *a1)
{
}

void sub_182A06BAC(_Unwind_Exception *a1)
{
}

uint64_t __copy_helper_block_e8_48c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE( uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 4_Block_object_dispose((const void *)(v1 - 112), 8) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2)
  {
    CFURLRef v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_48c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void __Block_byref_object_copy__456(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__457(uint64_t a1)
{
}

void _CFHSTSPolicyResetHSTSHostsSinceDate(uint64_t a1, CFTypeRef a2)
{
  uint64_t v4 = a1 + 16;
  if (!a1) {
    uint64_t v4 = 0LL;
  }
  HSTSCache::modifyHSTSStore(*(HSTSCache **)(v4 + 16), 0LL, 0LL, a2);
}

void std::__shared_ptr_pointer<__CFString *,Deleter_CFRelease,std::allocator<__CFString>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void sub_182A08580( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_182A09A90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void __Block_byref_object_copy__575(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__576(uint64_t a1)
{
}

uint64_t ___ZL13countSegmentsPU27objcproto16OS_dispatch_data8NSObject_block_invoke(uint64_t a1)
{
  return 1LL;
}

uint64_t ___ZL17resumeDataClassesv_block_invoke()
{
  CFPropertyListRef v0 = (void *)MEMORY[0x189603FE0];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend( v0,  "setWithObjects:",  v1,  v2,  v3,  v4,  v5,  v6,  objc_opt_class(),  0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    uint64_t v8 = [*(id *)(v1 + 2616) knownSZExtractorImplementations];
    [(id)resumeDataClasses(void)::resumeDataClasses unionSet:v8];
  }

  uint64_t result = objc_opt_class();
  if (result)
  {
    CFIndex v11 = (void *)resumeDataClasses(void)::resumeDataClasses;
    gotLoadHelper_x8__OBJC_CLASS___STRemoteExtractor(v10);
    return [v11 addObject:objc_opt_class()];
  }

  return result;
}

uint64_t BlockHolderVar<>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16LL))();
}

void std::unique_ptr<std::set<std::shared_ptr<void>>>::reset[abi:nn180100](void ***a1, void **a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    std::__tree<std::shared_ptr<void>>::destroy(v2[1]);
    operator delete(v2);
  }

void ___ZN14HTTPStallTimer5setupEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 40);
        if (v6)
        {
          if (*(void *)(v6 + 16))
          {
            std::__tree<std::shared_ptr<void>>::destroy(*(void **)(v6 + 8));
            *(void *)uint64_t v6 = v6 + 8;
            *(void *)(v6 + 16) = 0LL;
            *(void *)(v6 + _Block_object_dispose(va, 8) = 0LL;
            uint64_t v7 = *(void *)(v5 + 48);
            if (v7)
            {
              uint64_t v8 = *(void (**)(void *))(v7 + 8);
              uint64_t v9 = *(void *)(v7 + 16);
              double v10 = (void *)(v7 + (v9 >> 1));
              if ((v9 & 1) != 0) {
                uint64_t v8 = *(void (**)(void *))(*v10 + v8);
              }
              v8(v10);
            }
          }
        }
      }

      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A0C8C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN14HTTPStallTimer3addENSt3__110shared_ptrIvEE_block_invoke(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = a1[4];
      if (v5)
      {
        uint64_t v6 = *(uint64_t ***)(v5 + 40);
        uint64_t v8 = v6 + 1;
        uint64_t v7 = v6[1];
        if (v7)
        {
          unint64_t v9 = a1[6];
          while (1)
          {
            while (1)
            {
              double v10 = (uint64_t **)v7;
              unint64_t v11 = v7[4];
              if (v9 >= v11) {
                break;
              }
              uint64_t v7 = *v10;
              uint64_t v8 = v10;
              if (!*v10) {
                goto LABEL_13;
              }
            }

            if (v11 >= v9) {
              break;
            }
            uint64_t v7 = v10[1];
            if (!v7)
            {
              uint64_t v8 = v10 + 1;
              goto LABEL_13;
            }
          }
        }

        else
        {
          double v10 = v6 + 1;
LABEL_13:
          unint64_t v12 = (uint64_t *)operator new(0x30uLL);
          CFTypeRef v13 = v12;
          uint64_t v14 = a1[7];
          v12[4] = a1[6];
          v12[5] = v14;
          if (v14)
          {
            CFIndex v15 = (unint64_t *)(v14 + 8);
            do
              unint64_t v16 = __ldxr(v15);
            while (__stxr(v16 + 1, v15));
          }

          uint64_t *v12 = 0LL;
          v12[1] = 0LL;
          v12[2] = (uint64_t)v10;
          *uint64_t v8 = v12;
          uint64_t v17 = (uint64_t *)**v6;
          if (v17)
          {
            *uint64_t v6 = v17;
            CFTypeRef v13 = *v8;
          }

          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v6[1], v13);
          v6[2] = (uint64_t *)((char *)v6[2] + 1);
          uint64_t v6 = *(uint64_t ***)(v5 + 40);
        }

        if (v6[2] == (uint64_t *)1)
        {
          __int128 v18 = *(dispatch_source_s **)(v5 + 32);
          dispatch_time_t v19 = dispatch_time(0x8000000000000000LL, 3000000000LL);
          dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
        }
      }

      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A0CA60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>( uint64_t *result, uint64_t *a2)
{
  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            unint64_t v9 = (uint64_t **)a2[2];
          }

          else
          {
            unint64_t v9 = (uint64_t **)v2[1];
            double v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }

            v9[2] = v3;
            *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = v9;
            *unint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }

          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }

      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }

          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }

        else
        {
          a2 = (uint64_t *)a2[2];
        }

        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }

      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      _BYTE *v5 = 1;
    }

    while (v3 != result);
  }

  return result;
}

void ___ZN14HTTPStallTimer6removeENSt3__110shared_ptrIvEE_block_invoke(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (!v2) {
    return;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return;
  }
  uint64_t v4 = v3;
  uint64_t v5 = a1[4];
  if (!v5) {
    goto LABEL_32;
  }
  int v6 = *(uint64_t ***)(v5 + 40);
  uint64_t v7 = v6[1];
  if (!v7) {
    goto LABEL_32;
  }
  unint64_t v8 = a1[6];
  unint64_t v9 = v6[1];
  while (1)
  {
    unint64_t v10 = v9[4];
    if (v8 >= v10) {
      break;
    }
LABEL_9:
    unint64_t v9 = (uint64_t *)*v9;
    if (!v9) {
      goto LABEL_32;
    }
  }

  if (v10 < v8)
  {
    ++v9;
    goto LABEL_9;
  }

  uint64_t v11 = (uint64_t *)(v6 + 1);
  uint64_t v12 = v6[1];
  do
  {
    unint64_t v13 = v12[4];
    BOOL v14 = v13 >= v8;
    if (v13 >= v8) {
      CFIndex v15 = (uint64_t **)v12;
    }
    else {
      CFIndex v15 = (uint64_t **)(v12 + 1);
    }
    if (v14) {
      uint64_t v11 = v12;
    }
    uint64_t v12 = *v15;
  }

  while (*v15);
  if (v11 != (uint64_t *)(v6 + 1) && v8 >= v11[4])
  {
    unint64_t v16 = (uint64_t *)v11[1];
    if (v16)
    {
      do
      {
        uint64_t v17 = v16;
        unint64_t v16 = (uint64_t *)*v16;
      }

      while (v16);
    }

    else
    {
      __int128 v18 = v11;
      do
      {
        uint64_t v17 = (uint64_t *)v18[2];
        BOOL v19 = *v17 == (void)v18;
        __int128 v18 = v17;
      }

      while (!v19);
    }

    if (*v6 == v11) {
      *int v6 = v17;
    }
    v6[2] = (uint64_t *)((char *)v6[2] - 1);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v7, v11);
    std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v11 + 4));
    operator delete(v11);
    int v6 = *(uint64_t ***)(v5 + 40);
  }

  if (!v6[2]) {
    dispatch_source_set_timer(*(dispatch_source_t *)(v5 + 32), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  }
LABEL_32:
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    unint64_t v21 = __ldaxr(p_shared_owners);
  while (__stlxr(v21 - 1, p_shared_owners));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }

    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }

  int v5 = 1;
LABEL_8:
  int v6 = (uint64_t **)v3[2];
  uint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *int v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      uint64_t v7 = 0LL;
      uint64_t result = (uint64_t *)v2;
    }

    else
    {
      uint64_t v7 = v6[1];
    }
  }

  else
  {
    v6[1] = (uint64_t *)v2;
  }

  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8LL * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *uint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }

  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }

  while (1)
  {
    uint64_t v12 = v7[2];
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      uint64_t v18 = v7[1];
      *(void *)uint64_t v12 = v18;
      if (v18) {
        *(void *)(v18 + 16) = v12;
      }
      v7[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8LL * (**(void **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(void *)(v12 + 16) = v7;
      uint64_t v7 = *(uint64_t **)v12;
    }

    BOOL v19 = (void *)*v7;
    if (*v7 && !*((_BYTE *)v19 + 24)) {
      goto LABEL_68;
    }
    CFIndex v20 = (uint64_t *)v7[1];
    if (v20 && !*((_BYTE *)v20 + 24))
    {
      if (v19 && !*((_BYTE *)v19 + 24))
      {
LABEL_68:
        CFIndex v20 = v7;
      }

      else
      {
        *((_BYTE *)v20 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        uint64_t v26 = *v20;
        v7[1] = *v20;
        if (v26) {
          *(void *)(v26 + 16) = v7;
        }
        v20[2] = v7[2];
        *(void *)(v7[2] + 8LL * (*(void *)v7[2] != (void)v7)) = v20;
        uint64_t *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        BOOL v19 = v7;
      }

      uint64_t v23 = v20[2];
      *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      CFStringRef v24 = *(uint64_t **)v23;
      uint64_t v27 = *(void *)(*(void *)v23 + 8LL);
      *(void *)uint64_t v23 = v27;
      if (v27) {
        *(void *)(v27 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8LL * (**(void **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }

    *((_BYTE *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
LABEL_49:
    uint64_t v7 = *(uint64_t **)(v17[2] + 8LL * (*(void *)v17[2] == (void)v17));
  }

  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    unint64_t v13 = *(uint64_t **)(v12 + 8);
    uint64_t v14 = *v13;
    *(void *)(v12 + _Block_object_dispose(va, 8) = *v13;
    if (v14) {
      *(void *)(v14 + 16) = v12;
    }
    v13[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8LL * (**(void **)(v12 + 16) != v12)) = v13;
    uint64_t *v13 = v12;
    *(void *)(v12 + 16) = v13;
    uint64_t v7 = *(uint64_t **)(*v7 + 8);
  }

  CFIndex v15 = (void *)*v7;
  if (!*v7 || *((_BYTE *)v15 + 24))
  {
    unint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24)) {
      goto LABEL_59;
    }
    *((_BYTE *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }

    if (!*((_BYTE *)v17 + 24)) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }

  unint64_t v16 = (uint64_t *)v7[1];
  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_59:
    CFIndex v15 = v7;
  }

  else
  {
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    uint64_t v22 = v15[1];
    uint64_t *v7 = v22;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    v15[2] = v7[2];
    *(void *)(v7[2] + 8LL * (*(void *)v7[2] != (void)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    unint64_t v16 = v7;
  }

  uint64_t v23 = v15[2];
  *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  CFStringRef v24 = *(uint64_t **)(v23 + 8);
  uint64_t v25 = *v24;
  *(void *)(v23 + _Block_object_dispose(va, 8) = *v24;
  if (v25) {
    *(void *)(v25 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8LL * (**(void **)(v23 + 16) != v23)) = v24;
  *CFStringRef v24 = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

void sub_182A0D2C0(_Unwind_Exception *a1)
{
}

void TunnelProxy<HTTPEngine>::~TunnelProxy(NetworkProxy *a1)
{
}

{
  dispatch_object_s *v2;
  const void *v3;
  *(void *)a1 = off_189C02728;
  *((void *)a1 + 13) = &unk_189C027D0;
  uint64_t v2 = (dispatch_object_s *)*((void *)a1 + 24);
  if (v2) {
    dispatch_release(v2);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 256);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 240);
  uint64_t v3 = (const void *)*((void *)a1 + 29);
  *((void *)a1 + 29) = 0LL;
  if (v3) {
    CFRelease(v3);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 216);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 176);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 160);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 144);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 128);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 112);
  NetworkProxy::~NetworkProxy(a1);
}

const __CFString *TunnelProxy<HTTPEngine>::prettyType()
{
  return @"https";
}

CFTypeRef TunnelProxy<HTTPEngine>::copyCONNECTEndpointProperties(uint64_t a1)
{
  uint64_t v2 = CFNumberCreate(0LL, kCFNumberCFIndexType, (const void *)(a1 + 40));
  uint64_t v3 = _newConnPropsForHTTPSProxy(0LL, *(__CFHTTPMessage **)(a1 + 232), *(__CFString **)(a1 + 24), v2);
  uint64_t v4 = v3;
  if (!v3)
  {
    CFTypeRef v6 = 0LL;
    if (!v2) {
      return v6;
    }
    goto LABEL_8;
  }

  Value = CFDictionaryGetValue(v3, &unk_18C5B2450);
  if (Value) {
    CFTypeRef v6 = CFRetain(Value);
  }
  else {
    CFTypeRef v6 = 0LL;
  }
  CFRelease(v4);
  if (v2) {
LABEL_8:
  }
    CFRelease(v2);
  return v6;
}

void sub_182A0D3E8(_Unwind_Exception *a1)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t TunnelProxy<HTTPEngine>::getType()
{
  return 3LL;
}

uint64_t NetworkProxy::getPort(NetworkProxy *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t NetworkProxy::host@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  *a2 = *(void *)(this + 24);
  a2[1] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return this;
}

uint64_t NetworkProxy::getEndpointHost@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 56);
  *a2 = *(void *)(this + 48);
  a2[1] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return this;
}

uint64_t NetworkProxy::getEndpointPort(NetworkProxy *this)
{
  return *((unsigned int *)this + 16);
}

void TunnelProxy<HTTPEngine>::establishProxyConnection(uint64_t a1, uint64_t *a2)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  unint64_t v4 = CFStringCreateWithFormat(0LL, 0LL, @"%@:%d", *(void *)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
  int v5 = CFURLCreateWithString(0LL, v4, 0LL);
  if (v5)
  {
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v7 = (HTTPRequestMessage *)Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 16) = 0u;
      uint64_t v7 = (HTTPRequestMessage *)(Instance + 16);
      *(void *)(Instance + 192) = 0LL;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
    }

    HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)v44, (CFStringRef)&unk_18C5B00E0);
    HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v42, @"HTTP/1.1");
    HTTPRequestMessage::HTTPRequestMessage(v7, v44, v5, cf);
    CFIndex v41 = v7;
    UniChar v42 = off_189C16E38;
    if (cf) {
      CFRelease(cf);
    }
    v44[0] = off_189C16E38;
    if (v44[1]) {
      CFRelease(v44[1]);
    }
    int v8 = v4;
    if (*(_DWORD *)(a1 + 64) == 443) {
      int v8 = *(const __CFString **)(a1 + 48);
    }
    HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_18C5AF0E8, v8);
    if ((dyld_program_sdk_at_least() & 1) != 0) {
      goto LABEL_19;
    }
    uint64_t v9 = *(void *)(a1 + 232);
    uint64_t v10 = v9 ? (HTTPMessage *)(v9 + 16) : 0LL;
    uint64_t v11 = HTTPMessage::copyHeaderFieldValue(v10, 0x14E15421u);
    if (!v11)
    {
LABEL_19:
      pthread_once(&initControl, initializeUserAgentString);
      if (sUserAgentString)
      {
        pthread_once(&initControl, initializeUserAgentString);
        uint64_t v11 = (const __CFString *)CFRetain((CFTypeRef)sUserAgentString);
      }

      else
      {
        uint64_t v11 = 0LL;
      }
    }

    HTTPMessage::setHeaderFieldStringValue(v7, @"User-Agent", v11);
    uint64_t v14 = *(void *)(a1 + 232);
    if (v14) {
      CFIndex v15 = (HTTPMessage *)(v14 + 16);
    }
    else {
      CFIndex v15 = 0LL;
    }
    unint64_t v16 = HTTPMessage::copyHeaderFieldValue(v15, 0x1382736Bu);
    if (v16) {
      HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_18C5AF430, v16);
    }
    HTTPMessage::setHeaderFieldStringValue(v7, (const __CFString *)&unk_18C5AF468, @"keep-alive");
    HTTPMessage::setHeaderFieldStringValue(v7, @"Connection", @"keep-alive");
    if (v16) {
      CFRelease(v16);
    }
    if (v11) {
      CFRelease(v11);
    }
    CFRelease(v5);
    if (v4) {
LABEL_40:
    }
      CFRelease(v4);
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v12 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v13 = *(const void **)(a1 + 48);
      LODWORD(v44[0]) = 138412290;
      *(CFTypeRef *)((char *)v44 + 4) = v13;
      _os_log_impl( &dword_18298D000,  v12,  OS_LOG_TYPE_DEFAULT,  "Invalid URL for CONNECT request %@",  (uint8_t *)v44,  0xCu);
    }

    *(void *)(a1 + 200) = 4LL;
    *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = -2096;
    CFIndex v41 = 0LL;
    if (v4) {
      goto LABEL_40;
    }
  }

  uint64_t v17 = *std::shared_ptr<HTTPRequestMessage>::operator=[abi:nn180100]<HTTPRequestMessage,Deleter_release<HTTPRequestMessage>,void>( (void *)(a1 + 160),  (uint64_t *)&v41);
  if (v41) {
    CFRelease((char *)v41 - 16);
  }
  if (v17)
  {
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>( &v42,  *(void *)(a1 + 8),  *(std::__shared_weak_count **)(a1 + 16),  a1);
    std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>( (uint64_t *)v44,  *(void *)(a1 + 128),  *(std::__shared_weak_count **)(a1 + 136),  (uint64_t *)&v42);
    uint64_t v18 = (uint64_t *)(a1 + 112);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 112, (__int128 *)v44);
    BOOL v19 = (std::__shared_weak_count *)v44[1];
    if (v44[1])
    {
      CFIndex v20 = (unint64_t *)((char *)v44[1] + 8);
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }

    uint64_t v22 = (std::__shared_weak_count *)cf;
    if (cf)
    {
      uint64_t v23 = (unint64_t *)((char *)cf + 8);
      do
        unint64_t v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }

    v44[0] = 0LL;
    v44[1] = 0LL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 128, (__int128 *)v44);
    uint64_t v25 = (std::__shared_weak_count *)v44[1];
    if (v44[1])
    {
      uint64_t v26 = (unint64_t *)((char *)v44[1] + 8);
      do
        unint64_t v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }

    HTTPEngine::initialize(*v18, 3);
    *(_DWORD *)(*v18 + 32) |= 8u;
    uint64_t v28 = *a2;
    uint64_t v29 = (std::__shared_weak_count *)a2[1];
    if (v29)
    {
      p_shared_owners = (unint64_t *)&v29->__shared_owners_;
      do
        unint64_t v31 = __ldxr(p_shared_owners);
      while (__stxr(v31 + 1, p_shared_owners));
    }

    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(a1 + 240), v28, (uint64_t)v29);
    uint64_t v32 = *(void *)(a1 + 240);
    if (v32)
    {
      *(void *)(v32 + _Block_object_dispose(va, 8) = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
      *(void *)(v32 + 16) = 0LL;
    }

    if (v29)
    {
      int v33 = (unint64_t *)&v29->__shared_owners_;
      do
        unint64_t v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    TunnelProxy<HTTPEngine>::establishTunnel(a1);
  }

  else
  {
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>( v44,  *(void *)(a1 + 8),  *(std::__shared_weak_count **)(a1 + 16),  a1);
    __int128 v40 = *(_OWORD *)v44;
    v44[0] = 0LL;
    v44[1] = 0LL;
    SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()( *a2,  v40,  *((std::__shared_weak_count **)&v40 + 1),  0LL,  *(void *)(a1 + 200),  *(void *)(a1 + 208));
    if (*((void *)&v40 + 1))
    {
      int64_t v35 = (unint64_t *)(*((void *)&v40 + 1) + 8LL);
      do
        unint64_t v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        (*(void (**)(void))(**((void **)&v40 + 1) + 16LL))(*((void *)&v40 + 1));
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v40 + 1));
      }
    }

    v37 = (std::__shared_weak_count *)v44[1];
    if (v44[1])
    {
      CFIndex v38 = (unint64_t *)((char *)v44[1] + 8);
      do
        unint64_t v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
  }

void sub_182A0DA78( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf, uint64_t a17, uint64_t a18)
{
}

void TunnelProxy<HTTPEngine>::continueProxyEstablishment(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 208))
  {
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>( &v27,  *(void *)(a1 + 8),  *(std::__shared_weak_count **)(a1 + 16),  a1);
    __int128 v28 = v27;
    __int128 v27 = 0uLL;
    int v5 = (std::__shared_weak_count *)*((void *)&v28 + 1);
    SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()( *a3,  v28,  *((std::__shared_weak_count **)&v28 + 1),  0LL,  *(void *)(a1 + 200),  *(void *)(a1 + 208));
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }

    int v8 = (std::__shared_weak_count *)*((void *)&v27 + 1);
    if (*((void *)&v27 + 1))
    {
      uint64_t v9 = (unint64_t *)(*((void *)&v27 + 1) + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    *(void *)(a1 + 200) = 0LL;
    *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0;
  }

  else
  {
    *(_BYTE *)(a1 + 97) = 0;
    uint64_t v12 = *a3;
    unint64_t v13 = (std::__shared_weak_count *)a3[1];
    if (v13)
    {
      uint64_t v14 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }

    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(a1 + 240), v12, (uint64_t)v13);
    uint64_t v16 = *(void *)(a1 + 240);
    if (v16)
    {
      *(void *)(v16 + _Block_object_dispose(va, 8) = BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
      *(void *)(v16 + 16) = 0LL;
    }

    if (v13)
    {
      uint64_t v17 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>( &v25,  *(void *)(a1 + 8),  *(std::__shared_weak_count **)(a1 + 16),  a1);
    std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>( (uint64_t *)&v27,  *(void *)a2,  *(std::__shared_weak_count **)(a2 + 8),  &v25);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 112, &v27);
    BOOL v19 = (std::__shared_weak_count *)*((void *)&v27 + 1);
    if (*((void *)&v27 + 1))
    {
      CFIndex v20 = (unint64_t *)(*((void *)&v27 + 1) + 8LL);
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }

    uint64_t v22 = v26;
    if (v26)
    {
      uint64_t v23 = (unint64_t *)&v26->__shared_owners_;
      do
        unint64_t v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }

    HTTPEngine::initialize(*(void *)(a1 + 112), 3);
    *(_DWORD *)(*(void *)(a1 + 112) + 32LL) |= 8u;
    TunnelProxy<HTTPEngine>::completeTask(a1, 0);
  }

void sub_182A0DDB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TunnelProxy<HTTPEngine>::proxyResponse(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 176);
  if (v1) {
    return v1 - 16;
  }
  else {
    return 0LL;
  }
}

uint64_t TunnelProxy<HTTPEngine>::proxyResponseData(uint64_t a1)
{
  return *(void *)(a1 + 192);
}

void TunnelProxy<HTTPEngine>::errorOccurred(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_DWORD *)(a1 + 208))
  {
    *(void *)(a1 + 200) = a2;
    *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = a3;
    TunnelProxy<HTTPEngine>::newConnectionRequired(a1);
  }

void non-virtual thunk to'TunnelProxy<HTTPEngine>::~TunnelProxy(uint64_t a1)
{
}

{
  void *v1;
  TunnelProxy<HTTPEngine>::~TunnelProxy((NetworkProxy *)(a1 - 104));
  operator delete(v1);
}

void non-virtual thunk to'TunnelProxy<HTTPEngine>::errorOccurred(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_DWORD *)(a1 + 104))
  {
    *(void *)(a1 + 96) = a2;
    *(_DWORD *)(a1 + 104) = a3;
    TunnelProxy<HTTPEngine>::newConnectionRequired(a1 - 104);
  }

void TunnelProxy<HTTPEngine>::newConnectionRequired(uint64_t a1)
{
  __int128 v11 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 112, &v11);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    uint64_t v3 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  ++*(_DWORD *)(a1 + 272);
  *(_BYTE *)(a1 + 97) = 1;
  TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>( &v11,  *(void *)(a1 + 8),  *(std::__shared_weak_count **)(a1 + 16),  a1);
  __int128 v10 = v11;
  __int128 v11 = 0uLL;
  TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion( a1,  v10,  *((std::__shared_weak_count **)&v10 + 1),  1LL,  *(void *)(a1 + 200),  *(void *)(a1 + 208));
  if (*((void *)&v10 + 1))
  {
    int v5 = (unint64_t *)(*((void *)&v10 + 1) + 8LL);
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      (*(void (**)(void))(**((void **)&v10 + 1) + 16LL))(*((void *)&v10 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v10 + 1));
    }
  }

  unint64_t v7 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    int v8 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  *(void *)(a1 + 200) = 0LL;
  *(_DWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0;
}

void sub_182A0DF7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>( void *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4)
{
  unint64_t v6 = v13;
  *a1 = a4;
  a1[1] = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    unint64_t v9 = v13;
    if (v13)
    {
      __int128 v10 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

void TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion( uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v7 = (uint64_t *)(a1 + 240);
  uint64_t v16 = a2;
  uint64_t v17 = a3;
  if (a3)
  {
    p_shared_owners = (unint64_t *)&a3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()(*v7, a2, a3, a4, a5, a6);
  if (a3)
  {
    __int128 v10 = (unint64_t *)&a3->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }

  SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::SmartBlockWithArgs(&v15, 0LL);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v7, &v15);
  uint64_t v12 = (std::__shared_weak_count *)*((void *)&v15 + 1);
  if (*((void *)&v15 + 1))
  {
    unint64_t v13 = (unint64_t *)(*((void *)&v15 + 1) + 8LL);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_182A0E0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void SmartBlockWithArgs<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::operator()( uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a1)
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }

    unint64_t v8 = *(void (**)(void *, uint64_t *, uint64_t, uint64_t, uint64_t))(a1 + 8);
    uint64_t v9 = *(void *)(a1 + 16);
    __int128 v10 = (void *)(a1 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      unint64_t v8 = *(void (**)(void *, uint64_t *, uint64_t, uint64_t, uint64_t))(*v10 + v8);
    }
    uint64_t v19 = a2;
    CFIndex v20 = a3;
    if (a3)
    {
      unint64_t v11 = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }

    v8(v10, &v19, a4, a5, a6);
    unint64_t v13 = v20;
    if (v20)
    {
      unint64_t v14 = (unint64_t *)&v20->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    if (a3)
    {
      uint64_t v16 = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
        std::__shared_weak_count::__release_weak(a3);
      }
    }
  }

void sub_182A0E1FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_initial( uint64_t *a1, uint64_t *a2)
{
  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<NetworkProxy>,BOOL,CFStreamError>::invoke_normal;
  a1[2] = 0LL;
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  __int128 v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  unint64_t v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A0E2AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( void *a1, uint64_t a2, std::__shared_weak_count *this)
{
  *a1 = a2;
  if (this)
  {
    unint64_t v4 = std::__shared_weak_count::lock(this);
    a1[1] = v4;
    if (v4) {
      return a1;
    }
  }

  else
  {
    a1[1] = 0LL;
  }

  uint64_t v6 = std::__throw_bad_weak_ptr[abi:nn180100]();
  return (void *)TunnelProxy<HTTPEngine>::~TunnelProxy(v6);
}

void NetworkProxy::~NetworkProxy(NetworkProxy *this)
{
  *(void *)this = off_189C168A0;
  uint64_t v2 = (const void *)*((void *)this + 11);
  *((void *)this + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 10);
  *((void *)this + 10) = 0LL;
  if (v3) {
    CFRelease(v3);
  }
  unint64_t v4 = (const void *)*((void *)this + 9);
  *((void *)this + 9) = 0LL;
  if (v4) {
    CFRelease(v4);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 48);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  *(void *)this = off_189C19AE8;
  unint64_t v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<HTTPEngine::HTTPEngineDelegate,TunnelProxy<HTTPEngine>>( void *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4)
{
  uint64_t v6 = a4 + 104;
  unint64_t v7 = v14;
  if (!a4) {
    uint64_t v6 = 0LL;
  }
  *a1 = v6;
  a1[1] = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    __int128 v10 = v14;
    if (v14)
    {
      unint64_t v11 = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }

void std::allocate_shared[abi:nn180100]<HTTPEngine,std::allocator<HTTPEngine>,std::shared_ptr<TransportConnection> &,std::shared_ptr<HTTPEngine::HTTPEngineDelegate>,void>( uint64_t *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t *a4)
{
  unint64_t v8 = operator new(0x178uLL);
  unint64_t v9 = v8;
  v8[1] = 0LL;
  v8[2] = 0LL;
  *unint64_t v8 = off_189C12CD8;
  uint64_t v10 = (uint64_t)(v8 + 3);
  v20[0] = a2;
  v20[1] = (uint64_t)a3;
  if (a3)
  {
    p_shared_owners = (unint64_t *)&a3->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  uint64_t v13 = *a4;
  unint64_t v14 = (std::__shared_weak_count *)a4[1];
  v19[0] = v13;
  v19[1] = (uint64_t)v14;
  if (v14)
  {
    p_shared_weak_owners = (unint64_t *)&v14->__shared_weak_owners_;
    do
      unint64_t v16 = __ldxr(p_shared_weak_owners);
    while (__stxr(v16 + 1, p_shared_weak_owners));
  }

  HTTPEngine::HTTPEngine((uint64_t)(v8 + 3), v20, v19);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  if (a3)
  {
    unint64_t v17 = (unint64_t *)&a3->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }

  *a1 = v10;
  a1[1] = (uint64_t)v9;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>((uint64_t)a1, v9 + 4, v10);
}

void sub_182A0E5A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v14);
  _Unwind_Resume(a1);
}

void TunnelProxy<HTTPEngine>::completeTask(uint64_t a1, char a2)
{
  int v2 = *(_DWORD *)(a1 + 272) - 1;
  *(_DWORD *)(a1 + 272) = v2;
  if (!v2)
  {
    uint64_t v5 = a1 + 256;
    uint64_t v6 = *(void *)(a1 + 256);
    if (v6)
    {
      unint64_t v7 = *(void (**)(void *, uint64_t))(v6 + 8);
      uint64_t v8 = *(void *)(v6 + 16);
      unint64_t v9 = (void *)(v6 + (v8 >> 1));
      if ((v8 & 1) != 0) {
        unint64_t v7 = *(void (**)(void *, uint64_t))(*v9 + v7);
      }
      v7(v9, 1LL);
    }

    SmartBlockWithArgs<BOOL>::SmartBlockWithArgs(&v13, 0LL);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5, &v13);
    uint64_t v10 = (std::__shared_weak_count *)*((void *)&v13 + 1);
    if (!*((void *)&v13 + 1)) {
      goto LABEL_10;
    }
    unint64_t v11 = (unint64_t *)(*((void *)&v13 + 1) + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
      if ((a2 & 1) != 0) {
        return;
      }
    }

    else
    {
LABEL_10:
      if ((a2 & 1) != 0) {
        return;
      }
    }

    TunnelProxy<HTTPEngine>::establishTunnel(a1);
  }

void *SmartBlockWithArgs<BOOL>::SmartBlockWithArgs(void *a1, const void *a2)
{
  unint64_t v4 = operator new(0x18uLL);
  v4[1] = BlockHolderVar<BOOL>::invoke_initial;
  v4[2] = 0LL;
  void *v4 = _Block_copy(a2);
  *a1 = v4;
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = off_189C1A140;
  v5[1] = 0LL;
  v5[2] = 0LL;
  v5[3] = v4;
  a1[1] = v5;
  if (!a2)
  {
    v4[1] = BlockHolderVar<BOOL>::invoke_reseted;
    v4[2] = 0LL;
  }

  return a1;
}

void sub_182A0E720(_Unwind_Exception *a1)
{
}

void TunnelProxy<HTTPEngine>::establishTunnel(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 112);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 168);
  v10[0] = *(void *)(a1 + 160);
  v10[1] = (uint64_t)v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  v9[0] = 0LL;
  v9[1] = 0LL;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke;
  aBlock[3] = &__block_descriptor_40_e13_v24__0___qi_8l;
  aBlock[4] = a1;
  HTTPEngine::writeRequest(v2, v10, v9, aBlock);
  if (v3)
  {
    uint64_t v6 = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_182A0E7FC(_Unwind_Exception *a1)
{
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 144LL))(v3);
  }

  else
  {
    ++*(_DWORD *)(v3 + 272);
    uint64_t v4 = *(void *)(v3 + 112);
    uint64_t v5 = *(void *)(v3 + 160);
    uint64_t v6 = *(std::__shared_weak_count **)(v3 + 168);
    v12[5] = v5;
    v12[6] = v6;
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }

    v11[4] = v3;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_2;
    v12[3] = &__block_descriptor_40_e93_v40__0_shared_ptr_HTTPResponseMessage____HTTPResponseMessage_____shared_weak_count__8___qi_24l;
    v12[4] = v3;
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_3;
    v11[3] = &__block_descriptor_40_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
    HTTPEngine::readResponse(v4, v5, (uint64_t)v6, 0LL, v12, v11, &__block_literal_global_692);
    if (v6)
    {
      unint64_t v9 = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

void sub_182A0E920(_Unwind_Exception *a1)
{
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_2( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 32);
  if ((_DWORD)a4)
  {
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)v4 + 144LL))(*(void *)(a1 + 32), a3, a4);
    return;
  }

  uint64_t v5 = (HTTPMessage **)(v4 + 176);
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v4 + 176), *a2, a2[1]);
  int v6 = *(_DWORD *)(*(void *)(v4 + 176) + 128LL);
  if (v6 == 407)
  {
    uint64_t v7 = *(void *)(v4 + 144);
    if (!v7)
    {
      unint64_t v8 = operator new(0x50uLL);
      v8[1] = 0LL;
      v8[2] = 0LL;
      *unint64_t v8 = off_189C02868;
      *((_OWORD *)v8 + 2) = 0u;
      *((_OWORD *)v8 + 3) = 0u;
      *((_OWORD *)v8 + 4) = 0u;
      *(void *)&buf[8] = v8;
      v8[3] = off_189C03478;
      *(void *)buf = v8 + 3;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v4 + 144, (__int128 *)buf);
      unint64_t v9 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        unint64_t v10 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }

      uint64_t v7 = *(void *)(v4 + 144);
    }

    ++*(_DWORD *)(v4 + 272);
    uint64_t v13 = *(void *)(v4 + 216);
    unint64_t v12 = *(std::__shared_weak_count **)(v4 + 224);
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        unint64_t v15 = __ldxr(p_shared_owners);
      while (__stxr(v15 + 1, p_shared_owners));
    }

    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v63,  *(void *)(v4 + 8),  *(std::__shared_weak_count **)(v4 + 16));
    unint64_t v16 = *(std::__shared_weak_count **)(v4 + 168);
    uint64_t v61 = *(void *)(v4 + 160);
    int64_t v62 = v16;
    if (v16)
    {
      unint64_t v17 = (unint64_t *)&v16->__shared_owners_;
      do
        unint64_t v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }

    uint64_t v19 = *(std::__shared_weak_count **)(v4 + 184);
    v59 = *(HTTPResponseMessage **)(v4 + 176);
    int64_t v60 = v19;
    if (v19)
    {
      CFIndex v20 = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }

    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke;
    CFTypeID v66 = &__block_descriptor_40_e91_v40__0_shared_ptr_HTTPRequestMessage____HTTPRequestMessage_____shared_weak_count__8___qi_24l;
    uint64_t v67 = v4;
    SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::SmartBlockWithArgs(&v57, buf);
    AuthLiaison::negotiateAuthentication(v7, v13, (uint64_t)v12, &v63, &v61, &v59, &v57);
    uint64_t v22 = v58;
    if (v58)
    {
      uint64_t v23 = (unint64_t *)&v58->__shared_owners_;
      do
        unint64_t v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }

    uint64_t v25 = v60;
    if (v60)
    {
      uint64_t v26 = (unint64_t *)&v60->__shared_owners_;
      do
        unint64_t v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }

    __int128 v28 = v62;
    if (v62)
    {
      uint64_t v29 = (unint64_t *)&v62->__shared_owners_;
      do
        unint64_t v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }

    unint64_t v31 = v64;
    if (v64)
    {
      uint64_t v32 = (unint64_t *)&v64->__shared_owners_;
      do
        unint64_t v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }

    if (!v12) {
      goto LABEL_80;
    }
    unint64_t v34 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
LABEL_78:
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }

    goto LABEL_80;
  }

  if (v6 != 200)
  {
    uint64_t v36 = *(void *)(v4 + 112);
    uint64_t v37 = *(void *)(v36 + 56);
    unint64_t v12 = *(std::__shared_weak_count **)(v36 + 64);
    if (v12)
    {
      CFIndex v38 = (unint64_t *)&v12->__shared_owners_;
      do
        unint64_t v39 = __ldxr(v38);
      while (__stxr(v39 + 1, v38));
    }

    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    __int128 v40 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      if (v37) {
        uint64_t v56 = (*(uint64_t (**)(uint64_t))(*(void *)v37 + 256LL))(v37);
      }
      else {
        uint64_t v56 = 0LL;
      }
      *(_DWORD *)buf = 134218240;
      *(void *)&buf[4] = v56;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v6;
      _os_log_error_impl( &dword_18298D000,  v40,  OS_LOG_TYPE_ERROR,  "HTTPS Proxy Connection [%llu] received status code %d",  buf,  0x12u);
    }

    else {
      int v41 = -2098;
    }
    *(void *)(v4 + 200) = 4LL;
    *(_DWORD *)(v4 + 20_Block_object_dispose(va, 8) = v41;
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>( buf,  *(void *)(v4 + 8),  *(std::__shared_weak_count **)(v4 + 16),  v4);
    __int128 v42 = *(_OWORD *)buf;
    *(void *)buf = 0LL;
    *(void *)&buf[8] = 0LL;
    v43 = (std::__shared_weak_count *)*((void *)&v42 + 1);
    TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion( v4,  v42,  *((std::__shared_weak_count **)&v42 + 1),  0LL,  *(void *)(v4 + 200),  *(void *)(v4 + 208));
    if (v43)
    {
      int64_t v44 = (unint64_t *)&v43->__shared_owners_;
      do
        unint64_t v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }

    int64_t v46 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      CFIndex v47 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v48 = __ldaxr(v47);
      while (__stlxr(v48 - 1, v47));
      if (!v48)
      {
        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
        std::__shared_weak_count::__release_weak(v46);
      }
    }

    HTTPEngine::_cleanupConnection(*(HTTPEngine **)(v4 + 112), 0LL);
    *(void *)buf = 0LL;
    *(void *)&buf[8] = 0LL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v4 + 112, (__int128 *)buf);
    CFIndex v49 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      UniChar v50 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }

    *(void *)buf = 0LL;
    *(void *)&buf[8] = 0LL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v4 + 216, (__int128 *)buf);
    UniChar v52 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      v53 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v54 = __ldaxr(v53);
      while (__stlxr(v54 - 1, v53));
      if (!v54)
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
    }

    *(void *)(v4 + 200) = 0LL;
    *(_DWORD *)(v4 + 20_Block_object_dispose(va, 8) = 0;
    if (!v12) {
      goto LABEL_80;
    }
    int64_t v55 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v35 = __ldaxr(v55);
    while (__stlxr(v35 - 1, v55));
    goto LABEL_78;
  }

  HTTPEngine::setProperty(*(HTTPEngine **)(v4 + 112), (CFStringRef)&unk_18C5B0540, (const void *)*MEMORY[0x189604DE8]);
LABEL_80:
  HTTPMessage::ensureParserFinished(*v5);
  HTTPMessage::removeHeaderFieldValue(*v5, 0x143153CAu);
  HTTPMessage::removeHeaderFieldValue(*v5, 0x144173D0u);
}

void sub_182A0EF14( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  _Unwind_Resume(exception_object);
}

void ___ZN11TunnelProxyI10HTTPEngineE15establishTunnelEv_block_invoke_3( uint64_t a1, dispatch_data_s *object, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8 = *(void *)(a1 + 32);
  if (object)
  {
    unint64_t v10 = *(dispatch_object_s **)(v8 + 192);
    if (!v10)
    {
      dispatch_retain(object);
      *(void *)(v8 + 192) = object;
      if ((_DWORD)a4) {
        goto LABEL_5;
      }
      goto LABEL_7;
    }

    *(void *)(v8 + 192) = dispatch_data_create_concat(*(dispatch_data_t *)(v8 + 192), object);
    dispatch_release(v10);
  }

  if ((_DWORD)a4)
  {
LABEL_5:
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 144LL))(v8, a3, a4);
    return;
  }

void sub_182A0F40C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    CFRelease(v10);
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<__CFDictionary const*,Deleter_CFRelease,std::allocator<__CFDictionary const>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke( uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (a4 && a4 != -1002)
  {
    *(_DWORD *)(v4 + 20_Block_object_dispose(va, 8) = a4;
    *(void *)(v4 + 200) = a3;
    TunnelProxy<HTTPEngine>::completeTask(v4, 1);
    TunnelProxy<HTTPEngine>::hold_unmanaged_in_shared<TunnelProxy<HTTPEngine>,TunnelProxy<HTTPEngine>>( &v16,  *(void *)(v4 + 8),  *(std::__shared_weak_count **)(v4 + 16),  v4);
    __int128 v8 = v16;
    __int128 v16 = 0uLL;
    unint64_t v9 = (std::__shared_weak_count *)*((void *)&v8 + 1);
    TunnelProxy<HTTPEngine>::invokeTunnelEstablishedCompletion( v4,  v8,  *((std::__shared_weak_count **)&v8 + 1),  0LL,  *(void *)(v4 + 200),  *(void *)(v4 + 208));
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }

    unint64_t v12 = (std::__shared_weak_count *)*((void *)&v16 + 1);
    if (*((void *)&v16 + 1))
    {
      uint64_t v13 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }

  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v4 + 160), *a2, a2[1]);
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke_2;
    v15[3] = &__block_descriptor_40_e8_v12__0B8l;
    v15[4] = v4;
    SmartBlockWithArgs<BOOL>::SmartBlockWithArgs(&v16, v15);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v4 + 256, &v16);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)&v16 + 1);
    if (*((void *)&v16 + 1))
    {
      int v6 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
      do
        unint64_t v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }

    TunnelProxy<HTTPEngine>::completeTask(v4, 0);
  }

void sub_182A0F654( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::SmartBlockWithArgs( void *a1, const void *a2)
{
  uint64_t v4 = operator new(0x18uLL);
  v4[1] = BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial;
  v4[2] = 0LL;
  void *v4 = _Block_copy(a2);
  *a1 = v4;
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = off_189C028A0;
  v5[1] = 0LL;
  v5[2] = 0LL;
  v5[3] = v4;
  a1[1] = v5;
  if (!a2)
  {
    v4[1] = BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_reseted;
    v4[2] = 0LL;
  }

  return a1;
}

void sub_182A0F6F0(_Unwind_Exception *a1)
{
}

void BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial( uint64_t *a1, uint64_t *a2)
{
  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_normal;
  a1[2] = 0LL;
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  unint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  int v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A0F798( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError> *,SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1LL | (unint64_t)v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial && v5 != 0)
  {
    unint64_t v7 = (void *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0) {
      unint64_t v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
    }
                                                       + BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial);
    else {
      unint64_t v8 = BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_initial;
    }
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    ((void (*)(void *, uint64_t *, void, void))v8)(v7, &v12, 0LL, 0LL);
    uint64_t v9 = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

  _Block_release(*(const void **)v1);
  operator delete((void *)v1);
}

void sub_182A0F898( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  _Unwind_Resume(exception_object);
}

void BlockHolderVar<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::invoke_normal( uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  unint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  int v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A0F968( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double ___ZN11TunnelProxyI10HTTPEngineE25handleProxyAuthenticationEv_block_invoke_2(uint64_t a1, int a2)
{
  if (a2)
  {
    double result = NAN;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 112LL) + 176LL) = xmmword_182C9D750;
  }

  return result;
}

void std::__shared_ptr_emplace<AuthLiaison>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C02868;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AuthLiaison>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C02868;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<AuthLiaison>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t BlockHolderVar<BOOL>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<BOOL>::invoke_normal;
  a1[2] = 0LL;
  return (*(uint64_t (**)(void))(*a1 + 16LL))();
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL> *,SmartBlockWithArgs<BOOL>::Deleter,std::allocator<BlockHolderVar<BOOL>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<BOOL> *,SmartBlockWithArgs<BOOL>::Deleter,std::allocator<BlockHolderVar<BOOL>>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1LL | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<BOOL>::invoke_initial && v5 != 0)
  {
    unint64_t v7 = (void *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0) {
      (*(void (**)(void *, void))(*v7 + BlockHolderVar<BOOL>::invoke_initial))(v7, 0LL);
    }
    else {
      ((void (*)(void *, void))BlockHolderVar<BOOL>::invoke_initial)(v7, 0LL);
    }
  }

  _Block_release(*(const void **)v1);
  operator delete((void *)v1);
}

uint64_t BlockHolderVar<BOOL>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16LL))();
}

void std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    BOOL v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      int v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          unint64_t v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          unint64_t v9 = __ldxr(p_shared_weak_owners);
        while (__stxr(v9 + 1, p_shared_weak_owners));
        BOOL v4 = (std::__shared_weak_count *)a2[1];
      }

      *a2 = a3;
      a2[1] = v5;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v5)
      {
        unint64_t v10 = (unint64_t *)&v5->__shared_owners_;
        do
          unint64_t v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }

void std::__shared_ptr_emplace<HTTPEngine>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C12CD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPEngine>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C12CD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<HTTPEngine>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *std::shared_ptr<HTTPRequestMessage>::operator=[abi:nn180100]<HTTPRequestMessage,Deleter_release<HTTPRequestMessage>,void>( void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  if (*a2)
  {
    int v5 = operator new(0x20uLL);
    void *v5 = off_189C17828;
    v5[1] = 0LL;
    v5[2] = 0LL;
    v5[3] = v4;
  }

  else
  {
    int v5 = 0LL;
  }

  *a2 = 0LL;
  int v6 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return a1;
}

void std::__shared_ptr_pointer<HTTPRequestMessage *,Deleter_release<HTTPRequestMessage>,std::allocator<HTTPRequestMessage>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<HTTPRequestMessage *,Deleter_release<HTTPRequestMessage>,std::allocator<HTTPRequestMessage>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    CFRelease((CFTypeRef)(v1 - 16));
  }
}

CFWriteStreamRef CFWriteStreamCreateWithFTPURL(CFAllocatorRef alloc, CFURLRef ftpURL)
{
  if (!ftpURL) {
    return 0LL;
  }
  CFFTPHappyURL = _CreateCFFTPHappyURL(ftpURL);
  if (!CFFTPHappyURL) {
    return 0LL;
  }
  uint64_t v4 = CFFTPHappyURL;
  int v5 = CFURLCopyScheme(v4);
  if (!v5) {
    goto LABEL_31;
  }
  int v6 = v5;
  if (CFStringCompare(v5, @"ftp", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v6, @"ftps", 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v6);
    CFStringRef v8 = CFURLCopyHostName(v4);
    if (v8)
    {
      CFRelease(v8);
      unint64_t v9 = CFURLCopyUserName(v4);
      unint64_t v10 = v9;
      if (v9 && !_ValidFTPString(v9))
      {
        uint64_t v19 = v10;
      }

      else
      {
        unint64_t v11 = CFURLCopyPassword(v4);
        unint64_t v12 = v11;
        if (!v11 || _ValidFTPString(v11))
        {
          uint64_t v13 = MEMORY[0x186E12804](alloc, 144LL, 0LL);
          if (v13)
          {
            unint64_t v14 = (void *)v13;
            *(_OWORD *)(v13 + 112) = 0u;
            *(_OWORD *)(v13 + 12_Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)(v13 + 80) = 0u;
            *(_OWORD *)(v13 + 96) = 0u;
            *(_OWORD *)(v13 + 4_Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)(v13 + 64) = 0u;
            *(_OWORD *)(v13 + 16) = 0u;
            *(_OWORD *)(v13 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
            *(_OWORD *)uint64_t v13 = 0u;
            *(_WORD *)uint64_t v13 = 129;
            *(void *)(v13 + _Block_object_dispose(va, 8) = CFURLCopyAbsoluteURL(v4);
            v14[10] = CFArrayCreateMutable(alloc, 0LL, MEMORY[0x189605228]);
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
            v14[11] = Mutable;
            __int128 v16 = (const void *)v14[1];
            if (v16)
            {
              if (!v14[10] || !Mutable) {
                goto LABEL_34;
              }
              __int128 v23 = 1uLL;
              unint64_t v24 = _FTPStreamFinalize;
              uint64_t v25 = _FTPStreamCopyDescription;
              uint64_t v26 = _FTPStreamOpen;
              unint64_t v27 = _FTPStreamOpenCompleted;
              __int128 v28 = _FTPStreamWrite;
              uint64_t v29 = _FTPStreamCanWrite;
              CFComparisonResult v30 = _FTPStreamClose;
              __int128 v31 = _FTPStreamCopyProperty;
              uint64_t v32 = _FTPStreamSetProperty;
              uint64_t v33 = 0LL;
              unint64_t v34 = _FTPStreamSchedule;
              unint64_t v35 = _FTPStreamUnschedule;
              uint64_t v17 = CoreWriteStreamCreate((uint64_t)alloc, &v23, (uint64_t)v14);
              if (v17)
              {
                uint64_t v18 = v17;
                v14[4] = v17;
                if (v10)
                {
                  ++*(void *)(v18 + 96);
                  (*(void (**)(void, const __CFString *, const __CFString *))(**(void **)(v18 + 40) + 32LL))( *(void *)(v18 + 40),  @"kCFStreamPropertyFTPUserName_prevalidated",  v10);
                  --*(void *)(v18 + 96);
                }

                if (v12)
                {
                  ++*(void *)(v18 + 96);
                  (*(void (**)(void, const __CFString *, const __CFString *))(**(void **)(v18 + 40) + 32LL))( *(void *)(v18 + 40),  @"kCFStreamPropertyFTPPassword_prevalidated",  v12);
                  --*(void *)(v18 + 96);
                }

CFURLRef _CreateCFFTPHappyURL(const __CFURL *a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t v1 = CFURLCopyAbsoluteURL(a1);
  if (v1)
  {
    uint64_t v2 = v1;
    CFIndex v3 = CFURLGetBytes(v1, buffer, 2048LL);
    if (v3 == -1)
    {
      CFIndex v7 = CFURLGetBytes(v2, 0LL, 0LL);
      CFStringRef v8 = (UInt8 *)malloc(v7);
      if (!v8)
      {
        CFURLRef v6 = 0LL;
LABEL_10:
        CFRelease(v2);
        return v6;
      }

      int v5 = v8;
      CFIndex v4 = CFURLGetBytes(v2, v8, v7);
    }

    else
    {
      CFIndex v4 = v3;
      int v5 = buffer;
    }

    unint64_t v9 = CFGetAllocator(v2);
    CFURLRef v6 = CFURLCreateAbsoluteURLWithBytes(v9, v5, v4, 0, 0LL, 0);
    if (v5 != buffer) {
      free(v5);
    }
    goto LABEL_10;
  }

  return 0LL;
}

uint64_t _ValidFTPPathname(const __CFURL *a1)
{
  uint64_t v1 = _CFURLCopyPathReplacingPercentEscapes(a1);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = v1;
  CFIndex Length = CFStringGetLength(v1);
  CFStringRef theString = v2;
  uint64_t v27 = 0LL;
  CFIndex v28 = Length;
  CharactersPtr = CFStringGetCharactersPtr(v2);
  CStringPtr = 0LL;
  uint64_t v25 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v2, 0x600u);
  }
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v26 = CStringPtr;
  if (Length < 1)
  {
LABEL_32:
    uint64_t v21 = 1LL;
    goto LABEL_35;
  }

  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  int v8 = 0;
  uint64_t v9 = 0LL;
  uint64_t v10 = 64LL;
  while (1)
  {
    uint64_t v11 = (unint64_t)v9 >= 4 ? 4LL : v9;
    CFIndex v12 = v28;
    if (v28 <= v9) {
      break;
    }
    if (v25)
    {
      UniChar v13 = v25[v9 + v27];
    }

    else if (v26)
    {
      UniChar v13 = v26[v27 + v9];
    }

    else
    {
      if (v30 <= v9 || v7 > v9)
      {
        uint64_t v15 = v11 + v6;
        uint64_t v16 = v10 - v11;
        uint64_t v17 = v9 - v11;
        CFIndex v18 = v17 + 64;
        if (v17 + 64 >= v28) {
          CFIndex v18 = v28;
        }
        uint64_t v29 = v17;
        uint64_t v30 = v18;
        if (v28 >= v16) {
          CFIndex v12 = v16;
        }
        v31.length = v12 + v15;
        v31.location = v17 + v27;
        CFStringGetCharacters(theString, v31, buffer);
        uint64_t v7 = v29;
      }

      UniChar v13 = buffer[v9 - v7];
    }

    if (v13 != 10 && v13 != 13) {
      break;
    }
    int v20 = 1;
LABEL_31:
    ++v9;
    --v6;
    ++v10;
    int v8 = v20;
    if (Length == v9) {
      goto LABEL_32;
    }
  }

  int v20 = 0;
  if (!v8) {
    goto LABEL_31;
  }
  uint64_t v21 = 0LL;
LABEL_35:
  CFRelease(v2);
  return v21;
}

uint64_t _ValidFTPString(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v23 = 0LL;
  CFIndex v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0LL;
  uint64_t v21 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v25 = 0LL;
  uint64_t v26 = 0LL;
  uint64_t v22 = CStringPtr;
  if (Length < 1) {
    return 1LL;
  }
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  for (uint64_t i = 64LL; ; ++i)
  {
    uint64_t v9 = (unint64_t)v7 >= 4 ? 4LL : v7;
    CFIndex v10 = v24;
    if (v24 > v7)
    {
      if (v21)
      {
        UniChar v11 = v21[v7 + v23];
      }

      else if (v22)
      {
        UniChar v11 = v22[v23 + v7];
      }

      else
      {
        if (v26 <= v7 || v6 > v7)
        {
          uint64_t v13 = v9 + v5;
          uint64_t v14 = i - v9;
          uint64_t v15 = v7 - v9;
          CFIndex v16 = v15 + 64;
          if (v15 + 64 >= v24) {
            CFIndex v16 = v24;
          }
          uint64_t v25 = v15;
          uint64_t v26 = v16;
          if (v24 >= v14) {
            CFIndex v10 = v14;
          }
          v27.length = v10 + v13;
          v27.location = v15 + v23;
          CFStringGetCharacters(theString, v27, buffer);
          uint64_t v6 = v25;
        }

        UniChar v11 = buffer[v7 - v6];
      }

      if (v11 == 10 || v11 == 13) {
        break;
      }
    }

    ++v7;
    --v5;
    if (Length == v7) {
      return 1LL;
    }
  }

  return 0LL;
}

void _FTPStreamFinalize(const void *a1, void *a2)
{
  CFIndex v4 = (const void *)a2[1];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a2[2];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)a2[10];
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a2[11];
  if (v7) {
    CFRelease(v7);
  }
  int v8 = (const void *)a2[14];
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)a2[8];
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = a2[17];
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  UniChar v11 = CFGetAllocator(a1);
  CFAllocatorDeallocate(v11, a2);
}

CFStringRef _FTPStreamCopyDescription(const void *a1, uint64_t a2)
{
  CFIndex v4 = CFGetAllocator(a1);
  uint64_t v5 = @"upload";
  if ((*(_WORD *)a2 & 0x80) == 0) {
    uint64_t v5 = @"download";
  }
  return CFStringCreateWithFormat( v4,  0LL,  @"<FTPStream %p>{%@, url = %@, flags = %p }",  a1,  v5,  *(void *)(a2 + 8),  a2);
}

uint64_t _FTPStreamOpen(const void *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  if (_FTPStreamOpen(void const*,CFStreamError *,unsigned char *,_CFFTPStreamContext *)::onceToken != -1) {
    dispatch_once( &_FTPStreamOpen(void const*,CFStreamError *,unsigned char *,_CFFTPStreamContext *)::onceToken,  &__block_literal_global_743);
  }
  SInt32 valuePtr = -1;
  int v8 = CFGetAllocator(a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPAttemptPersistentConnection");
  if (Value) {
    BOOL v10 = CFEqual(Value, (CFTypeRef)*MEMORY[0x189604DE0]) != 0;
  }
  else {
    BOOL v10 = 0;
  }
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 0;
  *(void *)a2 = 0LL;
  UniChar v11 = *(const __CFArray **)(a4 + 112);
  if (v11 || (*(_WORD *)a4 & 0x1000) != 0)
  {
    if ((*(_WORD *)a4 & 0x1000) == 0) {
      goto LABEL_24;
    }
LABEL_49:
    *a3 = 0;
    return 1LL;
  }

  CFIndex v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPProxy");
  if (!v12 || (uint64_t v13 = (__CFDictionary *)CFRetain(v12)) == 0LL)
  {
    uint64_t v14 = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), &unk_18C5ADEF8);
    if (!v14 || (uint64_t v13 = (__CFDictionary *)CFRetain(v14)) == 0LL) {
      uint64_t v13 = CFNetworkCopySystemProxySettings();
    }
  }

  *(_WORD *)a4 &= ~0x1000u;
  uint64_t v15 = (const __CFArray *)__CFNetworkCopyProxiesForURLWithInterface(*(const __CFURL **)(a4 + 8), v13, 0LL);
  if (v13) {
    CFRelease(v13);
  }
  *(void *)(a4 + 120) = 0LL;
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v15, 0LL);
  if (!v15)
  {
    uint64_t v29 = 6LL;
    uint64_t v28 = 0xFFFFFFFFLL;
    goto LABEL_44;
  }

  uint64_t v17 = ValueAtIndex;
  CFIndex v18 = CFDictionaryGetValue(ValueAtIndex, @"kCFProxyTypeKey");
  if (!CFEqual(@"kCFProxyTypeAutoConfigurationURL", v18))
  {
    uint64_t v28 = 0LL;
    uint64_t v29 = 0LL;
    *(void *)(a4 + 112) = v15;
    goto LABEL_44;
  }

  v85[0] = 0LL;
  v85[1] = a4;
  memset(&v85[2], 0, 24);
  uint64_t v19 = (PAC *)CFDictionaryGetValue(v17, @"kCFProxyAutoConfigurationURLKey");
  int v20 = *(const __CFArray **)(a4 + 80);
  *(void *)(a4 + 96) = PAC::CreatePACTicket( v19,  *(const void **)(a4 + 8),  0LL,  0LL,  (std::__shared_weak_count_vtbl *)PACExecutionComplete_FTPStream,  (void (*)(void *, const __CFArray *, __CFError *))v85,  v21);
  *(_WORD *)a4 |= 0x1000u;
  if (v20 && CFArrayGetCount(v20) >= 1)
  {
    CFIndex Count = CFArrayGetCount(v20);
    if (Count >= 1)
    {
      CFIndex v23 = Count;
      CFTypeRef cf = v8;
      BOOL v24 = v10;
      for (CFIndex i = 0LL; i < v23; i += 2LL)
      {
        uint64_t v26 = (__CFRunLoop *)CFArrayGetValueAtIndex(v20, i);
        CFRange v27 = (const __CFString *)CFArrayGetValueAtIndex(v20, i + 1);
        CFRunLoopAddSource(v26, *(CFRunLoopSourceRef *)(a4 + 96), v27);
      }

      uint64_t v28 = 0LL;
      uint64_t v29 = 0LL;
      BOOL v10 = v24;
      int v8 = cf;
      goto LABEL_43;
    }

    goto LABEL_42;
  }

  context.version = 0LL;
  context.info = (void *)a4;
  memset(&context.retain, 0, 24);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  unint64_t v39 = CFRunLoopTimerCreate( v8,  Current + 60.0,  -1.0,  0LL,  0LL,  (CFRunLoopTimerCallBack)PACTimerCallback_FTPStream,  &context);
  __int128 v40 = CFRunLoopGetCurrent();
  CFRunLoopAddSource(v40, *(CFRunLoopSourceRef *)(a4 + 96), @"_kProxySupportSyncPACExecutionRunLoopMode");
  int v41 = CFRunLoopGetCurrent();
  CFRunLoopAddTimer(v41, v39, @"_kProxySupportSyncPACExecutionRunLoopMode");
  while ((*(_WORD *)a4 & 0x1000) != 0)
    CFRunLoopRunInMode(@"_kProxySupportSyncPACExecutionRunLoopMode", 1.0e10, 1u);
  CFRunLoopTimerInvalidate(v39);
  if (v39) {
    CFRelease(v39);
  }
  __int128 v42 = *(__CFError **)(a4 + 104);
  if (!v42)
  {
LABEL_42:
    uint64_t v28 = 0LL;
    uint64_t v29 = 0LL;
    goto LABEL_43;
  }

  uint64_t v29 = _CFStreamErrorFromCFError(v42);
  uint64_t v28 = v43;
LABEL_43:
  CFRelease(v15);
LABEL_44:
  *(void *)a2 = v29;
  *(void *)(a2 + _Block_object_dispose(va, 8) = v28;
  if (*(void *)(a4 + 128))
  {
    uint64_t result = 1LL;
    *a3 = 1;
    return result;
  }

  if ((*(_WORD *)a4 & 0x1000) != 0) {
    goto LABEL_49;
  }
  if ((_DWORD)v28)
  {
    uint64_t result = 0LL;
    *a3 = 1;
    return result;
  }

  UniChar v11 = *(const __CFArray **)(a4 + 112);
LABEL_24:
  uint64_t v30 = *(void *)(a4 + 120);
  if (v30 == CFArrayGetCount(v11))
  {
    *a3 = 1;
    if (*(_DWORD *)(a4 + 48))
    {
      uint64_t result = 0LL;
      *(_OWORD *)a2 = *(_OWORD *)(a4 + 40);
      return result;
    }

    uint64_t result = 0LL;
    *(void *)a2 = 1LL;
    int v44 = 57;
    goto LABEL_131;
  }

  *(void *)(a4 + 40) = 0LL;
  *(_DWORD *)(a4 + 4_Block_object_dispose(va, 8) = 0;
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPProxy");
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a4 + 88), &unk_18C5ADEF8);
  *(_WORD *)a4 &= 0xFFCFu;
  uint64_t v32 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 112), *(void *)(a4 + 120));
  uint64_t v33 = 0LL;
  CFStringRef v34 = 0LL;
  if (CFEqual(v32, &unk_189C46D28))
  {
LABEL_56:
    CFStringRef v47 = CFURLCopyScheme(*(CFURLRef *)(a4 + 8));
    if (valuePtr < 0) {
      SInt32 valuePtr = CFURLGetPortNumber(*(CFURLRef *)(a4 + 8));
    }
    if (!v34) {
      CFStringRef v34 = CFURLCopyHostName(*(CFURLRef *)(a4 + 8));
    }
    if (CFStringCompare(v47, @"ftp", 1uLL))
    {
      if (!CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), &unk_18C5ADE88)) {
        _FTPStreamSetProperty(0, (const __CFString *)&unk_18C5ADE88, (const __CFString *)&unk_18C5AE198, a4);
      }
      if (valuePtr == -1) {
        SInt32 valuePtr = 990;
      }
      if (v33) {
        int v48 = 4;
      }
      else {
        int v48 = 2;
      }
      if (v47) {
LABEL_69:
      }
        CFRelease(v47);
    }

    else
    {
      if (valuePtr == -1) {
        SInt32 valuePtr = 21;
      }
      if (v33) {
        int v48 = 3;
      }
      else {
        int v48 = 1;
      }
      if (v47) {
        goto LABEL_69;
      }
    }

    *a3 = 0;
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    if (*(void *)(a4 + 128))
    {
LABEL_122:
      if (v34) {
        CFRelease(v34);
      }
      v72 = *(NetConnection **)(a4 + 128);
      if (!v72 || !NetConnection::enqueue(v72, (void *)a4, 0))
      {
        *a3 = 1;
        if (*__error())
        {
          v73 = __error();
          uint64_t result = 0LL;
          int v44 = *v73;
          *(void *)a2 = 1LL;
        }

        else
        {
          uint64_t result = 0LL;
          *(void *)a2 = 1LL;
          int v44 = 12;
        }

LABEL_131:
        *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v44;
        return result;
      }

      if (v10) {
        NetConnection::doNotAllowMoreRequests(*(NetConnection **)(a4 + 128));
      }
      return 1LL;
    }

    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
    BOOL v78 = v10;
    if (v34)
    {
      SInt32 v50 = valuePtr;
      unint64_t v51 = *(const __CFDictionary **)(a4 + 88);
      uint64_t v52 = MEMORY[0x186E12804](v8, 48LL, 0LL);
      *(void *)(v52 + 20) = 0LL;
      *(void *)(v52 + 36) = 0LL;
      *(void *)(v52 + 2_Block_object_dispose(va, 8) = 0LL;
      *(_DWORD *)(v52 + 44) = 0;
      *(void *)uint64_t v52 = off_189C06BF8;
      *(void *)(v52 + _Block_object_dispose(va, 8) = v8;
      *(_DWORD *)(v52 + 16) = 1;
      if (((v52 + 16) & 3) != 0) {
        __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
      }
      v53 = (void *)v52;
      *(void *)uint64_t v52 = off_189C08A80;
      CFDictionaryRef Copy = (AutoDict *)CFStringCreateCopy(v8, v34);
      v53[3] = Copy;
      *((_DWORD *)v53 + _Block_object_dispose(va, 8) = v50;
      *((_DWORD *)v53 + 9) = v48;
      if (v51)
      {
        EmptyDict = CFDictionaryCreateCopy(v8, v51);
        BOOL v10 = v78;
      }

      else
      {
        EmptyDict = (const void *)AutoDict::getEmptyDict(Copy);
        BOOL v10 = v78;
        if (EmptyDict) {
          EmptyDict = CFRetain(EmptyDict);
        }
      }

      v53[5] = EmptyDict;
    }

    else
    {
      v53 = 0LL;
    }

    __int128 v81 = 0u;
    __int128 v82 = 0u;
    v79[0] = 0LL;
    __int128 v80 = 0u;
    v79[1] = v53;
    os_unfair_lock_lock((os_unfair_lock_t)&gFTPSpinLock);
    uint64_t v56 = &unk_18C5B2000;
    if (!gFTPConnectionCache) {
      _FTPConnectionCacheCreate();
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&gFTPSpinLock);
    os_unfair_lock_lock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    CFDictionaryApplyFunction( (CFDictionaryRef)gFTPConnectionTimeouts,  (CFDictionaryApplierFunction)_FTPConnectionCacheExpiration,  Mutable);
    os_unfair_lock_unlock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    CFTypeRef cfa = *(CFTypeRef *)(a4 + 88);
    if (v10)
    {
      NewConnection = createNewConnection((uint64_t)v8, _kFTPConnectionCallBacks, (uint64_t)v79, 0);
      if (NewConnection)
      {
        v58 = NewConnection;
        setConnectionProperties(NewConnection, cfa);
        goto LABEL_106;
      }

  uint64_t v70 = v58 & 0xFFFFFFFFFFFFFFBFLL;
  *((_WORD *)this + 126) = WORD2(v70);
  *((_DWORD *)this + 62) = v70 | 8;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
  CFWriteStreamSignalEvent();
LABEL_128:
  return v9;
}

LABEL_109:
      os_unfair_lock_lock((os_unfair_lock_t)(v56[452] + 8LL));
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, *(const void **)(a4 + 128));
      BOOL v10 = v78;
      if (CFArrayGetCount(Mutable))
      {
        CFIndex v67 = CFArrayGetCount(Mutable);
        if (v67 >= 1)
        {
          unint64_t v68 = v67 + 1;
          do
          {
            v69 = CFArrayGetValueAtIndex(Mutable, v68 - 2);
            CFDictionaryRemoveValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, v69);
            if (v69 != *(const void **)(a4 + 128))
            {
              uint64_t v70 = *((void *)v69 + 12);
              if (v70) {
                pthread_mutex_lock((pthread_mutex_t *)(v70 + 8));
              }
              *((_WORD *)v69 + 44) &= ~1u;
              NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)v69);
              uint64_t v71 = *((void *)v69 + 12);
              if (v71) {
                pthread_mutex_unlock((pthread_mutex_t *)(v71 + 8));
              }
            }

            --v68;
          }

          while (v68 > 1);
        }
      }

      if (Mutable) {
        CFRelease(Mutable);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(gFTPConnectionCache + 8));
      if (v53) {
        (*(void (**)(void *))(*v53 + 48LL))(v53);
      }
      goto LABEL_122;
    }

    uint64_t v74 = _kFTPConnectionCallBacks;
    uint64_t v59 = gFTPConnectionCache;
    int64_t v60 = (os_unfair_lock_s *)(gFTPConnectionCache + 8);
    os_unfair_lock_lock((os_unfair_lock_t)(gFTPConnectionCache + 8));
    uint64_t v75 = v59;
    uint64_t v61 = (NetConnection *)CFDictionaryGetValue(*(CFDictionaryRef *)(v59 + 16), v53);
    if (v61)
    {
      v58 = v61;
      if (NetConnection::willEnqueueRequests(v61))
      {
        int64_t v62 = v60;
        (*(void (**)(NetConnection *))(*(void *)v58 + 40LL))(v58);
        goto LABEL_105;
      }

      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v75 + 16), v53);
    }

    v65 = createNewConnection((uint64_t)v8, v74, (uint64_t)v79, 1);
    if (!v65)
    {
      os_unfair_lock_unlock(v60);
      uint64_t v56 = &unk_18C5B2000;
      goto LABEL_109;
    }

    v58 = v65;
    int64_t v62 = v60;
    setConnectionProperties(v65, cfa);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v75 + 16), v53, v58);
LABEL_105:
    uint64_t v56 = (void *)&unk_18C5B2000;
    os_unfair_lock_unlock(v62);
LABEL_106:
    *(void *)(a4 + 12_Block_object_dispose(va, 8) = v58;
    if (!*(void *)(a4 + 136))
    {
      CFTypeID v66 = (char *)operator new(0x48uLL);
      *(void *)CFTypeID v66 = off_189C12668;
      pthread_mutex_init((pthread_mutex_t *)(v66 + 8), 0LL);
      *(void *)CFTypeID v66 = off_189C12688;
      *(void *)(a4 + 136) = v66;
    }

    goto LABEL_109;
  }

  unint64_t v35 = CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyTypeKey");
  uint64_t v36 = CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyPortNumberKey");
  uint64_t v33 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyHostNameKey");
  if (CFEqual(v35, @"kCFProxyTypeFTP"))
  {
    uint64_t v37 = CFDictionaryCreateMutable(v8, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    CFDictionaryAddValue(v37, @"FTPProxy", v33);
    CFDictionaryAddValue(v37, @"FTPPort", v36);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPProxy", v37);
    if (v37) {
      CFRelease(v37);
    }
    if (v33) {
      CFRetain(v33);
    }
    CFNumberGetValue((CFNumberRef)v36, kCFNumberSInt32Type, &valuePtr);
    CFStringRef v34 = v33;
    goto LABEL_56;
  }

  if (CFEqual(v35, @"kCFProxyTypeSOCKS"))
  {
    unint64_t v45 = CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyUsernameKey");
    int64_t v46 = CFDictionaryGetValue((CFDictionaryRef)v32, @"kCFProxyPasswordKey");
    _SetSOCKS5ProxyInformation(v8, a4, v33, v36, v45, v46);
    uint64_t v33 = 0LL;
LABEL_55:
    CFStringRef v34 = 0LL;
    goto LABEL_56;
  }

  if (!CFEqual(v35, @"kCFProxyTypeHTTP") && !CFEqual(v35, @"kCFProxyTypeHTTPS")) {
    goto LABEL_55;
  }
  if ((*(_WORD *)a4 & 0x80) != 0)
  {
    ++*(void *)(a4 + 120);
    return _FTPStreamOpen(a1, a2, a3, a4);
  }

  else
  {
    CFNumberGetValue((CFNumberRef)v36, kCFNumberSInt32Type, v85);
    uint64_t v63 = CFStringCreateWithFormat(v8, 0LL, @"http://%@:%d", v33, LODWORD(v85[0]));
    v64 = CFURLCreateWithString(v8, v63, 0LL);
    if (v63) {
      CFRelease(v63);
    }
    _StartHTTPRequest(v8, (_WORD *)a4, (void *)a2, v64);
    if (v64) {
      CFRelease(v64);
    }
    *a3 = 1;
    return *(_DWORD *)(a2 + 8) == 0;
  }

      int64_t v55 = (unint64_t)v227;
LABEL_150:
      if (((1LL << v61) & 0x3C) != 0 && ((1LL << v65) & 0x78) != 0)
      {
        CFRange v105 = 0;
        if (a4)
        {
          CFRange v105 = 0;
          CFRange v106 = v236;
          do
          {
            v107 = *v106++;
            v105 += encode_table[2 * v107 + 1];
          }

          while ((unint64_t)v106 < v58);
        }

        v108 = 0;
        v109 = v105 >> 3;
        v110 = (v105 & 7) != 0;
        if ((_DWORD)v51)
        {
          v108 = 0;
          v111 = v233;
          do
          {
            v112 = *v111++;
            v108 += encode_table[2 * v112 + 1];
          }

          while ((unint64_t)v111 < v55);
        }

        v113 = v109 + *(_DWORD *)(v13 + 228) + v110 + (v108 >> 3);
        if ((v108 & 7) != 0) {
          ++v113;
        }
        if ((float)((float)v113 / (float)(v207 + *(_DWORD *)(v13 + 224))) > 0.95)
        {
          if (!(_DWORD)v10) {
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1917, "index");
          }
          v114 = *(FILE **)(v13 + 232);
          if (v114)
          {
            v115 = v51;
            v116 = v64;
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v114);
            fwrite("double lit would result in ratio > 0.95, reset", 0x2EuLL, 1uLL, *(FILE **)(v13 + 232));
            fputc(10, *(FILE **)(v13 + 232));
            LODWORD(v10) = 0;
            v117 = v116;
            unint64_t v51 = v115;
            v223 = v117;
          }

          else
          {
            LODWORD(v10) = 0;
            v223 = v64;
          }

          uint64_t v52 = v229;
LABEL_228:
          v58 = (unint64_t)v234;
          continue;
        }
      }

      break;
    }

    v118 = v65;
    v222 = v62;
    v223 = v64;
    v219 = v63;
    v119 = *(FILE **)(v13 + 232);
    if (v119)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v119);
      fprintf( *(FILE **)(v13 + 232),  "program: %s; %s; %s; flags: 0x%X",
        (&eea2str)[v61],
        (&eha2str)[v118],
        (&eta2str)[v222],
        v219);
      fputc(10, *(FILE **)(v13 + 232));
    }

    switch(v61)
    {
      case 0LL:
        goto LABEL_184;
      case 1LL:
        if (v224 < 1) {
          goto LABEL_186;
        }
        *v221 = 0;
        v126 = lsqpack_enc_int(v221, v218, *v226 - v223, 5);
        uint64_t v61 = v126 - v221;
        if (v126 <= v221) {
          goto LABEL_186;
        }
        goto LABEL_184;
      case 2LL:
        if (v224 < 1) {
          goto LABEL_186;
        }
        v127 = v221;
        *v221 = -64;
        v128 = v223;
        goto LABEL_180;
      case 3LL:
        if (v224 < 1) {
          goto LABEL_186;
        }
        v127 = v221;
        *v221 = 0x80;
        v128 = *v226 - v223;
LABEL_180:
        v129 = lsqpack_enc_int(v127, v218, v128, 6);
        if (v129 <= v127) {
          goto LABEL_186;
        }
        v121 = v129;
        v122 = v218 - (void)v129;
        v124 = v129;
        v125 = (unsigned __int16 *)v233;
        v123 = v51;
LABEL_182:
        v130 = lsqpack_enc_enc_str(7, v124, v122, v125, v123);
        if (v130 < 0)
        {
LABEL_186:
          v133 = *(void *)(*(void *)(v6[9] + 8LL) + 24LL);
          v134 = *(void *)(v6[8] + 8LL);
          v135 = *(void *)(v134 + 24);
          if (v133 < v135 + *(void *)(*(void *)(v6[7] + 8LL) + 24LL))
          {
            subrange = dispatch_data_create_subrange(*(dispatch_data_t *)(*(void *)(v6[10] + 8LL) + 40LL), 0LL, v133);
            v137 = *(void *)(v6[10] + 8LL);
            v138 = *(void **)(v137 + 40);
            *(void *)(v137 + 40) = subrange;

            v134 = *(void *)(v6[8] + 8LL);
            v135 = *(void *)(v134 + 24);
          }

          *(void *)(v134 + 24) = v135 + 512;
          alloc = (dispatch_data_s *)dispatch_data_create_alloc();
          concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(v6[10] + 8LL) + 40LL), alloc);
          v140 = *(void *)(v6[10] + 8LL);
          CFRange v27 = *(void **)(v140 + 40);
          *(void *)(v140 + 40) = concat;
          uint64_t v28 = v209;
          uint64_t v29 = v210;
LABEL_189:

          *(void *)(*(void *)(*v28 + 8LL) + 24LL) = *(void *)(*(void *)(*v29 + 8LL) + 24LL);
          continue;
        }

        uint64_t v61 = &v121[v130] - v221;
LABEL_184:
        switch(v118)
        {
          case 0LL:
            v131 = *v226 + 1;
            v132 = v216;
            goto LABEL_194;
          case 1LL:
            v132 = v216;
            *v216 = -64;
            v141 = v223;
            goto LABEL_220;
          case 2LL:
            v131 = v223;
            v132 = v216;
            if (v223 <= *(_DWORD *)(v13 + 188))
            {
              *v216 = 0x80;
              v141 = *(_DWORD *)(v13 + 188) - v223;
LABEL_220:
              v143 = v132;
              v144 = v217;
              v145 = 6;
            }

            else
            {
LABEL_194:
              *v132 = 16;
              v142 = *(_DWORD *)(v13 + 188);
              if (v131 <= v142) {
                __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2008, "id > enc->qpe_cur_header.base_idx");
              }
              v223 = v131;
              v141 = v131 + ~v142;
              v143 = v132;
              v144 = v217;
              v145 = 4;
            }

            v156 = lsqpack_enc_int(v143, v144, v141, v145);
            if (v156 > v132) {
              goto LABEL_222;
            }
            goto LABEL_8;
          case 3LL:
            v132 = v216;
            *v216 = 80;
            v147 = v223;
            goto LABEL_204;
          case 4LL:
            v146 = v223;
            v132 = v216;
            if (v223 > *(_DWORD *)(v13 + 188)) {
              goto LABEL_199;
            }
            *v216 = 64;
            v147 = *(_DWORD *)(v13 + 188) - v223;
LABEL_204:
            v149 = v132;
            v150 = v217;
            v151 = 4;
            goto LABEL_205;
          case 5LL:
            v146 = *v226 + 1;
            v132 = v216;
LABEL_199:
            *v132 = 0;
            v148 = *(_DWORD *)(v13 + 188);
            if (v146 <= v148) {
              __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2045, "id > enc->qpe_cur_header.base_idx");
            }
            v223 = v146;
            v147 = v146 + ~v148;
            v149 = v132;
            v150 = v217;
            v151 = 3;
LABEL_205:
            v154 = lsqpack_enc_int(v149, v150, v147, v151);
            if (v154 <= v132) {
              goto LABEL_8;
            }
            v153 = v154;
            break;
          case 6LL:
            v132 = v216;
            *v216 = 32;
            v152 = lsqpack_enc_enc_str(3, v216, v213, (unsigned __int16 *)v236, a4);
            if (v152 < 0) {
              goto LABEL_8;
            }
            v153 = &v216[v152];
            break;
          default:
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2075, "prog.ep_hea_action == EHA_LIT_WITH_NAME_STAT");
        }

        v155 = lsqpack_enc_enc_str(7, v153, v217 - (void)v153, (unsigned __int16 *)v233, a6);
        if (v155 < 0)
        {
LABEL_8:
          CFIndex v18 = *(void *)(*(void *)(v6[6] + 8LL) + 24LL);
          uint64_t v19 = *(void *)(v6[5] + 8LL);
          int v20 = *(void *)(v19 + 24);
          if (v18 < v20 + *(void *)(*(void *)(v6[4] + 8LL) + 24LL))
          {
            uint64_t v21 = dispatch_data_create_subrange(*(dispatch_data_t *)(*(void *)(v6[11] + 8LL) + 40LL), 0LL, v18);
            uint64_t v22 = *(void *)(v6[11] + 8LL);
            CFIndex v23 = *(void **)(v22 + 40);
            *(void *)(v22 + 40) = v21;

            uint64_t v19 = *(void *)(v6[5] + 8LL);
            int v20 = *(void *)(v19 + 24);
          }

          *(void *)(v19 + 24) = v20 + 512;
          alloc = (dispatch_data_s *)dispatch_data_create_alloc();
          uint64_t v25 = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(v6[11] + 8LL) + 40LL), alloc);
          uint64_t v26 = *(void *)(v6[11] + 8LL);
          CFRange v27 = *(void **)(v26 + 40);
          *(void *)(v26 + 40) = v25;
          uint64_t v28 = v214;
          uint64_t v29 = v215;
          goto LABEL_189;
        }

        v156 = &v153[v155];
LABEL_222:
        if ((unint64_t)(v222 - 1) > 1)
        {
          if (v222) {
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2117, "prog.ep_tab_action == ETA_NOOP");
          }
          v237 = v156 - v132;
          v170 = v224;
          if ((v219 & 2) != 0) {
            goto LABEL_262;
          }
        }

        else
        {
          unint64_t v51 = a6;
          if (v222 == 1) {
            v162 = a6;
          }
          else {
            v162 = 0;
          }
          v163 = lsqpack_enc_push_entry((uint64_t)v226, v56, v49, v236, a4, v233, v162);
          if (!v163)
          {
            LODWORD(v10) = 0;
            uint64_t v52 = v229;
            int64_t v55 = (unint64_t)v227;
            goto LABEL_228;
          }

          v237 = v156 - v216;
          v171 = *(_DWORD **)(v13 + 160);
          v171[13] += v163[12] + v163[13] + 32;
          if ((v219 & 4) != 0)
          {
            ++v163[9];
            *(_DWORD *)(v13 + 184) |= 2u;
            v172 = v171[15];
            v173 = v163[6];
            v170 = v224;
            if (!v172)
            {
              v171[14] = v173;
              v171[15] = v173;
              if ((v219 & 2) == 0) {
                goto LABEL_268;
              }
              goto LABEL_262;
            }

            if (v173 <= v172) {
              __assert_rtn( "lsqpack_enc_encode",  "lsqpack.c",  2111,  "new_entry->ete_id > enc->qpe_cur_header.hinfo->qhi_max_id");
            }
            v171[15] = v173;
            if ((v219 & 2) != 0) {
              goto LABEL_262;
            }
          }

          else
          {
            v170 = v224;
            if ((v219 & 2) == 0) {
              goto LABEL_268;
            }
LABEL_262:
            ++*(_DWORD *)(v8 + 36);
            v174 = *(void *)(v13 + 160);
            v175 = *(_DWORD *)(v8 + 24);
            v176 = *(_DWORD *)(v174 + 60);
            if (!v176)
            {
              *(_DWORD *)(v174 + 60) = v175;
LABEL_267:
              *(_DWORD *)(v174 + 56) = v175;
              goto LABEL_268;
            }

            if (v176 < v175)
            {
              *(_DWORD *)(v174 + 60) = v175;
              goto LABEL_268;
            }

            if (*(_DWORD *)(v174 + 56) > v175) {
              goto LABEL_267;
            }
          }
        }

void sub_182A10FE0(_Unwind_Exception *a1)
{
}

uint64_t _FTPStreamOpenCompleted(char *a1, uint64_t a2, char *a3)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
  if (!*((void *)a3 + 3)) {
    goto LABEL_12;
  }
  uint64_t v6 = *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96);
  CFTypeID v7 = CFGetTypeID(*((CFTypeRef *)a3 + 3));
  uint64_t v8 = *((void *)a3 + 3);
  if (v8) {
    uint64_t v9 = (CoreStreamBase *)(v8 + 16);
  }
  else {
    uint64_t v9 = 0LL;
  }
  if (v7 != v6)
  {
    CFIndex v38 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    unint64_t v39 = &__block_literal_global_3111;
    goto LABEL_66;
  }

  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    CFIndex v38 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
    unint64_t v39 = &__block_literal_global_16679;
LABEL_66:
    dispatch_once(v38, v39);
  }

uint64_t _FTPStreamWrite(int a1, unsigned __int8 *a2, uint64_t a3, void *a4, uint64_t *a5)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  while (1)
  {
    uint64_t v9 = (NetConnection *)a5[16];
    if (!v9)
    {
LABEL_29:
      uint64_t v25 = 0LL;
      goto LABEL_37;
    }

    uint64_t v10 = a5[3];
    if (v10)
    {
      uint64_t v9 = (NetConnection *)a5[16];
    }

    NetConnection::getState(v9, 1, a5);
    uint64_t v11 = a5[16];
    if (!v11) {
      break;
    }
    uint64_t v12 = *(void *)(v11 + 96);
    if (v12)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
      uint64_t v13 = *(void *)(v11 + 96);
      uint64_t v14 = *(void *)(v11 + 144);
      if (v13) {
        pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
      }
    }

    else
    {
      uint64_t v14 = *(void *)(v11 + 144);
    }

    uint64_t v15 = a5[16];
    uint64_t v16 = *(void *)(v15 + 96);
    if (v16)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
      uint64_t v17 = *(void *)(v15 + 96);
      uint64_t v18 = *(void *)(v15 + 152);
      if (v17) {
        pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
      }
      if (v18)
      {
LABEL_17:
        uint64_t v19 = *(void *)(v18 + 80);
        *a4 = *(void *)(v18 + 72);
        a4[1] = v19;
        if ((_DWORD)v19) {
          goto LABEL_27;
        }
LABEL_23:
        if (v14)
        {
          uint64_t v20 = *(void *)(v14 + 80);
          *a4 = *(void *)(v14 + 72);
          a4[1] = v20;
          LODWORD(v19) = v20;
        }

        goto LABEL_27;
      }
    }

    else
    {
      uint64_t v18 = *(void *)(v15 + 152);
      if (v18) {
        goto LABEL_17;
      }
    }

    LODWORD(v19) = *((_DWORD *)a4 + 2);
    if (!(_DWORD)v19) {
      goto LABEL_23;
    }
LABEL_27:
    if ((_DWORD)v19)
    {
      uint64_t v25 = -1LL;
      goto LABEL_37;
    }
  }

  uint64_t v21 = a5[4];
  uint64_t v22 = v21 + 16;
  if (!v21) {
    uint64_t v22 = 0LL;
  }
  uint64_t v24 = *(void *)(v22 + 56);
  uint64_t v23 = *(void *)(v22 + 64);
  *a4 = v24;
  a4[1] = v23;
  if ((_DWORD)v23) {
    uint64_t v25 = -1LL;
  }
  else {
    uint64_t v25 = 0LL;
  }
LABEL_37:
  uint64_t v26 = a5[3];
  if (v26)
  {
    uint64_t v25 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)(v26 + 16), a2, a3);
    if (v25 <= 0)
    {
      uint64_t v27 = a5[3];
      uint64_t v28 = v27 + 16;
      if (!v27) {
        uint64_t v28 = 0LL;
      }
      *(_OWORD *)a4 = *(_OWORD *)(v28 + 56);
    }
  }

  return v25;
}

uint64_t _FTPStreamCanWrite(int a1, char *a2)
{
  CFIndex v3 = (NetConnection *)*((void *)a2 + 16);
  if (v3)
  {
    NetConnection::getState(v3, 1, (uint64_t *)a2);
    uint64_t v4 = *((void *)a2 + 16);
    if (v4)
    {
      __int128 v24 = 0uLL;
      uint64_t v5 = *(void *)(v4 + 96);
      if (v5)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
        uint64_t v6 = *(void *)(v4 + 96);
        uint64_t v7 = *(void *)(v4 + 144);
        if (v6) {
          pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
        }
      }

      else
      {
        uint64_t v7 = *(void *)(v4 + 144);
      }

      uint64_t v13 = *((void *)a2 + 16);
      uint64_t v14 = *(void *)(v13 + 96);
      if (v14)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v14 + 8));
        uint64_t v15 = *(void *)(v13 + 96);
        uint64_t v16 = *(void *)(v13 + 152);
        if (v15) {
          pthread_mutex_unlock((pthread_mutex_t *)(v15 + 8));
        }
        if (v16)
        {
LABEL_19:
          CFIndex v17 = *(void *)(v16 + 72);
          uint64_t v16 = *(void *)(v16 + 80);
          *(void *)&__int128 v24 = v17;
          *((void *)&v24 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v16;
          int v18 = v16;
          if ((_DWORD)v16) {
            goto LABEL_29;
          }
          goto LABEL_25;
        }
      }

      else
      {
        uint64_t v16 = *(void *)(v13 + 152);
        if (v16) {
          goto LABEL_19;
        }
      }

      CFIndex v17 = 0LL;
      int v18 = 0;
LABEL_25:
      if (v7)
      {
        CFIndex v17 = *(void *)(v7 + 72);
        uint64_t v16 = *(void *)(v7 + 80);
        *(void *)&__int128 v24 = v17;
        *((void *)&v24 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v16;
        int v18 = v16;
      }

void **_FTPStreamClose(uint64_t a1, uint64_t a2)
{
  CFIndex v3 = *(const void **)(a2 + 24);
  if (v3)
  {
    CFTypeID v4 = CFGetTypeID(v3);
    if (v4 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
    {
      _ReleaseDataReadStream(a2);
    }

    else
    {
      _CFTypeInvalidate(*(char **)(a2 + 24));
      _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a2 + 24), *(const __CFArray **)(a2 + 80));
      uint64_t v5 = *(void *)(a2 + 24);
      if (v5) {
        uint64_t v6 = (CoreStreamBase *)(v5 + 16);
      }
      else {
        uint64_t v6 = 0LL;
      }
      CoreStreamBase::_streamInterface_Close(v6);
      uint64_t v7 = *(const void **)(a2 + 24);
      if (v7) {
        CFRelease(v7);
      }
      *(void *)(a2 + 24) = 0LL;
    }
  }

  uint64_t result = *(void ***)(a2 + 128);
  if (result)
  {
    if (NetConnection::getState((NetConnection *)result, 0, (uint64_t *)a2) == 2)
    {
      uint64_t v9 = *(const __CFArray **)(a2 + 80);
      CFIndex Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        CFIndex v11 = Count;
        for (CFIndex i = 0LL; i < v11; i += 2LL)
        {
          uint64_t v13 = *(NetConnection **)(a2 + 128);
          CFArrayGetValueAtIndex(v9, i);
          CFArrayGetValueAtIndex(v9, i + 1);
          NetConnection::unschedule(v13, (uint64_t *)a2, v14, v15);
        }
      }

      NetConnection::requestIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
      return (void **)NetConnection::responseIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
    }

    else
    {
      return NetConnection::dequeue(*(NetConnection **)(a2 + 128), (void *)a2);
    }
  }

  return result;
}

CFArrayRef _FTPStreamCopyProperty(int a1, CFTypeRef cf1, uint64_t a3)
{
  if (CFEqual(cf1, @"kCFStreamPropertyFTPUsePassiveMode"))
  {
    uint64_t v5 = (const void **)MEMORY[0x189604DE8];
    uint64_t v6 = (const void **)MEMORY[0x189604DE0];
    BOOL v7 = (*(_WORD *)a3 & 1) == 0;
    goto LABEL_7;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPFetchResourceInfo"))
  {
    uint64_t v5 = (const void **)MEMORY[0x189604DE8];
    uint64_t v6 = (const void **)MEMORY[0x189604DE0];
    BOOL v7 = (*(_WORD *)a3 & 4) == 0;
    goto LABEL_7;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPFetchNameList"))
  {
    uint64_t v5 = (const void **)MEMORY[0x189604DE8];
    uint64_t v6 = (const void **)MEMORY[0x189604DE0];
    BOOL v7 = (*(_WORD *)a3 & 8) == 0;
LABEL_7:
    if (v7) {
      uint64_t v5 = v6;
    }
LABEL_9:
    Value = *v5;
    if (!*v5) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }

  if (!CFEqual(cf1, @"kCFStreamPropertyFTPFileTransferOffset"))
  {
    if (CFEqual(cf1, @"kCFStreamPropertyFTPResourceSize"))
    {
      __int128 v34 = *(const __CFDictionary **)(a3 + 64);
      if (!v34) {
        goto LABEL_11;
      }
      Value = CFDictionaryGetValue(v34, @"kCFFTPResourceSize");
      if (!Value) {
        goto LABEL_11;
      }
    }

    else
    {
      if (!CFEqual(cf1, @"kCFStreamPropertyFTPAttemptPersistentConnection"))
      {
        if (CFEqual(cf1, @"_kCFStreamPropertyFTPLogInOnly"))
        {
          uint64_t v5 = (const void **)MEMORY[0x189604DE8];
          uint64_t v6 = (const void **)MEMORY[0x189604DE0];
          BOOL v7 = (*(_WORD *)a3 & 0x200) == 0;
        }

        else
        {
          if (!CFEqual(cf1, @"_kCFStreamPropertyFTPRemoveResource")) {
            goto LABEL_11;
          }
          uint64_t v5 = (const void **)MEMORY[0x189604DE8];
          uint64_t v6 = (const void **)MEMORY[0x189604DE0];
          BOOL v7 = (*(_WORD *)a3 & 0x100) == 0;
        }

        goto LABEL_7;
      }

      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 88), cf1);
      if (!Value)
      {
        uint64_t v5 = (const void **)MEMORY[0x189604DE8];
        goto LABEL_9;
      }
    }

uint64_t _FTPStreamSetProperty(int a1, const __CFString *cf1, const __CFString *a3, uint64_t a4)
{
  if (CFEqual(cf1, @"kCFStreamPropertyFTPProxy"))
  {
    if (*(void *)(a4 + 128) || *(void *)(a4 + 24)) {
      return 0LL;
    }
    if (a3)
    {
      CFTypeID v7 = CFGetTypeID(a3);
      if (v7 == CFDictionaryGetTypeID())
      {
        uint64_t v8 = *(__CFDictionary **)(a4 + 88);
        uint64_t v9 = (const __CFString *)&unk_18C5ADEF8;
LABEL_7:
        CFDictionaryRemoveValue(v8, v9);
LABEL_8:
        CFStreamError v10 = *(__CFDictionary **)(a4 + 88);
LABEL_9:
        CFTypeID v11 = cf1;
LABEL_10:
        CFDictionarySetValue(v10, v11, a3);
        return 1LL;
      }

      return 0LL;
    }

    goto LABEL_61;
  }

  if (CFEqual(cf1, &unk_18C5ADEF8))
  {
    if (*(void *)(a4 + 128) || *(void *)(a4 + 24)) {
      return 0LL;
    }
    if (a3)
    {
      CFTypeID v15 = CFGetTypeID(a3);
      if (v15 == CFDictionaryGetTypeID()
        && !CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 88), @"kCFStreamPropertyFTPProxy"))
      {
        uint64_t v8 = *(__CFDictionary **)(a4 + 88);
        uint64_t v9 = @"kCFStreamPropertyFTPProxy";
        goto LABEL_7;
      }

      return 0LL;
    }

    goto LABEL_61;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPUsePassiveMode"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x189604DE0])) {
      __int16 v13 = *(_WORD *)a4 & 0xFFFE;
    }
    else {
      __int16 v13 = *(_WORD *)a4 | 1;
    }
    __int16 v14 = v13 | 2;
    goto LABEL_21;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPFetchResourceInfo"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x189604DE8])) {
      __int16 v14 = *(_WORD *)a4 | 4;
    }
    else {
      __int16 v14 = *(_WORD *)a4 & 0xFFFB;
    }
LABEL_21:
    *(_WORD *)a4 = v14;
    return 1LL;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPFetchNameList"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x189604DE8])) {
      __int16 v14 = *(_WORD *)a4 | 8;
    }
    else {
      __int16 v14 = *(_WORD *)a4 & 0xFFF7;
    }
    goto LABEL_21;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPFileTransferOffset"))
  {
    uint64_t v16 = (void *)(a4 + 72);
    if (a3) {
      CFNumberGetValue((CFNumberRef)a3, kCFNumberLongLongType, v16);
    }
    else {
      *uint64_t v16 = 0LL;
    }
    return 1LL;
  }

  if (CFEqual(cf1, @"_kCFStreamPropertyFTPLogInOnly"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x189604DE8])) {
      __int16 v14 = *(_WORD *)a4 | 0x200;
    }
    else {
      __int16 v14 = *(_WORD *)a4 & 0xFDFF;
    }
    goto LABEL_21;
  }

  if (CFEqual(cf1, @"_kCFStreamPropertyFTPRemoveResource"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x189604DE8])) {
      __int16 v14 = *(_WORD *)a4 | 0x100;
    }
    else {
      __int16 v14 = *(_WORD *)a4 & 0xFEFF;
    }
    goto LABEL_21;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPResourceSize")) {
    return 0LL;
  }
  if (CFEqual(cf1, @"kCFStreamPropertyFTPAttemptPersistentConnection"))
  {
    if (a3 && CFEqual(a3, (CFTypeRef)*MEMORY[0x189604DE0])) {
      goto LABEL_8;
    }
LABEL_61:
    CFStreamError v10 = *(__CFDictionary **)(a4 + 88);
LABEL_62:
    CFTypeID v11 = cf1;
    goto LABEL_63;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPUserName") || CFEqual(cf1, @"kCFStreamPropertyFTPPassword"))
  {
    if (a3)
    {
      CFTypeID v17 = CFGetTypeID(a3);
      if (v17 == CFStringGetTypeID())
      {
        uint64_t result = _ValidFTPString(a3);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_8;
      }

      return 0LL;
    }

    goto LABEL_61;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPUserName_prevalidated"))
  {
    CFStreamError v10 = *(__CFDictionary **)(a4 + 88);
    CFTypeID v11 = @"kCFStreamPropertyFTPUserName";
    if (a3) {
      goto LABEL_10;
    }
LABEL_63:
    CFDictionaryRemoveValue(v10, v11);
    return 1LL;
  }

  if (CFEqual(cf1, @"kCFStreamPropertyFTPPassword_prevalidated"))
  {
    CFStreamError v10 = *(__CFDictionary **)(a4 + 88);
    CFTypeID v11 = @"kCFStreamPropertyFTPPassword";
    if (a3) {
      goto LABEL_10;
    }
    goto LABEL_63;
  }

  uint64_t v18 = *(const void **)(a4 + 24);
  if (!v18) {
    goto LABEL_82;
  }
  CFTypeID v19 = CFGetTypeID(v18);
  uint64_t v20 = *(void *)(a4 + 24);
  if (v20) {
    uint64_t v21 = v20 + 16;
  }
  else {
    uint64_t v21 = 0LL;
  }
  if (v19 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
    && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
  }

  ++*(void *)(v21 + 80);
  uint64_t result = (*(uint64_t (**)(void, const __CFString *, const __CFString *))(**(void **)(v21 + 24) + 32LL))( *(void *)(v21 + 24),  cf1,  a3);
  --*(void *)(v21 + 80);
  if (!(_DWORD)result)
  {
LABEL_82:
    CFStreamError v10 = *(__CFDictionary **)(a4 + 88);
    if (a3) {
      goto LABEL_9;
    }
    goto LABEL_62;
  }

  return result;
}

uint64_t _FTPStreamSchedule(uint64_t a1, CoreSchedulingSet *a2, const __CFString *a3, uint64_t a4)
{
  uint64_t result = _SchedulesAddRunLoopAndMode(*(const __CFArray **)(a4 + 80), a2, a3);
  if ((_DWORD)result)
  {
    uint64_t v8 = *(__CFRunLoopSource **)(a4 + 96);
    if (v8) {
      CFRunLoopAddSource((CFRunLoopRef)a2, v8, a3);
    }
    uint64_t v9 = *(void **)(a4 + 56);
    if (v9) {
      _CFTypeScheduleOnRunLoop(v9, (uint64_t)a2, (uint64_t)a3);
    }
    CFStreamError v10 = *(void **)(a4 + 24);
    if (v10) {
      _CFTypeScheduleOnRunLoop(v10, (uint64_t)a2, (uint64_t)a3);
    }
    uint64_t result = *(void *)(a4 + 128);
    if (result) {
      return NetConnection::schedule(result, (uint64_t *)a4, a2, a3);
    }
  }

  return result;
}

void _FTPStreamUnschedule(uint64_t a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  if (_SchedulesRemoveRunLoopAndMode(*(const __CFArray **)(a4 + 80), a2, a3))
  {
    uint64_t v9 = *(__CFRunLoopSource **)(a4 + 96);
    if (v9) {
      CFRunLoopRemoveSource(a2, v9, a3);
    }
    CFStreamError v10 = *(void **)(a4 + 56);
    if (v10) {
      _CFTypeUnscheduleFromRunLoop(v10, (uint64_t)a2, (uint64_t)a3);
    }
    CFTypeID v11 = *(void **)(a4 + 24);
    if (v11) {
      _CFTypeUnscheduleFromRunLoop(v11, (uint64_t)a2, (uint64_t)a3);
    }
    uint64_t v12 = *(NetConnection **)(a4 + 128);
    if (v12) {
      NetConnection::unschedule(v12, (uint64_t *)a4, v7, v8);
    }
  }

void _InvalidateServer(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    CFIndex v3 = *(const __CFArray **)(a1 + 80);
    if (v3)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v2, v3);
      uint64_t v2 = *(void **)(a1 + 56);
    }

    CFSocketInvalidate((CFSocketRef)v2);
    CFTypeID v4 = *(const void **)(a1 + 56);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 56) = 0LL;
  }

void invalidatePacExecutionContext(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 96);
  if (v2)
  {
    _CFTypeInvalidate(v2);
    _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a1 + 96), *(const __CFArray **)(a1 + 80));
    CFIndex v3 = *(const void **)(a1 + 96);
    if (v3) {
      CFRelease(v3);
    }
    *(void *)(a1 + 96) = 0LL;
  }

void _ReleaseDataReadStream(uint64_t a1)
{
  uint64_t v2 = *(const __CFArray **)(a1 + 80);
  CFIndex v3 = *(char **)(a1 + 24);
  if (v3) {
    CFTypeID v4 = (CoreStreamBase *)(v3 + 16);
  }
  else {
    CFTypeID v4 = 0LL;
  }
  (*(void (**)(CoreStreamBase *, void, void))(*(void *)v4 + 56LL))(v4, 0LL, 0LL);
  _CFTypeUnscheduleFromMultipleRunLoops(v3, v2);
  CoreStreamBase::_streamInterface_Close(v4);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 24) = 0LL;
}

void _ReportError(uint64_t a1, CFStreamError *a2)
{
  uint64_t v4 = *(void *)(a1 + 128);
  if (v4)
  {
    if (!*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)v4 + 80LL))(v4) + 20))
    {
      CFIndex v5 = *(void *)(a1 + 120);
      if (v5 < CFArrayGetCount(*(CFArrayRef *)(a1 + 112)))
      {
        uint64_t v6 = *(void *)(a1 + 128);
        ++*(void *)(a1 + 120);
        *(CFStreamError *)(a1 + 40) = *a2;
        (*(void (**)(uint64_t, CFStreamError *))(*(void *)v6 + 64LL))(v6, a2);
        return;
      }
    }

    uint64_t v7 = *(void *)(a1 + 128);
    *(_WORD *)a1 |= 0x400u;
    if (v7) {
      (*(void (**)(uint64_t, CFStreamError *))(*(void *)v7 + 64LL))(v7, a2);
    }
  }

  else
  {
    *(_WORD *)a1 |= 0x400u;
  }

  uint64_t v8 = *(const void **)(a1 + 24);
  if (v8)
  {
    CFTypeID v9 = CFGetTypeID(v8);
    if (v9 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
    {
      _ReleaseDataReadStream(a1);
    }

    else
    {
      _CFTypeInvalidate(*(char **)(a1 + 24));
      _CFTypeUnscheduleFromMultipleRunLoops(*(void **)(a1 + 24), *(const __CFArray **)(a1 + 80));
      uint64_t v10 = *(void *)(a1 + 24);
      if (v10) {
        CFTypeID v11 = (CoreStreamBase *)(v10 + 16);
      }
      else {
        CFTypeID v11 = 0LL;
      }
      CoreStreamBase::_streamInterface_Close(v11);
      uint64_t v12 = *(const void **)(a1 + 24);
      if (v12) {
        CFRelease(v12);
      }
      *(void *)(a1 + 24) = 0LL;
    }
  }

  CFTypeID v13 = CFGetTypeID(*(CFTypeRef *)(a1 + 32));
  uint64_t v14 = *(void *)(a1 + 32);
  if (v14) {
    CFTypeID v15 = (CoreStreamBase *)(v14 + 16);
  }
  else {
    CFTypeID v15 = 0LL;
  }
  if (v13 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream == -1)
    {
      if (a2) {
        goto LABEL_31;
      }
    }

    else
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
      if (a2) {
        goto LABEL_31;
      }
    }

LABEL_33:
    *(void *)&v16.CFErrorRef error = 0LL;
    v16.domain = 0LL;
    goto LABEL_34;
  }

  if (!a2) {
    goto LABEL_33;
  }
LABEL_31:
  CFStreamError v16 = *a2;
LABEL_34:
  CoreStreamBase::_signalEvent(v15, 8LL, v16, 1);
}

  uint64_t v28 = CFGetAllocator(*((CFTypeRef *)a2 + 11));
  uint64_t v29 = v28;
  v41.version = 0LL;
  v41.info = a2;
  memset(&v41.retain, 0, 24);
  if (v24)
  {
    uint64_t v30 = (const UInt8 *)v43;
    uint64_t v31 = 16LL;
  }

  else
  {
    uint64_t v30 = bytes;
    uint64_t v31 = 28LL;
  }

  uint64_t v35 = CFDataCreate(v28, v30, v31);
  if (!v35
    || ((CFIndex v36 = a2 + 12, (*a2 & 0x80) != 0) ? (v37 = 0LL, v38 = a2 + 12) : (v37 = a2 + 12, v38 = 0LL),
        _CoreSocketStreamCreateWithSignature(v29, v35, v37, v38, v32, v33, v34),
        CFRelease(v35),
        !*v36))
  {
    __int128 v40 = xmmword_182C9D930;
    uint64_t v6 = (CFStreamError *)&v40;
    goto LABEL_38;
  }

  unint64_t v39 = *v36 + 16LL;
  if ((*a2 & 0x80) != 0)
  {
    CoreWriteStream::setClient(v39, -1LL, (uint64_t)_DataStreamCallBack, &v41);
  }

  else
  {
    CoreReadStream::setClient(v39, -1LL, (uint64_t)_DataStreamCallBack, &v41);
  }

  _CFTypeScheduleOnMultipleRunLoops(*((void **)a2 + 3), *((const __CFArray **)a2 + 10));
  CFDictionaryApplyFunction( *((CFDictionaryRef *)a2 + 11),  (CFDictionaryApplierFunction)_StreamPropertyApplier,  *((void **)a2 + 3));
  _StartTransfer(a1, (uint64_t)a2);
}

  CFRelease(v9);
  if (v7) {
LABEL_34:
  }
    CFRelease(v7);
  return v22;
}

      operator delete(v6);
      return;
    }

    if (v4 != 1)
    {
      if (v4 == 2)
      {
        goto LABEL_31;
      }

      if (v4 != 5) {
        return;
      }
      uint64_t v6 = &__p;
LABEL_18:
      if (*(_DWORD *)v6 != 1936482662 || v6[4] != 101)
      {
        if ((v4 & 0x80) == 0) {
          return;
        }
LABEL_32:
        uint64_t v6 = __p;
        goto LABEL_33;
      }

  if (v15)
  {
    CFMakeCollectable(v15);
    CFTypeID v19 = v15;
  }

  return v15;
}

    SInt32 v50 = CFRetain(v8);
    uint64_t v20 = CFDictionaryGetCount(v8);
    uint64_t v21 = v20;
    unint64_t v51 = v20;
    if (v20 - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      uint64_t v52 = 0LL;
    }

    else
    {
      if (v20 > 0x1E)
      {
        uint64_t v22 = (const void **)malloc(8 * v20);
        uint64_t v52 = v22;
        if (!v22)
        {
LABEL_40:
          uint64_t v23 = 0LL;
          while (1)
          {
            uint64_t v24 = (const __CFString *)v48[v23];
            uint64_t v25 = CFGetTypeID(v24);
            if (v25 != CFStringGetTypeID()) {
              goto LABEL_61;
            }
            uint64_t v26 = v52[v23];
            uint64_t v27 = CFGetTypeID(v26);
            if (v27 != CFArrayGetTypeID()) {
              goto LABEL_61;
            }
            HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v44, v24);
            if (v26)
            {
              unint64_t v39 = CFRetain(v26);
              uint64_t v28 = CFArrayGetCount((CFArrayRef)v26);
              uint64_t v29 = v28;
              __int128 v40 = v28;
              if (v28 - 1 > 0x1FFFFFFFFFFFFFFDLL)
              {
                int v41 = 0LL;
              }

              else
              {
                if (v28 > 0x1E)
                {
                  uint64_t v30 = (const void **)malloc(8 * v28);
                  int v41 = v30;
                  if (!v30)
                  {
                    uint64_t v43 = 0LL;
LABEL_52:
                    uint64_t v31 = 0LL;
                    do
                    {
                      uint64_t v43 = v31 + 1;
                      uint64_t v32 = v41[v31];
                      uint64_t v33 = CFGetTypeID(v32);
                      if (v33 == CFStringGetTypeID())
                      {
                        HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)&v37, v32);
                        __int128 v34 = (CFDictionaryRef *)HTTPMessage::mutableHeaders(this);
                        HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)&v35, v24);
                        HTTPHeaderDict::addValue( v34,  (const HTTPHeaderKeyMixedValue *)&v35,  (const HTTPHeaderValueMixedValue *)&v37);
                        uint64_t v35 = off_189C16E38;
                        if (cf) {
                          CFRelease(cf);
                        }
                        uint64_t v37 = off_189C16E38;
                        if (v38) {
                          CFRelease(v38);
                        }
                      }

                      uint64_t v31 = v43;
                    }

                    while (v43 < v40);
                    goto LABEL_59;
                  }
                }

                else
                {
                  int v41 = (const void **)v42;
                  uint64_t v30 = (const void **)v42;
                }

                v54.location = 0LL;
                v54.length = v29;
                CFArrayGetValues((CFArrayRef)v26, v54, v30);
                uint64_t v29 = v40;
              }

              uint64_t v43 = 0LL;
              if (v29 >= 1) {
                goto LABEL_52;
              }
            }

            else
            {
              unint64_t v39 = 0LL;
              __int128 v40 = 0LL;
              int v41 = (const void **)v42;
              uint64_t v43 = 0LL;
            }
}

      operator delete(v4);
      return;
    }

    if (v2 != 1)
    {
      if (v2 == 2)
      {
        goto LABEL_31;
      }

      if (v2 != 5) {
        return;
      }
      uint64_t v4 = &__p;
LABEL_18:
      if (*(_DWORD *)v4 != 1936482662 || v4[4] != 101)
      {
        if ((v2 & 0x80) == 0) {
          return;
        }
LABEL_32:
        uint64_t v4 = __p;
        goto LABEL_33;
      }

  CFRelease(v7);
}

  *(_DWORD *)(a1 + 248) |= v31;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
  uint64_t v33 = WeakRetained;
  if ((!*(void *)(a1 + 232) || *(uint64_t *)(a1 + 224) < 1) && WeakRetained)
  {
    if ((*(_DWORD *)(a1 + 248) & 0x200) != 0) {
      _CFReadStreamSignalEventDelayed();
    }
    goto LABEL_39;
  }

  if (WeakRetained) {
LABEL_39:
  }
    CFRelease(v33);
  __int128 v34 = objc_loadWeakRetained((id *)(a1 + 280));
  if (v34)
  {
    uint64_t v35 = v34;
    if ((*(_DWORD *)(a1 + 248) & 0x400) != 0) {
      _CFWriteStreamSignalEventDelayed();
    }
    CFRelease(v35);
  }

  uint64_t v14 = 1LL;
LABEL_45:
  pthread_mutex_unlock(v10);
  return v14;
}

  if (*((_DWORD *)this + 66)) {
    SocketStream::removeHandshake_NoLock((uint64_t)this, 4);
  }
}

    if (!CFEqual(v12, v15)) {
      return 0LL;
    }
    goto LABEL_34;
  }

  return 0LL;
}

void PACExecutionComplete_FTPStream(uint64_t a1, const void *a2, void *a3)
{
  v17.domain = 0LL;
  *(void *)&v17.CFErrorRef error = 0LL;
  *(_WORD *)a1 &= ~0x1000u;
  invalidatePacExecutionContext(a1);
  *(void *)(a1 + 96) = 0LL;
  if (a3)
  {
    CFRetain(a3);
    *(void *)(a1 + 104) = a3;
    CFIndex v6 = _CFStreamErrorFromCFError((__CFError *)a3);
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      uint64_t v10 = (CoreStreamBase *)(v9 + 16);
    }
    else {
      uint64_t v10 = 0LL;
    }
    uint64_t v11 = 8LL;
    v12.domain = v6;
    *(void *)&v12.CFErrorRef error = v8;
  }

  else
  {
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(a1 + 112) = a2;
    CFTypeID v13 = *(const __CFArray **)(a1 + 80);
    if (v13 && CFArrayGetCount(v13) >= 1 && (_FTPStreamOpen(*(void *)(a1 + 32), &v17, &v16, a1), v17.error))
    {
      uint64_t v14 = *(void *)(a1 + 32);
      if (v14) {
        uint64_t v10 = (CoreStreamBase *)(v14 + 16);
      }
      else {
        uint64_t v10 = 0LL;
      }
      CFStreamError v12 = v17;
      uint64_t v11 = 8LL;
    }

    else
    {
      uint64_t v15 = *(void *)(a1 + 32);
      if (v15) {
        uint64_t v10 = (CoreStreamBase *)(v15 + 16);
      }
      else {
        uint64_t v10 = 0LL;
      }
      uint64_t v11 = 1LL;
      v12.domain = 0LL;
      *(void *)&v12.CFErrorRef error = 0LL;
    }
  }

  CoreStreamBase::_signalEvent(v10, v11, v12, 1);
}

void PACTimerCallback_FTPStream(uint64_t a1, uint64_t a2)
{
  CFIndex v3 = CFGetAllocator(*(CFTypeRef *)(a2 + 32));
  CFErrorRef CFError = __cfnCreateCFError(v3, @"kCFErrorDomainCFNetwork", 308LL, v4, v5, v6, v7, v8, 0LL);
  PACExecutionComplete_FTPStream(a2, 0LL, CFError);
  CFAbsoluteTime Current = CFRunLoopGetCurrent();
  CFRunLoopStop(Current);
}

void _SetSOCKS5ProxyInformation( const __CFAllocator *a1, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1896051E8], a3);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1896051F0], a4);
  if (a5) {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1896051F8], a5);
  }
  if (a6) {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1896051E0], a6);
  }
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a2 + 88), &unk_18C5ADEF8, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void _StartHTTPRequest(const __CFAllocator *a1, _WORD *a2, void *a3, const __CFURL *a4)
{
  v38.version = 0LL;
  v38.info = a2;
  memset(&v38.retain, 0, 24);
  Value = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), @"kCFStreamPropertyFTPUserName");
  uint64_t v9 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 11), @"kCFStreamPropertyFTPPassword");
  uint64_t v10 = (__CFHTTPMessage *)CFDictionaryGetValue( *((CFDictionaryRef *)a2 + 11),  @"_kCFStreamPropertyFTPLastHTTPResponse");
  *a2 |= 0x10u;
  *a3 = 0LL;
  a3[1] = 0LL;
  if (Value)
  {
    CFRetain(Value);
    if (v9)
    {
LABEL_3:
      CFRetain(v9);
      goto LABEL_6;
    }
  }

  else
  {
    Value = CFURLCopyUserName(*((CFURLRef *)a2 + 1));
    if (v9) {
      goto LABEL_3;
    }
  }

  uint64_t v9 = CFURLCopyPassword(*((CFURLRef *)a2 + 1));
LABEL_6:
  *(_OWORD *)CFTypeRef cf = 0u;
  *(_OWORD *)uint64_t v43 = 0u;
  *(_OWORD *)__int128 v40 = 0u;
  *(_OWORD *)int v41 = 0u;
  *(_OWORD *)unint64_t v39 = 0u;
  _CFURLCopyComponents();
  if (Value) {
    CFStringRef v11 = CFURLCreateStringByAddingPercentEscapes(a1, Value, 0LL, 0LL, 0x8000100u);
  }
  else {
    CFStringRef v11 = 0LL;
  }
  v39[1] = v11;
  if (!v40[0])
  {
    if (v9) {
      CFStringRef v12 = CFURLCreateStringByAddingPercentEscapes(a1, v9, 0LL, 0LL, 0x8000100u);
    }
    else {
      CFStringRef v12 = 0LL;
    }
    v40[0] = v12;
  }

  if (cf[1])
  {
    CFRelease(cf[1]);
    cf[1] = 0LL;
  }

  if (v43[0])
  {
    CFRelease(v43[0]);
    v43[0] = 0LL;
  }

  if (cf[0])
  {
    CFRelease(cf[0]);
    cf[0] = 0LL;
  }

  if (Value) {
    CFRelease(Value);
  }
  if (v9) {
    CFRelease(v9);
  }
  CFTypeID v13 = (const __CFURL *)_CFURLCreateFromComponents();
  if (v39[0]) {
    CFRelease(v39[0]);
  }
  if (v39[1]) {
    CFRelease(v39[1]);
  }
  if (v40[0]) {
    CFRelease(v40[0]);
  }
  if (v40[1]) {
    CFRelease(v40[1]);
  }
  if (v41[1]) {
    CFRelease(v41[1]);
  }
  if (v43[1]) {
    CFRelease(v43[1]);
  }
  if (v13)
  {
    Request = CFHTTPMessageCreateRequest(a1, @"GET", v13, @"HTTP/1.1");
    CFRelease(v13);
    if (!v10) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  Request = CFHTTPMessageCreateRequest(a1, @"GET", *((CFURLRef *)a2 + 1), @"HTTP/1.1");
  if (v10)
  {
LABEL_38:
    uint64_t v15 = (const __CFString *)CFDictionaryGetValue( *((CFDictionaryRef *)a2 + 11),  @"kCFStreamPropertyFTPProxyUser");
    char v16 = (const __CFString *)CFDictionaryGetValue( *((CFDictionaryRef *)a2 + 11),  @"kCFStreamPropertyFTPProxyPassword");
    CFHTTPMessageAddAuthentication(Request, v10, v15, v16, 0LL, 1u);
  }

CFMutableDictionaryRef _FTPConnectionCacheCreate(void)
{
  CFPropertyListRef v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (!_kFTPConnectionCallBacks)
  {
    uint64_t v1 = (void *)MEMORY[0x186E12804](v0, 80LL, 0LL);
    _kFTPConnectionCallBacks = (uint64_t)v1;
    void *v1 = 0LL;
    v1[1] = _CFFTPNetConnectionContextAllocate;
    v1[2] = _CFFTPNetConnectionContextFinalize;
    v1[3] = _FTPConnectionCreateStreams;
    v1[4] = _FTPConnectionRequestStateChanged;
    v1[5] = _FTPConnectionTransmitRequest;
    v1[6] = _FTPConnectionReceiveResponse;
    v1[7] = _FTPResponseStreamCallBack;
    v1[8] = _FTPRequestStreamCallBack;
    v1[9] = _FTPCopyRunLoopArrayCallBack;
  }

  gFTPConnectionTimeouts = (uint64_t)CFDictionaryCreateMutable( v0,  0LL,  &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks,  MEMORY[0x189605250]);
  uint64_t v2 = operator new(0x18uLL);
  v2[2] = 0;
  *(void *)uint64_t v2 = off_189C08AC8;
  CFMutableDictionaryRef result = CFDictionaryCreateMutable( 0LL,  0LL,  &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks,  &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  *((void *)v2 + 2) = result;
  gFTPConnectionCache = (uint64_t)v2;
  return result;
}

void sub_182A131D4(_Unwind_Exception *a1)
{
}

void _FTPConnectionCacheExpiration(const void *a1, uint64_t a2, __CFArray *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current >= MEMORY[0x186E12AB0](a2)) {
    CFArrayAppendValue(a3, a1);
  }
}

uint64_t NetConnection::doNotAllowMoreRequests(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  *((_WORD *)this + 44) &= ~1u;
  uint64_t result = NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  }
  return result;
}

uint64_t _CFFTPNetConnectionContextAllocate(const __CFAllocator *a1, __int128 *a2)
{
  uint64_t v4 = MEMORY[0x186E12804](a1, 64LL, 0LL);
  __int128 v5 = a2[3];
  __int128 v7 = *a2;
  __int128 v6 = a2[1];
  *(_OWORD *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = a2[2];
  *(_OWORD *)(v4 + 4_Block_object_dispose(va, 8) = v5;
  *(_OWORD *)uint64_t v4 = v7;
  *(_OWORD *)(v4 + 16) = v6;
  *(void *)(v4 + _Block_object_dispose(va, 8) = *((void *)a2 + 1);
  (*(void (**)(void))(**((void **)a2 + 1) + 40LL))(*((void *)a2 + 1));
  if (!*(void *)(v4 + 48)) {
    *(void *)(v4 + 4_Block_object_dispose(va, 8) = CFDataCreateMutable(a1, 0LL);
  }
  if (!*(void *)(v4 + 56)) {
    *(void *)(v4 + 56) = CFDataCreateMutable(a1, 0LL);
  }
  *(_BYTE *)v4 &= ~4u;
  return v4;
}

void _CFFTPNetConnectionContextFinalize(CFAllocatorRef allocator, void *ptr)
{
  uint64_t v4 = ptr[1];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 48LL))(v4);
  }
  __int128 v5 = (const void *)ptr[3];
  if (v5) {
    CFRelease(v5);
  }
  __int128 v6 = (const void *)ptr[6];
  if (v6) {
    CFRelease(v6);
  }
  __int128 v7 = (const void *)ptr[7];
  if (v7) {
    CFRelease(v7);
  }
  CFAllocatorDeallocate(allocator, ptr);
}

uint64_t _FTPConnectionCreateStreams(__CFAllocator *a1, uint64_t a2, void **a3, void **a4)
{
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v8 = *(const __CFString **)(v7 + 24);
  uint64_t v9 = *(unsigned int *)(v7 + 32);
  int v10 = *(_DWORD *)(v7 + 36);
  unsigned int valuePtr = *(_DWORD *)(v7 + 32);
  CFStringRef v11 = *(const __CFDictionary **)(v7 + 40);
  *a3 = 0LL;
  *a4 = 0LL;
  if ((v10 - 3) <= 1)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(v11, @"kCFStreamPropertyFTPProxy");
    CFTypeID v13 = (const __CFNumber *)CFDictionaryGetValue(Value, @"FTPPort");
    uint64_t v8 = (const __CFString *)CFDictionaryGetValue(Value, @"FTPProxy");
    if (v13)
    {
      CFNumberGetValue(v13, kCFNumberSInt32Type, &valuePtr);
      uint64_t v9 = valuePtr;
    }

    else
    {
      if (v10 == 3) {
        uint64_t v9 = 21LL;
      }
      else {
        uint64_t v9 = 990LL;
      }
      unsigned int valuePtr = v9;
    }
  }

  CFTypeRef v20 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t v14 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(a1, v8, (const __CFAllocator *)(unsigned __int16)v9);
  if (v14 || (uint64_t v14 = CFHostCreateWithName(a1, v8)) != 0LL)
  {
    __CFStreamCreatePairWithSocketToCFHost( a1,  v14,  (const __CFAllocator *)v9,  (__CFReadStream **)&cf,  (__CFWriteStream **)&v20,  0);
    CFRelease(v14);
    uint64_t v15 = (__CFReadStream *)cf;
  }

  else
  {
    uint64_t v15 = 0LL;
    CFTypeRef v20 = 0LL;
    CFTypeRef cf = 0LL;
  }

  *a4 = CoreReadStreamCreateWithCFReadStream(a1, v15);
  *a3 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v20);
  if (cf) {
    CFRelease(cf);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (*a4 && (char v16 = *a3) != 0LL)
  {
    uint64_t v17 = *MEMORY[0x189604DE8];
    ++v16[12];
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)v16[5] + 32LL))(v16[5], 0x18C5AD168LL, v17);
    --v16[12];
    CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)_StreamPropertyApplier, *a4);
    CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)_StreamPropertyApplier, *a3);
    return 0LL;
  }

  else
  {
    __error();
    return 1LL;
  }

void _FTPConnectionRequestStateChanged(uint64_t a1, int a2, uint64_t a3, NetConnection *a4, uint64_t a5)
{
  switch(a2)
  {
    case 1:
      *(void *)(a1 + 12_Block_object_dispose(va, 8) = a4;
      break;
    case 2:
      uint64_t v9 = *(const __CFArray **)(a1 + 80);
      CFIndex Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        CFIndex v11 = Count;
        for (CFIndex i = 0LL; i < v11; i += 2LL)
        {
          ValueAtIndex = (CoreSchedulingSet *)CFArrayGetValueAtIndex(v9, i);
          uint64_t v14 = (const __CFString *)CFArrayGetValueAtIndex(v9, i + 1);
          NetConnection::schedule((uint64_t)a4, (uint64_t *)a1, ValueAtIndex, v14);
        }
      }

      int v15 = *(_DWORD *)(a5 + 20);
      if (v15 == 8)
      {
        _StartProcess(a5, a1);
      }

      else if (v15 >= 9)
      {
        *(_BYTE *)a5 |= 2u;
        NetConnection::getState(*(NetConnection **)(a1 + 128), 1, (uint64_t *)a1);
      }

      break;
    case 5:
      Value = CFDictionaryGetValue( *(CFDictionaryRef *)(a1 + 88),  @"kCFStreamPropertyFTPAttemptPersistentConnection");
      if (Value)
      {
        int v17 = CFEqual(Value, (CFTypeRef)*MEMORY[0x189604DE0]);
        *(_BYTE *)a5 |= 8u;
        if (v17) {
          goto LABEL_16;
        }
      }

      else
      {
        *(_BYTE *)a5 |= 8u;
      }

      uint64_t v18 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      CFDateRef v20 = CFDateCreate(v18, Current + 180.0);
      if (v20)
      {
        CFDateRef v21 = v20;
        CFDictionarySetValue((CFMutableDictionaryRef)gFTPConnectionTimeouts, *(const void **)(a1 + 128), v20);
        CFRelease(v21);
      }

      goto LABEL_16;
    case 7:
LABEL_16:
      uint64_t v22 = *(const __CFArray **)(a1 + 80);
      CFIndex v23 = CFArrayGetCount(v22);
      NetConnection::dequeue(a4, (void *)a1);
      if (v23 >= 1)
      {
        for (CFIndex j = 0LL; j < v23; j += 2LL)
        {
          CFArrayGetValueAtIndex(v22, j);
          CFArrayGetValueAtIndex(v22, j + 1);
          NetConnection::unschedule(a4, (uint64_t *)a1, v25, v26);
        }
      }

      uint64_t v27 = *(void *)(a1 + 128);
      if (v27) {
        (*(void (**)(uint64_t))(*(void *)v27 + 48LL))(v27);
      }
      *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
      if (a2 == 7 && (*(_WORD *)a1 & 0x400) == 0)
      {
        _FTPStreamOpen(*(void *)(a1 + 32), &v33, &v32, a1);
        if (v32)
        {
          if (v33.error) {
            uint64_t v28 = 8LL;
          }
          else {
            uint64_t v28 = 1LL;
          }
          CFTypeID v29 = CFGetTypeID(*(CFTypeRef *)(a1 + 32));
          uint64_t v30 = *(void *)(a1 + 32);
          if (v30) {
            uint64_t v31 = (CoreStreamBase *)(v30 + 16);
          }
          else {
            uint64_t v31 = 0LL;
          }
          if (v29 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
            && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
          {
            dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
          }

          CoreStreamBase::_signalEvent(v31, v28, v33, 1);
        }
      }

      break;
    default:
      return;
  }

void _FTPConnectionTransmitRequest(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[12];
  if (!v6)
  {
    uint64_t v8 = a2[18];
LABEL_7:
    uint64_t v11 = a2[19];
    goto LABEL_8;
  }

  pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  uint64_t v7 = a2[12];
  uint64_t v8 = a2[18];
  if (!v7) {
    goto LABEL_7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  uint64_t v9 = a2[12];
  if (!v9) {
    goto LABEL_7;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  uint64_t v10 = a2[12];
  uint64_t v11 = a2[19];
  if (v10) {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
  }
LABEL_8:
  if (v8) {
    CFStringRef v12 = (CoreStreamBase *)(v8 + 16);
  }
  else {
    CFStringRef v12 = 0LL;
  }
  if (CoreStreamBase::_streamInterface_CanWrite(v12))
  {
    if ((*(_BYTE *)a3 & 0x10) != 0)
    {
      _FTPRequestStreamCallBack(a1, v8, 4LL, a2, a3);
    }

    else
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kCFStreamPropertyFTPUserName");
      uint64_t v14 = CFGetAllocator(*(CFTypeRef *)(a1 + 80));
      uint64_t v15 = *(void *)(a3 + 8);
      uint64_t v16 = *(void *)(v15 + 24);
      int v17 = *(_DWORD *)(v15 + 36);
      uint64_t v18 = *(int *)(v15 + 32);
      if (Value)
      {
        CFRetain(Value);
      }

      else
      {
        Value = CFURLCopyUserName(*(CFURLRef *)(a1 + 8));
        if (!Value) {
          Value = CFRetain(@"anonymous");
        }
      }

      if ((v17 - 3) <= 1)
      {
        BOOL v20 = v17 == 4 && (_DWORD)v18 == 990;
        BOOL v21 = (_DWORD)v18 == 21 && v17 == 3;
        if (v21 || v20) {
          CFStringRef v22 = CFStringCreateWithFormat(v14, 0LL, @"%@@%@", Value, v16);
        }
        else {
          CFStringRef v22 = CFStringCreateWithFormat(v14, 0LL, @"%@@%@:%ld", Value, v16, v18);
        }
        CFStringRef v23 = v22;
        CFRelease(Value);
        Value = v23;
      }

      CFStringRef v24 = CFStringCreateWithFormat(v14, 0LL, @"USER %@\r\n", Value);
      CFRelease(Value);
      *(_BYTE *)a3 |= 0x10u;
      if (v24)
      {
        _WriteCommand(a3, a1, v24);
        CFRelease(v24);
      }

      else
      {
        v32.domain = 1LL;
        SInt32 v25 = *__error();
        if (!v25) {
          SInt32 v25 = 12;
        }
        v32.CFErrorRef error = v25;
        _ReportError(a1, &v32);
      }
    }
  }

  if (*(void *)(a1 + 128))
  {
    if (v11) {
      int v26 = (CoreStreamBase *)(v11 + 16);
    }
    else {
      int v26 = 0LL;
    }
    if (CoreStreamBase::_streamInterface_CanRead(v26))
    {
      uint64_t v27 = a2[12];
      if (v27)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v27 + 8));
        uint64_t v28 = a2[12];
        uint64_t v29 = a2[19];
        if (v28) {
          pthread_mutex_unlock((pthread_mutex_t *)(v28 + 8));
        }
      }

      else
      {
        uint64_t v29 = a2[19];
      }

      if (v29) {
        uint64_t v30 = (CoreStreamBase *)(v29 + 16);
      }
      else {
        uint64_t v30 = 0LL;
      }
    }
  }

void _FTPConnectionReceiveResponse(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[12];
  if (!v6)
  {
    uint64_t v8 = a2[19];
LABEL_7:
    uint64_t v11 = a2[18];
    goto LABEL_8;
  }

  pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  uint64_t v7 = a2[12];
  uint64_t v8 = a2[19];
  if (!v7) {
    goto LABEL_7;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  uint64_t v9 = a2[12];
  if (!v9) {
    goto LABEL_7;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  uint64_t v10 = a2[12];
  uint64_t v11 = a2[18];
  if (v10) {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
  }
LABEL_8:
  if (v8) {
    CFStringRef v12 = (CoreStreamBase *)(v8 + 16);
  }
  else {
    CFStringRef v12 = 0LL;
  }
  if (*(void *)(a1 + 128))
  {
    if (v11) {
      uint64_t v14 = (CoreStreamBase *)(v11 + 16);
    }
    else {
      uint64_t v14 = 0LL;
    }
  }

void _FTPResponseStreamCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  switch(a3)
  {
    case 16LL:
      goto LABEL_115;
    case 8LL:
      uint64_t v13 = a2 + 16;
      if (!a2) {
        uint64_t v13 = 0LL;
      }
      __int128 v14 = *(_OWORD *)(v13 + 56);
      break;
    case 2LL:
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(a5 + 48));
      uint64_t v9 = *(void *)(a5 + 32);
      uint64_t v10 = a2 ? a2 + 16 : 0LL;
      uint64_t v11 = Length - v9;
      if (v11 <= 2047)
      {
        CFDataSetLength(*(CFMutableDataRef *)(a5 + 48), *(void *)(a5 + 32) + 2048LL);
        if (CFDataGetLength(*(CFDataRef *)(a5 + 48)) < *(void *)(a5 + 32) + 2048LL)
        {
          CFStringRef v12 = &xmmword_182C9D930;
LABEL_116:
          __int128 v14 = *v12;
          break;
        }

        uint64_t v11 = 2048LL;
      }

      uint64_t v15 = &CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 48))[*(void *)(a5 + 32)];
      uint64_t v16 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)v10, v15, v11);
      if ((v16 & 0x8000000000000000LL) == 0)
      {
        if (v16)
        {
          uint64_t v17 = *(void *)(a5 + 32) + v16;
          *(void *)(a5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v17;
          if (!v17) {
            return;
          }
          parsed = (CFDictionaryRef *)(a1 + 64);
          uint64_t v18 = MEMORY[0x1895F8770];
          while (1)
          {
            MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 48));
            uint64_t Line = _FindLine( MutableBytePtr,  *(void *)(a5 + 32),  (const unsigned __int8 **)&v46,  (const unsigned __int8 **)&v45);
            if (!Line) {
              return;
            }
            uint64_t v21 = Line;
            CFStringRef v22 = v46;
            if (!v46) {
              goto LABEL_101;
            }
            int64_t v23 = v45 - v46;
            if (v45 - v46 < 4) {
              break;
            }
            uint64_t v24 = *v46;
            if ((*(_DWORD *)(v18 + 4 * v24 + 60) & 0x400) == 0) {
              break;
            }
            uint64_t v25 = v46[1];
            if ((*(_DWORD *)(v18 + 4 * v25 + 60) & 0x400) == 0) {
              break;
            }
            uint64_t v26 = v46[2];
            if ((*(_DWORD *)(v18 + 4 * v26 + 60) & 0x400) == 0) {
              break;
            }
            int v27 = v46[3];
            if (v27 != 45 && v27 != 32) {
              break;
            }
            int v28 = 100 * v24 + 10 * v25 + v26;
            SInt32 v29 = v28 - 5328;
            if (v27 == 32)
            {
              char v30 = *(_BYTE *)a5;
              if ((*(_BYTE *)a5 & 1) != 0 && v29 != *(_DWORD *)(a5 + 16))
              {
                *(void *)&__int128 v47 = 6LL;
                goto LABEL_126;
              }

              *(_DWORD *)(a5 + 16) = v29;
              char v31 = v30 & 0xFE;
            }

            else
            {
              if (v29 == -1) {
                break;
              }
              *(_DWORD *)(a5 + 16) = v29;
              char v31 = *(_BYTE *)a5 | 1;
            }

            *(_BYTE *)a5 = v31;
LABEL_42:
            int v32 = *(_DWORD *)(a5 + 20);
            if ((v31 & 2) != 0)
            {
              if (v32 > 8)
              {
                if (v32 <= 0xE)
                {
                  if ((v31 & 1) == 0)
                  {
                    *(_DWORD *)(a5 + 20) = 8;
                    _StartProcess(a5, a1);
                  }

                  goto LABEL_101;
                }
              }

              else
              {
                *(_BYTE *)a5 = v31 & 0xFD;
              }
            }

            switch(v32)
            {
              case 0:
                if ((v31 & 1) == 0) {
                  _HandleConnect(a5, a1, v22, v23);
                }
                break;
              case 1:
                if ((v31 & 1) == 0) {
                  _HandleUsername(a5, a1);
                }
                break;
              case 2:
                if ((v31 & 1) == 0) {
                  _HandlePassword(a5, a1);
                }
                break;
              case 3:
                if ((v31 & 1) == 0) {
                  _HandleSystem(a5, a1, v22, v23);
                }
                break;
              case 4:
                if ((v31 & 1) == 0) {
                  _HandleSiteDirStyle(a5, a1, v22, v23);
                }
                break;
              case 5:
                if ((v31 & 1) == 0)
                {
                  *(_DWORD *)(a5 + 20) = 6;
                  _WriteCommand(a5, a1, @"PWD\r\n");
                }

                break;
              case 6:
                if ((v31 & 1) == 0) {
                  _HandlePrintWorkingDirectory(a5, a1, (char *)v22, v23);
                }
                break;
              case 7:
                if ((v31 & 1) == 0) {
                  _HandleType(a5, a1);
                }
                break;
              case 9:
                if ((v31 & 1) == 0) {
                  _HandleChangeDirectory((char *)a5, a1);
                }
                break;
              case 10:
                if ((v31 & 1) == 0) {
                  _HandlePassive(a5, (_WORD *)a1, (uint64_t)v22);
                }
                break;
              case 11:
                if ((v31 & 1) == 0) {
                  _HandlePort(a5, a1);
                }
                break;
              case 12:
                if (!*parsed)
                {
                  CFStreamError v33 = CFGetAllocator(*(CFTypeRef *)(a1 + 88));
                  CFFTPCreateParsedResourceListing(v33, v22, v23, parsed);
                }

                if ((v31 & 1) != 0 || (*(_DWORD *)(v18 + 4LL * *v22 + 60) & 0x400) == 0) {
                  break;
                }
                uint64_t v34 = CFGetAllocator(*(CFTypeRef *)(a1 + 88));
                uint64_t v35 = v34;
                if (*(void *)(a1 + 72))
                {
                  CFStringRef v36 = CFStringCreateWithFormat(v34, 0LL, @"REST %lld\r\n", *(void *)(a1 + 72));
                  *(_DWORD *)(a5 + 20) = 14;
LABEL_77:
                  _WriteCommand(a5, a1, v36);
                  if (v36) {
                    CFRelease(v36);
                  }
                  break;
                }

                PathForContext = _CreatePathForContext(v34, a5, *(__CFURL **)(a1 + 8));
                if (PathForContext)
                {
                  __int128 v40 = PathForContext;
                  CFStringRef v36 = CFStringCreateWithFormat(v35, 0LL, @"RETR %@\r\n", PathForContext);
                  *(_DWORD *)(a5 + 20) = 15;
                  *(_WORD *)a1 &= ~0x800u;
                  CFRelease(v40);
                  uint64_t v41 = *(void *)(a1 + 24);
                  if (v41)
                  {
                    CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v41 + 16));
                  }

                  goto LABEL_77;
                }

                __int128 v47 = xmmword_182C9D8F0;
                _ReportError(a1, (CFStreamError *)&v47);
                break;
              case 13:
                if ((v31 & 1) == 0) {
                  _HandleSize(a5, a1, (uint64_t)v22, v23);
                }
                break;
              case 14:
                if ((v31 & 1) == 0) {
                  _HandleRestart(a5, a1);
                }
                break;
              case 15:
                if ((v31 & 1) == 0) {
                  goto LABEL_90;
                }
                break;
              case 16:
                if ((v31 & 1) == 0) {
                  goto LABEL_90;
                }
                break;
              case 17:
                if ((v31 & 1) == 0) {
                  goto LABEL_90;
                }
                break;
              case 18:
                if ((v31 & 1) == 0) {
LABEL_90:
                }
                  _HandleRetrieve(a5, a1);
                break;
              case 19:
                if ((v31 & 1) == 0) {
                  goto LABEL_100;
                }
                break;
              case 20:
                if ((v31 & 1) == 0) {
                  goto LABEL_100;
                }
                break;
              case 21:
                if ((v31 & 1) == 0) {
                  goto LABEL_100;
                }
                break;
              case 22:
                if ((v31 & 1) == 0) {
                  _HandleRenameFrom(a5, a1);
                }
                break;
              case 23:
                if ((v31 & 1) == 0) {
LABEL_100:
                }
                  _HandleMakeDirectory(a5, a1);
                break;
              default:
                break;
            }

LABEL_101:
            uint64_t v37 = *(void *)(a5 + 32);
            size_t v38 = v37 - v21;
            *(void *)(a5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v37 - v21;
            if (v37 != v21)
            {
              memmove(MutableBytePtr, &MutableBytePtr[v21], v38);
              size_t v38 = *(void *)(a5 + 32);
            }

            if (!v38) {
              return;
            }
          }

          char v31 = *(_BYTE *)a5;
          if ((*(_BYTE *)a5 & 1) == 0)
          {
            *(void *)&__int128 v47 = 6LL;
            SInt32 v29 = -1;
LABEL_126:
            DWORD2(v47) = v29;
            *(_DWORD *)(a5 + 16) = v29;
            goto LABEL_118;
          }

          goto LABEL_42;
        }

        if ((*(_BYTE *)a5 & 8) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 136) + 8LL));
          uint64_t v42 = *(void *)(a1 + 128);
          if (v42)
          {
            (*(void (**)(uint64_t))(*(void *)v42 + 72LL))(v42);
            NetConnection::dequeue(*(NetConnection **)(a1 + 128), (void *)a1);
            uint64_t v43 = *(void *)(a1 + 128);
            if (v43) {
              (*(void (**)(uint64_t))(*(void *)v43 + 48LL))(v43);
            }
            *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
          }

          pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 136) + 8LL));
          _FTPStreamOpen(*(void *)(a1 + 32), &v47, &v46, a1);
          return;
        }

          uint64_t v9 = v24 + 1;
          switch(v24[1])
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_103;
            case 9:
            case 32:
            case 59:
              goto LABEL_144;
            case 13:
              CFStreamError v33 = (char *)v24[2];
              uint64_t v9 = v24 + 2;
              if (((1LL << v24[2]) & 0x28000000FFFFF9FFLL) != 0) {
                goto LABEL_157;
              }
              if (v33 == (char *)10)
              {
                uint64_t v7 = v24 + 2;
LABEL_142:
                uint64_t v37 = *++v9;
                CFStringRef v36 = v37;
                if (v37 != 9 && v36 != 32) {
                  goto LABEL_225;
                }
                while (1)
                {
LABEL_144:
                  unint64_t v39 = *++v9;
                  size_t v38 = v39;
                  if (v39 <= 0x22)
                  {
                    if (((1LL << v38) & 0xFFFFDDFFLL) != 0) {
                      goto LABEL_225;
                    }
                    if (v38 == 13)
                    {
LABEL_141:
                      uint64_t v35 = *++v9;
                      if (v35 != 10) {
                        goto LABEL_225;
                      }
                      goto LABEL_142;
                    }

                    if (v38 == 34) {
                      goto LABEL_154;
                    }
                  }

                  if ((_DWORD)v38 == 127) {
                    goto LABEL_225;
                  }
                }
              }

          CFRelease(v39);
          goto LABEL_51;
        }

LABEL_115:
        CFStringRef v12 = &xmmword_182C9D900;
        goto LABEL_116;
      }

      __int128 v14 = *(_OWORD *)(v10 + 56);
      break;
    default:
      return;
  }

  __int128 v47 = v14;
LABEL_118:
  _ReportError(a1, (CFStreamError *)&v47);
}

          if (CFBooleanGetValue((CFBooleanRef)*a3)) {
            *(_WORD *)&this->fFlags |= 2u;
          }
          SInt32 v50 = (void *)a3[1];
          if (v50) {
            SInt32 v50 = (void *)CFRetain(v50);
          }
          this->fURL = (__CFURL *)v50;
          unint64_t v51 = (const __CFNumber *)a3[2];
          unsigned int valuePtr = 0LL;
          Value = CFNumberGetValue(v51, kCFNumberDoubleType, &valuePtr);
          v53 = *(double *)&valuePtr;
          if (!Value) {
            v53 = 0.0;
          }
          this->fTimeout = v53;
          unint64_t v54 = (const __CFNumber *)a3[3];
          unsigned int valuePtr = 0LL;
          int64_t v55 = CFNumberGetValue(v54, kCFNumberCFIndexType, &valuePtr);
          uint64_t v56 = valuePtr;
          if (!v55) {
            uint64_t v56 = 0LL;
          }
          this->fCachePolicy = v56;
          uint64_t v57 = (void *)a3[4];
          if (v57) {
            uint64_t v57 = (void *)CFRetain(v57);
          }
          this->fMainDocumentURL = (__CFURL *)v57;
          *(_WORD *)&this->fFlags = *(_WORD *)&this->fFlags & 0xFFFE | (CFBooleanGetValue((CFBooleanRef)a3[5]) != 0);
          uint64_t v59 = (const __CFNumber *)a3[6];
          unsigned int valuePtr = 0LL;
          if (!CFNumberGetValue(v59, kCFNumberCFIndexType, &valuePtr)) {
            goto LABEL_139;
          }
          int64_t v60 = valuePtr;
          if (!valuePtr) {
            goto LABEL_139;
          }
          if ((valuePtr & 2) != 0)
          {
            *(_WORD *)&this->fFlags |= 0x20u;
            if ((v60 & 4) == 0)
            {
LABEL_130:
              if ((v60 & 8) == 0) {
                goto LABEL_131;
              }
              goto LABEL_179;
            }
          }

          else if ((valuePtr & 4) == 0)
          {
            goto LABEL_130;
          }

          *(_WORD *)&this->fFlags |= 0x40u;
          if ((v60 & 8) == 0)
          {
LABEL_131:
            if ((v60 & 0x10) == 0) {
              goto LABEL_132;
            }
            goto LABEL_180;
          }

void _FTPRequestStreamCallBack(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  switch(a3)
  {
    case 16LL:
      goto LABEL_20;
    case 8LL:
      uint64_t v8 = a2 + 16;
      if (!a2) {
        uint64_t v8 = 0LL;
      }
      __int128 v9 = *(_OWORD *)(v8 + 56);
      goto LABEL_21;
    case 4LL:
      if ((*(_BYTE *)a5 & 0x10) == 0)
      {
        _FTPConnectionTransmitRequest(a1, a4, a5);
        return;
      }

      if (*(void *)(a5 + 40))
      {
        MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a5 + 56));
        uint64_t v11 = *(void *)(a5 + 40);
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        {
          uint64_t v15 = *(void *)(a5 + 40);
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
          uint64_t v11 = v15;
        }

        if (a2) {
          uint64_t v12 = a2 + 16;
        }
        else {
          uint64_t v12 = 0LL;
        }
        uint64_t v13 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)v12, MutableBytePtr, v11);
        if (v13 < 0)
        {
          __int128 v9 = *(_OWORD *)(v12 + 56);
          goto LABEL_21;
        }

        if (v13)
        {
          size_t v14 = *(void *)(a5 + 40) - v13;
          *(void *)(a5 + 40) = v14;
          memmove(MutableBytePtr, &MutableBytePtr[v13], v14);
          return;
        }

CFArrayRef _FTPCopyRunLoopArrayCallBack(uint64_t a1)
{
  return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], *(CFArrayRef *)(a1 + 80));
}

uint64_t _FindLine( const unsigned __int8 *a1, uint64_t a2, const unsigned __int8 **a3, const unsigned __int8 **a4)
{
  uint64_t v4 = 0LL;
  *a3 = 0LL;
  *a4 = 0LL;
  if (a1 && a2)
  {
    __int128 v5 = &a1[a2 - 1];
    if (v5 < a1)
    {
      return a2;
    }

    else
    {
      uint64_t v6 = a1;
      while (1)
      {
        int v7 = *v6;
        if (v7 != 10 && v7 != 13) {
          break;
        }
        if (++v6 > v5) {
          return a2;
        }
      }

      if (v6 <= v5)
      {
        for (CFIndex i = v6 + 1; v7 != 10 && v7 != 13; ++i)
        {
          if (i > v5) {
            return v6 - a1;
          }
          unsigned __int8 v12 = *i;
          LOBYTE(v7) = v12;
        }

        uint64_t v13 = i - 1;
        *a3 = v6;
        *a4 = v13;
        do
        {
          int v14 = *v13;
          if (v14 != 13 && v14 != 10) {
            break;
          }
          ++v13;
        }

        while (v13 <= v5);
        return v13 - a1;
      }

      else
      {
        return v6 - a1;
      }
    }
  }

  return v4;
}

void _StartProcess(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)a2 & 0x200) != 0)
  {
    CFTypeID v6 = CFGetTypeID(*(CFTypeRef *)(a2 + 32));
    uint64_t v7 = *(void *)(a2 + 32);
    if (v7) {
      uint64_t v8 = (CoreStreamBase *)(v7 + 16);
    }
    else {
      uint64_t v8 = 0LL;
    }
    if (v6 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
      && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
    }

    v14.domain = 0LL;
    *(void *)&v14.CFErrorRef error = 0LL;
    CoreStreamBase::_signalEvent(v8, 1LL, v14, 1);
    _ConnectionComplete(a1, a2);
  }

  else
  {
    uint64_t v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    *(_BYTE *)a1 &= ~2u;
    if ((*(_BYTE *)a2 & 0x80) == 0
      && (CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)) || _IsRoot(*(const __CFURL **)(a2 + 8))))
    {
      PathForContext = _CreatePathForContext(v4, a1, *(__CFURL **)(a2 + 8));
      if (!PathForContext)
      {
LABEL_6:
        __int128 v13 = xmmword_182C9D8F0;
        _ReportError(a2, (CFStreamError *)&v13);
        return;
      }
    }

    else
    {
      __int128 v9 = *(const __CFURL **)(a2 + 8);
      PathComponent = CFURLCreateCopyDeletingLastPathComponent(v4, v9);
      *(void *)(a2 + _Block_object_dispose(va, 8) = PathComponent;
      PathForContext = _CreatePathForContext(v4, a1, PathComponent);
      uint64_t v11 = *(const void **)(a2 + 8);
      if (v11) {
        CFRelease(v11);
      }
      *(void *)(a2 + _Block_object_dispose(va, 8) = v9;
      if (!PathForContext) {
        goto LABEL_6;
      }
    }

    unsigned __int8 v12 = CFStringCreateWithFormat(v4, 0LL, @"CWD %@\r\n", PathForContext);
    CFRelease(PathForContext);
    *(_DWORD *)(a1 + 20) = 9;
    _WriteCommand(a1, a2, v12);
    if (v12) {
      CFRelease(v12);
    }
  }

void _HandleConnect(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4 >= 0xC8)
  {
    if (v4 < 0x12C)
    {
      uint64_t v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 80));
      __int128 v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
      if (v9 || (__int128 v9 = CFStringCreateWithBytes(v8, a3, a4, 0x201u, 0)) != 0LL)
      {
        v11.length = CFStringGetLength(v9);
        v11.location = 0LL;
        if (CFStringFindWithOptions(v9, @"Mac OS X Server", v11, 0LL, 0LL)) {
          *(_BYTE *)a1 |= 4u;
        }
        CFRelease(v9);
      }

      *(_DWORD *)(a1 + 20) = 1;
    }

    else
    {
      v10.domain = 6LL;
      v10.CFErrorRef error = v4;
      _ReportError(a2, &v10);
    }
  }

void _HandleUsername(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (v3 - 400 <= 0xFFFFFF37)
  {
    v9.domain = 6LL;
LABEL_3:
    v9.CFErrorRef error = v3;
    _ReportError(a2, &v9);
    return;
  }

  if (v3 < 0x12C)
  {
    *(_DWORD *)(a1 + 20) = 3;
    _WriteCommand(a1, a2, @"SYST\r\n");
  }

  else
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 88), @"kCFStreamPropertyFTPPassword");
    if (Value)
    {
      CFTypeID v6 = Value;
      CFRetain(Value);
    }

    else
    {
      CFTypeID v6 = CFURLCopyPassword(*(CFURLRef *)(a2 + 8));
      if (!v6) {
        CFTypeID v6 = CFRetain(@"cfnetwork@apple.com");
      }
    }

    uint64_t v7 = CFGetAllocator(*(CFTypeRef *)(a2 + 80));
    CFStringRef v8 = CFStringCreateWithFormat(v7, 0LL, @"PASS %@\r\n", v6);
    if (v6) {
      CFRelease(v6);
    }
    if (!v8)
    {
      v9.domain = 1LL;
      unsigned int v3 = *__error();
      if (!v3) {
        unsigned int v3 = 12;
      }
      goto LABEL_3;
    }

    *(_DWORD *)(a1 + 20) = 2;
    _WriteCommand(a1, a2, v8);
    CFRelease(v8);
  }

void _HandlePassword(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (v2 - 400 > 0xFFFFFF37 && v2 < 0x12C)
  {
    *(_DWORD *)(a1 + 20) = 3;
    _WriteCommand(a1, a2, @"SYST\r\n");
  }

  else
  {
    v3.domain = 6LL;
    v3.CFErrorRef error = v2;
    _ReportError(a2, &v3);
  }

void _HandleSystem(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  if ((*(_DWORD *)(a1 + 16) - 200) > 0x63)
  {
    CFStreamError v9 = 0LL;
    goto LABEL_6;
  }

  CFStringRef v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  CFStreamError v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
  CFIndex Length = CFStringGetLength(v9);
  if (!v9)
  {
LABEL_6:
    char v11 = 1;
    goto LABEL_7;
  }

  v13.length = Length;
  v13.location = 0LL;
  if (CFStringFindWithOptions(v9, @"Windows_NT", v13, 0LL, 0LL))
  {
    *(_DWORD *)(a1 + 20) = 4;
    _WriteCommand(a1, a2, @"SITE DIRSTYLE\r\n");
LABEL_11:
    CFRelease(v9);
    return;
  }

  char v11 = 0;
LABEL_7:
  if ((*(_BYTE *)a1 & 4) != 0)
  {
    *(_DWORD *)(a1 + 20) = 5;
    unsigned __int8 v12 = @"SITE TRUTH ON\r\n";
  }

  else
  {
    *(_DWORD *)(a1 + 20) = 6;
    unsigned __int8 v12 = @"PWD\r\n";
  }

  _WriteCommand(a1, a2, v12);
  if ((v11 & 1) == 0) {
    goto LABEL_11;
  }
}

void _HandleSiteDirStyle(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4)
{
  if ((*(_DWORD *)(a1 + 16) - 200) <= 0x63)
  {
    CFStringRef v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    CFStreamError v9 = CFStringCreateWithBytes(v8, a3, a4, 0x8000100u, 0);
    v11.length = CFStringGetLength(v9);
    v11.location = 0LL;
    if (CFStringFindWithOptions(v9, @"MSDOS-like directory output is on", v11, 0LL, 0LL))
    {
      *(_DWORD *)(a1 + 20) = 4;
      _WriteCommand(a1, a2, @"SITE DIRSTYLE\r\n");
      if (v9) {
        CFRelease(v9);
      }
      return;
    }

    if (v9) {
      CFRelease(v9);
    }
  }

  if ((*(_BYTE *)a1 & 4) != 0)
  {
    *(_DWORD *)(a1 + 20) = 5;
    CFStreamError v10 = @"SITE TRUTH ON\r\n";
  }

  else
  {
    *(_DWORD *)(a1 + 20) = 6;
    CFStreamError v10 = @"PWD\r\n";
  }

  _WriteCommand(a1, a2, v10);
}

void _WriteCommand(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 56));
  CFIndex v7 = CFStringGetLength(a3);
  v16.location = 0LL;
  v16.length = v7;
  CFIndex Bytes = CFStringGetBytes(a3, v16, 0, 0x5Fu, 0, 0LL, 0LL, 0LL);
  uint64_t v9 = *(void *)(a2 + 128);
  uint64_t v10 = *(void *)(v9 + 96);
  if (v10)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
    uint64_t v11 = *(void *)(v9 + 96);
    uint64_t v12 = *(void *)(v9 + 144);
    if (v11) {
      pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
    }
  }

  else
  {
    uint64_t v12 = *(void *)(v9 + 144);
  }

  if (Length - *(void *)(a1 + 40) < Bytes) {
    CFDataSetLength(*(CFMutableDataRef *)(a1 + 56), Bytes + *(void *)(a1 + 40));
  }
  MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 56));
  v17.location = 0LL;
  v17.length = v7;
  CFStringGetBytes(a3, v17, 0, 0x5Fu, 0, &MutableBytePtr[*(void *)(a1 + 40)], Bytes, 0LL);
  CFIndex v14 = *(void *)(a1 + 40) + Bytes;
  *(void *)(a1 + 40) = v14;
  if (v14)
  {
    if (v12) {
      uint64_t v15 = (CoreStreamBase *)(v12 + 16);
    }
    else {
      uint64_t v15 = 0LL;
    }
  }

uint64_t _HandlePrintWorkingDirectory(uint64_t a1, uint64_t a2, char *__s, size_t __n)
{
  if ((*(_DWORD *)(a1 + 16) - 200) <= 0x63)
  {
    CFStringRef v8 = (char *)memchr(__s, 34, __n);
    if (v8)
    {
      uint64_t v9 = (const UInt8 *)(v8 + 1);
      uint64_t v10 = (const UInt8 *)&__s[__n - 1];
      while (v10 != v9)
      {
        uint64_t v11 = v10;
        uint64_t v12 = (char *)(v10 + 1);
        int v13 = *v10--;
        if (v13 == 34)
        {
          int v15 = *(v12 - 2);
          CFIndex v14 = v12 - 2;
          if (v15 == 47) {
            CFRange v16 = (const UInt8 *)v14;
          }
          else {
            CFRange v16 = v11;
          }
          CFRange v17 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
          *(void *)(a1 + 24) = CFStringCreateWithBytes(v17, v9, v16 - v9, 0x8000100u, 0);
          break;
        }
      }
    }
  }

  *(_DWORD *)(a1 + 20) = 7;
  return _WriteCommand(a1, a2, @"TYPE I\r\n");
}

void _HandleType(uint64_t a1, uint64_t a2)
{
  SInt32 v2 = *(_DWORD *)(a1 + 16);
  if ((v2 - 300) > 0xFFFFFF9B)
  {
    *(_DWORD *)(a1 + 20) = 8;
    _StartProcess();
  }

  else
  {
    v3.domain = 6LL;
    v3.CFErrorRef error = v2;
    _ReportError(a2, &v3);
  }

void _HandlePassive(uint64_t a1, _WORD *a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 - 300) <= 0xFFFFFF9B)
  {
    *(void *)int v44 = 6LL;
    *(_DWORD *)&v44[8] = v5;
    CFTypeID v6 = (CFStreamError *)v44;
LABEL_38:
    _ReportError((uint64_t)a2, v6);
    return;
  }

  int ProtocolFamily = _GetProtocolFamily(*((void *)a2 + 16), (uint64_t)v44);
  if (ProtocolFamily == 30)
  {
    *(_OWORD *)bytes = *(_OWORD *)v44;
    *(_OWORD *)&bytes[12] = *(_OWORD *)&v44[12];
    unsigned int v22 = *(unsigned __int8 *)(a3 + 3);
    uint64_t v21 = (const char *)(a3 + 3);
    unsigned int v20 = v22;
    if (!v22) {
      goto LABEL_37;
    }
    while ((*(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v20 + 60) & 0x400) == 0)
    {
      unsigned int v23 = *(unsigned __int8 *)++v21;
      unsigned int v20 = v23;
      if (!v23) {
        goto LABEL_37;
      }
    }

    if (sscanf(v21, "%u", &v41) != 1) {
      goto LABEL_37;
    }
    int v24 = 0;
    *(_WORD *)&bytes[2] = bswap32(LOWORD(v41.version)) >> 16;
  }

  else
  {
    if (ProtocolFamily == 2)
    {
      unsigned int v12 = *(unsigned __int8 *)(a3 + 3);
      uint64_t v11 = (const char *)(a3 + 3);
      unsigned int v10 = v12;
      v43[0] = 0LL;
      v43[1] = 0LL;
      if (v12)
      {
        int v13 = 0;
        unsigned int v14 = 0;
        unsigned int v15 = 0;
        uint64_t v16 = MEMORY[0x1895F8770];
        while (1)
        {
          if ((*(_DWORD *)(v16 + 4LL * v10 + 60) & 0x400) != 0)
          {
            if (sscanf(v11, "%u", &v41) != 1) {
              goto LABEL_37;
            }
            char v17 = 8 * v13;
            if (v13 > 3)
            {
              v14 |= LODWORD(v41.version) << (40 - v17);
              if (v13 != 4)
              {
                unsigned int v3 = bswap32(v15);
                HIDWORD(v43[0]) = v3;
                LOWORD(v43[0]) = 528;
                WORD1(v43[0]) = bswap32(v14) >> 16;
                int v24 = 1;
                goto LABEL_22;
              }
            }

            else
            {
              v15 |= LODWORD(v41.version) << (24 - v17);
            }

            --v11;
            do
              unsigned int v18 = *(unsigned __int8 *)++v11;
            while ((*(_DWORD *)(v16 + 4LL * v18 + 60) & 0x400) != 0);
            ++v13;
          }

          unsigned int v19 = *(unsigned __int8 *)++v11;
          unsigned int v10 = v19;
          if (!v19) {
            goto LABEL_37;
          }
        }
      }

      goto LABEL_37;
    }

    int v24 = 0;
  }

void _HandlePort(uint64_t a1, uint64_t a2)
{
  SInt32 v2 = *(_DWORD *)(a1 + 16);
  if ((v2 - 300) > 0xFFFFFF9B)
  {
    _StartTransfer(a1, a2);
  }

  else
  {
    v3.domain = 6LL;
    v3.CFErrorRef error = v2;
    _ReportError(a2, &v3);
  }

void _HandleSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  CFStringRef v8 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  int v9 = *(_DWORD *)(a1 + 16);
  if ((v9 - 500) <= 0x63)
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a2 + 8));
    uint64_t v11 = *(const void **)(a2 + 64);
    if (v11)
    {
      CFRelease(v11);
      *(void *)(a2 + 64) = 0LL;
    }

    *(_DWORD *)(a1 + 20) = 12;
    CFStringRef v12 = CFStringCreateWithFormat(v8, 0LL, @"STAT %@\r\n", PathComponent);
    if (PathComponent) {
      CFRelease(PathComponent);
    }
    goto LABEL_27;
  }

  if (v9 == 213)
  {
    if (a4 < 1)
    {
      uint64_t v13 = 0LL;
    }

    else
    {
      uint64_t v13 = 0LL;
      while ((*(_DWORD *)(MEMORY[0x1895F8770] + 4LL * *(unsigned __int8 *)(a3 + v13) + 60) & 0x400) != 0)
      {
        if (a4 == ++v13) {
          goto LABEL_25;
        }
      }
    }

    if (v13 < a4)
    {
      while ((*(_DWORD *)(MEMORY[0x1895F8770] + 4LL * *(unsigned __int8 *)(a3 + v13) + 60) & 0x400) == 0)
      {
        if (a4 == ++v13) {
          goto LABEL_25;
        }
      }

      unsigned int v14 = (const char *)(a3 + v13);
      __endptr[0] = 0LL;
      unint64_t v15 = strtouq(v14, __endptr, 0);
      unint64_t valuePtr = v15;
      if (v15 == -1LL)
      {
        if (*__error()) {
          goto LABEL_25;
        }
      }

      else if (!v15 && __endptr[0] == v14)
      {
        goto LABEL_25;
      }

      keys[0] = @"kCFFTPResourceSize";
      values = CFNumberCreate(v8, kCFNumberLongLongType, &valuePtr);
      if (values)
      {
        *(void *)(a2 + 64) = CFDictionaryCreate( v8,  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
        if (values) {
          CFRelease(values);
        }
      }
    }
  }

CFIndex CFFTPCreateParsedResourceListing( CFAllocatorRef alloc, const UInt8 *buffer, CFIndex bufferLength, CFDictionaryRef *parsed)
{
  CFIndex v4 = 0LL;
  uint64_t v148 = *MEMORY[0x1895F89C0];
  CFDictionaryRef *parsed = 0LL;
  if (!buffer) {
    return v4;
  }
  CFIndex v5 = bufferLength;
  if (!bufferLength) {
    return v4;
  }
  CFTypeID v6 = buffer;
  CFIndex v4 = 0LL;
  uint64_t v7 = MEMORY[0x1895F8770];
  for (CFIndex i = bufferLength; ; i -= v11)
  {
    uint64_t Line = _FindLine(v6, i, (const unsigned __int8 **)&v136, (const unsigned __int8 **)&v135);
    v4 += Line;
    unsigned int v10 = v136;
    if (!v136) {
      return v4;
    }
    uint64_t v11 = Line;
    if (*(_DWORD *)v136 != 1635020660 || *((_WORD *)v136 + 2) != 8300) {
      break;
    }
LABEL_174:
    if (v4 >= v5) {
      return v4;
    }
    v6 += v11;
  }

  __s = (void *)i;
  uint64_t v147 = 0LL;
  __int128 v145 = 0u;
  __int128 v146 = 0u;
  __int128 v143 = 0u;
  __int128 v144 = 0u;
  __int128 v141 = 0u;
  __int128 v142 = 0u;
  __int128 v139 = 0u;
  __int128 v140 = 0u;
  uint64_t v13 = v135;
  if (v136 >= v135) {
    goto LABEL_173;
  }
  unint64_t v14 = 0LL;
  do
  {
    if (v10 >= v13)
    {
      int v18 = v14;
      break;
    }

    int64_t v15 = v13 - v10;
    while (1)
    {
      uint64_t v16 = *v10;
      if ((*(_DWORD *)(v7 + 4 * v16 + 60) & 0x4000) == 0) {
        goto LABEL_19;
      }
LABEL_17:
      ++v10;
      if (!--v15)
      {
        int v18 = v14;
        unsigned int v10 = v13;
        goto LABEL_28;
      }
    }

    if (__maskrune(v16, 0x4000uLL)) {
      goto LABEL_17;
    }
LABEL_19:
    *((void *)&v139 + v14) = v10;
    while (v10 < v13)
    {
      uint64_t v17 = *v10;
      if ((char)*v10 < 0)
      {
        if (__maskrune(v17, 0x4000uLL)) {
          break;
        }
      }

      else if ((*(_DWORD *)(v7 + 4 * v17 + 60) & 0x4000) != 0)
      {
        break;
      }

      ++v10;
    }

    int v18 = v14 + 1;
    if (v14 > 0xE) {
      break;
    }
    ++v14;
  }

  while (v10 < v13);
LABEL_28:
  v136 = v10;
  if (!v18)
  {
LABEL_173:
    CFIndex i = (CFIndex)__s;
    goto LABEL_174;
  }

  unsigned int v19 = (const UInt8 *)v139;
  unsigned int v20 = *(unsigned __int8 *)v139;
  v129 = v6;
  if (v20 <= 0x63)
  {
    switch(v20)
    {
      case '-':
        int v21 = 0;
        int v22 = 8;
        break;
      case 'b':
        int v21 = 0;
        int v22 = 6;
        break;
      case 'c':
        int v21 = 0;
        int v22 = 2;
        break;
      default:
        goto LABEL_147;
    }

    goto LABEL_44;
  }

  if (*(unsigned __int8 *)v139 > 0x6Fu)
  {
    if (v20 == 112)
    {
      int v21 = 0;
      int v134 = 1;
      goto LABEL_45;
    }

    if (v20 != 115) {
      goto LABEL_147;
    }
    int v21 = 0;
    int v22 = 12;
LABEL_44:
    int v134 = v22;
    goto LABEL_45;
  }

  if (v20 == 100)
  {
    int v21 = 0;
    int v134 = 4;
  }

  else
  {
    if (v20 == 108)
    {
      int v134 = 10;
      int v21 = 1;
      goto LABEL_45;
    }

LABEL_147:
    int v21 = 0;
    int v134 = 0;
  }

LABEL_125:
    char cf = v51;
    int v115 = v52;
    if (v49 != v35)
    {
      uint64_t v56 = v32[v49];
      else {
        int v57 = *(_DWORD *)(v7 + 4 * v56 + 60) & 0x4000;
      }
      char v51 = cf;
      if (v57) {
        goto LABEL_131;
      }
      goto LABEL_142;
    }

    int64_t v49 = v13 - v32;
LABEL_131:
    char cfc = v51;
    v58 = CFTimeZoneCopyDefault();
    double Current = CFAbsoluteTimeGetCurrent();
    CFAbsoluteTimeGetGregorianDate(Current, v58);
    if ((cfc & 1) != 0)
    {
      CFAbsoluteTime v60 = Current + 86400.0;
      unsigned int year = CFAbsoluteTimeGetGregorianDate(v60, v58).year;
      unint64_t cfa = (v114 << 56) | ((unint64_t)v115 << 48) | ((unint64_t)v117 << 32) | ((unint64_t)v116 << 40);
      *(void *)&v149.unsigned int year = cfa | year;
      v149.second = 0.0;
      if (CFGregorianDateGetAbsoluteTime(v149, v58) <= v60) {
        *(void *)&v61.unsigned int year = cfa | year;
      }
      else {
        *(void *)&v61.unsigned int year = (year - 1) | cfa;
      }
    }

    else
    {
      LODWORD(v62) = v115 + 1900;
      if (v115 >= 100) {
        uint64_t v62 = v115;
      }
      else {
        uint64_t v62 = v62;
      }
      *(void *)&v61.unsigned int year = v62 | ((unint64_t)v117 << 32) | ((unint64_t)v116 << 40);
    }

    v61.second = 0.0;
    CFAbsoluteTime AbsoluteTime = CFGregorianDateGetAbsoluteTime(v61, v58);
    if (v58) {
      CFRelease(v58);
    }
    CFDateRef v64 = CFDateCreate(alloc, AbsoluteTime);
    if (!v64)
    {
LABEL_142:
      int v32 = (unsigned __int8 *)*((void *)&v139 + ++v33);
      ++v34;
      if (!v32) {
        goto LABEL_166;
      }
      continue;
    }

    break;
  }

  CFDateRef cfb = v64;
  v65 = &v32[v49];
  signed int v66 = v34;
  do
  {
    int v67 = v66;
    BOOL v68 = v23 != 0;
    if (v67) {
      BOOL v68 = 0;
    }
    char v69 = v67 < 0 || v68;
    if ((v69 & 1) != 0) {
      goto LABEL_159;
    }
    int v70 = _ReadSize(*((char **)&v139 + v67), &v132);
    signed int v66 = v67 - 1;
  }

  while (!v70);
  if (v23 && v67 == 1)
  {
LABEL_159:
    uint64_t v71 = 0LL;
    v72 = 0LL;
    goto LABEL_160;
  }

  v72 = (const UInt8 *)*((void *)&v139 + v66);
  int v77 = v67 - 2;
  if (!v23 || v77)
  {
    if (!v23
      || v77 != 1
      || (v118 = (const UInt8 *)*((void *)&v139 + v66),
          int Size = _ReadSize(*((char **)&v139 + 1), (unint64_t *)keys),
          v72 = v118,
          uint64_t v71 = v118,
          !Size))
    {
      uint64_t v71 = (const UInt8 *)*((void *)&v139 + v77);
    }
  }

  else
  {
    uint64_t v71 = (const UInt8 *)*((void *)&v139 + v66);
  }

  do
  {
LABEL_160:
    unint64_t v73 = *((void *)&v139 + ++v34);
    if (v73) {
      BOOL v74 = (unint64_t)v65 > v73;
    }
    else {
      BOOL v74 = 0;
    }
  }

  while (v74);
  if (!v73)
  {
    CFRelease(cfb);
LABEL_166:
    CFIndex v24 = (CFIndex)v126;
    CFIndex v4 = v127;
    CFIndex v5 = bufferLength;
    goto LABEL_167;
  }

  __sa = v71;
  __int128 v81 = (const UInt8 *)*((void *)&v139 + v34);
  __int128 v82 = v72;
  if (v124)
  {
    while (1)
    {
      v83 = (_WORD *)*((void *)&v139 + v34);
      if (!v83) {
        break;
      }
      ++v34;
      if (*v83 == 15917)
      {
        v84 = (const UInt8 *)*((void *)&v139 + v34);
        goto LABEL_191;
      }
    }
  }

  v84 = 0LL;
LABEL_191:
  if (v23)
  {
    keys[0] = @"kCFFTPResourceMode";
    values[0] = CFNumberCreate(alloc, kCFNumberSInt32Type, &valuePtr);
    LODWORD(v85) = values[0] != 0LL;
  }

  else
  {
    LODWORD(v85) = 0;
  }

  keys[v85] = @"kCFFTPResourceName";
  uint64_t v86 = v85;
  if (v84) {
    uint64_t v87 = *((void *)&v139 + v34 - 1) - 1LL;
  }
  else {
    uint64_t v87 = (uint64_t)v13;
  }
  CFStringRef v88 = CFStringCreateWithBytes(alloc, v81, v87 - (void)v81, 0, 0);
  values[v85] = (void *)v88;
  if (v88)
  {
    v89 = v88;
    if (CFStringHasPrefix(v88, @"<")
      && CFStringHasSuffix(v89, @">")
      && (CFIndex location = CFStringFind(v89, @">", 0LL).location,
          CFIndex v91 = CFStringFind(v89, @"<", 4uLL).location,
          location < v91))
    {
      v150.length = v91 + ~location;
      v150.CFIndex location = location + 1;
      CFStringRef Copy = CFStringCreateWithSubstring(alloc, v89, v150);
    }

    else
    {
      CFStringRef Copy = CFStringCreateCopy(alloc, v89);
    }

    CFStringRef v93 = Copy;
    if (Copy)
    {
      CFRelease(v89);
      values[v85] = (void *)v93;
    }

    uint64_t v86 = (v85 + 1);
    LODWORD(v85) = v85 + 1;
  }

  keys[v86] = @"kCFFTPResourceLink";
  if (v84) {
    CFStringRef v94 = CFStringCreateWithBytes(alloc, v84, v13 - v84, 0, 0);
  }
  else {
    CFStringRef v94 = CFStringCreateWithCString(alloc, "", 0x8000100u);
  }
  values[v86] = (void *)v94;
  if (v94) {
    LODWORD(v85) = v85 + 1;
  }
  if ((v69 & 1) == 0)
  {
    if (v82 && v82 == __sa)
    {
      int64_t v96 = __sa - 1;
      do
      {
        uint64_t v97 = v96[1];
        else {
          int v98 = *(_DWORD *)(v7 + 4 * v97 + 60) & 0x4000;
        }
        ++v96;
      }

      while (!v98);
      unint64_t v99 = 0LL;
      do
      {
        CFRange v100 = (const UInt8 *)memchr(__sa, byte_182C9D988[v99], v96 - __sa);
        if (v100) {
          BOOL v101 = 1;
        }
        else {
          BOOL v101 = v99 >= 3;
        }
        ++v99;
      }

      while (!v101);
      CFIndex v95 = v100;
      if (v100) {
        __int128 v82 = v100 + 1;
      }
      else {
        __int128 v82 = __sa;
      }
    }

    else
    {
      CFIndex v95 = 0LL;
    }

    if (__sa)
    {
      if (!v95)
      {
        CFIndex v95 = __sa - 1;
        do
        {
          uint64_t v102 = v95[1];
          else {
            int v103 = *(_DWORD *)(v7 + 4 * v102 + 60) & 0x4000;
          }
          ++v95;
        }

        while (!v103);
      }

      keys[v85] = @"kCFFTPResourceOwner";
      CFStringRef v104 = CFStringCreateWithBytes(alloc, __sa, v95 - __sa, 0, 0);
      values[v85] = (void *)v104;
      if (v104) {
        LODWORD(v85) = v85 + 1;
      }
    }

    if (v82)
    {
      CFRange v105 = v82 - 1;
      do
      {
        uint64_t v106 = v105[1];
        else {
          int v107 = *(_DWORD *)(v7 + 4 * v106 + 60) & 0x4000;
        }
        ++v105;
      }

      while (!v107);
      keys[v85] = @"kCFFTPResourceGroup";
      CFStringRef v108 = CFStringCreateWithBytes(alloc, v82, v105 - v82, 0, 0);
      values[v85] = (void *)v108;
      if (v108) {
        LODWORD(v85) = v85 + 1;
      }
    }

    keys[v85] = @"kCFFTPResourceSize";
    CFNumberRef v109 = CFNumberCreate(alloc, kCFNumberLongLongType, &v132);
    values[v85] = v109;
    if (v109) {
      LODWORD(v85) = v85 + 1;
    }
  }

  keys[v85] = @"kCFFTPResourceType";
  CFNumberRef v110 = CFNumberCreate(alloc, kCFNumberIntType, &v134);
  values[v85] = v110;
  if (v110) {
    int v111 = v85 + 1;
  }
  else {
    int v111 = v85;
  }
  keys[v111] = @"kCFFTPResourceModDate";
  if (v110) {
    uint64_t v85 = v85 + 1LL;
  }
  else {
    uint64_t v85 = v85;
  }
  values[v111] = (void *)CFRetain(cfb);
  CFDictionaryRef *parsed = CFDictionaryCreate( alloc,  (const void **)keys,  (const void **)values,  (v111 + 1),  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFIndex v4 = v127;
  do
  {
    v112 = values[v85];
    if (v112) {
      CFRelease(v112);
    }
    BOOL v74 = v85-- <= 0;
  }

  while (!v74);
  CFDateRef v79 = cfb;
LABEL_184:
  CFRelease(v79);
  return v4;
}

CFStringRef _CreatePathForContext(const __CFAllocator *a1, uint64_t a2, __CFURL *a3)
{
  CFIndex v5 = _CFURLCopyPathReplacingPercentEscapes(a3);
  if (!v5) {
    return 0LL;
  }
  CFTypeID v6 = v5;
  if (!CFStringGetLength(v5))
  {
    CFRelease(v6);
    CFTypeID v6 = (const __CFString *)CFRetain(@"/");
  }

  if (CFStringHasPrefix(v6, @"//"))
  {
    v10.length = CFStringGetLength(v6) - 1;
    v10.CFIndex location = 1LL;
    CFStringRef v7 = CFStringCreateWithSubstring(a1, v6, v10);
    if (!v7) {
      return v6;
    }
  }

  else
  {
    if (!*(void *)(a2 + 24)) {
      return v6;
    }
    CFStringRef v7 = CFStringCreateWithFormat(a1, 0LL, @"%@%@", *(void *)(a2 + 24), v6);
    if (!v7) {
      return v6;
    }
  }

  CFStringRef v8 = v7;
  if (v6) {
    CFRelease(v6);
  }
  return v8;
}

void _HandleRestart(uint64_t a1, uint64_t a2)
{
  SInt32 v3 = *(_DWORD *)(a1 + 16);
  if ((v3 - 400) <= 0xFFFFFF9B)
  {
    *(void *)&__int128 v10 = 6LL;
    DWORD2(v10) = v3;
LABEL_11:
    _ReportError(a2, (CFStreamError *)&v10);
    return;
  }

  CFIndex v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  PathForContext = _CreatePathForContext(v5, a1, *(__CFURL **)(a2 + 8));
  if (!PathForContext)
  {
    __int128 v10 = xmmword_182C9D8F0;
    goto LABEL_11;
  }

  CFStringRef v7 = PathForContext;
  CFStringRef v8 = CFStringCreateWithFormat(v5, 0LL, @"RETR %@\r\n", PathForContext);
  CFRelease(v7);
  *(_DWORD *)(a1 + 20) = 15;
  *(_WORD *)a2 &= ~0x800u;
  uint64_t v9 = *(void *)(a2 + 24);
  if (v9)
  {
    CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v9 + 16));
  }

  _WriteCommand(a1, a2, v8);
  if (v8) {
    CFRelease(v8);
  }
}

void _HandleRetrieve(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  if (v2 >= 0xC8)
  {
    if ((*(_BYTE *)a1 & 2) != 0)
    {
      *(_DWORD *)(a1 + 20) = 8;
      _StartProcess();
    }

    else if (v2 < 0x12C)
    {
      _ConnectionComplete(a1, a2);
    }

    else
    {
      v3.domain = 6LL;
      v3.CFErrorRef error = v2;
      _ReportError(a2, &v3);
    }
  }

void _HandleChangeDirectory(char *a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  char v4 = *a1;
  int v5 = *((_DWORD *)a1 + 4);
  if ((*a1 & 8) == 0 || v5 != 421)
  {
    if ((v5 - 300) <= 0xFFFFFF9B)
    {
      *(void *)&v43.sa_len = 6LL;
      *(_DWORD *)&v43.sa_data[6] = v5;
      *a1 = v4 & 0xF7;
LABEL_10:
      p_CFSocketContext context = (CFStreamError *)&v43;
LABEL_11:
      _ReportError(a2, p_context);
      return;
    }

    uint64_t v9 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
    *a1 &= ~8u;
    if ((*(_BYTE *)a2 & 0x80) == 0)
    {
LABEL_37:
      if (*((_DWORD *)a1 + 5) != 9) {
        return;
      }
      if ((*(_WORD *)a2 & 1) != 0)
      {
        int ProtocolFamily = _GetProtocolFamily(*(void *)(a2 + 128), (uint64_t)&v43);
        *((_DWORD *)a1 + 5) = 10;
        if (ProtocolFamily == 30)
        {
          CFIndex v24 = @"EPSV\r\n";
        }

        else
        {
          if (ProtocolFamily != 2)
          {
            context.version = 6LL;
            LODWORD(context.info) = 522;
            p_CFSocketContext context = (CFStreamError *)&context;
            goto LABEL_11;
          }

          CFIndex v24 = @"PASV\r\n";
        }

        _WriteCommand(a1, a2, v24);
        return;
      }

      socklen_t v41 = 255;
      int v42 = 1;
      context.version = 0LL;
      context.info = (void *)a2;
      memset(&context.retain, 0, 24);
      uint64_t v19 = *(void *)(a2 + 128);
      uint64_t v20 = *(void *)(v19 + 96);
      if (v20)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v20 + 8));
        uint64_t v21 = *(void *)(v19 + 96);
        uint64_t v22 = *(void *)(v19 + 144);
        if (v21) {
          pthread_mutex_unlock((pthread_mutex_t *)(v21 + 8));
        }
      }

      else
      {
        uint64_t v22 = *(void *)(v19 + 144);
      }

      if (v22) {
        uint64_t v25 = v22 + 16;
      }
      else {
        uint64_t v25 = 0LL;
      }
      ++*(void *)(v25 + 80);
      unint64_t v26 = (const __CFData *)(*(uint64_t (**)(void, void *))(**(void **)(v25 + 24) + 40LL))( *(void *)(v25 + 24),  &unk_18C5ADD70);
      --*(void *)(v25 + 80);
      if (!v26) {
        goto LABEL_54;
      }
      char v27 = v26;
      __int128 v56 = 0u;
      memset(v57, 0, sizeof(v57));
      __int128 v54 = 0u;
      __int128 v55 = 0u;
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      sockaddr v43 = (sockaddr)0;
      BytePtr = (int *)CFDataGetBytePtr(v26);
      if (getsockname(*BytePtr, &v43, &v41)) {
        goto LABEL_53;
      }
      CFRelease(v27);
      int v29 = CFSocketCreate(v9, v43.sa_family, 1, 6, 2uLL, (CFSocketCallBack)_SocketCallBack, &context);
      *(void *)(a2 + 56) = v29;
      if (v29)
      {
        CFSocketNativeHandle Native = CFSocketGetNative(v29);
        setsockopt(Native, 0xFFFF, 4, &v42, 4u);
        CFIndex v31 = v43.sa_family == 2 ? 16LL : 28LL;
        *(_WORD *)v43.sa_data = 0;
        int v32 = CFDataCreateWithBytesNoCopy(v9, &v43.sa_len, v31, (CFAllocatorRef)*MEMORY[0x189604DC8]);
        if (v32)
        {
          char v27 = v32;
          if (CFSocketSetAddress(*(CFSocketRef *)(a2 + 56), v32))
          {
LABEL_53:
            CFRelease(v27);
            goto LABEL_54;
          }

          CFRelease(v27);
          if (!*(void *)(a2 + 80))
          {
LABEL_69:
            int64_t v35 = CFSocketCopyAddress(*(CFSocketRef *)(a2 + 56));
            uint64_t v36 = CFDataGetBytePtr(v35);
            int v37 = v36[1];
            if (v37 == 30)
            {
              CFStringRef v38 = CFStringCreateWithFormat( v9,  0LL,  @"EPRT |2|%x:%x:%x:%x:%x:%x:%x:%x|%u|\r\n",  bswap32(*((unsigned __int16 *)v36 + 4)) >> 16,  bswap32(*((unsigned __int16 *)v36 + 5)) >> 16,  bswap32(*((unsigned __int16 *)v36 + 6)) >> 16,  bswap32(*((unsigned __int16 *)v36 + 7)) >> 16,  bswap32(*((unsigned __int16 *)v36 + 8)) >> 16,  bswap32(*((unsigned __int16 *)v36 + 9)) >> 16,  bswap32(*((unsigned __int16 *)v36 + 10)) >> 16,  bswap32(*((unsigned __int16 *)v36 + 11)) >> 16,  bswap32(*((unsigned __int16 *)v36 + 1)) >> 16);
            }

            else
            {
              if (v37 != 2)
              {
                *(void *)&v43.sa_len = 6LL;
                *(_DWORD *)&v43.sa_data[6] = 522;
                _ReportError(a2, (CFStreamError *)&v43);
LABEL_76:
                CFRelease(v35);
                return;
              }

              CFStringRef v38 = CFStringCreateWithFormat( v9,  0LL,  @"PORT %u,%u,%u,%u,%u,%u\r\n",  v36[4],  v36[5],  v36[6],  v36[7],  v36[2],  v36[3]);
            }

            CFStringRef v39 = v38;
            if (v38)
            {
              *((_DWORD *)a1 + 5) = 11;
              _WriteCommand(a1, a2, v38);
              CFRelease(v39);
            }

            goto LABEL_76;
          }

          CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v9, *(CFSocketRef *)(a2 + 56), 0LL);
          if (RunLoopSource)
          {
            CFRunLoopSourceRef v34 = RunLoopSource;
            _CFTypeScheduleOnMultipleRunLoops(RunLoopSource, *(const __CFArray **)(a2 + 80));
            CFRelease(v34);
            goto LABEL_69;
          }
        }
      }

void _HandleMakeDirectory(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)a1 & 2) != 0)
  {
    *(_DWORD *)(a1 + 20) = 8;
    _StartProcess();
  }

  else
  {
    SInt32 v2 = *(_DWORD *)(a1 + 16);
    if ((v2 - 300) > 0xFFFFFF9B)
    {
      _ConnectionComplete(a1, a2);
    }

    else
    {
      v3.domain = 6LL;
      v3.CFErrorRef error = v2;
      _ReportError(a2, &v3);
    }
  }

void _HandleRenameFrom(uint64_t a1, uint64_t a2)
{
  SInt32 v3 = *(_DWORD *)(a1 + 16);
  if ((v3 - 400) <= 0xFFFFFF9B)
  {
    *(void *)&__int128 v11 = 6LL;
    DWORD2(v1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v3;
LABEL_7:
    _ReportError(a2, (CFStreamError *)&v11);
    return;
  }

  int v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v6 = *(__CFURL **)(a2 + 16);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v6;
  PathForContext = _CreatePathForContext(v5, a1, v6);
  if (!PathForContext)
  {
    __int128 v11 = xmmword_182C9D8F0;
    goto LABEL_7;
  }

  uint64_t v9 = PathForContext;
  *(void *)(a2 + _Block_object_dispose(va, 8) = v7;
  *(_DWORD *)(a1 + 20) = 23;
  CFStringRef v10 = CFStringCreateWithFormat(v5, 0LL, @"RNTO %@\r\n", PathForContext);
  CFRelease(v9);
  _WriteCommand(a1, a2, v10);
  if (v10) {
    CFRelease(v10);
  }
}

void _ConnectionComplete(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 20);
  int v5 = *(const __CFArray **)(a2 + 80);
  CFIndex Count = CFArrayGetCount(v5);
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    for (CFIndex i = 0LL; i < v7; i += 2LL)
    {
      uint64_t v9 = *(NetConnection **)(a2 + 128);
      CFArrayGetValueAtIndex(v5, i);
      CFArrayGetValueAtIndex(v5, i + 1);
      NetConnection::unschedule(v9, (uint64_t *)a2, v10, v11);
    }
  }

  *(_DWORD *)(a1 + 20) = 8;
  NetConnection::requestIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
  if (v4 != 15 || (*(_WORD *)a2 & 0x800) != 0)
  {
    NetConnection::responseIsComplete(*(NetConnection **)(a2 + 128), (void *)a2);
    __int16 v12 = *(_WORD *)a2 & 0xF7FF;
  }

  else
  {
    __int16 v12 = *(_WORD *)a2 | 0x800;
  }

  *(_WORD *)a2 = v12;
  if (!*(void *)(a2 + 56) && !*(void *)(a2 + 24))
  {
    CFTypeID v13 = CFGetTypeID(*(CFTypeRef *)(a2 + 32));
    uint64_t v14 = *(void *)(a2 + 32);
    if (v14) {
      int v15 = (CoreStreamBase *)(v14 + 16);
    }
    else {
      int v15 = 0LL;
    }
    if (v13 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
      && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
    }

    v16.domain = 0LL;
    *(void *)&v16.CFErrorRef error = 0LL;
    CoreStreamBase::_signalEvent(v15, 16LL, v16, 1);
  }

uint64_t _IsRoot(const __CFURL *a1)
{
  CFStringRef v2 = CFURLCopyStrictPath(a1, &isAbsolute);
  CFStringRef v3 = CFURLCopyResourceSpecifier(a1);
  int v4 = v3;
  if (v2) {
    CFRelease(v2);
  }
  if (v4) {
    CFRelease(v4);
  }
  return 0LL;
}

uint64_t _GetProtocolFamily(uint64_t a1, uint64_t a2)
{
  socklen_t v13 = 255;
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    uint64_t v5 = *(void *)(a1 + 96);
    uint64_t v6 = *(void *)(a1 + 144);
    if (v5) {
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
    }
  }

  else
  {
    uint64_t v6 = *(void *)(a1 + 144);
  }

  if (v6) {
    uint64_t v7 = v6 + 16;
  }
  else {
    uint64_t v7 = 0LL;
  }
  ++*(void *)(v7 + 80);
  CFStringRef v8 = (const __CFData *)(*(uint64_t (**)(void, void *))(**(void **)(v7 + 24) + 40LL))( *(void *)(v7 + 24),  &unk_18C5ADD70);
  --*(void *)(v7 + 80);
  if (!v8) {
    return 255LL;
  }
  uint64_t v9 = v8;
  *(_OWORD *)(a2 + 239) = 0u;
  *(_OWORD *)(a2 + 20_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)a2 = 0u;
  BytePtr = (int *)CFDataGetBytePtr(v8);
  if (getpeername(*BytePtr, (sockaddr *)a2, &v13)) {
    uint64_t v11 = 255LL;
  }
  else {
    uint64_t v11 = *(unsigned __int8 *)(a2 + 1);
  }
  CFRelease(v9);
  return v11;
}

void _SocketCallBack(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, _WORD *a5)
{
  v21.version = 0LL;
  v21.info = a5;
  memset(&v21.retain, 0, 24);
  CFStringRef v8 = CFGetAllocator(*((CFTypeRef *)a5 + 11));
  if (!a4 || *a4 == -1)
  {
    CFStreamError v20 = (CFStreamError)xmmword_182C9D8E0;
    _ReportError((uint64_t)a5, &v20);
    return;
  }

  if (a2 != 2) {
    return;
  }
  uint64_t v9 = a5 + 12;
  if ((*a5 & 0x80) != 0)
  {
    CFStringRef v10 = 0LL;
  }

  else
  {
    CFStringRef v10 = a5 + 12;
    uint64_t v9 = 0LL;
  }

  _CoreStreamCreatePairWithNativeSocket(v8, *a4, v10, v9);
  CFDictionaryApplyFunction( *((CFDictionaryRef *)a5 + 11),  (CFDictionaryApplierFunction)_StreamPropertyApplier,  *((void **)a5 + 3));
  CFTypeID v11 = CFGetTypeID(*((CFTypeRef *)a5 + 3));
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    CFTypeID v16 = v11;
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16679);
    CFTypeID v11 = v16;
  }

  uint64_t v12 = *((void *)a5 + 3);
  if (v12) {
    uint64_t v13 = v12 + 16;
  }
  else {
    uint64_t v13 = 0LL;
  }
  if (v11 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    CoreReadStream::setClient(v13, -1LL, (uint64_t)_DataStreamCallBack, &v21);
    _CFTypeScheduleOnMultipleRunLoops(*((void **)a5 + 3), *((const __CFArray **)a5 + 10));
    uint64_t v14 = *((void *)a5 + 3);
    uint64_t v17 = &CoreReadStream::Class(void)::sOnce_CoreReadStream;
    int v18 = &__block_literal_global_16679;
  }

  else
  {
    if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
    {
      uint64_t v19 = v13;
      dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
      uint64_t v13 = v19;
    }

    CoreWriteStream::setClient(v13, -1LL, (uint64_t)_DataStreamCallBack, &v21);
    _CFTypeScheduleOnMultipleRunLoops(*((void **)a5 + 3), *((const __CFArray **)a5 + 10));
    uint64_t v14 = *((void *)a5 + 3);
    uint64_t v17 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    int v18 = &__block_literal_global_3111;
  }

  dispatch_once(v17, v18);
LABEL_20:
  if (v14) {
    int v15 = (CoreStreamBase *)(v14 + 16);
  }
  else {
    int v15 = 0LL;
  }
  CoreStreamBase::_streamInterface_Open(v15);
  _InvalidateServer((uint64_t)a5);
}

void _CoreStreamCreatePairWithNativeSocket(const __CFAllocator *a1, int a2, void *a3, void *a4)
{
  CFTypeRef v9 = 0LL;
  CFTypeRef cf = 0LL;
  if (a3) {
    p_CFTypeRef cf = (__CFReadStream **)&cf;
  }
  else {
    p_CFTypeRef cf = 0LL;
  }
  if (a4) {
    CFStringRef v8 = (__CFWriteStream **)&v9;
  }
  else {
    CFStringRef v8 = 0LL;
  }
  _CFStreamCreatePairWithNativeSocket(a1, a2, p_cf, v8);
  if (a3) {
    *a3 = CoreReadStreamCreateWithCFReadStream(a1, (__CFReadStream *)cf);
  }
  if (a4) {
    *a4 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v9);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v9) {
    CFRelease(v9);
  }
}

uint64_t _StreamPropertyApplier(const void *a1, const void *a2, char *cf)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96)
    && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
  }

  if (cf) {
    uint64_t v7 = cf + 16;
  }
  else {
    uint64_t v7 = 0LL;
  }
  ++*((void *)v7 + 10);
  uint64_t result = (*(uint64_t (**)(void, const void *, const void *))(**((void **)v7 + 3) + 32LL))( *((void *)v7 + 3),  a1,  a2);
  --*((void *)v7 + 10);
  return result;
}

void _DataStreamCallBack(char *cf, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  if (a2 != 16 || (*(_WORD *)a3 & 0x10) != 0)
  {
    uint64_t v6 = *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96);
    CFTypeID v7 = CFGetTypeID(cf);
    if (cf) {
      CFStringRef v8 = cf + 16;
    }
    else {
      CFStringRef v8 = 0LL;
    }
    if (v7 == v6)
    {
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream == -1)
      {
LABEL_12:
        CFStreamError v18 = *(CFStreamError *)(v8 + 56);
        if ((*(_WORD *)a3 & 0x30) != 0x10) {
          goto LABEL_24;
        }
        if (v4 == 8)
        {
          CFIndex v9 = *(void *)(a3 + 120);
          if (v9 >= CFArrayGetCount(*(CFArrayRef *)(a3 + 112))) {
            goto LABEL_23;
          }
        }

        else
        {
          if (v4 != 2) {
            goto LABEL_24;
          }
          if (_ProcessHTTPResponse(a3, &v18))
          {
            if (!v18.error)
            {
              if ((*(_WORD *)a3 & 0x40) != 0) {
                return;
              }
              goto LABEL_33;
            }

uint64_t _ProcessHTTPResponse(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4) {
    uint64_t v5 = v4 + 16;
  }
  else {
    uint64_t v5 = 0LL;
  }
  ++*(void *)(v5 + 80);
  uint64_t result = (*(uint64_t (**)(void, void *))(**(void **)(v5 + 24) + 40LL))( *(void *)(v5 + 24),  &unk_18C5B0D20);
  --*(void *)(v5 + 80);
  *a2 = 0LL;
  a2[1] = 0LL;
  if (result)
  {
    CFTypeID v7 = (const void *)result;
    CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)result);
    if (ResponseStatusCode > 299)
    {
      int v9 = ResponseStatusCode;
      if (ResponseStatusCode == 407
        && (*(_WORD *)a1 & 0x40) == 0
        && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kCFStreamPropertyFTPProxyUser")
        && CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 88), @"kCFStreamPropertyFTPProxyPassword"))
      {
        *(_WORD *)a1 |= 0x40u;
        _ReleaseDataReadStream(a1);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 88), @"_kCFStreamPropertyFTPLastHTTPResponse", v7);
        _FTPStreamOpen(*(void *)(a1 + 32), a2, &v10, a1);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 88), @"_kCFStreamPropertyFTPLastHTTPResponse");
      }

      else
      {
        *a2 = 6LL;
        *((_DWORD *)a2 + 2) = v9;
      }
    }

    else
    {
      *(_WORD *)a1 |= 0x20u;
    }

    CFRelease(v7);
    return 1LL;
  }

  return result;
}

uint64_t _RollOverHTTPRequest(uint64_t a1, _OWORD *a2)
{
  *(_OWORD *)(a1 + 40) = *a2;
  *(_WORD *)a1 &= ~0x40u;
  return _FTPStreamOpen(*(void *)(a1 + 32), a2, &v5, a1);
}

CFStringRef _CFURLCopyPathReplacingPercentEscapes(const __CFURL *a1)
{
  CFStringRef v2 = CFGetAllocator(a1);
  uint64_t result = CFURLCopyPath(a1);
  if (result)
  {
    uint64_t v4 = result;
    CFStringRef v5 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v2, result, &stru_189C1D1D8, 0);
    CFRelease(v4);
    return v5;
  }

  return result;
}

uint64_t _ReadSize(char *__str, unint64_t *a2)
{
  *a2 = 0LL;
  CFStringRef v5 = __str;
  do
  {
    unsigned int v7 = *v5++;
    __darwin_ct_rune_t v6 = v7;
    int v8 = *(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v7 + 60);
  }

  while ((v8 & 0x400) != 0);
  if ((v6 & 0x80) != 0)
  {
    uint64_t result = __maskrune(v6, 0x4000uLL);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else
  {
    uint64_t result = v8 & 0x4000;
    if ((v8 & 0x4000) == 0) {
      return result;
    }
  }

  *a2 = strtouq(__str, 0LL, 10);
  return 1LL;
}

void _StartTransfer(uint64_t a1, uint64_t a2)
{
  CFStringRef PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)(a2 + 8));
  CFStringRef v5 = CFGetAllocator(*(CFTypeRef *)(a2 + 88));
  __darwin_ct_rune_t v6 = v5;
  if ((*(_WORD *)a2 & 0x80) != 0)
  {
    *(_DWORD *)(a1 + 20) = 18;
    unsigned int v7 = CFStringCreateWithFormat(v5, 0LL, @"STOR %@\r\n", PathComponent);
    uint64_t v8 = *(void *)(a2 + 24);
    if (!v8) {
      goto LABEL_14;
    }
    int v9 = &CoreWriteStream::Class(void)::sOnce_CoreWriteStream;
    char v10 = &__block_literal_global_3111;
    goto LABEL_28;
  }

  if (CFURLHasDirectoryPath(*(CFURLRef *)(a2 + 8)) || _IsRoot(*(const __CFURL **)(a2 + 8)))
  {
    if ((*(_WORD *)a2 & 8) != 0)
    {
      unsigned int v7 = CFStringCreateWithFormat(v6, 0LL, @"NLST %@\r\n", PathComponent);
      *(_DWORD *)(a1 + 20) = 16;
      uint64_t v8 = *(void *)(a2 + 24);
      if (!v8) {
        goto LABEL_14;
      }
    }

    else
    {
      unsigned int v7 = CFRetain(@"LIST\r\n");
      *(_DWORD *)(a1 + 20) = 17;
      uint64_t v8 = *(void *)(a2 + 24);
      if (!v8) {
        goto LABEL_14;
      }
    }

void _CoreSocketStreamCreateWithSignature( const __CFAllocator *a1, const __CFData *a2, void *a3, void *a4, const __CFData *a5, __CFReadStream **a6, __CFWriteStream **a7)
{
  CFTypeRef v12 = 0LL;
  CFTypeRef cf = 0LL;
  if (a3) {
    p_CFTypeRef cf = &cf;
  }
  else {
    p_CFTypeRef cf = 0LL;
  }
  if (a4) {
    CFTypeID v11 = &v12;
  }
  else {
    CFTypeID v11 = 0LL;
  }
  _CFStreamCreatePairWithCFSocketSignaturePieces(a1, a2, (uint64_t)p_cf, (uint64_t)v11, a5, a6, a7);
  if (a3) {
    *a3 = CoreReadStreamCreateWithCFReadStream(a1, (__CFReadStream *)cf);
  }
  if (a4) {
    *a4 = CoreWriteStreamCreateWithCFWriteStream(a1, (__CFWriteStream *)v12);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v12) {
    CFRelease(v12);
  }
}

void ___ZL14_FTPStreamOpenPKvP13CFStreamErrorPhP19_CFFTPStreamContext_block_invoke()
{
}

CFReadStreamRef CFReadStreamCreateWithFTPURL(CFAllocatorRef alloc, CFURLRef ftpURL)
{
  if (!ftpURL) {
    return 0LL;
  }
  CFFTPHappyURL = _CreateCFFTPHappyURL(ftpURL);
  if (!CFFTPHappyURL) {
    return 0LL;
  }
  uint64_t v4 = CFFTPHappyURL;
  CFStringRef v5 = CFURLCopyScheme(v4);
  if (!v5) {
    goto LABEL_31;
  }
  __darwin_ct_rune_t v6 = v5;
  if (CFStringCompare(v5, @"ftp", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v6, @"ftps", 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v6);
    CFStringRef v8 = CFURLCopyHostName(v4);
    if (v8)
    {
      CFRelease(v8);
      int v9 = CFURLCopyUserName(v4);
      char v10 = v9;
      if (v9 && !_ValidFTPString(v9))
      {
        uint64_t v19 = v10;
      }

      else
      {
        CFTypeID v11 = CFURLCopyPassword(v4);
        CFTypeRef v12 = v11;
        if (!v11 || _ValidFTPString(v11))
        {
          uint64_t v13 = MEMORY[0x186E12804](alloc, 144LL, 0LL);
          if (v13)
          {
            uint64_t v14 = (void *)v13;
            *(_OWORD *)(v13 + 112) = 0u;
            *(_OWORD *)(v13 + 12_Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)(v13 + 80) = 0u;
            *(_OWORD *)(v13 + 96) = 0u;
            *(_OWORD *)(v13 + 4_Block_object_dispose(va, 8) = 0u;
            *(_OWORD *)(v13 + 64) = 0u;
            *(_OWORD *)(v13 + 16) = 0u;
            *(_OWORD *)(v13 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
            *(_OWORD *)uint64_t v13 = 0u;
            *(_WORD *)uint64_t v13 = 1;
            *(void *)(v13 + _Block_object_dispose(va, 8) = CFURLCopyAbsoluteURL(v4);
            v14[10] = CFArrayCreateMutable(alloc, 0LL, MEMORY[0x189605228]);
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
            v14[11] = Mutable;
            CFTypeID v16 = (const void *)v14[1];
            if (v16)
            {
              if (!v14[10] || !Mutable) {
                goto LABEL_34;
              }
              uint64_t v29 = 0LL;
              __int128 v23 = 1uLL;
              CFIndex v24 = _FTPStreamFinalize;
              uint64_t v25 = _FTPStreamCopyDescription;
              unint64_t v26 = _FTPStreamOpen;
              char v27 = _FTPStreamOpenCompleted;
              int v28 = _FTPStreamRead;
              int v30 = _FTPStreamCanRead;
              CFIndex v31 = _FTPStreamClose;
              int v32 = _FTPStreamCopyProperty;
              uint64_t v34 = 0LL;
              int v33 = _FTPStreamSetProperty;
              int64_t v35 = _FTPStreamSchedule;
              uint64_t v36 = _FTPStreamUnschedule;
              uint64_t v17 = CoreReadStreamCreate((uint64_t)alloc, &v23, (uint64_t)v14);
              if (v17)
              {
                uint64_t v18 = (uint64_t)v17;
                v14[4] = v17;
                if (v10)
                {
                  ++*(void *)(v18 + 96);
                  (*(void (**)(void, const __CFString *, const __CFString *))(**(void **)(v18 + 40) + 32LL))( *(void *)(v18 + 40),  @"kCFStreamPropertyFTPUserName_prevalidated",  v10);
                  --*(void *)(v18 + 96);
                }

                if (v12)
                {
                  ++*(void *)(v18 + 96);
                  (*(void (**)(void, const __CFString *, const __CFString *))(**(void **)(v18 + 40) + 32LL))( *(void *)(v18 + 40),  @"kCFStreamPropertyFTPPassword_prevalidated",  v12);
                  --*(void *)(v18 + 96);
                }

uint64_t _FTPStreamRead(int a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, _BYTE *a5, char *a6)
{
  CFTypeID v11 = a6 + 40;
  while (2)
  {
    while (2)
    {
      *a5 = 0;
      *(void *)a4 = 0LL;
      *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = 0;
LABEL_3:
      CFTypeRef v12 = (NetConnection *)*((void *)a6 + 16);
      while (1)
      {
        if (!v12) {
          goto LABEL_39;
        }
        uint64_t v13 = *((void *)a6 + 3);
        if (v13)
        {
          CFTypeRef v12 = (NetConnection *)*((void *)a6 + 16);
        }

        NetConnection::getState(v12, 1, (uint64_t *)a6);
        uint64_t v14 = *((void *)a6 + 16);
        if (!v14) {
          break;
        }
        uint64_t v15 = *(void *)(v14 + 96);
        if (v15)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
          uint64_t v16 = *(void *)(v14 + 96);
          uint64_t v17 = *(void *)(v14 + 144);
          if (v16) {
            pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
          }
        }

        else
        {
          uint64_t v17 = *(void *)(v14 + 144);
        }

        uint64_t v18 = *((void *)a6 + 16);
        uint64_t v19 = *(void *)(v18 + 96);
        if (v19)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v19 + 8));
          uint64_t v20 = *(void *)(v18 + 96);
          uint64_t v21 = *(void *)(v18 + 152);
          if (v20) {
            pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
          }
          if (v21)
          {
LABEL_19:
            uint64_t v22 = *(void *)(v21 + 80);
            *(void *)a4 = *(void *)(v21 + 72);
            *(void *)(a4 + _Block_object_dispose(va, 8) = v22;
            if ((_DWORD)v22) {
              goto LABEL_29;
            }
LABEL_25:
            if (v17)
            {
              uint64_t v23 = *(void *)(v17 + 80);
              *(void *)a4 = *(void *)(v17 + 72);
              *(void *)(a4 + _Block_object_dispose(va, 8) = v23;
              LODWORD(v22) = v23;
            }

            goto LABEL_29;
          }
        }

        else
        {
          uint64_t v21 = *(void *)(v18 + 152);
          if (v21) {
            goto LABEL_19;
          }
        }

        LODWORD(v22) = *(_DWORD *)(a4 + 8);
        if (!(_DWORD)v22) {
          goto LABEL_25;
        }
LABEL_29:
        CFTypeRef v12 = (NetConnection *)*((void *)a6 + 16);
        if ((_DWORD)v22)
        {
          if (!*(_DWORD *)((*(uint64_t (**)(NetConnection *))(*(void *)v12 + 80LL))(v12) + 20))
          {
            CFIndex v24 = *((void *)a6 + 15);
            if (v24 < CFArrayGetCount(*((CFArrayRef *)a6 + 14)))
            {
              uint64_t v25 = *((void *)a6 + 16);
              ++*((void *)a6 + 15);
              *CFTypeID v11 = *(_OWORD *)a4;
              (*(void (**)(uint64_t, uint64_t))(*(void *)v25 + 64LL))(v25, a4);
              goto LABEL_3;
            }
          }

          goto LABEL_38;
        }
      }

      uint64_t v26 = *((void *)a6 + 4);
      uint64_t v27 = v26 + 16;
      if (!v26) {
        uint64_t v27 = 0LL;
      }
      uint64_t v29 = *(void *)(v27 + 56);
      uint64_t v28 = *(void *)(v27 + 64);
      *(void *)a4 = v29;
      *(void *)(a4 + _Block_object_dispose(va, 8) = v28;
      if ((_DWORD)v28)
      {
LABEL_38:
        *a5 = 1;
        uint64_t v30 = -1LL;
        goto LABEL_40;
      }

uint64_t _FTPStreamCanRead(int a1, char *a2)
{
  CFStringRef v3 = (NetConnection *)*((void *)a2 + 16);
  if (!v3) {
    goto LABEL_34;
  }
  NetConnection::getState(v3, 1, (uint64_t *)a2);
  uint64_t v4 = *((void *)a2 + 16);
  if (!v4)
  {
    uint64_t v8 = *((void *)a2 + 4);
    uint64_t v9 = v8 + 16;
    if (!v8) {
      uint64_t v9 = 0LL;
    }
    *(void *)&v10.CFErrorRef error = *(void *)(v9 + 64);
    if (!v10.error) {
      goto LABEL_34;
    }
    v10.domain = *(void *)(v9 + 56);
    uint64_t v11 = *((void *)a2 + 4);
    if (v11) {
      CFTypeRef v12 = (CoreStreamBase *)(v11 + 16);
    }
    else {
      CFTypeRef v12 = 0LL;
    }
    uint64_t v13 = 1LL;
    goto LABEL_41;
  }

  CFStreamError v30 = (CFStreamError)0LL;
  uint64_t v5 = *(void *)(v4 + 96);
  if (v5)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
    uint64_t v6 = *(void *)(v4 + 96);
    uint64_t v7 = *(void *)(v4 + 144);
    if (v6) {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
    }
  }

  else
  {
    uint64_t v7 = *(void *)(v4 + 144);
  }

  uint64_t v14 = *((void *)a2 + 16);
  uint64_t v15 = *(void *)(v14 + 96);
  if (v15)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
    uint64_t v16 = *(void *)(v14 + 96);
    uint64_t v17 = *(void *)(v14 + 152);
    if (v16) {
      pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
    }
    if (v17)
    {
LABEL_20:
      CFIndex v18 = *(void *)(v17 + 72);
      uint64_t v17 = *(void *)(v17 + 80);
      v30.domain = v18;
      *(void *)&v30.CFErrorRef error = v17;
      int v19 = v17;
      if ((_DWORD)v17) {
        goto LABEL_30;
      }
      goto LABEL_26;
    }
  }

  else
  {
    uint64_t v17 = *(void *)(v14 + 152);
    if (v17) {
      goto LABEL_20;
    }
  }

  CFIndex v18 = 0LL;
  int v19 = 0;
LABEL_26:
  if (v7)
  {
    CFIndex v18 = *(void *)(v7 + 72);
    uint64_t v17 = *(void *)(v7 + 80);
    v30.domain = v18;
    *(void *)&v30.CFErrorRef error = v17;
    int v19 = v17;
  }

void sub_182A18820(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A188B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A18910(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A18A90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_182A18D58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_182A18FC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_182A19328( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_182A1944C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A19598( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_182A19774(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A19B00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A19CB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

void sub_182A19EC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A1A004( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_182A1A100( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_182A1A1BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

id cookieNotificationQueue(void)
{
  return (id)cookieNotificationQueue(void)::notificaionQueue;
}

void sub_182A1A360( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZL23cookieNotificationQueuev_block_invoke()
{
  CFStringRef v3 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v3, QOS_CLASS_UTILITY, 0);
  CFPropertyListRef v0 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue();
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.NSHTTPCookieManagerNotification", v0);
  CFStringRef v2 = (void *)cookieNotificationQueue(void)::notificaionQueue;
  cookieNotificationQueue(void)::notificaionQueue = (uint64_t)v1;
}

void sub_182A1A670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A1A88C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A1ABC4(_Unwind_Exception *a1)
{
  uint64_t v5 = v3;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__853(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__854(uint64_t a1)
{
}

void sub_182A1AD9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A1AEEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A1B034(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A1B4F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_182A1B5A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A1B660(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A1B724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFReadStreamRef CFReadStreamCreateForHTTPRequest(CFAllocatorRef alloc, CFHTTPMessageRef request)
{
  return (CFReadStreamRef)CFReadStreamCreate();
}

void __CFReadStreamCreateForHTTPRequest_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v4 = MEMORY[0x186E12804](*(void *)(a1 + 32), 152LL, 0LL);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(v4 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 12_Block_object_dispose(va, 8) = 0u;
  *(void *)(v4 + 144) = 0LL;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (*(_BYTE *)(v5 + 40)) {
      uint64_t v6 = 0LL;
    }
    else {
      uint64_t v6 = (HTTPRequestMessage *)(v5 + 16);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  HTTPReadStream::HTTPReadStream((HTTPReadStream *)v4, a2, v6, 0LL);
}

CFReadStreamRef CFReadStreamCreateForStreamedHTTPRequest( CFAllocatorRef alloc, CFHTTPMessageRef requestHeaders, CFReadStreamRef requestBody)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!requestBody || CFReadStreamGetStatus(requestBody) != kCFStreamStatusOpen) {
    return (CFReadStreamRef)CFReadStreamCreate();
  }
  CFLog();
  CFReadStreamSetClient(requestBody, 0LL, 0LL, 0LL);
  CFStreamCreateBoundPair(alloc, &readStream, &writeStream, 0x8000LL);
  CFWriteStreamOpen(writeStream);
  *(_OWORD *)keys = xmmword_189C02998;
  values[0] = requestBody;
  values[1] = writeStream;
  CFDictionaryRef v5 = CFDictionaryCreate( alloc,  (const void **)keys,  (const void **)values,  2LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFRelease(writeStream);
  pthread_attr_init(&v11);
  pthread_attr_setdetachstate(&v11, 2);
  pthread_t v8 = 0LL;
  if (pthread_create(&v8, &v11, (void *(__cdecl *)(void *))_boundPairReadingThread, v5))
  {
    CFRelease(v5);
    CFLog();
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = (__CFReadStream *)CFReadStreamCreate();
  }

  pthread_attr_destroy(&v11);
  CFRelease(readStream);
  return v6;
}

uint64_t _boundPairReadingThread(const __CFDictionary *a1)
{
  CFStringRef v2 = (UInt8 *)operator new[](0x4000uLL);
  Value = (__CFReadStream *)CFDictionaryGetValue(a1, @"requestBody");
  uint64_t v4 = (__CFWriteStream *)CFDictionaryGetValue(a1, @"newWriteStream");
  while (1)
  {
    CFIndex v5 = CFReadStreamRead(Value, v2, 0x4000LL);
    if (v5 < 1) {
      break;
    }
    uint64_t v6 = &v2[v5];
    uint64_t v7 = v2;
    while (v7 < v6)
    {
      CFIndex v8 = CFWriteStreamWrite(v4, v7, v6 - v7);
      v7 += v8;
      if (v8 <= 0) {
        goto LABEL_6;
      }
    }
  }

void ___ZL24_handleAlreadyOpenStreamPK13__CFAllocatorP15__CFHTTPMessageP14__CFReadStream_block_invoke( uint64_t a1, const void *a2)
{
  uint64_t v4 = MEMORY[0x186E12804](*(void *)(a1 + 32), 152LL, 0LL);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(v4 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 12_Block_object_dispose(va, 8) = 0u;
  *(void *)(v4 + 144) = 0LL;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (*(_BYTE *)(v5 + 40)) {
      uint64_t v6 = 0LL;
    }
    else {
      uint64_t v6 = (HTTPRequestMessage *)(v5 + 16);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  HTTPReadStream::HTTPReadStream((HTTPReadStream *)v4, a2, v6, *(__CFReadStream **)(a1 + 48));
}

void __CFReadStreamCreateForStreamedHTTPRequest_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v4 = MEMORY[0x186E12804](*(void *)(a1 + 32), 152LL, 0LL);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(v4 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 12_Block_object_dispose(va, 8) = 0u;
  *(void *)(v4 + 144) = 0LL;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    if (*(_BYTE *)(v5 + 40)) {
      uint64_t v6 = 0LL;
    }
    else {
      uint64_t v6 = (HTTPRequestMessage *)(v5 + 16);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  HTTPReadStream::HTTPReadStream((HTTPReadStream *)v4, a2, v6, *(__CFReadStream **)(a1 + 48));
}

void non-virtual thunk to'GlueTubeManager::~GlueTubeManager(GlueTubeManager *this)
{
}

void non-virtual thunk to'GlueTubeManager::~GlueTubeManager(CFAllocatorRef *this)
{
  CFStringRef v2 = this - 3;
  GlueTubeManager::~GlueTubeManager((GlueTubeManager *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void std::__shared_ptr_pointer<NSObject  {objcproto13OS_nw_context}*,Deleter_NWRelease<NSObject  {objcproto13OS_nw_context}*>,std::allocator<NSObject  {objcproto13OS_nw_context}>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_emplace<NWIOConnection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C02A40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NWIOConnection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C02A40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void ___ZN15GlueTubeManager22_getIOPathFromDefaultsEv_block_invoke()
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  CFPropertyListRef v0 = (const __CFString *)CFPreferencesCopyValue( @"com.apple.CFNetwork.ForceIOPath",  (CFStringRef)*MEMORY[0x189605170],  (CFStringRef)*MEMORY[0x189605198],  (CFStringRef)*MEMORY[0x189605178]);
  if (!v0)
  {
    GlueTubeManager::_getIOPathFromDefaults(void)::ioPath = 0;
    return;
  }

  dispatch_queue_t v1 = v0;
  CFTypeID v2 = CFGetTypeID(v0);
  if (v2 != CFStringGetTypeID())
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v4 = (os_log_s *)CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    int v10 = 138543362;
    pthread_attr_t v11 = v1;
    uint64_t v6 = "CFNetwork I/O Path Preference(%{public}@) Invalid";
    goto LABEL_14;
  }

  if (CFStringCompare(v1, @"stream", 1uLL) == kCFCompareEqualTo)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      _os_log_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_DEFAULT,  "CFNetwork I/O Path Preference Forcing Stream I/O",  (uint8_t *)&v10,  2u);
    }

    CFIndex v8 = &TrustExceptionManager::_isSharingdProcess(void)::onceToken;
    int v9 = 1;
    goto LABEL_23;
  }

  CFComparisonResult v3 = CFStringCompare(v1, @"nw", 1uLL);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v4 = (os_log_s *)CFNLog::logger;
  BOOL v5 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
  if (v3 == kCFCompareEqualTo)
  {
    if (v5)
    {
      LOWORD(v10) = 0;
      _os_log_impl( &dword_18298D000,  v4,  OS_LOG_TYPE_DEFAULT,  "CFNetwork I/O Path Preference Forcing NW",  (uint8_t *)&v10,  2u);
    }

    CFIndex v8 = &TrustExceptionManager::_isSharingdProcess(void)::onceToken;
    int v9 = 2;
LABEL_23:
    *((_DWORD *)v8 + 522) = v9;
    goto LABEL_24;
  }

  if (v5)
  {
    int v10 = 138543362;
    pthread_attr_t v11 = v1;
    uint64_t v6 = "CFNetwork I/O Path Preference Unrecognized(%{public}@)";
LABEL_14:
    _os_log_impl(&dword_18298D000, v4, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v10, 0xCu);
  }

void *GlueTubeManager::_findOrCreateSManager(GlueTubeManager *this)
{
  dispatch_queue_t v1 = (void *)*((void *)this + 5);
  if (!v1)
  {
    uint64_t v3 = MEMORY[0x186E12804](*((void *)this + 1), 152LL, 0LL);
    *(_OWORD *)uint64_t v3 = 0u;
    *(_OWORD *)(v3 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
    *(_OWORD *)(v3 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    *(_OWORD *)(v3 + 112) = 0u;
    *(_OWORD *)(v3 + 12_Block_object_dispose(va, 8) = 0u;
    *(void *)(v3 + 144) = 0LL;
    *(_OWORD *)(v3 + 16) = 0u;
    uint64_t v4 = (const __CFAllocator *)*((void *)this + 1);
    uint64_t v5 = *((void *)this + 6);
    uint64_t v10 = *((void *)this + 11);
    __int128 v8 = *(_OWORD *)((char *)this + 56);
    __int128 v9 = *(_OWORD *)((char *)this + 72);
    *(void *)uint64_t v3 = off_189C06BF8;
    *(void *)(v3 + _Block_object_dispose(va, 8) = v4;
    *(_DWORD *)(v3 + 16) = 1;
    if (((v3 + 16) & 3) != 0) {
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    }
    dispatch_queue_t v1 = (void *)v3;
    *(void *)uint64_t v3 = off_189C18C98;
    *(void *)(v3 + 24) = &unk_189C18D00;
    *(_OWORD *)(v3 + 40) = xmmword_182C9D730;
    uint64_t v6 = v3 + 40;
    *(_OWORD *)(v3 + 56) = xmmword_182C9D740;
    *(void *)(v3 + 72) = 0x7800000078LL;
    *(void *)(v3 + 104) = off_189C18E58;
    *(void *)(v3 + 112) = CFDictionaryCreateMutable( v4,  0LL,  &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks,  &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
    v1[15] = off_189C18E78;
    v1[16] = CFDictionaryCreateMutable( v4,  0LL,  &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks,  MEMORY[0x189605250]);
    v1[17] = CFArrayCreateMutable(v4, 0LL, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    v1[18] = CFArrayCreateMutable(v4, 0LL, &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    if (!v5) {
      __assert_rtn("STubeManager", "STubeManager.cpp", 24, "schedulingSet");
    }
    v1[4] = v5;
    (*(void (**)(uint64_t))(*(void *)v5 + 40LL))(v5);
    *(_OWORD *)uint64_t v6 = v8;
    *(_OWORD *)(v6 + 16) = v9;
    *(void *)(v6 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v10;
    v1[11] = 0LL;
    v1[12] = 0LL;
    v1[10] = 0LL;
    *((void *)this + 5) = v1;
  }

  return v1;
}

void sub_182A1C14C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 120) = v3;
  CFRelease(*(CFTypeRef *)(v1 + 128));
  *(void *)(v1 + 104) = v2;
  CFRelease(*(CFTypeRef *)(v1 + 112));
  *(void *)(v1 + 24) = off_189C19AE8;
  _Unwind_Resume(a1);
}

uint64_t _CFServerCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!_ServerTypeId)
  {
    _ServerTypeId = _CFRuntimeRegisterClass();
    if (!_ServerTypeId) {
      return 0LL;
    }
  }

  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (!Instance) {
    return v6;
  }
  *(void *)(Instance + 16) = 0LL;
  *(void *)(Instance + 24) = 0LL;
  *(_DWORD *)(Instance + 40) = 0;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
  *(void *)(Instance + 56) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  uint64_t v7 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v8 = dispatch_queue_create("com.apple.CFNetwork.CFServer", v7);
  *(void *)(v6 + 4_Block_object_dispose(va, 8) = tcp_listener_create();
  dispatch_release(v8);
  if (!*(void *)(v6 + 48))
  {
    _CFServerInvalidate(v6);
    CFRelease((CFTypeRef)v6);
    return 0LL;
  }

  tcp_listener_set_accept_handler_f();
  tcp_listener_set_error_handler_f();
  *(void *)(v6 + 64) = a2;
  uint64_t v9 = *(void *)(a3 + 32);
  __int128 v10 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v6 + 72) = *(_OWORD *)a3;
  *(void *)(v6 + 104) = v9;
  *(_OWORD *)(v6 + 8_Block_object_dispose(va, 8) = v10;
  if (*(void *)(v6 + 80))
  {
    pthread_attr_t v11 = *(uint64_t (**)(void))(v6 + 88);
    if (v11) {
      *(void *)(v6 + 80) = v11();
    }
  }

  return v6;
}

uint64_t _tcp_listener_AcceptCallback()
{
  return tcp_connection_start();
}

uint64_t _tcp_listener_ErrorCallback(uint64_t result, int a2)
{
  if (*(void *)(result + 64))
  {
    uint64_t v2 = result;
    uint64_t result = *(void *)(result + 56);
    if (*(_DWORD *)(result + 40))
    {
      if (a2 >> 5 == 134215679)
      {
        if (a2 > -65549)
        {
          if (a2 == -65548)
          {
            a2 = -72001;
            goto LABEL_15;
          }

          if (a2 == -65540)
          {
            a2 = -72004;
            goto LABEL_15;
          }

uint64_t _CFServerInvalidate(uint64_t a1)
{
  if (*(void *)(a1 + 80))
  {
    uint64_t v2 = *(void (**)(void))(a1 + 96);
    if (v2) {
      v2();
    }
  }

  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 48LL))(v3);
    *(void *)(a1 + 56) = 0LL;
  }

  uint64_t v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a1 + 16) = 0LL;
  }

  int v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 24) = 0LL;
  }

  int v6 = *(const void **)(a1 + 32);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
  }

  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    tcp_listener_cancel();
    uint64_t result = tcp_listener_release();
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  }

  return result;
}

uint64_t ___ZL18_ServerHandleErrorP6Serveri_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)(a1 + 32) + 64LL))( *(void *)(a1 + 32),  0xFFFFFFFFLL,  a1 + 40,  *(void *)(*(void *)(a1 + 32) + 80LL));
}

_DWORD *___ZL28_tcp_listener_AcceptCallbackPvPU28objcproto17OS_tcp_connection8NSObject_block_invoke( _DWORD *result, int a2)
{
  if (a2 == 1)
  {
    uint64_t v9 = v2;
    uint64_t v10 = v3;
    uint64_t v4 = result;
    int v5 = tcp_connection_copy_socket();
    uint64_t result = (_DWORD *)tcp_connection_cancel();
    uint64_t v6 = *((void *)v4 + 5);
    if (*(void *)(v6 + 64))
    {
      uint64_t result = *(_DWORD **)(v6 + 56);
      if (result[10])
      {
        v7[6] = 0LL;
        v7[0] = MEMORY[0x1895F87A8];
        v7[1] = 3221225472LL;
        v7[2] = ___ZL19_ServerHandleAcceptP6Serveri_block_invoke;
        v7[3] = &__block_descriptor_60_e5_v8__0l;
        v7[4] = v6;
        v7[5] = 0LL;
        int v8 = v5;
        return (_DWORD *)(*(uint64_t (**)(_DWORD *, void *))(*(void *)result + 96LL))(result, v7);
      }
    }
  }

  return result;
}

uint64_t ___ZL19_ServerHandleAcceptP6Serveri_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 32) + 64LL))( *(void *)(a1 + 32),  *(unsigned int *)(a1 + 56),  a1 + 40,  *(void *)(*(void *)(a1 + 32) + 80LL));
}

CFStringRef _ServerCopyDescription(void *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  uint64_t v3 = (uint64_t (*)(void))a1[13];
  if (v3) {
    CFStringRef v4 = (CFStringRef)v3(a1[10]);
  }
  else {
    CFStringRef v4 = CFStringCreateWithFormat(v2, 0LL, @"<%p>", a1[10]);
  }
  CFStringRef v5 = v4;
  CFStringRef v6 = CFStringCreateWithFormat(v2, 0LL, @"<Server %p>{tcp_listener=%p, info=%@}", a1, a1[6], v4);
  CFRelease(v5);
  return v6;
}

uint64_t _CFServerScheduleWithRunLoopAndMode(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 56LL))(*(void *)(a1 + 56));
  *(void *)(a1 + 56) = result;
  return result;
}

uint64_t _CFServerGetPort(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    unsigned int port = tcp_listener_get_port();
    if (port) {
      return __rev16(port);
    }
    CFLog();
  }

  return *(unsigned __int16 *)(a1 + 40);
}

uint64_t _CFServerStart(uint64_t a1, const __CFString *a2, const void *a3, unsigned int a4)
{
  v24[1] = *MEMORY[0x1895F89C0];
  if (!*(void *)(a1 + 48)) {
    return 0LL;
  }
  if (!*(_DWORD *)(*(void *)(a1 + 56) + 40LL))
  {
    CFRunLoopRef Current = CFRunLoopGetCurrent();
    *(void *)(a1 + 56) = (*(uint64_t (**)(void, CFRunLoopRef, void))(**(void **)(a1 + 56) + 56LL))( *(void *)(a1 + 56),  Current,  *MEMORY[0x1896051A8]);
  }

  if (a4 < 0x10000)
  {
    if (a2) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = &stru_189C1D1D8;
    }
    *(void *)(a1 + 16) = CFRetain(v9);
    if (a3)
    {
      *(void *)(a1 + 24) = CFRetain(a3);
      *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &stru_189C1D1D8;
      *(_DWORD *)(a1 + 40) = a4;
      CFIndex Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
      CFIndex v11 = CFStringGetLength(*(CFStringRef *)(a1 + 24));
      CFIndex v12 = CFStringGetLength(*(CFStringRef *)(a1 + 32));
      CFIndex v13 = v12 + 1;
      uint64_t v14 = MEMORY[0x1895F8858](v12);
      uint64_t v15 = MEMORY[0x1895F8858](v14);
      uint64_t v16 = (char *)v24 - ((MEMORY[0x1895F8858](v15) + 16) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringGetCString( *(CFStringRef *)(a1 + 16),  (char *)v24 - ((Length + 16) & 0xFFFFFFFFFFFFFFF0LL),  Length + 1,  0x8000100u);
      CFStringGetCString( *(CFStringRef *)(a1 + 24),  (char *)v24 - ((v11 + 16) & 0xFFFFFFFFFFFFFFF0LL),  v11 + 1,  0x8000100u);
      CFStringGetCString(*(CFStringRef *)(a1 + 32), v16, v13, 0x8000100u);
      tcp_listener_set_service();
      if (!*(_DWORD *)(a1 + 40)) {
        goto LABEL_16;
      }
    }

    else
    {
      *(void *)(a1 + 24) = 0LL;
      *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &stru_189C1D1D8;
      *(_DWORD *)(a1 + 40) = a4;
      if (!a4) {
        goto LABEL_16;
      }
    }

    uint64_t v17 = CFGetAllocator((CFTypeRef)a1);
    CFIndex v18 = CFStringCreateWithFormat(v17, 0LL, @"%u", *(unsigned int *)(a1 + 40));
    CFIndex v19 = CFStringGetLength(v18);
    MEMORY[0x1895F8858](v19);
    CFStringGetCString(v18, (char *)v24 - v20, v21, 0x8000100u);
    int v22 = tcp_listener_set_port();
    CFRelease(v18);
    if (v22) {
      return 0LL;
    }
LABEL_16:
    tcp_listener_start();
    return 1LL;
  }

  tcp_listener_release();
  return 0LL;
}

CFStringRef ActualCredentialStorage::copyDebugDesc(ActualCredentialStorage *this)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<ActualCredentialStorage@%p<%p> { session %p, persistent %p }",  (char *)this - 16,  this,  *((void *)this + 13),  *((void *)this + 14));
}

CFStringRef ActualCredentialStorage::copyDebugSummary(ActualCredentialStorage *this)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"shared credential storage %p, session %p, persistent %p",  (char *)this - 16,  *((void *)this + 13),  *((void *)this + 14));
}

uint64_t ActualCredentialStorage::initialize(ActualCredentialStorage *this, const __CFString *a2, int a3)
{
  CFStringRef v6 = (char *)this - 16;
  CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
  uint64_t v8 = MEMORY[0x186E12804](v7, 64LL, 0LL);
  *(_OWORD *)uint64_t v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(v8 + 4_Block_object_dispose(va, 8) = 0u;
  uint64_t v9 = CFGetAllocator(v6);
  *(void *)uint64_t v8 = off_189C02C48;
  *(void *)(v8 + _Block_object_dispose(va, 8) = v9;
  *(void *)(v8 + 16) = &unk_189C02CA0;
  *(void *)(v8 + 24) = &unk_189C02D08;
  *(void *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = off_189C02D28;
  *(void *)(v8 + 40) = CFDictionaryCreateMutable(v9, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  *(void *)(v8 + 4_Block_object_dispose(va, 8) = off_189C02D48;
  *(void *)(v8 + 56) = CFDictionaryCreateMutable(v9, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  *((void *)this + 13) = v8;
  if (!a3)
  {
LABEL_4:
    if (a2) {
      CFTypeRef v15 = CFRetain(a2);
    }
    else {
      CFTypeRef v15 = 0LL;
    }
    *((void *)this + 12) = v15;
    return 1LL;
  }

  CFAllocatorRef v10 = CFGetAllocator(v6);
  uint64_t v11 = MEMORY[0x186E12804](v10, 48LL, 0LL);
  *(_OWORD *)uint64_t v11 = 0u;
  *(_OWORD *)(v11 + 16) = 0u;
  *(_OWORD *)(v11 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  CFAllocatorRef v12 = CFGetAllocator(v6);
  *(void *)uint64_t v11 = off_189C02D68;
  *(void *)(v11 + _Block_object_dispose(va, 8) = v12;
  *(void *)(v11 + 16) = &unk_189C02DD8;
  *(void *)(v11 + 24) = &unk_189C02E40;
  *(_BYTE *)(v11 + 40) = 0;
  *((void *)this + 14) = v11;
  int v13 = PersistentCredentialStorage::initialize((PersistentCredentialStorage *)v11, a2);
  uint64_t result = *((void *)this + 14);
  if (v13)
  {
    if (!result) {
      return result;
    }
    goto LABEL_4;
  }

  if (result) {
    (*(void (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  uint64_t result = 0LL;
  *((void *)this + 14) = 0LL;
  return result;
}

void sub_182A1CBC0(_Unwind_Exception *a1)
{
  *(void *)(v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v2;
  CFRelease(*(CFTypeRef *)(v1 + 40));
  *(void *)(v1 + 24) = off_189C19AE8;
  _Unwind_Resume(a1);
}

CFTypeRef ActualCredentialStorage::copyCredentialsForProtectionSpace( ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  CFStringRef v4 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 13) + 16LL))(*((void *)this + 13));
  uint64_t v5 = *((void *)this + 14);
  if (!v5) {
    return v4;
  }
  CFStringRef v6 = (const void *)(*(uint64_t (**)(uint64_t, _CFURLProtectionSpace *))(*(void *)v5 + 24LL))(v5, a2);
  if (!v4)
  {
    unint64_t v31 = 0LL;
    CFTypeRef v30 = 0LL;
    uint64_t v32 = (const void **)v33;
    CFTypeRef v34 = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v36 = (const void **)v37;
    goto LABEL_17;
  }

  CFTypeRef v30 = CFRetain(v4);
  unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)v4);
  unint64_t v31 = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    uint64_t v32 = 0LL;
    goto LABEL_11;
  }

  if (Count > 0x1E)
  {
    uint64_t v8 = (const void **)malloc(8 * Count);
    uint64_t v32 = v8;
    if (!v8) {
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v8 = (const void **)v33;
    uint64_t v32 = (const void **)v33;
  }

  CFDictionaryGetKeysAndValues((CFDictionaryRef)v4, v8, 0LL);
LABEL_11:
  CFTypeRef v34 = CFRetain(v4);
  unint64_t v10 = CFDictionaryGetCount((CFDictionaryRef)v4);
  uint64_t v35 = v10;
  if (v10 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    uint64_t v36 = 0LL;
    goto LABEL_17;
  }

  if (v10 > 0x1E)
  {
    uint64_t v11 = (const void **)malloc(8 * v10);
    uint64_t v36 = v11;
    if (!v11) {
      goto LABEL_17;
    }
  }

  else
  {
    uint64_t v11 = (const void **)v37;
    uint64_t v36 = (const void **)v37;
  }

  CFDictionaryGetKeysAndValues((CFDictionaryRef)v4, 0LL, v11);
LABEL_17:
  if (!v6)
  {
    CFTypeRef v22 = 0LL;
    unint64_t v23 = 0LL;
    uint64_t v24 = (const void **)v25;
    CFTypeRef v26 = 0LL;
    uint64_t v27 = 0LL;
    uint64_t v28 = (const void **)v29;
    if (!v35) {
      goto LABEL_44;
    }
    goto LABEL_42;
  }

  CFTypeRef v22 = CFRetain(v6);
  unint64_t v12 = CFDictionaryGetCount((CFDictionaryRef)v6);
  unint64_t v23 = v12;
  if (v12 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    uint64_t v24 = 0LL;
    goto LABEL_26;
  }

  if (v12 > 0x1E)
  {
    int v13 = (const void **)malloc(8 * v12);
    uint64_t v24 = v13;
    if (!v13) {
      goto LABEL_26;
    }
  }

  else
  {
    int v13 = (const void **)v25;
    uint64_t v24 = (const void **)v25;
  }

  CFDictionaryGetKeysAndValues((CFDictionaryRef)v6, v13, 0LL);
LABEL_26:
  CFTypeRef v26 = CFRetain(v6);
  unint64_t v14 = CFDictionaryGetCount((CFDictionaryRef)v6);
  uint64_t v27 = v14;
  if (v14 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    uint64_t v28 = 0LL;
  }

  else
  {
    if (v14 <= 0x1E)
    {
      CFTypeRef v15 = (const void **)v29;
      uint64_t v28 = (const void **)v29;
LABEL_31:
      CFDictionaryGetKeysAndValues((CFDictionaryRef)v6, 0LL, v15);
      goto LABEL_32;
    }

    CFTypeRef v15 = (const void **)malloc(8 * v14);
    uint64_t v28 = v15;
    if (v15) {
      goto LABEL_31;
    }
  }

LABEL_42:
  if (v4)
  {
    uint64_t v20 = v4;
LABEL_46:
    CFTypeRef v9 = CFRetain(v20);
    goto LABEL_49;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v24 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v25 = *(void *)(v3 + 72);
    CFTypeRef v26 = *(_DWORD *)(*(void *)(a1 + 40) + 80LL);
    uint64_t v27 = *(unsigned __int8 *)(a1 + 56);
    *(_DWORD *)buf = 134218496;
    *(void *)&buf[4] = v25;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v26;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v27;
    _os_log_debug_impl( &dword_18298D000,  v24,  OS_LOG_TYPE_DEBUG,  "HTTP/2 Connection %llu Stream %d ended. Connection considered operational %{BOOL}d",  buf,  0x18u);
    if (v14)
    {
LABEL_46:
      if (!*(_BYTE *)(v3 + 264) && (*(_DWORD *)(v3 + 176) - 3) >= 2)
      {
        if (*(_BYTE *)(a1 + 56))
        {
          *(void *)(v3 + 72_Block_object_dispose(va, 8) = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
          *(void *)(v3 + 736) = 0LL;
        }

        else
        {
          uint64_t v29 = *(void *)(v3 + 736) + 1LL;
          *(void *)(v3 + 736) = v29;
          if (v29 >= 0xB)
          {
            CFTypeRef v30 = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX) - *(void *)(v3 + 728);
            if (v30 >= 0xDF8475801LL)
            {
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
              }
              unint64_t v31 = (os_log_s *)CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
              {
                uint64_t v32 = *(void *)(v3 + 72);
                CFIndex v33 = *(void *)(v3 + 736);
                *(_DWORD *)buf = 134218496;
                *(void *)&buf[4] = v32;
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = v30 / 0x3B9ACA00;
                *(_WORD *)&buf[22] = 2048;
                uint64_t v36 = v33;
                _os_log_error_impl( &dword_18298D000,  v31,  OS_LOG_TYPE_ERROR,  "HTTP/2 terminating broken Connection %llu, last success %llus ago, consecutive failures %llu",  buf,  0x20u);
              }

              *(_BYTE *)(v3 + 264) = 1;
              HTTP2Connection::stopIfNoOutstandingRequests((HTTP2Connection *)v3);
            }
          }
        }
      }
    }
  }

  else if (v14)
  {
    goto LABEL_46;
  }

  CFRelease((CFTypeRef)(v3 - 16));
}

      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        uint64_t v24 = __ldaxr(p_shared_owners);
      while (__stlxr(v24 - 1, p_shared_owners));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }

  uint64_t v2 = (void *)objc_msgSend(v11, "URLByAppendingPathComponent:", @"com.apple.nsurlsessiond/Downloads", v41);
  uint64_t v29 = objc_msgSend((id)objc_msgSend(MEMORY[0x1896077F8], "mainBundle"), "bundleIdentifier");
  if (v29) {
    uint64_t v2 = (void *)[v2 URLByAppendingPathComponent:v29 isDirectory:1];
  }
LABEL_2:
  LOBYTE(v42) = 0;
  uint64_t v3 = objc_msgSend( (id)objc_msgSend(MEMORY[0x1896078A8], "defaultManager", v41),  "fileExistsAtPath:isDirectory:",  objc_msgSend(v2, "path"),  &v42);
  if (v3) {
    CFStringRef v4 = v42 == 0;
  }
  else {
    CFStringRef v4 = 0;
  }
  if (v4)
  {
    if (objc_msgSend((id)objc_msgSend(MEMORY[0x1896078A8], "defaultManager"), "removeItemAtURL:error:", v2, &v41)) {
      goto LABEL_19;
    }
    uint64_t v5 = [*(id *)(a1 + 112) _isProxySession];
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    CFStringRef v6 = (os_log_s *)CFNLog::logger;
    CFAllocatorRef v7 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
    if (v5)
    {
      if (!v7) {
        goto LABEL_19;
      }
      uint64_t v8 = *(void *)(a1 + 128);
      *(_DWORD *)buf = 138543618;
      __int128 v44 = v8;
      __int128 v45 = 2112;
      __int128 v46 = v41;
      CFTypeRef v9 = "ProxySession <%{public}@> error removing file at location of downloads directory: %@";
    }

    else
    {
      if (!v7) {
        goto LABEL_19;
      }
      CFTypeRef v30 = *(void *)(a1 + 128);
      *(_DWORD *)buf = 138543618;
      __int128 v44 = v30;
      __int128 v45 = 2112;
      __int128 v46 = v41;
      CFTypeRef v9 = "BackgroundSession <%{public}@> error removing file at location of downloads directory: %@";
    }

    _os_log_error_impl(&dword_18298D000, v6, OS_LOG_TYPE_ERROR, v9, buf, 0x16u);
  }

  else if ((v3 & 1) != 0)
  {
    return v2;
  }

        unint64_t v10 = 0LL;
        goto LABEL_40;
      }

      if (a2)
      {
        BytePtr = CFDataGetBytePtr(a2);
        CFIndex Length = CFDataGetLength(a2);
        CFTypeRef v26 = CFGetAllocator(a1);
        uint64_t v27 = CFWriteStreamCreateWithFTPURL(v26, a1);
        if (a3) {
          CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)_ApplyWriteStreamProperties, v27);
        }
        CFWriteStreamSetProperty( v27,  @"kCFStreamPropertyFTPAttemptPersistentConnection",  (CFTypeRef)*MEMORY[0x189604DE0]);
        if (CFWriteStreamOpen(v27))
        {
          do
          {
            if (!Length) {
              break;
            }
            uint64_t v28 = CFWriteStreamWrite(v27, BytePtr, Length);
            BytePtr += v28;
            Length -= v28;
          }

          while (v28 > 0);
          CFWriteStreamClose(v27);
        }

        Error = CFWriteStreamGetError(v27);
        CFTypeRef v30 = Error.error;
        if (a4)
        {
          *a4 = Error.error;
          CFRelease(v27);
          CFTypeRef v30 = *a4;
        }

        else
        {
          CFRelease(v27);
        }

        unint64_t v10 = v30 == 0;
        goto LABEL_40;
      }

      if (!a4) {
        goto LABEL_42;
      }
      unint64_t v10 = 0LL;
    }

    else
    {
      unint64_t v12 = CFGetAllocator(a1);
      if (a2)
      {
        int v13 = v12;
        Request = CFHTTPMessageCreateRequest(v12, @"PUT", a1, @"HTTP/1.0");
        CFTypeRef v15 = CFDataGetLength(a2);
        uint64_t v16 = CFStringCreateWithFormat(v13, 0LL, @"%ld", v15);
        CFHTTPMessageSetHeaderFieldValue(Request, (CFStringRef)&unk_18C5AEEB8, v16);
        CFRelease(v16);
        if (a3)
        {
          unint64_t Count = CFDictionaryGetCount(a3);
          if (Count >= 1)
          {
            CFIndex v18 = Count;
            CFIndex v19 = (const void **)MEMORY[0x186E12804](v13, 16 * Count, 0LL);
            uint64_t v20 = &v19[v18];
            CFDictionaryGetKeysAndValues(a3, v19, v20);
            CFIndex v21 = (CFStringRef *)v19;
            do
            {
              CFTypeRef v22 = CFGetTypeID(v21[v18]);
              if (v22 == CFStringGetTypeID()) {
                CFHTTPMessageSetHeaderFieldValue(Request, *v21, v21[v18]);
              }
              ++v21;
            }

            while (v21 < (CFStringRef *)v20);
            CFAllocatorDeallocate(v13, v19);
          }
        }

        unint64_t v10 = (unint64_t)_CFHTTPMessageSendRequest(Request);
        CFRelease(Request);
        if (v10)
        {
          CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v10);
          CFRelease((CFTypeRef)v10);
          unint64_t v10 = (ResponseStatusCode - 200) < 0x64;
          else {
            uint64_t v11 = 0;
          }
          if (!a4) {
            goto LABEL_40;
          }
        }

        else
        {
          if (!a4)
          {
LABEL_40:
            CFRelease(v9);
            return v10;
          }

          uint64_t v11 = -14;
        }

          CFHostCancelInfoResolution(this, kCFHostAddresses);
          if (!*((_DWORD *)cf + 70))
          {
            pthread_mutex_unlock(v8);
LABEL_5:
            CFRelease(cf);
            return;
          }

          uint64_t v29 = *((_DWORD *)cf + 66);
          *((_DWORD *)cf + 66) = v29 & 0xFFFFFFEC | 2;
          CFTypeRef v34 = *((_OWORD *)cf + 17);
          if ((v29 & 0x200) != 0)
          {
            WeakRetained = objc_loadWeakRetained((id *)cf + 36);
            if ((*((_DWORD *)cf + 66) & 0x400) != 0) {
              goto LABEL_45;
            }
          }

          else
          {
            WeakRetained = 0LL;
            if ((v29 & 0x400) != 0)
            {
LABEL_45:
              unint64_t v31 = objc_loadWeakRetained((id *)cf + 37);
LABEL_49:
              pthread_mutex_unlock(v8);
              if (WeakRetained)
              {
                CFReadStreamSignalEvent();
                CFRelease(WeakRetained);
              }

              if (v31)
              {
                CFWriteStreamSignalEvent();
                CFRelease(v31);
              }

              goto LABEL_5;
            }
          }

          unint64_t v31 = 0LL;
          goto LABEL_49;
        }

        unint64_t v31 = 0;
LABEL_44:

        goto LABEL_45;
      }

      -[NSHTTPCookie2LookupFilter inURL](self, "inURL");
      uint64_t v36 = (const __CFURL *)objc_claimAutoreleasedReturnValue();
      -[NSHTTPCookie2LookupFilter siteForCookies](self, "siteForCookies");
      uint64_t v37 = (const __CFURL *)objc_claimAutoreleasedReturnValue();
      uint64_t v38 = +[NSHTTPCookieStorageUtils isURLInMainDocumentDomain:withMainDocumentURL:ignoringTLD:]( (uint64_t)&OBJC_CLASS___NSHTTPCookieStorageUtils,  v36,  v37,  0);

      if ((v38 & 1) == 0) {
        goto LABEL_42;
      }
      goto LABEL_34;
    }
  }

  CFTypeRef v26 = *(HTTPMessage **)(-[HTTPProtocol _inner](a2, "_inner") + 56);
  if (v26
    && (uint64_t v27 = CFHTTPMessageCopyRequestMethod((HTTPMessage *)((char *)v26 - 16)), (v28 = v27) != 0LL)
    && (uint64_t v29 = CFEqual(v27, @"POST"), CFRelease(v28), v29))
  {
    HTTPMessage::ensureParserFinished(v26);
    CFTypeRef v30 = *((void *)v26 + 6);
    if (!v30 || (unint64_t v31 = *(const void **)(v30 + 16)) == 0LL && (unint64_t v31 = *(const void **)(v30 + 24)) == 0LL)
    {
      sockaddr v43 = *(HTTPMessage **)(-[HTTPProtocol _inner](this, "_inner") + 56);
      if (!v43 || (__int128 v44 = HTTPMessage::copyBody(v43)) == 0LL)
      {
LABEL_71:
        uint64_t v8 = 1LL;
        if (!v17) {
          return v8;
        }
        goto LABEL_74;
      }

      CFRelease(v44);
      goto LABEL_73;
    }

    uint64_t v32 = CFHash(v31);
    CFIndex v33 = MEMORY[0x1895F8858](v32);
    snprintf(v46, 0x11uLL, "%ld", v33);
    CFTypeRef v34 = strlen(v46);
    uint64_t v35 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)v46, v34);
    uint64_t v36 = *(HTTPMessage **)(-[HTTPProtocol _inner](this, "_inner") + 56);
    if (v36) {
      uint64_t v37 = HTTPMessage::copyBody(v36);
    }
    else {
      uint64_t v37 = 0LL;
    }
    int v42 = equalData(v37, v35);
    if (v37) {
      CFRelease(v37);
    }
    if (v35) {
      CFRelease(v35);
    }
  }

  else
  {
    uint64_t v38 = *(HTTPMessage **)(-[HTTPProtocol _inner](this, "_inner") + 56);
    if (v38) {
      CFStringRef v39 = HTTPMessage::copyBody(v38);
    }
    else {
      CFStringRef v39 = 0LL;
    }
    unsigned __int8 v40 = *(HTTPMessage **)(-[HTTPProtocol _inner](a2, "_inner") + 56);
    if (v40) {
      socklen_t v41 = HTTPMessage::copyBody(v40);
    }
    else {
      socklen_t v41 = 0LL;
    }
    int v42 = equalData(v39, v41);
    if (v39) {
      CFRelease(v39);
    }
    if (v41) {
      CFRelease(v41);
    }
  }

  if (v42) {
    goto LABEL_71;
  }
LABEL_73:
  uint64_t v8 = 0LL;
  if (v17) {
LABEL_74:
  }
    CFRelease(v17);
  return v8;
}

void sub_182A1CFA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

CFTypeRef ActualCredentialStorage::copyAllCredentials(ActualCredentialStorage *this)
{
  uint64_t v2 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 13) + 24LL))(*((void *)this + 13));
  uint64_t v3 = *((void *)this + 14);
  if (!v3) {
    return v2;
  }
  CFStringRef v4 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 32LL))(v3);
  CFTypeRef v5 = ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict(this, v2, v4);
  if (v4) {
    CFRelease(v4);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v5;
}

CFTypeRef ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain( ActualCredentialStorage *this, const __CFString *a2, uint64_t a3)
{
  CFStringRef v6 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 13) + 24LL))(*((void *)this + 13));
  uint64_t v7 = *((void *)this + 14);
  if (!v7) {
    return v6;
  }
  uint64_t v8 = (const void *)(*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(void *)v7 + 40LL))( v7,  a2,  a3);
  CFTypeRef v9 = ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict(this, v6, v8);
  if (v8) {
    CFRelease(v8);
  }
  if (v6) {
    CFRelease(v6);
  }
  return v9;
}

void ActualCredentialStorage::setCredentialForProtectionSpace( ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  CFStringRef v6 = (void *)(*(uint64_t (**)(ActualCredentialStorage *, _CFURLProtectionSpace *))(*(void *)this + 112LL))( this,  a3);
  (*(void (**)(ActualCredentialStorage *, const _CFURLCredential *, _CFURLProtectionSpace *))(*(void *)this + 104LL))( this,  a2,  a3);
  if (a2) {
    uint64_t v7 = (char *)a2 + 16;
  }
  else {
    uint64_t v7 = 0LL;
  }
  int v8 = *((_DWORD *)v7 + 9);
  if ((v8 - 3) < 2)
  {
    CFTypeRef v9 = (void *)*((void *)this + 14);
    if (v9)
    {
      uint64_t v10 = 6LL;
LABEL_11:
      (*(void (**)(void))(*v9 + 8 * v10))();
      goto LABEL_12;
    }

uint64_t ActualCredentialStorage::removeCredentialForProtectionSpace( ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const _CFURLCredential *, _CFURLProtectionSpace *))(*(void *)result
  }
                                                                                                 + 56LL))( result,  a2,  a3);
  return result;
}

uint64_t ActualCredentialStorage::copyDefaultCredentialForProtectionSpace( ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 13) + 56LL))(*((void *)this + 13));
  if (!result)
  {
    uint64_t result = *((void *)this + 14);
    if (result) {
      return (*(uint64_t (**)(uint64_t, _CFURLProtectionSpace *))(*(void *)result + 64LL))(result, a2);
    }
  }

  return result;
}

uint64_t ActualCredentialStorage::setDefaultCredentialForProtectionSpace( ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t result = (*(uint64_t (**)(void, void))(**((void **)this + 13) + 64LL))(*((void *)this + 13), 0LL);
  if (a2)
  {
    int v6 = *((_DWORD *)a2 + 13);
    if ((v6 - 3) < 2)
    {
      uint64_t v7 = *((void *)this + 14);
      if (v7)
      {
        int v8 = *(uint64_t (**)(void))(*(void *)v7 + 72LL);
        return v8();
      }

uint64_t ActualCredentialStorage::setUseSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 80LL))(result);
  }
  return result;
}

uint64_t ActualCredentialStorage::useSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 88LL))(result);
  }
  return result;
}

void non-virtual thunk to'ActualCredentialStorage::~ActualCredentialStorage(ActualCredentialStorage *this)
{
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 8));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 16));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 16));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 24));
}

{
  ActualCredentialStorage::~ActualCredentialStorage((ActualCredentialStorage *)((char *)this - 24));
}

CFTypeRef non-virtual thunk to'ActualCredentialStorage::copyCredentialsForProtectionSpace( ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return ActualCredentialStorage::copyCredentialsForProtectionSpace((ActualCredentialStorage *)((char *)this - 8), a2);
}

CFTypeRef non-virtual thunk to'ActualCredentialStorage::copyAllCredentials(ActualCredentialStorage *this)
{
  return ActualCredentialStorage::copyAllCredentials((ActualCredentialStorage *)((char *)this - 8));
}

CFTypeRef non-virtual thunk to'ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain( ActualCredentialStorage *this, const __CFString *a2, uint64_t a3)
{
  return ActualCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain( (ActualCredentialStorage *)((char *)this - 8),  a2,  a3);
}

void non-virtual thunk to'ActualCredentialStorage::setCredentialForProtectionSpace( ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

uint64_t non-virtual thunk to'ActualCredentialStorage::removeCredentialForProtectionSpace( ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t result = *((void *)this + 13);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const _CFURLCredential *, _CFURLProtectionSpace *))(*(void *)result
  }
                                                                                                 + 56LL))( result,  a2,  a3);
  return result;
}

uint64_t non-virtual thunk to'ActualCredentialStorage::copyDefaultCredentialForProtectionSpace( ActualCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 12) + 56LL))(*((void *)this + 12));
  if (!result)
  {
    uint64_t result = *((void *)this + 13);
    if (result) {
      return (*(uint64_t (**)(uint64_t, _CFURLProtectionSpace *))(*(void *)result + 64LL))(result, a2);
    }
  }

  return result;
}

uint64_t non-virtual thunk to'ActualCredentialStorage::setDefaultCredentialForProtectionSpace( ActualCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  return ActualCredentialStorage::setDefaultCredentialForProtectionSpace( (ActualCredentialStorage *)((char *)this - 8),  a2,  a3);
}

uint64_t non-virtual thunk to'ActualCredentialStorage::setUseSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result = *((void *)this + 13);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 80LL))(result);
  }
  return result;
}

uint64_t non-virtual thunk to'ActualCredentialStorage::useSystemKeychain(ActualCredentialStorage *this)
{
  uint64_t result = *((void *)this + 13);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 88LL))(result);
  }
  return result;
}

void ActualCredentialStorage::~ActualCredentialStorage(ActualCredentialStorage *this)
{
  *(void *)this = &off_189C02B00;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C02BA0;
  *((void *)this + 2) = &unk_189C02C08;
  *((void *)this + 3) = &unk_189C02C28;
  uint64_t v2 = *((void *)this + 13);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *((void *)this + 14);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  *(void *)this = &off_189C03088;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C030D8;
  *((void *)this + 2) = &unk_189C03140;
  *((void *)this + 3) = &unk_189C03160;
  CFStringRef v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 3) = off_189C12668;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  *((void *)this + 2) = off_189C19AE8;
}

void sub_182A1D6C8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = off_189C12668;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 32));
  *(void *)(v1 + 16) = off_189C19AE8;
  _Unwind_Resume(a1);
}

CFTypeRef ActualCredentialStorage::mergeProtectionSpaceToNameToCredentialsDict( ActualCredentialStorage *this, CFTypeRef cf, CFTypeRef a3)
{
  if (!cf)
  {
    unint64_t v29 = 0LL;
    CFTypeRef v28 = 0LL;
    CFTypeRef v30 = (const void **)v31;
    CFTypeRef v32 = 0LL;
    uint64_t v33 = 0LL;
    CFTypeRef v34 = (const void **)v35;
    goto LABEL_15;
  }

  CFTypeRef v28 = CFRetain(cf);
  unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)cf);
  unint64_t v29 = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    CFTypeRef v30 = 0LL;
    goto LABEL_9;
  }

  if (Count > 0x1E)
  {
    uint64_t v7 = (const void **)malloc(8 * Count);
    CFTypeRef v30 = v7;
    if (!v7) {
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v7 = (const void **)v31;
    CFTypeRef v30 = (const void **)v31;
  }

  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v7, 0LL);
LABEL_9:
  CFTypeRef v32 = CFRetain(cf);
  unint64_t v8 = CFDictionaryGetCount((CFDictionaryRef)cf);
  uint64_t v33 = v8;
  if (v8 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    CFTypeRef v34 = 0LL;
    goto LABEL_15;
  }

  if (v8 > 0x1E)
  {
    CFTypeRef v9 = (const void **)malloc(8 * v8);
    CFTypeRef v34 = v9;
    if (!v9) {
      goto LABEL_15;
    }
  }

  else
  {
    CFTypeRef v9 = (const void **)v35;
    CFTypeRef v34 = (const void **)v35;
  }

  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, 0LL, v9);
LABEL_15:
  if (!a3)
  {
    CFTypeRef v20 = 0LL;
    unint64_t v21 = 0LL;
    CFTypeRef v22 = (const void **)v23;
    CFTypeRef v24 = 0LL;
    uint64_t v25 = 0LL;
    CFTypeRef v26 = (const void **)v27;
    if (!v33) {
      goto LABEL_43;
    }
    goto LABEL_40;
  }

  CFTypeRef v20 = CFRetain(a3);
  unint64_t v10 = CFDictionaryGetCount((CFDictionaryRef)a3);
  unint64_t v21 = v10;
  if (v10 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    CFTypeRef v22 = 0LL;
    goto LABEL_24;
  }

  if (v10 > 0x1E)
  {
    uint64_t v11 = (const void **)malloc(8 * v10);
    CFTypeRef v22 = v11;
    if (!v11) {
      goto LABEL_24;
    }
  }

  else
  {
    uint64_t v11 = (const void **)v23;
    CFTypeRef v22 = (const void **)v23;
  }

  CFDictionaryGetKeysAndValues((CFDictionaryRef)a3, v11, 0LL);
LABEL_24:
  CFTypeRef v24 = CFRetain(a3);
  unint64_t v12 = CFDictionaryGetCount((CFDictionaryRef)a3);
  uint64_t v25 = v12;
  if (v12 - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    CFTypeRef v26 = 0LL;
    goto LABEL_30;
  }

  if (v12 > 0x1E)
  {
    int v13 = (const void **)malloc(8 * v12);
    CFTypeRef v26 = v13;
    if (!v13) {
      goto LABEL_30;
    }
  }

  else
  {
    int v13 = (const void **)v27;
    CFTypeRef v26 = (const void **)v27;
  }

  CFDictionaryGetKeysAndValues((CFDictionaryRef)a3, 0LL, v13);
LABEL_30:
  if (!v33)
  {
LABEL_42:
    CFTypeRef v18 = CFRetain(a3);
    goto LABEL_46;
  }

  if (!v25)
  {
LABEL_40:
    if (cf)
    {
      a3 = cf;
      goto LABEL_42;
    }

void sub_182A1DA58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void MemoryCredentialStorage::~MemoryCredentialStorage(MemoryCredentialStorage *this)
{
}

{
  *(void *)this = off_189C02C48;
  *((void *)this + 2) = &unk_189C02CA0;
  *((void *)this + 3) = &unk_189C02D08;
  *((void *)this + 6) = off_189C02D48;
  CFRelease(*((CFTypeRef *)this + 7));
  *((void *)this + 4) = off_189C02D28;
  CFRelease(*((CFTypeRef *)this + 5));
  *((void *)this + 3) = off_189C19AE8;
}

const __CFDictionary *MemoryCredentialStorage::copyCredentialsForProtectionSpace( CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  uint64_t result = (const __CFDictionary *)CFDictionaryGetValue(this[5], a2);
  if (result) {
    return CFDictionaryCreateCopy(this[1], result);
  }
  return result;
}

CFDictionaryRef MemoryCredentialStorage::copyAllCredentials(CFAllocatorRef *this)
{
  return CFDictionaryCreateCopy(this[1], this[5]);
}

uint64_t MemoryCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain( MemoryCredentialStorage *this, const __CFString *a2)
{
  return (*(uint64_t (**)(MemoryCredentialStorage *))(*(void *)this + 24LL))(this);
}

void MemoryCredentialStorage::setCredentialForProtectionSpace( CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  if (a2) {
    int v6 = (void *)((char *)a2 + 16);
  }
  else {
    int v6 = 0LL;
  }
  uint64_t v7 = (const void *)v6[7];
  if (v7 || (uint64_t v7 = (const void *)(*(uint64_t (**)(void *))(*v6 + 104LL))(v6), (v6[7] = v7) != 0LL))
  {
    Value = (void *)CFDictionaryGetValue(this[5], key);
    if (!Value)
    {
      Value = CFDictionaryCreateMutable(this[1], 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      CFDictionarySetValue(this[5], key, Value);
      if (Value) {
        CFRelease(Value);
      }
    }

    CFDictionarySetValue((CFMutableDictionaryRef)Value, v7, a2);
  }

void MemoryCredentialStorage::removeCredentialForProtectionSpace( CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  if (a2) {
    int v6 = (void *)((char *)a2 + 16);
  }
  else {
    int v6 = 0LL;
  }
  uint64_t v7 = (const void *)v6[7];
  if (v7 || (uint64_t v7 = (const void *)(*(uint64_t (**)(void *))(*v6 + 104LL))(v6), (v6[7] = v7) != 0LL))
  {
    Value = (__CFDictionary *)CFDictionaryGetValue(this[5], key);
    if (Value)
    {
      CFTypeRef v9 = Value;
      CFDictionaryRemoveValue(Value, v7);
      if (!CFDictionaryGetCount(v9)) {
        CFDictionaryRemoveValue(this[5], key);
      }
    }

    unint64_t v10 = CFDictionaryGetValue(this[7], key);
    if (v10)
    {
      if (CFEqual(v10, v7)) {
        CFDictionaryRemoveValue(this[7], key);
      }
    }
  }

CFTypeRef MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace( CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  Value = CFDictionaryGetValue(this[7], a2);
  if (Value
    && (CFTypeRef v5 = Value,
        int v6 = (const __CFDictionary *)CFDictionaryGetValue(this[5], a2),
        (uint64_t v7 = CFDictionaryGetValue(v6, v5)) != 0LL))
  {
    return CFRetain(v7);
  }

  else
  {
    return 0LL;
  }

void MemoryCredentialStorage::setDefaultCredentialForProtectionSpace( CFMutableDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *key)
{
  if (a2)
  {
    int v6 = (const void *)*((void *)a2 + 9);
    if (v6
      || (int v6 = (const void *)(*(uint64_t (**)(char *))(*((void *)a2 + 2) + 104LL))((char *)a2 + 16),
          (*((void *)a2 + 9) = v6) != 0LL))
    {
      CFDictionarySetValue(this[7], key, v6);
    }

    (*((void (**)(CFMutableDictionaryRef *, const _CFURLCredential *, _CFURLProtectionSpace *))*this + 5))( this,  a2,  key);
  }

  else
  {
    CFDictionaryRemoveValue(this[7], key);
  }

void non-virtual thunk to'MemoryCredentialStorage::~MemoryCredentialStorage(MemoryCredentialStorage *this)
{
}

{
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)((char *)this - 24));
}

void non-virtual thunk to'MemoryCredentialStorage::~MemoryCredentialStorage(CFAllocatorRef *this)
{
  uint64_t v2 = this - 2;
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)(this - 2));
  CFAllocatorDeallocate(*(this - 1), v2);
}

{
  CFAllocatorRef *v2;
  uint64_t v2 = this - 3;
  MemoryCredentialStorage::~MemoryCredentialStorage((MemoryCredentialStorage *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

const __CFDictionary *non-virtual thunk to'MemoryCredentialStorage::copyCredentialsForProtectionSpace( CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  return MemoryCredentialStorage::copyCredentialsForProtectionSpace(this - 2, a2);
}

CFDictionaryRef non-virtual thunk to'MemoryCredentialStorage::copyAllCredentials(CFAllocatorRef *this)
{
  return CFDictionaryCreateCopy(*(this - 1), this[3]);
}

uint64_t non-virtual thunk to'MemoryCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain( MemoryCredentialStorage *this, const __CFString *a2)
{
  return (*(uint64_t (**)(char *))(*((void *)this - 2) + 24LL))((char *)this - 16);
}

void non-virtual thunk to'MemoryCredentialStorage::setCredentialForProtectionSpace( CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

void non-virtual thunk to'MemoryCredentialStorage::removeCredentialForProtectionSpace( CFDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

CFTypeRef non-virtual thunk to'MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace( CFDictionaryRef *this, _CFURLProtectionSpace *a2)
{
  return MemoryCredentialStorage::copyDefaultCredentialForProtectionSpace(this - 2, a2);
}

void non-virtual thunk to'MemoryCredentialStorage::setDefaultCredentialForProtectionSpace( CFMutableDictionaryRef *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

uint64_t CredentialStorageBase::useSystemKeychain(CredentialStorageBase *this)
{
  return 0LL;
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace *,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = off_189C02D28;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<_CFURLProtectionSpace *,__CFDictionary *>::~RetainableTypedDict(CFTypeRef *a1)
{
  *a1 = off_189C02D28;
  CFRelease(a1[1]);
  operator delete(a1);
}

uint64_t RetainableTypedDict<_CFURLProtectionSpace *,__CFString const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = off_189C02D48;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<_CFURLProtectionSpace *,__CFString const*>::~RetainableTypedDict(CFTypeRef *a1)
{
  *a1 = off_189C02D48;
  CFRelease(a1[1]);
  operator delete(a1);
}

void sub_182A1E4C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void PersistentCredentialStorage::~PersistentCredentialStorage(PersistentCredentialStorage *this)
{
}

{
  const void *v2;
  *(void *)this = off_189C02D68;
  *((void *)this + 2) = &unk_189C02DD8;
  *((void *)this + 3) = &unk_189C02E40;
  uint64_t v2 = (const void *)*((void *)this + 4);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = off_189C19AE8;
}

uint64_t PersistentCredentialStorage::initialize(PersistentCredentialStorage *this, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0LL;
  }
  *((void *)this + 4) = v3;
  return 1LL;
}

__CFDictionary *PersistentCredentialStorage::copyCredentialsForProtectionSpace( PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  uint64_t v2 = a2;
  if (a2)
  {
    uint64_t v2 = (_CFURLProtectionSpace *)((char *)v2 + 16);
  }

  int v4 = *((_DWORD *)v2 + 14);
  if (v4 != 7)
  {
    StorageQuery::StorageQuery( (StorageQuery *)v10,  *((const __CFAllocator **)this + 1),  (const URLProtectionSpace *)v2,  *((_BYTE *)this + 40),  *((const __CFString **)this + 4));
    else {
      CFTypeRef v5 = 0LL;
    }
    StorageQuery::~StorageQuery((StorageQuery *)v10);
    return (__CFDictionary *)v5;
  }

  CFTypeRef v5 = (void *)PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace( *((PersistentCredentialStorage **)this + 1),  (const URLProtectionSpace *)v2);
  if (!v5) {
    return (__CFDictionary *)v5;
  }
  uint64_t v7 = (const __CFAllocator *)*((void *)this + 1);
  uint64_t v8 = v5[9];
  if (!v8)
  {
    uint64_t v8 = (*(uint64_t (**)(void *))(v5[2] + 104LL))(v5 + 2);
    v5[9] = v8;
  }

  MutableDictionary = cfTypeCreateMutableDictionary(v7, v8, v5, 0LL, 0LL);
  CFRelease(v5);
  return MutableDictionary;
}

void sub_182A1EC4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

CFTypeRef PersistentCredentialStorage::copyAllCredentials(PersistentCredentialStorage *this)
{
  else {
    CFTypeRef v1 = 0LL;
  }
  StorageQuery::~StorageQuery((StorageQuery *)v3);
  return v1;
}

void sub_182A1ECC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

CFMutableDictionaryRef PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain( PersistentCredentialStorage *this, CFStringRef theString1, int a3)
{
  if (theString1 && CFStringCompare(theString1, @"com.apple.cfnetwork", 0LL) == kCFCompareEqualTo)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v17 = 0;
      _os_log_impl(&dword_18298D000, v7, OS_LOG_TYPE_DEFAULT, "Enforcing strict auth scheme matching", v17, 2u);
    }

    int v6 = 1;
  }

  else
  {
    int v6 = 0;
  }

  uint64_t v8 = (const void **)MEMORY[0x18960BE68];
  if (a3)
  {
    StorageQuery::StorageQuery( (StorageQuery *)v17,  *((const __CFAllocator **)this + 1),  0LL,  *((_BYTE *)this + 40),  *((const __CFString **)this + 4));
    if (v6) {
      char v20 = 1;
    }
    CFTypeRef v9 = (const void *)*MEMORY[0x189604DE0];
    CFDictionarySetValue(theDict, *v8, (const void *)*MEMORY[0x189604DE0]);
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x18960BAA8], v9);
    else {
      unint64_t v10 = 0LL;
    }
    StorageQuery::~StorageQuery((StorageQuery *)v17);
  }

  else
  {
    unint64_t v10 = 0LL;
  }

  StorageQuery::StorageQuery( (StorageQuery *)v17,  *((const __CFAllocator **)this + 1),  0LL,  *((_BYTE *)this + 40),  *((const __CFString **)this + 4));
  if (v6) {
    char v20 = 1;
  }
  if (theString1)
  {
    CFDictionarySetValue(theDict, (const void *)*MEMORY[0x18960B820], theString1);
    CFDictionarySetValue(theDict, *v8, (const void *)*MEMORY[0x189604DE8]);
  }

  if (StorageQuery::performQuery((StorageQuery *)v17) && cf)
  {
    uint64_t v11 = (const __CFDictionary *)CFRetain(cf);
    unint64_t v12 = v11;
    BOOL v13 = v10 != 0LL;
    BOOL v14 = v11 != 0LL;
    if (v10 && v11)
    {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(*((CFAllocatorRef *)this + 1), 0LL, v10);
      if (MutableCopy) {
        CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)_merge_dictionaries, MutableCopy);
      }
      CFRelease(v10);
      CFRelease(v12);
      goto LABEL_37;
    }
  }

  else
  {
    BOOL v14 = 0;
    unint64_t v12 = 0LL;
    BOOL v13 = v10 != 0LL;
  }

  if (!v10 || (CFMutableDictionaryRef MutableCopy = v10, v14))
  {
    if (!v12) {
      BOOL v13 = 1;
    }
    if (v13) {
      CFMutableDictionaryRef MutableCopy = 0LL;
    }
    else {
      CFMutableDictionaryRef MutableCopy = v12;
    }
  }

void sub_182A1EF44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void PersistentCredentialStorage::setCredentialForProtectionSpace( PersistentCredentialStorage **this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, uint64_t a4, const __CFString *a5)
{
  if (a2)
  {
    if (*((_DWORD *)a2 + 13) != 3
      && *((_DWORD *)a2 + 13) != 4
      && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)CFTypeRef v9 = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "ephemeral credential in persistent store",  v9,  2u);
    }
  }

  if (*((_DWORD *)a3 + 18) == 7)
  {
    if (a2)
    {
      if (*((_DWORD *)a2 + 12) == 3) {
        PersistentCredentialStorage::setIdentityCredentialForProtectionSpace( this[1],  (const URLCredentialClientCertificate *)((char *)a2 + 16),  (const URLProtectionSpace *)((char *)a3 + 16));
      }
    }
  }

  else
  {
    if (a2)
    {
      uint64_t v8 = (const URLCredential *)((char *)a2 + 16);
    }

    else
    {
      uint64_t v8 = 0LL;
    }

    PersistentCredentialStorage::updateOrAddCredential( (PersistentCredentialStorage *)this,  v8,  (const URLProtectionSpace *)((char *)a3 + 16),  0,  a5);
  }

void PersistentCredentialStorage::removeCredentialForProtectionSpace( PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    int v6 = (char *)a3 + 16;
  }

  else
  {
    int v6 = 0LL;
  }

  uint64_t v7 = (const __CFString *)*((void *)v6 + 4);
  if (v7 && CFStringGetLength(v7) > 0)
  {
    if (*((_DWORD *)v6 + 14) == 7)
    {
      PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace( *((PersistentCredentialStorage **)this + 1),  (const URLProtectionSpace *)v6);
    }

    else if (a2)
    {
      if (!*((_DWORD *)a2 + 12))
      {
        uint64_t v8 = (const __CFDictionary *)*((void *)a2 + 12);
        if (v8)
        {
          CFTypeRef v9 = CFGetAllocator(a2);
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v9, 0LL, v8);
          updateAttrsWithValuesForModifyingStore( MutableCopy,  (const URLProtectionSpace *)v6,  (const URLCredential *)1,  *((void *)this + 4),  v11);
          unint64_t v12 = CFGetAllocator(a2);
          BOOL v13 = CFDictionaryCreateMutableCopy(v12, 0LL, MutableCopy);
          CFDictionarySetValue(v13, (const void *)*MEMORY[0x18960BB38], (const void *)*MEMORY[0x18960BB58]);
          int v14 = off_18C5AA310(v13);
          if (v14)
          {
            int v15 = v14;
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
            }
            uint64_t v16 = (os_log_s *)CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            {
              v17[0] = 67109378;
              v17[1] = v15;
              __int16 v18 = 2112;
              CFIndex v19 = v13;
              _os_log_debug_impl( &dword_18298D000,  v16,  OS_LOG_TYPE_DEBUG,  "CredStore - removeCredForProtSpace - Error removing cred.  Error=%d, query=%@",  (uint8_t *)v17,  0x12u);
            }
          }

          CFRelease(v13);
          CFRelease(MutableCopy);
        }
      }
    }
  }

  else
  {
    CFLog();
  }

CFTypeRef PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace( PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  uint64_t v2 = a2;
  if (a2)
  {
    uint64_t v2 = (_CFURLProtectionSpace *)((char *)v2 + 16);
  }

  if (*((_DWORD *)v2 + 14) == 7) {
    return (CFTypeRef)PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace( *((PersistentCredentialStorage **)this + 1),  (const URLProtectionSpace *)v2);
  }
  StorageQuery::StorageQuery( (StorageQuery *)v9,  *((const __CFAllocator **)this + 1),  (const URLProtectionSpace *)v2,  *((_BYTE *)this + 40),  *((const __CFString **)this + 4));
  Value = CFDictionaryGetValue(v9[3], (char *)v2 - 16);
  if (!Value) {
    goto LABEL_12;
  }
  int v6 = (const __CFDictionary *)StorageQuery::copyNameAndCredsDictForProtectionSpace(v9, (const URLProtectionSpace *)v2);
  CFTypeRef v7 = v6;
  if (v6)
  {
    uint64_t v8 = CFDictionaryGetValue(v6, Value);
    CFRelease(v7);
    if (v8)
    {
      CFTypeRef v7 = CFRetain(v8);
      goto LABEL_13;
    }

void sub_182A1F42C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void PersistentCredentialStorage::setDefaultCredentialForProtectionSpace( PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if (*((_DWORD *)a2 + 13) != 3
      && *((_DWORD *)a2 + 13) != 4
      && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v20[0]) = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "ephemeral credential in persistent store",  (uint8_t *)v20,  2u);
    }
  }

  int v6 = (const URLProtectionSpace *)((char *)a3 + 16);
  if (*((_DWORD *)a3 + 18) == 7)
  {
    if (a2)
    {
      if (*((_DWORD *)a2 + 12) == 3) {
        PersistentCredentialStorage::setIdentityCredentialForProtectionSpace( *((PersistentCredentialStorage **)this + 1),  (const URLCredentialClientCertificate *)((char *)a2 + 16),  (const URLProtectionSpace *)((char *)a3 + 16));
      }
    }

    else
    {
      PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace( *((PersistentCredentialStorage **)this + 1),  (const URLProtectionSpace *)((char *)a3 + 16));
    }

    return;
  }

  uint64_t v7 = (*(uint64_t (**)(PersistentCredentialStorage *, _CFURLProtectionSpace *))(*(void *)this + 64LL))( this,  a3);
  if (!v7)
  {
    int v14 = 1;
    if (!a2) {
      return;
    }
    goto LABEL_38;
  }

  uint64_t v10 = v7;
  uint64_t v11 = URLCredential_PasswordBased::safelyCast(v7, v8);
  if (v11)
  {
    BOOL v13 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 128LL))(v11);
    if (v13) {
      CFRelease(v13);
    }
  }

  if (a2 && CFEqual((CFTypeRef)v10, a2))
  {
    int v14 = 0;
    goto LABEL_34;
  }

  QueryFromProtectionSpaceAndCred = createQueryFromProtectionSpaceAndCred( *((const __CFAllocator **)this + 1),  v6,  (const URLCredential *)(v10 + 16),  *((void *)this + 4),  v12);
  AttrsFromProtectionSpaceAndCred = createAttrsFromProtectionSpaceAndCred( *((const __CFAllocator **)this + 1),  v6,  (const URLCredential *)(v10 + 16),  0);
  int v17 = off_18C5AA308(QueryFromProtectionSpaceAndCred, AttrsFromProtectionSpaceAndCred);
  if (v17)
  {
    int v18 = v17;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    CFIndex v19 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v20[0] = 67109634;
      v20[1] = v18;
      __int16 v21 = 2112;
      CFTypeRef v22 = QueryFromProtectionSpaceAndCred;
      __int16 v23 = 2112;
      CFTypeRef v24 = AttrsFromProtectionSpaceAndCred;
      _os_log_debug_impl( &dword_18298D000,  v19,  OS_LOG_TYPE_DEBUG,  "CredStore - setDefaultCredForProtSpace - Error removing cred.  Error=%d, query=%@, attrs=%@",  (uint8_t *)v20,  0x1Cu);
      if (!QueryFromProtectionSpaceAndCred) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }
  }

  if (QueryFromProtectionSpaceAndCred) {
LABEL_30:
  }
    CFRelease(QueryFromProtectionSpaceAndCred);
LABEL_31:
  if (AttrsFromProtectionSpaceAndCred) {
    CFRelease(AttrsFromProtectionSpaceAndCred);
  }
  int v14 = 1;
LABEL_34:
  CFRelease((CFTypeRef)v10);
  if (!a2) {
    return;
  }
LABEL_38:
  if (v14)
  {
    PersistentCredentialStorage::updateOrAddCredential(this, (const URLCredential *)((char *)a2 + 16), v6, 1, v9);
  }

uint64_t PersistentCredentialStorage::setUseSystemKeychain(uint64_t this, char a2)
{
  *(_BYTE *)(this + 40) = a2;
  return this;
}

uint64_t PersistentCredentialStorage::useSystemKeychain(PersistentCredentialStorage *this)
{
  return *((unsigned __int8 *)this + 40);
}

void non-virtual thunk to'PersistentCredentialStorage::~PersistentCredentialStorage( PersistentCredentialStorage *this)
{
}

{
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)((char *)this - 24));
}

void non-virtual thunk to'PersistentCredentialStorage::~PersistentCredentialStorage(CFAllocatorRef *this)
{
  uint64_t v2 = this - 2;
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)(this - 2));
  CFAllocatorDeallocate(*(this - 1), v2);
}

{
  CFAllocatorRef *v2;
  uint64_t v2 = this - 3;
  PersistentCredentialStorage::~PersistentCredentialStorage((PersistentCredentialStorage *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

__CFDictionary *non-virtual thunk to'PersistentCredentialStorage::copyCredentialsForProtectionSpace( PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return PersistentCredentialStorage::copyCredentialsForProtectionSpace( (PersistentCredentialStorage *)((char *)this - 16),  a2);
}

CFTypeRef non-virtual thunk to'PersistentCredentialStorage::copyAllCredentials( PersistentCredentialStorage *this)
{
  return PersistentCredentialStorage::copyAllCredentials((PersistentCredentialStorage *)((char *)this - 16));
}

CFMutableDictionaryRef non-virtual thunk to'PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain( PersistentCredentialStorage *this, const __CFString *a2, int a3)
{
  return PersistentCredentialStorage::copyAllCredentialsWithAccessControlGroupIncludeLegacyKeychain( (PersistentCredentialStorage *)((char *)this - 16),  a2,  a3);
}

void non-virtual thunk to'PersistentCredentialStorage::setCredentialForProtectionSpace( PersistentCredentialStorage **this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, uint64_t a4, const __CFString *a5)
{
}

void non-virtual thunk to'PersistentCredentialStorage::removeCredentialForProtectionSpace( PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

CFTypeRef non-virtual thunk to'PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace( PersistentCredentialStorage *this, _CFURLProtectionSpace *a2)
{
  return PersistentCredentialStorage::copyDefaultCredentialForProtectionSpace( (PersistentCredentialStorage *)((char *)this - 16),  a2);
}

void non-virtual thunk to'PersistentCredentialStorage::setDefaultCredentialForProtectionSpace( PersistentCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3)
{
}

uint64_t non-virtual thunk to'PersistentCredentialStorage::setUseSystemKeychain(uint64_t this, char a2)
{
  *(_BYTE *)(this + 24) = a2;
  return this;
}

uint64_t non-virtual thunk to'PersistentCredentialStorage::useSystemKeychain( PersistentCredentialStorage *this)
{
  return *((unsigned __int8 *)this + 24);
}

void sub_182A1F8B4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = off_189C19AE8;
  _Unwind_Resume(a1);
}

void PersistentCredentialStorage::removeIdentityPreferenceForProtectionSpace( PersistentCredentialStorage *this, const URLProtectionSpace *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(this, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFStringRef v4 = URLProtectionSpace::copyNameForIdentityPreference(a2);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B9F8], v4);
  CFRelease(v4);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BB38], (const void *)*MEMORY[0x18960BB50]);
  int v5 = off_18C5AA310(Mutable);
  if (v5)
  {
    int v6 = v5;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v8[0] = 67109378;
      v8[1] = v6;
      __int16 v9 = 2112;
      uint64_t v10 = Mutable;
      _os_log_debug_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_DEBUG,  "CredStore - removeIdentityPref - Error removing Identity prefs.  Error=%d, query=%@",  (uint8_t *)v8,  0x12u);
    }
  }

  CFRelease(Mutable);
}

void PersistentCredentialStorage::setIdentityCredentialForProtectionSpace( PersistentCredentialStorage *this, const URLCredentialClientCertificate *a2, const URLProtectionSpace *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(this, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFStringRef v6 = URLProtectionSpace::copyNameForIdentityPreference(a3);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B9F8], v6);
  CFRelease(v6);
  uint64_t v7 = (const void *)*MEMORY[0x18960BE88];
  uint64_t v8 = (const void *)(*(uint64_t (**)(const URLCredentialClientCertificate *))(*(void *)a2 + 120LL))(a2);
  CFDictionarySetValue(Mutable, v7, v8);
  int v9 = off_18C5AA300(Mutable, 0LL);
  if (v9)
  {
    int v10 = v9;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v11 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      v12[0] = 67109378;
      v12[1] = v10;
      __int16 v13 = 2112;
      int v14 = Mutable;
      _os_log_debug_impl( &dword_18298D000,  v11,  OS_LOG_TYPE_DEBUG,  "CredStore - setIdentityCred - Error adding cred.  Error=%d, attrs=%@",  (uint8_t *)v12,  0x12u);
    }
  }

  CFRelease(Mutable);
}

__CFDictionary *createQueryFromProtectionSpaceAndCred( const __CFAllocator *a1, const URLProtectionSpace *a2, const URLCredential *a3, uint64_t a4, const __CFString *a5)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  int v10 = (const void *)*MEMORY[0x18960BA18];
  AutoScalar::AutoScalar((AutoScalar *)&v24, (const __CFAllocator *)*((unsigned int *)a2 + 10));
  CFDictionarySetValue(Mutable, v10, value);
  CFTypeRef v24 = off_189C04A90;
  if (value) {
    CFRelease(value);
  }
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BB38], (const void *)*MEMORY[0x18960BB58]);
  uint64_t v11 = (const void *)*((void *)a2 + 4);
  if (a4)
  {
    CFStringRef v12 = CFStringCreateWithFormat(a1, 0LL, @"%@ (%@)", *((void *)a2 + 4), a4, v24);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BA80], v12);
    CFRelease(v12);
  }

  else
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (v11 && CFGetTypeID(v11) == TypeID) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BA80], v11);
    }
  }

  SecAttrProtocol = (const void *)URLProtectionSpace::getSecAttrProtocol((URLProtectionSpace *)*((unsigned int *)a2 + 11));
  CFTypeID v14 = CFStringGetTypeID();
  if (SecAttrProtocol && CFGetTypeID(SecAttrProtocol) == v14) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BA20], SecAttrProtocol);
  }
  if (*((_DWORD *)a3 + 9) == 4) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BAA8], (const void *)*MEMORY[0x189604DE8]);
  }
  if ((*((_DWORD *)a2 + 11) - 9) <= 0xFFFFFFFB)
  {
    uint64_t v15 = (const void *)*((void *)a2 + 6);
    CFTypeID v16 = CFStringGetTypeID();
    if (v15 && CFGetTypeID(v15) == v16) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BA70], v15);
    }
    int v17 = (const void *)*((void *)a3 + 7);
    if (v17)
    {
      CFTypeID v18 = CFStringGetTypeID();
    }

    else
    {
      int v17 = (const void *)(*(uint64_t (**)(const URLCredential *))(*(void *)a3 + 104LL))(a3);
      *((void *)a3 + 7) = v17;
      CFTypeID v18 = CFStringGetTypeID();
      if (!v17) {
        goto LABEL_22;
      }
    }

    if (CFGetTypeID(v17) == v18) {
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B870], v17);
    }
  }

void sub_182A1FE4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

__CFDictionary *createAttrsFromProtectionSpaceAndCred( const __CFAllocator *a1, const URLProtectionSpace *a2, const URLCredential *a3, int a4)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (a4) {
    int v9 = @"default";
  }
  else {
    int v9 = &stru_189C1D1D8;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (CFGetTypeID(v9) == TypeID) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B900], v9);
  }
  uint64_t v11 = (const void *)*((void *)a3 + 7);
  if (v11)
  {
    CFTypeID v12 = CFStringGetTypeID();
  }

  else
  {
    uint64_t v11 = (const void *)(*(uint64_t (**)(const URLCredential *))(*(void *)a3 + 104LL))(a3);
    *((void *)a3 + 7) = v11;
    CFTypeID v12 = CFStringGetTypeID();
    if (!v11) {
      goto LABEL_11;
    }
  }

  if (CFGetTypeID(v11) == v12) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B870], v11);
  }
LABEL_11:
  uint64_t v14 = URLCredential_PasswordBased::safelyCast((uint64_t)a3 - 16, v13);
  if (v14)
  {
    uint64_t v15 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 128LL))(v14);
    if (v15)
    {
      CFTypeID v16 = v15;
      CFIndex v29 = 1023LL;
      ptr = _CFStringGetOrCreateCString((uint64_t)a1, v15, v31, &v29, 0x8000100u);
      CFDataRef v17 = CFDataCreate(a1, (const UInt8 *)ptr, v29);
      if (v17)
      {
        CFTypeID v18 = CFDataGetTypeID();
        if (CFGetTypeID(v17) == v18) {
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BE78], v17);
        }
        CFRelease(v17);
      }

      CFRelease(v16);
      if (ptr && v31 != ptr) {
        CFAllocatorDeallocate(a1, ptr);
      }
    }
  }

  CFIndex v19 = (const void *)*((void *)a2 + 4);
  int v20 = (const __CFString *)*((void *)a3 + 7);
  if ((v20
     || (int v20 = (const __CFString *)(*(uint64_t (**)(const URLCredential *))(*(void *)a3 + 104LL))(a3),
         (*((void *)a3 + 7) = v20) != 0LL))
    && CFStringGetLength(v20))
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4714);
    }
    unsigned int v21 = CFBundleCopyLocalizedString( (CFBundleRef)__CFNGetCFNetworkBundle::bundle,  @"KEYCHAIN_LABEL_FORMAT%@%@",  @"%@ (%@)",  0LL);
    CFStringRef v22 = CFStringCreateWithFormat(a1, 0LL, v21, v19, v20);
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B9F8], v22);
    if (v21) {
      CFRelease(v21);
    }
    CFRelease(v22);
  }

  else
  {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B9F8], v19);
  }

  if (*((_DWORD *)a2 + 14) == 4)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4714);
    }
    CFStringRef v23 = CFBundleCopyLocalizedString( (CFBundleRef)__CFNGetCFNetworkBundle::bundle,  @"KEYCHAIN_WEB_FORM_PASSWORD",  @"Web form password",  0LL);
    CFTypeID v24 = CFStringGetTypeID();
    if (v23)
    {
      if (CFGetTypeID(v23) == v24) {
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B918], v23);
      }
      CFRelease(v23);
    }
  }

  if (*((_DWORD *)a3 + 9) == 4) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BAA8], (const void *)*MEMORY[0x189604DE8]);
  }
  if (!*((_DWORD *)a3 + 8))
  {
    CFTypeRef v26 = (const __CFDictionary *)*((void *)a3 + 10);
    if (v26)
    {
      uint64_t v27 = (const void *)*MEMORY[0x18960B910];
      if (CFDictionaryGetValue(v26, (const void *)*MEMORY[0x18960B910]))
      {
        Value = CFDictionaryGetValue(*((CFDictionaryRef *)a3 + 10), v27);
        CFDictionarySetValue(Mutable, v27, Value);
      }
    }
  }

  return Mutable;
}

void sub_182A20254( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  if (ptr)
  {
    if (v13 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }

  _Unwind_Resume(exception_object);
}

void PersistentCredentialStorage::updateOrAddCredential( PersistentCredentialStorage *this, const URLCredential *a2, const URLProtectionSpace *a3, int a4, const __CFString *a5)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  QueryFromProtectionSpaceAndCred = createQueryFromProtectionSpaceAndCred( *((const __CFAllocator **)this + 1),  a3,  a2,  *((void *)this + 4),  a5);
  AttrsFromProtectionSpaceAndCred = createAttrsFromProtectionSpaceAndCred( *((const __CFAllocator **)this + 1),  a3,  a2,  a4);
  int v11 = off_18C5AA308(QueryFromProtectionSpaceAndCred, AttrsFromProtectionSpaceAndCred);
  if (!v11) {
    goto LABEL_10;
  }
  int v12 = v11;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  __int16 v13 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    int v18 = 67109634;
    int v19 = v12;
    __int16 v20 = 2112;
    unsigned int v21 = QueryFromProtectionSpaceAndCred;
    __int16 v22 = 2112;
    CFStringRef v23 = AttrsFromProtectionSpaceAndCred;
    _os_log_debug_impl( &dword_18298D000,  v13,  OS_LOG_TYPE_DEBUG,  "CredStore - updateOrAddCredential - Error update cred.  Error=%d, query=%@, attrs=%@",  (uint8_t *)&v18,  0x1Cu);
  }

  updateAttrsWithValuesForModifyingStore(AttrsFromProtectionSpaceAndCred, a3, 0LL, *((void *)this + 4), v14);
  int v15 = off_18C5AA300(AttrsFromProtectionSpaceAndCred, 0LL);
  if (!v15) {
    goto LABEL_10;
  }
  int v16 = v15;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  CFDataRef v17 = (os_log_s *)CFNLog::logger;
  if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
LABEL_10:
    if (!QueryFromProtectionSpaceAndCred) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

  int v18 = 67109378;
  int v19 = v16;
  __int16 v20 = 2112;
  unsigned int v21 = AttrsFromProtectionSpaceAndCred;
  _os_log_debug_impl( &dword_18298D000,  v17,  OS_LOG_TYPE_DEBUG,  "CredStore - updateOrAddCredential - Error add cred.  Error=%d, attrs=%@",  (uint8_t *)&v18,  0x12u);
  if (QueryFromProtectionSpaceAndCred) {
LABEL_11:
  }
    CFRelease(QueryFromProtectionSpaceAndCred);
LABEL_12:
  if (AttrsFromProtectionSpaceAndCred) {
    CFRelease(AttrsFromProtectionSpaceAndCred);
  }
}

void updateAttrsWithValuesForModifyingStore( __CFDictionary *a1, const URLProtectionSpace *a2, const URLCredential *a3, uint64_t a4, const __CFString *a5)
{
  char v6 = (char)a3;
  CFDictionarySetValue(a1, (const void *)*MEMORY[0x18960BB38], (const void *)*MEMORY[0x18960BB58]);
  int v9 = (const void *)*((void *)a2 + 4);
  if (a4)
  {
    CFStringRef v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"%@ (%@)", *((void *)a2 + 4), a4);
    CFDictionarySetValue(a1, (const void *)*MEMORY[0x18960BA80], v10);
    CFRelease(v10);
  }

  else
  {
    CFTypeID TypeID = CFStringGetTypeID();
    if (v9 && CFGetTypeID(v9) == TypeID) {
      CFDictionarySetValue(a1, (const void *)*MEMORY[0x18960BA80], v9);
    }
  }

  int v11 = (const void *)*MEMORY[0x18960BA18];
  AutoScalar::AutoScalar((AutoScalar *)&v24, (const __CFAllocator *)*((unsigned int *)a2 + 10));
  CFDictionarySetValue(a1, v11, value);
  uint64_t v24 = off_189C04A90;
  if (value) {
    CFRelease(value);
  }
  int v12 = *((_DWORD *)a2 + 14);
  if (v12 != 2)
  {
    if (v12 == 4)
    {
      __int16 v13 = (const void *)*MEMORY[0x18960B888];
      uint64_t v14 = (const void *)*MEMORY[0x18960B898];
      int v15 = a1;
LABEL_17:
      CFDictionarySetValue(v15, v13, v14);
      goto LABEL_18;
    }

    goto LABEL_13;
  }

  unsigned int v17 = *((_DWORD *)a2 + 11) - 1;
  if (v17 > 5)
  {
LABEL_13:
    int v18 = (const void **)MEMORY[0x18960B890];
    goto LABEL_14;
  }

  int v18 = (const void **)qword_189C02E70[v17];
LABEL_14:
  CFDictionarySetValue(a1, (const void *)*MEMORY[0x18960B888], *v18);
  int v19 = (const void *)*((void *)a2 + 6);
  CFTypeID v20 = CFStringGetTypeID();
  if (v19 && CFGetTypeID(v19) == v20)
  {
    __int16 v13 = (const void *)*MEMORY[0x18960BA70];
    int v15 = a1;
    uint64_t v14 = v19;
    goto LABEL_17;
  }

void sub_182A206F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PersistentCredentialStorage::copyIdentityCredentialForProtectionSpace( PersistentCredentialStorage *this, const URLProtectionSpace *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(this, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFStringRef v4 = URLProtectionSpace::copyNameForIdentityPreference(a2);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960B9F8], v4);
  CFRelease(v4);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BE30], (const void *)*MEMORY[0x189604DE8]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x18960BB38], (const void *)*MEMORY[0x18960BB50]);
  CFTypeRef cf = 0LL;
  int v5 = off_18C5AA2F8(Mutable, &cf);
  if (v5)
  {
    int v6 = v5;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109378;
      int v13 = v6;
      __int16 v14 = 2112;
      int v15 = Mutable;
      _os_log_debug_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_DEBUG,  "CredStore - copyIdentPrefs - Error copying Identity cred.  Error=%d, query=%@",  buf,  0x12u);
    }

    goto LABEL_6;
  }

  if (!cf)
  {
LABEL_6:
    uint64_t v8 = 0LL;
    goto LABEL_7;
  }

  CFTypeID v10 = CFGetTypeID(cf);
  if (v10 != SecIdentityGetTypeID())
  {
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_6;
  }

  uint64_t v8 = CFURLCredentialCreateWithIdentityAndCertificateArray(*MEMORY[0x189604DB0], cf, 0LL, 3);
  if (cf) {
    CFRelease(cf);
  }
LABEL_7:
  CFRelease(Mutable);
  return v8;
}

void StorageQuery::StorageQuery( StorageQuery *this, const __CFAllocator *a2, const URLProtectionSpace *a3, char a4, const __CFString *a5)
{
  *((_BYTE *)this + 49) = a4;
  *(void *)this = off_189C02E60;
  *((_BYTE *)this + 50) = 0;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = cfTypeCreateMutableDictionary(a2, *MEMORY[0x18960BDA0], *MEMORY[0x18960BDA8], 0LL, 0LL);
  *((void *)this + 2) = CFDictionaryCreateMutable(a2, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a2, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  *((void *)this + 4) = a2;
  *((void *)this + 5) = a5;
  *((void *)this + 3) = Mutable;
  *((_BYTE *)this + 4_Block_object_dispose(va, 8) = 0;
  if (!a3)
  {
LABEL_17:
    CFDictionarySetValue( *((CFMutableDictionaryRef *)this + 1),  (const void *)*MEMORY[0x18960BE18],  (const void *)*MEMORY[0x189604DE8]);
    int v15 = (const void **)MEMORY[0x18960BB58];
    uint64_t v16 = (const void **)MEMORY[0x18960BB38];
    goto LABEL_18;
  }

  CFTypeID v10 = (const void *)*((void *)a3 + 4);
  if (a5)
  {
    CFStringRef v11 = CFStringCreateWithFormat(a2, 0LL, @"%@ (%@)", *((void *)a3 + 4), a5);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x18960BA80], v11);
    CFRelease(v11);
  }

  else if (v10)
  {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x18960BA80], v10);
  }

  SecAttrProtocol = (const void *)URLProtectionSpace::getSecAttrProtocol((URLProtectionSpace *)*((unsigned int *)a3 + 11));
  if (SecAttrProtocol) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x18960BA20], SecAttrProtocol);
  }
  int v13 = (const void *)*((void *)a3 + 6);
  if (v13) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), (const void *)*MEMORY[0x18960BA70], v13);
  }
  int v14 = *((_DWORD *)a3 + 14);
  if (v14 == 2)
  {
    unsigned int v17 = *((_DWORD *)a3 + 11);
    if (v17 <= 6 && ((1 << v17) & 0x62) != 0) {
      CFDictionarySetValue( *((CFMutableDictionaryRef *)this + 1),  (const void *)*MEMORY[0x18960B888],  (const void *)*MEMORY[0x18960B8A0]);
    }
    goto LABEL_17;
  }

  if (v14 == 8)
  {
    *((_BYTE *)this + 4_Block_object_dispose(va, 8) = 1;
    goto LABEL_19;
  }

  if (v14 != 7) {
    goto LABEL_17;
  }
  CFDictionarySetValue( *((CFMutableDictionaryRef *)this + 1),  (const void *)*MEMORY[0x18960BB38],  (const void *)*MEMORY[0x18960BB50]);
  int v15 = (const void **)MEMORY[0x189604DE8];
  uint64_t v16 = (const void **)MEMORY[0x18960BE30];
LABEL_18:
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), *v16, *v15);
LABEL_19:
  CFDictionarySetValue( *((CFMutableDictionaryRef *)this + 1),  (const void *)*MEMORY[0x18960BAA8],  (const void *)*MEMORY[0x18960BAB0]);
}

void sub_182A20B68(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  _Unwind_Resume(a1);
}

uint64_t StorageQuery::performQuery(StorageQuery *this)
{
  uint64_t v98 = *MEMORY[0x1895F89C0];
  CFTypeRef cf = 0LL;
  int v1 = off_18C5AA2F8(*((void *)this + 1), &cf);
  if (*((_BYTE *)this + 48)) {
    BOOL v2 = 0;
  }
  else {
    BOOL v2 = v1 == 0;
  }
  if (!v2 || cf == 0LL)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    CFStringRef v4 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v50 = *((void *)this + 1);
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v1;
      *(_WORD *)__int128 v82 = 2112;
      *(void *)&v82[2] = v50;
      _os_log_debug_impl( &dword_18298D000,  v4,  OS_LOG_TYPE_DEBUG,  "CredStore - performQuery - Error copying matching creds.  Error=%d, query=%@",  buf,  0x12u);
    }

    uint64_t result = (uint64_t)cf;
    if (cf)
    {
      CFRelease(cf);
      return 0LL;
    }
  }

  else
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    CFIndex v73 = Count;
    if (Count >= 1)
    {
      CFIndex v7 = 0LL;
      key = (void *)*MEMORY[0x18960BA80];
      uint64_t v72 = *MEMORY[0x18960BA18];
      uint64_t v71 = *MEMORY[0x18960BA20];
      uint64_t v70 = *MEMORY[0x18960B888];
      uint64_t v69 = *MEMORY[0x18960BA70];
      uint64_t v68 = *MEMORY[0x18960B900];
      CFTypeRef cf2 = (CFTypeRef)*MEMORY[0x18960BA40];
      CFTypeRef v63 = (CFTypeRef)*MEMORY[0x18960BA50];
      CFTypeRef v59 = (CFTypeRef)*MEMORY[0x18960BA28];
      CFTypeRef v57 = (CFTypeRef)*MEMORY[0x18960BA38];
      CFTypeRef v55 = (CFTypeRef)*MEMORY[0x18960BA48];
      CFTypeRef v53 = (CFTypeRef)*MEMORY[0x18960BA58];
      CFTypeRef v52 = (CFTypeRef)*MEMORY[0x18960BA30];
      CFTypeRef v51 = (CFTypeRef)*MEMORY[0x18960BA60];
      CFTypeRef v64 = (CFTypeRef)*MEMORY[0x18960B890];
      CFTypeRef v61 = (CFTypeRef)*MEMORY[0x18960B8A0];
      CFTypeRef v58 = (CFTypeRef)*MEMORY[0x18960B8A8];
      CFTypeRef v56 = (CFTypeRef)*MEMORY[0x18960B898];
      CFTypeRef v54 = (CFTypeRef)*MEMORY[0x18960B8B0];
      v65 = (void *)*MEMORY[0x18960B870];
      uint64_t v62 = (void *)*MEMORY[0x18960BE78];
      CFAbsoluteTime v60 = (void *)*MEMORY[0x18960BAA8];
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v7);
        if (ValueAtIndex)
        {
          CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, ValueAtIndex);
          CFTypeID v10 = MutableCopy;
          if (MutableCopy)
          {
            Value = (const __CFString *)CFDictionaryGetValue(MutableCopy, key);
            int v12 = Value;
            if (Value && (CFTypeID v13 = CFGetTypeID(Value), v13 == CFStringGetTypeID()))
            {
              CFIndex location = CFStringFind(v12, @" ", 0LL).location;
              CFIndex v15 = location;
              if (*((void *)this + 5))
              {
                if (location == -1) {
                  goto LABEL_114;
                }
                uint64_t v16 = CFStringGetLength(v12) - location;
                if (v16 < 4) {
                  goto LABEL_114;
                }
                v99.length = v16 - 3;
                v99.CFIndex location = v15 + 2;
                CFStringRef v17 = CFStringCreateWithSubstring(*((CFAllocatorRef *)this + 4), v12, v99);
                if (!v17) {
                  goto LABEL_114;
                }
                if (CFStringCompare(*((CFStringRef *)this + 5), v17, 0LL))
                {
                  CFRelease(v17);
LABEL_114:
                  CFRelease(v10);
                  goto LABEL_115;
                }

                v100.CFIndex location = 0LL;
                v100.length = v15;
                CFStringRef v25 = CFStringCreateWithSubstring(*((CFAllocatorRef *)this + 4), v12, v100);
                CFDictionarySetValue(v10, key, v25);
                if (v25) {
                  CFRelease(v25);
                }
                CFRelease(v17);
              }

              else if (location != -1)
              {
                goto LABEL_114;
              }
            }

            else if (*((void *)this + 5))
            {
              goto LABEL_114;
            }
          }
        }

        else
        {
          CFTypeID v10 = 0LL;
        }

        uint64_t Instance = _CFRuntimeCreateInstance();
        *(_OWORD *)(Instance + 16) = 0u;
        *(_OWORD *)(Instance + 80) = 0u;
        *(_OWORD *)(Instance + 96) = 0u;
        *(void *)(Instance + 112) = 0LL;
        *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
        *(_OWORD *)(Instance + 64) = 0u;
        *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
        *(void *)(Instance + 16) = &off_189C0EA00;
        *(void *)(Instance + 24) = &unk_189C0EA58;
        *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3780];
        *(_BYTE *)(Instance + 96) = 0;
        *(_BYTE *)(Instance + 104) = 0;
        *(void *)(Instance + 112) = 1LL;
        char v19 = *((_BYTE *)this + 50);
        *(_OWORD *)CFTypeRef cf1 = 0u;
        *(_OWORD *)CFStringRef theString = 0u;
        *(_OWORD *)number = 0u;
        *(void *)buf = key;
        *(void *)__int128 v82 = CFStringGetTypeID();
        v82[8] = 1;
        uint64_t v83 = v72;
        CFTypeID TypeID = CFNumberGetTypeID();
        char v85 = 1;
        uint64_t v86 = v71;
        CFTypeID v87 = CFStringGetTypeID();
        char v88 = 1;
        uint64_t v89 = v70;
        CFTypeID v90 = CFStringGetTypeID();
        char v91 = 0;
        uint64_t v92 = v69;
        CFTypeID v93 = CFStringGetTypeID();
        char v94 = 0;
        uint64_t v95 = v68;
        uint64_t v20 = 0LL;
        CFTypeID v96 = CFStringGetTypeID();
        char v97 = 0;
        unsigned int v21 = (const void **)&v82[8];
        do
        {
          CFTypeID v22 = (const __CFNumber *)CFDictionaryGetValue(v10, *(v21 - 2));
          number[v20] = v22;
          if (v22)
          {
            if ((const void *)CFGetTypeID(v22) != *(v21 - 1))
            {
              if (*(_BYTE *)v21) {
                goto LABEL_113;
              }
              number[v20] = 0LL;
            }
          }

          else if (*(_BYTE *)v21)
          {
            goto LABEL_113;
          }

          v21 += 3;
          ++v20;
        }

        while (v20 != 6);
        CFTypeRef v23 = cf1[0];
        if (!cf1[0]) {
          goto LABEL_113;
        }
        if (CFEqual(cf1[0], cf2))
        {
          int v24 = 1;
        }

        else if (CFEqual(v23, v63))
        {
          int v24 = 2;
        }

        else if (CFEqual(v23, v59))
        {
          int v24 = 3;
        }

        else if (CFEqual(v23, v57))
        {
          int v24 = 4;
        }

        else if (CFEqual(v23, v55))
        {
          int v24 = 5;
        }

        else if (CFEqual(v23, v53))
        {
          int v24 = 6;
        }

        else if (CFEqual(v23, v52))
        {
          int v24 = 7;
        }

        else
        {
          if (!CFEqual(v23, v51)) {
            goto LABEL_113;
          }
          int v24 = 8;
        }

        CFTypeRef v26 = cf1[1];
        if (!cf1[1] || CFEqual(cf1[1], v64)) {
          break;
        }
        if (CFEqual(v26, v61))
        {
          int v27 = 2;
        }

        else if (CFEqual(v26, v58))
        {
          int v27 = 3;
        }

        else if (CFEqual(v26, v56))
        {
          int v27 = 4;
        }

        else
        {
          if (!CFEqual(v26, v54)) {
            break;
          }
          int v27 = 5;
        }

LABEL_63:
        CFStringRef v28 = theString[0];
        if (theString[0])
        {
          if (CFStringGetLength(theString[0])) {
            CFIndex v29 = v28;
          }
          else {
            CFIndex v29 = 0LL;
          }
        }

        else
        {
          CFIndex v29 = 0LL;
        }

        uint64_t valuePtr = 0LL;
        CFNumberGetValue(number[1], kCFNumberCFIndexType, &valuePtr);
        int v30 = valuePtr;
        if (theString[1]) {
          BOOL v67 = CFEqual(theString[1], @"default") != 0;
        }
        else {
          BOOL v67 = 0;
        }
        *(_BYTE *)(Instance + 96) = v19;
        URLProtectionSpace::initialize(Instance + 16, (const __CFString *)number[0], v30, v24, v29, v27);
        unint64_t v31 = CFDictionaryGetValue(v10, v65);
        uint64_t v32 = v31;
        if (v31)
        {
          CFTypeID v33 = CFGetTypeID(v31);
          if (v33 == CFStringGetTypeID())
          {
            CFTypeRef v34 = (const __CFData *)CFDictionaryGetValue(v10, v62);
            uint64_t v35 = v34;
            if (!v34
              || (CFTypeID v36 = CFGetTypeID(v34), v36 != CFDataGetTypeID())
              || (uint64_t v37 = (const __CFAllocator *)*((void *)this + 4),
                  (CFStringRef v39 = (const __CFDictionary *)CFPropertyListCreateWithData(v37, v35, 0LL, 0LL, 0LL)) == 0LL)
              || (unsigned __int8 v40 = URLCredential::createFromPropertyList(v37, v39, v38), CFRelease(v39), !v40))
            {
              uint64_t v41 = _CFRuntimeCreateInstance();
              unsigned __int8 v40 = (uint64_t (***)(URLCredentialClientCertificate *__hidden, const CFObject *))v41;
              if (v41)
              {
                *(_OWORD *)(v41 + 16) = 0u;
                unsigned __int8 v40 = (uint64_t (***)(URLCredentialClientCertificate *__hidden, const CFObject *))(v41 + 16);
                *(void *)(v41 + 112) = 0LL;
                *(_OWORD *)(v41 + 80) = 0u;
                *(_OWORD *)(v41 + 96) = 0u;
                *(_OWORD *)(v41 + 4_Block_object_dispose(va, 8) = 0u;
                *(_OWORD *)(v41 + 64) = 0u;
                *(_OWORD *)(v41 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
              }

              *((_DWORD *)v40 + _Block_object_dispose(va, 8) = 0;
              *((_BYTE *)v40 + 4_Block_object_dispose(va, 8) = 0;
              v40[7] = 0LL;
              v40[5] = 0LL;
              *unsigned __int8 v40 = &off_189C11DC8;
              v40[1] = (uint64_t (**)(URLCredentialClientCertificate *__hidden, const CFObject *))&unk_189C11E70;
              CFTypeRef v40[2] = (uint64_t (**)(URLCredentialClientCertificate *__hidden, const CFObject *))&gConstantCFStringValueTable[3773];
              v40[3] = (uint64_t (**)(URLCredentialClientCertificate *__hidden, const CFObject *))&unk_189C11EA0;
              *((_BYTE *)v40 + 8_Block_object_dispose(va, 8) = 0;
              if (!v10) {
                goto LABEL_88;
              }
              int v42 = (const __CFBoolean *)CFDictionaryGetValue(v10, v60);
              if (v42 && CFBooleanGetValue(v42)) {
                uint64_t v43 = 4LL;
              }
              else {
LABEL_88:
              }
                uint64_t v43 = 3LL;
              if (!((unsigned int (*)(uint64_t (***)(URLCredentialClientCertificate *__hidden, const CFObject *), const void *, void, uint64_t, const __CFDictionary *))(*v40)[18])( v40,  v32,  0LL,  v43,  v10)) {
                goto LABEL_112;
              }
            }

            if (*((_BYTE *)this + 49)) {
              (*v40)[10]((URLCredentialClientCertificate *)v40, (const CFObject *)1);
            }
            if (*((void *)this + 5)) {
              ((void (*)(uint64_t (***)(URLCredentialClientCertificate *__hidden, const CFObject *)))(*v40)[11])(v40);
            }
            __int128 v44 = (__CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 2), (const void *)Instance);
            if (v44)
            {
              __int128 v45 = v40[7];
              if (!v45)
              {
                __int128 v45 = (uint64_t (**)(URLCredentialClientCertificate *__hidden, const CFObject *))((uint64_t (*)(uint64_t (***)(URLCredentialClientCertificate *__hidden, const CFObject *)))(*v40)[13])(v40);
                v40[7] = v45;
              }

              if (!CFDictionaryContainsKey(v44, v45))
              {
                __int128 v46 = v40[7];
                if (!v46)
                {
                  __int128 v46 = (uint64_t (**)(URLCredentialClientCertificate *__hidden, const CFObject *))((uint64_t (*)(uint64_t (***)(URLCredentialClientCertificate *__hidden, const CFObject *)))(*v40)[13])(v40);
                  v40[7] = v46;
                }

                CFDictionarySetValue(v44, v46, v40 - 2);
              }

              if (!v67) {
                goto LABEL_112;
              }
            }

            else
            {
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( *((CFAllocatorRef *)this + 4),  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 2), (const void *)Instance, Mutable);
              __int128 v48 = v40[7];
              if (!v48)
              {
                __int128 v48 = (uint64_t (**)(URLCredentialClientCertificate *__hidden, const CFObject *))((uint64_t (*)(uint64_t (***)(URLCredentialClientCertificate *__hidden, const CFObject *)))(*v40)[13])(v40);
                v40[7] = v48;
              }

              CFDictionarySetValue(Mutable, v48, v40 - 2);
              CFRelease(Mutable);
            }

            __int128 v49 = v40[7];
            if (v49
              || (__int128 v49 = (uint64_t (**)(URLCredentialClientCertificate *__hidden, const CFObject *))((uint64_t (*)(uint64_t (***)(URLCredentialClientCertificate *__hidden, const CFObject *)))(*v40)[13])(v40),
                  (v40[7] = v49) != 0LL))
            {
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 3), (const void *)Instance, v49);
            }

  __int128 v49 = v56;
  if (v56)
  {
    uint64_t v50 = (unint64_t *)&v56->__shared_owners_;
    do
      CFTypeRef v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }

  *(void *)buf = &v57;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
}

LABEL_121:
    CFRelease(cf);
    return 1LL;
  }

  return result;
}

void sub_182A21604(_Unwind_Exception *a1)
{
  if (v1) {
    CFRelease(v1);
  }
  CFRelease(v2);
  CFRelease(v3);
  _Unwind_Resume(a1);
}

void StorageQuery::~StorageQuery(StorageQuery *this)
{
  *(void *)this = off_189C02E60;
  BOOL v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  CFStringRef v4 = (const void *)*((void *)this + 3);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)this = off_189C19AE8;
}

{
  void *v1;
  StorageQuery::~StorageQuery(this);
  operator delete(v1);
}

void sub_182A216D0(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  _Unwind_Resume(a1);
}

CFTypeRef StorageQuery::copyNameAndCredsDictForProtectionSpace( CFDictionaryRef *this, const URLProtectionSpace *a2)
{
  Value = CFDictionaryGetValue(this[2], (char *)a2 - 16);
  if (Value) {
    return CFRetain(Value);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  int v6 = (URLProtectionSpace *)(Instance + 16);
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(void *)(Instance + 112) = 0LL;
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(Instance + 64) = 0u;
  *(void *)(Instance + 16) = &off_189C0EA00;
  *(void *)(Instance + 24) = &unk_189C0EA58;
  *(_BYTE *)(Instance + 96) = 0;
  *(_BYTE *)(Instance + 104) = 0;
  *(void *)(Instance + 112) = 1LL;
  uint64_t v8 = *((void *)a2 + 3);
  CFTypeRef v7 = (CFTypeRef)*((void *)a2 + 4);
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3780];
  *(void *)(Instance + 40) = v8;
  if (v7) {
    CFTypeRef v7 = CFRetain(v7);
  }
  *(void *)(Instance + 4_Block_object_dispose(va, 8) = v7;
  *(void *)(Instance + 56) = *((void *)a2 + 5);
  CFTypeRef v9 = (CFTypeRef)*((void *)a2 + 6);
  if (v9) {
    CFTypeRef v9 = CFRetain(v9);
  }
  *(void *)(Instance + 64) = v9;
  *(_DWORD *)(Instance + 72) = *((_DWORD *)a2 + 14);
  CFTypeRef v10 = (CFTypeRef)*((void *)a2 + 8);
  if (v10) {
    CFTypeRef v10 = CFRetain(v10);
  }
  *(void *)(Instance + 80) = v10;
  URLProtectionSpace::calcHash(v6);
  *(_DWORD *)(Instance + 56) = 0;
  URLProtectionSpace::calcHash(v6);
  Value = CFDictionaryGetValue(this[2], (const void *)Instance);
  CFRelease((CFTypeRef)Instance);
  if (Value) {
    return CFRetain(Value);
  }
  else {
    return 0LL;
  }
}

void _merge_dictionaries(const void *a1, CFTypeRef cf, __CFDictionary *a3)
{
  if (a1)
  {
    if (cf)
    {
      CFTypeID v6 = CFGetTypeID(cf);
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (a3)
      {
        if (v6 == TypeID) {
          CFDictionarySetValue(a3, a1, cf);
        }
      }
    }
  }

void sub_182A21A10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___Z23newCookieStorageEnabledv_block_invoke()
{
  uint64_t result = _os_feature_enabled_impl();
  newCookieStorageEnabled(void)::enabled = result;
  return result;
}

void sub_182A21D04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A2227C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GetSvcTicketForHostWithPassword( double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  double Helper_x8__GSSCreateCredentialFromUUID = gotLoadHelper_x8__GSSCreateCredentialFromUUID(a1);
  if (!*(void *)(v18 + 3040)) {
    return 1LL;
  }
  char v19 = v16;
  uint64_t v20 = v15;
  unsigned int v21 = v14;
  CFTypeID v22 = v13;
  CFTypeRef v23 = v12;
  int v24 = v11;
  CFStringRef v25 = v10;
  size_t v53 = 0LL;
  CFTypeRef v54 = 0LL;
  uint64_t v51 = 0LL;
  uint64_t v52 = 0LL;
  uint64_t v49 = 0LL;
  uint64_t v50 = 0LL;
  uint64_t inited = 0LL;
  int v47 = 0;
  _DWORD *v14 = 0;
  if (v10 && !strcmp(v10, "localhost")) {
    CFStringRef v25 = 0LL;
  }
  if (a10)
  {
    uint64_t inited = GSSCreateCredentialFromUUID_delayInitStub(Helper_x8__GSSCreateCredentialFromUUID);
  }

  else if (v23)
  {
    __s = 0LL;
    __int128 v46 = (char *)v23;
    size_t v45 = strlen(v23);
    uint64_t v27 = gss_import_name_delayInitStub(v29);
    if ((_DWORD)v27) {
      goto LABEL_29;
    }
    if (v19)
    {
      int v30 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFStringRef v31 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v19, 0x8000100u);
      if (v31)
      {
        CFStringRef v33 = v31;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v30, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
        if (Mutable)
        {
          uint64_t v35 = Mutable;
          CFDictionarySetValue(Mutable, @"kGSSICPassword", v33);
          gss_aapl_initial_cred_delayInitStub(v36);
          CFRelease(v35);
        }

        CFRelease(v33);
      }

      gss_release_name_delayInitStub(v32);
    }

    else
    {
      uint64_t v27 = gss_acquire_cred_delayInitStub(v28);
      gss_release_name_delayInitStub(v42);
      if ((_DWORD)v27) {
        goto LABEL_29;
      }
    }
  }

  if (v22)
  {
    __int128 v46 = (char *)v22;
    size_t v45 = strlen(v22);
    uint64_t v27 = gss_import_name_delayInitStub(v26);
    if ((_DWORD)v27) {
      goto LABEL_29;
    }
  }

  else
  {
    asprintf(&__s, "%s@%s", v24, v25);
    __int128 v46 = __s;
    size_t v45 = strlen(__s);
    uint64_t v27 = gss_import_name_delayInitStub(v37);
    free(__s);
    if ((_DWORD)v27) {
      goto LABEL_29;
    }
  }

  uint64_t v38 = gss_init_sec_context_delayInitStub(v28);
  size_t v39 = v53;
  if (v38 > 1)
  {
    uint64_t v27 = v38;
    if (!v53) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }

  if (!v53) {
    goto LABEL_26;
  }
  unsigned __int8 v40 = v54;
  uint64_t v41 = malloc(v53);
  void *v20 = v41;
  if (v41)
  {
    _DWORD *v21 = v39;
    memcpy(v41, v40, v39);
LABEL_26:
    uint64_t v27 = 0LL;
    goto LABEL_29;
  }

  uint64_t v27 = 12LL;
LABEL_29:
  if (v53) {
LABEL_30:
  }
    gss_release_buffer_delayInitStub(v28);
LABEL_31:
  if (v49) {
    gss_delete_sec_context_delayInitStub(v28);
  }
  if (v50) {
    gss_release_name_delayInitStub(v28);
  }
  if (inited) {
    gss_release_cred_delayInitStub(v28);
  }
  return v27;
}

uint64_t __DestroyAllKerberosTickets_block_invoke(double a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    return gss_destroy_cred_delayInitStub(a1);
  }
  return result;
}

void __ListAllKerberosTickets_block_invoke(int a1, int a2, CFTypeRef obj)
{
}

CFTypeRef CFURLCredentialStorageCreate(char *a1)
{
  uint64_t v1 = _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault;
  if (!_CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault)
  {
    a1 = StorageSession::copyProcessDefault((StorageSession *)a1);
    uint64_t v1 = (uint64_t)(a1 - 16);
    _CFURLStorageSessionGetDefault(__CFAllocator const*)::sDefault = (uint64_t)(a1 - 16);
  }

  return _CFURLStorageSessionCopyCredentialStorage((uint64_t)a1, v1);
}

void *_CFURLCredentialStorageCreateWithProperties( const __CFAllocator *a1, const __CFString *a2, CFDictionaryRef theDict)
{
  if (theDict) {
    BOOL v4 = CFDictionaryGetValue(theDict, @"kCFURLStorageSessionIsPrivate") == (const void *)*MEMORY[0x189604DE0];
  }
  else {
    BOOL v4 = 1;
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  CFTypeID v6 = (void *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    CFTypeID v6 = (void *)(Instance + 16);
    *(void *)(Instance + 12_Block_object_dispose(va, 8) = 0LL;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
    *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
  }

  *CFTypeID v6 = &off_189C03088;
  v6[1] = &unk_189C030D8;
  v6[3] = &unk_189C03160;
  v6[2] = off_189C19AE8;
  _CoreLockable::_CoreLockable((_CoreLockable *)(v6 + 3), 1);
  *CFTypeID v6 = &off_189C02B00;
  v6[1] = &unk_189C02BA0;
  v6[2] = &unk_189C02C08;
  v6[3] = &unk_189C02C28;
  int v7 = ActualCredentialStorage::initialize((ActualCredentialStorage *)v6, a2, v4);
  uint64_t result = v6 - 2;
  if (!v7)
  {
    CFRelease(result);
    return 0LL;
  }

  return result;
}

void sub_182A22750(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

uint64_t CFURLCredentialStorageCopyCredentialsForProtectionSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a1 + 16;
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v5 + 8) + 16LL))(v5 + 8, a2);
  int v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_1128, 1);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v7 + 16LL))( v7,  "CopyCredentials",  0LL))
    {
      CFTypeRef v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (a1)
      {
        uint64_t v18 = off_189C1A178;
        uint64_t v20 = 0LL;
        uint64_t v21 = 0LL;
        CFStringRef v19 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
        CFTypeRef v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 32LL))(a1 + 16);
        CFStringRef v11 = v19;
      }

      else
      {
        uint64_t v18 = off_189C1A178;
        CFStringRef v11 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
        uint64_t v4 = 0LL;
        uint64_t v20 = 0LL;
        uint64_t v21 = 0LL;
        CFStringRef v19 = v11;
        CFTypeRef v10 = @"null";
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v8 + 64LL))(v8, v11, v10);
      if (v4 && v10) {
        CFRelease(v10);
      }
      AutoString::~AutoString((AutoString *)&v18);
      if (a2)
      {
        uint64_t v18 = off_189C1A178;
        CFStringRef v12 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
        uint64_t v20 = 0LL;
        uint64_t v21 = 0LL;
        CFStringRef v19 = v12;
        uint64_t v14 = *(void *)(a2 + 16);
        uint64_t v13 = a2 + 16;
        CFIndex v15 = (const __CFString *)(*(uint64_t (**)(uint64_t))(v14 + 32))(v13);
        CFStringRef v16 = v19;
      }

      else
      {
        uint64_t v18 = off_189C1A178;
        CFStringRef v16 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
        uint64_t v13 = 0LL;
        uint64_t v20 = 0LL;
        uint64_t v21 = 0LL;
        CFIndex v15 = @"null";
        CFStringRef v19 = v16;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v8 + 64LL))(v8, v16, v15);
      if (v13 && v15) {
        CFRelease(v15);
      }
      AutoString::~AutoString((AutoString *)&v18);
      (*(void (**)(void *, const char *, uint64_t))(*(void *)v8 + 96LL))(v8, "Result", v6);
      (*(void (**)(void *))(*(void *)v8 + 8LL))(v8);
    }
  }

  return v6;
}

void sub_182A22A18(_Unwind_Exception *exception_object)
{
}

uint64_t __CFURLCredentialStorageCopyCredentialsForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 49LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t CFURLCredentialStorageCopyAllCredentials(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v2 = a1 + 16;
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0LL;
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)(v3 + 8) + 24LL))(v3 + 8);
  uint64_t v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_8, 1);
  if (v5)
  {
    uint64_t v6 = v5;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v5 + 16LL))( v5,  "CopyAllCredentials",  0LL))
    {
      int v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (a1)
      {
        if (URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage != -1)
        {
          CFStringRef v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          dispatch_once(&URLCredentialStorage::Class(void)::sOnce_URLCredentialStorage, &__block_literal_global_2_1160);
          int v7 = v11;
        }

        CFStringRef v12 = off_189C1A178;
        uint64_t v14 = 0LL;
        uint64_t v15 = 0LL;
        CFStringRef v13 = CFStringCreateWithCString(v7, "Store", 0x8000100u);
        uint64_t v8 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 32LL))(v2);
        CFStringRef v9 = v13;
      }

      else
      {
        CFStringRef v12 = off_189C1A178;
        CFStringRef v9 = CFStringCreateWithCString(v7, "Store", 0x8000100u);
        uint64_t v2 = 0LL;
        uint64_t v14 = 0LL;
        uint64_t v15 = 0LL;
        CFStringRef v13 = v9;
        uint64_t v8 = @"null";
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v6 + 64LL))(v6, v9, v8);
      if (v2 && v8) {
        CFRelease(v8);
      }
      AutoString::~AutoString((AutoString *)&v12);
      (*(void (**)(void *, const char *, uint64_t))(*(void *)v6 + 96LL))(v6, "Result", v4);
      (*(void (**)(void *))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_182A22C88(_Unwind_Exception *exception_object)
{
}

uint64_t __CFURLCredentialStorageCopyAllCredentials_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 60LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t CFURLCredentialStorageSetCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_12, 1);
  if (v6)
  {
    int v7 = v6;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v6 + 16LL))(v6, "SetCredential", 0LL))
    {
      uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (a1)
      {
        uint64_t v9 = a1 + 16;
        uint64_t v22 = off_189C1A178;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        CFTypeRef v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32LL))(a1 + 16);
        CFStringRef v11 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v11 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        uint64_t v9 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v11;
        CFTypeRef v10 = @"null";
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v11, v10);
      if (v9 && v10) {
        CFRelease(v10);
      }
      AutoString::~AutoString((AutoString *)&v22);
      if (a3)
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v12 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        uint64_t v13 = a3 + 16;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v12;
        uint64_t v14 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)(a3 + 16) + 32LL))(a3 + 16);
        CFStringRef v15 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v15 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        uint64_t v13 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        uint64_t v14 = @"null";
        CFStringRef v23 = v15;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v15, v14);
      if (v13 && v14) {
        CFRelease(v14);
      }
      AutoString::~AutoString((AutoString *)&v22);
      if (a2)
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v16 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
        uint64_t v17 = a2 + 16;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v16;
        uint64_t v18 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)(a2 + 16) + 32LL))(a2 + 16);
        CFStringRef v19 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v19 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
        uint64_t v17 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        uint64_t v18 = @"null";
        CFStringRef v23 = v19;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v19, v18);
      if (v17 && v18) {
        CFRelease(v18);
      }
      AutoString::~AutoString((AutoString *)&v22);
      (*(void (**)(void *))(*(void *)v7 + 8LL))(v7);
    }
  }

  if (a1) {
    uint64_t v20 = a1 + 16;
  }
  else {
    uint64_t v20 = 0LL;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v20 + 8) + 40LL))(v20 + 8, a2, a3);
}

void sub_182A230E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageSetCredentialForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 82LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void CFURLCredentialStorageRemoveCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_15, 1);
  if (v6)
  {
    int v7 = v6;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v6 + 16LL))( v6,  "RemoveCredential",  0LL))
    {
      uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (a1)
      {
        uint64_t v9 = a1 + 16;
        uint64_t v22 = off_189C1A178;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        CFTypeRef v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32LL))(a1 + 16);
        CFStringRef v11 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v11 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        uint64_t v9 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v11;
        CFTypeRef v10 = @"null";
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v11, v10);
      if (v9 && v10) {
        CFRelease(v10);
      }
      AutoString::~AutoString((AutoString *)&v22);
      if (a3)
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v12 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        uint64_t v13 = a3 + 16;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v12;
        uint64_t v14 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)(a3 + 16) + 32LL))(a3 + 16);
        CFStringRef v15 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v15 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        uint64_t v13 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        uint64_t v14 = @"null";
        CFStringRef v23 = v15;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v15, v14);
      if (v13 && v14) {
        CFRelease(v14);
      }
      AutoString::~AutoString((AutoString *)&v22);
      if (a2)
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v16 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
        uint64_t v17 = a2 + 16;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v16;
        uint64_t v18 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)(a2 + 16) + 32LL))(a2 + 16);
        CFStringRef v19 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v19 = CFStringCreateWithCString(v8, "Credential", 0x8000100u);
        uint64_t v17 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        uint64_t v18 = @"null";
        CFStringRef v23 = v19;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v19, v18);
      if (v17 && v18) {
        CFRelease(v18);
      }
      AutoString::~AutoString((AutoString *)&v22);
      (*(void (**)(void *))(*(void *)v7 + 8LL))(v7);
    }
  }

  uint64_t v20 = a2 + 16;
  if (!a2) {
    uint64_t v20 = 0LL;
  }
  if (*(_DWORD *)(v20 + 36) != 4)
  {
    if (a1) {
      uint64_t v21 = a1 + 16;
    }
    else {
      uint64_t v21 = 0LL;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v21 + 8) + 48LL))(v21 + 8, a2, a3);
  }

void sub_182A23530( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageRemoveCredentialForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 95LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t ___Z67CFURLCredentialStorageRemoveCredentialForProtectionSpaceWithOptionsP23_CFURLCredentialStoragePK16_CFURLCredentialP21_CFURLProtectionSpacePK14__CFDictionary_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 114LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t CFURLCredentialStorageCopyDefaultCredentialForProtectionSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a1 + 16;
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v5 + 8) + 56LL))(v5 + 8, a2);
  int v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_19, 1);
  if (v7)
  {
    uint64_t v8 = v7;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v7 + 16LL))( v7,  "CopyDefaultCredential",  0LL))
    {
      uint64_t v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (a1)
      {
        uint64_t v22 = off_189C1A178;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
        CFTypeRef v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 32LL))(a1 + 16);
        CFStringRef v11 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v11 = CFStringCreateWithCString(v9, "Store", 0x8000100u);
        uint64_t v4 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v11;
        CFTypeRef v10 = @"null";
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v8 + 64LL))(v8, v11, v10);
      if (v4 && v10) {
        CFRelease(v10);
      }
      AutoString::~AutoString((AutoString *)&v22);
      if (a2)
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v12 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v12;
        uint64_t v14 = *(void *)(a2 + 16);
        uint64_t v13 = a2 + 16;
        CFStringRef v15 = (const __CFString *)(*(uint64_t (**)(uint64_t))(v14 + 32))(v13);
        CFStringRef v16 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v16 = CFStringCreateWithCString(v9, "Space", 0x8000100u);
        uint64_t v13 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v15 = @"null";
        CFStringRef v23 = v16;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v8 + 64LL))(v8, v16, v15);
      if (v13 && v15) {
        CFRelease(v15);
      }
      AutoString::~AutoString((AutoString *)&v22);
      if (v6)
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v17 = CFStringCreateWithCString(v9, "Result", 0x8000100u);
        uint64_t v18 = v6 + 16;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v17;
        CFStringRef v19 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)(v6 + 16) + 32LL))(v6 + 16);
        CFStringRef v20 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v20 = CFStringCreateWithCString(v9, "Result", 0x8000100u);
        uint64_t v18 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v19 = @"null";
        CFStringRef v23 = v20;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v8 + 64LL))(v8, v20, v19);
      if (v18 && v19) {
        CFRelease(v19);
      }
      AutoString::~AutoString((AutoString *)&v22);
      (*(void (**)(void *))(*(void *)v8 + 8LL))(v8);
    }
  }

  return v6;
}

void sub_182A23988( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageCopyDefaultCredentialForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 145LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t CFURLCredentialStorageSetDefaultCredentialForProtectionSpace(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_21_1145, 1);
  if (v6)
  {
    int v7 = v6;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v6 + 16LL))( v6,  "SetDefaultCredential",  0LL))
    {
      uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (a1)
      {
        uint64_t v9 = a1 + 16;
        uint64_t v22 = off_189C1A178;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        CFTypeRef v10 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v9 + 32LL))(a1 + 16);
        CFStringRef v11 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v11 = CFStringCreateWithCString(v8, "Store", 0x8000100u);
        uint64_t v9 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v11;
        CFTypeRef v10 = @"null";
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v11, v10);
      if (v9 && v10) {
        CFRelease(v10);
      }
      AutoString::~AutoString((AutoString *)&v22);
      if (a3)
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v12 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        uint64_t v13 = a3 + 16;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v12;
        uint64_t v14 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)(a3 + 16) + 32LL))(a3 + 16);
        CFStringRef v15 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v15 = CFStringCreateWithCString(v8, "Space", 0x8000100u);
        uint64_t v13 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        uint64_t v14 = @"null";
        CFStringRef v23 = v15;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v15, v14);
      if (v13 && v14) {
        CFRelease(v14);
      }
      AutoString::~AutoString((AutoString *)&v22);
      if (a2)
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v16 = CFStringCreateWithCString(v8, "Result", 0x8000100u);
        uint64_t v17 = a2 + 16;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        CFStringRef v23 = v16;
        uint64_t v18 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)(a2 + 16) + 32LL))(a2 + 16);
        CFStringRef v19 = v23;
      }

      else
      {
        uint64_t v22 = off_189C1A178;
        CFStringRef v19 = CFStringCreateWithCString(v8, "Result", 0x8000100u);
        uint64_t v17 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        uint64_t v18 = @"null";
        CFStringRef v23 = v19;
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v7 + 64LL))(v7, v19, v18);
      if (v17 && v18) {
        CFRelease(v18);
      }
      AutoString::~AutoString((AutoString *)&v22);
      (*(void (**)(void *))(*(void *)v7 + 8LL))(v7);
    }
  }

  if (a1) {
    uint64_t v20 = a1 + 16;
  }
  else {
    uint64_t v20 = 0LL;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v20 + 8) + 64LL))(v20 + 8, a2, a3);
}

void sub_182A23D90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __CFURLCredentialStorageSetDefaultCredentialForProtectionSpace_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 157LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t URLCredentialStorage::initialize(URLCredentialStorage *this, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0LL;
  }
  *((void *)this + 12) = v3;
  return 1LL;
}

uint64_t ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke()
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3221225472LL;
  uint64_t v18 = ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke_2;
  CFStringRef v19 = &__block_descriptor_40_e5_v8__0l;
  uint64_t inited = (const __CFDictionary *)MKBUserTypeDeviceMode_delayInitStub(COERCE_DOUBLE(3221225472LL));
  if (inited)
  {
    gotLoadHelper_x8__kMKBDeviceModeKey(v1);
    Value = (const __CFString *)CFDictionaryGetValue(inited, **(const void ***)(v2 + 1360));
    gotLoadHelper_x8__kMKBUserTypeKey(v4);
    uint64_t v6 = (const __CFString *)CFDictionaryGetValue(inited, **(const void ***)(v5 + 1392));
    uint64_t v8 = v6;
    if (Value) {
      BOOL v9 = v6 == 0LL;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9
      || (gotLoadHelper_x8__kMKBDeviceModeMultiUser(v7), CFStringCompare(Value, **(CFStringRef **)(v10 + 1368), 0LL)))
    {
      BOOL v12 = 0;
    }

    else
    {
      gotLoadHelper_x8__kMKBUserTypeEphemeral(v11);
      BOOL v12 = CFStringCompare(v8, **(CFStringRef **)(v16 + 1384), 0LL) == kCFCompareEqualTo;
    }

    URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser = v12;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v13 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)CFStringRef v23 = URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser;
      *(_WORD *)&v23[4] = 2112;
      *(void *)&v23[6] = Value;
      __int16 v24 = 2112;
      uint64_t v25 = v8;
      _os_log_impl( &dword_18298D000,  v13,  OS_LOG_TYPE_DEFAULT,  "Device is multi-user=%d for mode %@ userType %@",  buf,  0x1Cu);
    }

    CFRelease(inited);
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v14 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)CFStringRef v23 = v21;
      _os_log_error_impl(&dword_18298D000, v14, OS_LOG_TYPE_ERROR, "MKBUserTypeDeviceMode returned NULL: %@", buf, 0xCu);
    }
  }

  return ((uint64_t (*)(void *))v18)(v17);
}

void sub_182A240B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
}

void ___ZN29URLCredentialStorageUtilities25isSystemKeychainSupportedEv_block_invoke_2(uint64_t a1)
{
  double v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t CFURLCredentialStorageIsSystemKeychainSupported()
{
  if (URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken != -1) {
    dispatch_once( &URLCredentialStorageUtilities::isSystemKeychainSupported(void)::onceToken,  &__block_literal_global_1155);
  }
  return URLCredentialStorageUtilities::isSystemKeychainSupported(void)::isMultiUser;
}

void ___ZN20URLCredentialStorage5ClassEv_block_invoke()
{
  CFPropertyListRef v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "CFURLCredentialStorage");
  URLCredentialStorage::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182A24168(_Unwind_Exception *a1)
{
}

uint64_t CFURLCredentialStorageSetUseSystemKeychain(uint64_t a1, uint64_t a2)
{
  if (a1) {
    uint64_t v4 = a1 + 16;
  }
  else {
    uint64_t v4 = 0LL;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v4 + 8) + 72LL))(v4 + 8, a2);
}

id ___ZN2H329reportServerProtocolViolationEP8NSStringNS_23ServerProtocolViolationE_block_invoke(uint64_t a1)
{
  v6[2] = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  v5[1] = @"violationType";
  v6[0] = v1;
  v5[0] = @"domain";
  [MEMORY[0x189607968] numberWithUnsignedChar:*(unsigned __int8 *)(a1 + 40)];
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  v6[1] = v2;
  [MEMORY[0x189603F68] dictionaryWithObjects:v6 forKeys:v5 count:2];
  CFTypeRef v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_182A24290(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t HTTP3Framer::HTTP3Framer(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, char a5)
{
  id v10 = a3;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 40) = 0;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  double v11 = (void **)(a1 + 48);
  *(void *)(a1 + 56) = 0LL;
  *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)a1 = 0u;
  *(_BYTE *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0;
  *(void *)(a1 + 64) = 0LL;
  *(_BYTE *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_DWORD *)(a1 + 10_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 144) = 0LL;
  *(_DWORD *)(a1 + 152) = 0;
  uint64_t v13 = *a2;
  uint64_t v12 = a2[1];
  if (v12)
  {
    uint64_t v14 = (unint64_t *)(v12 + 8);
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    uint64_t v16 = *(std::__shared_weak_count **)(a1 + 24);
    *(void *)(a1 + 16) = v13;
    *(void *)(a1 + 24) = v12;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }

  else
  {
    *(void *)(a1 + 16) = v13;
    *(void *)(a1 + 24) = 0LL;
  }

  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = a4;
  *(_BYTE *)(a1 + 40) = a5;
  objc_storeStrong((id *)(a1 + 56), a3);
  if (a5) {
    id v19 = 0LL;
  }
  else {
    id v19 = v10;
  }
  uint64_t v20 = *v11;
  *double v11 = v19;

  if (v10) {
    (*(void (**)(void, id))(**(void **)(a1 + 16) + 40LL))(*(void *)(a1 + 16), v10);
  }

  return a1;
}

void sub_182A243F8(_Unwind_Exception *a1)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 8);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  _Unwind_Resume(a1);
}

BOOL HTTP3Framer::setReadHandleBeforeReading(uint64_t a1, void *a2, void *a3, int a4)
{
  id v8 = a2;
  id v9 = a3;
  uint64_t v10 = *(void *)(a1 + 48);
  if (!v10)
  {
    objc_storeStrong((id *)(a1 + 48), a2);
    objc_storeStrong((id *)(a1 + 136), a3);
    if (a4)
    {
      *(void *)(a1 + 144) = 4LL;
      *(_DWORD *)(a1 + 152) = -2300;
    }
  }

  return v10 == 0;
}

uint64_t HTTP3Framer::getStreamID(HTTP3Framer *this)
{
  uint64_t v2 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v3 = nw_content_context_copy_protocol_metadata(this, v2);

  uint64_t v4 = (void *)nw_quic_connection_copy_stream_metadata();
  if (v4) {
    uint64_t id = nw_quic_stream_get_id();
  }
  else {
    uint64_t id = -1LL;
  }

  return id;
}

void sub_182A24544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HTTP3Framer::_readHeader(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = a2;
  uint64_t v6 = a3;
  uint64_t v35 = 0LL;
  double v36 = &v35;
  uint64_t v37 = 0x2020000000LL;
  char v38 = 0;
  if (v5)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke;
    applier[3] = &unk_189C09418;
    applier[4] = &v35;
    applier[5] = a1;
    dispatch_data_apply(v5, applier);
    if (*((_BYTE *)v36 + 24))
    {
      double v7 = *(dispatch_data_s **)(a1 + 136);
      if (!v7) {
        __assert_rtn("_readHeader", "HTTP3Frame.mm", 114, "_pendingData");
      }
      size_t v8 = *(void *)(a1 + 96);
      size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 136));
      size_t v10 = size - v8;
      if (size < v8) {
        __assert_rtn("_readHeader", "HTTP3Frame.mm", 117, "pendingSize >= headerSize");
      }
      double v11 = (__int128 *)(a1 + 80);
      size_t v12 = *(void *)(a1 + 88);
      if (v10 >= v12)
      {
        dispatch_data_t subrange = dispatch_data_create_subrange(v7, v8, v12);
        uint64_t v21 = *(void *)(a1 + 88);
        uint64_t v22 = *(dispatch_data_s **)(a1 + 136);
        if (v10 == v21)
        {
          dispatch_data_t v23 = 0LL;
        }

        else
        {
          dispatch_data_t v23 = dispatch_data_create_subrange(v22, v21 + v8, v10 - v21);
          uint64_t v22 = *(dispatch_data_s **)(a1 + 136);
        }

        *(void *)(a1 + 136) = v23;

        __int128 v32 = *v11;
        uint64_t v33 = *(void *)(a1 + 96);
        if (*(void *)(a1 + 136))
        {
          uint64_t v24 = 0LL;
          uint64_t v25 = 0LL;
        }

        else
        {
          uint64_t v25 = *(void *)(a1 + 144);
          uint64_t v24 = *(void *)(a1 + 152);
        }

        v6[2](v6, &v32, subrange, 1LL, v25, v24);
      }

      else
      {
        dispatch_data_t subrange = dispatch_data_create_subrange(v7, v8, v10);
        *(_DWORD *)(a1 + 76) = 1;
        *(void *)(a1 + 104) = *(void *)(a1 + 88) - v10;
        uint64_t v14 = *(void **)(a1 + 136);
        *(void *)(a1 + 136) = 0LL;

        uint64_t v31 = *(void *)(a1 + 96);
        __int128 v30 = *v11;
        v6[2](v6, &v30, subrange, 0LL, *(void *)(a1 + 144), *(void *)(a1 + 152));
      }

void sub_182A2485C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v4 - 96), 8);
  _Unwind_Resume(a1);
}

BOOL ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke( uint64_t a1, int a2, int a3, void *__src, unint64_t a5)
{
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 128);
  if (16 - v7 >= a5) {
    size_t v8 = a5;
  }
  else {
    size_t v8 = 16 - v7;
  }
  memcpy((void *)(v6 + 112 + v7), __src, v8);
  unsigned __int8 v9 = *(_BYTE *)(v6 + 128) + v8;
  *(_BYTE *)(v6 + 12_Block_object_dispose(va, 8) = v9;
  *(void *)(v6 + 96) = 0LL;
  *(void *)&v15[1] = v9;
  uint64_t v16 = v6 + 112;
  if (QUICUtilities::quic_vle_decode( (QUICUtilities *)&v16,  (const unsigned __int8 **)&v15[1],  &v14,  (unint64_t *)v15,  v10)
    && (*(void *)(v6 + 80) = v14,
        *(void *)(v6 + 96) += v15[0],
        QUICUtilities::quic_vle_decode( (QUICUtilities *)&v16,  (const unsigned __int8 **)&v15[1],  (unint64_t *)(v6 + 88),  (unint64_t *)v15,  v11)))
  {
    *(void *)(v6 + 96) += v15[0];
    *(_BYTE *)(v6 + 12_Block_object_dispose(va, 8) = 0;
    char v12 = 1;
  }

  else
  {
    char v12 = 0;
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v12;
  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

void ___ZN11HTTP3Framer11_readHeaderEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_b13CFStreamErrorE_block_invoke_2( uint64_t a1, void *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  id v11 = a2;
  char v12 = a3;
  uint64_t v13 = v12;
  uint64_t v14 = *(void *)(a1 + 40);
  if ((_DWORD)a6)
  {
    *(void *)(v14 + 144) = a5;
    *(void *)(v14 + 152) = a6;
  }

  else if (a4)
  {
    *(void *)(v14 + 144) = 4LL;
    *(_DWORD *)(v14 + 152) = -2300;
  }

  if (v12)
  {
    uint64_t v15 = *(dispatch_data_s **)(v14 + 136);
    if (v15) {
      dispatch_data_t concat = dispatch_data_create_concat(v15, v13);
    }
    else {
      dispatch_data_t concat = v13;
    }
    uint64_t v18 = *(void **)(v14 + 136);
    *(void *)(v14 + 136) = concat;

    HTTP3Framer::_readHeader(v14, v13, *(void *)(a1 + 32));
  }

  else
  {
    if (*(_DWORD *)(v14 + 152))
    {
      uint64_t v17 = *(void *)(v14 + 144);
    }

    else
    {
      uint64_t v17 = 4LL;
      *(void *)(v14 + 144) = 4LL;
      *(_DWORD *)(v14 + 152) = -1;
    }

    uint64_t v19 = *(void *)(a1 + 32);
    memset(v20, 0, sizeof(v20));
    (*(void (**)(uint64_t, void *, void, BOOL, uint64_t, void))(v19 + 16))( v19,  v20,  0LL,  *(_BYTE *)(v14 + 128) == 0,  v17,  *(void *)(v14 + 152));
  }
}

void sub_182A24AA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void HTTP3Framer::_read(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  int v5 = *(_DWORD *)(a1 + 76);
  if (v5 == 1)
  {
    if (!*(void *)(a1 + 104))
    {
      char v12 = "_waitingBodySize > 0";
      int v13 = 167;
      goto LABEL_19;
    }

    if (*(void *)(a1 + 136))
    {
      char v12 = "_pendingData == nullptr";
      int v13 = 168;
      goto LABEL_19;
    }

    if (*(_DWORD *)(a1 + 152))
    {
      memset(v17, 0, sizeof(v17));
      (*((void (**)(id, void *, void, void, void, void))v3 + 2))( v3,  v17,  0LL,  0LL,  *(void *)(a1 + 144),  *(void *)(a1 + 152));
    }

    else
    {
      uint64_t v6 = *(void *)(a1 + 16);
      uint64_t v7 = *(void *)(a1 + 48);
      uint64_t v8 = *(void *)(a1 + 64);
      if (v8)
      {
        uint64_t v9 = (*(uint64_t (**)(void))(v8 + 16))();
        int v10 = 132001;
        if (v9 > 132001) {
          int v10 = v9;
        }
        uint64_t v11 = (v10 - 1);
      }

      else
      {
        uint64_t v11 = 132000LL;
      }

      v14[0] = MEMORY[0x1895F87A8];
      v14[1] = 3221225472LL;
      v14[2] = ___ZN11HTTP3Framer5_readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke;
      v14[3] = &unk_189C031A0;
      uint64_t v16 = a1;
      id v15 = v4;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v6 + 24LL))( v6,  v7,  1LL,  v11,  v14);
    }
  }

  else if (!v5)
  {
    if (!*(void *)(a1 + 104))
    {
      HTTP3Framer::_readHeader(a1, *(void **)(a1 + 136), v3);
      goto LABEL_15;
    }

    char v12 = "_waitingBodySize == 0";
    int v13 = 162;
LABEL_19:
    __assert_rtn("_read", "HTTP3Frame.mm", v13, v12);
  }

void sub_182A24C44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Framer5_readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke( uint64_t a1, void *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  id v11 = a2;
  char v12 = a3;
  int v13 = v12;
  uint64_t v14 = *(void *)(a1 + 40);
  if ((_DWORD)a6)
  {
    *(void *)(v14 + 144) = a5;
    *(void *)(v14 + 152) = a6;
  }

  else if (a4)
  {
    *(void *)(v14 + 144) = 4LL;
    *(_DWORD *)(v14 + 152) = -2300;
  }

  if (v12)
  {
    size_t size = dispatch_data_get_size(v12);
    size_t v16 = *(void *)(v14 + 104);
    if (v16 <= size)
    {
      if (v16 == size)
      {
        dispatch_data_t subrange = v13;
      }

      else
      {
        size_t v17 = size;
        dispatch_data_t subrange = dispatch_data_create_subrange(v13, 0LL, v16);
        dispatch_data_t v19 = dispatch_data_create_subrange(v13, *(void *)(v14 + 104), v17 - *(void *)(v14 + 104));
        uint64_t v20 = *(void **)(v14 + 136);
        *(void *)(v14 + 136) = v19;
      }

      uint64_t v21 = 0LL;
      uint64_t v22 = 0LL;
      *(void *)(v14 + 104) = 0LL;
      *(_DWORD *)(v14 + 76) = 0;
      uint64_t v23 = *(void *)(a1 + 32);
      __int128 v24 = *(_OWORD *)(v14 + 80);
      uint64_t v25 = *(void *)(v14 + 96);
      if (!*(void *)(v14 + 136))
      {
        uint64_t v22 = *(void *)(v14 + 144);
        uint64_t v21 = *(void *)(v14 + 152);
      }

      (*(void (**)(uint64_t, __int128 *, dispatch_data_t, uint64_t, uint64_t, uint64_t))(v23 + 16))( v23,  &v24,  subrange,  1LL,  v22,  v21);
    }

    else
    {
      *(void *)(v14 + 104) = v16 - size;
      (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    }
  }

  else
  {
    if (!*(_DWORD *)(v14 + 152))
    {
      *(void *)(v14 + 144) = 4LL;
      *(_DWORD *)(v14 + 152) = -1;
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }
}

void sub_182A24E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP3Framer4readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke( uint64_t a1, __int128 *a2, uint64_t a3)
{
  *(_BYTE *)(*(void *)(a1 + 40) + 72LL) = 0;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v6 = *((void *)a2 + 2);
  __int128 v5 = *a2;
  return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t))(v3 + 16))(v3, &v5, a3);
}

uint64_t __copy_helper_block_ea8_40c39_ZTSNSt3__110shared_ptrI11HTTP3FramerEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 4_Block_object_dispose(va, 8) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_40c39_ZTSNSt3__110shared_ptrI11HTTP3FramerEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void HTTP3Framer::_readFrame(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  v11[2] = ___ZN11HTTP3Framer10_readFrameEmPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_13CFStreamErrorE_block_invoke;
  v11[3] = &unk_189C03200;
  id v12 = v7;
  id v13 = v8;
  uint64_t v14 = a1;
  uint64_t v15 = a2;
  id v9 = v7;
  id v10 = v8;
  HTTP3Framer::_read(a1, v11);
}

void sub_182A24F44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Framer10_readFrameEmPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvN2H313FrameMetadataES2_13CFStreamErrorE_block_invoke( void *a1, __int128 *a2, void *a3, int a4, uint64_t a5, uint64_t a6)
{
  id v11 = a3;
  if (v11)
  {
    uint64_t v12 = a1[6];
    id v13 = (dispatch_data_s *)a1[4];
    if (dispatch_data_get_size(v13) >= a1[7]) {
      dispatch_data_t concat = v13;
    }
    else {
      dispatch_data_t concat = dispatch_data_create_concat(v13, v11);
    }
    dispatch_data_t v18 = concat;
    if (a4)
    {
      uint64_t v19 = a1[5];
      uint64_t v21 = *((void *)a2 + 2);
      __int128 v20 = *a2;
      (*(void (**)(uint64_t, __int128 *, dispatch_data_t))(v19 + 16))(v19, &v20, v18);
    }

    else
    {
      HTTP3Framer::_readFrame(v12, a1[7], concat, a1[5]);
    }
  }

  else
  {
    uint64_t v15 = a6;
    if ((_DWORD)a6) {
      uint64_t v16 = a5;
    }
    else {
      uint64_t v16 = 4LL;
    }
    uint64_t v17 = a1[5];
    uint64_t v23 = *((void *)a2 + 2);
    __int128 v22 = *a2;
    if (!(_DWORD)a6) {
      uint64_t v15 = 0xFFFFFFFFLL;
    }
    (*(void (**)(uint64_t, __int128 *, void, uint64_t, unint64_t))(v17 + 16))( v17,  &v22,  0LL,  v16,  v15 | a6 & 0xFFFFFFFF00000000LL);
  }
}

void sub_182A25088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN11HTTP3Framer9readFrameEmU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke( uint64_t a1, __int128 *a2, uint64_t a3)
{
  *(_BYTE *)(*(void *)(a1 + 40) + 72LL) = 0;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v6 = *((void *)a2 + 2);
  __int128 v5 = *a2;
  return (*(uint64_t (**)(uint64_t, __int128 *, uint64_t))(v3 + 16))(v3, &v5, a3);
}

void HTTP3Framer::writeFrame(uint64_t a1, unint64_t a2, void *a3, int a4, void *a5)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  id v9 = a3;
  id v10 = a5;
  if (!v9) {
    __assert_rtn("writeFrame", "HTTP3Frame.mm", 254, "data");
  }
  __int128 v32 = v10;
  unsigned int v12 = QUICUtilities::quic_vle_encode(a2, &__src, v11);
  memcpy(__dst, &__src, v12);
  size_t size = dispatch_data_get_size(v9);
  size_t v15 = QUICUtilities::quic_vle_encode(size, &__src, v14);
  memcpy(&__dst[v12], &__src, v15);
  size_t v16 = v15 + v12;
  dispatch_data_t v18 = dispatch_data_create(__dst, v16, 0LL, 0LL);
  char v19 = *(_BYTE *)(a1 + 40);
  if (v19)
  {
    unsigned int v20 = QUICUtilities::quic_vle_encode(*(void *)(a1 + 32), &buffer, v17);
    uint64_t v21 = dispatch_data_create(&buffer, v20, 0LL, 0LL);
    dispatch_data_t concat = dispatch_data_create_concat(v21, v18);

    *(_BYTE *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0;
    *(_BYTE *)(a1 + 40) = 0;

    dispatch_data_t v18 = concat;
  }

  data2 = v9;
  uint64_t v23 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16LL))(*(void *)(a1 + 16));
  id v24 = *(id *)(a1 + 56);
  uint64_t v25 = *(void *)(a1 + 16);
  uint64_t v26 = *(void *)(a1 + 56);
  uint64_t v27 = a4 ^ 1u;
  dispatch_data_t v28 = dispatch_data_create_concat(v18, data2);
  v34[0] = MEMORY[0x1895F87A8];
  v34[1] = 3221225472LL;
  v34[2] = ___ZN11HTTP3Framer10writeFrameEN2H39FrameTypeEPU27objcproto16OS_dispatch_data8NSObjectbU13block_pointerFvm13CFStreamErrorE_block_invoke;
  v34[3] = &unk_189C03260;
  id v29 = v32;
  char v39 = v19;
  id v35 = v24;
  id v36 = v29;
  size_t v37 = v16;
  uint64_t v38 = v23;
  __int128 v30 = *(void (**)(uint64_t, uint64_t, uint64_t, dispatch_data_t, void *))(*(void *)v25 + 32LL);
  id v31 = v24;
  v30(v25, v26, v27, v28, v34);
}

void sub_182A25324( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Framer10writeFrameEN2H39FrameTypeEPU27objcproto16OS_dispatch_data8NSObjectbU13block_pointerFvm13CFStreamErrorE_block_invoke( uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  if (*(_BYTE *)(a1 + 64))
  {
    __int128 v5 = *(nw_content_context **)(a1 + 32);
    if (v5 && a3 == 0LL)
    {
      id v7 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
      nw_protocol_metadata_t v8 = nw_content_context_copy_protocol_metadata(v5, v7);

      id v9 = (void *)nw_quic_connection_copy_stream_metadata();
      uint64_t id = nw_quic_stream_get_id();
      if ((id & 3) != 2 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = *(void *)(a1 + 56);
        int v12 = 134218240;
        uint64_t v13 = v11;
        __int16 v14 = 2048;
        uint64_t v15 = id;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "Connection %llu: Not unidirectional outbound stream %llu",  (uint8_t *)&v12,  0x16u);
      }
    }
  }

void sub_182A254A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t HTTP3Framer::cancelStream(uint64_t a1, uint64_t a2)
{
  if (a2 != -1)
  {
    uint64_t v3 = *(nw_content_context **)(a1 + 48);
    unint64_t v4 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
    nw_protocol_metadata_t v5 = nw_content_context_copy_protocol_metadata(v3, v4);

    uint64_t v6 = (void *)nw_quic_connection_copy_stream_metadata();
    nw_quic_stream_set_application_error();
  }

  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 16) + 48LL))( *(void *)(a1 + 16),  *(void *)(a1 + 48));
}

void sub_182A25554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL8getDafsav_block_invoke()
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  [@"com.apple.nsurlsessiond" UTF8String];
  [@"systemgroup.com.apple.nsurlstoragedresources" UTF8String];
  CFPropertyListRef v0 = (void *)container_system_group_path_for_identifier();
  if (v0)
  {
    uint64_t v1 = (void *)[MEMORY[0x189604030] fileURLWithFileSystemRepresentation:v0 isDirectory:1 relativeToURL:0];
    free(v0);
  }

  else
  {
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      id v9 = @"systemgroup.com.apple.nsurlstoragedresources";
      _os_log_debug_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_DEBUG,  "Error getting the system group container for Group ID %@ ",  buf,  0xCu);
    }

    uint64_t v1 = 0LL;
  }

  if ((mmapDafsaFileAtLocation((const char *)objc_msgSend( (id)objc_msgSend( v1,  "URLByAppendingPathComponent:isDirectory:",  @"Library/dafsaData.bin",  0),  "fileSystemRepresentation")) & 1) == 0)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v2 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( &dword_18298D000,  v2,  OS_LOG_TYPE_INFO,  "TLD info from asset location is unavailable or too old. Falling back to builtin",  buf,  2u);
    }

    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4714);
    }
    CFURLRef v3 = CFBundleCopyResourceURL((CFBundleRef)__CFNGetCFNetworkBundle::bundle, @"DafsaData", @"bin", 0LL);
    CFURLRef v4 = v3;
    if (v3)
    {
      unsigned __int8 v5 = mmapDafsaFileAtLocation((const char *)-[__CFURL fileSystemRepresentation]( v3,  "fileSystemRepresentation"));
      CFRelease(v4);
      if ((v5 & 1) != 0) {
        return;
      }
    }

    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v6 = (os_log_s *)CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT)) {
        goto LABEL_20;
      }
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_18298D000, v6, OS_LOG_TYPE_FAULT, "Failed to get builtin TLD URL", buf, 2u);
    }

    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
LABEL_20:
    id v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_18298D000, v7, OS_LOG_TYPE_FAULT, "Failed to mmap TLD info", buf, 2u);
    }
  }

void sub_182A25848(_Unwind_Exception *a1)
{
}

const char *mmapDafsaFileAtLocation(const char *result)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (result)
  {
    uint64_t v1 = result;
    int v2 = open(result, 0);
    if (v2 == -1) {
      return 0LL;
    }
    int v3 = v2;
    stat(v1, &v16);
    st_size_t size = v16.st_size;
    if (v16.st_size <= 3uLL)
    {
      close(v3);
      return 0LL;
    }

    unsigned __int8 v5 = (unsigned int *)mmap(0LL, v16.st_size, 1, 1, v3, 0LL);
    close(v3);
    if (*v5 > 0x1002B)
    {
      if ((st_size & 0xFFFFFFFFFFFFFFFCLL) == 4)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        id v7 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
        {
          LOWORD(v16.st_dev) = 0;
          _os_log_fault_impl(&dword_18298D000, v7, OS_LOG_TYPE_FAULT, "Corrupted dafsa data", (uint8_t *)&v16, 2u);
        }

        uint64_t result = (const char *)munmap(v5, st_size);
        if ((_DWORD)result)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          uint64_t v6 = (os_log_s *)CFNLog::logger;
          uint64_t result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
          if ((_DWORD)result) {
            goto LABEL_51;
          }
        }
      }

      else
      {
        unint64_t v8 = v5[1];
        unint64_t v9 = st_size - 8 - v8;
        if (st_size - 8 >= v8)
        {
          if (v9 > 3)
          {
            int v12 = (unsigned int *)((char *)v5 + v8 + 8);
            unint64_t v13 = *v12;
            if (v9 - 4 >= v13)
            {
              getDafsa(void)::dafsaToBeReturned = (uint64_t)(v5 + 2);
              getDafsa(void)::dafsaToBeReturned = v8;
              getDafsa(void)::dafsaToBeReturned = (uint64_t)(v12 + 1);
              getDafsa(void)::dafsaToBeReturned = v13;
              return (const char *)1;
            }

            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
            }
            __int16 v14 = (os_log_s *)CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
            {
              LOWORD(v16.st_dev) = 0;
              _os_log_fault_impl(&dword_18298D000, v14, OS_LOG_TYPE_FAULT, "Corrupted dafsa data", (uint8_t *)&v16, 2u);
            }

            uint64_t result = (const char *)munmap(v5, st_size);
            if ((_DWORD)result)
            {
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
              }
              uint64_t v6 = (os_log_s *)CFNLog::logger;
              uint64_t result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
              if ((_DWORD)result) {
                goto LABEL_51;
              }
            }
          }

          else
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
            }
            uint64_t v11 = (os_log_s *)CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
            {
              LOWORD(v16.st_dev) = 0;
              _os_log_fault_impl(&dword_18298D000, v11, OS_LOG_TYPE_FAULT, "Corrupted dafsa data", (uint8_t *)&v16, 2u);
            }

            uint64_t result = (const char *)munmap(v5, st_size);
            if ((_DWORD)result)
            {
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
              }
              uint64_t v6 = (os_log_s *)CFNLog::logger;
              uint64_t result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
              if ((_DWORD)result) {
                goto LABEL_51;
              }
            }
          }
        }

        else
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          uint64_t v10 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
          {
            LOWORD(v16.st_dev) = 0;
            _os_log_fault_impl(&dword_18298D000, v10, OS_LOG_TYPE_FAULT, "Corrupted dafsa data", (uint8_t *)&v16, 2u);
          }

          uint64_t result = (const char *)munmap(v5, st_size);
          if ((_DWORD)result)
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
            }
            uint64_t v6 = (os_log_s *)CFNLog::logger;
            uint64_t result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result) {
              goto LABEL_51;
            }
          }
        }
      }
    }

    else
    {
      uint64_t result = (const char *)munmap(v5, st_size);
      if ((_DWORD)result)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        uint64_t v6 = (os_log_s *)CFNLog::logger;
        uint64_t result = (const char *)os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
LABEL_51:
          int v15 = *__error();
          v16.st_dev = 67109120;
          *(_DWORD *)&v16.st_mode = v15;
          _os_log_error_impl( &dword_18298D000,  v6,  OS_LOG_TYPE_ERROR,  "Failed to munmap TLD dafsa %{error}d",  (uint8_t *)&v16,  8u);
          return 0LL;
        }
      }
    }
  }

  return result;
}

BOOL _CFHostIsDomainTopLevelForCookiePolicy(const __CFString *a1)
{
  return isTopLevelDomain(a1, 1);
}

BOOL _CFHostIsDomainTopLevel(const __CFString *a1)
{
  return isTopLevelDomain(a1, 1);
}

BOOL _CFHostIsDomainTopLevelForCertificatePolicy(const __CFString *a1)
{
  return isTopLevelDomain(a1, 0);
}

CFStringRef _cfnCreateRegistrableDomain(const __CFString *a1)
{
  *(void *)&v10[255] = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  CFStringRef IDNAEncodedDomain = createIDNAEncodedDomain(a1);
  if (!CFStringGetCString(IDNAEncodedDomain, buffer, 256LL, 0x600u))
  {
    CFStringRef v5 = 0LL;
    if (!IDNAEncodedDomain) {
      return v5;
    }
LABEL_16:
    CFRelease(IDNAEncodedDomain);
    return v5;
  }

  size_t v2 = strlen(buffer);
  uint64_t v3 = v2;
  if (v2 && buffer[v2 - 1] == 46)
  {
    buffer[v2 - 1] = 0;
    uint64_t v3 = v2 - 1;
  }

  TopLevelDomain = _CFHostGetTopLevelDomain((unint64_t)buffer, v3, 1);
  CFStringRef v5 = 0LL;
  if (TopLevelDomain && TopLevelDomain > v10)
  {
    uint64_t v6 = TopLevelDomain - 2;
    do
    {
      id v7 = v6;
      if (v6 < buffer) {
        break;
      }
      --v6;
    }

    while (*v7 != 46);
    CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], v7 + 1, 0x600u);
  }

  if (IDNAEncodedDomain) {
    goto LABEL_16;
  }
  return v5;
}

void sub_182A25F30(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZL12creatEnqueueP17HTTPNetConnectionP15__CFHTTPMessageP14__CFReadStream_block_invoke( uint64_t a1, __CFReadStream *a2)
{
  uint64_t v4 = MEMORY[0x186E12804](*(void *)(a1 + 40), 184LL, 0LL);
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(v4 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(void *)(v4 + 176) = 0LL;
  HTTPNetStreamInfo::HTTPNetStreamInfo( (HTTPNetStreamInfo *)v4,  a2,  *(CFTypeRef *)(a1 + 48),  *(HTTPNetConnection **)(a1 + 56));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v5;
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  (*(void (**)(uint64_t, void, void))(*(void *)v6 + 112LL))(v6, 0LL, 0LL);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t volumeSupportsFileProtection(const char *a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  uint64_t v1 = dirname_r(a1, v3);
  if (statfs(v1, &v4) == -1) {
    return 0LL;
  }
  else {
    return (v4.f_flags >> 7) & 1;
  }
}

void sub_182A26484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A265BC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

CFStringRef MetaConnectionCache::copyDebugDesc(MetaConnectionCache *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"MetaConnectionCache<%p>", this);
}

BOOL MetaConnectionCache::equals(MetaConnectionCache *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

void MetaConnectionCache::initWithSchedulingSet( MetaConnectionCache *this, const CoreSchedulingSet *a2, TubeManager *a3)
{
}

void MetaConnectionCache::initWithSchedulingSet()
{
}

void MetaConnectionCache::ingestTube(MetaConnectionCache *this, Tube *a2)
{
}

void MetaConnectionCache::ingestTube()
{
}

void MetaConnectionCache::getPendingTubeForProtocolWithKey()
{
}

uint64_t MetaNetStreamInfo::getHTTPConnectionInfo(MetaNetStreamInfo *this)
{
  return 0LL;
}

uint64_t MetaNetStreamInfo::getCurrentSuspensionThreshold(MetaNetStreamInfo *this, uint64_t a2)
{
  return a2;
}

void MetaNetStreamInfo::getAuthState(void *a1@<X8>)
{
  *a1 = 0LL;
  a1[1] = 0LL;
}

CFTypeID CFNetServiceBrowserGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CFNetServiceBrowserRegisterClass;
  if (_kCFNetServiceBrowserRegisterClass != -1) {
    dispatch_once(&_kCFNetServiceBrowserRegisterClass, block);
  }
  return _kCFNetServiceBrowserTypeID;
}

void *_CFNetServiceBrowserRegisterClass(void)
{
  uint64_t result = calloc(1uLL, 0x60uLL);
  _kCFNetServiceBrowserClass = (uint64_t)result;
  if (result)
  {
    *uint64_t result = 0LL;
    result[1] = "CFNetServiceBrowser";
    result[4] = _NetServiceBrowserDestroy;
    uint64_t result = (void *)_CFRuntimeRegisterClass();
    _kCFNetServiceBrowserCFTypeID TypeID = (uint64_t)result;
  }

  return result;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void _NetServiceBrowserDestroy(__CFNetServiceBrowser *a1)
{
  size_t v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if (*((void *)a1 + 14))
  {
    uint64_t v3 = (void (*)(void))*((void *)a1 + 16);
    if (v3) {
      v3();
    }
  }

  statfs v4 = (char *)*((void *)a1 + 5);
  if (v4)
  {
    uint64_t v5 = *((void *)a1 + 11);
    if (v5)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v4, v5);
      statfs v4 = (char *)*((void *)a1 + 5);
    }

    _CFTypeInvalidate(v4);
    CFRelease(*((CFTypeRef *)a1 + 5));
  }

  uint64_t v6 = (_DNSServiceRef_t *)*((void *)a1 + 6);
  if (v6) {
    DNSServiceRefDeallocate(v6);
  }
  id v7 = (const void *)*((void *)a1 + 8);
  if (v7) {
    CFRelease(v7);
  }
  unint64_t v8 = (const void *)*((void *)a1 + 9);
  if (v8) {
    CFRelease(v8);
  }
  unint64_t v9 = (const void *)*((void *)a1 + 10);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (const void *)*((void *)a1 + 11);
  if (v10) {
    CFRelease(v10);
  }
  os_unfair_lock_unlock(v2);
}

CFNetServiceBrowserRef CFNetServiceBrowserCreate( CFAllocatorRef alloc, CFNetServiceBrowserClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  uint64_t v3 = 0LL;
  if (clientCB && clientContext)
  {
    if (!CFNetServiceBrowserGetTypeID()) {
      return 0LL;
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v3 = (void *)Instance;
    if (Instance)
    {
      memset(&v18, 0, sizeof(v18));
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
      *(void *)(Instance + 96) = clientCB;
      __int128 v12 = *(_OWORD *)&clientContext->version;
      __int128 v13 = *(_OWORD *)&clientContext->retain;
      *(void *)(Instance + 136) = clientContext->copyDescription;
      *(_OWORD *)(Instance + 120) = v13;
      *(_OWORD *)(Instance + 104) = v12;
      uint64_t v14 = *(void *)(Instance + 112);
      if (v14)
      {
        int v15 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v3[15];
        if (v15) {
          v3[14] = v15(v14, v8, v9, v10, v11);
        }
      }

      stat v16 = (const CFArrayCallBacks *)MEMORY[0x189605228];
      v3[11] = CFArrayCreateMutable(alloc, 0LL, MEMORY[0x189605228]);
      v3[8] = CFDictionaryCreateMutable(alloc, 0LL, MEMORY[0x189605240], &v18);
      v3[9] = CFArrayCreateMutable(alloc, 0LL, v16);
      v3[10] = CFArrayCreateMutable(alloc, 0LL, v16);
      if (!v3[11])
      {
        CFRelease(v3);
        return 0LL;
      }
    }
  }

  return (CFNetServiceBrowserRef)v3;
}

void CFNetServiceBrowserInvalidate(CFNetServiceBrowserRef browser)
{
  size_t v2 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (*((void *)browser + 14))
  {
    uint64_t v3 = (void (*)(void))*((void *)browser + 16);
    if (v3) {
      v3();
    }
  }

  uint64_t v4 = *((void *)browser + 5);
  if (v4)
  {
    _CFTypeUnscheduleFromMultipleRunLoops(v4, *((void *)browser + 11));
    _CFTypeInvalidate(*((void *)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    *((void *)browser + 5) = 0LL;
  }

  uint64_t v5 = (_DNSServiceRef_t *)*((void *)browser + 6);
  if (v5)
  {
    DNSServiceRefDeallocate(v5);
    *((void *)browser + 6) = 0LL;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)browser + 8));
    CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 9));
    CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 10));
  }

  *((_OWORD *)browser + 7) = 0u;
  *((_OWORD *)browser + _Block_object_dispose(va, 8) = 0u;
  *((_OWORD *)browser + 6) = 0u;
  os_unfair_lock_unlock(v2);
}

Boolean CFNetServiceBrowserSearchForDomains( CFNetServiceBrowserRef browser, Boolean registrationDomains, CFStreamError *error)
{
  int v3 = registrationDomains;
  if (error) {
    uint64_t v5 = error;
  }
  else {
    uint64_t v5 = (CFStreamError *)&v22;
  }
  v5->domain = 0LL;
  *(void *)&v5->CFErrorRef error = 0LL;
  CFRetain(browser);
  uint64_t v6 = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  context.version = 0LL;
  context.info = browser;
  context.retain = v6;
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
  context.copyDescription = 0LL;
  if (!*((void *)browser + 12))
  {
    Boolean v10 = 0;
    *((void *)browser + 3) = 10LL;
    int v11 = -72006;
    goto LABEL_9;
  }

  int v7 = -72008;
  uint64_t v8 = (const void *)*((void *)browser + 5);
  if (v8)
  {
    CFTypeID v9 = CFGetTypeID(v8);
    if (v9 == CFSocketGetTypeID())
    {
      Boolean v10 = 0;
      *((void *)browser + 3) = 10LL;
      int v11 = -72003;
LABEL_9:
      *((_DWORD *)browser + _Block_object_dispose(va, 8) = v11;
      goto LABEL_28;
    }

    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)browser + 5), *((const __CFArray **)browser + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    *((void *)browser + 5) = 0LL;
  }

  *((_BYTE *)browser + 20) = 1;
  if (v3) {
    DNSServiceFlags v12 = 128;
  }
  else {
    DNSServiceFlags v12 = 64;
  }
  DNSServiceErrorType v13 = DNSServiceEnumerateDomains( (DNSServiceRef *)browser + 6,  v12,  0,  (DNSServiceDomainEnumReply)_DomainEnumReply,  browser);
  *((_DWORD *)browser + _Block_object_dispose(va, 8) = v13;
  if (v13 <= -65549)
  {
    if (v13 == -65555) {
      goto LABEL_27;
    }
    if (v13 == -65554)
    {
      int v7 = -72002;
      goto LABEL_27;
    }

    goto LABEL_26;
  }

  if (v13 == -65548)
  {
    int v7 = -72001;
    goto LABEL_27;
  }

  if (v13)
  {
    if (v13 == -65540)
    {
      int v7 = -72004;
LABEL_27:
      Boolean v10 = 0;
      *((void *)browser + 3) = 10LL;
      *((_DWORD *)browser + _Block_object_dispose(va, 8) = v7;
      goto LABEL_28;
    }

void _DomainEnumReply(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, char *cf)
{
  if (a4 != -65570)
  {
    uint64_t v19 = v6;
    uint64_t v20 = v7;
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((void *)cf + 6))
    {
      DNSServiceErrorType v13 = 0LL;
      uint64_t v14 = 0LL;
      CFStringRef v15 = 0LL;
LABEL_19:
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v13 && v15)
      {
        if ((a2 & 2) != 0) {
          int v17 = 2;
        }
        else {
          int v17 = 10;
        }
        v13(cf, v17 | a2 & 5u, v15, &v18, v14);
      }

      else if (!v15)
      {
LABEL_27:
        CFRelease(cf);
        return;
      }

      CFRelease(v15);
      goto LABEL_27;
    }

    if (!a4)
    {
      if (a5)
      {
        stat v16 = CFGetAllocator(cf);
        CFStringRef v15 = CFStringCreateWithCString(v16, a5, 0x8000100u);
      }

      else
      {
        CFStringRef v15 = 0LL;
      }

      goto LABEL_18;
    }

    int v12 = -72008;
    if (a4 > -65549)
    {
      if (a4 == -65548)
      {
        int v12 = -72001;
        goto LABEL_17;
      }

      if (a4 == -65540)
      {
        int v12 = -72004;
        goto LABEL_17;
      }
    }

    else
    {
      if (a4 == -65555)
      {
LABEL_17:
        *((void *)cf + 3) = 10LL;
        *((_DWORD *)cf + _Block_object_dispose(va, 8) = v12;
        _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
        CFSocketInvalidate(*((CFSocketRef *)cf + 5));
        CFRelease(*((CFTypeRef *)cf + 5));
        *((void *)cf + 5) = 0LL;
        DNSServiceRefDeallocate(*((DNSServiceRef *)cf + 6));
        CFStringRef v15 = 0LL;
        *((void *)cf + 6) = 0LL;
LABEL_18:
        DNSServiceErrorType v13 = (void (*)(char *, void, CFStringRef, __int128 *, uint64_t))*((void *)cf + 12);
        __int128 v18 = *(_OWORD *)(cf + 24);
        uint64_t v14 = *((void *)cf + 14);
        goto LABEL_19;
      }

      if (a4 == -65554)
      {
        int v12 = -72002;
        goto LABEL_17;
      }
    }

    int v12 = -72000;
    goto LABEL_17;
  }

void _SocketCallBack( __CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, DNSServiceRef *cf)
{
  uint64_t v6 = (_DNSServiceRef_t *)DNSServiceProcessResult(cf[6]);
  if ((_DWORD)v6)
  {
    if (*((_BYTE *)cf + 20)) {
      _DomainEnumReply(v6, 0, v7, (int)v6, 0LL, (char *)cf);
    }
    else {
      _BrowseReply(v6, 0, v7, (int)v6, 0LL, 0LL, 0LL, (char *)cf);
    }
  }

  CFRelease(cf);
}

BOOL _BrowserBlockUntilComplete(os_unfair_lock_s *a1)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  CFNetServiceBrowserScheduleWithRunLoop( (CFNetServiceBrowserRef)a1,  Current,  @"_kCFNetServiceBrowserBlockingMode");
  os_unfair_lock_lock(a1 + 4);
  while (*(void *)&a1[10]._os_unfair_lock_opaque)
  {
    os_unfair_lock_unlock(a1 + 4);
    CFRunLoopRunInMode(@"_kCFNetServiceBrowserBlockingMode", 1.79769313e308, 1u);
    os_unfair_lock_lock(a1 + 4);
  }

  BOOL v3 = a1[8]._os_unfair_lock_opaque == 0;
  os_unfair_lock_unlock(a1 + 4);
  CFNetServiceBrowserUnscheduleFromRunLoop( (CFNetServiceBrowserRef)a1,  Current,  @"_kCFNetServiceBrowserBlockingMode");
  return v3;
}

void CFNetServiceBrowserScheduleWithRunLoop( CFNetServiceBrowserRef browser, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)browser + 11), runLoop, runLoopMode))
  {
    unsigned int v7 = (void *)*((void *)browser + 5);
    if (v7) {
      _CFTypeScheduleOnRunLoop(v7, (uint64_t)runLoop, (uint64_t)runLoopMode);
    }
  }

  os_unfair_lock_unlock(v6);
}

void CFNetServiceBrowserUnscheduleFromRunLoop( CFNetServiceBrowserRef browser, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  uint64_t v6 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)browser + 11), runLoop, runLoopMode))
  {
    unsigned int v7 = (void *)*((void *)browser + 5);
    if (v7) {
      _CFTypeUnscheduleFromRunLoop(v7, (uint64_t)runLoop, (uint64_t)runLoopMode);
    }
  }

  os_unfair_lock_unlock(v6);
}

void _BrowseReply( _DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, const char *a6, const char *a7, char *cf)
{
  if (a4 != -65570)
  {
    uint64_t v46 = v8;
    uint64_t v47 = v9;
    __int128 v45 = 0uLL;
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((void *)cf + 6)) {
      goto LABEL_51;
    }
    if (a4)
    {
      int v16 = -72008;
      if (a4 > -65549)
      {
        if (a4 == -65548)
        {
          int v16 = -72001;
          goto LABEL_20;
        }

        if (a4 == -65540)
        {
          int v16 = -72004;
          goto LABEL_20;
        }
      }

      else
      {
        if (a4 == -65555)
        {
LABEL_20:
          *((void *)cf + 3) = 10LL;
          *((_DWORD *)cf + _Block_object_dispose(va, 8) = v16;
          _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
          CFSocketInvalidate(*((CFSocketRef *)cf + 5));
          CFRelease(*((CFTypeRef *)cf + 5));
          *((void *)cf + 5) = 0LL;
          DNSServiceRefDeallocate(*((DNSServiceRef *)cf + 6));
          *((void *)cf + 6) = 0LL;
          CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)cf + 8));
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 9));
          CFArrayRemoveAllValues(*((CFMutableArrayRef *)cf + 10));
          goto LABEL_21;
        }

        if (a4 == -65554)
        {
          int v16 = -72002;
          goto LABEL_20;
        }
      }

      int v16 = -72000;
      goto LABEL_20;
    }

    if (!a5 || !a6 || !a7) {
      goto LABEL_21;
    }
    int v17 = CFGetAllocator(cf);
    __int128 v18 = CFStringCreateWithCString(v17, a7, 0x8000100u);
    uint64_t v19 = CFStringCreateWithCString(v17, a6, 0x8000100u);
    uint64_t v20 = CFStringCreateWithCString(v17, a5, 0x8000100u);
    uint64_t v21 = v20;
    if (v18 && v19 && v20)
    {
      CFNetServiceRef v22 = CFNetServiceCreate(v17, v18, v19, v20, -1);
    }

    else
    {
      CFNetServiceRef v22 = 0LL;
      __int128 v32 = 0LL;
      if (!v18) {
        goto LABEL_34;
      }
    }

    CFRelease(v18);
    __int128 v32 = v22;
LABEL_34:
    if (v19) {
      CFRelease(v19);
    }
    if (v21) {
      CFRelease(v21);
    }
    if (!v32) {
      goto LABEL_21;
    }
    uint64_t v33 = *((void *)cf + 7);
    if ((v33 & 1) != 0)
    {
      unsigned int v34 = 7;
    }

    else
    {
      if ((v33 & 2) == 0) {
        goto LABEL_56;
      }
      unsigned int v34 = 9;
    }

    _ServiceSetInfo(v32, v34, (const void *)*MEMORY[0x189604DE8], 0);
LABEL_56:
    unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)cf + 8), v32);
    if ((a2 & 2) != 0)
    {
      if (!Value)
      {
        uint64_t v43 = (const __CFArray *)*((void *)cf + 10);
        v49.length = CFArrayGetCount(v43);
        v49.CFIndex location = 0LL;
        FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(v43, v49, v32);
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)cf + 8), v32, (const void *)1);
        CFArrayAppendValue(*((CFMutableArrayRef *)cf + 9), v32);
        if (FirstIndexOfValue != -1)
        {
          double v42 = (__CFArray *)*((void *)cf + 10);
          goto LABEL_65;
        }

BOOL _CFNetServiceBrowserSearchForServices(char *cf, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (a5) {
    *a5 = 0LL;
  }
  CFRetain(cf);
  Boolean v10 = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
  lock = (os_unfair_lock_s *)(cf + 16);
  os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
  v39[0] = a3;
  v39[1] = a2;
  context.version = 0LL;
  context.info = cf;
  context.retain = v10;
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
  context.copyDescription = 0LL;
  if (!*((void *)cf + 12))
  {
    if (!a5)
    {
LABEL_35:
      BOOL v19 = 0LL;
      goto LABEL_37;
    }

    BOOL v19 = 0LL;
    *a5 = __cfnCreateCFError(0LL, @"kCFErrorDomainCFNetwork", -72006LL, v11, v12, v13, v14, v15, 0LL);
    goto LABEL_32;
  }

  int v16 = -72008;
  int v17 = (const void *)*((void *)cf + 5);
  if (v17)
  {
    CFTypeID v18 = CFGetTypeID(v17);
    if (v18 == CFSocketGetTypeID())
    {
      BOOL v19 = 0LL;
      *((void *)cf + 3) = 10LL;
      *((_DWORD *)cf + _Block_object_dispose(va, 8) = -72003;
      goto LABEL_32;
    }

    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)cf + 5));
    CFRelease(*((CFTypeRef *)cf + 5));
    *((void *)cf + 5) = 0LL;
  }

  uint64_t v20 = 0LL;
  char v21 = 1;
  do
  {
    char v22 = v21;
    uint64_t v23 = (const __CFString *)v39[v20];
    if (v23)
    {
      v43.length = CFStringGetLength((CFStringRef)v39[v20]);
      uint64_t v24 = (UInt8 *)&regtype[1024 * v20];
      v43.CFIndex location = 0LL;
      CFStringGetBytes(v23, v43, 0x8000100u, 0, 0, v24, 1023LL, &usedBufLen);
      v24[usedBufLen] = 0;
    }

    else
    {
      regtype[1024 * v20] = 0;
    }

    char v21 = 0;
    uint64_t v20 = 1LL;
  }

  while ((v22 & 1) != 0);
  cf[20] = 0;
  *((void *)cf + 7) = a4;
  if ((a4 & 1) != 0) {
    DNSServiceFlags v25 = 0x100000;
  }
  else {
    DNSServiceFlags v25 = ((_DWORD)a4 << 19) & 0x100000;
  }
  DNSServiceErrorType v26 = DNSServiceBrowse((DNSServiceRef *)cf + 6, v25, 0, regtype, v41, (DNSServiceBrowseReply)_BrowseReply, cf);
  *((_DWORD *)cf + _Block_object_dispose(va, 8) = v26;
  if (v26 <= -65549)
  {
    if (v26 == -65555) {
      goto LABEL_31;
    }
    if (v26 == -65554)
    {
      int v16 = -72002;
      goto LABEL_31;
    }

    goto LABEL_30;
  }

  if (v26 == -65548)
  {
    int v16 = -72001;
    goto LABEL_31;
  }

  if (v26)
  {
    if (v26 == -65540)
    {
      int v16 = -72004;
LABEL_31:
      BOOL v19 = 0LL;
      *((void *)cf + 3) = 10LL;
      *((_DWORD *)cf + _Block_object_dispose(va, 8) = v16;
      goto LABEL_32;
    }

Boolean CFNetServiceBrowserSearchForServices( CFNetServiceBrowserRef browser, CFStringRef domain, CFStringRef serviceType, CFStreamError *error)
{
  CFTypeRef cf = 0LL;
  BOOL v5 = _CFNetServiceBrowserSearchForServices( (char *)browser,  (uint64_t)domain,  (uint64_t)serviceType,  0LL,  (CFErrorRef *)&cf);
  Boolean v6 = v5;
  if (error && !v5)
  {
    error->domain = _CFStreamErrorFromCFError((__CFError *)cf);
    *(void *)&error->CFErrorRef error = v7;
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

void CFNetServiceBrowserStopSearch(CFNetServiceBrowserRef browser, CFStreamError *error)
{
  uint64_t v16 = 10LL;
  int v17 = -72005;
  if (error) {
    BOOL v3 = error;
  }
  else {
    BOOL v3 = (CFStreamError *)&v16;
  }
  uint64_t v4 = (os_unfair_lock_s *)((char *)browser + 16);
  os_unfair_lock_lock((os_unfair_lock_t)browser + 4);
  BOOL v5 = (void *)*((void *)browser + 5);
  if (v5)
  {
    v15.version = 0LL;
    v15.info = browser;
    v15.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
    v15.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
    memset(&v15.copyDescription, 0, 40);
    v15.perform = (void (__cdecl *)(void *))_BrowserCancel;
    _CFTypeUnscheduleFromMultipleRunLoops(v5, *((const __CFArray **)browser + 11));
    _CFTypeInvalidate(*((char **)browser + 5));
    CFRelease(*((CFTypeRef *)browser + 5));
    Boolean v6 = (_DNSServiceRef_t *)*((void *)browser + 6);
    if (v6)
    {
      DNSServiceRefDeallocate(v6);
      *((void *)browser + 6) = 0LL;
      CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)browser + 8));
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 9));
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)browser + 10));
    }

    *(CFStreamError *)((char *)browser + 24) = *v3;
    uint64_t v7 = CFGetAllocator(browser);
    CFRunLoopSourceRef v8 = CFRunLoopSourceCreate(v7, 0LL, &v15);
    *((void *)browser + 5) = v8;
    if (v8)
    {
      uint64_t v9 = (const __CFArray *)*((void *)browser + 11);
      CFIndex Count = CFArrayGetCount(v9);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)browser + 5), v9);
      CFRunLoopSourceSignal(*((CFRunLoopSourceRef *)browser + 5));
      if (Count >= 1)
      {
        for (CFIndex i = 0LL; i < Count; i += 2LL)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v9, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            uint64_t v13 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v13)
            {
              uint64_t v14 = v13;
              if (CFRunLoopContainsSource(ValueAtIndex, *((CFRunLoopSourceRef *)browser + 5), v13)) {
                CFRunLoopWakeUp(ValueAtIndex);
              }
              CFRelease(v14);
            }
          }
        }
      }
    }
  }

  os_unfair_lock_unlock(v4);
}

void _BrowserCancel(__CFNetServiceBrowser *a1)
{
  size_t v2 = (void *)*((void *)a1 + 5);
  if (v2)
  {
    BOOL v3 = (void (*)(__CFNetServiceBrowser *, void, void, __int128 *, uint64_t))*((void *)a1 + 12);
    __int128 v9 = *(_OWORD *)((char *)a1 + 24);
    uint64_t v5 = *((void *)a1 + 14);
    uint64_t v4 = (void (*)(void))*((void *)a1 + 15);
    Boolean v6 = (void (*)(uint64_t))*((void *)a1 + 16);
    if (v3) {
      BOOL v7 = v5 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7 && v4 != 0LL)
    {
      v4(*((void *)a1 + 14));
      size_t v2 = (void *)*((void *)a1 + 5);
    }

    _CFTypeUnscheduleFromMultipleRunLoops(v2, *((const __CFArray **)a1 + 11));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)a1 + 5));
    CFRelease(*((CFTypeRef *)a1 + 5));
    *((void *)a1 + 5) = 0LL;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    if (v3)
    {
      v3(a1, 0LL, 0LL, &v9, v5);
      if (v5)
      {
        if (v6) {
          v6(v5);
        }
      }
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  }

  CFRelease(a1);
}

void HTTP3ConnectionCacheEntry::~HTTP3ConnectionCacheEntry(HTTP3ConnectionCacheEntry *this)
{
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  void **v7;
  *(void *)this = off_189C03360;
  size_t v2 = *((void *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
    *((void *)this + 10) = 0LL;
  }

  BOOL v3 = *((void *)this + 11);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 48LL))(v3);
    *((void *)this + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  }

  if (*((void *)this + 12)) {
    *((void *)this + 12) = 0LL;
  }
  uint64_t v4 = *((void *)this + 16);
  *((void *)this + 16) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  BOOL v7 = (void **)((char *)this + 104);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&v7);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  *(void *)this = off_189C19AE8;
  Boolean v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_182A27BBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v12 = *(void *)(v10 + 128);
  *(void *)(v10 + 12_Block_object_dispose(va, 8) = 0LL;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
  }
  a10 = (void **)(v10 + 104);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a10);
  uint64_t v13 = *(std::__shared_weak_count **)(v10 + 32);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)uint64_t v10 = off_189C19AE8;
  uint64_t v14 = *(std::__shared_weak_count **)(v10 + 16);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(a1);
}

void std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  size_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v4 - 16);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void HTTP3ConnectionCacheEntry::enqueueRequestForProtocol(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFRunLoopSourceRef v8 = (__CFHTTPMessage *)(a3 - 16);
  __int128 v9 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(a3 - 16));
  if (a2) {
    uint64_t v10 = a2 - 176;
  }
  else {
    uint64_t v10 = 0LL;
  }
  if ((HTTPProtocol::canUseH2WithCurrentAuthScheme((HTTPProtocol *)v10, v9) & 1) == 0) {
    goto LABEL_136;
  }
  v113 = v9;
  uint64_t v11 = *MEMORY[0x189604DB0];
  CFHTTPMessageRef Copy = CFHTTPMessageCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v8);
  v121[0] = MEMORY[0x1895F87A8];
  v121[1] = 3221225472LL;
  v122 = ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke;
  v123 = &__block_descriptor_40_e5_v8__0l;
  CFHTTPMessageRef v124 = Copy;
  uint64_t v13 = (void *)a1[16];
  uint64_t v114 = a1;
  if (*((_BYTE *)Copy + 40)) {
    uint64_t v14 = 0LL;
  }
  else {
    uint64_t v14 = (CFHTTPMessageRef)((char *)Copy + 16);
  }
  AuthenticationCache::processRequest(v13, a2, v14);
  if (*((_BYTE *)Copy + 40)) {
    CFRunLoopSourceContext v15 = 0LL;
  }
  else {
    CFRunLoopSourceContext v15 = (CFHTTPMessageRef)((char *)Copy + 16);
  }
  AuthenticationCache::applyAuthenticationToRequest(a2, v15);
  int v110 = *((unsigned __int8 *)Copy + 40);
  if (*((_BYTE *)Copy + 40)) {
    uint64_t v16 = 0LL;
  }
  else {
    uint64_t v16 = (char *)Copy + 16;
  }
  uint64_t v112 = (uint64_t)v16;
  v119 = 0LL;
  v120 = 0LL;
  uint64_t v17 = a1[13];
  uint64_t v18 = a1[14];
  while (v17 != v18)
  {
    uint64_t v20 = *(HTTP3Connection **)v17;
    BOOL v19 = *(std::__shared_weak_count **)(v17 + 8);
    *(void *)&__int128 v125 = *(void *)v17;
    *((void *)&v125 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v19;
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v22 = __ldxr(p_shared_owners);
      while (__stxr(v22 + 1, p_shared_owners));
    }

    if (HTTP3Connection::willEnqueueRequests(v20))
    {
      if (v19)
      {
        DNSServiceFlags v25 = (unint64_t *)&v19->__shared_owners_;
        do
          unint64_t v26 = __ldxr(v25);
        while (__stxr(v26 + 1, v25));
      }

      v119 = v20;
      v120 = v19;
      if (*((void *)&v125 + 1))
      {
        CFIndex v27 = (unint64_t *)(*((void *)&v125 + 1) + 8LL);
        do
          unint64_t v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          (*(void (**)(void))(**((void **)&v125 + 1) + 16LL))(*((void *)&v125 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v125 + 1));
        }
      }

      break;
    }

    if (v19)
    {
      uint64_t v23 = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }

    v17 += 16LL;
  }

  uint64_t v29 = (int64x2_t *)v119;
  if (v119)
  {
    if ([*(id *)(v10 + 80) _preconnect])
    {
      uint64_t v30 = *((void *)v119 + 126);
      id v31 = (std::__shared_weak_count *)*((void *)v119 + 127);
      *(void *)&__int128 v125 = v30;
      *((void *)&v125 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v31;
      if (v31)
      {
        __int128 v32 = (unint64_t *)&v31->__shared_owners_;
        do
          unint64_t v33 = __ldxr(v32);
        while (__stxr(v33 + 1, v32));
      }

      __int128 v9 = v113;
      if (v30)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 744LL))(v10);
        int v34 = (_BYTE *)objc_claimAutoreleasedReturnValue();
        (*(void (**)(uint64_t))(*(void *)v30 + 248LL))(v30);
        CFIndex v35 = (void *)objc_claimAutoreleasedReturnValue();
        -[__CFN_TransactionMetrics linkWithConnection:](v34, v35);

        (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 88LL))(v30, 1LL);
      }

      if (v31)
      {
        id v36 = (unint64_t *)&v31->__shared_owners_;
        do
          unint64_t v37 = __ldaxr(v36);
        while (__stlxr(v37 - 1, v36));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }

      uint64_t v38 = *((void *)v119 + 126);
      if (v38) {
        char v39 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v38 + 216LL))(v38, 0x18C5ACD08LL);
      }
      else {
        char v39 = 0LL;
      }
      BOOL v101 = *(void **)(v10 + 80);
      if (v101) {
        objc_msgSend(v101, "set_TCPConnectionMetadata:", v39);
      }
      if (v39) {
        CFRelease(v39);
      }
      URLProtocol::sendDidFinishLoading((URLProtocol *)v10);
      goto LABEL_130;
    }

    float v43 = *(float *)(a4 + 4);
    int v44 = *(unsigned __int8 *)(a4 + 16);
    double v45 = 0.0;
    if (*((void *)v119 + 142) == *((void *)v119 + 143))
    {
      (*(void (**)(void, void))(**((void **)v119 + 126) + 88LL))(*((void *)v119 + 126), 0LL);
      (*(void (**)(void, void, void))(**((void **)v119 + 126) + 136LL))( *((void *)v119 + 126),  0LL,  0LL);
      (*(void (**)(void))(**((void **)v119 + 126) + 248LL))(*((void *)v119 + 126));
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue();
      double Current = CFAbsoluteTimeGetCurrent();
      (*(void (**)(void))(**((void **)v119 + 126) + 248LL))(*((void *)v119 + 126));
      CFRange v48 = (double *)objc_claimAutoreleasedReturnValue();
      if (v48) {
        double v49 = v48[22];
      }
      else {
        double v49 = 0.0;
      }
      double v45 = Current - v49;
    }

    uint64_t v50 = MEMORY[0x186E12804](v11, 48LL, 0LL);
    *(_OWORD *)(v50 + 16) = 0u;
    *(_OWORD *)(v50 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
    *(_OWORD *)uint64_t v50 = 0u;
    uint64_t v51 = (void *)v29[62].i64[1];
    size_t v53 = (std::__shared_weak_count_vtbl *)v29->i64[1];
    uint64_t v52 = (std::__shared_weak_count *)v29[1].i64[0];
    if (v52)
    {
      p_shared_weak_owners = (unint64_t *)&v52->__shared_weak_owners_;
      do
        unint64_t v55 = __ldxr(p_shared_weak_owners);
      while (__stxr(v55 + 1, p_shared_weak_owners));
    }

    BOOL v56 = v44 != 0;
    id v57 = v51;
    *(void *)uint64_t v50 = off_189C06BF8;
    *(void *)(v50 + _Block_object_dispose(va, 8) = v11;
    *(_DWORD *)(v50 + 16) = 1;
    if (((v50 + 16) & 3) != 0) {
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    }
    CFTypeRef v58 = v57;
    BOOL v107 = v56;
    *(void *)(v50 + 24) = &unk_189C08640;
    *(void *)uint64_t v50 = off_189C08568;
    *(void *)(v50 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
    CFNumberRef v109 = (__int128 *)(v50 + 32);
    *(void *)(v50 + 40) = 0LL;
    CFTypeRef v59 = (std::__shared_weak_count *)operator new(0x1A0uLL);
    v59->__shared_owners_ = 0LL;
    CFAbsoluteTime v60 = (unint64_t *)&v59->__shared_owners_;
    v59->__shared_weak_owners_ = 0LL;
    v59->__vftable = (std::__shared_weak_count_vtbl *)off_189C08710;
    if (v52)
    {
      CFTypeRef v61 = (unint64_t *)&v52->__shared_weak_owners_;
      do
        unint64_t v62 = __ldxr(v61);
      while (__stxr(v62 + 1, v61));
    }

    id v63 = v58;
    v59[2].__vftable = 0LL;
    v59[1].__shared_owners_ = 0LL;
    v59[1].__shared_weak_owners_ = 0LL;
    v59[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C09148;
    v59[2].__shared_owners_ = 0LL;
    id v108 = v63;
    v59[2].__shared_weak_owners_ = (uint64_t)v108;
    v59[3].__vftable = v53;
    v59[3].__shared_owners_ = (uint64_t)v52;
    if (v52)
    {
      CFTypeRef v64 = (unint64_t *)&v52->__shared_weak_owners_;
      do
        unint64_t v65 = __ldxr(v64);
      while (__stxr(v65 + 1, v64));
    }

    if (!v110) {
      CFRetain((CFTypeRef)(v112 - 16));
    }
    v59[3].__shared_weak_owners_ = v112;
    signed int v66 = (std::__shared_weak_count_vtbl *)operator new(0x20uLL);
    v66->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))off_189C17828;
    v66->~__shared_weak_count_0 = 0LL;
    v66->__on_zero_shared = 0LL;
    v66->__get_deleter = (const void *(__cdecl *)(const std::__shared_weak_count *__hidden, const std::type_info *))v112;
    v59[8].__shared_weak_owners_ = 0LL;
    *(_OWORD *)&v59[4].__shared_owners_ = 0u;
    v59[5].std::__shared_count = 0u;
    v59[4].__vftable = v66;
    *(_OWORD *)((char *)&v59[5].__shared_owners_ + 4) = 0u;
    *(_DWORD *)((char *)&v59[6].__vftable + 6) = 0;
    WORD1(v59[6].__shared_owners_) = 1;
    BYTE4(v59[6].__shared_owners_) = 0;
    *(_OWORD *)&v59[6].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v59[7].__shared_owners_ = 0u;
    v59[8].__vftable = (std::__shared_weak_count_vtbl *)-1LL;
    BYTE1(v59[8].__shared_owners_) = 0;
    v59[9].__vftable = 0LL;
    v59[9].__shared_owners_ = 0LL;
    v59[12].__shared_weak_owners_ = 0LL;
    v59[13].__vftable = 0LL;
    LODWORD(v59[12].__shared_owners_) = 0;
    v59[11].__shared_weak_owners_ = 0LL;
    v59[12].__vftable = 0LL;
    if (a2) {
      (*(void (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
    }
    v59[13].__shared_owners_ = a2;
    BOOL v67 = operator new(0x20uLL);
    *BOOL v67 = off_189C09468;
    v67[1] = 0LL;
    v67[2] = 0LL;
    v67[3] = a2;
    v59[13].__shared_weak_owners_ = (uint64_t)v67;
    v59[14].__vftable = 0LL;
    v59[14].__shared_owners_ = 0LL;
    v59[14].__shared_weak_owners_ = 0LL;
    v59[15].__vftable = (std::__shared_weak_count_vtbl *)-1LL;
    v59[15].__shared_owners_ = 0LL;
    (*(void (**)(uint64_t))(*(void *)a2 + 72LL))(a2);
    uint64_t v68 = v59 + 1;
    LOWORD(v59[16].__shared_owners_) = 0;
    v59[16].__shared_weak_owners_ = 0LL;
    if (v43 >= 0.5) {
      float v69 = (float)((float)(1.0 - v43) * 20.0) / 3.0;
    }
    else {
      float v69 = ceilf((float)(0.7 - v43) * 10.0);
    }
    BYTE4(v59[6].__vftable) = (int)v69;
    BYTE5(v59[6].__vftable) = v107;
    *(double *)&v59[17].__vftable = v45;

    if (v52) {
      std::__shared_weak_count::__release_weak(v52);
    }
    *(void *)&__int128 v125 = v59 + 1;
    *((void *)&v125 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v59;
    shared_weak_owners = (std::__shared_weak_count *)v59[1].__shared_weak_owners_;
    if (shared_weak_owners)
    {
      if (shared_weak_owners->__shared_owners_ != -1)
      {
LABEL_92:
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v109, &v125);
        BOOL v78 = (std::__shared_weak_count *)*((void *)&v125 + 1);
        if (*((void *)&v125 + 1))
        {
          CFDateRef v79 = (unint64_t *)(*((void *)&v125 + 1) + 8LL);
          do
            unint64_t v80 = __ldaxr(v79);
          while (__stlxr(v80 - 1, v79));
          if (!v80)
          {
            ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
            std::__shared_weak_count::__release_weak(v78);
          }
        }

        if (v52) {
          std::__shared_weak_count::__release_weak(v52);
        }
        __int128 v125 = *v109;
        __int128 v81 = v125;
        if (*((void *)&v125 + 1))
        {
          __int128 v82 = (unint64_t *)(*((void *)&v125 + 1) + 8LL);
          do
            unint64_t v83 = __ldxr(v82);
          while (__stxr(v83 + 1, v82));
        }

        v84 = (__int128 *)v29[71].i64[1];
        unint64_t v85 = v29[72].u64[0];
        if ((unint64_t)v84 >= v85)
        {
          *(_OWORD *)int v111 = v81;
          uint64_t v87 = v29[71].i64[0];
          uint64_t v88 = ((uint64_t)v84 - v87) >> 4;
          uint64_t v89 = v85 - v87;
          uint64_t v90 = v89 >> 3;
          else {
            unint64_t v91 = v90;
          }
          uint64_t v92 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(v91);
          char v94 = &v92[16 * v88];
          *(_OWORD *)char v94 = *(_OWORD *)v111;
          uint64_t v95 = (void *)v29[71].i64[1];
          CFTypeID v96 = (void *)v29[71].i64[0];
          if (v95 == v96)
          {
            int64x2_t v99 = vdupq_n_s64((unint64_t)v95);
            char v97 = &v92[16 * v88];
          }

          else
          {
            char v97 = &v92[16 * v88];
            do
            {
              __int128 v98 = *((_OWORD *)v95 - 1);
              v95 -= 2;
              *((_OWORD *)v97 - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v98;
              v97 -= 16;
              *uint64_t v95 = 0LL;
              v95[1] = 0LL;
            }

            while (v95 != v96);
            int64x2_t v99 = v29[71];
          }

          uint64_t v86 = v94 + 16;
          v29[71].i64[0] = (uint64_t)v97;
          v29[71].i64[1] = (uint64_t)(v94 + 16);
          v29[72].i64[0] = (uint64_t)&v92[16 * v93];
          uint64_t v102 = v99.i64[1];
          int v103 = (void *)v99.i64[0];
          if (v103) {
            operator delete(v103);
          }
        }

        else
        {
          __int128 *v84 = v81;
          uint64_t v86 = v84 + 1;
        }

        v29[71].i64[1] = (uint64_t)v86;
        v115[0] = MEMORY[0x1895F87A8];
        v115[1] = 3221225472LL;
        unsigned __int8 v116 = ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke_2;
        unsigned __int8 v117 = &__block_descriptor_40_e5_v8__0l;
        uint64_t v118 = v50;
        __int128 v9 = v113;
        if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)a2 + 80LL))( a2,  v50 + 24,  v112,  *((unsigned __int8 *)v114 + 136)))
        {
          *((_BYTE *)v114 + 136) = 0;
        }

        v116((uint64_t)v115);
        goto LABEL_130;
      }

      do
        unint64_t v71 = __ldxr(v60);
      while (__stxr(v71 + 1, v60));
      uint64_t v72 = (unint64_t *)&v59->__shared_weak_owners_;
      do
        unint64_t v73 = __ldxr(v72);
      while (__stxr(v73 + 1, v72));
      v59[1].__shared_owners_ = (uint64_t)v68;
      v59[1].__shared_weak_owners_ = (uint64_t)v59;
      std::__shared_weak_count::__release_weak(shared_weak_owners);
    }

    else
    {
      do
        unint64_t v74 = __ldxr(v60);
      while (__stxr(v74 + 1, v60));
      CFStringRef v75 = (unint64_t *)&v59->__shared_weak_owners_;
      do
        unint64_t v76 = __ldxr(v75);
      while (__stxr(v76 + 1, v75));
      v59[1].__shared_owners_ = (uint64_t)v68;
      v59[1].__shared_weak_owners_ = (uint64_t)v59;
    }

    do
      unint64_t v77 = __ldaxr(v60);
    while (__stlxr(v77 - 1, v60));
    if (!v77)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }

    goto LABEL_92;
  }

  __int128 v9 = v113;
  uint64_t v40 = v114[12];
  uint64_t v41 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32LL))(a2);
  TubeManager::invalidateKey(v40, v41, 1, 2u);
  uint64_t v42 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32LL))(a2);
  if (CFStringCompare(*(CFStringRef *)(v42 + 32), *(CFStringRef *)(v42 + 136), 0LL))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a2 - 176) + 280LL))( a2 - 176,  4LL,  4294965096LL,  0LL);
  }

  else
  {
    CFRange v100 = (CFArrayRef *)v114[12];
    __int128 v125 = *(_OWORD *)a4;
    uint64_t v126 = *(void *)(a4 + 16);
    TubeManager::_onqueue_enqueueRequestForProtocol(v100, a2, a3, &v125, 0LL);
  }

void sub_182A286F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20, CFTypeRef cf, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, char a30, uint64_t a31, void (*a32)(char *))
{
  if (v32) {
    CFRelease(v32);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  a32(&a30);
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(a1);
}

void ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t ___ZN25HTTP3ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48LL))(*(void *)(a1 + 32));
}

void ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke(uint64_t a1)
{
}

uint64_t ___ZN11URLProtocol20sendDidFinishLoadingEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  size_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 199LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t ___ZN25HTTP3ConnectionCacheEntry10ingestTubeEP4Tubeb_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    (*(void (**)(uint64_t, void))(*(void *)result + 56LL))(result, 0LL);
    return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48LL))(*(void *)(a1 + 32));
  }

  return result;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

void std::__shared_ptr_emplace<HTTP3Connection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C033D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3Connection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C033D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<HTTP3Connection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void HTTP3ConnectionCacheEntry::stopConnections( HTTP3ConnectionCacheEntry *this, HTTP3ConnectionCacheEntry *a2, char a3)
{
  if (this != a2)
  {
    uint64_t v5 = this;
    do
    {
      Boolean v6 = *(HTTP3Connection **)v5;
      BOOL v7 = (std::__shared_weak_count *)*((void *)v5 + 1);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          unint64_t v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }

      HTTP3Connection::stop(v6, a3);
      if (v7)
      {
        uint64_t v10 = (unint64_t *)&v7->__shared_owners_;
        do
          unint64_t v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }

      uint64_t v5 = (HTTP3ConnectionCacheEntry *)((char *)v5 + 16);
    }

    while (v5 != a2);
  }

void sub_182A28AB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN25HTTP3ConnectionCacheEntry16connectionClosedENSt3__110shared_ptrI15HTTP3ConnectionEE_block_invoke( void *a1)
{
  uint64_t v1 = a1[4];
  uint64_t v2 = a1[6];
  BOOL v3 = (std::__shared_weak_count *)a1[7];
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  Boolean v6 = *(void **)(v1 + 104);
  uint64_t v7 = *(void *)(v1 + 112);
  CFRunLoopSourceRef v8 = v6;
  if (v6 != (void *)v7)
  {
    while (*v8 != v2)
    {
      v8 += 2;
      if (v8 == (void *)v7)
      {
        CFRunLoopSourceRef v8 = *(void **)(v1 + 112);
        break;
      }
    }
  }

  if (v8 == (void *)v7)
  {
    CFRunLoopSourceRef v8 = *(void **)(v1 + 112);
  }

  else
  {
    unint64_t v9 = v8 + 2;
    if (v8 + 2 != (void *)v7)
    {
      do
      {
        __int128 v10 = *(_OWORD *)v9;
        *unint64_t v9 = 0LL;
        v9[1] = 0LL;
        unint64_t v11 = (std::__shared_weak_count *)v8[1];
        *(_OWORD *)CFRunLoopSourceRef v8 = v10;
        if (v11)
        {
          uint64_t v12 = (unint64_t *)&v11->__shared_owners_;
          do
            unint64_t v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }

        v9 += 2;
        v8 += 2;
      }

      while (v9 != (void *)v7);
      uint64_t v7 = *(void *)(v1 + 112);
    }

    while ((void *)v7 != v8)
    {
      v7 -= 16LL;
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7);
    }

    *(void *)(v1 + 112) = v8;
    Boolean v6 = *(void **)(v1 + 104);
  }

  if (v8 == v6)
  {
    uint64_t v16 = *(std::__shared_weak_count **)(v1 + 32);
    if (v16)
    {
      uint64_t v17 = std::__shared_weak_count::lock(v16);
      if (v17)
      {
        uint64_t v18 = v17;
        BOOL v19 = *(HTTP3ConnectionCache **)(v1 + 24);
        if (v19) {
          HTTP3ConnectionCache::_entryRemove(v19, *(const HTTPConnectionCacheKey **)(v1 + 80));
        }
        uint64_t v20 = (unint64_t *)&v18->__shared_owners_;
        do
          unint64_t v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }
  }

  if (v3)
  {
    uint64_t v14 = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_182A28C88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void *__copy_helper_block_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    BOOL v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    Boolean v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE( uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void _CFTypeScheduleOnRunLoop(void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceRef RunLoopSource = (void *)CFRetain(a1);
  }

  else if (v6 == CFMachPortGetTypeID())
  {
    CFRunLoopSourceRef v8 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0LL);
  }

  else
  {
    if (v6 != CFSocketGetTypeID())
    {
      if (v6 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
      {
        uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CoreReadStreamScheduleWithRunLoop;
      }

      else
      {
        if (v6 == *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
        {
          uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CoreWriteStreamScheduleWithRunLoop;
        }

        else if (v6 == CFReadStreamGetTypeID())
        {
          uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1896030A8];
        }

        else if (v6 == CFWriteStreamGetTypeID())
        {
          uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x189603968];
        }

        else
        {
          if (v6 == *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
          {
            uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFHostScheduleWithRunLoop;
          }

          else if (v6 == SCNetworkReachabilityGetTypeID())
          {
            uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x18960C318];
          }

          else
          {
            if (v6 == CFRunLoopTimerGetTypeID())
            {
              CFTypeRef v10 = CFRetain(a1);
              unint64_t v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x189603110];
              if (v10) {
                goto LABEL_8;
              }
              return;
            }

            if (v6 == CFNetServiceGetTypeID())
            {
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceScheduleWithRunLoop;
            }

            else if (v6 == CFNetServiceBrowserGetTypeID())
            {
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceBrowserScheduleWithRunLoop;
            }

            else if (v6 == CFNetServiceMonitorGetTypeID())
            {
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceMonitorScheduleWithRunLoop;
            }

            else
            {
              if (v6 != SCNetworkConnectionGetTypeID()) {
                return;
              }
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x18960C268];
            }
          }
        }
      }

      v12(a1, a2, a3);
      return;
    }

    unint64_t v9 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0LL);
  }

  CFTypeRef v10 = RunLoopSource;
  unint64_t v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x189603108];
  if (RunLoopSource)
  {
LABEL_8:
    v11(a2, v10, a3);
    CFRelease(v10);
  }

void _CFTypeUnscheduleFromRunLoop(void *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceRef RunLoopSource = (void *)CFRetain(a1);
  }

  else if (v6 == CFMachPortGetTypeID())
  {
    CFRunLoopSourceRef v8 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0LL);
  }

  else
  {
    if (v6 != CFSocketGetTypeID())
    {
      if (v6 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
      {
        uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CoreReadStreamUnscheduleFromRunLoop;
      }

      else
      {
        if (v6 == *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
        {
          uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CoreWriteStreamUnscheduleFromRunLoop;
        }

        else if (v6 == CFReadStreamGetTypeID())
        {
          uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x1896030D0];
        }

        else if (v6 == CFWriteStreamGetTypeID())
        {
          uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x189603990];
        }

        else
        {
          if (v6 == *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
          {
            uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFHostUnscheduleFromRunLoop;
          }

          else if (v6 == SCNetworkReachabilityGetTypeID())
          {
            uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x18960C330];
          }

          else
          {
            if (v6 == CFRunLoopTimerGetTypeID())
            {
              CFTypeRef v10 = CFRetain(a1);
              unint64_t v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x189603188];
              if (v10) {
                goto LABEL_8;
              }
              return;
            }

            if (v6 == CFNetServiceGetTypeID())
            {
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceUnscheduleFromRunLoop;
            }

            else if (v6 == CFNetServiceBrowserGetTypeID())
            {
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceBrowserUnscheduleFromRunLoop;
            }

            else if (v6 == CFNetServiceMonitorGetTypeID())
            {
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))CFNetServiceMonitorUnscheduleFromRunLoop;
            }

            else
            {
              if (v6 != SCNetworkConnectionGetTypeID()) {
                return;
              }
              uint64_t v12 = (void (*)(void *, uint64_t, uint64_t))MEMORY[0x18960C270];
            }
          }
        }
      }

      v12(a1, a2, a3);
      return;
    }

    unint64_t v9 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0LL);
  }

  CFTypeRef v10 = RunLoopSource;
  unint64_t v11 = (void (*)(uint64_t, CFTypeRef, uint64_t))MEMORY[0x189603180];
  if (RunLoopSource)
  {
LABEL_8:
    v11(a2, v10, a3);
    CFRelease(v10);
  }

void _CFTypeScheduleOnMultipleRunLoops(void *a1, const __CFArray *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceRef RunLoopSource = (void *)CFRetain(a1);
    goto LABEL_10;
  }

  if (v4 == CFRunLoopTimerGetTypeID())
  {
    CFTypeRef v6 = CFRetain(a1);
    unint64_t v7 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x189603110];
    if (!v6) {
      return;
    }
    goto LABEL_11;
  }

  if (v4 == CFMachPortGetTypeID())
  {
    CFRunLoopSourceRef v8 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(v8, (CFMachPortRef)a1, 0LL);
    goto LABEL_10;
  }

  if (v4 == CFSocketGetTypeID())
  {
    unint64_t v9 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v9, (CFSocketRef)a1, 0LL);
LABEL_10:
    CFTypeRef v6 = RunLoopSource;
    unint64_t v7 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x189603108];
    if (!RunLoopSource) {
      return;
    }
LABEL_11:
    CFIndex Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0LL; i < v11; i += 2LL)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
        uint64_t v14 = CFArrayGetValueAtIndex(a2, i + 1);
        v7(ValueAtIndex, v6, v14);
      }
    }

    CFRelease(v6);
    return;
  }

  if (v4 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    unint64_t v15 = (void (*)(void *, const void *, const void *))CoreReadStreamScheduleWithRunLoop;
  }

  else
  {
    if (v4 == *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
      unint64_t v15 = (void (*)(void *, const void *, const void *))CoreWriteStreamScheduleWithRunLoop;
    }

    else if (v4 == CFReadStreamGetTypeID())
    {
      unint64_t v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1896030A8];
    }

    else if (v4 == CFWriteStreamGetTypeID())
    {
      unint64_t v15 = (void (*)(void *, const void *, const void *))MEMORY[0x189603968];
    }

    else
    {
      if (v4 == *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
      {
        unint64_t v15 = (void (*)(void *, const void *, const void *))CFHostScheduleWithRunLoop;
      }

      else if (v4 == CFNetServiceGetTypeID())
      {
        unint64_t v15 = (void (*)(void *, const void *, const void *))CFNetServiceScheduleWithRunLoop;
      }

      else if (v4 == CFNetServiceBrowserGetTypeID())
      {
        unint64_t v15 = (void (*)(void *, const void *, const void *))CFNetServiceBrowserScheduleWithRunLoop;
      }

      else if (v4 == CFNetServiceMonitorGetTypeID())
      {
        unint64_t v15 = (void (*)(void *, const void *, const void *))CFNetServiceMonitorScheduleWithRunLoop;
      }

      else if (v4 == SCNetworkReachabilityGetTypeID())
      {
        unint64_t v15 = (void (*)(void *, const void *, const void *))MEMORY[0x18960C318];
      }

      else
      {
        if (v4 != SCNetworkConnectionGetTypeID()) {
          return;
        }
        unint64_t v15 = (void (*)(void *, const void *, const void *))MEMORY[0x18960C268];
      }
    }
  }

  CFIndex v16 = CFArrayGetCount(a2);
  if (v16 >= 1)
  {
    CFIndex v17 = v16;
    for (CFIndex j = 0LL; j < v17; j += 2LL)
    {
      BOOL v19 = CFArrayGetValueAtIndex(a2, j);
      uint64_t v20 = CFArrayGetValueAtIndex(a2, j + 1);
      v15(a1, v19, v20);
    }
  }

void _CFTypeUnscheduleFromMultipleRunLoops(void *a1, const __CFArray *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceRef RunLoopSource = (void *)CFRetain(a1);
    goto LABEL_7;
  }

  if (v4 == CFMachPortGetTypeID())
  {
    CFTypeRef v6 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFMachPortCreateRunLoopSource(v6, (CFMachPortRef)a1, 0LL);
    goto LABEL_7;
  }

  if (v4 == CFSocketGetTypeID())
  {
    unint64_t v7 = CFGetAllocator(a1);
    CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v7, (CFSocketRef)a1, 0LL);
LABEL_7:
    CFTypeRef v8 = RunLoopSource;
    unint64_t v9 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x189603180];
    if (!RunLoopSource) {
      return;
    }
LABEL_8:
    CFIndex Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      CFIndex v11 = Count;
      for (CFIndex i = 0LL; i < v11; i += 2LL)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
        uint64_t v14 = CFArrayGetValueAtIndex(a2, i + 1);
        v9(ValueAtIndex, v8, v14);
      }
    }

    CFRelease(v8);
    return;
  }

  if (v4 == *(void *)(CoreReadStream::Class(void)::sClass_OBJTYPE + 96))
  {
    unint64_t v15 = (void (*)(void *, const void *, const void *))CoreReadStreamUnscheduleFromRunLoop;
  }

  else
  {
    if (v4 == *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
      unint64_t v15 = (void (*)(void *, const void *, const void *))CoreWriteStreamUnscheduleFromRunLoop;
    }

    else if (v4 == CFReadStreamGetTypeID())
    {
      unint64_t v15 = (void (*)(void *, const void *, const void *))MEMORY[0x1896030D0];
    }

    else if (v4 == CFWriteStreamGetTypeID())
    {
      unint64_t v15 = (void (*)(void *, const void *, const void *))MEMORY[0x189603990];
    }

    else
    {
      if (v4 == *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
      {
        unint64_t v15 = (void (*)(void *, const void *, const void *))CFHostUnscheduleFromRunLoop;
      }

      else if (v4 == SCNetworkReachabilityGetTypeID())
      {
        unint64_t v15 = (void (*)(void *, const void *, const void *))MEMORY[0x18960C330];
      }

      else
      {
        if (v4 == CFRunLoopTimerGetTypeID())
        {
          CFTypeRef v8 = CFRetain(a1);
          unint64_t v9 = (void (*)(const void *, CFTypeRef, const void *))MEMORY[0x189603188];
          if (!v8) {
            return;
          }
          goto LABEL_8;
        }

        if (v4 == CFNetServiceGetTypeID())
        {
          unint64_t v15 = (void (*)(void *, const void *, const void *))CFNetServiceUnscheduleFromRunLoop;
        }

        else if (v4 == CFNetServiceBrowserGetTypeID())
        {
          unint64_t v15 = (void (*)(void *, const void *, const void *))CFNetServiceBrowserUnscheduleFromRunLoop;
        }

        else if (v4 == CFNetServiceMonitorGetTypeID())
        {
          unint64_t v15 = (void (*)(void *, const void *, const void *))CFNetServiceMonitorUnscheduleFromRunLoop;
        }

        else
        {
          if (v4 != SCNetworkConnectionGetTypeID()) {
            return;
          }
          unint64_t v15 = (void (*)(void *, const void *, const void *))MEMORY[0x18960C270];
        }
      }
    }
  }

  CFIndex v16 = CFArrayGetCount(a2);
  if (v16 >= 1)
  {
    CFIndex v17 = v16;
    for (CFIndex j = 0LL; j < v17; j += 2LL)
    {
      BOOL v19 = CFArrayGetValueAtIndex(a2, j);
      uint64_t v20 = CFArrayGetValueAtIndex(a2, j + 1);
      v15(a1, v19, v20);
    }
  }

void _CFTypeInvalidate(char *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFRunLoopSourceGetTypeID())
  {
    CFRunLoopSourceInvalidate((CFRunLoopSourceRef)a1);
  }

  else if (v2 == CFMachPortGetTypeID())
  {
    CFMachPortInvalidate((CFMachPortRef)a1);
  }

  else if (v2 == CFSocketGetTypeID())
  {
    CFSocketInvalidate((CFSocketRef)a1);
  }

  else
  {
    if (v2 == *(void *)(CoreWriteStream::Class(void)::sClass_OBJTYPE + 96))
    {
LABEL_13:
      if (a1) {
        BOOL v3 = a1 + 16;
      }
      else {
        BOOL v3 = 0LL;
      }
      (*(void (**)(char *, void, void))(*(void *)v3 + 56LL))(v3, 0LL, 0LL);
    }

    else if (v2 == CFReadStreamGetTypeID())
    {
      CFReadStreamSetClient((CFReadStreamRef)a1, 0LL, 0LL, 0LL);
    }

    else if (v2 == CFWriteStreamGetTypeID())
    {
      CFWriteStreamSetClient((CFWriteStreamRef)a1, 0LL, 0LL, 0LL);
    }

    else
    {
      if (v2 == *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96))
      {
        CFHostSetClient((CFHostRef)a1, 0LL, 0LL);
      }

      else if (v2 == SCNetworkReachabilityGetTypeID())
      {
        SCNetworkReachabilitySetCallback((SCNetworkReachabilityRef)a1, 0LL, 0LL);
      }

      else if (v2 == CFRunLoopTimerGetTypeID())
      {
        CFRunLoopTimerInvalidate((CFRunLoopTimerRef)a1);
      }

      else if (v2 == CFNetServiceGetTypeID())
      {
        CFNetServiceSetClient((CFNetServiceRef)a1, 0LL, 0LL);
      }

      else if (v2 == CFNetServiceBrowserGetTypeID())
      {
        CFNetServiceBrowserInvalidate((CFNetServiceBrowserRef)a1);
      }

      else if (v2 == CFNetServiceMonitorGetTypeID())
      {
        CFNetServiceMonitorInvalidate((CFNetServiceMonitorRef)a1);
      }
    }
  }

uint64_t _SchedulesAddRunLoopAndMode(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count)
  {
    CFIndex v7 = Count;
    v8.CFIndex location = 0LL;
    v8.length = Count;
    do
    {
      FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(a1, v8, a2);
      if (FirstIndexOfValue == -1) {
        break;
      }
      CFIndex v10 = FirstIndexOfValue;
      ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
      if (CFEqual(ValueAtIndex, a3)) {
        return 0LL;
      }
      v8.CFIndex location = v10 + 2;
      v8.length = v7 - (v10 + 2);
    }

    while (v7 != v10 + 2);
  }

  CFArrayAppendValue(a1, a2);
  CFArrayAppendValue(a1, a3);
  return 1LL;
}

CFIndex _SchedulesRemoveRunLoopAndMode(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex result = CFArrayGetCount(a1);
  if (result)
  {
    CFIndex v7 = result;
    v8.CFIndex location = 0LL;
    v8.length = result;
    while (1)
    {
      FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(a1, v8, a2);
      if (FirstIndexOfValue == -1) {
        return 0LL;
      }
      CFIndex v10 = FirstIndexOfValue;
      ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
      if (CFEqual(ValueAtIndex, a3)) {
        break;
      }
      v8.CFIndex location = v10 + 2;
      v8.length = v7 - (v10 + 2);
      if (v7 == v10 + 2) {
        return 0LL;
      }
    }

    v12.CFIndex location = v10;
    v12.length = 2LL;
    CFArrayReplaceValues(a1, v12, 0LL, 0LL);
    return 1LL;
  }

  return result;
}

uint64_t _SchedulesFind(const __CFArray *a1, const void *a2, const void *a3)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return -1LL;
  }
  CFIndex v7 = Count;
  v8.CFIndex location = 0LL;
  v8.length = Count;
  while (1)
  {
    FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue(a1, v8, a2);
    CFIndex v10 = FirstIndexOfValue;
    if (FirstIndexOfValue == -1) {
      break;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(a1, FirstIndexOfValue + 1);
    if (CFEqual(ValueAtIndex, a3)) {
      break;
    }
    v8.CFIndex location = v10 + 2;
    v8.length = v7 - (v10 + 2);
    if (v7 == v10 + 2) {
      return -1LL;
    }
  }

  return v10;
}

void sub_182A29ED8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_182A2A138(_Unwind_Exception *a1)
{
  CFTypeID v4 = v3;

  _Unwind_Resume(a1);
}

void sub_182A2A56C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A2A634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_89:
          int v34 = 1;
        }

        goto LABEL_90;
      case 2:
        [v12 objectForKeyedSubscript:@"streamLength"];
        CFRange v48 = (void *)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        double v49 = objc_opt_isKindOfClass();

        if ((v49 & 1) != 0)
        {
          [v12 objectForKeyedSubscript:@"streamLength"];
          uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          int v34 = 0;
          *((void *)a1 + _Block_object_dispose(va, 8) = -[os_log_s integerValue](v42, "integerValue");
LABEL_90:
        }

        else
        {
          int v34 = 0;
        }

        break;
      default:
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        uint64_t v42 = (os_log_s *)(id)CFNLog::logger;
        if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          goto LABEL_89;
        }
        *(_WORD *)buf = 0;
        float v43 = "ResumableUploadState: cannot initWithResumeData with unrecognized body type";
        goto LABEL_88;
    }

    goto LABEL_63;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  unint64_t v28 = (os_log_s *)(id)CFNLog::logger;
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    uint64_t v29 = "ResumableUploadState: cannot initWithResumeData with nil body type";
LABEL_35:
    uint64_t v30 = v28;
    id v31 = 2;
LABEL_41:
    _os_log_error_impl(&dword_18298D000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
  }

  v103.domain = a5;
  *(void *)&v103.CFErrorRef error = a6;
  switch(HTTP3Stream::_translateError((HTTP3Stream *)v12, v103, 0))
  {
    case 0u:

      if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
      {
        *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
        unint64_t v65 = a1 + 6;
        goto LABEL_120;
      }

      HTTP3Stream::_read((HTTP3Stream *)a1[7], 1);
      goto LABEL_121;
    case 1u:
      if ((_DWORD)a4)
      {
        BOOL v67 = *(_DWORD *)(v12 + 116);
        if (v67 == 9 || v67 == 3)
        {
          *(_DWORD *)(v12 + 116) = 9;
          HTTP3Stream::_reportResult((HTTP3Stream *)v12, 1);
          *(_BYTE *)(v12 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 1;
          break;
        }

void sub_182A2B05C(_Unwind_Exception *a1)
{
  unint64_t v9 = v8;

  _Unwind_Resume(a1);
}

void ___ZL22supportedDraftVersionsv_block_invoke()
{
  uint64_t v0 = objc_msgSend(MEMORY[0x189603FE0], "setWithObjects:", @"3", @"6", 0);
  uint64_t v1 = (void *)supportedDraftVersions(void)::supportedDraftVersions;
  supportedDraftVersions(void)::supportedDraftVersions = v0;
}

void ___ZL17resumeDataClassesv_block_invoke_1517()
{
  uint64_t v0 = (void *)MEMORY[0x189603FE0];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_msgSend(v0, "setWithObjects:", v1, v2, v3, v4, v5, v6, objc_opt_class(), 0);
  CFRange v8 = (void *)resumeDataClasses(void)::resumeDataClasses;
  resumeDataClasses(void)::resumeDataClasses = v7;
}

void sub_182A2B338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A2B434( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  _Unwind_Resume(a1);
}

void sub_182A2B6F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A2BAC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  _Unwind_Resume(a1);
}

void AuthLiaison::~AuthLiaison(AuthLiaison *this)
{
}

{
  char *v2;
  *(void *)this = off_189C03478;
  uint64_t v2 = (char *)this + 40;
  (*(void (**)(void))(**((void **)this + 5) + 24LL))(*((void *)this + 5));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  *(void *)this = off_189C19AE8;
}

void sub_182A2BBA0(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  _Unwind_Resume(a1);
}

void AuthLiaison::negotiateAuthentication( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t *a5, HTTPResponseMessage **a6, uint64_t *a7)
{
  uint64_t v115 = *MEMORY[0x1895F89C0];
  CFRange v12 = (void *)(a1 + 40);
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(a1 + 40), a2, a3);
  if ((*(uint64_t (**)(void))(**(void **)(a1 + 40) + 32LL))(*(void *)(a1 + 40)))
  {
    unint64_t v13 = (const void *)(*(uint64_t (**)(void))(*(void *)*v12 + 32LL))(*v12);
    uint64_t v14 = (std::__shared_weak_count_vtbl *)CFRetain(v13);
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  uint64_t v112 = v14;
  unint64_t v15 = (std::__shared_weak_count *)operator new(0x20uLL);
  v15->__vftable = (std::__shared_weak_count_vtbl *)off_189C17020;
  v15->__shared_owners_ = 0LL;
  v15->__shared_weak_owners_ = 0LL;
  v15[1].__vftable = v14;
  v113 = v15;
  uint64_t v104 = 0LL;
  CFRange v105 = &v104;
  uint64_t v106 = 0x4012000000LL;
  BOOL v107 = __Block_byref_object_copy__1582;
  id v108 = __Block_byref_object_dispose__1583;
  uint64_t v110 = 0LL;
  uint64_t v111 = 0LL;
  CFNumberRef v109 = &unk_182CE6F99;
  CFIndex v17 = (uint64_t *)(a1 + 24);
  uint64_t v16 = *(void *)(a1 + 24);
  if (!v16)
  {
LABEL_29:
    (*(void (**)(uint8_t *__return_ptr))(*(void *)*a4 + 72LL))(buf);
    uint64_t v36 = *(void *)buf;
    unsigned __int16 v37 = (*(uint64_t (**)(void))(*(void *)*a4 + 64LL))(*a4);
    uint64_t v38 = CFStringCreateWithFormat(0LL, 0LL, @"%@://%@:%d", 0x18C5B2B50LL, v36, v37);
    CFURLRef v39 = CFURLCreateWithString(0LL, v38, 0LL);
    HTTPResponseMessage::setResponseURL(*a6, v39, 1);
    uint64_t v40 = *v12;
    uint64_t v41 = (std::__shared_weak_count *)a4[1];
    uint64_t v98 = *a4;
    int64x2_t v99 = v41;
    if (v41)
    {
      p_shared_owners = (unint64_t *)&v41->__shared_owners_;
      do
        unint64_t v43 = __ldxr(p_shared_owners);
      while (__stxr(v43 + 1, p_shared_owners));
    }

    int v44 = (std::__shared_weak_count *)a6[1];
    CFTypeID v96 = *a6;
    char v97 = v44;
    if (v44)
    {
      double v45 = (unint64_t *)&v44->__shared_owners_;
      do
        unint64_t v46 = __ldxr(v45);
      while (__stxr(v46 + 1, v45));
    }

    v88[0] = MEMORY[0x1895F87A8];
    v88[1] = 3321888768LL;
    v88[2] = ___ZN11AuthLiaison23negotiateAuthenticationENSt3__110shared_ptrI14MetaAuthClientEENS1_I12NetworkProxyEENS1_I18HTTPRequestMessageEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJS7_13CFStreamErrorEE_block_invoke;
    v88[3] = &unk_189C03490;
    uint64_t v48 = *a5;
    uint64_t v47 = (std::__shared_weak_count *)a5[1];
    v88[5] = a1;
    v88[6] = v48;
    uint64_t v89 = v47;
    if (v47)
    {
      double v49 = (unint64_t *)&v47->__shared_owners_;
      do
        unint64_t v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
    }

    uint64_t v90 = v112;
    unint64_t v91 = v113;
    if (v113)
    {
      uint64_t v51 = (unint64_t *)&v113->__shared_owners_;
      do
        unint64_t v52 = __ldxr(v51);
      while (__stxr(v52 + 1, v51));
    }

    uint64_t v54 = *a7;
    uint64_t v53 = a7[1];
    v88[4] = &v104;
    uint64_t v92 = v54;
    uint64_t v93 = (std::__shared_weak_count *)v53;
    if (v53)
    {
      unint64_t v55 = (unint64_t *)(v53 + 8);
      do
        unint64_t v56 = __ldxr(v55);
      while (__stxr(v56 + 1, v55));
    }

    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs(&v94, v88);
    (*(void (**)(uint64_t, uint64_t *, HTTPResponseMessage **, uint64_t *))(*(void *)v40 + 16LL))( v40,  &v98,  &v96,  &v94);
    id v57 = v95;
    if (v95)
    {
      CFTypeRef v58 = (unint64_t *)&v95->__shared_owners_;
      do
        unint64_t v59 = __ldaxr(v58);
      while (__stlxr(v59 - 1, v58));
      if (!v59)
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
    }

    CFAbsoluteTime v60 = v97;
    if (v97)
    {
      CFTypeRef v61 = (unint64_t *)&v97->__shared_owners_;
      do
        unint64_t v62 = __ldaxr(v61);
      while (__stlxr(v62 - 1, v61));
      if (!v62)
      {
        ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
        std::__shared_weak_count::__release_weak(v60);
      }
    }

    id v63 = v99;
    if (v99)
    {
      CFTypeRef v64 = (unint64_t *)&v99->__shared_owners_;
      do
        unint64_t v65 = __ldaxr(v64);
      while (__stlxr(v65 - 1, v64));
      if (!v65)
      {
        ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
        std::__shared_weak_count::__release_weak(v63);
      }
    }

    signed int v66 = v93;
    if (v93)
    {
      BOOL v67 = (unint64_t *)&v93->__shared_owners_;
      do
        unint64_t v68 = __ldaxr(v67);
      while (__stlxr(v68 - 1, v67));
      if (!v68)
      {
        ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
        std::__shared_weak_count::__release_weak(v66);
      }
    }

    float v69 = v91;
    if (v91)
    {
      uint64_t v70 = (unint64_t *)&v91->__shared_owners_;
      do
        unint64_t v71 = __ldaxr(v70);
      while (__stlxr(v71 - 1, v70));
      if (!v71)
      {
        ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
        std::__shared_weak_count::__release_weak(v69);
      }
    }

    uint64_t v72 = v89;
    if (v89)
    {
      unint64_t v73 = (unint64_t *)&v89->__shared_owners_;
      do
        unint64_t v74 = __ldaxr(v73);
      while (__stlxr(v74 - 1, v73));
      if (!v74)
      {
        ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
        std::__shared_weak_count::__release_weak(v72);
      }
    }

    if (v39) {
      CFRelease(v39);
    }
    if (v38) {
      CFRelease(v38);
    }
    CFStringRef v75 = *(std::__shared_weak_count **)&buf[8];
    if (!*(void *)&buf[8]) {
      goto LABEL_97;
    }
    unint64_t v76 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v77 = __ldaxr(v76);
    while (__stlxr(v77 - 1, v76));
    goto LABEL_94;
  }

  (*(void (**)(uint64_t, HTTPResponseMessage *, uint64_t))(*(void *)v16 + 16LL))(v16, *a6, a1);
  isValuint64_t id = AuthenticationState::isValid(*v17, 0);
  BOOL v19 = (AuthenticationState *)*v17;
  if (!isValid)
  {
    if (v19)
    {
      uint64_t Auth = AuthenticationState::getAuth(v19, 1);
      if (!Auth)
      {
        uint64_t v30 = 0LL;
        uint64_t v31 = 0LL;
        goto LABEL_83;
      }

      unint64_t v28 = (uint64_t *)(Auth + 88);
      uint64_t v29 = (uint64_t *)(Auth + 96);
    }

    else
    {
      unint64_t v28 = v105 + 6;
      uint64_t v29 = v105 + 7;
    }

    uint64_t v30 = *v29;
    uint64_t v31 = *v28;
    if (*v28 == 4 && *v29 == 4294966295LL)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      __int128 v32 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        *(void *)&uint8_t buf[4] = v14;
        _os_log_impl( &dword_18298D000,  v32,  OS_LOG_TYPE_DEFAULT,  "Proxy credentials had a bad username/password, trying again %{public}@",  buf,  0xCu);
      }

      *(void *)buf = 0LL;
      *(void *)&uint8_t buf[8] = 0LL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 24, (__int128 *)buf);
      unint64_t v33 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        int v34 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }

      goto LABEL_29;
    }

void sub_182A2C2A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

__n128 __Block_byref_object_copy__1582(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::operator()( uint64_t a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, uint64_t a5)
{
  if (a1)
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }

    uint64_t v7 = *(void (**)(void *, uint64_t *, uint64_t, uint64_t))(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    unint64_t v9 = (void *)(a1 + (v8 >> 1));
    if ((v8 & 1) != 0) {
      uint64_t v7 = *(void (**)(void *, uint64_t *, uint64_t, uint64_t))(*v9 + v7);
    }
    uint64_t v18 = a2;
    BOOL v19 = a3;
    if (a3)
    {
      CFIndex v10 = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }

    v7(v9, &v18, a4, a5);
    CFRange v12 = v19;
    if (v19)
    {
      unint64_t v13 = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }

    if (a3)
    {
      unint64_t v15 = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
        std::__shared_weak_count::__release_weak(a3);
      }
    }
  }

void sub_182A2C46C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void ___ZN11AuthLiaison23negotiateAuthenticationENSt3__110shared_ptrI14MetaAuthClientEENS1_I12NetworkProxyEENS1_I18HTTPRequestMessageEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJS7_13CFStreamErrorEE_block_invoke( uint64_t a1, uint64_t *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (*a2
    && (uint64_t v4 = *(void *)(a1 + 40),
        AuthenticationState::canApplyHeadersToRequest((AuthenticationState *)*a2, *(HTTPRequestMessage **)(a1 + 48))))
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v4 + 24), *a2, a2[1]);
    if ((*(unsigned int (**)(void, void, uint64_t, uint64_t))(**(void **)(v4 + 24) + 24LL))( *(void *)(v4 + 24),  *(void *)(a1 + 48),  v4,  1LL))
    {
      NotificationStation::notifyPropertyChanged( (NotificationStation *)UnitTestNotificationCenter::shared(void)::shared,  @"AuthBrokerQueryCount",  (const void *)*MEMORY[0x189604DE8]);
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v5 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(a1 + 64);
        *(_DWORD *)buf = 138543362;
        uint64_t v19 = v6;
        _os_log_impl(&dword_18298D000, v5, OS_LOG_TYPE_DEFAULT, "Applied proxy auth to %{public}@", buf, 0xCu);
      }
    }

    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      unint64_t v15 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        uint64_t v16 = *(void *)(a1 + 64);
        *(_DWORD *)buf = 138543362;
        uint64_t v19 = v16;
        _os_log_error_impl( &dword_18298D000,  v15,  OS_LOG_TYPE_ERROR,  "Failed to apply proxy auth to %{public}@",  buf,  0xCu);
      }
    }
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = *(void *)(a1 + 64);
      *(_DWORD *)buf = 138543362;
      uint64_t v19 = v17;
      _os_log_error_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_ERROR,  "Failed to get applicable proxy auth %{public}@",  buf,  0xCu);
    }

    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
    *(void *)(v8 + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 4LL;
    *(_DWORD *)(v8 + 56) = -2097;
  }

  uint64_t v9 = *(void *)(a1 + 48);
  CFIndex v10 = *(std::__shared_weak_count **)(a1 + 56);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  SmartBlockWithArgs<std::shared_ptr<HTTPRequestMessage>,CFStreamError>::operator()( *(void *)(a1 + 80),  v9,  v10,  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL),  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 56LL));
  if (v10)
  {
    unint64_t v13 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

void sub_182A2C764( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs( void *a1, const void *a2)
{
  uint64_t v4 = operator new(0x18uLL);
  v4[1] = BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial;
  v4[2] = 0LL;
  void *v4 = _Block_copy(a2);
  *a1 = v4;
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = off_189C0CF30;
  v5[1] = 0LL;
  void v5[2] = 0LL;
  v5[3] = v4;
  a1[1] = v5;
  if (!a2)
  {
    v4[1] = BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_reseted;
    v4[2] = 0LL;
  }

  return a1;
}

void sub_182A2C7F8(_Unwind_Exception *a1)
{
}

void BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial(uint64_t *a1, uint64_t *a2)
{
  a1[1] = (uint64_t)BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_normal;
  a1[2] = 0LL;
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  CFIndex v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  uint64_t v6 = v10;
  if (v10)
  {
    uint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A2C8A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<AuthenticationState>> *,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<AuthenticationState>>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<std::shared_ptr<AuthenticationState>> *,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::Deleter,std::allocator<BlockHolderVar<std::shared_ptr<AuthenticationState>>>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v3 = *(void (**)(uint64_t *, uint64_t *))(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1LL | (unint64_t)v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if (v3 == BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial && v5 != 0)
  {
    uint64_t v7 = (uint64_t *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0) {
      unint64_t v8 = *(void (**)(uint64_t *, uint64_t *))(*v7
    }
                                                       + BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial);
    else {
      unint64_t v8 = BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_initial;
    }
    uint64_t v12 = 0LL;
    unint64_t v13 = 0LL;
    v8(v7, &v12);
    uint64_t v9 = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

  _Block_release(*(const void **)v1);
  operator delete((void *)v1);
}

void sub_182A2C998( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  _Unwind_Resume(exception_object);
}

void BlockHolderVar<std::shared_ptr<AuthenticationState>>::invoke_normal(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  CFIndex v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(v2 + 16))(v2, &v9);
  uint64_t v6 = v10;
  if (v10)
  {
    uint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A2CA68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *__copy_helper_block_e8_48c46_ZTSNSt3__110shared_ptrI18HTTPRequestMessageEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE80c85_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI18HTTPRequestMessageEE13CFStreamErrorEE( void *result, void *a2)
{
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[9];
  result[8] = a2[8];
  result[9] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a2[11];
  result[10] = a2[10];
  result[11] = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_48c46_ZTSNSt3__110shared_ptrI18HTTPRequestMessageEE64c39_ZTSNSt3__110shared_ptrIK10__CFStringEE80c85_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI18HTTPRequestMessageEE13CFStreamErrorEE( uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  uint64_t v2 = a1 + 64;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

double ___ZN26UnitTestNotificationCenter6sharedEv_block_invoke_1593()
{
  uint64_t v0 = operator new(0x60uLL);
  void *v0 = 0LL;
  v0[1] = 850045863LL;
  double result = 0.0;
  *((_OWORD *)v0 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  *((_OWORD *)v0 + 2) = 0u;
  *((_OWORD *)v0 + 3) = 0u;
  *((_OWORD *)v0 + 4) = 0u;
  v0[10] = CFTypeRefRelease<__CFSet const*>;
  *((_BYTE *)v0 + 8_Block_object_dispose((const void *)(v31 - 192), 8) = 1;
  UnitTestNotificationCenter::shared(void)::shared = (uint64_t)v0;
  return result;
}

void std::__shared_ptr_pointer<__CFString const*,Deleter_CFRelease,std::allocator<__CFString const>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void *_CFNetServiceRegisterClass(void)
{
  double result = calloc(1uLL, 0x60uLL);
  _kCFNetServiceClass = (uint64_t)result;
  if (result)
  {
    *double result = 0LL;
    result[1] = "CFNetService";
    result[4] = _ServiceDestroy;
    result[5] = _ServiceEqual;
    result[6] = _ServiceHash;
    result[8] = _ServiceCopyDebugDesc;
    double result = (void *)_CFRuntimeRegisterClass();
    _kCFNetServiceCFTypeID TypeID = (uint64_t)result;
  }

  return result;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1611(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void _ServiceDestroy(os_unfair_lock_s *a1)
{
  uint64_t v2 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  if (*(void *)&a1[30]._os_unfair_lock_opaque)
  {
    uint64_t v3 = *(void (**)(void))&a1[34]._os_unfair_lock_opaque;
    if (v3) {
      v3();
    }
  }

  _CleanupService_NoLock((__CFNetService *)a1);
  unint64_t v4 = *(const void **)&a1[22]._os_unfair_lock_opaque;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)&a1[20]._os_unfair_lock_opaque;
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)&a1[12]._os_unfair_lock_opaque;
  if (v6) {
    CFRelease(v6);
  }
  unint64_t v7 = *(const void **)&a1[16]._os_unfair_lock_opaque;
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(const void **)&a1[24]._os_unfair_lock_opaque;
  if (v8) {
    CFRelease(v8);
  }
  os_unfair_lock_unlock(v2);
}

BOOL _ServiceEqual(__CFNetService *a1, __CFNetService *a2)
{
  unint64_t v4 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  uint64_t v5 = (os_unfair_lock_s *)((char *)a2 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 4);
  unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)4);
  unint64_t v7 = CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), (const void *)4);
  if (!CFEqual(Value, v7)) {
    goto LABEL_19;
  }
  uint64_t v8 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), 0LL);
  uint64_t v9 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), 0LL);
  if (CFEqual(v8, &stru_189C1D1D8)) {
    uint64_t v8 = &stru_189C1D1D8;
  }
  unint64_t v10 = CFEqual(v9, &stru_189C1D1D8) ? &stru_189C1D1D8 : (__CFString *)v9;
  if (!CFEqual(v8, v10)) {
    goto LABEL_19;
  }
  unint64_t v11 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  unint64_t v12 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 6), (const void *)2);
  if (CFEqual(v11, v12))
  {
    BOOL v13 = 1LL;
    goto LABEL_20;
  }

  if (!CFEqual(v11, &stru_189C1D1D8) && !CFEqual(v12, &stru_189C1D1D8)
    || (CFStringRef v14 = SCDynamicStoreCopyComputerName(0LL, 0LL)) == 0LL)
  {
LABEL_19:
    BOOL v13 = 0LL;
    goto LABEL_20;
  }

  CFStringRef v15 = v14;
  if (CFEqual(v11, &stru_189C1D1D8)) {
    unint64_t v11 = v15;
  }
  if (CFEqual(v12, &stru_189C1D1D8)) {
    CFStringRef v16 = v15;
  }
  else {
    CFStringRef v16 = v12;
  }
  BOOL v13 = CFEqual(v11, v16) != 0;
  CFRelease(v15);
LABEL_20:
  os_unfair_lock_unlock(v4);
  os_unfair_lock_unlock(v5);
  return v13;
}

CFHashCode _ServiceHash(__CFNetService *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  CFHashCode v4 = CFHash(Value);
  if (CFEqual(Value, &stru_189C1D1D8))
  {
    CFStringRef v5 = SCDynamicStoreCopyComputerName(0LL, 0LL);
    if (v5)
    {
      CFStringRef v6 = v5;
      CFHashCode v4 = CFHash(v5);
      CFRelease(v6);
    }
  }

  os_unfair_lock_unlock(v2);
  return v4;
}

CFStringRef _ServiceCopyDebugDesc(__CFNetService *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  uint64_t v3 = CFGetAllocator(a1);
  unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), 0LL);
  CFStringRef v5 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)4);
  CFStringRef v6 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)2);
  unint64_t v7 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)1);
  uint64_t v8 = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 6), (const void *)3);
  CFStringRef v9 = CFStringCreateWithFormat( v3,  0LL,  @"<CFNetService %p>{domain=%@, type=%@, name=%@, specific=%@, addresses=%@}",  a1,  Value,  v5,  v6,  v7,  v8);
  os_unfair_lock_unlock(v2);
  return v9;
}

void _CleanupService_NoLock(__CFNetService *a1)
{
  if (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    uint64_t v2 = (const __CFArray *)*((void *)a1 + 12);
    if (v2) {
      _UnscheduleSources(*((const __CFArray **)a1 + 8), v2);
    }
    _InvalidateSources(*((__CFArray **)a1 + 8));
  }

  uint64_t v3 = (_DNSServiceRef_t *)*((void *)a1 + 9);
  if (v3)
  {
    DNSServiceRefDeallocate(v3);
    *((void *)a1 + 9) = 0LL;
  }

  CFHashCode v4 = (const void *)*((void *)a1 + 5);
  if (v4)
  {
    CFRelease(v4);
    *((void *)a1 + 5) = 0LL;
  }

  CFSetRemoveAllValues(*((CFMutableSetRef *)a1 + 11));
}

void _UnscheduleSources(const __CFArray *a1, const __CFArray *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0LL; i != v5; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeUnscheduleFromMultipleRunLoops(ValueAtIndex, a2);
    }
  }

void _InvalidateSources(__CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0LL; i != v3; ++i)
    {
      ValueAtIndex = (char *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeInvalidate(ValueAtIndex);
    }
  }

  CFArrayRemoveAllValues(a1);
}

CFNetServiceRef CFNetServiceCreate( CFAllocatorRef alloc, CFStringRef domain, CFStringRef serviceType, CFStringRef name, SInt32 port)
{
  uint64_t v5 = 0LL;
  if (domain && serviceType && name)
  {
    if (!CFNetServiceGetTypeID()) {
      return 0LL;
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v5 = Instance;
    if (Instance)
    {
      memset(&keyCallBacks, 0, sizeof(keyCallBacks));
      memset(&v16, 0, sizeof(v16));
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 12_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
      *(void *)(Instance + 144) = 0LL;
      *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
      *(void *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = CFDictionaryCreateMutable(alloc, 0LL, &keyCallBacks, MEMORY[0x189605250]);
      *(void *)(v5 + 80) = CFDictionaryCreateMutable(alloc, 0LL, &keyCallBacks, &v16);
      *(void *)(v5 + 8_Block_object_dispose((const void *)(v31 - 192), 8) = CFSetCreateMutable(alloc, 0LL, MEMORY[0x189605258]);
      unint64_t v12 = (const CFArrayCallBacks *)MEMORY[0x189605228];
      *(void *)(v5 + 96) = CFArrayCreateMutable(alloc, 0LL, MEMORY[0x189605228]);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(alloc, 0LL, v12);
      *(void *)(v5 + 64) = Mutable;
      CFStringRef v14 = *(__CFDictionary **)(v5 + 48);
      if (v14 && *(void *)(v5 + 96) && *(void *)(v5 + 80) && Mutable)
      {
        CFDictionaryAddValue(v14, 0LL, domain);
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v5 + 48), (const void *)4, serviceType);
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(v5 + 48), (const void *)2, name);
        *(_DWORD *)(v5 + 56) = port;
        return (CFNetServiceRef)v5;
      }

      CFRelease((CFTypeRef)v5);
      return 0LL;
    }
  }

  return (CFNetServiceRef)v5;
}

CFNetServiceRef CFNetServiceCreateCopy(CFAllocatorRef alloc, CFNetServiceRef service)
{
  CFTypeID TypeID = (void *)CFNetServiceGetTypeID();
  os_unfair_lock_lock((os_unfair_lock_t)service + 4);
  if (TypeID)
  {
    uint64_t Instance = _CFRuntimeCreateInstance();
    CFTypeID TypeID = (void *)Instance;
    if (Instance)
    {
      memset(&keyCallBacks, 0, sizeof(keyCallBacks));
      memset(&v12, 0, sizeof(v12));
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 12_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
      *(void *)(Instance + 144) = 0LL;
      *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
      *(void *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = CFDictionaryCreateMutable(alloc, 0LL, &keyCallBacks, MEMORY[0x189605250]);
      TypeID[10] = CFDictionaryCreateMutable(alloc, 0LL, &keyCallBacks, &v12);
      CFStringRef v6 = (void *)TypeID[6];
      if (v6) {
        CFDictionaryApplyFunction( *((CFDictionaryRef *)service + 6),  (CFDictionaryApplierFunction)_DictionaryApplier,  v6);
      }
      TypeID[11] = CFSetCreateMutable(alloc, 0LL, MEMORY[0x189605258]);
      unint64_t v7 = (const CFArrayCallBacks *)MEMORY[0x189605228];
      TypeID[12] = CFArrayCreateMutable(alloc, 0LL, MEMORY[0x189605228]);
      CFMutableArrayRef Mutable = CFArrayCreateMutable(alloc, 0LL, v7);
      TypeID[8] = Mutable;
      CFStringRef v9 = (const __CFDictionary *)TypeID[6];
      if (!v9
        || !TypeID[12]
        || !Mutable
        || !TypeID[10]
        || (CFIndex Count = CFDictionaryGetCount(v9), Count != CFDictionaryGetCount(*((CFDictionaryRef *)service + 6))))
      {
        CFRelease(TypeID);
        CFTypeID TypeID = 0LL;
      }
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)service + 4);
  return (CFNetServiceRef)TypeID;
}

void _DictionaryApplier(const void *a1, const __CFString *cf, void *a3)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    unint64_t v7 = CFGetAllocator(a3);
    CFHTTPMessageRef Copy = CFStringCreateCopy(v7, cf);
    if (Copy)
    {
LABEL_3:
      CFStringRef v9 = Copy;
      CFDictionaryAddValue((CFMutableDictionaryRef)a3, a1, Copy);
      CFRelease(v9);
    }
  }

  else if (v6 == CFArrayGetTypeID())
  {
    unint64_t v10 = CFGetAllocator(a3);
    CFHTTPMessageRef Copy = CFArrayCreateCopy(v10, (CFArrayRef)cf);
    if (Copy) {
      goto LABEL_3;
    }
  }

  else
  {
    CFDictionaryAddValue((CFMutableDictionaryRef)a3, a1, cf);
  }

CFStringRef CFNetServiceGetDomain(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 0);
}

const void *CFNetServiceGetInfo(uint64_t a1, unsigned int a2)
{
  CFHashCode v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), (const void *)a2);
  os_unfair_lock_unlock(v4);
  return Value;
}

CFStringRef CFNetServiceGetType(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 4u);
}

CFStringRef CFNetServiceGetName(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 2u);
}

CFArrayRef CFNetServiceGetAddressing(CFNetServiceRef theService)
{
  return (CFArrayRef)CFNetServiceGetInfo((uint64_t)theService, 3u);
}

CFStringRef CFNetServiceGetTargetHost(CFNetServiceRef theService)
{
  return (CFStringRef)CFNetServiceGetInfo((uint64_t)theService, 5u);
}

SInt32 CFNetServiceGetPortNumber(CFNetServiceRef theService)
{
  return *((_DWORD *)theService + 14);
}

CFDataRef CFNetServiceGetTXTData(CFNetServiceRef theService)
{
  CFDataRef result = (CFDataRef)CFNetServiceGetInfo((uint64_t)theService, 1u);
  if (result)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFDataGetTypeID()) {
      return v2;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

Boolean CFNetServiceSetTXTData(CFNetServiceRef theService, CFDataRef txtRecord)
{
  return _ServiceSetInfo(theService, 1u, txtRecord, 1);
}

uint64_t _ServiceSetInfo(__CFNetService *a1, unsigned int a2, const void *a3, int a4)
{
  uint64_t v8 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if ((*((_BYTE *)a1 + 20) & 2) != 0)
  {
LABEL_27:
    uint64_t v11 = 0LL;
    goto LABEL_29;
  }

  CFStringRef v9 = (__CFDictionary *)*((void *)a1 + 6);
  unint64_t v10 = a2;
  if (a3) {
    CFDictionarySetValue(v9, (const void *)a2, a3);
  }
  else {
    CFDictionaryRemoveValue(v9, (const void *)a2);
  }
  if (a2 == 8)
  {
    int valuePtr = 0;
    uint64_t v11 = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, &valuePtr);
    *((_DWORD *)a1 + 14) = valuePtr;
    goto LABEL_29;
  }

  if (!a4 || (CFDictionaryValueCallBacks v12 = (_DNSServiceRef_t *)*((void *)a1 + 9)) == 0LL)
  {
LABEL_28:
    uint64_t v11 = 1LL;
    goto LABEL_29;
  }

  if (a2 != 1)
  {
    if ((a2 & 0xFFFF0000) == 0x10000)
    {
      CFStringRef v15 = (_DNSRecordRef_t *)CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 10), (const void *)a2);
      CFDictionaryValueCallBacks v16 = v15;
      value = v15;
      if (a3)
      {
        uint64_t v17 = (_DNSServiceRef_t *)*((void *)a1 + 9);
        if (v15)
        {
          uint16_t Length = CFDataGetLength((CFDataRef)a3);
          BytePtr = CFDataGetBytePtr((CFDataRef)a3);
          DNSServiceErrorType updated = DNSServiceUpdateRecord(v17, v16, 0, Length, BytePtr, 0);
        }

        else
        {
          uint64_t v21 = (unsigned __int16)CFDataGetLength((CFDataRef)a3);
          unint64_t v22 = CFDataGetBytePtr((CFDataRef)a3);
          DNSServiceErrorType updated = DNSServiceAddRecord(v17, (DNSRecordRef *)&value, 0, a2, v21, v22, 0);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)a2, value);
        }
      }

      else
      {
        DNSServiceErrorType updated = v15 ? DNSServiceRemoveRecord(*((DNSServiceRef *)a1 + 9), v15, 0) : 0;
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)a2);
      }

      if (updated)
      {
        if (value) {
          DNSServiceRemoveRecord(*((DNSServiceRef *)a1 + 9), (DNSRecordRef)value, 0);
        }
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a1 + 10), (const void *)v10);
        goto LABEL_27;
      }
    }

    goto LABEL_28;
  }

  if (a3)
  {
    uint16_t v13 = CFDataGetLength((CFDataRef)a3);
    CFStringRef v14 = CFDataGetBytePtr((CFDataRef)a3);
  }

  else
  {
    uint16_t v13 = 0;
    CFStringRef v14 = 0LL;
  }

  uint64_t v11 = DNSServiceUpdateRecord(v12, 0LL, 0, v13, v14, 0) == 0;
LABEL_29:
  os_unfair_lock_unlock(v8);
  return v11;
}

uint64_t CFNetServiceSetInfo(__CFNetService *a1, unsigned int a2, const void *a3)
{
  return _ServiceSetInfo(a1, a2, a3, 1);
}

Boolean CFNetServiceRegisterWithOptions( CFNetServiceRef theService, CFOptionFlags options, CFStreamError *error)
{
  int v3 = options;
  uint64_t v43 = *MEMORY[0x1895F89C0];
  int v5 = -72008;
  CFTypeID v6 = (CFStreamError *)&v39;
  if (error) {
    CFTypeID v6 = error;
  }
  v6->domain = 0LL;
  *(void *)&v6->CFErrorRef error = 0LL;
  unint64_t v35 = v6;
  CFRetain(theService);
  unint64_t v7 = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
  lock = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  context.version = 0LL;
  context.info = theService;
  context.retain = v7;
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
  context.copyDescription = 0LL;
  unsigned int Value = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)1);
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    if ((*((_BYTE *)theService + 20) & 8) != 0)
    {
      _UnscheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
      _InvalidateSources(*((__CFArray **)theService + 8));
    }

    else
    {
      *((void *)theService + 3) = 10LL;
      *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = -72003;
    }
  }

  uint64_t v9 = 0LL;
  unint64_t v10 = dword_182BD7B00;
  do
  {
    unsigned int v11 = *v10++;
    CFDictionaryValueCallBacks v12 = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)v11);
    if (v12)
    {
      uint16_t v13 = v12;
      v44.length = CFStringGetLength(v12);
      v44.CFIndex location = 0LL;
      CFStringGetBytes(v13, v44, 0x8000100u, 0, 0, (UInt8 *)&name[v9], 1023LL, (CFIndex *)&usedBufLen);
      name[v9 + (void)usedBufLen] = 0;
    }

    else
    {
      name[v9] = 0;
    }

    v9 += 1024LL;
  }

  while (v9 != 3072);
  DNSServiceFlags v14 = v3 & 0x120800 | (8 * (v3 & 1));
  CFStringRef v15 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)7);
  if (v15 && CFBooleanGetValue(v15)) {
    v14 |= 0x100000u;
  }
  CFDictionaryValueCallBacks v16 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)9);
  if (v16 && CFBooleanGetValue(v16)) {
    v14 |= 0x100000u;
  }
  if ((v3 & 0x200000) != 0 && !getifaddrs(&usedBufLen))
  {
    unint64_t v23 = usedBufLen;
    if (usedBufLen)
    {
      uint32_t v17 = 0;
      do
      {
        if (v23->ifa_addr->sa_family == 30)
        {
          ifa_name = v23->ifa_name;
          if (!strncasecmp(ifa_name, "awdl0", 5uLL)) {
            uint32_t v17 = if_nametoindex(ifa_name);
          }
        }

        unint64_t v23 = v23->ifa_next;
      }

      while (v23);
      unint64_t v25 = usedBufLen;
    }

    else
    {
      unint64_t v25 = 0LL;
      uint32_t v17 = 0;
    }

    MEMORY[0x186E14538](v25);
  }

  else
  {
    uint32_t v17 = 0;
  }

  unsigned int v18 = bswap32(*((unsigned __int16 *)theService + 28)) >> 16;
  if (Value)
  {
    uint16_t Length = CFDataGetLength(Value);
    txtRecord = CFDataGetBytePtr(Value);
  }

  else
  {
    uint16_t Length = 0;
    txtRecord = 0LL;
  }

  DNSServiceErrorType v21 = DNSServiceRegister( (DNSServiceRef *)theService + 9,  v14,  v17,  name,  v41,  v42,  0LL,  v18,  Length,  txtRecord,  (DNSServiceRegisterReply)_RegisterReply,  theService);
  *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = v21;
  if (v21 <= -65549)
  {
    unint64_t v22 = (os_unfair_lock_s *)((char *)theService + 16);
    if (v21 == -65555) {
      goto LABEL_46;
    }
    if (v21 == -65554)
    {
      int v5 = -72002;
      goto LABEL_46;
    }

    goto LABEL_45;
  }

  unint64_t v22 = (os_unfair_lock_s *)((char *)theService + 16);
  if (v21 == -65548)
  {
    int v5 = -72001;
    goto LABEL_46;
  }

  if (v21)
  {
    if (v21 == -65540)
    {
      int v5 = -72004;
LABEL_46:
      LOBYTE(v27) = 0;
      *((void *)theService + 3) = 10LL;
      *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = v5;
LABEL_47:
      unint64_t v28 = v35;
      goto LABEL_48;
    }

LABEL_58:
    int v5 = -72000;
    goto LABEL_59;
  }

  uint64_t v30 = CFGetAllocator(theService);
  dnssd_sock_t v31 = DNSServiceRefSockFD(*((DNSServiceRef *)theService + 9));
  __int128 v32 = CFSocketCreateWithNative(v30, v31, 1uLL, (CFSocketCallBack)_SocketCallBack_NetService, &context);
  CFIndex v27 = v32;
  if (!v32)
  {
    int v34 = *__error();
    *((void *)theService + 3) = 1LL;
    *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = v34;
    DNSServiceRefDeallocate(*((DNSServiceRef *)theService + 9));
    *((void *)theService + 9) = 0LL;
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)theService + 10));
    goto LABEL_47;
  }

  CFOptionFlags SocketFlags = CFSocketGetSocketFlags(v32);
  CFSocketSetSocketFlags(v27, SocketFlags & 0xFFFFFFFFFFFFFF7FLL);
  CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v27);
  CFRelease(v27);
  *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = 0;
  *((void *)theService + 3) = 0LL;
  *((_BYTE *)theService + 20) |= 4u;
  unint64_t v28 = v35;
  if (CFArrayGetCount(*((CFArrayRef *)theService + 12)))
  {
    _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    LOBYTE(v27) = 1;
  }

  else
  {
    os_unfair_lock_unlock(lock);
    LOBYTE(v27) = _ServiceBlockUntilComplete(theService);
    os_unfair_lock_lock(lock);
  }

void _RegisterReply( _DNSServiceRef_t *a1, unsigned int a2, int a3, const char *a4, const char *a5, const char *a6, char *cf)
{
  v21[3] = *MEMORY[0x1895F89C0];
  if (a3 != -65570)
  {
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    if (!*((void *)cf + 9))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
LABEL_24:
      CFRelease(cf);
      return;
    }

    CFDictionaryValueCallBacks v12 = CFGetAllocator(cf);
    v21[0] = a4;
    v21[1] = a5;
    v21[2] = a6;
    if (!a3)
    {
LABEL_15:
      for (uint64_t i = 0LL; i != 3; ++i)
      {
        CFStringRef v15 = (const char *)v21[i];
        if (v15)
        {
          CFStringRef v16 = CFStringCreateWithCString(v12, v15, 0x8000100u);
          if (v16)
          {
            CFStringRef v17 = v16;
            CFDictionarySetValue( *((CFMutableDictionaryRef *)cf + 6),  (const void *)dword_182BD7B00[i],  v16);
            CFRelease(v17);
          }
        }
      }

      unsigned int v18 = (void (*)(char *, __int128 *, uint64_t))*((void *)cf + 13);
      __int128 v20 = *(_OWORD *)(cf + 24);
      uint64_t v19 = *((void *)cf + 15);
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v18 && (a3 || (cf[20] & 1) == 0)) {
        v18(cf, &v20, v19);
      }
      goto LABEL_24;
    }

    int v13 = -72008;
    if (a3 > -65549)
    {
      if (a3 == -65548)
      {
        int v13 = -72001;
        goto LABEL_14;
      }

      if (a3 == -65540)
      {
        int v13 = -72004;
        goto LABEL_14;
      }
    }

    else
    {
      if (a3 == -65555)
      {
LABEL_14:
        *((void *)cf + 3) = 10LL;
        *((_DWORD *)cf + _Block_object_dispose((const void *)(v31 - 192), 8) = v13;
        goto LABEL_15;
      }

      if (a3 == -65554)
      {
        int v13 = -72002;
        goto LABEL_14;
      }
    }

    int v13 = -72000;
    goto LABEL_14;
  }

void _AddRecords(const void *a1, CFDataRef theData, void *a3)
{
  if ((a1 & 0xFFFF0000) == 0x10000LL)
  {
    RecordRef[7] = v3;
    RecordRef[8] = v4;
    if (!*((_DWORD *)a3 + 8))
    {
      uint64_t v8 = (_DNSServiceRef_t *)*((void *)a3 + 9);
      uint16_t Length = CFDataGetLength(theData);
      BytePtr = CFDataGetBytePtr(theData);
      DNSServiceErrorType v11 = DNSServiceAddRecord(v8, RecordRef, 0, (uint16_t)a1, Length, BytePtr, 0);
      *((_DWORD *)a3 + _Block_object_dispose((const void *)(v31 - 192), 8) = v11;
      if (!v11) {
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)a3 + 10), a1, RecordRef[0]);
      }
    }
  }

void _SocketCallBack_NetService( __CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, char *cf)
{
  DNSServiceErrorType v6 = DNSServiceProcessResult(*((DNSServiceRef *)cf + 9));
  if (!v6) {
    goto LABEL_13;
  }
  int v7 = -72008;
  *(void *)&__int128 v10 = 10LL;
  if (v6 <= -65549)
  {
    if (v6 == -65555) {
      goto LABEL_11;
    }
    if (v6 == -65554)
    {
      int v7 = -72002;
      goto LABEL_11;
    }

void _ScheduleSources(const __CFArray *a1, const __CFArray *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0LL; i != v5; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      _CFTypeScheduleOnMultipleRunLoops(ValueAtIndex, a2);
    }
  }

BOOL _ServiceBlockUntilComplete(__CFNetService *a1)
{
  double Current = CFRunLoopGetCurrent();
  CFNetServiceScheduleWithRunLoop(a1, Current, @"_kCFNetServiceBlockingMode");
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  while (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    CFRunLoopRunInMode(@"_kCFNetServiceBlockingMode", 1.79769313e308, 1u);
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  }

  BOOL v3 = *((_DWORD *)a1 + 8) == 0;
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  CFNetServiceUnscheduleFromRunLoop(a1, Current, @"_kCFNetServiceBlockingMode");
  return v3;
}

void CFNetServiceScheduleWithRunLoop(CFNetServiceRef theService, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  DNSServiceErrorType v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)theService + 12), runLoop, runLoopMode))
  {
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)theService + 8));
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0LL; i != v8; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)theService + 8), i);
        _CFTypeScheduleOnRunLoop(ValueAtIndex, runLoop, runLoopMode);
      }
    }
  }

  os_unfair_lock_unlock(v6);
}

void CFNetServiceUnscheduleFromRunLoop( CFNetServiceRef theService, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  DNSServiceErrorType v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)theService + 12), runLoop, runLoopMode))
  {
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)theService + 8));
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0LL; i != v8; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)theService + 8), i);
        _CFTypeUnscheduleFromRunLoop(ValueAtIndex, runLoop, runLoopMode);
      }
    }
  }

  os_unfair_lock_unlock(v6);
}

Boolean CFNetServiceResolveWithTimeout( CFNetServiceRef theService, CFTimeInterval timeout, CFStreamError *error)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (error) {
    CFIndex v5 = error;
  }
  else {
    CFIndex v5 = (CFStreamError *)&v21;
  }
  v5->domain = 0LL;
  *(void *)&v5->CFErrorRef error = 0LL;
  CFRetain(theService);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  *((void *)theService + 3) = 0LL;
  *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = 0;
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    if ((*((_BYTE *)theService + 20) & 8) == 0)
    {
      Boolean v6 = 0;
      *((void *)theService + 3) = 10LL;
      *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = -72003;
      goto LABEL_29;
    }

    _UnscheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    _InvalidateSources(*((__CFArray **)theService + 8));
    int v7 = (const void *)*((void *)theService + 5);
    if (v7)
    {
      CFRelease(v7);
      *((void *)theService + 5) = 0LL;
    }
  }

  if (*((_DWORD *)theService + 8))
  {
    Boolean v6 = 0;
    goto LABEL_29;
  }

  uint64_t v8 = 0LL;
  uint64_t v9 = dword_182BD7B00;
  do
  {
    unsigned int v10 = *v9++;
    unsigned int Value = (const __CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)theService + 6), (const void *)v10);
    if (Value)
    {
      CFDictionaryValueCallBacks v12 = Value;
      v26.length = CFStringGetLength(Value);
      v26.CFIndex location = 0LL;
      CFStringGetBytes(v12, v26, 0x8000100u, 0, 0, (UInt8 *)&v22[v8], 1023LL, &context.version);
      v22[v8 + context.version] = 0;
    }

    else
    {
      v22[v8] = 0;
    }

    v8 += 1024LL;
  }

  while (v8 != 3072);
  _ServiceCreateQuery_NoLock((CFDictionaryRef *)theService, 0LL, 0, v22, v23, v24);
  int v13 = *((_DWORD *)theService + 8);
  if (timeout > 0.0 && !v13)
  {
    context.version = 0LL;
    context.info = theService;
    memset(&context.retain, 0, 24);
    CFAbsoluteTime v14 = CFAbsoluteTimeGetCurrent() + timeout;
    CFStringRef v15 = CFGetAllocator(theService);
    CFRunLoopTimerRef v16 = CFRunLoopTimerCreate(v15, v14, 0.0, 0LL, 0LL, (CFRunLoopTimerCallBack)_LongTimerCallBack, &context);
    if (!v16)
    {
      if (*__error())
      {
        int v18 = *__error();
        *((void *)theService + 3) = 1LL;
      }

      else
      {
        *((void *)theService + 3) = 1LL;
        int v18 = 12;
      }

      *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = v18;
      if (v18) {
        goto LABEL_21;
      }
      goto LABEL_26;
    }

    CFRunLoopTimerRef v17 = v16;
    CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v16);
    CFRelease(v17);
    int v13 = *((_DWORD *)theService + 8);
  }

  if (v13)
  {
LABEL_21:
    _InvalidateSources(*((__CFArray **)theService + 8));
    DNSServiceRefDeallocate(*((DNSServiceRef *)theService + 9));
    Boolean v6 = 0;
    *((void *)theService + 9) = 0LL;
    goto LABEL_29;
  }

void _ServiceCreateQuery_NoLock( CFDictionaryRef *a1, uint64_t a2, unsigned int a3, const char *a4, const char *a5, const char *a6)
{
  unsigned int Value = (const __CFBoolean *)CFDictionaryGetValue(a1[6], (const void *)7);
  if (Value) {
    int v13 = (CFBooleanGetValue(Value) != 0) << 20;
  }
  else {
    int v13 = 0;
  }
  CFAbsoluteTime v14 = (const __CFBoolean *)CFDictionaryGetValue(a1[6], (const void *)9);
  if (v14 && CFBooleanGetValue(v14)) {
    int v13 = 0x100000;
  }
  CFStringRef v15 = a1 + 9;
  if (a3)
  {
    if (*v15)
    {
      CFRunLoopTimerRef v16 = CFGetAllocator(a1);
      CFStringRef v17 = CFStringCreateWithCString(v16, a4, 0x8000100u);
      if (!v17) {
        goto LABEL_20;
      }
      CFStringRef v18 = v17;
      uint64_t v19 = CFStringCreateWithFormat(v16, 0LL, @"%@%d.%d", v17, a3, a2);
      if (v19)
      {
        __int128 v20 = v19;
        CFIndex Length = CFStringGetLength(v19);
        CFMutableDictionaryRef MutableCopy = CFStringCreateMutableCopy(v16, Length, v20);
        CFStringLowercase(MutableCopy, 0LL);
        CFRelease(v20);
        CFRelease(v18);
        if (!MutableCopy) {
          goto LABEL_20;
        }
        if (!CFSetContainsValue(a1[11], MutableCopy))
        {
          CFSetSetValue(a1[11], MutableCopy);
          sdRef.version = (CFIndex)a1[9];
          *((_DWORD *)a1 + _Block_object_dispose((const void *)(v31 - 192), 8) = DNSServiceQueryRecord( (DNSServiceRef *)&sdRef,  v13 | 0x4000,  a2,  a4,  a3,  1u,  (DNSServiceQueryRecordReply)_QueryRecordReply_NetService,  a1);
        }

        unint64_t v23 = MutableCopy;
      }

      else
      {
        unint64_t v23 = (__CFString *)v18;
      }

      CFRelease(v23);
    }

    else
    {
      *((_DWORD *)a1 + _Block_object_dispose((const void *)(v31 - 192), 8) = -65537;
    }
  }

  else
  {
    DNSServiceErrorType Connection = DNSServiceCreateConnection(v15);
    *((_DWORD *)a1 + _Block_object_dispose((const void *)(v31 - 192), 8) = Connection;
    if (!Connection)
    {
      sdRef.version = (CFIndex)a1[9];
      *((_DWORD *)a1 + _Block_object_dispose((const void *)(v31 - 192), 8) = DNSServiceResolve( (DNSServiceRef *)&sdRef,  v13 | 0x4000,  a2,  a4,  a5,  a6,  (DNSServiceResolveReply)_ResolveReply,  a1);
    }
  }

void _LongTimerCallBack(__CFRunLoopTimer *a1, char *cf)
{
  if (CFArrayGetCount(*((CFArrayRef *)cf + 8)))
  {
    _CleanupService_NoLock((__CFNetService *)cf);
    *((void *)cf + 3) = 10LL;
    *((_DWORD *)cf + _Block_object_dispose((const void *)(v31 - 192), 8) = -72007;
    BOOL v3 = (void (*)(char *, __int128 *, uint64_t))*((void *)cf + 13);
    __int128 v5 = *(_OWORD *)(cf + 24);
    uint64_t v4 = *((void *)cf + 15);
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
    if (v3) {
      v3(cf, &v5, v4);
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  }

  CFRelease(cf);
}

void _ResolveReply( _DNSServiceRef_t *a1, unsigned int a2, unsigned int a3, int a4, const char *a5, const char *a6, unsigned int a7, unsigned int a8, const unsigned __int8 *a9, char *a10)
{
  if (a4 == -65570) {
    return;
  }
  uint64_t v32 = v10;
  uint64_t v33 = v11;
  CFRetain(a10);
  os_unfair_lock_lock((os_unfair_lock_t)a10 + 4);
  if (*((void *)a10 + 9))
  {
    if (a4)
    {
      int v17 = -72000;
      if (a4 > -65549)
      {
        if (a4 == -65548)
        {
          int v17 = -72001;
        }

        else if (a4 == -65540)
        {
          int v17 = -72004;
        }
      }

      else if (a4 == -65555)
      {
        int v17 = -72008;
      }

      else if (a4 == -65554)
      {
        int v17 = -72002;
      }

      BOOL v18 = 0;
      BOOL v19 = 0;
      *((void *)a10 + 3) = 10LL;
      *((_DWORD *)a10 + _Block_object_dispose((const void *)(v31 - 192), 8) = v17;
      goto LABEL_44;
    }

    __int128 v20 = CFGetAllocator(a10);
    char v21 = v20;
    if (a9) {
      CFDataRef v22 = CFDataCreate(v20, a9, a8);
    }
    else {
      CFDataRef v22 = 0LL;
    }
    unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)a10 + 6), (const void *)1);
    if (a6) {
      CFStringRef v24 = CFStringCreateWithCString(v21, a6, 0x8000100u);
    }
    else {
      CFStringRef v24 = 0LL;
    }
    int v25 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a10 + 6), (const void *)3);
    *((_DWORD *)a10 + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = __rev16(a7);
    if (Value && v22)
    {
      BOOL v19 = CFEqual(Value, v22) == 0;
    }

    else if (!Value || v22)
    {
      if (Value) {
        BOOL v26 = 1;
      }
      else {
        BOOL v26 = v22 == 0LL;
      }
      BOOL v19 = !v26;
      if (!Value) {
        goto LABEL_35;
      }
    }

    else
    {
      BOOL v19 = 1;
    }

    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)1);
LABEL_35:
    if (v22)
    {
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)1, v22);
      CFRelease(v22);
    }

    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)5);
    if (v24)
    {
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)a10 + 6), (const void *)5, v24);
      CFRelease(v24);
    }

    _ServiceCreateQuery_NoLock((__CFNetService *)a10, a3, 1u, a6, 0LL, 0LL, v27);
    _ServiceCreateQuery_NoLock((__CFNetService *)a10, a3, 0x1Cu, a6, 0LL, 0LL, v28);
    if (*((_DWORD *)a10 + 8))
    {
      *((void *)a10 + 3) = 10LL;
      *((_DWORD *)a10 + _Block_object_dispose((const void *)(v31 - 192), 8) = -72000;
    }

    if (v25) {
      BOOL v18 = CFArrayGetCount(v25) != 0;
    }
    else {
      BOOL v18 = 0;
    }
    goto LABEL_44;
  }

  BOOL v18 = 0;
  BOOL v19 = 0;
LABEL_44:
  if (*((_DWORD *)a10 + 8) || v19 && v18)
  {
    uint64_t v29 = (void (*)(char *, __int128 *, uint64_t))*((void *)a10 + 13);
    __int128 v31 = *(_OWORD *)(a10 + 24);
    uint64_t v30 = *((void *)a10 + 15);
    os_unfair_lock_unlock((os_unfair_lock_t)a10 + 4);
    if (v29) {
      v29(a10, &v31, v30);
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a10 + 4);
  }

  CFRelease(a10);
}

void _QueryRecordReply_NetService( _DNSServiceRef_t *a1, char a2, int a3, int a4, const char *a5, int a6, unsigned __int16 a7, int a8, _DWORD *a9, unsigned int a10, char *cf)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  if (a4 != -65570)
  {
    CFRetain(cf);
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    CFRunLoopTimerRef v16 = CFGetAllocator(cf);
    unsigned int Value = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 6), (const void *)3);
    if (!Value)
    {
      unsigned int Value = CFArrayCreateMutable(v16, 0LL, MEMORY[0x189605228]);
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)cf + 6), (const void *)3, Value);
      CFRelease(Value);
    }

    if (a4 == -65554) {
      goto LABEL_32;
    }
    if (a4)
    {
      int v20 = -72008;
      if (a4 != -65555)
      {
        if (a4 == -65548)
        {
          int v20 = -72001;
        }

        else if (a4 == -65540)
        {
          int v20 = -72004;
        }

        else
        {
          int v20 = -72000;
        }
      }

      *((void *)cf + 3) = 10LL;
      *((_DWORD *)cf + _Block_object_dispose((const void *)(v31 - 192), 8) = v20;
      CFStringRef v24 = (void (*)(char *, _OWORD *, uint64_t))*((void *)cf + 13);
      v31[0] = *(_OWORD *)(cf + 24);
      uint64_t v25 = *((void *)cf + 15);
      os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
      if (v24) {
        v24(cf, v31, v25);
      }
      goto LABEL_33;
    }

    unsigned int v18 = *((_DWORD *)cf + 14);
    __int128 v43 = 0u;
    memset(v44, 0, sizeof(v44));
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v32 = 0u;
    memset(v31, 0, sizeof(v31));
    if (a6 == 1)
    {
      if (a8 == 4)
      {
        LOWORD(v31[0]) = 528;
        WORD1(v31[0]) = bswap32(v18) >> 16;
        DWORD1(v31[0]) = *a9;
        CFIndex v19 = 16LL;
LABEL_19:
        CFDataRef v21 = CFDataCreate(v16, (const UInt8 *)v31, v19);
        if (v21)
        {
          CFDataRef v22 = v21;
          if ((a2 & 2) != 0)
          {
            CFArrayAppendValue((CFMutableArrayRef)Value, v21);
          }

          else
          {
            v46.length = CFArrayGetCount((CFArrayRef)Value);
            v46.CFIndex location = 0LL;
            FirstIndexOfunsigned int Value = CFArrayGetFirstIndexOfValue((CFArrayRef)Value, v46, v22);
            if (FirstIndexOfValue != -1) {
              CFArrayRemoveValueAtIndex((CFMutableArrayRef)Value, FirstIndexOfValue);
            }
          }

          CFRelease(v22);
        }
      }
    }

    else if (a6 == 28 && a8 == 16)
    {
      LOWORD(v31[0]) = 7708;
      WORD1(v31[0]) = bswap32(v18) >> 16;
      *(_OWORD *)((char *)v31 + _Block_object_dispose((const void *)(v31 - 192), 8) = *(_OWORD *)a9;
      if (BYTE8(v31[0]) == 254 && (BYTE9(v31[0]) & 0xC0) == 0x80) {
        DWORD2(v31[1]) = a3;
      }
      CFIndex v19 = 28LL;
      goto LABEL_19;
    }

    double v26 = dbl_182C9D760[(a2 & 1) == 0];
    double v27 = CFAbsoluteTimeGetCurrent() + v26;
    unsigned __int8 v28 = (__CFRunLoopTimer *)*((void *)cf + 5);
    if (v28)
    {
      CFRunLoopTimerSetNextFireDate(v28, v27);
    }

    else
    {
      *(void *)&v31[0] = 0LL;
      *((void *)&v31[0] + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = cf;
      *(void *)&__int128 v32 = 0LL;
      v31[1] = 0uLL;
      uint64_t v29 = CFGetAllocator(cf);
      CFRunLoopTimerRef v30 = CFRunLoopTimerCreate( v29,  v27,  10000000.0,  0LL,  0LL,  (CFRunLoopTimerCallBack)_ShortTimerCallBack,  (CFRunLoopTimerContext *)v31);
      *((void *)cf + 5) = v30;
      CFArrayAppendValue(*((CFMutableArrayRef *)cf + 8), v30);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)cf + 5), *((const __CFArray **)cf + 12));
    }

void _ShortTimerCallBack(__CFRunLoopTimer *a1, char *cf)
{
  BOOL v3 = (void (*)(char *, __int128 *, uint64_t))*((void *)cf + 13);
  __int128 v5 = *(_OWORD *)(cf + 24);
  uint64_t v4 = *((void *)cf + 15);
  os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  if (v3)
  {
    v3(cf, &v5, v4);
  }

  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)cf + 4);
    _CleanupService_NoLock((__CFNetService *)cf);
    os_unfair_lock_unlock((os_unfair_lock_t)cf + 4);
  }

  CFRelease(cf);
}

void CFNetServiceCancel(CFNetServiceRef theService)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (CFArrayGetCount(*((CFArrayRef *)theService + 8)))
  {
    v12.version = 0LL;
    v12.info = theService;
    v12.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
    v12.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
    memset(&v12.copyDescription, 0, 40);
    v12.perform = (void (__cdecl *)(void *))_ServiceCancel;
    _CleanupService_NoLock(theService);
    *((_BYTE *)theService + 20) &= 0xF1u;
    *((void *)theService + 3) = 10LL;
    *((_DWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = -72005;
    BOOL v3 = CFGetAllocator(theService);
    CFRunLoopSourceRef v4 = CFRunLoopSourceCreate(v3, 0LL, &v12);
    if (v4)
    {
      CFRunLoopSourceRef v5 = v4;
      Boolean v6 = (const __CFArray *)*((void *)theService + 12);
      CFIndex Count = CFArrayGetCount(v6);
      *((_BYTE *)theService + 20) |= 8u;
      CFArrayAppendValue(*((CFMutableArrayRef *)theService + 8), v5);
      _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
      CFRunLoopSourceSignal(v5);
      if (Count >= 1)
      {
        for (CFIndex i = 0LL; i < Count; i += 2LL)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v6, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            uint64_t v10 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v10)
            {
              uint64_t v11 = v10;
              if (CFRunLoopContainsSource(ValueAtIndex, v5, v10)) {
                CFRunLoopWakeUp(ValueAtIndex);
              }
              CFRelease(v11);
            }
          }
        }
      }

      CFRelease(v5);
    }
  }

  os_unfair_lock_unlock(v2);
}

void _ServiceCancel(__CFNetService *a1)
{
  if (CFArrayGetCount(*((CFArrayRef *)a1 + 8)))
  {
    __int128 v5 = *(_OWORD *)((char *)a1 + 24);
    uint64_t v2 = *((void *)a1 + 15);
    BOOL v3 = (void (*)(__CFNetService *, __int128 *, uint64_t))*((void *)a1 + 13);
    _UnscheduleSources(*((const __CFArray **)a1 + 8), *((const __CFArray **)a1 + 12));
    _InvalidateSources(*((__CFArray **)a1 + 8));
    CFRunLoopSourceRef v4 = (const void *)*((void *)a1 + 5);
    if (v4)
    {
      CFRelease(v4);
      *((void *)a1 + 5) = 0LL;
    }
  }

  else
  {
    BOOL v3 = 0LL;
    uint64_t v2 = 0LL;
  }

  *((_BYTE *)a1 + 20) &= ~8u;
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  if (v3) {
    v3(a1, &v5, v2);
  }
  CFRelease(a1);
}

Boolean CFNetServiceSetClient( CFNetServiceRef theService, CFNetServiceClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  Boolean v6 = (os_unfair_lock_s *)((char *)theService + 16);
  os_unfair_lock_lock((os_unfair_lock_t)theService + 4);
  if (*((void *)theService + 15))
  {
    int v7 = (void (*)(void))*((void *)theService + 17);
    if (v7) {
      v7();
    }
  }

  if (clientCB && clientContext)
  {
    if (!*((void *)theService + 13) && CFArrayGetCount(*((CFArrayRef *)theService + 8))) {
      _ScheduleSources(*((const __CFArray **)theService + 8), *((const __CFArray **)theService + 12));
    }
    *((void *)theService + 13) = clientCB;
    __int128 v8 = *(_OWORD *)&clientContext->version;
    __int128 v9 = *(_OWORD *)&clientContext->retain;
    *((void *)theService + 1_Block_object_dispose((const void *)(v31 - 192), 8) = clientContext->copyDescription;
    *((_OWORD *)theService + 7) = v8;
    *((_OWORD *)theService + _Block_object_dispose((const void *)(v31 - 192), 8) = v9;
    if (*((void *)theService + 15))
    {
      uint64_t v10 = (uint64_t (*)(void))*((void *)theService + 16);
      if (v10) {
        *((void *)theService + 15) = v10();
      }
    }
  }

  else
  {
    _CleanupService_NoLock(theService);
    *((_BYTE *)theService + 20) &= 0xF0u;
    *(_OWORD *)((char *)theService + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)((char *)theService + 120) = 0u;
    *(_OWORD *)((char *)theService + 136) = 0u;
  }

  os_unfair_lock_unlock(v6);
  return 1;
}

CFDictionaryRef CFNetServiceCreateDictionaryWithTXTData(CFAllocatorRef alloc, CFDataRef txtRecord)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFDataGetLength(txtRecord);
  BytePtr = CFDataGetBytePtr(txtRecord);
  Boolean v6 = BytePtr;
  unsigned int Count = TXTRecordGetCount(Length, BytePtr);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( alloc,  0LL,  &CFNetServiceCreateDictionaryWithTXTData::kTXTDictionaryKeyCallBacks,  MEMORY[0x189605250]);
  if (Mutable && Count)
  {
    uint16_t v9 = 0;
    uint64_t v10 = (const __CFData *)*MEMORY[0x189605018];
    while (1)
    {
      uint8_t valueLen = 0;
      value = 0LL;
LABEL_17:
      if (Count <= ++v9) {
        return Mutable;
      }
    }

    CFStringRef v11 = CFStringCreateWithCString(alloc, key, 0x8000100u);
    CFDataRef v12 = v10;
    if (value) {
      CFDataRef v12 = CFDataCreate(alloc, (const UInt8 *)value, valueLen);
    }
    if (v12 && v11)
    {
      if (CFStringGetLength(v11) && !CFDictionaryGetValue(Mutable, v11)) {
        CFDictionaryAddValue(Mutable, v11, v12);
      }
    }

    else if (!v12)
    {
      goto LABEL_15;
    }

    CFRelease(v12);
LABEL_15:
    if (v11) {
      CFRelease(v11);
    }
    goto LABEL_17;
  }

  return Mutable;
}

CFTypeRef TXTDictionaryKeyRetain(const __CFAllocator *a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

void TXTDictionaryKeyRelease(const __CFAllocator *a1, CFTypeRef cf)
{
}

BOOL TXTDictionaryKeyEqual(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 1uLL) == kCFCompareEqualTo;
}

CFDataRef CFNetServiceCreateTXTDataWithDictionary(CFAllocatorRef alloc, CFDictionaryRef keyValuePairs)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  CFIndex Count = CFDictionaryGetCount(keyValuePairs);
  __int128 v5 = (const void **)MEMORY[0x186E12804](alloc, 8 * Count, 0LL);
  uint64_t v6 = MEMORY[0x186E12804](alloc, 8 * Count, 0LL);
  int v7 = (const void **)v6;
  if (v5 && v6)
  {
    CFTypeID TypeID = CFStringGetTypeID();
    CFTypeID v9 = CFDataGetTypeID();
    CFDictionaryGetKeysAndValues(keyValuePairs, v5, v7);
    TXTRecordCreate(&txtRecord, 0, 0LL);
    if (Count < 1)
    {
      uint64_t v10 = 0LL;
    }

    else
    {
      uint64_t v10 = 0LL;
      unint64_t v23 = (const void *)*MEMORY[0x189605018];
      while (1)
      {
        CFIndex usedBufLen = 0LL;
        CFTypeID v11 = CFGetTypeID(v7[v10]);
        if (CFGetTypeID(v5[v10]) != TypeID) {
          break;
        }
        CFIndex Length = CFStringGetLength((CFStringRef)v5[v10]);
        v29.CFIndex location = 0LL;
        v29.length = Length;
        CFIndex Bytes = CFStringGetBytes((CFStringRef)v5[v10], v29, 0x600u, 0, 0, buffer, 256LL, &usedBufLen);
        if (!Length || Bytes < Length || usedBufLen > 255) {
          break;
        }
        buffer[usedBufLen] = 0;
        if (v11 == TypeID)
        {
          CFIndex v14 = CFStringGetLength((CFStringRef)v7[v10]);
          v30.CFIndex location = 0LL;
          v30.length = v14;
          if (CFStringGetBytes((CFStringRef)v7[v10], v30, 0x8000100u, 0, 0, v25, 256LL, &usedBufLen) < v14
            || usedBufLen > 255)
          {
            break;
          }

          uint8_t v15 = usedBufLen;
          BytePtr = v25;
        }

        else if (v11 != v9 || CFDataGetLength((CFDataRef)v7[v10]) > 255 || CFDataGetLength((CFDataRef)v7[v10]) < 0)
        {
          if (v7[v10] != v23) {
            break;
          }
          uint8_t v15 = 0;
          BytePtr = 0LL;
        }

        else
        {
          uint8_t v17 = CFDataGetLength((CFDataRef)v7[v10]);
          BytePtr = CFDataGetBytePtr((CFDataRef)v7[v10]);
          uint8_t v15 = v17;
        }

        if (Count == ++v10) {
          goto LABEL_28;
        }
      }
    }

    if (v10 == Count)
    {
LABEL_28:
      BytesPtr = (const UInt8 *)TXTRecordGetBytesPtr(&txtRecord);
      unsigned int v22 = TXTRecordGetLength(&txtRecord);
      CFDataRef v18 = CFDataCreate(alloc, BytesPtr, v22);
    }

    else
    {
      CFDataRef v18 = 0LL;
    }

    TXTRecordDeallocate(&txtRecord);
LABEL_31:
    CFAllocatorDeallocate(alloc, v5);
    CFIndex v19 = v18;
    if (!v7) {
      return v19;
    }
    goto LABEL_24;
  }

  CFDataRef v18 = 0LL;
  CFIndex v19 = 0LL;
  if (v5) {
    goto LABEL_31;
  }
  if (v6) {
LABEL_24:
  }
    CFAllocatorDeallocate(alloc, v7);
  return v19;
}

CFNetServiceRef _CFNetServiceCreateFromServiceName(const __CFAllocator *a1, CFStringRef theString)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  if (!theString || !CFStringGetCString(theString, buffer, 1009LL, 0x8000100u)) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  v52[0] = 0;
  while (1)
  {
    uint64_t v4 = v52[v3];
    if (v4 > 0x3F)
    {
LABEL_7:
      __int128 v5 = buffer;
      uint64_t v6 = buffer;
      goto LABEL_8;
    }

    if (!v52[v3]) {
      break;
    }
    v3 += v4 + 1;
  }

  CFDataRef v18 = &v52[v3];
  uint64_t v6 = buffer;
  if ((unint64_t)v3 > 0xFE || (char v19 = buffer[0]) == 0)
  {
    __int128 v5 = &v52[v3];
    goto LABEL_8;
  }

  uint64_t v6 = buffer;
  do
  {
    if (v19 == 46)
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "AppendDNSNameString: Illegal empty label in name %s", buffer);
      return 0LL;
    }

    if (v3 <= 254) {
      uint64_t v20 = 254LL;
    }
    else {
      uint64_t v20 = v3;
    }
    for (uint64_t i = v3; ; ++i)
    {
      if (!v19 || v19 == 46)
      {
        uint64_t v20 = i;
LABEL_42:
        uint64_t v3 = i + 1;
        __int128 v5 = &v52[i + 1];
        uint64_t i = v20;
        goto LABEL_43;
      }

      if (v20 == i) {
        goto LABEL_42;
      }
      unsigned int v22 = v6 + 1;
      if (v19 == 92) {
        break;
      }
LABEL_40:
      v52[i + 1] = v19;
      char v19 = *v22;
      uint64_t v6 = v22;
    }

    int v23 = *v22;
    if (*v22)
    {
      char v19 = *v22;
      unsigned int v22 = v6 + 2;
      if (v23 - 48 <= 9)
      {
        int v24 = *v22;
        if ((v24 - 48) <= 9)
        {
          int v25 = v6[3];
          if ((v25 - 48) <= 9)
          {
            int v26 = 100 * v23 + 10 * v24 + v25;
            double v27 = v6 + 4;
            if (v26 < 5584)
            {
              char v19 = v26 + 48;
              unsigned int v22 = v27;
            }
          }
        }
      }

      goto LABEL_40;
    }

    char v19 = 0;
    uint64_t v3 = i + 1;
    __int128 v5 = &v52[i + 1];
    ++v6;
LABEL_43:
    uint64_t v28 = (uint64_t)&v5[~(unint64_t)v18];
    if (v28 > 63) {
      return 0LL;
    }
    if (v19) {
      ++v6;
    }
    *CFDataRef v18 = v28;
    char v19 = *v6;
    if (!*v6) {
      break;
    }
    CFDataRef v18 = v5;
  }

  while (i < 254);
LABEL_8:
  char *v5 = 0;
  if (*v6) {
    return 0LL;
  }
  uint64_t v7 = v52[0];
  uint64_t v8 = 0LL;
  uint64_t v9 = v52[0] + 1LL;
  do
  {
    uint64_t v10 = v8 + 1;
    v50[v8] = v52[v8];
    uint64_t v8 = v10;
  }

  while (v9 != v10);
  uint64_t v11 = v52[v10];
  if (v52[v10 + 1] != 95) {
    return 0LL;
  }
  uint64_t v12 = 0LL;
  int v13 = &v52[v7 + 1];
  uint64_t v14 = v7 + 2 + v11;
  uint64_t v15 = v11 + 1;
  do
  {
    v49[v12] = v13[v12];
    ++v12;
  }

  while (v15 != v12);
  CFRunLoopTimerRef v16 = &v13[v12];
  if (*v16 != 4 || v16[1] != 95) {
    return 0LL;
  }
  int v17 = v16[2] & 0xDF;
  if (v17 != 84)
  {
    if (v17 != 85 || (v16[3] & 0xDF) != 0x44) {
      return 0LL;
    }
LABEL_55:
    if ((v16[4] & 0xDF) != 0x50) {
      return 0LL;
    }
    uint64_t v31 = 0LL;
    do
    {
      v49[v31 + v12] = v52[v14 + v31];
      ++v31;
    }

    while ((_DWORD)v31 != 5);
    uint64_t v32 = v14 + v31;
    v49[v12 + v31] = 0;
    unsigned int v33 = v52[v14 + v31];
    if (v52[v32])
    {
      __int128 v34 = v48;
      while (v33 <= 0x3F && v32 + v33 + 1 <= 254)
      {
        unsigned int v35 = v33 + 1;
        do
        {
          unsigned __int8 v36 = v52[v32++];
          *v34++ = v36;
          --v35;
        }

        while (v35);
        unsigned int v33 = v52[v32];
        if (!v52[v32]) {
          goto LABEL_67;
        }
      }

      return 0LL;
    }

    __int128 v34 = v48;
LABEL_67:
    *__int128 v34 = 0;
    if (v50[0] <= 0x3Fu)
    {
      if (v50[0])
      {
        __int128 v37 = &v50[v50[0] + 1];
        __int128 v38 = (char *)&v51;
        __int128 v39 = cStr;
        do
        {
          char v40 = *v38++;
          *v39++ = v40;
        }

        while (v38 < v37);
      }

      else
      {
        __int128 v39 = cStr;
      }

      char *v39 = 0;
    }

    _DNSServiceConvertDomainNameToCString_withescape(v49, (unsigned __int8 *)v46);
    _DNSServiceConvertDomainNameToCString_withescape(v48, (unsigned __int8 *)v45);
    __int128 v41 = CFStringCreateWithCString(a1, cStr, 0x8000100u);
    __int128 v42 = CFStringCreateWithCString(a1, v46, 0x8000100u);
    __int128 v43 = CFStringCreateWithCString(a1, v45, 0x8000100u);
    CFRange v44 = v43;
    if (v41)
    {
      if (v42 && v43)
      {
        CFNetServiceRef v29 = CFNetServiceCreate(a1, v43, v42, v41, -1);
        CFRelease(v41);
        CFRelease(v42);
        CFRelease(v44);
        return v29;
      }

      CFRelease(v41);
    }

    if (v42) {
      CFRelease(v42);
    }
    if (v44) {
      CFRelease(v44);
    }
    return 0LL;
  }

  if ((v16[3] & 0xDF) == 0x43) {
    goto LABEL_55;
  }
  return 0LL;
}

CFNetServiceRef _CFNetServiceCreateFromURL(const __CFAllocator *a1, CFURLRef anURL)
{
  if (!anURL) {
    return 0LL;
  }
  uint64_t v3 = CFURLCopyHostName(anURL);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  CFNetServiceRef v5 = _CFNetServiceCreateFromServiceName(a1, v3);
  CFRelease(v4);
  return v5;
}

CFTypeID CFNetServiceMonitorGetTypeID(void)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1633;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CFNetServiceMonitorRegisterClass;
  if (_kCFNetServiceMonitorRegisterClass != -1) {
    dispatch_once(&_kCFNetServiceMonitorRegisterClass, block);
  }
  return _kCFNetServiceMonitorTypeID;
}

void *_CFNetServiceMonitorRegisterClass(void)
{
  CFDataRef result = calloc(1uLL, 0x60uLL);
  _kCFNetServiceMonitorClass = (uint64_t)result;
  if (result)
  {
    *CFDataRef result = 0LL;
    result[1] = "CFNetServiceMonitor";
    result[4] = _MonitorDestroy;
    CFDataRef result = (void *)_CFRuntimeRegisterClass();
    _kCFNetServiceMonitorCFTypeID TypeID = (uint64_t)result;
  }

  return result;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_1633(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void _MonitorDestroy(__CFNetServiceMonitor *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 4);
  if (*((void *)a1 + 13))
  {
    uint64_t v3 = (void (*)(void))*((void *)a1 + 15);
    if (v3) {
      v3();
    }
  }

  uint64_t v4 = *((void *)a1 + 6);
  if (v4)
  {
    uint64_t v5 = *((void *)a1 + 10);
    if (v5)
    {
      _CFTypeUnscheduleFromMultipleRunLoops(v4, v5);
      uint64_t v4 = *((void *)a1 + 6);
    }

    _CFTypeInvalidate(v4);
    CFRelease(*((CFTypeRef *)a1 + 6));
  }

  uint64_t v6 = (_DNSServiceRef_t *)*((void *)a1 + 7);
  if (v6) {
    DNSServiceRefDeallocate(v6);
  }
  uint64_t v7 = (const void *)*((void *)a1 + 5);
  if (v7)
  {
    CFRelease(v7);
    *((void *)a1 + 5) = 0LL;
  }

  uint64_t v8 = (const void *)*((void *)a1 + 10);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)*((void *)a1 + 8);
  if (v9) {
    CFRelease(v9);
  }
  os_unfair_lock_unlock(v2);
}

CFNetServiceMonitorRef CFNetServiceMonitorCreate( CFAllocatorRef alloc, CFNetServiceRef theService, CFNetServiceMonitorClientCallBack clientCB, CFNetServiceClientContext *clientContext)
{
  uint64_t v4 = 0LL;
  if (clientCB && clientContext)
  {
    if (!CFNetServiceMonitorGetTypeID()) {
      return 0LL;
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    uint64_t v4 = (__CFNetServiceMonitor *)Instance;
    if (Instance)
    {
      *(void *)(Instance + 12_Block_object_dispose((const void *)(v31 - 192), 8) = 0LL;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
      *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(void *)(Instance + 8_Block_object_dispose((const void *)(v31 - 192), 8) = clientCB;
      __int128 v11 = *(_OWORD *)&clientContext->version;
      __int128 v10 = *(_OWORD *)&clientContext->retain;
      *(void *)(Instance + 12_Block_object_dispose((const void *)(v31 - 192), 8) = clientContext->copyDescription;
      *(_OWORD *)(Instance + 96) = v11;
      *(_OWORD *)(Instance + 112) = v10;
      if (*(void *)(Instance + 104))
      {
        uint64_t v12 = *(uint64_t (**)(void))(Instance + 112);
        if (v12) {
          *(void *)(Instance + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v12();
        }
      }

      CFMutableArrayRef Mutable = CFArrayCreateMutable(alloc, 0LL, MEMORY[0x189605228]);
      *((void *)v4 + 10) = Mutable;
      if (Mutable)
      {
        *((void *)v4 + 5) = CFRetain(theService);
        return v4;
      }

      CFRelease(v4);
      return 0LL;
    }
  }

  return v4;
}

void CFNetServiceMonitorInvalidate(CFNetServiceMonitorRef monitor)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (*((void *)monitor + 13))
  {
    uint64_t v3 = (void (*)(void))*((void *)monitor + 15);
    if (v3) {
      v3();
    }
  }

  uint64_t v4 = *((void *)monitor + 6);
  if (v4)
  {
    _CFTypeUnscheduleFromMultipleRunLoops(v4, *((void *)monitor + 10));
    _CFTypeInvalidate(*((void *)monitor + 6));
    CFRelease(*((CFTypeRef *)monitor + 6));
    *((void *)monitor + 6) = 0LL;
  }

  uint64_t v5 = (_DNSServiceRef_t *)*((void *)monitor + 7);
  if (v5)
  {
    DNSServiceRefDeallocate(v5);
    *((void *)monitor + 7) = 0LL;
  }

  uint64_t v6 = (const void *)*((void *)monitor + 5);
  if (v6)
  {
    CFRelease(v6);
    *((void *)monitor + 5) = 0LL;
  }

  *(_OWORD *)((char *)monitor + 120) = 0u;
  *(_OWORD *)((char *)monitor + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)((char *)monitor + 8_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  os_unfair_lock_unlock(v2);
}

Boolean CFNetServiceMonitorStart( CFNetServiceMonitorRef monitor, CFNetServiceMonitorType recordType, CFStreamError *error)
{
  uint64_t v3 = (char *)MEMORY[0x1895F8858](monitor);
  int v6 = v5;
  uint64_t v7 = v3;
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (v4) {
    uint64_t v8 = v4;
  }
  else {
    uint64_t v8 = &v34;
  }
  *(void *)uint64_t v8 = 0LL;
  *((void *)v8 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  CFRetain(v3);
  uint64_t v9 = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
  os_unfair_lock_lock((os_unfair_lock_t)v7 + 4);
  v35[0] = CFNetServiceGetInfo(*((void *)v7 + 5), 0);
  v35[1] = CFNetServiceGetInfo(*((void *)v7 + 5), 4u);
  v35[2] = CFNetServiceGetInfo(*((void *)v7 + 5), 2u);
  context.version = 0LL;
  context.info = v7;
  context.retain = v9;
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
  context.copyDescription = 0LL;
  if (!*((void *)v7 + 11))
  {
    Boolean v12 = 0;
    *((void *)v7 + 3) = 10LL;
    int v13 = -72006;
    goto LABEL_9;
  }

  __int128 v10 = (const void *)*((void *)v7 + 6);
  if (v10)
  {
    CFTypeID v11 = CFGetTypeID(v10);
    if (v11 == CFSocketGetTypeID())
    {
      Boolean v12 = 0;
      *((void *)v7 + 3) = 10LL;
      int v13 = -72003;
LABEL_9:
      *((_DWORD *)v7 + _Block_object_dispose((const void *)(v31 - 192), 8) = v13;
      goto LABEL_39;
    }

    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)v7 + 6), *((const __CFArray **)v7 + 10));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)v7 + 6));
    CFRelease(*((CFTypeRef *)v7 + 6));
    *((void *)v7 + 6) = 0LL;
  }

  uint64_t v14 = 0LL;
  uint64_t v15 = (const __CFString **)v35;
  do
  {
    CFRunLoopTimerRef v16 = *v15++;
    v41.length = CFStringGetLength(v16);
    v41.CFIndex location = 0LL;
    CFStringGetBytes(v16, v41, 0x8000100u, 0, 0, (UInt8 *)&domain[v14], 1023LL, &usedBufLen);
    domain[v14 + usedBufLen] = 0;
    v14 += 1024LL;
  }

  while (v14 != 3072);
  if (v6 == 1) {
    uint16_t v17 = 1;
  }
  else {
    uint16_t v17 = HIWORD(v6);
  }
  if (v6 == 1) {
    uint16_t v18 = 16;
  }
  else {
    uint16_t v18 = v6;
  }
  DNSServiceConstructFullName(v39, v38, v37, domain);
  *((_DWORD *)v7 + 1_Block_object_dispose((const void *)(v31 - 192), 8) = v6;
  Info = (const __CFBoolean *)CFNetServiceGetInfo(*((void *)v7 + 5), 7u);
  if (Info) {
    int v20 = (CFBooleanGetValue(Info) != 0) << 20;
  }
  else {
    int v20 = 0;
  }
  CFDataRef v21 = (const __CFBoolean *)CFNetServiceGetInfo(*((void *)v7 + 5), 9u);
  if (v21 && CFBooleanGetValue(v21)) {
    int v20 = 0x100000;
  }
  int v22 = -72008;
  DNSServiceErrorType Record = DNSServiceQueryRecord( (DNSServiceRef *)v7 + 7,  v20 | 0x100,  0,  v39,  v18,  v17,  (DNSServiceQueryRecordReply)_QueryRecordReply,  v7);
  *((_DWORD *)v7 + _Block_object_dispose((const void *)(v31 - 192), 8) = Record;
  if (Record <= -65549)
  {
    if (Record == -65555) {
      goto LABEL_38;
    }
    if (Record == -65554)
    {
      int v22 = -72002;
      goto LABEL_38;
    }

    goto LABEL_37;
  }

  if (Record == -65548)
  {
    int v22 = -72001;
    goto LABEL_38;
  }

  if (Record)
  {
    if (Record == -65540)
    {
      int v22 = -72004;
LABEL_38:
      Boolean v12 = 0;
      *((void *)v7 + 3) = 10LL;
      *((_DWORD *)v7 + _Block_object_dispose((const void *)(v31 - 192), 8) = v22;
      goto LABEL_39;
    }

void _QueryRecordReply( _DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, unsigned __int16 a6, unsigned __int16 a7, unsigned int a8, const UInt8 *a9, unsigned int a10, unsigned int *a11)
{
  if (a4 != -65570)
  {
    uint64_t v28 = v11;
    uint64_t v29 = v12;
    CFRetain(a11);
    os_unfair_lock_lock((os_unfair_lock_t)a11 + 4);
    if (!*((void *)a11 + 7))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)a11 + 4);
LABEL_36:
      CFRelease(a11);
      return;
    }

    CFRunLoopTimerRef v16 = (__CFNetService *)CFRetain(*((CFTypeRef *)a11 + 5));
    uint64_t v17 = a11[18];
    if (a4)
    {
      int v18 = -72008;
      if (a4 > -65549)
      {
        if (a4 == -65548)
        {
          int v18 = -72001;
          goto LABEL_20;
        }

        if (a4 == -65540)
        {
          int v18 = -72004;
          goto LABEL_20;
        }
      }

      else
      {
        if (a4 == -65555)
        {
LABEL_20:
          *((void *)a11 + 3) = 10LL;
          a11[8] = v18;
          _CFTypeUnscheduleFromMultipleRunLoops(*((void **)a11 + 6), *((const __CFArray **)a11 + 10));
          CFSocketInvalidate(*((CFSocketRef *)a11 + 6));
          CFRelease(*((CFTypeRef *)a11 + 6));
          *((void *)a11 + 6) = 0LL;
          DNSServiceRefDeallocate(*((DNSServiceRef *)a11 + 7));
          CFDataRef v20 = 0LL;
          int v19 = 0;
          *((void *)a11 + 7) = 0LL;
          goto LABEL_30;
        }

        if (a4 == -65554)
        {
          int v18 = -72002;
          goto LABEL_20;
        }
      }

      int v18 = -72000;
      goto LABEL_20;
    }

    int v19 = 0;
    CFDataRef v20 = 0LL;
    if ((a2 & 2) == 0 || !a9) {
      goto LABEL_30;
    }
    CFDataRef v21 = CFGetAllocator(a11);
    CFDataRef v20 = CFDataCreate(v21, a9, a8);
    int v22 = (const void *)*((void *)a11 + 8);
    if (v22 && v20)
    {
      int v23 = CFEqual(v22, v20);
      int v22 = (const void *)*((void *)a11 + 8);
      if (!v23)
      {
        int v19 = 1;
        if (!v22) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }

      BOOL v24 = v22 == 0LL;
    }

    else
    {
      BOOL v24 = v22 == 0LL;
      if (v22 && !v20)
      {
        int v19 = 1;
LABEL_28:
        CFRelease(v22);
LABEL_29:
        *((void *)a11 + _Block_object_dispose((const void *)(v31 - 192), 8) = v20;
        _ServiceSetInfo(v16, v17, v20, 0);
LABEL_30:
        dnssd_sock_t v25 = (void (*)(unsigned int *, __CFNetService *, uint64_t, CFDataRef, __int128 *, uint64_t))*((void *)a11 + 11);
        __int128 v27 = *(_OWORD *)(a11 + 6);
        uint64_t v26 = *((void *)a11 + 13);
        os_unfair_lock_unlock((os_unfair_lock_t)a11 + 4);
        if (v25 && (a2 & 2) != 0 && v19) {
          v25(a11, v16, v17, v20, &v27, v26);
        }
        if (v16) {
          CFRelease(v16);
        }
        goto LABEL_36;
      }
    }

    if (v20) {
      int v19 = v24;
    }
    else {
      int v19 = 0;
    }
    if (!v22) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }

void _SocketCallBack_Mon( __CFSocket *a1, unint64_t a2, const __CFData *a3, const void *a4, DNSServiceRef *cf)
{
  int v6 = (_DNSServiceRef_t *)DNSServiceProcessResult(cf[7]);
  if ((_DWORD)v6) {
    _QueryRecordReply(v6, 0, v7, (int)v6, v8, 0, 0, 0, 0LL, v9, (unsigned int *)cf);
  }
  CFRelease(cf);
}

void CFNetServiceMonitorScheduleWithRunLoop( CFNetServiceMonitorRef monitor, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  int v6 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (_SchedulesAddRunLoopAndMode(*((const __CFArray **)monitor + 10), runLoop, runLoopMode))
  {
    uint64_t v7 = *((void *)monitor + 6);
    if (v7) {
      _CFTypeScheduleOnRunLoop(v7, runLoop, runLoopMode);
    }
  }

  os_unfair_lock_unlock(v6);
}

void CFNetServiceMonitorUnscheduleFromRunLoop( CFNetServiceMonitorRef monitor, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  int v6 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)monitor + 10), runLoop, runLoopMode))
  {
    uint64_t v7 = *((void *)monitor + 6);
    if (v7) {
      _CFTypeUnscheduleFromRunLoop(v7, runLoop, runLoopMode);
    }
  }

  os_unfair_lock_unlock(v6);
}

void CFNetServiceMonitorStop(CFNetServiceMonitorRef monitor, CFStreamError *error)
{
  uint64_t v16 = 10LL;
  int v17 = -72005;
  if (error) {
    uint64_t v3 = error;
  }
  else {
    uint64_t v3 = (CFStreamError *)&v16;
  }
  uint64_t v4 = (os_unfair_lock_s *)((char *)monitor + 16);
  os_unfair_lock_lock((os_unfair_lock_t)monitor + 4);
  int v5 = (void *)*((void *)monitor + 6);
  if (v5)
  {
    v15.version = 0LL;
    v15.info = monitor;
    v15.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
    v15.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
    memset(&v15.copyDescription, 0, 40);
    v15.perform = (void (__cdecl *)(void *))_MonitorCancel;
    _CFTypeUnscheduleFromMultipleRunLoops(v5, *((const __CFArray **)monitor + 10));
    _CFTypeInvalidate(*((char **)monitor + 6));
    CFRelease(*((CFTypeRef *)monitor + 6));
    int v6 = (_DNSServiceRef_t *)*((void *)monitor + 7);
    if (v6)
    {
      DNSServiceRefDeallocate(v6);
      *((void *)monitor + 7) = 0LL;
    }

    *(CFStreamError *)((char *)monitor + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = *v3;
    uint64_t v7 = CFGetAllocator(monitor);
    CFRunLoopSourceRef v8 = CFRunLoopSourceCreate(v7, 0LL, &v15);
    *((void *)monitor + 6) = v8;
    if (v8)
    {
      unsigned int v9 = (const __CFArray *)*((void *)monitor + 10);
      CFIndex Count = CFArrayGetCount(v9);
      _CFTypeScheduleOnMultipleRunLoops(*((void **)monitor + 6), v9);
      CFRunLoopSourceSignal(*((CFRunLoopSourceRef *)monitor + 6));
      if (Count >= 1)
      {
        for (CFIndex i = 0LL; i < Count; i += 2LL)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v9, i);
          if (CFRunLoopIsWaiting(ValueAtIndex))
          {
            int v13 = CFRunLoopCopyCurrentMode(ValueAtIndex);
            if (v13)
            {
              uint64_t v14 = v13;
              if (CFRunLoopContainsSource(ValueAtIndex, *((CFRunLoopSourceRef *)monitor + 6), v13)) {
                CFRunLoopWakeUp(ValueAtIndex);
              }
              CFRelease(v14);
            }
          }
        }
      }
    }
  }

  os_unfair_lock_unlock(v4);
}

void _MonitorCancel(__CFNetServiceMonitor *a1)
{
  uint64_t v2 = (void *)*((void *)a1 + 6);
  if (v2)
  {
    __int128 v5 = *(_OWORD *)((char *)a1 + 24);
    uint64_t v3 = *((void *)a1 + 13);
    uint64_t v4 = (void (*)(__CFNetServiceMonitor *, void, void, void, __int128 *, uint64_t))*((void *)a1 + 11);
    _CFTypeUnscheduleFromMultipleRunLoops(v2, *((const __CFArray **)a1 + 10));
    CFRunLoopSourceInvalidate(*((CFRunLoopSourceRef *)a1 + 6));
    CFRelease(*((CFTypeRef *)a1 + 6));
    *((void *)a1 + 6) = 0LL;
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
    if (v4) {
      v4(a1, 0LL, 0LL, 0LL, &v5, v3);
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 4);
  }

  CFRelease(a1);
}

__CFDictionary *CFNetDiagnosticCreateBasic( const __CFAllocator *a1, const void *a2, const void *a3, const void *a4)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    unsigned int v9 = MainBundle;
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x189604E10]);
    if (ValueForInfoDictionaryKey) {
      CFDictionaryAddValue(Mutable, @"NDNameKey", ValueForInfoDictionaryKey);
    }
    CFStringRef Identifier = CFBundleGetIdentifier(v9);
    if (Identifier) {
      CFDictionaryAddValue(Mutable, @"NDBundleKey", Identifier);
    }
  }

  if (a2) {
    CFDictionaryAddValue(Mutable, @"NDRemoteHostKey", a2);
  }
  if (a3) {
    CFDictionaryAddValue(Mutable, @"NDProtocolKey", a3);
  }
  if (a4) {
    CFDictionaryAddValue(Mutable, @"NDPortKey", a4);
  }
  CFDictionaryAddValue(Mutable, @"NDMethodKey", @"CFNetDiagnosticCreateBasic");
  return Mutable;
}

CFNetDiagnosticRef CFNetDiagnosticCreateWithURL(CFAllocatorRef alloc, CFURLRef url)
{
  if (!CFURLCanBeDecomposed(url)) {
    return 0LL;
  }
  SInt32 valuePtr = CFURLGetPortNumber(url);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(alloc, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    int v6 = MainBundle;
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x189604E10]);
    if (ValueForInfoDictionaryKey) {
      CFDictionaryAddValue(Mutable, @"NDNameKey", ValueForInfoDictionaryKey);
    }
    CFStringRef Identifier = CFBundleGetIdentifier(v6);
    if (Identifier) {
      CFDictionaryAddValue(Mutable, @"NDBundleKey", Identifier);
    }
  }

  CFStringRef v9 = CFURLCopyHostName(url);
  if (v9)
  {
    CFStringRef v10 = v9;
    CFDictionaryAddValue(Mutable, @"NDRemoteHostKey", v9);
    CFRelease(v10);
  }

  CFStringRef v11 = CFURLCopyScheme(url);
  if (v11)
  {
    CFStringRef v12 = v11;
    CFDictionaryAddValue(Mutable, @"NDProtocolKey", v11);
    CFRelease(v12);
  }

  CFNumberRef v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberSInt32Type, &valuePtr);
  if (v13)
  {
    CFNumberRef v14 = v13;
    CFDictionaryAddValue(Mutable, @"NDPortKey", v13);
    CFRelease(v14);
  }

  CFDictionaryAddValue(Mutable, @"NDMethodKey", @"CFNetDiagnosticCreateWithURL");
  return Mutable;
}

CFNetDiagnosticRef CFNetDiagnosticCreateWithStreams( CFAllocatorRef alloc, CFReadStreamRef readStream, CFWriteStreamRef writeStream)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(alloc, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    __int128 v5 = MainBundle;
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(MainBundle, (CFStringRef)*MEMORY[0x189604E10]);
    if (ValueForInfoDictionaryKey) {
      CFDictionaryAddValue(Mutable, @"NDNameKey", ValueForInfoDictionaryKey);
    }
    CFStringRef Identifier = CFBundleGetIdentifier(v5);
    if (Identifier) {
      CFDictionaryAddValue(Mutable, @"NDBundleKey", Identifier);
    }
  }

  CFDictionaryAddValue(Mutable, @"NDMethodKey", @"CFNetDiagnosticCreateWithStreams");
  return Mutable;
}

void CFNetDiagnosticSetName(CFNetDiagnosticRef details, CFStringRef name)
{
  if (name) {
    CFDictionaryAddValue(details, @"NDNameKey", name);
  }
}

void CFNetDiagnosticSetProtocol(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionaryAddValue(a1, @"NDProtocolKey", value);
  }
}

void CFNetDiagnosticSetServiceID(__CFDictionary *a1, void *value)
{
  if (value) {
    CFDictionaryAddValue(a1, @"NDServiceIDKey", value);
  }
}

CFNetDiagnosticStatus CFNetDiagnosticDiagnoseProblemInteractively(CFNetDiagnosticRef details)
{
  if (CFNetDiagnosticDiagnoseProblemInteractively::sOnce != -1) {
    dispatch_once(&CFNetDiagnosticDiagnoseProblemInteractively::sOnce, &__block_literal_global_1675);
  }
  return -66560LL;
}

void __CFNetDiagnosticDiagnoseProblemInteractively_block_invoke()
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v0 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_error_impl( &dword_18298D000,  v0,  OS_LOG_TYPE_ERROR,  "CFNetDiagnosticDiagnoseProblemInteractively is no longer supported. Please stop using it.",  v1,  2u);
  }

uint64_t CFNetDiagnosticCopyNetworkStatusActively(const __CFDictionary *a1, CFStringRef *a2, double a3)
{
  uint64_t v6 = -66557LL;
  if (!mach_timebase_info(&info))
  {
    uint64_t v7 = mach_absolute_time();
    uint32_t numer = info.numer;
    uint32_t denom = info.denom;
    CFStringRef v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    SCDynamicStoreRef v11 = SCDynamicStoreCreate((CFAllocatorRef)*MEMORY[0x189604DB0], @"CFNetDiagnostics", 0LL, 0LL);
    if (v11)
    {
      CFStringRef v12 = v11;
      uint64_t v46 = v7;
      uint64_t v13 = mach_absolute_time();
      CFNumberRef v14 = (const __CFString *)*MEMORY[0x18960C588];
      domain = (const __CFString *)*MEMORY[0x18960C548];
      NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity( v10,  (CFStringRef)*MEMORY[0x18960C548],  (CFStringRef)*MEMORY[0x18960C588]);
      store = v12;
      uint64_t v16 = (const __CFDictionary *)SCDynamicStoreCopyValue(v12, NetworkGlobalEntity);
      if (v16)
      {
        int v17 = v16;
        CFMutableDictionaryRef theDict = a1;
        unsigned int Value = (const __CFString *)CFDictionaryGetValue(v16, (const void *)*MEMORY[0x18960C718]);
        if (Value)
        {
          int v19 = Value;
          double v20 = (double)numer * -0.000000001 / (double)denom;
          CFRetain(Value);
          CFRelease(v17);
          CFRelease(NetworkGlobalEntity);
          if (CFNetDiagnosticPing(v19, 1LL, (a3 + v20 * (double)(v13 - v46)), 0LL))
          {
            CFDataRef v21 = SCDynamicStoreKeyCreateNetworkGlobalEntity(v10, domain, v14);
            int v22 = (const __CFDictionary *)SCDynamicStoreCopyValue(store, v21);
            if (v22)
            {
              int v23 = v22;
              BOOL v24 = (const __CFString *)CFDictionaryGetValue(v22, (const void *)*MEMORY[0x18960C560]);
              if (v24)
              {
                dnssd_sock_t v25 = v24;
                CFRetain(v24);
                CFRelease(v23);
                CFRelease(v21);
                NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity( v10,  domain,  v25,  (CFStringRef)*MEMORY[0x18960C580]);
                __int128 v27 = (const __CFDictionary *)SCDynamicStoreCopyValue(store, NetworkServiceEntity);
                if (v27)
                {
                  uint64_t v28 = v27;
                  uint64_t v29 = (const __CFArray *)CFDictionaryGetValue(v27, (const void *)*MEMORY[0x18960C620]);
                  int v30 = v29;
                  if (v29) {
                    CFRetain(v29);
                  }
                  CFRelease(v28);
                }

                else
                {
                  int v30 = 0LL;
                }

                CFRelease(NetworkServiceEntity);
                CFRelease(v25);
                uint64_t v31 = store;
                if (!v30) {
                  goto LABEL_18;
                }
                CFIndex Count = CFArrayGetCount(v30);
                uint64_t v34 = mach_absolute_time();
                if (Count >= 1)
                {
                  uint64_t v35 = ((a3 + v20 * (double)(v34 - v46)) / (double)Count);
                  uint64_t v36 = 1LL;
                  do
                  {
                    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v30, v36 - 1);
                    BOOL v38 = CFNetDiagnosticPing(ValueAtIndex, 1LL, v35, 0LL);
                    if (v36 >= Count) {
                      break;
                    }
                    ++v36;
                  }

                  while (!v38);
                  if (v38)
                  {
                    uint64_t v39 = mach_absolute_time();
                    if (CFNetDiagnosticPing( @"www.apple.com",  1LL,  (a3 + v20 * (double)(v39 - v46)),  &err))
                    {
                      uint64_t v40 = (const __CFString *)CFDictionaryGetValue(theDict, @"NDRemoteHostKey");
                      uint64_t v41 = -66559LL;
                      if (!v40) {
                        goto LABEL_45;
                      }
                      __int128 v42 = v40;
                      if (CFEqual(v40, @"www.apple.com")) {
                        goto LABEL_45;
                      }
                      uint64_t v43 = mach_absolute_time();
                      if (CFNetDiagnosticPing(v42, 1LL, (a3 + v20 * (double)(v43 - v46)), &err))
                      {
                        uint64_t v41 = -66552LL;
LABEL_45:
                        CFRelease(v30);
                        uint64_t v6 = v41;
                        goto LABEL_18;
                      }

                      if (CFErrorGetDomain(err) == (CFErrorDomain)*MEMORY[0x189604F58] && CFErrorGetCode(err) == 65) {
                        uint64_t v6 = -66555LL;
                      }
                      else {
                        uint64_t v6 = -66553LL;
                      }
                    }

                    else if (CFErrorGetDomain(err) == (CFErrorDomain)*MEMORY[0x189604F58] && CFErrorGetCode(err) == 65)
                    {
                      uint64_t v6 = -66556LL;
                    }

                    CFRelease(err);
                    uint64_t v41 = v6;
                    goto LABEL_45;
                  }
                }

                uint64_t v41 = -66556LL;
                goto LABEL_45;
              }

              CFRelease(v23);
            }

            CFRelease(v21);
          }

          else
          {
            uint64_t v6 = -66554LL;
          }

          uint64_t v31 = store;
LABEL_18:
          CFRelease(v19);
          goto LABEL_19;
        }

        CFRelease(v17);
      }

      CFRelease(NetworkGlobalEntity);
      uint64_t v31 = store;
LABEL_19:
      CFRelease(v31);
    }
  }

  if (a2) {
    *a2 = _CFNetDiagnosticCopyLocalizedDescription(v6);
  }
  return v6;
}

CFStringRef _CFNetDiagnosticCopyLocalizedDescription(uint64_t a1)
{
  if (__CFNGetCFNetworkBundle::onceToken != -1) {
    dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4714);
  }
  switch(a1)
  {
    case -66559LL:
      uint64_t v2 = @"CONNECTION_UP";
      goto LABEL_13;
    case -66558LL:
      uint64_t v2 = @"CONNECTION_INDETERMINATE";
      goto LABEL_13;
    case -66557LL:
      uint64_t v2 = @"CONNECTION_DOWN";
      goto LABEL_13;
    case -66556LL:
      uint64_t v2 = @"NAMESERVER_DOWN";
      goto LABEL_13;
    case -66555LL:
      uint64_t v2 = @"NAMELOOKUP_FAILED";
      goto LABEL_13;
    case -66554LL:
      uint64_t v2 = @"ROUTER_DOWN";
      goto LABEL_13;
    case -66553LL:
      uint64_t v2 = @"SERVER_DOWN";
      goto LABEL_13;
    case -66552LL:
      uint64_t v2 = @"SERVER_UP";
LABEL_13:
      CFStringRef result = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, v2, v2, 0LL);
      break;
    default:
      CFStringRef result = 0LL;
      break;
  }

  return result;
}

CFNetDiagnosticStatus CFNetDiagnosticCopyNetworkStatusPassively( CFNetDiagnosticRef details, CFStringRef *description)
{
  CFNetDiagnosticStatus v4 = -66560LL;
  __int128 v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  SCDynamicStoreRef v6 = SCDynamicStoreCreate((CFAllocatorRef)*MEMORY[0x189604DB0], @"CFNetDiagnostics", 0LL, 0LL);
  if (v6)
  {
    uint64_t v7 = v6;
    unsigned int Value = (const __CFString *)CFDictionaryGetValue(details, @"NDServiceIDKey");
    if (Value)
    {
      uint64_t v9 = _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific(v7, Value, description);
      goto LABEL_18;
    }

    NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity( v5,  (CFStringRef)*MEMORY[0x18960C540],  (CFStringRef)*MEMORY[0x18960C588]);
    SCDynamicStoreRef v11 = (const __CFDictionary *)SCDynamicStoreCopyValue(v7, NetworkGlobalEntity);
    if (v11)
    {
      CFStringRef v12 = v11;
      uint64_t v13 = (const __CFArray *)CFDictionaryGetValue(v11, (const void *)*MEMORY[0x18960C970]);
      if (v13)
      {
        CFNumberRef v14 = v13;
        CFRetain(v13);
        CFRelease(v12);
        CFRelease(NetworkGlobalEntity);
        CFIndex Count = CFArrayGetCount(v14);
        uint64_t v9 = -66557LL;
        if (Count >= 1)
        {
          CFIndex v16 = Count;
          for (CFIndex i = 0LL; v16 != i; ++i)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v14, i);
            uint64_t v19 = _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific(v7, ValueAtIndex, 0LL);
            if (v19 == -66558)
            {
              uint64_t v9 = -66558LL;
            }

            else if (v19 == -66559)
            {
              uint64_t v9 = -66559LL;
              if (!description)
              {
LABEL_15:
                CFRelease(v14);
                goto LABEL_18;
              }

uint64_t _CFNetDiagnosticCopyNetworkStatusPassivelyInterfaceSpecific( const __SCDynamicStore *a1, CFStringRef serviceID, const __CFString **a3)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  uint64_t v6 = -66557LL;
  uint64_t v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity( (CFAllocatorRef)*MEMORY[0x189604DB0],  (CFStringRef)*MEMORY[0x18960C540],  serviceID,  (CFStringRef)*MEMORY[0x18960C598]);
  uint64_t v9 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, NetworkServiceEntity);
  if (!v9) {
    goto LABEL_37;
  }
  CFStringRef v10 = v9;
  SCDynamicStoreRef v11 = (const void *)*MEMORY[0x18960CB48];
  unsigned int Value = CFDictionaryGetValue(v9, (const void *)*MEMORY[0x18960C7A0]);
  int v13 = CFEqual(v11, Value);
  CFNumberRef v14 = CFDictionaryGetValue(v10, (const void *)*MEMORY[0x18960C798]);
  if (v14)
  {
    CFRunLoopSourceContext v15 = v14;
    if (CFEqual(v14, (CFTypeRef)*MEMORY[0x18960CB40])) {
      goto LABEL_11;
    }
    BOOL v16 = CFEqual(v15, (CFTypeRef)*MEMORY[0x18960CB38]) == 0;
  }

  else
  {
    BOOL v16 = 1;
  }

  if (v13) {
    BOOL v17 = !v16;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17)
  {
LABEL_11:
    uint64_t v40 = a3;
    int v18 = (const __CFString *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x18960C790]);
    uint64_t v19 = (const __CFString *)*MEMORY[0x18960C548];
    NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( v7,  (CFStringRef)*MEMORY[0x18960C548],  v18,  (CFStringRef)*MEMORY[0x18960C5A0]);
    CFDataRef v21 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, NetworkInterfaceEntity);
    if (v21)
    {
      int v22 = v21;
      int v23 = (const __CFBoolean *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x18960C7A8]);
      BOOL v24 = (const __CFBoolean *)CFDictionaryGetValue(v22, (const void *)*MEMORY[0x18960C7B0]);
      if (v23)
      {
        LODWORD(v23) = CFBooleanGetValue(v23);
      }

      else if (v24)
      {
        LODWORD(v23) = CFBooleanGetValue(v24) == 0;
      }

      else
      {
        LODWORD(v23) = 1;
      }

      CFRelease(v22);
    }

    else
    {
      LODWORD(v23) = 0;
    }

    CFRelease(NetworkInterfaceEntity);
    a3 = v40;
    goto LABEL_23;
  }

  memset(&context, 0, sizeof(context));
  dnssd_sock_t v25 = SCNetworkConnectionCreateWithServiceID(v7, serviceID, 0LL, &context);
  int v23 = v25;
  if (v25)
  {
    BOOL v26 = (SCNetworkConnectionGetStatus(v25) - 1) < 2;
    __int128 v27 = v23;
    LODWORD(v23) = v26;
    CFRelease(v27);
  }

  uint64_t v19 = (const __CFString *)*MEMORY[0x18960C548];
LABEL_23:
  uint64_t v28 = SCDynamicStoreKeyCreateNetworkServiceEntity(v7, v19, serviceID, (CFStringRef)*MEMORY[0x18960C588]);
  uint64_t v29 = (const __CFDictionary *)SCDynamicStoreCopyValue(a1, v28);
  if (!v29)
  {
    BOOL v37 = 0;
    goto LABEL_33;
  }

  int v30 = v29;
  uint64_t v31 = (const __CFArray *)CFDictionaryGetValue(v29, (const void *)*MEMORY[0x18960C6C0]);
  if (!v31
    || (uint64_t v32 = v31, !CFArrayGetCount(v31))
    || (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v32, 0LL)) == 0LL
    || (int v34 = (int)v23, !CFStringGetCString(ValueAtIndex, (char *)&context, 16LL, 0x600u))
    || (in_addr_t v35 = inet_addr((const char *)&context), v35 == -1))
  {
    CFRelease(v30);
    BOOL v37 = (_DWORD)v23 != 0;
    goto LABEL_33;
  }

  unsigned __int16 v36 = v35;
  CFRelease(v30);
  BOOL v37 = v34 != 0;
  if (v36 != 65193)
  {
LABEL_33:
    uint64_t v38 = -66559LL;
    goto LABEL_34;
  }

  uint64_t v38 = -66558LL;
LABEL_34:
  if (v37) {
    uint64_t v6 = v38;
  }
  CFRelease(v28);
  CFRelease(v10);
LABEL_37:
  CFRelease(NetworkServiceEntity);
  if (a3) {
    *a3 = _CFNetDiagnosticCopyLocalizedDescription(v6);
  }
  return v6;
}

void TrustExceptionManager::~TrustExceptionManager(TrustExceptionManager *this)
{
  *(void *)this = off_189C03570;
  *((void *)this + 2) = off_189C035D0;
  CFRelease(*((CFTypeRef *)this + 3));
  *(void *)this = off_189C19AE8;
}

{
  *(void *)this = off_189C03570;
  *((void *)this + 2) = off_189C035D0;
  CFRelease(*((CFTypeRef *)this + 3));
  operator delete(this);
}

uint64_t RetainableTypedDict<__CFData const*,__CFData const*>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = off_189C035D0;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFData const*,__CFData const*>::~RetainableTypedDict(CFTypeRef *a1)
{
  *a1 = off_189C035D0;
  CFRelease(a1[1]);
  operator delete(a1);
}

CFMutableDictionaryRef ___ZN21TrustExceptionManager27sharedTrustExceptionManagerEv_block_invoke()
{
  uint64_t v0 = operator new(0x20uLL);
  void *v0 = off_189C03570;
  uint64_t v1 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  v0[2] = off_189C035D0;
  CFMutableDictionaryRef result = CFDictionaryCreateMutable(v1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  v0[3] = result;
  *((_DWORD *)v0 + 2) = 0;
  TrustExceptionManager::sharedTrustExceptionManager(void)::singleton = (uint64_t)v0;
  return result;
}

void sub_182A31944(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  operator delete(v1);
  _Unwind_Resume(a1);
}

void TrustExceptionManager::storeTrustExceptions( TrustExceptionManager *this, const __CFData *a2, SecTrustRef trust)
{
  if (a2 && trust)
  {
    if (!TrustExceptionManager::_isSharingdProcess(void)::isSharingd)
    {
      uint64_t v6 = SecTrustCopyExceptions(trust);
      if (v6)
      {
        uint64_t v7 = v6;
        CFDataRef Copy = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v6);
        if (Copy)
        {
          os_unfair_lock_lock((os_unfair_lock_t)this + 2);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 3), a2, Copy);
          CFRelease(Copy);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 2);
        }

        CFRelease(v7);
      }
    }
  }

void sub_182A31A44(_Unwind_Exception *a1)
{
}

uint64_t ___ZN21TrustExceptionManager18_isSharingdProcessEv_block_invoke()
{
  uint64_t v0 = (const char **)_CFGetProgname();
  uint64_t result = strcmp(*v0, "sharingd");
  TrustExceptionManager::_isSharingdProcess(void)::isSharingd = (_DWORD)result == 0;
  return result;
}

CFTypeID CFHostGetTypeID(void)
{
  return *(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96);
}

CFHostRef CFHostCreateCopy(CFAllocatorRef alloc, CFHostRef host)
{
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  CFNetDiagnosticStatus v4 = (HostBase *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    CFNetDiagnosticStatus v4 = (HostBase *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  if (host)
  {
    __int128 v5 = (CFHostRef)((char *)host + 16);
  }

  else
  {
    __int128 v5 = 0LL;
  }

  HostBase::HostBase(v4, v5);
  *(void *)CFNetDiagnosticStatus v4 = &off_189C15B78;
  *((void *)v4 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C15BE8;
  *((void *)v4 + 1_Block_object_dispose((const void *)(v31 - 192), 8) = copyHostQueue();
  *((void *)v4 + 19) = dispatch_group_create();
  return (HostBase *)((char *)v4 - 16);
}

void sub_182A31BC0(_Unwind_Exception *a1)
{
}

CFHostRef CFHostCreateWithName(CFAllocatorRef allocator, CFStringRef hostname)
{
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  __int128 v5 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    __int128 v5 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  Array = cfTypeCreateArray(allocator, hostname, 0LL, 0LL, 0LL);
  DispatchHost::DispatchHost(v5, (const __CFString *)&unk_18C5B1730, Array, 0LL);
  if (Array) {
    CFRelease(Array);
  }
  if (v5) {
    return (DispatchHost *)((char *)v5 - 16);
  }
  uint64_t v7 = (_OWORD *)_CFRuntimeCreateInstance();
  __int128 v5 = (DispatchHost *)v7;
  if (v7)
  {
    v7[1] = 0u;
    __int128 v5 = (DispatchHost *)(v7 + 1);
    v7[8] = 0u;
    v7[9] = 0u;
    v7[6] = 0u;
    void v7[7] = 0u;
    v7[4] = 0u;
    v7[5] = 0u;
    v7[2] = 0u;
    v7[3] = 0u;
  }

  CFRunLoopSourceRef v8 = cfTypeCreateArray(allocator, hostname, 0LL, 0LL, 0LL);
  Host::Host(v5, (const __CFString *)&unk_18C5B1730, v8, 0LL);
  if (v8) {
    CFRelease(v8);
  }
  if (v5) {
    return (DispatchHost *)((char *)v5 - 16);
  }
  else {
    return 0LL;
  }
}

void sub_182A31D60(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

CFHostRef CFHostCreateWithAddress(CFAllocatorRef allocator, CFDataRef addr)
{
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  __int128 v5 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    __int128 v5 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  Array = cfTypeCreateArray(allocator, addr, 0LL, 0LL, 0LL);
  DispatchHost::DispatchHost(v5, (const __CFString *)&unk_18C5B16F8, Array, 0LL);
  if (Array) {
    CFRelease(Array);
  }
  if (v5) {
    return (DispatchHost *)((char *)v5 - 16);
  }
  uint64_t v7 = (_OWORD *)_CFRuntimeCreateInstance();
  __int128 v5 = (DispatchHost *)v7;
  if (v7)
  {
    v7[1] = 0u;
    __int128 v5 = (DispatchHost *)(v7 + 1);
    v7[8] = 0u;
    v7[9] = 0u;
    v7[6] = 0u;
    void v7[7] = 0u;
    v7[4] = 0u;
    v7[5] = 0u;
    v7[2] = 0u;
    v7[3] = 0u;
  }

  CFRunLoopSourceRef v8 = cfTypeCreateArray(allocator, addr, 0LL, 0LL, 0LL);
  Host::Host(v5, (const __CFString *)&unk_18C5B16F8, v8, 0LL);
  if (v8) {
    CFRelease(v8);
  }
  if (v5) {
    return (DispatchHost *)((char *)v5 - 16);
  }
  else {
    return 0LL;
  }
}

void sub_182A31F08(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CFHostCreateWithNameAndPortForConnect( const __CFAllocator *a1, const __CFString *a2, const __CFAllocator *a3)
{
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v7 = (DispatchHost *)Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v7 = (DispatchHost *)(Instance + 1);
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  Array = cfTypeCreateArray(a1, a2, 0LL, 0LL, 0LL);
  AutoScalar::AutoScalar((AutoScalar *)&v10, a3);
  DispatchHost::DispatchHost(v7, (const __CFString *)&unk_18C5B1730, Array, 0x18C5B15E0LL, cf, 0LL);
  CFStringRef v10 = off_189C04A90;
  if (cf) {
    CFRelease(cf);
  }
  if (Array) {
    CFRelease(Array);
  }
  if (v7) {
    return (uint64_t)v7 - 16;
  }
  else {
    return 0LL;
  }
}

void sub_182A32040( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  if (v14) {
    CFRelease(v14);
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef CFHostGetInfo(uint64_t a1, int a2, BOOL *a3)
{
  __int128 v5 = (const void *)infoToString(a2);
  if (a1) {
    uint64_t v6 = a1 + 16;
  }
  else {
    uint64_t v6 = 0LL;
  }
  CFRetain((CFTypeRef)(v6 - 16));
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 32));
  ++*(void *)(v6 + 16);
  unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 96), v5);
  if (Value) {
    CFTypeRef v8 = CFRetain(Value);
  }
  else {
    CFTypeRef v8 = 0LL;
  }
  HostBase::unlock((HostBase *)v6);
  if (a3) {
    *a3 = v8 != 0LL;
  }
  if (v8)
  {
    if (v8 == (CFTypeRef)*MEMORY[0x189605018]
      || (CFTypeID v9 = CFGetTypeID(v8), v9 == CFErrorGetTypeID())
      || v8 == (CFTypeRef)*MEMORY[0x189604DE0])
    {
      CFRelease(v8);
      return 0LL;
    }

    else
    {
      CFRetain((CFTypeRef)(v6 - 16));
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 32));
      ++*(void *)(v6 + 16);
      CFMutableArrayRef Mutable = *(__CFDictionary **)(v6 + 128);
      if (!Mutable)
      {
        SCDynamicStoreRef v11 = CFGetAllocator((CFTypeRef)(v6 - 16));
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v11, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
        *(void *)(v6 + 12_Block_object_dispose((const void *)(v31 - 192), 8) = Mutable;
      }

      CFDictionarySetValue(Mutable, v5, v8);
      CFRelease(v8);
      HostBase::unlock((HostBase *)v6);
    }
  }

  return v8;
}

uint64_t infoToString(int a1)
{
  switch(a1)
  {
    case -1:
      uint64_t v1 = &_kCFNullHostInfoTypeString;
      goto LABEL_13;
    case 0:
      uint64_t v1 = &kCFHostAddressesString;
      goto LABEL_13;
    case 1:
      uint64_t v1 = &kCFHostNamesString;
      goto LABEL_13;
    case 2:
      uint64_t v1 = &kCFHostReachabilityString;
LABEL_13:
      uint64_t result = *v1;
      break;
    default:
      switch(a1)
      {
        case 65531:
          uint64_t v1 = &_kCFHostByPassMasterAddressLookupString;
          goto LABEL_13;
        case 65532:
          uint64_t v1 = &_kCFHostMasterAddressLookupString;
          goto LABEL_13;
        case 65533:
          uint64_t v1 = &_kCFHostIPv6AddressesString;
          goto LABEL_13;
        case 65534:
          uint64_t v1 = &_kCFHostIPv4AddressesString;
          goto LABEL_13;
        default:
          uint64_t result = 0LL;
          break;
      }

      break;
  }

  return result;
}

Boolean CFHostSetClient(CFHostRef theHost, CFHostClientCallBack clientCB, CFHostClientContext *clientContext)
{
  if (theHost) {
    uint64_t v6 = (CFHostRef)((char *)theHost + 16);
  }
  else {
    uint64_t v6 = 0LL;
  }
  CFTypeRef v8 = CFGetAllocator((char *)v6 - 16);
  CFTypeID v9 = (StubHostDelegate *)MEMORY[0x186E12804](v8, 96LL, 0LL);
  *(_OWORD *)CFTypeID v9 = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  uint64_t v10 = (uint64_t)v9 + 16;
  StubHostDelegate::StubHostDelegate(v9, v8, clientContext);
  *SCDynamicStoreRef v11 = off_189C15DB0;
  *(void *)uint64_t v10 = &unk_189C15DE8;
  v11[11] = clientCB;
  Boolean v12 = HostBase::setDelegate(v6, v10);
  (*(void (**)(uint64_t))(*(void *)v10 + 32LL))(v10);
  return v12;
}

uint64_t _CFHostSetClientInfoCallback(__CFHost *a1, unint64_t a2, CFHostClientContext *a3)
{
  if (a1) {
    uint64_t v6 = (__CFHost *)((char *)a1 + 16);
  }
  else {
    uint64_t v6 = 0LL;
  }
  CFTypeRef v8 = CFGetAllocator((char *)v6 - 16);
  CFTypeID v9 = (StubHostDelegate *)MEMORY[0x186E12804](v8, 96LL, 0LL);
  *(_OWORD *)CFTypeID v9 = 0u;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  uint64_t v10 = (uint64_t)v9 + 16;
  StubHostDelegate::StubHostDelegate(v9, v8, a3);
  *SCDynamicStoreRef v11 = off_189C15E88;
  *(void *)uint64_t v10 = &unk_189C15EC0;
  v11[11] = a2;
  uint64_t v12 = HostBase::setDelegate(v6, v10);
  (*(void (**)(uint64_t))(*(void *)v10 + 32LL))(v10);
  return v12;
}

CFArrayRef CFHostGetAddressing(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFArrayRef)CFHostGetInfo((uint64_t)theHost, 0, (BOOL *)hasBeenResolved);
}

CFArrayRef CFHostGetNames(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFArrayRef)CFHostGetInfo((uint64_t)theHost, 1, (BOOL *)hasBeenResolved);
}

CFDataRef CFHostGetReachability(CFHostRef theHost, Boolean *hasBeenResolved)
{
  return (CFDataRef)CFHostGetInfo((uint64_t)theHost, 2, (BOOL *)hasBeenResolved);
}

Boolean CFHostStartInfoResolution(CFHostRef theHost, CFHostInfoType info, CFStreamError *error)
{
  if (theHost) {
    uint64_t v6 = (char *)theHost + 16;
  }
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t v7 = infoToString(info);
  CFTypeRef v8 = (__CFError *)(*(uint64_t (**)(char *, uint64_t, void, void))(*(void *)v6 + 56LL))( v6,  v7,  0LL,  0LL);
  if (v8)
  {
    CFTypeID v9 = v8;
    if (error)
    {
      error->domain = _CFStreamErrorFromCFError(v8);
      *(void *)&error->CFErrorRef error = v10;
    }

    CFRelease(v9);
    return 0;
  }

  else
  {
    if (error)
    {
      error->CFErrorRef error = 0;
      error->domain = 0LL;
    }

    return 1;
  }

uint64_t _CFHostStartInfoResolutionForInterface(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1) {
    uint64_t v6 = a1 + 16;
  }
  else {
    uint64_t v6 = 0LL;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v6 + 56LL))(v6, a2, a3, 0LL);
}

void CFHostCancelInfoResolution(CFHostRef theHost, CFHostInfoType info)
{
  if (theHost) {
    CFNetDiagnosticStatus v4 = (char *)theHost + 16;
  }
  else {
    CFNetDiagnosticStatus v4 = 0LL;
  }
  uint64_t v5 = infoToString(info);
  (*(void (**)(char *, uint64_t))(*(void *)v4 + 64LL))(v4, v5);
}

void CFHostScheduleWithRunLoop(CFHostRef theHost, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  if (theHost) {
    uint64_t v6 = (char *)theHost + 16;
  }
  else {
    uint64_t v6 = 0LL;
  }
  (*(void (**)(char *, CFRunLoopRef, CFStringRef))(*(void *)v6 + 72LL))(v6, runLoop, runLoopMode);
}

void CFHostUnscheduleFromRunLoop(CFHostRef theHost, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
  if (theHost) {
    uint64_t v6 = (char *)theHost + 16;
  }
  else {
    uint64_t v6 = 0LL;
  }
  (*(void (**)(char *, CFRunLoopRef, CFStringRef))(*(void *)v6 + 80LL))(v6, runLoop, runLoopMode);
}

BOOL CFNetDiagnosticPingWithOptions(const __CFString *a1, const __CFDictionary *a2, CFErrorRef *a3)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  bzero(buffer, 0x400uLL);
  if (!a1 || !CFStringGetLength(a1) || !CFStringGetCString(a1, buffer, 1024LL, 0x8000100u))
  {
    BOOL v11 = 0;
    int v12 = 22;
    goto LABEL_7;
  }

  *(_DWORD *)&__dst[8] = 0;
  *(void *)__dst = inet_addr(buffer);
  if (*(_DWORD *)__dst == -1)
  {
    BOOL v16 = gethostbyname(buffer);
    if (!v16)
    {
      BOOL v11 = 0;
      int v12 = 65;
      goto LABEL_7;
    }

    int h_addrtype = v16->h_addrtype;
    memcpy(__dst, *(const void **)v16->h_addr_list, v16->h_length);
    int v10 = h_addrtype << 8;
  }

  else
  {
    int v10 = 512;
  }

  int v52 = v10;
  int valuePtr = 10;
  unsigned int Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionTimeout");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  }
  int v56 = 0;
  uint64_t v19 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionTypeOfService");
  if (v19) {
    CFNumberGetValue(v19, kCFNumberIntType, &v56);
  }
  int v57 = 0;
  double v20 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionTrafficClass");
  if (v20) {
    CFNumberGetValue(v20, kCFNumberIntType, &v57);
  }
  int v55 = 1;
  CFDataRef v21 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionPacketCount");
  if (v21) {
    CFNumberGetValue(v21, kCFNumberIntType, &v55);
  }
  int v58 = 0;
  int v22 = (const __CFNumber *)CFDictionaryGetValue(a2, @"kCFNetDiagnosticPingOptionDataLength");
  if (v22) {
    CFNumberGetValue(v22, kCFNumberIntType, &v58);
  }
  LODWORD(v61.tv_sec) = 51200;
  int v23 = getprotobyname("icmp");
  if (!v23)
  {
    int v12 = 46;
LABEL_37:
    BOOL v11 = 0;
    goto LABEL_7;
  }

  int v24 = socket(2, 2, v23->p_proto);
  int v25 = v24;
  if (v24 < 0)
  {
    int v12 = 1;
    goto LABEL_37;
  }

  setsockopt(v24, 0xFFFF, 4098, &v61, 4u);
  *(void *)&v64.sa_len = 1LL;
  *(_DWORD *)&v64.sa_data[6] = 0;
  if (setsockopt(v25, 0xFFFF, 4102, &v64, 0x10u))
  {
    close(v25);
    int v12 = *__error();
  }

  else
  {
    int v12 = 0;
  }

  BOOL v11 = 0;
  if (v12 || v55 < 1) {
    goto LABEL_110;
  }
  unsigned int v26 = 0;
  BOOL v11 = 0;
  int v51 = *(_DWORD *)__dst;
  uint64_t v50 = *(void *)&__dst[4];
  while (1)
  {
    int v27 = v57;
    int v28 = v58;
    int v29 = v56;
    *(_DWORD *)&v64.sa_len = v52;
    *(_DWORD *)&v64.sa_data[2] = v51;
    *(void *)&v64.sa_data[6] = v50;
    size_t v30 = v58 + 48LL;
    uint64_t v31 = (unsigned __int16 *)calloc(1uLL, v30);
    uint64_t v32 = v31;
    if (!v31)
    {
      int v12 = 12;
      break;
    }

    *uint64_t v31 = 8;
    v31[3] = bswap32(v26) >> 16;
    _OWORD v31[2] = bswap32(getpid()) >> 16;
    if (!gettimeofday((timeval *)v32 + 2, 0LL))
    {
      uint64_t v49 = v28;
      if (v28 >= 1)
      {
        unsigned int v33 = v32 + 24;
        uint64_t v34 = v49;
        do
        {
          *v33++ = random();
          --v34;
        }

        while (v34);
      }

      if (!v27) {
        goto LABEL_56;
      }
      LODWORD(v61.tv_sec) = v27;
      if (!setsockopt(v25, 0xFFFF, 4230, &v61, 4u)) {
        goto LABEL_56;
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      in_addr_t v35 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)&v65.sa_len = 0;
        _os_log_error_impl( &dword_18298D000,  v35,  OS_LOG_TYPE_ERROR,  "setsockopt SO_TRAFFIC_CLASS failed",  &v65.sa_len,  2u);
        if (!v29) {
          goto LABEL_62;
        }
      }

      else
      {
LABEL_56:
        if (!v29) {
          goto LABEL_62;
        }
      }

      LODWORD(v61.tv_sec) = v29;
      if (setsockopt(v25, 0, 3, &v61, 4u))
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        unsigned __int16 v36 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)&v65.sa_len = 0;
          _os_log_error_impl(&dword_18298D000, v36, OS_LOG_TYPE_ERROR, "setsockopt IP_TOS failed", &v65.sa_len, 2u);
        }
      }

LABEL_110:
  close(v25);
LABEL_7:
  if (a3)
  {
    if (v12)
    {
      CFErrorRef CFError = __cfnCreateCFError(0LL, (CFErrorDomain)*MEMORY[0x189604F58], v12, v5, v6, v7, v8, v9, 0LL);
      goto LABEL_10;
    }

    if (!v11)
    {
      CFErrorRef CFError = __cfnCreateCFError(0LL, (CFErrorDomain)*MEMORY[0x189604F58], 60LL, v5, v6, v7, v8, v9, 0LL);
LABEL_10:
      *a3 = CFError;
    }
  }

  if (v12) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = !v11;
  }
  return !v14;
}

BOOL CFNetDiagnosticPing(const __CFString *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v11 = a3;
  uint64_t valuePtr = a2;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFNumberRef v7 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
  CFNumberRef v8 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v11);
  CFDictionarySetValue(Mutable, @"kCFNetDiagnosticPingOptionPacketCount", v7);
  CFDictionarySetValue(Mutable, @"kCFNetDiagnosticPingOptionTimeout", v8);
  BOOL v9 = CFNetDiagnosticPingWithOptions(a1, Mutable, a4);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(Mutable);
  return v9;
}

CFStringRef _CFNetworkCopyDefaultUserAgentString()
{
  uint64_t v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  pthread_once(&initControl, initializeUserAgentString);
  return CFStringCreateCopy(v0, (CFStringRef)sUserAgentString);
}

CFStringRef copyMIMETypeForExtension(CFStringRef inTag)
{
  uint64_t result = UTTypeCreatePreferredIdentifierForTag( (CFStringRef)*MEMORY[0x1896057A0],  inTag,  (CFStringRef)*MEMORY[0x1896057B0]);
  if (result)
  {
    uint64_t v2 = result;
    CFStringRef v3 = UTTypeCopyPreferredTagWithClass(result, (CFStringRef)*MEMORY[0x1896057A8]);
    CFRelease(v2);
    return v3;
  }

  return result;
}

CFStringRef copyPreferredExtensionForMIMEType(CFStringRef inTag)
{
  uint64_t result = UTTypeCreatePreferredIdentifierForTag( (CFStringRef)*MEMORY[0x1896057A8],  inTag,  (CFStringRef)*MEMORY[0x1896057B0]);
  if (result)
  {
    uint64_t v2 = result;
    CFStringRef v3 = UTTypeCopyPreferredTagWithClass(result, (CFStringRef)*MEMORY[0x1896057A0]);
    CFRelease(v2);
    return v3;
  }

  return result;
}

CFStringRef createSanitizedFileNameFromString(const __CFString *cf)
{
  if (!createSanitizedFileNameFromString::charsToReplaceWithADash) {
    createSanitizedFileNameFromString::charsToReplaceWithADash = (uint64_t)CFCharacterSetCreateWithCharactersInString( (CFAllocatorRef)*MEMORY[0x189604DB0],  @":/");
  }
  uint64_t v2 = CFGetAllocator(cf);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0LL);
  if (!Mutable) {
    return 0LL;
  }
  CFNetDiagnosticStatus v4 = Mutable;
  CFIndex Length = CFStringGetLength(cf);
  CFStringRef v26 = cf;
  uint64_t v29 = 0LL;
  CFIndex v30 = Length;
  CharactersPtr = CFStringGetCharactersPtr(cf);
  CStringPtr = 0LL;
  int v27 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(cf, 0x600u);
  }
  int v28 = CStringPtr;
  int64_t v31 = 0LL;
  int64_t v32 = 0LL;
  if (Length >= 1)
  {
    uint64_t v8 = 0LL;
    int v9 = 0;
    int64_t v10 = 0LL;
    uint64_t v11 = 64LL;
    do
    {
      else {
        uint64_t v12 = v10;
      }
      CFIndex v13 = v30;
      if (v30 <= v10)
      {
        UniChar chars = 0;
      }

      else
      {
        if (v27)
        {
          UniChar v14 = v27[v10 + v29];
        }

        else if (v28)
        {
          UniChar v14 = v28[v29 + v10];
        }

        else
        {
          int64_t v15 = v31;
          if (v32 <= v10 || v31 > v10)
          {
            uint64_t v17 = v12 + v8;
            uint64_t v18 = v11 - v12;
            int64_t v19 = v10 - v12;
            CFIndex v20 = v19 + 64;
            if (v19 + 64 >= v30) {
              CFIndex v20 = v30;
            }
            int64_t v31 = v19;
            int64_t v32 = v20;
            if (v30 >= v18) {
              CFIndex v13 = v18;
            }
            v33.length = v13 + v17;
            v33.CFIndex location = v19 + v29;
            CFStringGetCharacters(v26, v33, buffer);
            int64_t v15 = v31;
          }

          UniChar v14 = buffer[v10 - v15];
        }

        UniChar chars = v14;
        if (v14)
        {
          if (v9 || v14 != 46)
          {
            if (CFCharacterSetIsCharacterMember( (CFCharacterSetRef)createSanitizedFileNameFromString::charsToReplaceWithADash,  v14))
            {
              CFStringAppend(v4, @"_");
              int v9 = 1;
            }

            else
            {
              int v9 = 1;
              CFStringAppendCharacters(v4, &chars, 1LL);
            }
          }

          else
          {
            int v9 = 0;
          }
        }
      }

      ++v10;
      --v8;
      ++v11;
    }

    while (Length != v10);
  }

  if (CFStringGetLength(v4))
  {
    CFDataRef v21 = CFGetAllocator(cf);
    CFStringRef Copy = CFStringCreateCopy(v21, v4);
  }

  else
  {
    CFStringRef Copy = 0LL;
  }

  CFRelease(v4);
  return Copy;
}

CFStringRef createFilenameFromContentDispositionHeader(const __CFString *a1)
{
  uint64_t v1 = a1;
  CFIndex Length = CFStringGetLength(a1);
  buffer.CFStringRef theString = v1;
  buffer.rangeToBuffer.CFIndex location = 0LL;
  buffer.rangeToBuffer.length = Length;
  CharactersPtr = CFStringGetCharactersPtr(v1);
  CStringPtr = 0LL;
  buffer.directUniCharBuffer = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v1, 0x600u);
  }
  buffer.CFIndex bufferedRangeStart = 0LL;
  buffer.bufferedRangeEnd = 0LL;
  buffer.directCStringBuffer = CStringPtr;
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  uint64_t v6 = 0LL;
  int64_t v7 = 0LL;
  CFIndex v8 = Length - 1;
  if (Length <= 1) {
    uint64_t v9 = 1LL;
  }
  else {
    uint64_t v9 = Length;
  }
  for (uint64_t i = 64LL; ; ++i)
  {
    uint64_t v11 = (unint64_t)v7 >= 4 ? 4LL : v7;
    CFIndex v12 = buffer.rangeToBuffer.length;
    if (buffer.rangeToBuffer.length <= v7)
    {
      UniChar v13 = 0;
    }

    else if (buffer.directUniCharBuffer)
    {
      UniChar v13 = buffer.directUniCharBuffer[v7 + buffer.rangeToBuffer.location];
    }

    else if (buffer.directCStringBuffer)
    {
      UniChar v13 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
    }

    else
    {
      CFIndex bufferedRangeStart = buffer.bufferedRangeStart;
      BOOL v15 = buffer.bufferedRangeEnd > v7 && buffer.bufferedRangeStart <= v7;
      if (!v15)
      {
        uint64_t v16 = v11 + v6;
        CFIndex v17 = i - v11;
        CFIndex v18 = v7 - v11;
        CFIndex v19 = v18 + 64;
        if (v18 + 64 >= buffer.rangeToBuffer.length) {
          CFIndex v19 = buffer.rangeToBuffer.length;
        }
        buffer.CFIndex bufferedRangeStart = v18;
        buffer.bufferedRangeEnd = v19;
        if (buffer.rangeToBuffer.length >= v17) {
          CFIndex v12 = v17;
        }
        v237.length = v12 + v16;
        v237.CFIndex location = v18 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v237, buffer.buffer);
        CFIndex bufferedRangeStart = buffer.bufferedRangeStart;
      }

      UniChar v13 = buffer.buffer[v7 - bufferedRangeStart];
    }

    if (!CFCharacterSetIsCharacterMember(Predefined, v13)) {
      break;
    }
    ++v7;
    --v6;
    if (v9 == v7) {
      return 0LL;
    }
  }

  if (Length - v7 < 9) {
    return 0LL;
  }
  CFStringRef v20 = 0LL;
  uint64_t v21 = 0x18C5B0AF0LL;
  int v22 = &buffer.buffer[1];
  CFIndex v23 = 1 - Length;
LABEL_31:
  v253.CFIndex location = v7;
  v253.length = 8LL;
  if (!CFStringFindWithOptions(v1, @"filename", v253, 9uLL, &result)) {
    goto LABEL_236;
  }
  int64_t v7 = result.length + result.location;
  if (result.length + result.location >= Length) {
    goto LABEL_413;
  }
  if (v7 < 0) {
    goto LABEL_43;
  }
  CFIndex v24 = buffer.rangeToBuffer.length;
  if (buffer.rangeToBuffer.length <= v7) {
    goto LABEL_43;
  }
  directUniCharBuffer = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    CFIndex v26 = buffer.rangeToBuffer.location + v7;
LABEL_37:
    UniChar v27 = directUniCharBuffer->buffer[v26];
    goto LABEL_40;
  }

  if (!buffer.directCStringBuffer)
  {
    if (buffer.bufferedRangeEnd <= v7 || (CFIndex v66 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      CFIndex v67 = v7 - 4;
      if (v67 + 64 < buffer.rangeToBuffer.length) {
        CFIndex v24 = v67 + 64;
      }
      buffer.CFIndex bufferedRangeStart = v67;
      buffer.bufferedRangeEnd = v24;
      v240.CFIndex location = buffer.rangeToBuffer.location + v67;
      v240.length = v24 - v67;
      CFStringGetCharacters(buffer.theString, v240, buffer.buffer);
      CFIndex v66 = buffer.bufferedRangeStart;
    }

    CFIndex v26 = v7 - v66;
    directUniCharBuffer = &buffer;
    goto LABEL_37;
  }

  UniChar v27 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
LABEL_40:
  if (v27 != 42)
  {
LABEL_43:
    if (v20) {
      goto LABEL_236;
    }
    CFCharacterSetRef theSet = 0LL;
    CFIndex v232 = v23;
    CFIndex v227 = v8;
    v228 = (const __CFString *)v21;
    int v28 = v22;
    char v29 = 0;
    goto LABEL_45;
  }

  if (++v7 >= Length) {
    goto LABEL_413;
  }
  CFCharacterSetRef theSet = (CFCharacterSetRef)v20;
  CFIndex v232 = v23;
  CFIndex v227 = v8;
  v228 = (const __CFString *)v21;
  int v28 = v22;
  char v29 = 1;
LABEL_45:
  int64_t v30 = -v7;
  int64_t v31 = v7 + 64;
  do
  {
    else {
      uint64_t v32 = v7;
    }
    if (v7 < 0 || (CFIndex v33 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
    {
      UniChar v34 = 0;
    }

    else if (buffer.directUniCharBuffer)
    {
      UniChar v34 = buffer.directUniCharBuffer[v7 + buffer.rangeToBuffer.location];
    }

    else if (buffer.directCStringBuffer)
    {
      UniChar v34 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
    }

    else
    {
      if (buffer.bufferedRangeEnd <= v7 || (CFIndex v36 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
      {
        uint64_t v37 = v32 + v30;
        CFIndex v38 = v31 - v32;
        CFIndex v39 = v7 - v32;
        CFIndex v40 = v39 + 64;
        if (v39 + 64 >= buffer.rangeToBuffer.length) {
          CFIndex v40 = buffer.rangeToBuffer.length;
        }
        buffer.CFIndex bufferedRangeStart = v39;
        buffer.bufferedRangeEnd = v40;
        if (buffer.rangeToBuffer.length >= v38) {
          CFIndex v33 = v38;
        }
        v238.length = v33 + v37;
        v238.CFIndex location = v39 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v238, buffer.buffer);
        CFIndex v36 = buffer.bufferedRangeStart;
      }

      UniChar v34 = buffer.buffer[v7 - v36];
    }

    int v35 = v34;
    if (!CFCharacterSetIsCharacterMember(Predefined, v34)) {
      break;
    }
    ++v7;
    --v30;
    ++v31;
  }

  while (v7 < Length);
  if (v35 != 61)
  {
    int v22 = v28;
    CFIndex v8 = v227;
    uint64_t v21 = (uint64_t)v228;
LABEL_92:
    CFStringRef v20 = (CFStringRef)theSet;
    CFIndex v23 = v232;
    goto LABEL_236;
  }

  unint64_t v41 = v7 + 1;
  if (v7 + 1 >= Length)
  {
LABEL_417:
    CFStringRef v20 = (CFStringRef)theSet;
    goto LABEL_413;
  }

  int v22 = v28;
  int64_t v42 = ~v7;
  int64_t v43 = v7 + 65;
  CFIndex v8 = v227;
  while (1)
  {
    CFIndex v44 = v7 + 1;
    uint64_t v45 = v41 >= 4 ? 4LL : v41;
    if (v44 < 0 || (CFIndex v46 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v44))
    {
      UniChar v47 = 0;
    }

    else if (buffer.directUniCharBuffer)
    {
      UniChar v47 = buffer.directUniCharBuffer[v7 + 1 + buffer.rangeToBuffer.location];
    }

    else if (buffer.directCStringBuffer)
    {
      UniChar v47 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7];
    }

    else
    {
      if (buffer.bufferedRangeEnd <= v44 || (CFIndex v48 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v44))
      {
        uint64_t v49 = v45 + v42;
        CFIndex v50 = v43 - v45;
        int64_t v51 = v7 - v45;
        CFIndex v52 = v51 + 1;
        CFIndex v53 = v51 + 65;
        if (v53 >= buffer.rangeToBuffer.length) {
          CFIndex v53 = buffer.rangeToBuffer.length;
        }
        buffer.CFIndex bufferedRangeStart = v52;
        buffer.bufferedRangeEnd = v53;
        if (buffer.rangeToBuffer.length >= v50) {
          CFIndex v46 = v50;
        }
        v239.length = v46 + v49;
        v239.CFIndex location = v52 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v239, buffer.buffer);
        CFIndex v48 = buffer.bufferedRangeStart;
      }

      UniChar v47 = v22[v7 - v48];
    }

    if (!CFCharacterSetIsCharacterMember(Predefined, v47)) {
      break;
    }
    ++v41;
    ++v7;
    --v42;
    ++v43;
    if (v227 == v7)
    {
      int64_t v7 = Length;
      goto LABEL_94;
    }
  }

  ++v7;
LABEL_94:
  uint64_t v54 = 0x18C5B10A0LL;
  CFStringRef v20 = (CFStringRef)theSet;
  CFIndex v23 = v232;
  if ((v29 & 1) == 0)
  {
    if (theSet)
    {
      BOOL v61 = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT);
      uint64_t v54 = 0x18C5B10A0LL;
      if (v61)
      {
        LOWORD(v236.location) = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "filename should be NULL",  (uint8_t *)&v236,  2u);
        uint64_t v54 = 0x18C5B10A0LL;
      }
    }

    if (Length <= v7) {
      goto LABEL_413;
    }
    uint64_t v21 = (uint64_t)v228;
    if ((v7 & 0x8000000000000000LL) == 0)
    {
      CFIndex v62 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > v7)
      {
        p_CFStringInlineBuffer buffer = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
        if (buffer.directUniCharBuffer)
        {
          CFIndex v64 = buffer.rangeToBuffer.location + v7;
          goto LABEL_114;
        }

        if (buffer.directCStringBuffer)
        {
          UniChar v65 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
        }

        else
        {
          if (buffer.bufferedRangeEnd <= v7 || (CFIndex v104 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
          {
            CFIndex v105 = v7 - 4;
            if (v105 + 64 < buffer.rangeToBuffer.length) {
              CFIndex v62 = v105 + 64;
            }
            buffer.CFIndex bufferedRangeStart = v105;
            buffer.bufferedRangeEnd = v62;
            v243.CFIndex location = buffer.rangeToBuffer.location + v105;
            v243.length = v62 - v105;
            CFStringGetCharacters(buffer.theString, v243, buffer.buffer);
            uint64_t v54 = 0x18C5B10A0LL;
            uint64_t v21 = (uint64_t)v228;
            CFIndex v104 = buffer.bufferedRangeStart;
          }

          CFIndex v64 = v7 - v104;
          p_CFStringInlineBuffer buffer = &buffer;
LABEL_114:
          UniChar v65 = p_buffer->buffer[v64];
        }

        if (v65 == 59 || v65 == 44) {
          goto LABEL_236;
        }
        if (v65 == 34)
        {
          v222 = v22;
          int64_t v70 = v7 + 1;
          if (v7 + 1 >= Length) {
            goto LABEL_413;
          }
          CFIndex v71 = buffer.rangeToBuffer.length;
          if (buffer.rangeToBuffer.length <= v70)
          {
            UniChar v72 = 0;
          }

          else
          {
            if (buffer.directUniCharBuffer)
            {
              UniChar v72 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v70];
            }

            else if (buffer.directCStringBuffer)
            {
              UniChar v72 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v70];
            }

            else
            {
              if (buffer.bufferedRangeEnd <= v70 || (CFIndex v175 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v70))
              {
                CFIndex v176 = v7 - 3;
                if (v176 + 64 < buffer.rangeToBuffer.length) {
                  CFIndex v71 = v176 + 64;
                }
                buffer.CFIndex bufferedRangeStart = v176;
                buffer.bufferedRangeEnd = v71;
                v250.CFIndex location = buffer.rangeToBuffer.location + v176;
                v250.length = v71 - v176;
                CFStringGetCharacters(buffer.theString, v250, buffer.buffer);
                int64_t v70 = v7 + 1;
                CFIndex v175 = buffer.bufferedRangeStart;
              }

              UniChar v72 = buffer.buffer[v70 - v175];
              uint64_t v54 = 0x18C5B10A0LL;
              uint64_t v21 = (uint64_t)v228;
            }

            if (v72 == 34)
            {
              uint64_t v87 = v7 + 2;
              goto LABEL_366;
            }
          }

          int v177 = 0;
          int64_t v178 = v70;
          while (1)
          {
            if (v72 == 92)
            {
              int v177 = 1;
              uint64_t v179 = 2LL;
            }

            else
            {
              if (v72 == 34)
              {
                CFIndex v185 = v178 - v70;
                CFIndex v186 = v70;
                v187 = CFGetAllocator(v1);
                v257.CFIndex location = v186;
                v257.length = v185;
                v188 = (__CFString *)CFStringCreateWithSubstring(v187, v1, v257);
                v189 = v188;
                if (v177 && v188 && (CFMutableStringRef v190 = cdReplaceQuotedPairs(v188)) != 0LL)
                {
                  CFStringRef v20 = v190;
                  CFRelease(v189);
                }

                else
                {
                  CFStringRef v20 = v189;
                }

                uint64_t v87 = v178 + 1;
LABEL_366:
                int v22 = v222;
LABEL_188:
                int64_t v7 = v87;
                if (v87 >= Length) {
                  goto LABEL_413;
                }
                goto LABEL_236;
              }

              uint64_t v179 = 1LL;
            }

            v178 += v179;
            if (v178 >= Length) {
              goto LABEL_413;
            }
            UniChar v72 = 0;
            if ((v178 & 0x8000000000000000LL) == 0)
            {
              UniChar v72 = 0;
              CFIndex v180 = buffer.rangeToBuffer.length;
              if (buffer.rangeToBuffer.length > v178)
              {
                if (buffer.directUniCharBuffer)
                {
                  UniChar v72 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v178];
                }

                else if (buffer.directCStringBuffer)
                {
                  UniChar v72 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v178];
                }

                else
                {
                  if (buffer.bufferedRangeEnd <= v178
                    || (CFIndex v181 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v178))
                  {
                    CFIndex v182 = v178 - 4;
                    if (v182 + 64 < buffer.rangeToBuffer.length) {
                      CFIndex v180 = v182 + 64;
                    }
                    buffer.CFIndex bufferedRangeStart = v182;
                    buffer.bufferedRangeEnd = v180;
                    uint64_t v183 = v54;
                    v251.CFIndex location = buffer.rangeToBuffer.location + v182;
                    int64_t v184 = v70;
                    v251.length = v180 - v182;
                    CFStringGetCharacters(buffer.theString, v251, buffer.buffer);
                    int64_t v70 = v184;
                    uint64_t v54 = v183;
                    uint64_t v21 = (uint64_t)v228;
                    CFIndex v181 = buffer.bufferedRangeStart;
                  }

                  UniChar v72 = buffer.buffer[v178 - v181];
                }
              }
            }
          }
        }
      }
    }

    v223 = v22;
    unint64_t v73 = v7 + 1;
    if (v7 + 1 >= Length) {
      goto LABEL_413;
    }
    CFStringRef v229 = (CFStringRef)v21;
    uint64_t v74 = 0LL;
    int64_t v75 = ~v7;
    int64_t v76 = v7 + 65;
    unint64_t v77 = &v223[v7];
    while (1)
    {
      CFIndex v78 = v7 + v74 + 1;
      if (v73 >= 4) {
        uint64_t v79 = 4LL;
      }
      else {
        uint64_t v79 = v73;
      }
      if ((v78 & 0x8000000000000000LL) == 0)
      {
        CFIndex v80 = buffer.rangeToBuffer.length;
        if (buffer.rangeToBuffer.length > v78)
        {
          if (buffer.directUniCharBuffer)
          {
            UniChar v81 = buffer.directUniCharBuffer[v7 + 1 + v74 + buffer.rangeToBuffer.location];
          }

          else if (buffer.directCStringBuffer)
          {
            UniChar v81 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7 + v74];
          }

          else
          {
            if (buffer.bufferedRangeEnd <= v78 || (CFIndex v82 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v78))
            {
              uint64_t v83 = v79 + v75;
              CFIndex v84 = v76 - v79;
              v224 = v77;
              CFIndex v85 = v7 + v74 + 1 - v79;
              uint64_t v86 = v7 + v74 + 65 - v79;
              if (v86 >= buffer.rangeToBuffer.length) {
                uint64_t v86 = buffer.rangeToBuffer.length;
              }
              buffer.CFIndex bufferedRangeStart = v85;
              buffer.bufferedRangeEnd = v86;
              if (buffer.rangeToBuffer.length >= v84) {
                CFIndex v80 = v84;
              }
              v241.length = v80 + v83;
              v241.CFIndex location = v85 + buffer.rangeToBuffer.location;
              CFStringGetCharacters(buffer.theString, v241, buffer.buffer);
              unint64_t v77 = v224;
              CFIndex v82 = buffer.bufferedRangeStart;
            }

            UniChar v81 = v77[v74 - v82];
          }

          if (v81 > 0x3Au)
          {
            if (v81 == 59) {
              goto LABEL_160;
            }
            if (v81 == 92)
            {
LABEL_184:
              v7 += v74 + 1;
              uint64_t v21 = (uint64_t)v229;
              int v22 = v223;
              goto LABEL_92;
            }
          }

          else
          {
            if (v81 == 34) {
              goto LABEL_184;
            }
            if (v81 == 44)
            {
LABEL_160:
              uint64_t v87 = v7 + v74 + 1;
LABEL_161:
              CFIndex v88 = v87 - v7;
              theSeta = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
              if (v87 - v7 >= 2)
              {
                unint64_t v89 = v87 - 1;
                uint64_t v90 = 1 - v87;
                CFIndex v91 = v87;
                uint64_t v92 = v87 + 63;
                CFCharacterSetRef v218 = (CFCharacterSetRef)v91;
                while (1)
                {
                  uint64_t v93 = v89 >= 4 ? 4LL : v89;
                  if (v91 >= 1 && (CFIndex v94 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length >= v91))
                  {
                    if (buffer.directUniCharBuffer)
                    {
                      UniChar v95 = buffer.directUniCharBuffer[v91 - 1 + buffer.rangeToBuffer.location];
                    }

                    else if (buffer.directCStringBuffer)
                    {
                      UniChar v95 = buffer.directCStringBuffer[buffer.rangeToBuffer.location - 1 + v91];
                    }

                    else
                    {
                      if (buffer.bufferedRangeEnd < v91
                        || (CFIndex v96 = buffer.bufferedRangeStart, buffer.bufferedRangeStart >= v91))
                      {
                        uint64_t v97 = v93 + v90;
                        CFIndex v98 = v92 - v93;
                        CFIndex v99 = v91 - v93;
                        CFIndex v100 = v99 - 1;
                        CFIndex v101 = v99 + 63;
                        if (v101 >= buffer.rangeToBuffer.length) {
                          CFIndex v101 = buffer.rangeToBuffer.length;
                        }
                        buffer.CFIndex bufferedRangeStart = v100;
                        buffer.bufferedRangeEnd = v101;
                        if (buffer.rangeToBuffer.length >= v98) {
                          CFIndex v94 = v98;
                        }
                        v242.length = v94 + v97;
                        v242.CFIndex location = v100 + buffer.rangeToBuffer.location;
                        CFStringGetCharacters(buffer.theString, v242, buffer.buffer);
                        CFIndex v96 = buffer.bufferedRangeStart;
                      }

                      UniChar v95 = *((_WORD *)&result.length + v91 - v96 + 3);
                    }
                  }

                  else
                  {
                    UniChar v95 = 0;
                  }

                  if (!CFCharacterSetIsCharacterMember(theSeta, v95)) {
                    break;
                  }
                  uint64_t v102 = v91 - v7;
                  --v89;
                  ++v90;
                  --v92;
                  --v91;
                  if (v102 <= 2)
                  {
                    CFIndex v88 = 1LL;
                    goto LABEL_186;
                  }
                }

                CFIndex v88 = v91 - v7;
LABEL_186:
                uint64_t v87 = (uint64_t)v218;
              }

              int v103 = CFGetAllocator(v1);
              v256.CFIndex location = v7;
              v256.length = v88;
              CFStringRef v20 = CFStringCreateWithSubstring(v103, v1, v256);
              uint64_t v21 = (uint64_t)v229;
              int v22 = v223;
              CFIndex v23 = v232;
              goto LABEL_188;
            }
          }
        }
      }

      ++v73;
      ++v74;
      --v75;
      ++v76;
      if (!(v232 + v7 + v74))
      {
        uint64_t v87 = Length;
        goto LABEL_161;
      }
    }
  }

  uint64_t v55 = Length - v7;
  if (Length <= v7 || v55 < 8) {
    goto LABEL_413;
  }
  v236.CFIndex location = 0LL;
  v236.length = 0LL;
  v254.CFIndex location = v7;
  v254.length = 5LL;
  int v56 = CFStringFindWithOptions(v1, (CFStringRef)&unk_18C5B10A0, v254, 9uLL, &v236);
  if (!v56 && (unint64_t)v55 >= 0xD)
  {
    v255.CFIndex location = v7;
    v255.length = 10LL;
    CFStringFindWithOptions(v1, v228, v255, 9uLL, &v236);
  }

  CFIndex v57 = v236.length;
  if (!v236.length)
  {
    unint64_t v68 = 0LL;
    BOOL v69 = (unint64_t)v55 > 0xA;
    goto LABEL_234;
  }

  int range_12 = v56;
  v221 = v22;
  CFIndex location = v236.location;
  int64_t v7 = v236.location + v236.length;
  if (v236.location + v236.length >= Length) {
    goto LABEL_417;
  }
  if (v7 < 0) {
    goto LABEL_233;
  }
  CFIndex v59 = buffer.rangeToBuffer.length;
  if (buffer.rangeToBuffer.length <= v7) {
    goto LABEL_233;
  }
  if (buffer.directUniCharBuffer)
  {
    UniChar v60 = buffer.directUniCharBuffer[buffer.rangeToBuffer.location + v7];
  }

  else if (buffer.directCStringBuffer)
  {
    UniChar v60 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
  }

  else
  {
    if (buffer.bufferedRangeEnd <= v7 || (CFIndex v106 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      CFIndex v107 = v7 - 4;
      if (v107 + 64 < buffer.rangeToBuffer.length) {
        CFIndex v59 = v107 + 64;
      }
      buffer.CFIndex bufferedRangeStart = v107;
      buffer.bufferedRangeEnd = v59;
      v244.CFIndex location = buffer.rangeToBuffer.location + v107;
      v244.length = v59 - v107;
      CFStringGetCharacters(buffer.theString, v244, buffer.buffer);
      CFIndex v106 = buffer.bufferedRangeStart;
    }

    UniChar v60 = buffer.buffer[v7 - v106];
  }

  CFIndex v8 = v227;
  if (v60 != 39)
  {
LABEL_233:
    unint64_t v68 = 0LL;
    BOOL v69 = 1;
    int v22 = v221;
    goto LABEL_234;
  }

  v219 = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  CFIndex v108 = v57 + location;
  unint64_t v109 = v57 + location + 1;
  CFIndex v110 = ~(v57 + location);
  uint64_t v111 = v57 + location + 65;
  uint64_t v112 = -2 - (v57 + location);
  CFIndex v113 = v108 + 66;
  while (1)
  {
    CFIndex v114 = v7 + 1;
    if (v109 >= 4) {
      uint64_t v115 = 4LL;
    }
    else {
      uint64_t v115 = v109;
    }
    if (v114 >= Length) {
      goto LABEL_417;
    }
    CFIndex v225 = v113;
    if (v7 >= -1)
    {
      CFIndex v116 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > v114) {
        break;
      }
    }

    UniChar v117 = 0;
LABEL_231:
    int v124 = v117;
    uint64_t v125 = v112;
    CFIndex v126 = v110;
    CFIndex v127 = v8;
    unint64_t v128 = v109;
    uint64_t v129 = v111;
    int IsCharacterMember = CFCharacterSetIsCharacterMember(v219, v117);
    uint64_t v131 = v129;
    unint64_t v132 = v128;
    CFIndex v8 = v127;
    unint64_t v109 = v132 + 1;
    CFIndex v110 = v126 - 1;
    uint64_t v111 = v131 + 1;
    ++v7;
    uint64_t v112 = v125 - 1;
    CFIndex v113 = v225 + 1;
    if (v124 != 45 && !IsCharacterMember) {
      goto LABEL_233;
    }
  }

  if (buffer.directUniCharBuffer)
  {
    UniChar v117 = buffer.directUniCharBuffer[v7 + 1 + buffer.rangeToBuffer.location];
  }

  else if (buffer.directCStringBuffer)
  {
    UniChar v117 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 1 + v7];
  }

  else
  {
    if (buffer.bufferedRangeEnd <= v114 || (CFIndex v118 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v114))
    {
      uint64_t v119 = v115 + v110;
      CFIndex v120 = v111 - v115;
      int64_t v121 = v7 - v115;
      uint64_t v214 = v111;
      CFIndex range = v110;
      CFIndex v122 = v121 + 1;
      CFIndex v123 = v121 + 65;
      if (v123 >= buffer.rangeToBuffer.length) {
        CFIndex v123 = buffer.rangeToBuffer.length;
      }
      buffer.CFIndex bufferedRangeStart = v122;
      buffer.bufferedRangeEnd = v123;
      if (buffer.rangeToBuffer.length >= v120) {
        CFIndex v116 = v120;
      }
      v245.length = v116 + v119;
      v245.CFIndex location = v122 + buffer.rangeToBuffer.location;
      CFStringGetCharacters(buffer.theString, v245, buffer.buffer);
      uint64_t v111 = v214;
      CFIndex v110 = range;
      CFIndex v118 = buffer.bufferedRangeStart;
    }

    UniChar v117 = v221[v7 - v118];
  }

  if (v117 != 39) {
    goto LABEL_231;
  }
  unint64_t v162 = v7 + 2;
  if (v7 + 2 >= Length) {
    goto LABEL_417;
  }
  CFIndex v163 = v225;
  v220 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  while (1)
  {
    CFIndex v164 = v7 + 2;
    uint64_t v165 = v162 >= 4 ? 4LL : v162;
    if (v164 < 0 || (CFIndex v166 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v164))
    {
      UniChar v167 = 0;
    }

    else if (buffer.directUniCharBuffer)
    {
      UniChar v167 = buffer.directUniCharBuffer[v7 + 2 + buffer.rangeToBuffer.location];
    }

    else if (buffer.directCStringBuffer)
    {
      UniChar v167 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + 2 + v7];
    }

    else
    {
      if (buffer.bufferedRangeEnd <= v164 || (CFIndex v169 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v164))
      {
        uint64_t v170 = v165 + v112;
        CFIndex v171 = v163 - v165;
        int64_t v172 = v7 - v165;
        CFIndex v173 = v172 + 2;
        CFIndex v174 = v172 + 66;
        if (v174 >= buffer.rangeToBuffer.length) {
          CFIndex v174 = buffer.rangeToBuffer.length;
        }
        buffer.CFIndex bufferedRangeStart = v173;
        buffer.bufferedRangeEnd = v174;
        if (buffer.rangeToBuffer.length >= v171) {
          CFIndex v166 = v171;
        }
        v249.length = v166 + v170;
        v249.CFIndex location = v173 + buffer.rangeToBuffer.location;
        CFStringGetCharacters(buffer.theString, v249, buffer.buffer);
        CFIndex v169 = buffer.bufferedRangeStart;
      }

      UniChar v167 = buffer.buffer[v7 + 2 - v169];
    }

    if (!CFCharacterSetIsCharacterMember(v220, v167)) {
      break;
    }
    ++v162;
    CFIndex v168 = v7 + 3;
    ++v7;
    --v112;
    ++v163;
    if (v168 >= Length) {
      goto LABEL_417;
    }
  }

  CFIndex rangea = v7 + 2;
  uint64_t v226 = v112;
  unint64_t v68 = 0LL;
  BOOL v69 = 1;
  if (v167 == 44 || v167 == 59)
  {
    v7 += 2LL;
    goto LABEL_411;
  }

  v7 += 2LL;
  unsigned __int16 CharacterFromInlineBuffer = v167;
  while (2)
  {
    if (CharacterFromInlineBuffer > 0x3Au)
    {
      if (CharacterFromInlineBuffer == 59) {
        goto LABEL_379;
      }
      if (CharacterFromInlineBuffer == 92)
      {
LABEL_402:
        unint64_t v68 = 0LL;
        BOOL v69 = 1;
        goto LABEL_411;
      }

LABEL_377:
      if (++v7 >= Length) {
        goto LABEL_379;
      }
      unsigned __int16 CharacterFromInlineBuffer = CFStringGetCharacterFromInlineBuffer(&buffer, v7);
      continue;
    }

    break;
  }

  if (CharacterFromInlineBuffer == 34) {
    goto LABEL_402;
  }
  if (CharacterFromInlineBuffer != 44) {
    goto LABEL_377;
  }
LABEL_379:
  CFIndex v192 = v7 - rangea;
  if (v7 - rangea >= 2)
  {
    unint64_t v193 = v7 - 1;
    int64_t v194 = 1 - v7;
    int64_t v195 = v7 + 63;
    CFIndex v196 = v7;
    while (1)
    {
      uint64_t v197 = v193 >= 4 ? 4LL : v193;
      if (v196 >= 1 && (CFIndex v198 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length >= v196))
      {
        if (buffer.directUniCharBuffer)
        {
          UniChar v199 = buffer.directUniCharBuffer[v196 - 1 + buffer.rangeToBuffer.location];
        }

        else if (buffer.directCStringBuffer)
        {
          UniChar v199 = buffer.directCStringBuffer[buffer.rangeToBuffer.location - 1 + v196];
        }

        else
        {
          if (buffer.bufferedRangeEnd < v196 || (CFIndex v200 = buffer.bufferedRangeStart, buffer.bufferedRangeStart >= v196))
          {
            uint64_t v201 = v197 + v194;
            CFIndex v202 = v195 - v197;
            CFIndex v203 = v196 - v197;
            CFIndex v204 = v203 - 1;
            CFIndex v205 = v203 + 63;
            if (v205 >= buffer.rangeToBuffer.length) {
              CFIndex v205 = buffer.rangeToBuffer.length;
            }
            buffer.CFIndex bufferedRangeStart = v204;
            buffer.bufferedRangeEnd = v205;
            if (buffer.rangeToBuffer.length >= v202) {
              CFIndex v198 = v202;
            }
            v252.length = v198 + v201;
            v252.CFIndex location = v204 + buffer.rangeToBuffer.location;
            CFStringGetCharacters(buffer.theString, v252, buffer.buffer);
            CFIndex v200 = buffer.bufferedRangeStart;
          }

          UniChar v199 = *((_WORD *)&result.length + v196 - v200 + 3);
        }
      }

      else
      {
        UniChar v199 = 0;
      }

      if (!CFCharacterSetIsCharacterMember(v220, v199)) {
        break;
      }
      uint64_t v206 = v226 + v196;
      --v193;
      ++v194;
      --v195;
      --v196;
      if (v206 <= 2)
      {
        CFIndex v192 = 1LL;
        goto LABEL_404;
      }
    }

    CFIndex v192 = v226 + v196;
  }

LABEL_404:
  v207 = CFGetAllocator(v1);
  v258.CFIndex location = rangea;
  v258.length = v192;
  CFStringRef v208 = CFStringCreateWithSubstring(v207, v1, v258);
  if (v208)
  {
    v209 = v208;
    v210 = CFGetAllocator(v1);
    if (range_12) {
      CFStringEncoding v211 = 134217984;
    }
    else {
      CFStringEncoding v211 = 513;
    }
    unint64_t v68 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v210, v209, &stru_189C1D1D8, v211);
    CFRelease(v209);
  }

  else
  {
    unint64_t v68 = 0LL;
  }

  BOOL v69 = v7 < Length;
LABEL_411:
  int v22 = v221;
  CFIndex v8 = v227;
LABEL_234:
  uint64_t v21 = (uint64_t)v228;
  CFStringRef v20 = (CFStringRef)theSet;
  CFIndex v23 = v232;
  if (!v69 || v68)
  {
    if (!v68) {
      goto LABEL_413;
    }
    if (theSet) {
      CFRelease(theSet);
    }
    goto LABEL_414;
  }

LABEL_236:
  while (2)
  {
    if (v7 >= Length) {
      goto LABEL_413;
    }
LABEL_237:
    if (v7 < 0 || (CFIndex v133 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
    {
LABEL_279:
      ++v7;
      continue;
    }

    break;
  }

  int v134 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    CFIndex v135 = buffer.rangeToBuffer.location + v7;
    goto LABEL_241;
  }

  if (buffer.directCStringBuffer)
  {
    UniChar v136 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
  }

  else
  {
    if (buffer.bufferedRangeEnd <= v7 || (CFIndex v150 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
    {
      CFIndex v151 = v7 - 4;
      if (v151 + 64 < buffer.rangeToBuffer.length) {
        CFIndex v133 = v151 + 64;
      }
      buffer.CFIndex bufferedRangeStart = v151;
      buffer.bufferedRangeEnd = v133;
      v247.CFIndex location = buffer.rangeToBuffer.location + v151;
      v247.length = v133 - v151;
      CFStringGetCharacters(buffer.theString, v247, buffer.buffer);
      CFIndex v150 = buffer.bufferedRangeStart;
    }

    CFIndex v135 = v7 - v150;
    int v134 = &buffer;
LABEL_241:
    UniChar v136 = v134->buffer[v135];
  }

  if (v136 != 34)
  {
    if (v136 != 44 && v136 != 59) {
      goto LABEL_279;
    }
    if (++v7 >= Length) {
      goto LABEL_413;
    }
    CFIndex v233 = v23;
    CFIndex v152 = v8;
    v153 = v22;
    while (1)
    {
      v154 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      if (v7 < 0 || (CFIndex v155 = buffer.rangeToBuffer.length, buffer.rangeToBuffer.length <= v7))
      {
        UniChar v158 = 0;
      }

      else
      {
        v156 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
        if (buffer.directUniCharBuffer)
        {
          CFIndex v157 = buffer.rangeToBuffer.location + v7;
        }

        else
        {
          if (buffer.directCStringBuffer)
          {
            UniChar v158 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + v7];
            goto LABEL_288;
          }

          if (buffer.bufferedRangeEnd <= v7 || (CFIndex v160 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > v7))
          {
            CFIndex v161 = v7 - 4;
            if (v161 + 64 < buffer.rangeToBuffer.length) {
              CFIndex v155 = v161 + 64;
            }
            buffer.CFIndex bufferedRangeStart = v161;
            buffer.bufferedRangeEnd = v155;
            v248.CFIndex location = buffer.rangeToBuffer.location + v161;
            v248.length = v155 - v161;
            CFStringGetCharacters(buffer.theString, v248, buffer.buffer);
            CFIndex v160 = buffer.bufferedRangeStart;
          }

          CFIndex v157 = v7 - v160;
          v156 = &buffer;
        }

        UniChar v158 = v156->buffer[v157];
      }

LABEL_288:
      int v159 = v158;
      if (!CFCharacterSetIsCharacterMember(v154, v158) && v159 != 59 && v159 != 44)
      {
        int v22 = v153;
        CFIndex v8 = v152;
        CFIndex v23 = v233;
        if (Length - v7 < 9) {
          goto LABEL_413;
        }
        goto LABEL_31;
      }

      if (++v7 >= Length) {
        goto LABEL_413;
      }
    }
  }

  v137 = v1;
  CFIndex v138 = v8;
  __int128 v139 = v22;
  CFIndex v140 = v23;
  uint64_t v141 = v21;
  __int128 v142 = v20;
  for (CFIndex j = v7 + 1; ; ++j)
  {
    if (j >= Length)
    {
LABEL_412:
      CFStringRef v20 = v142;
      goto LABEL_413;
    }

    if (v7 >= -1)
    {
      CFIndex v144 = buffer.rangeToBuffer.length;
      if (buffer.rangeToBuffer.length > j) {
        break;
      }
    }

LABEL_258:
    int64_t v7 = j;
  }

  __int128 v145 = (CFStringInlineBuffer *)buffer.directUniCharBuffer;
  if (buffer.directUniCharBuffer)
  {
    CFIndex v146 = buffer.rangeToBuffer.location + j;
LABEL_251:
    UniChar v147 = v145->buffer[v146];
    goto LABEL_254;
  }

  if (!buffer.directCStringBuffer)
  {
    if (buffer.bufferedRangeEnd <= j || (CFIndex v148 = buffer.bufferedRangeStart, buffer.bufferedRangeStart > j))
    {
      CFIndex v149 = j - 4;
      if (v149 + 64 < buffer.rangeToBuffer.length) {
        CFIndex v144 = v149 + 64;
      }
      buffer.CFIndex bufferedRangeStart = v149;
      buffer.bufferedRangeEnd = v144;
      v246.CFIndex location = buffer.rangeToBuffer.location + v149;
      v246.length = v144 - v149;
      CFStringGetCharacters(buffer.theString, v246, buffer.buffer);
      CFIndex v148 = buffer.bufferedRangeStart;
    }

    CFIndex v146 = j - v148;
    __int128 v145 = &buffer;
    goto LABEL_251;
  }

  UniChar v147 = buffer.directCStringBuffer[buffer.rangeToBuffer.location + j];
LABEL_254:
  if (v147 == 92)
  {
    if (++j >= Length) {
      goto LABEL_412;
    }
    goto LABEL_258;
  }

  if (v147 != 34) {
    goto LABEL_258;
  }
  int64_t v7 = j + 1;
  BOOL v15 = j + 1 < Length;
  CFStringRef v20 = v142;
  uint64_t v21 = v141;
  CFIndex v23 = v140;
  int v22 = v139;
  CFIndex v8 = v138;
  uint64_t v1 = v137;
  if (v15) {
    goto LABEL_237;
  }
LABEL_413:
  unint64_t v68 = v20;
  if (!v20) {
    return 0LL;
  }
LABEL_414:
  CFStringRef SanitizedFileNameFromString = createSanitizedFileNameFromString(v68);
  CFRelease(v68);
  return SanitizedFileNameFromString;
}

CFMutableStringRef cdReplaceQuotedPairs(__CFString *a1)
{
  CFMutableStringRef MutableCopy = a1;
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = Length - 1;
  if (Length > 1)
  {
    CFIndex v4 = Length;
    uint64_t v5 = CFGetAllocator(MutableCopy);
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v5, 0LL, MutableCopy);
    for (CFIndex i = 0LL; i < v4; ++i)
    {
      v10.CFIndex location = i;
      v10.length = v3;
      if (!CFStringFindWithOptions(MutableCopy, @"\\"", v10, 0LL, &range)) {
        break;
      }
      v9.CFIndex location = range.location;
      v9.length = 1LL;
      CFStringDelete(MutableCopy, v9);
      --v4;
      v3 -= 2LL;
    }
  }

  else
  {
    CFRetain(MutableCopy);
  }

  return MutableCopy;
}

uint64_t CFStringGetCharacterFromInlineBuffer(CFStringInlineBuffer *buffer, int64_t a2)
{
  if (a2 < 0)
  {
    return 0;
  }

  else
  {
    CFIndex length = buffer->rangeToBuffer.length;
    if (length <= a2)
    {
      return 0;
    }

    else
    {
      directUniCharBuffer = buffer->directUniCharBuffer;
      if (directUniCharBuffer)
      {
        return directUniCharBuffer[buffer->rangeToBuffer.location + a2];
      }

      else
      {
        directCStringBuffer = buffer->directCStringBuffer;
        if (directCStringBuffer)
        {
          return (unsigned __int16)directCStringBuffer[buffer->rangeToBuffer.location + a2];
        }

        else
        {
          if (buffer->bufferedRangeEnd <= a2
            || (CFIndex bufferedRangeStart = buffer->bufferedRangeStart, bufferedRangeStart > a2))
          {
            CFIndex v10 = a2 - 4;
            if (v10 + 64 < length) {
              CFIndex length = v10 + 64;
            }
            buffer->CFIndex bufferedRangeStart = v10;
            buffer->bufferedRangeEnd = length;
            v11.CFIndex location = buffer->rangeToBuffer.location + v10;
            v11.CFIndex length = length - v10;
            CFStringGetCharacters(buffer->theString, v11, buffer->buffer);
            CFIndex bufferedRangeStart = buffer->bufferedRangeStart;
          }

          return buffer->buffer[a2 - bufferedRangeStart];
        }
      }
    }
  }

CFStringRef createExtensionFromFilename(const __CFString *a1)
{
  uint64_t v1 = a1;
  CFIndex Length = CFStringGetLength(a1);
  if (Length >= 2)
  {
    CFIndex v4 = Length;
    CFIndex v5 = Length - 1;
    while (v5)
    {
      CFIndex v6 = v5;
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v1, v5);
      if (CharacterAtIndex == 47) {
        break;
      }
      CFIndex v5 = v6 - 1;
      if (CharacterAtIndex == 46)
      {
        CFIndex v8 = v6 + 1;
        if (v8 != 3) {
          goto LABEL_14;
        }
        if (CFStringGetLength(v1) <= 1 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)CFIndex v10 = 0;
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "createExtensionFromFilename(): passed a bogus filename",  v10,  2u);
        }

        if (CFStringGetCharacterAtIndex(v1, 1LL) != 58
          || (CFStringGetCharacterAtIndex(v1, 0LL) & 0xFFDFu) - 91 < 0xFFFFFFE6)
        {
LABEL_14:
          CFRange v9 = CFGetAllocator(v1);
          v11.CFIndex length = v4 - v8;
          v11.CFIndex location = v8;
          return CFStringCreateWithSubstring(v9, v1, v11);
        }

        break;
      }
    }
  }

  CFRetain(v1);
  return v1;
}

CFStringRef _CFURLCopyPathExtension_WorksWithMoreSchemes(const __CFURL *a1)
{
  CFStringRef v2 = CFURLCopyPathExtension(a1);
  if (!v2)
  {
    CFIndex v3 = CFURLCopyPath(a1);
    if (v3)
    {
      CFIndex v4 = v3;
      CFIndex Length = CFStringGetLength(v3);
      if (Length < 1)
      {
        CFStringRef v2 = 0LL;
      }

      else
      {
        CFIndex v6 = Length;
        int64_t v7 = CFCharacterSetCreateWithCharactersInString(0LL, @"./;=");
        v13.CFIndex location = 0LL;
        v13.CFIndex length = v6;
        if (CFStringFindCharacterFromSet(v4, v7, v13, 4uLL, &result)
          && CFStringGetCharacterAtIndex(v4, result.location) == 46)
        {
          CFIndex v8 = CFCharacterSetCreateWithCharactersInString(0LL, @";=?");
          v14.CFIndex location = 0LL;
          v14.CFIndex length = v6;
          CFStringRef v2 = 0LL;
          if (!CFStringFindCharacterFromSet(v4, v8, v14, 4uLL, &v11))
          {
            v9.CFIndex length = v6 + ~result.location;
            if (v9.length < 1)
            {
              CFStringRef v2 = 0LL;
            }

            else
            {
              v9.CFIndex location = result.location + 1;
              CFStringRef v2 = CFStringCreateWithSubstring(0LL, v4, v9);
            }
          }

          CFRelease(v8);
        }

        else
        {
          CFStringRef v2 = 0LL;
        }

        CFRelease(v7);
      }

      CFRelease(v4);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

char *_CFNetworkIsKnownHSTSHostWithSession(char *a1, os_unfair_lock_s *a2)
{
  CFIndex v3 = _HSTSPolicyForSession(a2);
  if (v3)
  {
    CFIndex v4 = v3;
    if (HSTSPolicy::Class(void)::sOnce_HSTSPolicy == -1)
    {
      if (a1) {
        goto LABEL_4;
      }
    }

    else
    {
      dispatch_once(&HSTSPolicy::Class(void)::sOnce_HSTSPolicy, &__block_literal_global_313);
      if (a1)
      {
LABEL_4:
        CFIndex v5 = (NSString *)[a1 host];
        if (v5) {
          a1 = (char *)HSTSPolicy::isKnownHSTSHost((HSTSPolicy *)(v4 + 2), v5, &v7);
        }
        else {
          a1 = 0LL;
        }
      }
    }

    CFRelease(v4);
    return a1;
  }

  return 0LL;
}

id *_HSTSPolicyForSession(os_unfair_lock_s *a1)
{
  if (a1)
  {
    return (id *)StorageSession::copyHSTSStorage(a1 + 4);
  }

  else
  {
    CFRange result = (id *)+[NSURLSession _sharedSessionForConnection]();
    if (result) {
      return (id *)[result[14] copyHSTSPolicy];
    }
  }

  return result;
}

id *_CFNetworkCopyHSTSPolicies(os_unfair_lock_s *a1)
{
  CFRange result = _HSTSPolicyForSession(a1);
  if (result)
  {
    CFStringRef v2 = result;
    CFDictionaryRef v3 = HSTSPolicy::copyExternalRepresentationOfHSTSPolicies((HSTSPolicy *)(v2 + 2));
    CFRelease(v2);
    return (id *)v3;
  }

  return result;
}

void _CFNetworkResetHSTS(const __CFURL *a1, os_unfair_lock_s *a2)
{
  CFDictionaryRef v3 = _HSTSPolicyForSession(a2);
  if (v3)
  {
    CFIndex v4 = (HSTSCache **)v3;
    CFStringRef v5 = CFURLCopyHostName(a1);
    if (v5)
    {
      CFStringRef v6 = v5;
      HSTSCache::modifyHSTSStore(v4[4], v6, 0LL, 0LL);
      CFRelease(v6);
    }

    CFRelease(v4);
  }

void _CFNetworkResetHSTSHostsSinceDate(os_unfair_lock_s *a1, const void *a2)
{
  CFDictionaryRef v3 = _HSTSPolicyForSession(a1);
  if (v3)
  {
    CFIndex v4 = (HSTSCache **)v3;
    HSTSCache::modifyHSTSStore(v4[4], 0LL, 0LL, a2);
    CFRelease(v4);
  }

void _CFNetworkResetHSTSHostsWithSession(os_unfair_lock_s *a1)
{
}

void _CFNetworkResetHSTSHosts()
{
}

CFRunLoopSourceRef CFNetworkExecuteProxyAutoConfigurationURL( CFURLRef proxyAutoConfigURL, CFURLRef targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext *clientContext)
{
  return PAC::CreatePACTicket( proxyAutoConfigURL,  targetURL,  0LL,  0LL,  (std::__shared_weak_count_vtbl *)cb,  (void (*)(void *, const __CFArray *, __CFError *))clientContext,  v4);
}

CFRunLoopSourceRef CFNetworkExecuteProxyAutoConfigurationScript( CFStringRef proxyAutoConfigurationScript, CFURLRef targetURL, CFProxyAutoConfigurationResultCallback cb, CFStreamClientContext *clientContext)
{
  return PAC::CreatePACTicket( (PAC *)proxyAutoConfigurationScript,  targetURL,  0LL,  0LL,  (std::__shared_weak_count_vtbl *)cb,  (void (*)(void *, const __CFArray *, __CFError *))clientContext,  v4);
}

CFDictionaryRef _newConnPropsForHTTPSProxy( CFAllocatorRef allocator, __CFHTTPMessage *a2, __CFString *a3, const __CFNumber *a4)
{
  CFDictionaryRef v6 = a2;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    keys = &unk_18C5AF900;
    CFIndex v8 = (CFDictionaryRef)((char *)v6 + 16);
    values = (void *)HTTPMessage::copyHeaderFieldValue(v8, 0x14E15421u);
    if (!values)
    {
      pthread_once(&initControl, initializeUserAgentString);
      values = (void *)sUserAgentString;
      CFRetain((CFTypeRef)sUserAgentString);
    }

    uint64_t v17 = 0x18C5AF430LL;
    CFTypeRef cf = HTTPMessage::copyHeaderFieldValue(v8, 0x1382736Bu);
    if (cf) {
      CFIndex v9 = 2LL;
    }
    else {
      CFIndex v9 = 1LL;
    }
    CFDictionaryRef v6 = CFDictionaryCreate( allocator,  (const void **)&keys,  (const void **)&values,  v9,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    CFRelease(values);
    if (cf) {
      CFRelease(cf);
    }
  }

  keys = &unk_18C5B2488;
  uint64_t v17 = 0x18C5B24C0LL;
  values = a3;
  CFTypeRef cf = a4;
  if (v6)
  {
    uint64_t v18 = 0x18C5B2418LL;
    CFDictionaryRef v15 = v6;
    CFDictionaryRef v10 = CFDictionaryCreate( allocator,  (const void **)&keys,  (const void **)&values,  3LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    CFRelease(v6);
  }

  else
  {
    CFDictionaryRef v10 = CFDictionaryCreate( allocator,  (const void **)&keys,  (const void **)&values,  2LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  }

  keys = &unk_18C5B2450;
  values = v10;
  CFDictionaryRef v11 = CFDictionaryCreate( allocator,  (const void **)&keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  CFRelease(v10);
  return v11;
}

void initializeUserAgentString(void)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (sUserAgentString) {
    return;
  }
  uint64_t v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (Mutable)
  {
    CFStringRef v2 = Mutable;
    MainBundle = CFBundleGetMainBundle();
    CFIndex v4 = (const void **)MEMORY[0x189604E18];
    if (!MainBundle) {
      goto LABEL_23;
    }
    CFStringRef v5 = MainBundle;
    InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
    if (dyld_program_sdk_at_least())
    {
      if (!InfoDictionary) {
        goto LABEL_14;
      }
      unsigned int Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, (const void *)*MEMORY[0x189604E10]);
    }

    else
    {
      unsigned int Value = (const __CFString *)CFBundleGetValueForInfoDictionaryKey(v5, (CFStringRef)*MEMORY[0x189604E10]);
    }

    if (Value)
    {
      appendEscaped(v2, Value);
      if (!InfoDictionary) {
        goto LABEL_20;
      }
      goto LABEL_17;
    }

void appendEscaped(__CFString *a1, const __CFString *a2)
{
  CFDictionaryRef v3 = CFURLCreateStringByAddingPercentEscapes( (CFAllocatorRef)*MEMORY[0x189604DB0],  a2,  0LL,  @"()<>@,;:\\/[]?={} \t",
         0x8000100u);
  CFStringAppend(a1, v3);
  CFRelease(v3);
}

CFStringRef copySysctl(int *a1)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  size_t v2 = 128LL;
  if (sysctl(a1, 2u, cStr, &v2, 0LL, 0LL) < 0) {
    return 0LL;
  }
  else {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x8000100u);
  }
}

CFDictionaryRef newConnPropsForSOCKSProxy( CFAllocatorRef allocator, const __CFString *a2, const __CFNumber *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6)
{
  keys[5] = *(void **)MEMORY[0x1895F89C0];
  unsigned __int8 v7 = (void *)*MEMORY[0x1896051F0];
  keys[0] = *(void **)MEMORY[0x1896051E8];
  keys[1] = v7;
  values[0] = (void *)a2;
  values[1] = a3;
  keys[2] = *(void **)MEMORY[0x189605200];
  CFIndex v8 = (const __CFString *)*MEMORY[0x189605210];
  if (a6) {
    CFIndex v8 = a6;
  }
  values[2] = (void *)v8;
  if (a4)
  {
    CFIndex v9 = (void *)*MEMORY[0x1896051E0];
    keys[3] = *(void **)MEMORY[0x1896051F8];
    keys[4] = v9;
    values[3] = (void *)a4;
    values[4] = (void *)a5;
    CFIndex v10 = 5LL;
  }

  else
  {
    CFIndex v10 = 3LL;
  }

  CFDictionaryRef v11 = (const CFDictionaryKeyCallBacks *)MEMORY[0x189605240];
  CFIndex v12 = (const CFDictionaryValueCallBacks *)MEMORY[0x189605250];
  CFDictionaryRef v13 = CFDictionaryCreate( allocator,  (const void **)keys,  (const void **)values,  v10,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  keys[0] = &unk_18C5ADEF8;
  values[0] = v13;
  CFDictionaryRef v14 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, 1LL, v11, v12);
  CFRelease(v13);
  return v14;
}

unint64_t canKeepAlive(__CFHTTPMessage *a1, __CFHTTPMessage *a2)
{
  if (!a1) {
    return 0LL;
  }
  CFStringRef v4 = HTTPMessage::copyHeaderFieldValue((__CFHTTPMessage *)((char *)a1 + 16), 0x13921375u);
  if (!v4)
  {
    CFStringRef v4 = HTTPMessage::copyHeaderFieldValue((__CFHTTPMessage *)((char *)a1 + 16), 0x11B152B9u);
    if (!v4)
    {
      CFStringRef v6 = CFHTTPMessageCopyVersion(a1);
      if (v6)
      {
        unsigned __int8 v7 = v6;
        CFStringRef v8 = CFHTTPMessageCopyVersion(a2);
        if (!v8)
        {
          unint64_t v5 = 0LL;
          CFStringRef v4 = v7;
          goto LABEL_14;
        }

        CFStringRef v4 = v8;
        if (!CFEqual(v7, @"HTTP/1.0") && !CFEqual(v4, @"HTTP/1.0"))
        {
          if (CFEqual(v7, @"HTTP/1.1"))
          {
            unint64_t v5 = 1LL;
            goto LABEL_20;
          }

          CFIndex Length = CFStringGetLength(v7);
          if (Length >= 7)
          {
            CFIndex v11 = Length;
            CFIndex v12 = CFGetAllocator(v7);
            v14.CFIndex length = v11 - 5;
            v14.CFIndex location = 5LL;
            CFDictionaryRef v13 = CFStringCreateWithSubstring(v12, v7, v14);
            unint64_t v5 = CFStringGetDoubleValue(v13) > 1.1;
            CFRelease(v13);
            goto LABEL_20;
          }
        }

        unint64_t v5 = 0LL;
LABEL_20:
        CFRelease(v7);
        goto LABEL_14;
      }

      return 0LL;
    }
  }

  if (CFStringCompare(v4, @"close", 1uLL) == kCFCompareEqualTo)
  {
LABEL_13:
    unint64_t v5 = 0LL;
    goto LABEL_14;
  }

  unint64_t v5 = 1LL;
  if (CFStringCompare(v4, @"keep-alive", 1uLL))
  {
    if (CFStringCompare(v4, (CFStringRef)&unk_18C5B0000, 1uLL)
      && CFStringFind(v4, @",", 0LL).location != -1
      && !hasTokenInList(v4, @"close"))
    {
      unint64_t v5 = hasTokenInList(v4, @"keep-alive");
      goto LABEL_14;
    }

    goto LABEL_13;
  }

unint64_t hasTokenInList(const __CFString *a1, const __CFString *a2)
{
  uint64_t Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetLength(a2);
  v17.CFIndex location = 0LL;
  v17.CFIndex length = Length;
  if (Length < 1) {
    return 0LL;
  }
  CFIndex v6 = v5;
  v18.CFIndex location = 0LL;
  v18.CFIndex length = Length;
  unint64_t result = CFStringFindWithOptions(a1, a2, v18, 1uLL, &v17);
  if (!(_DWORD)result) {
    return result;
  }
  if (!v17.location)
  {
    unsigned int CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v17.length);
    BOOL v11 = CharacterAtIndex > 0x2C;
    uint64_t v12 = 1LL << CharacterAtIndex;
LABEL_7:
    uint64_t v14 = v12 & 0x100100000200LL;
    return !v11 && v14 != 0;
  }

  uint64_t v8 = Length - v17.location;
  unsigned int v9 = CFStringGetCharacterAtIndex(a1, v17.location - 1);
  unsigned int v10 = v9;
  if (v6 == v8)
  {
    BOOL v11 = v9 > 0x2C;
    uint64_t v12 = 1LL << v9;
    goto LABEL_7;
  }

  unint64_t result = 0LL;
  if (v10 <= 0x2C && ((1LL << v10) & 0x100100000200LL) != 0)
  {
    unsigned int v16 = CFStringGetCharacterAtIndex(a1, v17.length + v17.location);
    if (v16 <= 0x2C) {
      return (0x100100000200uLL >> v16) & 1;
    }
    return 0LL;
  }

  return result;
}

BOOL _urlIsHTTPish(const __CFURL *a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = CFURLCopyScheme(a1);
  if (!v1) {
    return 0LL;
  }
  size_t v2 = v1;
  BOOL v3 = 1LL;
  if (CFStringCompare(v1, (CFStringRef)&unk_18C5B2B18, 1uLL)) {
    BOOL v3 = CFStringCompare(v2, (CFStringRef)&unk_18C5B2B50, 1uLL) == kCFCompareEqualTo;
  }
  CFRelease(v2);
  return v3;
}

uint64_t convertIPAddress(const __CFString *a1, int a2, void *a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  LOBYTE(result) = 0;
  if (Length)
  {
    if (Length <= 56)
    {
      LODWORD(result) = CFStringGetCString(a1, buffer, 57LL, 0x600u);
      if ((_DWORD)result) {
        LOBYTE(result) = inet_pton(a2, buffer, a3);
      }
    }
  }

  return result;
}

BOOL haveTheSameOrigin(NSURL *a1, NSURL *a2)
{
  uint64_t v4 = -[NSURL host](a1, "host");
  uint64_t v5 = -[NSURL host](a2, "host");
  if (v4 && v5)
  {
    if (![(id)v4 caseInsensitiveCompare:v5]) {
      goto LABEL_6;
    }
    return 0LL;
  }

  if (v4 | v5) {
    return 0LL;
  }
LABEL_6:
  uint64_t v6 = -[NSURL scheme](a1, "scheme");
  uint64_t v7 = -[NSURL scheme](a2, "scheme");
  if (v6 && v7)
  {
    if ([(id)v6 caseInsensitiveCompare:v7]) {
      return 0LL;
    }
  }

  else if (v6 | v7)
  {
    return 0LL;
  }

  BestPortunsigned int Value = getBestPortValue(a1);
  return BestPortValue == getBestPortValue(a2);
}

uint64_t getBestPortValue(NSURL *a1)
{
  size_t v2 = -[NSURL port](a1, "port");
  if (v2) {
    return -[NSNumber unsignedShortValue](v2, "unsignedShortValue");
  }
  uint64_t v4 = -[NSString lowercaseString](-[NSURL scheme](a1, "scheme"), "lowercaseString");
  if (v4 && (size_t v2 = (NSNumber *)[&unk_189C46D00 objectForKeyedSubscript:v4]) != 0) {
    return -[NSNumber unsignedShortValue](v2, "unsignedShortValue");
  }
  else {
    return 0LL;
  }
}

uint64_t ___Z23createIDNAEncodedDomainPK10__CFString_block_invoke()
{
  int v1 = 0;
  uint64_t result = MEMORY[0x186E165C0](60LL, &v1);
  createIDNAEncodedDomain(__CFString const*)::idna = result;
  if (v1 >= 1) {
    abort();
  }
  return result;
}

void sub_182A36484( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

NSMutableURLRequest *CFURLRequestCreateMutable(double a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v6 = -[NSURLRequest initWithURL:cachePolicy:timeoutInterval:]( objc_alloc(&OBJC_CLASS___NSMutableURLRequest),  "initWithURL:cachePolicy:timeoutInterval:",  a3,  a4,  a1);
  uint64_t v7 = v6;
  if (a5) {
    -[NSMutableURLRequest setMainDocumentURL:](v6, "setMainDocumentURL:", a5);
  }
  return v7;
}

uint64_t CFURLRequestCreateCopy(uint64_t a1, void *a2)
{
  return [a2 copy];
}

uint64_t CFURLRequestCreateMutableCopy(uint64_t a1, void *a2)
{
  return [a2 mutableCopy];
}

uint64_t CFURLRequestCreateHTTPRequest( int a1, __CFAllocator *a2, __CFHTTPMessage *a3, int a4, NSURLRequestCachePolicy a5, double a6)
{
  return _constructRequestFromParts(a2, a3, (const __CFArray *)a4, a5, a6, 0LL);
}

uint64_t CFURLRequestCreateMutableHTTPRequest( int a1, __CFAllocator *a2, __CFHTTPMessage *a3, int a4, NSURLRequestCachePolicy a5, double a6)
{
  return _constructRequestFromParts(a2, a3, (const __CFArray *)a4, a5, a6, (const __CFURL *)1);
}

id _CFURLRequestCreateFromArchiveList( uint64_t a1, uint64_t a2, const void **a3, uint64_t a4, const __CFDictionary *a5)
{
  uint64_t v9 = objc_alloc_init(&OBJC_CLASS___NSURLRequestInternal);
  if (URLRequest::initialize((URLRequest *)-[NSURLRequestInternal _inner](v9, "_inner"), a2, a3, a4, a5))
  {
    if (v9)
    {
      id v10 = -[NSURLRequest _initWithInternal:](objc_alloc(&OBJC_CLASS___NSMutableURLRequest), "_initWithInternal:", v9);

      return v10;
    }
  }

  else
  {
  }

  return 0LL;
}

uint64_t CFURLRequestGetURL(void *a1)
{
  return *(void *)([a1 _inner] + 8);
}

uint64_t CFURLRequestGetCachePolicy(void *a1)
{
  return *(unsigned int *)([a1 _inner] + 16);
}

double CFURLRequestGetTimeoutInterval(void *a1)
{
  return *(double *)([a1 _inner] + 24);
}

uint64_t CFURLRequestGetSSLProperties(void *a1)
{
  return *(void *)([a1 _inner] + 72);
}

uint64_t CFURLRequestGetMainDocumentURL(void *a1)
{
  return *(void *)([a1 _inner] + 32);
}

uint64_t CFURLRequestGetProxySettings(void *a1)
{
  return *(void *)([a1 _inner] + 48);
}

HTTPMessage *CFURLRequestCopyHTTPRequestBody(void *a1)
{
  uint64_t result = *(HTTPMessage **)([a1 _inner] + 56);
  if (result) {
    return HTTPMessage::copyBody(result);
  }
  return result;
}

HTTPMessage *CFURLRequestCopyHTTPHeaderFieldValue(void *a1, const __CFString *a2)
{
  uint64_t result = *(HTTPMessage **)([a1 _inner] + 56);
  if (result) {
    return (HTTPMessage *)HTTPMessage::copyHeaderFieldValue(result, a2);
  }
  return result;
}

HTTPMessage *CFURLRequestCopyAllHTTPHeaderFields(void *a1)
{
  uint64_t result = *(HTTPMessage **)([a1 _inner] + 56);
  if (result) {
    return HTTPMessage::copyAllHeaderFields(result);
  }
  return result;
}

CFArrayRef CFURLRequestCopyHTTPRequestBodyParts(void *a1)
{
  uint64_t v1 = *(void *)([a1 _inner] + 56);
  if (v1 && (size_t v2 = *(const __CFArray **)(v1 + 208)) != 0LL) {
    return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v2);
  }
  else {
    return 0LL;
  }
}

uint64_t CFURLRequestShouldHandleHTTPCookies(void *a1)
{
  return *(_WORD *)([a1 _inner] + 64) & 1;
}

CFTypeRef CFURLRequestCopyHTTPCookieStorage(void *a1)
{
  uint64_t v1 = *(void *)([a1 _inner] + 56);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 192)) != 0)
  {
    CFRetain(*(CFTypeRef *)(v1 + 192));
  }

  else
  {
    BOOL v3 = +[NSHTTPCookieStorage sharedHTTPCookieStorage](&OBJC_CLASS___NSHTTPCookieStorage, "sharedHTTPCookieStorage");
    if (v3)
    {
      uint64_t v4 = -[NSHTTPCookieStorage _cookieStorage](v3, "_cookieStorage");
      if (v4) {
        return CFRetain(v4);
      }
    }

    return 0LL;
  }

  return (CFTypeRef)v2;
}

uint64_t CFURLRequestSetCachePolicy(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  *(_WORD *)(result + 64) |= 0x400u;
  *(void *)(result + 16) = a2;
  return result;
}

uint64_t CFURLRequestSetTimeoutInterval(void *a1, double a2)
{
  uint64_t result = [a1 _inner];
  *(_WORD *)(result + 64) |= 0x800u;
  *(double *)(result + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a2;
  return result;
}

CFTypeRef CFURLRequestSetMainDocumentURL(void *a1, CFTypeRef a2)
{
  uint64_t v3 = [a1 _inner];
  CFTypeRef result = *(CFTypeRef *)(v3 + 32);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFTypeRef result = CFRetain(a2);
    }
    else {
      CFTypeRef result = 0LL;
    }
    *(void *)(v3 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = result;
  }

  return result;
}

CFDictionaryRef CFURLRequestSetProxySettings(void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = [a1 _inner];
  *(_WORD *)(v3 + 64) |= 0x1000u;
  CFDictionaryRef result = *(CFDictionaryRef *)(v3 + 48);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFDictionaryRef result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], a2);
    }
    else {
      CFDictionaryRef result = 0LL;
    }
    *(void *)(v3 + 4_Block_object_dispose((const void *)(v31 - 192), 8) = result;
  }

  return result;
}

CFDictionaryRef CFURLRequestSetSSLProperties(void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = [a1 _inner];
  *(_WORD *)(v3 + 64) |= 0x2000u;
  CFDictionaryRef result = *(CFDictionaryRef *)(v3 + 72);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFDictionaryRef result = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], a2);
    }
    else {
      CFDictionaryRef result = 0LL;
    }
    *(void *)(v3 + 72) = result;
  }

  return result;
}

void CFURLRequestAppendHTTPHeaderFieldValue(void *a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t v5 = [a1 _inner];
  fHTTPRequest = *(HTTPMessage **)(v5 + 56);
  if (!fHTTPRequest)
  {
    BOOL v11 = (URLRequest *)v5;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v12);
    URLRequest::createHTTPRequest(v11, (CFTypeRef *)&v12);
    uint64_t v12 = off_189C16E38;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = (HTTPMessage *)v11->fHTTPRequest;
    if (a3) {
      goto LABEL_3;
    }
LABEL_10:
    HTTPMessage::removeHeaderFieldValue(fHTTPRequest, a2);
    return;
  }

  if (!a3) {
    goto LABEL_10;
  }
LABEL_3:
  CFStringRef v7 = HTTPMessage::copyHeaderFieldValue(fHTTPRequest, a2);
  if (v7)
  {
    CFStringRef v8 = v7;
    uint64_t v9 = CFGetAllocator((char *)fHTTPRequest - 16);
    id v10 = CFStringCreateWithFormat(v9, 0LL, @"%@,%@", v8, a3);
    HTTPMessage::setHeaderFieldStringValue(fHTTPRequest, a2, v10);
    if (v10) {
      CFRelease(v10);
    }
    CFRelease(v8);
  }

  else
  {
    HTTPMessage::setHeaderFieldStringValue(fHTTPRequest, a2, a3);
  }

void sub_182A36B00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void CFURLRequestSetMultipleHTTPHeaderFields(void *a1, const __CFDictionary *a2)
{
  uint64_t v3 = (URLRequest *)[a1 _inner];
  fHTTPRequest = (HTTPMessage *)v3->fHTTPRequest;
  if (!fHTTPRequest)
  {
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v5);
    URLRequest::createHTTPRequest(v3, (CFTypeRef *)&v5);
    uint64_t v5 = off_189C16E38;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = (HTTPMessage *)v3->fHTTPRequest;
  }

  HTTPMessage::setMultipleHeaderFields(fHTTPRequest, a2);
}

void sub_182A36B90( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void CFURLRequestSetHTTPRequestBodyParts(void *a1, const __CFArray *a2)
{
}

uint64_t CFURLRequestSetShouldHandleHTTPCookies(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  __int16 v4 = *(_WORD *)(result + 64);
  __int16 v5 = v4 | 0x21;
  __int16 v6 = v4 & 0xFFDE | 0x20;
  if (a2) {
    __int16 v6 = v5;
  }
  *(_WORD *)(result + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6;
  return result;
}

CFTypeRef CFURLRequestSetHTTPCookieStorage(void *a1, CFTypeRef a2)
{
  uint64_t v3 = [a1 _inner];
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    __int16 v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v7);
    URLRequest::createHTTPRequest(v5, (CFTypeRef *)&v7);
    CFStringRef v7 = off_189C16E38;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = v5->fHTTPRequest;
  }

  CFTypeRef result = (CFTypeRef)*((void *)fHTTPRequest + 24);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFTypeRef result = CFRetain(a2);
    }
    else {
      CFTypeRef result = 0LL;
    }
    *((void *)fHTTPRequest + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = result;
  }

  return result;
}

void sub_182A36CB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void CFURLRequestSetHTTPCookieStorageAcceptPolicy()
{
  if (CFURLRequestSetHTTPCookieStorageAcceptPolicy::sOnce != -1) {
    dispatch_once(&CFURLRequestSetHTTPCookieStorageAcceptPolicy::sOnce, &__block_literal_global_1900);
  }
}

void __CFURLRequestSetHTTPCookieStorageAcceptPolicy_block_invoke()
{
}

void _CFURLRequestSetProtocolProperty(void *a1, const __CFString *cf1, CFStringRef a3)
{
  if (!CFEqual(cf1, @"_kNSURLRequestKey"))
  {
    int v6 = CFEqual(cf1, @"_kCFHTTPCookiePolicyPropertySiteForCookies");
    if (a3 && v6)
    {
      CFTypeID v7 = CFGetTypeID(a3);
      if (v7 != CFURLGetTypeID()) {
        return;
      }
      a3 = CFURLGetString((CFURLRef)a3);
    }

    URLRequest::setProtocolProperty((URLRequest *)[a1 _inner], cf1, a3);
    return;
  }

  if (_CFURLRequestSetProtocolProperty::sOnce != -1) {
    dispatch_once(&_CFURLRequestSetProtocolProperty::sOnce, &__block_literal_global_6_1904);
  }
}

CFAllocatorRef _CFURLRequestCreateArchiveList( const __CFAllocator *result, void *a2, uint64_t *a3, const void ***a4, uint64_t *a5, const __CFDictionary **a6)
{
  if (a2) {
    return URLRequest::createArchiveList((URLRequest *)[a2 _inner], result, a3, a4, a5, a6);
  }
  if (a5) {
    *a5 = 22LL;
  }
  return result;
}

CFTypeRef _CFURLRequestCopyContentDispositionEncodingFallbackArray(void *a1)
{
  CFTypeRef result = *(CFTypeRef *)([a1 _inner] + 80);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

CFTypeRef _CFURLRequestSetContentDispositionEncodingFallbackArray(void *a1, CFTypeRef a2)
{
  uint64_t v3 = [a1 _inner];
  CFTypeRef result = *(CFTypeRef *)(v3 + 80);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2) {
      CFTypeRef result = CFRetain(a2);
    }
    else {
      CFTypeRef result = 0LL;
    }
    *(void *)(v3 + 80) = result;
  }

  return result;
}

uint64_t CFURLRequestSetNetworkServiceType(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  *(_WORD *)(result + 64) |= 0x40u;
  *(_DWORD *)(result + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a2;
  return result;
}

void CFURLRequestSetShouldPipelineHTTP(void *a1, char a2, char a3)
{
  uint64_t v5 = [a1 _inner];
  *(_WORD *)(v5 + 64) |= 0x200u;
  fHTTPRequest = *(HTTPRequest **)(v5 + 56);
  if (!fHTTPRequest)
  {
    CFTypeID v7 = (URLRequest *)v5;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v8);
    URLRequest::createHTTPRequest(v7, (CFTypeRef *)&v8);
    CFStringRef v8 = off_189C16E38;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = v7->fHTTPRequest;
  }

  *((_BYTE *)fHTTPRequest + 216) = a2;
  *((_BYTE *)fHTTPRequest + 217) = a3;
}

void sub_182A36FB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void _CFURLRequestSetShouldPipelineNonIdempotentHTTP(void *a1, char a2)
{
  uint64_t v3 = [a1 _inner];
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    uint64_t v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v6);
    URLRequest::createHTTPRequest(v5, (CFTypeRef *)&v6);
    int v6 = off_189C16E38;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = v5->fHTTPRequest;
  }

  *((_BYTE *)fHTTPRequest + 21_Block_object_dispose((const void *)(v31 - 192), 8) = a2;
}

void sub_182A37040( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void _CFURLRequestSetShouldSkipPipelineProbe(void *a1, char a2)
{
  uint64_t v3 = [a1 _inner];
  fHTTPRequest = *(HTTPRequest **)(v3 + 56);
  if (!fHTTPRequest)
  {
    uint64_t v5 = (URLRequest *)v3;
    HTTPMethodMixedValue::HTTPMethodMixedValue(&v6);
    URLRequest::createHTTPRequest(v5, (CFTypeRef *)&v6);
    int v6 = off_189C16E38;
    if (cf) {
      CFRelease(cf);
    }
    fHTTPRequest = v5->fHTTPRequest;
  }

  *((_BYTE *)fHTTPRequest + 219) = a2;
}

void sub_182A370CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CFURLRequestSetRequestPriority(void *a1, uint64_t a2)
{
  uint64_t result = [a1 _inner];
  *(void *)(result + 8_Block_object_dispose((const void *)(v31 - 192), 8) = a2;
  return result;
}

uint64_t CFURLRequestGetRequestPriority(void *a1)
{
  return *(void *)([a1 _inner] + 88);
}

char *CFURLRequestSetShouldStartSynchronously(void *a1, int a2)
{
  uint64_t v3 = [a1 _inner];
  uint64_t result = *(char **)(v3 + 8);
  if (!result
    || (uint64_t result = _CFNetworkIsKnownHSTSHostWithSession(result, *(os_unfair_lock_s **)(v3 + 232)), !(_DWORD)result))
  {
    __int16 v5 = *(_WORD *)(v3 + 64);
    __int16 v6 = v5 | 0x4004;
    __int16 v7 = v5 & 0xBFFB | 0x4000;
    if (a2) {
      __int16 v7 = v6;
    }
    *(_WORD *)(v3 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v7;
  }

  return result;
}

uint64_t CFURLRequestSetAllowsCellularAccess(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  __int16 v4 = *(_WORD *)(result + 64);
  __int16 v5 = v4 | 0x88;
  __int16 v6 = v4 & 0xFF77 | 0x80;
  if (a2) {
    __int16 v6 = v5;
  }
  *(_WORD *)(result + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6;
  return result;
}

void _CFURLRequestSetStorageSession(void *a1, const void *a2)
{
  uint64_t v3 = [a1 _inner];
  __int16 v4 = *(const void **)(v3 + 232);
  if (v4 != a2)
  {
    if (v4) {
      CFRelease(v4);
    }
    if (a2) {
      CFTypeRef v5 = CFRetain(a2);
    }
    else {
      CFTypeRef v5 = 0LL;
    }
    *(void *)(v3 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v5;
  }

  uint64_t v6 = *(void *)(v3 + 56);
  if (v6)
  {
    __int16 v7 = *(const void **)(v6 + 192);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(v6 + 192) = 0LL;
    }
  }

uint64_t _CFURLRequestSetAllowedProtocolTypes(void *a1, uint64_t a2)
{
  uint64_t result = [a1 _inner];
  *(void *)(result + 96) = a2;
  return result;
}

uint64_t CFURLResponseGetTypeID()
{
  if (CFURLResponseGetTypeID::sOnce != -1) {
    dispatch_once(&CFURLResponseGetTypeID::sOnce, &__block_literal_global_1910);
  }
  return CFURLResponseGetTypeID::sID;
}

uint64_t __CFURLResponseGetTypeID_block_invoke()
{
  uint64_t v0 = objc_alloc(&OBJC_CLASS___NSURLResponse);
  CFURLResponseGetTypeID::sID = CFGetTypeID(v0);

  return CFLog();
}

id CFURLResponseCreate( uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, const __CFString *a5, int a6)
{
  BOOL v11 = objc_alloc_init(&OBJC_CLASS___NSURLResponseInternal);
  URLResponse::initialize((uint64_t)-[NSURLResponseInternal _inner](v11, "_inner"), a2, a3, a4, a5, a6);
  id v12 = -[NSURLResponse _initWithInternal:](objc_alloc(&OBJC_CLASS___NSURLResponse), "_initWithInternal:", v11);

  return v12;
}

uint64_t CFURLResponseGetURL(void *a1)
{
  return *(void *)([a1 _inner] + 8);
}

uint64_t CFURLResponseGetRecommendedCachePolicy(void *a1)
{
  return *(unsigned int *)([a1 _inner] + 72);
}

__CFString *CFURLResponseGetMIMEType(void *a1)
{
  return URLResponse::getMIMEType((URLResponse *)[a1 _inner]);
}

uint64_t CFURLResponseGetTextEncodingName(void *a1)
{
  uint64_t v1 = [a1 _inner];
  uint64_t v2 = *(void *)(v1 + 88);
  if (v2 && (*(_WORD *)(v2 + 297) & 0x400) == 0)
  {
    HeaderFieldunsigned int Value = HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)v2, 0x121192ECu);
    if (HeaderFieldValue)
    {
      __int16 v4 = HeaderFieldValue;
      CFIndex Length = CFStringGetLength(HeaderFieldValue);
      v21.CFIndex location = 0LL;
      v21.CFIndex length = Length;
      uint64_t v6 = 0LL;
      if (CFStringFindWithOptions(v4, @"charset=", v21, 1uLL, &v18) && v18.length)
      {
        CFCharacterSetRef Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
        CFIndex v8 = v18.length + v18.location;
        if (v18.length + v18.location >= Length) {
          goto LABEL_22;
        }
        uint64_t v9 = Predefined;
        CFIndex v10 = -1LL;
        uint64_t v11 = -1LL;
        do
        {
          int CharacterAtIndex = CFStringGetCharacterAtIndex(v4, v8);
          if (CharacterAtIndex == 44 || CharacterAtIndex == 59) {
            break;
          }
          if (CFCharacterSetIsCharacterMember(v9, CharacterAtIndex))
          {
            uint64_t v13 = -1LL;
          }

          else
          {
            uint64_t v11 = v8;
            uint64_t v13 = v8;
          }

          if (v10 == -1) {
            CFIndex v10 = v13;
          }
          ++v8;
        }

        while (v8 < Length);
        if (v10 == -1)
        {
LABEL_22:
          uint64_t v6 = 0LL;
        }

        else
        {
          uint64_t v14 = CFGetAllocator(v4);
          CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v14, Length, v4);
          uint64_t v6 = MutableCopy;
          if (v11 != Length)
          {
            v19.CFIndex location = v11 + 1;
            v19.CFIndex length = Length + ~v11;
            CFStringDelete(MutableCopy, v19);
          }

          v20.CFIndex location = 0LL;
          v20.CFIndex length = v10;
          CFStringDelete(v6, v20);
          CFStringLowercase(v6, 0LL);
        }
      }

      CFRelease(v4);
      unsigned int v16 = *(const void **)(v1 + 24);
      if (v16) {
        CFRelease(v16);
      }
      *(void *)(v1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6;
    }

    *(_WORD *)(*(void *)(v1 + 88) + 297LL) |= 0x400u;
  }

  return *(void *)(v1 + 24);
}

double CFURLResponseGetCreationTime(void *a1)
{
  return URLResponse::getCreationTime((URLResponse *)[a1 _inner]);
}

double CFURLResponseGetExpirationTime(void *a1)
{
  uint64_t v1 = (URLResponse *)[a1 _inner];
  fHTTP = v1->fHTTP;
  if (fHTTP && (*(_WORD *)((char *)fHTTP + 297) & 0x1000) == 0)
  {
    uint64_t v3 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)fHTTP, 0x1160729Bu);
    Intunsigned int Value = 0.0;
    if (v3)
    {
      CFTypeRef v5 = v3;
      Intunsigned int Value = (double)CFStringGetIntValue(v3);
      CFRelease(v5);
    }

    double CreationTime = URLResponse::getCreationTime(v1);
    URLResponse::freshnessLifetimeForResponse(v1);
    fdouble CreationTime = v1->fCreationTime;
    double v9 = fCreationTime - CreationTime;
    if (fCreationTime - CreationTime < 0.0) {
      double v9 = 0.0;
    }
    if (v9 <= IntValue) {
      double v9 = IntValue;
    }
    v1->fExpiration = fCreationTime + v7 - v9;
    *(_WORD *)((char *)v1->fHTTP + 297) |= 0x1000u;
  }

  return v1->fExpiration;
}

uint64_t CFURLResponseSetExpectedContentLength(void *a1, uint64_t a2)
{
  uint64_t result = [a1 _inner];
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = a2;
  uint64_t v4 = *(void *)(result + 88);
  if (v4)
  {
    *(_WORD *)(v4 + 297) |= 0x100u;
    *(_WORD *)(*(void *)(result + 88) + 297LL) |= 0x2000u;
  }

  return result;
}

void CFURLResponseSetMIMEType(void *a1, const __CFString *Copy)
{
  uint64_t v3 = [a1 _inner];
  if (Copy) {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], Copy);
  }
  uint64_t v4 = *(const void **)(v3 + 16);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(v3 + 16) = Copy;
  uint64_t v5 = *(void *)(v3 + 88);
  if (v5)
  {
    *(_WORD *)(v5 + 297) |= 0x200u;
    *(_WORD *)(*(void *)(v3 + 88) + 297LL) |= 0x4000u;
  }

uint64_t CFURLResponseSetExpiration(void *a1, double a2)
{
  uint64_t result = [a1 _inner];
  *(double *)(result + 40) = a2;
  uint64_t v4 = *(void *)(result + 88);
  if (v4) {
    *(_WORD *)(v4 + 297) |= 0x1000u;
  }
  return result;
}

uint64_t _CFURLResponseSetCreationTime(void *a1, double a2)
{
  uint64_t result = [a1 _inner];
  *(double *)(result + 4_Block_object_dispose((const void *)(v31 - 192), 8) = a2;
  return result;
}

uint64_t CFURLResponseSetRecommendedCachePolicy(void *a1, int a2)
{
  uint64_t result = [a1 _inner];
  *(_DWORD *)(result + 72) = a2;
  return result;
}

uint64_t _CFURLResponseGetSSLCertificateContext(void *a1)
{
  return *(void *)([a1 _inner] + 64);
}

uint64_t CFURLResponseGetHTTPResponse(void *a1)
{
  uint64_t v1 = *(void *)([a1 _inner] + 88);
  if (v1) {
    return v1 - 16;
  }
  else {
    return 0LL;
  }
}

double _CFURLResponseGetFreshnessLifetime(void *a1)
{
  uint64_t v1 = (URLResponse *)[a1 _inner];
  if (!v1->fHTTP) {
    return 1.79769313e308;
  }
  URLResponse::freshnessLifetimeForResponse(v1);
  return result;
}

CFAllocatorRef _CFURLResponseCreateArchiveList( const __CFAllocator *result, void *a2, uint64_t *a3, const void ***a4, uint64_t *a5)
{
  if (a2) {
    return (const __CFAllocator *)URLResponse::createArchiveList( (URLResponse *)[a2 _inner],  result,  a3,  a4,  a5);
  }
  if (a5) {
    *a5 = 7LL;
  }
  return result;
}

uint64_t _CFURLResponseCreateFromArchiveList(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4)
{
  double v7 = objc_alloc_init(&OBJC_CLASS___NSURLResponseInternal);
  URLResponse::initialize(-[NSURLResponseInternal _inner](v7, "_inner"), a2, a3, a4);
  -[NSURLResponseInternal _inner](v7, "_inner");
  uint64_t v8 = [objc_alloc((Class)objc_opt_class()) _initWithInternal:v7];

  return v8;
}

uint64_t _CFURLResponseCreateFromPropertyList(const __CFAllocator *a1, const void *a2)
{
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSURLResponseInternal);
  uint64_t v4 = -[NSURLResponseInternal _inner](v3, "_inner");
  CFTypeID v5 = CFGetTypeID(a1);
  if (v5 == CFDictionaryGetTypeID())
  {
    unsigned int Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"Version");
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      double v7 = (const __CFArray *)CFDictionaryGetValue(a1, @"Array");
      if (v7)
      {
        uint64_t v8 = v7;
        CFIndex Count = CFArrayGetCount(v7);
        CFIndex v10 = (const void **)calloc(Count, 8uLL);
        v18.CFIndex location = 0LL;
        v18.CFIndex length = Count;
        CFArrayGetValues(v8, v18, v10);
        if (Count >= 2)
        {
          uint64_t v11 = v10 - 1;
          CFIndex v12 = Count;
          do
          {
            CFTypeID v13 = CFGetTypeID(v11[v12]);
            if (v13 == CFStringGetTypeID() && CFEqual(@"__CFURLResponseNullTokenString__", v11[v12])) {
              v11[v12] = 0LL;
            }
            --v12;
          }

          while ((unint64_t)(v12 + 1) > 2);
        }

        *CFIndex v10 = (const void *)_CFURLCreateFromPropertyListRepresentation();
        URLResponse::initialize(v4, valuePtr, v10, Count);
        if (*v10) {
          CFRelease(*v10);
        }
        free(v10);
        fHTTP = (HTTPMessage *)v4->fHTTP;
        if (fHTTP) {
          HTTPMessage::ensureParserFinished(fHTTP);
        }
      }
    }
  }

  -[NSURLResponseInternal _inner](v3, "_inner");
  uint64_t v15 = [objc_alloc((Class)objc_opt_class()) _initWithInternal:v3];

  return v15;
}

CFStringRef CFURLResponseCopySuggestedFilename(void *a1)
{
  return URLResponse::copySuggestedFilename((URLResponse *)[a1 _inner]);
}

BOOL CFURLResponseDataIsEncoded(void *a1)
{
  uint64_t v1 = *(void *)([a1 _inner] + 88);
  return v1 && ((*(unsigned __int16 *)(v1 + 297) | (*(unsigned __int8 *)(v1 + 299) << 16)) & 0x10000) != 0;
}

uint64_t CFURLResponseConnectionDidFallback(void *a1)
{
  return *(unsigned __int8 *)([a1 _inner] + 96);
}

uint64_t CFURLResponseConnectionIsCellular(void *a1)
{
  return *(unsigned __int8 *)([a1 _inner] + 97);
}

uint64_t _CFURLProtocolSendDidFailCallback(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "client"), "URLProtocol:didFailWithError:", a1, a2);
}

uint64_t _CFURLProtocolSendDidReceiveResponseCallback(void *a1, uint64_t a2)
{
  return objc_msgSend( (id)objc_msgSend(a1, "client"),  "URLProtocol:didReceiveResponse:cacheStoragePolicy:",  a1,  +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", a2),  2);
}

uint64_t _CFURLProtocolSendDidLoadDataCallback(void *a1, uint64_t a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "client"), "URLProtocol:didLoadData:", a1, a2);
}

uint64_t _CFURLProtocolSendDidFinishLoadingCallback(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "client"), "URLProtocolDidFinishLoading:", a1);
}

BOOL CFURLProtocolRegisterImplementation(BOOL result)
{
  uint64_t v1 = result;
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (*(void *)result || *(void *)(result + 16) || *(void *)(result + 24))
  {
    CFLog();
    abort();
  }

  if (*(void *)(result + 8))
  {
    uint64_t v2 = 0LL;
    for (CFIndex i = &_translatedFileProtocol; *i; ++i)
    {
      if (++v2 == 8) {
        return result;
      }
    }

    double v7 = operator new(0x48uLL);
    *CFIndex i = (uint64_t)v7;
    v7[8] = *(void *)(v1 + 64);
    __int128 v8 = *(_OWORD *)(v1 + 48);
    *((_OWORD *)v7 + 2) = *(_OWORD *)(v1 + 32);
    *((_OWORD *)v7 + 3) = v8;
    __int128 v9 = *(_OWORD *)(v1 + 16);
    *(_OWORD *)double v7 = *(_OWORD *)v1;
    *((_OWORD *)v7 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v9;
    snprintf(__str, 0x100uLL, "_NSCFTranslatedFileURLProtocol_PIMPL_%d", v2);
    return +[NSURLProtocol registerClass:](&OBJC_CLASS___NSURLProtocol, "registerClass:", objc_getClass(__str));
  }

  else
  {
    _wikipediaProtocol = *(_OWORD *)result;
    __int128 v4 = *(_OWORD *)(result + 16);
    __int128 v5 = *(_OWORD *)(result + 32);
    __int128 v6 = *(_OWORD *)(result + 48);
    off_18C5B2F38 = *(uint64_t (**)(void, void, void))(result + 64);
    unk_18C5B2F18 = v5;
    unk_18C5B2F28 = v6;
    xmmword_18C5B2F08 = v4;
    return +[NSURLProtocol registerClass:](&OBJC_CLASS___NSURLProtocol, "registerClass:", objc_opt_class());
  }

uint64_t CFURLProtocolGetCachedResponse()
{
  return 0LL;
}

uint64_t CFURLProtocolGetClient(uint64_t result)
{
  if (result) {
    result += 40LL;
  }
  return result;
}

uint64_t CFURLCredentialCreate(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4, int a5)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(void *)(Instance + 112) = 0LL;
  *(_DWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0;
  *(_BYTE *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(Instance + 72) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  *(void *)(Instance + 16) = &off_189C11DC8;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C11E70;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3773];
  *(void *)(Instance + 40) = &unk_189C11EA0;
  *(_BYTE *)(Instance + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  if (!URLCredentialInternetPassword::initialize(Instance + 16, a2, a3, a5, 0LL))
  {
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t CFURLCredentialCreateWithIdentityAndCertificateArray( uint64_t a1, const void *a2, const __CFArray *a3, int a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(_DWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 3;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C11D78;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3773];
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(Instance + 72) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  *(void *)(Instance + 16) = &off_189C11CE8;
  *(void *)(Instance + 40) = &unk_189C11DA8;
  if (!URLCredentialClientCertificate::initialize(Instance + 16, a2, a3, a4))
  {
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t CFURLCredentialCreateWithTrust(uint64_t a1, const void *a2)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(void *)(Instance + 16) = &off_189C12048;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C120C8;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_BYTE *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(Instance + 72) = 0LL;
  *(void *)(Instance + 80) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3773];
  *(void *)(Instance + 40) = &unk_189C120F8;
  *(void *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0x200000001LL;
  if (a2) {
    CFTypeRef v4 = CFRetain(a2);
  }
  else {
    CFTypeRef v4 = 0LL;
  }
  *(void *)(Instance + 80) = v4;
  return Instance;
}

uint64_t _CFURLCredentialCreateForKerberosTicketWithUUID( const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4, const __CFUUID *a5)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 2;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C11FD8;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3773];
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_BYTE *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(Instance + 72) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  *(void *)(Instance + 16) = &off_189C11F30;
  *(void *)(Instance + 40) = &unk_189C12008;
  *(void *)(Instance + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  if (!URLCredentialKerberosTicket::initialize( (URLCredentialKerberosTicket *)(Instance + 16),  a2,  a3,  a4,  a5))
  {
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t _CFURLCredentialCreateForKerberosTicket( const __CFAllocator *a1, const __CFString *a2, const __CFString *a3, const __CFDictionary *a4)
{
  return _CFURLCredentialCreateForKerberosTicketWithUUID(a1, a2, a3, a4, 0LL);
}

uint64_t _CFURLCredentialCreateXMobileMeAuthToken( uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 4;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C172C8;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3773];
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_BYTE *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(Instance + 72) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  *(void *)(Instance + 16) = &off_189C17220;
  *(void *)(Instance + 40) = &unk_189C172F8;
  if (!URLCredentialXMobileMeAuthToken::initialize( (URLCredentialXMobileMeAuthToken *)(Instance + 16),  a2,  a3,  a4))
  {
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t _CFURLCredentialCreateOAuth2(uint64_t a1, const __CFString *a2, const __CFString *a3)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 6;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C19440;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3773];
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(Instance + 56) = 0LL;
  *(void *)(Instance + 16) = &off_189C193A8;
  *(void *)(Instance + 40) = &unk_189C19470;
  *(void *)(Instance + 72) = 0LL;
  *(void *)(Instance + 80) = 0LL;
  *(void *)(Instance + 8_Block_object_dispose((const void *)(v31 - 192), 8) = 0LL;
  if (!URLCredentialOAuth2::initialize((URLCredentialOAuth2 *)(Instance + 16), a2, a3))
  {
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t _CFURLCredentialCreateOAuth1(uint64_t a1, objc_object *a2, int a3, const __CFString *a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_DWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 7;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C189E8;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3773];
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_BYTE *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(Instance + 72) = 0LL;
  *(void *)(Instance + 56) = 0LL;
  *(void *)(Instance + 16) = &off_189C18938;
  *(void *)(Instance + 40) = &unk_189C18A18;
  *(_DWORD *)(Instance + 80) = 0;
  *(void *)(Instance + 8_Block_object_dispose((const void *)(v31 - 192), 8) = 0LL;
  *(void *)(Instance + 96) = 0LL;
  if (!URLCredentialOAuth1::initialize((URLCredentialOAuth1 *)(Instance + 16), a2, a3, a4))
  {
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

uint64_t CFURLCredentialGetPersistence(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(unsigned int *)(v2 + 36);
}

uint64_t CFURLCredentialGetUsername(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  if (!*(_DWORD *)(a1 + 48) || *(_DWORD *)(a1 + 48) == 4 || *(_DWORD *)(a1 + 48) == 2 || *(_DWORD *)(a1 + 48) == 6) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 16) + 112LL))(a1 + 16);
  }
  else {
    return 0LL;
  }
}

uint64_t CFURLCredentialCopyPassword(uint64_t a1, const _CFURLCredential *a2)
{
  uint64_t result = URLCredential_PasswordBased::safelyCast(a1, a2);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 128LL))(result);
  }
  return result;
}

uint64_t CFURLCredentialContainsPassword(uint64_t a1, const _CFURLCredential *a2)
{
  uint64_t result = URLCredential_PasswordBased::safelyCast(a1, a2);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 136LL))(result);
  }
  return result;
}

CFTypeRef _CFURLCredentialCreateArchive(CFAllocatorRef allocator, uint64_t a2)
{
  uint64_t v2 = a2;
  if (a2)
  {
    v2 += 16LL;
  }

  CFTypeRef cf = CFDictionaryCreateMutable(allocator, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if ((*(unsigned int (**)(uint64_t, CFTypeRef *))(*(void *)v2 + 72LL))(v2, &cf))
  {
    if (!cf) {
      return 0LL;
    }
    CFTypeRef v4 = CFRetain(cf);
  }

  else
  {
    CFTypeRef v4 = 0LL;
  }

  if (cf) {
    CFRelease(cf);
  }
  return v4;
}

void sub_182A38B04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CFURLCredentialCopyOAuthToken(const _CFURLCredential *a1)
{
  if (!a1) {
    return 0LL;
  }
  if (*((_DWORD *)a1 + 12) == 6) {
    return (*(uint64_t (**)(char *))(*((void *)a1 + 2) + 128LL))((char *)a1 + 16);
  }
  else {
    return 0LL;
  }
}

uint64_t _CFURLCredentialCopyOAuth1Account(const _CFURLCredential *a1)
{
  if (!a1) {
    return 0LL;
  }
  if (*((_DWORD *)a1 + 12) == 7) {
    return (*(uint64_t (**)(char *))(*((void *)a1 + 2) + 128LL))((char *)a1 + 16);
  }
  else {
    return 0LL;
  }
}

uint64_t _CFURLCredentialGetOAuth1PID(const _CFURLCredential *a1)
{
  if (!a1) {
    return 0LL;
  }
  if (*((_DWORD *)a1 + 12) == 7) {
    return (*(uint64_t (**)(char *))(*((void *)a1 + 2) + 152LL))((char *)a1 + 16);
  }
  else {
    return 0LL;
  }
}

uint64_t (***_CFURLCredentialCreateFromArchive( URLCredential *a1, const __CFDictionary *a2, const void *a3))(URLCredentialClientCertificate *__hidden this, const CFObject *)
{
  uint64_t v3 = URLCredential::createFromPropertyList(a1, a2, a3);
  if (v3) {
    return v3 - 2;
  }
  else {
    return 0LL;
  }
}

uint64_t CFURLProtectionSpaceGetHost(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 32);
}

uint64_t CFURLProtectionSpaceGetPort(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(unsigned int *)(v2 + 40);
}

uint64_t CFURLProtectionSpaceGetServerType(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(unsigned int *)(v2 + 44);
}

uint64_t CFURLProtectionSpaceGetRealm(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 48);
}

uint64_t CFURLProtectionSpaceGetAuthenticationScheme(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(unsigned int *)(v2 + 56);
}

BOOL CFURLProtectionSpaceIsProxy(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return (*(_DWORD *)(v2 + 44) - 5) < 4;
}

uint64_t CFURLProtectionSpaceReceivesCredentialSecurely(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  int v3 = *(_DWORD *)(v2 + 44);
  if (v3 == 2 || v3 == 4) {
    return 1LL;
  }
  unsigned int v6 = *(_DWORD *)(v2 + 56);
  BOOL v7 = v6 > 4;
  unsigned int v8 = (9u >> v6) & 1;
  if (v7) {
    return 1LL;
  }
  else {
    return v8;
  }
}

uint64_t CFURLProtectionSpaceGetServerTrust(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 72);
}

CFTypeRef _CFURLProtectionSpaceCreateArchive(const __CFAllocator *a1, uint64_t a2)
{
  CFTypeRef cf = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (a2) {
    uint64_t v3 = a2 + 16;
  }
  else {
    uint64_t v3 = 0LL;
  }
  if ((*(unsigned int (**)(uint64_t, CFTypeRef *))(*(void *)v3 + 64LL))(v3, &cf))
  {
    if (!cf) {
      return 0LL;
    }
    CFTypeRef v4 = CFRetain(cf);
  }

  else
  {
    CFTypeRef v4 = 0LL;
  }

  if (cf) {
    CFRelease(cf);
  }
  return v4;
}

void sub_182A39030( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Archiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Archiver(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Archiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Archiver(void *__p)
{
  uint64_t v2 = (const void *)__p[1];
  if (v2) {
    CFRelease(v2);
  }
  operator delete(__p);
}

uint64_t _CFURLProtectionSpaceCreateFromArchive(const __CFAllocator *a1, CFTypeRef cf)
{
  cfa[1] = a1;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0LL;
  }
  cfa[0] = v3;
  cfa[2] = a1;
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + 96) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3780];
  *(void *)(Instance + 16) = &off_189C0EA00;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C0EA58;
  *(_BYTE *)(Instance + 96) = 0;
  *(_BYTE *)(Instance + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(Instance + 112) = 1LL;
  if (!URLProtectionSpace::initializeFromPropertyList((URLProtectionSpace *)(Instance + 16), (CFDictionaryRef *)cfa))
  {
    CFRelease((CFTypeRef)Instance);
    uint64_t Instance = 0LL;
  }

  if (cfa[0]) {
    CFRelease(cfa[0]);
  }
  return Instance;
}

void sub_182A391A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Dearchiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Dearchiver(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Dearchiver<URLProtectionSpace,_CFURLProtectionSpace *>::~Dearchiver(void *__p)
{
  uint64_t v2 = (const void *)__p[1];
  if (v2) {
    CFRelease(v2);
  }
  operator delete(__p);
}

CFTypeRef URLProtectionSpace::setDistinguishedNames(URLProtectionSpace *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 8);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0LL;
    }
    *((void *)this + _Block_object_dispose((const void *)(v31 - 192), 8) = result;
  }

  return result;
}

uint64_t authMethodToAuthScheme(NSString *a1)
{
  if (!a1) {
    return 1LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodDefault")) {
    return 1LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodHTTPBasic")) {
    return 2LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodHTTPDigest")) {
    return 3LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodHTMLForm")) {
    return 4LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodNTLM")) {
    return 5LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodNegotiate")) {
    return 6LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodClientCertificate")) {
    return 7LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodServerTrust")) {
    return 8LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodXMobileMeAuthToken")) {
    return 9LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodOAuth")) {
    return 10LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodPrivateAccessToken")) {
    return 11LL;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", @"NSURLAuthenticationMethodOAuthBearerToken")) {
    return 12LL;
  }
  return 1LL;
}

void __acquireAssertion_block_invoke(double a1)
{
  v15[2] = *MEMORY[0x1895F89C0];
  double Helper_x8__OBJC_CLASS___RBSDomainAttribute = gotLoadHelper_x8__OBJC_CLASS___RBSDomainAttribute(a1);
  objc_msgSend( *(id *)(v2 + 480),  "attributeWithDomain:name:",  @"com.apple.common",  @"FinishTaskUninterruptable",  Helper_x8__OBJC_CLASS___RBSDomainAttribute);
  CFTypeRef v3 = (void *)objc_claimAutoreleasedReturnValue();
  v15[0] = v3;
  double Helper_x8__OBJC_CLASS___RBSAcquisitionCompletionAttribute = gotLoadHelper_x8__OBJC_CLASS___RBSAcquisitionCompletionAttribute(v4);
  objc_msgSend( *(id *)(v6 + 272),  "attributeWithCompletionPolicy:",  1,  Helper_x8__OBJC_CLASS___RBSAcquisitionCompletionAttribute);
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
  v15[1] = v7;
  uint64_t v8 = [MEMORY[0x189603F18] arrayWithObjects:v15 count:2];
  __int128 v9 = (void *)acquireAssertion_attributes;
  acquireAssertion_attributes = v8;

  double Helper_x8__OBJC_CLASS___RBSTarget = gotLoadHelper_x8__OBJC_CLASS___RBSTarget(v10);
  uint64_t v13 = objc_msgSend(*(id *)(v12 + 912), "currentProcess", Helper_x8__OBJC_CLASS___RBSTarget);
  uint64_t v14 = (void *)acquireAssertion_target;
  acquireAssertion_target = v13;
}

uint64_t CFURLAuthChallengeGetProtectionSpace(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 24);
}

uint64_t CFURLAuthChallengeGetProposedCredential(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 32);
}

uint64_t CFURLAuthChallengeGetPreviousFailureCount(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 40);
}

uint64_t CFURLAuthChallengeGetError(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 56);
}

uint64_t CFURLAuthChallengeGetFailureResponse(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 48);
}

uint64_t Archiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Archiver(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Archiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Archiver(void *__p)
{
  uint64_t v2 = (const void *)__p[1];
  if (v2) {
    CFRelease(v2);
  }
  operator delete(__p);
}

uint64_t _CFURLAuthChallengeCreateFromArchive(const __CFAllocator *a1, CFTypeRef cf)
{
  cfa[1] = a1;
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0LL;
  }
  cfa[0] = v3;
  cfa[2] = a1;
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(Instance + 80) = 0u;
  *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(Instance + 4_Block_object_dispose((const void *)(v31 - 192), 8) = 0u;
  *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = &gConstantCFStringValueTable[3766];
  *(void *)(Instance + 16) = &off_189C0E8D8;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C0E930;
  if (!URLAuthChallenge::initializeFromPropertyList((URLAuthChallenge *)(Instance + 16), (CFDictionaryRef *)cfa))
  {
    CFRelease((CFTypeRef)Instance);
    uint64_t Instance = 0LL;
  }

  if (cfa[0]) {
    CFRelease(cfa[0]);
  }
  return Instance;
}

void sub_182A3A758( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Dearchiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Dearchiver(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void Dearchiver<URLAuthChallenge,_CFURLAuthChallenge *>::~Dearchiver(void *__p)
{
  uint64_t v2 = (const void *)__p[1];
  if (v2) {
    CFRelease(v2);
  }
  operator delete(__p);
}

uint64_t CFHTTPCookieGetTypeID()
{
  if (CFHTTPCookieGetTypeID::sOnce != -1) {
    dispatch_once(&CFHTTPCookieGetTypeID::sOnce, &__block_literal_global_2212);
  }
  return CFHTTPCookieGetTypeID::sResult;
}

CFTypeID __CFHTTPCookieGetTypeID_block_invoke()
{
  v2[4] = *MEMORY[0x1895F89C0];
  CFLog();
  v1[0] = @"Name";
  v1[1] = @"Value";
  v2[0] = @"name";
  v2[1] = @"value";
  v1[2] = @"Path";
  v1[3] = @"Domain";
  v2[2] = @"/";
  v2[3] = @"fake.com";
  CFTypeID result = CFGetTypeID( +[NSHTTPCookie cookieWithProperties:]( NSHTTPCookie,  "cookieWithProperties:",  [MEMORY[0x189603F68] dictionaryWithObjects:v2 forKeys:v1 count:4]));
  CFHTTPCookieGetTypeID::sResult = result;
  return result;
}

CFArrayRef _CFHTTPParsedCookiesWithResponseHeaderFields( const __CFAllocator *a1, CFDictionaryRef theDict, const __CFURL *a3)
{
  unsigned int Value = CFDictionaryGetValue(theDict, &unk_18C5AF698);
  if (!Value) {
    return CFArrayCreate(a1, 0LL, 0LL, MEMORY[0x189605228]);
  }
  Array = cfTypeCreateArray(a1, Value, 0LL, 0LL, 0LL);
  CookiesWithCookieStrings = _createCookiesWithCookieStrings(a1, Array, a3, 0LL, 1);
  if (Array) {
    CFRelease(Array);
  }
  if (CookiesWithCookieStrings) {
    return CookiesWithCookieStrings;
  }
  else {
    return CFArrayCreate(a1, 0LL, 0LL, MEMORY[0x189605228]);
  }
}

void sub_182A3A9A4(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

__CFArray *_createCookiesWithCookieStrings( const __CFAllocator *a1, const void *a2, const __CFURL *a3, const void *a4, int a5)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  CFMutableStringRef Mutable = CFArrayCreateMutable(a1, 0LL, MEMORY[0x189605228]);
  int theString2 = a5;
  if (a5) {
    uint64_t v11 = SingleCookieParser_parse;
  }
  else {
    uint64_t v11 = CookieParser_parse;
  }
  if (a2)
  {
    CFTypeRef v59 = CFRetain(a2);
    unint64_t Count = CFArrayGetCount((CFArrayRef)a2);
    CFIndex v13 = Count;
    CFIndex v60 = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      BOOL v61 = 0LL;
    }

    else
    {
      if (Count > 0x1E)
      {
        uint64_t v14 = (const void **)malloc(8 * Count);
        BOOL v61 = v14;
        if (!v14)
        {
          CFIndex v63 = 0LL;
          goto LABEL_13;
        }
      }

      else
      {
        uint64_t v14 = (const void **)v62;
        BOOL v61 = (const void **)v62;
      }

      v67.CFIndex location = 0LL;
      v67.CFIndex length = v13;
      CFArrayGetValues((CFArrayRef)a2, v67, v14);
      CFIndex v13 = v60;
    }

    CFIndex v63 = 0LL;
    if (v13 >= 1)
    {
LABEL_13:
      CFIndex v15 = 0LL;
      while (1)
      {
        CFIndex v63 = v15 + 1;
        unsigned int v16 = (const __CFString *)v61[v15];
        CFIndex Length = CFStringGetLength(v16);
        CFRange v18 = (unsigned __int8 *)MEMORY[0x186E12804](a1, Length + 4, 0LL);
        bzero(v18, Length + 4);
        v68.CFIndex location = 0LL;
        v68.CFIndex length = Length;
        CFIndex Bytes = CFStringGetBytes(v16, v68, 0x201u, 0, 0, v18, Length, 0LL);
        int v58 = v18;
        if (Bytes < 1) {
          goto LABEL_37;
        }
        unsigned int v20 = *v18;
        BOOL v21 = v20 >= 0x20 || v20 == 9;
        BOOL v22 = !v21;
        if (v20 != 127 && !v22) {
          break;
        }
LABEL_55:
        CFAllocatorDeallocate(a1, v18);
LABEL_56:
        CFIndex v15 = v63;
        if (v63 >= v60) {
          goto LABEL_57;
        }
      }

      CFIndex v23 = 0LL;
      while (Bytes - 1 != v23)
      {
        unsigned int v24 = v18[v23 + 1];
        BOOL v26 = v24 < 0x20 && v24 != 9;
        ++v23;
        if (v24 == 127 || v26)
        {
          if (v23 >= Bytes) {
            break;
          }
          goto LABEL_55;
        }
      }

void sub_182A3AF90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (v18) {
    operator delete(v18);
  }
  CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&a18);
  _Unwind_Resume(a1);
}

const void *_CFHTTPCookieCreateWithStringAndPartition( const __CFAllocator *a1, uint64_t a2, const __CFURL *a3, const void *a4)
{
  Array = cfTypeCreateArray(a1, a2, 0LL, 0LL, 0LL);
  CookiesWithCookieStrings = _createCookiesWithCookieStrings(a1, Array, a3, a4, 1);
  if (Array) {
    CFRelease(Array);
  }
  if (!CookiesWithCookieStrings) {
    return 0LL;
  }
  if (CFArrayGetCount(CookiesWithCookieStrings) < 1)
  {
    double v10 = 0LL;
  }

  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(CookiesWithCookieStrings, 0LL);
    double v10 = ValueAtIndex;
    if (ValueAtIndex) {
      CFRetain(ValueAtIndex);
    }
  }

  CFRelease(CookiesWithCookieStrings);
  return v10;
}

void sub_182A3B094(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef _CFHTTPCookieCreateCookiesWithResponseMessage( CFAllocatorRef allocator, uint64_t a2, const __CFURL *a3, const void *a4)
{
  if (a2)
  {
    uint64_t v8 = *(_BYTE *)(a2 + 40) ? (os_unfair_lock_s *)(a2 + 16) : 0LL;
    __int128 v9 = HTTPResponseMessage::copyCookiesStrings(v8);
    if (v9)
    {
      double v10 = v9;
      if (CFArrayGetCount(v9) <= 0)
      {
        CFRelease(v10);
      }

      else
      {
        CookiesWithCookieStrings = _createCookiesWithCookieStrings(allocator, v10, a3, a4, 1);
        CFRelease(v10);
        if (CookiesWithCookieStrings) {
          return CookiesWithCookieStrings;
        }
      }
    }
  }

  return CFArrayCreate(allocator, 0LL, 0LL, MEMORY[0x189605228]);
}

id CFHTTPCookieCreateWithProperties(uint64_t a1, uint64_t a2)
{
  return -[NSHTTPCookie _initWithProperties:fromString:]( objc_alloc(&OBJC_CLASS___NSHTTPCookie),  "_initWithProperties:fromString:",  a2,  0LL);
}

BOOL CFHTTPCookie_domainMatches(OpaqueCFHTTPCookie *a1, const __CFURL *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return 1LL;
  }
  uint64_t v4 = -[OpaqueCFHTTPCookie _inner](a1, "_inner");
  __int128 v5 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  if (*v5 < 0x14) {
    return 0LL;
  }
  uint64_t v6 = v5[4];
  if (!(_DWORD)v6) {
    return 0LL;
  }
  uint64_t v7 = *v5;
  uint64_t v8 = (char *)v5 + v6;
  __int128 v9 = (char *)v5 + v7;
  double v10 = v8;
  while (*v10)
  {
    if (++v10 >= v9) {
      return 0LL;
    }
  }

  size_t v12 = strlen(v8);
  if (!v12) {
    return 0LL;
  }
  size_t v13 = v12;
  uint64_t v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  int v31 = off_189C1A178;
  CFIndex v15 = CFStringCreateWithCString(v14, v8, 0x8000100u);
  uint64_t v33 = 0LL;
  uint64_t v34 = 0LL;
  uint64_t v32 = (__CFString *)v15;
  uint64_t Length = CFStringGetLength(v15);
  if (CFStringCompare(@".^filecookies^", v15, 0LL))
  {
    if (!looksLikeDomainName(__CFString const*)::allowedSymbolsSet) {
      looksLikeDomainName(__CFString const*)::allowedSymbolsSet = (uint64_t)CFCharacterSetCreateWithCharactersInString( 0LL,  @"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-_[]:");
    }
    if (Length >= 1)
    {
      CFIndex v17 = 0LL;
      CFIndex v18 = 0LL;
      while (1)
      {
        v30.CFIndex location = 0LL;
        v30.CFIndex length = 0LL;
        v37.CFIndex location = v17;
        v37.CFIndex length = Length;
        int CharacterFromSet = CFStringFindCharacterFromSet( v15,  (CFCharacterSetRef)looksLikeDomainName(__CFString const*)::allowedSymbolsSet,  v37,  0LL,  &v30);
        if (Length != 1 && !CharacterFromSet) {
          break;
        }
        if (v30.location > v17 + 2) {
          break;
        }
        if (v30.location == v17 + 2)
        {
          v38.CFIndex location = v17;
          v38.CFIndex length = 2LL;
          if (CFStringCompareWithOptions(v15, @"--", v38, 0LL)) {
            break;
          }
          v17 += 3LL;
          uint64_t v20 = -3LL;
        }

        else if (v30.location == v17)
        {
          if (v18 == v17 && CFStringGetCharacterAtIndex(v15, v17) == 45) {
            break;
          }
          ++v17;
          uint64_t v20 = -1LL;
        }

        else
        {
          if (CFStringGetCharacterAtIndex(v15, v17) != 46 || v17 && CFStringGetCharacterAtIndex(v15, v17 - 1) == 45) {
            break;
          }
          CFIndex v18 = v17 + 1;
          uint64_t v20 = -2LL;
          v17 += 2LL;
        }

        BOOL v21 = __OFADD__(v20, Length);
        Length += v20;
        if ((Length < 0) ^ v21 | (Length == 0)) {
          goto LABEL_32;
        }
      }

      AutoString::~AutoString((AutoString *)&v31);
      return 0LL;
    }
  }

void sub_182A3B4D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *a46)
{
}

uint64_t CFHTTPCookieCopyProperties(void *a1)
{
  uint64_t v1 = [a1 _inner];
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 40LL))(v1);
}

uint64_t CFHTTPCookieIsHTTPOnly(void *a1)
{
  uint64_t v1 = [a1 _inner];
  uint64_t v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16LL))(v1);
  if (*v2 >= 0xCu) {
    return (v2[2] >> 2) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t CFHTTPCookieGetFlags(void *a1)
{
  uint64_t v1 = [a1 _inner];
  uint64_t v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16LL))(v1);
  if (*v2 >= 0xCu) {
    return v2[2] & 0x7F;
  }
  else {
    return 0LL;
  }
}

uint64_t CFHTTPCookieIsSecure(void *a1)
{
  uint64_t v1 = [a1 _inner];
  uint64_t v2 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 16LL))(v1);
  if (*v2 >= 0xCu) {
    return v2[2] & 1;
  }
  else {
    return 0LL;
  }
}

double CFHTTPCookieGetExpirationTime(void *a1)
{
  if (CFHTTPCookieGetExpirationTime::sOnce != -1) {
    dispatch_once(&CFHTTPCookieGetExpirationTime::sOnce, &__block_literal_global_16);
  }
  uint64_t v2 = [a1 _inner];
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  if (*(_DWORD *)v3 >= 0xCu && (*(_DWORD *)(v3 + 8) & 2) != 0 || *(_DWORD *)v3 < 0x30u) {
    return 0.0;
  }
  else {
    return floor(*(double *)(v3 + 40));
  }
}

uint64_t __CFHTTPCookieGetExpirationTime_block_invoke()
{
  return CFLog();
}

id _makeCookie( const __CFAllocator *a1, const void *a2, const void *a3, const __CFDictionary *a4, const __CFURL *a5, const void *a6)
{
  double v10 = a1;
  CFStringRef theString = 0LL;
  value = 0LL;
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  v41[0] = MEMORY[0x1895F87A8];
  v41[1] = 3221225472LL;
  int64_t v42 = ___makeCookie_block_invoke;
  uint64_t v43 = &__block_descriptor_40_e5_v8__0l;
  CFIndex v44 = Mutable;
  CFDictionarySetValue(Mutable, &unk_18C5AE828, a2);
  CFDictionarySetValue(Mutable, &unk_18C5AEA20, a3);
  if (a4)
  {
    CFIndex Count = CFDictionaryGetCount(a4);
    size_t v13 = (const void **)MEMORY[0x186E12804](v10, 8 * Count, 0LL);
    uint64_t v14 = (const void **)MEMORY[0x186E12804](v10, 8 * Count, 0LL);
    CFDictionaryGetKeysAndValues(a4, v13, v14);
    CFIndex v15 = v10;
    if (Count >= 1)
    {
      unsigned int v16 = (CFStringRef *)v13;
      CFIndex v17 = v14;
      do
      {
        unsigned int CanonicalString = _findCanonicalString(*v16, 3u);
        if (CanonicalString == 571) {
          CFDictionaryAddValue(Mutable, *v16, *v17);
        }
        else {
          CFDictionaryAddValue(Mutable, &gConstantCFStringValueTable[7 * ((CanonicalString >> 20) & 0x3FF)], *v17);
        }
        ++v17;
        ++v16;
        --Count;
      }

      while (Count);
    }

    double v10 = v15;
    CFAllocatorDeallocate(v15, v13);
    CFAllocatorDeallocate(v15, v14);
  }

  if (a5) {
    CFStringRef v19 = CFURLCopyHostName(a5);
  }
  else {
    CFStringRef v19 = 0LL;
  }
  if (!CFDictionaryGetValueIfPresent(Mutable, &unk_18C5AE710, (const void **)&value)
    || !CFStringGetLength((CFStringRef)value))
  {
    if (!v19)
    {
LABEL_22:
      CFDictionarySetValue(Mutable, &unk_18C5AE710, @".^filecookies^");
      goto LABEL_23;
    }

void sub_182A3BC58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
}

void ___makeCookie_block_invoke(uint64_t a1)
{
}

void CookieHostName::~CookieHostName(CookieHostName *this)
{
  *(void *)this = off_189C038A8;
  uint64_t v2 = (char *)*((void *)this + 35);
}

{
  char *v2;
  *(void *)this = off_189C038A8;
  uint64_t v2 = (char *)*((void *)this + 35);
  operator delete(this);
}

uint64_t CookieUtils::looksLikeIPAddress(const __CFString *this, const __CFString *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(this);
  uint64_t result = 0LL;
  if (Length && Length <= 23)
  {
    if (CFStringGetCharacterAtIndex(this, 0LL) == 46
      && Length == 1
      && (*(_DWORD *)(MEMORY[0x1895F8770] + 244LL) & 0x10000) == 0)
    {
      return 0LL;
    }

    else
    {
      uint64_t result = CFStringGetCString(this, buffer, 24LL, 0x600u);
      if ((_DWORD)result)
      {
        uint64_t result = inet_pton(2, buffer, v6);
        if ((_DWORD)result != 1) {
          return inet_pton(30, buffer, v6) == 1;
        }
      }
    }
  }

  return result;
}

BOOL CookieUtils::web_domainMatches_LCC_LCC(CookieUtils *this, const char *a2, const unsigned __int8 *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFIndex v17 = off_189C1A178;
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  CFStringRef theString1 = CFStringCreateWithCString(v4, (const char *)this, 0x8000100u);
  v16[0] = off_189C1A178;
  __int128 v5 = CFStringCreateWithCString(v4, a2, 0x8000100u);
  v16[2] = 0LL;
  v16[3] = 0LL;
  v16[1] = v5;
  if (CFStringCompare(theString1, v5, 0LL) == kCFCompareEqualTo) {
    goto LABEL_17;
  }
  if (CFStringHasSuffix(theString1, @"."))
  {
    CFMutableStringRef MutableCopy = (__CFString *)CFRetain(theString1);
  }

  else
  {
    uint64_t v7 = CFGetAllocator(theString1);
    CFIndex Length = CFStringGetLength(theString1);
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v7, Length + 1, theString1);
    CFStringAppend(MutableCopy, @".");
  }

  if (CFStringHasSuffix(v5, @"."))
  {
    if (v5) {
      __int128 v9 = (__CFString *)CFRetain(v5);
    }
    else {
      __int128 v9 = 0LL;
    }
  }

  else
  {
    double v10 = CFGetAllocator(v5);
    CFIndex v11 = CFStringGetLength(v5);
    __int128 v9 = CFStringCreateMutableCopy(v10, v11 + 1, v5);
    CFStringAppend(v9, @".");
  }

  CFComparisonResult v12 = CFStringCompare(MutableCopy, v9, 0LL);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v12)
  {
    if (CFStringGetCharacterAtIndex(theString1, 0LL) == 46)
    {
      size_t v13 = (const __CFString *)CFRetain(theString1);
    }

    else
    {
      AutoStringWithFormat::AutoStringWithFormat((AutoStringWithFormat *)v21, 0LL, @".%@", theString1);
      if (v22) {
        size_t v13 = (const __CFString *)CFRetain(v22);
      }
      else {
        size_t v13 = 0LL;
      }
      AutoString::~AutoString((AutoString *)v21);
    }

    if (CFStringHasSuffix(v13, v5))
    {
      BOOL v14 = !isTopLevelDomain(v5, 1);
      if (!v13) {
        goto LABEL_27;
      }
      goto LABEL_26;
    }

    BOOL v14 = 0LL;
    if (v13) {
LABEL_26:
    }
      CFRelease(v13);
  }

  else
  {
LABEL_17:
    BOOL v14 = 1LL;
  }

void sub_182A3C098( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

uint64_t _cookiePathDomainAndNameComparator(void *a1, void *a2, void *a3)
{
  uint64_t v4 = objc_msgSend(a1, "_inner", a3);
  uint64_t v5 = [a2 _inner];
  uint64_t v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  if (*v6 >= 0x1C && (v7 = v6[6], (_DWORD)v7) && (uint64_t v8 = *v6, v8 > v7))
  {
    unint64_t v9 = (unint64_t)v6 + v7;
    double v10 = (char *)v6 + v8;
    CFIndex v11 = (_BYTE *)v9;
    while (*v11)
    {
      if (++v11 >= v10) {
        goto LABEL_7;
      }
    }
  }

  else
  {
LABEL_7:
    unint64_t v9 = 0LL;
  }

  CFComparisonResult v12 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16LL))(v5);
  if (*v12 >= 0x1C && (uint64_t v13 = v12[6], (_DWORD)v13) && (v14 = *v12, v14 > v13))
  {
    unint64_t v15 = (unint64_t)v12 + v13;
    unsigned int v16 = (char *)v12 + v14;
    CFIndex v17 = (_BYTE *)v15;
    while (*v17)
    {
      if (++v17 >= v16) {
        goto LABEL_14;
      }
    }
  }

  else
  {
LABEL_14:
    unint64_t v15 = 0LL;
  }

  if (v9)
  {
    int64_t v18 = strlen((const char *)v9);
    if (v15)
    {
LABEL_17:
      int64_t v19 = strlen((const char *)v15);
      goto LABEL_20;
    }
  }

  else
  {
    int64_t v18 = 0LL;
    if (v15) {
      goto LABEL_17;
    }
  }

  int64_t v19 = 0LL;
LABEL_20:
  if (v18 != v19)
  {
    if (v18 > v19) {
      return -1LL;
    }
    else {
      return 1LL;
    }
  }

  if (v9 | v15)
  {
    if (!v9 && v15) {
      return 1LL;
    }
    if (v9 && !v15) {
      return -1LL;
    }
    int v45 = strcmp((const char *)v9, (const char *)v15);
    if (v45 < 0) {
      return -1LL;
    }
    if (v45) {
      return 1LL;
    }
  }

  uint64_t v20 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  if (*v20 >= 0x14 && (uint64_t v21 = v20[4], (_DWORD)v21) && (v22 = *v20, v22 > v21))
  {
    unint64_t v23 = (unint64_t)v20 + v21;
    CFRange v24 = (char *)v20 + v22;
    int v25 = (_BYTE *)v23;
    while (*v25)
    {
      if (++v25 >= v24) {
        goto LABEL_28;
      }
    }
  }

  else
  {
LABEL_28:
    unint64_t v23 = 0LL;
  }

  int v26 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16LL))(v5);
  if (*v26 >= 0x14 && (uint64_t v27 = v26[4], (_DWORD)v27) && (v28 = *v26, v28 > v27))
  {
    unint64_t v29 = (unint64_t)v26 + v27;
    uint64_t v30 = (char *)v26 + v28;
    int v31 = (_BYTE *)v29;
    while (*v31)
    {
      if (++v31 >= v30) {
        goto LABEL_35;
      }
    }
  }

  else
  {
LABEL_35:
    unint64_t v29 = 0LL;
  }

  if (!(v23 | v29)) {
    goto LABEL_37;
  }
  if (!v23 && v29) {
    return 1LL;
  }
  if (v23 && !v29) {
    return -1LL;
  }
  int v46 = strcmp((const char *)v23, (const char *)v29);
  if (v46 < 0) {
    return -1LL;
  }
  if (v46) {
    return 1LL;
  }
LABEL_37:
  CFStringRef v32 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  if (*v32 >= 0x18 && (uint64_t v33 = v32[5], (_DWORD)v33) && (v34 = *v32, v34 > v33))
  {
    unint64_t v35 = (unint64_t)v32 + v33;
    uint64_t v36 = (char *)v32 + v34;
    id v37 = (_BYTE *)v35;
    while (*v37)
    {
      if (++v37 >= v36) {
        goto LABEL_43;
      }
    }
  }

  else
  {
LABEL_43:
    unint64_t v35 = 0LL;
  }

  CFRange v38 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16LL))(v5);
  if (*v38 >= 0x18 && (v39 = v38[5], (_DWORD)v39) && (uint64_t v40 = *v38, v40 > v39))
  {
    unint64_t v41 = (unint64_t)v38 + v39;
    int64_t v42 = (char *)v38 + v40;
    uint64_t v43 = (_BYTE *)v41;
    while (*v43)
    {
      if (++v43 >= v42) {
        goto LABEL_50;
      }
    }
  }

  else
  {
LABEL_50:
    unint64_t v41 = 0LL;
  }

  if (!(v35 | v41)) {
    return 0LL;
  }
  if (!v35 && v41) {
    return 1LL;
  }
  if (v35 && !v41) {
    return -1LL;
  }
  int v47 = strcmp((const char *)v35, (const char *)v41);
  if (v47 < 0) {
    return -1LL;
  }
  else {
    return v47 != 0;
  }
}

uint64_t FilePathStorage<unsigned char>::FilePathStorage( uint64_t a1, CFURLRef url, int a3, int a4, Boolean a5)
{
  *(_BYTE *)a1 = CFURLGetFileSystemRepresentation(url, a5, (UInt8 *)(a1 + 1), 1024LL);
  *(_DWORD *)(a1 + 102_Block_object_dispose((const void *)(v31 - 192), 8) = a3;
  unint64_t v9 = (const __CFURL *)CFCopyHomeDirectoryURLForUser();
  if (!v9)
  {
    *(_DWORD *)(a1 + 10std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = a4;
    return a1;
  }

  double v10 = v9;
  CFIndex v11 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x189604DB0], v9, @"Library/Cookies", 1u);
  CFComparisonResult v12 = CFGetAllocator(url);
  CFStringRef PathComponent = CFURLCreateCopyDeletingLastPathComponent(v12, url);
  if (PathComponent && v11)
  {
    uint64_t v14 = CFURLGetString(v11);
    unint64_t v15 = CFURLGetString(PathComponent);
    if (CFStringCompare(v14, v15, 1uLL)) {
      int v16 = a4;
    }
    else {
      int v16 = 1;
    }
    *(_DWORD *)(a1 + 10std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v16;
    goto LABEL_10;
  }

  *(_DWORD *)(a1 + 10std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = a4;
  if (v11) {
LABEL_10:
  }
    CFRelease(v11);
  if (PathComponent) {
    CFRelease(PathComponent);
  }
  CFRelease(v10);
  return a1;
}

CFStringRef formCopyProperty(__CFReadStream *a1, CFTypeRef cf1, void *a3)
{
  if (!CFEqual(cf1, &unk_18C5AEEB8)) {
    return 0LL;
  }
  uint64_t v5 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v5, 0LL, @"%lld", a3[5]);
}

uint64_t formSetProperty(__CFReadStream *a1, CFTypeRef cf1, const __CFNumber *a3, void *a4)
{
  uint64_t result = CFEqual(cf1, (CFTypeRef)*MEMORY[0x1896051D8]);
  if ((_DWORD)result)
  {
    uint64_t valuePtr = 0LL;
    CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr);
    a4[6] = valuePtr;
    return 1LL;
  }

  return result;
}

uint64_t formUnschedule(__CFReadStream *a1, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode, void *a4)
{
  uint64_t v7 = (__CFReadStream *)a4[2];
  if (v7) {
    CFReadStreamUnscheduleFromRunLoop(v7, runLoop, runLoopMode);
  }
  uint64_t result = (*(uint64_t (**)(void, CFRunLoopRef, CFRunLoopMode))(*(void *)*a4 + 64LL))( *a4,  runLoop,  runLoopMode);
  *a4 = result;
  return result;
}

void __CFURLCache::~__CFURLCache(__CFURLCache *this)
{
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  dispatch_object_s *v5;
  const void *v6;
  const void *v7;
  uint64_t v8;
  dispatch_queue_s *v9;
  sqlite3 *v10;
  std::__shared_weak_count *v11;
  void block[5];
  *(void *)this = off_189C03910;
  __CFURLCache::PurgeMemoryCache(this);
  uint64_t v2 = (const void *)*((void *)this + 27);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 27) = 0LL;
  }

  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  CFSetRemoveAllValues(*((CFMutableSetRef *)this + 56));
  uint64_t v3 = (const void *)*((void *)this + 56);
  if (v3) {
    CFRelease(v3);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 376));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 376));
  uint64_t v4 = (const void *)*((void *)this + 4);
  if (v4)
  {
    _Block_release(v4);
    *((void *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  }

  uint64_t v5 = (dispatch_object_s *)*((void *)this + 3);
  if (v5)
  {
    dispatch_release(v5);
    *((void *)this + 3) = 0LL;
  }

  if (*((void *)this + 65))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 65));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
    uint64_t v6 = (const void *)*((void *)this + 65);
    if (v6) {
      CFRelease(v6);
    }
    *((void *)this + 65) = 0LL;
  }

  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 456));
  if (*((void *)this + 67))
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 552));
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 67));
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 552));
    uint64_t v7 = (const void *)*((void *)this + 67);
    if (v7) {
      CFRelease(v7);
    }
    *((void *)this + 67) = 0LL;
  }

  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 552));
  uint64_t v8 = *((void *)this + 16);
  *((void *)this + 16) = 0LL;
  if (v8)
  {
    unint64_t v9 = (dispatch_queue_s *)*((void *)this + 17);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZN12__CFURLCacheD2Ev_block_invoke;
    block[3] = &unk_189C1A548;
    block[4] = v8;
    dispatch_async(v9, block);
  }

  dispatch_release(*((dispatch_object_t *)this + 17));

  double v10 = (sqlite3 *)*((void *)this + 78);
  if (v10) {
    sqlite3_close(v10);
  }
  std::deque<__CFURLCacheNode *>::~deque[abi:nn180100]((uint64_t)this + 264);
  std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::~__hash_table((uint64_t)this + 224);
  *((void *)this + 6) = off_189C12668;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  CFIndex v11 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_182A3C9A8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 4_Block_object_dispose((const void *)(v31 - 192), 8) = off_189C12668;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 56));
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t __CFURLCache::PurgeMemoryCache(__CFURLCache *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 312);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 312));
  for (CFIndex i = (void *)*((void *)this + 30); i; CFIndex i = (void *)*i)
  {
    NodeFromHashMap = __CFURLCache::GetNodeFromHashMap(this, i[2]);
    if (NodeFromHashMap) {
      (*(void (**)(void *))(*NodeFromHashMap + 8LL))(NodeFromHashMap);
    }
  }

  if (*((void *)this + 31))
  {
    uint64_t v5 = (void *)*((void *)this + 30);
    if (v5)
    {
      do
      {
        uint64_t v6 = (void *)*v5;
        operator delete(v5);
        uint64_t v5 = v6;
      }

      while (v6);
    }

    *((void *)this + 30) = 0LL;
    uint64_t v7 = *((void *)this + 29);
    if (v7)
    {
      for (uint64_t j = 0LL; j != v7; ++j)
        *(void *)(*((void *)this + 28) + 8 * j) = 0LL;
    }

    *((void *)this + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  }

  unint64_t v9 = (void **)*((void *)this + 34);
  uint64_t v10 = *((void *)this + 35);
  *((void *)this + 3_Block_object_dispose((const void *)(v31 - 192), 8) = 0LL;
  unint64_t v11 = v10 - (void)v9;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v9);
      uint64_t v12 = *((void *)this + 35);
      unint64_t v9 = (void **)(*((void *)this + 34) + 8LL);
      *((void *)this + 3os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v9;
      unint64_t v11 = v12 - (void)v9;
    }

    while (v11 > 0x10);
  }

  if (v11 >> 3 == 1)
  {
    uint64_t v13 = 256LL;
    goto LABEL_18;
  }

  if (v11 >> 3 == 2)
  {
    uint64_t v13 = 512LL;
LABEL_18:
    *((void *)this + 37) = v13;
  }

  *((void *)this + 1_Block_object_dispose((const void *)(v31 - 192), 8) = 0LL;
  return pthread_mutex_unlock(v2);
}

void ___ZN12__CFURLCacheD2Ev_block_invoke(uint64_t a1)
{
}

uint64_t std::deque<__CFURLCacheNode *>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8LL);
      *(void *)(a1 + _Block_object_dispose((const void *)(v31 - 192), 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256LL;
    goto LABEL_7;
  }

  if (v5 == 2)
  {
    uint64_t v6 = 512LL;
LABEL_7:
    *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v6;
  }

  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }

    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::find<unsigned long>( void *a1, uint64_t a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0LL;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = (int)a2;
  }

  else
  {
    unint64_t v4 = (v2 - 1) & (int)a2;
  }

  unint64_t v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0LL;
  }
  uint64_t result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == (int)a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }

      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= v2) {
            v7 %= v2;
          }
        }

        else
        {
          v7 &= v2 - 1;
        }

        if (v7 != v4) {
          return 0LL;
        }
      }

      uint64_t result = (void *)*result;
    }

    while (result);
  }

  return result;
}

uint64_t _URLCacheRegisterClass(void)
{
  uint64_t result = _CFRuntimeRegisterClass();
  kCFURLCacheCFTypeID TypeID = result;
  return result;
}

uint64_t ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2331(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

uint64_t _CFURLCacheDeallocate(const void *a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)a1 + 16);
}

BOOL _CFURLCacheEqual(void *a1, void *a2)
{
  return a1[2] == a2[2];
}

uint64_t _CFURLCacheHash(void *a1)
{
  return *(void *)(a1[2] + 208LL);
}

CFStringRef _CFURLCacheCopyDescription(const void *a1)
{
  unint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0LL, @"<CFURLCache %p [%p]>", a1, v3);
}

uint64_t _CachedURLResponseRegisterClass(void)
{
  uint64_t result = _CFRuntimeRegisterClass();
  kCFCachedURLResponseCFTypeID TypeID = result;
  return result;
}

BOOL _CFCachedURLResponseEqual(void *a1, void *a2)
{
  return a1[2] == a2[2];
}

uint64_t _CFCachedURLResponseHash(void *a1)
{
  return *(void *)(a1[2] + 64LL);
}

CFStringRef _CFCachedURLResponseCopyDescription(const void *a1)
{
  unint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0LL, @"<CFCachedURLResponse %p [%p]>", a1, v3);
}

uint64_t CFCachedURLResponseCopyWrappedRequest(const _CFCachedURLResponse *a1)
{
  if (!a1) {
    return 0LL;
  }
  var1 = a1->var1;
  unint64_t v2 = (os_unfair_lock_s *)((char *)var1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)var1 + 22);
  CFAllocatorRef v3 = (void *)*((void *)var1 + 14);
  os_unfair_lock_unlock(v2);
  if (!v3) {
    return 0LL;
  }
  CFGetAllocator(v3);
  return [v3 copy];
}

void ___ZN12__CFURLCache13AddCacheTask0ERNSt3__110unique_ptrI16__CFURLCacheNodeNS0_14default_deleteIS2_EEEE_block_invoke( uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  __retainStorageAssertion(*(void **)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = *(id *)(a1 + 48);
  if (!v2) {
    goto LABEL_47;
  }
  BOOL v32 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 28));
  if ((-[NSURLStorageURLCacheDB openAndPrepareWriteCacheDB_NoLock]((id)v2, v4) & 1) == 0)
  {
LABEL_46:
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 28));
    goto LABEL_47;
  }

  if (!v3)
  {
    -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
    goto LABEL_46;
  }

  unint64_t v5 = (__CFString *)v3;
  uint64_t v6 = _ExtractCStringfromCFStringRef(v5, &v32);
  if (!v6)
  {

LABEL_22:
    -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
    -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
    goto LABEL_46;
  }

  unint64_t v7 = -[NSURLStorageURLCacheDB getEntryIDandReceiverDataForRequestKey:]((sqlite3_stmt **)v2, v6);
  uint64_t v8 = v7;
  if (v7)
  {
    sqlite3_int64 v9 = *(void *)v7;
    if (*(void *)v7)
    {
      if (v7[20])
      {
        uint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        unint64_t v11 = (UInt8 *)*((void *)v7 + 1);
        CFStringRef v13 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x189604DB0], v11, *((int *)v7 + 4), 0x8000100u, 0);
        if (v13)
        {
          Property = (const __CFString *)objc_getProperty((id)v2, v12, 160LL, 1);
          FS2 = _CFURLCacheCreateFS2(Property);
          int v31 = FS2;
          if (FS2)
          {
            int v16 = CFStringCreateWithFormat(v10, 0LL, @"%@/%@", *((void *)FS2 + 10), v13);
            CFIndex v17 = v16;
            if (v16)
            {
              BOOL v33 = 0;
              int64_t v18 = _ExtractCStringfromCFStringRef(v16, &v33);
              CFTypeRef cf = v17;
              if (v18)
              {
                __p = v18;
                if (unlink(v18) == -1)
                {
                  if (CFNLog::onceToken != -1) {
                    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
                  }
                  uint64_t v22 = (os_log_s *)CFNLog::logger;
                  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                  {
                    int v28 = *__error();
                    *(_DWORD *)buf = 136315394;
                    unint64_t v35 = __p;
                    __int16 v36 = 1024;
                    int v37 = v28;
                    _os_log_error_impl( &dword_18298D000,  v22,  OS_LOG_TYPE_ERROR,  "unlink of file %s failed.  Errno=%{errno}d",  buf,  0x12u);
                  }

                  int v19 = 0;
                }

                else
                {
                  int v19 = 1;
                }

                if (v33) {
                  operator delete[](__p);
                }
              }

              else
              {
                if (CFNLog::onceToken != -1) {
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
                }
                uint64_t v21 = (os_log_s *)CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)buf = 0;
                  _os_log_error_impl( &dword_18298D000,  v21,  OS_LOG_TYPE_ERROR,  "purgeItemFromFileSystemStoreForKey - unable to determine path to file for unlink.",  buf,  2u);
                }

                int v19 = 0;
              }

              CFRelease(cf);
              if (v19) {
                -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk]((void *)v2, v23);
              }
            }

            (*(void (**)(CFURLCacheFS *))(*(void *)v31 + 8LL))(v31);
          }

          CFRelease(v13);
        }
      }

      else
      {
        unint64_t v11 = (UInt8 *)*((void *)v7 + 1);
      }

      if (v11) {
        free(v11);
      }
      free(v8);
      sqlite3_reset(*(sqlite3_stmt **)(v2 + 96));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 112), 1, v9))
      {
        if (v32) {
          operator delete[](v6);
        }
LABEL_45:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 112));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_46;
      }

      int v25 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 112));
      if (v25 && v25 != 101)
      {
        if (v32) {
          operator delete[](v6);
        }
        goto LABEL_45;
      }

      sqlite3_reset(*(sqlite3_stmt **)(v2 + 112));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 120), 1, v9))
      {
        if (v32) {
          operator delete[](v6);
        }
LABEL_53:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 120));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_46;
      }

      int v26 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 120));
      if (v26 && v26 != 101)
      {
        if (v32) {
          operator delete[](v6);
        }
        goto LABEL_53;
      }

      sqlite3_reset(*(sqlite3_stmt **)(v2 + 120));
      if (sqlite3_bind_int64(*(sqlite3_stmt **)(v2 + 128), 1, v9))
      {
        if (v32) {
          operator delete[](v6);
        }
LABEL_62:
        sqlite3_reset(*(sqlite3_stmt **)(v2 + 128));

        -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
        -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
        goto LABEL_46;
      }

      int v27 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]((void *)v2, *(sqlite3_stmt **)(v2 + 128));
      if (v27 && v27 != 101)
      {
        if (v32) {
          operator delete[](v6);
        }
        goto LABEL_62;
      }

      sqlite3_reset(*(sqlite3_stmt **)(v2 + 128));

      if (v32) {
        operator delete[](v6);
      }
      goto LABEL_22;
    }
  }

  if (v32) {
    operator delete[](v6);
  }

  -[NSURLStorageURLCacheDB _finalizeDBDeleteStatements]((sqlite3_stmt **)v2);
  -[NSURLStorageURLCacheDB _finalizeDBInsertUpdateStatements]((sqlite3_stmt **)v2);
  -[NSURLStorageURLCacheDB _closeDBWriteConnections](v2);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 28));
  if (v8)
  {
    uint64_t v20 = (void *)v8[1];
    if (v20) {
      free(v20);
    }
    free(v8);
  }

void sub_182A3D384(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN12__CFURLCache13logCacheEventE19CFURLCacheEventTypePK13_CFURLRequest_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 32LL);
  if (v2) {
    (*(void (**)(uint64_t, void, void, void, void))(v2 + 16))( v2,  *(unsigned int *)(a1 + 56),  *(void *)(a1 + 40),  *(void *)(a1 + 48),  0LL);
  }
  id v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  unint64_t v4 = *(const void **)(a1 + 48);
  if (v4) {
    CFRelease(v4);
  }
}

void *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,__CFURLCacheNode **,__CFURLCacheNode **,std::__deque_iterator<__CFURLCacheNode *,__CFURLCacheNode **,__CFURLCacheNode *&,__CFURLCacheNode ***,long,512l>,0>( void *result, _BYTE *__src, _BYTE *a3, void *a4, char *__dst)
{
  uint64_t v6 = a4;
  uint64_t v8 = result;
  if (__src != a3)
  {
    sqlite3_int64 v9 = __src;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      if ((a3 - v9) >> 3 >= v11 >> 3) {
        uint64_t v12 = v11 >> 3;
      }
      else {
        uint64_t v12 = (a3 - v9) >> 3;
      }
      if (v12) {
        uint64_t result = memmove(__dst, v9, 8 * v12);
      }
      v9 += 8 * v12;
      if (v9 == a3) {
        break;
      }
      CFStringRef v13 = (char *)v6[1];
      ++v6;
      uint64_t v10 = v13;
      __dst = v13;
    }

    __dst += 8 * v12;
    if ((char *)(*v6 + 4096LL) == __dst)
    {
      uint64_t v14 = (char *)v6[1];
      ++v6;
      __dst = v14;
    }
  }

  *uint64_t v8 = a3;
  v8[1] = v6;
  _DWORD v8[2] = __dst;
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<__CFURLCacheNode **,std::__deque_iterator<__CFURLCacheNode *,__CFURLCacheNode **,__CFURLCacheNode *&,__CFURLCacheNode ***,long,512l>,0>( void *result, char *a2, char *a3, void *a4, char *a5)
{
  uint64_t v6 = a4;
  uint64_t v8 = result;
  if (a2 == a3)
  {
    sqlite3_int64 v9 = a2;
  }

  else
  {
    sqlite3_int64 v9 = a3;
    uint64_t v10 = *a4;
    uint64_t v11 = a3;
    while (1)
    {
      uint64_t v12 = (uint64_t)&a5[-v10];
      if ((v11 - a2) >> 3 >= v12 >> 3) {
        uint64_t v13 = v12 >> 3;
      }
      else {
        uint64_t v13 = (v11 - a2) >> 3;
      }
      v11 -= 8 * v13;
      a5 -= 8 * v13;
      if (v13) {
        uint64_t result = memmove(a5, v11, 8 * v13);
      }
      if (v11 == a2) {
        break;
      }
      uint64_t v14 = *--v6;
      uint64_t v10 = v14;
      a5 = (char *)(v14 + 4096);
    }

    if ((char *)(*v6 + 4096LL) == a5)
    {
      unint64_t v15 = (char *)v6[1];
      ++v6;
      a5 = v15;
    }
  }

  *uint64_t v8 = v9;
  v8[1] = v6;
  _DWORD v8[2] = a5;
  return result;
}

void ___ZN12__CFURLCache23CreateAndStoreCacheNodeEP16__CFURLCacheNodePK20_CFCachedURLResponsePK10__CFStringPK13_CFURLRequestPKvbRb_block_invoke( uint64_t a1)
{
  uint64_t v172 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 16LL);
  id v3 = (CFAllocatorRef *)MEMORY[0x189604DB0];
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 552));
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 16LL);
    unint64_t v5 = *(void **)(v4 + 536);
    *(void *)(v4 + 54os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v5;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 16LL) + 536LL) = CFDictionaryCreateMutable( *v3,  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(*(void *)(a1 + 40) + 16LL) + 552LL));
  }

  else
  {
    unint64_t v5 = 0LL;
  }

  if ([v5 count])
  {
    __retainStorageAssertion(*(void **)(*(void *)(*(void *)(a1 + 40) + 16LL) + 136LL));
    uint64_t v6 = *(os_unfair_lock_s **)(a1 + 32);
    if (v6)
    {
      os_unfair_lock_lock(v6 + 7);
      uint64_t v8 = *(void *)(a1 + 32);
      if (v8)
      {
        -[NSURLStorageURLCacheDB openAndPrepareWriteCacheDB_NoLock](*(id *)(a1 + 32), v7);
        -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v8,  "BEGIN IMMEDIATE TRANSACTION;",
          *(sqlite3 **)(v8 + 16),
          1);
      }
    }

    __int128 v156 = 0u;
    __int128 v157 = 0u;
    __int128 v154 = 0u;
    __int128 v155 = 0u;
    uint64_t v10 = [v5 countByEnumeratingWithState:&v154 objects:v163 count:16];
    if (v10)
    {
      uint64_t v153 = *(void *)v155;
      allocator = *v3;
      contentsDeallocator = (const __CFAllocator *)*MEMORY[0x189604DC8];
      do
      {
        uint64_t v12 = 0LL;
        uint64_t v131 = v10;
        do
        {
          if (*(void *)v155 != v153) {
            objc_enumerationMutation(v5);
          }
          uint64_t v13 = *(void **)(*((void *)&v154 + 1) + 8 * v12);
          uint64_t v14 = *(void *)(a1 + 32);
          uint64_t v15 = objc_msgSend(v5, "objectForKeyedSubscript:", v13, v128, Property);
          uint64_t v16 = *(void *)(a1 + 40);
          id v18 = v13;
          if (v14)
          {
            BOOL v159 = 0;
            if (*(uint64_t *)(v14 + 176) >= 1)
            {
              if (-[NSURLStorageURLCacheDB openAndPrepareWriteCacheDB_NoLock]((id)v14, v17))
              {
                int v19 = (const __CFString *)v18;
                CFIndex v152 = (CFURLCacheFS *)v19;
                if (!v15 || (v19 ? (BOOL v20 = *(void *)(v15 + 16) == 0LL) : (BOOL v20 = 1), v20))
                {
                  uint64_t v21 = 0LL;
                  uint64_t v22 = 0LL;
                  goto LABEL_84;
                }

                uint64_t v137 = v16;
                CFIndex v148 = _ExtractCStringfromCFStringRef(v19, &v159);
                uint64_t v23 = *(void *)(v15 + 16);
                sqlite3_int64 v140 = *(void *)(v23 + 64);
                int v139 = *(_DWORD *)(v23 + 56);
                double v24 = *(const __CFData **)(v23 + 48);
                if (v24)
                {
                  int Length = CFDataGetLength(v24);
                  uint64_t v23 = *(void *)(v15 + 16);
                  int v25 = *(const __CFData **)(v23 + 48);
                  if (v25)
                  {
                    BytePtr = CFDataGetBytePtr(v25);
                    uint64_t v23 = *(void *)(v15 + 16);
                    goto LABEL_28;
                  }
                }

                else
                {
                  int Length = 0;
                }

                BytePtr = 0LL;
LABEL_28:
                os_unfair_lock_lock((os_unfair_lock_t)(v23 + 88));
                int v26 = *(const void **)(v23 + 72);
                if (v26) {
                  theData = (const __CFData *)CFRetain(v26);
                }
                else {
                  theData = CopyAllDataFromDataArray(*(const __CFArray **)(v23 + 80));
                }
                os_unfair_lock_unlock((os_unfair_lock_t)(v23 + 88));
                if (theData)
                {
                  CFTypeRef cf = (char *)CFDataGetLength(theData);
                  CFAutorelease(theData);
                }

                else
                {
                  CFTypeRef cf = 0LL;
                }

                int v27 = *(void **)(*(void *)(v15 + 16) + 32LL);
                if (v27)
                {
                  CFDictionaryRef v28 = URLResponse::copyPropertyList((URLResponse *)[v27 _inner], allocator);
                  Data = CFPropertyListCreateData(allocator, v28, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
                  uint64_t v30 = Data;
                  if (Data)
                  {
                    CFIndex v135 = CFDataGetBytePtr(Data);
                    *(void *)n = CFDataGetLength(v30);
                    CFAutorelease(v30);
                    int v31 = &cf[*(void *)n];
                  }

                  else
                  {
                    n[0] = 0;
                    CFIndex v135 = 0LL;
                    int v31 = cf;
                  }

                  CFIndex v149 = v31;
                  if (v28) {
                    CFRelease(v28);
                  }
                }

                else
                {
                  n[0] = 0;
                  CFIndex v135 = 0LL;
                  CFIndex v149 = cf;
                }

                uint64_t v32 = *(void *)(v15 + 16);
                BOOL v33 = (os_unfair_lock_s *)(v32 + 88);
                os_unfair_lock_lock((os_unfair_lock_t)(v32 + 88));
                uint64_t v34 = *(void **)(v32 + 112);
                os_unfair_lock_unlock(v33);
                CFPropertyListRef plist = 0LL;
                if (v34)
                {
                  __int16 v36 = (URLRequest *)[v34 _inner];
                  values = 0LL;
                  URLRequest::createArchiveList( v36,  allocator,  &valuePtr,  (const void ***)&values,  &numValues,  (const __CFDictionary **)&plist);
                  int v37 = values;
                  uint64_t v38 = values[1];
                  if (v38)
                  {
                    v37[1] = (void *)_CFURLCopyPropertyListRepresentation();
                    CFRelease(v38);
                  }

                  uint64_t v39 = v37[4];
                  if (v39)
                  {
                    v37[4] = (void *)_CFURLCopyPropertyListRepresentation();
                    CFRelease(v39);
                  }

                  CFIndex v40 = numValues;
                  CFIndex v41 = numValues - 1;
                  if (numValues < 1)
                  {
                    CFArrayRef v43 = CFArrayCreate(allocator, (const void **)v37, numValues, MEMORY[0x189605228]);
                  }

                  else
                  {
                    do
                    {
                      if (!v37[v41]) {
                        v37[v41] = @"__CFURLRequestNullTokenString__";
                      }
                      unint64_t v42 = v41-- + 1;
                    }

                    while (v42 > 1);
                    CFArrayRef v43 = CFArrayCreate(allocator, (const void **)v37, v40, MEMORY[0x189605228]);
                    do
                    {
                      CFIndex v44 = (__CFString *)v37[v40 - 1];
                      if (v44 != @"__CFURLRequestNullTokenString__") {
                        CFRelease(v44);
                      }
                      --v40;
                    }

                    while ((unint64_t)(v40 + 1) > 1);
                    uint64_t v10 = v131;
                  }

                  CFAllocatorDeallocate(allocator, v37);
                  if (CFPropertyListIsValid(v43, kCFPropertyListXMLFormat_v1_0))
                  {
                    if (v43)
                    {
                      keys = @"Version";
                      uint64_t v166 = (uint64_t)@"Array";
                      v164[0] = CFNumberCreate(allocator, kCFNumberCFIndexType, &valuePtr);
                      v164[1] = v43;
                      CFDictionaryRef v45 = CFDictionaryCreate( allocator,  (const void **)&keys,  (const void **)v164,  2LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
                      CFRelease(v164[0]);
                      CFRelease(v43);
                      goto LABEL_62;
                    }
                  }

                  else
                  {
                    CFRelease(v43);
                  }

                  CFDictionaryRef v45 = 0LL;
LABEL_62:
                  int v46 = CFPropertyListCreateData(allocator, v45, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
                  int v47 = v46;
                  if (v46)
                  {
                    int v134 = CFDataGetBytePtr(v46);
                    CFIndex v141 = CFDataGetLength(v47);
                    CFAutorelease(v47);
                    v149 += v141;
                    if (!v45)
                    {
LABEL_67:
                      CFRange v48 = (CFURLCacheFS *)plist;
                      if (plist)
                      {
                        if (!CFPropertyListIsValid(plist, kCFPropertyListBinaryFormat_v1_0))
                        {
                          unint64_t v128 = v48;
                          CFLog();
                          goto LABEL_82;
                        }

                        unint64_t v49 = CFPropertyListCreateData(allocator, v48, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
                        CFIndex v50 = v49;
                        if (v49)
                        {
                          unint64_t v132 = CFDataGetBytePtr(v49);
                          CFIndex v138 = CFDataGetLength(v50);
                          CFAutorelease(v50);
                          v149 += v138;
                        }

                        else
                        {
                          CFIndex v138 = 0LL;
                          unint64_t v132 = 0LL;
                        }

                        unsigned int Value = (const __CFString *)CFDictionaryGetValue(v48, @"_kCFURLCachePartitionKey");
                        CFRelease(v48);
LABEL_75:
                        int v52 = *(sqlite3_stmt **)(v14 + 40);
                        if (!v52)
                        {
                          unint64_t v128 = *(CFURLCacheFS **)(v14 + 16);
                          id Property = objc_getProperty((id)v14, v35, 160LL, 1);
                          CFLog();
                          goto LABEL_82;
                        }

                        CFIndex v53 = (CFURLCacheFS *)sqlite3_bind_int(v52, 1, 0);
                        if ((_DWORD)v53)
                        {
                          unint64_t v128 = v53;
                          id Property = v152;
                          CFLog();
                          goto LABEL_82;
                        }

                        if (sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 40), 2, v140)
                          || sqlite3_bind_int(*(sqlite3_stmt **)(v14 + 40), 3, v139)
                          || !v148
                          || sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 40), 4, v148, -1, 0LL))
                        {
LABEL_81:
                          unint64_t v128 = v152;
                          CFLog();
                          goto LABEL_82;
                        }

                        if (Value)
                        {
                          LOBYTE(keys) = 0;
                          CStringfromCFStringRef = _ExtractCStringfromCFStringRef(Value, (BOOL *)&keys);
                          if (CStringfromCFStringRef)
                          {
                            if (sqlite3_bind_text( *(sqlite3_stmt **)(v14 + 40),  5,  CStringfromCFStringRef,  -1,  (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL))
                            {
                              if ((_BYTE)keys) {
                                operator delete[](CStringfromCFStringRef);
                              }
                              goto LABEL_81;
                            }

                            if ((_BYTE)keys) {
                              operator delete[](CStringfromCFStringRef);
                            }
                          }
                        }

                        else if (sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 40), 5, 0LL, 0, 0LL))
                        {
                          goto LABEL_81;
                        }

                        int v58 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]( (void *)v14,  *(sqlite3_stmt **)(v14 + 40));
                        sqlite3_reset(*(sqlite3_stmt **)(v14 + 40));
                        if (v58)
                        {
                          if (v58 != 19)
                          {
                            if (v58 == 101) {
                              goto LABEL_113;
                            }
LABEL_82:
                            uint64_t v21 = 0LL;
LABEL_83:
                            uint64_t v22 = (char *)v148;
LABEL_84:
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 40));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 48));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 56));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 72));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 32));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 64));
                            if (v22 && v159) {
                              operator delete[](v22);
                            }
                            if (v152) {

                            }
                            if (v21)
                            {
                              uint64_t v55 = (void *)v21[1];
                              if (v55) {
                                free(v55);
                              }
                              free(v21);
                            }

                            unint64_t v56 = *(void *)(v14 + 144) + 1LL;
                            *(void *)(v14 + 14os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v56;
                            if (v56 >= 0xBB9)
                            {
                              *(void *)(v14 + 14os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
                              -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk]((void *)v14, v54);
                              -[NSURLStorageURLCacheDB updateSQLiteDBCacheUsageOnDisk]((void *)v14);
                            }

                            goto LABEL_95;
                          }

                          CFRange v69 = (sqlite3_int64 *)-[NSURLStorageURLCacheDB getEntryIDandReceiverDataForRequestKey:]( (sqlite3_stmt **)v14,  v148);
                          uint64_t v21 = v69;
                          if (!v69) {
                            goto LABEL_83;
                          }
                          sqlite3_int64 v70 = *v69;
                          if (!*v69) {
                            goto LABEL_83;
                          }
                          CFIndex v71 = *(sqlite3_stmt **)(v14 + 64);
                          if (v71)
                          {
                            if (sqlite3_bind_int(v71, 1, 0)
                              || sqlite3_bind_int(*(sqlite3_stmt **)(v14 + 64), 2, v140)
                              || sqlite3_bind_int(*(sqlite3_stmt **)(v14 + 64), 3, v139))
                            {
                              goto LABEL_83;
                            }

                            if (Value)
                            {
                              LOBYTE(keys) = 0;
                              UniChar v72 = _ExtractCStringfromCFStringRef(Value, (BOOL *)&keys);
                              if (v72)
                              {
                                if (sqlite3_bind_text( *(sqlite3_stmt **)(v14 + 64),  4,  v72,  -1,  (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL))
                                {
                                  if ((_BYTE)keys) {
                                    operator delete[](v72);
                                  }
                                  goto LABEL_83;
                                }

                                if ((_BYTE)keys) {
                                  operator delete[](v72);
                                }
                              }
                            }

                            else if (sqlite3_bind_text(*(sqlite3_stmt **)(v14 + 64), 4, 0LL, 0, 0LL))
                            {
                              goto LABEL_83;
                            }

                            uint64_t v95 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]( (void *)v14,  *(sqlite3_stmt **)(v14 + 64));
                            sqlite3_reset(*(sqlite3_stmt **)(v14 + 64));
                            if ((_DWORD)v95)
                            {
                              unint64_t v128 = v152;
                              id Property = (id)v95;
                              CFLog();
                              goto LABEL_83;
                            }

                            CFIndex v96 = *(sqlite3_stmt **)(v14 + 72);
                            if (!v96
                              || !*(void *)(v14 + 32)
                              || sqlite3_bind_blob(v96, 1, v135, n[0], 0LL)
                              || sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 72), 2, v134, v141, 0LL))
                            {
LABEL_194:
                              uint64_t v10 = v131;
                              goto LABEL_83;
                            }

                            if (theData)
                            {
                              if (CFDataGetLength(theData) < *(void *)(v14 + 208))
                              {
                                if (*((_BYTE *)v21 + 20))
                                {
                                  CFIndex v98 = (const __CFString *)objc_getProperty((id)v14, v97, 160LL, 1);
                                  if (v98)
                                  {
                                    CFIndex v99 = (__CFString *)v98;
                                    FS2 = _CFURLCacheCreateFS2(v98);
                                    uint64_t v101 = (uint64_t)FS2;
                                    if (FS2)
                                    {
                                      uint64_t v102 = _CFURLCacheFSGetItemSize((uint64_t)FS2);
                                      _CFURLCacheFSPurgeItemFromFileSystemStore(v101, (char *)v21[1]);
                                      v149 -= (uint64_t)v102;
                                      (*(void (**)(uint64_t))(*(void *)v101 + 8LL))(v101);
                                    }
                                  }
                                }

                                else
                                {
                                  v149 -= *((int *)v21 + 4);
                                }

                                CFIndex v107 = *(sqlite3_stmt **)(v14 + 32);
                                CFIndex v108 = CFDataGetBytePtr(theData);
                                int v103 = sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 32), 2, 0LL);
                                goto LABEL_211;
                              }

                              id v104 = objc_getProperty((id)v14, v97, 160LL, 1);
                              if (v104)
                              {
                                CFIndex v105 = v104;
                                if (*((_BYTE *)v21 + 20))
                                {
                                  CFIndex v106 = (const UInt8 *)v21[1];
                                  if (v106)
                                  {
                                    CFStringRef cfa = CFStringCreateWithBytesNoCopy( allocator,  v106,  *((int *)v21 + 4),  0x8000100u,  0,  contentsDeallocator);
LABEL_215:
                                    if (cfa)
                                    {
                                      nb = _CFURLCacheCreateFS3(v105, theData, cfa);
                                      uint64_t v111 = _CFURLCacheFSGetItemSize((uint64_t)nb);
                                      uint64_t v112 = v111;
                                      uint64_t v113 = *(void *)(v15 + 16);
                                      if (v114 != CFDataGetLength(theData)
                                        || (*(void *)(v14 + 184) += v114,
                                            sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 32), 2, v114 != 0)))
                                      {

                                        uint64_t v10 = v131;
                                        (*(void (**)(char *))(*(void *)nb + 8LL))(nb);
                                        CFRelease(cfa);
                                        goto LABEL_83;
                                      }

                                      LOBYTE(keys) = 0;
                                      CFIndex v116 = _ExtractCStringfromCFStringRef(cfa, (BOOL *)&keys);
                                      if (v116)
                                      {
                                        if (sqlite3_bind_text( *(sqlite3_stmt **)(v14 + 32),  1,  v116,  -1,  (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL))
                                        {
                                          if ((_BYTE)keys) {
                                            operator delete[](v116);
                                          }

                                          (*(void (**)(char *))(*(void *)nb + 8LL))(nb);
                                          CFRelease(cfa);
                                          goto LABEL_194;
                                        }

                                        if ((_BYTE)keys) {
                                          operator delete[](v116);
                                        }
                                      }

                                      __CFURLCache::ReplaceDataInMemoryCacheResponseWithMMappedData( *(__CFURLCache **)(v137 + 16),  (_CFCachedURLResponse *)nb,  v152,  v115);
                                      (*(void (**)(char *))(*(void *)nb + 8LL))(nb);
                                      CFRelease(cfa);
                                      v149 -= (uint64_t)v112;
                                    }
                                  }
                                }

                                else
                                {
                                  uint64_t v109 = *((int *)v21 + 4);
                                  CFIndex v110 = CFUUIDCreate(allocator);
                                  v149 -= v109;
                                  if (v110)
                                  {
                                    CFStringRef cfa = CFUUIDCreateString(allocator, v110);
                                    CFRelease(v110);
                                    goto LABEL_215;
                                  }
                                }
                              }
                            }

                            else
                            {
                              if (sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 32), 1, 0LL, 0, 0LL)) {
                                goto LABEL_194;
                              }
                              int v103 = sqlite3_bind_blob(*(sqlite3_stmt **)(v14 + 32), 2, 0LL, 0, 0LL);
LABEL_211:
                              if (v103) {
                                goto LABEL_194;
                              }
                            }

                            UniChar v117 = *(sqlite3_stmt **)(v14 + 72);
                            if (v138 < 1) {
                              int v118 = sqlite3_bind_blob(v117, 3, 0LL, 0, 0LL);
                            }
                            else {
                              int v118 = sqlite3_bind_blob(v117, 3, v132, v138, 0LL);
                            }
                            if (v118) {
                              goto LABEL_194;
                            }
                            uint64_t v119 = *(sqlite3_stmt **)(v14 + 72);
                            if (BytePtr
                               ? sqlite3_bind_blob(v119, 4, BytePtr, Length, 0LL)
                               : sqlite3_bind_blob(v119, 4, 0LL, 0, 0LL))
                            {
                              goto LABEL_194;
                            }

                            sqlite3_int64 v121 = *v21;
                            if (sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 72), 5, *v21)
                              || sqlite3_bind_int64(*(sqlite3_stmt **)(v14 + 32), 3, v121))
                            {
                              goto LABEL_194;
                            }

                            int v122 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]( (void *)v14,  *(sqlite3_stmt **)(v14 + 72));
                            CFIndex v123 = *(sqlite3_stmt **)(v14 + 72);
                            if (v122
                              || (sqlite3_reset(v123),
                                  int v124 = -[NSURLStorageURLCacheDB stepSQLStatement:toCompletionWithRetry:]( (void *)v14,  *(sqlite3_stmt **)(v14 + 32)),  v123 = *(sqlite3_stmt **)(v14 + 32),  v124))
                            {
                              sqlite3_reset(v123);
                              uint64_t v10 = v131;
                              goto LABEL_83;
                            }

                            sqlite3_reset(v123);
                            uint64_t v10 = v131;
                          }

LABEL_173:
                          unint64_t v89 = &v149[*(void *)(v14 + 200)];
                          *(void *)(v14 + 200) = v89;
                          if ((unint64_t)v89 > *(void *)(v14 + 176))
                          {
                            uint64_t v90 = *(void *)(v137 + 16);
                            if (!*(_BYTE *)(v90 + 121))
                            {
                              *(_BYTE *)(v90 + 12__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
                              CFTypeRef v91 = CFRetain(*(CFTypeRef *)(v90 + 440));
                              keys = (void *)MEMORY[0x1895F87A8];
                              uint64_t v166 = 3221225472LL;
                              UniChar v167 = ___ZN12__CFURLCache6ShrinkEP22NSURLStorageURLCacheDB_block_invoke;
                              CFIndex v168 = &unk_189C10E30;
                              uint64_t v170 = v90;
                              CFTypeRef v171 = v91;
                              uint64_t v169 = v14;
                              dispatch_block_t v92 = dispatch_block_create_with_qos_class( (dispatch_block_flags_t)0LL,  QOS_CLASS_UTILITY,  0,  &keys);
                              dispatch_time_t v93 = dispatch_time(0LL, 1000000000LL);
                              dispatch_after(v93, *(dispatch_queue_t *)(v90 + 136), v92);
                              _Block_release(v92);
                            }
                          }

                          goto LABEL_83;
                        }

LABEL_71:
                      unsigned int Value = 0LL;
                      CFIndex v138 = 0LL;
                      unint64_t v132 = 0LL;
                      goto LABEL_75;
                    }
                  }

                  else
                  {
                    LODWORD(v14__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
                    int v134 = 0LL;
                    if (!v45) {
                      goto LABEL_67;
                    }
                  }

                  CFRelease(v45);
                  goto LABEL_67;
                }

                int v134 = 0LL;
                LODWORD(v14__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
                goto LABEL_71;
              }
            }
          }

          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)buf);
LABEL_72:
          dispatch_data_t subrange = data2;
          goto LABEL_118;
        }

        break;
      default:
        if ((unint64_t)(v14 - 984832) >= 2)
        {
LABEL_44:
          CFN_LOG_h3stream();
          CFIndex v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_INFO))
          {
            CFDictionaryRef v45 = *(void *)(v12 + 336);
            *(_DWORD *)buf = 134218496;
            *(void *)&uint8_t buf[4] = v12;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v45;
            *(_WORD *)&buf[22] = 2048;
            *(void *)&uint8_t buf[24] = v14;
            _os_log_impl(&dword_18298D000, v44, OS_LOG_TYPE_INFO, "%p ID=%llu unsupported frame type %llu", buf, 0x20u);
          }

LABEL_88:
          dispatch_data_t subrange = data2;
          goto LABEL_89;
        }

      int v47 = CFGetAllocator(*(CFTypeRef *)(a1 + 224));
      Empty = CFHTTPMessageCreateEmpty(v47, 0);
      unint64_t v49 = *(const void **)(a1 + 224);
      *(void *)(a1 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
      if (v49) {
        CFRelease(v49);
      }
      *(void *)(a1 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = Empty;
      if (v45 == 100)
      {
        CFIndex v50 = (*(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16)) & 0xFFFEFFFF;
        *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = *(_WORD *)(a1 + 232);
        *(_BYTE *)(a1 + 23os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = BYTE2(v50);
        v88.domain = 0LL;
        *(void *)&v88.CFErrorRef error = 0LL;
        CoreStreamBase::_signalEvent((CoreStreamBase *)a1, 64LL, v88, 1);
      }

      continue;
    }

    break;
  }

  int v46 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
  if ((v46 & 0x20000) == 0) {
    goto LABEL_71;
  }
  int v62 = 0;
  int v63 = v46 | 0x2000;
  *(_BYTE *)(a1 + 23os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = BYTE2(v46);
  *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v46 | 0x2000;
LABEL_97:
  if (v62 || (v63 & 0x2000) != 0)
  {
    int64_t v75 = v63 & 0xFFFFDFFF;
    *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v75;
    *(_BYTE *)(a1 + 23os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = BYTE2(v75);
    goto LABEL_137;
  }

  CFIndex v64 = *(void *)(a1 + 224);
  if (v13[238] != -1) {
    dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5084);
  }
  if (v64) {
    BOOL v65 = (HTTPMessage *)(v64 + 16);
  }
  else {
    BOOL v65 = 0LL;
  }
  uint64_t v66 = HTTPMessage::copyHeaderFieldValue(v65, 0x148233EDu);
  if (v66)
  {
    CFRange v68 = v66;
    CFRange v69 = CFGetAllocator(v66);
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v69, v68, @",");
    CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count >= 1)
    {
      UniChar v72 = Count;
      int v73 = 0LL;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v73);
        v89.CFIndex length = CFStringGetLength(ValueAtIndex);
        v89.CFIndex location = 0LL;
        if (CFStringFindWithOptions(ValueAtIndex, (CFStringRef)&unk_18C5AFBD8, v89, 1uLL, 0LL)) {
          break;
        }
        if (v72 == ++v73) {
          goto LABEL_124;
        }
      }

      if (v72 == 1)
      {
        int64_t v76 = CFRetain(&unk_18C5AFD28);
      }

      else
      {
        uint64_t v77 = CFGetAllocator(v68);
        CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(v77, v72, ArrayBySeparatingStrings);
        CFArrayRemoveValueAtIndex(MutableCopy, v73);
        uint64_t v79 = CFGetAllocator(v68);
        int64_t v76 = CFStringCreateByCombiningStrings(v79, ArrayBySeparatingStrings, @",");
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
      }

      CFIndex v80 = *(void *)(a1 + 224);
      if (v13[238] != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5084);
      }
      if (v80) {
        UniChar v81 = (HTTPMessage *)(v80 + 16);
      }
      else {
        UniChar v81 = 0LL;
      }
      HTTPMessage::setHeaderFieldStringValue(v81, 0x148233EDu, v76);
      if (v76) {
        CFRelease(v76);
      }
      *(_WORD *)(a1 + 232) |= 0x20u;
    }

LABEL_95:
          ++v12;
        }

        while (v12 != v10);
        uint64_t v125 = [v5 countByEnumeratingWithState:&v154 objects:v163 count:16];
        uint64_t v10 = v125;
      }

      while (v125);
    }

    uint64_t v126 = *(void *)(a1 + 32);
    if (v126)
    {
      -[NSURLStorageURLCacheDB openAndPrepareWriteCacheDB_NoLock](*(id *)(a1 + 32), v9);
      -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v126,  "COMMIT TRANSACTION;",
        *(sqlite3 **)(v126 + 16),
        1);
      CFIndex v127 = *(os_unfair_lock_s **)(a1 + 32);
      if (v127) {
        os_unfair_lock_unlock(v127 + 7);
      }
    }

    __releaseStorageAssertion(v11);
  }

  if (v5)
  {
    pthread_mutex_lock((pthread_mutex_t *)(*(void *)(*(void *)(a1 + 40) + 16LL) + 552LL));
    *(void *)(*(void *)(*(void *)(a1 + 40) + 16LL) + 544LL) = 0LL;
    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(*(void *)(a1 + 40) + 16LL) + 552LL));
  }

  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void sub_182A3E880( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29)
{
}

void *std::__hash_table<std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,__CFURLCache__::HashFunc,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,__CFURLCacheNode *>,std::equal_to<unsigned long>,__CFURLCache__::HashFunc,true>,std::allocator<std::__hash_value_type<unsigned long,__CFURLCacheNode *>>>::__emplace_unique_key_args<unsigned long,std::pair<unsigned long,__CFURLCacheNode *>>( float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = (int)a2;
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = (int)a2;
    }

    else
    {
      unint64_t v4 = (v9 - 1) & (int)a2;
    }

    double v11 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (CFIndex i = *v11; i; CFIndex i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == (int)a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }

          else
          {
            v13 &= v9 - 1;
          }

          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }

  CFIndex i = operator new(0x20uLL);
  *CFIndex i = 0LL;
  i[1] = v8;
  i[2] = a3;
  i[3] = a4;
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1LL);
  float v15 = a1[8];
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1LL;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      int8x8_t prime = (int8x8_t)v18;
    }
    else {
      int8x8_t prime = (int8x8_t)v17;
    }
    if (*(void *)&prime == 1LL)
    {
      int8x8_t prime = (int8x8_t)2LL;
    }

    else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v9 = *((void *)a1 + 1);
    }

    if (*(void *)&prime > v9) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v26 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        unint64_t v26 = std::__next_prime(v26);
      }

      else
      {
        uint64_t v28 = 1LL << -(char)__clz(v26 - 1);
        if (v26 >= 2) {
          unint64_t v26 = v28;
        }
      }

      if (*(void *)&prime <= v26) {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *((void *)a1 + 1);
      }

      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          BOOL v20 = operator new(8LL * *(void *)&prime);
          uint64_t v21 = *(void **)a1;
          *(void *)a1 = v20;
          if (v21) {
            operator delete(v21);
          }
          uint64_t v22 = 0LL;
          *((int8x8_t *)a1 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v22++) = 0LL;
          while (*(void *)&prime != v22);
          uint64_t v23 = (void *)*((void *)a1 + 2);
          if (v23)
          {
            unint64_t v24 = v23[1];
            uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(void *)&prime) {
                v24 %= *(void *)&prime;
              }
            }

            else
            {
              v24 &= *(void *)&prime - 1LL;
            }

            *(void *)(*(void *)a1 + 8 * v2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a1 + 4;
            unint64_t v29 = (void *)*v23;
            if (*v23)
            {
              do
              {
                unint64_t v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(void *)&prime) {
                    v30 %= *(void *)&prime;
                  }
                }

                else
                {
                  v30 &= *(void *)&prime - 1LL;
                }

                if (v30 != v24)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v30))
                  {
                    *(void *)(*(void *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }

                  void *v23 = *v29;
                  void *v29 = **(void **)(*(void *)a1 + 8 * v30);
                  **(void **)(*(void *)a1 + 8 * v30) = v29;
                  unint64_t v29 = v23;
                }

                unint64_t v30 = v24;
LABEL_55:
                uint64_t v23 = v29;
                unint64_t v29 = (void *)*v29;
                unint64_t v24 = v30;
              }

              while (v29);
            }
          }

          unint64_t v9 = (unint64_t)prime;
          goto LABEL_59;
        }

        unint64_t v35 = *(void **)a1;
        *(void *)a1 = 0LL;
        if (v35) {
          operator delete(v35);
        }
        unint64_t v9 = 0LL;
        *((void *)a1 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
      }
    }

void sub_182A3ECF4(_Unwind_Exception *a1)
{
}

void std::__split_buffer<__CFURLCacheNode **>::push_front(uint64_t a1, void *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(_BYTE **)(a1 + 16);
    unint64_t v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      unint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v11);
      unint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8LL];
      float v15 = *(uint64_t **)(a1 + 8);
      BOOL v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        BOOL v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v18 = 8 * (v17 >> 3);
        int v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)int v19 = v20;
          v19 += 8;
          v18 -= 8LL;
        }

        while (v18);
      }

      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + _Block_object_dispose((const void *)(v31 - 192), 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        unint64_t v5 = *(char **)(a1 + 8);
      }
    }

    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      unint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        unint64_t v4 = *(char **)(a1 + 16);
      }

      *(void *)(a1 + _Block_object_dispose((const void *)(v31 - 192), 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }

  else
  {
    unint64_t v5 = *(char **)(a1 + 8);
  }

  *((void *)v5 - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = *a2;
  *(void *)(a1 + 8) -= 8LL;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

void ___ZN21__CFCachedURLResponse22GetNSCachedURLResponseEv_block_invoke(uint64_t a1)
{
}

CFStringRef _CFURLCacheCopyCacheDirectory(os_unfair_lock_s **a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t TypeID = CFURLCacheGetTypeID();
  if (TypeID != CFGetTypeID(a1) || !__CFURLCache::GetDirectoryOfPersistentStore(a1[2])) {
    return 0LL;
  }
  id v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  DirectoryOfPersistentStore = (const __CFString *)__CFURLCache::GetDirectoryOfPersistentStore(a1[2]);
  return CFStringCreateCopy(v3, DirectoryOfPersistentStore);
}

uint64_t __CFURLCache::GetDirectoryOfPersistentStore(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 31;
  os_unfair_lock_lock(this + 31);
  if (!*(void *)&this[54]._os_unfair_lock_opaque) {
    *(void *)&this[54]._os_unfair_lock_opaque = __CreatePathToCacheDirectory(0LL, 0);
  }
  os_unfair_lock_unlock(v2);
  return *(void *)&this[54]._os_unfair_lock_opaque;
}

uint64_t __CFURLCacheCreateInternal( const __CFAllocator *a1, uint64_t a2, uint64_t a3, const __CFString *a4, char a5, int a6, char a7)
{
  block = (void *)MEMORY[0x1895F87A8];
  uint64_t block_8 = 3221225472LL;
  uint64_t v22 = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2331;
  uint64_t v23 = &__block_descriptor_40_e5_v8__0l;
  unint64_t v24 = _URLCacheRegisterClass;
  if (_CFURLCacheClassRegistration != -1) {
    dispatch_once(&_CFURLCacheClassRegistration, &block);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = 0LL;
  *(void *)(Instance + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  if (a4)
  {
    if (a6) {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], a4);
    }
    else {
      CFStringRef Copy = __CreatePathToCacheDirectory(a4, a5);
    }
    a4 = Copy;
  }

  float v15 = operator new(0x298uLL);
  v15[1] = 0LL;
  v15[2] = 0LL;
  *float v15 = off_189C03AA0;
  __CFURLCache::__CFURLCache((__CFURLCache *)(v15 + 3), (const _CFURLCache *)Instance, a2, a3, a4, a7);
  block = v15 + 3;
  uint64_t block_8 = (uint64_t)v15;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( (uint64_t)&block,  v15 + 4,  (uint64_t)(v15 + 3));
  BOOL v16 = (std::__shared_weak_count *)block_8;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(Instance + 16), (uint64_t)block, block_8);
  if (a4) {
    CFRelease(a4);
  }
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  return Instance;
}

void sub_182A3F0D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void __CFURLCache::__CFURLCache( __CFURLCache *this, const _CFURLCache *a2, uint64_t a3, uint64_t a4, const __CFString *a5, char a6)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *((void *)this + 2) = 0LL;
  *(void *)this = off_189C03910;
  *((void *)this + 6) = off_189C12668;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 56), 0LL);
  *((_OWORD *)this + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *((void *)this + 6) = off_189C12688;
  *((_OWORD *)this + 15) = 0u;
  *((_DWORD *)this + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1065353216;
  *(_OWORD *)((char *)this + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((_BYTE *)this + 6std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = a6;
  *(_OWORD *)((char *)this + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *((void *)this + 1_Block_object_dispose((const void *)(v31 - 192), 8) = 0LL;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 18os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *((void *)this + 55) = a2;
  *((_BYTE *)this + 40) = 0;
  *((void *)this + 25) = 0x3FA999999999999ALL;
  *((void *)this + 27) = 0LL;
  *((_BYTE *)this + 52_Block_object_dispose((const void *)(v31 - 192), 8) = 0;
  *((void *)this + 65) = 0LL;
  *((_WORD *)this + 60) = 0;
  *((_DWORD *)this + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  *((void *)this + 16) = 0LL;
  *(_OWORD *)((char *)this + 536) = 0u;
  uint64_t v12 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((void *)this + 17) = dispatch_queue_create("com.apple.CFNetwork.CacheDB-write", v12);
  if (pthread_mutex_init((pthread_mutex_t *)((char *)this + 456), 0LL)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 312), 0LL)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 376), 0LL)
    || pthread_mutex_init((pthread_mutex_t *)((char *)this + 552), 0LL))
  {
    return;
  }

  unint64_t v13 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  *((void *)this + 56) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
  *((void *)this + 65) = CFDictionaryCreateMutable(v13, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  *((void *)this + 67) = CFDictionaryCreateMutable(v13, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (a5) {
    *((void *)this + 27) = CFStringCreateCopy(v13, a5);
  }
  if (a4) {
    BOOL v14 = a4 < 15001;
  }
  else {
    BOOL v14 = 0;
  }
  int v15 = v14;
  if (a3 && a3 < 1025)
  {
    *((void *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0x400000LL;
    if (v15)
    {
      *((void *)this + 22) = 20971520LL;
      int64x2_t v16 = (int64x2_t)xmmword_182C9D780;
LABEL_25:
      *(int64x2_t *)((char *)this + 18os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v16), *((double *)this + 25)));
      goto LABEL_26;
    }

    *((void *)this + 22) = a4;
    a3 = 0x400000LL;
LABEL_23:
    if (a4)
    {
      v16.i64[0] = a3;
      v16.i64[1] = a4;
      goto LABEL_25;
    }

    goto LABEL_26;
  }

  *((void *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = a3;
  if ((v15 & 1) == 0)
  {
    *((void *)this + 22) = a4;
    if (!a3) {
      goto LABEL_26;
    }
    goto LABEL_23;
  }

  *((void *)this + 22) = 20971520LL;
  if (a3)
  {
    int64x2_t v16 = vdupq_n_s64(0x1400000uLL);
    v16.i64[0] = a3;
    goto LABEL_25;
  }

void sub_182A3F480(_Unwind_Exception *a1)
{
  *(void *)(v1 + 4_Block_object_dispose((const void *)(v31 - 192), 8) = v5;
  pthread_mutex_destroy(v2);
  unint64_t v7 = *(std::__shared_weak_count **)(v1 + 16);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
  _Unwind_Resume(a1);
}

void ___ZN12__CFURLCacheC2EPK11_CFURLCachellPK10__CFStringb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = getenv("CFN_VARY_HEADER_SUPPORT");
  if (v2)
  {
    p_p = (char *)&__p;
    std::string::basic_string[abi:nn180100]<0>(&__p, v2);
    unsigned __int8 v4 = v10;
    if ((v10 & 0x80u) == 0) {
      uint64_t v5 = (char *)&__p + v10;
    }
    else {
      uint64_t v5 = (char *)__p + v9;
    }
    if ((v10 & 0x80u) != 0) {
      p_p = (char *)__p;
    }
    if (p_p != v5)
    {
      do
      {
        char *p_p = __tolower(*p_p);
        ++p_p;
      }

      while (p_p != v5);
      unsigned __int8 v4 = v10;
    }

    if ((v4 & 0x80) != 0)
    {
      uint64_t v6 = __p;
      switch(v9)
      {
        case 1LL:
          if (*(_BYTE *)__p != 48) {
            break;
          }
          goto LABEL_31;
        case 2LL:
          if (*(_WORD *)__p == 28526) {
            goto LABEL_31;
          }
          break;
        case 5LL:
          goto LABEL_18;
      }

void sub_182A3F610( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void __CFURLCache::_createVaryStateTable(sqlite3 **this)
{
  uint64_t v2 = 0LL;
  uint64_t v7 = *MEMORY[0x1895F89C0];
  errmsg = 0LL;
  do
  {
    if (sqlite3_exec(this[78], off_189C03988[v2], 0LL, 0LL, &errmsg))
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v3 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v6 = errmsg;
        _os_log_impl(&dword_18298D000, v3, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
      }

      sqlite3_free(errmsg);
    }

    ++v2;
  }

  while (v2 != 5);
}

void std::__shared_ptr_emplace<__CFURLCache>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C03AA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<__CFURLCache>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C03AA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<__CFURLCache>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t CFURLCacheCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, const __CFString *a4)
{
  return __CFURLCacheCreateInternal(a1, a2, a3, a4, 0, 0, 0);
}

void ___Z24_CFURLCacheCreateWithURLPK13__CFAllocatorllPK7__CFURL_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZL35__CFURLCacheCreateForStorageSessionPK13__CFAllocatorllPK10__CFStringhS4_hh_block_invoke()
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t started = sysdir_start_search_path_enumeration_private();
  if ((_DWORD)started)
  {
    uint64_t v1 = started;
    bzero(__s, 0x400uLL);
    MEMORY[0x186E161DC](v1, __s);
    uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    size_t v3 = strlen(__s);
    unsigned __int8 v4 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)__s, v3, 1u);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = CFURLCreateCopyAppendingPathComponent(v2, v4, @"Caches", 1u);
      CFRelease(v5);
      if (v6)
      {
        __CFURLCacheCreateForStorageSession(__CFAllocator const*,long,long,__CFString const*,unsigned char,__CFString const*,unsigned char,unsigned char)::sharedCachesDirectory = (uint64_t)CFURLCreateCopyAppendingPathComponent(v2, v6, @"sharedCaches", 1u);
        CFRelease(v6);
      }
    }
  }

uint64_t CFURLCacheCopySharedURLCache()
{
  Internal = (const void *)gSharedInstance;
  if (!gSharedInstance)
  {
    Internal = (const void *)__CFURLCacheCreateInternal( (const __CFAllocator *)*MEMORY[0x189604DB0],  0x400000LL,  20971520LL,  0LL,  0,  0,  0);
    gShareduint64_t Instance = (uint64_t)Internal;
  }

  CFRetain(Internal);
  uint64_t v1 = gSharedInstance;
  pthread_mutex_unlock(&gSharedInstanceLock);
  return v1;
}

uint64_t CFURLCacheSetSharedURLCache(const void *a1)
{
  if ((const void *)gSharedInstance != a1)
  {
    if (gSharedInstance) {
      CFRelease((CFTypeRef)gSharedInstance);
    }
    if (a1) {
      CFRetain(a1);
    }
    gShareduint64_t Instance = (uint64_t)a1;
  }

  return pthread_mutex_unlock(&gSharedInstanceLock);
}

uint64_t __CFURLCacheVaryStateForURL(__CFURLCache **a1, __CFString *a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t TypeID = CFURLCacheGetTypeID();
  if (TypeID == CFGetTypeID(a1)) {
    return __CFURLCache::_varyStateForURL(a1[2], a2);
  }
  if ((objc_opt_respondsToSelector() & 1) != 0) {
    return [a1 performSelector:sel__varyStateForURL_ withObject:a2];
  }
  else {
    return 0LL;
  }
}

void ___ZN12__CFURLCache43CopyResponseForRequestWithCompletionHandlerEPK13_CFURLRequestbP12NSURLSessionU13block_pointerFvPK20_CFCachedURLResponseE_block_invoke( uint64_t a1, uint64_t a2)
{
  if (a2) {
    requestURLIsBlocked(*(NSURL **)(a1 + 32));
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  size_t v3 = *(const void **)(a1 + 48);
  if (v3) {
    CFRelease(v3);
  }
}

void mmapFileDeallocate(void *a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *a2;
  uint64_t v5 = (pthread_mutex_t *)(*a2 + 376LL);
  pthread_mutex_lock(v5);
  if (a1)
  {
    uint64_t v6 = *(__CFSet **)(v4 + 448);
    if (v6) {
      CFSetRemoveValue(v6, a1);
    }
  }

  pthread_mutex_unlock(v5);
  if (munmap(a1, a2[1]) == -1)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      int v9 = *__error();
      v10[0] = 67109120;
      v10[1] = v9;
      _os_log_error_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_ERROR,  "===== munmap failed. errno = %{errno}d",  (uint8_t *)v10,  8u);
    }
  }

  uint64_t v8 = *(const void **)(*a2 + 440LL);
  if (v8) {
    CFRelease(v8);
  }
  operator delete(a2);
}

uint64_t __CFURLCache::addMMappedDataToSet(__CFURLCache *this, void *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  if (a2)
  {
    uint64_t v5 = (__CFSet *)*((void *)this + 56);
    if (v5) {
      CFSetAddValue(v5, a2);
    }
  }

  return pthread_mutex_unlock(v4);
}

void __CFCachedURLResponse::SetReceiverData(__CFCachedURLResponse *this, const __CFData *a2)
{
  values = a2;
  size_t v3 = (os_unfair_lock_s *)((char *)this + 88);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  uint64_t v4 = (const void *)*((void *)this + 9);
  if (v4)
  {
    *((void *)this + 9) = 0LL;
    CFRelease(v4);
  }

  uint64_t v5 = (const void *)*((void *)this + 10);
  if (v5)
  {
    *((void *)this + 10) = 0LL;
    CFRelease(v5);
  }

  *((void *)this + 10) = CFArrayCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)&values,  1LL,  MEMORY[0x189605228]);
  __CFCachedURLResponse::EncodeReceiverData(this);
  os_unfair_lock_unlock(v3);
}

__CFData *__CFCachedURLResponse::GetReceiverData(__CFCachedURLResponse *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 88);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  size_t v3 = (__CFData *)*((void *)this + 9);
  if (!v3)
  {
    uint64_t v4 = (const __CFArray *)*((void *)this + 10);
    if (v4)
    {
      size_t v3 = CopyAllDataFromDataArray(v4);
      *((void *)this + 9) = v3;
    }

    else
    {
      size_t v3 = 0LL;
    }
  }

  os_unfair_lock_unlock(v2);
  return v3;
}

__CFData *CopyAllDataFromDataArray(const __CFArray *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count == 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, 0LL);
      return (__CFData *)CFRetain(ValueAtIndex);
    }

    CFIndex v5 = Count;
    if (Count >= 2)
    {
      CFIndex v6 = 0LL;
      CFIndex v7 = 0LL;
      do
      {
        uint64_t v8 = (const __CFData *)CFArrayGetValueAtIndex(a1, v7);
        v6 += CFDataGetLength(v8);
        ++v7;
      }

      while (v5 != v7);
      if (v6 > 0)
      {
        int v9 = CFGetAllocator(a1);
        CFMutableDataRef Mutable = CFDataCreateMutable(v9, v6);
        if (Mutable)
        {
          uint64_t v11 = Mutable;
          CFIndex v12 = 0LL;
          do
          {
            unint64_t v13 = (const __CFData *)CFArrayGetValueAtIndex(a1, v12);
            BytePtr = CFDataGetBytePtr(v13);
            CFIndex Length = CFDataGetLength(v13);
            CFDataAppendBytes(v11, BytePtr, Length);
            ++v12;
          }

          while (v5 != v12);
          return v11;
        }

        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        int64x2_t v16 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          int v17 = 134217984;
          CFIndex v18 = v6;
          _os_log_error_impl( &dword_18298D000,  v16,  OS_LOG_TYPE_ERROR,  "CopyAllDataFromDataArray:  ERROR.  Failed to allocate a CFDataRef of size %ld.",  (uint8_t *)&v17,  0xCu);
        }
      }
    }
  }

  return 0LL;
}

uint64_t __CFURLCache::_varyStateForURL(__CFURLCache *this, __CFString *a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!*((void *)this + 78)) {
    return 0LL;
  }
  std::string::basic_string[abi:nn180100]<0>(&v11, "SELECT * from cfurl_vary_state where request_key=");
  std::string::append(&v11, (const std::string::value_type *)-[__CFString UTF8String](a2, "UTF8String"));
  std::string::append(&v11, "");
  errmsg = 0LL;
  __retainStorageAssertion(*((void **)this + 17));
  uint64_t v9 = 0LL;
  if ((v11.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v4 = &v11;
  }
  else {
    uint64_t v4 = (std::string *)v11.__r_.__value_.__r.__words[0];
  }
  if (sqlite3_exec( *((sqlite3 **)this + 78),  (const char *)v4,  (int (__cdecl *)(void *, int, char **, char **))select_callback,  &v9,  &errmsg))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    CFIndex v6 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      unint64_t v13 = errmsg;
      _os_log_impl(&dword_18298D000, v6, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
    }

    sqlite3_free(errmsg);
  }

  __releaseStorageAssertion(v5);
  uint64_t v7 = v9;
  return v7;
}

void sub_182A40024( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t select_callback(void *a1, int a2, char **a3, char **a4)
{
  if (a2 >= 1)
  {
    uint64_t v18 = v4;
    uint64_t v19 = v5;
    uint64_t v9 = 0LL;
    uint64_t v10 = a2;
    do
    {
      std::string::basic_string[abi:nn180100]<0>(&v15, a4[v9]);
      if (v17 < 0)
      {
        if (v16 == 10)
        {
          BOOL v13 = *(void *)v15 != 0x6174735F79726176LL || v15[4] != 25972;
          operator delete(v15);
          if (!v13)
          {
LABEL_23:
            *a1 = [NSString stringWithUTF8String:a3[v9]];
            return 0LL;
          }
        }

        else
        {
          operator delete(v15);
        }
      }

      else if (v17 == 10 && v15 == (_WORD *)0x6174735F79726176LL && (unsigned __int16)v16 == 25972)
      {
        goto LABEL_23;
      }

      ++v9;
    }

    while (v10 != v9);
  }

  return 0LL;
}

id CFURLCacheCopyResponseForRequest(void *a1, _CFURLRequest *a2)
{
  if (IsCFURLCache((BOOL)a1))
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2020000000LL;
    uint64_t v12 = 0LL;
    uint64_t v4 = dispatch_semaphore_create(0LL);
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    _DWORD v8[2] = ____CFURLCacheCopyResponseForRequest_block_invoke;
    v8[3] = &unk_189C038C0;
    v8[4] = v4;
    v8[5] = &v9;
    __CFURLCacheCopyResponseForRequestWithCompletionHandler((uint64_t)a1, a2, 0LL, (uint64_t)v8);
    dispatch_semaphore_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v4);
    uint64_t v5 = v10[3];
    _Block_object_dispose(&v9, 8);
    return (id)v5;
  }

  else
  {
    uint64_t v7 = (const char *)__CFURLCacheCopyResponseForRequestInternalWithSession(_CFURLCache const*,_CFURLRequest const*,unsigned char,NSURLSession *)::s;
    if (!__CFURLCacheCopyResponseForRequestInternalWithSession(_CFURLCache const*,_CFURLRequest const*,unsigned char,NSURLSession *)::s)
    {
      uint64_t v7 = sel_registerName("_nscfBridgeURLCacheCopyResponseForRequest:");
      __CFURLCacheCopyResponseForRequestInternalWithSession(_CFURLCache const*,_CFURLRequest const*,unsigned char,NSURLSession *)::s = (uint64_t)v7;
    }

    return objc_msgSend(a1, v7, a2);
  }

void sub_182A4028C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void CFCachedURLResponseSetNSCachedURLResponse(const _CFCachedURLResponse *a1, const void *a2)
{
  var1 = a1->var1;
  if (var1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)var1 + 22);
    *((void *)var1 + 13) = a2;
    os_unfair_lock_unlock((os_unfair_lock_t)var1 + 22);
  }

void __CFURLCache::_updateVaryStateForURL(__CFURLCache *this, __CFString *a2, __CFString *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (*((void *)this + 78) && *((void *)this + 22))
  {
    errmsg = 0LL;
    __retainStorageAssertion(*((void **)this + 17));
    std::string::basic_string[abi:nn180100]<0>( &__p,  "INSERT OR REPLACE INTO cfurl_vary_state(request_key, vary_state) VALUES ('");
    std::string::append(&__p, (const std::string::value_type *)-[__CFString UTF8String](a3, "UTF8String"));
    std::string::append(&__p, "', '");
    std::string::append(&__p, (const std::string::value_type *)-[__CFString UTF8String](a2, "UTF8String"));
    std::string::append(&__p, "');");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (sqlite3_exec(*((sqlite3 **)this + 78), (const char *)p_p, 0LL, 0LL, &errmsg))
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v8 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v12 = errmsg;
        _os_log_impl(&dword_18298D000, v8, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
      }

      sqlite3_free(errmsg);
    }

    __releaseStorageAssertion(v7);
  }

void sub_182A40488( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void CFURLCacheAddCachedResponseForRequest( _CFURLCache *a1, _CFCachedURLResponse *a2, _CFURLRequest *a3, const void *a4)
{
  if (a1)
  {
    uint64_t TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      Class Class = objc_getClass("__NSURLSessionLocal");
      uint64_t v10 = (HTTPProtocol *)objc_msgSend(Class, sel_registerName("sharedSession"));
      __CFURLCacheAddCachedResponseForRequestWithSession(a1, v10, a2, a3, a4);
    }

    else
    {
      uint64_t v11 = (const char *)CFURLCacheAddCachedResponseForRequest::s;
      if (!CFURLCacheAddCachedResponseForRequest::s)
      {
        uint64_t v11 = sel_registerName("_nscfBridgeURLCacheStoreCachedResponse:forRequest:");
        CFURLCacheAddCachedResponseForRequest::s = (uint64_t)v11;
      }

      objc_msgSend(a1, v11, a2, a3);
    }
  }

uint64_t ___ZL50__CFURLCacheAddCachedResponseForRequestWithSessionPK11_CFURLCacheP12NSURLSessionPK20_CFCachedURLResponsePK13_CFURLRequestPKv_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 752LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void CFURLCacheRemoveCachedResponseForRequest(__CFURLCache **a1, _CFURLRequest *a2)
{
  if (a1)
  {
    uint64_t TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      if (a2)
      {
        uint64_t v5 = *(const __CFURL **)(-[_CFURLRequest _inner](a2, "_inner") + 8);
        unsigned int v6 = __CFURLCacheIsVaryHeaderSupportEnabled(a1);
        double v7 = 0LL;
        if (v6 && v5)
        {
          uint64_t v8 = (__CFString *)CFURLGetString(v5);
          double v7 = (__CFString *)__CFURLCacheVaryStateForURL(a1, v8);
        }

        CacheKeyForRequest = _createCacheKeyForRequest(a2, 1, v7);
        uint64_t v10 = (_CFCachedURLResponse **)operator new(0x78uLL);
        __CFURLCacheNode::__CFURLCacheNode((uint64_t)v10, 0LL, CacheKeyForRequest, a2, 1);
        uint64_t v12 = v10;
        __CFURLCache::AddCacheTask((uint64_t)a1[2], &v12);
        if (v12) {
          ((void (*)(_CFCachedURLResponse **))(*v12)->var0.var1)(v12);
        }
        if (CacheKeyForRequest) {
          CFRelease(CacheKeyForRequest);
        }
      }
    }

    else
    {
      uint64_t v11 = (const char *)CFURLCacheRemoveCachedResponseForRequest::s;
      if (!CFURLCacheRemoveCachedResponseForRequest::s)
      {
        uint64_t v11 = sel_registerName("_nscfBridgeURLCacheRemoveCachedResponseForRequest:");
        CFURLCacheRemoveCachedResponseForRequest::s = (uint64_t)v11;
      }

      objc_msgSend(a1, v11, a2);
    }
  }

void sub_182A40728( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

void CFURLCacheRemoveAllCachedResponses(void *a1)
{
  if (a1)
  {
    uint64_t TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      size_t v3 = (__CFURLCache *)a1[2];
      __CFURLCache::PurgeMemoryCache(v3);
      __CFURLCache::PurgePersistentCache(v3);
    }

    else
    {
      uint64_t v4 = (const char *)CFURLCacheRemoveAllCachedResponses::s;
      if (!CFURLCacheRemoveAllCachedResponses::s)
      {
        uint64_t v4 = sel_registerName("_nscfBridgeURLCacheRemoveAllCachedResponses");
        CFURLCacheRemoveAllCachedResponses::s = (uint64_t)v4;
      }

      [a1 v4];
    }
  }

void __CFURLCache::PurgePersistentCache(__CFURLCache *this)
{
  void v17[2] = *MEMORY[0x1895F89C0];
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 552);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 552));
  CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 67));
  pthread_mutex_unlock(v2);
  id v3 = __CFURLCache::createAndOpenCacheDB(this);
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *((void *)this + 17);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZN12__CFURLCache20PurgePersistentCacheEv_block_invoke;
    block[3] = &unk_189C1A270;
    block[4] = v5;
    void block[5] = v3;
    dispatch_block_t v6 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0LL, QOS_CLASS_UTILITY, 0, block);
    dispatch_async(*((dispatch_queue_t *)this + 17), v6);
    _Block_release(v6);
  }

  if (*((_BYTE *)this + 632) && *((void *)this + 78))
  {
    __retainStorageAssertion(*((void **)this + 17));
    char v7 = 0;
    uint64_t v8 = 0LL;
    v17[0] = "DROP table IF EXISTS cfurl_vary_state;";
    v17[1] = "DROP TRIGGER IF EXISTS cfurl_vary_state_delete;";
    do
    {
      char v9 = v7;
      uint64_t v10 = (const char *)v17[v8];
      errmsg = 0LL;
      if (sqlite3_exec(*((sqlite3 **)this + 78), v10, 0LL, 0LL, &errmsg))
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        uint64_t v11 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          uint64_t v16 = errmsg;
          _os_log_impl(&dword_18298D000, v11, OS_LOG_TYPE_DEFAULT, "SQL error: %s", buf, 0xCu);
        }

        sqlite3_free(errmsg);
      }

      char v7 = 1;
      uint64_t v8 = 1LL;
    }

    while ((v9 & 1) == 0);
    __CFURLCache::_createVaryStateTable((sqlite3 **)this);
    __releaseStorageAssertion(v12);
  }

void ___ZN12__CFURLCache20PurgePersistentCacheEv_block_invoke(uint64_t a1)
{
  id v3 = *(os_unfair_lock_s **)(a1 + 40);
  if (v3)
  {
    os_unfair_lock_lock(v3 + 7);
    uint64_t v4 = MEMORY[0x1895F87A8];
    v19[0] = MEMORY[0x1895F87A8];
    v19[1] = 3221225472LL;
    uint64_t v20 = __44__NSURLStorageURLCacheDB_deleteAllResponses__block_invoke;
    uint64_t v21 = &unk_189C1A548;
    uint64_t v22 = v3;
    dispatch_block_t v6 = -[NSURLStorageURLCacheDB openReadWriteConnection](v3, v5);
    char v7 = v6;
    if (v6)
    {
      v14[0] = v4;
      v14[1] = 3221225472LL;
      int v15 = __44__NSURLStorageURLCacheDB_deleteAllResponses__block_invoke_2;
      uint64_t v16 = &unk_189C1A570;
      char v17 = v3;
      uint64_t v18 = v6;
      int v13 = 141;
      if (sqlite3_file_control(v6, 0LL, 101, &v13))
      {
        id v9 = objc_getProperty(v3, v8, 168LL, 1);
        uint64_t v10 = sqlite3_errmsg(v7);
        uint64_t v11 = sqlite3_errcode(v7);
        NSLog( @"ERROR: NSURLStorageURLCacheDB deleteAllResponses: dbConnection=%p DB=%@ Truncate Database failed:%s ErrCode: %d.",  v7,  v9,  v10,  v11);

        v15((uint64_t)v14);
        v20((uint64_t)v19);
        goto LABEL_7;
      }

      v15((uint64_t)v14);
    }

    v20((uint64_t)v19);
    -[NSURLStorageURLCacheDB updateToCurrentSchema]((uint64_t)v3, v12);
  }

void sub_182A40B38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void (*a16)(char *), uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, void (*a22)(char *))
{
}

void ___ZN12__CFURLCache30removeCachedResponsesSinceDateEPK8__CFDate_block_invoke(uint64_t a1)
{
  double v2 = *(os_unfair_lock_s **)(a1 + 40);
  id v4 = *(id *)(a1 + 48);
  if (v2)
  {
    BOOL v44 = 0;
    uint64_t v5 = -[NSURLStorageURLCacheDB openReadWriteConnection](v2, v3);
    [v4 description];
    dispatch_block_t v6 = (const __CFString *)objc_claimAutoreleasedReturnValue();
    char v7 = (__CFString *)v6;
    if (v6) {
      uint64_t v8 = _ExtractCStringfromCFStringRef(v6, &v44);
    }
    else {
      uint64_t v8 = 0LL;
    }
    errmsg = 0LL;
    id v9 = sqlite3_mprintf( "SELECT receiver_data from cfurl_cache_receiver_data WHERE isDataOnFS > 0 AND entry_ID in (SELECT entry_ID FRO M cfurl_cache_response WHERE time_stamp >= %s)",  v8);
    if (sqlite3_exec(v5, v9, (int (__cdecl *)(void *, int, char **, char **))SQLdeleteSinceDateCallback, v2, &errmsg)
      && errmsg)
    {
      objc_getProperty(v2, v10, 168LL, 1);
      CFLog();
      sqlite3_free(errmsg);
    }

    sqlite3_free(v9);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( v2,  "BEGIN IMMEDIATE;",
                         v5,
                         0))
    {
      id v12 = objc_getProperty(v2, v11, 168LL, 1);
      int v13 = sqlite3_errmsg(v5);
      uint64_t v14 = sqlite3_errcode(v5);
      NSLog( @"ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Begin transaction failed:%s ErrCode: %d.",  v5,  v12,  v13,  v14);
    }

    int v15 = sqlite3_mprintf( "DELETE from cfurl_cache_receiver_data WHERE entry_ID in (SELECT entry_ID FROM cfurl_cache_response WHERE tim e_stamp >= %s)",  v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( v2,  v15,  v5,  0))
    {
      id v17 = objc_getProperty(v2, v16, 168LL, 1);
      uint64_t v18 = sqlite3_errmsg(v5);
      uint64_t v19 = sqlite3_errcode(v5);
      NSLog( @"ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Delete failed:%s ErrCode: %d.",  v5,  v17,  v18,  v19);
    }

    sqlite3_free(v15);
    uint64_t v20 = sqlite3_mprintf( "DELETE from cfurl_cache_blob_data WHERE entry_ID in (SELECT entry_ID FROM cfurl_cache_response WHERE time_stamp >= %s)",  v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( v2,  v20,  v5,  0))
    {
      id v22 = objc_getProperty(v2, v21, 168LL, 1);
      uint64_t v23 = sqlite3_errmsg(v5);
      uint64_t v24 = sqlite3_errcode(v5);
      NSLog( @"ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Delete failed:%s ErrCode: %d.",  v5,  v22,  v23,  v24);
    }

    sqlite3_free(v20);
    uint8x8_t v25 = sqlite3_mprintf("DELETE from cfurl_cache_response WHERE time_stamp >= %s", v8);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( v2,  v25,  v5,  0))
    {
      id v27 = objc_getProperty(v2, v26, 168LL, 1);
      uint64_t v28 = sqlite3_errmsg(v5);
      uint64_t v29 = sqlite3_errcode(v5);
      NSLog( @"ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Delete failed:%s ErrCode: %d.",  v5,  v27,  v28,  v29);
    }

    sqlite3_free(v25);
    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( v2,  "COMMIT;",
                         v5,
                         0))
    {
      id v31 = objc_getProperty(v2, v30, 168LL, 1);
      uint64_t v32 = sqlite3_errmsg(v5);
      uint64_t v33 = sqlite3_errcode(v5);
      NSLog( @"ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Commit transaction failed:%s ErrCode: %d.",  v5,  v31,  v32,  v33);
    }

    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( v2,  "PRAGMA incremental_vacuum(500);",
                         v5,
                         0))
    {
      id v35 = objc_getProperty(v2, v34, 168LL, 1);
      __int16 v36 = sqlite3_errmsg(v5);
      uint64_t v37 = sqlite3_errcode(v5);
      NSLog( @"ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Vacuum failed:%s ErrCode: %d.",  v5,  v35,  v36,  v37);
    }

    if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( v2,  "PRAGMA wal_checkpoint;",
                         v5,
                         0))
    {
      id v39 = objc_getProperty(v2, v38, 168LL, 1);
      CFIndex v40 = sqlite3_errmsg(v5);
      uint64_t v41 = sqlite3_errcode(v5);
      NSLog( @"ERROR: NSURLStorageURLCacheDB deleteResponsesSinceDate: dbConnection=%p DB=%@ Pragma checkpoint failed:%s ErrCode: %d.",  v5,  v39,  v40,  v41);
    }

    if (v8 && v44) {
      operator delete[](v8);
    }
    if (v5) {
      sqlite3_close(v5);
    }
  }

  __releaseStorageAssertion(v42);
}

void sub_182A40F90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CFURLCacheSetMemoryCapacity(void *result, uint64_t a2)
{
  if (result)
  {
    id v3 = result;
    uint64_t TypeID = CFURLCacheGetTypeID();
    uint64_t result = (void *)CFGetTypeID(v3);
    if ((void *)TypeID == result)
    {
      uint64_t v5 = v3[2];
      *(void *)(v5 + 16_Block_object_dispose(va, 8) = a2;
      v6.i64[0] = a2;
      v6.i64[1] = *(void *)(v5 + 176);
      *(int64x2_t *)(v5 + 18os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v6), *(double *)(v5 + 200)));
    }

    else
    {
      char v7 = (const char *)CFURLCacheSetMemoryCapacity::s;
      if (!CFURLCacheSetMemoryCapacity::s)
      {
        char v7 = sel_registerName("_nscfBridgeURLCacheSetMemoryCapacity:");
        CFURLCacheSetMemoryCapacity::s = (uint64_t)v7;
      }

      return objc_msgSend(v3, v7, a2);
    }
  }

  return result;
}

void *_CFURLCacheSetMemoryLimit(void *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v5 = result;
    uint64_t TypeID = CFURLCacheGetTypeID();
    uint64_t result = (void *)CFGetTypeID(v5);
    if ((void *)TypeID == result)
    {
      uint64_t v7 = v5[2];
      *(void *)(v7 + 16_Block_object_dispose(va, 8) = a2;
      if (a3 < 1 || a3 >= a2)
      {
        double v8 = *(double *)(v7 + 200);
        a3 = (uint64_t)(v8 * (double)a2);
        *(void *)(v7 + 192) = (uint64_t)(v8 * (double)*(uint64_t *)(v7 + 176));
      }

      *(void *)(v7 + 18os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a3;
    }

    else
    {
      id v9 = (const char *)_CFURLCacheSetMemoryLimit::s;
      if (!_CFURLCacheSetMemoryLimit::s)
      {
        id v9 = sel_registerName("_nscfBridgeURLCacheSetMemoryCapacity:");
        _CFURLCacheSetMemoryLimit::s = (uint64_t)v9;
      }

      return objc_msgSend(v5, v9, a2);
    }
  }

  return result;
}

void _CFURLCacheSetCacheEventCallBackBlock(uint64_t a1, void *aBlock, dispatch_object_t object)
{
  uint64_t v5 = *(void *)(a1 + 16);
  int64x2_t v6 = *(const void **)(v5 + 32);
  if (v6 != aBlock)
  {
    if (v6)
    {
      _Block_release(v6);
      uint64_t v5 = *(void *)(a1 + 16);
      *(void *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
    }

    if (aBlock)
    {
      double v8 = _Block_copy(aBlock);
      uint64_t v5 = *(void *)(a1 + 16);
      *(void *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v8;
    }
  }

  id v9 = *(dispatch_object_s **)(v5 + 24);
  if (v9 != object)
  {
    if (v9)
    {
      dispatch_release(v9);
      uint64_t v5 = *(void *)(a1 + 16);
      *(void *)(v5 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
    }

    if (object)
    {
      *(void *)(v5 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = object;
      dispatch_retain(object);
    }
  }

void _CFCachedURLResponseSetBecameFileBackedCallBackBlock(void *a1, const void *a2, dispatch_queue_s *a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v6 = CFURLCacheCopySharedURLCache();
  if (!v6 || (v7 = (const void *)v6, TypeID = CFURLCacheGetTypeID(), CFTypeID v9 = CFGetTypeID(v7), CFRelease(v7), TypeID == v9))
  {
    uint64_t v10 = a1[2];
    uint64_t v11 = *(const void **)(v10 + 16);
    if (v11 != a2)
    {
      if (v11)
      {
        _Block_release(v11);
        uint64_t v10 = a1[2];
        *(void *)(v10 + 16) = 0LL;
      }

      if (a2)
      {
        id v12 = _Block_copy(a2);
        uint64_t v10 = a1[2];
        *(void *)(v10 + 16) = v12;
      }
    }

    int v13 = *(dispatch_object_s **)(v10 + 8);
    if (v13 == a3) {
      goto LABEL_28;
    }
    if (v13)
    {
      dispatch_release(v13);
      uint64_t v10 = a1[2];
      *(void *)(v10 + _Block_object_dispose(va, 8) = 0LL;
    }

    if (!a3 || (*(void *)(v10 + 8) = a3, dispatch_retain(a3), (uint64_t v10 = a1[2]) != 0))
    {
LABEL_28:
      if (*(void *)(v10 + 16) && *(void *)(v10 + 8))
      {
        uint64_t v14 = (os_unfair_lock_s *)(v10 + 88);
        os_unfair_lock_lock((os_unfair_lock_t)(v10 + 88));
        int v15 = *(const void **)(v10 + 128);
        os_unfair_lock_unlock(v14);
        if (v15)
        {
          uint64_t v16 = CFURLCacheCopySharedURLCache();
          if (v16)
          {
            id v17 = (void *)v16;
            uint64_t v18 = *(void *)(v16 + 16);
            if (v18)
            {
              pthread_mutex_lock((pthread_mutex_t *)(v18 + 456));
              uint64_t v19 = v17[2];
              uint64_t v20 = *(__CFDictionary **)(v19 + 520);
              if (v20)
              {
                CFDictionaryAddValue(v20, v15, a1);
                *(void *)&__int128 buf = 0LL;
                *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &buf;
                uint64_t v25 = 0x2020000000LL;
                CFTypeRef v26 = CFRetain(v15);
                dispatch_time_t v21 = dispatch_time(0LL, 10000000000LL);
                block[0] = MEMORY[0x1895F87A8];
                block[1] = 3221225472LL;
                block[2] = ___CFCachedURLResponseSetBecameFileBackedCallBackBlock_block_invoke;
                block[3] = &unk_189C17740;
                block[4] = &buf;
                dispatch_after(v21, a3, block);
                _Block_object_dispose(&buf, 8);
                uint64_t v19 = v17[2];
              }

              pthread_mutex_unlock((pthread_mutex_t *)(v19 + 456));
            }

            CFRelease(v17);
          }
        }

        else
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          id v22 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a1;
            _os_log_error_impl( &dword_18298D000,  v22,  OS_LOG_TYPE_ERROR,  "VM: ADD attempt FAILED for cached response %p. No key found.",  (uint8_t *)&buf,  0xCu);
          }
        }
      }
    }
  }

const void *_CFCachedURLResponseGetMemMappedData(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (*(_BYTE *)(v1 + 120) && (double v2 = *(const __CFArray **)(v1 + 80)) != 0LL) {
    return CFArrayGetValueAtIndex(v2, 0LL);
  }
  else {
    return 0LL;
  }
}

void CFURLCacheSetDiskCapacity(void *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      if (a2 >= 5242880 || !a2)
      {
        uint64_t v6 = a1[2];
        *(void *)(v6 + 176) = a2;
        v7.i64[0] = *(void *)(v6 + 168);
        v7.i64[1] = a2;
        *(int64x2_t *)(v6 + 18os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = vcvtq_s64_f64(vmulq_n_f64(vcvtq_f64_s64(v7), *(double *)(v6 + 200)));
        os_unfair_lock_lock((os_unfair_lock_t)(v6 + 124));
        uint64_t v8 = *(void *)(v6 + 128);
        if (v8) {
          *(void *)(v8 + 176) = a2;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 124));
      }
    }

    else
    {
      uint64_t v5 = (const char *)CFURLCacheSetDiskCapacity::s;
      if (!CFURLCacheSetDiskCapacity::s)
      {
        uint64_t v5 = sel_registerName("_nscfBridgeURLCacheSetDiskCapacity:");
        CFURLCacheSetDiskCapacity::s = (uint64_t)v5;
      }

      objc_msgSend(a1, v5, a2);
    }
  }

void *CFURLCacheCurrentMemoryUsage(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t TypeID = CFURLCacheGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      return *(void **)(v1[2] + 144LL);
    }

    else
    {
      id v3 = (const char *)CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s;
      if (!CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s)
      {
        id v3 = sel_registerName("_nscfBridgeURLCacheCurrentMemoryUsage");
        CFURLCacheCurrentMemoryUsage(_CFURLCache const*)::s = (uint64_t)v3;
      }

      return [v1 v3];
    }
  }

  return result;
}

id CFURLCacheCurrentDiskUsage(__CFURLCache **a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t TypeID = CFURLCacheGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    id v3 = __CFURLCache::createAndOpenCacheDB(a1[2]);
    if (v3)
    {
      uint64_t v5 = v3;
      -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk](v3, v4);
      -[NSURLStorageURLCacheDB updateSQLiteDBCacheUsageOnDisk](v5);
      uint64_t v6 = v5[25];

      return (id)v6;
    }

    return 0LL;
  }

  uint64_t v8 = (const char *)CFURLCacheCurrentDiskUsage::s;
  if (!CFURLCacheCurrentDiskUsage::s)
  {
    uint64_t v8 = sel_registerName("_nscfBridgeURLCacheCurrentDiskUsage");
    CFURLCacheCurrentDiskUsage::s = (uint64_t)v8;
  }

  return [a1 v8];
}

uint64_t CFCachedURLResponseCreateWithData(uint64_t a1, const void *a2, const void *a3)
{
  v9[5] = *(const void **)MEMORY[0x1895F89C0];
  v9[0] = (const void *)MEMORY[0x1895F87A8];
  v9[1] = (const void *)3221225472LL;
  void v9[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2331;
  v9[3] = &__block_descriptor_40_e5_v8__0l;
  v9[4] = _CachedURLResponseRegisterClass;
  if (_CFCachedURLResponseClassRegistration != -1) {
    dispatch_once(&_CFCachedURLResponseClassRegistration, v9);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v6 = operator new(0x88uLL);
    *uint64_t v6 = off_189C038F0;
    v6[4] = CFRetain(a2);
    v6[5] = 0LL;
    *((_DWORD *)v6 + 22) = 0;
    if (a3)
    {
      v9[0] = a3;
      v6[9] = CFRetain(a3);
      CFArrayRef v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], v9, 1LL, MEMORY[0x189605228]);
    }

    else
    {
      CFArrayRef v7 = 0LL;
      v6[9] = 0LL;
    }

    v6[10] = v7;
    uint8_t v6[8] = 0LL;
    *((_DWORD *)v6 + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
    v6[6] = 0LL;
    v6[16] = 0LL;
    v6[1] = 0LL;
    v6[2] = 0LL;
    v6[13] = 0LL;
    v6[14] = 0LL;
    v6[12] = 0LL;
    *((_BYTE *)v6 + 120) = 0;
    __CFCachedURLResponse::Encode((__CFCachedURLResponse *)v6);
    *(void *)(Instance + 16) = v6;
  }

  return Instance;
}

void sub_182A41854(_Unwind_Exception *a1)
{
}

uint64_t CFCachedURLResponseCreateWithDataArray( uint64_t a1, const void *a2, const void *a3, const void *a4, int a5)
{
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZL19_dispatch_once_funcPlPFvvE_block_invoke_2331;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = _CachedURLResponseRegisterClass;
  if (_CFCachedURLResponseClassRegistration != -1) {
    dispatch_once(&_CFCachedURLResponseClassRegistration, block);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v10 = operator new(0x88uLL);
    *uint64_t v10 = off_189C038F0;
    CFTypeRef v11 = CFRetain(a2);
    v10[5] = 0LL;
    v10[4] = v11;
    v10[6] = 0LL;
    v10[9] = 0LL;
    v10[10] = 0LL;
    v10[8] = 0LL;
    *((_DWORD *)v10 + 22) = 0;
    v10[13] = 0LL;
    v10[14] = 0LL;
    v10[12] = 0LL;
    if (a4) {
      v10[5] = CFRetain(a4);
    }
    if (a3)
    {
      v10[10] = CFRetain(a3);
      if (CFArrayGetCount((CFArrayRef)a3) == 1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, 0LL);
        if (ValueAtIndex) {
          v10[9] = CFRetain(ValueAtIndex);
        }
      }
    }

    *((_DWORD *)v10 + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a5;
    *((_BYTE *)v10 + 120) = 0;
    uint8_t v10[16] = 0LL;
    v10[1] = 0LL;
    _DWORD v10[2] = 0LL;
    __CFCachedURLResponse::Encode((__CFCachedURLResponse *)v10);
    *(void *)(Instance + 16) = v10;
  }

  return Instance;
}

void sub_182A419D4(_Unwind_Exception *a1)
{
}

uint64_t CFCachedURLResponseGetWrappedResponse(uint64_t result)
{
  if (result) {
    return *(void *)(*(void *)(result + 16) + 32LL);
  }
  return result;
}

__CFData *CFCachedURLResponseGetReceiverData(__CFData *result)
{
  if (result) {
    return __CFCachedURLResponse::GetReceiverData(*((__CFCachedURLResponse **)result + 2));
  }
  return result;
}

uint64_t CFCachedURLResponseGetStoragePolicy(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(*(void *)(a1 + 16) + 56LL);
  }
  else {
    return 2LL;
  }
}

uint64_t CFCachedURLResponseSetStoragePolicy(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(*(void *)(result + 16) + 56LL) = a2;
  }
  return result;
}

void ___ZN12__CFURLCache6ShrinkEP22NSURLStorageURLCacheDB_block_invoke(void *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  double v2 = (__CFURLCache *)a1[5];
  __retainStorageAssertion(*(void **)(*(void *)(a1[6] + 16LL) + 136LL));
  uint64_t v5 = a1[4];
  if (v5)
  {
    buf[0] = 0;
    uint64_t v6 = -[NSURLStorageURLCacheDB openReadWriteConnection]((void *)v5, v3);
    if (v6)
    {
      CFArrayRef v7 = v6;
      if (-[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  "BEGIN IMMEDIATE",  v6,  0))
      {
        CFLog();
      }

      else
      {
        uint64_t v8 = sqlite3_mprintf( "SELECT receiver_data, entry_ID from cfurl_cache_receiver_data WHERE isDataOnFS > 0 AND entry_ID in \t\t\t \t\t\t\t\t (SELECT entry_ID from cfurl_cache_response WHERE entry_ID > 0 ORDER BY time_stamp ASC LIMIT %d)",  1500);
        uint64_t v9 = sqlite3_exec( v7,  v8,  (int (__cdecl *)(void *, int, char **, char **))SQLHostForDeleteCallback,  (void *)v5,  0LL);
        sqlite3_free(v8);
        if ((_DWORD)v9)
        {
          uint64_t v31 = v9;
          CFLog();
        }

        objc_msgSend(*(id *)(v5 + 136), "componentsJoinedByString:", @",", v31);
        uint64_t v10 = (const __CFString *)objc_claimAutoreleasedReturnValue();
        CFTypeRef v11 = (__CFString *)v10;
        if (v10)
        {
          CStringfromCFStringRef = _ExtractCStringfromCFStringRef(v10, (BOOL *)buf);
          int v13 = CStringfromCFStringRef;
          if (CStringfromCFStringRef)
          {
            uint64_t v14 = sqlite3_mprintf( "DELETE from %s WHERE entry_ID in (%s)",  "cfurl_cache_blob_data",  CStringfromCFStringRef);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  v14,  v7,  0);
            sqlite3_free(v14);
            int v15 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_receiver_data", v13);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  v15,  v7,  0);
            sqlite3_free(v15);
            uint64_t v16 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_response", v13);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  v16,  v7,  0);
            sqlite3_free(v16);
            if (buf[0]) {
              operator delete[](v13);
            }
          }
        }

        [*(id *)(v5 + 136) removeAllObjects];
        id v17 = sqlite3_mprintf( "SELECT entry_ID from cfurl_cache_receiver_data WHERE isDataOnFS < 1 AND entry_ID in \t\t\t\t\t\t\t\t (SE LECT entry_ID from cfurl_cache_response WHERE entry_ID > 0 ORDER BY time_stamp ASC LIMIT %d)",  500);
        uint64_t v18 = sqlite3_exec( v7,  v17,  (int (__cdecl *)(void *, int, char **, char **))SQLHostForDeleteCallback,  (void *)v5,  0LL);
        sqlite3_free(v17);
        if ((_DWORD)v18)
        {
          uint64_t v32 = v18;
          CFLog();
        }

        objc_msgSend(*(id *)(v5 + 136), "componentsJoinedByString:", @",", v32);
        uint64_t v19 = (__CFString *)objc_claimAutoreleasedReturnValue();

        if (v19)
        {
          uint64_t v20 = _ExtractCStringfromCFStringRef(v19, (BOOL *)buf);
          dispatch_time_t v21 = v20;
          if (v20)
          {
            id v22 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_blob_data", v20);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  v22,  v7,  0);
            sqlite3_free(v22);
            uint64_t v23 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_receiver_data", v21);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  v23,  v7,  0);
            sqlite3_free(v23);
            uint64_t v24 = sqlite3_mprintf("DELETE from %s WHERE entry_ID in (%s)", "cfurl_cache_response", v21);
            -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  v24,  v7,  0);
            sqlite3_free(v24);
            if (buf[0]) {
              operator delete[](v21);
            }
          }
        }

        [*(id *)(v5 + 136) removeAllObjects];
        -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  "COMMIT",  v7,  0);
        -[NSURLStorageURLCacheDB execSQLStatement:onConnection:toCompletionWithRetry:writeLockHeld:]( (os_unfair_lock_s *)v5,  "PRAGMA incremental_vacuum(500);",
          v7,
          0);
      }

      sqlite3_close(v7);
    }
  }

  __releaseStorageAssertion(v4);
  CFTypeRef v26 = (void *)a1[4];
  if (v26)
  {
    -[NSURLStorageURLCacheDB updateFSBackedCacheUsageOnDisk]((void *)a1[4], v25);
    -[NSURLStorageURLCacheDB updateSQLiteDBCacheUsageOnDisk](v26);
    unint64_t v27 = v26[25];
    unint64_t v28 = a1[4];
    if (v28) {
      unint64_t v28 = *(void *)(v28 + 176);
    }
    if (v27 > v28)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v29 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 134217984;
        unint64_t v34 = v27;
        _os_log_error_impl( &dword_18298D000,  v29,  OS_LOG_TYPE_ERROR,  "Cache storage usage (%lu) still exceeds limit after cache shrinking. Purging persistent cache.",  buf,  0xCu);
      }

      __CFURLCache::PurgePersistentCache(v2);
    }
  }

  unint64_t v30 = (void *)a1[6];
  *(_BYTE *)(v30[2] + 121LL) = 0;
  CFRelease(v30);
}

void sub_182A41EC0(_Unwind_Exception *exception_object)
{
}

uint64_t __CFURLCache::ReplaceDataInMemoryCacheResponseWithMMappedData( __CFURLCache *this, _CFCachedURLResponse *a2, CFURLCacheFS *a3, const __CFString *a4)
{
  CFArrayRef v7 = (pthread_mutex_t *)((char *)this + 312);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 312));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 456));
  uint64_t v8 = (const __CFDictionary *)*((void *)this + 65);
  if (v8
    && CFDictionaryGetCount(v8) >= 1
    && (unsigned int Value = (__CFCachedURLResponse **)CFDictionaryGetValue(*((CFDictionaryRef *)this + 65), a3)) != 0LL)
  {
    uint64_t v10 = Value;
    CFRetain(Value);
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 65), a3);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
    uint64_t v23 = 0LL;
    bytes = 0LL;
    if (CFURLCacheFS::getCachedResponseDataFromFS((CFURLCacheFS *)a2, (void **)&bytes, &v23))
    {
      CFTypeRef v11 = operator new(0x10uLL);
      CFIndex v12 = v23;
      *CFTypeRef v11 = this;
      v11[1] = v12;
      int v13 = (const void *)*((void *)this + 55);
      if (v13) {
        CFRetain(v13);
      }
      context.version = 0LL;
      context.mach_timebase_info info = v11;
      memset(&context.retain, 0, 40);
      context.deallocate = (CFAllocatorDeallocateCallBack)mmapFileDeallocate;
      context.preferredint Size = 0LL;
      uint64_t v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      int v15 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x189604DB0], &context);
      if (v15)
      {
        uint64_t v16 = v15;
        id v17 = bytes;
        uint64_t v18 = CFDataCreateWithBytesNoCopy(v14, bytes, v12, v15);
        __CFURLCache::addMMappedDataToSet(this, v17);
        CFRelease(v16);
        if (v18)
        {
          __CFCachedURLResponse::SetReceiverData(v10[2], v18);
          uint64_t v19 = v10[2];
          *((_BYTE *)v19 + 120) = 1;
          if (*((void *)v19 + 2))
          {
            uint64_t v20 = (dispatch_queue_s *)*((void *)v19 + 1);
            if (v20) {
              dispatch_time_t v21 = v20;
            }
            else {
              dispatch_time_t v21 = (dispatch_queue_s *)MEMORY[0x1895F8AE0];
            }
            CFRetain(v10);
            context.version = MEMORY[0x1895F87A8];
            context.mach_timebase_info info = (void *)3221225472LL;
            context.retain = (CFAllocatorRetainCallBack)___ZL39notifyCachedURLResponseBecameFileBackedPK20_CFCachedURLResponse_block_invoke;
            context.release = (CFAllocatorReleaseCallBack)&__block_descriptor_40_e5_v8__0l;
            context.copyDescription = (CFAllocatorCopyDescriptionCallBack)v10;
            dispatch_async(v21, &context);
          }

          CFRelease(v18);
        }
      }
    }

    CFRelease(v10);
  }

  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 456));
  }

  return pthread_mutex_unlock(v7);
}

void sub_182A420BC(_Unwind_Exception *a1)
{
}

void ___ZL39notifyCachedURLResponseBecameFileBackedPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  double v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(v2[2] + 16LL);
}

uint64_t _CFURLCachePurgeMemoryCache(uint64_t a1)
{
  return __CFURLCache::PurgeMemoryCache(*(__CFURLCache **)(a1 + 16));
}

uint64_t _CFURLCacheGetSharedCache(void)
{
  return gSharedInstance;
}

uint64_t __createCachedResponseFromParts( int a1, const UInt8 *a2, CFIndex a3, UInt8 *bytes, CFIndex length, const UInt8 *a6, CFIndex a7, const UInt8 *a8, CFIndex a9, const UInt8 *a10, CFIndex a11)
{
  CFTypeRef cf = 0LL;
  int v15 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v16 = (const __CFAllocator *)*MEMORY[0x189604DC8];
  if (!bytes) {
    goto LABEL_10;
  }
  CFReadStreamRef v17 = CFReadStreamCreateWithBytesNoCopy(v15, bytes, length, v16);
  if (!CFReadStreamOpen(v17))
  {
    CFRelease(v17);
LABEL_10:
    dispatch_time_t v21 = 0LL;
    goto LABEL_11;
  }

  dispatch_time_t v21 = (__CFDictionary *)dep_CFPropertyListCreateFromStream(v15, v17, (CFStringRef *)&cf, v18, v19, v20);
  if (v21) {
    BOOL v22 = 1;
  }
  else {
    BOOL v22 = cf == 0LL;
  }
  if (!v22) {
    CFRelease(cf);
  }
  CFReadStreamClose(v17);
  CFRelease(v17);
LABEL_11:
  CFPropertyListFormat format = kCFPropertyListXMLFormat_v1_0;
  uint64_t v23 = CFDataCreateWithBytesNoCopy(v15, a2, a3, v16);
  if (v23)
  {
    uint64_t v24 = v23;
    uint64_t v25 = (const __CFAllocator *)CFPropertyListCreateWithData(v15, v23, 0LL, &format, &error);
    if (v25)
    {
      unint64_t v27 = v25;
      unint64_t v28 = (const _CFURLRequest *)_CFURLResponseCreateFromPropertyList(v25, v26);
      CFRelease(v24);
      uint64_t v24 = v27;
    }

    else
    {
      unint64_t v28 = 0LL;
    }

    CFRelease(v24);
  }

  else
  {
    unint64_t v28 = 0LL;
  }

  CFErrorRef error = (CFErrorRef)100;
  uint64_t v29 = CFDataCreateWithBytesNoCopy(v15, a8, a9, v16);
  if (!v29)
  {
    uint64_t v49 = 0LL;
    if (v28)
    {
LABEL_72:
      CFRelease(v28);
      goto LABEL_73;
    }

    goto LABEL_73;
  }

  unint64_t v30 = v29;
  uint64_t v31 = (const __CFData *)CFPropertyListCreateWithData(v15, v29, 0LL, (CFPropertyListFormat *)&error, &v66);
  if (!v31)
  {
    CFRange v48 = 0LL;
    CFErrorRef v50 = v66;
    uint64_t v32 = v30;
    if (!v66) {
      goto LABEL_49;
    }
    goto LABEL_48;
  }

  uint64_t v32 = v31;
  int v62 = a1;
  uint64_t v33 = objc_alloc_init(&OBJC_CLASS___NSURLRequestInternal);
  uint64_t v34 = -[NSURLRequestInternal _inner](v33, "_inner");
  CFTypeID v35 = CFGetTypeID(v32);
  if (v35 != CFDictionaryGetTypeID()) {
    goto LABEL_44;
  }
  unsigned int Value = (const __CFNumber *)CFDictionaryGetValue(v32, @"Version");
  if (!Value) {
    goto LABEL_44;
  }
  CFPropertyListFormat format = 0LL;
  CFPropertyListFormat v37 = CFNumberGetValue(Value, kCFNumberCFIndexType, &format) ? format : 0LL;
  uint64_t v38 = (const __CFArray *)CFDictionaryGetValue(v32, @"Array");
  if (!v38) {
    goto LABEL_44;
  }
  id v39 = v38;
  uint64_t v58 = v37;
  CFTypeRef v59 = (URLRequest *)v34;
  CFIndex v60 = v21;
  CFIndex Count = CFArrayGetCount(v38);
  uint64_t v41 = (const void **)calloc(Count, 8uLL);
  v69.CFIndex location = 0LL;
  v69.CFIndex length = Count;
  CFArrayGetValues(v39, v69, v41);
  uint64_t v61 = Count;
  if (Count >= 2)
  {
    double v42 = v41 - 1;
    uint64_t v43 = v61;
    do
    {
      CFTypeID v44 = CFGetTypeID(v42[v43]);
      if (v44 == CFStringGetTypeID() && CFEqual(@"__CFURLRequestNullTokenString__", v42[v43])) {
        v42[v43] = 0LL;
      }
      --v43;
    }

    while ((unint64_t)(v43 + 1) > 2);
  }

  if (v41[1]) {
    v41[1] = (const void *)_CFURLCreateFromPropertyListRepresentation();
  }
  dispatch_time_t v21 = v60;
  if (v41[4]) {
    v41[4] = (const void *)_CFURLCreateFromPropertyListRepresentation();
  }
  int v45 = URLRequest::initialize(v59, v58, v41, v61, v60);
  int v46 = v41[1];
  if (v46) {
    CFRelease(v46);
  }
  int v47 = v41[4];
  if (v47) {
    CFRelease(v47);
  }
  free(v41);
  if (!v45)
  {
LABEL_44:

    goto LABEL_45;
  }

  if (!v33)
  {
LABEL_45:
    CFRange v48 = 0LL;
    goto LABEL_46;
  }

  CFRange v48 = -[NSURLRequest _initWithInternal:](objc_alloc(&OBJC_CLASS___NSMutableURLRequest), "_initWithInternal:", v33);

LABEL_46:
  CFErrorRef v50 = v30;
  a1 = v62;
LABEL_48:
  CFRelease(v50);
  unint64_t v30 = v32;
LABEL_49:
  CFRelease(v30);
  if (v28 && v48)
  {
    if (a6)
    {
      CFDataRef v51 = CFDataCreate(v15, a6, a7);
      if (!a10) {
        goto LABEL_66;
      }
    }

    else
    {
      CFDataRef v51 = 0LL;
      if (!a10) {
        goto LABEL_66;
      }
    }

    int v52 = CFReadStreamCreateWithBytesNoCopy(v15, a10, a11, v16);
    if (CFReadStreamOpen(v52))
    {
      CFPropertyListRef v56 = dep_CFPropertyListCreateFromStream(v15, v52, (CFStringRef *)&cf, v53, v54, v55);
      if (!v56 && cf) {
        CFRelease(cf);
      }
      CFReadStreamClose(v52);
      CFRelease(v52);
      uint64_t v49 = CFCachedURLResponseCreateWithUserInfo((uint64_t)v15, v28, v51, v56, a1);
      if (v56) {
        CFRelease(v56);
      }
      goto LABEL_67;
    }

    CFRelease(v52);
LABEL_66:
    uint64_t v49 = CFCachedURLResponseCreateWithUserInfo((uint64_t)v15, v28, v51, 0LL, a1);
LABEL_67:
    if (v51) {
      CFRelease(v51);
    }
    if (v49) {
      __CFCachedURLResponse::SetRequest(*(__CFCachedURLResponse **)(v49 + 16), v48);
    }
    CFRelease(v28);
    unint64_t v28 = v48;
    goto LABEL_72;
  }

  if (v28) {
    CFRelease(v28);
  }
  uint64_t v49 = 0LL;
  unint64_t v28 = v48;
  if (v48) {
    goto LABEL_72;
  }
LABEL_73:
  if (v21) {
    CFRelease(v21);
  }
  return v49;
}

char *_CFURLCacheCreateFS3(const void *a1, const void *a2, const void *a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (char *)operator new(0x80uLL);
  *(void *)uint64_t v6 = off_189C12668;
  pthread_mutex_init((pthread_mutex_t *)(v6 + 8), 0LL);
  *(void *)uint64_t v6 = off_189C1A510;
  *(_OWORD *)(v6 + 72) = 0u;
  CFArrayRef v7 = (CFTypeRef *)(v6 + 72);
  *(_OWORD *)(v6 + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v6 + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  v6[120] = 0;
  *((void *)v6 + 9) = CFRetain(a1);
  uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  *((void *)v6 + 10) = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"%@/%s",  a1,  "fsCachedData");
  *((void *)v6 + 12) = CFRetain(a3);
  *((void *)v6 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = CFRetain(a2);
  uint64_t v9 = (const __CFString *)*((void *)v6 + 9);
  if (!v9 {
    || (*((void *)v6 + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = _ExtractCStringfromCFStringRef(v9, (BOOL *)v6 + 120),
  }
        (uint64_t v10 = (const __CFString *)*((void *)v6 + 9)) == 0LL))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v14 = CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
      return v6;
    }
    *(_WORD *)__int128 buf = 0;
    int v15 = "ERROR: Unable to generate the path to the cache file as the path is NULL.";
    uint64_t v16 = (os_log_s *)v14;
    uint32_t v17 = 2;
LABEL_19:
    _os_log_error_impl(&dword_18298D000, v16, OS_LOG_TYPE_ERROR, v15, buf, v17);
    return v6;
  }

  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v8, 0LL, v10);
  *((void *)v6 + 13) = MutableCopy;
  if (MutableCopy)
  {
    uint64_t v12 = *((void *)v6 + 12);
    if (v12)
    {
      CFStringAppendFormat(MutableCopy, 0LL, @"/%@/%@", @"fsCachedData", v12);
      if (*v7) {
        CFRelease(*v7);
      }
      CFTypeRef v13 = (CFTypeRef)*((void *)v6 + 13);
      if (v13) {
        CFTypeRef v13 = CFRetain(v13);
      }
      CFTypeRef *v7 = v13;
      return v6;
    }
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v18 = CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = *((void *)v6 + 12);
    uint64_t v20 = *((void *)v6 + 13);
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v23 = v20;
    __int16 v24 = 2112;
    uint64_t v25 = v21;
    int v15 = "ERROR: The path to the FS cached directory (%@) or the UUID (%@) is wrong.";
    uint64_t v16 = (os_log_s *)v18;
    uint32_t v17 = 22;
    goto LABEL_19;
  }

  return v6;
}

void sub_182A42850(_Unwind_Exception *a1)
{
}

CFURLCacheFS *_CFURLCacheCreateFS2(const __CFString *a1)
{
  if (!a1) {
    return 0LL;
  }
  double v2 = (CFURLCacheFS *)operator new(0x80uLL);
  CFURLCacheFS::CFURLCacheFS(v2, a1);
  return v2;
}

void sub_182A428B8(_Unwind_Exception *a1)
{
}

void _CFURLCacheFlush(uint64_t a1, void (**a2)(void))
{
  if (IsCFURLCache(a1))
  {
    dispatch_async(*(dispatch_queue_t *)(*(void *)(a1 + 16) + 136LL), a2);
  }

  else
  {
    CFURLCacheCurrentDiskUsage((__CFURLCache **)a1);
    a2[2](a2);
  }

BOOL HTTP2Connection::equals(HTTP2Connection *this, const CFObject *a2)
{
  CFTypeID v4 = CFGetTypeID((char *)this - 16);
  uint64_t v5 = (*(uint64_t (**)(const CFObject *))(*(void *)a2 + 8LL))(a2);
  return v5 == (*(uint64_t (**)(HTTP2Connection *))(*(void *)this + 8LL))(this);
}

CFStringRef HTTP2Connection::copyDebugDesc(HTTP2Connection *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"HTTP2Connection<%p>", this);
}

void HTTP2Connection::_onqueue_pingWithPongHandler(uint64_t a1, const void *a2)
{
  if (!*(void *)(a1 + 160)) {
    return;
  }
  nghttp2_submit_ping();
  uint64_t v5 = _Block_copy(a2);
  unint64_t v6 = *(void *)(a1 + 664);
  unint64_t v7 = *(void *)(a1 + 680);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v2 = *(void *)(a1 + 664);
      if (v6 >= v7) {
        unint64_t v2 = v6 % v7;
      }
    }

    else
    {
      unint64_t v2 = (v7 - 1) & v6;
    }

    uint64_t v9 = *(void **)(*(void *)(a1 + 672) + 8 * v2);
    if (v9)
    {
      for (CFIndex i = (void *)*v9; i; CFIndex i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6) {
            goto LABEL_76;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v2) {
            break;
          }
        }
      }
    }
  }

  uint64_t v12 = operator new(0x28uLL);
  void *v12 = 0LL;
  v12[1] = v6;
  _DWORD v12[2] = v6;
  v12[3] = 0LL;
  v12[4] = v5;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 696) + 1LL);
  float v14 = *(float *)(a1 + 704);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1LL)
    {
      int8x8_t prime = (int8x8_t)2LL;
    }

    else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *(void *)(a1 + 680);
    }

    if (*(void *)&prime > v7) {
      goto LABEL_32;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 696) / *(float *)(a1 + 704));
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }

      else
      {
        uint64_t v27 = 1LL << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }

      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *(void *)(a1 + 680);
      }

      else
      {
        if (prime)
        {
LABEL_32:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v19 = operator new(8LL * *(void *)&prime);
          uint64_t v20 = *(void **)(a1 + 672);
          *(void *)(a1 + 672) = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0LL;
          *(int8x8_t *)(a1 + 680) = prime;
          do
            *(void *)(*(void *)(a1 + 672) + 8 * v21++) = 0LL;
          while (*(void *)&prime != v21);
          BOOL v22 = *(void **)(a1 + 688);
          if (v22)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }

            else
            {
              v23 &= *(void *)&prime - 1LL;
            }

            *(void *)(*(void *)(a1 + 672) + 8 * v23) = a1 + 688;
            unint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }

                else
                {
                  v29 &= *(void *)&prime - 1LL;
                }

                if (v29 != v23)
                {
                  uint64_t v30 = *(void *)(a1 + 672);
                  if (!*(void *)(v30 + 8 * v29))
                  {
                    *(void *)(v30 + 8 * v29) = v22;
                    goto LABEL_57;
                  }

                  void *v22 = *v28;
                  void *v28 = **(void **)(*(void *)(a1 + 672) + 8 * v29);
                  **(void **)(*(void *)(a1 + 672) + 8 * v29) = v28;
                  unint64_t v28 = v22;
                }

                unint64_t v29 = v23;
LABEL_57:
                BOOL v22 = v28;
                unint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }

              while (v28);
            }
          }

          unint64_t v7 = (unint64_t)prime;
          goto LABEL_61;
        }

        uint64_t v34 = *(void **)(a1 + 672);
        *(void *)(a1 + 672) = 0LL;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0LL;
        *(void *)(a1 + 680) = 0LL;
      }
    }

LABEL_61:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v2 = v6 % v7;
      }
      else {
        unint64_t v2 = v6;
      }
    }

    else
    {
      unint64_t v2 = (v7 - 1) & v6;
    }
  }

  uint64_t v31 = *(void *)(a1 + 672);
  uint64_t v32 = *(void **)(v31 + 8 * v2);
  if (v32)
  {
    void *v12 = *v32;
  }

  else
  {
    void *v12 = *(void *)(a1 + 688);
    *(void *)(a1 + 68_Block_object_dispose(va, 8) = v12;
    *(void *)(v31 + 8 * v2) = a1 + 688;
    if (!*v12) {
      goto LABEL_75;
    }
    unint64_t v33 = *(void *)(*v12 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v33 >= v7) {
        v33 %= v7;
      }
    }

    else
    {
      v33 &= v7 - 1;
    }

    uint64_t v32 = (void *)(*(void *)(a1 + 672) + 8 * v33);
  }

  *uint64_t v32 = v12;
LABEL_75:
  ++*(void *)(a1 + 696);
  unint64_t v6 = *(void *)(a1 + 664);
LABEL_76:
  *(void *)(a1 + 66os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6 + 1;
  HTTP2Connection::_onqueue_scheduleIO((HTTP2Connection *)a1);
}

  *(void *)(*(void *)(*(void *)(v2 + 48) + 8LL) + 4_CFNetworkResetHSTSHostsSinceDate(0LL, 0LL) = v3;
  return result;
}

void sub_182A42DEC(_Unwind_Exception *a1)
{
}

void HTTP2Connection::connEventReadClose(HTTP2Connection *this)
{
  if (!(*((void *)this + 18) | *((unsigned int *)this + 38)))
  {
    *((_BYTE *)this + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
    HTTP2Connection::stopIfNoOutstandingRequests(this);
  }

void HTTP2Connection::connEventDisconnected(HTTP2Connection *this)
{
  if (!(*((void *)this + 18) | *((unsigned int *)this + 38)))
  {
    *((void *)this + 1_Block_object_dispose(va, 8) = 4LL;
    *((_DWORD *)this + 3_Block_object_dispose(va, 8) = -4;
    HTTP2Connection::closeConnection(this, 0);
  }

void HTTP2Connection::connErrorOccurred(CFStreamError *this, CFStreamError a2)
{
  this[9] = a2;
  HTTP2Connection::closeConnection((HTTP2Connection *)this, 0);
}

uint64_t HTTP2Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
  HTTP2Connection::stopIfNoOutstandingRequests((HTTP2Connection *)a1);
  v21.domain = 4LL;
  v21.CFErrorRef error = -5;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 232));
  if (Count >= 1)
  {
    CFIndex v5 = Count;
    for (CFIndex i = 0LL; i != v5; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 232), i);
      uint64_t v9 = (HTTP2Stream *)*((void *)ValueAtIndex + 3);
      uint8x8_t v8 = (std::__shared_weak_count *)*((void *)ValueAtIndex + 4);
      if (v8)
      {
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          unint64_t v11 = __ldxr(p_shared_owners);
        while (__stxr(v11 + 1, p_shared_owners));
      }

      if ((a2 & 0xFFFFFFFD) == 1
        && (uint64_t v12 = *((void *)v9 + 2)) != 0
        && (*(unsigned int (**)(uint64_t, CFStreamError *, void))(*(void *)v12 + 280LL))(v12, &v21, 0LL)
         - 5 <= 5)
      {
        HTTP2Stream::setError(v9, v21);
        HTTP2Stream::closeStreamWithErrorCode(v9);
        if (v8)
        {
          float v13 = (unint64_t *)&v8->__shared_owners_;
          do
            unint64_t v14 = __ldxr(v13);
          while (__stxr(v14 + 1, v13));
        }

        HTTP2Connection::cancelStream(a1, (uint64_t)v9, v8);
        if (v8)
        {
          BOOL v15 = (unint64_t *)&v8->__shared_owners_;
          do
            unint64_t v16 = __ldaxr(v15);
          while (__stlxr(v16 - 1, v15));
          if (!v16)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }

      else
      {
        uint64_t v17 = *((void *)v9 + 2);
        if (v17) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 248LL))(v17, a2);
        }
      }

      if (v8)
      {
        uint64_t v18 = (unint64_t *)&v8->__shared_owners_;
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
  }

  return 1LL;
}

void sub_182A43008( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void non-virtual thunk to'HTTP2Connection::~HTTP2Connection(HTTP2Connection *this)
{
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 8));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 16));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 16));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 24));
}

{
  HTTP2Connection::~HTTP2Connection((HTTP2Connection *)((char *)this - 24));
}

void non-virtual thunk to'HTTP2Connection::connEventDisconnected(HTTP2Connection *this)
{
}

void non-virtual thunk to'HTTP2Connection::connErrorOccurred(CFStreamError *this, CFStreamError a2)
{
  this[8] = a2;
  HTTP2Connection::closeConnection((HTTP2Connection *)&this[-1], 0);
}

uint64_t non-virtual thunk to'HTTP2Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

void non-virtual thunk to'HTTP2Connection::_onqueue_pingWithPongHandler(uint64_t a1, const void *a2)
{
}

void ___ZN15HTTP2ConnectionD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t RetainableTypedDict<__CFNumber const*,__CFDictionary *>::~RetainableTypedDict(uint64_t a1)
{
  *(void *)a1 = off_189C03F40;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<__CFNumber const*,__CFDictionary *>::~RetainableTypedDict(CFTypeRef *a1)
{
  *a1 = off_189C03F40;
  CFRelease(a1[1]);
  operator delete(a1);
}

void HTTP2Connection::closeConnection(HTTP2Connection *this, char a2)
{
  CFTypeID v4 = (dispatch_queue_s *)*((void *)this + 21);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZN15HTTP2Connection15closeConnectionEb_block_invoke;
  v5[3] = &__block_descriptor_41_e5_v8__0l;
  v5[4] = this;
  char v6 = a2;
  dispatch_async(v4, v5);
}

void ___ZN15HTTP2Connection15closeConnectionEb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(HTTP2Connection **)(a1 + 32);
  HTTP2Connection::_onqueue_closeConnection(v1, *(_BYTE *)(a1 + 40), 0LL);
  CFRelease((char *)v1 - 16);
}

void HTTP2Connection::_onqueue_closeConnection(HTTP2Connection *this, char a2, uint64_t a3)
{
  if (*((_DWORD *)this + 44) != 3)
  {
    CFStringRef Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], *((CFArrayRef *)this + 29));
    CFIndex v7 = 0LL;
    uint8x8_t v8 = (char *)this - 16;
    while (v7 < CFArrayGetCount(Copy))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 29), v7);
      uint64_t v10 = *((void *)ValueAtIndex + 3);
      unint64_t v11 = (std::__shared_weak_count *)*((void *)ValueAtIndex + 4);
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          unint64_t v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
        do
          unint64_t v14 = __ldaxr(p_shared_owners);
        while (__stlxr(v14 - 1, p_shared_owners));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }

      if (*(void *)(v10 + 432))
      {
        LODWORD(v35) = *(_DWORD *)(v10 + 80);
        BOOL v15 = CFGetAllocator((char *)this - 16);
        CFNumberRef v16 = CFNumberCreate(v15, kCFNumberSInt32Type, &v35);
        __NSURLSessionTaskDependency_RemoveRequest( *(void **)(v10 + 432),  (uint64_t)v16,  *((void **)this + 5),  *(void *)(v10 + 48));
        if (v16) {
          CFRelease(v16);
        }
      }

      HTTP2Stream::breakStreamUserDataCycle((HTTP2Stream *)v10);
      if (*(_DWORD *)(v10 + 56) != 3)
      {
        if (*((_DWORD *)this + 38)) {
          HTTP2Stream::setError((HTTP2Stream *)v10, *((CFStreamError *)this + 9));
        }
        HTTP2Stream::closeStreamWithErrorCode((HTTP2Stream *)v10);
      }

      if (*((void *)this + 20)) {
        nghttp2_session_set_stream_user_data();
      }
      ++v7;
    }

    CFRelease(Copy);
    if (*((void *)this + 90)) {
      HTTP2Connection::stopStallRecovery((dispatch_source_t *)this);
    }
    uint64_t v17 = (HTTPStallTimer *)*((void *)this + 81);
    if (v17)
    {
      HTTPStallTimer::invalidate(v17);
      __int128 v35 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 648, &v35);
      uint64_t v18 = (std::__shared_weak_count *)*((void *)&v35 + 1);
      if (*((void *)&v35 + 1))
      {
        unint64_t v19 = (unint64_t *)(*((void *)&v35 + 1) + 8LL);
        do
          unint64_t v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }

    *((_BYTE *)this + 640) = 1;
    BOOL v21 = (a2 & 1) == 0 && *((_DWORD *)this + 44) != 4;
    if (*((void *)this + 20))
    {
      int v22 = nghttp2_session_terminate_session();
      char v23 = !v21;
      if (v22) {
        char v23 = 1;
      }
      if ((v23 & 1) == 0) {
        HTTP2Connection::_onqueue_scheduleIO(this);
      }
      nghttp2_session_del();
      *((void *)this + 20) = 0LL;
    }

    unint64_t v25 = (int **)((char *)this + 56);
    uint64_t v24 = *((void *)this + 7);
    *((_DWORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 3;
    if (v24)
    {
      if (*(_DWORD *)v24 == 1)
      {
        TransportConnection::rstConnectionDelegate(*(TransportConnection **)(v24 + 8));
        int v26 = **v25;
        if (v26 != 2)
        {
          if (v26 != 1) {
            __assert_rtn("close", "TCPIOConnectionTest.hpp", 276, "false");
          }
          (*(void (**)(void, uint64_t))(**((void **)*v25 + 1) + 152LL))(*((void *)*v25 + 1), a3);
        }
      }

      else if (*(_DWORD *)v24 != 2)
      {
        __assert_rtn("rstConnectionDelegate", "TCPIOConnectionTest.hpp", 266, "false");
      }

      _Block_release(*((const void **)this + 14));
      _Block_release(*((const void **)this + 15));
      _Block_release(*((const void **)this + 16));
      *((void *)this + CFRetain((char *)this - 16) = 0LL;
      __int128 v35 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 56, &v35);
      uint64_t v27 = (std::__shared_weak_count *)*((void *)&v35 + 1);
      if (*((void *)&v35 + 1))
      {
        unint64_t v28 = (unint64_t *)(*((void *)&v35 + 1) + 8LL);
        do
          unint64_t v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }

    uint64_t v30 = *((void *)this + 30);
    if (*(void *)(v30 + 72))
    {
      CFRetain((CFTypeRef)(v30 - 16));
      uint64_t v31 = *(void *)(v30 + 72);
      *(void *)&__int128 v35 = MEMORY[0x1895F87A8];
      *((void *)&v35 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3221225472LL;
      __int16 v36 = ___ZN25HTTP2ConnectionCacheEntry16connectionClosedEP15HTTP2Connection_block_invoke;
      CFPropertyListFormat v37 = &__block_descriptor_48_e5_v8__0l;
      uint64_t v38 = v30;
      id v39 = this;
      (*(void (**)(uint64_t, __int128 *))(*(void *)v31 + 96LL))(v31, &v35);
    }

    __int128 v35 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 272, &v35);
    uint64_t v32 = (std::__shared_weak_count *)*((void *)&v35 + 1);
    if (*((void *)&v35 + 1))
    {
      unint64_t v33 = (unint64_t *)(*((void *)&v35 + 1) + 8LL);
      do
        unint64_t v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }

    CFRelease(v8);
  }

void sub_182A43590(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void HTTP2Connection::stopStallRecovery(dispatch_source_t *this)
{
  unint64_t v2 = this[90];
  this[90] = 0LL;
  if (v2) {
    dispatch_release(v2);
  }
  this[32] = 0LL;
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C03ED0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::~__shared_ptr_emplace( std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C03ED0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<TCPIOConnectionTest::EnqueedRead>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 40);
  if (v1) {
    _Block_release(v1);
  }
}

uint64_t ___ZN15HTTP2Connection21_onqueue_performWriteEv_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 104LL) = 0;
  return result;
}

uint64_t HTTP2Server::write(HTTP2Server *this)
{
  uint64_t result = nghttp2_session_want_write();
  if ((_DWORD)result)
  {
    uint64_t v8 = 0LL;
    uint64_t result = MEMORY[0x186E14970](*((void *)this + 5), &v8);
    uint64_t v3 = *((void *)this + 7);
    if (v3)
    {
      uint64_t v4 = result;
      CFIndex v5 = *(uint64_t (**)(void *, uint64_t, uint64_t))(v3 + 8);
      uint64_t v6 = *(void *)(v3 + 16);
      CFIndex v7 = (void *)(v3 + (v6 >> 1));
      if ((v6 & 1) != 0) {
        CFIndex v5 = *(uint64_t (**)(void *, uint64_t, uint64_t))(*v7 + v5);
      }
      return v5(v7, v8, v4);
    }
  }

  return result;
}

void ___ZN15HTTP2Connection27stopIfNoOutstandingRequestsEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(int *)(v1 + 304);
  if (!(CFArrayGetCount(*(CFArrayRef *)(v1 + 232)) + v2)) {
    HTTP2Connection::_onqueue_closeConnection((HTTP2Connection *)v1, 0, 0);
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

void HTTP2Connection::cancelStream(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (*(void *)(a1 + 160))
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }

    if (*(_DWORD *)(a2 + 80) == -1) {
      goto LABEL_13;
    }
    CFRetain((CFTypeRef)(a1 - 16));
    uint64_t v8 = *(dispatch_queue_s **)(a1 + 168);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3321888768LL;
    block[2] = ___ZN15HTTP2Connection13sendRSTStreamENSt3__110shared_ptrI11HTTP2StreamEE18nghttp2_error_code_block_invoke;
    block[3] = &__block_descriptor_60_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e5_v8__0l;
    block[4] = a1;
    void block[5] = a2;
    uint64_t v17 = a3;
    if (a3)
    {
      uint64_t v9 = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }

    int v18 = 8;
    dispatch_async(v8, block);
    unint64_t v11 = v17;
    if (!v17) {
      goto LABEL_13;
    }
    uint64_t v12 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (v13)
    {
LABEL_13:
      if (!a3) {
        return;
      }
    }

    else
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      if (!a3) {
        return;
      }
    }

    unint64_t v14 = (unint64_t *)&a3->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }

void sub_182A4382C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN15HTTP2Connection13sendRSTStreamENSt3__110shared_ptrI11HTTP2StreamEE18nghttp2_error_code_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }

  if (*(void *)(v1 + 160))
  {
    if ((nghttp2_submit_rst_stream() & 0x80000000) != 0) {
      HTTP2Connection::closeConnection((HTTP2Connection *)v1, 0);
    }
    CFIndex v5 = *(void **)(v1 + 128);
    if (v5) {
      dispatch_async(*(dispatch_queue_t *)(v1 + 168), v5);
    }
  }

  if (v2)
  {
    uint64_t v6 = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

void sub_182A438F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN15HTTP2Connection5ClassEv_block_invoke()
{
  uint64_t v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "HTTP2Connection");
  HTTP2Connection::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182A43944(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<IOConnWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C03F60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IOConnWrapper>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C03F60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke(void *a1)
{
  uint64_t v172 = *MEMORY[0x1895F89C0];
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = *(void *)(v2 + 56);
  if (*(_DWORD *)v4 == 1)
  {
    uint64_t v5 = *(void *)(v3 + 136);
    if (v5) {
      *(_BYTE *)(v3 + 240) = 0;
    }
    uint64_t v6 = *(std::__shared_weak_count **)(v3 + 144);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
      if (*(_DWORD *)v4 == 1) {
        std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v4 + 8), v5, (uint64_t)v6);
      }
      uint64_t v9 = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }

    else
    {
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v4 + 8), v5, 0LL);
    }

    uint64_t v11 = *(void *)(v2 + 56);
    uint64_t v12 = *(void *)(v11 + 8);
    unint64_t v13 = *(std::__shared_weak_count **)(v11 + 16);
    *(void *)&__int128 aBlock = v12;
    *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v13;
    if (v13)
    {
      unint64_t v14 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }

    *(void *)(v2 + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 256LL))(v12);
    if (v13)
    {
      CFNumberRef v16 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    if (!*(void *)(v2 + 56)) {
      goto LABEL_35;
    }
    uint64_t v3 = a1[6];
  }

  v168[0] = 0LL;
  int v18 = nghttp2_option_new();
  if (v18)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    unint64_t v19 = (os_log_s *)CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT)) {
      goto LABEL_35;
    }
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v18;
    unint64_t v20 = "Failed to create http2 option %d";
LABEL_61:
    _os_log_fault_impl(&dword_18298D000, v19, OS_LOG_TYPE_FAULT, v20, buf, 8u);
LABEL_35:
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
    return;
  }

  nghttp2_option_set_no_auto_window_update();
  nghttp2_option_set_no_rfc9113_leading_and_trailing_ws_validation();
  *(_DWORD *)(v2 + 180) = 4096;
  *(_BYTE *)(v2 + 18os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
  *(_OWORD *)(v2 + 18_Block_object_dispose(va, 8) = xmmword_182C9D790;
  int v21 = nghttp2_session_client_new2();
  MEMORY[0x186E14850](v168[0]);
  if (v21)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    unint64_t v19 = (os_log_s *)CFNLog::logger;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT)) {
      goto LABEL_35;
    }
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    unint64_t v20 = "Failed to create http2 session %d";
    goto LABEL_61;
  }

  uint64_t v22 = Tube::copyWaiter(*(Tube **)(v3 + 112));
  uint64_t v23 = MEMORY[0x1895F87A8];
  if (v22)
  {
    *(void *)&__int128 aBlock = MEMORY[0x1895F87A8];
    *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3221225472LL;
    uint64_t v153 = (void (*)(__int128 *))___ZN15HTTP2Connection15initializeHTTP2EP4Tube_block_invoke;
    __int128 v154 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v155 = v22;
    uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 80LL))(v22);
    if (v24) {
      *(_DWORD *)(v2 + 2CFRetain((char *)this - 16) = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 168LL))(v24);
    }
    v153(&aBlock);
  }

  unint64_t v25 = getenv("CFN_USE_HTTP2_SERVER_PUSH");
  if (!v25) {
    goto LABEL_75;
  }
  int v26 = buf;
  std::string::basic_string[abi:nn180100]<0>(buf, v25);
  char v27 = buf[23];
  if (buf[23] >= 0) {
    unint64_t v28 = &buf[buf[23]];
  }
  else {
    unint64_t v28 = (_BYTE *)(*(void *)buf + *(void *)&buf[8]);
  }
  if (buf[23] < 0) {
    int v26 = *(_BYTE **)buf;
  }
  if (v26 != v28)
  {
    do
    {
      *int v26 = __tolower((char)*v26);
      ++v26;
    }

    while (v26 != v28);
    char v27 = buf[23];
  }

  if (v27 < 0)
  {
    if (*(void *)&buf[8] == 1LL)
    {
      if (**(_BYTE **)buf == 49)
      {
LABEL_77:
        operator delete(*(void **)buf);
        goto LABEL_78;
      }
    }

    else if (*(void *)&buf[8] == 3LL)
    {
      if (**(_WORD **)buf == 25977 && *(_BYTE *)(*(void *)buf + 2LL) == 115) {
        goto LABEL_77;
      }
    }

    else if (*(void *)&buf[8] == 4LL && **(_DWORD **)buf == 1702195828)
    {
      goto LABEL_77;
    }

    operator delete(*(void **)buf);
    goto LABEL_75;
  }

  if (v27 != 1)
  {
    if (v27 == 3)
    {
    }

    else if (v27 == 4 && *(_DWORD *)buf == 1702195828)
    {
      goto LABEL_78;
    }

LABEL_75:
    *(void *)__int128 buf = 2LL;
    int v32 = *(_DWORD *)(v2 + 212);
    int v31 = *(_DWORD *)(v2 + 216);
    *(_DWORD *)&uint8_t buf[8] = 4;
    *(_DWORD *)&buf[12] = v31;
    *(_DWORD *)&uint8_t buf[16] = 3;
    *(_DWORD *)&buf[20] = v32;
    int v33 = nghttp2_submit_settings();
    goto LABEL_79;
  }

  if (buf[0] != 49) {
    goto LABEL_75;
  }
LABEL_78:
  int v35 = *(_DWORD *)(v2 + 212);
  int v34 = *(_DWORD *)(v2 + 216);
  *(_DWORD *)__int128 buf = 4;
  *(_DWORD *)&uint8_t buf[4] = v34;
  *(_DWORD *)&uint8_t buf[8] = 3;
  *(_DWORD *)&buf[12] = v35;
  int v33 = nghttp2_submit_settings();
LABEL_79:
  *(_BYTE *)(v2 + 596) = v33 == 0;
  int v36 = nghttp2_submit_window_update();
  if (v36 < 0)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v43 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      CFTypeID v44 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
      int v45 = _cfnAutoreleaseInDebug(v44);
      *(_DWORD *)__int128 buf = 136315394;
      *(void *)&uint8_t buf[4] = v45;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v36;
      _os_log_error_impl( &dword_18298D000,  v43,  OS_LOG_TYPE_ERROR,  "Could not submit window update on [%s], error code: %d",  buf,  0x12u);
    }

    goto LABEL_35;
  }

  *(_DWORD *)(v2 + 176) = 0;
  CFPropertyListFormat v37 = *(int **)(v2 + 56);
  if (!v37)
  {
    BOOL v46 = 0;
    *(_BYTE *)(v2 + 597) = 0;
    goto LABEL_133;
  }

  int v38 = *v37;
  if (*v37 == 1)
  {
    uint64_t v47 = *((void *)v37 + 1);
    CFRange v48 = (std::__shared_weak_count *)*((void *)v37 + 2);
    *(void *)&__int128 aBlock = v47;
    *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v48;
    if (v48)
    {
      uint64_t v49 = (unint64_t *)&v48->__shared_owners_;
      do
        unint64_t v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
    }

    CFDataRef v51 = (const void *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v47 + 216LL))(v47, &unk_18C5AD910);
    if (v48)
    {
      int v52 = (unint64_t *)&v48->__shared_owners_;
      do
        unint64_t v53 = __ldaxr(v52);
      while (__stlxr(v53 - 1, v52));
      if (!v53)
      {
        ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
        std::__shared_weak_count::__release_weak(v48);
      }
    }

    if (v51)
    {
      CFTypeID v54 = CFGetTypeID(v51);
      if (v54 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        LOWORD(aBlock) = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&aBlock,  2u);
      }

      BOOL v55 = *MEMORY[0x189604DE8] == (void)v51;
      CFRelease(v51);
      goto LABEL_108;
    }
  }

  else
  {
    if (v38 != 2)
    {
      *(_BYTE *)(v2 + 597) = 0;
      goto LABEL_111;
    }

    id v39 = (std::__shared_weak_count *)*((void *)v37 + 2);
    if (v39)
    {
      CFIndex v40 = (unint64_t *)&v39->__shared_owners_;
      do
        unint64_t v41 = __ldxr(v40);
      while (__stxr(v41 + 1, v40));
      do
        unint64_t v42 = __ldaxr(v40);
      while (__stlxr(v42 - 1, v40));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }
  }

  BOOL v55 = 0;
LABEL_108:
  CFPropertyListFormat v37 = *(int **)(v2 + 56);
  *(_BYTE *)(v2 + 597) = v55;
  if (!v37) {
    goto LABEL_132;
  }
  int v38 = *v37;
LABEL_111:
  if (v38 == 2)
  {
    CFIndex v64 = (std::__shared_weak_count *)*((void *)v37 + 2);
    if (v64)
    {
      BOOL v65 = (unint64_t *)&v64->__shared_owners_;
      do
        unint64_t v66 = __ldxr(v65);
      while (__stxr(v66 + 1, v65));
      do
        unint64_t v67 = __ldaxr(v65);
      while (__stlxr(v67 - 1, v65));
      if (!v67)
      {
        ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
        std::__shared_weak_count::__release_weak(v64);
      }
    }

    goto LABEL_132;
  }

  if (v38 != 1) {
    goto LABEL_132;
  }
  uint64_t v56 = *((void *)v37 + 1);
  CFIndex v57 = (std::__shared_weak_count *)*((void *)v37 + 2);
  *(void *)&__int128 aBlock = v56;
  *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v57;
  if (v57)
  {
    uint64_t v58 = (unint64_t *)&v57->__shared_owners_;
    do
      unint64_t v59 = __ldxr(v58);
    while (__stxr(v59 + 1, v58));
  }

  CFIndex v60 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v56 + 216LL))(v56, 0x18C5AB610LL);
  if (v57)
  {
    uint64_t v61 = (unint64_t *)&v57->__shared_owners_;
    do
      unint64_t v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }

  if (!v60)
  {
LABEL_132:
    BOOL v46 = 0;
    goto LABEL_133;
  }

  CFTypeID v63 = CFGetTypeID(v60);
  if (v63 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(aBlock) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&aBlock,  2u);
  }

  BOOL v46 = *MEMORY[0x189604DE8] == (void)v60;
  CFRelease(v60);
LABEL_133:
  *(_BYTE *)(v2 + 59_Block_object_dispose(va, 8) = v46;
  CFRetain((CFTypeRef)(v2 - 16));
  CFRetain((CFTypeRef)(v2 - 16));
  uint64_t v166 = (std::__shared_weak_count *)v2;
  CFRange v68 = (std::__shared_weak_count *)operator new(0x20uLL);
  v68->__shared_owners_ = 0LL;
  CFRange v69 = (unint64_t *)&v68->__shared_owners_;
  v68->__vftable = (std::__shared_weak_count_vtbl *)off_189C03F08;
  v68->__shared_weak_owners_ = 0LL;
  v68[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  UniChar v167 = v68;
  uint64_t v164 = v2 + 16;
  uint64_t v165 = v68;
  do
    unint64_t v70 = __ldxr(v69);
  while (__stxr(v70 + 1, v69));
  uint64_t v71 = *(void *)(v2 + 56);
  if (*(_DWORD *)v71 != 2)
  {
    if (*(_DWORD *)v71 != 1) {
      __assert_rtn("setConnectionDelegate", "TCPIOConnectionTest.hpp", 196, "false");
    }
    uint64_t v72 = *(void *)(v71 + 8);
    *(void *)&__int128 aBlock = v2 + 16;
    *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v68;
    do
      unint64_t v73 = __ldxr(v69);
    while (__stxr(v73 + 1, v69));
    (*(void (**)(uint64_t, __int128 *))(*(void *)v72 + 184LL))(v72, &aBlock);
    id v74 = (std::__shared_weak_count *)*((void *)&aBlock + 1);
    if (*((void *)&aBlock + 1))
    {
      int64_t v75 = (unint64_t *)(*((void *)&aBlock + 1) + 8LL);
      do
        unint64_t v76 = __ldaxr(v75);
      while (__stlxr(v76 - 1, v75));
      if (!v76)
      {
        ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
        std::__shared_weak_count::__release_weak(v74);
      }
    }
  }

  uint64_t v162 = v2;
  CFIndex v163 = v68;
  do
    unint64_t v77 = __ldxr(v69);
  while (__stxr(v77 + 1, v69));
  *(void *)&__int128 aBlock = v23;
  *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
  uint64_t v153 = (void (*)(__int128 *))___ZN15HTTP2Connection25setupWriteCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
  __int128 v154 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e13_v24__0___qi_8l;
  uint64_t v155 = v2;
  __int128 v156 = v68;
  do
    unint64_t v78 = __ldxr(v69);
  while (__stxr(v78 + 1, v69));
  *(void *)(v2 + 112) = _Block_copy(&aBlock);
  uint64_t v79 = v156;
  if (v156)
  {
    CFIndex v80 = (unint64_t *)&v156->__shared_owners_;
    do
      unint64_t v81 = __ldaxr(v80);
    while (__stlxr(v81 - 1, v80));
    if (!v81)
    {
      ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
      std::__shared_weak_count::__release_weak(v79);
    }
  }

  BOOL v82 = v163;
  if (v163)
  {
    uint64_t v83 = (unint64_t *)&v163->__shared_owners_;
    do
      unint64_t v84 = __ldaxr(v83);
    while (__stlxr(v84 - 1, v83));
    if (!v84)
    {
      ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
      std::__shared_weak_count::__release_weak(v82);
    }
  }

  uint64_t v86 = (uint64_t)v166;
  BOOL v85 = v167;
  CFIndex v160 = v166;
  CFIndex v161 = v167;
  if (v167)
  {
    uint64_t v87 = (unint64_t *)&v167->__shared_owners_;
    do
      unint64_t v88 = __ldxr(v87);
    while (__stxr(v88 + 1, v87));
    *(void *)&__int128 aBlock = v23;
    *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
    uint64_t v153 = (void (*)(__int128 *))___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
    __int128 v154 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e47_v36__0__NSObject_OS_dispatch_data__8B16___qi_20l;
    uint64_t v155 = v86;
    __int128 v156 = v85;
    unint64_t v89 = (unint64_t *)&v85->__shared_owners_;
    do
      unint64_t v90 = __ldxr(v89);
    while (__stxr(v90 + 1, v89));
  }

  else
  {
    *(void *)&__int128 aBlock = v23;
    *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
    uint64_t v153 = (void (*)(__int128 *))___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
    __int128 v154 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e47_v36__0__NSObject_OS_dispatch_data__8B16___qi_20l;
    uint64_t v155 = (uint64_t)v166;
    __int128 v156 = 0LL;
  }

  *(void *)(v86 + 120) = _Block_copy(&aBlock);
  CFTypeRef v91 = v156;
  if (v156)
  {
    dispatch_block_t v92 = (unint64_t *)&v156->__shared_owners_;
    do
      unint64_t v93 = __ldaxr(v92);
    while (__stlxr(v93 - 1, v92));
    if (!v93)
    {
      ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
      std::__shared_weak_count::__release_weak(v91);
    }
  }

  CFIndex v94 = v161;
  if (v161)
  {
    uint64_t v95 = (unint64_t *)&v161->__shared_owners_;
    do
      unint64_t v96 = __ldaxr(v95);
    while (__stlxr(v96 - 1, v95));
    if (!v96)
    {
      ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
      std::__shared_weak_count::__release_weak(v94);
    }
  }

  uint64_t v98 = (uint64_t)v166;
  uint64_t v97 = v167;
  UniChar v158 = v166;
  BOOL v159 = v167;
  if (v167)
  {
    CFIndex v99 = (unint64_t *)&v167->__shared_owners_;
    do
      unint64_t v100 = __ldxr(v99);
    while (__stxr(v100 + 1, v99));
    *(void *)&__int128 aBlock = v23;
    *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
    uint64_t v153 = (void (*)(__int128 *))___ZN15HTTP2Connection20setupScheduleIOBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
    __int128 v154 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e5_v8__0l;
    uint64_t v155 = v98;
    __int128 v156 = v97;
    uint64_t v101 = (unint64_t *)&v97->__shared_owners_;
    do
      unint64_t v102 = __ldxr(v101);
    while (__stxr(v102 + 1, v101));
  }

  else
  {
    *(void *)&__int128 aBlock = v23;
    *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
    uint64_t v153 = (void (*)(__int128 *))___ZN15HTTP2Connection20setupScheduleIOBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke;
    __int128 v154 = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e5_v8__0l;
    uint64_t v155 = (uint64_t)v166;
    __int128 v156 = 0LL;
  }

  *(void *)(v98 + 12_Block_object_dispose(va, 8) = _Block_copy(&aBlock);
  int v103 = v156;
  if (v156)
  {
    id v104 = (unint64_t *)&v156->__shared_owners_;
    do
      unint64_t v105 = __ldaxr(v104);
    while (__stlxr(v105 - 1, v104));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }

  CFIndex v106 = v159;
  if (v159)
  {
    CFIndex v107 = (unint64_t *)&v159->__shared_owners_;
    do
      unint64_t v108 = __ldaxr(v107);
    while (__stlxr(v108 - 1, v107));
    if (!v108)
    {
      ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
      std::__shared_weak_count::__release_weak(v106);
    }
  }

  *(void *)&__int128 aBlock = v23;
  *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
  uint64_t v153 = (void (*)(__int128 *))___ZN15HTTP2Connection20initializeConnectionEv_block_invoke;
  __int128 v154 = &__block_descriptor_56_e8_40c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e25_v24__0____CFString__8_v16l;
  uint64_t v155 = v2;
  __int128 v156 = v166;
  __int128 v157 = v167;
  if (v167)
  {
    uint64_t v109 = (unint64_t *)&v167->__shared_owners_;
    do
      unint64_t v110 = __ldxr(v109);
    while (__stxr(v110 + 1, v109));
  }

  uint64_t v111 = operator new(0x28uLL);
  v111[1] = 0LL;
  v111[2] = 0LL;
  *uint64_t v111 = off_189C087A0;
  v111[3] = off_189C18E98;
  v111[4] = 0LL;
  v111[4] = _Block_copy(&aBlock);
  *(void *)__int128 buf = v111 + 3;
  *(void *)&uint8_t buf[8] = v111;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v2 + 272, (__int128 *)buf);
  uint64_t v112 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v113 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v114 = __ldaxr(v113);
    while (__stlxr(v114 - 1, v113));
    if (!v114)
    {
      ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
      std::__shared_weak_count::__release_weak(v112);
    }
  }

  uint64_t v115 = *(void *)(v2 + 56);
  uint64_t v116 = *(void *)(v2 + 272);
  UniChar v117 = *(std::__shared_weak_count **)(v2 + 280);
  v150[5] = v116;
  CFIndex v151 = v117;
  if (v117)
  {
    int v118 = (unint64_t *)&v117->__shared_owners_;
    do
      unint64_t v119 = __ldxr(v118);
    while (__stxr(v119 + 1, v118));
  }

  *(void *)__int128 buf = v23;
  *(void *)&uint8_t buf[8] = 3221225472LL;
  *(void *)&uint8_t buf[16] = ___ZN15HTTP2Connection20initializeConnectionEv_block_invoke_34;
  uint64_t v170 = &__block_descriptor_40_e6__v8__0l;
  uint64_t v171 = v2;
  if (*(_DWORD *)v115 != 2)
  {
    if (*(_DWORD *)v115 != 1) {
      __assert_rtn("registerForPropertyUpdates", "TCPIOConnectionTest.hpp", 206, "false");
    }
    uint64_t v120 = *(void *)(v115 + 8) + 16LL;
    v168[0] = v116;
    v168[1] = v117;
    if (v117)
    {
      sqlite3_int64 v121 = (unint64_t *)&v117->__shared_owners_;
      do
        unint64_t v122 = __ldxr(v121);
      while (__stxr(v122 + 1, v121));
    }

    NotificationStation::registerForPropertyUpdates(v120, @"__kCFStreamPropertyDoNotReuse", v168, (uint64_t)buf);
    if (!v117) {
      goto LABEL_218;
    }
    CFIndex v123 = (unint64_t *)&v117->__shared_owners_;
    do
      unint64_t v124 = __ldaxr(v123);
    while (__stlxr(v124 - 1, v123));
LABEL_216:
    if (!v124)
    {
      ((void (*)(std::__shared_weak_count *))v117->__on_zero_shared)(v117);
      std::__shared_weak_count::__release_weak(v117);
    }

  pthread_mutex_unlock(v6);
  if (*((void *)this + 36))
  {
    (*(void (**)(void))(**((void **)this + 25) + 216LL))(*((void *)this + 25));
    *((void *)this + 36) = 0LL;
  }

  return a3;
}

LABEL_218:
    if (v151)
    {
      CFIndex v127 = &v151->__shared_owners_;
      do
        unint64_t v128 = __ldaxr((unint64_t *)v127);
      while (__stlxr(v128 - 1, (unint64_t *)v127));
      if (!v128)
      {
        ((void (*)(std::__shared_weak_count *))v151->__on_zero_shared)(v151);
        std::__shared_weak_count::__release_weak(v151);
      }
    }

    goto LABEL_223;
  }

  if (v117)
  {
    uint64_t v125 = (unint64_t *)&v117->__shared_owners_;
    do
      unint64_t v126 = __ldxr(v125);
    while (__stxr(v126 + 1, v125));
    do
      unint64_t v124 = __ldaxr(v125);
    while (__stlxr(v124 - 1, v125));
    goto LABEL_216;
  }

LABEL_223:
  uint64_t v129 = v157;
  if (v157)
  {
    v130 = (unint64_t *)&v157->__shared_owners_;
    do
      unint64_t v131 = __ldaxr(v130);
    while (__stlxr(v131 - 1, v130));
    if (!v131)
    {
      ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
      std::__shared_weak_count::__release_weak(v129);
    }
  }

  unint64_t v132 = v165;
  if (v165)
  {
    CFIndex v133 = (unint64_t *)&v165->__shared_owners_;
    do
      unint64_t v134 = __ldaxr(v133);
    while (__stlxr(v134 - 1, v133));
    if (!v134)
    {
      ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
      std::__shared_weak_count::__release_weak(v132);
    }
  }

  CFIndex v135 = v167;
  if (v167)
  {
    UniChar v136 = (unint64_t *)&v167->__shared_owners_;
    do
      unint64_t v137 = __ldaxr(v136);
    while (__stlxr(v137 - 1, v136));
    if (!v137)
    {
      ((void (*)(std::__shared_weak_count *))v135->__on_zero_shared)(v135);
      std::__shared_weak_count::__release_weak(v135);
    }
  }

  uint64_t v138 = *(void *)(a1[6] + 112LL);
  else {
    char v140 = 1;
  }
  *(_BYTE *)(v2 + 642) = v140;
  v150[0] = v23;
  v150[1] = 3221225472LL;
  v150[2] = ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke_2;
  v150[3] = &__block_descriptor_40_e5_v8__0l;
  v150[4] = v2;
  CFIndex v141 = operator new(0x58uLL);
  v141[1] = 0LL;
  v141[2] = 0LL;
  *CFIndex v141 = off_189C08768;
  __int128 v142 = *(dispatch_object_s **)(v2 + 168);
  SmartBlockWithArgs<>::SmartBlockWithArgs(&aBlock, v150);
  HTTPStallTimer::HTTPStallTimer((uint64_t)(v141 + 3), v142, (uint64_t *)&aBlock);
  __int128 v143 = (std::__shared_weak_count *)*((void *)&aBlock + 1);
  if (*((void *)&aBlock + 1))
  {
    CFIndex v144 = (unint64_t *)(*((void *)&aBlock + 1) + 8LL);
    do
      unint64_t v145 = __ldaxr(v144);
    while (__stlxr(v145 - 1, v144));
    if (!v145)
    {
      ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
      std::__shared_weak_count::__release_weak(v143);
    }
  }

  *(void *)&__int128 aBlock = v141 + 3;
  *((void *)&aBlock + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v141;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( (uint64_t)&aBlock,  v141 + 4,  (uint64_t)(v141 + 3));
  CFIndex v146 = (HTTPStallTimer **)(v2 + 648);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v2 + 648, &aBlock);
  UniChar v147 = (std::__shared_weak_count *)*((void *)&aBlock + 1);
  if (*((void *)&aBlock + 1))
  {
    CFIndex v148 = (unint64_t *)(*((void *)&aBlock + 1) + 8LL);
    do
      unint64_t v149 = __ldaxr(v148);
    while (__stlxr(v149 - 1, v148));
    if (!v149)
    {
      ((void (*)(std::__shared_weak_count *))v147->__on_zero_shared)(v147);
      std::__shared_weak_count::__release_weak(v147);
    }
  }

  HTTPStallTimer::setup(*v146);
}

void sub_182A449DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void ___ZN15HTTP2Connection10initializeEP4TubeiP25HTTP2ConnectionCacheEntry_block_invoke_2(uint64_t a1)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v1 + 642) && *(void *)(v1 + 56))
  {
    *(_DWORD *)uint64_t valuePtr = 3;
    CFNumberRef v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, valuePtr);
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    unint64_t v17 = ___ZN15HTTP2Connection11handleStallEv_block_invoke;
    int v18 = &__block_descriptor_40_e5_v8__0l;
    CFNumberRef v19 = v2;
    if (!v2 || (uint64_t v3 = *(void *)(v1 + 56), *(_DWORD *)v3 == 2))
    {
      ___ZN15HTTP2Connection11handleStallEv_block_invoke((uint64_t)v16);
    }

    else
    {
      if (*(_DWORD *)v3 != 1) {
        __assert_rtn("setProperty", "TCPIOConnectionTest.hpp", 247, "false");
      }
      (*(void (**)(void, uint64_t, CFNumberRef))(**(void **)(v3 + 8) + 200LL))( *(void *)(v3 + 8),  0x18C5ABDB8LL,  v2);
      v17((uint64_t)v16);
    }
  }

  if (*(_DWORD *)(v1 + 176) == 2 && *(_BYTE *)(v1 + 641) && !*(void *)(v1 + 720))
  {
    dispatch_source_t v4 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *(dispatch_queue_t *)(v1 + 168));
    uint64_t v5 = *(dispatch_object_s **)(v1 + 720);
    *(void *)(v1 + 720) = v4;
    if (v5) {
      dispatch_release(v5);
    }
    double Current = CFAbsoluteTimeGetCurrent();
    double v7 = Current - *(double *)(v1 + 248);
    if (v7 >= 30.0)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v9 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *(void *)(v1 + 72);
        *(_DWORD *)uint64_t valuePtr = 134218240;
        *(void *)&valuePtr[4] = v10;
        *(_WORD *)&valuePtr[12] = 2048;
        *(double *)&valuePtr[14] = v7;
        _os_log_impl( &dword_18298D000,  v9,  OS_LOG_TYPE_DEFAULT,  "Connection %llu idle %f will initiate stall recovery",  valuePtr,  0x16u);
      }

      int64_t v8 = 0LL;
      *(double *)(v1 + 256) = Current + -3.0;
    }

    else
    {
      *(void *)(v1 + 256) = 0LL;
      int64_t v8 = (uint64_t)((30.0 - v7) * 1000000000.0);
    }

    uint64_t v11 = *(dispatch_source_s **)(v1 + 720);
    dispatch_time_t v12 = dispatch_time(0x8000000000000000LL, v8);
    dispatch_source_set_timer(v11, v12, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    CFRetain((CFTypeRef)(v1 - 16));
    uint64_t v13 = MEMORY[0x1895F87A8];
    unint64_t v14 = *(dispatch_source_s **)(v1 + 720);
    *(void *)uint64_t valuePtr = MEMORY[0x1895F87A8];
    *(void *)&valuePtr[8] = 3221225472LL;
    *(void *)&valuePtr[16] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke;
    uint64_t v22 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v23 = v1;
    dispatch_source_set_cancel_handler(v14, valuePtr);
    unint64_t v15 = *(dispatch_source_s **)(v1 + 720);
    handler[0] = v13;
    handler[1] = 3221225472LL;
    handler[2] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_55;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = v1;
    dispatch_source_set_event_handler(v15, handler);
    dispatch_resume(*(dispatch_object_t *)(v1 + 720));
  }

void sub_182A44DEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
}

uint64_t BlockHolderVar<>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<>::invoke_normal;
  a1[2] = 0LL;
  return (*(uint64_t (**)(void))(*a1 + 16LL))();
}

void std::__shared_ptr_pointer<BlockHolderVar<> *,SmartBlockWithArgs<>::Deleter,std::allocator<BlockHolderVar<>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_emplace<HTTPStallTimer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C08768;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTPStallTimer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C08768;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void ___ZN15HTTP2Connection11handleStallEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  CFNumberRef v2 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(v1 + 72);
    int v4 = 134217984;
    uint64_t v5 = v3;
    _os_log_debug_impl( &dword_18298D000,  v2,  OS_LOG_TYPE_DEBUG,  "Connection %llu recovery timer canceled",  (uint8_t *)&v4,  0xCu);
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_55(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  double Current = CFAbsoluteTimeGetCurrent();
  double v3 = *(double *)(v1 + 256);
  if (v3 == 0.0)
  {
    *(double *)(v1 + 256) = Current;
    double v3 = Current;
  }

  double v4 = Current - v3;
  if (v4 < 9.0)
  {
    uint64_t v5 = *(dispatch_source_s **)(v1 + 720);
    dispatch_time_t v6 = dispatch_time(0x8000000000000000LL, (uint64_t)((9.0 - v4) * 1000000000.0));
    dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 3221225472LL;
    v23[2] = ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_2;
    v23[3] = &__block_descriptor_40_e23_v24__0____CFError__8d16l;
    v23[4] = v1;
    (*(void (**)(uint64_t, void *))(*(void *)v1 + 56LL))(v1, v23);
    return;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  double v7 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    CFIndex v8 = *(void *)(v1 + 72);
    LODWORD(buf.domain) = 134217984;
    *(CFIndex *)((char *)&buf.domain + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v8;
    _os_log_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_DEFAULT,  "Connection %llu reached max hang time, will retry applicable streams",  (uint8_t *)&buf,  0xCu);
  }

  if (*(void *)(v1 + 720)) {
    HTTP2Connection::stopStallRecovery((dispatch_source_t *)v1);
  }
  *(_BYTE *)(v1 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
  HTTP2Connection::stop((HTTP2Connection *)v1, 0);
  buf.domain = 4LL;
  buf.CFErrorRef error = -5;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 232));
  if (Count >= 1)
  {
    CFIndex v10 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 232), v10);
      uint64_t v13 = (HTTP2Stream *)*((void *)ValueAtIndex + 3);
      dispatch_time_t v12 = (std::__shared_weak_count *)*((void *)ValueAtIndex + 4);
      if (v12)
      {
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          unint64_t v15 = __ldxr(p_shared_owners);
        while (__stxr(v15 + 1, p_shared_owners));
      }

      uint64_t v16 = *((void *)v13 + 2);
      if (v16)
      {
        if ((*(unsigned int (**)(uint64_t, CFStreamError *, void))(*(void *)v16 + 280LL))(v16, &buf, 0LL)
           - 5 <= 5)
          break;
      }

      if (v12) {
        goto LABEL_27;
      }
LABEL_31:
      if (++v10 == Count) {
        return;
      }
    }

    HTTP2Stream::setError(v13, buf);
    HTTP2Stream::closeStreamWithErrorCode(v13);
    if (v12)
    {
      unint64_t v17 = (unint64_t *)&v12->__shared_owners_;
      do
        unint64_t v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }

    HTTP2Connection::cancelStream(v1, (uint64_t)v13, v12);
    if (!v12) {
      goto LABEL_31;
    }
    CFNumberRef v19 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }

void sub_182A45224(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      unint64_t v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }

    uint64_t v5 = (unint64_t *)&v1->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

  _Unwind_Resume(exception_object);
}

void ___ZN15HTTP2Connection18startStallRecoveryEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2)
  {
    if (*(void *)(v2 + 720)) {
      HTTP2Connection::stopStallRecovery((dispatch_source_t *)v2);
    }
  }

  else
  {
    *(void *)(v2 + 256) = 0LL;
    double v3 = *(dispatch_source_s **)(v2 + 720);
    if (v3)
    {
      dispatch_time_t v4 = dispatch_time(0x8000000000000000LL, 45000000000LL);
      dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }
  }

void HTTP2Connection::stop(HTTP2Connection *this, char a2)
{
  dispatch_time_t v4 = (dispatch_queue_s *)*((void *)this + 21);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZN15HTTP2Connection4stopEb_block_invoke;
  v5[3] = &__block_descriptor_41_e5_v8__0l;
  v5[4] = this;
  char v6 = a2;
  dispatch_async(v4, v5);
}

void ___ZN15HTTP2Connection4stopEb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(HTTP2Connection **)(a1 + 32);
  HTTP2Connection::_onqueue_closeConnection(v1, 0, *(_BYTE *)(a1 + 40));
  CFRelease((char *)v1 - 16);
}

void ___ZN15HTTP2Connection20initializeConnectionEv_block_invoke(uint64_t a1, int a2, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v5 = *(HTTP2Connection **)(a1 + 32);
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&v11,  2u);
    }

    if ((CFTypeRef)*MEMORY[0x189604DE8] == cf)
    {
      __int128 v11 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(a1 + 40) + 272LL, &v11);
      double v7 = (std::__shared_weak_count *)*((void *)&v11 + 1);
      if (*((void *)&v11 + 1))
      {
        CFIndex v8 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
        do
          unint64_t v9 = __ldaxr(v8);
        while (__stlxr(v9 - 1, v8));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }

      uint64_t v10 = *(void *)(a1 + 40);
      if (!*(_BYTE *)(v10 + 264))
      {
        *(_BYTE *)(v10 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
        HTTP2Connection::stopIfNoOutstandingRequests(v5);
      }
    }
  }

uint64_t ___ZN15HTTP2Connection20initializeConnectionEv_block_invoke_34(uint64_t a1)
{
  return IOConnWrapper::copyProperty( *(IOConnWrapper **)(*(void *)(a1 + 32) + 56LL),  @"__kCFStreamPropertyDoNotReuse");
}

void std::__shared_ptr_emplace<PropertyObserver>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C087A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PropertyObserver>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C087A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void ___ZN15HTTP2Connection20setupScheduleIOBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke(uint64_t a1)
{
}

void ___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke( uint64_t a1, dispatch_data_t data, char a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a1 + 32);
  *(_WORD *)(v6 + 80) = 256;
  if (data)
  {
    uint64_t v8 = *(void *)(v6 + 648);
    if (*(void *)(*(void *)(v8 + 40) + 16LL))
    {
      unint64_t v9 = *(dispatch_source_s **)(v8 + 32);
      dispatch_time_t v10 = dispatch_time(0x8000000000000000LL, 3000000000LL);
      dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      uint64_t v6 = *(void *)(a1 + 32);
    }

    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3321888768LL;
    applier[2] = ___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke_2;
    applier[3] = &__block_descriptor_48_e8_32c43_ZTSNSt3__110shared_ptrI15HTTP2ConnectionEE_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
    __int128 v11 = *(std::__shared_weak_count **)(a1 + 40);
    applier[4] = v6;
    int v26 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    dispatch_data_apply(data, applier);
    unint64_t v14 = v26;
    if (v26)
    {
      unint64_t v15 = (unint64_t *)&v26->__shared_owners_;
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }

  else
  {
    uint64_t v19 = a5;
    if (a4 | a5)
    {
      *(_DWORD *)(v6 + 176) = 4;
      HTTP2Connection::closeConnection((HTTP2Connection *)v6, 0);
      if (a4 != 1 || v19 != 57)
      {
        uint64_t v20 = *(void *)(a1 + 32);
        *(void *)(v20 + 14os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a4;
        *(void *)(v20 + 152) = a5;
      }

      int v21 = *(HTTP2Connection **)(a1 + 32);
      if (!*((_BYTE *)v21 + 136))
      {
        *((_BYTE *)v21 + 136) = 1;
        HTTP2Connection::closeConnection(v21, 0);
      }
    }

    else
    {
      if ((a3 & 1) == 0)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        unint64_t v22 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
        {
          v24[0] = 0;
          _os_log_fault_impl( &dword_18298D000,  v22,  OS_LOG_TYPE_FAULT,  "Unexpected API behavior: received no bytes, no error, and no EOF from connection",  (uint8_t *)v24,  2u);
        }
      }

      HTTP2Connection::_onqueue_closeConnection(*(HTTP2Connection **)(a1 + 32), 0, 0LL);
    }
  }

  HTTP2Connection::flushAllBatchedData(*(HTTP2Connection **)(a1 + 32));
  uint64_t v23 = *(HTTP2Connection **)(a1 + 32);
  *((_BYTE *)v23 + 8__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
  HTTP2Connection::_onqueue_scheduleIO(v23);
}

BOOL ___ZN15HTTP2Connection24setupReadCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke_2( uint64_t a1, dispatch_object_t object, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(*(void *)(a1 + 32) + 88LL) = object;
  dispatch_retain(object);
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(v8 + 96) = a4;
  uint64_t v9 = MEMORY[0x186E14964](*(void *)(v8 + 160), a4, a5);
  if (v9 != a5)
  {
    dispatch_time_t v10 = *(HTTP2Connection **)(a1 + 32);
    *((_DWORD *)v10 + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 4;
    HTTP2Connection::closeConnection(v10, 0);
  }

  dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 88LL));
  uint64_t v11 = *(void *)(a1 + 32);
  *(void *)(v11 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v11 + 96) = 0LL;
  return v9 == a5;
}

void ___ZN15HTTP2Connection25setupWriteCompletionBlockINSt3__110shared_ptrIS_EEEEvT__block_invoke( uint64_t a1, uint64_t a2, unsigned int a3)
{
  double v3 = *(HTTP2Connection **)(a1 + 32);
  --*((_DWORD *)v3 + 27);
  if (a2 | a3)
  {
  }

  else
  {
    HTTP2Connection::_onqueue_scheduleIO(v3);
  }

void std::__shared_ptr_pointer<HTTP2Connection *,Deleter_release<HTTP2Connection>,std::allocator<HTTP2Connection>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t ___ZN15HTTP2Connection15initializeHTTP2EP4Tube_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48LL))(*(void *)(a1 + 32));
}

uint64_t ___ZL16sessionCallbacksv_block_invoke()
{
  return nghttp2_session_callbacks_set_error_callback2();
}

void NotificationStation::~NotificationStation(NotificationStation *this)
{
  uint64_t v2 = *((void *)this + 9);
  *((void *)this + 9) = 0LL;
  if (v2) {
    (*((void (**)(void))this + 10))();
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
  std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]( (void *****)this,  0LL);
}

BOOL HTTP2StreamEqualCallBack(const void *a1, const void *a2)
{
  if (!a1 || !a2) {
    __assert_rtn("HTTP2StreamEqualCallBack", "HTTP2Connection.cpp", 1785, "value1 && value2");
  }
  return a1 == a2;
}

void ___ZN15HTTP2Connection22createStreamAndEnqueueEPK18HTTPRequestMessageP25MetaConnectionCacheClientif_block_invoke( void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t Instance = _CFRuntimeCreateInstance();
  dispatch_time_t v4 = (void *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    dispatch_time_t v4 = (void *)(Instance + 16);
    *(void *)(Instance + 4_Block_object_dispose(va, 8) = 0LL;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  }

  uint64_t v6 = *(void *)(v2 + 56);
  uint64_t v5 = *(std::__shared_weak_count **)(v2 + 64);
  if (v5)
  {
    p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_weak_owners);
    while (__stxr(v8 + 1, p_shared_weak_owners));
  }

  uint64_t v10 = a1[6];
  uint64_t v9 = a1[7];
  uint64_t v11 = a1[8];
  void *v4 = &off_189C0E598;
  v4[1] = &unk_189C0E680;
  v4[2] = &unk_189C0E750;
  dispatch_time_t v12 = (char *)operator new(0x1C0uLL);
  unint64_t v13 = v12;
  if (v5)
  {
    unint64_t v14 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }

  *(void *)dispatch_time_t v12 = off_189C0E348;
  *((void *)v12 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C0E3F8;
  *((void *)v12 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *((void *)v12 + 12) = 0LL;
  *((void *)v12 + 20) = 0LL;
  *((void *)v12 + 23) = 0LL;
  *((void *)v12 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  *((void *)v12 + 27) = 0LL;
  *((void *)v12 + 2_Block_object_dispose(va, 8) = 0LL;
  *((void *)v12 + 30) = 0LL;
  *(_OWORD *)(v12 + 360) = 0u;
  *(_OWORD *)(v12 + 376) = 0u;
  *((void *)v12 + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *(_OWORD *)(v12 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(v12 + 280) = 0u;
  *((void *)v12 + 4__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *((void *)v12 + 42) = 0LL;
  *((_WORD *)v12 + 176) = 0;
  *((void *)v12 + 43) = 0LL;
  *((void *)v12 + 49) = _release_dispatch_safe<NSObject  {objcproto18OS_dispatch_object}*>;
  *((_OWORD *)v12 + 25) = 0u;
  *((_OWORD *)v12 + 26) = 0u;
  *((void *)v12 + 5os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  *((void *)v12 + 5) = v10;
  CFRetain((CFTypeRef)(v10 - 16));
  unint64_t v16 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(*((void *)v13 + 5) - 16LL));
  CFStringRef v17 = CFURLGetString(v16);
  CFRetain(v17);
  CFRelease(v16);
  *((void *)v13 + 6) = v17;
  *((void *)v13 + 2) = v9;
  (*(void (**)(uint64_t))(*(void *)v9 + 16LL))(v9);
  *((_DWORD *)v13 + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  unint64_t v18 = *(dispatch_object_s **)(v2 + 168);
  *((void *)v13 + 9) = v18;
  dispatch_retain(v18);
  *((void *)v13 + _Block_object_dispose(va, 8) = v2;
  CFRetain((CFTypeRef)(v2 - 16));
  if (v5)
  {
    uint64_t v19 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      unint64_t v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }

  int v21 = (std::__shared_weak_count *)*((void *)v13 + 12);
  *((void *)v13 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v6;
  *((void *)v13 + 12) = v5;
  if (v21) {
    std::__shared_weak_count::__release_weak(v21);
  }
  *((void *)v13 + 26) = 0LL;
  *((void *)v13 + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *((void *)v13 + 15) = 0LL;
  *((void *)v13 + 17) = 0LL;
  unint64_t v22 = (const void *)*((void *)v13 + 30);
  *((void *)v13 + 30) = 0LL;
  if (v22) {
    CFRelease(v22);
  }
  *((void *)v13 + 1_Block_object_dispose(va, 8) = 0LL;
  *((_WORD *)v13 + 76) = 0;
  v13[176] = 0;
  *((_DWORD *)v13 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0;
  uint64_t v23 = (*(uint64_t (**)(void))(**((void **)v13 + 2) + 168LL))(*((void *)v13 + 2));
  *((void *)v13 + 13) = v23;
  *((void *)v13 + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v23;
  *((_DWORD *)v13 + 20) = -1;
  *(_WORD *)(v13 + 233) = 16;
  v13[256] = 0;
  *((_DWORD *)v13 + 50) = 0;
  *((void *)v13 + 37) = 0LL;
  *((void *)v13 + 3) = 0LL;
  *((void *)v13 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  (*(void (**)(__int128 *__return_ptr))(**((void **)v13 + 2) + 72LL))(&v35);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v13 + 216), &v35);
  uint64_t v24 = (std::__shared_weak_count *)*((void *)&v35 + 1);
  if (*((void *)&v35 + 1))
  {
    uint64_t v25 = (unint64_t *)(*((void *)&v35 + 1) + 8LL);
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  v13[232] = 0;
  *((void *)v13 + 39) = 0LL;
  v13[320] = 0;
  __int128 v35 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v13 + 264), &v35);
  char v27 = (std::__shared_weak_count *)*((void *)&v35 + 1);
  if (*((void *)&v35 + 1))
  {
    unint64_t v28 = (unint64_t *)(*((void *)&v35 + 1) + 8LL);
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  *((void *)v13 + 55) = v11;
  v4[3] = v13;
  uint64_t v30 = operator new(0x20uLL);
  void *v30 = off_189C0E770;
  v30[1] = 0LL;
  v30[2] = 0LL;
  v30[3] = v13;
  v4[4] = v30;
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v31 = v4[3];
    uint64_t v30 = (void *)v4[4];
    if (!v30) {
      goto LABEL_34;
    }
  }

  else
  {
    uint64_t v31 = v4[3];
  }

  int v32 = v30 + 2;
  do
    unint64_t v33 = __ldxr(v32);
  while (__stxr(v33 + 1, v32));
LABEL_34:
  int v34 = *(std::__shared_weak_count **)(v31 + 288);
  *(void *)(v31 + 280) = v31;
  *(void *)(v31 + 28_Block_object_dispose(va, 8) = v30;
  if (v34) {
    std::__shared_weak_count::__release_weak(v34);
  }
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v4;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 232), *(const void **)(*(void *)(a1[4] + 8LL) + 24LL));
}

void sub_182A45D44( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, DataBuffer *a10, uint64_t a11)
{
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  *(void *)(v11 + CFRetain((char *)this - 16) = off_189C19AE8;
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  _Unwind_Resume(a1);
}

void ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke( uint64_t a1)
{
  uint64_t v152 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 64);
  uint64_t v123 = *(void *)(a1 + 56);
  uint64_t v2 = CFHTTPMessageCopyRequestMethod((CFHTTPMessageRef)(*(void *)(v1 + 40) - 16LL));
  if (CFStringCompare(v2, @"GET", 1uLL) == kCFCompareEqualTo)
  {
    BOOL v3 = *(void *)(v1 + 264) == 0LL;
    if (!v2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  BOOL v3 = 0;
  if (v2) {
LABEL_3:
  }
    CFRelease(v2);
LABEL_4:
  if (v3 && *(void *)(v123 + 312) != *(void *)(v123 + 320))
  {
    __int128 v141 = 0u;
    __int128 v142 = 0u;
    LODWORD(v143) = 1065353216;
    uint64_t v4 = a1;
    if (*(_DWORD *)(a1 + 104))
    {
      unint64_t v5 = 0LL;
      do
      {
        std::string::basic_string[abi:nn180100]( &__dst,  *(void **)(*(void *)(v4 + 80) + 40 * v5),  *(void *)(*(void *)(v4 + 80) + 40 * v5 + 16));
        if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v6 = (std::string *)((char *)&__dst + __dst.__r_.__value_.__s.__size_);
        }
        else {
          uint64_t v6 = (std::string *)(__dst.__r_.__value_.__r.__words[0] + __dst.__r_.__value_.__l.__size_);
        }
        if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_dst = &__dst;
        }
        else {
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        while (p_dst != v6)
        {
          p_dst->__r_.__value_.__s.__data_[0] = __tolower(p_dst->__r_.__value_.__s.__data_[0]);
          p_dst = (std::string *)((char *)p_dst + 1);
        }

        std::string::basic_string[abi:nn180100]( __p,  *(void **)(*(void *)(a1 + 80) + 40 * v5 + 8),  *(void *)(*(void *)(a1 + 80) + 40 * v5 + 24));
        if ((char)__dst.__r_.__value_.__s.__size_ < 0) {
          std::string::__init_copy_ctor_external( &v149,  __dst.__r_.__value_.__l.__data_,  __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string v149 = __dst;
        }
        __int128 v150 = *(_OWORD *)__p;
        uint64_t v151 = v140;
        __p[1] = 0LL;
        uint64_t v140 = 0LL;
        __p[0] = 0LL;
        std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>( (uint64_t)&v141,  (uint64_t)&v149,  (uint64_t)&v149);
        if (SHIBYTE(v151) < 0) {
          operator delete((void *)v150);
        }
        if (SHIBYTE(v140) < 0) {
          operator delete(__p[0]);
        }
        ++v5;
        uint64_t v4 = a1;
      }

      while (v5 < *(unsigned int *)(a1 + 104));
    }

    uint64_t hasPromised = HTTP2ServerPush::hasPromised((int8x8_t *)(v123 + 288), &v141);
    uint64_t v9 = hasPromised;
    if (hasPromised)
    {
      int v10 = *(_DWORD *)(hasPromised + 172);
      if (v10 <= 0) {
        __assert_rtn("setStreamID", "HTTP2Stream.cpp", 693, "streamID > 0");
      }
      uint64_t v11 = *(_DWORD **)(a1 + 64);
      v11[20] = v10;
      v11[14] = 0;
      uint64_t v12 = (*(uint64_t (**)(_DWORD *))(*(void *)v11 + 24LL))(v11);
      uint64_t v13 = v12;
      if (v12) {
        *(_BYTE *)(v12 + 10) = 1;
      }
      uint64_t v14 = *(void *)(v123 + 56);
      if (*(_DWORD *)v14 == 1) {
        unint64_t v15 = (void *)(*(uint64_t (**)(void))(**(void **)(v14 + 8) + 248LL))(*(void *)(v14 + 8));
      }
      else {
        unint64_t v15 = 0LL;
      }
      -[__CFN_TransactionMetrics requestBeginOnConnection:reusedAfterTime:]( v13,  v15,  *(double *)(*(void *)(a1 + 64) + 440LL));
      if (v13)
      {
        *(CFAbsoluteTime *)(v13 + 18os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = CFAbsoluteTimeGetCurrent();
        *(void *)(v13 + 200) = 0x7FF8000000000000LL;
      }

      v131[0] = MEMORY[0x1895F87A8];
      v131[1] = 3321888768LL;
      unint64_t v132 = ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_2;
      CFIndex v133 = &__block_descriptor_68_e8_40c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE_e8_v12__0B8l;
      uint64_t v17 = *(void *)(a1 + 64);
      unint64_t v16 = *(std::__shared_weak_count **)(a1 + 72);
      uint64_t v134 = v123;
      uint64_t v135 = v17;
      UniChar v136 = v16;
      if (v16)
      {
        p_shared_owners = (unint64_t *)&v16->__shared_owners_;
        do
          unint64_t v19 = __ldxr(p_shared_owners);
        while (__stxr(v19 + 1, p_shared_owners));
      }

      uint64_t v137 = v9;
      int v138 = v10;
      if (*(_BYTE *)(v9 + 168))
      {
        unint64_t v20 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_21_2439, 2);
        int v21 = v20;
        if (v20
          && (*(unsigned int (**)(void *, const char *, void))(*(void *)v20 + 16LL))( v20,  "h2 info push promise",  0LL))
        {
          HTTP2ServerPushStream::_getFullURL(v9 + 8, (std::string *)(v9 + 224));
          (*(void (**)(void *, const char *, const __CFString *))(*(void *)v21 + 72LL))( v21,  "h2 psps",  @"[%llu] found complete push promise stream<stream_id=%d> url: %s");
          (*(void (**)(void *))(*(void *)v21 + 8LL))(v21);
        }

        v132((uint64_t)v131, 1);
      }

      else
      {
        unint64_t v77 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_25, 2);
        unint64_t v78 = v77;
        if (v77
          && (*(unsigned int (**)(void *, const char *, void))(*(void *)v77 + 16LL))( v77,  "h2 info push promise",  0LL))
        {
          uint64_t v79 = *(dispatch_data_s **)(v9 + 152);
          if (v79) {
            dispatch_data_get_size(v79);
          }
          HTTP2ServerPushStream::_getFullURL(v9 + 8, (std::string *)(v9 + 224));
          (*(void (**)(void *, const char *, const __CFString *))(*(void *)v78 + 72LL))( v78,  "h2 psps",  @"[%llu] found incomplete push promise stream<stream_id=%d data_received=%lu> url: %s");
          (*(void (**)(void *))(*(void *)v78 + 8LL))(v78);
        }

        SmartBlockWithArgs<BOOL>::SmartBlockWithArgs(&v129, v131);
        std::vector<SmartBlockWithArgs<BOOL>>::push_back[abi:nn180100]((char **)(v9 + 176), v129, (uint64_t)v130);
        ++*(_DWORD *)(*(void *)v9 + 16LL);
        CFIndex v80 = v130;
        if (v130)
        {
          unint64_t v81 = (unint64_t *)&v130->__shared_owners_;
          do
            unint64_t v82 = __ldaxr(v81);
          while (__stlxr(v82 - 1, v81));
          if (!v82)
          {
            ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
            std::__shared_weak_count::__release_weak(v80);
          }
        }
      }

      unint64_t v22 = *(void **)(v123 + 128);
      if (v22) {
        dispatch_async(*(dispatch_queue_t *)(v123 + 168), v22);
      }
      uint64_t v23 = v136;
      if (v136)
      {
        uint64_t v24 = (unint64_t *)&v136->__shared_owners_;
        do
          unint64_t v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }

      std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v141);
      return;
    }

    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table((uint64_t)&v141);
  }

  if (*(_BYTE *)(v123 + 264)
    || (*(_DWORD *)(v123 + 176) - 3) < 2
    || *(void *)(v123 + 144) | *(unsigned int *)(v123 + 152))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
    return;
  }

  uint64_t v26 = *(void *)(a1 + 64);
  if (*(void *)(v26 + 432))
  {
    LODWORD(__p[0]) = nghttp2_session_get_next_stream_id();
    uint64_t v27 = v123;
    CFMutableSetRef Mutable = *(CFMutableSetRef *)(v123 + 584);
    if (!Mutable)
    {
      unint64_t v29 = CFGetAllocator((CFTypeRef)(v123 - 16));
      CFMutableSetRef Mutable = CFSetCreateMutable(v29, 0LL, MEMORY[0x189605258]);
      uint64_t v27 = v123;
      uint64_t v30 = *(const void **)(v123 + 584);
      *(void *)(v123 + 58os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = Mutable;
      if (v30)
      {
        CFRelease(v30);
        CFMutableSetRef Mutable = *(CFMutableSetRef *)(v123 + 584);
      }
    }

    uint64_t v31 = *(void **)(*(void *)(a1 + 64) + 432LL);
    int data = (int)__p[0];
    v125[0] = MEMORY[0x1895F87A8];
    v125[1] = 3221225472LL;
    unint64_t v126 = ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_3_28;
    CFIndex v127 = &__block_descriptor_40_e17_v24__0i8i12i16B20l;
    uint64_t v128 = v27;
    unint64_t v33 = (void *)[v31 objectForKeyedSubscript:@"MainDocumentTaskIdentifier"];
    if (v33)
    {
      uint64_t v34 = [v31 objectForKeyedSubscript:@"DependencyTree"];
      if (v34)
      {
        if ((-[__CFSet containsObject:](Mutable, "containsObject:", v33) & 1) == 0)
        {
          -[__CFSet addObject:](Mutable, "addObject:", v33);
          LODWORD(__dst.__r_.__value_.__l.__data_) = data;
          int v36 = *(void **)(v34 + 24);
          if (v36 && (objc_setProperty_nonatomic(v36, v35, v33, 32LL), (CFPropertyListFormat v37 = *(void ***)(v34 + 24)) != 0LL))
          {
            if (!v37[5])
            {
              int v38 = (void *)[MEMORY[0x189603FC8] dictionary];
              objc_setProperty_nonatomic(v37, v39, v38, 40LL);
            }

            if (!v37[6])
            {
              CFIndex v40 = (void *)[MEMORY[0x189603FC8] dictionary];
              objc_setProperty_nonatomic(v37, v41, v40, 48LL);
            }

            unint64_t v42 = (void *)[MEMORY[0x189603FA8] array];
            -[__NSCFURLSessionTaskDependencyTreeNode makePriorityInfoStartingFromStreamID:parentStream:priorityInfo:dependentToParentStreamIDs:parentToParentStreamIDs:]( (uint64_t)v37,  (unsigned int *)&__dst,  0LL,  v42,  v37[5],  v37[6]);
          }

          else
          {
            unint64_t v42 = 0LL;
          }

          __int128 v143 = 0u;
          __int128 v144 = 0u;
          __int128 v141 = 0u;
          __int128 v142 = 0u;
          uint64_t v43 = [v42 countByEnumeratingWithState:&v141 objects:&v149 count:16];
          if (v43)
          {
            uint64_t v44 = *(void *)v142;
            do
            {
              for (uint64_t i = 0LL; i != v43; ++i)
              {
                if (*(void *)v142 != v44) {
                  objc_enumerationMutation(v42);
                }
                BOOL v46 = *(void **)(*((void *)&v141 + 1) + 8 * i);
                uint64_t v47 = objc_msgSend((id)objc_msgSend(v46, "objectForKeyedSubscript:", @"streamID"), "intValue");
                uint64_t v48 = objc_msgSend( (id)objc_msgSend(v46, "objectForKeyedSubscript:", @"parentStreamID"),  "intValue");
                uint64_t v49 = objc_msgSend((id)objc_msgSend(v46, "objectForKeyedSubscript:", @"weight"), "intValue");
                uint64_t v50 = objc_msgSend((id)objc_msgSend(v46, "objectForKeyedSubscript:", @"exclusive"), "BOOLValue");
                ((void (*)(void *, uint64_t, uint64_t, uint64_t, uint64_t))v126)(v125, v47, v48, v49, v50);
              }

              uint64_t v43 = [v42 countByEnumeratingWithState:&v141 objects:&v149 count:16];
            }

            while (v43);
          }

          if ([v42 count]) {
            int data = LODWORD(__dst.__r_.__value_.__l.__data_) + 2;
          }
          else {
            int data = (int)__dst.__r_.__value_.__l.__data_;
          }
        }
      }
    }

    LODWORD(__p[0]) = data;
    nghttp2_session_set_next_stream_id();
    CFDataRef v51 = CFGetAllocator((CFTypeRef)(v123 - 16));
    CFNumberRef v52 = CFNumberCreate(v51, kCFNumberSInt32Type, __p);
    uint64_t v53 = *(void *)(a1 + 64);
    CFTypeID v54 = *(void **)(v53 + 432);
    BOOL v55 = *(void **)(v123 + 40);
    CFURLRef v56 = CFHTTPMessageCopyRequestURL((CFHTTPMessageRef)(*(void *)(v53 + 40) - 16LL));
    CFIndex v57 = (void *)[v55 objectForKeyedSubscript:@"TaskIDs"];
    uint64_t v58 = [v54 objectForKeyedSubscript:@"ParentTaskIdentifier"];
    if (v58)
    {
      unint64_t v59 = (void *)[v57 objectForKeyedSubscript:v58];
      if (v59) {
        unint64_t v59 = (void *)v59[1];
      }
      int v60 = [v59 intValue];
      if (v60) {
        goto LABEL_158;
      }
    }

    uint64_t v61 = [v54 objectForKeyedSubscript:@"DependencyTree"];
    uint64_t v62 = [v54 objectForKeyedSubscript:@"MainDocumentTaskIdentifier"];
    if (!v62) {
      goto LABEL_157;
    }
    v149.__r_.__value_.__r.__words[0] = 0LL;
    v149.__r_.__value_.__l.__size_ = (std::string::size_type)&v149;
    v149.__r_.__value_.__l.__cap_ = 0x3052000000LL;
    *(void *)&__int128 v150 = __Block_byref_object_copy__12231;
    *((void *)&v150 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = __Block_byref_object_dispose__12232;
    *(void *)&__int128 v141 = 0LL;
    *((void *)&v141 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &v141;
    *(void *)&__int128 v142 = 0x3052000000LL;
    *((void *)&v142 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = __Block_byref_object_copy__12231;
    *(void *)&__int128 v143 = __Block_byref_object_dispose__12232;
    __dst.__r_.__value_.__r.__words[0] = MEMORY[0x1895F87A8];
    __dst.__r_.__value_.__l.__size_ = 3221225472LL;
    __dst.__r_.__value_.__l.__cap_ = (std::string::size_type)____NSURLSessionTaskDependency_FindParentStreamID_block_invoke;
    CFIndex v146 = &unk_189C130C8;
    UniChar v147 = &v149;
    CFIndex v148 = &v141;
    CFTypeID v63 = (void *)[MEMORY[0x189607A50] componentsWithURL:v56 resolvingAgainstBaseURL:1];
    uint64_t v64 = [v63 rangeOfPath];
    BOOL v65 = (void *)[v63 string];
    uint64_t v66 = objc_msgSend(v65, "substringWithRange:", 0, v64);
    uint64_t v67 = objc_msgSend(v65, "substringWithRange:", v64, objc_msgSend(v65, "length") - v64);
    ((void (*)(std::string *, uint64_t, uint64_t))__dst.__r_.__value_.__l.__cap_)(&__dst, v66, v67);
    uint64_t v68 = [v54 objectForKeyedSubscript:@"DependencyDescription"];
    if (v68)
    {
      if (v61 && (uint64_t v69 = *(void *)(v61 + 24)) != 0) {
        unint64_t v70 = *(void **)(v69 + 48);
      }
      else {
        unint64_t v70 = 0LL;
      }
      int v60 = objc_msgSend((id)objc_msgSend(v70, "objectForKeyedSubscript:", *(void *)(v68 + 24)), "intValue");
      if (v60) {
        goto LABEL_135;
      }
      uint64_t v71 = *(void *)(v68 + 24);
      if (v71)
      {
        if (*(void *)(v71 + 8))
        {
          uint64_t v72 = (void *)[MEMORY[0x189607940] stringWithString:*(void *)(v149.__r_.__value_.__l.__size_ + 40)];
          uint64_t v73 = (uint64_t)v72;
          uint64_t v74 = *(void *)(v68 + 24);
          if (v74) {
            uint64_t v75 = *(void *)(v74 + 8);
          }
          else {
            uint64_t v75 = 0LL;
          }
          [v72 appendString:v75];
          int v76 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForURLString:]( [v57 objectForKeyedSubscript:v62],  v73);
          goto LABEL_134;
        }

        if (*(void *)(v71 + 16))
        {
          uint64_t v103 = [v57 objectForKeyedSubscript:v62];
          uint64_t v104 = *(void *)(v68 + 24);
          if (v104) {
            uint64_t v105 = *(void *)(v104 + 16);
          }
          else {
            uint64_t v105 = 0LL;
          }
          int v76 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForMimeType:](v103, v105);
LABEL_134:
          int v60 = v76;
          if (v76)
          {
LABEL_135:
            char v106 = 0;
            goto LABEL_156;
          }
        }
      }

      char v106 = 0;
      int v60 = 0;
      goto LABEL_156;
    }

    if (!v61) {
      goto LABEL_154;
    }
    uint64_t v83 = *(void **)(*((void *)&v141 + 1) + 40LL);
    unint64_t v84 = objc_alloc_init(&OBJC_CLASS_____NSURLSessionTaskDependencyResourceIdentifier);
    uint64_t v86 = v84;
    if (v84) {
      objc_setProperty_nonatomic(v84, v85, v83, 8LL);
    }
    uint64_t v87 = [*(id *)(v61 + 16) objectForKey:v86];
    if (v87)
    {
      uint64_t v88 = *(void *)(v61 + 24);
      unint64_t v89 = v88 ? *(void **)(v88 + 40) : 0LL;
      int v60 = objc_msgSend((id)objc_msgSend(v89, "objectForKeyedSubscript:", *(void *)(v87 + 16)), "intValue");
      if (v60) {
        goto LABEL_135;
      }
    }

    unint64_t v90 = (void *)+[NSURLSessionTaskDependencyTree mimeTypeForURLString:]( (uint64_t)&OBJC_CLASS___NSURLSessionTaskDependencyTree,  *(void *)(*((void *)&v141 + 1) + 40LL));
    CFTypeRef v91 = objc_alloc_init(&OBJC_CLASS_____NSURLSessionTaskDependencyResourceIdentifier);
    unint64_t v93 = v91;
    if (v91) {
      objc_setProperty_nonatomic(v91, v92, v90, 16LL);
    }
    uint64_t v94 = [*(id *)(v61 + 16) objectForKey:v93];
    if (v94)
    {
      uint64_t v95 = *(void *)(v61 + 24);
      unint64_t v96 = v95 ? *(void **)(v95 + 40) : 0LL;
      int v60 = objc_msgSend((id)objc_msgSend(v96, "objectForKeyedSubscript:", *(void *)(v94 + 16)), "intValue");
      if (v60) {
        goto LABEL_135;
      }
    }

    if (v87)
    {
      uint64_t v97 = *(void *)(v87 + 24);
      if (v97)
      {
        if (*(void *)(v97 + 8))
        {
          uint64_t v98 = (void *)[MEMORY[0x189607940] stringWithString:*(void *)(v149.__r_.__value_.__l.__size_ + 40)];
          uint64_t v99 = (uint64_t)v98;
          uint64_t v100 = *(void *)(v87 + 24);
          if (v100) {
            uint64_t v101 = *(void *)(v100 + 8);
          }
          else {
            uint64_t v101 = 0LL;
          }
          [v98 appendString:v101];
          int v102 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForURLString:]( [v57 objectForKeyedSubscript:v62],  v99);
        }

        else
        {
          if (!*(void *)(v97 + 16)) {
            goto LABEL_142;
          }
          uint64_t v107 = [v57 objectForKeyedSubscript:v62];
          uint64_t v108 = *(void *)(v87 + 24);
          if (v108) {
            uint64_t v109 = *(void *)(v108 + 16);
          }
          else {
            uint64_t v109 = 0LL;
          }
          int v102 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForMimeType:](v107, v109);
        }

        int v60 = v102;
        if (v102) {
          goto LABEL_135;
        }
      }
    }

LABEL_142:
    if (v94)
    {
      uint64_t v110 = *(void *)(v94 + 24);
      if (v110)
      {
        if (*(void *)(v110 + 8))
        {
          uint64_t v111 = (void *)[MEMORY[0x189607940] stringWithString:*(void *)(v149.__r_.__value_.__l.__size_ + 40)];
          uint64_t v112 = (uint64_t)v111;
          uint64_t v113 = *(void *)(v94 + 24);
          if (v113) {
            uint64_t v114 = *(void *)(v113 + 8);
          }
          else {
            uint64_t v114 = 0LL;
          }
          [v111 appendString:v114];
          int v115 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForURLString:]( [v57 objectForKeyedSubscript:v62],  v112);
          goto LABEL_152;
        }

        if (*(void *)(v110 + 16))
        {
          uint64_t v116 = [v57 objectForKeyedSubscript:v62];
          uint64_t v117 = *(void *)(v94 + 24);
          if (v117) {
            uint64_t v118 = *(void *)(v117 + 16);
          }
          else {
            uint64_t v118 = 0LL;
          }
          int v115 = -[__NSCFURLSessionTaskActiveStreamDependencyInfo parentStreamIDForMimeType:](v116, v118);
LABEL_152:
          int v60 = v115;
          if (v115) {
            goto LABEL_135;
          }
          goto LABEL_155;
        }
      }
    }

            uint64_t v61 = (const __CFNumber *)a3[15];
            uint64_t valuePtr = -1LL;
            uint64_t v62 = CFNumberGetValue(v61, kCFNumberCFIndexType, &valuePtr);
            CFTypeID v63 = valuePtr;
            if (!v62) {
              CFTypeID v63 = -1LL;
            }
            this->fRequestPriority = v63;
            goto LABEL_145;
          }

  *(void *)&a4->unsigned int year = 0LL;
  a4->second = 0.0;
  if (a5)
  {
    if (*a5) {
      CFRelease(*a5);
    }
    *a5 = 0LL;
  }

  return v7;
}

LABEL_154:
    int v60 = 0;
LABEL_155:
    char v106 = 1;
LABEL_156:
    _Block_object_dispose(&v141, 8);
    _Block_object_dispose(&v149, 8);
    if ((v106 & 1) == 0)
    {
LABEL_158:
      if (v56) {
        CFRelease(v56);
      }
      uint64_t v26 = *(void *)(a1 + 64);
      goto LABEL_161;
    }

LABEL_157:
    int v60 = 0;
    goto LABEL_158;
  }

  CFNumberRef v52 = 0LL;
  int v60 = 0;
LABEL_161:
  LODWORD(v149.__r_.__value_.__r.__words[1]) = 0;
  v149.__r_.__value_.__r.__words[0] = 0LL;
  if (*(_BYTE *)(v26 + 233) != 16 || v60) {
    nghttp2_priority_spec_init();
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = nghttp2_submit_request();
  int v119 = *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  if (v119 == -509 || v119 == -901)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
  }

  else
  {
    if (!*(_DWORD *)(v123 + 600))
    {
      *(_DWORD *)(v123 + 600) = v119;
      int v119 = *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    }

    if (v119 <= 0) {
      __assert_rtn("setStreamID", "HTTP2Stream.cpp", 693, "streamID > 0");
    }
    uint64_t v120 = *(void *)(a1 + 64);
    *(_DWORD *)(v120 + 80) = v119;
    *(_DWORD *)(v120 + 56) = 0;
    sqlite3_int64 v121 = *(void **)(v120 + 432);
    if (v121) {
      __NSURLSessionTaskDependency_AddNewRequest(v121, v52, *(void **)(v123 + 40), *(void *)(v120 + 48));
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    unint64_t v122 = *(void **)(v123 + 128);
    if (v122) {
      dispatch_async(*(dispatch_queue_t *)(v123 + 168), v122);
    }
  }

  if (v52) {
    CFRelease(v52);
  }
}

            double v7 = v9;
LABEL_225:
            if (v6 >= (const UInt8 *)v7) {
              CFURLRef v56 = &stru_189C1D1D8;
            }
            else {
              CFURLRef v56 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
            }
            *a1 = v56;
            uint64_t result = 260LL;
            break;
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
            goto LABEL_107;
          case 39:
            goto LABEL_161;
          default:
            if (v33[1] == 127) {
              goto LABEL_250;
            }
            goto LABEL_107;
        }

        break;
      case 0x3Bu:
      case 0x3Du:
        uint64_t v13 = 1;
LABEL_119:
        uint64_t v9 = v7;
        goto LABEL_125;
      default:
        continue;
    }

    break;
  }

void sub_182A46C90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *__p, uint64_t a33, int a34, __int16 a35, char a36, char a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *a46, uint64_t a47, int a48, __int16 a49, char a50,char a51)
{
  if (v52) {
    CFRelease(v52);
  }
  if (v51) {
    CFRelease(v51);
  }
  _Unwind_Resume(a1);
}

void MemPool::~MemPool(MemPool *this)
{
  uint64_t v2 = (void **)*((void *)this + 1);
  BOOL v3 = (void **)*((void *)this + 2);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = *v2;
      v2 += 2;
      free(v4);
    }

    while (v2 != v3);
    uint64_t v2 = (void **)*((void *)this + 1);
  }

  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }

uint64_t __copy_helper_block_e8_64c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 72);
  *(void *)(result + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = *(void *)(a2 + 64);
  *(void *)(result + 72) = v2;
  if (v2)
  {
    BOOL v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_64c39_ZTSNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
}

void std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::pair<std::string,std::string>>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    unint64_t v8 = (uint64_t *)a2;
  }
  else {
    unint64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }

    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }

    unint64_t v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
        }

        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }

          else
          {
            v17 &= v12 - 1;
          }

          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }

  unint64_t v18 = (void *)(a1 + 16);
  unint64_t v19 = (char *)operator new(0x40uLL);
  v29[0] = v19;
  v29[1] = a1 + 16;
  *(void *)unint64_t v19 = 0LL;
  *((void *)v19 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v11;
  *((_OWORD *)v19 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = *(_OWORD *)a3;
  *((void *)v19 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = *(void *)(a3 + 16);
  *(void *)a3 = 0LL;
  *(void *)(a3 + _Block_object_dispose((const void *)(v53 - 256), 8) = 0LL;
  *(_OWORD *)(v19 + 40) = *(_OWORD *)(a3 + 24);
  *((void *)v19 + 7) = *(void *)(a3 + 40);
  *(void *)(a3 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
  *(void *)(a3 + 40) = 0LL;
  *(void *)(a3 + CFRetain((char *)this - 16) = 0LL;
  *(void *)(a3 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  char v30 = 1;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1LL;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::__rehash<true>( a1,  v25);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }

    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }

  uint64_t v26 = *(void *)a1;
  uint64_t v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *(void *)unint64_t v19 = *v27;
LABEL_44:
    void *v27 = v19;
    goto LABEL_45;
  }

  *(void *)unint64_t v19 = *v18;
  *unint64_t v18 = v19;
  *(void *)(v26 + 8 * v3) = v18;
  if (*(void *)v19)
  {
    unint64_t v28 = *(void *)(*(void *)v19 + 8LL);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12) {
        v28 %= v12;
      }
    }

    else
    {
      v28 &= v12 - 1;
    }

    uint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_44;
  }

void sub_182A470C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t std::pair<std::string,std::string>::~pair(uint64_t a1)
{
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::string>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::string>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::string>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::string>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_2( uint64_t a1, int a2)
{
  unint64_t v3 = *(HTTP2Stream **)(a1 + 40);
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    HTTP2Stream::beginHeaders(v3);
    for (uint64_t i = *(uint64_t **)(*(void *)(a1 + 56) + 96LL); i; uint64_t i = (uint64_t *)*i)
    {
      if (*((char *)i + 39) < 0)
      {
        uint64_t v6 = (unsigned __int8 *)i[2];
        size_t v7 = i[3];
      }

      else
      {
        uint64_t v6 = (unsigned __int8 *)(i + 2);
        size_t v7 = *((unsigned __int8 *)i + 39);
      }

      if (*((char *)i + 63) < 0)
      {
        unint64_t v8 = (unsigned __int8 *)i[5];
        size_t v9 = i[6];
      }

      else
      {
        unint64_t v8 = (unsigned __int8 *)(i + 5);
        size_t v9 = *((unsigned __int8 *)i + 63);
      }

      HTTP2Stream::processHeaderLine(*(HTTP2Stream **)(a1 + 40), v6, v7, v8, v9);
    }

    unint64_t v10 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_10_2451, 2);
    if (v10)
    {
      unint64_t v11 = v10;
      if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v10 + 16LL))( v10,  "h2 info push promise",  0LL))
      {
        (*(void (**)(void *, const char *, const __CFString *))(*(void *)v11 + 72LL))( v11,  "h2 psps",  @"[%llu] finish push promise processing stream_id=%d");
        (*(void (**)(void *))(*(void *)v11 + 8LL))(v11);
      }
    }

    HTTP2Stream::endHeaders(*(HTTP2Stream **)(a1 + 40));
    uint64_t v12 = *(void *)(a1 + 56);
    uint8x8_t v13 = *(dispatch_data_s **)(v12 + 152);
    if (v13)
    {
      HTTP2Stream::bufferDataFromDataFrame(*(void *)(a1 + 40), v13, 0);
      uint64_t v12 = *(void *)(a1 + 56);
    }

    unint64_t v14 = (HTTP2Connection *)*(unsigned int *)(v12 + 256);
    if (!(_DWORD)v14)
    {
      int v20 = *(_DWORD *)(a1 + 64);
      CFRetain((CFTypeRef)(v4 - 16));
      float v21 = *(dispatch_queue_s **)(v4 + 168);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      block[2] = ___ZN15HTTP2Connection24removeServerPushedStreamEi_block_invoke;
      block[3] = &__block_descriptor_44_e5_v8__0l;
      block[4] = v4;
      int v23 = v20;
      dispatch_async(v21, block);
      goto LABEL_20;
    }

    unint64_t v15 = *(HTTP2Stream **)(a1 + 40);
    CFIndex v16 = HTTP2Connection::http2ErrorCodeToCFStreamError(v14);
    uint64_t v18 = v17;
    unint64_t v3 = v15;
    v19.domain = v16;
    *(void *)&v19.CFErrorRef error = v18;
  }

  else
  {
    v19.domain = 1LL;
    *(void *)&v19.CFErrorRef error = 53LL;
  }

  HTTP2Stream::setError(v3, v19);
LABEL_20:
  HTTP2Stream::closeStreamWithErrorCode(*(HTTP2Stream **)(a1 + 40));
  HTTP2Stream::breakStreamUserDataCycle(*(HTTP2Stream **)(a1 + 40));
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_3_28()
{
  return nghttp2_submit_priority();
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_2_24@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v53 - 256), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 485LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = "none";
  return result;
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_20@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v53 - 256), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 477LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = "none";
  return result;
}

uint64_t HTTP2Connection::http2ErrorCodeToCFStreamError(HTTP2Connection *this)
{
  else {
    return qword_182C9D350[(int)this - 1];
  }
}

void ___ZN15HTTP2Connection24removeServerPushedStreamEi_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v1 + 288), *(_DWORD *)(a1 + 40), 1);
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN15HTTP2Connection13submitRequestENSt3__110shared_ptrI11HTTP2StreamEEU13block_pointerFvvE_block_invoke_3@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v53 - 256), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 451LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = "none";
  return result;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]( uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      uint64_t v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      uint64_t v6 = *a1 - 0x3C5A37A36834CED9LL * (v5 + a2);
      uint64_t v8 = a1[2];
      uint64_t v7 = a1[3];
      uint64_t v9 = __ROR8__(v6 + v7, 52);
      uint64_t v10 = v6 + a1[1];
      uint64_t v11 = __ROR8__(v10, 7);
      uint64_t v12 = v10 + v8;
      uint64_t v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      uint64_t v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      uint64_t v15 = __ROR8__(v14 + v13, 52);
      uint64_t v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9LL * (v5 + a2), 37) + v9;
      uint64_t v17 = __ROR8__(v13, 37);
      uint64_t v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      uint64_t v19 = __ROR8__(v18, 7);
      uint64_t v20 = v16 + __ROR8__(v12, 31);
      uint64_t v21 = v18 + v5;
      uint64_t v22 = v21 + v14;
      unint64_t v23 = 0x9AE16A3B2F90404FLL;
      unint64_t v24 = 0xC3A5C85C97CB3127LL * (v22 + v20) - 0x651E95C4D06FBFB1LL * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      unint64_t v25 = v20 - 0x3C5A37A36834CED9LL * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }

    unint64_t v4 = 0x9DDFEA08EB382D69LL;
    uint64_t v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    uint64_t v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    uint64_t v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    uint64_t v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    uint64_t v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    uint64_t v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    uint64_t v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v39 = v35 + v37;
    unint64_t v40 = 0x9DDFEA08EB382D69LL
        * (v34 ^ ((0x9DDFEA08EB382D69LL * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69LL * (v34 ^ (v32 + a2))));
    unint64_t v41 = 0x9DDFEA08EB382D69LL * (v40 ^ (v40 >> 47));
    unint64_t v42 = v36 + a2 + v35 + v32;
    uint64_t v43 = v42 + v33;
    unint64_t v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297LL * (v40 ^ (v40 >> 47)), 21);
    uint64_t v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    uint64_t v46 = v45 + v34 + v37;
    uint64_t v47 = __ROR8__(v46, 44);
    uint64_t v48 = v46 + v38;
    uint64_t v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    uint64_t v51 = *a1;
    uint64_t v50 = a1 + 4;
    unint64_t v52 = v51 - 0x4B6D499041670D8DLL * v33;
    uint64_t v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0LL);
    do
    {
      uint64_t v54 = *(v50 - 3);
      uint64_t v55 = v52 + v43 + v39 + v54;
      uint64_t v56 = v50[2];
      uint64_t v57 = v50[3];
      uint64_t v58 = v50[1];
      unint64_t v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      uint64_t v59 = v41 + v48;
      uint64_t v60 = *(v50 - 2);
      uint64_t v61 = *(v50 - 1);
      uint64_t v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      uint64_t v63 = v62 + v48 + v61;
      uint64_t v64 = v62 + v54 + v60;
      uint64_t v43 = v64 + v61;
      uint64_t v65 = __ROR8__(v64, 44) + v62;
      unint64_t v66 = (0xB492B66FBE98F273LL * __ROR8__(v55, 37)) ^ v49;
      unint64_t v52 = 0xB492B66FBE98F273LL * __ROR8__(v59, 33);
      unint64_t v44 = v65 + __ROR8__(v63 + v66, 21);
      unint64_t v67 = v52 + v49 + *v50;
      uint64_t v48 = v67 + v58 + v56 + v57;
      uint64_t v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      unint64_t v41 = v66;
      v53 += 64LL;
    }

    while (v53);
    unint64_t v68 = v52
        - 0x622015F714C7D297LL
        * ((0x9DDFEA08EB382D69LL
          * (v49 ^ ((0x9DDFEA08EB382D69LL * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69LL * (v49 ^ ((0x9DDFEA08EB382D69LL * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v49 ^ v44)))) >> 47));
    unint64_t v69 = 0x9DDFEA08EB382D69LL
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297LL
                * ((0x9DDFEA08EB382D69LL
                  * (v48 ^ ((0x9DDFEA08EB382D69LL * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69LL * (v48 ^ ((0x9DDFEA08EB382D69LL * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v48 ^ v43)))) >> 47))));
    unint64_t v70 = 0x9DDFEA08EB382D69LL * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }

  if (a2 > 0x10)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xB492B66FBE98F273LL * *a1;
    uint64_t v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    unint64_t v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557LL, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v23 = 0x9DDFEA08EB382D69LL;
    unint64_t v30 = 0x9DDFEA08EB382D69LL * (v29 ^ (v28 - 0x3C5A37A36834CED9LL * *(uint64_t *)((char *)a1 + a2 - 16)));
    unint64_t v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    unint64_t v25 = 0x9DDFEA08EB382D69LL * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }

  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      uint64_t v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v23 = 0x9DDFEA08EB382D69LL;
      unint64_t v73 = 0x9DDFEA08EB382D69LL * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      unint64_t v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }

    unint64_t v4 = 0x9AE16A3B2F90404FLL;
    if (!a2) {
      return v4;
    }
    unint64_t v70 = (0xC949D7C7509E6557LL * (a2 + 4LL * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }

  uint64_t v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69LL
        * ((0x9DDFEA08EB382D69LL
          * (v3 ^ ((0x9DDFEA08EB382D69LL * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69LL * (v3 ^ ((0x9DDFEA08EB382D69LL * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v3 ^ *a1)))) >> 47))) ^ v2;
}

BOOL std::equal_to<std::string>::operator()[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0LL) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0LL) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0LL;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1LL;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }

  while (v13 && v12);
  return v14;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }

void ___ZN15HTTP2Connection14didCloseStreamENSt3__110shared_ptrI11HTTP2StreamEEb_block_invoke(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v34 = (HTTP2Stream *)v2;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    if (!v2)
    {
      BOOL v14 = 0;
      goto LABEL_38;
    }

    *(void *)CFStreamError buf = v2;
    *(void *)&uint8_t buf[8] = v4;
    int v7 = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  else
  {
    if (!v2)
    {
      BOOL v14 = 0;
      goto LABEL_42;
    }

    *(void *)CFStreamError buf = *(void *)(a1 + 40);
    *(void *)&uint8_t buf[8] = 0LL;
  }

  HTTP2Connection::streamExitedStallableState(v3, v2, v4);
  if (v4)
  {
    int v9 = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  uint64_t v11 = *(const __CFArray **)(v3 + 232);
  CFIndex Count = CFArrayGetCount(v11);
  if (Count < 1)
  {
    BOOL v14 = 0;
    goto LABEL_35;
  }

  CFIndex v13 = 0LL;
  BOOL v14 = 1;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v11, v13);
    uint64_t v17 = (HTTP2Stream *)*((void *)ValueAtIndex + 3);
    uint64_t v16 = (std::__shared_weak_count *)*((void *)ValueAtIndex + 4);
    if (v16) {
      break;
    }
    if (v17 == v34) {
      goto LABEL_30;
    }
LABEL_26:
    BOOL v14 = ++v13 < Count;
    if (v13 == Count) {
      goto LABEL_35;
    }
  }

  uint64_t v18 = (unint64_t *)&v16->__shared_owners_;
  do
    unint64_t v19 = __ldxr(v18);
  while (__stxr(v19 + 1, v18));
  do
    unint64_t v20 = __ldaxr(v18);
  while (__stlxr(v20 - 1, v18));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }

  if (v17 != v34) {
    goto LABEL_26;
  }
LABEL_30:
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 232), v13);
  uint64_t v21 = *(int *)(v3 + 304);
  if (!(CFArrayGetCount(*(CFArrayRef *)(v3 + 232)) + v21))
  {
    if (*(void *)(v3 + 720)) {
      HTTP2Connection::stopStallRecovery((dispatch_source_t *)v3);
    }
    *(CFAbsoluteTime *)(v3 + 24_Block_object_dispose((const void *)(v53 - 256), 8) = CFAbsoluteTimeGetCurrent();
    *(_BYTE *)(v3 + 64__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
    if (*(_BYTE *)(v3 + 264))
    {
      HTTP2Connection::stop((HTTP2Connection *)v3, 0);
    }

    else
    {
      uint64_t v28 = *(void *)(v3 + 56);
      if (v28 && *(_DWORD *)v28 == 1) {
        (*(void (**)(void, uint64_t))(**(void **)(v28 + 8) + 88LL))(*(void *)(v28 + 8), 1LL);
      }
    }
  }

void sub_182A47EA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void ___ZN15HTTP2Connection19resumeDataForStreamENSt3__110shared_ptrI11HTTP2StreamEE_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(HTTP2Connection **)(a1 + 32);
  if (*((void *)v1 + 20))
  {
    nghttp2_session_resume_data();
    HTTP2Connection::_onqueue_scheduleIO(v1);
  }

  CFRelease((char *)v1 - 16);
}

void HTTP2Connection::setErrorOnAllStreams(HTTP2Connection *this, int a2)
{
  uint64_t v4 = (dispatch_queue_s *)*((void *)this + 21);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZN15HTTP2Connection20setErrorOnAllStreamsEj_block_invoke;
  v5[3] = &__block_descriptor_44_e5_v8__0l;
  v5[4] = this;
  int v6 = a2;
  dispatch_async(v4, v5);
}

void ___ZN15HTTP2Connection20setErrorOnAllStreamsEj_block_invoke(uint64_t a1)
{
  CFIndex v1 = 0LL;
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (HTTP2Connection *)*(unsigned int *)(a1 + 40);
  while (v1 < CFArrayGetCount(*(CFArrayRef *)(v2 + 232)))
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 232), v1);
    int v6 = (HTTP2Stream *)*((void *)ValueAtIndex + 3);
    int v5 = (std::__shared_weak_count *)*((void *)ValueAtIndex + 4);
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }

    CFIndex v9 = HTTP2Connection::http2ErrorCodeToCFStreamError(v3);
    uint64_t v11 = v10;
    v14.domain = v9;
    *(void *)&v14.CFErrorRef error = v11;
    HTTP2Stream::setError(v6, v14);
    if (v5)
    {
      BOOL v12 = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }

    ++v1;
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN15HTTP2Connection20changeStreamPriorityENSt3__110shared_ptrI11HTTP2StreamEEl_block_invoke( void *a1)
{
  uint64_t v1 = a1[4];
  if (*(void *)(v1 + 160))
  {
    uint64_t v3 = a1[5];
    uint64_t v2 = (std::__shared_weak_count *)a1[6];
    if (v2)
    {
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        unint64_t v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }

    if ((*(_DWORD *)(v3 + 56) & 0xFFFFFFFE) != 2)
    {
      nghttp2_priority_spec_init();
      if (!nghttp2_submit_priority())
      {
        int v6 = *(void **)(v1 + 128);
        if (v6) {
          dispatch_async(*(dispatch_queue_t *)(v1 + 168), v6);
        }
      }
    }

    if (v2)
    {
      int v7 = (unint64_t *)&v2->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

void sub_182A48124( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __copy_helper_block_e8_40c40_ZTSKNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 4_Block_object_dispose((const void *)(v53 - 256), 8) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_40c40_ZTSKNSt3__110shared_ptrI11HTTP2StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

std::string *HTTP2Diagnostic::APPEND_RECV_HEADER( std::string *a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5)
{
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = __p.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(a1, (const std::string::value_type *)p_p, size);
  std::string::append(a1, "] recv (stream_id=");
  std::to_string(&__p, a4);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    BOOL v12 = &__p;
  }
  else {
    BOOL v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v13 = __p.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type v13 = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(a1, (const std::string::value_type *)v12, v13);
  std::string::append(a1, ") ");
  int v14 = *(char *)(a2 + 23);
  if (v14 >= 0) {
    uint64_t v15 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v15 = *(const std::string::value_type **)a2;
  }
  if (v14 >= 0) {
    std::string::size_type v16 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v16 = *(void *)(a2 + 8);
  }
  std::string::append(a1, v15, v16);
  std::string::append(a1, ": ");
  if (__CFNCanLogSensitiveContent::onceToken != -1) {
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4760);
  }
  if (__CFNCanLogSensitiveContent::ok)
  {
    else {
      std::string __p = *(std::string *)a3;
    }
  }

  else
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, "<redacted>");
  }

  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v17 = &__p;
  }
  else {
    uint64_t v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v18 = __p.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
  }
  std::string::append(a1, (const std::string::value_type *)v17, v18);
  return std::string::append(a1, "\n");
}

void sub_182A48338( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN15HTTP2Connection22handlePUSHPROMISEframeEPK13nghttp2_frame_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v53 - 256), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 1272LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = "none";
  return result;
}

void ___ZN15HTTP2Connection19handleSETTINGSFrameEPK13nghttp2_frame_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  __int128 v2 = *(_OWORD *)(a1 + 40);
  *(void *)(v1 + 196) = *(void *)(a1 + 56);
  *(_OWORD *)(v1 + 180) = v2;
  *(_BYTE *)(v1 + 22_Block_object_dispose((const void *)(v53 - 256), 8) = 1;
  HTTP2Connection::_onqueue_scheduleIO((HTTP2Connection *)v1);
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN15HTTP2Connection18handleHEADERSFrameEPK13nghttp2_frame_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  __int128 v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v53 - 256), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 1301LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = "none";
  return result;
}

uint64_t _CFHTTPAuthenticationUpdateFromResponse(uint64_t a1, __CFHTTPMessage *a2, void *a3)
{
  if (a1) {
    int v6 = (HTTPAuthentication *)(a1 + 16);
  }
  else {
    int v6 = 0LL;
  }
  return HTTPAuthentication::updateFromResponse(v6, a2, a3);
}

Boolean CFHTTPAuthenticationIsValid(CFHTTPAuthenticationRef auth, CFStreamError *error)
{
  if (auth) {
    unint64_t v4 = (char *)auth + 16;
  }
  else {
    unint64_t v4 = 0LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  CFIndex v5 = *((void *)v4 + 11);
  uint64_t v7 = *((void *)v4 + 12);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
  if (error)
  {
    error->domain = v5;
    *(void *)&error->CFErrorRef error = v7;
  }

  return (_DWORD)v7 == 0;
}

CFStringRef _CFHTTPAuthenticationIsConnectionBasedAuth(_CFHTTPAuthentication *a1)
{
  if (a1) {
    __int128 v2 = (_CFHTTPAuthentication *)((char *)a1 + 16);
  }
  else {
    __int128 v2 = 0LL;
  }
  return HTTPAuthentication::isConnectionBasedAuth(v2);
}

Boolean CFHTTPAuthenticationRequiresOrderedRequests(CFHTTPAuthenticationRef auth)
{
  if (auth) {
    __int128 v2 = (char *)auth + 16;
  }
  else {
    __int128 v2 = 0LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
  Property_Locked = (const __CFString *)HTTPAuthentication::getProperty_Locked( (HTTPAuthentication *)v2,  @"kCFHTTPAuthenticationPropertyMethod");
  Boolean v4 = 1;
  int ExactString = _findExactString(Property_Locked, 1u);
  if (ExactString != 6324248 && ExactString != 5316627)
  {
    if (ExactString == 2146311)
    {
      if (!HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, @"Nextnonce")) {
        Boolean v4 = HTTPAuthentication::getProperty_Locked((HTTPAuthentication *)v2, @"Qop") != 0LL;
      }
    }

    else
    {
      Boolean v4 = 0;
    }
  }

  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 16));
  return v4;
}

Boolean CFHTTPMessageApplyCredentials( CFHTTPMessageRef request, CFHTTPAuthenticationRef auth, CFStringRef username, CFStringRef password, CFStreamError *error)
{
  uint64_t v10 = CFGetAllocator(request);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v10, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    BOOL v12 = Mutable;
    if (username)
    {
      if (auth) {
        std::string::size_type v13 = (CFHTTPAuthenticationRef)((char *)auth + 16);
      }
      else {
        std::string::size_type v13 = 0LL;
      }
      if (HTTPAuthentication::requiresAccountDomain(v13))
      {
        int v14 = CFGetAllocator(username);
        ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v14, username, @"\\"");
        if (ArrayBySeparatingStrings)
        {
          std::string::size_type v16 = ArrayBySeparatingStrings;
          if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v16, 0LL);
            CFDictionaryAddValue(v12, @"kCFHTTPAuthenticationAccountDomain", ValueAtIndex);
            std::string::size_type v18 = CFArrayGetValueAtIndex(v16, 1LL);
            unint64_t v19 = v12;
          }

          else
          {
            unint64_t v19 = v12;
            std::string::size_type v18 = username;
          }

          CFDictionaryAddValue(v19, @"kCFHTTPAuthenticationUsername", v18);
          CFRelease(v16);
          if (!password) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }
      }

      CFDictionaryAddValue(v12, @"kCFHTTPAuthenticationUsername", username);
    }

    if (!password)
    {
LABEL_15:
      Boolean v20 = CFHTTPMessageApplyCredentialDictionary(request, auth, v12, error);
      CFRelease(v12);
      LOBYTE(Mutable) = v20;
      return Mutable;
    }

Boolean CFHTTPMessageApplyCredentialDictionary( CFHTTPMessageRef request, CFHTTPAuthenticationRef auth, CFDictionaryRef dict, CFStreamError *error)
{
  if (auth) {
    unint64_t v8 = (char *)auth + 16;
  }
  else {
    unint64_t v8 = 0LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
  HTTPAuthentication::applyCredentials_Locked((CFMutableDictionaryRef *)v8, request, dict, error);
  Boolean v10 = v9;
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 16));
  return v10;
}

Boolean CFHTTPAuthenticationRequiresAccountDomain(CFHTTPAuthenticationRef auth)
{
  if (auth) {
    __int128 v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    __int128 v2 = 0LL;
  }
  return HTTPAuthentication::requiresAccountDomain(v2);
}

Boolean CFHTTPAuthenticationAppliesToRequest(CFHTTPAuthenticationRef auth, CFHTTPMessageRef request)
{
  if (auth) {
    Boolean v4 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    Boolean v4 = 0LL;
  }
  return HTTPAuthentication::appliesToRequest(v4, request);
}

CFTypeID CFHTTPAuthenticationGetTypeID(void)
{
  return *(void *)(HTTPAuthentication::Class(void)::sClass_OBJTYPE + 96);
}

_OWORD *_CFHTTPAuthenticationCreateFromResponseInternal( const __CFAllocator *a1, CFHTTPMessageRef response, const __CFString *a3, char a4, const void *a5, const __CFString *a6, const __CFString *a7, const __CFUUID *a8, char a9, unsigned __int8 a10)
{
  if (!response) {
    return 0LL;
  }
  CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(response);
  CFIndex v17 = ResponseStatusCode;
  if (ResponseStatusCode != 407 && ResponseStatusCode != 401) {
    return 0LL;
  }
  uint64_t v18 = 88LL;
  if (v17 == 407) {
    uint64_t v18 = 96LL;
  }
  unint64_t v19 = *(const void **)((char *)response + v18);
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v21 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    Instance[14] = 0u;
    Instance[15] = 0u;
    Instance[12] = 0u;
    Instance[13] = 0u;
    Instance[10] = 0u;
    Instance[11] = 0u;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
    HTTPAuthentication::HTTPAuthentication((HTTPAuthentication *)(Instance + 1));
    *((_BYTE *)v21 + 177) = a4;
    HTTPAuthentication::_initialize(v23, response, 0LL, a5, a6, a7, v24);
    HTTPAuthentication::initializeSchemes((HTTPAuthentication *)(v21 + 1), response, a3);
  }

  else
  {
    HTTPAuthentication::HTTPAuthentication(0LL);
  }

  return v21;
}

CFHTTPAuthenticationRef CFHTTPAuthenticationCreateFromResponse(CFAllocatorRef alloc, CFHTTPMessageRef response)
{
  return (CFHTTPAuthenticationRef)_CFHTTPAuthenticationCreateFromResponseInternal( alloc,  response,  0LL,  1,  0LL,  0LL,  0LL,  0LL,  0,  v3);
}

_OWORD *_CFHTTPAuthenticationCreateFromResponseWithFlags( const __CFAllocator *a1, __CFHTTPMessage *a2, __CFUUID *a3, char a4)
{
  return _CFHTTPAuthenticationCreateFromResponseInternal(a1, a2, 0LL, 1, 0LL, 0LL, 0LL, a3, a4, v5);
}

CFDictionaryRef _CFHTTPAuthenticationApplyHeaderToRequest( _CFHTTPAuthentication *a1, __CFHTTPMessage *a2, const void *a3)
{
  if (a1) {
    int v6 = (CFDictionaryRef *)((char *)a1 + 16);
  }
  else {
    int v6 = 0LL;
  }
  return HTTPAuthentication::applyHeaderToRequest(v6, a2, a3);
}

uint64_t _CFHTTPAuthenticationDisassociateConnection(uint64_t a1, const void *a2)
{
  if (a1) {
    uint64_t v4 = a1 + 16;
  }
  else {
    uint64_t v4 = 0LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v4 + 152), a2);
  return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
}

uint64_t _CFHTTPAuthenticationSetPreferredScheme(uint64_t a1, const void *a2)
{
  if (a1) {
    uint64_t v4 = a1 + 16;
  }
  else {
    uint64_t v4 = 0LL;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
  unsigned __int8 v5 = *(const __CFDictionary **)(v4 + 144);
  if (v5 && (unsigned int Value = CFDictionaryGetValue(v5, a2)) != 0LL)
  {
    CFTypeRef v7 = CFRetain(Value);
    unint64_t v8 = *(const void **)(v4 + 136);
    *(void *)(v4 + 136) = v7;
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v9 = 1LL;
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
  return v9;
}

BOOL _CFHTTPAuthenticationRequiresPersistentConnection(CFHTTPAuthenticationRef auth)
{
  __int128 v2 = (__CFString *)CFHTTPAuthenticationCopyMethod(auth);
  if (!v2) {
    return 0LL;
  }
  BOOL v4 = v2 == @"Negotiate" || v2 == @"NTLM";
  CFRelease(v2);
  return v4;
}

CFStringRef CFHTTPAuthenticationCopyRealm(CFHTTPAuthenticationRef auth)
{
  if (auth) {
    __int128 v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    __int128 v2 = 0LL;
  }
  return (CFStringRef)HTTPAuthentication::copyRealm(v2);
}

CFArrayRef CFHTTPAuthenticationCopyDomains(CFHTTPAuthenticationRef auth)
{
  if (auth) {
    __int128 v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    __int128 v2 = 0LL;
  }
  return (CFArrayRef)HTTPAuthentication::lockAndCopyProperty(v2, @"Domain");
}

CFStringRef CFHTTPAuthenticationCopyMethod(CFHTTPAuthenticationRef auth)
{
  if (auth) {
    __int128 v2 = (CFHTTPAuthenticationRef)((char *)auth + 16);
  }
  else {
    __int128 v2 = 0LL;
  }
  return HTTPAuthentication::lockAndCopyProperty(v2, @"kCFHTTPAuthenticationPropertyMethod");
}

Boolean CFHTTPAuthenticationRequiresUserNameAndPassword(CFHTTPAuthenticationRef auth)
{
  return 1;
}

BOOL _CFHTTPAuthenticationPasswordInClear(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = a1 + 16;
  }
  else {
    uint64_t v2 = 0LL;
  }
  unsigned __int8 v3 = (pthread_mutex_t *)(v2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 16));
  Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked( (HTTPAuthentication *)v2,  @"kCFHTTPAuthenticationPropertyMethod");
  pthread_mutex_unlock(v3);
  BOOL result = 1;
  if (Property_Locked)
  {
    BOOL v5 = Property_Locked == @"Digest" || Property_Locked == @"Negotiate";
    if (v5 || Property_Locked == @"NTLM") {
      return 0;
    }
  }

  return result;
}

BOOL _CFHTTPAuthenticationConnectionAuthenticated(_CFHTTPAuthentication *a1, const void *a2)
{
  unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)a1 + 21), a2);
  if (!Value) {
    goto LABEL_6;
  }
  BOOL v5 = Value;
  Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked( (_CFHTTPAuthentication *)((char *)a1 + 16),  @"kCFHTTPAuthenticationPropertyMethod");
  if (Property_Locked == @"NTLM")
  {
    if (v5[2]) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }

  if (Property_Locked == @"Negotiate")
  {
    if (!v5[2]) {
      goto LABEL_12;
    }
LABEL_10:
    if (v5[1])
    {
      BOOL v7 = *v5 == 0LL;
      goto LABEL_13;
    }

_CFHTTPAuthentication *_CFHTTPMessageCanRetry(__CFHTTPMessage *a1)
{
  BOOL v2 = CFHTTPMessageGetResponseStatusCode(a1) == 407;
  BOOL result = (_CFHTTPAuthentication *)_CFHTTPMessageGetAuthentication(a1, v2);
  if (result) {
    return (_CFHTTPAuthentication *)CFHTTPAuthenticationIsValid(result, 0LL);
  }
  return result;
}

Boolean CFHTTPMessageAddAuthentication( CFHTTPMessageRef request, CFHTTPMessageRef authenticationFailureResponse, CFStringRef username, CFStringRef password, CFStringRef authenticationScheme, Boolean forProxy)
{
  int v6 = (const __CFString *)forProxy;
  Boolean v10 = (char *)authenticationFailureResponse;
  keys[2] = *(void **)MEMORY[0x1895F89C0];
  if (!authenticationFailureResponse
    || (BOOL v12 = CFGetAllocator(authenticationFailureResponse),
        (Boolean v10 = (char *)_CFHTTPAuthenticationCreateFromResponseInternal( v12,  (CFHTTPMessageRef)v10,  authenticationScheme,  1,  0LL,  0LL,  0LL,  0LL,  0,  v27)) == 0LL))
  {
    int v15 = 0;
    if (!authenticationScheme) {
      goto LABEL_38;
    }
    goto LABEL_9;
  }

  pthread_mutex_lock((pthread_mutex_t *)(v10 + 32));
  if (!authenticationScheme)
  {
    Property_Locked = (__CFString *)HTTPAuthentication::getProperty_Locked( (HTTPAuthentication *)(v10 + 16),  @"kCFHTTPAuthenticationPropertyMethod");
    if (Property_Locked != @"NTLM")
    {
      authenticationScheme = Property_Locked;
      goto LABEL_37;
    }

    authenticationScheme = @"Digest";
    unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)v10 + 20), @"Digest");
    if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication == -1)
    {
      if (!Value)
      {
LABEL_32:
        authenticationScheme = (CFStringRef)gConstantCFStringValueTable;
        unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)v10 + 20), gConstantCFStringValueTable);
        if (!Value)
        {
LABEL_40:
          Boolean v14 = 0;
          goto LABEL_41;
        }

        if (HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication != -1)
        {
          int v26 = Value;
          dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7883);
          unsigned int Value = v26;
        }
      }
    }

    else
    {
      uint64_t v25 = Value;
      dispatch_once(&HTTPAuthentication::Class(void)::sOnce_HTTPAuthentication, &__block_literal_global_7883);
      unsigned int Value = v25;
      if (!v25) {
        goto LABEL_32;
      }
    }

    unint64_t v23 = (const void *)*((void *)v10 + 19);
    *((void *)v10 + 19) = Value;
    if (v23) {
      CFRelease(v23);
    }
LABEL_37:
    int v15 = 1;
    if (!authenticationScheme)
    {
LABEL_38:
      Boolean v14 = 0;
      if (!v15) {
        return v14;
      }
      goto LABEL_41;
    }

unsigned __int8 *_CFHTTPAuthenticationIsFirstNTLMTransaction(_CFHTTPAuthentication *a1, void *key)
{
  BOOL result = 0LL;
  if (a1 && key)
  {
    BOOL result = (unsigned __int8 *)*((void *)a1 + 21);
    if (result)
    {
      BOOL result = (unsigned __int8 *)CFDictionaryGetValue((CFDictionaryRef)result, key);
      if (result) {
        return (unsigned __int8 *)result[24];
      }
    }
  }

  return result;
}

void _CFHTTPAuthenticationApplyProxyAuthorizationToRequest( __CFHTTPMessage *a1, const void *a2, void *a3, const void *a4, const void *a5, uint64_t a6)
{
  uint64_t v102 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  Boolean v10 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)CFStreamError buf = 138413314;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = a2;
    *(_WORD *)&buf[22] = 2112;
    uint64_t v94 = a3;
    *(_WORD *)uint64_t v95 = 2112;
    *(void *)&v95[2] = a4;
    *(_WORD *)&v95[10] = 2048;
    *(void *)&v95[12] = a5;
    _os_log_debug_impl( &dword_18298D000,  v10,  OS_LOG_TYPE_DEBUG,  "Applying proxy auth: response=%@, proxyURL=%@, request=%@, credentials=%@, handle=%p",  buf,  0x34u);
  }

  uint64_t v11 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"%p", a5);
  std::string::size_type v13 = (std::__shared_weak_count *)operator new(0x20uLL);
  v13->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  v13->__vftable = (std::__shared_weak_count_vtbl *)off_189C17020;
  v13->__shared_weak_owners_ = 0LL;
  v13[1].__vftable = (std::__shared_weak_count_vtbl *)v11;
  if (a1 && a2 && a3)
  {
    error.CFIndex domain = 0LL;
    *(void *)&error.CFStreamError error = 0LL;
    _CFHTTPMessageSetResponseProxyURL((uint64_t)a1, a2);
    CFTypeRef cf = a4;
    int v15 = (const __CFURL *)_CFHTTPAuthenticationCreateFromResponseInternal(0LL, a1, 0LL, 1, 0LL, 0LL, 0LL, 0LL, 0, v69);
    std::string::size_type v16 = (std::__shared_weak_count *)operator new(0x20uLL);
    key = (HTTPProxyAuthentication *)v11;
    v16->__shared_owners_ = 0LL;
    CFIndex v17 = (unint64_t *)&v16->__shared_owners_;
    v16->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DBF8;
    v16->__shared_weak_owners_ = 0LL;
    v16[1].__vftable = (std::__shared_weak_count_vtbl *)v15;
    proxyProtectionSpaceFromAuthentication((_CFHTTPAuthentication *)&v91, v15, (const __CFURL *)a2);
    uint64_t v74 = (__CFHTTPMessage *)a3;
    uint64_t v71 = a2;
    if (v15) {
      uint64_t v18 = (const __CFDictionary **)((char *)v15 + 16);
    }
    else {
      uint64_t v18 = 0LL;
    }
    if (!HTTPAuthentication::isConnectionBasedAuth((HTTPAuthentication *)v18))
    {
      uint64_t v21 = a6;
      uint64_t v22 = (__CFHTTPMessage *)a3;
      BOOL v23 = a3[12] != 0LL;
      goto LABEL_62;
    }

    os_unfair_lock_lock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
    uint64_t v75 = v16;
    if (CFDictionaryGetValue( *(CFDictionaryRef *)(HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache + 8),  v11))
    {
      unsigned int Value = CFDictionaryGetValue( *(CFDictionaryRef *)(HTTPProxyAuthentication::GetProxyAuthCache(void)::ProxyAuthCache + 8),  v11);
      Boolean v20 = (std::__shared_weak_count_vtbl *)CFRetain(Value);
    }

    else
    {
      Boolean v20 = 0LL;
    }

    unint64_t v24 = (std::__shared_weak_count *)operator new(0x20uLL);
    v24->__shared_owners_ = 0LL;
    uint64_t v25 = (unint64_t *)&v24->__shared_owners_;
    v24->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DBF8;
    v24->__shared_weak_owners_ = 0LL;
    v24[1].__vftable = v20;
    os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
    if (v20)
    {
      do
        unint64_t v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
      do
        unint64_t v27 = __ldaxr(v17);
      while (__stlxr(v27 - 1, v17));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
        std::__shared_weak_count::__release_weak(v75);
      }

      uint64_t v75 = v24;
    }

    else
    {
      unsigned int v37 = HTTPAuthentication::isKerberosThePreferredAuthScheme(v18[17]);
      uint64_t v22 = v74;
      if (!v37)
      {
        HTTPProxyAuthentication::SetCachedProxyAuth((HTTPProxyAuthentication *)v11, (const __CFString *)v15, v38);
        BOOL v23 = 0;
        char v36 = 1;
        goto LABEL_58;
      }

      if (!v15)
      {
        p_on_zero_shared = 0LL;
        Boolean v20 = 0LL;
LABEL_35:
        HTTPAuthentication::updateFromResponse((HTTPAuthentication *)p_on_zero_shared, a1, a5);
        pthread_mutex_lock((pthread_mutex_t *)(p_on_zero_shared + 2));
        __uint64_t v30 = p_on_zero_shared[11];
        unint64_t v29 = p_on_zero_shared[12];
        pthread_mutex_unlock((pthread_mutex_t *)(p_on_zero_shared + 2));
        if ((_DWORD)v29)
        {
          if (v30 == (void (__cdecl *)(std::__shared_count *__hidden))4 && (_DWORD)v29 == -1001)
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
            }
            unint64_t v31 = (os_log_s *)CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)CFStreamError buf = 134217984;
              *(void *)&uint8_t buf[4] = a5;
              _os_log_impl( &dword_18298D000,  v31,  OS_LOG_TYPE_INFO,  "Proxy credentials had a bad username/password, trying again handle %p",  buf,  0xCu);
            }
          }

          int v15 = (const __CFURL *)_CFHTTPAuthenticationCreateFromResponseInternal( 0LL,  a1,  0LL,  1,  0LL,  0LL,  0LL,  0LL,  0,  v70);
          uint64_t v33 = (std::__shared_weak_count *)operator new(0x20uLL);
          v33->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DBF8;
          v33->__shared_owners_ = 0LL;
          uint64_t v34 = (unint64_t *)&v75->__shared_owners_;
          v33->__shared_weak_owners_ = 0LL;
          v33[1].__vftable = (std::__shared_weak_count_vtbl *)v15;
          do
            unint64_t v35 = __ldaxr(v34);
          while (__stlxr(v35 - 1, v34));
          if (!v35)
          {
            ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
            std::__shared_weak_count::__release_weak(v75);
          }

          HTTPProxyAuthentication::SetCachedProxyAuth(key, (const __CFString *)v15, v32);
          BOOL v23 = 1;
          uint64_t v75 = v33;
          char v36 = 1;
          uint64_t v22 = v74;
        }

        else
        {
          HTTPAuthentication::applyHeaderToRequest((CFDictionaryRef *)p_on_zero_shared, v74, a5);
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          unint64_t v39 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)CFStreamError buf = 134217984;
            *(void *)&uint8_t buf[4] = a5;
            _os_log_debug_impl( &dword_18298D000,  v39,  OS_LOG_TYPE_DEBUG,  "applied header to request for handle %p",  buf,  0xCu);
          }

          (*(void (**)(uint64_t, __CFHTTPMessage *, void (__cdecl *)(std::__shared_count *__hidden), void (__cdecl *)(std::__shared_count *__hidden)))(a6 + 16))( a6,  v74,  v30,  v29);
          BOOL v23 = 0;
          char v36 = 0;
          int v15 = (const __CFURL *)v20;
          uint64_t v22 = v74;
        }

        do
LABEL_58:
          unint64_t v40 = __ldaxr(v25);
        while (__stlxr(v40 - 1, v25));
        if (!v40)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }

        std::string::size_type v16 = v75;
        uint64_t v21 = a6;
        if ((v36 & 1) == 0) {
          goto LABEL_100;
        }
LABEL_62:
        uint64_t v83 = 0LL;
        unint64_t v84 = &v83;
        uint64_t v85 = 0x4012000000LL;
        uint64_t v86 = __Block_byref_object_copy__8014;
        uint64_t v87 = __Block_byref_object_dispose__8015;
        uint64_t v88 = &unk_182CE6F99;
        if (cf) {
          CFTypeRef v41 = CFRetain(cf);
        }
        else {
          CFTypeRef v41 = 0LL;
        }
        CFTypeRef v89 = v41;
        unint64_t v42 = (AuthBrokerAgentClient *)operator new(0x20uLL);
        *(void *)unint64_t v42 = off_189C0DBC0;
        *((void *)v42 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
        *((void *)v42 + 2) = 0LL;
        *((void *)v42 + 3) = v41;
        unint64_t v90 = (std::__shared_weak_count *)v42;
        if (v15)
        {
          if (!cf)
          {
            if (AuthBrokerAgentClient::AuthBrokerIsAvailable(v42))
            {
              CFTypeRef v43 = v91;
              if (v91)
              {
                if (CFNLog::onceToken != -1) {
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
                }
                unint64_t v44 = (os_log_s *)CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)CFStreamError buf = 138412290;
                  *(void *)&uint8_t buf[4] = key;
                  _os_log_debug_impl( &dword_18298D000,  v44,  OS_LOG_TYPE_DEBUG,  "Proxy credentials not present, querying AuthBrokerAgent with uuid %@",  buf,  0xCu);
                }

                os_unfair_lock_lock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
                if (HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken != -1) {
                  dispatch_once( &HTTPProxyAuthentication::GetProxyCredCache(void)::onceToken,  &__block_literal_global_67_8024);
                }
                uint64_t v45 = key;
                int v76 = v16;
                uint64_t v46 = (NetworkProxyCredential *)CFDictionaryGetValue( *(CFDictionaryRef *)(HTTPProxyAuthentication::GetProxyCredCache(void)::ProxyCredCache + 8),  v43);
                os_unfair_lock_unlock((os_unfair_lock_t)&HTTPProxyAuthentication::ProxyAuthCacheLock);
                uint64_t v47 = MEMORY[0x186E12804](0LL, 80LL, 0LL);
                *(_OWORD *)(v47 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = 0u;
                *(_OWORD *)(v47 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
                *(_OWORD *)(v47 + CFRetain((char *)this - 16) = 0u;
                *(_OWORD *)(v47 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
                *(_OWORD *)uint64_t v47 = 0u;
                NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements( (NetworkProxyAuthorizationElements *)v47,  0LL,  v46,  v43,  0LL,  key);
                uint64_t v48 = MEMORY[0x1895F87A8];
                v79[0] = MEMORY[0x1895F87A8];
                v79[1] = 3221225472LL;
                CFIndex v80 = ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorEU13block_pointerFvP22NetworkProxyCredentialP33NetworkProxyAuthorizationElementsU13block_pointerFvSE_EE_block_invoke;
                unint64_t v81 = &__block_descriptor_40_e5_v8__0l;
                uint64_t v82 = v47;
                if (v23)
                {
                  if (CFNLog::onceToken != -1) {
                    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
                  }
                  uint64_t v49 = (os_log_s *)CFNLog::logger;
                  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
                  {
                    *(_DWORD *)CFStreamError buf = 134217984;
                    *(void *)&uint8_t buf[4] = a5;
                    _os_log_impl( &dword_18298D000,  v49,  OS_LOG_TYPE_INFO,  "Setting proxy creds to unviable handle %p",  buf,  0xCu);
                  }

                  HTTPProxyAuthentication::SetCachedProxyCred(v43, 0LL);
                  uint64_t v45 = key;
                  uint64_t v50 = *(void *)(v47 + 40);
                  uint64_t v46 = 0LL;
                  if (v50) {
                    *(_DWORD *)(v50 + 40) = 2;
                  }
                }

                *(void *)CFStreamError buf = v48;
                *(void *)&uint8_t buf[8] = 3321888768LL;
                *(void *)&uint8_t buf[16] = ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorEU13block_pointerFvP22NetworkProxyCredentialP33NetworkProxyAuthorizationElementsU13block_pointerFvSE_EE_block_invoke_57;
                uint64_t v94 = &unk_189C0DB20;
                *(void *)&v95[16] = v45;
                unint64_t v96 = v13;
                do
                  unint64_t v60 = __ldxr(p_shared_owners);
                while (__stxr(v60 + 1, p_shared_owners));
                std::string::size_type v16 = v76;
                uint64_t v97 = v15;
                uint64_t v98 = v76;
                uint64_t v61 = (unint64_t *)&v76->__shared_owners_;
                do
                  unint64_t v62 = __ldxr(v61);
                while (__stxr(v62 + 1, v61));
                uint64_t v99 = v71;
                uint64_t v100 = v74;
                uint64_t v101 = a5;
                *(void *)uint64_t v95 = v21;
                *(void *)&v95[8] = &v83;
                ___ZN18HTTPAuthentication32applyProxyAuthorizationToRequestEP15__CFHTTPMessagePK7__CFURLS1_PK14__CFDictionaryPKvU13block_pointerFvS1_13CFStreamErrorE_block_invoke( (uint64_t)v46,  v47,  (void (**)(void, void))buf);
                uint64_t v63 = v98;
                if (v98)
                {
                  uint64_t v64 = (unint64_t *)&v98->__shared_owners_;
                  do
                    unint64_t v65 = __ldaxr(v64);
                  while (__stlxr(v65 - 1, v64));
                  if (!v65)
                  {
                    ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
                    std::__shared_weak_count::__release_weak(v63);
                  }
                }

                unint64_t v66 = v96;
                if (v96)
                {
                  unint64_t v67 = (unint64_t *)&v96->__shared_owners_;
                  do
                    unint64_t v68 = __ldaxr(v67);
                  while (__stlxr(v68 - 1, v67));
                  if (!v68)
                  {
                    ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
                    std::__shared_weak_count::__release_weak(v66);
                  }
                }

                v80((uint64_t)v79);
                goto LABEL_95;
              }
            }
          }

          if (CFHTTPMessageApplyCredentialDictionary(v22, v15, (CFDictionaryRef)v84[6], &error))
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
            }
            uint64_t v51 = (os_log_s *)CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)CFStreamError buf = 138412546;
              *(void *)&uint8_t buf[4] = v22;
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = a5;
              _os_log_debug_impl( &dword_18298D000,  v51,  OS_LOG_TYPE_DEBUG,  "Applied proxy credentials dictionary to request %@ handle %p",  buf,  0x16u);
            }

            _CFHTTPAuthenticationApplyHeaderToRequest(v15, v22, a5);
          }

          CFIndex domain = error.domain;
        }

        else
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          uint64_t v53 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)CFStreamError buf = 134217984;
            *(void *)&uint8_t buf[4] = a5;
            _os_log_error_impl( &dword_18298D000,  v53,  OS_LOG_TYPE_ERROR,  "Failed to create proxy auth from response handle %p",  buf,  0xCu);
          }

          CFIndex domain = 4LL;
          error.CFIndex domain = 4LL;
          error.CFStreamError error = -1000;
        }

        (*(void (**)(uint64_t, __CFHTTPMessage *, CFIndex, void))(v21 + 16))( v21,  v22,  domain,  *(void *)&error.error);
LABEL_95:
        _Block_object_dispose(&v83, 8);
        uint64_t v54 = v90;
        if (v90)
        {
          uint64_t v55 = (unint64_t *)&v90->__shared_owners_;
          do
            unint64_t v56 = __ldaxr(v55);
          while (__stlxr(v56 - 1, v55));
          if (!v56)
          {
            ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
            std::__shared_weak_count::__release_weak(v54);
          }
        }

void sub_182A4A17C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void (*a19)(char *), uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, std::__shared_weak_count *a29, CFTypeRef cf, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42)
{
  uint64_t v45 = a29;
  if (a29)
  {
    p_shared_owners = (unint64_t *)&a29->__shared_owners_;
    do
      unint64_t v47 = __ldaxr(p_shared_owners);
    while (__stlxr(v47 - 1, p_shared_owners));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  uint64_t v48 = (unint64_t *)&a14->__shared_owners_;
  do
    unint64_t v49 = __ldaxr(v48);
  while (__stlxr(v49 - 1, v48));
  if (!v49)
  {
    ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
    std::__shared_weak_count::__release_weak(a14);
  }

  do
    unint64_t v50 = __ldaxr(v42);
  while (__stlxr(v50 - 1, v42));
  if (!v50)
  {
    ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
    std::__shared_weak_count::__release_weak(v43);
  }

  _Unwind_Resume(a1);
}

CFStringRef _CFHTTPAuthenticationCreateNTLMHeaderForRequest(uint64_t a1, int a2, void *key)
{
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0LL;
  }
  unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 152), key);
  return HTTPAuthentication::createNTLMHeaderForRequest_Mac(v5, Value, key);
}

CFStringRef _CFHTTPAuthenticationCreateNegotiateHeaderForRequest(uint64_t a1, int a2, void *key)
{
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0LL;
  }
  CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 152), key);
  return HTTPAuthentication::createNegotiateHeaderForRequest_Mac(v5);
}

uint64_t _CFHTTPAuthenticationGetSchemesDict(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 144);
}

CFArrayRef _CFHTTPAuthenticationCopySortedAuthSchemes(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = (HTTPAuthentication *)(a1 + 16);
  }
  else {
    uint64_t v2 = 0LL;
  }
  unsigned __int8 v3 = (const __CFArray *)HTTPAuthentication::copyServerSupportedSchemes(v2);
  if (!v3) {
    return 0LL;
  }
  BOOL v4 = v3;
  CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v3);
  v7.CFIndex length = CFArrayGetCount(MutableCopy);
  v7.CFIndex location = 0LL;
  CFArraySortValues(MutableCopy, v7, (CFComparatorFunction)sortArrayBySecurityStrength, 0LL);
  CFRelease(v4);
  return MutableCopy;
}

void sub_182A4A55C(_Unwind_Exception *a1)
{
}

uint64_t _CFHTTPAuthenticationGetPATSchemes(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(void *)(v2 + 232);
}

void _CFHTTPAuthenticationGetPATAuthHeaders( uint64_t a1, const __CFArray *a2, const __CFData *a3, uint64_t a4, const __CFURL *a5, const __CFURL *a6, void *a7, int a8, char a9, char a10, void *a11, uint64_t a12)
{
  v23[0] = MEMORY[0x1895F87A8];
  v23[1] = 3221225472LL;
  v23[2] = ___CFHTTPAuthenticationGetPATAuthHeaders_block_invoke;
  v23[3] = &unk_189C04050;
  v23[4] = a12;
  SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs(&v24, v23);
  PrivateAccessTokens::getPATAuthHeaders(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, &v24);
  unint64_t v19 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

void sub_182A4A6DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void *SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs( void *a1, const void *a2)
{
  BOOL v4 = operator new(0x18uLL);
  v4[1] = BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial;
  v4[2] = 0LL;
  void *v4 = _Block_copy(a2);
  *a1 = v4;
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = off_189C0CEC0;
  v5[1] = 0LL;
  void v5[2] = 0LL;
  v5[3] = v4;
  a1[1] = v5;
  if (!a2)
  {
    v4[1] = BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_reseted;
    v4[2] = 0LL;
  }

  return a1;
}

void sub_182A4A77C(_Unwind_Exception *a1)
{
}

uint64_t BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_normal;
  a1[2] = 0LL;
  return (*(uint64_t (**)(void))(*a1 + 16LL))();
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFDictionary const*,__CFError *> *,SmartBlockWithArgs<__CFDictionary const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<__CFDictionary const*,__CFError *>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFDictionary const*,__CFError *> *,SmartBlockWithArgs<__CFDictionary const*,__CFError *>::Deleter,std::allocator<BlockHolderVar<__CFDictionary const*,__CFError *>>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1LL | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial
    && v5 != 0)
  {
    CFRange v7 = (void *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0) {
      (*(void (**)(void *, void, void))(*v7
    }
                                                       + BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial))( v7,  0LL,  0LL);
    else {
      ((void (*)(void *, void, void))BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_initial)( v7,  0LL,  0LL);
    }
  }

  _Block_release(*(const void **)v1);
  operator delete((void *)v1);
}

uint64_t BlockHolderVar<__CFDictionary const*,__CFError *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16LL))();
}

uint64_t _CFHTTPAuthenticationCheckOriginAllowedAsThirdParty(double a1)
{
  double Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(a1);
  return [*(id *)(v2 + 2656) checkOriginAllowedAsThirdParty:Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher];
}

uint64_t _CFHTTPAuthenticationUsingAppSSO()
{
  return 0LL;
}

uint64_t _CFHTTPAuthenticationAppSSOIsPerformDefaultHandlingError()
{
  return 0LL;
}

uint64_t _CFHTTPAuthenticationAppSSOShouldManageURL()
{
  return 0LL;
}

void _CFHTTPAuthenticationGetAuthHeadersFromAppSSO( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  CFErrorRef v8 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x189604DB0], @"kCFErrorDomainCFNetwork", -1000LL, 0LL);
  (*(void (**)(uint64_t, void, CFErrorRef))(a7 + 16))(a7, 0LL, v8);
  if (v8) {
    CFRelease(v8);
  }
}

void sub_182A4A8F8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CFHTTPAuthenticationFailedToGetKerberosTicket(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(unsigned __int8 *)(v2 + 224);
}

BOOL _CFHTTPAuthenticationCanRecoverFromKerberosFailure( KerberosAccountBroker *a1, const __CFData *a2, const __CFString *a3)
{
  return KerberosAccountBroker::getKerberosAccountBrokerForApplication(a1, a2, a3) != 0;
}

void _CFHTTPAuthenticationAskAccountsForCreds( uint64_t a1, const void *a2, KerberosAccountBroker *this, __CFData *a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  KerberosAccountBrokerForApplication = (void *)KerberosAccountBroker::getKerberosAccountBrokerForApplication( this,  a4,  (const __CFString *)this);
  if (KerberosAccountBrokerForApplication)
  {
    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 3221225472LL;
    void v17[2] = ___CFHTTPAuthenticationAskAccountsForCreds_block_invoke;
    void v17[3] = &unk_189C04078;
    v17[6] = a6;
    v17[7] = a7;
    uint8_t v17[8] = a2;
    v17[9] = this;
    v17[10] = a4;
    v17[4] = a8;
    v17[5] = a1;
    KerberosAccountBroker::getKerberosCredentialForURL(KerberosAccountBrokerForApplication, a5, a2, (uint64_t)v17);
  }

  else
  {
    (*(void (**)(uint64_t, void, void))(a8 + 16))(a8, 0LL, 0LL);
  }

void _CFHTTPAuthenticationClearAccountRefreshState( const __CFURL *a1, KerberosAccountBroker *this, __CFData *a3)
{
  KerberosAccountBrokerForApplication = (dispatch_queue_s **)KerberosAccountBroker::getKerberosAccountBrokerForApplication( this,  a3,  (const __CFString *)a3);
  if (KerberosAccountBrokerForApplication) {
    KerberosAccountBroker::clearAccountRefreshState(KerberosAccountBrokerForApplication, a1);
  }
}

BOOL _CFHTTPAuthenticationIsSecondNTLMTransaction(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = (HTTPAuthentication *)(a1 + 16);
  }
  else {
    uint64_t v2 = 0LL;
  }
  return HTTPAuthentication::isSecondNTLMTransaction(v2);
}

uint64_t _CFHTTPAuthenticationFetchProxyCredentialFromAuthBroker( AuthBrokerAgentClient *a1, const void *a2, const void *a3, uint64_t a4)
{
  CFErrorRef v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (a1)
  {
    uint64_t v9 = MEMORY[0x186E12804](*MEMORY[0x189604DB0], 56LL, 0LL);
    *(_OWORD *)uint64_t v9 = 0u;
    *(_OWORD *)(v9 + CFRetain((char *)this - 16) = 0u;
    *(_OWORD *)(v9 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
    *(void *)(v9 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = 0LL;
    NetworkProxyCredential::NetworkProxyCredential((NetworkProxyCredential *)v9, v8, a1);
    *(_DWORD *)(v10 + 40) = 2;
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  BOOL v12 = (NetworkProxyAuthorizationElements *)MEMORY[0x186E12804](v8, 80LL, 0LL);
  *(_OWORD *)BOOL v12 = 0u;
  *((_OWORD *)v12 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  *((_OWORD *)v12 + 2) = 0u;
  *((_OWORD *)v12 + 3) = 0u;
  *((_OWORD *)v12 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements( v12,  v8,  (NetworkProxyCredential *)v9,  a2,  0LL,  a3);
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 3221225472LL;
  void v16[2] = ___CFHTTPAuthenticationFetchProxyCredentialFromAuthBroker_block_invoke;
  v16[3] = &unk_189C040A0;
  v16[4] = a4;
  SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs(&v17, v16);
  AuthBrokerAgentClient::FetchProxyCredentials((uint64_t)v12, &v17);
  std::string::size_type v13 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  uint64_t result = (*(uint64_t (**)(NetworkProxyAuthorizationElements *))(*(void *)v12 + 48LL))(v12);
  if (v9) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48LL))(v9);
  }
  return result;
}

void sub_182A4AEC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs(void *a1, const void *a2)
{
  BOOL v4 = operator new(0x18uLL);
  v4[1] = BlockHolderVar<NetworkProxyCredential *>::invoke_initial;
  v4[2] = 0LL;
  void *v4 = _Block_copy(a2);
  *a1 = v4;
  int v5 = operator new(0x20uLL);
  void *v5 = off_189C0DC70;
  v5[1] = 0LL;
  void v5[2] = 0LL;
  v5[3] = v4;
  a1[1] = v5;
  if (!a2)
  {
    v4[1] = BlockHolderVar<NetworkProxyCredential *>::invoke_reseted;
    v4[2] = 0LL;
  }

  return a1;
}

void sub_182A4AF6C(_Unwind_Exception *a1)
{
}

uint64_t BlockHolderVar<NetworkProxyCredential *>::invoke_initial(void *a1)
{
  a1[1] = BlockHolderVar<NetworkProxyCredential *>::invoke_normal;
  a1[2] = 0LL;
  return (*(uint64_t (**)(void))(*a1 + 16LL))();
}

void std::__shared_ptr_pointer<BlockHolderVar<NetworkProxyCredential *> *,SmartBlockWithArgs<NetworkProxyCredential *>::Deleter,std::allocator<BlockHolderVar<NetworkProxyCredential *>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<NetworkProxyCredential *> *,SmartBlockWithArgs<NetworkProxyCredential *>::Deleter,std::allocator<BlockHolderVar<NetworkProxyCredential *>>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  unint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  if (v2) {
    BOOL v4 = (*(void *)(v1 + 16) & 1LL | v3) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  if ((uint64_t (*)(void *))v3 == BlockHolderVar<NetworkProxyCredential *>::invoke_initial && v5 != 0)
  {
    CFRange v7 = (void *)(v1 + (v2 >> 1));
    if ((v2 & 1) != 0) {
      (*(void (**)(void *, void))(*v7
    }
                                               + BlockHolderVar<NetworkProxyCredential *>::invoke_initial))( v7,  0LL);
    else {
      ((void (*)(void *, void))BlockHolderVar<NetworkProxyCredential *>::invoke_initial)(v7, 0LL);
    }
  }

  _Block_release(*(const void **)v1);
  operator delete((void *)v1);
}

uint64_t BlockHolderVar<NetworkProxyCredential *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16LL))();
}

uint64_t SyncClient::SyncClient( uint64_t a1, const __CFAllocator *a2, void *a3, dispatch_object_t object, const void *a5)
{
  *(void *)a1 = off_189C06BF8;
  *(void *)(a1 + _Block_object_dispose((const void *)(v53 - 256), 8) = a2;
  *(_DWORD *)(a1 + CFRetain((char *)this - 16) = 1;
  if (((a1 + 16) & 3) != 0) {
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  }
  *(void *)a1 = off_189C040F8;
  *(void *)(a1 + 56) = object;
  dispatch_retain(object);
  *(void *)(a1 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = _Block_copy(a5);
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = CFDataCreateMutable(a2, 0LL);
  v14[0] = 1LL;
  v14[1] = a1;
  void v14[2] = CFAllocatedReferenceCountedObject::_retainable_instance_retain;
  v14[3] = CFAllocatedReferenceCountedObject::_retainable_instance_release;
  void v14[4] = CFAllocatedReferenceCountedObject::_retainable_copyDescription;
  v14[5] = 0LL;
  v14[6] = SyncClient::synchClientDidReceiveResponse;
  v14[7] = SyncClient::synchClientDidReceiveData;
  v14[8] = 0LL;
  v14[9] = SyncClient::synchClientDidFinishLoading;
  v14[11] = 0LL;
  v14[12] = 0LL;
  v14[10] = SyncClient::synchClientDidFail;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = (void *)MEMORY[0x186E1578C]();
  uint64_t v11 = CFURLConnectionCreateWithProperties(v9, a3, v14, 0LL);
  objc_autoreleasePoolPop(v10);
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v11;
  dispatch_queue_t v12 = dispatch_queue_create("com.apple.CFURLConnectionSynchronous", 0LL);
  CFURLConnectionSetDelegateDispatchQueue(*(void *)(a1 + 24), (uint64_t)v12);
  dispatch_release(v12);
  return a1;
}

void SyncClient::synchClientDidReceiveResponse( SyncClient *this, _CFURLConnection *a2, _CFURLResponse *a3, const void *a4)
{
  if (*((void *)a3 + 4)) {
    SyncClient::cleanup((SyncClient *)a3);
  }
  else {
    *((void *)a3 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a2;
  }
}

void SyncClient::synchClientDidReceiveData( SyncClient *this, CFDataRef theData, const __CFData *a3, uint64_t a4, const void *a5)
{
  int v6 = *(__CFData **)(a4 + 48);
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  CFDataAppendBytes(v6, BytePtr, Length);
}

void SyncClient::synchClientDidFinishLoading(SyncClient *this, _CFURLConnection *a2, const void *a3)
{
}

void SyncClient::synchClientDidFail(SyncClient *this, CFTypeRef cf, __CFError *a3, const void *a4)
{
  if (!*((void *)a3 + 5))
  {
    int v6 = (const void *)*((void *)a3 + 6);
    if (v6) {
      CFRelease(v6);
    }
    *((void *)a3 + 6) = 0LL;
    if (cf) {
      CFTypeRef v7 = CFRetain(cf);
    }
    else {
      CFTypeRef v7 = 0LL;
    }
    *((void *)a3 + 5) = v7;
    SyncClient::cleanup(a3);
  }

void SyncClient::cleanup(SyncClient *this)
{
  if (!*((void *)this + 5))
  {
    unint64_t v3 = (void *)*((void *)this + 4);
    if (v3)
    {
      BOOL v4 = *(const __CFURL **)([v3 _inner] + 8);
      if (v4)
      {
        int v5 = CFURLCopyScheme(v4);
        if (v5)
        {
          int v6 = v5;
          if (CFStringCompare(v5, @"http", 0LL) == kCFCompareEqualTo
            || CFStringCompare(v6, (CFStringRef)&unk_18C5B2B50, 0LL) == kCFCompareEqualTo)
          {
            uint64_t v7 = *(void *)([*((id *)this + 4) _inner] + 88);
            CFErrorRef v8 = v7 ? (__CFHTTPMessage *)(v7 - 16) : 0LL;
            if (v7 && (CFHTTPMessageGetResponseStatusCode(v8) == 401 || CFHTTPMessageGetResponseStatusCode(v8) == 407))
            {
              id v9 = *((id *)this + 4);
              CFRelease(*((CFTypeRef *)this + 4));
              *((void *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
              CFErrorRef CFError = __cfnCreateCFError( *((CFAllocatorRef *)this + 1),  @"kCFErrorDomainCFNetwork",  -1012LL,  v10,  v11,  v12,  v13,  v14,  0LL);
              *((void *)this + 5) = CFError;
              if (CFError)
              {
                std::string::size_type v16 = CFErrorCopyUserInfo(CFError);
                if (v16)
                {
                  uint64_t v17 = v16;
                  uint64_t v18 = (const __CFAllocator *)*MEMORY[0x189604DB0];
                  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v16);
                  CFRelease(v17);
                  if (MutableCopy)
                  {
                    CFDictionarySetValue(MutableCopy, @"_kCFURLErrorAuthFailedResponseKey", v9);
                    Domain = CFErrorGetDomain(*((CFErrorRef *)this + 5));
                    CFIndex Code = CFErrorGetCode(*((CFErrorRef *)this + 5));
                    CFErrorRef v22 = CFErrorCreate(v18, Domain, Code, MutableCopy);
                    CFRelease(MutableCopy);
                    BOOL v23 = (const void *)*((void *)this + 5);
                    if (v23) {
                      CFRelease(v23);
                    }
                    if (v22)
                    {
                      *((void *)this + 5) = CFRetain(v22);
                      CFRelease(v22);
                    }

                    else
                    {
                      *((void *)this + 5) = 0LL;
                    }
                  }
                }
              }
            }
          }

          CFRelease(v6);
        }
      }
    }
  }

  uint64_t v2 = (dispatch_queue_s *)*((void *)this + 7);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN10SyncClient7cleanupEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
}

uint64_t ___ZN10SyncClient7cleanupEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  (*(void (**)(void))(v1[8] + 16LL))();
  return (*(uint64_t (**)(void *))(*v1 + 48LL))(v1);
}

void SyncClient::~SyncClient(SyncClient *this)
{
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  *(void *)this = off_189C040F8;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }

  unint64_t v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
  BOOL v4 = (const void *)*((void *)this + 6);
  if (v4) {
    CFRelease(v4);
  }
  dispatch_release(*((dispatch_object_t *)this + 7));
  _Block_release(*((const void **)this + 8));
}

uint64_t SyncClient::equals(SyncClient *this, const CFAllocatedReferenceCountedObject *a2)
{
  return 0LL;
}

uint64_t CFURLConnectionSendSynchronousRequest(void *a1, void *a2, void *a3, double a4)
{
  CFErrorRef v8 = CFGetAllocator(a1);
  id v9 = (void *)[a1 mutableCopy];
  if (*(double *)([v9 _inner] + 24) >= a4)
  {
    uint64_t v10 = [v9 _inner];
    *(_WORD *)(v10 + 64) |= 0x800u;
    *(double *)(v10 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a4;
  }

  uint64_t v11 = dispatch_semaphore_create(0LL);
  dispatch_queue_t v12 = dispatch_queue_create("com.apple.CFURLConnectionSynchronous", 0LL);
  uint64_t v33 = 0LL;
  uint64_t v34 = &v33;
  uint64_t v35 = 0x2020000000LL;
  uint64_t v36 = 0LL;
  uint64_t v29 = 0LL;
  __uint64_t v30 = &v29;
  uint64_t v31 = 0x2020000000LL;
  uint64_t v32 = 0LL;
  uint64_t v25 = 0LL;
  unint64_t v26 = &v25;
  uint64_t v27 = 0x2020000000LL;
  uint64_t v28 = 0LL;
  uint64_t v13 = MEMORY[0x186E12804](v8, 72LL, 0LL);
  *(_OWORD *)(v13 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(_OWORD *)(v13 + 4_Block_object_dispose((const void *)(v53 - 256), 8) = 0u;
  *(_OWORD *)uint64_t v13 = 0u;
  *(_OWORD *)(v13 + CFRetain((char *)this - 16) = 0u;
  *(void *)(v13 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 3221225472LL;
  void v24[2] = __CFURLConnectionSendSynchronousRequest_block_invoke;
  v24[3] = &unk_189C040C8;
  v24[6] = &v29;
  v24[7] = &v25;
  v24[4] = v11;
  v24[5] = &v33;
  SyncClient::SyncClient(v13, v8, v9, v12, v24);
  CFURLConnectionStart(*(void *)(v13 + 24));
  dispatch_semaphore_wait(v11, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v11);
  dispatch_release(v12);
  (*(void (**)(uint64_t))(*(void *)v13 + 48LL))(v13);
  if (v34[3] || v26[3])
  {
    if (!v9) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  CFErrorRef CFError = __cfnCreateCFError(v8, @"kCFErrorDomainCFNetwork", -1001LL, v14, v15, v16, v17, v18, 0LL);
  v26[3] = (uint64_t)CFError;
  if (v9) {
LABEL_6:
  }
    CFRelease(v9);
LABEL_7:
  unint64_t v19 = (void *)v30[3];
  if (a2) {
    *a2 = v19;
  }
  else {

  }
  Boolean v20 = (const void *)v26[3];
  if (a3)
  {
    *a3 = v20;
  }

  else if (v20)
  {
    CFRelease(v20);
  }

  uint64_t v21 = v34[3];
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  return v21;
}

void sub_182A4B7B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

uint64_t __CFURLConnectionSendSynchronousRequest_block_invoke( uint64_t a1, CFTypeRef cf, void *a3, const void *a4)
{
  if (cf) {
    CFTypeRef v7 = CFRetain(cf);
  }
  else {
    CFTypeRef v7 = 0LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v7;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = a3;
  if (a4) {
    CFTypeRef v8 = CFRetain(a4);
  }
  else {
    CFTypeRef v8 = 0LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = v8;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t stringToServiceType(uint64_t result)
{
  if (result)
  {
    int ExactString = _findExactString((CFStringRef)result, 2u);
    if (ExactString <= 180604075)
    {
      if (ExactString <= 177638502)
      {
        if (ExactString == 175426624) {
          return 8LL;
        }
        if (ExactString == 176467028) {
          return 3LL;
        }
      }

      else
      {
        switch(ExactString)
        {
          case 177638503:
            return 5LL;
          case 178588802:
            return 11LL;
          case 179645591:
            return 10LL;
        }
      }
    }

    else if (ExactString > 183766244)
    {
      switch(ExactString)
      {
        case 185855239:
          return 1LL;
        case 184814838:
          return 4LL;
        case 183766245:
          return 2LL;
      }
    }

    else
    {
      switch(ExactString)
      {
        case 180604076:
          return 7LL;
        case 181726396:
          return 9LL;
        case 182791376:
          return 6LL;
      }
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

uint64_t serviceTypeToString(int a1)
{
  switch(a1)
  {
    case 1:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoIP;
      goto LABEL_14;
    case 2:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVideo;
      goto LABEL_14;
    case 3:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeBackground;
      goto LABEL_14;
    case 4:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoice;
      goto LABEL_14;
    case 5:
      uint64_t v1 = &kCFStreamNetworkServiceTypeBackgroundSystemInitiated;
      goto LABEL_14;
    case 6:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveData;
      goto LABEL_14;
    case 7:
      uint64_t v1 = &kCFStreamNetworkServiceTypeOAM;
      goto LABEL_14;
    case 8:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeAVStreaming;
      goto LABEL_14;
    case 9:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveAV;
      goto LABEL_14;
    case 10:
      uint64_t v1 = &kCFStreamNetworkServiceTypeNetworkControl;
      goto LABEL_14;
    case 11:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeCallSignaling;
LABEL_14:
      uint64_t result = *v1;
      break;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

void addProhibitedNetworkType(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = nw_parameters_copy_prohibited_interface_types();
  if (v3)
  {
    xpc_object_t v4 = (xpc_object_t)v3;
    uint64_t v7 = 0LL;
    CFTypeRef v8 = &v7;
    uint64_t v9 = 0x2020000000LL;
    char v10 = 0;
  }

  else
  {
    xpc_object_t v4 = xpc_array_create(0LL, 0LL);
    uint64_t v7 = 0LL;
    CFTypeRef v8 = &v7;
    uint64_t v9 = 0x2020000000LL;
    char v10 = 0;
    if (!v4) {
      goto LABEL_7;
    }
  }

  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___Z24addProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke;
  v5[3] = &unk_189C04138;
  unsigned int v6 = a2;
  v5[4] = &v7;
  xpc_array_apply(v4, v5);
  if (!*((_BYTE *)v8 + 24))
  {
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, a2);
    nw_parameters_set_prohibited_interface_types();
  }

  xpc_release(v4);
LABEL_7:
  _Block_object_dispose(&v7, 8);
}

void sub_182A4BB78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t ___Z24addProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  if (MEMORY[0x186E16728](a3) != MEMORY[0x1895F92F0]) {
    return 1LL;
  }
  uint64_t value = xpc_uint64_get_value(a3);
  uint64_t result = 1LL;
  if (value == *(_DWORD *)(a1 + 40))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return result;
}

void removeProhibitedNetworkType(uint64_t a1, int a2)
{
  uint64_t v3 = nw_parameters_copy_prohibited_interface_types();
  if (v3)
  {
    xpc_object_t v4 = (void *)v3;
    xpc_object_t v5 = xpc_array_create(0LL, 0LL);
    if (v5)
    {
      xpc_object_t v6 = v5;
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 3221225472LL;
      v7[2] = ___Z27removeProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke;
      v7[3] = &unk_189C04160;
      int v8 = a2;
      v7[4] = v5;
      xpc_array_apply(v4, v7);
      xpc_release(v4);
      nw_parameters_set_prohibited_interface_types();
      xpc_object_t v4 = v6;
    }

    xpc_release(v4);
  }

uint64_t ___Z27removeProhibitedNetworkTypePU27objcproto16OS_nw_parameters8NSObject19nw_interface_type_t_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  return 1LL;
}

void addProhibitedNetworkSubtype(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = nw_parameters_copy_prohibited_interface_subtypes();
  if (v3)
  {
    xpc_object_t v4 = (xpc_object_t)v3;
    uint64_t v7 = 0LL;
    int v8 = &v7;
    uint64_t v9 = 0x2020000000LL;
    char v10 = 0;
  }

  else
  {
    xpc_object_t v4 = xpc_array_create(0LL, 0LL);
    uint64_t v7 = 0LL;
    int v8 = &v7;
    uint64_t v9 = 0x2020000000LL;
    char v10 = 0;
    if (!v4) {
      goto LABEL_7;
    }
  }

  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___Z27addProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke;
  v5[3] = &unk_189C04138;
  unsigned int v6 = a2;
  v5[4] = &v7;
  xpc_array_apply(v4, v5);
  if (!*((_BYTE *)v8 + 24))
  {
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, a2);
    nw_parameters_set_prohibited_interface_subtypes();
  }

  xpc_release(v4);
LABEL_7:
  _Block_object_dispose(&v7, 8);
}

void sub_182A4BE18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t ___Z27addProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  if (MEMORY[0x186E16728](a3) != MEMORY[0x1895F92F0]) {
    return 1LL;
  }
  uint64_t value = xpc_uint64_get_value(a3);
  uint64_t result = 1LL;
  if (value == *(_DWORD *)(a1 + 40))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    return 0LL;
  }

  return result;
}

void removeProhibitedNetworkSubtype(uint64_t a1, int a2)
{
  uint64_t v3 = nw_parameters_copy_prohibited_interface_subtypes();
  if (v3)
  {
    xpc_object_t v4 = (void *)v3;
    xpc_object_t v5 = xpc_array_create(0LL, 0LL);
    if (v5)
    {
      xpc_object_t v6 = v5;
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 3221225472LL;
      v7[2] = ___Z30removeProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke;
      v7[3] = &unk_189C04160;
      int v8 = a2;
      v7[4] = v5;
      xpc_array_apply(v4, v7);
      xpc_release(v4);
      nw_parameters_set_prohibited_interface_subtypes();
      xpc_object_t v4 = v6;
    }

    xpc_release(v4);
  }

uint64_t ___Z30removeProhibitedNetworkSubtypePU27objcproto16OS_nw_parameters8NSObject22nw_interface_subtype_t_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  return 1LL;
}

uint64_t tlsProtocolVersionForSSLProtocol(SSLProtocol a1, int a2)
{
  int v2 = a1 - 1;
  uint64_t result = 769LL;
  switch(v2)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return result;
    case 6:
      uint64_t result = 770LL;
      break;
    case 7:
      uint64_t result = 771LL;
      break;
    case 9:
      uint64_t result = 772LL;
      break;
    default:
      if (a2) {
        uint64_t result = sec_protocol_options_get_default_min_tls_protocol_version();
      }
      else {
        uint64_t result = sec_protocol_options_get_default_max_tls_protocol_version();
      }
      break;
  }

  return result;
}

CFStringRef CFNNSURLRequest::copyDebugDesc(CFNNSURLRequest *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<CFNNSURLRequest@%p>", this);
}

void CFNNSURLRequest::~CFNNSURLRequest(CFNNSURLRequest *this)
{
  *(void *)this = &off_189C04190;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C041D8;
  int v2 = (void *)*((void *)this + 2);
  if (v2) {

  }
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C19AE8;
}

{
  void *v2;
  *(void *)this = &off_189C04190;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C041D8;
  int v2 = (void *)*((void *)this + 2);
  if (v2) {

  }
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C19AE8;
}

void sub_182A4C094(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

void sub_182A4C0E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

void non-virtual thunk to'CFNNSURLRequest::~CFNNSURLRequest(CFNNSURLRequest *this)
{
  *((void *)this - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &off_189C04190;
  *(void *)this = &unk_189C041D8;
  int v2 = (void *)*((void *)this + 1);
  if (v2) {

  }
  *(void *)this = off_189C19AE8;
}

{
  void *v2;
  *((void *)this - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &off_189C04190;
  *(void *)this = &unk_189C041D8;
  int v2 = (void *)*((void *)this + 1);
  if (v2) {

  }
  *(void *)this = off_189C19AE8;
}

void sub_182A4C140(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  _Unwind_Resume(a1);
}

void sub_182A4C198(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  _Unwind_Resume(a1);
}

void ___ZN20URLDataDecoderHolder5ClassEv_block_invoke()
{
  uint64_t v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "CFURLDataDecoder");
  URLDataDecoderHolder::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182A4C1E0(_Unwind_Exception *a1)
{
}

CFStringRef BrotliDataDecoderHolder::copyDebugDesc(BrotliDataDecoderHolder *this)
{
  int v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0LL, @"<BrotliDecoder@%p>", this);
}

void BrotliDataDecoderHolder::~BrotliDataDecoderHolder(BrotliDataDecoderHolder *this)
{
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C13480;
  if (*((_BYTE *)this + 56)) {
    compression_stream_destroy((compression_stream *)((char *)this + 16));
  }
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C134B8;
}

{
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C13480;
  if (*((_BYTE *)this + 56)) {
    compression_stream_destroy((compression_stream *)((char *)this + 16));
  }
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C134B8;
}

void sub_182A4C27C(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C134B8;
  _Unwind_Resume(a1);
}

void sub_182A4C2D0(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C134B8;
  _Unwind_Resume(a1);
}

uint64_t BrotliDataDecoderHolder::decoder(BrotliDataDecoderHolder *this)
{
  return (uint64_t)this + 8;
}

void non-virtual thunk to'BrotliDataDecoderHolder::~BrotliDataDecoderHolder(BrotliDataDecoderHolder *this)
{
  *(void *)this = off_189C13480;
  if (*((_BYTE *)this + 48)) {
    compression_stream_destroy((compression_stream *)((char *)this + 8));
  }
  *(void *)this = off_189C134B8;
}

{
  *(void *)this = off_189C13480;
  if (*((_BYTE *)this + 48)) {
    compression_stream_destroy((compression_stream *)((char *)this + 8));
  }
  *(void *)this = off_189C134B8;
}

void sub_182A4C32C(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

void sub_182A4C380(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

uint64_t BrotliDataDecoder::isInitialized(BrotliDataDecoder *this)
{
  return *((unsigned __int8 *)this + 48);
}

CFStringRef DeflateDataDecoderHolder::copyDebugDesc(DeflateDataDecoderHolder *this)
{
  int v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0LL, @"<GZipDecoder@%p>", this);
}

void DeflateDataDecoderHolder::~DeflateDataDecoderHolder(DeflateDataDecoderHolder *this)
{
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C04770;
  if (*((_BYTE *)this + 128)) {
    inflateEnd((z_streamp)((char *)this + 16));
  }
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C134B8;
}

{
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C04770;
  if (*((_BYTE *)this + 128)) {
    inflateEnd((z_streamp)((char *)this + 16));
  }
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C134B8;
}

void sub_182A4C420(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C134B8;
  _Unwind_Resume(a1);
}

void sub_182A4C474(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C134B8;
  _Unwind_Resume(a1);
}

uint64_t DeflateDataDecoderHolder::decoder(DeflateDataDecoderHolder *this)
{
  return (uint64_t)this + 8;
}

void non-virtual thunk to'DeflateDataDecoderHolder::~DeflateDataDecoderHolder( DeflateDataDecoderHolder *this)
{
  *(void *)this = off_189C04770;
  if (*((_BYTE *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  *(void *)this = off_189C134B8;
}

{
  *(void *)this = off_189C04770;
  if (*((_BYTE *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  *(void *)this = off_189C134B8;
}

void sub_182A4C4D0(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

void sub_182A4C524(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

uint64_t DeflateDataDecoder::isInitialized(DeflateDataDecoder *this)
{
  return *((unsigned __int8 *)this + 120);
}

CFStringRef GZIPDataDecoderHolder::copyDebugDesc(GZIPDataDecoderHolder *this)
{
  int v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0LL, @"<GZipDecoder@%p>", this);
}

void sub_182A4C5C0(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C134B8;
  _Unwind_Resume(a1);
}

void non-virtual thunk to'GZIPDataDecoderHolder::~GZIPDataDecoderHolder(GZIPDataDecoderHolder *this)
{
  *(void *)this = off_189C047A8;
  if (*((_BYTE *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  *(void *)this = off_189C134B8;
}

{
  *(void *)this = off_189C047A8;
  if (*((_BYTE *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  *(void *)this = off_189C134B8;
}

void sub_182A4C614(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

void sub_182A4C668(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

_OWORD *CFURLDataDecoderCreateWithResponse(const __CFAllocator *a1, _CFURLResponse *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(-[_CFURLResponse _inner](a2, "_inner") + 88);
  if (!v3) {
    return 0LL;
  }
  xpc_object_t v4 = CFHTTPMessageCopyHeaderFieldValue((CFHTTPMessageRef)(v3 - 16), (CFStringRef)&unk_18C5AEE48);
  if (!v4) {
    return 0LL;
  }
  xpc_object_t v5 = v4;
  unsigned __int8 v6 = determineHTTPEncodingFromString(v4);
  uint64_t v7 = CFURLDataDecoderCreateWithContentEncoding(a1, v6);
  CFRelease(v5);
  return v7;
}

void ___ZN25DownloadDataDecoderHolder5ClassEv_block_invoke()
{
  uint64_t v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "CFURLDownloadDataDecoder");
  DownloadDataDecoderHolder::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182A4C72C(_Unwind_Exception *a1)
{
}

CFStringRef DownloadDataDecoderHolder::copyDebugDesc(DownloadDataDecoderHolder *this)
{
  int v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0LL, @"<%sDownloadDataDecoder@%p>", *((void *)this + 1), this);
}

void MacBinaryDownloadDataDecoderHolder::~MacBinaryDownloadDataDecoderHolder( MacBinaryDownloadDataDecoderHolder *this)
{
  *((void *)this + 2) = off_189C048B0;
}

{
  *((void *)this + 2) = off_189C048B0;
}

uint64_t MacBinaryDownloadDataDecoderHolder::downloadDecoder(MacBinaryDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

void non-virtual thunk to'MacBinaryDownloadDataDecoderHolder::~MacBinaryDownloadDataDecoderHolder( MacBinaryDownloadDataDecoderHolder *this)
{
  *(void *)this = off_189C048B0;
}

{
  *(void *)this = off_189C048B0;
}

uint64_t MacBinaryDownloadDataDecoder::isInitialized(MacBinaryDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 8);
}

uint64_t MacBinaryDownloadDataDecoder::getMIMEType(MacBinaryDownloadDataDecoder *this)
{
  return 0x18C5B18F0LL;
}

uint64_t MacBinaryDownloadDataDecoder::supportsResume(MacBinaryDownloadDataDecoder *this)
{
  return 1LL;
}

void BinHexDownloadDataDecoderHolder::~BinHexDownloadDataDecoderHolder( BinHexDownloadDataDecoderHolder *this)
{
  *((void *)this + 2) = off_189C048B0;
}

{
  *((void *)this + 2) = off_189C048B0;
}

uint64_t BinHexDownloadDataDecoderHolder::downloadDecoder(BinHexDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

void non-virtual thunk to'BinHexDownloadDataDecoderHolder::~BinHexDownloadDataDecoderHolder( BinHexDownloadDataDecoderHolder *this)
{
  *(void *)this = off_189C048B0;
}

{
  *(void *)this = off_189C048B0;
}

uint64_t BinHexDownloadDataDecoder::isInitialized(BinHexDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 8);
}

uint64_t BinHexDownloadDataDecoder::getMIMEType(BinHexDownloadDataDecoder *this)
{
  return 0x18C5B18B8LL;
}

uint64_t BinHexDownloadDataDecoder::supportsResume(BinHexDownloadDataDecoder *this)
{
  return 1LL;
}

void GZipDownloadDataDecoderHolder::~GZipDownloadDataDecoderHolder(GZipDownloadDataDecoderHolder *this)
{
}

{
  GZipDownloadDataDecoder::~GZipDownloadDataDecoder((GZipDownloadDataDecoderHolder *)((char *)this + 16));
}

uint64_t GZipDownloadDataDecoderHolder::downloadDecoder(GZipDownloadDataDecoderHolder *this)
{
  return (uint64_t)this + 16;
}

uint64_t GZipDownloadDataDecoder::isInitialized(GZipDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 136);
}

uint64_t GZipDownloadDataDecoder::getMIMEType(GZipDownloadDataDecoder *this)
{
  return 0x18C5B1B90LL;
}

uint64_t DownloadDataDecoder::supportsResume(DownloadDataDecoder *this)
{
  return 0LL;
}

uint64_t DownloadDataDecoder::createResumeInformation(DownloadDataDecoder *this, const __CFAllocator *a2)
{
  return 0LL;
}

uint64_t CFURLDownloadDataDecoderDecodeData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
    dispatch_once( &DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder,  &__block_literal_global_2512);
  }
  if (a1) {
    uint64_t v8 = a1 + 16;
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t v9 = (const void *)(v8 - 16);
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 56LL))(v8);
  CFAllocatorRef v11 = CFGetAllocator(v9);
  return (*(uint64_t (**)(uint64_t, uint64_t, CFAllocatorRef, uint64_t, uint64_t))(*(void *)v10 + 40LL))( v10,  a2,  v11,  a3,  a4);
}

void BinHexDownloadDataDecoder::~BinHexDownloadDataDecoder(BinHexDownloadDataDecoder *this)
{
  *(void *)this = off_189C048B0;
}

BOOL BinHexDownloadDataDecoder::canDecodeHeaderData(BinHexDownloadDataDecoder *this, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  *((void *)this + 7) = BytePtr;
  *((void *)this + _Block_object_dispose(va, 8) = &BytePtr[CFDataGetLength(theData)];
  BinHexDownloadDataDecoder::decodeDownloadHeader(this);
  BOOL result = *((_BYTE *)this + 153) == 0;
  *((_DWORD *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *((_BYTE *)this + 72) = 0;
  *(void *)((char *)this + 36) = 0LL;
  *(void *)((char *)this + 2_Block_object_dispose(va, 8) = 0LL;
  *(void *)((char *)this + 43) = 0LL;
  *(void *)((char *)this + 14_Block_object_dispose(va, 8) = 0LL;
  return result;
}

BOOL BinHexDownloadDataDecoder::decodeData( BinHexDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  *a4 = 0LL;
  *a5 = 0LL;
  BytePtr = CFDataGetBytePtr(theData);
  *((void *)this + 7) = BytePtr;
  *((void *)this + _Block_object_dispose(va, 8) = &BytePtr[CFDataGetLength(theData)];
  if (!*((_BYTE *)this + 152)) {
    BinHexDownloadDataDecoder::decodeDownloadHeader(this);
  }
  *a4 = BinHexDownloadDataDecoder::decodeForkWithData(this, a3, (unsigned int *)this + 10, (unsigned __int8 *)this + 48);
  if (*((_BYTE *)this + 48)) {
    *a5 = BinHexDownloadDataDecoder::decodeForkWithData( this,  a3,  (unsigned int *)this + 11,  (unsigned __int8 *)this + 49);
  }
  return *((_BYTE *)this + 153) == 0;
}

CFStringRef BinHexDownloadDataDecoder::createFilenameWithOriginalFilename( ConstStr255Param pStr, CFAllocatorRef alloc, CFTypeRef cf)
{
  if (pStr[72]) {
    return CFStringCreateWithPascalString(alloc, pStr + 72, 0);
  }
  else {
    return (CFStringRef)CFRetain(cf);
  }
}

uint64_t BinHexDownloadDataDecoder::isFinishedDecoding(BinHexDownloadDataDecoder *this)
{
  return *((unsigned __int8 *)this + 49);
}

__CFDictionary *BinHexDownloadDataDecoder::createFileAttributesDictionary( BinHexDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (!*((_BYTE *)this + 152)) {
    return 0LL;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
    *(void *)bytes = *((void *)this + 17);
    LOWORD(v9) = *((_DWORD *)this + 36);
    CFDataRef v5 = CFDataCreate(allocator, bytes, 32LL);
    if (v5)
    {
      CFDataRef v6 = v5;
      CFDictionaryAddValue(Mutable, @"kCFURLDownloadFinderInfoAttr", v5);
      CFRelease(v6);
    }
  }

  return Mutable;
}

CFDictionaryRef BinHexDownloadDataDecoder::createResumeInformation( BinHexDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  values[10] = *(void **)MEMORY[0x1895F89C0];
  if (!*((_BYTE *)this + 152) || *((_BYTE *)this + 153)) {
    return 0LL;
  }
  __int16 valuePtr = *((_BYTE *)this + 48) != 0;
  CFNumberRef v6 = CFNumberCreate(allocator, kCFNumberSInt16Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 36);
  CFNumberRef v8 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 40);
  CFNumberRef v9 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 44);
  CFNumberRef v10 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 32);
  CFDataRef v11 = CFDataCreate(allocator, (const UInt8 *)this + 20, *((unsigned int *)this + 7));
  CFDataRef v12 = CFDataCreate(allocator, (const UInt8 *)this + 9, *((unsigned int *)this + 4));
  keys[0] = @"NSURLDownloadDecoderMIMEType";
  values[0] = (void *)(*(uint64_t (**)(BinHexDownloadDataDecoder *))(*(void *)this + 24LL))(this);
  values[1] = v6;
  keys[1] = @"NSURLDownloadBinHexDataForkCRCChecked";
  keys[2] = @"NSURLDownloadBinHexCRC";
  values[2] = v7;
  values[3] = v8;
  keys[3] = @"NSURLDownloadBinHexDataForkBytesRemaining";
  keys[4] = @"NSURLDownloadBinHexResourceForkBytesRemaining";
  values[4] = v9;
  values[5] = v10;
  CFNumberRef cf = v10;
  keys[5] = @"NSURLDownloadBinHexDecodedDataOffset";
  keys[6] = @"NSURLDownloadBinHexDecodedData";
  keys[7] = @"NSURLDownloadBinHexEncodedData";
  values[6] = v11;
  values[7] = v12;
  if (*((_BYTE *)this + 50))
  {
    CFDataRef v13 = CFDataCreate(allocator, (const UInt8 *)this + 157, 1LL);
    keys[8] = @"NSURLDownloadBinHexFirstCRCByte";
    values[8] = v13;
    CFIndex v14 = 9LL;
  }

  else
  {
    CFDataRef v13 = 0LL;
    CFIndex v14 = 8LL;
  }

  if (*((_BYTE *)this + 155))
  {
    CFDataRef v15 = CFDataCreate(allocator, (const UInt8 *)this + 156, 1LL);
    keys[v14] = @"NSURLDownloadBinHexRepeatByte";
    values[v14++] = v15;
  }

  else
  {
    CFDataRef v15 = 0LL;
  }

  CFDictionaryRef v3 = CFDictionaryCreate( allocator,  (const void **)keys,  (const void **)values,  v14,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (v6) {
    CFRelease(v6);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v3;
}

uint64_t BinHexDownloadDataDecoder::decodeDownloadHeader(BinHexDownloadDataDecoder *this)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  memset(v16, 0, 19);
  memset(__src, 0, sizeof(__src));
  *(_WORD *)CFIndex v14 = 0;
  xpc_object_t v4 = (char *)this + 56;
  int v2 = (const void *)*((void *)this + 7);
  CFDictionaryRef v3 = (unsigned __int8 *)*((void *)v4 + 1);
  while (1)
  {
    uint64_t result = (uint64_t)memchr(v2, 40, v3 - (_BYTE *)v2);
    *((void *)this + 7) = result;
    if (!result) {
      break;
    }
    uint64_t v6 = result;
    uint64_t result = memcmp((const void *)result, "(This file must be converted with BinHex 4.0)", 0x2DuLL);
    if (!(_DWORD)result)
    {
      CFNumberRef v7 = (unsigned __int8 *)(v6 + 45);
      *((void *)this + 7) = v6 + 45;
      if ((unsigned __int8 *)(v6 + 45) != v3)
      {
        while (1)
        {
          CFNumberRef v8 = v7 + 1;
          *((void *)this + 7) = v7 + 1;
          int v9 = *v7;
          if (v9 != 10 && v9 != 13) {
            break;
          }
          CFNumberRef v7 = v8;
          if (v8 == v3) {
            goto LABEL_27;
          }
        }

        if (v9 == 58)
        {
          uint64_t result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, (unsigned __int8 *)__src, 1u, 0);
          if ((_DWORD)result != 1) {
            *((_BYTE *)this + 153) = 1;
          }
          int v11 = LOBYTE(__src[0]);
          if (LOBYTE(__src[0]) - 64 > 0xFFFFFFC0)
          {
            if (BinHexDownloadDataDecoder::decodeIntoBuffer( this,  (unsigned __int8 *)__src + 1,  LOBYTE(__src[0]),  0) != v11) {
              *((_BYTE *)this + 153) = 1;
            }
            uint64_t result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, v16, 0x13u, 0);
            if ((_DWORD)result != 19) {
              *((_BYTE *)this + 153) = 1;
            }
            if (!v16[0])
            {
              uint64_t result = BinHexDownloadDataDecoder::decodeIntoBuffer(this, v14, 2u, 1);
              if ((_DWORD)result != 2) {
                *((_BYTE *)this + 153) = 1;
              }
              if (*((unsigned __int16 *)this + 18) == bswap32(*(unsigned __int16 *)v14) >> 16)
              {
                uint64_t result = (uint64_t)memcpy((char *)this + 72, __src, LOBYTE(__src[0]) + 1LL);
                unsigned int v12 = bswap32(*(unsigned int *)&v16[5]);
                *((_DWORD *)this + 3os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = bswap32(*(unsigned int *)&v16[1]);
                *((_DWORD *)this + 35) = v12;
                *((_DWORD *)this + 36) = __rev16(*(unsigned __int16 *)&v16[9]);
                unsigned int v13 = bswap32(*(unsigned int *)&v16[15]);
                *((_DWORD *)this + 10) = bswap32(*(unsigned int *)&v16[11]);
                *((_DWORD *)this + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v13;
                *((_DWORD *)this + 9) = 0;
                *((_BYTE *)this + 152) = 1;
                return result;
              }
            }
          }
        }
      }

      break;
    }

    int v2 = (const void *)(v6 + 1);
    *((void *)this + 7) = v6 + 1;
  }

__CFData *BinHexDownloadDataDecoder::decodeForkWithData( BinHexDownloadDataDecoder *this, const __CFAllocator *a2, unsigned int *a3, unsigned __int8 *a4)
{
  uint64_t v4 = MEMORY[0x1895F8858](this);
  CFNumberRef v8 = v7;
  uint64_t v9 = v4;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  unsigned int v10 = *v6;
  if (*v6)
  {
    int v11 = v6;
    unsigned int v12 = v5;
    CFMutableDictionaryRef Mutable = 0LL;
    while (1)
    {
      unsigned int v14 = v10 >= 0x2000 ? 0x2000 : v10;
      unsigned int v15 = BinHexDownloadDataDecoder::decodeIntoBuffer((BinHexDownloadDataDecoder *)v9, bytes, v14, 0);
      if (!v15) {
        break;
      }
      unsigned int v16 = v15;
      if (!Mutable) {
        CFMutableDictionaryRef Mutable = CFDataCreateMutable(v12, 0LL);
      }
      CFDataAppendBytes(Mutable, bytes, v16);
      unsigned int v10 = *v11 - v16;
      BOOL v17 = *v11 == v16;
      *int v11 = v10;
      if (v17) {
        goto LABEL_13;
      }
    }
  }

  else
  {
    CFMutableDictionaryRef Mutable = 0LL;
LABEL_13:
    if (!*v8)
    {
      if (*(_BYTE *)(v9 + 50))
      {
        bytes[0] = *(_BYTE *)(v9 + 157);
        uint64_t v18 = &bytes[1];
        int v19 = 1;
        Boolean v20 = (BinHexDownloadDataDecoder *)v9;
        unsigned int v21 = 1;
      }

      else
      {
        int v19 = 2;
        uint64_t v18 = bytes;
        Boolean v20 = (BinHexDownloadDataDecoder *)v9;
        unsigned int v21 = 2;
      }

      int v22 = BinHexDownloadDataDecoder::decodeIntoBuffer(v20, v18, v21, 1);
      if (v22 == 1 && !*(_BYTE *)(v9 + 50))
      {
        *(_BYTE *)(v9 + 50) = 1;
        *(_BYTE *)(v9 + 157) = bytes[0];
      }

      else
      {
        *CFNumberRef v8 = 1;
        *(_DWORD *)(v9 + 36) = 0;
        *(_BYTE *)(v9 + 50) = 0;
      }
    }
  }

  return Mutable;
}

uint64_t BinHexDownloadDataDecoder::decodeIntoBuffer( BinHexDownloadDataDecoder *this, unsigned __int8 *a2, unsigned int a3, int a4)
{
  if (*((_BYTE *)this + 153)) {
    return 0LL;
  }
  unsigned int v35 = *((_DWORD *)this + 4);
  unsigned int v8 = *((_DWORD *)this + 8);
  unsigned int v38 = *((_DWORD *)this + 7);
  uint64_t v9 = *((unsigned int *)this + 9);
  unsigned int v10 = (unsigned __int8 *)*((void *)this + 7);
  int v33 = (int)a2;
  uint64_t v34 = (unsigned __int8 *)*((void *)this + 8);
  int v11 = *((unsigned __int8 *)this + 155);
  unsigned int v12 = *((_DWORD *)this + 37);
  if (!v12)
  {
    uint64_t v14 = *((unsigned __int8 *)this + 156);
    unsigned int v15 = a2;
LABEL_10:
    unsigned int v36 = (_DWORD)a2 + a3;
    while (v8 != v38)
    {
      unsigned int v17 = v8 + 1;
      uint64_t v18 = *((unsigned __int8 *)this + v8 + 20);
      if ((_DWORD)v18 != 144)
      {
        unsigned int v21 = 1;
        ++v8;
        goto LABEL_19;
      }

      unsigned int v19 = v35;
      if (v17 == v38)
      {
        int v24 = *((unsigned __int8 *)this + 154);
        if (*((_BYTE *)this + 154))
        {
LABEL_44:
          uint64_t result = 0LL;
          *((_BYTE *)this + 153) = 1;
          return result;
        }

uint64_t handleRepeatCount(int a1, unsigned int a2, uint64_t a3, unsigned __int8 *a4, int a5)
{
  if (a1)
  {
    if (a5) {
      unsigned int v5 = 0;
    }
    else {
      unsigned int v5 = a2;
    }
    do
    {
      *a4 = a2;
      int v6 = 8;
      unsigned int v7 = v5;
      do
      {
        int v8 = 2 * a3;
        if ((a3 & 0x8000) != 0) {
          int v8 = (2 * a3) & 0xFFFE ^ 0x1021;
        }
        a3 = v8 ^ (v7 >> 7);
        unsigned int v7 = 2 * (v7 & 0x7F);
        --v6;
      }

      while (v6);
      ++a4;
      --a1;
    }

    while (a1);
  }

  return a3;
}

uint64_t DownloadDataDecoder::isInitialized(DownloadDataDecoder *this)
{
  return 0LL;
}

uint64_t DownloadDataDecoder::canDecodeHeaderData(DownloadDataDecoder *this, const __CFData *a2)
{
  return 0LL;
}

uint64_t DownloadDataDecoder::decodeData( DownloadDataDecoder *this, const __CFData *a2, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  return 0LL;
}

uint64_t DownloadDataDecoder::createFilenameWithOriginalFilename( DownloadDataDecoder *this, const __CFAllocator *a2, const __CFString *a3)
{
  return 0LL;
}

uint64_t DownloadDataDecoder::isFinishedDecoding(DownloadDataDecoder *this)
{
  return 1LL;
}

uint64_t DownloadDataDecoder::createFileAttributesDictionary( DownloadDataDecoder *this, const __CFAllocator *a2)
{
  return 0LL;
}

void sub_182A4D61C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4D770(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4D8D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4D9A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4DBBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4DCD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4DD38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4DE00( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS____NSHTTPAlternativeServicesStorage;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_182A4DF24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id a22)
{
  _Unwind_Resume(a1);
}

void sub_182A4E2B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4E51C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21)
{
  _Unwind_Resume(a1);
}

void sub_182A4E604( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_182A4E6C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4E9AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

void sub_182A4ED6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
  a14(&a12);
  _Unwind_Resume(a1);
}

void sub_182A4F220( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *))
{
  a14(&a12);
  _Unwind_Resume(a1);
}

void sub_182A4F5E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

void sub_182A4F6A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A4F9F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

void sub_182A4FAF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A50304( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void sub_182A50514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A506CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2695(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__2696(uint64_t a1)
{
}

void sub_182A50A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___Z25parseAndStoreAltSvcHeaderP33_NSHTTPAlternativeServicesStorageP8NSStringS2_S2_lPK9__CFArray_block_invoke( uint64_t a1)
{
}

void checkCertAndStore( _NSHTTPAlternativeServicesStorage *a1, _NSHTTPAlternativeServiceEntry *a2, const __CFArray *a3)
{
  unsigned int v5 = a1;
  int v6 = a2;
  -[_NSHTTPAlternativeServiceEntry host](v6, "host");
  unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7)
  {
    -[_NSHTTPAlternativeServiceEntry alternateHost](v6, "alternateHost");
    int v8 = (void *)objc_claimAutoreleasedReturnValue();

    if (v8)
    {
      -[_NSHTTPAlternativeServiceEntry host](v6, "host");
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
      -[_NSHTTPAlternativeServiceEntry alternateHost](v6, "alternateHost");
      unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue();
      if (v9 == v10)
      {
        -[_NSHTTPAlternativeServiceEntry host](v6, "host");
        int v11 = (void *)objc_claimAutoreleasedReturnValue();
        -[_NSHTTPAlternativeServiceEntry alternateHost](v6, "alternateHost");
        unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue();
        char v13 = [v11 isEqualToString:v12];

        if ((v13 & 1) != 0)
        {
LABEL_7:
          -[_NSHTTPAlternativeServicesStorage storeHTTPServiceEntry:](v5, "storeHTTPServiceEntry:", v6);
          goto LABEL_13;
        }
      }

      else
      {
      }

      -[_NSHTTPAlternativeServiceEntry alternateHost](v6, "alternateHost");
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
      char v15 = __NSURLSession_CoalescingHelperIsOnDNSNameList(a3, v14);

      if ((v15 & 1) != 0) {
        goto LABEL_7;
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      int v16 = (os_log_s *)(id)CFNLog::logger;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v17 = 0;
        _os_log_impl( &dword_18298D000,  v16,  OS_LOG_TYPE_DEFAULT,  "Ignoring the alternative service header since it is not covered under the setting origin's certificate",  v17,  2u);
      }
    }
  }

void sub_182A50C80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *trimwhitespace(char *a1)
{
  uint64_t v1 = a1 - 1;
  uint64_t v2 = MEMORY[0x1895F8770];
  do
  {
    uint64_t v3 = v1[1];
    if (v1[1] < 0) {
      int v4 = __maskrune(v3, 0x4000uLL);
    }
    else {
      int v4 = *(_DWORD *)(v2 + 4 * v3 + 60) & 0x4000;
    }
    ++v1;
  }

  while (v4);
  if (*v1)
  {
    unsigned int v5 = &v1[strlen(v1) - 1];
    do
    {
      int v6 = v5;
      if (v5 <= v1) {
        break;
      }
      uint64_t v7 = *v5;
      int v8 = *v5 < 0 ? __maskrune(v7, 0x4000uLL) : *(_DWORD *)(v2 + 4 * v7 + 60) & 0x4000;
      unsigned int v5 = v6 - 1;
    }

    while (v8);
    v6[1] = 0;
  }

  return v1;
}

void DeflateDataDecoder::~DeflateDataDecoder(DeflateDataDecoder *this)
{
  *(void *)this = off_189C04770;
  if (*((_BYTE *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  *(void *)this = off_189C134B8;
}

{
  *(void *)this = off_189C04770;
  if (*((_BYTE *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  operator delete(this);
}

void sub_182A50DC4(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

void sub_182A50E10(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

__CFData *DeflateDataDecoder::decodeData( DeflateDataDecoder *this, const __CFAllocator *a2, const __CFData *a3, unsigned __int8 *a4)
{
  uint64_t v4 = MEMORY[0x1895F8858](this);
  int v6 = v5;
  int v8 = v7;
  uint64_t v9 = v4;
  uint64_t v21 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(v10, 0LL);
  *int v6 = 0;
  if (!Mutable) {
    return Mutable;
  }
  *(void *)(v9 + _Block_object_dispose(va, 8) = CFDataGetBytePtr(v8);
  int Length = CFDataGetLength(v8);
  *(_DWORD *)(v9 + CFRetain((char *)this - 16) = Length;
  if (!Length) {
    return Mutable;
  }
  int v13 = 1;
  while (1)
  {
    while (1)
    {
      *(void *)(v9 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v20;
      *(_DWORD *)(v9 + 40) = 0x4000;
      unsigned int v14 = inflate((z_streamp)(v9 + 8), 0);
      unsigned int v15 = v14;
      int v16 = *(_DWORD *)(v9 + 40);
      if (*(_DWORD *)(v9 + 16)) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v14 == -5;
      }
      if (v17) {
        goto LABEL_17;
      }
      if (v14 > 1) {
        break;
      }
      CFDataAppendBytes(Mutable, v20, 0x4000 - v16);
      if (v15 == 1) {
        return Mutable;
      }
      if (!*(_DWORD *)(v9 + 16)) {
        goto LABEL_17;
      }
    }

    if (v14 != -3 || !v13) {
      goto LABEL_20;
    }
    CFDataSetLength(Mutable, 0LL);
    inflateEnd((z_streamp)(v9 + 8));
    if (inflateInit2_((z_streamp)(v9 + 8), -15, "1.2.12", 112)) {
      break;
    }
    *(void *)(v9 + _Block_object_dispose(va, 8) = CFDataGetBytePtr(v8);
    int v18 = CFDataGetLength(v8);
    int v13 = 0;
    *(_DWORD *)(v9 + CFRetain((char *)this - 16) = v18;
    if (!v18)
    {
LABEL_17:
      if (v16) {
        return Mutable;
      }
    }
  }

  *(_BYTE *)(v9 + 120) = 0;
LABEL_20:
  CFRelease(Mutable);
  return 0LL;
}

void DataDecoder::~DataDecoder(DataDecoder *this)
{
  *(void *)this = off_189C134B8;
}

uint64_t DataDecoder::isInitialized(DataDecoder *this)
{
  return 0LL;
}

uint64_t DataDecoder::decodeData( DataDecoder *this, const __CFAllocator *a2, const __CFData *a3, unsigned __int8 *a4)
{
  *a4 = 0;
  return 0LL;
}

void GZipDataDecoder::~GZipDataDecoder(GZipDataDecoder *this)
{
  *(void *)this = off_189C047A8;
  if (*((_BYTE *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  *(void *)this = off_189C134B8;
}

{
  *(void *)this = off_189C047A8;
  if (*((_BYTE *)this + 120)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  operator delete(this);
}

void sub_182A51048(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

void sub_182A51094(_Unwind_Exception *a1)
{
  void *v1 = off_189C134B8;
  _Unwind_Resume(a1);
}

void GZipDownloadDataDecoder::~GZipDownloadDataDecoder(GZipDownloadDataDecoder *this)
{
}

{
  const void *v2;
  *(void *)this = off_189C047E0;
  if (*((_BYTE *)this + 136)) {
    inflateEnd((z_streamp)((char *)this + 8));
  }
  uint64_t v2 = (const void *)*((void *)this + 15);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)this = off_189C048B0;
}

uint64_t GZipDownloadDataDecoder::canDecodeHeaderData(GZipDownloadDataDecoder *this, const __CFData *a2)
{
  return gzipDecodeHeader(a2, 0LL, 0LL, 0LL, 0LL, &v3);
}

BOOL GZipDownloadDataDecoder::decodeData( GZipDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  int v8 = 0LL;
  LODWORD(v13) = 0;
  *a5 = 0LL;
  if (!*((_BYTE *)this + 137))
  {
    int v9 = gzipDecodeHeader( theData,  (uInt *)&v13,  a3,  (const __CFString **)this + 15,  (unint64_t *)this + 16,  &v12);
    *((_BYTE *)this + 137) = v9;
    if (!v9)
    {
      GzipDecodedData = 0LL;
      goto LABEL_5;
    }

    int v8 = (const __CFData *)v13;
  }

  GzipDecodedData = (const __CFData *)createGzipDecodedData( (z_stream_s *)((char *)this + 8),  (unsigned __int8 *)this + 138,  theData,  v8);
LABEL_5:
  *a4 = GzipDecodedData;
  return GzipDecodedData != 0LL;
}

CFStringRef GZipDownloadDataDecoder::createFilenameWithOriginalFilename( GZipDownloadDataDecoder *this, CFAllocatorRef alloc, const __CFString *a3)
{
  uint64_t v4 = (const __CFString *)*((void *)this + 15);
  if (v4) {
    return CFStringCreateCopy(alloc, v4);
  }
  ExtensionFromFilename = createExtensionFromFilename(a3);
  if (!ExtensionFromFilename) {
    return (CFStringRef)CFRetain(a3);
  }
  int v8 = ExtensionFromFilename;
  if (CFStringCompare(ExtensionFromFilename, @"gz", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v8, @"gzip", 1uLL) == kCFCompareEqualTo)
  {
    CFIndex Length = CFStringGetLength(a3);
    CFIndex v11 = CFStringGetLength(v8);
    if (Length > v11 + 1)
    {
      v18.CFIndex length = Length + ~v11;
      v18.CFIndex location = 0LL;
      int v9 = CFStringCreateWithSubstring(alloc, a3, v18);
      goto LABEL_11;
    }

uint64_t GZipDownloadDataDecoder::isFinishedDecoding(GZipDownloadDataDecoder *this)
{
  else {
    return 1LL;
  }
}

__CFDictionary *GZipDownloadDataDecoder::createFileAttributesDictionary( GZipDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  if (!*((void *)this + 16)) {
    return 0LL;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    CFDateRef v5 = CFDateCreate(allocator, (double)*((unint64_t *)this + 16) - *MEMORY[0x189604DA8]);
    if (v5)
    {
      CFDateRef v6 = v5;
      CFDictionaryAddValue(Mutable, @"kCFURLDownloadFileModDate", v5);
    }

    else
    {
      CFDateRef v6 = Mutable;
      CFMutableDictionaryRef Mutable = 0LL;
    }

    CFRelease(v6);
  }

  return Mutable;
}

void sub_182A51458(_Unwind_Exception *a1)
{
  void *v1 = off_189C048B0;
  _Unwind_Resume(a1);
}

void MacBinaryDownloadDataDecoder::~MacBinaryDownloadDataDecoder(MacBinaryDownloadDataDecoder *this)
{
  *(void *)this = off_189C048B0;
}

BOOL MacBinaryDownloadDataDecoder::canDecodeHeaderData( MacBinaryDownloadDataDecoder *this, CFDataRef theData)
{
  if (CFDataGetLength(theData) < 128) {
    return 0LL;
  }
  BytePtr = CFDataGetBytePtr(theData);
  if (BytePtr[102] != 109 || BytePtr[103] != 66 || BytePtr[104] != 73 || BytePtr[105] != 78)
  {
    uint64_t v4 = 0LL;
    unsigned __int16 v5 = 0;
    do
      unsigned __int16 v5 = gMagic[((unsigned __int16)(v5 ^ (BytePtr[v4++] << 8)) >> 8)] ^ (v5 << 8);
    while ((_DWORD)v4 != 124);
    if ((BytePtr[125] | (BytePtr[124] << 8)) != v5)
    {
      if (!BytePtr[82] && !BytePtr[126] && !BytePtr[127])
      {
        uint64_t v8 = 0LL;
        while (!BytePtr[v8 + 99])
        {
          if (++v8 == 27)
          {
            uint64_t v6 = 0LL;
            int v9 = bswap32(*(_DWORD *)(BytePtr + 83));
            if (v9 < 0x800000)
            {
              int v10 = bswap32(*(_DWORD *)(BytePtr + 87));
              if (v10 < 0x800000) {
                return (v9 | v10) != 0;
              }
            }

            return v6;
          }
        }
      }

      return 0LL;
    }
  }

  return BytePtr[123] < 0x82u;
}

uint64_t MacBinaryDownloadDataDecoder::decodeData( MacBinaryDownloadDataDecoder *this, CFDataRef theData, const __CFAllocator *a3, const __CFData **a4, const __CFData **a5)
{
  v33[1] = *MEMORY[0x1895F89C0];
  *a4 = 0LL;
  *a5 = 0LL;
  CFIndex Length = (const __CFData *)CFDataGetLength(theData);
  signed int v11 = (int)Length;
  if (*((_DWORD *)this + 3))
  {
    unsigned int v12 = *((_DWORD *)this + 20);
    unsigned int v13 = *((_DWORD *)this + 21);
  }

  else
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = (const __CFData *)memcpy((char *)this + 16, BytePtr + 1, BytePtr[1] + 1LL);
    *((_DWORD *)this + 25) = bswap32(*(_DWORD *)(BytePtr + 65));
    *((_DWORD *)this + 26) = bswap32(*(_DWORD *)(BytePtr + 69));
    unsigned int v12 = bswap32(*(_DWORD *)(BytePtr + 83));
    *((_DWORD *)this + 20) = v12;
    unsigned int v13 = bswap32(*(_DWORD *)(BytePtr + 87));
    *((_DWORD *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v13;
    *((_DWORD *)this + 23) = bswap32(*(_DWORD *)(BytePtr + 91));
    *((_DWORD *)this + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = bswap32(*(_DWORD *)(BytePtr + 95));
    __int16 v15 = BytePtr[101] | (BytePtr[73] << 8);
    *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v15;
    UInt8 v16 = BytePtr[107];
    *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v15 & 0xAC4E;
    *((_WORD *)this + 45) = v16 & 4;
    if (BytePtr[102] == 109 && BytePtr[103] == 66 && BytePtr[104] == 73 && BytePtr[105] == 78) {
      *((_WORD *)this + 5os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = BytePtr[106];
    }
  }

  int v17 = v12 + 128;
  int v18 = *((_DWORD *)this + 3);
  if (v12) {
    BOOL v19 = v17 <= v18;
  }
  else {
    BOOL v19 = 1;
  }
  if (v19)
  {
    unsigned int v20 = v13;
  }

  else
  {
    unsigned int v20 = v13;
    if (v18 + v11 >= 129)
    {
      if (v18 >= 128) {
        uint64_t v21 = 0LL;
      }
      else {
        uint64_t v21 = (128 - v18);
      }
      signed int v22 = v17 - v18;
      if (v22 >= v11) {
        signed int v22 = v11;
      }
      int v23 = v22 - v21;
      int v24 = CFDataGetBytePtr(theData);
      CFIndex Length = CFDataCreate(a3, &v24[v21], v23);
      *a4 = Length;
      int v18 = *((_DWORD *)this + 3);
      unsigned int v20 = *((_DWORD *)this + 21);
    }
  }

  if (v20)
  {
    signed int v25 = (v12 + 255) & 0xFFFFFF80;
    if ((int)(v25 + v13) > v18 && v18 + v11 > v25)
    {
      int v27 = (v25 - v18) & ~((v25 - v18) >> 31);
      else {
        unsigned int v28 = v25 + v13 - v18;
      }
      CFIndex v29 = (int)(v28 - v27);
      MEMORY[0x1895F8858](Length);
      unsigned __int8 v31 = (const UInt8 *)v33 - v30;
      v34.CFIndex length = v29;
      CFDataGetBytes(theData, v34, (UInt8 *)v33 - v30);
      *a5 = CFDataCreate(a3, v31, v29);
      int v18 = *((_DWORD *)this + 3);
    }
  }

  *((_DWORD *)this + 3) = v18 + v11;
  return 1LL;
}

CFStringRef MacBinaryDownloadDataDecoder::createFilenameWithOriginalFilename( const unsigned __int8 *pStr, CFAllocatorRef alloc, CFTypeRef cf)
{
  if (pStr[16]) {
    return CFStringCreateWithPascalString(alloc, pStr + 16, *((__int16 *)pStr + 54));
  }
  else {
    return (CFStringRef)CFRetain(cf);
  }
}

BOOL MacBinaryDownloadDataDecoder::isFinishedDecoding(MacBinaryDownloadDataDecoder *this)
{
  return *((_DWORD *)this + 3) >= (int)(((*((_DWORD *)this + 20) + 255) & 0xFFFFFF80) + *((_DWORD *)this + 21));
}

__CFDictionary *MacBinaryDownloadDataDecoder::createFileAttributesDictionary( MacBinaryDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (Mutable)
  {
    uint64_t v15 = 0LL;
    uint64_t v16 = 0LL;
    uint64_t v14 = 0LL;
    *(void *)bytes = *(void *)((char *)this + 100);
    LOWORD(v1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = *((_WORD *)this + 44);
    LOWORD(vCFRetain((char *)this - 16) = *((_WORD *)this + 45);
    CFDataRef v5 = CFDataCreate(allocator, bytes, 32LL);
    if (v5)
    {
      CFDataRef v6 = v5;
      CFDictionaryAddValue(Mutable, @"kCFURLDownloadFinderInfoAttr", v5);
      CFRelease(v6);
    }

    if (convertLocalMacTimeToCFAbsoluteTime(*((_DWORD *)this + 23), &at))
    {
      CFDateRef v7 = CFDateCreate(allocator, at);
      if (v7)
      {
        CFDateRef v8 = v7;
        CFDictionaryAddValue(Mutable, @"kCFURLDownloadFileCreateDate", v7);
        CFRelease(v8);
      }
    }

    if (convertLocalMacTimeToCFAbsoluteTime(*((_DWORD *)this + 24), &at))
    {
      CFDateRef v9 = CFDateCreate(allocator, at);
      if (v9)
      {
        CFDateRef v10 = v9;
        CFDictionaryAddValue(Mutable, @"kCFURLDownloadFileModDate", v9);
        CFRelease(v10);
      }
    }
  }

  return Mutable;
}

CFDictionaryRef MacBinaryDownloadDataDecoder::createResumeInformation( MacBinaryDownloadDataDecoder *this, CFAllocatorRef allocator)
{
  values[4] = *(void **)MEMORY[0x1895F89C0];
  CFNumberRef v4 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 80);
  CFNumberRef v5 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 12);
  CFNumberRef v6 = CFNumberCreate(allocator, kCFNumberSInt32Type, (char *)this + 84);
  CFNumberRef v7 = v6;
  if (v4 && v5 && v6)
  {
    keys[0] = @"NSURLDownloadDecoderMIMEType";
    keys[1] = @"NSURLDownloadMacBinaryDataForkLength";
    keys[2] = @"NSURLDownloadMacBinaryOffset";
    keys[3] = @"NSURLDownloadMacBinaryResourceForkLength";
    values[0] = (void *)(*(uint64_t (**)(MacBinaryDownloadDataDecoder *))(*(void *)this + 24LL))(this);
    values[1] = v4;
    values[2] = v5;
    values[3] = v7;
    CFDictionaryRef v8 = CFDictionaryCreate( allocator,  (const void **)keys,  (const void **)values,  4LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  }

  else
  {
    CFDictionaryRef v8 = 0LL;
    CFDictionaryRef v9 = 0LL;
    if (!v4) {
      goto LABEL_7;
    }
  }

  CFRelease(v4);
  CFDictionaryRef v9 = v8;
LABEL_7:
  if (v5) {
    CFRelease(v5);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v9;
}

CFTimeZoneRef convertLocalMacTimeToCFAbsoluteTime(unsigned int a1, double *a2)
{
  uint64_t result = CFTimeZoneCopySystem();
  if (result)
  {
    CFNumberRef v5 = result;
    CFAbsoluteTime v6 = (double)a1 - *MEMORY[0x189604DA0];
    CFTimeInterval SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(result, v6);
    double v8 = CFTimeZoneGetSecondsFromGMT(v5, v6 - SecondsFromGMT);
    CFRelease(v5);
    *a2 = v6 - v8;
    return (const __CFTimeZone *)1;
  }

  return result;
}

uint64_t _CFNetworkDoesNeedProxy(const __CFString *a1, const __CFArray *a2, const void *a3)
{
  uint64_t v67 = *MEMORY[0x1895F89C0];
  CFNumberRef v4 = (const void *)*MEMORY[0x189604DE0];
  if (a3) {
    CFNumberRef v5 = a3;
  }
  else {
    CFNumberRef v5 = (const void *)*MEMORY[0x189604DE0];
  }
  if (!v5)
  {
    CFNumberRef v7 = (const void *)*MEMORY[0x189604DE8];
    goto LABEL_10;
  }

  CFTypeID v6 = CFGetTypeID(v5);
  if (v6 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)v5, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v7 = (const void *)*MEMORY[0x189604DE8];
    if (!(_DWORD)valuePtr) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }

  CFNumberRef v7 = (const void *)*MEMORY[0x189604DE8];
  if ((const void *)*MEMORY[0x189604DE8] == v5) {
LABEL_10:
  }
    CFNumberRef v4 = v7;
LABEL_11:
  if (CFStringCompare(a1, @"localhost", 1uLL) == kCFCompareEqualTo) {
    return 0LL;
  }
  if (CFStringCompare(a1, @"127.0.0.1", 1uLL) == kCFCompareEqualTo) {
    return 0LL;
  }
  if (CFStringCompare(a1, @"::1", 1uLL) == kCFCompareEqualTo) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(a1);
  if (v4)
  {
    if (CFEqual(v4, v7) && CFStringFind(a1, @".", 0LL).location == -1) {
      return 0LL;
    }
  }

  if (!a2) {
    return 1LL;
  }
  CFIndex Count = CFArrayGetCount(a2);
  if (!Count) {
    return 1LL;
  }
  if (CFStringHasSuffix(a1, @"."))
  {
    CFDictionaryRef v9 = CFGetAllocator(a1);
    CFIndex v10 = CFStringGetLength(a1);
    CFStringRef theString = CFStringCreateMutableCopy(v9, v10, a1);
    CFIndex v11 = CFStringGetLength(a1);
    v68.CFIndex length = CFStringGetLength(@".");
    v68.CFIndex location = v11 - 1;
    CFStringDelete(theString, v68);
    a1 = theString;
  }

  else
  {
    CFStringRef theString = 0LL;
  }

  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, a1, @".");
  uint64_t v15 = ArrayBySeparatingStrings;
  if (!ArrayBySeparatingStrings) {
    goto LABEL_30;
  }
  CFIndex v16 = CFArrayGetCount(ArrayBySeparatingStrings);
  CFIndex v17 = v16;
  if (v16 == 5)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v15, 4LL);
    BOOL v58 = 0;
    if (CFStringGetLength(ValueAtIndex) || Length >= 17)
    {
      uint64_t v18 = 5LL;
      goto LABEL_32;
    }

LABEL_114:
    unint64_t v52 = CFGetAllocator(a1);
    CFAllocatorRef valuePtr = v52;
    uint64_t v64 = 1023LL;
    if (a1)
    {
      uint64_t v53 = _CFStringGetOrCreateCString((uint64_t)v52, a1, v66, &v64, 0x600u);
    }

    else
    {
      v66[0] = 0;
      uint64_t v64 = 0LL;
      uint64_t v53 = v66;
    }

    ptr = v53;
    uint64_t v18 = v17;
    BOOL v58 = inet_pton(2, (const char *)v53, &v62) == 1;
    if (ptr && v66 != ptr) {
      CFAllocatorDeallocate(valuePtr, ptr);
    }
    goto LABEL_32;
  }

  uint64_t v18 = v16;
  if (v16 == 4)
  {
    if (Length > 16)
    {
      BOOL v58 = 0;
      uint64_t v18 = 4LL;
      goto LABEL_32;
    }

    goto LABEL_114;
  }

  if (!v16)
  {
    CFRelease(v15);
    uint64_t v15 = 0LL;
LABEL_30:
    uint64_t v18 = 0LL;
  }

  BOOL v58 = 0;
LABEL_32:
  if (Count >= 1)
  {
    CFIndex v19 = 0LL;
    uint64_t v57 = v18;
    CFIndex idx = v18 - 1;
    while (1)
    {
      unsigned int v20 = (const __CFString *)CFArrayGetValueAtIndex(a2, v19);
      if (CFStringHasSuffix(v20, @"."))
      {
        uint64_t v21 = CFGetAllocator(v20);
        CFIndex v22 = CFStringGetLength(v20);
        CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v21, v22, v20);
        CFIndex v24 = CFStringGetLength(v20);
        v69.CFIndex length = CFStringGetLength(@".");
        v69.CFIndex location = v24 - 1;
        CFStringDelete(MutableCopy, v69);
        unsigned int v20 = MutableCopy;
      }

      else
      {
        CFMutableStringRef MutableCopy = 0LL;
      }

      if (CFStringCompare(a1, v20, 1uLL))
      {
        if (!v58
          || (v70.CFIndex length = CFStringGetLength(v20),
              v70.CFIndex location = 0LL,
              !CFStringFindWithOptions(v20, @"/", v70, 0LL, 0LL)))
        {
          if (v15)
          {
            unint64_t v39 = CFStringCreateArrayBySeparatingStrings(0LL, v20, @".");
            unint64_t v26 = v39;
            if (v39)
            {
              CFIndex v40 = CFArrayGetCount(v39);
              if (v40 >= 2 && v57 >= 1)
              {
                CFIndex v42 = v40 - 1;
                CFIndex v43 = idx;
                while (1)
                {
                  unint64_t v44 = (const __CFString *)CFArrayGetValueAtIndex(v15, v43);
                  uint64_t v45 = (const __CFString *)CFArrayGetValueAtIndex(v26, v42);
                  uint64_t v46 = v45;
                  if (!v42 && !CFStringGetLength(v45)) {
                    uint64_t v46 = @"*";
                  }
                  if (CFStringCompare(v44, v46, 1uLL))
                  {
                    if (CFStringCompare(v46, @"*", 1uLL)) {
                      break;
                    }
                    while (1)
                    {
                      unint64_t v47 = (const __CFString *)CFArrayGetValueAtIndex(v26, v42);
                      uint64_t v48 = v47;
                      if (!v42 && !CFStringGetLength(v47)) {
                        uint64_t v48 = @"*";
                      }
                      if (CFStringCompare(v48, @"*", 1uLL)) {
                        break;
                      }
                      BOOL v49 = v42-- <= 0;
                      if (v49) {
                        goto LABEL_92;
                      }
                    }

                    if (v43 < 0) {
                      break;
                    }
                    while (1)
                    {
                      unint64_t v50 = (const __CFString *)CFArrayGetValueAtIndex(v15, v43);
                      if (CFStringCompare(v48, v50, 1uLL) == kCFCompareEqualTo) {
                        break;
                      }
                      BOOL v49 = v43-- <= 0;
                      if (v49) {
                        goto LABEL_82;
                      }
                    }
                  }

                  else
                  {
                    if (!(v43 | v42))
                    {
LABEL_92:
                      BOOL v12 = 0LL;
                      goto LABEL_83;
                    }

                    --v43;
                    --v42;
                  }

                  BOOL v12 = 1LL;
                  if (v43 < 0 || v42 < 0) {
                    goto LABEL_83;
                  }
                }
              }

LABEL_82:
              BOOL v12 = 1LL;
              goto LABEL_83;
            }
          }

      unint64_t v52 = v97;
      if (v97)
      {
        uint64_t v53 = (unint64_t *)&v97->__shared_owners_;
        do
          uint64_t v54 = __ldaxr(v53);
        while (__stlxr(v54 - 1, v53));
        if (!v54)
        {
          ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
          std::__shared_weak_count::__release_weak(v52);
        }
      }

      return;
  }

void sub_182A52378( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, CFAllocatorRef allocator, uint64_t a21, void *ptr)
{
  if (ptr)
  {
    if (a11 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }

  _Unwind_Resume(exception_object);
}

CFArrayRef CFNetworkCopyProxiesForURL(CFURLRef url, CFDictionaryRef proxySettings)
{
  return (CFArrayRef)__CFNetworkCopyProxiesForURLWithInterface(url, proxySettings, 0LL);
}

CFDictionaryRef CFNetworkCopySystemProxySettings(void)
{
  if (_CFNetworkCopySystemProxySettings::onceToken != -1) {
    dispatch_once(&_CFNetworkCopySystemProxySettings::onceToken, &__block_literal_global_2828);
  }
  pthread_mutex_lock(&__sCFNSystemProxyDictLock);
  if (!__sProxyOverrideDict || (uint64_t v0 = (const __CFDictionary *)CFRetain((CFTypeRef)__sProxyOverrideDict)) == 0LL)
  {
    if (!_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary) {
      goto LABEL_22;
    }
    uint64_t v1 = _CFNetworkCopySystemProxySettings::configWatcher;
    int check = 0;
    if (notify_check(*(_DWORD *)_CFNetworkCopySystemProxySettings::configWatcher, &check)) {
      BOOL v2 = 1;
    }
    else {
      BOOL v2 = check == 0;
    }
    int v3 = !v2;
    uint32_t v4 = notify_check(*(_DWORD *)(v1 + 4), &check);
    if (check) {
      BOOL v5 = v4 == 0;
    }
    else {
      BOOL v5 = 0;
    }
    CFDictionaryRef v6 = (CFDictionaryRef)_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary;
    if (v5 || v3 != 0)
    {
      _CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary = 0LL;
      if (!v6) {
        goto LABEL_22;
      }
      CFRelease(v6);
      CFDictionaryRef v6 = (CFDictionaryRef)_CFNetworkCopySystemProxySettings::__sSCDynamicStoreProxiesDictionary;
    }

    if (v6)
    {
LABEL_23:
      uint64_t v0 = (const __CFDictionary *)CFRetain(v6);
      goto LABEL_25;
    }

void sub_182A52550(_Unwind_Exception *a1)
{
}

uint64_t _CFNetworkSetOverrideSystemProxySettings(const void *a1)
{
  if (a1) {
    CFTypeRef v2 = CFRetain(a1);
  }
  else {
    CFTypeRef v2 = 0LL;
  }
  __sProxyOverrideDict = (uint64_t)v2;
  return pthread_mutex_unlock(&__sCFNSystemProxyDictLock);
}

void sub_182A526F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A528A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_182A52A60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182A52C88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_182A52D30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_182A52EBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id getCookieLogHandle(void)
{
  return (id)cookieLogHandle;
}

void ___Z18getCookieLogHandlev_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.cfnetwork", "cookies");
  uint64_t v1 = (void *)cookieLogHandle;
  cookieLogHandle = (uint64_t)v0;
}

uint64_t CookieParser_lex(CFStringRef *a1, CFAllocatorRef alloc, char **a3)
{
  CFDictionaryRef v6 = (const UInt8 *)*a3;
  *a1 = 0LL;
  while (2)
  {
    switch(*v6)
    {
      case 0u:
        goto LABEL_112;
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xBu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x2Cu:
      case 0x3Bu:
      case 0x3Du:
      case 0x7Fu:
        CFNumberRef v7 = (char *)(v6 + 1);
        uint64_t result = *(char *)v6;
        goto LABEL_229;
      case 9u:
      case 0x20u:
        ++v6;
        continue;
      case 0xAu:
        CFNumberRef v7 = (char *)(v6 + 1);
        uint64_t result = 10LL;
        goto LABEL_229;
      case 0xDu:
        CFNumberRef v7 = (char *)(v6 + 1);
        if (v6[1])
        {
          if (v6[1] != 10 || (int v21 = *((char *)v6 + 2), v6 += 2, v21 >= 1))
          {
            uint64_t result = 13LL;
            goto LABEL_229;
          }
        }

        else
        {
LABEL_111:
          CFDictionaryRef v6 = (const UInt8 *)v7;
        }

LABEL_188:
        CFStringRef v49 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_206:
        *a1 = v49;
        uint64_t result = 262LL;
        goto LABEL_229;
      case 0x44u:
      case 0x64u:
        CFNumberRef v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x6F) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x6D) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x61) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x69) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6E) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 6);
        unsigned int v14 = *((char *)v6 + 6);
        if ((v14 > 0x3D || ((1LL << v14) & 0x28000000FFFFFDFFLL) == 0) && v14 != 127)
        {
          LOBYTE(v12) = v6[6];
          int v13 = 5;
          goto LABEL_84;
        }

LABEL_184:
        CFStringRef v47 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_202:
        *a1 = v47;
        uint64_t result = 263LL;
        goto LABEL_229;
      case 0x45u:
      case 0x65u:
        CFNumberRef v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x78) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x70) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x69) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x72) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 6);
        int v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x73) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 7);
        unsigned int v15 = *((char *)v6 + 7);
        if ((v15 > 0x3D || ((1LL << v15) & 0x28000000FFFFFDFFLL) == 0) && v15 != 127)
        {
          LOBYTE(v12) = v6[7];
          int v13 = 8;
          goto LABEL_84;
        }

          *(_WORD *)&this->fFlags |= 0x1000u;
          if ((v60 & 0x400) == 0)
          {
LABEL_137:
            if ((v60 & 0x1000) == 0) {
              goto LABEL_139;
            }
            goto LABEL_138;
          }

          goto LABEL_185;
        }
      }
    }

    return 0LL;
  }

  int v30 = a3[8];
  if (v30)
  {
    uint64_t v31 = CFGetTypeID(v30);
    if (v31 != CFDictionaryGetTypeID()) {
      return 0LL;
    }
  }

  if ((unint64_t)a2 < 3)
  {
LABEL_73:
    switch(a2)
    {
      case 1LL:
        uint64_t v34 = 0LL;
        if (a4 != 13) {
          goto LABEL_88;
        }
        int v35 = 9LL;
        goto LABEL_78;
      case 2LL:
        if (a4 != 14) {
          goto LABEL_114;
        }
        CFStringRef v46 = 9LL;
        goto LABEL_109;
      case 4LL:
        if (a4 != 16) {
          goto LABEL_114;
        }
        CFStringRef v46 = 11LL;
        goto LABEL_109;
      case 5LL:
        if (a4 != 17) {
          goto LABEL_114;
        }
        CFStringRef v46 = 12LL;
        goto LABEL_109;
      case 6LL:
        if (a4 == 20) {
          goto LABEL_106;
        }
        if (a4 == 19) {
          CFStringRef v46 = 14LL;
        }
        else {
          CFStringRef v46 = 0LL;
        }
        if (a4 != 19) {
          goto LABEL_114;
        }
        goto LABEL_109;
      case 7LL:
        if (a4 != 20) {
          goto LABEL_114;
        }
LABEL_106:
        CFStringRef v46 = 14LL;
        goto LABEL_109;
      case 8LL:
        if (a4 != 21) {
          goto LABEL_114;
        }
        CFStringRef v46 = 15LL;
        goto LABEL_109;
      default:
        CFStringRef v46 = 16LL;
        goto LABEL_109;
    }
  }

  uint64_t result = (uint64_t)a3[9];
  if (!result) {
    return result;
  }
  unsigned int v32 = CFGetTypeID((CFTypeRef)result);
  if (v32 != CFBooleanGetTypeID()) {
    return 0LL;
  }
  if ((unint64_t)a2 < 4)
  {
    if (a4 != 15)
    {
LABEL_114:
      int v35 = 0LL;
      uint64_t v111 = 1;
      goto LABEL_115;
    }

    CFStringRef v46 = 10LL;
LABEL_109:
    CFStringRef v47 = a3[v46];
    if (!v47 || (CFStringRef v48 = CFGetTypeID(v47), v48 == CFArrayGetTypeID()))
    {
      uint64_t result = (uint64_t)a3[v46 + 1];
      if (!result) {
        return result;
      }
      int v35 = v46;
      CFStringRef v49 = CFGetTypeID((CFTypeRef)result);
      if (v49 == CFNumberGetTypeID())
      {
        uint64_t v34 = 1LL;
        goto LABEL_78;
      }
    }

    return 0LL;
  }

  uint64_t result = (uint64_t)a3[10];
  if (result)
  {
    int v33 = CFGetTypeID((CFTypeRef)result);
    if (v33 == CFBooleanGetTypeID()) {
      goto LABEL_73;
    }
    return 0LL;
  }

  return result;
}

LABEL_190:
        CFStringRef v50 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_208:
        *a1 = v50;
        uint64_t result = 269LL;
        goto LABEL_229;
      case 0x48u:
      case 0x68u:
        CFNumberRef v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x74) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x74) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x70) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x6F) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6E) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 6);
        int v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x6C) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 7);
        int v10 = *((char *)v6 + 7);
        if ((v10 | 0x20) != 0x79) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 8);
        unsigned int v16 = *((char *)v6 + 8);
        if ((v16 > 0x3D || ((1LL << v16) & 0x28000000FFFFFDFFLL) == 0) && v16 != 127)
        {
          LOBYTE(v12) = v6[8];
          int v13 = 11;
          goto LABEL_84;
        }

LABEL_180:
        CFStringRef v45 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_198:
        *a1 = v45;
        uint64_t result = 267LL;
        goto LABEL_229;
      case 0x4Du:
      case 0x6Du:
        CFNumberRef v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x61) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x78) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 3);
        int v12 = v6[3];
        if (v12 != 45) {
          goto LABEL_83;
        }
        CFNumberRef v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x61
          || (v7 = (char *)(v6 + 5), int v10 = *((char *)v6 + 5), (v10 | 0x20) != 0x67)
          || (v7 = (char *)(v6 + 6), int v10 = *((char *)v6 + 6), (v10 | 0x20) != 0x65))
        {
LABEL_82:
          LOBYTE(v12) = v10;
LABEL_83:
          int v13 = 1;
          goto LABEL_84;
        }

        CFNumberRef v7 = (char *)(v6 + 7);
        unsigned int v17 = *((char *)v6 + 7);
        if ((v17 > 0x3D || ((1LL << v17) & 0x28000000FFFFFDFFLL) == 0) && v17 != 127)
        {
          LOBYTE(v12) = v6[7];
          int v13 = 9;
          goto LABEL_84;
        }

          *(_WORD *)&this->fFlags |= 0x100u;
          if ((v60 & 0x40) == 0)
          {
LABEL_133:
            if ((v60 & 0x80) == 0) {
              goto LABEL_134;
            }
            goto LABEL_182;
          }

      if (__dst[0].domain) {
        CFRelease((CFTypeRef)__dst[0].domain);
      }
      if (!*(_DWORD *)(v3 + 264)) {
        goto LABEL_183;
      }
      return;
    case 7:
      int v36 = *(_DWORD *)(v1 + 264);
      if (v36)
      {
        int v37 = *(void *)(v1 + 256);
        uint64_t v38 = v36 == 35 && v37 == 1;
        if (!v38 && (v36 != -9803 || v37 != *MEMORY[0x1896051C0]))
        {
          SocketStream::removeSSLHandshake((SocketStream *)v1);
          return;
        }
      }

      unsigned int v39 = *(unsigned int *)(v1 + 248);
      unsigned int v40 = v39 | ((unint64_t)*(unsigned __int16 *)(v1 + 252) << 32);
      if ((v39 & 0x60000000) != 0) {
        return;
      }
      if ((v39 & 0x18000) != 0x8000) {
        goto LABEL_192;
      }
      CFSocketGetNative(*(CFSocketRef *)(v1 + 288));
      uint64_t v41 = (CFNA *)SCNetworkSignatureCopyIdentifierForConnectedSocket();
      if (!v41) {
        goto LABEL_190;
      }
      CFIndex v43 = (const __CFString *)v41;
      CFStringRef v44 = CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore( v41,  (const __CFString *)"TLSFalseStart",  v42);
      if (v44)
      {
        CFStringRef v45 = v44;
        CFStringRef v46 = CFStringCompare(v44, @"TRUE", 0LL);
        CFRelease(v43);
        CFRelease(v45);
        CFStringRef v47 = *(unsigned int *)(v3 + 248);
        CFStringRef v48 = v47 | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
        if (v46 == kCFCompareEqualTo)
        {
          *(_DWORD *)(v3 + 24_Block_object_dispose(va, 8) = v47 | 0x10000;
          *(_WORD *)(v3 + 252) = WORD2(v48);
          SSLSetSessionOption(*(SSLContextRef *)(v3 + 296), kSSLSessionOptionFalseStart, 1u);
          unsigned int v40 = *(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
          goto LABEL_192;
        }
      }

      else
      {
        CFNA::CFNetworkAgentClient::executeLegacyQuery( (CFNA::CFNetworkAgentClient *)CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client,  v43,  2LL);
        CFRelease(v43);
LABEL_190:
        CFStringRef v48 = *(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
      }

      unsigned int v40 = v48 & 0xFFFFFFFFFFFF7FFFLL;
      *(_DWORD *)(v3 + 24_Block_object_dispose(va, 8) = v40;
      *(_WORD *)(v3 + 252) = WORD2(v40);
LABEL_192:
      if ((v40 & 0x80000) != 0) {
        goto LABEL_313;
      }
      uint64_t v125 = *(SSLContext **)(v3 + 296);
      uint64_t v214 = 0LL;
      unint64_t v126 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
      if (SSLGetPeerDomainNameLength(v125, (size_t *)__dst))
      {
        CFIndex v127 = 0LL;
      }

      else
      {
        if (__dst[0].domain >= 7uLL) {
          __int128 v142 = (UInt8 *)MEMORY[0x186E12804](v126);
        }
        else {
          __int128 v142 = buf;
        }
        else {
          CFIndex v127 = CFStringCreateWithBytes(v126, v142, __dst[0].domain, 0x8000100u, 0);
        }
        if (v142 != buf) {
          CFAllocatorDeallocate(v126, v142);
        }
      }

      if (!CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_18C5B2450)
        && !CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_18C5ADEF8))
      {
        goto LABEL_261;
      }

      __dst[0].CFIndex domain = 0LL;
      number.CFIndex domain = 0LL;
      SocketStream::_CreateNameAndPortForCONNECTProxy( *(SocketStream **)(v3 + 336),  (const __CFDictionary *)__dst,  (const __CFString **)&number,  (const __CFNumber **)buf,  v147);
      CFIndex v148 = (const void *)__dst[0].domain;
      std::string v149 = (const void *)number.domain;
      if (__dst[0].domain && number.domain)
      {
        CFNumberGetValue((CFNumberRef)number.domain, kCFNumberSInt32Type, valuePtr);
        if (v127) {
          __int128 v150 = v127;
        }
        else {
          __int128 v150 = @"nulldomain";
        }
        uint64_t v151 = CFGetAllocator((CFTypeRef)(v3 - 16));
        uint64_t v152 = CFStringCreateWithFormat(v151, 0LL, @"{%@:%d}%@", v148, LOWORD(valuePtr[0]), v150);
      }

      else
      {
        uint64_t v152 = 0LL;
        if (!__dst[0].domain) {
          goto LABEL_258;
        }
      }

      CFRelease(v148);
LABEL_258:
      if (v149) {
        CFRelease(v149);
      }
      if (v152) {
        goto LABEL_302;
      }
LABEL_261:
      LODWORD(__dst[0].domain) = 255;
      if (v127) {
        uint64_t v153 = v127;
      }
      else {
        uint64_t v153 = @"nulldomain";
      }
      CFSocketNativeHandle Native = CFSocketGetNative(*(CFSocketRef *)(v3 + 288));
      if (getpeername(Native, (sockaddr *)buf, (socklen_t *)__dst)) {
        goto LABEL_265;
      }
      if (buf[1] == 30)
      {
        BOOL v159 = CFGetAllocator((CFTypeRef)(v3 - 16));
        __int128 v156 = CFStringCreateWithFormat( v159,  0LL,  @"{%8.8x:%8.8x:%8.8x:%8.8x:%d}%@",  *(unsigned int *)&buf[8],  *(unsigned int *)&buf[12],  *(unsigned int *)&buf[16],  *(unsigned int *)&buf[20],  *(unsigned __int16 *)&buf[2],  v153);
      }

      else
      {
        if (buf[1] != 2)
        {
LABEL_265:
          uint64_t v152 = 0LL;
          goto LABEL_302;
        }

        uint64_t v155 = CFGetAllocator((CFTypeRef)(v3 - 16));
        __int128 v156 = CFStringCreateWithFormat( v155,  0LL,  @"{%d.%d.%d.%d:%d}%@",  buf[7],  buf[6],  buf[5],  buf[4],  *(unsigned __int16 *)&buf[2],  v153);
      }

      uint64_t v152 = v156;
LABEL_302:
      if (v152) {
        CFIndex v160 = v152;
      }
      else {
        CFIndex v160 = v127;
      }
      if (v152 && v127) {
        CFRelease(v127);
      }
      if (v160)
      {
        *(void *)CFStreamError buf = v126;
        *(void *)&uint8_t buf[8] = 1023LL;
        *(void *)&uint8_t buf[16] = _CFStringGetOrCreateCString((uint64_t)v126, v160, v213, (uint64_t *)&buf[8], 0x8000100u);
        CFRelease(v160);
        SSLSetPeerID(v125, *(const void **)&buf[16], *(size_t *)&buf[8]);
        if (*(void *)&buf[16])
        {
          if (v213 != *(UInt8 **)&buf[16]) {
            CFAllocatorDeallocate(*(CFAllocatorRef *)buf, *(void **)&buf[16]);
          }
        }
      }

LABEL_192:
        CFStringRef v51 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_210:
        *a1 = v51;
        uint64_t result = 264LL;
        goto LABEL_229;
      case 0x50u:
      case 0x70u:
        CFNumberRef v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x61) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x74) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x68) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 4);
        unsigned int v18 = *((char *)v6 + 4);
        if ((v18 > 0x3D || ((1LL << v18) & 0x28000000FFFFFDFFLL) == 0) && v18 != 127)
        {
          LOBYTE(v12) = v6[4];
          int v13 = 4;
          goto LABEL_84;
        }

LABEL_182:
        CFStringRef v46 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_200:
        *a1 = v46;
        uint64_t result = 265LL;
        goto LABEL_229;
      case 0x53u:
      case 0x73u:
        CFNumberRef v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x63) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x75) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x72) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 6);
        unsigned int v19 = *((char *)v6 + 6);
        if ((v19 > 0x3D || ((1LL << v19) & 0x28000000FFFFFDFFLL) == 0) && v19 != 127)
        {
          LOBYTE(v12) = v6[6];
          int v13 = 6;
          goto LABEL_84;
        }

          *(_WORD *)&this->fFlags |= 0x400u;
          if ((v60 & 0x100) == 0)
          {
LABEL_135:
            if ((v60 & 0x200) == 0) {
              goto LABEL_136;
            }
            goto LABEL_184;
          }

LABEL_186:
        CFStringRef v48 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_204:
        *a1 = v48;
        uint64_t result = 266LL;
        goto LABEL_229;
      case 0x56u:
      case 0x76u:
        CFNumberRef v7 = (char *)(v6 + 1);
        int v10 = *((char *)v6 + 1);
        if ((v10 | 0x20) != 0x65) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 2);
        int v10 = *((char *)v6 + 2);
        if ((v10 | 0x20) != 0x72) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 3);
        int v10 = *((char *)v6 + 3);
        if ((v10 | 0x20) != 0x73) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 4);
        int v10 = *((char *)v6 + 4);
        if ((v10 | 0x20) != 0x69) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 5);
        int v10 = *((char *)v6 + 5);
        if ((v10 | 0x20) != 0x6F) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 6);
        int v10 = *((char *)v6 + 6);
        if ((v10 | 0x20) != 0x6E) {
          goto LABEL_82;
        }
        CFNumberRef v7 = (char *)(v6 + 7);
        unsigned int v20 = *((char *)v6 + 7);
        if (v20 <= 0x3D && ((1LL << v20) & 0x28000000FFFFFDFFLL) != 0 || v20 == 127)
        {
LABEL_194:
          CFStringRef v52 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
LABEL_212:
          *a1 = v52;
          uint64_t result = 268LL;
        }

        else
        {
          LOBYTE(v12) = v6[7];
          int v13 = 10;
LABEL_84:
          uint64_t result = *(char *)v6;
          while (1)
          {
            int v54 = (char)v12;
            if ((char)v12 <= 122)
            {
              CFIndex v43 = v7;
              CFDictionaryRef v9 = v7;
              switch(v54)
              {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                case 30:
                case 31:
                case 59:
                case 61:
                  goto LABEL_216;
                case 9:
                case 32:
                  goto LABEL_238;
                case 34:
                case 40:
                case 41:
                case 47:
                case 58:
                case 60:
                case 62:
                case 63:
                case 64:
                case 91:
                case 92:
                case 93:
                  goto LABEL_250;
                case 44:
                  goto LABEL_244;
                default:
                  goto LABEL_213;
              }
            }

            if ((char)v12 == 123 || (char)v12 == 125)
            {
              CFDictionaryRef v9 = v7;
              goto LABEL_250;
            }

LABEL_213:
            char v53 = *++v7;
            LOBYTE(v12) = v53;
            int v13 = 1;
          }

LABEL_216:
          if (v6 >= (const UInt8 *)v7) {
            CFStringRef v55 = &stru_189C1D1D8;
          }
          else {
            CFStringRef v55 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
          }
          *a1 = v55;
          uint64_t result = 258LL;
        }

        goto LABEL_229;
      default:
        uint64_t result = *(char *)v6;
        CFNumberRef v7 = (char *)v6;
        goto LABEL_213;
    }

    break;
  }

  while (2)
  {
    unsigned int v25 = *++v7;
    uint64_t result = v25;
    switch(v25)
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x7Fu:
        goto LABEL_216;
      case 9u:
      case 0x20u:
        int v13 = 1;
LABEL_114:
        CFDictionaryRef v9 = v7 + 1;
        while (2)
        {
          switch(*v9)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_117;
            case 9:
            case 32:
              ++v9;
              continue;
            case 13:
              goto LABEL_122;
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 41:
            case 42:
            case 43:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 60:
              goto LABEL_107;
            case 39:
LABEL_161:
              unsigned int v40 = *++v9;
              LODWORD(v33) = v40;
              uint64_t v41 = (1LL << v40) & 0x28000000FFFFFDFFLL;
              BOOL v42 = v40 > 0x3D || v41 == 0;
              if (v42 && (_DWORD)v33 != 127)
              {
                int v13 = 3;
                uint64_t result = *(char *)v6;
                goto LABEL_169;
              }

              CFNumberRef v7 = v9;
LABEL_177:
              if (v6 >= (const UInt8 *)v7) {
                CFStringRef v44 = &stru_189C1D1D8;
              }
              else {
                CFStringRef v44 = CFStringCreateWithBytes(alloc, v6, v7 - (char *)v6, 0x600u, 0);
              }
              *a1 = v44;
              uint64_t result = 259LL;
              break;
            case 44:
              int v33 = v9;
              goto LABEL_133;
            case 59:
            case 61:
              goto LABEL_125;
            default:
              if (*v9 == 127) {
                goto LABEL_117;
              }
              goto LABEL_107;
          }

          break;
        }

        break;
      case 0xDu:
        int v13 = 1;
LABEL_121:
        CFDictionaryRef v9 = v7;
        goto LABEL_122;
      case 0x22u:
      case 0x28u:
      case 0x29u:
      case 0x2Fu:
      case 0x3Au:
      case 0x3Cu:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x5Bu:
      case 0x5Cu:
      case 0x5Du:
      case 0x7Bu:
      case 0x7Du:
        CFDictionaryRef v9 = v7;
LABEL_107:
        CFNumberRef v7 = v9;
        while (2)
        {
          int v27 = *++v7;
          int v26 = v27;
          switch(v27)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              goto LABEL_225;
            case 9:
            case 32:
              int v13 = 2;
              goto LABEL_114;
            case 13:
              int v13 = 2;
              goto LABEL_121;
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 40:
            case 41:
            case 42:
            case 43:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 60:
              continue;
            case 39:
              CFDictionaryRef v9 = v7;
              goto LABEL_161;
            case 44:
              int v13 = 2;
              goto LABEL_132;
            case 59:
            case 61:
              int v13 = 2;
              goto LABEL_119;
            default:
              if (v26 == 127) {
                goto LABEL_225;
              }
              continue;
          }
        }

      case 0x27u:
        goto LABEL_213;
      case 0x2Cu:
        int v13 = 1;
LABEL_132:
        int v33 = v7;
LABEL_133:
        CFDictionaryRef v9 = v33 + 1;
        uint64_t result = 39LL;
        switch(v33[1])
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 10:
          case 11:
          case 12:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
            goto LABEL_250;
          case 9:
          case 32:
          case 59:
            goto LABEL_125;
          case 13:
            uint64_t v34 = v33[2];
            CFDictionaryRef v9 = v33 + 2;
            int v13 = 2;
            if (((1LL << v33[2]) & 0x28000000FFFFF9FFLL) != 0) {
              goto LABEL_157;
            }
            if (v34 == 10)
            {
              CFNumberRef v7 = v33 + 2;
LABEL_123:
              int v30 = *++v9;
              int v29 = v30;
              if (v30 != 9 && v29 != 32)
              {
LABEL_117:
                uint64_t result = 39LL;
                goto LABEL_176;
              }

              while (1)
              {
LABEL_125:
                unsigned int v32 = *++v9;
                uint64_t v31 = v32;
                if (v32 <= 0x27)
                {
                  if (((1LL << v31) & 0xFFFFDDFFLL) != 0) {
                    goto LABEL_117;
                  }
                  if (v31 == 13)
                  {
LABEL_122:
                    int v28 = *++v9;
                    if (v28 != 10) {
                      goto LABEL_117;
                    }
                    goto LABEL_123;
                  }

                  if (v31 == 39)
                  {
LABEL_154:
                    CFNumberRef v7 = v9 + 1;
                    goto LABEL_177;
                  }
                }

                if ((_DWORD)v31 == 127) {
                  goto LABEL_117;
                }
              }
            }

            int v119 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this);
            if ((_DWORD)v111 || !v119)
            {
              CFGetAllocator((char *)this - 16);
              uint64_t v120 = [*((id *)this + 11) _inner];
              sqlite3_int64 v121 = CFURLResponseCreateWithHTTPResponse(v120, *(const void **)(v120 + 8), (uint64_t)a2, 2);
              (*(void (**)(HTTPProtocol *, void))(*(void *)this + 640LL))(this, 0LL);
              unint64_t v122 = CFGetAllocator((char *)this - 16);
              uint64_t v123 = (const void *)CFURLAuthChallengeCreate((uint64_t)v122, v181, 0LL, *((void *)this + 43), v121, 0LL);
              if (v123)
              {
                (*(void (**)(HTTPProtocol *, const void *))(*(void *)this + 640LL))(this, v123);
                unint64_t v124 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648LL))(this);
                if (v124) {
                  uint64_t v125 = (URLAuthChallenge *)(v124 + 16);
                }
                else {
                  uint64_t v125 = 0LL;
                }
                URLAuthChallenge::setListOfProtectionSpaces(v125, (CFTypeRef)buf);
                CFRelease(v123);
              }
            }

            uint64_t v64 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this) != 0;
LABEL_343:
            uint64_t v108 = 1;
            uint32_t v4 = 1LL;
            goto LABEL_344;
          }

          CFIndex v146 = (const void *)(*(uint64_t (**)(void, _CFURLProtectionSpace *, void))(**((void **)this + 87)
                                                                                                  + 80LL))( *((void *)this + 87),  v181,  *((void *)this + 10));
          (*(void (**)(HTTPProtocol *, const void *))(*(void *)this + 624LL))(this, v146);
          if (v146) {
            CFRelease(v146);
          }
LABEL_363:
          LODWORD(v11__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
          goto LABEL_208;
        }

        uint64_t v102 = HTTPProtocol::handleKerberosChallenge(this, v95, a2, v181, (const __CFArray *)buf, v97);
LABEL_201:
        uint64_t v64 = v102;
        uint64_t v108 = 0;
        uint32_t v4 = v102;
LABEL_344:
        uint64_t v162 = v182;
        if (v182)
        {
          CFIndex v163 = (unint64_t *)&v182->__shared_owners_;
          do
            uint64_t v164 = __ldaxr(v163);
          while (__stlxr(v164 - 1, v163));
          if (!v164)
          {
            ((void (*)(std::__shared_weak_count *))v162->__on_zero_shared)(v162);
            std::__shared_weak_count::__release_weak(v162);
          }
        }

        uint64_t v165 = (std::__shared_weak_count *)*((void *)&buf + 1);
        if (*((void *)&buf + 1))
        {
          uint64_t v166 = (unint64_t *)(*((void *)&buf + 1) + 8LL);
          do
            UniChar v167 = __ldaxr(v166);
          while (__stlxr(v167 - 1, v166));
          if (!v167)
          {
            ((void (*)(std::__shared_weak_count *))v165->__on_zero_shared)(v165);
            std::__shared_weak_count::__release_weak(v165);
          }
        }

        if ((v108 & 1) == 0) {
          goto LABEL_356;
        }
        goto LABEL_355;
      }

      if (v181)
      {
        uint64_t v99 = *((_DWORD *)v96 + 18) == 6;
      }

      else
      {
        uint64_t v99 = 0;
      }

      if (v50 == 6 || v99)
      {
        uint64_t v102 = HTTPProtocol::handleKerberosChallenge(this, v95, a2, v181, (const __CFArray *)buf, v177);
        goto LABEL_201;
      }

      uint64_t v103 = [*((id *)this + 11) _inner];
      char v106 = *(void *)(v103 + 8);
      if (v106) {
        uint64_t v107 = CFURLCopyUserName(*(CFURLRef *)(v103 + 8));
      }
      else {
        uint64_t v107 = 0LL;
      }
      if (*((void *)this + 44) && (*((void *)this + 47) || !*((_BYTE *)this + 41)))
      {
        if (v107) {
          unint64_t v126 = CFStringGetLength(v107) == 0;
        }
        else {
          unint64_t v126 = 1;
        }
        uint64_t v129 = *((void *)this + 40);
        if (v129 != 0x7FFFFFFFFFFFFFFFLL) {
          *((void *)this + 40) = v129 + 1;
        }
        HTTPProtocol::RemoveCredentialPasswordForProtectionSpace( this,  *((const _CFURLCredential **)this + 44),  v181,  v126);
        CFIndex v127 = (const void *)*((void *)this + 44);
        *((void *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
      }

      else
      {
        CFIndex v127 = 0LL;
      }

      if (a2) {
        v130 = CFRetain(a2);
      }
      else {
        v130 = 0LL;
      }
      unint64_t v131 = (const void *)*((void *)this + 39);
      *((void *)this + 39) = v130;
      if (v131) {
        CFRelease(v131);
      }
      if (v50 == 9)
      {
        unint64_t v132 = *((void *)this + 40);
        if (v132 < 1 || !*((void *)this + 44)) {
          *((_DWORD *)this + 48) |= 0x40000000u;
        }
        if (v127 && v132 == 1)
        {
          CFIndex v133 = CFRetain(v127);
          uint64_t v134 = *((unsigned int *)this + 48);
          *((void *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v133;
          uint64_t v135 = v134 & 0xFFFFFFFFBFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
          *((_DWORD *)this + 4_Block_object_dispose(va, 8) = v135;
          *((_WORD *)this + 9_Block_object_dispose(va, 8) = WORD2(v135);
        }

        if ((v175 & 1) == 0)
        {
          if (!*((_BYTE *)this + 41)) {
            goto LABEL_311;
          }
          if (*v178 && v107 && v174)
          {
            if ((*((_DWORD *)this + 48) & 0x40000000) != 0)
            {
              UniChar v136 = CFGetAllocator((char *)this - 16);
              uint64_t v137 = _CFURLCredentialCreateXMobileMeAuthToken((uint64_t)v136, v107, 0LL, v174);
              *((void *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v137;
              if (v137)
              {
                if (*(_DWORD *)(v137 + 48) != 4
                  || !(*(unsigned int (**)(uint64_t))(*(void *)(v137 + 16) + 144LL))(v137 + 16))
                {
                  int v138 = (const void *)*((void *)this + 44);
                  *((void *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
                  if (v138) {
                    CFRelease(v138);
                  }
                }
              }

              else
              {
                *((void *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
              }

              uint64_t v172 = *((_DWORD *)this + 48) & 0xBFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
              *((_DWORD *)this + 48) &= ~0x40000000u;
              *((_WORD *)this + 9_Block_object_dispose(va, 8) = WORD2(v172);
              goto LABEL_312;
            }
          }

          else if (!*v178)
          {
            goto LABEL_311;
          }

          UniChar v147 = (void *)*((void *)this + 10);
          if (v147) {
            CFIndex v148 = [v147 _prohibitAuthUI] ^ 1;
          }
          else {
            CFIndex v148 = 1;
          }
          *((_DWORD *)this + 48) |= 0x20000000u;
          std::string v149 = *((void *)this + 44);
          if (v149 && (__int128 v150 = URLCredential_PasswordBased::safelyCast(v149, (const _CFURLCredential *)v104)) != 0) {
            uint64_t v151 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v150 + 128LL))(v150);
          }
          else {
            uint64_t v151 = 0LL;
          }
          HTTPProtocol::performAsyncCallout(this, v107, v151, v94, v148, a2, v105);
          if (v151) {
            CFRelease(v151);
          }
LABEL_311:
          if (!v107)
          {
LABEL_313:
            if (v174) {
              CFRelease(v174);
            }
            CFGetAllocator((char *)this - 16);
            uint64_t v152 = [*((id *)this + 11) _inner];
            uint64_t v153 = CFURLResponseCreateWithHTTPResponse(v152, *(const void **)(v152 + 8), (uint64_t)a2, 2);
            __int128 v154 = (const void *)*((void *)this + 47);
            if (v154) {
              CFRelease(v154);
            }
            uint64_t v155 = CFGetAllocator((char *)this - 16);
            __int128 v156 = *((void *)this + 44) ? (const void *)*((void *)this + 44) : v127;
            __int128 v157 = CFURLAuthChallengeCreate((uint64_t)v155, v181, v156, *((void *)this + 40), v153, 0LL);
            *((void *)this + 47) = v157;
            if (v157)
            {
              URLAuthChallenge::setListOfProtectionSpaces((URLAuthChallenge *)(v157 + 16), (CFTypeRef)buf);
              UniChar v158 = 0;
            }

            else
            {
              UniChar v158 = *((void *)this + 44) != 0LL;
            }

            if (v158)
            {
LABEL_329:
              uint64_t v64 = 1LL;
            }

            else
            {
              BOOL v159 = (const _CFURLCredential *)*((void *)this + 44);
              if (v159)
              {
                CFIndex v160 = (AuthenticationState *)*((void *)this + 97);
                if (a2)
                {
                  if (*((_BYTE *)a2 + 40)) {
                    CFIndex v161 = (__CFHTTPMessage *)((char *)a2 + 16);
                  }
                  else {
                    CFIndex v161 = 0LL;
                  }
                  BOOL v159 = (const _CFURLCredential *)*((void *)this + 44);
                }

                else
                {
                  CFIndex v161 = 0LL;
                }

                AuthenticationState::updateState(v160, v161, *((void *)this + 47), v159, *((__SecTrust **)this + 57));
              }

              uint64_t v64 = 0LL;
            }

            if (v127) {
              CFRelease(v127);
            }
            goto LABEL_343;
          }

LABEL_174:
            if ((_DWORD)v34 != 127)
            {
              uint64_t result = 39LL;
              LODWORD(v33) = v33[2];
LABEL_169:
              CFIndex v43 = v9;
              while (1)
              {
                CFNumberRef v7 = v9;
LABEL_238:
                LODWORD(v33) = v7[1];
                CFDictionaryRef v9 = v7 + 1;
              }

              if (((1LL << (char)v33) & 0x28000000FFFFFDFFLL) != 0)
              {
                CFNumberRef v7 = v43;
              }

              else if (v33 == 44LL)
              {
                CFNumberRef v7 = v9;
LABEL_244:
                while (1)
                {
                  char v59 = v7[1];
                  CFDictionaryRef v9 = v7 + 1;
                  if (v59 <= 0x3B)
                  {
                    CFNumberRef v7 = v43;
                    if (((1LL << v59) & 0x800000100000200LL) != 0) {
                      break;
                    }
                  }

LABEL_250:
                  CFNumberRef v7 = v9;
                  while (1)
                  {
                    unsigned int v58 = *++v7;
                    uint64_t v57 = v58;
                    if (v58 <= 0x3D)
                    {
                      if (((1LL << v57) & 0x28000000FFFFFDFFLL) != 0) {
                        goto LABEL_225;
                      }
                      if (((1LL << v57) & 0x100000200LL) != 0)
                      {
                        int v13 = 2;
                        CFIndex v43 = v7;
                        goto LABEL_238;
                      }

                      if (v57 == 44) {
                        break;
                      }
                    }

                    if ((_DWORD)v57 == 127) {
                      goto LABEL_225;
                    }
                  }

                  int v13 = 2;
                  CFIndex v43 = v7;
                }
              }

              else
              {
LABEL_249:
                CFNumberRef v7 = v43;
                if ((_DWORD)v33 != 127) {
                  goto LABEL_250;
                }
              }

LABEL_229:
  *a3 = v7;
  return result;
}

        unsigned int v61 = 0LL;
        unsigned int v62 = 0LL;
        uint64_t v63 = 2;
        v228 = 1;
        unint64_t v65 = 4LL;
      }

      else
      {
        unint64_t v65 = 0LL;
        v228 = 1;
LABEL_234:
        CFIndex v232 = 1;
        LODWORD(v10) = 1;
        unsigned int v61 = 3LL;
      }

        *(void *)(v3 + 256) = 1LL;
        uint64_t v83 = 12;
        goto LABEL_394;
      }

      CFRelease(ValueAtIndex);
LABEL_228:
      CFRelease(v90);
      goto LABEL_229;
    case 4:
      SocketStream::_PerformSOCKSv4Handshake_NoLock((CFDictionaryRef *)v1);
      return;
    case 5:
      WeakRetained = objc_loadWeakRetained((id *)(v1 + 280));
      if (WeakRetained)
      {
        int v26 = WeakRetained;
        int v27 = *(_DWORD *)(v3 + 248);
        if ((v27 & 0x400) != 0)
        {
          *(_WORD *)(v3 + 252) = *(_WORD *)(v3 + 252);
          *(_DWORD *)(v3 + 24_Block_object_dispose(va, 8) = v27 | 8;
          _CFWriteStreamSignalEventDelayed();
        }

        CFRelease(v26);
      }

      int v28 = objc_loadWeakRetained((id *)(v3 + 272));
      if (v28)
      {
        int v29 = v28;
        int v30 = *(_DWORD *)(v3 + 248);
        if ((v30 & 0x200) != 0)
        {
          *(_WORD *)(v3 + 252) = *(_WORD *)(v3 + 252);
          *(_DWORD *)(v3 + 24_Block_object_dispose(va, 8) = v30 | 4;
          _CFReadStreamSignalEventDelayed();
        }

        CFRelease(v29);
      }

      return;
    case 6:
      *(void *)&number.CFStreamError error = 0LL;
      number.CFIndex domain = 0LL;
      uint64_t v31 = CFGetAllocator(*(CFTypeRef *)(v1 + 336));
      unsigned int v32 = (char *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_18C5B24F8);
      if (v32)
      {
        int v33 = v32;
        uint64_t v34 = SocketStream::socketRead((SocketStream *)v3, buf, 4096LL, &number);
        int v35 = number.error;
        if (number.error)
        {
          if (number.error != 35 || number.domain != 1)
          {
            *(void *)(v3 + 256) = number.domain;
LABEL_175:
            *(_DWORD *)(v3 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v35;
          }

__n128 _CFURLConnectionSetFrameworkStubs(uint64_t a1)
{
  if (*(void *)a1) {
    __assert_rtn("_CFURLConnectionSetFrameworkStubs", "SecItem-shim.cpp", 13, "stubs->version == 0");
  }
  __n128 result = *(__n128 *)a1;
  __int128 v2 = *(_OWORD *)(a1 + 16);
  off_18C5AA310 = *(uint64_t (**)(void))(a1 + 32);
  _gFwStubs = result;
  *(_OWORD *)&off_18C5AA300 = v2;
  return result;
}

uint64_t CFURLDownloadCreate(uint64_t a1, void *a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    uint64_t v6 = Instance + 16;
    *(void *)(Instance + 336) = 0LL;
    *(_OWORD *)(Instance + 30os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 320) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 28_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 20_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 14os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  }

  *(void *)uint64_t v6 = &off_189C07A68;
  *(void *)(v6 + _Block_object_dispose(va, 8) = &unk_189C07AB0;
  *(void *)(v6 + 160) = 0LL;
  *(void *)(v6 + 28_Block_object_dispose(va, 8) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_DWORD *)(v6 + 30os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(_BYTE *)(v6 + 320) = 1;
  if (!a2 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFURLDownloadCreate(): Asked to create from a NULL request!",  (uint8_t *)&allocator,  2u);
  }

  URLDownload::_internal_setClient(v6, a3);
  CFGetAllocator((CFTypeRef)(v6 - 16));
  *(void *)(v6 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = [a2 copy];
  if (*(void *)([a2 _inner] + 32))
  {
    CFNumberRef v7 = CFGetAllocator((CFTypeRef)(v6 - 16));
    URLPortion::URLPortion((URLPortion *)&allocator, v7, *(CFURLRef *)([a2 _inner] + 32), 1);
    double v8 = CFGetAllocator((CFTypeRef)(v6 - 16));
    size_t v9 = strlen(__s);
    *(void *)(v6 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = CFURLCreateWithBytes(v8, (const UInt8 *)__s, v9, 0x201u, 0LL);
    if (ptr != v15) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }

  else
  {
    *(void *)(v6 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  }

  CFAllocatorRef allocator = (CFAllocatorRef)3;
  v15[0] = v6;
  v15[1] = DownloadConnectionClient::_implRetain;
  v15[2] = DownloadConnectionClient::_implRelease;
  void v15[3] = DownloadConnectionClient::_copyDescription;
  v15[4] = DownloadConnectionClient::_willSendRequestCallback;
  void v15[5] = DownloadConnectionClient::_didReceiveResponseCallback;
  v15[6] = DownloadConnectionClient::_didReceiveDataCallback;
  v15[7] = DownloadConnectionClient::_didStopBufferingDataCallback;
  v15[8] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
  _BYTE v15[9] = DownloadConnectionClient::_didFailCallback;
  v15[10] = DownloadConnectionClient::_willCacheResponseCallback;
  v15[11] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
  v15[12] = 0LL;
  v15[13] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
  v15[14] = 0LL;
  int v10 = CFGetAllocator((CFTypeRef)(v6 - 16));
  DownloadConnectionProperties = createDownloadConnectionProperties(v10);
  CFAllocatorRef v12 = CFGetAllocator((CFTypeRef)(v6 - 16));
  *(void *)(v6 + CFRetain((char *)this - 16) = CFURLConnectionCreateWithProperties((uint64_t)v12, a2, &allocator, DownloadConnectionProperties);
  if (DownloadConnectionProperties) {
    CFRelease(DownloadConnectionProperties);
  }
  *(_BYTE *)(v6 + 28__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
  *(void *)(v6 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  return v6 - 16;
}

void sub_182A541C0(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

uint64_t CFURLDownloadCreateWithResumeInformation( uint64_t a1, const __CFDictionary *a2, const void *a3, void *a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    uint64_t v8 = Instance + 16;
    *(void *)(Instance + 336) = 0LL;
    *(_OWORD *)(Instance + 30os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 320) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 28_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 20_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 14os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  }

  *(void *)uint64_t v8 = &off_189C07A68;
  *(void *)(v8 + _Block_object_dispose(va, 8) = &unk_189C07AB0;
  *(void *)(v8 + 160) = 0LL;
  *(void *)(v8 + 28_Block_object_dispose(va, 8) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_DWORD *)(v8 + 30os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(_BYTE *)(v8 + 320) = 1;
  if (!a2 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(valuePtr[0]) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFURLDownloadCreateWithResumeInformation(): Asked to create from NULL resumeInformation!",  (uint8_t *)valuePtr,  2u);
    if (!a3)
    {
LABEL_8:
      if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        LOWORD(valuePtr[0]) = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFURLDownloadCreateWithResumeData(): Asked to create from a NULL path!",  (uint8_t *)valuePtr,  2u);
      }
    }
  }

  else if (!a3)
  {
    goto LABEL_8;
  }

  URLDownload::_internal_setClient(v8, a4);
  uint64_t v9 = v8 - 16;
  int v10 = CFGetAllocator((CFTypeRef)(v8 - 16));
  unsigned int Value = (const __CFString *)CFDictionaryGetValue(a2, @"NSURLDownloadURL");
  if (!Value)
  {
    unsigned int Value = (const __CFString *)CFDictionaryGetValue(a2, @"kCFURLDownloadResumeURL");
    if (!Value) {
      goto LABEL_100;
    }
  }

  CFTypeID v12 = CFGetTypeID(Value);
  if (v12 != CFStringGetTypeID()) {
    goto LABEL_100;
  }
  CFURLRef v13 = CFURLCreateWithString(v10, Value, 0LL);
  if (!v13) {
    goto LABEL_100;
  }
  unsigned int v14 = (NSMutableURLRequest *)v13;
  unsigned int v15 = CFDictionaryGetValue(a2, @"NSURLDownloadBytesReceived");
  if (!v15)
  {
    unsigned int v15 = CFDictionaryGetValue(a2, @"kCFURLDownloadResumeBytesReceived");
    if (!v15) {
      goto LABEL_99;
    }
  }

  CFTypeID v16 = CFGetTypeID(v15);
  if (v16 != CFNumberGetTypeID()) {
    goto LABEL_99;
  }
  number = (const __CFNumber *)v15;
  unsigned int v17 = (__CFString *)CFDictionaryGetValue(a2, @"NSURLDownloadEntityTag");
  if (v17 || (unsigned int v17 = (__CFString *)CFDictionaryGetValue(a2, @"kCFURLDownloadResumeEntityTag")) != 0LL)
  {
    CFTypeID v18 = CFGetTypeID(v17);
    if (v18 == CFStringGetTypeID()) {
      unsigned int v19 = v17;
    }
    else {
      unsigned int v19 = 0LL;
    }
    uint64_t v82 = v19;
  }

  else
  {
    uint64_t v82 = 0LL;
  }

  uint64_t v85 = v14;
  CFAllocatorRef allocator = v10;
  unsigned int v20 = (__CFString *)CFDictionaryGetValue(a2, @"NSURLDownloadServerModificationDate");
  unint64_t v84 = a3;
  if (v20
    || (unsigned int v20 = (__CFString *)CFDictionaryGetValue(a2, @"kCFURLDownloadResumeServerModificationDateString")) != 0LL)
  {
    CFTypeID v21 = CFGetTypeID(v20);
    if (v21 == CFStringGetTypeID()) {
      int v22 = v20;
    }
    else {
      int v22 = 0LL;
    }
    unint64_t v81 = v22;
  }

  else
  {
    unint64_t v81 = 0LL;
  }

  CFArrayRef theArray = (const __CFArray *)CFDictionaryGetValue(a2, @"NSURLDownloadDecoders");
  if (!theArray || (uint64_t capacity = CFArrayGetCount(theArray), capacity < 1))
  {
LABEL_79:
    unsigned int v14 = -[NSURLRequest initWithURL:cachePolicy:timeoutInterval:]( objc_alloc(&OBJC_CLASS___NSMutableURLRequest),  "initWithURL:cachePolicy:timeoutInterval:",  v14,  0LL,  60.0);
    CFRelease(v85);
    if (!v14) {
      goto LABEL_100;
    }
    URLDownload::_internal_setServerModificationDateString((URLDownload *)v8, v81);
    URLDownload::_internal_setEntityTag((URLDownload *)v8, v82);
    if (!*(void *)(v8 + 240) && !*(void *)(v8 + 232)) {
      goto LABEL_99;
    }
    CFStringRef v70 = CFStringCreateWithFormat(allocator, 0LL, @"bytes=%lld-", *(void *)(v8 + 272));
    if (!v70) {
      goto LABEL_99;
    }
    uint64_t v71 = v70;
    uint64_t v72 = *(const __CFString **)(v8 + 232);
    if (!v72) {
      uint64_t v72 = *(const __CFString **)(v8 + 240);
    }
    CFURLRequestSetHTTPHeaderFieldValue(v14, @"If-Range", v72);
    CFURLRequestSetHTTPHeaderFieldValue(v14, (const __CFString *)&unk_18C5AF4D8, v71);
    CFRelease(v71);
    URLDownload::_internal_setRequest((URLDownload *)v8, (_CFURLRequest *)v14);
    CFRelease(v14);
    unint64_t v73 = (const __CFString *)CFDictionaryGetValue(a2, @"NSURLDownloadOriginatingURLString");
    if (v73)
    {
      uint64_t v74 = CFURLCreateWithString(allocator, v73, 0LL);
    }

    else
    {
      CFIndex v80 = *(void **)(v8 + 24);
      if (!v80) {
        goto LABEL_100;
      }
      uint64_t v74 = *(const void **)([v80 _inner] + 32);
      if (v74) {
        uint64_t v74 = CFRetain(v74);
      }
    }

    *(void *)(v8 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v74;
    if (!*(void *)(v8 + 24)) {
      goto LABEL_100;
    }
    valuePtr[0] = 3LL;
    valuePtr[1] = v8;
    valuePtr[2] = DownloadConnectionClient::_implRetain;
    valuePtr[3] = DownloadConnectionClient::_implRelease;
    valuePtr[4] = DownloadConnectionClient::_copyDescription;
    valuePtr[5] = DownloadConnectionClient::_willSendRequestCallback;
    void valuePtr[6] = DownloadConnectionClient::_didReceiveResponseCallback;
    valuePtr[7] = DownloadConnectionClient::_didReceiveDataCallback;
    valuePtr[8] = DownloadConnectionClient::_didStopBufferingDataCallback;
    valuePtr[9] = DownloadConnectionClient::_connectionDidFinishLoadingCallback;
    valuePtr[10] = DownloadConnectionClient::_didFailCallback;
    valuePtr[11] = DownloadConnectionClient::_willCacheResponseCallback;
    valuePtr[12] = DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback;
    valuePtr[13] = 0LL;
    valuePtr[14] = DownloadConnectionClient::_shouldUseCredentialStorageCallback;
    valuePtr[15] = 0LL;
    uint64_t v75 = CFGetAllocator((CFTypeRef)(v8 - 16));
    DownloadConnectionProperties = createDownloadConnectionProperties(v75);
    CFAllocatorRef v77 = CFGetAllocator((CFTypeRef)(v8 - 16));
    *(void *)(v8 + CFRetain((char *)this - 16) = CFURLConnectionCreateWithProperties( (uint64_t)v77,  *(void **)(v8 + 24),  valuePtr,  DownloadConnectionProperties);
    if (DownloadConnectionProperties) {
      CFRelease(DownloadConnectionProperties);
    }
    *(_BYTE *)(v8 + 28__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
    *(void *)(v8 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
    *(_WORD *)(v8 + 28os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 256;
    if (v84) {
      CFTypeRef v78 = CFRetain(v84);
    }
    else {
      CFTypeRef v78 = 0LL;
    }
    *(void *)(v8 + 200) = v78;
    return v9;
  }

  CFMutableArrayRef Mutable = CFArrayCreateMutable(v10, capacity, MEMORY[0x189605228]);
  *(void *)(v8 + 256) = Mutable;
  if (!Mutable) {
    goto LABEL_99;
  }
  CFIndex v24 = 0LL;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v24);
    int v26 = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadDecoderMIMEType");
    if (CFStringCompare(v26, @"application/mac-binhex40", 1uLL) == kCFCompareEqualTo)
    {
      if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
        dispatch_once( &DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder,  &__block_literal_global_2512);
      }
      unsigned int v39 = (_OWORD *)_CFRuntimeCreateInstance();
      int v28 = v39;
      if (v39)
      {
        v39[1] = 0u;
        int v28 = v39 + 1;
        v39[10] = 0u;
        v39[11] = 0u;
        v39[8] = 0u;
        v39[9] = 0u;
        v39[6] = 0u;
        v39[7] = 0u;
        v39[4] = 0u;
        v39[5] = 0u;
        void v39[2] = 0u;
        v39[3] = 0u;
      }

      *(void *)int v28 = &off_189C044D8;
      *((void *)v28 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = "GZip";
      *((void *)v28 + 2) = off_189C04698;
      *(void *)((char *)v28 + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
      *((_DWORD *)v28 + _Block_object_dispose(va, 8) = 0;
      *((_BYTE *)v28 + 8_Block_object_dispose(va, 8) = 0;
      *(void *)((char *)v28 + 52) = 0LL;
      *(void *)((char *)v28 + 59) = 0LL;
      *(void *)((char *)v28 + 16os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
      *((_BYTE *)v28 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
      unsigned int v40 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadBinHexDataForkCRCChecked");
      uint64_t v41 = v40;
      if (!v40) {
        goto LABEL_76;
      }
      CFTypeID v42 = CFGetTypeID(v40);
      if (v42 != CFNumberGetTypeID()) {
        goto LABEL_76;
      }
      CFNumberGetValue(v41, kCFNumberSInt16Type, valuePtr);
      *((_BYTE *)v28 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = LOWORD(valuePtr[0]) != 0;
      CFIndex v43 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadBinHexCRC");
      CFStringRef v44 = v43;
      if (!v43) {
        goto LABEL_76;
      }
      CFTypeID v45 = CFGetTypeID(v43);
      if (v45 != CFNumberGetTypeID()) {
        goto LABEL_76;
      }
      CFNumberGetValue(v44, kCFNumberSInt32Type, (char *)v28 + 52);
      CFStringRef v46 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadBinHexDataForkBytesRemaining");
      CFStringRef v47 = v46;
      if (!v46) {
        goto LABEL_76;
      }
      CFTypeID v48 = CFGetTypeID(v46);
      if (v48 != CFNumberGetTypeID()) {
        goto LABEL_76;
      }
      CFNumberGetValue(v47, kCFNumberSInt32Type, (char *)v28 + 56);
      CFStringRef v49 = (const __CFNumber *)CFDictionaryGetValue( ValueAtIndex,  @"NSURLDownloadBinHexResourceForkBytesRemaining");
      CFStringRef v50 = v49;
      if (!v49) {
        goto LABEL_76;
      }
      CFTypeID v51 = CFGetTypeID(v49);
      if (v51 != CFNumberGetTypeID()) {
        goto LABEL_76;
      }
      CFNumberGetValue(v50, kCFNumberSInt32Type, (char *)v28 + 60);
      CFStringRef v52 = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadBinHexDecodedDataOffset");
      char v53 = v52;
      if (!v52) {
        goto LABEL_76;
      }
      CFTypeID v54 = CFGetTypeID(v52);
      if (v54 != CFNumberGetTypeID()) {
        goto LABEL_76;
      }
      CFNumberGetValue(v53, kCFNumberSInt32Type, v28 + 3);
      CFStringRef v55 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadBinHexDecodedData");
      CFStringRef v56 = v55;
      if (!v55) {
        goto LABEL_76;
      }
      CFTypeID v57 = CFGetTypeID(v55);
      if (v57 != CFDataGetTypeID()) {
        goto LABEL_76;
      }
      uint64_t Length = CFDataGetLength(v56);
      if (Length > 8) {
        goto LABEL_76;
      }
      v90.CFIndex location = 0LL;
      v90.CFIndex length = Length;
      CFDataGetBytes(v56, v90, (UInt8 *)v28 + 36);
      *((_DWORD *)v28 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = Length;
      char v59 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadBinHexEncodedData");
      unint64_t v60 = v59;
      if (!v59) {
        goto LABEL_76;
      }
      CFTypeID v61 = CFGetTypeID(v59);
      if (v61 != CFDataGetTypeID()) {
        goto LABEL_76;
      }
      uint64_t v62 = CFDataGetLength(v60);
      if (v62 > 3) {
        goto LABEL_76;
      }
      v91.CFIndex location = 0LL;
      v91.CFIndex length = v62;
      CFDataGetBytes(v60, v91, (UInt8 *)v28 + 25);
      *((_DWORD *)v28 + _Block_object_dispose(va, 8) = v62;
      uint64_t v63 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadBinHexFirstCRCByte");
      uint64_t v64 = v63;
      if (v63)
      {
        CFTypeID v65 = CFGetTypeID(v63);
        if (v65 == CFDataGetTypeID())
        {
          if (CFDataGetLength(v64) != 1) {
            goto LABEL_76;
          }
          v92.CFIndex location = 0LL;
          v92.CFIndex length = 1LL;
          CFDataGetBytes(v64, v92, (UInt8 *)v28 + 173);
          *((_BYTE *)v28 + 66) = 1;
        }
      }

      unint64_t v66 = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, @"NSURLDownloadBinHexRepeatByte");
      uint64_t v67 = v66;
      if (!v66) {
        goto LABEL_75;
      }
      CFTypeID v68 = CFGetTypeID(v66);
      if (v68 != CFDataGetTypeID()) {
        goto LABEL_75;
      }
      if (CFDataGetLength(v67) == 1)
      {
        v93.CFIndex location = 0LL;
        v93.CFIndex length = 1LL;
        CFDataGetBytes(v67, v93, (UInt8 *)v28 + 172);
        *((_BYTE *)v28 + 17__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
LABEL_75:
        *((_BYTE *)v28 + 16_Block_object_dispose(va, 8) = 1;
        *((_BYTE *)v28 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
      }

void sub_182A54D60(_Unwind_Exception *a1)
{
  *(void *)(v1 + CFRetain((char *)this - 16) = off_189C048B0;
  _Unwind_Resume(a1);
}

void sub_182A54D74(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

uint64_t CFURLDownloadCreateAndStartWithLoadingConnection( uint64_t a1, char *a2, _CFURLRequest *a3, _CFURLResponse *a4, void *a5)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v10 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    uint64_t v10 = Instance + 16;
    *(void *)(Instance + 336) = 0LL;
    *(_OWORD *)(Instance + 30os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 320) = 0u;
    *(_OWORD *)(Instance + 272) = 0u;
    *(_OWORD *)(Instance + 28_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 256) = 0u;
    *(_OWORD *)(Instance + 20_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 14os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  }

  *(void *)uint64_t v10 = &off_189C07A68;
  *(void *)(v10 + _Block_object_dispose(va, 8) = &unk_189C07AB0;
  *(void *)(v10 + 160) = 0LL;
  *(void *)(v10 + 28_Block_object_dispose(va, 8) = CoreSchedulingSet::createEmpty((CoreSchedulingSet *)Instance);
  *(_DWORD *)(v10 + 30os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(_BYTE *)(v10 + 320) = 1;
  if (!a2 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFURLDownloadCreateWithConnection(): Asked to create from a NULL connection!",  (uint8_t *)&allocator,  2u);
    if (a3) {
      goto LABEL_10;
    }
  }

  else if (a3)
  {
    goto LABEL_10;
  }

  if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(allocator) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFURLDownloadCreateWithConnection(): Asked to create with a NULL request!",  (uint8_t *)&allocator,  2u);
  }

void sub_182A55318( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, const __CFAllocator *allocator, uint64_t a26)
{
}

uint64_t CFURLDownloadCreateWithResumeData( CFAllocatorRef allocator, CFDataRef data, const void *a3, void *a4)
{
  if (!data && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFStreamError buf = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFURLDownloadCreateWithResumeData(): Asked to create from NULL resumeData!",  buf,  2u);
    if (a3) {
      goto LABEL_6;
    }
  }

  else if (a3)
  {
    goto LABEL_6;
  }

  if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)unsigned int v11 = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFURLDownloadCreateWithResumeData(): Asked to create from a NULL path!",  v11,  2u);
  }

void CFURLDownloadSetDestination(uint64_t a1, CFURLRef url, int a3)
{
  if (a1) {
    uint64_t v6 = a1 + 16;
  }
  else {
    uint64_t v6 = 0LL;
  }
  if (!*(void *)(v6 + 200))
  {
    if (a3 || !objectExistsAtURL(url))
    {
      if (url) {
        CFNumberRef v7 = (const __CFURL *)CFRetain(url);
      }
      else {
        CFNumberRef v7 = 0LL;
      }
LABEL_30:
      *(void *)(v6 + 200) = v7;
      *(_BYTE *)(v6 + 283) = a3;
      return;
    }

    uint64_t v8 = CFGetAllocator(url);
    CFStringRef v9 = CFURLCopyPathExtension(url);
    if (!v9)
    {
      size_t v14 = (const __CFURL *)CFRetain(url);
      CFTypeRef v15 = 0LL;
LABEL_18:
      CFStringRef PathComponent = CFURLCopyLastPathComponent(v14);
      if (v14) {
        CFRelease(v14);
      }
      uint64_t v17 = CFURLCreateCopyDeletingLastPathComponent(v8, url);
      uint64_t v18 = 1LL;
      while (1)
      {
        unsigned int v19 = v15
            ? CFStringCreateWithFormat(v8, 0LL, @"%@-%d.%@", PathComponent, v18, v15)
            : CFStringCreateWithFormat(v8, 0LL, @"%@-%d", PathComponent, v18, v22);
        unsigned int v20 = v19;
        CFNumberRef v7 = CFURLCreateCopyAppendingPathComponent(v8, v17, v19, 0);
        CFRelease(v20);
        if (!objectExistsAtURL(v7)) {
          break;
        }
        CFRelease(v7);
        BOOL v21 = __CFADD__((_DWORD)v18, 1);
        uint64_t v18 = (v18 + 1);
        if (v21)
        {
          CFNumberRef v7 = 0LL;
          break;
        }
      }

      CFRelease(PathComponent);
      CFRelease(v17);
      if (v15) {
        CFRelease(v15);
      }
      goto LABEL_30;
    }

    CFStringRef v10 = v9;
    unsigned int v11 = CFURLCreateCopyDeletingPathExtension(v8, url);
    CFStringRef v12 = CFURLCopyPathExtension(v11);
    if (v12)
    {
      CFStringRef v13 = v12;
      size_t v14 = CFURLCreateCopyDeletingPathExtension(v8, v11);
      CFTypeRef v15 = CFStringCreateWithFormat(v8, 0LL, @"%@.%@", v13, v10);
      CFRelease(v13);
      if (!v11)
      {
LABEL_15:
        CFRelease(v10);
        goto LABEL_18;
      }
    }

    else
    {
      CFTypeRef v15 = CFRetain(v10);
      size_t v14 = (const __CFURL *)CFRetain(v11);
      if (!v11) {
        goto LABEL_15;
      }
    }

    CFRelease(v11);
    goto LABEL_15;
  }

void CFURLDownloadSetDeletesUponFailure(uint64_t a1, char a2)
{
  uint64_t v4 = a1 + 16;
  if (!a1) {
    uint64_t v4 = 0LL;
  }
  *(_BYTE *)(v4 + 28__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = a2;
}

uint64_t CFURLDownloadDeletesUponFailure(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  if (!a1) {
    uint64_t v2 = 0LL;
  }
  return *(unsigned __int8 *)(v2 + 281);
}

CFDictionaryRef CFURLDownloadCopyResumeData(char *a1)
{
  uint64_t v2 = CFGetAllocator(a1);
  if (a1) {
    int v3 = (URLDownload *)(a1 + 16);
  }
  else {
    int v3 = 0LL;
  }
  CFDictionaryRef result = URLDownload::createResumeInformation(v3, v2);
  if (result)
  {
    CFDictionaryRef v5 = result;
    CFDataRef Data = CFPropertyListCreateData(v2, result, kCFPropertyListXMLFormat_v1_0, 0LL, 0LL);
    CFRelease(v5);
    return Data;
  }

  return result;
}

uint64_t CFURLDownloadScheduleWithRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1) {
    uint64_t v6 = a1 + 16;
  }
  else {
    uint64_t v6 = 0LL;
  }
  CFURLConnectionScheduleWithRunLoop(*(void *)(v6 + 16), a2, a3);
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 288) + 56LL))( *(void *)(v6 + 288),  a2,  a3);
  *(void *)(v6 + 28_Block_object_dispose(va, 8) = result;
  return result;
}

void CFURLDownloadStart(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = a1 + 16;
  }
  else {
    uint64_t v2 = 0LL;
  }
  if (!*(_BYTE *)(v2 + 282))
  {
    *(_BYTE *)(v2 + 282) = 1;
    CFRetain((CFTypeRef)(v2 - 16));
  }

  CFURLConnectionStart(*(void *)(v2 + 16));
}

void CFURLDownloadCancel(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = (URLDownload *)(a1 + 16);
  }
  else {
    uint64_t v2 = 0LL;
  }
  URLDownload::_internal_downloadCancel(v2, 0LL);
}

__CFArray *cfTypeCreateArray(const __CFAllocator *a1, ...)
{
  CFIndex v1 = -1LL;
  do
  {
    uint64_t v2 = va_arg(v6, void);
    ++v1;
  }

  while (v2);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, v1, MEMORY[0x189605228]);
  va_copy(v7, va);
  for (; v1; --v1)
  {
    uint64_t v4 = (const void **)v7;
    v7 += 8;
    CFArrayAppendValue(Mutable, *v4);
  }

  return Mutable;
}

void sub_182A56044( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void AutoDict::~AutoDict(AutoDict *this)
{
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  *(void *)this = off_189C04A50;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  int v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 3);
  if (v4) {
    CFRelease(v4);
  }
}

__CFDictionary *cfTypeCreateMutableDictionary(const __CFAllocator *a1, ...)
{
  unint64_t v1 = -1LL;
  do
  {
    uint64_t v2 = va_arg(v10, void);
    ++v1;
  }

  while (v2);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  if (v1 >= 2)
  {
    unint64_t v4 = v1 >> 1;
    while (1)
    {
      CFDictionaryRef v5 = v11;
      va_list v6 = *v11;
      v11 += 2;
      va_list v7 = v5[1];
      if (!v6 || v7 == 0LL) {
        break;
      }
      CFDictionarySetValue(Mutable, v6, v7);
      if (!--v4) {
        return Mutable;
      }
    }

    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

CFMutableDictionaryRef AutoDict::getMutableDict(AutoDict *this)
{
  CFMutableDictionaryRef result = (CFMutableDictionaryRef)*((void *)this + 3);
  if (!result)
  {
    int v3 = (const __CFAllocator *)*((void *)this + 1);
    unint64_t v4 = (const __CFDictionary *)*((void *)this + 2);
    if (v4)
    {
      CFMutableDictionaryRef result = CFDictionaryCreateMutableCopy(v3, 0LL, v4);
      CFDictionaryRef v5 = (const void *)*((void *)this + 2);
      *((void *)this + 2) = 0LL;
      *((void *)this + 3) = result;
      if (v5)
      {
        CFRelease(v5);
        return (CFMutableDictionaryRef)*((void *)this + 3);
      }
    }

    else
    {
      CFMutableDictionaryRef result = CFDictionaryCreateMutable(v3, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      *((void *)this + 3) = result;
    }
  }

  return result;
}

CFDictionaryRef AutoDict::copyDictAndSetEmpty(AutoDict *this)
{
  CFDictionaryRef Copy = (CFDictionaryRef)*((void *)this + 3);
  if (Copy) {
    goto LABEL_2;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)*((void *)this + 2);
  if (v5)
  {
    va_list v6 = CFGetAllocator(*((CFTypeRef *)this + 2));
    CFDictionaryRef Copy = CFDictionaryCreateCopy(v6, v5);
    va_list v7 = (const void *)*((void *)this + 2);
    *((void *)this + 2) = 0LL;
    if (v7) {
      CFRelease(v7);
    }
    if (Copy)
    {
LABEL_2:
      int v3 = CFGetAllocator(Copy);
      *((void *)this + 3) = CFDictionaryCreateMutable(v3, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      return Copy;
    }
  }

  CFMutableArrayRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  *((void *)this + 3) = Mutable;
  EmptyDict = (const void *)AutoDict::getEmptyDict(Mutable);
  if (!EmptyDict) {
    return 0LL;
  }
  return (CFDictionaryRef)CFRetain(EmptyDict);
}

void AutoScalar::~AutoScalar(AutoScalar *this)
{
  *(void *)this = off_189C04A90;
  unint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C04A90;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

uint64_t AutoScalar::getRef(AutoScalar *this)
{
  return *((void *)this + 1);
}

uint64_t AutoScalar::isEmpty(AutoScalar *this)
{
  return 0LL;
}

void AutoScalar::AutoScalar(AutoScalar *this, const __CFAllocator *a2)
{
  int valuePtr = (int)a2;
  *(void *)this = off_189C04A90;
  if (((_DWORD)a2 - 16) > 0xFFFFFFEC)
  {
    int v7 = (int)a2;
    uint64_t v4 = ((_DWORD)a2 + 3);
    CFNumberRef v5 = (CFNumberRef)copyInternedInt(int)::sInterned[v4];
    if (!v5)
    {
      CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &v7);
      copyInternedInt(int)::sInterned[v4] = v5;
    }

    int v3 = (void *)CFRetain(v5);
  }

  else
  {
    int v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberSInt32Type, &valuePtr);
  }

  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v3;
}

void HTTPServerService_NW::ensureServerExists(uint64_t a1, dispatch_semaphore_s *a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 88));
  if (*(void *)(a1 + 328))
  {
    if (a2) {
      dispatch_semaphore_signal(a2);
    }
    return;
  }

  if (a2)
  {
    uint64_t v4 = *(void **)(a1 + 336);
    if (!v4)
    {
      uint64_t v4 = (void *)[objc_alloc(MEMORY[0x189603FA8]) initWithCapacity:0];
      *(void *)(a1 + 336) = v4;
    }

    [v4 addObject:a2];
  }

  if (!*(_BYTE *)(a1 + 345))
  {
    *(_BYTE *)(a1 + 345) = 1;
    CFNumberRef v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    uint64_t v6 = MEMORY[0x186E12804](*MEMORY[0x189604DB0], 72LL, 0LL);
    *(_OWORD *)(v6 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
    *(_OWORD *)(v6 + 4_Block_object_dispose(va, 8) = 0u;
    *(void *)(v6 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
    *(_OWORD *)uint64_t v6 = 0u;
    *(_OWORD *)(v6 + CFRetain((char *)this - 16) = 0u;
    __int16 v7 = *(_WORD *)(a1 + 296);
    *(void *)uint64_t v6 = off_189C06BF8;
    *(void *)(v6 + _Block_object_dispose(va, 8) = v5;
    *(_DWORD *)(v6 + CFRetain((char *)this - 16) = 1;
    if (((v6 + 16) & 3) != 0) {
      __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
    }
    uint64_t v8 = (void *)v6;
    *(void *)uint64_t v6 = off_189C04D38;
    *(void *)(v6 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
    CFStringRef v9 = (nw_listener_t *)(v6 + 32);
    *(void *)(v6 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C04D90;
    *(void *)(v6 + 40) = 0LL;
    *(_WORD *)(v6 + 4_Block_object_dispose(va, 8) = 0;
    *(void *)(v6 + 56) = 0LL;
    *(void *)(v6 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a1;
    CFRetain((CFTypeRef)(a1 - 16));
    *((_WORD *)v8 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v7;
    v8[7] = 0LL;
    va_list v10 = (const void *)(*(uint64_t (**)(void *, uint64_t))(*v8 + 64LL))(v8, 0x18C5B1538LL);
    if (v10)
    {
      unsigned int v11 = operator new(0x10uLL);
      *unsigned int v11 = off_189C0ABF0;
      CFTypeRef v12 = CFRetain(v10);
      *unsigned int v11 = off_189C04DB0;
      v11[1] = v12;
      v8[7] = v11;
    }

    snprintf(__str, 0x20uLL, "%u", *((unsigned __int16 *)v8 + 24));
    uint64_t v40 = 0LL;
    uint64_t v41 = &v40;
    uint64_t v42 = 0x3052000000LL;
    CFIndex v43 = __Block_byref_object_copy__3096;
    CFStringRef v44 = __Block_byref_object_dispose__3097;
    CFStringRef v13 = (HTTPServer *)v8[8];
    if (v13 && (size_t v14 = (const __CFArray *)HTTPServer::copyServerTrustChain(v13), (v15 = v14) != 0LL))
    {
      CFIndex Count = CFArrayGetCount(v14);
      if (Count)
      {
        ValueAtIndex = (AutoArray *)CFArrayGetValueAtIndex(v15, 0LL);
        uint64_t v18 = ValueAtIndex;
        if (Count == 1)
        {
          EmptyArray = (const __CFArray *)AutoArray::getEmptyArray(ValueAtIndex);
          sec_identity_t v20 = sec_identity_create_with_certificates(v18, EmptyArray);
        }

        else
        {
          CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(v5, Count, v15);
          CFArrayRemoveValueAtIndex(MutableCopy, 0LL);
          sec_identity_t v20 = sec_identity_create_with_certificates(v18, MutableCopy);
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
        }
      }

      else
      {
        sec_identity_t v20 = 0LL;
      }

      CFRelease(v15);
    }

    else
    {
      sec_identity_t v20 = 0LL;
    }

    sec_identity_t v45 = v20;
    uint64_t v22 = MEMORY[0x1895F87A8];
    if (v41[5])
    {
      v39[0] = MEMORY[0x1895F87A8];
      v39[1] = 3221225472LL;
      void v39[2] = ___ZN8Listener5startEv_block_invoke;
      v39[3] = &unk_189C04B20;
      v39[4] = &v40;
      v39[5] = v8;
      int v23 = v39;
    }

    else
    {
      int v23 = (void *)*MEMORY[0x189608EB0];
    }

    secure_tcp = nw_parameters_create_secure_tcp(v23, (nw_parameters_configure_protocol_block_t)*MEMORY[0x189608EA8]);
    uint64_t v25 = (void *)(*(uint64_t (**)(void *, uint64_t))(*v8 + 64LL))(v8, 0x18C5B10D8LL);
    int v26 = v25;
    if (v25)
    {
      if (CFEqual(v25, @"all"))
      {
        nw_parameters_set_use_awdl();
      }

      else
      {
        [v26 UTF8String];
        uint64_t v27 = (nw_interface *)nw_interface_create_with_name();
        if (v27)
        {
          nw_parameters_require_interface(secure_tcp, v27);
          CFRelease(v27);
        }
      }
    }

    int v28 = nw_listener_create_with_port(__str, secure_tcp);
    v8[4] = v28;
    nw_listener_set_queue(v28, *(dispatch_queue_t *)(v8[8] + 88LL));
    if (secure_tcp) {
      CFRelease(secure_tcp);
    }
    v35[0] = v22;
    v35[1] = 3221225472LL;
    int v36 = ___ZN8Listener5startEv_block_invoke_2;
    CFTypeID v37 = &__block_descriptor_40_e44_v32__0__NSString_8__NSString_16__NSString_24l;
    uint64_t v38 = v8;
    int v29 = (void *)(*(uint64_t (**)(void, uint64_t))(*(void *)v8[8] + 64LL))(v8[8], 0x18C5B1500LL);
    if (!v29) {
      goto LABEL_41;
    }
    CFDictionaryRef Copy = (__CFString *)(*(uint64_t (**)(void, uint64_t))(*(void *)v8[8] + 64LL))(v8[8], 0x18C5B1260LL);
    if (Copy)
    {
      ___ZN8Listener5startEv_block_invoke_2((uint64_t)v35, v29, Copy, &stru_189C1D1D8);
    }

    else
    {
      CFDictionaryRef Copy = (__CFString *)CFStringCreateCopy(v5, &stru_189C1D1D8);
      v36((uint64_t)v35, v29, Copy, &stru_189C1D1D8);
      if (!Copy)
      {
LABEL_40:
        CFRelease(v29);
LABEL_41:
        (*(void (**)(void *))(*v8 + 40LL))(v8);
        CFTypeID v31 = (nw_listener *)v8[4];
        handler[0] = v22;
        handler[1] = 3221225472LL;
        handler[2] = ___ZN8Listener5startEv_block_invoke_3;
        handler[3] = &__block_descriptor_40_e34_v20__0i8__NSObject_OS_nw_error__12l;
        handler[4] = v8;
        nw_listener_set_state_changed_handler(v31, handler);
        unsigned int v32 = (nw_listener *)v8[4];
        v33[0] = v22;
        v33[1] = 3221225472LL;
        void v33[2] = ___ZN8Listener5startEv_block_invoke_4;
        v33[3] = &__block_descriptor_40_e36_v16__0__NSObject_OS_nw_connection__8l;
        v33[4] = v8;
        nw_listener_set_new_connection_handler(v32, v33);
        nw_listener_start(*v9);
        _Block_object_dispose(&v40, 8);
        (*(void (**)(void *))(*v8 + 48LL))(v8);
        return;
      }
    }

    CFRelease(Copy);
    goto LABEL_40;
  }

void sub_182A57410(_Unwind_Exception *a1)
{
  *(void *)(v1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = off_189C19AE8;
  _Unwind_Resume(a1);
}

void HTTPServerService_NW::scheduled_onQueue(HTTPServerService_NW *this)
{
  if (!*((_BYTE *)this + 344) && !*((void *)this + 41)) {
    (*(void (**)(HTTPServerService_NW *, void))(*(void *)this + 80LL))(this, 0LL);
  }
  HTTPServerService::scheduled_onQueue(this);
}

void HTTPServerService_NW::canceled_onQueue(HTTPServerService_NW *this)
{
  if (!*((_BYTE *)this + 344))
  {
    *((_BYTE *)this + 34os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
    uint64_t v2 = (Listener *)*((void *)this + 41);
    if (v2) {
      Listener::_onqueue_invalidate(v2);
    }
  }

  *((_BYTE *)this + 313) = 0;
}

uint64_t HTTPServerService_NW::setupTLSOnStreams( HTTPServerService_NW *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return 1LL;
}

uint64_t HTTPServerService_NW::getPort(HTTPServerService_NW *this)
{
  uint64_t v1 = *((void *)this + 41);
  if (v1) {
    uint64_t v2 = (unsigned __int16 *)(v1 + 48);
  }
  else {
    uint64_t v2 = (unsigned __int16 *)((char *)this + 296);
  }
  return *v2;
}

uint64_t HTTPServerService_NW::createServerInstance(HTTPServerService_NW *this)
{
  return 0LL;
}

void HTTPServerService_NW::errorHandler_onQueue(HTTPServerService_NW *this, __CFError *a2)
{
}

void non-virtual thunk to'HTTPServerService_NW::~HTTPServerService_NW(HTTPServerService_NW *this)
{
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 8));
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 56));
}

{
  HTTPServerService_NW::~HTTPServerService_NW((HTTPServerService_NW *)((char *)this - 56));
}

void non-virtual thunk to'HTTPServerService_NW::scheduled_onQueue(HTTPServerService_NW *this)
{
}

void non-virtual thunk to'HTTPServerService_NW::canceled_onQueue(HTTPServerService_NW *this)
{
  if (!*((_BYTE *)this + 336))
  {
    *((_BYTE *)this + 336) = 1;
    uint64_t v2 = (Listener *)*((void *)this + 40);
    if (v2) {
      Listener::_onqueue_invalidate(v2);
    }
  }

  *((_BYTE *)this + 305) = 0;
}

void HTTPServerService_NW::~HTTPServerService_NW(HTTPServerService_NW *this)
{
  *(void *)this = &off_189C04BB0;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C04C70;
  *((void *)this + 7) = &unk_189C04CD8;
  uint64_t v2 = *((void *)this + 41);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
    *((void *)this + 4__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  }

  HTTPServerService::~HTTPServerService(this);
}

void sub_182A575C0(_Unwind_Exception *a1)
{
}

void Listener::_onqueue_invalidate(Listener *this)
{
  uint64_t v2 = (nw_listener *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
    nw_listener_cancel(v2);
    CFRelease(v2);
  }

  else
  {
    uint64_t v3 = *((void *)this + 8);
    if (v3)
    {
      CFRelease((CFTypeRef)(v3 - 16));
      *((void *)this + _Block_object_dispose(va, 8) = 0LL;
    }
  }

void __Block_byref_object_copy__3096(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3097(uint64_t a1)
{
}

void ___ZN8Listener5startEv_block_invoke(uint64_t a1, sec_protocol_options *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 40);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  CFNumberRef v5 = (os_log_s *)CFNLog::logger;
  BOOL v6 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
  __int16 v7 = (const void **)MEMORY[0x189604DE8];
  if (v6)
  {
    int v8 = *(unsigned __int16 *)(v4 + 48);
    BOOL v9 = CFDictionaryGetValue( *(CFDictionaryRef *)(*(void *)(v4 + 56) + 8LL),  @"kCFHTTPServerRequireClientCertificate") != 0LL;
    BOOL v10 = CFDictionaryGetValue( *(CFDictionaryRef *)(*(void *)(v4 + 56) + 8LL),  @"kCFHTTPServerRequireClientCertificate") == *v7;
    v12[0] = 67109632;
    v12[1] = v8;
    __int16 v13 = 1024;
    BOOL v14 = v9;
    __int16 v15 = 1024;
    BOOL v16 = v10;
    _os_log_impl( &dword_18298D000,  v5,  OS_LOG_TYPE_DEFAULT,  "CFHTTPServer configuring TLS {port=%u, wants_client_cert=%{BOOL}d, requires_client_cert=%{BOOL}d}",  (uint8_t *)v12,  0x14u);
  }

  sec_protocol_options_set_local_identity(a2, *(sec_identity_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL));
  unsigned int v11 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  if (v11) {
    CFRelease(v11);
  }
  sec_protocol_options_set_verify_block( a2,  &__block_literal_global_3107,  *(dispatch_queue_t *)(*(void *)(v4 + 64) + 88LL));
  if (CFDictionaryGetValue( *(CFDictionaryRef *)(*(void *)(v4 + 56) + 8LL),  @"kCFHTTPServerRequireClientCertificate"))
  {
    if (CFDictionaryGetValue( *(CFDictionaryRef *)(*(void *)(v4 + 56) + 8LL),  @"kCFHTTPServerRequireClientCertificate") == *v7) {
      sec_protocol_options_set_peer_authentication_required(a2, 1);
    }
    else {
      sec_protocol_options_set_peer_authentication_optional(a2, 1);
    }
  }

void ___ZN8Listener5startEv_block_invoke_2(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  bonjour_service = nw_advertise_descriptor_create_bonjour_service( (const char *)[a3 UTF8String],  (const char *)objc_msgSend(a2, "UTF8String"),  (const char *)objc_msgSend(a4, "UTF8String"));
  if (bonjour_service)
  {
    BOOL v6 = bonjour_service;
    nw_listener_set_advertise_descriptor(*(nw_listener_t *)(v4 + 32), bonjour_service);
    CFRelease(v6);
  }

uint64_t ___ZN8Listener5startEv_block_invoke_3(uint64_t result, int a2, nw_error_t error)
{
  if (a2 != 1)
  {
    uint64_t v5 = *(void *)(result + 32);
    uint64_t v6 = *(void *)(v5 + 64);
    if (v6 && !*(void *)(v6 + 328))
    {
      *(void *)(v6 + 32_Block_object_dispose(va, 8) = v5;
      (*(void (**)(uint64_t))(*(void *)v5 + 40LL))(v5);
      __int16 v7 = *(void **)(v6 + 336);
      if (v7)
      {
        *(void *)(v6 + 336) = 0LL;
        [v7 enumerateObjectsUsingBlock:&__block_literal_global_10_3102];
        CFRelease(v7);
      }

      if (*(_BYTE *)(v6 + 344)) {
        Listener::_onqueue_invalidate(*(Listener **)(v6 + 328));
      }
    }

    if (a2 == 2)
    {
      CFMutableDictionaryRef result = *(void *)(v5 + 32);
      if (result)
      {
        CFMutableDictionaryRef result = nw_listener_get_port((nw_listener_t)result);
        *(_WORD *)(v5 + 4_Block_object_dispose(va, 8) = result;
      }
    }

    else
    {
      if (error) {
        CFErrorRef v8 = nw_error_copy_cf_error(error);
      }
      else {
        CFErrorRef v8 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (CFErrorDomain)*MEMORY[0x189604F58], 22LL, 0LL);
      }
      CFErrorRef v9 = v8;
      uint64_t v10 = *(void *)(v5 + 64);
      if (v10)
      {
        *(void *)(v5 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
        unsigned int v11 = (const void *)(v10 - 16);
        (*(void (**)(uint64_t, CFErrorRef))(*(void *)v10 + 168LL))(v10, v9);
        CFRelease(v11);
      }

      CFRelease(v9);
      CFTypeRef v12 = *(nw_listener **)(v5 + 32);
      if (v12)
      {
        nw_listener_set_state_changed_handler(v12, 0LL);
        nw_listener_set_new_connection_handler(*(nw_listener_t *)(v5 + 32), 0LL);
      }

      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48LL))(v5);
    }
  }

  return result;
}

void ___ZN8Listener5startEv_block_invoke_4(uint64_t a1, nw_connection_t connection)
{
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3[4])
  {
    uint64_t v4 = dispatch_queue_create("com.apple.cfnetwork.httpserver-connection-queue", 0LL);
    nw_connection_set_queue(connection, v4);
    uint64_t v5 = v3[8];
    uint64_t v6 = *(void *)(v5 + 88);
    if (v6) {
      CFRetain(*(CFTypeRef *)(v5 + 88));
    }
    v8[0] = 0LL;
    v8[1] = v8;
    _DWORD v8[2] = 0x2020000000LL;
    char v9 = 0;
    (*(void (**)(void *))(*v3 + 40LL))(v3);
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke;
    handler[3] = &unk_189C04AB8;
    handler[7] = v8;
    handler[8] = v3;
    handler[4] = connection;
    void handler[5] = v4;
    handler[6] = v6;
    nw_connection_set_state_changed_handler(connection, handler);
    dispatch_release(v4);
    nw_connection_start(connection);
    _Block_object_dispose(v8, 8);
  }

  else
  {
    nw_connection_cancel(connection);
  }

void sub_182A57B04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke( uint64_t result, int a2)
{
  if ((a2 - 3) <= 2)
  {
    block[11] = v2;
    block[12] = v3;
    uint64_t v4 = result;
    if (!*(_BYTE *)(*(void *)(*(void *)(result + 56) + 8LL) + 24LL))
    {
      uint64_t v5 = *(void *)(result + 64);
      unsigned int v6 = 6u >> ((a2 - 3) & 7);
      nw_connection_set_state_changed_handler(*(nw_connection_t *)(result + 32), 0LL);
      *(_BYTE *)(*(void *)(*(void *)(v4 + 56) + 8LL) + 24LL) = 1;
      if ((v6 & 1) != 0)
      {
        nw_connection_cancel(*(nw_connection_t *)(v4 + 32));
      }

      else
      {
        (*(void (**)(uint64_t))(*(void *)v5 + 40LL))(v5);
        __int16 v7 = *(const void **)(v4 + 32);
        if (v7) {
          CFRetain(v7);
        }
        CFErrorRef v8 = *(const void **)(v4 + 40);
        if (v8)
        {
          CFRetain(v8);
          uint64_t v9 = *(void *)(v4 + 40);
        }

        else
        {
          uint64_t v9 = 0LL;
        }

        uint64_t v10 = *(dispatch_queue_s **)(v4 + 48);
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2;
        block[3] = &unk_189C194B0;
        void block[5] = v9;
        void block[6] = v5;
        block[4] = *(void *)(v4 + 32);
        dispatch_async(v10, block);
      }

      dispatch_release(*(dispatch_object_t *)(v4 + 48));
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 48LL))(v5);
    }
  }

  return result;
}

uint64_t ___ZN8Listener13newConnectionEPU27objcproto16OS_nw_connection8NSObject_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void **)(a1 + 32);
  if (!*(void *)(v2 + 32)) {
    goto LABEL_26;
  }
  uint64_t v4 = *(void *)(v2 + 64);
  if (!v4)
  {
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)CFStreamError buf = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "if we have an _nwListener, we should have a _server",  buf,  2u);
    }

    goto LABEL_26;
  }

  uint64_t v5 = *(const void **)(a1 + 40);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v4 + 88));
  unsigned int v6 = objc_alloc(&OBJC_CLASS___NWStreamPair);
  if (!v6) {
    goto LABEL_26;
  }
  v27.receiver = v6;
  v27.super_class = (Class)&OBJC_CLASS___NWStreamPair;
  __int16 v7 = objc_msgSendSuper2(&v27, sel_initWithLoggableName_, "nwstream");
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (uint64_t)v7;
  v7[2] = v3;
  if (v3)
  {
    CFRetain(v3);
    uint64_t v9 = *(nw_connection **)(v8 + 16);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  uint64_t v10 = nw_connection_copy_endpoint(v9);
  unsigned int v11 = (CFAllocatorRef *)MEMORY[0x189604DB0];
  if (v10)
  {
    CFTypeRef v12 = v10;
    address = nw_endpoint_get_address(v10);
    *(void *)(v8 + 8_Block_object_dispose(va, 8) = CFDataCreate(*v11, &address->sa_len, address->sa_len);
    CFRelease(v12);
  }

  uint64_t v28 = 0LL;
  int v29 = &v28;
  uint64_t v30 = 0x2020000000LL;
  uint64_t v14 = MEMORY[0x1895F87A8];
  uint64_t v31 = 0LL;
  *(void *)CFStreamError buf = MEMORY[0x1895F87A8];
  uint64_t v33 = 3221225472LL;
  uint64_t v34 = __39__NWStreamPair_copyConnectionPeerTrust__block_invoke;
  int v35 = (CFStringRef (*)(uint64_t, uint64_t))&unk_189C131D8;
  int v36 = &v28;
  -[NWStreamPair withTLSMetadata:](v8, (uint64_t)buf);
  uint64_t v15 = v29[3];
  _Block_object_dispose(&v28, 8);
  *(void *)(v8 + 96) = v15;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(*v11, 0LL, MEMORY[0x189605228]);
  *(void *)CFStreamError buf = v14;
  uint64_t v33 = 3221225472LL;
  uint64_t v34 = __39__NWStreamPair_copyConnectionPeerCerts__block_invoke;
  int v35 = (CFStringRef (*)(uint64_t, uint64_t))&__block_descriptor_40_e44_v16__0__NSObject_OS_sec_protocol_metadata__8l;
  int v36 = Mutable;
  -[NWStreamPair withTLSMetadata:](v8, (uint64_t)buf);
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    CFMutableArrayRef Mutable = 0LL;
  }

  *(void *)(v8 + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = Mutable;
  *(void *)(v8 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  *(void *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
  *(void *)(v8 + 56) = 0LL;
  uint64_t v17 = operator new(0x28uLL);
  void *v17 = off_189C13208;
  v17[1] = 0xFFFFLL;
  void v17[2] = 0LL;
  void v17[3] = 0LL;
  *((_BYTE *)v17 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0;
  *(void *)(v8 + 72) = v17;
  *(_BYTE *)(v8 + 80) = 0;
  *(void *)(v8 + 40) = v5;
  if (v5) {
    CFRetain(v5);
  }
  uint64_t v18 = operator new(0x30uLL);
  *uint64_t v18 = off_189C132A8;
  v18[1] = (id)v8;
  v18[2] = "read";
  v18[4] = 0LL;
  v18[5] = 0LL;
  *uint64_t v18 = off_189C13250;
  *(void *)(v8 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v18;
  unsigned int v19 = operator new(0x38uLL);
  *unsigned int v19 = off_189C132A8;
  v19[1] = (id)v8;
  void v19[2] = "write";
  *unsigned int v19 = off_189C132E0;
  v19[5] = 0LL;
  v19[6] = 0LL;
  v19[4] = 0LL;
  *(void *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v19;
  uint64_t v20 = *(void *)(v8 + 24);
  *(void *)CFStreamError buf = 2LL;
  uint64_t v33 = (uint64_t)PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#1}::__invoke;
  uint64_t v34 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#2}::__invoke;
  int v35 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#3}::__invoke;
  int v36 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFError **,unsigned char *,void *)#1}::__invoke;
  CFTypeID v37 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFError **,void *)#1}::__invoke;
  uint64_t v42 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFString const*,void *)#1}::__invoke;
  CFIndex v43 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFString const*,void const*,void *)#1}::__invoke;
  CFStringRef v44 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,unsigned long,void *)#1}::__invoke;
  sec_identity_t v45 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFRunLoop *,__CFString const*,void *)#1}::__invoke;
  CFStringRef v46 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,__CFRunLoop *,__CFString const*,void *)#2}::__invoke;
  uint64_t v38 = PerSide_CFReadStream::fillinCB(CFReadStreamCallBacks *)::{lambda(__CFReadStream *,unsigned char *,long,__CFError **,unsigned char *,void *)#1}::__invoke;
  unsigned int v39 = 0LL;
  uint64_t v40 = PerSide_CFReadStream::fillinCB(CFReadStreamCallBacks *)::{lambda(__CFReadStream *,__CFError **,void *)#1}::__invoke;
  uint64_t v41 = PerSide<__CFReadStream *,CFReadStreamCallBacks>::fillinCB(CFReadStreamCallBacks*)::{lambda(__CFReadStream *,void *)#4}::__invoke;
  BOOL v21 = (const void *)CFReadStreamCreate();
  *(void *)(v20 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v21;
  uint64_t v22 = v21 ? (__CFReadStream *)CFRetain(v21) : 0LL;
  uint64_t v23 = *(void *)(v8 + 32);
  *(void *)CFStreamError buf = 2LL;
  uint64_t v33 = (uint64_t)PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#1}::__invoke;
  uint64_t v34 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#2}::__invoke;
  int v35 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#3}::__invoke;
  int v36 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFError **,unsigned char *,void *)#1}::__invoke;
  CFTypeID v37 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFError **,void *)#1}::__invoke;
  uint64_t v40 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,void *)#4}::__invoke;
  uint64_t v41 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFString const*,void *)#1}::__invoke;
  uint64_t v42 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFString const*,void const*,void *)#1}::__invoke;
  CFIndex v43 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,unsigned long,void *)#1}::__invoke;
  CFStringRef v44 = (void (*)(uint64_t, uint64_t, uint64_t))PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFRunLoop *,__CFString const*,void *)#1}::__invoke;
  sec_identity_t v45 = PerSide<__CFWriteStream *,CFWriteStreamCallBacks>::fillinCB(CFWriteStreamCallBacks*)::{lambda(__CFWriteStream *,__CFRunLoop *,__CFString const*,void *)#2}::__invoke;
  uint64_t v38 = PerSide_CFWriteStream::fillinCB(CFWriteStreamCallBacks *)::{lambda(__CFWriteStream *,unsigned char const*,long,__CFError **,void *)#1}::__invoke;
  unsigned int v39 = PerSide_CFWriteStream::fillinCB(CFWriteStreamCallBacks *)::{lambda(__CFWriteStream *,__CFError **,void *)#1}::__invoke;
  CFAllocatorRef v24 = (const void *)CFWriteStreamCreate();
  *(void *)(v23 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v24;
  uint64_t v25 = v24 ? (__CFWriteStream *)CFRetain(v24) : 0LL;

  if (!v22 || !v25)
  {
LABEL_26:
    nw_connection_cancel((nw_connection_t)v3);
    goto LABEL_27;
  }

  HTTPServer::newConnectionWithStreams(*(dispatch_object_s ***)(v2 + 64), v22, v25);
  CFRelease(v25);
  CFRelease(v22);
LABEL_27:
  nw_release(*(void **)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
}

void sub_182A5811C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  *unsigned int v11 = off_189C19AE8;
  operator delete(v11);
  _Unwind_Resume(a1);
}

uint64_t ___ZN20HTTPServerService_NW15listenerStartedEP8Listener_block_invoke( int a1, dispatch_semaphore_t dsema)
{
  return dispatch_semaphore_signal(dsema);
}

uint64_t ___ZN8Listener5startEv_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, 1LL);
}

void HTTPServerSSLSettings::~HTTPServerSSLSettings(HTTPServerSSLSettings *this)
{
  *(void *)this = off_189C0ABF0;
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C0ABF0;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

void Listener::~Listener(Listener *this)
{
  *(void *)this = off_189C04D38;
  *((void *)this + 3) = &unk_189C04D90;
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = off_189C19AE8;
}

{
  uint64_t v2;
  *(void *)this = off_189C04D38;
  *((void *)this + 3) = &unk_189C04D90;
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *((void *)this + 3) = off_189C19AE8;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t Listener::operator CoreLoggable *(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  if (v1) {
    return v1 + 56;
  }
  else {
    return 0LL;
  }
}

const void *Listener::_getProperty(Listener *this, const __CFString *a2)
{
  uint64_t v2 = *((void *)this + 8);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = (const void *)(*(uint64_t (**)(uint64_t, const __CFString *))(*(void *)v2 + 64LL))(v2, a2);
  uint64_t v4 = v3;
  if (v3) {
    CFAutorelease(v3);
  }
  return v4;
}

void non-virtual thunk to'Listener::~Listener(Listener *this)
{
  *((void *)this - 3) = off_189C04D38;
  *(void *)this = &unk_189C04D90;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)this = off_189C19AE8;
}

{
  char *v2;
  uint64_t v3;
  *((void *)this - 3) = off_189C04D38;
  uint64_t v2 = (char *)this - 24;
  *(void *)this = &unk_189C04D90;
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  *(void *)this = off_189C19AE8;
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

void CoreWriteStreamClient::coreStreamEventsAvailable(CoreWriteStreamClient *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((void *)this + 1) && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
    if (!v2) {
      return;
    }
  }

  else if (!a2)
  {
    return;
  }

  uint64_t v4 = 1LL;
  do
  {
    if ((v4 & ~v2) == 0)
    {
      (*(void (**)(CoreWriteStreamClient *, void, uint64_t))(*(void *)this + 56LL))( this,  *((void *)this + 1),  v4);
      v2 &= ~v4;
    }

    v4 *= 2LL;
  }

  while (v2);
}

uint64_t CoreStreamClient::coreStreamClientCopyCFStreamRef(CoreStreamClient *this)
{
  return 0LL;
}

void ___ZN15CoreWriteStream5ClassEv_block_invoke()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "CoreWriteStream");
  CoreWriteStream::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182A58464(_Unwind_Exception *a1)
{
}

CFWriteStreamRef CoreWriteStreamFromCFWriteStream::streamSetClient( CFWriteStreamRef *this, CFOptionFlags a2, CoreStreamClient *a3)
{
  if (a3)
  {
    clientContext.version = 0LL;
    clientContext.mach_timebase_info info = this;
    clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
    clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
    CFWriteStreamSetClient( this[16],  a2,  (CFWriteStreamClientCallBack)CoreWriteStreamFromCFWriteStream::_writeStreamClientCallBack,  &clientContext);
    return (CFWriteStreamRef)CoreStreamBase::streamSetClient((uint64_t)this, a2, a3);
  }

  else
  {
    CFWriteStreamSetClient(this[16], 0LL, 0LL, 0LL);
    CFWriteStreamRef result = this[2];
    this[2] = 0LL;
    if (result) {
      return (CFWriteStreamRef)(*(uint64_t (**)(CFWriteStreamRef))(*(void *)result + 24LL))(result);
    }
  }

  return result;
}

CFIndex CoreWriteStreamFromCFWriteStream::_streamImpl_Write( CFWriteStreamRef *this, const unsigned __int8 *a2, CFIndex a3, CFStreamError *a4)
{
  if (!a4) {
    return CFWriteStreamWrite(this[16], a2, a3);
  }
  a4->CFIndex domain = 0LL;
  a4->CFErrorRef error = 0;
  CFIndex v6 = CFWriteStreamWrite(this[16], a2, a3);
  if (CFWriteStreamGetStatus(this[16]) == kCFStreamStatusError)
  {
    __int16 v7 = this[16];
    if (v7 && (uint64_t v8 = CFWriteStreamCopyError(v7)) != 0LL)
    {
      uint64_t v9 = v8;
      CFIndex v10 = _CFStreamErrorFromCFError(v8);
      uint64_t v12 = v11;
      CFRelease(v9);
    }

    else
    {
      uint64_t v12 = 0LL;
      CFIndex v10 = 0LL;
    }

    a4->CFIndex domain = v10;
    *(void *)&a4->CFErrorRef error = v12;
  }

  else
  {
    a4->CFErrorRef error = 0;
    a4->CFIndex domain = 0LL;
  }

  return v6;
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_CanWrite(CFWriteStreamRef *this)
{
  return CFWriteStreamCanAcceptBytes(this[16]);
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_SetProperty( CFWriteStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFWriteStreamSetProperty(this[16], a2, a3);
}

CFTypeRef CoreWriteStreamFromCFWriteStream::_streamImpl_CopyProperty( CFWriteStreamRef *this, const __CFString *a2)
{
  return CFWriteStreamCopyProperty(this[16], a2);
}

uint64_t CoreWriteStreamFromCFWriteStream::_streamImpl_Open( CoreWriteStreamFromCFWriteStream *this, unint64_t a2, BOOL *a3)
{
  if (a2)
  {
    *(void *)a2 = 0LL;
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 0;
  }

  if (a3) {
    *a3 = 0;
  }
  *((_BYTE *)this + 136) = CFWriteStreamOpen(*((CFWriteStreamRef *)this + 16));
  if (a2 | (unint64_t)a3)
  {
    CFStreamStatus Status = CFWriteStreamGetStatus(*((CFWriteStreamRef *)this + 16));
    if (a3) {
      *a3 = Status > kCFStreamStatusOpening;
    }
    if (a2 && Status == kCFStreamStatusError)
    {
      __int16 v7 = (__CFWriteStream *)*((void *)this + 16);
      if (v7 && (uint64_t v8 = CFWriteStreamCopyError(v7)) != 0LL)
      {
        uint64_t v9 = v8;
        CFIndex v10 = _CFStreamErrorFromCFError(v8);
        uint64_t v12 = v11;
        CFRelease(v9);
      }

      else
      {
        uint64_t v12 = 0LL;
        CFIndex v10 = 0LL;
      }

      *(void *)a2 = v10;
      *(void *)(a2 + _Block_object_dispose(va, 8) = v12;
    }
  }

  return *((unsigned __int8 *)this + 136);
}

BOOL CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted(CFWriteStreamRef *this, CFStreamError *a2)
{
  CFStreamStatus Status = CFWriteStreamGetStatus(this[16]);
  uint64_t v5 = Status;
  if (a2)
  {
    if (Status == kCFStreamStatusError)
    {
      CFIndex v6 = this[16];
      if (v6 && (__int16 v7 = CFWriteStreamCopyError(v6)) != 0LL)
      {
        uint64_t v8 = v7;
        CFIndex v9 = _CFStreamErrorFromCFError(v7);
        uint64_t v11 = v10;
        CFRelease(v8);
      }

      else
      {
        uint64_t v11 = 0LL;
        CFIndex v9 = 0LL;
      }

      a2->CFIndex domain = v9;
      *(void *)&a2->CFErrorRef error = v11;
    }

    else
    {
      a2->CFIndex domain = 0LL;
      a2->CFErrorRef error = 0;
    }
  }

  return v5 > 1;
}

void CoreWriteStreamFromCFWriteStream::_streamImpl_Close(CoreWriteStreamFromCFWriteStream *this)
{
  if (*((_BYTE *)this + 136))
  {
    if (!*((_BYTE *)this + 137))
    {
      *((_BYTE *)this + 137) = 1;
      CFWriteStreamClose(*((CFWriteStreamRef *)this + 16));
    }
  }

void CoreWriteStreamFromCFWriteStream::_streamImpl_UpdateScheduling( __CFWriteStream **this, CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
}

void non-virtual thunk to'CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream( CoreWriteStreamFromCFWriteStream *this)
{
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 8));
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 120));
}

{
  CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream((CoreWriteStreamFromCFWriteStream *)((char *)this - 120));
}

uint64_t non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_SetProperty( CFWriteStreamRef *this, const __CFString *a2, const void *a3)
{
  return CFWriteStreamSetProperty(this[1], a2, a3);
}

CFTypeRef non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_CopyProperty( CFWriteStreamRef *this, const __CFString *a2)
{
  return CFWriteStreamCopyProperty(this[1], a2);
}

uint64_t non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Open( CoreWriteStreamFromCFWriteStream *this, CFStreamError *a2, BOOL *a3)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_Open( (CoreWriteStreamFromCFWriteStream *)((char *)this - 120),  (unint64_t)a2,  a3);
}

BOOL non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted( CFWriteStreamRef *this, CFStreamError *a2)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_OpenCompleted(this - 15, a2);
}

void non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Close( CoreWriteStreamFromCFWriteStream *this)
{
  if (*((_BYTE *)this + 16))
  {
    if (!*((_BYTE *)this + 17))
    {
      *((_BYTE *)this + 17) = 1;
      CFWriteStreamClose(*((CFWriteStreamRef *)this + 1));
    }
  }

CFIndex non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_Write( CFWriteStreamRef *this, const unsigned __int8 *a2, CFIndex a3, CFStreamError *a4)
{
  return CoreWriteStreamFromCFWriteStream::_streamImpl_Write(this - 15, a2, a3, a4);
}

uint64_t non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_CanWrite(CFWriteStreamRef *this)
{
  return CFWriteStreamCanAcceptBytes(this[1]);
}

void non-virtual thunk to'CoreWriteStreamFromCFWriteStream::_streamImpl_UpdateScheduling( __CFWriteStream **this, CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
}

void CoreWriteStreamFromCFWriteStream::~CoreWriteStreamFromCFWriteStream( CoreWriteStreamFromCFWriteStream *this)
{
  *(void *)this = &off_189C04F80;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C05018;
  uint64_t v2 = (const void *)*((void *)this + 16);
  *((void *)this + 15) = &unk_189C05038;
  *((void *)this + CFRetain((char *)this - 16) = 0LL;
  if (v2) {
    CFRelease(v2);
  }
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_182A588CC(_Unwind_Exception *a1)
{
}

void CoreWriteStreamFromCFWriteStream::_writeStreamClientCallBack( CoreWriteStreamFromCFWriteStream *this, uint64_t a2, CoreStreamBase *a3, void *a4)
{
  if (a2 == 8)
  {
    if (this && (uint64_t v5 = CFWriteStreamCopyError(this)) != 0LL)
    {
      CFIndex v6 = v5;
      CFIndex v7 = _CFStreamErrorFromCFError(v5);
      uint64_t v9 = v8;
      CFRelease(v6);
    }

    else
    {
      uint64_t v9 = 0LL;
      CFIndex v7 = 0LL;
    }

    uint64_t v10 = a3;
    a2 = 8LL;
    v11.CFIndex domain = v7;
    *(void *)&v11.CFErrorRef error = v9;
  }

  else
  {
    uint64_t v10 = a3;
    v11.CFIndex domain = 0LL;
    *(void *)&v11.CFErrorRef error = 0LL;
  }

  CoreStreamBase::_signalEvent(v10, a2, v11, 1);
}

uint64_t CoreWriteStream::setClient(uint64_t a1, uint64_t a2, uint64_t a3, const CFStreamClientContext *a4)
{
  if (a3)
  {
    uint64_t v8 = a1 - 16;
    CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)(a1 - 16));
    uint64_t v10 = MEMORY[0x186E12804](v9, 96LL, 0LL);
    *(_OWORD *)uint64_t v10 = 0u;
    *(_OWORD *)(v10 + CFRetain((char *)this - 16) = 0u;
    *(_OWORD *)(v10 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
    *(_OWORD *)(v10 + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(v10 + 80) = 0u;
    *(_OWORD *)(v10 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    uint64_t v11 = v10 + 64;
    uint64_t v12 = CFGetAllocator((CFTypeRef)(a1 - 16));
    ClassicStreamClient::ClassicStreamClient((ClassicStreamClient *)v10, v12, a4);
    *(void *)uint64_t v10 = off_189C050F0;
    *(void *)(v10 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C05160;
    *(void *)(v10 + 72) = v8;
    *(void *)(v10 + 80) = v8;
    *(void *)(v10 + 8_Block_object_dispose(va, 8) = a3;
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56LL))(a1, a2, v11);
  if (v11) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v11 + 24LL))(v11);
  }
  return result;
}

void ClassicWriteClient::~ClassicWriteClient(ClassicWriteClient *this)
{
  *((void *)this + 10) = 0LL;
  *((void *)this + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *((void *)this + _Block_object_dispose(va, 8) = off_189C04DF0;
  *((void *)this + 9) = 0LL;
  *(void *)this = off_189C0AEE8;
  if (*((void *)this + 4))
  {
    uint64_t v1 = (void (*)(void))*((void *)this + 6);
    if (v1) {
      v1();
    }
  }

{
  void (*v2)(void);
  *((void *)this + 10) = 0LL;
  *((void *)this + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *((void *)this + _Block_object_dispose(va, 8) = off_189C04DF0;
  *((void *)this + 9) = 0LL;
  *(void *)this = off_189C0AEE8;
  if (*((void *)this + 4))
  {
    uint64_t v2 = (void (*)(void))*((void *)this + 6);
    if (v2) {
      v2();
    }
  }

  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

BOOL ClassicWriteClient::equals(ClassicWriteClient *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

char *ClassicWriteClient::coreStreamClientRetain(ClassicWriteClient *this)
{
  uint64_t v1 = (char *)this + 64;
  (*(void (**)(ClassicWriteClient *))(*(void *)this + 40LL))(this);
  return v1;
}

uint64_t ClassicWriteClient::coreStreamClientRelease(ClassicWriteClient *this)
{
  return (*(uint64_t (**)(ClassicWriteClient *))(*(void *)this + 48LL))(this);
}

uint64_t ClassicWriteClient::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 88))(a2, a3, *(void *)(a1 + 32));
}

void ClassicWriteClient::coreStreamEventsAvailable(ClassicWriteClient *this, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((void *)this + 10) && CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
  {
    dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
    if (!v2) {
      return;
    }
  }

  else if (!a2)
  {
    return;
  }

  uint64_t v4 = 1LL;
  do
  {
    if ((v4 & ~v2) == 0)
    {
      (*(void (**)(ClassicWriteClient *, void, uint64_t))(*(void *)this + 80LL))( this,  *((void *)this + 10),  v4);
      v2 &= ~v4;
    }

    v4 *= 2LL;
  }

  while (v2);
}

void non-virtual thunk to'ClassicWriteClient::~ClassicWriteClient(ClassicWriteClient *this)
{
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *(void *)this = off_189C04DF0;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  *((void *)this - _Block_object_dispose(va, 8) = off_189C0AEE8;
  if (*((void *)this - 4))
  {
    uint64_t v1 = (void (*)(void))*((void *)this - 2);
    if (v1) {
      v1(*((void *)this - 4));
    }
  }

{
  ClassicWriteClient::~ClassicWriteClient((ClassicWriteClient *)((char *)this - 64));
}

ClassicWriteClient *non-virtual thunk to'ClassicWriteClient::coreStreamClientRetain( ClassicWriteClient *this)
{
  return this;
}

uint64_t non-virtual thunk to'ClassicWriteClient::coreStreamClientRelease(ClassicWriteClient *this)
{
  return (*(uint64_t (**)(char *))(*((void *)this - 8) + 48LL))((char *)this - 64);
}

CFStringRef non-virtual thunk to'ClassicWriteClient::coreStreamClientCopyDescription( ClassicWriteClient *this)
{
  return ClassicStreamClient::clientCopyDescription((ClassicWriteClient *)((char *)this - 64));
}

void non-virtual thunk to'ClassicWriteClient::coreStreamEventsAvailable( ClassicWriteClient *this, uint64_t a2)
{
}

uint64_t non-virtual thunk to'ClassicWriteClient::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return ClassicWriteClient::coreStreamWriteEvent(a1 - 64, a2, a3);
}

uint64_t CoreWriteStreamCreate(uint64_t a1, __int128 *a2, uint64_t a3)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    uint64_t v6 = Instance + 16;
    *(void *)(Instance + 256) = 0LL;
    *(_OWORD *)(Instance + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 240) = 0u;
    *(_OWORD *)(Instance + 192) = 0u;
    *(_OWORD *)(Instance + 20_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 14os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 112) = 0u;
    *(_OWORD *)(Instance + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
    *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
  }

  *(_DWORD *)(v6 + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)(v6 + 120) = &unk_189C05270;
  *(void *)(v6 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6 + 120;
  *(void *)uint64_t v6 = &off_189C051B0;
  *(void *)(v6 + _Block_object_dispose(va, 8) = &unk_189C05250;
  __int128 v7 = *a2;
  __int128 v8 = a2[1];
  *(_OWORD *)(v6 + 16_Block_object_dispose(va, 8) = a2[2];
  *(_OWORD *)(v6 + 152) = v8;
  *(_OWORD *)(v6 + 136) = v7;
  __int128 v9 = a2[3];
  __int128 v10 = a2[4];
  __int128 v11 = a2[5];
  *(_OWORD *)(v6 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = a2[6];
  *(_OWORD *)(v6 + 2CFRetain((char *)this - 16) = v11;
  *(_OWORD *)(v6 + 200) = v10;
  *(_OWORD *)(v6 + 18os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v9;
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 144);
  if (v12) {
    a3 = v12(v6 - 16, a3);
  }
  *(void *)(v6 + 12_Block_object_dispose(va, 8) = a3;
  return v6 - 16;
}

void sub_182A58DE8(_Unwind_Exception *a1)
{
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_Write( CoreWriteStreamWithCallbacks *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  if (a4)
  {
    a4->CFIndex domain = 0LL;
    a4->CFErrorRef error = 0;
  }

  uint64_t v4 = (uint64_t (*)(char *, const unsigned __int8 *))*((void *)this + 23);
  if (v4) {
    return v4((char *)this - 16, a2);
  }
  else {
    return -1LL;
  }
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_CanWrite(CoreWriteStreamWithCallbacks *this)
{
  uint64_t v1 = (unsigned int (*)(char *, void))*((void *)this + 24);
  return v1 && v1((char *)this - 16, *((void *)this + 16)) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_RequestEvents(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, void))(this + 224);
  if (v2) {
    return v2(this - 16, a2, *(void *)(this + 128));
  }
  return this;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_SetProperty( CoreWriteStreamWithCallbacks *this, const __CFString *a2, const void *a3)
{
  uint64_t v3 = (unsigned int (*)(char *, const __CFString *, const void *, void))*((void *)this + 27);
  return v3 && v3((char *)this - 16, a2, a3, *((void *)this + 16)) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_CopyProperty( CoreWriteStreamWithCallbacks *this, const __CFString *a2)
{
  uint64_t v2 = (uint64_t (*)(char *, const __CFString *, void))*((void *)this + 26);
  if (v2) {
    return v2((char *)this - 16, a2, *((void *)this + 16));
  }
  else {
    return 0LL;
  }
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_Open( CoreWriteStreamWithCallbacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  if (a2)
  {
    a2->CFIndex domain = 0LL;
    a2->CFErrorRef error = 0;
  }

  if (a3) {
    *a3 = 0;
  }
  uint64_t v3 = (unsigned int (*)(char *))*((void *)this + 21);
  return v3 && v3((char *)this - 16) != 0;
}

BOOL CoreWriteStreamWithCallbacks::_streamImpl_OpenCompleted( CoreWriteStreamWithCallbacks *this, CFStreamError *a2)
{
  if (a2)
  {
    a2->CFIndex domain = 0LL;
    a2->CFErrorRef error = 0;
  }

  uint64_t v2 = (unsigned int (*)(char *))*((void *)this + 22);
  return v2 && v2((char *)this - 16) != 0;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_Close(uint64_t this)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t, void))(this + 200);
  if (v1) {
    return v1(this - 16, *(void *)(this + 128));
  }
  return this;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Schedule( uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 232);
  if (v3) {
    return v3(this - 16, a2, a3, *(void *)(this + 128));
  }
  return this;
}

uint64_t CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Unschedule( uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 240);
  if (v3) {
    return v3(this - 16, a2, a3, *(void *)(this + 128));
  }
  return this;
}

void non-virtual thunk to'CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks( CoreWriteStreamWithCallbacks *this)
{
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 8));
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 120));
}

{
  CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks((CoreWriteStreamWithCallbacks *)((char *)this - 120));
}

BOOL non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_SetProperty( CoreWriteStreamWithCallbacks *this, const __CFString *a2, const void *a3)
{
  uint64_t v3 = (unsigned int (*)(char *, const __CFString *, const void *, void))*((void *)this + 12);
  return v3 && v3((char *)this - 136, a2, a3, *((void *)this + 1)) != 0;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_CopyProperty( CoreWriteStreamWithCallbacks *this, const __CFString *a2)
{
  uint64_t v2 = (uint64_t (*)(char *, const __CFString *, void))*((void *)this + 11);
  if (v2) {
    return v2((char *)this - 136, a2, *((void *)this + 1));
  }
  else {
    return 0LL;
  }
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_RequestEvents( uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, void))(this + 104);
  if (v2) {
    return v2(this - 136, a2, *(void *)(this + 8));
  }
  return this;
}

BOOL non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Open( CoreWriteStreamWithCallbacks *this, CFStreamError *a2, unsigned __int8 *a3)
{
  if (a2)
  {
    a2->CFIndex domain = 0LL;
    a2->CFErrorRef error = 0;
  }

  if (a3) {
    *a3 = 0;
  }
  uint64_t v3 = (unsigned int (*)(char *))*((void *)this + 6);
  return v3 && v3((char *)this - 136) != 0;
}

BOOL non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_OpenCompleted( CoreWriteStreamWithCallbacks *this, CFStreamError *a2)
{
  if (a2)
  {
    a2->CFIndex domain = 0LL;
    a2->CFErrorRef error = 0;
  }

  uint64_t v2 = (unsigned int (*)(char *))*((void *)this + 7);
  return v2 && v2((char *)this - 136) != 0;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Close(uint64_t this)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t, void))(this + 80);
  if (v1) {
    return v1(this - 136, *(void *)(this + 8));
  }
  return this;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_Write( CoreWriteStreamWithCallbacks *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  if (a4)
  {
    a4->CFIndex domain = 0LL;
    a4->CFErrorRef error = 0;
  }

  uint64_t v4 = (uint64_t (*)(char *, const unsigned __int8 *))*((void *)this + 8);
  if (v4) {
    return v4((char *)this - 136, a2);
  }
  else {
    return -1LL;
  }
}

BOOL non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_CanWrite( CoreWriteStreamWithCallbacks *this)
{
  uint64_t v1 = (unsigned int (*)(char *, void))*((void *)this + 9);
  return v1 && v1((char *)this - 136, *((void *)this + 1)) != 0;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Schedule( uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 112);
  if (v3) {
    return v3(this - 136, a2, a3, *(void *)(this + 8));
  }
  return this;
}

uint64_t non-virtual thunk to'CoreWriteStreamWithCallbacks::_streamImpl_deprecated_Unschedule( uint64_t this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v3 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, void))(this + 120);
  if (v3) {
    return v3(this - 136, a2, a3, *(void *)(this + 8));
  }
  return this;
}

void CoreWriteStreamWithCallbacks::~CoreWriteStreamWithCallbacks(CoreWriteStreamWithCallbacks *this)
{
  *(void *)this = &off_189C051B0;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C05250;
  *((void *)this + 15) = &unk_189C05270;
  uint64_t v2 = (void (*)(char *, void))*((void *)this + 19);
  if (v2) {
    v2((char *)this - 16, *((void *)this + 16));
  }
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_182A591E8(_Unwind_Exception *a1)
{
}

_OWORD *CoreWriteStreamCreateWithCFWriteStream(const __CFAllocator *a1, __CFWriteStream *a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v4 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v4 = Instance + 1;
    Instance[8] = 0u;
    Instance[9] = 0u;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  *((_DWORD *)v4 + 26) = 0;
  *((void *)v4 + 15) = &unk_189C05038;
  *((void *)v4 + 3) = (char *)v4 + 120;
  *(void *)uint64_t v4 = &off_189C04F80;
  *((void *)v4 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C05018;
  *((void *)v4 + CFRetain((char *)this - 16) = CFRetain(a2);
  *((_WORD *)v4 + 6_Block_object_dispose(va, 8) = 0;
  return v4 - 1;
}

void sub_182A592C4(_Unwind_Exception *a1)
{
}

uint64_t _CFWriteStreamCreateWithCoreStream()
{
  return CFWriteStreamCreate();
}

__CFWriteStream *CoreWriteStreamCFStreamSupport::_stream_create_and_bump_refcount( CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, void *a3)
{
  uint64_t v5 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  CFAllocatorRef v6 = CFGetAllocator(this);
  uint64_t v7 = MEMORY[0x186E12804](v6, 56LL, 0LL);
  *(_OWORD *)uint64_t v7 = 0u;
  *(_OWORD *)(v7 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0u;
  *(void *)(v7 + 4_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(v7 + CFRetain((char *)this - 16) = 0u;
  CFAllocatorRef v8 = CFGetAllocator(this);
  *(void *)uint64_t v7 = off_189C06BF8;
  *(void *)(v7 + _Block_object_dispose(va, 8) = v8;
  *(_DWORD *)(v7 + CFRetain((char *)this - 16) = 1;
  if (((v7 + 16) & 3) != 0) {
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  }
  *(void *)(v7 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C05408;
  *(void *)uint64_t v7 = off_189C05398;
  *(void *)(v7 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = v5;
  *(void *)(v7 + 40) = this;
  *(void *)(v7 + 4_Block_object_dispose(va, 8) = CFRetain(v5);
  (*(void (**)(__CFWriteStream *, uint64_t, uint64_t))(*(void *)a2 + 56LL))(a2, -1LL, v7 + 24);
  (*(void (**)(uint64_t))(*(void *)v7 + 48LL))(v7);
  return a2;
}

void sub_182A59434(_Unwind_Exception *a1)
{
  *(void *)(v1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = off_189C04DF0;
  *(void *)(v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
  _Unwind_Resume(a1);
}

void CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_finalize(uint64_t a1, uint64_t a2)
{
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_copyDescription( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24LL))(a2);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_open( int a1, uint64_t a2, _BYTE *a3, CoreStreamBase *this)
{
  if (a2)
  {
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 0;
    *(void *)a2 = 0LL;
  }

  if (a3)
  {
    *a3 = 0;
    uint64_t v7 = CoreStreamBase::_streamInterface_Open(this);
    if ((_DWORD)v7)
    {
      uint64_t v8 = v7;
      *a3 = (*(uint64_t (**)(char *, uint64_t))(*((void *)this + 15) + 64LL))((char *)this + 120, a2);
      return v8;
    }

    if (!a2) {
      return 0LL;
    }
LABEL_10:
    uint64_t v8 = 0LL;
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
    return v8;
  }

  uint64_t v9 = CoreStreamBase::_streamInterface_Open(this);
  uint64_t v8 = v9;
  if (a2 && !(_DWORD)v9) {
    goto LABEL_10;
  }
  return v8;
}

BOOL CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_openCompleted( int a1, uint64_t a2, CoreStreamBase *this)
{
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (a2)
  {
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = 0;
    *(void *)a2 = 0LL;
    if (Status == 7) {
      *(_OWORD *)a2 = *(_OWORD *)((char *)this + 56);
    }
  }

  return Status > 1;
}

uint64_t CoreWriteStreamCFStreamSupport::_stream_write( CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, void *a6)
{
  if (a4)
  {
    *(void *)a4 = 0LL;
    *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = 0;
  }

  uint64_t v8 = CoreStreamBase::_streamInterface_Write((CoreStreamBase *)a5, (const unsigned __int8 *)a2, (uint64_t)a3);
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)a5);
  if (a4 && Status == 7) {
    *(CFStreamError *)a4 = *(CFStreamError *)((char *)a5 + 56);
  }
  return v8;
}

uint64_t CoreWriteStreamCFStreamSupport::_stream_canWrite( CoreWriteStreamCFStreamSupport *this, __CFWriteStream *a2, void *a3)
{
  uint64_t v4 = CoreStreamBase::_streamInterface_CanWrite(a2);
  if (!(_DWORD)v4)
  {
    uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(a2);
    if (Status == 5 || Status == 7) {
      CFWriteStreamSignalEvent();
    }
  }

  return v4;
}

void CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_close( uint64_t a1, CoreStreamBase *a2)
{
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_copyProperty( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 24) + 40LL))(*(void *)(a3 + 24));
  --*(void *)(a3 + 80);
  return result;
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_setProperty( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a4 + 24) + 32LL))(*(void *)(a4 + 24));
  --*(void *)(a4 + 80);
  return result;
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_requestEvents( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 80LL))(a3);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_schedule( int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Schedule(this, a2, a3);
}

uint64_t CoreStreamCFStreamSupport<__CFWriteStream *,CoreWriteStream>::_stream_unschedule( int a1, __CFRunLoop *a2, const __CFString *a3, os_unfair_lock_s *this)
{
  return CoreStreamBase::_streamInterface_Deprecated_Unschedule(this, a2, a3);
}

void CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport(CoreWriteStreamCFStreamSupport *this)
{
}

{
  const void *v2;
  *(void *)this = off_189C05398;
  *((void *)this + 3) = &unk_189C05408;
  uint64_t v2 = (const void *)*((void *)this + 6);
  *((void *)this + 5) = 0LL;
  *((void *)this + 6) = 0LL;
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 3) = off_189C04DF0;
  *((void *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
}

BOOL CoreWriteStreamCFStreamSupport::equals( CoreWriteStreamCFStreamSupport *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

CFTypeRef CoreWriteStreamCFStreamSupport::coreStreamClientCopyCFStreamRef( CoreWriteStreamCFStreamSupport *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 5);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamClientRetain(CoreWriteStreamCFStreamSupport *this)
{
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRetain(v2);
  }
  return (uint64_t)this + 24;
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamClientRelease(CoreWriteStreamCFStreamSupport *this)
{
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRelease(v2);
  }
  return (*(uint64_t (**)(CoreWriteStreamCFStreamSupport *))(*(void *)this + 48LL))(this);
}

CFStringRef CoreWriteStreamCFStreamSupport::coreStreamClientCopyDescription( CoreWriteStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<write side %p to stream %p>",  *((void *)this + 6),  *((void *)this + 5));
}

uint64_t CoreWriteStreamCFStreamSupport::coreStreamWriteEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CFWriteStreamSignalEvent();
}

void non-virtual thunk to'CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport( CoreWriteStreamCFStreamSupport *this)
{
}

void non-virtual thunk to'CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport( CFAllocatorRef *this)
{
  uint64_t v2 = this - 3;
  CoreWriteStreamCFStreamSupport::~CoreWriteStreamCFStreamSupport((CoreWriteStreamCFStreamSupport *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

CoreWriteStreamCFStreamSupport *non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientRetain( CoreWriteStreamCFStreamSupport *this)
{
  uint64_t v2 = (char *)this - 24;
  (*(void (**)(char *))(*((void *)this - 3) + 40LL))((char *)this - 24);
  uint64_t v3 = (const void *)*((void *)v2 + 6);
  if (v3) {
    CFRetain(v3);
  }
  return this;
}

uint64_t non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientRelease( CoreWriteStreamCFStreamSupport *this)
{
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  return (*(uint64_t (**)(char *))(*((void *)this - 3) + 48LL))((char *)this - 24);
}

CFStringRef non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientCopyDescription( CoreWriteStreamCFStreamSupport *this)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<write side %p to stream %p>",  *((void *)this + 3),  *((void *)this + 2));
}

CFTypeRef non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamClientCopyCFStreamRef( CoreWriteStreamCFStreamSupport *this)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 2);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t non-virtual thunk to'CoreWriteStreamCFStreamSupport::coreStreamWriteEvent( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CoreWriteStreamCFStreamSupport::coreStreamWriteEvent(a1 - 24, a2, a3);
}

void sub_182A59A10(_Unwind_Exception *a1)
{
  *(void *)(v1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = off_189C04DF0;
  *(void *)(v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v9 - 32) = 0LL;
  _Unwind_Resume(a1);
}

uint64_t ___ZL17resumeDataClassesv_block_invoke_3165()
{
  os_log_t v0 = (void *)MEMORY[0x189603FE0];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend( v0,  "setWithObjects:",  v1,  v2,  v3,  v4,  v5,  v6,  objc_opt_class(),  0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    uint64_t v8 = [*(id *)(v1 + 2616) knownSZExtractorImplementations];
    [(id)resumeDataClasses(void)::resumeDataClasses unionSet:v8];
  }

  uint64_t result = objc_opt_class();
  if (result)
  {
    __int128 v11 = (void *)resumeDataClasses(void)::resumeDataClasses;
    gotLoadHelper_x8__OBJC_CLASS___STRemoteExtractor(v10);
    return [v11 addObject:objc_opt_class()];
  }

  return result;
}

void sub_182A5A66C(_Unwind_Exception *a1)
{
}

void sub_182A5A6EC(_Unwind_Exception *a1)
{
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_3245()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(void *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182A5AC28(_Unwind_Exception *a1)
{
}

void NSCFURLProtocolClient::~NSCFURLProtocolClient(NSCFURLProtocolClient *this)
{
  this->var2 = 0LL;
  this->var3 = 0LL;
  this->var0 = (void **)off_189C05478;
  this->var1 = (void **)off_189C19AE8;
}

id NSCFURLProtocolClient::protocolRetainClient(NSCFURLProtocolClient *this)
{
  return this->var2;
}

void NSCFURLProtocolClient::protocolReleaseClient(NSCFURLProtocolClient *this)
{
}

CFStringRef NSCFURLProtocolClient::protocolCopyDescription(NSCFURLProtocolClient *this)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"NSCFURLProtocolClient@%p:%p { %@ }",  this,  this->var2,  this->var2);
}

uint64_t NSCFURLProtocolClient::protocolWasRedirected( NSCFURLProtocolClient *this, NSURLRequest *a2, _CFURLResponse *a3)
{
  return objc_msgSend( this->var2,  "URLProtocol:wasRedirectedToRequest:redirectResponse:",  this->var3,  a2,  +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", a3));
}

void NSCFURLProtocolClient::protocolCacheResponseIsValid( NSCFURLProtocolClient *this, const _CFCachedURLResponse *a2)
{
  id v3 = -[NSCachedURLResponse _initWithCFCachedURLResponse:]( objc_alloc(&OBJC_CLASS___NSCachedURLResponse),  "_initWithCFCachedURLResponse:",  a2);
  [this->var2 URLProtocol:this->var3 cachedResponseIsValid:v3];
}

uint64_t NSCFURLProtocolClient::protocolDidReceiveResponse(NSCFURLProtocolClient *this, _CFURLResponse *a2)
{
  return objc_msgSend( this->var2,  "URLProtocol:didReceiveResponse:cacheStoragePolicy:",  this->var3,  +[NSURLResponse _responseWithCFURLResponse:](NSURLResponse, "_responseWithCFURLResponse:", a2),  *(int *)(-[_CFURLResponse _inner](a2, "_inner") + 72));
}

uint64_t NSCFURLProtocolClient::protocolDidLoadData(NSCFURLProtocolClient *this, const __CFData *a2)
{
  return [this->var2 URLProtocol:this->var3 didLoadData:a2];
}

uint64_t NSCFURLProtocolClient::protocolDidFinishLoading(NSCFURLProtocolClient *this)
{
  return [this->var2 URLProtocolDidFinishLoading:this->var3];
}

uint64_t NSCFURLProtocolClient::protocolDidFail(NSCFURLProtocolClient *this, __CFError *a2)
{
  return [this->var2 URLProtocol:this->var3 didFailWithError:a2];
}

void NSCFURLProtocolClient::protocolDidReceiveAuthenticationChallenge( NSCFURLProtocolClient *this, _CFURLAuthChallenge *a2)
{
  id v3 = +[NSURLAuthenticationChallenge _createAuthenticationChallengeForCFAuthChallenge:sender:]( &OBJC_CLASS___NSURLAuthenticationChallenge,  "_createAuthenticationChallengeForCFAuthChallenge:sender:",  a2,  this->var3);
  [this->var2 URLProtocol:this->var3 didReceiveAuthenticationChallenge:v3];
}

void NSCFURLProtocolClient::protocolReceivedSocketStreamsForUpgradeHeaderAvailable( NSCFURLProtocolClient *this, CFReadStreamRef stream, CFWriteStreamRef a3)
{
  if (stream) {
    CFReadStreamClose(stream);
  }
  if (a3) {
    CFWriteStreamClose(a3);
  }
}

uint64_t NSCFURLProtocolClient::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 152LL))(result, 0LL);
  }
  return result;
}

void non-virtual thunk to'NSCFURLProtocolClient::~NSCFURLProtocolClient(NSCFURLProtocolClient *this)
{
  this->var1 = 0LL;
  this->var2 = 0LL;
  this[-1].var3 = off_189C05478;
  this->var0 = (void **)off_189C19AE8;
}

{
  this->var1 = 0LL;
  this->var2 = 0LL;
  this->var0 = (void **)off_189C19AE8;
  this[-1].var3 = off_189C05478;
  operator delete(&this[-1].var3);
}

CFStringRef ClassicURLConnection::copyDebugDesc(ClassicURLConnection *this)
{
  uint64_t v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0LL, @"<CFURLConnection %p> { request = %@ }", this, *((void *)this + 7));
}

void ClassicURLConnection::start(id *this)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  id v3 = Current;
  if (Current)
  {
    CFRetain(Current);
  }

  else if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFRunLoopGetCurrent() unexpectedly returned NULL",  (uint8_t *)block,  2u);
  }

  CFRetain(this - 2);
  if (!this[5]) {
    ClassicURLConnection::pinThisRunLoop((ClassicURLConnection *)this, v3, (CFRunLoopMode)*MEMORY[0x1896051B0]);
  }
  uint64_t v4 = (void *)[this[7] originalRequest];
  if (v4 && (*(_WORD *)([v4 _inner] + 64) & 4) != 0) {
    (*(void (**)(id))(*(void *)this[3] + 56LL))(this[3]);
  }
  uint64_t v5 = MEMORY[0x1895F87A8];
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN20ClassicURLConnection5startEv_block_invoke;
  v9[3] = &__block_descriptor_48_e39_v16__0__ConnectionClientInterface_____8l;
  v9[4] = this;
  v9[5] = v3;
  CFRetain(this - 2);
  id v6 = this[3];
  v10[0] = v5;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v10[3] = &unk_189C057B0;
  v10[4] = v9;
  v10[5] = this;
  v11[0] = v5;
  v11[1] = 3221225472LL;
  v11[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v11[3] = &unk_189C19878;
  void v11[4] = v10;
  void v11[5] = v6;
  uint64_t v7 = (*(uint64_t (**)(void))(**((void **)v6 + 4) + 64LL))(*((void *)v6 + 4));
  uint64_t v8 = (dispatch_queue_s *)*((void *)v6 + 5);
  block[0] = v5;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v11;
  void block[5] = v7;
  dispatch_async(v8, block);
}

void ClassicURLConnection::useCredential(ClassicURLConnection *this, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  uint64_t v6 = MEMORY[0x1895F87A8];
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  _DWORD v10[2] = ___ZN20ClassicURLConnection13useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke;
  v10[3] = &__block_descriptor_48_e29_v16__0__LoaderInterface_____8l;
  v10[4] = cf;
  v10[5] = a3;
  CFRetain((char *)this - 16);
  uint64_t v7 = *((void *)this + 4);
  v11[0] = v6;
  v11[1] = 3221225472LL;
  v11[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v11[3] = &unk_189C10248;
  void v11[4] = v10;
  void v11[5] = this;
  v12[0] = v6;
  v12[1] = 3221225472LL;
  _DWORD v12[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v12[3] = &unk_189C19878;
  v12[4] = v11;
  v12[5] = v7;
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(v7 + 32) + 64LL))(*(void *)(v7 + 32));
  uint64_t v9 = *(dispatch_queue_s **)(v7 + 40);
  block[0] = v6;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v12;
  void block[5] = v8;
  dispatch_async(v9, block);
}

void ClassicURLConnection::performDefaultHandlingForChallenge(ClassicURLConnection *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v4 = MEMORY[0x1895F87A8];
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _DWORD v8[2] = ___ZN20ClassicURLConnection34performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke;
  void v8[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
  v8[4] = cf;
  CFRetain((char *)this - 16);
  uint64_t v5 = *((void *)this + 4);
  v9[0] = v4;
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v9[3] = &unk_189C10248;
  v9[4] = v8;
  v9[5] = this;
  v10[0] = v4;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v10[3] = &unk_189C19878;
  v10[4] = v9;
  v10[5] = v5;
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(v5 + 32) + 64LL))(*(void *)(v5 + 32));
  uint64_t v7 = *(dispatch_queue_s **)(v5 + 40);
  block[0] = v4;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v10;
  void block[5] = v6;
  dispatch_async(v7, block);
}

void ClassicURLConnection::rejectChallenge(ClassicURLConnection *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v4 = MEMORY[0x1895F87A8];
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _DWORD v8[2] = ___ZN20ClassicURLConnection15rejectChallengeEP19_CFURLAuthChallenge_block_invoke;
  void v8[3] = &__block_descriptor_40_e29_v16__0__LoaderInterface_____8l;
  v8[4] = cf;
  CFRetain((char *)this - 16);
  uint64_t v5 = *((void *)this + 4);
  v9[0] = v4;
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v9[3] = &unk_189C10248;
  v9[4] = v8;
  v9[5] = this;
  v10[0] = v4;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke;
  v10[3] = &unk_189C19878;
  v10[4] = v9;
  v10[5] = v5;
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(v5 + 32) + 64LL))(*(void *)(v5 + 32));
  uint64_t v7 = *(dispatch_queue_s **)(v5 + 40);
  block[0] = v4;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v10;
  void block[5] = v6;
  dispatch_async(v7, block);
}

void ClassicURLConnection::halt(id *this)
{
  if (!(*(unsigned int (**)(id))(*(void *)this[3] + 64LL))(this[3]))
  {
    [this[7] _metrics];
    uint64_t v2 = (os_unfair_lock_s *)this[3];
    os_unfair_lock_lock(v2 + 34);
    LOBYTE(v2[35]._os_unfair_lock_opaque) = 1;
    os_unfair_lock_unlock(v2 + 34);
  }

void ClassicURLConnection::resume(ClassicURLConnection *this)
{
  uint64_t v2 = *((void *)this + 3);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 136));
  *(_BYTE *)(v2 + 140) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 136));
  uint64_t v3 = MEMORY[0x1895F87A8];
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  v7[2] = ___ZN20ClassicURLConnection6resumeEv_block_invoke;
  v7[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
  v7[4] = this;
  CFRetain((char *)this - 16);
  uint64_t v4 = *((void *)this + 3);
  v8[0] = v3;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  void v8[3] = &unk_189C057B0;
  v8[4] = v7;
  void v8[5] = this;
  v9[0] = v3;
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v9[3] = &unk_189C19878;
  v9[4] = v8;
  v9[5] = v4;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v4 + 32) + 64LL))(*(void *)(v4 + 32));
  uint64_t v6 = *(dispatch_queue_s **)(v4 + 40);
  block[0] = v3;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v9;
  void block[5] = v5;
  dispatch_async(v6, block);
}

uint64_t ClassicURLConnection::scheduleWithRunLoop( ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  if (a3) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = (const __CFString *)*MEMORY[0x1896051B0];
  }
  ClassicURLConnection::pinThisRunLoop(this, a2, v5);
  uint64_t v7 = (const CoreSchedulingSet *)CoreSchedulingSet::create((CoreSchedulingSet *)a2, v5, v6);
  ClassicURLConnection::setDelegateScheduling(this, v7);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v7 + 48LL))(v7);
}

void ClassicURLConnection::unscheduleFromRunLoop( ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v4 = (const __CFString *)*MEMORY[0x1896051B0];
  if (a3) {
    uint64_t v4 = a3;
  }
  uint64_t v5 = MEMORY[0x1895F87A8];
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN20ClassicURLConnection21unscheduleFromRunLoopEP11__CFRunLoopPK10__CFString_block_invoke;
  v9[3] = &__block_descriptor_48_e39_v16__0__ConnectionClientInterface_____8l;
  v9[4] = a2;
  v9[5] = v4;
  CFRetain((char *)this - 16);
  uint64_t v6 = *((void *)this + 3);
  v10[0] = v5;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v10[3] = &unk_189C057B0;
  v10[4] = v9;
  v10[5] = this;
  v11[0] = v5;
  v11[1] = 3221225472LL;
  v11[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v11[3] = &unk_189C19878;
  void v11[4] = v10;
  void v11[5] = v6;
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(v6 + 32) + 64LL))(*(void *)(v6 + 32));
  uint64_t v8 = *(dispatch_queue_s **)(v6 + 40);
  block[0] = v5;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v11;
  void block[5] = v7;
  dispatch_async(v8, block);
}

uint64_t ClassicURLConnection::setDelegateDispatchQueue(CoreSchedulingSet *a1, CoreSchedulingSet *this)
{
  if (this) {
    Empty = CoreSchedulingSet::createWithDispatchQueue(this, this);
  }
  else {
    Empty = (CFAllocatedReferenceCountedObject *)CoreSchedulingSet::createEmpty(a1);
  }
  uint64_t v4 = Empty;
  ClassicURLConnection::setDelegateScheduling((ClassicURLConnection *)a1, (const CoreSchedulingSet *)Empty);
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(void *)v4 + 48LL))(v4);
}

void ClassicURLConnection::scheduleLoaderWithRunLoop( ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v3 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_error_impl( &dword_18298D000,  v3,  OS_LOG_TYPE_ERROR,  "Rescheduling the CFNetwork loader is no longer supported",  v4,  2u);
  }

void ClassicURLConnection::unscheduleLoaderFromRunLoop( ClassicURLConnection *this, __CFRunLoop *a2, const __CFString *a3)
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v3 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_error_impl( &dword_18298D000,  v3,  OS_LOG_TYPE_ERROR,  "Rescheduling the CFNetwork loader is no longer supported",  v4,  2u);
  }

void ClassicURLConnection::updateClientForCFURLDownload_sync(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = dispatch_semaphore_create(0LL);
  uint64_t v5 = MEMORY[0x1895F87A8];
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN20ClassicURLConnection33updateClientForCFURLDownload_syncEP24CFURLConnectionClient_V1_block_invoke;
  v9[3] = &unk_189C05740;
  v9[4] = v4;
  v9[5] = a2;
  CFRetain((CFTypeRef)(a1 - 16));
  uint64_t v6 = *(void *)(a1 + 24);
  v10[0] = v5;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v10[3] = &unk_189C057B0;
  v10[4] = v9;
  v10[5] = a1;
  v11[0] = v5;
  v11[1] = 3221225472LL;
  v11[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v11[3] = &unk_189C19878;
  void v11[4] = v10;
  void v11[5] = v6;
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(v6 + 32) + 64LL))(*(void *)(v6 + 32));
  uint64_t v8 = *(dispatch_queue_s **)(v6 + 40);
  block[0] = v5;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v11;
  void block[5] = v7;
  dispatch_async(v8, block);
  dispatch_semaphore_wait(v4, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v4);
}

uint64_t ClassicURLConnection::canUpdateForCFURLDownload(ClassicURLConnection *this)
{
  uint64_t v10 = 0LL;
  __int128 v11 = &v10;
  uint64_t v12 = 0x2020000000LL;
  char v13 = 0;
  uint64_t v2 = dispatch_semaphore_create(0LL);
  uint64_t v3 = MEMORY[0x1895F87A8];
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN20ClassicURLConnection25canUpdateForCFURLDownloadEv_block_invoke;
  v9[3] = &unk_189C05768;
  v9[4] = v2;
  v9[5] = &v10;
  CFRetain((char *)this - 16);
  uint64_t v4 = *((void *)this + 3);
  v14[0] = v3;
  v14[1] = 3221225472LL;
  unsigned __int8 v14[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v14[3] = &unk_189C057B0;
  void v14[4] = v9;
  v14[5] = this;
  v15[0] = v3;
  v15[1] = 3221225472LL;
  v15[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  void v15[3] = &unk_189C19878;
  v15[4] = v14;
  void v15[5] = v4;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v4 + 32) + 64LL))(*(void *)(v4 + 32));
  uint64_t v6 = *(dispatch_queue_s **)(v4 + 40);
  block[0] = v3;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v15;
  void block[5] = v5;
  dispatch_async(v6, block);
  dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v2);
  uint64_t v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_182A5BB6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

CFTypeRef ClassicURLConnection::copyPeerAddress(ClassicURLConnection *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = (os_unfair_lock_s *)(v1 + 208);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 208));
  uint64_t v3 = *(const void **)(v1 + 200);
  if (v3) {
    CFTypeRef v4 = CFRetain(v3);
  }
  else {
    CFTypeRef v4 = 0LL;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

void ClassicURLConnection::cancel(ClassicURLConnection *this)
{
  if (!(*(unsigned int (**)(void))(**((void **)this + 3) + 40LL))(*((void *)this + 3)))
  {
    uint64_t v2 = MEMORY[0x1895F87A8];
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    v6[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke;
    void v6[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
    v6[4] = this;
    CFRetain((char *)this - 16);
    uint64_t v3 = *((void *)this + 3);
    v7[0] = v2;
    v7[1] = 3221225472LL;
    v7[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
    v7[3] = &unk_189C057B0;
    v7[4] = v6;
    void v7[5] = this;
    v8[0] = v2;
    v8[1] = 3221225472LL;
    _DWORD v8[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
    void v8[3] = &unk_189C19878;
    v8[4] = v7;
    void v8[5] = v3;
    uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(v3 + 32) + 64LL))(*(void *)(v3 + 32));
    uint64_t v5 = *(dispatch_queue_s **)(v3 + 40);
    block[0] = v2;
    block[1] = 3221225472LL;
    block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
    block[3] = &unk_189C19878;
    block[4] = v8;
    void block[5] = v4;
    dispatch_async(v5, block);
  }

id ClassicURLConnection::copyOriginalImmutableRequest(id *this)
{
  return (id)[this[7] originalRequest];
}

uint64_t ClassicURLConnection::loaderClientSupportsDispatchData(ClassicURLConnection *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 24LL))(*((void *)this + 3));
}

void ClassicURLConnection::withLoaderClientAsync(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = MEMORY[0x1895F87A8];
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _DWORD v8[2] = ___ZN20ClassicURLConnection21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke;
  void v8[3] = &unk_189C057D8;
  v8[4] = a2;
  void v8[5] = a1;
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN19URLConnectionClient21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke;
  v9[3] = &unk_189C19878;
  v9[4] = v8;
  v9[5] = v4;
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(v4 + 32) + 64LL))(*(void *)(v4 + 32));
  uint64_t v7 = *(dispatch_queue_s **)(v4 + 40);
  block[0] = v5;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v9;
  void block[5] = v6;
  dispatch_async(v7, block);
}

void non-virtual thunk to'ClassicURLConnection::~ClassicURLConnection(ClassicURLConnection *this)
{
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 8));
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 16));
}

{
  ClassicURLConnection::~ClassicURLConnection((ClassicURLConnection *)((char *)this - 16));
}

id non-virtual thunk to'ClassicURLConnection::copyOriginalImmutableRequest(id *this)
{
  return (id)[this[6] originalRequest];
}

CFStringRef non-virtual thunk to'ClassicURLConnection::copyDebugDesc(ClassicURLConnection *this)
{
  uint64_t v2 = (char *)this - 8;
  uint64_t v3 = CFGetAllocator((char *)this - 24);
  return CFStringCreateWithFormat(v3, 0LL, @"<CFURLConnection %p> { request = %@ }", v2, *((void *)this + 6));
}

uint64_t non-virtual thunk to'ClassicURLConnection::loaderClientSupportsDispatchData( ClassicURLConnection *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 2) + 24LL))(*((void *)this + 2));
}

void non-virtual thunk to'ClassicURLConnection::withLoaderClientAsync(uint64_t a1, uint64_t a2)
{
}

void non-virtual thunk to'ClassicURLConnection::cancel(ClassicURLConnection *this)
{
}

void ClassicURLConnection::~ClassicURLConnection(ClassicURLConnection *this)
{
  *(void *)this = &off_189C05578;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C05668;
  *((void *)this + 2) = &unk_189C056C8;
  uint64_t v2 = *((void *)this + 4);
  if (v2 && !*(_BYTE *)(v2 + 25) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFStreamError buf = 0;
    _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "loader not invalidated", buf, 2u);
  }

  uint64_t v3 = *((void *)this + 3);
  if (v3 && !*(_BYTE *)(v3 + 25) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "client not invalidated", v6, 2u);
  }

  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }

  *((void *)this + 2) = off_189C19AE8;
}

void sub_182A5BF98(_Unwind_Exception *a1)
{
  *(void *)(v1 + CFRetain((char *)this - 16) = off_189C19AE8;
  _Unwind_Resume(a1);
}

void ___ZN20ClassicURLConnection21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionClient21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  CFRetain((CFTypeRef)(v3 - 16));
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke_2;
  v5[3] = &__block_descriptor_40_e5_v8__0l;
  v5[4] = v3;
  if (!(*(unsigned int (**)(uint64_t, dispatch_queue_global_t, void *))(*(void *)a2 + 48LL))( a2,  global_queue,  v5)) {
    CFRelease((CFTypeRef)(v3 - 16));
  }
}

void ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  uint64_t v3 = global_queue;
  uint64_t v4 = (dispatch_object_s **)MEMORY[0x1895F87A8];
  v26[0] = MEMORY[0x1895F87A8];
  v26[1] = 3221225472LL;
  v26[2] = ___ZN20ClassicURLConnection6cancelEv_block_invoke_3;
  v26[3] = &__block_descriptor_40_e5_v8__0l;
  void v26[4] = v1;
  if (!*(void *)(v1 + 32) && !*(void *)(v1 + 24))
  {
    dispatch_async(global_queue, v26);
    return;
  }

  std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>( &v38,  global_queue,  v26);
  if (*(void *)(v1 + 32))
  {
    int v29 = v4;
    uint64_t v30 = 3321888768LL;
    uint64_t v31 = ___ZN20ClassicURLConnection25invalidateConnectionAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke;
    unsigned int v32 = &__block_descriptor_56_e8_40c51_ZTSNSt3__110shared_ptrI23CoreSchedulingSetOneOffEE_e5_v8__0l;
    uint64_t v33 = v1;
    uint64_t v34 = v38;
    int v35 = v39;
    if (v39)
    {
      p_shared_owners = (unint64_t *)&v39->__shared_owners_;
      do
        unint64_t v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }

    std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject  {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>( &v36,  v3,  &v29);
    uint64_t v7 = *(void *)(v1 + 32);
    objc_super v27 = v36;
    uint64_t v28 = v37;
    if (v37)
    {
      uint64_t v8 = (unint64_t *)&v37->__shared_owners_;
      do
        unint64_t v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }

    (*(void (**)(uint64_t, dispatch_object_s ***))(*(void *)v7 + 16LL))(v7, &v27);
    uint64_t v10 = v28;
    if (v28)
    {
      __int128 v11 = (unint64_t *)&v28->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    char v13 = v37;
    if (v37)
    {
      uint64_t v14 = (unint64_t *)&v37->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    BOOL v16 = v35;
    if (!v35) {
      goto LABEL_32;
    }
    uint64_t v17 = (unint64_t *)&v35->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
  }

  else
  {
    uint64_t v19 = *(void *)(v1 + 24);
    int v29 = v38;
    uint64_t v30 = (uint64_t)v39;
    if (v39)
    {
      uint64_t v20 = (unint64_t *)&v39->__shared_owners_;
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }

    (*(void (**)(uint64_t, dispatch_object_s ***))(*(void *)v19 + 16LL))(v19, &v29);
    BOOL v16 = (std::__shared_weak_count *)v30;
    if (!v30) {
      goto LABEL_32;
    }
    uint64_t v22 = (unint64_t *)(v30 + 8);
    do
      unint64_t v18 = __ldaxr(v22);
    while (__stlxr(v18 - 1, v22));
  }

  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }

void sub_182A5C318( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  if (a17)
  {
    p_shared_owners = (unint64_t *)&a17->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(p_shared_owners);
    while (__stlxr(v25 - 1, p_shared_owners));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a17->__on_zero_shared)(a17);
      std::__shared_weak_count::__release_weak(a17);
    }
  }

  int v26 = *(std::__shared_weak_count **)(v22 - 40);
  if (v26)
  {
    objc_super v27 = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  _Unwind_Resume(exception_object);
}

void ___ZN20ClassicURLConnection6cancelEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(__CFRunLoopSource **)(v1 + 40);
  if (v2)
  {
    CFRunLoopSourceInvalidate(v2);
    uint64_t v3 = *(const void **)(v1 + 40);
    *(void *)(v1 + 40) = 0LL;
    if (v3) {
      CFRelease(v3);
    }
    uint64_t v4 = *(__CFRunLoop **)(v1 + 48);
    if (v4)
    {
      CFRunLoopWakeUp(v4);
      uint64_t v5 = *(const void **)(v1 + 48);
      *(void *)(v1 + 4_Block_object_dispose(va, 8) = 0LL;
      if (v5) {
        CFRelease(v5);
      }
    }
  }

  CFRelease((CFTypeRef)(v1 - 16));
}

dispatch_object_s *std::allocate_shared[abi:nn180100]<CoreSchedulingSetOneOff,std::allocator<CoreSchedulingSetOneOff>,NSObject {objcproto17OS_dispatch_queue}*&,void({block_pointer}&)(void),void>( dispatch_object_s ***a1, dispatch_object_s *a2, const void *a3)
{
  unint64_t v6 = (dispatch_object_s **)operator new(0x28uLL);
  v6[1] = 0LL;
  v6[2] = 0LL;
  *unint64_t v6 = (dispatch_object_s *)off_189C10E98;
  uint64_t v7 = v6 + 3;
  if (a2) {
    dispatch_retain(a2);
  }
  dispatch_queue_s *v7 = a2;
  if (a3) {
    uint64_t result = (dispatch_object_s *)_Block_copy(a3);
  }
  else {
    uint64_t result = 0LL;
  }
  v6[4] = result;
  *a1 = v7;
  a1[1] = v6;
  return result;
}

void sub_182A5C508(_Unwind_Exception *a1)
{
}

void ___ZN20ClassicURLConnection25invalidateConnectionAsyncEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvvE_block_invoke( void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = *(void *)(a1[4] + 24LL);
  uint64_t v4 = (std::__shared_weak_count *)a1[6];
  uint64_t v10 = v2;
  __int128 v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 16LL))(v3, &v10);
  uint64_t v7 = v11;
  if (v11)
  {
    uint64_t v8 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

void sub_182A5C5B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__shared_ptr_emplace<CoreSchedulingSetOneOff>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C10E98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<CoreSchedulingSetOneOff>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C10E98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t ___ZN20ClassicURLConnection25canUpdateForCFURLDownloadEv_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t ___ZN20ClassicURLConnection33updateClientForCFURLDownload_syncEP24CFURLConnectionClient_V1_block_invoke( uint64_t a1, uint64_t a2)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void ClassicURLConnection::setDelegateScheduling(ClassicURLConnection *this, const CoreSchedulingSet *a2)
{
  uint64_t v4 = MEMORY[0x1895F87A8];
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  _DWORD v8[2] = ___ZN20ClassicURLConnection21setDelegateSchedulingEPK17CoreSchedulingSet_block_invoke;
  void v8[3] = &__block_descriptor_40_e39_v16__0__ConnectionClientInterface_____8l;
  v8[4] = a2;
  CFRetain((char *)this - 16);
  uint64_t v5 = *((void *)this + 3);
  v9[0] = v4;
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN20ClassicURLConnection15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v9[3] = &unk_189C057B0;
  v9[4] = v8;
  v9[5] = this;
  v10[0] = v4;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = ___ZN19URLConnectionClient15withClientAsyncEU13block_pointerFvP25ConnectionClientInterfaceE_block_invoke;
  v10[3] = &unk_189C19878;
  v10[4] = v9;
  v10[5] = v5;
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(v5 + 32) + 64LL))(*(void *)(v5 + 32));
  uint64_t v7 = *(dispatch_queue_s **)(v5 + 40);
  block[0] = v4;
  block[1] = 3221225472LL;
  block[2] = ___ZNK25URLConnectionInstanceData18withWorkQueueAsyncEU13block_pointerFvvE_block_invoke;
  block[3] = &unk_189C19878;
  block[4] = v10;
  void block[5] = v6;
  dispatch_async(v7, block);
}

uint64_t ___ZN20ClassicURLConnection21setDelegateSchedulingEPK17CoreSchedulingSet_block_invoke( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48LL))(*(void *)(a1 + 32));
}

uint64_t ___ZN20ClassicURLConnection21unscheduleFromRunLoopEP11__CFRunLoopPK10__CFString_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32LL))(a2);
  if (!(_DWORD)result)
  {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 64LL))( a2,  CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  }

  return result;
}

void ClassicURLConnection::pinThisRunLoop(ClassicURLConnection *this, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v5 = (__CFRunLoopSource *)*((void *)this + 5);
  if (!v5)
  {
    v8.version = 0LL;
    v8.mach_timebase_info info = (char *)this - 16;
    v8.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
    v8.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
    memset(&v8.copyDescription, 0, 40);
    v8.perform = (void (__cdecl *)(void *))_doNothingPerform;
    uint64_t v7 = CFGetAllocator((char *)this - 16);
    uint64_t v5 = CFRunLoopSourceCreate(v7, 0LL, &v8);
    *((void *)this + 5) = v5;
    if (!*((void *)this + 6))
    {
      *((void *)this + 6) = rl;
      if (rl)
      {
        CFRetain(rl);
        uint64_t v5 = (__CFRunLoopSource *)*((void *)this + 5);
      }
    }
  }

  CFRunLoopAddSource(rl, v5, mode);
}

uint64_t ___ZN20ClassicURLConnection6resumeEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 56) _metrics];
  if (v3) {
    v4.n128_u64[0] = *(void *)(v3 + 56);
  }
  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)a2 + 56LL))(a2, v4);
}

void ___ZN20ClassicURLConnection15rejectChallengeEP19_CFURLAuthChallenge_block_invoke( uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 88LL))(a2, *(void *)(a1 + 32));
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
}

void ___ZN20ClassicURLConnection15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN19URLConnectionLoader15withLoaderAsyncEU13block_pointerFvP15LoaderInterfaceE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___ZN20ClassicURLConnection34performDefaultHandlingForChallengeEP19_CFURLAuthChallenge_block_invoke( uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 72LL))(a2, *(void *)(a1 + 32));
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
}

void ___ZN20ClassicURLConnection13useCredentialEPK16_CFURLCredentialP19_CFURLAuthChallenge_block_invoke( uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 80LL))( a2,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
  }
  uint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
    CFRelease(v3);
  }
  __n128 v4 = *(const void **)(a1 + 40);
  if (v4) {
    CFRelease(v4);
  }
}

void ___ZN20ClassicURLConnection5startEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = [*(id *)(v4 + 56) _metrics];
  if (v5) {
    v6.n128_u64[0] = *(void *)(v5 + 56);
  }
  (*(void (**)(uint64_t, void, void, __n128))(*(void *)a2 + 40LL))( a2,  *(void *)(a1 + 40),  *MEMORY[0x1896051B0],  v6);
  uint64_t v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRelease(v7);
  }
  CFRelease((CFTypeRef)(v4 - 16));
}

uint64_t ClassicURLConnection::getNetworkServiceTypeString(int a1)
{
  switch(a1)
  {
    case 1:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoIP;
      goto LABEL_14;
    case 2:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVideo;
      goto LABEL_14;
    case 3:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeBackground;
      goto LABEL_14;
    case 4:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeVoice;
      goto LABEL_14;
    case 5:
      uint64_t v1 = &kCFStreamNetworkServiceTypeBackgroundSystemInitiated;
      goto LABEL_14;
    case 6:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveData;
      goto LABEL_14;
    case 7:
      uint64_t v1 = &kCFStreamNetworkServiceTypeOAM;
      goto LABEL_14;
    case 8:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeAVStreaming;
      goto LABEL_14;
    case 9:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeResponsiveAV;
      goto LABEL_14;
    case 10:
      uint64_t v1 = &kCFStreamNetworkServiceTypeNetworkControl;
      goto LABEL_14;
    case 11:
      uint64_t v1 = (uint64_t *)&kCFStreamNetworkServiceTypeCallSignaling;
LABEL_14:
      uint64_t result = *v1;
      break;
    default:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

__CFDictionary *createUpdatedSocketPropertiesForRequest( _CFURLRequest *a1, const __CFDictionary *a2, const __CFDictionary *a3)
{
  __n128 v6 = CFGetAllocator(a1);
  uint64_t v7 = v6;
  if (a2) {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v6, 0LL, a2);
  }
  else {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(v6, 0LL, MEMORY[0x189604E40], MEMORY[0x189605250]);
  }
  unint64_t v9 = MutableCopy;
  uint64_t v10 = *(void *)(-[_CFURLRequest _inner](a1, "_inner") + 96);
  uint64_t v11 = allowNewHTTP(void)::onceToken;
  if (v10 == 16) {
    goto LABEL_14;
  }
  int v12 = allowNewHTTP(void)::result;
  if (a3)
  {
    char v13 = (const __CFBoolean *)CFDictionaryGetValue(a3, &unk_18C5B05B0);
    if (v13) {
      int v12 = CFBooleanGetValue(v13);
    }
  }

  if (!v12) {
    CFDictionaryAddValue(v9, &unk_18C5ABB18, (const void *)*MEMORY[0x189604DE8]);
  }
  if (v10 != 64)
  {
    uint64_t v11 = allowNewHTTP(void)::onceToken;
LABEL_14:
    if (v11 != -1) {
      dispatch_once(&allowNewHTTP(void)::onceToken, &__block_literal_global_3282);
    }
    int v14 = allowNewHTTP(void)::result;
    if (a3)
    {
      unint64_t v15 = (const __CFBoolean *)CFDictionaryGetValue(a3, &unk_18C5B05E8);
      if (v15) {
        int v14 = CFBooleanGetValue(v15);
      }
    }

    if (!v14) {
      CFDictionaryAddValue(v9, &unk_18C5ABB50, (const void *)*MEMORY[0x189604DE8]);
    }
  }

  BOOL v16 = *(const __CFString **)(-[_CFURLRequest _inner](a1, "_inner") + 112);
  uint64_t v17 = (CFAllocatorRef *)MEMORY[0x189604DB0];
  if (v16) {
    CFStringRef value = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x189604DB0], v16);
  }
  else {
    CFStringRef value = 0LL;
  }
  NetworkServiceTypeString = (const void *)ClassicURLConnection::getNetworkServiceTypeString(*(_DWORD *)(-[_CFURLRequest _inner](a1, "_inner") + 104));
  __int16 v19 = *(_WORD *)(-[_CFURLRequest _inner](a1, "_inner") + 64);
  if (!a2)
  {
    unint64_t v21 = 0LL;
LABEL_31:
    CFStringRef v23 = 0LL;
    goto LABEL_32;
  }

  uint64_t v20 = (const __CFDictionary *)CFDictionaryGetValue(a2, &unk_18C5AD830);
  unint64_t v21 = v20;
  if (!v20) {
    goto LABEL_31;
  }
  if (CFDictionaryGetValue(v20, @"kConditionalConnectionIdentifier")) {
    goto LABEL_31;
  }
  if (!CFDictionaryGetValue(v21, @"kConditionalConnectionLaunchOnDemand")) {
    goto LABEL_31;
  }
  uint64_t v22 = *(const __CFURL **)(-[_CFURLRequest _inner](a1, "_inner") + 8);
  if (!v22) {
    goto LABEL_31;
  }
  CFStringRef v23 = CFURLGetString(v22);
LABEL_32:
  double v24 = *(double *)(-[_CFURLRequest _inner](a1, "_inner") + 136);
  double valuePtr = v24;
  double v25 = *(double *)(-[_CFURLRequest _inner](a1, "_inner") + 144);
  double v46 = v25;
  if (NetworkServiceTypeString || value || (v19 & 8) == 0 || v23)
  {
    if (!v9) {
      goto LABEL_66;
    }
    if (NetworkServiceTypeString) {
      CFDictionarySetValue(v9, &unk_18C5AD440, NetworkServiceTypeString);
    }
    if (value) {
      CFDictionarySetValue(v9, &unk_18C5AD7F8, value);
    }
    if ((v19 & 8) == 0) {
      CFDictionarySetValue(v9, &unk_18C5ADC20, (const void *)*MEMORY[0x189604DE8]);
    }
    if (v23) {
      goto LABEL_50;
    }
  }

  else if (v24 == 0.0 || v25 == 0.0 || !v9)
  {
    goto LABEL_66;
  }

  if (v24 == 0.0 || v25 == 0.0) {
    goto LABEL_66;
  }
LABEL_50:
  if (v21) {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutableCopy(v7, 0LL, v21);
  }
  else {
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v7, 0LL, MEMORY[0x189604E40], MEMORY[0x189605250]);
  }
  objc_super v27 = Mutable;
  if (Mutable)
  {
    if (v23) {
      CFDictionarySetValue(Mutable, @"kConditionalConnectionIdentifier", v23);
    }
    if (v24 == 0.0 || v25 == 0.0) {
      goto LABEL_65;
    }
    CFNumberRef v28 = CFNumberCreate(v7, kCFNumberDoubleType, &valuePtr);
    CFNumberRef v29 = CFNumberCreate(v7, kCFNumberDoubleType, &v46);
    CFNumberRef v30 = v29;
    if (v28 && v29)
    {
      CFDictionarySetValue(v27, @"kConditionalConnectionRequirementTimeWindowDelay", v28);
      CFDictionarySetValue(v27, @"kConditionalConnectionRequirementTimeWindowDuration", v30);
    }

    else if (!v28)
    {
      goto LABEL_63;
    }

    CFRelease(v28);
LABEL_63:
    if (v30) {
      CFRelease(v30);
    }
LABEL_65:
    CFDictionarySetValue(v9, &unk_18C5AD830, v27);
    CFRelease(v27);
  }

uint64_t ___ZL12allowNewHTTPv_block_invoke()
{
  uint64_t result = _CFGetProgname();
  if (result)
  {
    uint64_t v1 = *(const char **)result;
    if (*(void *)result)
    {
      uint64_t result = strncmp(*(const char **)result, "com.apple.WebKit", 0x10uLL);
      if ((_DWORD)result && (uint64_t result = strcmp(v1, "MobileSafari"), (_DWORD)result))
      {
        uint64_t result = strncmp(v1, "com.apple.Safari", 0x10uLL);
        BOOL v2 = (_DWORD)result == 0;
      }

      else
      {
        BOOL v2 = 1;
      }

      allowNewHTTP(void)::uint64_t result = v2;
    }
  }

  return result;
}

void sub_182A5DB38(_Unwind_Exception *a1)
{
}

void sub_182A5DC14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_182A5EBE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void SessionConnectionLoadable::~SessionConnectionLoadable(SessionConnectionLoadable *this)
{
  this->var0 = (void **)off_189C05C10;
  this->var1 = (void **)&unk_189C05D10;
  this->var2 = (void **)off_189C19AE8;
}

id SessionConnectionLoadable::copyOriginalImmutableRequest(SessionConnectionLoadable *this, const char *a2)
{
  id var3 = this->var3;
  if (var3) {
    id var3 = objc_getProperty(var3, a2, 8LL, 1);
  }
  return (id)[var3 originalRequest];
}

const void *SessionConnectionLoadable::copyDebugDesc(SessionConnectionLoadable *this)
{
  uint64_t v1 = (const void *)[this->var3 description];
  uint64_t v2 = v1;
  if (v1) {
    CFRetain(v1);
  }
  return v2;
}

uint64_t SessionConnectionLoadable::cancel(SessionConnectionLoadable *this)
{
  return [this->var3 cancel];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3) {
    id v7 = +[NSURLResponse _responseWithCFURLResponse:](&OBJC_CLASS___NSHTTPURLResponse, "_responseWithCFURLResponse:");
  }
  else {
    id v7 = 0LL;
  }
  CFRunLoopSourceContext v8 = *(void **)(a1 + 24);
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  _DWORD v10[2] = ___ZN25SessionConnectionLoadable48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke;
  v10[3] = &unk_189C0B6C0;
  v10[4] = a4;
  return [v8 _redirectRequest:a2 redirectResponse:v7 completion:v10];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidReceiveChallenge( SessionConnectionLoadable *this, _CFURLAuthChallenge *a2)
{
  return objc_msgSend( this->var3,  "_didReceiveChallenge:",  +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:]( NSURLAuthenticationChallenge,  "_authenticationChallengeForCFAuthChallenge:sender:",  a2,  this->var3));
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStream(SessionConnectionLoadable *this)
{
  return [this->var3 _needNewBodyStream];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStreamFromOffset( SessionConnectionLoadable *this, uint64_t a2)
{
  return [this->var3 _needNewBodyStreamFromOffset:a2];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidReceiveInformationalResponse( SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return [this->var3 _didReceiveInformationalResponse:a2];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidReceiveResponse( SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return objc_msgSend( this->var3,  "_didReceiveResponse:sniff:",  +[NSURLResponse _responseWithCFURLResponse:]( NSHTTPURLResponse,  "_responseWithCFURLResponse:",  a2),  1);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidSendBodyData( SessionConnectionLoadable *this, UploadProgressInfo *a2)
{
  id var3 = this->var3;
  UploadProgressInfo v4 = *a2;
  return [var3 _didSendBodyData:&v4];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_HandleCacheResponseIsValid( SessionConnectionLoadable *this, const _CFCachedURLResponse *a2)
{
  if (a2) {
    uint64_t v4 = *((void *)a2->var1 + 4);
  }
  else {
    uint64_t v4 = 0LL;
  }
  (*((void (**)(SessionConnectionLoadable *, uint64_t))this->var0 + 16))(this, v4);
  CFTypeRef v5 = CFCachedURLResponseCopyReceiverDataArray((uint64_t)a2);
  if (v5)
  {
    __n128 v6 = v5;
    (*((void (**)(SessionConnectionLoadable *, CFTypeRef, void))this->var0 + 17))(this, v5, 0LL);
    CFRelease(v6);
  }

  return (*((uint64_t (**)(SessionConnectionLoadable *))this->var0 + 20))(this);
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidFinishLoading(SessionConnectionLoadable *this)
{
  return [this->var3 _didFinishWithError:0];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_DidFailWithError( SessionConnectionLoadable *this, __CFError *a2)
{
  return [this->var3 _didFinishWithError:a2];
}

void SessionConnectionLoadable::_loaderClientEvent_DidTimeout(SessionConnectionLoadable *this)
{
  keys[2] = *(void **)MEMORY[0x1895F89C0];
  int valuePtr = -2102;
  keys[0] = @"_kCFStreamErrorDomainKey";
  keys[1] = @"_kCFStreamErrorCodeKey";
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &kCFStreamErrorDomainHTTP);
  values[1] = CFNumberCreate(v2, kCFNumberIntType, &valuePtr);
  uint64_t v4 = CFDictionaryCreate(v2, (const void **)keys, (const void **)values, 2LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  uint64_t v5 = 0LL;
  char v6 = 1;
  do
  {
    char v7 = v6;
    CFRunLoopSourceContext v8 = values[v5];
    if (v8) {
      CFRelease(v8);
    }
    char v6 = 0;
    uint64_t v5 = 1LL;
  }

  while ((v7 & 1) != 0);
  id var3 = this->var3;
  if (var3
    && (Property = objc_getProperty(var3, v3, 8LL, 1), (uint64_t v11 = Property) != 0LL)
    && [Property _proxySettings]
    && [v11 _proxyHandshakePending]
    && !objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v11, "currentRequest_URL"), "scheme"),  "caseInsensitiveCompare:",  @"https"))
  {
    CFIndex v12 = 310LL;
  }

  else
  {
    CFIndex v12 = -1001LL;
  }

  CFErrorRef v13 = CFErrorCreate(v2, @"kCFErrorDomainCFNetwork", v12, v4);
  if (v4) {
    CFRelease(v4);
  }
  (*((void (**)(SessionConnectionLoadable *, CFErrorRef))this->var0 + 21))(this, v13);
  if (v13) {
    CFRelease(v13);
  }
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForEstablishedConnection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZN25SessionConnectionLoadable58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke;
  v5[3] = &unk_189C0B6C0;
  v5[4] = a3;
  return [v3 _willSendRequestForEstablishedConnection:a2 completion:v5];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_ConnectionWaiting(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 24) _connectionIsWaitingWithReason:a2];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_ConditionalRequirementsChanged( SessionConnectionLoadable *this, int a2)
{
  return [this->var3 _conditionalRequirementsChanged:a2 != 0];
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_AlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 24) _alternatePathAvailable:a2];
}

void SessionConnectionLoadable::_loaderClientEvent_asyncError( SessionConnectionLoadable *this, const __CFString *a2, CFIndex a3)
{
  CFErrorRef v4 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x189604DB0], a2, a3, 0LL);
  (*((void (**)(SessionConnectionLoadable *, CFErrorRef))this->var0 + 21))(this, v4);
  if (v4) {
    CFRelease(v4);
  }
}

uint64_t SessionConnectionLoadable::_loaderClientEvent_capturedSocketStreams( SessionConnectionLoadable *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return [this->var3 _capturedSocketInputStream:a2 outputStream:a3];
}

void SessionConnectionLoadable::_loaderClientEvent_captureTransportConnection( uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 24);
  CFErrorRef v4 = (std::__shared_weak_count *)a2[1];
  uint64_t v10 = *a2;
  uint64_t v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  [v3 _captureTransportConnection:&v10 extraBytes:a3];
  char v7 = v11;
  if (v11)
  {
    CFRunLoopSourceContext v8 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

void sub_182A5F1DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void non-virtual thunk to'SessionConnectionLoadable::~SessionConnectionLoadable( SessionConnectionLoadable *this)
{
  this[-1].id var3 = off_189C05C10;
  this->var0 = (void **)&unk_189C05D10;
  this->var1 = (void **)off_189C19AE8;
}

{
  this->var0 = (void **)&unk_189C05D10;
  this->var1 = (void **)off_189C19AE8;
  this[-1].id var3 = off_189C05C10;
  operator delete(&this[-1].var3);
}

{
  this[-1].var2 = (void **)off_189C05C10;
  this[-1].id var3 = &unk_189C05D10;
  this->var0 = (void **)off_189C19AE8;
}

{
  this[-1].id var3 = &unk_189C05D10;
  this->var0 = (void **)off_189C19AE8;
  this[-1].var2 = (void **)off_189C05C10;
  operator delete(&this[-1].var2);
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClient_SupportsDispatchData( SessionConnectionLoadable *this)
{
  return 1LL;
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForRedirection(a1 - 8, a2, a3, a4);
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_WillSendRequestForEstablishedConnection( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 16);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZN25SessionConnectionLoadable58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke;
  v5[3] = &unk_189C0B6C0;
  v5[4] = a3;
  return [v3 _willSendRequestForEstablishedConnection:a2 completion:v5];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidReceiveChallenge( SessionConnectionLoadable *this, _CFURLAuthChallenge *a2)
{
  return objc_msgSend( this->var2,  "_didReceiveChallenge:",  +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:]( NSURLAuthenticationChallenge,  "_authenticationChallengeForCFAuthChallenge:sender:",  a2,  this->var2));
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStream( SessionConnectionLoadable *this)
{
  return [this->var2 _needNewBodyStream];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_NeedNewBodyStreamFromOffset( SessionConnectionLoadable *this, uint64_t a2)
{
  return [this->var2 _needNewBodyStreamFromOffset:a2];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidReceiveInformationalResponse( SessionConnectionLoadable *this, _CFURLResponse *a2)
{
  return [this->var2 _didReceiveInformationalResponse:a2];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_HandleCacheResponseIsValid( SessionConnectionLoadable *this, const _CFCachedURLResponse *a2)
{
  return SessionConnectionLoadable::_loaderClientEvent_HandleCacheResponseIsValid( (SessionConnectionLoadable *)((char *)this - 8),  a2);
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidFailWithError( SessionConnectionLoadable *this, __CFError *a2)
{
  return [this->var2 _didFinishWithError:a2];
}

void non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_DidTimeout( SessionConnectionLoadable *this)
{
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_ConnectionWaiting( uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 16) _connectionIsWaitingWithReason:a2];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_ConditionalRequirementsChanged( SessionConnectionLoadable *this, int a2)
{
  return [this->var2 _conditionalRequirementsChanged:a2 != 0];
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_AlternatePathAvailable( uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 16) _alternatePathAvailable:a2];
}

void non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_asyncError( SessionConnectionLoadable *this, const __CFString *a2, CFIndex a3)
{
}

uint64_t non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_capturedSocketStreams( SessionConnectionLoadable *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return [this->var2 _capturedSocketInputStream:a2 outputStream:a3];
}

void non-virtual thunk to'SessionConnectionLoadable::_loaderClientEvent_captureTransportConnection( uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

uint64_t ___ZN25SessionConnectionLoadable58_loaderClientEvent_WillSendRequestForEstablishedConnectionEPK14__CFDictionaryU13block_pointerFvP12NSURLRequestE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

dispatch_object_t createDispatchDataFromDataArray(NSArray *a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  dispatch_object_t v11 = 0LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  dispatch_object_t result = (dispatch_object_t)-[NSArray countByEnumeratingWithState:objects:count:]( a1,  "countByEnumeratingWithState:objects:count:",  &v7,  v12,  16LL);
  if (result)
  {
    dispatch_object_t v3 = result;
    uint64_t v4 = *(void *)v8;
    do
    {
      for (dispatch_object_t i = 0LL; i != v3; dispatch_object_t i = (dispatch_object_t)((char *)i + 1))
      {
        if (*(void *)v8 != v4) {
          objc_enumerationMutation(a1);
        }
        unint64_t v6 = (dispatch_data_s *)[*(id *)(*((void *)&v7 + 1) + 8 * (void)i) _createDispatchData];
        conCatData(&v11, v6);
        dispatch_release(v6);
      }

      dispatch_object_t v3 = (dispatch_object_t)-[NSArray countByEnumeratingWithState:objects:count:]( a1,  "countByEnumeratingWithState:objects:count:",  &v7,  v12,  16LL);
    }

    while (v3);
    return v11;
  }

  return result;
}

uint64_t ___ZN25SessionConnectionLoadable48_loaderClientEvent_WillSendRequestForRedirectionEP12NSURLRequestP14_CFURLResponseU13block_pointerFvS1_E_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN25SessionConnectionLoadable21withLoaderClientAsyncEU13block_pointerFvP21LoaderClientInterfaceE_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 72LL))(v1);
}

void AutoString::~AutoString(AutoString *this)
{
}

{
  const void *v2;
  void *v3;
  CFAllocatorRef v4;
  const void *v5;
  *(void *)this = off_189C1A178;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  dispatch_object_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    uint64_t v4 = (const __CFAllocator *)*((void *)this + 3);
    if (v4)
    {
      CFAllocatorDeallocate(v4, v3);
      uint64_t v5 = (const void *)*((void *)this + 3);
      *((void *)this + 2) = 0LL;
      *((void *)this + 3) = 0LL;
      if (v5) {
        CFRelease(v5);
      }
    }
  }

void AutoStringWithFormat::~AutoStringWithFormat(AutoStringWithFormat *this)
{
}

void AutoStringWithFormatAndArgs::~AutoStringWithFormatAndArgs(AutoStringWithFormatAndArgs *this)
{
}

uint64_t AutoString::getCString(AutoString *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result)
  {
    CFIndex Length = CFStringGetLength(*((CFStringRef *)this + 1));
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFIndex v5 = MaximumSizeForEncoding + 1;
    if (MaximumSizeForEncoding > 118)
    {
      __int128 v7 = CFGetAllocator(*((CFTypeRef *)this + 1));
      if (v7) {
        __int128 v7 = CFRetain(v7);
      }
      *((void *)this + 3) = v7;
      unint64_t v6 = (char *)MEMORY[0x186E12804]();
    }

    else
    {
      unint64_t v6 = (char *)this + 32;
    }

    *((void *)this + 2) = v6;
    CFStringGetCString(*((CFStringRef *)this + 1), v6, v5, 0x8000100u);
    return *((void *)this + 2);
  }

  return result;
}

void AutoStringWithFormat::AutoStringWithFormat( AutoStringWithFormat *this, CFAllocatorRef alloc, const __CFString *a3, ...)
{
  *(void *)this = off_189C05DF0;
  CFStringRef v4 = CFStringCreateWithFormatAndArguments(alloc, 0LL, a3, va);
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v4;
}

void sub_182A5F660(_Unwind_Exception *a1)
{
}

void AutoStringArray::addFormat(CFTypeRef *this, const __CFString *a2, ...)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  CFStringRef v4 = CFGetAllocator(*this);
  CFIndex v5 = off_189C05E10;
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  CFStringRef v6 = CFStringCreateWithFormatAndArguments(v4, 0LL, a2, va);
  CFArrayAppendValue((CFMutableArrayRef)*this, v6);
  AutoString::~AutoString((AutoString *)&v5);
}

void sub_182A5F710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double ___ZN11WeakTrackerI19TransportConnectionE15_trackedObjectsEv_block_invoke()
{
  os_log_t v0 = operator new(0x28uLL);
  double result = 0.0;
  _OWORD *v0 = 0u;
  v0[1] = 0u;
  *((_DWORD *)v0 + _Block_object_dispose(va, 8) = 1065353216;
  WeakTracker<TransportConnection>::_trackedObjects(void)::trackedObjects = (uint64_t)v0;
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::weak_ptr<TransportConnection>>,void *>>>::operator()[abi:nn180100]( char a1, void *__p)
{
  if (a1)
  {
    dispatch_object_t v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t NWIOConnection::registerContext()
{
  return nw_connection_register_context();
}

uint64_t NWIOConnection::unregisterContext()
{
  return nw_connection_unregister_context();
}

void NWIOConnection::setQUICMaxStreamsUnidirectional(nw_connection_t *this, uint64_t a2)
{
  CFStringRef v4 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v5 = nw_connection_copy_protocol_metadata(this[34], v4);
  nw_protocol_metadata_t v6 = v5;
  if (v5)
  {
    MEMORY[0x186E15594](v5, a2);
    nw_release(v6);
  }

  if (v4) {
    nw_release(v4);
  }
}

void sub_182A5F834(_Unwind_Exception *a1)
{
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::getQUICPeerIdleTimeout(nw_connection_t *this)
{
  uint64_t v2 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (!v3)
  {
    uint64_t peer_idle_timeout = 0LL;
    if (!v2) {
      return peer_idle_timeout;
    }
    goto LABEL_3;
  }

  uint64_t peer_idle_timeout = nw_quic_connection_get_peer_idle_timeout();
  nw_release(v3);
  if (v2) {
LABEL_3:
  }
    nw_release(v2);
  return peer_idle_timeout;
}

void sub_182A5F8CC(_Unwind_Exception *a1)
{
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

void NWIOConnection::closeWithQUICApplicationError(nw_connection_t *this)
{
  uint64_t v2 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (v3)
  {
    nw_quic_connection_close_with_error();
    nw_release(v3);
  }

  if (v2) {
    nw_release(v2);
  }
}

void sub_182A5F964(_Unwind_Exception *a1)
{
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t NWIOConnection::getQUICApplicationError(nw_connection_t *this)
{
  uint64_t v2 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
  nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(this[34], v2);
  if (!v3)
  {
    application_CFErrorRef error = -1LL;
    if (!v2) {
      return application_error;
    }
    goto LABEL_3;
  }

  application_CFErrorRef error = nw_quic_connection_get_application_error();
  nw_release(v3);
  if (v2) {
LABEL_3:
  }
    nw_release(v2);
  return application_error;
}

void sub_182A5F9FC(_Unwind_Exception *a1)
{
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

void NWIOConnection::reportQUICApplicationResult(uint64_t a1)
{
  if (*(void *)(a1 + 272))
  {
    uint64_t v2 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
    nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(*(nw_connection_t *)(a1 + 272), v2);
    if (v3)
    {
      nw_quic_connection_report_application_result();
      nw_release(v3);
    }

    if (v2) {
      nw_release(v2);
    }
  }

void sub_182A5FAA0(_Unwind_Exception *a1)
{
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

void NWIOConnection::setQUICKeepalive(uint64_t a1)
{
  if (*(void *)(a1 + 272))
  {
    uint64_t v2 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
    nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(*(nw_connection_t *)(a1 + 272), v2);
    if (v3)
    {
      nw_quic_connection_set_keepalive();
      nw_release(v3);
    }

    if (v2) {
      nw_release(v2);
    }
  }

void sub_182A5FB58(_Unwind_Exception *a1)
{
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(a1);
}

void NWIOConnection::close(TransportConnection *this, char a2)
{
}

void NWIOConnection::setReusedAfterAPSleepWake(NWIOConnection *this)
{
  if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)nw_protocol_metadata_t v3 = 0;
    _os_log_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEFAULT, "setReusedAfterAPSleepWake", v3, 2u);
  }

  uint64_t v2 = *((void *)this + 25);
  if (v2) {
    *(_BYTE *)(v2 + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
  }
}

void NWIOConnection::coalesce(NWIOConnection *this)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  int v1 = *((unsigned __int16 *)this + 124) | (*((unsigned __int8 *)this + 250) << 16);
  if ((v1 & 0x20000) == 0)
  {
    *((_WORD *)this + 12os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = *((_WORD *)this + 124);
    *((_BYTE *)this + 250) = (v1 | 0x20000u) >> 16;
    uint64_t v3 = *((void *)this + 25);
    if (v3) {
      *(_BYTE *)(v3 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    CFStringRef v4 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *((void *)this + 36);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v5;
      _os_log_impl( &dword_18298D000,  v4,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: will be coalesced",  (uint8_t *)&buf,  0xCu);
    }

    uint64_t v6 = *((void *)this + 56);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 57);
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }

    uint64_t v10 = *((void *)this + 60);
    dispatch_object_t v11 = (std::__shared_weak_count *)*((void *)this + 61);
    if (v11)
    {
      CFIndex v12 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }

    uint64_t v14 = *((void *)this + 32);
    unint64_t v15 = (std::__shared_weak_count *)*((void *)this + 33);
    if (v15)
    {
      p_shared_weak_owners = (unint64_t *)&v15->__shared_weak_owners_;
      do
        unint64_t v17 = __ldxr(p_shared_weak_owners);
      while (__stxr(v17 + 1, p_shared_weak_owners));
    }

    double v46 = 0LL;
    uint64_t v47 = 0LL;
    if (v7)
    {
      unint64_t v18 = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
    }

    v45[0] = v10;
    v45[1] = (uint64_t)v11;
    if (v11)
    {
      uint64_t v20 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }

    *(void *)&__int128 buf = MEMORY[0x1895F87A8];
    *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
    double v49 = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke;
    CFStringRef v50 = &__block_descriptor_88_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE_e144_v60__0B8_shared_ptr___SecTrust______SecTrust_____shared_weak_count__12_shared_ptr_const___CFArray______CFArray_____shared_weak_count__28___qi_44l;
    CFTypeID v51 = this;
    uint64_t v52 = v14;
    char v53 = v15;
    if (v15)
    {
      uint64_t v22 = (unint64_t *)&v15->__shared_weak_owners_;
      do
        unint64_t v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }

    uint64_t v54 = v6;
    CFStringRef v55 = v7;
    if (v7)
    {
      double v24 = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
    }

    uint64_t v56 = v10;
    CFTypeID v57 = v11;
    if (v11)
    {
      int v26 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }

    NWIOConnection::_tlsProcessValidateServerTrust_Invoke((uint64_t)this, &v46, v6, (uint64_t)v7, v45, (uint64_t)&buf);
    if (v11)
    {
      CFNumberRef v28 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }

    if (v7)
    {
      CFNumberRef v30 = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }

    unsigned int v32 = v47;
    if (v47)
    {
      uint64_t v33 = (unint64_t *)&v47->__shared_owners_;
      do
        unint64_t v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }

    CFStringRef v35 = v57;
    if (v57)
    {
      double v36 = (unint64_t *)&v57->__shared_owners_;
      do
        unint64_t v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }

    CFNumberRef v38 = v55;
    if (v55)
    {
      CFNumberRef v39 = (unint64_t *)&v55->__shared_owners_;
      do
        unint64_t v40 = __ldaxr(v39);
      while (__stlxr(v40 - 1, v39));
      if (!v40)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
    }

    if (v53) {
      std::__shared_weak_count::__release_weak(v53);
    }
    if (v15) {
      std::__shared_weak_count::__release_weak(v15);
    }
    if (v11)
    {
      CFStringRef v41 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }

    if (v7)
    {
      CFIndex v43 = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v44 = __ldaxr(v43);
      while (__stlxr(v44 - 1, v43));
      if (!v44)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }

void sub_182A60014( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20, std::__shared_weak_count *a21, uint64_t a22, std::__shared_weak_count *a23)
{
  if (a23)
  {
    p_shared_owners = (unint64_t *)&a23->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(p_shared_owners);
    while (__stlxr(v28 - 1, p_shared_owners));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))a23->__on_zero_shared)(a23);
      std::__shared_weak_count::__release_weak(a23);
    }
  }

  if (a21)
  {
    unint64_t v29 = (unint64_t *)&a21->__shared_owners_;
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))a21->__on_zero_shared)(a21);
      std::__shared_weak_count::__release_weak(a21);
    }
  }

  if (a19) {
    std::__shared_weak_count::__release_weak(a19);
  }
  if (a10)
  {
    unint64_t v31 = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  if (v23)
  {
    uint64_t v33 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  if (a12)
  {
    CFStringRef v35 = (unint64_t *)&a12->__shared_owners_;
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }

  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  if (v24)
  {
    unint64_t v37 = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  if (v23)
  {
    CFNumberRef v39 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  _Unwind_Resume(exception_object);
}

void NWIOConnection::setPeerCerts(NWIOConnection *this, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeRef v3 = CFRetain(cf);
    *(void *)&__int128 v9 = v3;
    CFStringRef v4 = operator new(0x20uLL);
    void *v4 = off_189C11328;
    v4[1] = 0LL;
    v4[2] = 0LL;
    v4[3] = v3;
    *((void *)&v9 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v4;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 480, &v9);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)&v9 + 1);
    if (!*((void *)&v9 + 1)) {
      return;
    }
    uint64_t v6 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
  }

  else
  {
    __int128 v9 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 480, &v9);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)&v9 + 1);
    if (!*((void *)&v9 + 1)) {
      return;
    }
    uint64_t v8 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
    do
      unint64_t v7 = __ldaxr(v8);
    while (__stlxr(v7 - 1, v8));
  }

  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }

uint64_t NWIOConnection::createPeerTrustUsingTrustData(uint64_t this, const __CFData *a2)
{
  if (a2)
  {
    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 3221225472LL;
    v2[2] = ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke;
    v2[3] = &__block_descriptor_48_e24_v20__0____CFString__8B16l;
    v2[4] = this;
    void v2[5] = a2;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)this + 344LL))(this, v2);
  }

  return this;
}

uint64_t NWIOConnection::copyConnectionEndpoint(NWIOConnection *this)
{
  uint64_t v1 = *((void *)this + 38);
  if (v1) {
    nw_retain(*((void **)this + 38));
  }
  return v1;
}

nw_parameters *NWIOConnection::copyConnectionParameters(NWIOConnection *this)
{
  double result = (nw_parameters *)*((void *)this + 37);
  if (result) {
    return nw_parameters_copy(result);
  }
  return result;
}

uint64_t NWIOConnection::logConnectionAtAPSleep(uint64_t this)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (!*(_BYTE *)(this + 681))
  {
    uint64_t v1 = this;
    *(_BYTE *)(this + 68__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 1;
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v3 = *(void *)(v1 + 200);
    if (v3) {
      double v4 = *(double *)(v3 + 176);
    }
    else {
      double v4 = 0.0;
    }
    unsigned int v5 = ((Current - v4) * 1000.0);
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      unsigned int v7 = v5;
      _os_log_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_DEFAULT,  "logConnectionAtAPSleep: idleDuration=%u",  buf,  8u);
    }

    return AnalyticsSendEventLazy_delayInitStub(COERCE_DOUBLE(3221225472LL));
  }

  return this;
}

void non-virtual thunk to'NWIOConnection::~NWIOConnection(NWIOConnection *this)
{
}

{
  void *v1;
  NWIOConnection::~NWIOConnection((NWIOConnection *)((char *)this - 112));
  operator delete(v1);
}

uint64_t non-virtual thunk to'NWIOConnection::getConnectionID(NWIOConnection *this)
{
  return *((void *)this + 22);
}

void non-virtual thunk to'NWIOConnection::readWithContext( uint64_t a1, uint64_t a2, uint32_t a3, uint32_t a4, uint64_t a5)
{
}

void non-virtual thunk to'NWIOConnection::writeWithContext( uint64_t a1, nw_content_context *a2, int a3, dispatch_data_s *a4, uint64_t a5)
{
}

uint64_t non-virtual thunk to'NWIOConnection::registerContext()
{
  return nw_connection_register_context();
}

uint64_t non-virtual thunk to'NWIOConnection::unregisterContext()
{
  return nw_connection_unregister_context();
}

void NWIOConnection::_cleanupConnection(nw_connection_t *this, char a2)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  NWIOConnection::_kickTimerCancel((NWIOConnection *)this);
  double v4 = (dispatch_source_s *)this[70];
  if (v4)
  {
    dispatch_source_cancel(v4);
    unsigned int v5 = (dispatch_object_s *)this[70];
    this[70] = 0LL;
    if (v5) {
      dispatch_release(v5);
    }
  }

  NWIOConnection::_connectionAttemptTimerCancel((NWIOConnection *)this);
  NWIOConnection::_conditionalSchedulingSIMCancel((NWIOConnection *)this);
  if ((*((_DWORD *)this + 34) - 6) >= 0xFFFFFFFD)
  {
    uint64_t v6 = (const void *)(*((uint64_t (**)(nw_connection_t *, uint64_t))*this + 27))(this, 0x18C5ACD08LL);
    if (v6) {
      CFDictionarySetValue(this[46], &unk_18C5ACD08, v6);
    }
    unsigned int v7 = (const void *)(*((uint64_t (**)(nw_connection_t *, void *))*this + 27))(this, &unk_18C5AD910);
    if (v7) {
      CFRelease(v7);
    }
    uint64_t v8 = (const void *)(*((uint64_t (**)(nw_connection_t *, uint64_t))*this + 27))(this, 0x18C5AD868LL);
    if (v8)
    {
      CFDictionarySetValue(this[46], &unk_18C5AD868, v8);
      CFRelease(v8);
    }

    if (v6) {
      CFRelease(v6);
    }
  }

  if (this[34])
  {
    int v9 = *((unsigned __int16 *)this + 124);
    int v10 = v9 | (*((unsigned __int8 *)this + 250) << 16);
    if ((v9 & 0x20) == 0)
    {
      *((_BYTE *)this + 250) = BYTE2(v10);
      *((_WORD *)this + 12os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v10 | 0x20;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      dispatch_object_t v11 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        nw_connection_t v12 = this[36];
        *(_DWORD *)__int128 buf = 134217984;
        *(void *)&uint8_t buf[4] = v12;
        _os_log_impl(&dword_18298D000, v11, OS_LOG_TYPE_DEFAULT, "Connection %llu: cleaning up", buf, 0xCu);
      }

      uint64_t v13 = (uint64_t)this[25];
      if (v13)
      {
        *(CFAbsoluteTime *)(v13 + 112) = CFAbsoluteTimeGetCurrent();
        os_unfair_lock_lock((os_unfair_lock_t)(v13 + 8));
        if (*(_BYTE *)(v13 + 12))
        {
          uint64_t v14 = -[__CFN_ConnectionMetrics _tcpInfo](v13);
          unint64_t v15 = *(void **)(v13 + 48);
          *(void *)(v13 + 4_Block_object_dispose(va, 8) = v14;
        }

        if (*(_BYTE *)(v13 + 13))
        {
          uint64_t v16 = -[__CFN_ConnectionMetrics _subflowCounts](v13);
          unint64_t v17 = *(void **)(v13 + 56);
          *(void *)(v13 + 56) = v16;
        }

        unint64_t v18 = *(void **)(v13 + 40);
        *(void *)(v13 + 40) = 0LL;

        os_unfair_lock_unlock((os_unfair_lock_t)(v13 + 8));
        if (!*(_BYTE *)(v13 + 23) && !*(_BYTE *)(v13 + 24))
        {
          id v20 = objc_getProperty((id)v13, v19, 160LL, 1);
          connectionTimingFromMetrics((__CFN_ConnectionMetrics *)&connection, (void *)v13);
          int v21 = *(_DWORD *)(v13 + 32);
          summaryLog();
          uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v23 = *(void *)(v13 + 72);
            unsigned int v24 = ((*(double *)(v13 + 112) - *(double *)(v13 + 96)) * 1000.0);
            *(_DWORD *)__int128 buf = 134219522;
            *(void *)&uint8_t buf[4] = v23;
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v20;
            __int16 v70 = 1024;
            int v71 = v66;
            __int16 v72 = 1024;
            int v73 = v67;
            __int16 v74 = 1024;
            int v75 = v68;
            __int16 v76 = 1024;
            BOOL v77 = v21 == 2;
            __int16 v78 = 1024;
            unsigned int v79 = v24;
            _os_log_impl( &dword_18298D000,  v22,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: summary for unused connection {protocol=%{public}@, domain_lookup_duration_ms=%u, con nect_duration_ms=%u, secure_connection_duration_ms=%u, private_relay=%{BOOL}d, idle_duration_ms=%u}",  buf,  0x34u);
          }
        }
      }

      nw_connection_t v25 = this[35];
      nw_connection_t connection = this[34];
      CFTypeID v65 = (std::__shared_weak_count *)v25;
      if (v25)
      {
        int v26 = (unint64_t *)((char *)v25 + 8);
        do
          unint64_t v27 = __ldxr(v26);
        while (__stxr(v27 + 1, v26));
      }

      *(void *)__int128 buf = 0LL;
      *(void *)&uint8_t buf[8] = 0LL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(this + 34), (__int128 *)buf);
      unint64_t v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        unint64_t v29 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }

      int v31 = *((_DWORD *)this + 34);
      if (v31 != 7)
      {
        if (v31 >= 6) {
          __assert_rtn("_changeState", "TransportConnection.cpp", 288, "newState >= _state");
        }
        *((_DWORD *)this + 3os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 5;
      }

      nw_connection_t v32 = this[50];
      if (v32)
      {
        uint64_t v33 = (uint64_t *)*((void *)v32 + 6);
        unint64_t v34 = (uint64_t *)v33[1];
        if (*((_BYTE *)v32 + 41)) {
          unint64_t v34 = (uint64_t *)v34[1];
        }
        if (v34 != v33)
        {
          do
          {
            uint64_t v35 = v34[2];
            if (v35)
            {
              uint64_t v36 = *(void *)(v35 + 64);
              if (v36)
              {
                (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v36 + 16))(v36, 0LL, 1LL, 89LL);
                _Block_release(*(const void **)(v35 + 64));
                *(void *)(v35 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
              }
            }

            else
            {
              uint64_t v37 = v34[4];
              if (v37)
              {
                uint64_t v38 = *(void *)(v37 + 64);
                if (v38)
                {
                  *(void *)__int128 buf = 0LL;
                  *(void *)&uint8_t buf[8] = 0LL;
                  (*(void (**)(uint64_t, _BYTE *, uint64_t, uint64_t))(v38 + 16))(v38, buf, 1LL, 89LL);
                  CFNumberRef v39 = *(std::__shared_weak_count **)&buf[8];
                  if (*(void *)&buf[8])
                  {
                    unint64_t v40 = (unint64_t *)(*(void *)&buf[8] + 8LL);
                    do
                      unint64_t v41 = __ldaxr(v40);
                    while (__stlxr(v41 - 1, v40));
                    if (!v41)
                    {
                      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
                      std::__shared_weak_count::__release_weak(v39);
                    }
                  }

                  _Block_release(*(const void **)(v37 + 64));
                  *(void *)(v37 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
                }
              }
            }

            uint64_t v42 = *((void *)v32 + 6);
            uint64_t v43 = *v34;
            unint64_t v44 = (uint64_t *)v34[1];
            *(void *)(v43 + _Block_object_dispose(va, 8) = v44;
            *(void *)v34[1] = v43;
            --*(void *)(v42 + 16);
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v34 + 4));
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(v34 + 2));
            operator delete(v34);
            unint64_t v34 = v44;
          }

          while (*((uint64_t **)v32 + 6) != v44);
        }
      }

      if ((a2 & 1) != 0)
      {
        if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEFAULT))
        {
          nw_connection_t v45 = this[25];
          if (v45) {
            nw_connection_t v45 = (nw_connection_t)*((void *)v45 + 9);
          }
          *(_DWORD *)__int128 buf = 134217984;
          *(void *)&uint8_t buf[4] = v45;
          _os_log_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_DEFAULT,  "nw_connection_force_cancel connection=%llu",  buf,  0xCu);
        }

        nw_connection_force_cancel(connection);
      }

      else
      {
        nw_connection_cancel(connection);
      }

      if (!CFDictionaryGetValue(this[46], &unk_18C5AD830)) {
        goto LABEL_80;
      }
      gotLoadHelper_x8__OBJC_CLASS____DASActivity(v46);
      if (objc_opt_class())
      {
        if (this[73])
        {
          int v47 = *((unsigned __int8 *)this + 592);
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          double v48 = (os_log_s *)CFNLog::logger;
          BOOL v49 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT);
          if (v47)
          {
            if (!v49) {
              goto LABEL_75;
            }
            nw_connection_t v51 = this[36];
            nw_connection_t v52 = this[73];
            *(_DWORD *)__int128 buf = 134218240;
            *(void *)&uint8_t buf[4] = v51;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v52;
            char v53 = "Connection %llu: activity(%p) will be completed";
          }

          else
          {
            if (!v49) {
              goto LABEL_75;
            }
            nw_connection_t v54 = this[36];
            nw_connection_t v55 = this[73];
            *(_DWORD *)__int128 buf = 134218240;
            *(void *)&uint8_t buf[4] = v54;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v55;
            char v53 = "Connection %llu: activity(%p) will be canceled";
          }

          _os_log_impl(&dword_18298D000, v48, OS_LOG_TYPE_DEFAULT, v53, buf, 0x16u);
LABEL_75:
          nw_connection_t v56 = this[73];
          double Helper_x8__OBJC_CLASS____DASScheduler = gotLoadHelper_x8__OBJC_CLASS____DASScheduler(v50);
          char v59 = (void *)objc_msgSend(*(id *)(v58 + 584), "sharedScheduler", Helper_x8__OBJC_CLASS____DASScheduler);
          if (v47) {
            [v59 activityCompleted:v56];
          }
          else {
            [v59 activityCanceled:v56];
          }
          nw_connection_t v60 = this[73];
          this[73] = 0LL;
          if (v60) {
            CFRelease(v60);
          }
        }
      }

      else
      {
        NWIOConnection::_conditionalSchedulingSIMCancel((NWIOConnection *)this);
      }

LABEL_80:
      CFTypeID v61 = v65;
      if (v65)
      {
        p_shared_owners = (unint64_t *)&v65->__shared_owners_;
        do
          unint64_t v63 = __ldaxr(p_shared_owners);
        while (__stlxr(v63 - 1, p_shared_owners));
        if (!v63)
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
        }
      }
    }
  }

void sub_182A60B90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection22logConnectionAtAPSleepEv_block_invoke(uint64_t a1)
{
  v3[1] = *MEMORY[0x1895F89C0];
  uint64_t v2 = @"idleDuration";
  v3[0] = [MEMORY[0x189607968] numberWithUnsignedInt:*(unsigned int *)(a1 + 32)];
  return [MEMORY[0x189603F68] dictionaryWithObjects:v3 forKeys:&v2 count:1];
}

uint64_t __Block_byref_object_copy__3485(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(result + 4_Block_object_dispose(va, 8) = v2;
  return result;
}

void __Block_byref_object_dispose__3486(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  if (v2) {
    CFRelease(v2);
  }
}

uint64_t ___ZN14NWIOConnection21ipAddressWithPolicyIdEPU21objcproto10OS_nw_path8NSObjectPU25objcproto14OS_nw_endpointS0_b_block_invoke( uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v6 = nw_endpoint_copy_address_string(*(nw_endpoint_t *)(a1 + 32));
  if (!v6) {
    __assert_rtn("ipAddressWithPolicyId_block_invoke", "NWIOConnection.cpp", 1619, "address");
  }
  unsigned int v7 = v6;
  uint64_t v22 = MEMORY[0x1895F87A8];
  uint64_t v23 = 3221225472LL;
  unsigned int v24 = ___ZN14NWIOConnection21ipAddressWithPolicyIdEPU21objcproto10OS_nw_path8NSObjectPU25objcproto14OS_nw_endpointS0_b_block_invoke_2;
  nw_connection_t v25 = &__block_descriptor_40_e5_v8__0l;
  int v26 = v6;
  if (a3)
  {
    int v8 = *(unsigned __int8 *)(a1 + 56);
    int v9 = (__CFN_CoalescingDomainHolder *)[a2 objectForKeyedSubscript:a3];
    if (!v9 && !v8)
    {
      int v9 = objc_alloc_init(&OBJC_CLASS_____CFN_CoalescingDomainHolder);
      [a2 setObject:v9 forKeyedSubscript:a3];
    }

    if (v9)
    {
      if (v9->_pathPolicyManager)
      {
        int v10 = (nw_interface *)nw_path_copy_interface();
        if (v10)
        {
          *(void *)uu = 0LL;
          uint64_t v29 = 0LL;
          if (nw_path_get_vpn_config_id())
          {
            dispatch_object_t v11 = out;
            uuid_unparse_upper(uu, out);
          }

          else
          {
            dispatch_object_t v11 = "0";
          }

          nw_connection_t v12 = (void *)NSString;
          name = nw_interface_get_name(v10);
          uint64_t interface_index = nw_path_get_interface_index();
          uint64_t type = nw_interface_get_type(v10);
          subuint64_t type = nw_interface_get_subtype();
          uint64_t v17 = objc_msgSend( v12,  "stringWithFormat:",  @"{%s}{%d}{%d}{%d}{%s}{%d}",  name,  interface_index,  type,  subtype,  v11,  nw_path_get_policy_id(),  v22,  v23);
          nw_release(v10);
          if (v17)
          {
            CFStringRef v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"%s@%@", v7, v17);
            uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8LL);
            id v20 = *(const void **)(v19 + 48);
            *(void *)(v19 + 4_Block_object_dispose(va, 8) = v18;
            if (v20) {
              CFRelease(v20);
            }
          }
        }
      }
    }
  }

  return ((uint64_t (*)(uint64_t *))v24)(&v22);
}

void sub_182A60EF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void (*a17)(char *))
{
}

void ___ZN14NWIOConnection21ipAddressWithPolicyIdEPU21objcproto10OS_nw_path8NSObjectPU25objcproto14OS_nw_endpointS0_b_block_invoke_2( uint64_t a1)
{
}

void ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke(uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v23 = 0LL;
  unsigned int v24 = &v23;
  uint64_t v25 = 0x2020000000LL;
  uint64_t v26 = 0LL;
  v19[0] = MEMORY[0x1895F87A8];
  v19[1] = 3221225472LL;
  id v20 = ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke_2;
  int v21 = &unk_189C17740;
  uint64_t v22 = &v23;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (const __CFArray *)SecTrustDeserialize();
  theArray[1] = v2;
  uint64_t v3 = (unint64_t *)operator new(0x20uLL);
  v3[1] = 0LL;
  double v4 = v3 + 1;
  *uint64_t v3 = (unint64_t)off_189C06A70;
  void v3[2] = 0LL;
  v3[3] = (unint64_t)v2;
  theArray[2] = (CFArrayRef)v3;
  if (!v24[3] && v2)
  {
    theArray[0] = 0LL;
    OSStatus v5 = SecTrustCopyPolicies(v2, theArray);
    if (v5 || !theArray[0])
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v14 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v2_Block_object_dispose(va, 8) = v5;
      unsigned int v7 = "SecTrustCopyPolicies failed %d";
      int v8 = (os_log_s *)v14;
      uint32_t v9 = 8;
    }

    else if (CFArrayGetCount(theArray[0]) == 1)
    {
      CFArrayGetValueAtIndex(theArray[0], 0LL);
      if ((SecPolicySetSSLHostname() & 1) != 0) {
        goto LABEL_23;
      }
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v6 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT)) {
        goto LABEL_23;
      }
      *(_WORD *)__int128 buf = 0;
      unsigned int v7 = "SecPolicySetSSLHostname failed";
      int v8 = (os_log_s *)v6;
      uint32_t v9 = 2;
    }

    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v15 = CFNLog::logger;
      if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT)) {
        goto LABEL_23;
      }
      CFIndex Count = CFArrayGetCount(theArray[0]);
      *(_DWORD *)__int128 buf = 134217984;
      CFIndex v28 = Count;
      unsigned int v7 = "SecTrust has an unexpected number of policies %lu";
      int v8 = (os_log_s *)v15;
      uint32_t v9 = 12;
    }

    _os_log_fault_impl(&dword_18298D000, v8, OS_LOG_TYPE_FAULT, v7, buf, v9);
LABEL_23:
    if (theArray[0]) {
      CFRelease(theArray[0]);
    }
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v1 + 448), (uint64_t)v2, (uint64_t)v3);
    goto LABEL_26;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  int v10 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    CFIndex v11 = *(void *)(v1 + 288);
    uint64_t v12 = v24[3];
    if (v12) {
      CFIndex Code = CFErrorGetCode((CFErrorRef)v24[3]);
    }
    else {
      CFIndex Code = 0LL;
    }
    *(_DWORD *)__int128 buf = 134218498;
    CFIndex v28 = v11;
    __int16 v29 = 2112;
    uint64_t v30 = v12;
    __int16 v31 = 2048;
    CFIndex v32 = Code;
    _os_log_error_impl( &dword_18298D000,  v10,  OS_LOG_TYPE_ERROR,  "Connection %llu: failed to deserialize cloned trust %@ [%ld]",  buf,  0x20u);
  }

  do
LABEL_26:
    unint64_t v16 = __ldaxr(v4);
  while (__stlxr(v16 - 1, v4));
  if (!v16)
  {
    (*(void (**)(unint64_t *))(*v3 + 16))(v3);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v3);
  }

  v20((uint64_t)v19);
  _Block_object_dispose(&v23, 8);
}

void sub_182A612C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, void);
  uint64_t v8 = va_arg(va2, void);
  uint32_t v9 = va_arg(va2, void (*)(uint64_t *));
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  v9((uint64_t *)va1);
  _Block_object_dispose(va2, 8);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection29createPeerTrustUsingTrustDataEPK8__CFData_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_pointer<__SecTrust *,Deleter_CFRelease,std::allocator<__SecTrust>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<__CFArray const*,Deleter_CFRelease,std::allocator<__CFArray const>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke( void *a1, int a2, uint64_t a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  unsigned int v7 = (std::__shared_weak_count *)a1[6];
  if (v7)
  {
    uint64_t v11 = (NWIOConnection *)a1[4];
    uint64_t v12 = std::__shared_weak_count::lock(v7);
    v19[6] = v12;
    if (v12)
    {
      uint64_t v13 = v12;
      uint64_t v14 = a1[5];
      v19[5] = v14;
      if (v14 && (*(_WORD *)(v14 + 248) & 0x60) == 0 && (*(_DWORD *)(v14 + 136) - 5) >= 3)
      {
        if (a5 || (_DWORD)a6)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          uint64_t v15 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            uint64_t v18 = *((void *)v11 + 36);
            *(_DWORD *)__int128 buf = 134218496;
            uint64_t v21 = v18;
            __int16 v22 = 2048;
            CFIndex v23 = a5;
            __int16 v24 = 1024;
            int v25 = a6;
            _os_log_error_impl( &dword_18298D000,  v15,  OS_LOG_TYPE_ERROR,  "Connection %llu: coalesced TLS Trust encountered error %ld:%d",  buf,  0x1Cu);
          }

          v27.CFIndex domain = a5;
          *(void *)&v27.CFErrorRef error = a6;
          NWIOConnection::_handleError(v11, v27);
        }

        else if (a2)
        {
          v19[0] = MEMORY[0x1895F87A8];
          v19[1] = 3221225472LL;
          void v19[2] = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_206;
          v19[3] = &__block_descriptor_40_e45_v24__0____CFDictionary__8____CFDictionary__16l;
          v19[4] = v11;
          (*(void (**)(NWIOConnection *, void *))(*(void *)v11 + 336LL))(v11, v19);
          std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)v11 + 56, a1[7], a1[8]);
          std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)v11 + 60, a1[9], a1[10]);
          NWIOConnection::_tlsProcessHandshakeComplete(v11);
          NWIOConnection::_completeEndpointSetup(v11);
        }
      }

      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(p_shared_owners);
      while (__stlxr(v17 - 1, p_shared_owners));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

void sub_182A61548( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

__n128 __Block_byref_object_copy__155(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

__n128 __Block_byref_object_copy__142(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  return result;
}

uint64_t __Block_byref_object_dispose__143(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke( uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL), v3);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_182A615D4(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_2( uint64_t a1, int a2, char a3)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = *(dispatch_queue_s **)(v5 + 120);
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3321888768LL;
  v13[2] = ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_3;
  v13[3] = &unk_189C06780;
  char v19 = a3;
  __int128 v14 = *(_OWORD *)(a1 + 32);
  uint64_t v15 = v4;
  uint64_t v16 = v5;
  unsigned int v7 = *(std::__shared_weak_count **)(a1 + 64);
  unint64_t v17 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  int v18 = a2;
  dispatch_async(v6, v13);
  uint64_t v10 = v17;
  if (v17)
  {
    uint64_t v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_3( uint64_t a1)
{
  if (*(_BYTE *)(a1 + 76))
  {
    uint64_t v1 = *(void *)(*(void *)(a1 + 40) + 8LL);
    *(void *)(v1 + 4_Block_object_dispose(va, 8) = 1LL;
    *(_DWORD *)(v1 + 56) = 89;
    uint64_t v53 = 0LL;
    nw_connection_t v54 = 0LL;
    uint64_t v51 = 0LL;
    nw_connection_t v52 = 0LL;
    (*(void (**)(void, void, uint64_t *, uint64_t *, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  0LL,  &v53,  &v51,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL),  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 56LL));
    uint64_t v2 = v52;
    if (v52)
    {
      p_shared_owners = (unint64_t *)&v52->__shared_owners_;
      do
        unint64_t v4 = __ldaxr(p_shared_owners);
      while (__stlxr(v4 - 1, p_shared_owners));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }

    uint64_t v5 = v54;
    if (v54)
    {
      uint64_t v6 = (unint64_t *)&v54->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
LABEL_21:
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }

      return;
    }

    return;
  }

  uint64_t v8 = *(void *)(a1 + 56);
  if ((*(_WORD *)(v8 + 248) & 0x60) == 0 && (*(_DWORD *)(v8 + 136) - 5) > 2)
  {
    uint64_t v14 = *(void *)(a1 + 48);
    v38[0] = MEMORY[0x1895F87A8];
    v38[1] = 3321888768LL;
    CFNumberRef v39 = ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_4;
    unint64_t v40 = &unk_189C06748;
    uint64_t v43 = v14;
    uint64_t v44 = v8;
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 64);
    nw_connection_t v45 = v15;
    if (v15)
    {
      uint64_t v16 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }

    uint64_t v18 = *(void *)(a1 + 40);
    uint64_t v41 = *(void *)(a1 + 32);
    uint64_t v42 = v18;
    int v19 = *(_DWORD *)(a1 + 72);
    int v46 = v19;
    if (v19)
    {
      if (v19 == 2)
      {
        uint64_t v21 = *(void *)(a1 + 56);
        __int16 v22 = *(std::__shared_weak_count **)(v14 + 472);
        v37[0] = *(void *)(v14 + 464);
        v37[1] = (uint64_t)v22;
        if (v22)
        {
          CFIndex v23 = (unint64_t *)&v22->__shared_owners_;
          do
            unint64_t v24 = __ldxr(v23);
          while (__stxr(v24 + 1, v23));
        }

        NWIOConnection::_tlsProcessTrust_PolicyStrict(v21, v37, (uint64_t)v38);
        if (!v22) {
          goto LABEL_51;
        }
        int v25 = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
      }

      else
      {
        if (v19 == 1)
        {
          uint64_t v20 = *(void *)(a1 + 56);
          if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1) {
            dispatch_once( &TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce,  &__block_literal_global_1697);
          }
          TrustExceptionManager::storeTrustExceptions( (TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton,  *(const __CFData **)(v20 + 432),  *(SecTrustRef *)(v20 + 448));
          v39(v38, 0);
          goto LABEL_51;
        }

        uint64_t v27 = *(void *)(v18 + 8);
        *(void *)(v27 + 4_Block_object_dispose(va, 8) = 1LL;
        *(_DWORD *)(v27 + 56) = 22;
        uint64_t v35 = 0LL;
        uint64_t v36 = 0LL;
        uint64_t v33 = 0LL;
        unint64_t v34 = 0LL;
        (*(void (**)(void, void, uint64_t *, uint64_t *, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  0LL,  &v35,  &v33,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL),  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 56LL));
        CFIndex v28 = v34;
        if (v34)
        {
          __int16 v29 = (unint64_t *)&v34->__shared_owners_;
          do
            unint64_t v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }

        __int16 v22 = v36;
        if (!v36) {
          goto LABEL_51;
        }
        __int16 v31 = (unint64_t *)&v36->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v31);
        while (__stlxr(v26 - 1, v31));
      }

      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }

      goto LABEL_51;
    }

    NWIOConnection::_tlsProcessTrust_PolicyDefault(*(void *)(a1 + 56), (uint64_t)v38);
LABEL_51:
    uint64_t v5 = v45;
    if (!v45) {
      return;
    }
    CFIndex v32 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(v32);
    while (__stlxr(v7 - 1, v32));
    goto LABEL_21;
  }

  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
  *(void *)(v9 + 4_Block_object_dispose(va, 8) = 1LL;
  *(_DWORD *)(v9 + 56) = 89;
  uint64_t v49 = 0LL;
  double v50 = 0LL;
  uint64_t v47 = 0LL;
  double v48 = 0LL;
  (*(void (**)(void, void, uint64_t *, uint64_t *, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  0LL,  &v49,  &v47,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL),  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 56LL));
  uint64_t v10 = v48;
  if (v48)
  {
    uint64_t v11 = (unint64_t *)&v48->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  uint64_t v5 = v50;
  if (v50)
  {
    uint64_t v13 = (unint64_t *)&v50->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(v13);
    while (__stlxr(v7 - 1, v13));
    goto LABEL_21;
  }

void sub_182A61A48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
}

void ___ZN14NWIOConnection37_tlsProcessValidateServerTrust_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEENS1_IK9__CFArrayEEU13block_pointerFvbS6_S9_13CFStreamErrorE_block_invoke_4( void *a1, unsigned int a2)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1[7];
  if ((*(_WORD *)(v3 + 248) & 0x60) != 0 || (*(_DWORD *)(v3 + 136) - 5) <= 2)
  {
    uint64_t v4 = *(void *)(a1[5] + 8LL);
    *(void *)(v4 + 4_Block_object_dispose(va, 8) = 1LL;
    *(_DWORD *)(v4 + 56) = 89;
    uint64_t v52 = 0LL;
    uint64_t v53 = 0LL;
    uint64_t v50 = 0LL;
    uint64_t v51 = 0LL;
    (*(void (**)(void))(a1[4] + 16LL))();
  }

  else
  {
    uint64_t v6 = (void *)a1[6];
    if (a2) {
      int v7 = *MEMORY[0x1896051C0];
    }
    else {
      int v7 = 0;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v8 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = v6[36];
      *(_DWORD *)__int128 buf = 134218240;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      _os_log_impl(&dword_18298D000, v8, OS_LOG_TYPE_DEFAULT, "Connection %llu: TLS Trust result %d", buf, 0x12u);
    }

    uint64_t v11 = v6[56];
    uint64_t v10 = (std::__shared_weak_count *)v6[57];
    *(void *)__int128 buf = v11;
    *(void *)&uint8_t buf[8] = v10;
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }

    uint64_t v14 = (std::__shared_weak_count *)v6[61];
    uint64_t v48 = v6[60];
    uint64_t v49 = v14;
    if (v14)
    {
      uint64_t v15 = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }

    if (!a2)
    {
      __int128 v47 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v6 + 56), &v47);
      unint64_t v17 = (std::__shared_weak_count *)*((void *)&v47 + 1);
      if (*((void *)&v47 + 1))
      {
        uint64_t v18 = (unint64_t *)(*((void *)&v47 + 1) + 8LL);
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }

      __int128 v47 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v6 + 58), &v47);
      uint64_t v20 = (std::__shared_weak_count *)*((void *)&v47 + 1);
      if (*((void *)&v47 + 1))
      {
        uint64_t v21 = (unint64_t *)(*((void *)&v47 + 1) + 8LL);
        do
          unint64_t v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }

      __int128 v47 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)(v6 + 60), &v47);
      CFIndex v23 = (std::__shared_weak_count *)*((void *)&v47 + 1);
      if (*((void *)&v47 + 1))
      {
        unint64_t v24 = (unint64_t *)(*((void *)&v47 + 1) + 8LL);
        do
          unint64_t v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
          std::__shared_weak_count::__release_weak(v23);
        }
      }

      uint64_t v11 = *(void *)buf;
      uint64_t v10 = *(std::__shared_weak_count **)&buf[8];
    }

    uint64_t v26 = a1[4];
    uint64_t v45 = v11;
    int v46 = v10;
    if (v10)
    {
      uint64_t v27 = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
    }

    uint64_t v43 = v48;
    uint64_t v44 = v49;
    if (v49)
    {
      __int16 v29 = (unint64_t *)&v49->__shared_owners_;
      do
        unint64_t v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }

    (*(void (**)(uint64_t, BOOL, uint64_t *, uint64_t *, void, void))(v26 + 16))( v26,  a2 == 0,  &v45,  &v43,  v7,  a2);
    __int16 v31 = v44;
    if (v44)
    {
      CFIndex v32 = (unint64_t *)&v44->__shared_owners_;
      do
        unint64_t v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }

    unint64_t v34 = v46;
    if (v46)
    {
      uint64_t v35 = (unint64_t *)&v46->__shared_owners_;
      do
        unint64_t v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
    }

    uint64_t v37 = v49;
    if (v49)
    {
      uint64_t v38 = (unint64_t *)&v49->__shared_owners_;
      do
        unint64_t v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }

    unint64_t v40 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      uint64_t v41 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
  }

void sub_182A61ED4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void NWIOConnection::_tlsProcessTrust_PolicyStrict(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  unsigned int Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_18C5AE048);
  ATSVersion = StrictSecurity::getATSVersion(Value, v7);
  if (Value)
  {
    uint64_t v10 = CFDictionaryGetValue(Value, &unk_18C5ACF38);
    uint64_t v9 = (uint64_t)v10;
    if (v10)
    {
      CFTypeID v11 = CFGetTypeID(v10);
      if (v11 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  buf,  2u);
      }

      uint64_t v9 = *MEMORY[0x189604DE8] == v9;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  v38[0] = 0LL;
  v38[1] = v38;
  void v38[2] = 0x4012000000LL;
  v38[3] = __Block_byref_object_copy__160;
  v38[4] = __Block_byref_object_dispose__161;
  uint64_t v39 = 0LL;
  unint64_t v40 = 0LL;
  v38[5] = &unk_182CE6F99;
  unint64_t v12 = *(std::__shared_weak_count **)(a1 + 264);
  if (v12)
  {
    unint64_t v40 = std::__shared_weak_count::lock(v12);
    if (v40) {
      uint64_t v39 = *(void *)(a1 + 256);
    }
  }

  uint64_t v13 = *a2;
  uint64_t v14 = *(void *)(a1 + 120);
  uint64_t v15 = MEMORY[0x1895F87A8];
  v30[0] = MEMORY[0x1895F87A8];
  v30[1] = 3221225472LL;
  __int16 v31 = ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke;
  CFIndex v32 = &unk_189C067F0;
  uint64_t v35 = a1;
  unint64_t v36 = ATSVersion;
  int v37 = v9;
  uint64_t v33 = a3;
  unint64_t v34 = v38;
  CFErrorRef err = 0LL;
  unint64_t v16 = (const void *)SecTrustDeserialize();
  unint64_t v17 = v16;
  BOOL v18 = err || v16 == 0LL;
  BOOL v19 = v18;
  if (v18)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v20 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      CFErrorRef v21 = err;
      if (err) {
        CFIndex Code = CFErrorGetCode(err);
      }
      else {
        CFIndex Code = 0LL;
      }
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v21;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = Code;
      _os_log_error_impl( &dword_18298D000,  v20,  OS_LOG_TYPE_ERROR,  "Failed to deserialize cloned ATS trust %@ [%ld]",  buf,  0x16u);
    }
  }

  else
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x4012000000LL;
    uint64_t v44 = __Block_byref_object_copy__131;
    uint64_t v45 = __Block_byref_object_dispose__132;
    int v46 = &unk_182CE6F99;
    std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>(&v47, v16);
    uint64_t v23 = *(void *)(*(void *)&buf[8] + 48LL);
    v41[0] = v15;
    v41[1] = 3221225472LL;
    void v41[2] = ___ZN14StrictSecurity33performSystemTrustEvaluationAsyncEPK8__CFDataNS_21SessionStrengthPolicyEN14CFNetworkTrust26SignatureAlgorithmStrengthEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFviE_block_invoke;
    v41[3] = &unk_189C137C8;
    v41[4] = v30;
    v41[5] = buf;
    CFNetworkTrust::strictEvaluateAsync(v23, 1LL, v9, v14, (uint64_t)v41);
    _Block_object_dispose(buf, 8);
    unint64_t v24 = v48;
    if (v48)
    {
      p_shared_owners = (unint64_t *)&v48->__shared_owners_;
      do
        unint64_t v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }

  if (err) {
    CFRelease(err);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v19) {
LABEL_40:
  }
    v31((uint64_t)v30, 0);
  _Block_object_dispose(v38, 8);
  uint64_t v27 = v40;
  if (v40)
  {
    unint64_t v28 = (unint64_t *)&v40->__shared_owners_;
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

void sub_182A622F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (v18) {
    CFRelease(v18);
  }
  _Block_object_dispose(&a18, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v19 + 48);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__163(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  return result;
}

uint64_t __Block_byref_object_dispose__164(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

__n128 __Block_byref_object_copy__160(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  return result;
}

uint64_t __Block_byref_object_dispose__161(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN14NWIOConnection30_tlsProcessTrust_PolicyDefaultEU13block_pointerFviE_block_invoke( void *a1, int a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if ((a2 - 1) < 2)
  {
    uint64_t v3 = a1[7];
    int v4 = CFNetworkTrust::errorForEvaluationFalure(*(CFNetworkTrust **)(*(void *)(a1[5] + 8LL) + 48LL));
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v5 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(v3 + 288);
      *(_DWORD *)uint64_t v13 = 134218240;
      *(void *)&void v13[4] = v6;
      *(_WORD *)&v13[12] = 1024;
      *(_DWORD *)&v13[14] = v4;
      _os_log_error_impl( &dword_18298D000,  v5,  OS_LOG_TYPE_ERROR,  "Connection %llu: default TLS Trust evaluation failed(%d)",  v13,  0x12u);
    }
  }

  (*(void (**)(void))(a1[4] + 16LL))();
  *(void *)uint64_t v13 = 0LL;
  *(void *)&v13[8] = 0LL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(a1[5] + 8LL) + 48LL, (__int128 *)v13);
  int v7 = *(std::__shared_weak_count **)&v13[8];
  if (*(void *)&v13[8])
  {
    uint64_t v8 = (unint64_t *)(*(void *)&v13[8] + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  *(void *)uint64_t v13 = 0LL;
  *(void *)&v13[8] = 0LL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(a1[6] + 8LL) + 48LL, (__int128 *)v13);
  uint64_t v10 = *(std::__shared_weak_count **)&v13[8];
  if (*(void *)&v13[8])
  {
    CFTypeID v11 = (unint64_t *)(*(void *)&v13[8] + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

void ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke( uint64_t a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 48);
  if (!a2)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x4012000000LL;
    BOOL v18 = __Block_byref_object_copy__163;
    uint64_t v19 = __Block_byref_object_dispose__164;
    uint64_t v20 = &unk_182CE6F99;
    std::allocate_shared[abi:nn180100]<CFNetworkTrust,std::allocator<CFNetworkTrust>,__SecTrust *,void>( &v21,  *(const void **)(v3 + 448));
    uint64_t v9 = *(void *)(*(void *)&buf[8] + 48LL);
    uint64_t v10 = *(void *)(a1 + 56);
    uint64_t v11 = *(unsigned int *)(a1 + 64);
    uint64_t v12 = *(void *)(v3 + 120);
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    void v16[2] = ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke_166;
    v16[3] = &unk_189C06818;
    uint64_t v13 = *(void *)(a1 + 40);
    v16[4] = *(void *)(a1 + 32);
    void v16[5] = buf;
    v16[6] = v13;
    v16[7] = v3;
    CFNetworkTrust::strictEvaluateAsync(v9, v10, v11, v12, (uint64_t)v16);
    _Block_object_dispose(buf, 8);
    uint64_t v6 = v22;
    if (!v22) {
      return;
    }
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    goto LABEL_13;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v5 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = *(void *)(v3 + 288);
    *(_DWORD *)__int128 buf = 134218240;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_error_impl( &dword_18298D000,  v5,  OS_LOG_TYPE_ERROR,  "Connection %llu: system TLS Trust evaluation failed(%d)",  buf,  0x12u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  *(void *)__int128 buf = 0LL;
  *(void *)&uint8_t buf[8] = 0LL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]( *(void *)(*(void *)(a1 + 40) + 8LL) + 48LL,  (__int128 *)buf);
  uint64_t v6 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    int v7 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
LABEL_13:
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A6275C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void ___ZN14NWIOConnection29_tlsProcessTrust_PolicyStrictENSt3__110shared_ptrIK8__CFDataEEU13block_pointerFviE_block_invoke_166( void *a1, int a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v4 = a1[7];
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v5 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = *(void *)(v4 + 288);
      *(_DWORD *)uint64_t v13 = 134218240;
      *(void *)&void v13[4] = v12;
      *(_WORD *)&v13[12] = 1024;
      *(_DWORD *)&v13[14] = a2;
      _os_log_error_impl( &dword_18298D000,  v5,  OS_LOG_TYPE_ERROR,  "Connection %llu: strict TLS Trust evaluation failed(%d)",  v13,  0x12u);
    }
  }

  (*(void (**)(void))(a1[4] + 16LL))();
  *(void *)uint64_t v13 = 0LL;
  *(void *)&v13[8] = 0LL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(a1[5] + 8LL) + 48LL, (__int128 *)v13);
  uint64_t v6 = *(std::__shared_weak_count **)&v13[8];
  if (*(void *)&v13[8])
  {
    int v7 = (unint64_t *)(*(void *)&v13[8] + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  *(void *)uint64_t v13 = 0LL;
  *(void *)&v13[8] = 0LL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(a1[6] + 8LL) + 48LL, (__int128 *)v13);
  uint64_t v9 = *(std::__shared_weak_count **)&v13[8];
  if (*(void *)&v13[8])
  {
    uint64_t v10 = (unint64_t *)(*(void *)&v13[8] + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

void std::__shared_ptr_pointer<__CFArray *,Deleter_CFRelease,std::allocator<__CFArray>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<__CFData const*,Deleter_CFRelease,std::allocator<__CFData const>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void *__copy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE( void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a2[10];
  result[9] = a2[9];
  result[10] = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  return result;
}

void __destroy_helper_block_e8_40c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE56c38_ZTSNSt3__110shared_ptrI10__SecTrustEE72c37_ZTSNSt3__110shared_ptrIK9__CFArrayEE( uint64_t a1)
{
  uint64_t v2 = a1 + 56;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 72);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void NWIOConnection::_handleError(NWIOConnection *this, CFStreamError a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v5 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = *((void *)this + 36);
    *(_DWORD *)__int128 buf = 134218496;
    uint64_t v9 = v7;
    __int16 v10 = 2048;
    CFIndex v11 = domain;
    __int16 v12 = 1024;
    int v13 = v2;
    _os_log_error_impl( &dword_18298D000,  v5,  OS_LOG_TYPE_ERROR,  "Connection %llu: encountered error(%ld:%d)",  buf,  0x1Cu);
  }

  int v6 = *((_DWORD *)this + 34);
  if (v6 == 7)
  {
    *((void *)this + 47) = domain;
    *((void *)this + 4_Block_object_dispose(va, 8) = v2;
LABEL_12:
    if ((*((_WORD *)this + 124) & 0x10) == 0)
    {
      NWIOConnection::_cleanupConnection((nw_connection_t *)this, 0);
      goto LABEL_14;
    }

    NWIOConnection::_signalError(this);
    return;
  }

  if (v6 >= 8) {
    __assert_rtn("_changeState", "TransportConnection.cpp", 288, "newState >= _state");
  }
  *((_DWORD *)this + 3os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 7;
  *((void *)this + 47) = domain;
  *((void *)this + 4_Block_object_dispose(va, 8) = v2;
  if (v6 >= 4) {
    goto LABEL_12;
  }
  NWIOConnection::_cleanupConnection((nw_connection_t *)this, 0);
  if (v6 >= 1) {
LABEL_14:
  }
    NWIOConnection::_signalEstablished(this);
}

void sub_182A62BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_206( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_2;
  v5[3] = &__block_descriptor_56_e24_v20__0____CFString__8B16l;
  v5[4] = v3;
  void v5[5] = a2;
  v5[6] = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 344LL))(v3, v5);
}

void ___ZN14NWIOConnection39_tlsCopyClientCertificatesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke( uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL), v3);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_182A62C9C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke( uint64_t a1, dispatch_data_s *a2)
{
  CFMutableArrayRef Mutable = (unint64_t *)CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  CFTypeRef v5 = Mutable;
  unint64_t v16 = Mutable;
  if (Mutable)
  {
    CFMutableArrayRef Mutable = (unint64_t *)operator new(0x20uLL);
    unint64_t *Mutable = (unint64_t)off_189C12750;
    Mutable[1] = 0LL;
    Mutable[2] = 0LL;
    Mutable[3] = (unint64_t)v5;
  }

  unint64_t v17 = (std::__shared_weak_count *)Mutable;
  v14[0] = MEMORY[0x1895F87A8];
  v14[1] = 3321888768LL;
  unsigned __int8 v14[2] = ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke_2;
  v14[3] = &__block_descriptor_48_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
  void v14[4] = v5;
  uint64_t v15 = (std::__shared_weak_count *)Mutable;
  if (Mutable)
  {
    int v6 = Mutable + 1;
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  dispatch_data_apply(a2, v14);
  if (v5) {
    CFTypeRef v5 = CFRetain(v5);
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL), v5);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v8 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  CFIndex v11 = v17;
  if (v17)
  {
    __int16 v12 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

void sub_182A62E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection39_tlsCopyDistinguishedNamesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke_2( uint64_t a1, int a2, int a3, UInt8 *bytes, CFIndex length)
{
  return 1LL;
}

uint64_t __copy_helper_block_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    SecCertificateRef v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c35_ZTSNSt3__110shared_ptrI8__CFDataEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void std::__shared_ptr_pointer<__CFData *,Deleter_CFRelease,std::allocator<__CFData>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<__CFData *,Deleter_CFRelease,std::allocator<__CFData>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN14NWIOConnection37_tlsCopyPeerCertificatesUsingMetadataEPU35objcproto24OS_sec_protocol_metadata8NSObject_block_invoke( uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL), v3);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_182A62F34(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_2(void *a1, void *a2, char a3)
{
  if (a2)
  {
    if ((a3 & 1) == 0)
    {
      uint64_t v5 = a1[4];
      unint64_t v4 = (void *)a1[5];
      uint64_t v6 = a1[6];
      unsigned int Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 368), &unk_18C5AB3A8);
      v8[0] = MEMORY[0x1895F87A8];
      v8[1] = 3221225472LL;
      _DWORD v8[2] = ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_3;
      void v8[3] = &__block_descriptor_40_e66_v40__0____CFString__8____CFArray__16____CFData__24____CFString__32l;
      v8[4] = v5;
      v9[0] = MEMORY[0x1895F87A8];
      v9[1] = 3221225472LL;
      void v9[2] = ___ZN18H2CoalescingEngine31updateCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke;
      v9[3] = &unk_189C17CB8;
      v9[4] = v8;
      __NSURLSession_CoalescingGetCoalescingCCEntryHostWithDNSRecord(v4, v6, a2, Value, 0, (uint64_t)v9);
    }
  }

void ___ZN14NWIOConnection30_coalescingValidateServerTrustEv_block_invoke_3( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  unint64_t v7 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(v6 + 288);
    int v9 = 134218242;
    uint64_t v10 = v8;
    __int16 v11 = 2112;
    uint64_t v12 = a5;
    _os_log_impl(&dword_18298D000, v7, OS_LOG_TYPE_DEFAULT, "Connection %llu: coalesced with %@", (uint8_t *)&v9, 0x16u);
  }

uint64_t ___ZN18H2CoalescingEngine31updateCoalescingConnectionEntryEP14__CFDictionaryPKS0_PK10__CFStringPK9__CFArrayU13block_pointerFvS6_S9_PK8__CFDataS6_E_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void NWIOConnection::_signalError(NWIOConnection *this)
{
  uint64_t v2 = *((void *)this + 20);
  SecCertificateRef v3 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  if (v2)
  {
    (*(void (**)(uint64_t, void, void))(*(void *)v2 + 40LL))( v2,  *((void *)this + 47),  *((void *)this + 48));
    int v7 = *((unsigned __int16 *)this + 124);
    uint64_t v6 = (char *)this + 248;
    int v8 = v6[2];
    *(_WORD *)uint64_t v6 = v7 & 0xFFFD;
    v6[2] = (v7 & 0xFFFFFFFD | (v8 << 16)) >> 16;
    if (!v3) {
      return;
    }
  }

  else
  {
    *((_WORD *)this + 124) |= 2u;
    if (!v3) {
      return;
    }
  }

  int v9 = (unint64_t *)&v3->__shared_owners_;
  do
    unint64_t v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }

void sub_182A631C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t NWIOConnection::_copyNetworkSignature(uint64_t this, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  *(void *)this = 0LL;
  if (*(void *)(a2 + 336))
  {
    SecCertificateRef v3 = (void *)this;
    this = *(void *)(a2 + 344);
    if (this)
    {
      this = nw_endpoint_get_type((nw_endpoint_t)this);
      if ((_DWORD)this == 1)
      {
        this = (uint64_t)nw_endpoint_get_address(*(nw_endpoint_t *)(a2 + 344));
        if (this)
        {
          unsigned __int8 v10 = 20;
          this = MEMORY[0x1895F8858](this);
          int v4 = *(unsigned __int8 *)(this + 1);
          if (v4 == 30)
          {
            this = nw_path_get_ipv6_network_signature();
          }

          else
          {
            if (v4 != 2) {
              return this;
            }
            this = nw_path_get_ipv4_network_signature();
          }

          if ((_DWORD)this)
          {
            MEMORY[0x1895F8858](this);
            uint64_t v6 = &v9[-v5];
            unint64_t v7 = 0LL;
            int v8 = &v9[-v5];
            do
            {
              snprintf(v8, 3uLL, "%.2x", v9[v7++]);
              v8 += 2;
            }

            while (v7 < v10);
            this = (uint64_t)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"0x%s", v6);
            *SecCertificateRef v3 = this;
          }
        }
      }
    }
  }

  return this;
}

void sub_182A63378(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  _Unwind_Resume(a1);
}

uint64_t ___ZN14NWIOConnection12copyPropertyEPK10__CFString_block_invoke(uint64_t a1, const char *a2)
{
  CFStringRef v3 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], a2, 0x8000100u);
  if (v3)
  {
    CFStringRef v4 = v3;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
    CFRelease(v4);
  }

  return 1LL;
}

uint64_t __copy_helper_block_e8_32c36_ZTSNSt3__110shared_ptrI9__CFArrayEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    CFStringRef v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c36_ZTSNSt3__110shared_ptrI9__CFArrayEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t ___ZN14NWIOConnection13setPropertiesEPK14__CFDictionary_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 200LL))(*(void *)(a1 + 32));
}

void NWIOConnection::_setPropertyForSSLSettings(CFDictionaryRef *this, const __CFString *a2, const void *a3)
{
  unsigned int Value = (const __CFDictionary *)CFDictionaryGetValue(this[46], &unk_18C5AE048);
  unint64_t v7 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (Value) {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v7, 0LL, Value);
  }
  else {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(v7, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  }
  int v9 = MutableCopy;
  if (a3) {
    CFDictionarySetValue(MutableCopy, a2, a3);
  }
  else {
    CFDictionaryRemoveValue(MutableCopy, a2);
  }
  CFDictionarySetValue(this[46], &unk_18C5AE048, v9);
  if (v9) {
    CFRelease(v9);
  }
}

void sub_182A634F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>( void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  if (*a2)
  {
    uint64_t v5 = operator new(0x20uLL);
    void *v5 = off_189C11328;
    v5[1] = 0LL;
    void v5[2] = 0LL;
    v5[3] = v4;
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  *a2 = 0LL;
  uint64_t v6 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return a1;
}

uint64_t ___ZN14NWIOConnection26_applyPropertyToConnectionEPK10__CFString_block_invoke( xpc_object_t *a1, size_t a2, void *a3)
{
  xpc_object_t value = xpc_array_get_value(a1[4], a2);
  uint64_t v6 = MEMORY[0x186E16728](a3);
  uint64_t v7 = MEMORY[0x1895F92E8];
  if (v6 == MEMORY[0x1895F92E8] && MEMORY[0x186E16728](value) == v7)
  {
    string_ptr = xpc_string_get_string_ptr(a3);
    if (strncmp(string_ptr, "Persistent", 0x20uLL)
      || (int v9 = xpc_string_get_string_ptr(value), strncmp(v9, "Persistent", 0x20uLL)))
    {
      xpc_array_append_value(a1[5], a3);
      xpc_array_append_value(a1[6], value);
    }
  }

  return 1LL;
}

void ___ZN14NWIOConnection26_applyPropertyToConnectionEPK10__CFString_block_invoke_114(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t NWIOConnection::_toDiagnosticLog(nw_endpoint **a1, uint64_t a2)
{
  uint64_t v4 = a1[43];
  uint64_t v5 = a1[44];
  uint64_t v6 = a1[38];
  return (*(uint64_t (**)(uint64_t, const char *, const __CFString *))(*(void *)a2 + 72LL))( a2,  "Connection",  @"{ conn (%llu), local %s => peer %s %s }");
}

void ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerAdaptiveWriteEU13block_pointerFvvE_block_invoke_2( uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    CFStringRef v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A637E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void NWIOConnection::_handleEvent_AdaptiveWriteTimeout(NWIOConnection *this)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v2 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 36);
    int v4 = 134217984;
    uint64_t v5 = v3;
    _os_log_impl( &dword_18298D000,  v2,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: encountered write timeout event",  (uint8_t *)&v4,  0xCu);
  }

  v7.CFIndex domain = 4LL;
  *(void *)&v7.CFErrorRef error = 4294965196LL;
  NWIOConnection::_handleTimeout(this, v7);
}

void NWIOConnection::_handleTimeout(NWIOConnection *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  uint64_t v16 = *MEMORY[0x1895F89C0];
  BOOL v4 = a2.domain == 0;
  BOOL v5 = a2.error == 0;
  if (v4 && v5) {
    CFIndex domain = 1LL;
  }
  else {
    CFIndex domain = a2.domain;
  }
  if (v4 && v5) {
    uint64_t error = 60LL;
  }
  else {
    uint64_t error = a2.error;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  unint64_t v8 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v9 = *((void *)this + 36);
    int v10 = 134218496;
    uint64_t v11 = v9;
    __int16 v12 = 2048;
    CFIndex v13 = domain;
    __int16 v14 = 1024;
    int v15 = error;
    _os_log_error_impl( &dword_18298D000,  v8,  OS_LOG_TYPE_ERROR,  "Connection %llu: timed out with error(%ld:%d)",  (uint8_t *)&v10,  0x1Cu);
  }

  if (*((void *)this + 34))
  {
    *(void *)&v17.uint64_t error = v2 & 0xFFFFFFFF00000000LL | error;
    v17.CFIndex domain = domain;
    NWIOConnection::_handleError(this, v17);
    NWIOConnection::_cleanupConnection((nw_connection_t *)this, 0);
  }

uint64_t ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerAdaptiveWriteEU13block_pointerFvvE_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 4030LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void ___ZN14NWIOConnection51_applyPropertyToConnection_EventHandlerAdaptiveReadEU13block_pointerFvvE_block_invoke_2( uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      BOOL v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A63B10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void NWIOConnection::_handleEvent_AdaptiveReadTimeout(NWIOConnection *this)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v2 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 36);
    int v4 = 134217984;
    uint64_t v5 = v3;
    _os_log_impl( &dword_18298D000,  v2,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: encountered read timeout event",  (uint8_t *)&v4,  0xCu);
  }

  v7.CFIndex domain = 4LL;
  *(void *)&v7.uint64_t error = 4294965195LL;
  NWIOConnection::_handleTimeout(this, v7);
}

uint64_t ___ZN14NWIOConnection51_applyPropertyToConnection_EventHandlerAdaptiveReadEU13block_pointerFvvE_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 3988LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void ___ZN14NWIOConnection57_applyPropertyToConnection_EventHandlerExcessiveKeepaliveEU13block_pointerFvvE_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A63D00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t NWIOConnection::_handleEvent_ExcessiveKeepalive(NWIOConnection *this)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v2 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 36);
    int v5 = 134217984;
    uint64_t v6 = v3;
    _os_log_impl( &dword_18298D000,  v2,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: encountered excessive keepalive event",  (uint8_t *)&v5,  0xCu);
  }

  uint64_t result = *((void *)this + 79);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, 0LL);
  }
  return result;
}

void ___ZN14NWIOConnection52_applyPropertyToConnection_EventHandlerLowThroughputEU13block_pointerFvyEb_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    int v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

void sub_182A63EA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t NWIOConnection::_handleEvent_LowThroughput(NWIOConnection *this, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  int v4 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *((void *)this + 36);
    int v7 = 134218240;
    uint64_t v8 = v5;
    __int16 v9 = 2048;
    uint64_t v10 = a2;
    _os_log_impl( &dword_18298D000,  v4,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: encountered low throughput event %llu",  (uint8_t *)&v7,  0x16u);
  }

  uint64_t result = *((void *)this + 80);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, 0LL);
  }
  return result;
}

void ___ZN14NWIOConnection7sendEOFEv_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 2)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v3 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v4 = *(void *)(v2 + 288);
      int v5 = 134217984;
      uint64_t v6 = v4;
      _os_log_debug_impl(&dword_18298D000, v3, OS_LOG_TYPE_DEBUG, "Connection %llu: sent EOF", (uint8_t *)&v5, 0xCu);
    }
  }

uint64_t ___ZN14NWIOConnection16writeWithContextEPU32objcproto21OS_nw_content_context8NSObjectN26ContextReadWriteConnection17WriteContextStateEPU27objcproto16OS_dispatch_dataS0_U13block_pointerFv13CFStreamErrorE_block_invoke( uint64_t result, nw_error *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(result + 56);
  if ((*(_WORD *)(v2 + 248) & 0x60) == 0 && (*(_DWORD *)(v2 + 136) - 5) >= 2)
  {
    uint64_t v4 = (void *)result;
    uint64_t v5 = *(void *)(result + 48);
    NWIOConnection::_watchdogTouch((NWIOConnection *)v5, 0);
    uint64_t v6 = *(IOLogger **)(v5 + 392);
    if (v6 && !a2 && v4[9])
    {
      int v7 = (*(unsigned __int16 *)(v5 + 248) >> 12) & 1;
      uint64_t v8 = (dispatch_data_s *)v4[4];
      size_t size_ptr = 0LL;
      *(void *)buffer_ptr = 0LL;
      dispatch_data_t v9 = dispatch_data_create_map(v8, (const void **)buffer_ptr, &size_ptr);
      IOLogger::logBytesSent(v6, v7, *(const unsigned __int8 **)buffer_ptr, size_ptr);
      dispatch_release(v9);
    }

    else if (a2)
    {
      uint64_t v10 = NWIOConnection::_convertError(v5, a2);
      int v12 = v11;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      CFIndex v13 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = *(void *)(v5 + 288);
        *(_DWORD *)buffer_ptr = 134218496;
        *(void *)&buffer_ptr[4] = v14;
        __int16 v17 = 2048;
        uint64_t v18 = v10;
        __int16 v19 = 1024;
        int v20 = v12;
        _os_log_error_impl( &dword_18298D000,  v13,  OS_LOG_TYPE_ERROR,  "Connection %llu: write error %ld:%d",  buffer_ptr,  0x1Cu);
      }
    }

    return (*(uint64_t (**)(void))(v4[5] + 16LL))();
  }

  return result;
}

uint64_t NWIOConnection::_convertError(uint64_t a1, nw_error_t error)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (error)
  {
    uint64_t v3 = nw_error_copy_cf_error(error);
    uint64_t v4 = _CFStreamErrorFromCFError(v3);
    int v6 = v5;
    if (v3) {
      CFRelease(v3);
    }
  }

  else if (*(void *)(a1 + 272))
  {
    int v6 = 0;
    uint64_t v4 = 0LL;
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    int v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = *(void *)(a1 + 288);
      *(_DWORD *)unint64_t v22 = 134217984;
      *(void *)&v22[4] = v21;
      _os_log_debug_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_DEBUG,  "Connection %llu: generating ENOTCONN, since in an error state with no error and no connection",  v22,  0xCu);
    }

    uint64_t v4 = 1LL;
    int v6 = 57;
  }

  if (*(int *)(a1 + 136) <= 2 && v4 == 1 && v6 == 57LL)
  {
    unsigned int Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), &unk_18C5AD830);
    uint64_t v10 = Value;
    if (Value)
    {
      int v11 = CFDictionaryGetValue(Value, @"kConditionalConnectionRequirementTimeWindowStartTime");
      int v12 = (const __CFNumber *)CFDictionaryGetValue(v10, @"kConditionalConnectionRequirementTimeWindowDuration");
      if (v11 && v12 != 0LL)
      {
        *(void *)unint64_t v22 = 0LL;
        if (CFNumberGetValue(v12, kCFNumberDoubleType, v22))
        {
          double v14 = MEMORY[0x186E12AB0](v11);
          double v15 = *(double *)v22;
          if (v14 + v15 <= CFAbsoluteTimeGetCurrent()) {
            int v6 = 60;
          }
        }
      }
    }
  }

  if (!v6)
  {
    if (*(int *)(a1 + 136) >= 3)
    {
      if ((*(_WORD *)(a1 + 248) & 0x1800) == 0x800)
      {
        uint64_t v4 = (int)*MEMORY[0x1896051C0];
        int v6 = -9806;
      }

      else
      {
        uint64_t v4 = 1LL;
        int v6 = 53;
      }
    }

    else
    {
      uint64_t v4 = 1LL;
      int v6 = 2;
    }

    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v16 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = *(void *)(a1 + 288);
      *(_DWORD *)unint64_t v22 = 134218496;
      *(void *)&v22[4] = v19;
      __int16 v23 = 2048;
      uint64_t v24 = v4;
      __int16 v25 = 1024;
      int v26 = v6;
      _os_log_error_impl( &dword_18298D000,  v16,  OS_LOG_TYPE_ERROR,  "Connection %llu: missing error, so heuristics synthesized error(%ld:%d)",  v22,  0x1Cu);
    }
  }

  if (v4 == 1 && v6 == 54LL)
  {
    if ((*(_WORD *)(a1 + 248) & 0x1800) == 0x800)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      __int16 v17 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        uint64_t v20 = *(void *)(a1 + 288);
        *(_DWORD *)unint64_t v22 = 134217984;
        *(void *)&v22[4] = v20;
        _os_log_error_impl( &dword_18298D000,  v17,  OS_LOG_TYPE_ERROR,  "Connection %llu: received ECONNRESET with incomplete TLS handshake - generating errSSLClosedNoNotify",  v22,  0xCu);
      }

      return (int)*MEMORY[0x1896051C0];
    }

    else
    {
      return 1LL;
    }
  }

  return v4;
}

void sub_182A645E0(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection14_watchdogTouchEb_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 3)
      {
        v8.CFIndex domain = 4LL;
        *(void *)&v8.uint64_t error = 4294965192LL;
        NWIOConnection::_handleTimeout((NWIOConnection *)v5, v8);
      }

      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A646AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ___ZN14NWIOConnection15readWithContextEPU32objcproto21OS_nw_content_context8NSObjectjjU13block_pointerFvS2_PU27objcproto16OS_dispatch_dataS0_b13CFStreamErrorE_block_invoke( uint64_t result, dispatch_data_t data, uint64_t a3, int a4, nw_error *a5)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(void *)(result + 56);
  if ((*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
  {
    uint64_t v9 = result;
    uint64_t v10 = *(void *)(result + 48);
    if (data) {
      size_t size = dispatch_data_get_size(data);
    }
    else {
      size_t size = 0LL;
    }
    NWIOConnection::_watchdogTouch((NWIOConnection *)v10, 0);
    if (size)
    {
      uint64_t v12 = *(void *)(v10 + 584);
      if (v12)
      {
        BOOL isCellular = NWIOConnection::_isCellular((NWIOConnection *)v10);
        BOOL isExpensive = NWIOConnection::_isExpensive((NWIOConnection *)v10);
        __ConditionalConnectionDUETSupport_ReportBytes(v12, size, isCellular, isExpensive, 0);
      }
    }

    if (data)
    {
      double v15 = *(IOLogger **)(v10 + 392);
      if (v15)
      {
        int v16 = (*(unsigned __int16 *)(v10 + 248) >> 12) & 1;
        size_t size_ptr = 0LL;
        *(void *)buffer_ptr = 0LL;
        dispatch_data_t v17 = dispatch_data_create_map(data, (const void **)buffer_ptr, &size_ptr);
        IOLogger::logBytesRead(v15, v16, *(const unsigned __int8 **)buffer_ptr, size_ptr);
        dispatch_release(v17);
      }
    }

    if (a5)
    {
      uint64_t v18 = NWIOConnection::_convertError(v10, a5);
      LODWORD(a5) = v19;
      if (!size) {
        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v18 = 0LL;
      if (!size)
      {
LABEL_18:
        uint64_t v20 = *(nw_content_context **)(v9 + 32);
        int v21 = 78;
        if (v20)
        {
          if (nw_content_context_get_is_final(v20)) {
            int v21 = 89;
          }
          else {
            int v21 = 78;
          }
        }

        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        unint64_t v22 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v23 = *(void *)(v10 + 288);
          if (a4) {
            int v24 = 89;
          }
          else {
            int v24 = 78;
          }
          *(_DWORD *)buffer_ptr = 134219008;
          *(void *)&buffer_ptr[4] = v23;
          __int16 v27 = 2048;
          uint64_t v28 = v18;
          __int16 v29 = 1024;
          int v30 = (int)a5;
          __int16 v31 = 1024;
          int v32 = v24;
          __int16 v33 = 1024;
          int v34 = v21;
          _os_log_impl( &dword_18298D000,  v22,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: final read %ld:%d, complete[%c], final[%c]",  buffer_ptr,  0x28u);
        }
      }
    }

    return (*(uint64_t (**)(void))(*(void *)(v9 + 40) + 16LL))();
  }

  return result;
}

uint64_t ___ZN14NWIOConnection5writeEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFv13CFStreamErrorE_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t ___ZN14NWIOConnection4readEjjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke( uint64_t a1, nw_content_context_t context, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = *(void *)(a1 + 32);
  if (context) {
    uint64_t is_final = 0LL;
  }
  else {
    uint64_t is_final = a4;
  }
  if (context && a4) {
    uint64_t is_final = nw_content_context_get_is_final(context);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v9 + 16))(v9, a3, is_final, a5, a6);
}

uint64_t ___ZN14NWIOConnection4openEv_block_invoke(uint64_t a1)
{
  return NWIOConnection::_signalEstablished(*(NWIOConnection **)(a1 + 32));
}

void ___ZN14NWIOConnection16_startConnectionEv_block_invoke(uint64_t a1)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int16 *)(v3 + 248);
  int v5 = v4 | (*(unsigned __int8 *)(v3 + 250) << 16);
  if ((v4 & 0x200) != 0)
  {
    *(_BYTE *)(v3 + 250) = BYTE2(v5);
    *(_WORD *)(v3 + 24_Block_object_dispose(va, 8) = v5 | 0x800;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    int v6 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(v3 + 288);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v7;
      _os_log_impl(&dword_18298D000, v6, OS_LOG_TYPE_DEFAULT, "Connection %llu: enabling TLS", (uint8_t *)&buf, 0xCu);
    }
  }

  uint64_t v8 = *(void *)(a1 + 40);
  if (!CFDictionaryGetValue(*(CFDictionaryRef *)(v8 + 368), &unk_18C5AD830))
  {
    NWIOConnection::_startConnection_Completion((NWIOConnection *)v8);
    return;
  }

  gotLoadHelper_x8__OBJC_CLASS____DASActivity(v9);
  if (objc_opt_class())
  {
    nw_parameters_set_discretionary();
    uint64_t v10 = *(std::__shared_weak_count **)(v8 + 264);
    if (v10)
    {
      int v11 = std::__shared_weak_count::lock(v10);
      if (v11)
      {
        uint64_t v12 = *(void *)(v8 + 256);
        goto LABEL_25;
      }
    }

    else
    {
      int v11 = 0LL;
    }

    uint64_t v12 = 0LL;
LABEL_25:
    int v21 = *(const __CFDictionary **)(v8 + 368);
    uint64_t v22 = *(void *)(v8 + 120);
    uint64_t v24 = *(void *)(v8 + 296);
    uint64_t v23 = *(void *)(v8 + 304);
    uint64_t v25 = *(void *)(v8 + 200);
    uint64_t v26 = MEMORY[0x1895F87A8];
    *(void *)&__int128 buf = MEMORY[0x1895F87A8];
    *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
    __int16 v76 = ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke;
    BOOL v77 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e9_C16__0_v8l;
    uint64_t v78 = v8;
    uint64_t v79 = v12;
    uint64_t v80 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v28 = __ldxr(p_shared_owners);
      while (__stxr(v28 + 1, p_shared_owners));
    }

    uint64_t v68 = v26;
    uint64_t v69 = 3321888768LL;
    __int16 v70 = ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_198;
    int v71 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e9_v16__0_v8l;
    uint64_t v72 = v8;
    uint64_t v73 = v12;
    __int16 v74 = v11;
    if (v11)
    {
      __int16 v29 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }

    *(void *)&__int128 v62 = v26;
    *((void *)&v62 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
    unint64_t v63 = ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_201;
    uint64_t v64 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e12_v20__0C8_v12l;
    uint64_t v65 = v8;
    uint64_t v66 = v12;
    int v67 = v11;
    if (v11)
    {
      __int16 v31 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
    }

    __ConditionalConnectionDUETSupport_StartActivity( v21,  v22,  v23,  v24,  v25,  (uint64_t)&buf,  (uint64_t)&v68,  (uint64_t)&v62);
    __int16 v33 = v67;
    if (v67)
    {
      int v34 = (unint64_t *)&v67->__shared_owners_;
      do
        unint64_t v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }

    unint64_t v36 = v74;
    if (v74)
    {
      int v37 = (unint64_t *)&v74->__shared_owners_;
      do
        unint64_t v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }

    uint64_t v39 = v80;
    if (v80)
    {
      unint64_t v40 = (unint64_t *)&v80->__shared_owners_;
      do
        unint64_t v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }

    if (v11)
    {
      unint64_t v42 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v43 = __ldaxr(v42);
      while (__stlxr(v43 - 1, v42));
LABEL_81:
      if (!v43)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }

      return;
    }

    return;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  CFIndex v13 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(v8 + 288);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v14;
    _os_log_impl( &dword_18298D000,  v13,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: setting up SIM scheduler",  (uint8_t *)&buf,  0xCu);
  }

  unsigned int Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v8 + 368), &unk_18C5AD830);
  int v16 = CFDictionaryGetValue(Value, @"kConditionalConnectionRequirementTimeWindowStartTime");
  dispatch_data_t v17 = (const __CFNumber *)CFDictionaryGetValue(Value, @"kConditionalConnectionRequirementTimeWindowDelay");
  uint64_t v18 = (const __CFNumber *)CFDictionaryGetValue(Value, @"kConditionalConnectionRequirementTimeWindowDuration");
  nw_parameters_set_indefinite();
  int v19 = *(std::__shared_weak_count **)(v8 + 264);
  if (v19)
  {
    int v11 = std::__shared_weak_count::lock(v19);
    if (v11)
    {
      uint64_t v20 = *(void *)(v8 + 256);
      goto LABEL_55;
    }
  }

  else
  {
    int v11 = 0LL;
  }

  uint64_t v20 = 0LL;
LABEL_55:
  uint64_t v44 = *(dispatch_object_s **)(v8 + 120);
  uint64_t v45 = MEMORY[0x1895F87A8];
  *(void *)&__int128 buf = MEMORY[0x1895F87A8];
  *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
  __int16 v76 = ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke;
  BOOL v77 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e5_v8__0l;
  uint64_t v78 = v8;
  uint64_t v79 = v20;
  uint64_t v80 = v11;
  if (v11)
  {
    int v46 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v47 = __ldxr(v46);
    while (__stxr(v47 + 1, v46));
  }

  uint64_t v68 = v45;
  uint64_t v69 = 3321888768LL;
  __int16 v70 = ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke_2;
  int v71 = &__block_descriptor_56_e8_40c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE_e5_v8__0l;
  uint64_t v72 = v8;
  uint64_t v73 = v20;
  __int16 v74 = v11;
  if (v11)
  {
    uint64_t v48 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v49 = __ldxr(v48);
    while (__stxr(v49 + 1, v48));
  }

  uint64_t v50 = operator new(0x80uLL);
  v50[1] = 0LL;
  v50[2] = 0LL;
  *uint64_t v50 = off_189C0A3B8;
  ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler( (uint64_t)(v50 + 3),  (uint64_t)v16,  v17,  v18,  v44,  &buf,  &v68);
  *(void *)&__int128 v62 = v50 + 3;
  *((void *)&v62 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v50;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( (uint64_t)&v62,  (void *)v62,  v62);
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 600, &v62);
  uint64_t v51 = (std::__shared_weak_count *)*((void *)&v62 + 1);
  if (*((void *)&v62 + 1))
  {
    uint64_t v52 = (unint64_t *)(*((void *)&v62 + 1) + 8LL);
    do
      unint64_t v53 = __ldaxr(v52);
    while (__stlxr(v53 - 1, v52));
    if (!v53)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }

  ConditionalConnectionSIMScheduler::start(*(ConditionalConnectionSIMScheduler **)(v8 + 600));
  if ((v54 & 1) == 0)
  {
    v82.CFIndex domain = 1LL;
    *(void *)&v82.uint64_t error = 22LL;
    NWIOConnection::_handleError((NWIOConnection *)v8, v82);
  }

  uint64_t v55 = v74;
  if (v74)
  {
    nw_connection_t v56 = (unint64_t *)&v74->__shared_owners_;
    do
      unint64_t v57 = __ldaxr(v56);
    while (__stlxr(v57 - 1, v56));
    if (!v57)
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }

  uint64_t v58 = v80;
  if (v80)
  {
    char v59 = (unint64_t *)&v80->__shared_owners_;
    do
      unint64_t v60 = __ldaxr(v59);
    while (__stlxr(v60 - 1, v59));
    if (!v60)
    {
      ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
      std::__shared_weak_count::__release_weak(v58);
    }
  }

  if (v11)
  {
    CFTypeID v61 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v43 = __ldaxr(v61);
    while (__stlxr(v43 - 1, v61));
    goto LABEL_81;
  }

void sub_182A65004( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, std::__shared_weak_count *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, std::__shared_weak_count *a29)
{
  if (a22)
  {
    p_shared_owners = (unint64_t *)&a22->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(p_shared_owners);
    while (__stlxr(v32 - 1, p_shared_owners));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))a22->__on_zero_shared)(a22);
      std::__shared_weak_count::__release_weak(a22);
    }
  }

  if (a29)
  {
    __int16 v33 = (unint64_t *)&a29->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))a29->__on_zero_shared)(a29);
      std::__shared_weak_count::__release_weak(a29);
    }
  }

  if (v29)
  {
    unint64_t v35 = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke( void *a1, sec_protocol_options *a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v3 = (std::__shared_weak_count *)a1[6];
  if (v3)
  {
    uint64_t v5 = a1[4];
    int v6 = std::__shared_weak_count::lock(v3);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = a1[5];
      if (v8)
      {
        if ((*(_WORD *)(v8 + 248) & 0x60) != 0 || (*(_DWORD *)(v8 + 136) - 5) <= 2)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          double v9 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v10 = *(void *)(v5 + 288);
            *(_DWORD *)__int128 buf = 134217984;
            uint64_t v14 = v10;
            _os_log_impl( &dword_18298D000,  v9,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: Ignoring sec configuration block - connection canceled",  buf,  0xCu);
          }
        }

        else
        {
          NWIOConnection::_tlsConfigure(v8, a2);
        }
      }

      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }

void sub_182A6534C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_43(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  nw_quic_connection_set_idle_timeout();
  nw_quic_connection_set_initial_max_streams_bidirectional();
  nw_quic_connection_set_initial_max_streams_unidirectional();
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 368), &unk_18C5AB6F0)) {
    nw_quic_connection_set_enable_l4s();
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  int v6 = v3;
  if (v3)
  {
    p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_weak_owners);
    while (__stxr(v5 + 1, p_shared_weak_owners));
  }

  nw_quic_connection_set_max_streams_update_block();
  nw_quic_connection_set_keepalive_count();
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_182A65460( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_weak(a14);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_48( uint64_t a1, nw_protocol_options *a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    unint64_t v5 = std::__shared_weak_count::lock(v3);
    uint64_t v24 = v5;
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = *(void *)(a1 + 40);
      uint64_t v23 = v7;
      if (v7)
      {
        unsigned int Value = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_18C5ABF08);
        if (Value)
        {
          int v9 = CFBooleanGetValue(Value);
          int v10 = *(_WORD *)(v7 + 248) & 0xFEFF | (*(unsigned __int8 *)(v7 + 250) << 16);
          BOOL v11 = (v9 != 0) & ((unsigned __int16)(*(_WORD *)(v7 + 248) & 0x200) >> 9);
          if (v11) {
            __int16 v12 = 256;
          }
          else {
            __int16 v12 = 0;
          }
          *(_BYTE *)(v7 + 250) = BYTE2(v10);
          *(_WORD *)(v7 + 24_Block_object_dispose(va, 8) = v10 | v12;
          nw_tcp_options_set_enable_fast_open(a2, v11);
        }

        if (CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_18C5AC720)) {
          nw_tcp_options_set_connection_timeout(a2, 0xAu);
        }
        CFIndex v13 = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_18C5AB6F0);
        uint64_t v14 = (CFTypeRef *)MEMORY[0x189604DE8];
        if (v13) {
          nw_tcp_options_set_enable_l4s();
        }
        uint64_t v15 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_18C5AD168);
        if (v15)
        {
          BOOL v16 = CFBooleanGetValue(v15) != 0;
          nw_tcp_options_set_no_delay(a2, v16);
        }

        dispatch_data_t v17 = CFDictionaryGetValue(*(CFDictionaryRef *)(v7 + 368), &unk_18C5AC950);
        uint64_t v18 = v17;
        if (v17)
        {
          if (!CFEqual(v17, *v14))
          {
            CFTypeID v19 = CFGetTypeID(v18);
            if (v19 == CFNumberGetTypeID())
            {
              int valuePtr = 0;
              CFNumberGetValue((CFNumberRef)v18, kCFNumberSInt32Type, &valuePtr);
            }
          }

          nw_tcp_options_set_enable_background_traffic_management();
        }
      }

      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

void sub_182A65664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_49(uint64_t a1)
{
  id v2 = (id)nw_quic_connection_copy_sec_protocol_options();
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

uint64_t ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_50(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_2_52(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 3)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v4 = (nw_endpoint *)nw_retain(*(void **)(v3 + 304));
    if (*(_BYTE *)(a1 + 64))
    {
      unsigned int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 368), &unk_18C5AB990);
      if (Value) {
        int v6 = (const __CFString *)CFRetain(Value);
      }
      else {
        int v6 = 0LL;
      }
      *(void *)&__int128 v94 = v6;
      uint64_t v7 = (__CFString *)operator new(0x20uLL);
      v7->mach_timebase_info info = 0LL;
      p_mach_timebase_info info = (unint64_t *)&v7->info;
      v7->isa = off_189C17020;
      v7->int data = 0LL;
      v7->CFIndex length = (uint64_t)v6;
      *((void *)&v94 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v7;
      int v9 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 368), &unk_18C5AB9C8);
      LODWORD(valuePtr[0]) = 0;
      int v10 = (void *)nw_protocol_copy_quic_connection_definition();
      if (v6 && v9 && CFNumberGetValue(v9, kCFNumberSInt32Type, valuePtr) && SLODWORD(valuePtr[0]) >= 1)
      {
        v67[0] = v6;
        v67[1] = v7;
        do
          unint64_t v11 = __ldxr(p_info);
        while (__stxr(v11 + 1, p_info));
        NWIOConnection::_createEndpoint(handler, (NWIOConnection *)v3, v67);
        do
          unint64_t v12 = __ldaxr(p_info);
        while (__stlxr(v12 - 1, p_info));
        if (!v12)
        {
          (*((void (**)(__CFString *))v7->isa + 2))(v7);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v7);
        }

        CFIndex v13 = (void *)handler[0];
        nw_endpoint_add_alternative();
        uint64_t v14 = *(void *)(v3 + 200);
        if (v14) {
          *(void *)(v14 + 12_Block_object_dispose(va, 8) = 3LL;
        }
        if (v13) {
          nw_release(v13);
        }
      }

      else
      {
        uint64_t v15 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 368), &unk_18C5AB290);
        BOOL v16 = v15;
        if (!v15) {
          goto LABEL_26;
        }
        CFTypeID v17 = CFGetTypeID(v15);
        if (v17 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
        {
          LOWORD(handler[0]) = 0;
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)handler,  2u);
        }

        if ((const void *)*MEMORY[0x189604DE8] == v16)
        {
          uint64_t v18 = 4LL;
        }

        else
        {
LABEL_26:
          nw_endpoint_add_alternative();
          uint64_t v18 = 2LL;
        }

        uint64_t v19 = *(void *)(v3 + 200);
        if (v19) {
          *(void *)(v19 + 12_Block_object_dispose(va, 8) = v18;
        }
      }

      if (v10) {
        nw_release(v10);
      }
      uint64_t v20 = (std::__shared_weak_count *)*((void *)&v94 + 1);
      if (*((void *)&v94 + 1))
      {
        unint64_t v21 = (unint64_t *)(*((void *)&v94 + 1) + 8LL);
        do
          unint64_t v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }
    }

    uint64_t v23 = (nw_endpoint *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 368), &unk_18C5AB728);
    if (!v23) {
      uint64_t v23 = v4;
    }
    nw_connection_t v24 = nw_connection_create(v23, *(nw_parameters_t *)(v3 + 296));
    *(void *)&__int128 v94 = v24;
    uint64_t v25 = operator new(0x20uLL);
    void *v25 = off_189C06AA8;
    v25[1] = 0LL;
    int v25[2] = 0LL;
    v25[3] = v24;
    *((void *)&v94 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v25;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v3 + 272, &v94);
    uint64_t v26 = (std::__shared_weak_count *)*((void *)&v94 + 1);
    if (*((void *)&v94 + 1))
    {
      __int16 v27 = (unint64_t *)(*((void *)&v94 + 1) + 8LL);
      do
        unint64_t v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }

    if (*(void *)(v3 + 272))
    {
      *(void *)(v3 + 28_Block_object_dispose(va, 8) = nw_connection_get_id();
      TransportConnection::_flushPendingTaskAssociations((TransportConnection *)v3);
      uint64_t v29 = *(void *)(a1 + 48);
      uint64_t v31 = *(void *)(v29 + 256);
      unint64_t v30 = *(std::__shared_weak_count **)(v29 + 264);
      if (v30)
      {
        p_shared_weak_owners = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v33 = __ldxr(p_shared_weak_owners);
        while (__stxr(v33 + 1, p_shared_weak_owners));
      }

      nw_connection_set_queue(*(nw_connection_t *)(v29 + 272), *(dispatch_queue_t *)(v29 + 120));
      *(void *)&__int128 v94 = 0LL;
      *((void *)&v94 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &v94;
      uint64_t v95 = 0x4012000000LL;
      unint64_t v96 = __Block_byref_object_copy__53;
      uint64_t v97 = __Block_byref_object_dispose__54;
      unint64_t v34 = *(nw_connection **)(v29 + 272);
      unint64_t v35 = *(std::__shared_weak_count **)(v29 + 280);
      uint64_t v99 = v34;
      uint64_t v100 = v35;
      if (v35)
      {
        p_shared_owners = (unint64_t *)&v35->__shared_owners_;
        do
          unint64_t v37 = __ldxr(p_shared_owners);
        while (__stxr(v37 + 1, p_shared_owners));
        unint64_t v34 = *(nw_connection **)(v29 + 272);
      }

      uint64_t v38 = MEMORY[0x1895F87A8];
      handler[0] = MEMORY[0x1895F87A8];
      handler[1] = 3321888768LL;
      handler[2] = (uint64_t)___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke;
      handler[3] = (uint64_t)&unk_189C06340;
      void handler[5] = v31;
      CFRange v93 = v30;
      if (v30)
      {
        uint64_t v39 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v40 = __ldxr(v39);
        while (__stxr(v40 + 1, v39));
      }

      handler[4] = (uint64_t)&v94;
      nw_connection_set_state_changed_handler(v34, handler);
      valuePtr[0] = v38;
      valuePtr[1] = 3321888768LL;
      valuePtr[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_57;
      valuePtr[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      valuePtr[4] = v31;
      CFRange v91 = v30;
      if (v30)
      {
        unint64_t v41 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v42 = __ldxr(v41);
        while (__stxr(v42 + 1, v41));
      }

      nw_connection_set_read_close_handler();
      uint64_t v84 = v38;
      uint64_t v85 = 3321888768LL;
      uint64_t v86 = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_59;
      uint64_t v87 = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      uint64_t v88 = v31;
      CFTypeRef v89 = v30;
      if (v30)
      {
        unint64_t v43 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v44 = __ldxr(v43);
        while (__stxr(v44 + 1, v43));
      }

      nw_connection_set_write_close_handler();
      uint64_t v78 = v38;
      uint64_t v79 = 3321888768LL;
      uint64_t v80 = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2;
      uint64_t v81 = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e8_v12__0i8l;
      uint64_t v82 = v31;
      uint64_t v83 = v30;
      if (v30)
      {
        uint64_t v45 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v46 = __ldxr(v45);
        while (__stxr(v46 + 1, v45));
      }

      nw_connection_set_alternate_path_state_handler();
      unint64_t v47 = *(nw_connection **)(v29 + 272);
      v76[0] = v38;
      v76[1] = 3321888768LL;
      v76[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_62;
      v76[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e8_v12__0B8l;
      v76[4] = v31;
      BOOL v77 = v30;
      if (v30)
      {
        uint64_t v48 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v49 = __ldxr(v48);
        while (__stxr(v49 + 1, v48));
      }

      nw_connection_set_viability_changed_handler(v47, v76);
      v74[0] = v38;
      v74[1] = 3321888768LL;
      v74[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_65;
      v74[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e8_v16__0Q8l;
      v74[4] = v31;
      int v75 = v30;
      if (v30)
      {
        uint64_t v50 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v51 = __ldxr(v50);
        while (__stxr(v51 + 1, v50));
      }

      NWIOConnection::_applyPropertyToConnection_EventHandlerLowThroughput(v29, (uint64_t)v74, 0);
      v72[0] = v38;
      v72[1] = 3321888768LL;
      v72[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_68;
      v72[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      v72[4] = v31;
      uint64_t v73 = v30;
      if (v30)
      {
        uint64_t v52 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v53 = __ldxr(v52);
        while (__stxr(v53 + 1, v52));
      }

      NWIOConnection::_applyPropertyToConnection_EventHandlerExcessiveKeepalive(v29, (uint64_t)v72);
      v70[0] = v38;
      v70[1] = 3321888768LL;
      v70[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2_69;
      v70[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      v70[4] = v31;
      int v71 = v30;
      if (v30)
      {
        char v54 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v55 = __ldxr(v54);
        while (__stxr(v55 + 1, v54));
      }

      NWIOConnection::_applyPropertyToConnection_EventHandlerAdaptiveRead(v29, (uint64_t)v70);
      v68[0] = v38;
      v68[1] = 3321888768LL;
      v68[2] = ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_3;
      v68[3] = &__block_descriptor_48_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE_e5_v8__0l;
      v68[4] = v31;
      uint64_t v69 = v30;
      if (v30)
      {
        nw_connection_t v56 = (unint64_t *)&v30->__shared_weak_owners_;
        do
          unint64_t v57 = __ldxr(v56);
        while (__stxr(v57 + 1, v56));
      }

      NWIOConnection::_applyPropertyToConnection_EventHandlerAdaptiveWrite(v29, (uint64_t)v68);
      if (v69) {
        std::__shared_weak_count::__release_weak(v69);
      }
      if (v71) {
        std::__shared_weak_count::__release_weak(v71);
      }
      if (v73) {
        std::__shared_weak_count::__release_weak(v73);
      }
      if (v75) {
        std::__shared_weak_count::__release_weak(v75);
      }
      if (v77) {
        std::__shared_weak_count::__release_weak(v77);
      }
      if (v83) {
        std::__shared_weak_count::__release_weak(v83);
      }
      if (v89) {
        std::__shared_weak_count::__release_weak(v89);
      }
      if (v91) {
        std::__shared_weak_count::__release_weak(v91);
      }
      if (v93) {
        std::__shared_weak_count::__release_weak(v93);
      }
      _Block_object_dispose(&v94, 8);
      uint64_t v64 = v100;
      if (v100)
      {
        uint64_t v65 = (unint64_t *)&v100->__shared_owners_;
        do
          unint64_t v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }

      if (v30) {
        std::__shared_weak_count::__release_weak(v30);
      }
      (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  v58,  v59,  v60,  v61,  v62,  v63);
    }

    else
    {
      v101.CFIndex domain = 1LL;
      *(void *)&v101.uint64_t error = 22LL;
      NWIOConnection::_handleError((NWIOConnection *)v3, v101);
    }

    if (v4) {
      nw_release(v4);
    }
  }

void sub_182A65E0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, std::__shared_weak_count *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, std::__shared_weak_count *a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, std::__shared_weak_count *a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, std::__shared_weak_count *a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, std::__shared_weak_count *a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,std::__shared_weak_count *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,std::__shared_weak_count *a58)
{
  if (v60) {
    nw_release(v60);
  }
  if (v59) {
    nw_release(v59);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v61 - 160);
  if (v58) {
    nw_release(v58);
  }
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

__n128 __Block_byref_object_copy__53(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  return result;
}

uint64_t __Block_byref_object_dispose__54(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke(void *a1, int a2, nw_error *a3)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  uint64_t v76 = 0LL;
  BOOL v77 = 0LL;
  int v6 = (std::__shared_weak_count *)a1[6];
  if (v6 && (BOOL v77 = std::__shared_weak_count::lock(v6)) != 0LL)
  {
    uint64_t v7 = a1[5];
    uint64_t v76 = v7;
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  if (a2 == 5)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0LL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(a1[4] + 8LL) + 48LL, (__int128 *)buf);
    uint64_t v8 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      int v9 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    if (v76)
    {
      int v11 = *(_WORD *)(v76 + 248) & 0xFF9F | (*(unsigned __int8 *)(v76 + 250) << 16);
      *(_WORD *)(v76 + 24_Block_object_dispose(va, 8) = *(_WORD *)(v76 + 248) & 0xFF9F | 0x40;
      *(_BYTE *)(v76 + 250) = BYTE2(v11);
      int v12 = *(_DWORD *)(v76 + 136);
      if (v12 == 7)
      {
LABEL_15:
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        CFIndex v13 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = *(void *)(v76 + 288);
          *(_DWORD *)__int128 buf = 134217984;
          *(void *)&uint8_t buf[4] = v14;
          _os_log_impl(&dword_18298D000, v13, OS_LOG_TYPE_DEFAULT, "Connection %llu: done", buf, 0xCu);
        }

        goto LABEL_22;
      }

      if (v12 <= 6)
      {
        *(_DWORD *)(v76 + 136) = 6;
        goto LABEL_15;
      }

void sub_182A66A48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, std::__shared_weak_count *a23)
{
  if (v24) {
    CFRelease(v24);
  }
  if (v23) {
    CFRelease(v23);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_57(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      unint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        int v6 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = *(void *)(v5 + 288);
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v7;
          _os_log_impl( &dword_18298D000,  v6,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: read-side closed",  (uint8_t *)&buf,  0xCu);
        }

        uint64_t v8 = *(void *)(v5 + 160);
        int v9 = *(std::__shared_weak_count **)(v5 + 168);
        *(void *)&__int128 buf = v8;
        *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v9;
        if (v9)
        {
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            unint64_t v11 = __ldxr(p_shared_owners);
          while (__stxr(v11 + 1, p_shared_owners));
        }

        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 16LL))(v8);
        }
        else {
          NWIOConnection::_handleEvent_Disconnected(v5, 0LL);
        }
        if (v9)
        {
          int v12 = (unint64_t *)&v9->__shared_owners_;
          do
            unint64_t v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
      }

      uint64_t v14 = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A66C8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_59(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      unint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 2)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        int v6 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = *(void *)(v5 + 288);
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v7;
          _os_log_impl( &dword_18298D000,  v6,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: write-side closed",  (uint8_t *)&buf,  0xCu);
        }

        uint64_t v8 = *(void *)(v5 + 160);
        int v9 = *(std::__shared_weak_count **)(v5 + 168);
        *(void *)&__int128 buf = v8;
        *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v9;
        if (v9)
        {
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            unint64_t v11 = __ldxr(p_shared_owners);
          while (__stxr(v11 + 1, p_shared_owners));
        }

        if (v8) {
          (*(void (**)(uint64_t))(*(void *)v8 + 24LL))(v8);
        }
        else {
          NWIOConnection::_handleEvent_Disconnected(v5, 0LL);
        }
        if (v9)
        {
          int v12 = (unint64_t *)&v9->__shared_owners_;
          do
            unint64_t v13 = __ldaxr(v12);
          while (__stlxr(v13 - 1, v12));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
      }

      uint64_t v14 = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A66E84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v8 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(v7 + 288);
        *(_DWORD *)__int128 buf = 134218240;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a2;
        _os_log_impl(&dword_18298D000, v8, OS_LOG_TYPE_DEFAULT, "Connection %llu: received advisory(%d)", buf, 0x12u);
      }

      if ((nw_connection_uses_multipath() & 1) != 0) {
        goto LABEL_32;
      }
      uint64_t v10 = *(void *)(v7 + 160);
      unint64_t v11 = *(std::__shared_weak_count **)(v7 + 168);
      *(void *)__int128 buf = v10;
      *(void *)&uint8_t buf[8] = v11;
      if (v11)
      {
        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          unint64_t v13 = __ldxr(p_shared_owners);
        while (__stxr(v13 + 1, p_shared_owners));
        if (!v10)
        {
          do
            unint64_t v14 = __ldaxr(p_shared_owners);
          while (__stlxr(v14 - 1, p_shared_owners));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }

          goto LABEL_25;
        }
      }

      else if (!v10)
      {
LABEL_25:
        if ((_DWORD)a2 == 1)
        {
          uint64_t v18 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_102, 2);
          uint64_t v22 = (uint64_t)v18;
          if (v18
            && (*(unsigned int (**)(void *, const char *, void))(*(void *)v18 + 16LL))( v18,  "Better Route Detected",  0LL))
          {
            NWIOConnection::_toDiagnosticLog((nw_endpoint **)v7, v22);
            (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
          }

          uint64_t v23 = *(void *)(v7 + 656);
          if (v23) {
            (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v23 + 16))(v23, v19, v20, v21);
          }
          NWIOConnection::_terminateConnectionIfAppropriate((CFDictionaryRef *)v7, 1);
        }

void sub_182A67158( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_62(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7 && (*(_WORD *)(v7 + 248) & 0x60) == 0 && (*(_DWORD *)(v7 + 136) - 5) >= 2)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        uint64_t v8 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v9 = *(void *)(v7 + 288);
          if ((_DWORD)a2) {
            int v10 = 89;
          }
          else {
            int v10 = 78;
          }
          *(_DWORD *)__int128 buf = 134218240;
          uint64_t v17 = v9;
          __int16 v18 = 1024;
          int v19 = v10;
          _os_log_impl( &dword_18298D000,  v8,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: received viability advisory(%c)",  buf,  0x12u);
        }

        unint64_t v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_104, 2);
        uint64_t v12 = (uint64_t)v11;
        if (v11
          && (*(unsigned int (**)(void *, const char *, void))(*(void *)v11 + 16LL))( v11,  "Connection Viability Changed",  0LL))
        {
          NWIOConnection::_toDiagnosticLog((nw_endpoint **)v7, v12);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v12 + 72LL))( v12,  "Viable",  @"%s");
          (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
        }

        uint64_t v13 = *(void *)(v7 + 648);
        if (v13) {
          (*(void (**)(uint64_t, void, uint64_t))(v13 + 16))(v13, 0LL, a2);
        }
        if ((a2 & 1) == 0) {
          NWIOConnection::_terminateConnectionIfAppropriate((CFDictionaryRef *)v7, 0);
        }
      }

      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

void sub_182A673BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_65(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    uint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      int v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

void sub_182A67488( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_68(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      unint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A67540( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_2_69(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      unint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A675F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN14NWIOConnection22_setupConnectionEventsEv_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      unint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A676B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void NWIOConnection::_terminateConnectionIfAppropriate(CFDictionaryRef *this, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  unsigned int Value = CFDictionaryGetValue(this[46], &unk_18C5AD7C0);
  if (!Value) {
    goto LABEL_8;
  }
  uint64_t v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v1_Block_object_dispose(va, 8) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&v18,  2u);
  }

  if ((const void *)*MEMORY[0x189604DE8] == v5)
  {
LABEL_8:
    CFDictionaryRef v8 = this[81];
    BOOL v7 = v8 == 0LL;
    if ((a2 & 1) == 0)
    {
      if (v8) {
        return;
      }
      unint64_t v9 = this + 31;
      __int16 v10 = *((_WORD *)this + 124);
      uint64_t v13 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_87, 2);
      if (v13)
      {
        uint64_t v14 = (uint64_t)v13;
        if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v13 + 16LL))( v13,  "_networkReachabilityChanged",  0LL))
        {
          NWIOConnection::_toDiagnosticLog(this, v14);
          (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v14 + 72LL))( v14,  "conn",  @"issuing error to ECONNABORTED");
          (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
        }
      }

      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      unint64_t v15 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        CFDictionaryRef v16 = this[36];
        int v18 = 134217984;
        CFDictionaryRef v19 = v16;
        _os_log_impl( &dword_18298D000,  v15,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: reachability changed, issuing ECONNABORTED",  (uint8_t *)&v18,  0xCu);
      }

      *((_WORD *)this + 124) |= 0x80u;
      v21.CFIndex domain = 1LL;
      *(void *)&v21.uint64_t error = 53LL;
      NWIOConnection::_handleError((NWIOConnection *)this, v21);
      goto LABEL_23;
    }
  }

  else
  {
    if (!a2) {
      return;
    }
    BOOL v7 = 0;
  }

  unint64_t v9 = this + 31;
  __int16 v10 = *((_WORD *)this + 124);
  unint64_t v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_82, 2);
  if (v11)
  {
    uint64_t v12 = (uint64_t)v11;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v11 + 16LL))( v11,  "_networkReachabilityChanged",  0LL))
    {
      NWIOConnection::_toDiagnosticLog(this, v12);
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v12 + 72LL))( v12,  "conn",  @"keeping alive");
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
  }

uint64_t ___ZN14NWIOConnection33_terminateConnectionIfAppropriateEb_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2310LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection33_terminateConnectionIfAppropriateEb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2298LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection29_handleEvent_ViabilityChangedEb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2917LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

uint64_t ___ZN14NWIOConnection23_handleEvent_BetterPathE36nw_connection_alternate_path_state_t_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2899LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void NWIOConnection::_handleEvent_Disconnected(uint64_t a1, nw_error *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  int v3 = *(_DWORD *)(a1 + 136);
  if (v3 == 4)
  {
    if ((*(_WORD *)(a1 + 248) & 0x10) != 0)
    {
      uint64_t v4 = *(void *)(a1 + 160);
      if (v4)
      {
        uint64_t v5 = *(std::__shared_weak_count **)(a1 + 168);
        *(void *)__int128 buf = v4;
        *(void *)&uint8_t buf[8] = v5;
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            unint64_t v7 = __ldxr(p_shared_owners);
          while (__stxr(v7 + 1, p_shared_owners));
        }

        (*(void (**)(uint64_t))(*(void *)v4 + 32LL))(v4);
        if (v5)
        {
          CFDictionaryRef v8 = (unint64_t *)&v5->__shared_owners_;
          do
            unint64_t v9 = __ldaxr(v8);
          while (__stlxr(v9 - 1, v8));
          if (!v9)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }

        return;
      }
    }

void sub_182A67DCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t NWIOConnection::_captureEstablishmentFailureReason(NWIOConnection *this)
{
  uint64_t v2 = 0xFFFFFFFFLL;
  unsigned int valuePtr = -1;
  int v3 = (nw_connection *)*((void *)this + 34);
  if (!v3) {
    return v2;
  }
  nw_path_t v4 = nw_connection_copy_current_path(v3);
  if (!v4) {
    goto LABEL_11;
  }
  int reason = nw_path_get_reason();
  if (reason > 25)
  {
    if (reason != 26)
    {
      int v9 = 0;
      BOOL v10 = reason == 30;
      goto LABEL_17;
    }

    BOOL v10 = 0;
    unsigned int valuePtr = 2;
  }

  else
  {
    if (reason == 5)
    {
      BOOL v10 = 0;
      int v9 = 1;
      unsigned int valuePtr = 1;
      goto LABEL_17;
    }

    if (reason != 6) {
      goto LABEL_11;
    }
    unsigned int Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 46), &unk_18C5ADC20);
    unint64_t v7 = Value;
    if (!Value) {
      goto LABEL_11;
    }
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  buf,  2u);
    }

    if ((const void *)*MEMORY[0x189604DE8] != v7)
    {
LABEL_11:
      int v9 = 0;
      BOOL v10 = 0;
      goto LABEL_17;
    }

    BOOL v10 = 0;
    unsigned int valuePtr = 0;
  }

  int v9 = 1;
LABEL_17:
  int privacy_stance = nw_connection_get_privacy_stance();
  int v12 = nw_connection_failed_due_to_blocked_tracker();
  int v13 = (void *)nw_connection_copy_failed_resolution_report();
  if (v9)
  {
    CFNumberRef v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_18C5AB4F8, v14);
    if (v14) {
      CFRelease(v14);
    }
  }

  if (privacy_stance == 3) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_18C5AB5A0, (const void *)*MEMORY[0x189604DE8]);
  }
  if (v4) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_18C5AB530, v4);
  }
  if (v12) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_18C5AB4C0, (const void *)*MEMORY[0x189604DE8]);
  }
  if (v13) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_18C5AB568, v13);
  }
  if (v10) {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 46), &unk_18C5AB5D8, (const void *)*MEMORY[0x189604DE8]);
  }
  uint64_t v2 = valuePtr;
  if (v13) {
    nw_release(v13);
  }
  if (v4) {
    nw_release(v4);
  }
  return v2;
}

void sub_182A68078(_Unwind_Exception *exception_object)
{
  if (v3)
  {
    CFRelease(v3);
    if (!v2)
    {
LABEL_3:
      if (!v1) {
LABEL_8:
      }
        _Unwind_Resume(exception_object);
LABEL_7:
      nw_release(v1);
      goto LABEL_8;
    }
  }

  else if (!v2)
  {
    goto LABEL_3;
  }

  nw_release(v2);
  if (!v1) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

uint64_t ___ZN14NWIOConnection25_handleEvent_DisconnectedEPU22objcproto11OS_nw_error8NSObject_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2788LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void ___ZN14NWIOConnection24_handleEvent_ReadyFinishEv_block_invoke(void *a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    nw_path_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = a1[5];
      if (v6)
      {
        int v7 = *(_WORD *)(v3 + 248) & 0xFFF7 | (*(unsigned __int8 *)(v3 + 250) << 16);
        *(_WORD *)(v3 + 248) &= ~8u;
        *(_BYTE *)(v3 + 250) = BYTE2(v7);
        IOPMAssertionID v8 = *(_DWORD *)(v3 + 576);
        if (v8)
        {
          IOReturn v9 = IOPMAssertionRelease(v8);
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          BOOL v10 = (os_log_s *)CFNLog::logger;
          if (v9)
          {
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
            {
              uint64_t v11 = *(void *)(v3 + 288);
              int v12 = *(_DWORD *)(v3 + 576);
              *(_DWORD *)__int128 buf = 134218496;
              uint64_t v28 = v11;
              __int16 v29 = 1024;
              int v30 = v12;
              __int16 v31 = 1024;
              IOReturn v32 = v9;
              _os_log_error_impl( &dword_18298D000,  v10,  OS_LOG_TYPE_ERROR,  "Connection %llu: failed to release assertion(%d), result(%d)",  buf,  0x18u);
            }
          }

          else if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v25 = *(void *)(v3 + 288);
            int v26 = *(_DWORD *)(v3 + 576);
            *(_DWORD *)__int128 buf = 134218240;
            uint64_t v28 = v25;
            __int16 v29 = 1024;
            int v30 = v26;
            _os_log_debug_impl( &dword_18298D000,  v10,  OS_LOG_TYPE_DEBUG,  "Connection %llu: successfully released assertion(%d)",  buf,  0x12u);
          }

          *(_DWORD *)(v3 + 576) = 0;
        }

        if ((*(_WORD *)(v6 + 248) & 0x60) != 0 || (*(_DWORD *)(v6 + 136) - 5) <= 2)
        {
          int v13 = *(unsigned __int8 **)(v3 + 400);
          if (v13)
          {
            int v14 = v13[40];
            v13[40] = 0;
            if (v14) {
              TLSCallbackQueue::_invokeNextCallback((TLSCallbackQueue *)v13);
            }
          }
        }

        else
        {
          if (*(void *)(v3 + 328))
          {
            uint64_t v15 = (void *)network_proxy_create_from_parameters();
            CFDictionaryRef v16 = operator new(0x20uLL);
            NetworkProxyConfiguration::NetworkProxyConfiguration((uint64_t)v16, v15);
            if (v15 && (network_proxy_is_transparent() & 1) == 0)
            {
              int v17 = *(unsigned __int16 *)(v3 + 248);
              *(_BYTE *)(v3 + 250) = (v17 | (*(unsigned __int8 *)(v3 + 250) << 16) | 0x10000u) >> 16;
              *(_WORD *)(v3 + 24_Block_object_dispose(va, 8) = v17;
            }

            if (v15) {
              nw_release(v15);
            }
          }

          else
          {
            CFDictionaryRef v16 = 0LL;
          }

          uint64_t v18 = *(unsigned __int8 **)(v3 + 400);
          if (v18)
          {
            int v19 = v18[40];
            v18[40] = 0;
            if (v19) {
              TLSCallbackQueue::_invokeNextCallback((TLSCallbackQueue *)v18);
            }
          }

          int v20 = *(unsigned __int16 *)(v3 + 248) | (*(unsigned __int8 *)(v3 + 250) << 16);
          if ((~v20 & 0x18000) == 0
            && (*(_WORD *)(v3 + 248) & 0x200) != 0
            && v16
            && (int v21 = (*(uint64_t (**)(void *))(*(void *)v16 + 40LL))(v16),
                LOWORD(v20) = *(_WORD *)(v3 + 248),
                v21 == 3))
          {
            int v22 = *(_WORD *)(v3 + 248) & 0xF7FF | (*(unsigned __int8 *)(v3 + 250) << 16);
            *(_WORD *)(v3 + 248) &= ~0x800u;
            *(_BYTE *)(v3 + 250) = BYTE2(v22);
            NWIOConnection::_startTLS((NWIOConnection *)v3);
          }

          else
          {
            if ((v20 & 0xA00) == 0x200)
            {
              NWIOConnection::_startTLS((NWIOConnection *)v3);
            }

            else
            {
              if ((v20 & 0x800) != 0) {
                NWIOConnection::_tlsProcessHandshakeComplete((NWIOConnection *)v3);
              }
              NWIOConnection::_completeEndpointSetup((NWIOConnection *)v3);
            }

            if (!v16) {
              goto LABEL_42;
            }
          }

          (*(void (**)(void *))(*(void *)v16 + 8LL))(v16);
        }
      }

void sub_182A684C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (v10) {
    nw_release(v10);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void NWIOConnection::_startTLS(NWIOConnection *this)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  int v1 = *((unsigned __int16 *)this + 124) | (*((unsigned __int8 *)this + 250) << 16);
  if ((*((_WORD *)this + 124) & 0xA00) == 0x200 && (*((_DWORD *)this + 34) - 3) <= 1)
  {
    *((_BYTE *)this + 250) = BYTE2(v1);
    *((_WORD *)this + 12os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v1 | 0x800;
    options = nw_tls_create_options();
    NWIOConnection::_tlsConfigure((uint64_t)this, options);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    nw_path_t v4 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *((void *)this + 36);
      int v6 = 134217984;
      uint64_t v7 = v5;
      _os_log_impl(&dword_18298D000, v4, OS_LOG_TYPE_DEFAULT, "Connection %llu: enabling TLS", (uint8_t *)&v6, 0xCu);
    }

    nw_connection_append_and_start_application_protocol();
    if (options) {
      nw_release(options);
    }
  }

void sub_182A68680(_Unwind_Exception *exception_object)
{
  if (v1) {
    nw_release(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke( void *a1, std::__shared_weak_count_vtbl *a2, sec_trust *a3, uint64_t a4)
{
  uint64_t v131 = *MEMORY[0x1895F89C0];
  int v6 = (CFDictionaryRef *)a1[4];
  uint64_t v114 = 0LL;
  int v115 = 0LL;
  uint64_t v7 = (std::__shared_weak_count *)a1[6];
  if (!v7)
  {
    BOOL v10 = 0LL;
    goto LABEL_8;
  }

  BOOL v10 = std::__shared_weak_count::lock(v7);
  int v115 = v10;
  if (!v10 || (uint64_t v11 = a1[5], (v114 = v11) == 0))
  {
LABEL_8:
    (*(void (**)(uint64_t, void))(a4 + 16))(a4, 0LL);
    if (!v10) {
      return;
    }
    goto LABEL_9;
  }

  if ((*(_WORD *)(v11 + 248) & 0x60) != 0 || (*(_DWORD *)(v11 + 136) - 5) <= 2)
  {
    (*(void (**)(uint64_t, void))(a4 + 16))(a4, 0LL);
LABEL_9:
    p_uint64_t shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

    return;
  }

  sec_retain(a2);
  uint64_t v112 = a2;
  int v14 = (std::__shared_weak_count *)operator new(0x20uLL);
  v14->__shared_owners_ = 0LL;
  uint64_t v15 = (unint64_t *)&v14->__shared_owners_;
  v14->__vftable = (std::__shared_weak_count_vtbl *)off_189C06AE0;
  v14->__shared_weak_owners_ = 0LL;
  v14[1].__vftable = a2;
  uint64_t v113 = v14;
  CFDictionaryRef v16 = sec_trust_copy_ref(a3);
  policies[1] = v16;
  int v17 = (std::__shared_weak_count *)operator new(0x20uLL);
  v17->__shared_owners_ = 0LL;
  uint64_t v18 = (unint64_t *)&v17->__shared_owners_;
  v17->__vftable = (std::__shared_weak_count_vtbl *)off_189C06A70;
  v17->__shared_weak_owners_ = 0LL;
  v17[1].__vftable = (std::__shared_weak_count_vtbl *)v16;
  char v106 = v17;
  uint64_t v111 = v17;
  unsigned int Value = CFDictionaryGetValue(v6[46], &unk_18C5AB2C8);
  policies[0] = 0LL;
  OSStatus v20 = SecTrustCopyPolicies(v16, policies);
  if (v20 || !policies[0])
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v26 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v20;
      int v23 = "SecTrustCopyPolicies failed %d";
      unint64_t v24 = (os_log_s *)v26;
      uint32_t v25 = 8;
      goto LABEL_150;
    }
  }

  else if (CFArrayGetCount(policies[0]) == 1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(policies[0], 0LL);
    v109[0] = MEMORY[0x1895F87A8];
    v109[1] = 3221225472LL;
    v109[2] = ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_2;
    v109[3] = &__block_descriptor_40_e24_v20__0____CFString__8B16l;
    v109[4] = ValueAtIndex;
    (*((void (**)(CFDictionaryRef *, void *))*v6 + 43))(v6, v109);
    if (Value && (SecPolicySetATSPinning() & 1) == 0)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v22 = CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
      {
        LOWORD(buf) = 0;
        int v23 = "SecPolicySetATSPinning failed";
        unint64_t v24 = (os_log_s *)v22;
        uint32_t v25 = 2;
LABEL_150:
        _os_log_fault_impl(&dword_18298D000, v24, OS_LOG_TYPE_FAULT, v23, (uint8_t *)&buf, v25);
      }
    }
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v27 = CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
    {
      CFIndex Count = CFArrayGetCount(policies[0]);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = Count;
      int v23 = "SecTrust has an unexpected number of policies %lu";
      unint64_t v24 = (os_log_s *)v27;
      uint32_t v25 = 12;
      goto LABEL_150;
    }
  }

  if (policies[0]) {
    CFRelease(policies[0]);
  }
  uint64_t v107 = (uint64_t)a2;
  uint64_t v108 = v14;
  do
    unint64_t v28 = __ldxr(v15);
  while (__stxr(v28 + 1, v15));
  __int16 v29 = v106;
  do
    unint64_t v30 = __ldxr(v18);
  while (__stxr(v30 + 1, v18));
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  __int16 v31 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v32 = *(void *)(v11 + 288);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v32;
    _os_log_impl( &dword_18298D000,  v31,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: asked to evaluate TLS Trust",  (uint8_t *)&buf,  0xCu);
  }

  if ((*(_WORD *)(v11 + 248) & 0x60) != 0 || (*(_DWORD *)(v11 + 136) - 5) <= 2)
  {
    (*(void (**)(uint64_t, void))(a4 + 16))(a4, 0LL);
    goto LABEL_43;
  }

  NWIOConnection::_watchdogTouch((NWIOConnection *)v11, 0);
  uint64_t v42 = (TLSCallbackQueue **)(v11 + 400);
  if (!*(void *)(v11 + 400))
  {
    _ZNSt3__115allocate_sharedB8nn180100I16TLSCallbackQueueNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&buf);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v11 + 400, &buf);
    CFIndex v43 = (std::__shared_weak_count *)*((void *)&buf + 1);
    if (*((void *)&buf + 1))
    {
      uint64_t v44 = (unint64_t *)(*((void *)&buf + 1) + 8LL);
      do
        unint64_t v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }

    TLSCallbackQueue::initialize(*v42);
  }

  uint64_t v46 = *(void *)(v11 + 256);
  unint64_t v47 = *(std::__shared_weak_count **)(v11 + 264);
  if (v47)
  {
    p_shared_weak_owners = (unint64_t *)&v47->__shared_weak_owners_;
    do
      unint64_t v49 = __ldxr(p_shared_weak_owners);
    while (__stxr(v49 + 1, p_shared_weak_owners));
    uint64_t v123 = ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke;
    unint64_t v124 = &__block_descriptor_80_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE64c38_ZTSNSt3__110shared_ptrI10__SecTrustEE_e145_v16__0___v__B_shared_ptr___SecTrust______SecTrust_____shared_weak_count___shared_ptr_const___CFArray______CFArray_____shared_weak_count_____qi__8l;
    uint64_t v125 = v46;
    unint64_t v126 = v47;
    do
      unint64_t v50 = __ldxr(p_shared_weak_owners);
    while (__stxr(v50 + 1, p_shared_weak_owners));
  }

  else
  {
    uint64_t v123 = ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke;
    unint64_t v124 = &__block_descriptor_80_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE64c38_ZTSNSt3__110shared_ptrI10__SecTrustEE_e145_v16__0___v__B_shared_ptr___SecTrust______SecTrust_____shared_weak_count___shared_ptr_const___CFArray______CFArray_____shared_weak_count_____qi__8l;
    uint64_t v125 = v46;
    unint64_t v126 = 0LL;
  }

  uint64_t v51 = MEMORY[0x1895F87A8];
  *(void *)&__int128 buf = MEMORY[0x1895F87A8];
  *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
  uint64_t v127 = v107;
  uint64_t v128 = v14;
  if (v14)
  {
    uint64_t v52 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v53 = __ldxr(v52);
    while (__stxr(v53 + 1, v52));
  }

  uint64_t v129 = v16;
  v130 = v106;
  if (v106)
  {
    CFTypeID v54 = (unint64_t *)&v106->__shared_owners_;
    do
      unint64_t v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }

  aBlock[0] = v51;
  aBlock[1] = 3321888768LL;
  aBlock[2] = ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke_153;
  aBlock[3] = &unk_189C06710;
  void aBlock[5] = v46;
  int v119 = v47;
  if (v47)
  {
    CFStringRef v56 = (unint64_t *)&v47->__shared_weak_owners_;
    do
      unint64_t v57 = __ldxr(v56);
    while (__stxr(v57 + 1, v56));
  }

  aBlock[4] = a4;
  uint64_t v58 = (char *)operator new(0x88uLL);
  uint64_t v59 = (std::__shared_weak_count *)v58;
  *((void *)v58 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  uint64_t v60 = (unint64_t *)(v58 + 8);
  *((void *)v58 + 2) = 0LL;
  *(void *)uint64_t v58 = off_189C06B50;
  uint64_t v120 = v107;
  sqlite3_int64 v121 = v108;
  if (v108)
  {
    uint64_t v61 = (unint64_t *)&v108->__shared_owners_;
    do
      unint64_t v62 = __ldxr(v61);
    while (__stxr(v62 + 1, v61));
  }

  *(_OWORD *)(v58 + 120) = 0u;
  *((void *)v58 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  *((void *)v58 + 5) = 0LL;
  *((void *)v58 + 3) = off_189C12E58;
  *((_OWORD *)v58 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(v58 + 10os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *((_OWORD *)v58 + 3) = 0u;
  *((_OWORD *)v58 + 5) = 0u;
  v58[96] = 0;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)v58 + 8, v107, (uint64_t)v108);
  v59[3].__shared_owners_ = (uint64_t)_Block_copy(&buf);
  uint64_t v63 = v59 + 1;
  v59[3].__shared_weak_owners_ = (uint64_t)_Block_copy(aBlock);
  __int16 v29 = v106;
  if (v108)
  {
    uint64_t v64 = (unint64_t *)&v108->__shared_owners_;
    do
      unint64_t v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
      std::__shared_weak_count::__release_weak(v108);
    }
  }

  uint64_t v116 = v59 + 1;
  uint64_t v117 = v59;
  shared_weak_owners = (std::__shared_weak_count *)v59[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    do
      unint64_t v70 = __ldxr(v60);
    while (__stxr(v70 + 1, v60));
    uint64_t v71 = (unint64_t *)&v59->__shared_weak_owners_;
    do
      unint64_t v72 = __ldxr(v71);
    while (__stxr(v72 + 1, v71));
    v59[1].__shared_owners_ = (uint64_t)v63;
    v59[1].__shared_weak_owners_ = (uint64_t)v59;
    do
LABEL_104:
      unint64_t v73 = __ldaxr(v60);
    while (__stlxr(v73 - 1, v60));
    if (!v73)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }

    goto LABEL_107;
  }

  if (shared_weak_owners->__shared_owners_ == -1)
  {
    do
      unint64_t v67 = __ldxr(v60);
    while (__stxr(v67 + 1, v60));
    uint64_t v68 = (unint64_t *)&v59->__shared_weak_owners_;
    do
      unint64_t v69 = __ldxr(v68);
    while (__stxr(v69 + 1, v68));
    v59[1].__shared_owners_ = (uint64_t)v63;
    v59[1].__shared_weak_owners_ = (uint64_t)v59;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
    goto LABEL_104;
  }

void sub_182A690BC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, char a22, uint64_t a23, char a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, std::__shared_weak_count *a34, char a35)
{
  if (a34) {
    std::__shared_weak_count::__release_weak(a34);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v36 - 128);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v36 - 144);
  unint64_t v38 = *(std::__shared_weak_count **)(v36 - 152);
  if (v38) {
    std::__shared_weak_count::__release_weak(v38);
  }
  if (v35) {
    std::__shared_weak_count::__release_weak(v35);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_131( uint64_t a1, std::__shared_weak_count_vtbl *a2, uint64_t a3)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v5)
  {
    uint64_t v7 = 0LL;
    goto LABEL_8;
  }

  uint64_t v7 = std::__shared_weak_count::lock(v5);
  BOOL v77 = v7;
  if (!v7 || (uint64_t v8 = *(void *)(a1 + 32)) == 0)
  {
LABEL_8:
    (*(void (**)(uint64_t, void))(a3 + 16))(a3, 0LL);
    if (!v7) {
      return;
    }
    goto LABEL_9;
  }

  if ((*(_WORD *)(v8 + 248) & 0x60) != 0 || (*(_DWORD *)(v8 + 136) - 5) <= 2)
  {
    (*(void (**)(uint64_t, void))(a3 + 16))(a3, 0LL);
LABEL_9:
    p_uint64_t shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }

    return;
  }

  sec_retain(a2);
  uint64_t v11 = (std::__shared_weak_count *)operator new(0x20uLL);
  v11->__shared_owners_ = 0LL;
  int v12 = (unint64_t *)&v11->__shared_owners_;
  v11->__vftable = (std::__shared_weak_count_vtbl *)off_189C06AE0;
  v11->__shared_weak_owners_ = 0LL;
  v11[1].__vftable = a2;
  uint64_t v76 = v11;
  uint64_t v74 = (uint64_t)a2;
  uint64_t v75 = v11;
  do
    unint64_t v13 = __ldxr(v12);
  while (__stxr(v13 + 1, v12));
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  int v14 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(v8 + 288);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v15;
    _os_log_impl( &dword_18298D000,  v14,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: asked for TLS Client Certificates",  (uint8_t *)&buf,  0xCu);
  }

  if ((*(_WORD *)(v8 + 248) & 0x60) != 0 || (*(_DWORD *)(v8 + 136) - 5) <= 2)
  {
    (*(void (**)(uint64_t, void))(a3 + 16))(a3, 0LL);
    goto LABEL_23;
  }

  NWIOConnection::_watchdogTouch((NWIOConnection *)v8, 0);
  OSStatus v20 = (TLSCallbackQueue **)(v8 + 400);
  if (!*(void *)(v8 + 400))
  {
    _ZNSt3__115allocate_sharedB8nn180100I16TLSCallbackQueueNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&buf);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v8 + 400, &buf);
    int v21 = (std::__shared_weak_count *)*((void *)&buf + 1);
    if (*((void *)&buf + 1))
    {
      uint64_t v22 = (unint64_t *)(*((void *)&buf + 1) + 8LL);
      do
        unint64_t v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }

    TLSCallbackQueue::initialize(*v20);
  }

  uint64_t v24 = *(void *)(v8 + 256);
  uint32_t v25 = *(std::__shared_weak_count **)(v8 + 264);
  if (v25)
  {
    p_shared_weak_owners = (unint64_t *)&v25->__shared_weak_owners_;
    do
      unint64_t v27 = __ldxr(p_shared_weak_owners);
    while (__stxr(v27 + 1, p_shared_weak_owners));
    uint64_t v85 = ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke;
    uint64_t v86 = &__block_descriptor_64_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE_e148_v16__0___v___shared_ptr_const___CFArray______CFArray_____shared_weak_count___shared_ptr_const___CFArray______CFArray_____shared_weak_count_____qi__8l;
    uint64_t v87 = v24;
    unint64_t v88 = v25;
    do
      unint64_t v28 = __ldxr(p_shared_weak_owners);
    while (__stxr(v28 + 1, p_shared_weak_owners));
  }

  else
  {
    uint64_t v85 = ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke;
    uint64_t v86 = &__block_descriptor_64_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE_e148_v16__0___v___shared_ptr_const___CFArray______CFArray_____shared_weak_count___shared_ptr_const___CFArray______CFArray_____shared_weak_count_____qi__8l;
    uint64_t v87 = v24;
    unint64_t v88 = 0LL;
  }

  uint64_t v29 = MEMORY[0x1895F87A8];
  *(void *)&__int128 buf = MEMORY[0x1895F87A8];
  *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3321888768LL;
  uint64_t v89 = v74;
  uint64_t v90 = v75;
  if (v75)
  {
    unint64_t v30 = (unint64_t *)&v75->__shared_owners_;
    do
      unint64_t v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }

  aBlock[0] = v29;
  aBlock[1] = 3321888768LL;
  aBlock[2] = ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke_173;
  aBlock[3] = &unk_189C06870;
  void aBlock[5] = v24;
  uint64_t v81 = v25;
  if (v25)
  {
    uint64_t v32 = (unint64_t *)&v25->__shared_weak_owners_;
    do
      unint64_t v33 = __ldxr(v32);
    while (__stxr(v33 + 1, v32));
  }

  aBlock[4] = a3;
  int v34 = (std::__shared_weak_count *)operator new(0x80uLL);
  unint64_t v35 = v34;
  v34->__shared_owners_ = 0LL;
  uint64_t v36 = (unint64_t *)&v34->__shared_owners_;
  v34->__shared_weak_owners_ = 0LL;
  v34->__vftable = (std::__shared_weak_count_vtbl *)off_189C06BC0;
  uint64_t v82 = v74;
  unint64_t v83 = v75;
  if (v75)
  {
    unint64_t v37 = (unint64_t *)&v75->__shared_owners_;
    do
      unint64_t v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
  }

  *(_OWORD *)&v34[4].__shared_weak_owners_ = 0u;
  v34[1].__shared_owners_ = 0LL;
  v34[1].__shared_weak_owners_ = 0LL;
  *(_OWORD *)&v34[2].__shared_weak_owners_ = 0u;
  v34[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C12EB0;
  v34[4].std::__shared_count = 0u;
  v34[2].std::__shared_count = 0u;
  *(_OWORD *)&v34[3].__shared_owners_ = 0u;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100](&v34[2].__shared_weak_owners_, v74, (uint64_t)v75);
  v35[3].__shared_owners_ = (uint64_t)_Block_copy(&buf);
  uint64_t v39 = v35 + 1;
  v35[3].__shared_weak_owners_ = (uint64_t)_Block_copy(aBlock);
  if (v75)
  {
    uint64_t v40 = (unint64_t *)&v75->__shared_owners_;
    do
      unint64_t v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
      std::__shared_weak_count::__release_weak(v75);
    }
  }

  uint64_t v78 = v35 + 1;
  int v79 = v35;
  shared_weak_owners = (std::__shared_weak_count *)v35[1].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    do
      unint64_t v46 = __ldxr(v36);
    while (__stxr(v46 + 1, v36));
    unint64_t v47 = (unint64_t *)&v35->__shared_weak_owners_;
    do
      unint64_t v48 = __ldxr(v47);
    while (__stxr(v48 + 1, v47));
    v35[1].__shared_owners_ = (uint64_t)v39;
    v35[1].__shared_weak_owners_ = (uint64_t)v35;
    do
LABEL_73:
      unint64_t v49 = __ldaxr(v36);
    while (__stlxr(v49 - 1, v36));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }

    goto LABEL_76;
  }

  if (shared_weak_owners->__shared_owners_ == -1)
  {
    do
      unint64_t v43 = __ldxr(v36);
    while (__stxr(v43 + 1, v36));
    uint64_t v44 = (unint64_t *)&v35->__shared_weak_owners_;
    do
      unint64_t v45 = __ldxr(v44);
    while (__stxr(v45 + 1, v44));
    v35[1].__shared_owners_ = (uint64_t)v39;
    v35[1].__shared_weak_owners_ = (uint64_t)v35;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
    goto LABEL_73;
  }

void sub_182A698B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, std::__shared_weak_count *a24, char a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, std::__shared_weak_count *a32, uint64_t a33)
{
  if (a24) {
    std::__shared_weak_count::__release_weak(a24);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a33);
  if (a32) {
    std::__shared_weak_count::__release_weak(a32);
  }
  if (v33) {
    std::__shared_weak_count::__release_weak(v33);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  _Unwind_Resume(a1);
}

void std::default_delete<std::forward_list<SSLCiphersuiteGroup>>::operator()[abi:nn180100](void **__p)
{
  if (__p)
  {
    uint64_t v2 = *__p;
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }

      while (v3);
    }

    operator delete(__p);
  }

void NWIOConnection::_tlsCreateIdentityFromClientCertificates(sec_identity_t *a1, CFArrayRef *a2)
{
  *a1 = 0LL;
  if (*a2 && CFArrayGetCount(*a2) >= 1)
  {
    ValueAtIndex = (__SecIdentity *)CFArrayGetValueAtIndex(*a2, 0LL);
    CFIndex Count = CFArrayGetCount(*a2);
    if (Count < 2)
    {
      CFMutableArrayRef Mutable = 0LL;
    }

    else
    {
      CFIndex v6 = Count - 1;
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], Count - 1, MEMORY[0x189605228]);
      v8.CFIndex location = 1LL;
      v8.CFIndex length = v6;
      CFArrayAppendArray(Mutable, *a2, v8);
    }

    *a1 = sec_identity_create_with_certificates(ValueAtIndex, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }

void sub_182A69AA8(_Unwind_Exception *exception_object)
{
  void *v1 = 0LL;
  _Unwind_Resume(exception_object);
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke( uint64_t a1)
{
  int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_2( uint64_t a1)
{
  int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN14NWIOConnection16_tlsApplyOptionsEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_3( uint64_t a1)
{
  int v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void _ZNSt3__115allocate_sharedB8nn180100I16TLSCallbackQueueNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_( void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)operator new(0x60uLL);
  *(_OWORD *)&v2->__shared_owners_ = 0u;
  p_uint64_t shared_owners = (unint64_t *)&v2->__shared_owners_;
  v2->__vftable = (std::__shared_weak_count_vtbl *)off_189C06B18;
  v2[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C12F08;
  nw_path_t v4 = v2 + 1;
  v2[3].__vftable = 0LL;
  *(_OWORD *)&v2[3].__shared_owners_ = 0u;
  *(_OWORD *)&v2[1].__shared_owners_ = 0u;
  v2[2].std::__shared_count = 0u;
  LOWORD(v2[2].__shared_weak_owners_) = 0;
  uint64_t v5 = (uint64_t *)operator new(0x18uLL);
  uint64_t *v5 = (uint64_t)v5;
  v5[1] = (uint64_t)v5;
  void v5[2] = 0LL;
  std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100]( (uint64_t **)&v2[3],  v5);
  CFIndex v6 = (uint64_t *)operator new(0x18uLL);
  *CFIndex v6 = (uint64_t)v6;
  v6[1] = (uint64_t)v6;
  v6[2] = 0LL;
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackServerTrust>>>::reset[abi:nn180100]( (uint64_t **)&v2[3].__shared_owners_,  v6);
  uint64_t v7 = (uint64_t *)operator new(0x18uLL);
  uint64_t *v7 = (uint64_t)v7;
  v7[1] = (uint64_t)v7;
  v7[2] = 0LL;
  std::unique_ptr<std::list<std::shared_ptr<TLSCallbackClientCertificate>>>::reset[abi:nn180100]( (uint64_t **)&v2[3].__shared_weak_owners_,  v7);
  *a1 = v2 + 1;
  a1[1] = v2;
  shared_weak_owners = (std::__shared_weak_count *)v2[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      return;
    }
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_weak_owners);
    while (__stxr(v11 + 1, p_shared_weak_owners));
    v2[1].__shared_owners_ = (uint64_t)v4;
    v2[1].__shared_weak_owners_ = (uint64_t)v2;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }

  else
  {
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    unint64_t v13 = (unint64_t *)&v2->__shared_weak_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    v2[1].__shared_owners_ = (uint64_t)v4;
    v2[1].__shared_weak_owners_ = (uint64_t)v2;
  }

  do
    unint64_t v15 = __ldaxr(p_shared_owners);
  while (__stlxr(v15 - 1, p_shared_owners));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

void sub_182A69CA0(_Unwind_Exception *a1)
{
  uint64_t shared_owners = (std::__shared_weak_count *)v1[2].__shared_owners_;
  if (shared_owners) {
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  v1[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C19AE8;
  shared_weak_owners = (std::__shared_weak_count *)v1[1].__shared_weak_owners_;
  if (shared_weak_owners) {
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v8);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v102 = *MEMORY[0x1895F89C0];
  uint64_t v75 = 0LL;
  uint64_t v76 = 0LL;
  nw_path_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4)
  {
    uint64_t v76 = std::__shared_weak_count::lock(v4);
    if (v76)
    {
      uint64_t v5 = a1[4];
      uint64_t v75 = v5;
      if (v5)
      {
        uint64_t v7 = (sec_protocol_metadata *)a1[6];
        CFIndex v6 = (std::__shared_weak_count *)a1[7];
        unint64_t v73 = v7;
        uint64_t v74 = v6;
        if (v6)
        {
          p_uint64_t shared_owners = (unint64_t *)&v6->__shared_owners_;
          do
            unint64_t v9 = __ldxr(p_shared_owners);
          while (__stxr(v9 + 1, p_shared_owners));
        }

        uint64_t v87 = 0LL;
        unint64_t v88 = &v87;
        uint64_t v90 = __Block_byref_object_copy__155;
        uint64_t v91 = __Block_byref_object_dispose__156;
        uint64_t v89 = 0x4012000000LL;
        uint64_t v93 = 0LL;
        uint64_t v94 = 0LL;
        unint64_t v92 = &unk_182CE6F99;
        if ((*(_WORD *)(v5 + 248) & 0x60) != 0 || (*(_DWORD *)(v5 + 136) - 5) <= 2)
        {
          uint64_t v93 = 1LL;
          LODWORD(v9os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 89;
          *(void *)__int128 buf = 0LL;
          *(void *)&uint8_t buf[8] = 0LL;
          uint64_t handler = 0LL;
          uint64_t v83 = 0LL;
          (*(void (**)(uint64_t, _BYTE *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, buf, &handler, 1LL, v94);
          unint64_t v10 = (std::__shared_weak_count *)v83;
          if (v83)
          {
            unint64_t v11 = (unint64_t *)(v83 + 8);
            do
              unint64_t v12 = __ldaxr(v11);
            while (__stlxr(v12 - 1, v11));
            if (!v12)
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
          }

          unint64_t v13 = *(std::__shared_weak_count **)&buf[8];
          if (!*(void *)&buf[8]) {
            goto LABEL_92;
          }
          unint64_t v14 = (unint64_t *)(*(void *)&buf[8] + 8LL);
          do
            unint64_t v15 = __ldaxr(v14);
          while (__stlxr(v15 - 1, v14));
          if (v15) {
            goto LABEL_92;
          }
LABEL_18:
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
LABEL_92:
          _Block_object_dispose(&v87, 8);
          if (!v6) {
            goto LABEL_97;
          }
          unint64_t v65 = (unint64_t *)&v6->__shared_owners_;
          do
            unint64_t v20 = __ldaxr(v65);
          while (__stlxr(v20 - 1, v65));
          goto LABEL_95;
        }

        uint64_t v21 = MEMORY[0x1895F87A8];
        if (!v7)
        {
LABEL_55:
          if (!*(void *)(v5 + 144))
          {
            uint64_t v43 = *(void *)(v5 + 520);
            *(void *)__int128 buf = *(void *)(v5 + 512);
            *(void *)&uint8_t buf[8] = v43;
            if (v43)
            {
              uint64_t v44 = (unint64_t *)(v43 + 8);
              do
                unint64_t v45 = __ldxr(v44);
              while (__stxr(v45 + 1, v44));
            }

            unint64_t v46 = *(std::__shared_weak_count **)(v5 + 504);
            BOOL v77 = *(std::__shared_weak_count **)(v5 + 496);
            uint64_t v78 = v46;
            if (v46)
            {
              unint64_t v47 = (unint64_t *)&v46->__shared_owners_;
              do
                unint64_t v48 = __ldxr(v47);
              while (__stxr(v48 + 1, v47));
            }

            (*(void (**)(uint64_t, _BYTE *, std::__shared_weak_count **, uint64_t, uint64_t))(a2 + 16))( a2,  buf,  &v77,  v88[6],  v88[7]);
            unint64_t v49 = v78;
            if (v78)
            {
              unint64_t v50 = (unint64_t *)&v78->__shared_owners_;
              do
                unint64_t v51 = __ldaxr(v50);
              while (__stlxr(v51 - 1, v50));
              if (!v51)
              {
                ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                std::__shared_weak_count::__release_weak(v49);
              }
            }

            unint64_t v13 = *(std::__shared_weak_count **)&buf[8];
            if (!*(void *)&buf[8]) {
              goto LABEL_92;
            }
            uint64_t v52 = (unint64_t *)(*(void *)&buf[8] + 8LL);
            do
              unint64_t v53 = __ldaxr(v52);
            while (__stlxr(v53 - 1, v52));
            goto LABEL_91;
          }

          BOOL v77 = 0LL;
          uint64_t v78 = 0LL;
          uint64_t v40 = *(std::__shared_weak_count **)(v5 + 264);
          if (v40)
          {
            unint64_t v41 = std::__shared_weak_count::lock(v40);
            uint64_t v78 = v41;
            if (v41)
            {
              uint64_t v42 = *(std::__shared_weak_count **)(v5 + 256);
              BOOL v77 = v42;
LABEL_76:
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
              }
              CFTypeID v54 = (os_log_s *)CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v55 = *(void *)(v5 + 288);
                CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v5 + 496));
                *(_DWORD *)__int128 buf = 134218240;
                *(void *)&uint8_t buf[4] = v55;
                *(_WORD *)&buf[12] = 2048;
                *(void *)&buf[14] = Count;
                _os_log_impl( &dword_18298D000,  v54,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: issuing challenge for client certificates, DNs(%ld)",  buf,  0x16u);
              }

              uint64_t v57 = *(void *)(v5 + 144);
              uint64_t v58 = *(void *)(v5 + 496);
              *(void *)__int128 buf = v21;
              *(void *)&uint8_t buf[8] = 3321888768LL;
              *(void *)&uint8_t buf[16] = ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke_177;
              unint64_t v96 = (__n128 (*)(__n128 *, __n128 *))&unk_189C068A8;
              uint64_t v97 = (uint64_t (*)(uint64_t))a2;
              unint64_t v98 = &v87;
              CFMutableArrayRef v99 = (CFMutableArrayRef)v5;
              uint64_t v100 = v42;
              unint64_t v101 = v41;
              if (v41)
              {
                uint64_t v59 = (unint64_t *)&v41->__shared_owners_;
                do
                  unint64_t v60 = __ldxr(v59);
                while (__stxr(v60 + 1, v59));
              }

              (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)v57 + 40LL))(v57, v58, buf);
              unint64_t v61 = v101;
              if (v101)
              {
                unint64_t v62 = (unint64_t *)&v101->__shared_owners_;
                do
                  unint64_t v63 = __ldaxr(v62);
                while (__stlxr(v63 - 1, v62));
                if (!v63)
                {
                  ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                  std::__shared_weak_count::__release_weak(v61);
                }
              }

              unint64_t v13 = v78;
              if (!v78) {
                goto LABEL_92;
              }
              uint64_t v64 = (unint64_t *)&v78->__shared_owners_;
              do
                unint64_t v53 = __ldaxr(v64);
              while (__stlxr(v53 - 1, v64));
LABEL_91:
              if (v53) {
                goto LABEL_92;
              }
              goto LABEL_18;
            }
          }

          else
          {
            unint64_t v41 = 0LL;
          }

          uint64_t v42 = 0LL;
          goto LABEL_76;
        }

        *(void *)__int128 buf = 0LL;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x4012000000LL;
        unint64_t v96 = __Block_byref_object_copy__142;
        uint64_t v97 = __Block_byref_object_dispose__143;
        unint64_t v98 = (uint64_t *)&unk_182CE6F99;
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
        CFMutableArrayRef v99 = Mutable;
        unint64_t v23 = (std::__shared_weak_count *)operator new(0x20uLL);
        v23->__vftable = (std::__shared_weak_count_vtbl *)off_189C06A38;
        v23->__shared_owners_ = 0LL;
        v23->__shared_weak_owners_ = 0LL;
        v23[1].__vftable = (std::__shared_weak_count_vtbl *)Mutable;
        uint64_t v100 = v23;
        uint64_t handler = v21;
        uint64_t v83 = 3221225472LL;
        uint64_t v84 = ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke;
        uint64_t v85 = &unk_189C066B8;
        uint64_t v86 = buf;
        BOOL v24 = sec_protocol_metadata_access_distinguished_names(v7, &handler);
        BOOL v25 = v24;
        if (v24)
        {
          uint64_t v26 = *(const void **)(*(void *)&buf[8] + 48LL);
          if (v26) {
            CFTypeRef v27 = CFRetain(v26);
          }
          else {
            CFTypeRef v27 = 0LL;
          }
          *(void *)&__int128 v81 = v27;
          unint64_t v35 = operator new(0x20uLL);
          void *v35 = off_189C11328;
          v35[1] = 0LL;
          void v35[2] = 0LL;
          void v35[3] = v27;
          *((void *)&v81 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v35;
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5 + 496, &v81);
          uint64_t v32 = (std::__shared_weak_count *)*((void *)&v81 + 1);
          if (!*((void *)&v81 + 1)) {
            goto LABEL_49;
          }
          uint64_t v36 = (unint64_t *)(*((void *)&v81 + 1) + 8LL);
          do
            unint64_t v34 = __ldaxr(v36);
          while (__stlxr(v34 - 1, v36));
        }

        else
        {
          unint64_t v28 = v88;
          v88[6] = (int)*MEMORY[0x1896051C0];
          *((_DWORD *)v28 + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = -9800;
          __int128 v81 = 0uLL;
          uint64_t v79 = 0LL;
          unint64_t v80 = 0LL;
          (*(void (**)(uint64_t, __int128 *, uint64_t *))(a2 + 16))(a2, &v81, &v79);
          uint64_t v29 = v80;
          if (v80)
          {
            unint64_t v30 = (unint64_t *)&v80->__shared_owners_;
            do
              unint64_t v31 = __ldaxr(v30);
            while (__stlxr(v31 - 1, v30));
            if (!v31)
            {
              ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
              std::__shared_weak_count::__release_weak(v29);
            }
          }

          uint64_t v32 = (std::__shared_weak_count *)*((void *)&v81 + 1);
          if (!*((void *)&v81 + 1))
          {
LABEL_49:
            _Block_object_dispose(buf, 8);
            unint64_t v37 = v100;
            if (v100)
            {
              unint64_t v38 = (unint64_t *)&v100->__shared_owners_;
              do
                unint64_t v39 = __ldaxr(v38);
              while (__stlxr(v39 - 1, v38));
              if (!v39)
              {
                ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                std::__shared_weak_count::__release_weak(v37);
              }
            }

            if (!v25) {
              goto LABEL_92;
            }
            goto LABEL_55;
          }

          unint64_t v33 = (unint64_t *)(*((void *)&v81 + 1) + 8LL);
          do
            unint64_t v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
        }

        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }

        goto LABEL_49;
      }
    }
  }

  uint64_t v71 = 0LL;
  unint64_t v72 = 0LL;
  uint64_t v69 = 0LL;
  unint64_t v70 = 0LL;
  (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t, uint64_t))(a2 + 16))(a2, &v71, &v69, 1LL, 89LL);
  CFDictionaryRef v16 = v70;
  if (v70)
  {
    unint64_t v17 = (unint64_t *)&v70->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  CFIndex v6 = v72;
  if (v72)
  {
    unint64_t v19 = (unint64_t *)&v72->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
LABEL_95:
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A6A41C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void ___ZN14NWIOConnection41_tlsProcessClientCertificateRequest_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvPU26objcproto15OS_sec_identityS2_E_block_invoke_173( void *a1, const __CFArray **a2, CFIndex a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  unint64_t v30 = 0LL;
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (!v5 || (v30 = std::__shared_weak_count::lock(v5)) == 0LL || (uint64_t v9 = a1[5]) == 0)
  {
    (*(void (**)(void))(a1[4] + 16LL))();
    goto LABEL_28;
  }

  unint64_t v10 = *a2;
  unint64_t v11 = a2[1];
  CFArrayRef theArray = v10;
  if (v11)
  {
    unint64_t v12 = (unint64_t *)((char *)v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  uint64_t v14 = a1[4];
  if ((*(_WORD *)(v9 + 248) & 0x60) == 0 && (*(_DWORD *)(v9 + 136) - 5) >= 3)
  {
    if (!a3 && !(_DWORD)a4)
    {
      v31[0] = v10;
      v31[1] = v11;
      if (v11)
      {
        unint64_t v15 = (unint64_t *)((char *)v11 + 8);
        do
          unint64_t v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }

      NWIOConnection::_tlsCreateIdentityFromClientCertificates(&v32, v31);
      if (v11)
      {
        unint64_t v17 = (unint64_t *)((char *)v11 + 8);
        do
          unint64_t v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          (*(void (**)(const __CFArray *))(*(void *)v11 + 16LL))(v11);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v11);
        }
      }

      sec_identity_t v19 = v32;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      unint64_t v20 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = *(void *)(v9 + 288);
        if (theArray) {
          CFIndex Count = CFArrayGetCount(theArray);
        }
        else {
          CFIndex Count = -1LL;
        }
        *(_DWORD *)__int128 buf = 134218240;
        uint64_t v34 = v21;
        __int16 v35 = 2048;
        CFIndex v36 = Count;
        _os_log_impl( &dword_18298D000,  v20,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: providing TLS Client Identity (%ld elements)",  buf,  0x16u);
      }

      (*(void (**)(uint64_t, sec_identity_t))(v14 + 16))(v14, v19);
      if (v19) {
        sec_release(v19);
      }
      goto LABEL_40;
    }

    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    BOOL v25 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = *(void *)(v9 + 288);
      *(_DWORD *)__int128 buf = 134218496;
      uint64_t v34 = v28;
      __int16 v35 = 2048;
      CFIndex v36 = a3;
      __int16 v37 = 1024;
      int v38 = a4;
      _os_log_error_impl( &dword_18298D000,  v25,  OS_LOG_TYPE_ERROR,  "Connection %llu: TLS Client Certificates encountered error %ld:%d",  buf,  0x1Cu);
    }

    v40.CFIndex domain = a3;
    *(void *)&v40.uint64_t error = a4;
    NWIOConnection::_handleError((NWIOConnection *)v9, v40);
  }

  (*(void (**)(uint64_t, void))(v14 + 16))(v14, 0LL);
LABEL_40:
  if (v11)
  {
    uint64_t v26 = (unint64_t *)((char *)v11 + 8);
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      (*(void (**)(const __CFArray *))(*(void *)v11 + 16LL))(v11);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v11);
    }
  }

void sub_182A6A844( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14)
{
  if (v14) {
    sec_release(v14);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TLSCallbackClientCertificate>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C06BC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TLSCallbackClientCertificate>::~__shared_ptr_emplace( std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C06BC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<TLSCallbackClientCertificate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *__copy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    CFIndex v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE( uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke( uint64_t a1, const void *a2)
{
}

void ___ZN14NWIOConnection42_tlsProcessClientCertificateRequest_InvokeENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEEU13block_pointerFvNS1_IK9__CFArrayEES7_13CFStreamErrorE_block_invoke_177( void *a1, const __CFArray *a2, int a3)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    uint64_t v4 = *(void *)(a1[5] + 8LL);
    *(void *)(v4 + 4_Block_object_dispose(va, 8) = 1LL;
    *(_DWORD *)(v4 + 56) = 89;
    uint64_t v55 = 0LL;
    uint64_t v56 = 0LL;
    uint64_t v53 = 0LL;
    uint64_t v54 = 0LL;
    (*(void (**)(void))(a1[4] + 16LL))();
  }

  else
  {
    uint64_t v5 = a1[6];
    if ((*(_WORD *)(v5 + 248) & 0x60) != 0 || (*(_DWORD *)(v5 + 136) - 5) <= 2)
    {
      uint64_t v6 = *(void *)(a1[5] + 8LL);
      *(void *)(v6 + 4_Block_object_dispose(va, 8) = 1LL;
      *(_DWORD *)(v6 + 56) = 89;
      uint64_t v51 = 0LL;
      uint64_t v52 = 0LL;
      uint64_t v49 = 0LL;
      uint64_t v50 = 0LL;
      (*(void (**)(void))(a1[4] + 16LL))();
    }

    else
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      CFRange v8 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(v5 + 288);
        if (a2) {
          CFIndex Count = CFArrayGetCount(a2);
        }
        else {
          CFIndex Count = -1LL;
        }
        *(_DWORD *)__int128 buf = 134218240;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = Count;
        _os_log_impl( &dword_18298D000,  v8,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: received response for client certificates (%ld elements)",  buf,  0x16u);
      }

      if (a2) {
        a2 = (const __CFArray *)CFRetain(a2);
      }
      *(void *)__int128 buf = a2;
      unint64_t v11 = operator new(0x20uLL);
      *unint64_t v11 = off_189C11328;
      v11[1] = 0LL;
      v11[2] = 0LL;
      v11[3] = a2;
      *(void *)&uint8_t buf[8] = v11;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1[7] + 512LL, (__int128 *)buf);
      unint64_t v12 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        unint64_t v13 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }

      uint64_t v15 = *(void *)(v5 + 520);
      *(void *)__int128 buf = *(void *)(v5 + 512);
      *(void *)&uint8_t buf[8] = v15;
      if (v15)
      {
        unint64_t v16 = (unint64_t *)(v15 + 8);
        do
          unint64_t v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
      }

      __int128 v48 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5 + 512, &v48);
      unint64_t v18 = (std::__shared_weak_count *)*((void *)&v48 + 1);
      if (*((void *)&v48 + 1))
      {
        sec_identity_t v19 = (unint64_t *)(*((void *)&v48 + 1) + 8LL);
        do
          unint64_t v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }

      uint64_t v21 = *(void *)(v5 + 504);
      *(void *)&__int128 v48 = *(void *)(v5 + 496);
      *((void *)&v48 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v21;
      if (v21)
      {
        uint64_t v22 = (unint64_t *)(v21 + 8);
        do
          unint64_t v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }

      __int128 v47 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v5 + 496, &v47);
      unint64_t v24 = (std::__shared_weak_count *)*((void *)&v47 + 1);
      if (*((void *)&v47 + 1))
      {
        BOOL v25 = (unint64_t *)(*((void *)&v47 + 1) + 8LL);
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      uint64_t v27 = a1[4];
      uint64_t v45 = *(void *)buf;
      unint64_t v46 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        uint64_t v28 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }

      __int128 v44 = v48;
      if (*((void *)&v48 + 1))
      {
        unint64_t v30 = (unint64_t *)(*((void *)&v48 + 1) + 8LL);
        do
          unint64_t v31 = __ldxr(v30);
        while (__stxr(v31 + 1, v30));
      }

      (*(void (**)(uint64_t, uint64_t *, __int128 *, void, void))(v27 + 16))( v27,  &v45,  &v44,  *(void *)(*(void *)(a1[5] + 8LL) + 48LL),  *(void *)(*(void *)(a1[5] + 8LL) + 56LL));
      sec_identity_t v32 = (std::__shared_weak_count *)*((void *)&v44 + 1);
      if (*((void *)&v44 + 1))
      {
        unint64_t v33 = (unint64_t *)(*((void *)&v44 + 1) + 8LL);
        do
          unint64_t v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
      }

      __int16 v35 = v46;
      if (v46)
      {
        p_uint64_t shared_owners = (unint64_t *)&v46->__shared_owners_;
        do
          unint64_t v37 = __ldaxr(p_shared_owners);
        while (__stlxr(v37 - 1, p_shared_owners));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
        }
      }

      int v38 = (std::__shared_weak_count *)*((void *)&v48 + 1);
      if (*((void *)&v48 + 1))
      {
        uint64_t v39 = (unint64_t *)(*((void *)&v48 + 1) + 8LL);
        do
          unint64_t v40 = __ldaxr(v39);
        while (__stlxr(v40 - 1, v39));
        if (!v40)
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }

      unint64_t v41 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        uint64_t v42 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v43 = __ldaxr(v42);
        while (__stlxr(v43 - 1, v42));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }
    }
  }

void sub_182A6AE34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void std::__shared_ptr_emplace<TLSCallbackQueue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C06B18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TLSCallbackQueue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C06B18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<NSObject  {objcproto24OS_sec_protocol_metadata}*,Deleter_SecRelease<NSObject  {objcproto24OS_sec_protocol_metadata}*>,std::allocator<NSObject  {objcproto24OS_sec_protocol_metadata}>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void ___ZN14NWIOConnection13_tlsConfigureEPU34objcproto23OS_sec_protocol_options8NSObject_block_invoke_2()
{
  if ((SecPolicySetSSLHostname() & 1) == 0)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    os_log_t v0 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int v1 = 0;
      _os_log_fault_impl(&dword_18298D000, v0, OS_LOG_TYPE_FAULT, "SecPolicySetSSLHostname failed", v1, 2u);
    }
  }

void ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v32 = 0LL;
  unint64_t v33 = 0LL;
  uint64_t v4 = (std::__shared_weak_count *)a1[5];
  if (v4 && (v33 = std::__shared_weak_count::lock(v4)) != 0LL && (v5 = a1[4], (uint64_t v32 = v5) != 0))
  {
    uint64_t v6 = (std::__shared_weak_count *)a1[7];
    unint64_t v30 = (void *)a1[6];
    unint64_t v31 = v6;
    if (v6)
    {
      p_uint64_t shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        unint64_t v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }

    uint64_t v9 = a1[8];
    unint64_t v10 = (std::__shared_weak_count *)a1[9];
    void v29[2] = v9;
    void v29[3] = (uint64_t)v10;
    if (v10)
    {
      unint64_t v11 = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }

    v29[0] = 0LL;
    v29[1] = 0LL;
    NWIOConnection::_tlsProcessValidateServerTrust_Invoke(v5, &v30, v9, (uint64_t)v10, v29, a2);
    if (v10)
    {
      unint64_t v13 = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    uint64_t v15 = v31;
    if (v31)
    {
      unint64_t v16 = (unint64_t *)&v31->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      goto LABEL_27;
    }
  }

  else
  {
    uint64_t v27 = 0LL;
    uint64_t v28 = 0LL;
    uint64_t v25 = 0LL;
    unint64_t v26 = 0LL;
    (*(void (**)(uint64_t, void, uint64_t *, uint64_t *, uint64_t, uint64_t))(a2 + 16))( a2,  0LL,  &v27,  &v25,  1LL,  89LL);
    unint64_t v18 = v26;
    if (v26)
    {
      sec_identity_t v19 = (unint64_t *)&v26->__shared_owners_;
      do
        unint64_t v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }

    uint64_t v15 = v28;
    if (v28)
    {
      uint64_t v21 = (unint64_t *)&v28->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v21);
      while (__stlxr(v17 - 1, v21));
LABEL_27:
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }

  uint64_t v22 = v33;
  if (v33)
  {
    unint64_t v23 = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

void sub_182A6B138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 48);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32);
  _Unwind_Resume(a1);
}

void ___ZN14NWIOConnection36_tlsProcessValidateServerTrust_StartENSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEENS1_I10__SecTrustEEU13block_pointerFvbE_block_invoke_153( void *a1, uint64_t a2, CFIndex a3, uint64_t a4)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (!v5)
  {
    uint64_t v9 = 0LL;
    goto LABEL_16;
  }

  uint64_t v9 = std::__shared_weak_count::lock(v5);
  if (!v9 || (uint64_t v10 = a1[5]) == 0)
  {
LABEL_16:
    (*(void (**)(void, void))(a1[4] + 16LL))(a1[4], 0LL);
    if (!v9) {
      return;
    }
    goto LABEL_17;
  }

  uint64_t v11 = a1[4];
  if ((*(_WORD *)(v10 + 248) & 0x60) == 0 && (*(_DWORD *)(v10 + 136) - 5) >= 3)
  {
    if (!a3 && !(_DWORD)a4) {
      goto LABEL_14;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    unint64_t v12 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = *(void *)(v10 + 288);
      *(_DWORD *)__int128 buf = 134218496;
      uint64_t v17 = v15;
      __int16 v18 = 2048;
      CFIndex v19 = a3;
      __int16 v20 = 1024;
      int v21 = a4;
      _os_log_error_impl( &dword_18298D000,  v12,  OS_LOG_TYPE_ERROR,  "Connection %llu: TLS Trust encountered error %ld:%d",  buf,  0x1Cu);
    }

    v23.CFIndex domain = a3;
    *(void *)&v23.uint64_t error = a4;
    NWIOConnection::_handleError((NWIOConnection *)v10, v23);
  }

  a2 = 0LL;
LABEL_14:
  (*(void (**)(uint64_t, uint64_t))(v11 + 16))(v11, a2);
LABEL_17:
  p_uint64_t shared_owners = (unint64_t *)&v9->__shared_owners_;
  do
    unint64_t v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }

void sub_182A6B368( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__shared_ptr_emplace<TLSCallbackServerTrust>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C06B50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TLSCallbackServerTrust>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C06B50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void *__copy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE64c38_ZTSNSt3__110shared_ptrI10__SecTrustEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  return result;
}

void __destroy_helper_block_e8_32c39_ZTSNSt3__18weak_ptrI14NWIOConnectionEE48c73_ZTSNSt3__110shared_ptrIU35objcproto24OS_sec_protocol_metadata8NSObjectEE64c38_ZTSNSt3__110shared_ptrI10__SecTrustEE( uint64_t a1)
{
  uint64_t v2 = a1 + 48;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t ___ZN14NWIOConnection18_handleEvent_ReadyEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2556LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void std::__shared_ptr_pointer<NSObject  {objcproto16OS_nw_connection}*,Deleter_NWRelease<NSObject  {objcproto16OS_nw_connection}*>,std::allocator<NSObject  {objcproto16OS_nw_connection}>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void ___ZN14NWIOConnection22_addConnectionProtocolEv_block_invoke(uint64_t a1)
{
}

void ___ZN14NWIOConnection16_setupConnectionEU13block_pointerFvvE_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a2 == 1)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (v3)
    {
      unint64_t v4 = std::__shared_weak_count::lock(v3);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v6 = *(void *)(a1 + 32);
        if (v6 && (*(_WORD *)(v6 + 248) & 0x60) == 0 && (*(_DWORD *)(v6 + 136) - 5) >= 2)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          unint64_t v7 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v8 = *(void *)(v6 + 288);
            LODWORD(buf) = 134217984;
            *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v8;
            _os_log_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: encountered bidirectional stream limit updated event",  (uint8_t *)&buf,  0xCu);
          }

          uint64_t v9 = *(void *)(v6 + 160);
          unint64_t v10 = *(std::__shared_weak_count **)(v6 + 168);
          *(void *)&__int128 buf = v9;
          *((void *)&buf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v10;
          if (v10)
          {
            p_uint64_t shared_owners = (unint64_t *)&v10->__shared_owners_;
            do
              unint64_t v12 = __ldxr(p_shared_owners);
            while (__stxr(v12 + 1, p_shared_owners));
          }

          if (v9) {
            (*(void (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
          }
          if (v10)
          {
            unint64_t v13 = (unint64_t *)&v10->__shared_owners_;
            do
              unint64_t v14 = __ldaxr(v13);
            while (__stlxr(v14 - 1, v13));
            if (!v14)
            {
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v10);
            }
          }
        }

        uint64_t v15 = (unint64_t *)&v5->__shared_owners_;
        do
          unint64_t v16 = __ldaxr(v15);
        while (__stlxr(v16 - 1, v15));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }

void sub_182A6B680( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void *___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke(void *result)
{
  uint64_t v1 = *((void *)result + 5);
  return result;
}

void ___ZN14NWIOConnection30_conditionalSchedulingSIMSetupEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v1 + 248) & 0x60) == 0 && (*(_DWORD *)(v1 + 136) - 5) >= 3)
  {
    v2.CFIndex domain = 1LL;
    *(void *)&v2.uint64_t error = 60LL;
    NWIOConnection::_handleError((NWIOConnection *)v1, v2);
  }

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A3B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::~__shared_ptr_emplace( std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A3B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<ConditionalConnectionSIMScheduler>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0LL;
  if (v2) {
    (*(void (**)(void))(a1 + 120))();
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 96);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  unint64_t v7 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(v6 + 288);
    int v9 = 134218240;
    uint64_t v10 = v8;
    __int16 v11 = 2048;
    uint64_t v12 = a2;
    _os_log_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: activity(%p) start handler called",  (uint8_t *)&v9,  0x16u);
  }

  uint64_t v3 = 1LL;
  *(_BYTE *)(v6 + 592) = 1;
  NWIOConnection::_startConnection_Completion((NWIOConnection *)v6);
  return v3;
}

void ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_198(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 40);
  if ((*(_WORD *)(v2 + 248) & 0x60) == 0 && (*(_DWORD *)(v2 + 136) - 5) >= 3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v6 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(v5 + 288);
      int v8 = 134218240;
      uint64_t v9 = v7;
      __int16 v10 = 2048;
      uint64_t v11 = a2;
      _os_log_impl( &dword_18298D000,  v6,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: activity(%p) suspend handler called",  (uint8_t *)&v8,  0x16u);
    }

    if (*(void *)(*(void *)(a1 + 40) + 624LL)) {
      (*(void (**)(void))(*(void *)(v5 + 624) + 16LL))();
    }
    NWIOConnection::_terminateConnectionIfAppropriate((CFDictionaryRef *)v5, 0);
  }

void ___ZN14NWIOConnection30_conditionalSchedulingDASSetupEv_block_invoke_201( uint64_t a1, int a2, CFTypeRef cf)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  unint64_t v4 = *(NWIOConnection **)(a1 + 32);
  if (a2)
  {
    if (cf) {
      CFTypeRef v6 = CFRetain(cf);
    }
    else {
      CFTypeRef v6 = 0LL;
    }
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(const void **)(v8 + 584);
    *(void *)(v8 + 58os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6;
    if (v9) {
      CFRelease(v9);
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    __int16 v10 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *((void *)v4 + 36);
      int v15 = 134218240;
      uint64_t v16 = v11;
      __int16 v17 = 2048;
      CFTypeRef v18 = cf;
      _os_log_impl( &dword_18298D000,  v10,  OS_LOG_TYPE_DEFAULT,  "Connection %llu: submitted activity(%p)",  (uint8_t *)&v15,  0x16u);
    }

    uint64_t v12 = *((void *)v4 + 18);
    if (v12) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 72LL))(v12, 10000LL);
    }
    uint64_t v13 = *((void *)v4 + 77);
    if (v13) {
      (*(void (**)(uint64_t, void, uint64_t))(v13 + 16))(v13, 0LL, 10000LL);
    }
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = *((void *)v4 + 36);
      int v15 = 134218240;
      uint64_t v16 = v14;
      __int16 v17 = 2048;
      CFTypeRef v18 = cf;
      _os_log_error_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_ERROR,  "Connection %llu: failed to start activity(%p)",  (uint8_t *)&v15,  0x16u);
    }

    v20.CFIndex domain = 1LL;
    *(void *)&v20.uint64_t error = 22LL;
    NWIOConnection::_handleError(v4, v20);
  }

uint64_t ___ZN14NWIOConnection27_startConnection_CompletionEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2161LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void ___ZN14NWIOConnection29_connectionAttemptTimerCreateEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      unint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (*(_WORD *)(v5 + 248) & 0x60) == 0 && (*(_DWORD *)(v5 + 136) - 5) >= 3)
      {
        v8.CFIndex domain = 4LL;
        *(void *)&v8.uint64_t error = 4294965190LL;
        NWIOConnection::_handleTimeout((NWIOConnection *)v5, v8);
      }

      p_uint64_t shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A6BCC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN14NWIOConnection16_kickTimerCreateEv_block_invoke(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = a1[5];
      if (v6 && (*(_WORD *)(v6 + 248) & 0x60) == 0 && (*(_DWORD *)(v6 + 136) - 5) >= 3)
      {
        unint64_t v7 = *(nw_connection **)(v3 + 272);
        if (v7) {
          nw_connection_restart(v7);
        }
        double v8 = *(double *)(v3 + 536) + *(double *)(v3 + 536);
        *(double *)(v3 + 536) = v8;
        uint64_t v9 = *(dispatch_source_s **)(v3 + 544);
        dispatch_time_t v10 = dispatch_time(0x8000000000000000LL, (uint64_t)(v8 * 1000000000.0));
        dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      }

      p_uint64_t shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }

void sub_182A6BDD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14NWIOConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void CFAllocatedReferenceCountedObject::~CFAllocatedReferenceCountedObject(CFAllocatorRef *this)
{
}

CFStringRef CFAllocatedReferenceCountedObject::copyDebugDesc(CFAllocatedReferenceCountedObject *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<CFAllocatedObject@%p>", this);
}

BOOL CFAllocatedReferenceCountedObject::equals( CFAllocatedReferenceCountedObject *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_copyDescription( CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(void *)this + 16LL))(this);
}

BOOL CFObject::equals(CFObject *this, const CFObject *a2)
{
  return this == a2;
}

uint64_t CFObject::hash(CFObject *this)
{
  return (uint64_t)this - 16;
}

uint64_t CFObject::copyFormattingDesc(CFObject *this, const __CFDictionary *a2)
{
  return 0LL;
}

CFStringRef CFObject::copyDebugDescHeader(CFObject *this)
{
  uint64_t v2 = (char *)this - 16;
  CFGetTypeID((char *)this - 16);
  ClassWithuint64_t TypeID = _CFRuntimeGetClassWithTypeID();
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<%s %p [%p]>",  *(void *)(ClassWithTypeID + 8),  v2,  this);
}

CFStringRef CFObject::_cfobj_copyDescription(CFObject *this, const void *a2)
{
  return CFCopyDescription((char *)this - 16);
}

uint64_t CFObject::_cfobj_equal(CFObject *this, char *a2, const void *a3)
{
  return CFEqual((char *)this - 16, a2 - 16);
}

void CFAllocatedObject::~CFAllocatedObject(CFAllocatorRef *this)
{
}

CFAllocatedReferenceCountedObject *CFAllocatedReferenceCountedObject::_retainable_instance_retain( CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return this;
}

uint64_t CFAllocatedReferenceCountedObject::_retainable_instance_release( CFAllocatedReferenceCountedObject *this, const void *a2)
{
  return (*(uint64_t (**)(CFAllocatedReferenceCountedObject *))(*(void *)this + 48LL))(this);
}

uint64_t CFClass::EqualObj(CFClass *this, char *a2, const void *a3)
{
  if (this) {
    uint64_t v3 = (char *)this + 16;
  }
  else {
    uint64_t v3 = 0LL;
  }
  if (a2) {
    unint64_t v4 = a2 + 16;
  }
  else {
    unint64_t v4 = 0LL;
  }
  return (**(uint64_t (***)(char *, char *, const void *))v3)(v3, v4, a3);
}

uint64_t CFClass::HashObj(CFClass *this, const void *a2)
{
  if (this) {
    return (*(uint64_t (**)(char *))(*((void *)this + 2) + 8LL))((char *)this + 16);
  }
  else {
    return (*(uint64_t (**)(void))(MEMORY[0] + 8LL))(0LL);
  }
}

uint64_t CFClass::CopyFormattingDescObj(CFClass *this, const void *a2, const __CFDictionary *a3)
{
  if (this) {
    uint64_t v3 = (char *)this + 16;
  }
  else {
    uint64_t v3 = 0LL;
  }
  return (*(uint64_t (**)(char *, const void *))(*(void *)v3 + 16LL))(v3, a2);
}

uint64_t CFClass::CopyDebugDescObj(CFClass *this, const void *a2)
{
  if (this) {
    return (*(uint64_t (**)(char *))(*((void *)this + 2) + 24LL))((char *)this + 16);
  }
  else {
    return (*(uint64_t (**)(void))(MEMORY[0] + 24LL))(0LL);
  }
}

void CFClass::CFClass(CFClass *this, const char *a2)
{
  *(void *)this = 0LL;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = a2;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
  *((void *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = CFClass::FinalizeObj;
  *((void *)this + 5) = CFClass::EqualObj;
  *((void *)this + 6) = CFClass::HashObj;
  *((void *)this + 7) = CFClass::CopyFormattingDescObj;
  *((void *)this + 9) = 0LL;
  *((void *)this + 10) = 0LL;
  *((void *)this + _Block_object_dispose(va, 8) = CFClass::CopyDebugDescObj;
  uint64_t v3 = _CFRuntimeRegisterClass();
  *((void *)this + 12) = v3;
  if (!v3 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)unint64_t v4 = 0;
    _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "Couldn't allocate a type ID", v4, 2u);
  }

CFObject *CFObject::_cfobj_instance_retain(CFObject *this, void *a2)
{
  return this;
}

void CFObject::_cfobj_instance_release(CFObject *this, void *a2)
{
}

CFStringRef CFObject::_cfobj_instance_copyDescription(CFObject *this, void *a2)
{
  return CFCopyDescription((char *)this - 16);
}

void ___Z26_cfnAutoreleaseDebugBufferl_block_invoke_2(uint64_t a1)
{
  int v2 = _cfnAutoreleaseDebugBuffer(long)::pPos;
  size_t v3 = *(void *)(a1 + 40);
  _cfnAutoreleaseDebugBuffer(long)::pPos += v3;
  if (_cfnAutoreleaseDebugBuffer(long)::pPos >= 0x200)
  {
    int v2 = 0;
    _cfnAutoreleaseDebugBuffer(long)::pPos = 0;
  }

  unint64_t v4 = (void *)(_cfnAutoreleaseDebugBuffer(long)::pBuffer + v2);
  bzero(v4, v3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
}

dispatch_queue_t ___Z26_cfnAutoreleaseDebugBufferl_block_invoke()
{
  _cfnAutoreleaseDebugBuffer(long)::pBuffer = (uint64_t)malloc(0x200uLL);
  dispatch_queue_t result = dispatch_queue_create("circLock", 0LL);
  _cfnAutoreleaseDebugBuffer(long)::sLock = (uint64_t)result;
  return result;
}

char *_cfnAutoreleaseInDebug(const __CFString *a1)
{
  if (!a1) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  if (_cfnAutoreleaseDebugBuffer(long)::sOnce != -1) {
    dispatch_once(&_cfnAutoreleaseDebugBuffer(long)::sOnce, &__block_literal_global_3721);
  }
  if (v3 >= 512) {
    goto LABEL_7;
  }
  uint64_t v7 = 0LL;
  double v8 = &v7;
  uint64_t v9 = 0x2020000000LL;
  uint64_t v10 = 0LL;
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = ___Z26_cfnAutoreleaseDebugBufferl_block_invoke_2;
  void v6[3] = &unk_189C19850;
  v6[4] = &v7;
  void v6[5] = v3;
  dispatch_sync((dispatch_queue_t)_cfnAutoreleaseDebugBuffer(long)::sLock, v6);
  unint64_t v4 = (char *)v8[3];
  _Block_object_dispose(&v7, 8);
  if (v4) {
    CFStringGetCString(a1, v4, v3, 0x8000100u);
  }
  else {
LABEL_7:
  }
    unint64_t v4 = "-";
  CFRelease(a1);
  return v4;
}

_OWORD *CFURLConnectionCreate(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = (void *)MEMORY[0x186E1578C]();
  uint64_t v7 = CFURLConnectionCreateWithProperties(a1, a2, a3, 0LL);
  objc_autoreleasePoolPop(v6);
  return v7;
}

_OWORD *CFURLConnectionCreateWithProperties(uint64_t a1, void *a2, void *a3, const __CFDictionary *a4)
{
  CFAllocatorContext context = (void *)MEMORY[0x186E1578C]();
  if (!a2 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "CFURLConnectionCreate(): Asked to create from a NULL request!",  buf,  2u);
  }

  uint64_t v6 = (_CFURLRequest *)[a2 mutableCopy];
  if (a4)
  {
    unsigned int Value = (const __CFDictionary *)CFDictionaryGetValue(a4, @"kCFURLConnectionSocketStreamProperties");
    if (Value)
    {
      double v8 = (const __CFDictionary *)CFDictionaryGetValue(Value, &unk_18C5AD830);
      if (v8)
      {
        uint64_t v9 = v8;
        if (CFDictionaryContainsKey(v8, @"kConditionalConnectionRequirementTimeWindowDelay")
          || CFDictionaryContainsKey(v9, @"kConditionalConnectionRequirementTimeWindowStartTime"))
        {
          uint64_t v10 = -[_CFURLRequest _inner](v6, "_inner");
          *(_WORD *)(v10 + 64) |= 0x400u;
          *(void *)(v10 + CFRelease((char *)this - 16) = 1LL;
        }
      }
    }

    uint64_t v11 = CFDictionaryGetValue(a4, &unk_18C5B0658);
    if (v11)
    {
      unint64_t v12 = v11;
      uint64_t v13 = -[_CFURLRequest _inner](v6, "_inner");
      CFRetain(v12);
      uint64_t v14 = *(const void **)(v13 + 200);
      if (v14) {
        CFRelease(v14);
      }
      *(void *)(v13 + 200) = v12;
    }
  }

  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  uint64_t v16 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    uint64_t v16 = Instance + 1;
    Instance[3] = 0u;
    Instance[4] = 0u;
    Instance[2] = 0u;
  }

  *((void *)v16 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C05668;
  *(void *)uint64_t v16 = &off_189C05578;
  *((void *)v16 + 2) = &unk_189C056C8;
  if (a4)
  {
    __int16 v17 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"kCFURLConnectionSocketStreamProperties");
    CFTypeRef v18 = (const __CFDictionary *)CFDictionaryGetValue(a4, @"kCFURLConnectionURLConnectionProperties");
    UpdatedSocketPropertiesForRequest = createUpdatedSocketPropertiesForRequest(v6, v17, v18);
  }

  else
  {
    UpdatedSocketPropertiesForRequest = createUpdatedSocketPropertiesForRequest(v6, 0LL, 0LL);
    CFTypeRef v18 = 0LL;
  }

  uint64_t v20 = +[NSURLSession _sharedSessionForConnection]();
  if (v20)
  {
    int v21 = -[CONNECTION_SessionTask initWithRequest:mutableCurrent:connProps:sockProps:session:]( objc_alloc(&OBJC_CLASS___CONNECTION_SessionTask),  "initWithRequest:mutableCurrent:connProps:sockProps:session:",  a2,  v6,  v18,  UpdatedSocketPropertiesForRequest,  v20);
    if (!UpdatedSocketPropertiesForRequest) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }

  int v21 = 0LL;
  if (UpdatedSocketPropertiesForRequest) {
LABEL_23:
  }
    CFRelease(UpdatedSocketPropertiesForRequest);
LABEL_24:
  *((void *)v16 + 7) = v21;
  CFAllocatorRef v22 = CFGetAllocator(v16 - 1);
  uint64_t v23 = [*((id *)v16 + 7) session];
  CFNumberRef cf = v6;
  if (v23) {
    unint64_t v24 = *(dispatch_object_s **)(v23 + 120);
  }
  else {
    unint64_t v24 = 0LL;
  }
  uint64_t v25 = MEMORY[0x186E12804](v22, 288LL, 0LL);
  *(_OWORD *)uint64_t v25 = 0u;
  *(_OWORD *)(v25 + CFRelease((char *)this - 16) = 0u;
  *(_OWORD *)(v25 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
  *(_OWORD *)(v25 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v25 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(v25 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = 0u;
  *(_OWORD *)(v25 + 96) = 0u;
  *(_OWORD *)(v25 + 112) = 0u;
  *(_OWORD *)(v25 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v25 + 14os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(v25 + 160) = 0u;
  *(_OWORD *)(v25 + 176) = 0u;
  *(_OWORD *)(v25 + 192) = 0u;
  *(_OWORD *)(v25 + 20_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v25 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(v25 + 240) = 0u;
  *(_OWORD *)(v25 + 256) = 0u;
  *(_OWORD *)(v25 + 272) = 0u;
  unint64_t v26 = (void *)*((void *)v16 + 7);
  uint64_t v27 = (*(uint64_t (**)(uint64_t))(*((void *)v16 + 1) + 56LL))((uint64_t)v16 + 8);
  *(void *)uint64_t v25 = off_189C0F708;
  *(void *)(v25 + _Block_object_dispose(va, 8) = v27;
  *(void *)(v25 + CFRelease((char *)this - 16) = &unk_189C0F730;
  *(_BYTE *)(v25 + 25) = 0;
  *(void *)(v25 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = (char *)v16 + 8;
  *(void *)(v25 + 40) = v24;
  dispatch_retain(v24);
  *(_BYTE *)(v25 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
  *(void *)uint64_t v25 = off_189C0F750;
  *(void *)(v25 + CFRelease((char *)this - 16) = &unk_189C0F898;
  *(void *)(v25 + 4_Block_object_dispose(va, 8) = &unk_189C0F8B8;
  *(void *)(v25 + 56) = &unk_189C0F970;
  *(void *)(v25 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C0F9C8;
  *(void *)(v25 + 2CFRelease((char *)this - 16) = v16;
  *(void *)(v25 + 8_Block_object_dispose(va, 8) = v26;
  *(void *)(v25 + 120) = 1LL;
  uint64_t v28 = MEMORY[0x1895F87A8];
  *(_BYTE *)(v25 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0;
  *(void *)__int128 buf = v28;
  uint64_t v36 = 3221225472LL;
  unint64_t v37 = ___ZN19URLConnectionClientC2EP20ClassicURLConnectionP16NSURLSessionTaskPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
  int v38 = &__block_descriptor_40_e24_v16__0r__XURLCache_____8l;
  uint64_t v39 = v25;
  [v26 _withXURLCache:buf];
  *(_BYTE *)(v25 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0;
  *(_DWORD *)(v25 + 12_Block_object_dispose(va, 8) = 0;
  *(_BYTE *)(v25 + 140) = 0;
  *(_DWORD *)(v25 + 136) = 0;
  *(void *)(v25 + 200) = 0LL;
  *(_DWORD *)(v25 + 20_Block_object_dispose(va, 8) = 0;
  *(_BYTE *)(v25 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
  *(void *)uint64_t v25 = off_189C0FCF8;
  *(void *)(v25 + CFRelease((char *)this - 16) = &unk_189C0FED8;
  *(void *)(v25 + 4_Block_object_dispose(va, 8) = &unk_189C0FEF8;
  *(void *)(v25 + 56) = &unk_189C0FFB0;
  *(void *)(v25 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C10008;
  *(void *)(v25 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  *(void *)(v25 + 24_Block_object_dispose(va, 8) = 0LL;
  URLConnectionClient_Classic::setDelegate(v25, a3);
  *((void *)v16 + 3) = v25;
  buf[0] = 0x80;
  if (a3)
  {
    uint8_t v29 = 0x80;
    switch(*a3)
    {
      case 3LL:
      case 4LL:
        goto LABEL_38;
      case 5LL:
      case 6LL:
        goto LABEL_36;
      case 7LL:
        goto LABEL_34;
      case 8LL:
        goto LABEL_32;
      case 9LL:
        if (a3[23])
        {
          uint8_t v29 = -112;
          buf[0] = -112;
        }

        if (a3[22])
        {
          v29 |= 0x20u;
          buf[0] = v29;
        }

LABEL_38:
        if (a3[13]) {
          buf[0] = v29 | 2;
        }
        if (a3[14]) {
          *(_WORD *)(*((void *)v16 + 3) + 76LL) |= 0x100u;
        }
        break;
      default:
        break;
    }
  }

  unint64_t v30 = (URLConnectionLoader_Classic *)MEMORY[0x186E12804](v22, 224LL, 0LL);
  *(_OWORD *)unint64_t v30 = 0u;
  *((_OWORD *)v30 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  *((_OWORD *)v30 + 2) = 0u;
  *((_OWORD *)v30 + 3) = 0u;
  *((_OWORD *)v30 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *((_OWORD *)v30 + 5) = 0u;
  *((_OWORD *)v30 + 6) = 0u;
  *((_OWORD *)v30 + 7) = 0u;
  *((_OWORD *)v30 + _Block_object_dispose(va, 8) = 0u;
  *((_OWORD *)v30 + 9) = 0u;
  *((_OWORD *)v30 + 10) = 0u;
  *((_OWORD *)v30 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  *((_OWORD *)v30 + 12) = 0u;
  *((_OWORD *)v30 + 13) = 0u;
  URLConnectionLoader_Classic::URLConnectionLoader_Classic( v30,  (InterfaceRequiredForLoader *)((char *)v16 + 8),  (const ConfigFlags *)buf,  (__NSURLSessionLocal *)[*((id *)v16 + 7) session],  v24);
  *((void *)v16 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v30;

  if (cf) {
    CFRelease(cf);
  }
  objc_autoreleasePoolPop(context);
  return v16 - 1;
}

  if (v5 != -1 && *(void *)(v3 + 272))
  {
    unsigned int valuePtr = v5;
    uint64_t v20 = CFGetAllocator((CFTypeRef)(v3 - 16));
    int v21 = CFNumberCreate(v20, kCFNumberSInt64Type, &valuePtr);
    (*(void (**)(void, uint64_t, CFNumberRef))(**(void **)(v3 + 272) + 40LL))( *(void *)(v3 + 272),  10LL,  v21);
    if (v21) {
      CFRelease(v21);
    }
  }

void sub_182A6C810(_Unwind_Exception *a1)
{
}

void ___ZN9TCFObjectI13URLConnectionE5ClassEv_block_invoke()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  qmemcpy(_PNAME<URLConnection>::GET(void)::p, "URLConnection", 13);
  CFClass::CFClass(v0, (const char *)_PNAME<URLConnection>::GET(void)::p);
  TCFObject<URLConnection>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182A6C8C0(_Unwind_Exception *a1)
{
}

void CFURLConnectionStart(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0LL;
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 56LL))(v3);
  objc_autoreleasePoolPop(v2);
}

void CFURLConnectionCancel(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0LL;
  }
  (*(void (**)(uint64_t))(*(void *)(v3 + 8) + 48LL))(v3 + 8);
  objc_autoreleasePoolPop(v2);
}

void CFURLConnectionUseCredential(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v7 = a1 + 16;
  }
  else {
    uint64_t v7 = 0LL;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 64LL))(v7, a2, a3);
  objc_autoreleasePoolPop(v6);
}

void CFURLConnectionPerformDefaultHandlingForChallenge(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0LL;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 72LL))(v5, a2);
  objc_autoreleasePoolPop(v4);
}

void CFURLConnectionRejectChallenge(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0LL;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 80LL))(v5, a2);
  objc_autoreleasePoolPop(v4);
}

void CFURLConnectionHalt(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0LL;
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 88LL))(v3);
  objc_autoreleasePoolPop(v2);
}

void CFURLConnectionResume(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = 0LL;
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 96LL))(v3);
  objc_autoreleasePoolPop(v2);
}

void CFURLConnectionScheduleWithRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v7 = a1 + 16;
  }
  else {
    uint64_t v7 = 0LL;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 104LL))(v7, a2, a3);
  objc_autoreleasePoolPop(v6);
}

void CFURLConnectionUnscheduleFromRunLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v7 = a1 + 16;
  }
  else {
    uint64_t v7 = 0LL;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 112LL))(v7, a2, a3);
  objc_autoreleasePoolPop(v6);
}

void CFURLConnectionScheduleDownloadWithRunLoop()
{
  if (CFURLConnectionScheduleDownloadWithRunLoop::onceToken != -1) {
    dispatch_once(&CFURLConnectionScheduleDownloadWithRunLoop::onceToken, &__block_literal_global_3751);
  }
}

void __CFURLConnectionScheduleDownloadWithRunLoop_block_invoke()
{
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  os_log_t v0 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_error_impl( &dword_18298D000,  v0,  OS_LOG_TYPE_ERROR,  "Scheduling the NSURLConnection loader is no longer supported.",  v1,  2u);
  }

void CFURLConnectionSetDelegateDispatchQueue(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (void *)MEMORY[0x186E1578C]();
  if (a1) {
    uint64_t v5 = a1 + 16;
  }
  else {
    uint64_t v5 = 0LL;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 120LL))(v5, a2);
  objc_autoreleasePoolPop(v4);
}

void CFURLConnectionInvalidateConnectionCache()
{
  os_log_t v0 = (void *)MEMORY[0x186E1578C]();
  uint64_t v1 = +[NSURLSession _sharedSessionForConnection]();
  if (v1)
  {
    int v2 = *(CFDictionaryRef **)(v1 + 168);
    if (v2) {
      XTubeManager::invalidateAllConnections(v2, 0);
    }
  }

  objc_autoreleasePoolPop(v0);
}

void *_CFURLConnectionCopyTimingData(void *a1)
{
  int v2 = (void *)MEMORY[0x186E1578C]();
  if (a1)
  {
    uint64_t v3 = (void *)a1[9];
    if (!v3) {
      goto LABEL_9;
    }
    id Property = (id)[v3 _metrics];
    if (Property) {
      id Property = objc_getProperty(Property, v5, 96LL, 1);
    }
    id v6 = -[__CFN_TransactionMetrics legacyStaticMetrics]((uint64_t)Property);
    if (v6) {
      a1 = CFRetain(v6);
    }
    else {
LABEL_9:
    }
      a1 = 0LL;
  }

  objc_autoreleasePoolPop(v2);
  return a1;
}

void non-virtual thunk to'HTTPRequest::~HTTPRequest(HTTPRequest *this)
{
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 8));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 16));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 16));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 128));
}

{
  HTTPRequest::~HTTPRequest((HTTPRequest *)((char *)this - 128));
}

void non-virtual thunk to'HTTPResponse::~HTTPResponse(HTTPResponse *this)
{
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 8));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 16));
}

{
  HTTPResponseMessage::~HTTPResponseMessage((HTTPResponseMessage *)((char *)this - 16));
}

uint64_t URLProtocol::getCurrentBodyStream(URLProtocol *this)
{
  return 0LL;
}

void URLProtocol::setBytesPerSecondLimit(URLProtocol *this, uint64_t a2)
{
  int v2 = (Throttler *)*((void *)this + 8);
  if (v2) {
    Throttler::setMaximumBPSTarget(v2, a2);
  }
}

uint64_t URLProtocol::getCurrentSuspensionThreshold(URLProtocol *this, uint64_t a2)
{
  return a2;
}

uint64_t URLProtocol::_throttle_throttle(URLProtocol *this)
{
  *((_BYTE *)this + 72) = 1;
  return (*(uint64_t (**)(URLProtocol *))(*(void *)this + 104LL))(this);
}

uint64_t URLProtocol::_throttle_unthrottle(URLProtocol *this)
{
  *((_BYTE *)this + 72) = 0;
  return (*(uint64_t (**)(URLProtocol *))(*(void *)this + 112LL))(this);
}

uint64_t URLProtocol::_throttle_getCurrentSuspensionThreshold(URLProtocol *this)
{
  return (*(uint64_t (**)(URLProtocol *))(*(void *)this + 168LL))(this);
}

uint64_t URLProtocol::_throttle_getMaximumWaitTime(URLProtocol *this)
{
  uint64_t result = [*((id *)this + 10) _timeoutInterval];
  if (v3 + -2.0 >= 0.0) {
    return objc_msgSend(*((id *)this + 10), "_timeoutInterval", 0.0);
  }
  return result;
}

uint64_t URLProtocol::needsThrottler(URLProtocol *this)
{
  return 0LL;
}

uint64_t non-virtual thunk to'URLProtocol::_throttle_throttle(URLProtocol *this)
{
  uint64_t v1 = *((void *)this - 2);
  *((_BYTE *)this + 56) = 1;
  return (*(uint64_t (**)(void))(v1 + 104))();
}

uint64_t non-virtual thunk to'URLProtocol::_throttle_unthrottle(URLProtocol *this)
{
  uint64_t v1 = *((void *)this - 2);
  *((_BYTE *)this + 56) = 0;
  return (*(uint64_t (**)(void))(v1 + 112))();
}

uint64_t non-virtual thunk to'URLProtocol::_throttle_getMaximumWaitTime(URLProtocol *this)
{
  uint64_t result = [*((id *)this + 8) _timeoutInterval];
  if (v3 + -2.0 >= 0.0) {
    return objc_msgSend(*((id *)this + 8), "_timeoutInterval", 0.0);
  }
  return result;
}

void ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke_3796(uint64_t a1)
{
}

void URLProtocol::uploadActivityOccurred(URLProtocol *this, uint64_t a2)
{
  *((CFAbsoluteTime *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = CFAbsoluteTimeGetCurrent();
  if (a2 >= 1)
  {
    uint64_t v4 = *((void *)this + 12);
    if (v4)
    {
      uint64_t v5 = (*(uint64_t (**)(void))(*(void *)v4 + 16LL))(*((void *)this + 12));
      id v6 = (void *)MEMORY[0x186E1578C](v5);
      *((void *)this + 6) += a2;
      (*(void (**)(void, uint64_t))(**((void **)this + 12) + 80LL))(*((void *)this + 12), a2);
      objc_autoreleasePoolPop(v6);
      (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
    }
  }

BOOL XCredentialStorage::equals(XCredentialStorage *this, XCredentialStorage *a2)
{
  return this == a2;
}

void NSXCredentialStorage::setDefaultCredentialForProtectionSpace( id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  double v8 = (void *)MEMORY[0x186E1578C]();
  objc_msgSend( this[3],  "setDefaultCredential:forProtectionSpace:task:",   -[NSURLCredential _initWithCFURLCredential:]( [NSURLCredential alloc],  "_initWithCFURLCredential:",  a2),   -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]( [NSURLProtectionSpace alloc],  "_initWithCFURLProtectionSpace:",  a3),  a4);
  objc_autoreleasePoolPop(v8);
}

void NSXCredentialStorage::setCredentialForProtectionSpace( id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  double v8 = (void *)MEMORY[0x186E1578C]();
  objc_msgSend( this[3],  "setCredential:forProtectionSpace:task:",   -[NSURLCredential _initWithCFURLCredential:]( [NSURLCredential alloc],  "_initWithCFURLCredential:",  a2),   -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]( [NSURLProtectionSpace alloc],  "_initWithCFURLProtectionSpace:",  a3),  a4);
  objc_autoreleasePoolPop(v8);
}

void NSXCredentialStorage::removeCredentialForProtectionSpace( id *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  double v8 = (void *)MEMORY[0x186E1578C]();
  objc_msgSend( this[3],  "removeCredential:forProtectionSpace:options:task:",   -[NSURLCredential _initWithCFURLCredential:]( [NSURLCredential alloc],  "_initWithCFURLCredential:",  a2),   -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]( [NSURLProtectionSpace alloc],  "_initWithCFURLProtectionSpace:",  a3),  0,  a4);
  objc_autoreleasePoolPop(v8);
}

uint64_t NSXCredentialStorage::copyDefaultCredentialForProtectionSpace( NSXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  uint64_t v16 = 0LL;
  id v6 = (void *)MEMORY[0x186E1578C]();
  id v7 =  -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]( objc_alloc(&OBJC_CLASS___NSURLProtectionSpace),  "_initWithCFURLProtectionSpace:",  a2);
  double v8 = dispatch_group_create();
  dispatch_group_enter(v8);
  uint64_t v9 = (void *)*((void *)this + 3);
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  _DWORD v12[2] = ___ZNK20NSXCredentialStorage39copyDefaultCredentialForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke;
  v12[3] = &unk_189C06F30;
  v12[4] = v8;
  v12[5] = &v13;
  [v9 getDefaultCredentialForProtectionSpace:v7 task:a3 completionHandler:v12];
  dispatch_group_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v8);
  objc_autoreleasePoolPop(v6);
  uint64_t v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_182A6D414( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t NSXCredentialStorage::copyCredentialsForProtectionSpace( NSXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  uint64_t v16 = 0LL;
  id v6 = (void *)MEMORY[0x186E1578C]();
  id v7 =  -[NSURLProtectionSpace _initWithCFURLProtectionSpace:]( objc_alloc(&OBJC_CLASS___NSURLProtectionSpace),  "_initWithCFURLProtectionSpace:",  a2);
  double v8 = dispatch_group_create();
  dispatch_group_enter(v8);
  uint64_t v9 = (void *)*((void *)this + 3);
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  _DWORD v12[2] = ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke;
  v12[3] = &unk_189C06F80;
  v12[4] = v8;
  v12[5] = &v13;
  [v9 getCredentialsForProtectionSpace:v7 task:a3 completionHandler:v12];
  dispatch_group_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v8);
  objc_autoreleasePoolPop(v6);
  uint64_t v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_182A6D534( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t NSXCredentialStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = (void *)MEMORY[0x186E1578C]();
    id v6 = (void *)[*(id *)(a1 + 24) allCredentials];
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    _DWORD v8[2] = ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke;
    void v8[3] = &__block_descriptor_40_e15_v32__0_8_16_B24l;
    v8[4] = a1;
    [v6 enumerateKeysAndObjectsUsingBlock:v8];
    objc_autoreleasePoolPop(v5);
  }

  return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
}

uint64_t ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke_2;
  v5[3] = &unk_189C06FA8;
  v5[4] = a2;
  void v5[5] = v3;
  return [a3 enumerateKeysAndObjectsUsingBlock:v5];
}

uint64_t ___ZNK20NSXCredentialStorage12flushOrResetEhU13block_pointerFvvE_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(*(void *)(a1 + 40) + 24) removeCredential:a3 forProtectionSpace:*(void *)(a1 + 32)];
}

void ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke( uint64_t a1, void *a2)
{
  if (a2 && [a2 count])
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 3221225472LL;
    v4[2] = ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke_2;
    v4[3] = &unk_189C06F58;
    v4[4] = *(void *)(a1 + 40);
    [a2 enumerateKeysAndObjectsUsingBlock:v4];
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = cfTypeCreateMutableDictionary( (const __CFAllocator *)*MEMORY[0x189604DB0],  0LL,  0LL);
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void ___ZNK20NSXCredentialStorage33copyCredentialsForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke_2( uint64_t a1, const void *a2, void *a3)
{
  uint64_t v5 = (const void *)[a3 _cfurlcredential];
  if (v5)
  {
    CFTypeRef v6 = CFRetain(v5);
    if (v6)
    {
      id v7 = v6;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a2, v6);
      CFRelease(v7);
    }
  }

void ___ZNK20NSXCredentialStorage39copyDefaultCredentialForProtectionSpaceEP21_CFURLProtectionSpaceP16NSURLSessionTask_block_invoke( uint64_t a1, void *a2)
{
  CFTypeRef v3 = (CFTypeRef)[a2 _cfurlcredential];
  if (v3) {
    CFTypeRef v3 = CFRetain(v3);
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v3;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

uint64_t XCredentialStorage::createCFXCredentialStorage( XCredentialStorage *this, _CFURLCredentialStorage *a2)
{
  uint64_t v3 = *MEMORY[0x189604DB0];
  uint64_t v4 = MEMORY[0x186E12804](*MEMORY[0x189604DB0], 32LL, 0LL);
  *(void *)(v4 + 20) = 0LL;
  *(_DWORD *)(v4 + 2_Block_object_dispose(va, 8) = 0;
  *(void *)uint64_t v4 = off_189C06BF8;
  *(void *)(v4 + _Block_object_dispose(va, 8) = v3;
  *(_DWORD *)(v4 + CFRelease((char *)this - 16) = 1;
  if (((v4 + 16) & 3) != 0) {
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  }
  uint64_t v5 = v4;
  *(void *)uint64_t v4 = off_189C06FD8;
  if (this) {
    CFTypeRef v6 = CFRetain(this);
  }
  else {
    CFTypeRef v6 = 0LL;
  }
  *(void *)(v5 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6;
  return v5;
}

void CFXCredentialStorage::~CFXCredentialStorage(CFXCredentialStorage *this)
{
  *(void *)this = off_189C06FD8;
  uint64_t v1 = (const void *)*((void *)this + 3);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C06FD8;
  int v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t CFXCredentialStorage::setDefaultCredentialForProtectionSpace( CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  return CFURLCredentialStorageSetDefaultCredentialForProtectionSpace(*((void *)this + 3), (uint64_t)a2, (uint64_t)a3);
}

uint64_t CFXCredentialStorage::setCredentialForProtectionSpace( CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
  return CFURLCredentialStorageSetCredentialForProtectionSpace(*((void *)this + 3), (uint64_t)a2, (uint64_t)a3);
}

void CFXCredentialStorage::removeCredentialForProtectionSpace( CFXCredentialStorage *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, NSURLSessionTask *a4)
{
}

uint64_t CFXCredentialStorage::copyDefaultCredentialForProtectionSpace( CFXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  return CFURLCredentialStorageCopyDefaultCredentialForProtectionSpace(*((void *)this + 3), (uint64_t)a2);
}

uint64_t CFXCredentialStorage::copyCredentialsForProtectionSpace( CFXCredentialStorage *this, _CFURLProtectionSpace *a2, NSURLSessionTask *a3)
{
  return CFURLCredentialStorageCopyCredentialsForProtectionSpace(*((void *)this + 3), (uint64_t)a2);
}

uint64_t CFXCredentialStorage::flushOrReset(uint64_t a1, int a2, uint64_t a3)
{
  if (!a2) {
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  uint64_t v5 = (const __CFDictionary *)CFURLCredentialStorageCopyAllCredentials(*(void *)(a1 + 24));
  if (!v5) {
    return (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  CFTypeRef v6 = v5;
  v22[0] = CFRetain(v5);
  unint64_t Count = CFDictionaryGetCount(v6);
  v22[1] = Count;
  if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
  {
    uint64_t v23 = 0LL;
  }

  else
  {
    if (Count <= 0x1E)
    {
      double v8 = (const void **)v24;
      uint64_t v23 = (const void **)v24;
LABEL_8:
      CFDictionaryGetKeysAndValues(v6, v8, 0LL);
      goto LABEL_9;
    }

    double v8 = (const void **)malloc(8 * Count);
    uint64_t v23 = v8;
    if (v8) {
      goto LABEL_8;
    }
  }

void sub_182A6DB58( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, char a43)
{
}

NSXCredentialStorage *XCredentialStorage::createEmptyXCredentialStorage(XCredentialStorage *this)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS_____NSCFMemoryURLCredentialStorage);
  int v2 = (NSXCredentialStorage *)MEMORY[0x186E12804](*MEMORY[0x189604DB0], 32LL, 0LL);
  *(_OWORD *)int v2 = 0u;
  *((_OWORD *)v2 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0u;
  NSXCredentialStorage::NSXCredentialStorage(v2, v1);

  return v2;
}

CFStringRef URLRequest::copyDebugDesc(URLRequest *this)
{
  fURL = this->fURL;
  if (fURL) {
    CFStringRef v3 = CFURLGetString(fURL);
  }
  else {
    CFStringRef v3 = @"Null URL";
  }
  if ((*(_WORD *)&this->fFlags & 2) != 0) {
    uint64_t v4 = "CFMutableURLRequest";
  }
  else {
    uint64_t v4 = "CFURLRequest";
  }
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<%s %p> { url = %@ }",  v4,  this,  v3);
}

CFStringRef URLRequest::copyDebugSummary(URLRequest *this)
{
  fHTTPRequest = this->fHTTPRequest;
  if (fHTTPRequest)
  {
    uint64_t v3 = (*(uint64_t (**)(HTTPRequest *))(*(void *)fHTTPRequest + 32LL))(fHTTPRequest);
    if (v3)
    {
      uint64_t v4 = (const void *)v3;
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"request %@", v3);
      CFRelease(v4);
      if (v5) {
        return v5;
      }
    }
  }

  fURL = this->fURL;
  if (fURL)
  {
    CFURLRef v7 = CFURLCopyAbsoluteURL(fURL);
    if (v7)
    {
      double v8 = v7;
      if (__CFNCanLogSensitiveContent::onceToken != -1) {
        dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4760);
      }
      if (__CFNCanLogSensitiveContent::ok)
      {
        CFStringRef v9 = CFURLGetString(v8);
        if (!v9)
        {
          CFRelease(v8);
          return (CFStringRef)CFRetain(@"request has no url");
        }

        uint64_t v10 = (const __CFString *)CFRetain(v9);
      }

      else
      {
        uint64_t v10 = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"%@://%@/<redacted>",  -[__CFURL scheme](v8, "scheme"),  -[__CFURL host](v8, "host"));
      }

      CFStringRef v5 = v10;
      CFRelease(v8);
      if (v5) {
        return v5;
      }
    }
  }

  return (CFStringRef)CFRetain(@"request has no url");
}

unint64_t URLRequest::hash(URLRequest *this)
{
  CFHashCode fURL = (CFHashCode)this->fURL;
  if (fURL) {
    CFHashCode fURL = CFHash((CFTypeRef)fURL);
  }
  return fURL ^ (4 * this->fCachePolicy);
}

void URLRequest::setProtocolProperty(URLRequest *this, const __CFString *key, const void *value)
{
  fProtocolProperties = this->fProtocolProperties;
  if (!fProtocolProperties)
  {
    fProtocolProperties = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    this->fProtocolProperties = fProtocolProperties;
  }

  if (value) {
    CFDictionarySetValue(fProtocolProperties, key, value);
  }
  else {
    CFDictionaryRemoveValue(fProtocolProperties, key);
  }
}

uint64_t URLRequest::initialize( URLRequest *this, uint64_t a2, const void **a3, uint64_t a4, const __CFDictionary *a5)
{
  if (a4 >= 1 && !*a3) {
    return 0LL;
  }
  if (a2)
  {
    switch(a2)
    {
      case 1LL:
        if ((a4 | 4) != 0xD) {
          return 0LL;
        }
        goto LABEL_8;
      case 2LL:
        if (a4 != 9 && a4 != 14) {
          return 0LL;
        }
        goto LABEL_8;
      case 3LL:
        if (a4 != 10 && a4 != 15) {
          return 0LL;
        }
        goto LABEL_8;
      case 4LL:
        if (a4 == 11) {
          goto LABEL_8;
        }
        goto LABEL_58;
      case 5LL:
        if (a4 != 12 && a4 != 17) {
          return 0LL;
        }
        goto LABEL_8;
      case 6LL:
        if (a4 != 14 && a4 != 19) {
          return 0LL;
        }
        goto LABEL_8;
      case 7LL:
        if (a4 != 14 && a4 != 20) {
          return 0LL;
        }
        goto LABEL_8;
      case 8LL:
        if (a4 != 15 && a4 != 21) {
          return 0LL;
        }
        goto LABEL_8;
      case 9LL:
        if (a4 == 22) {
          goto LABEL_8;
        }
LABEL_58:
        if (a4 != 16) {
          return 0LL;
        }
        goto LABEL_8;
      default:
        return 0LL;
    }
  }

  if ((a4 | 4) != 0xC) {
    return 0LL;
  }
LABEL_8:
  uint64_t result = (uint64_t)*a3;
  if (!*a3) {
    return result;
  }
  CFTypeID v11 = CFGetTypeID((CFTypeRef)result);
  if (v11 != CFBooleanGetTypeID()) {
    return 0LL;
  }
  unint64_t v12 = a3[1];
  if (v12)
  {
    CFTypeID v13 = CFGetTypeID(v12);
    if (v13 != CFURLGetTypeID()) {
      return 0LL;
    }
  }

  uint64_t result = (uint64_t)a3[2];
  if (!result) {
    return result;
  }
  CFTypeID v14 = CFGetTypeID((CFTypeRef)result);
  if (v14 != CFNumberGetTypeID()) {
    return 0LL;
  }
  uint64_t result = (uint64_t)a3[3];
  if (!result) {
    return result;
  }
  CFTypeID v15 = CFGetTypeID((CFTypeRef)result);
  if (v15 != CFNumberGetTypeID()) {
    return 0LL;
  }
  CFIndex v16 = a3[4];
  if (v16)
  {
    CFTypeID v17 = CFGetTypeID(v16);
    if (v17 != CFURLGetTypeID()) {
      return 0LL;
    }
  }

  uint64_t result = (uint64_t)a3[5];
  if (!result) {
    return result;
  }
  CFTypeID v18 = CFGetTypeID((CFTypeRef)result);
  if (v18 != CFBooleanGetTypeID()) {
    return 0LL;
  }
  uint64_t result = (uint64_t)a3[11];
  if (!result) {
    return result;
  }
  CFTypeID v19 = CFGetTypeID((CFTypeRef)result);
  if (v19 != CFNumberGetTypeID()) {
    return 0LL;
  }
  uint64_t result = (uint64_t)a3[6];
  if (!result) {
    return result;
  }
  CFTypeID v20 = CFGetTypeID((CFTypeRef)result);
  if (v20 != CFNumberGetTypeID()) {
    return 0LL;
  }
  if ((unint64_t)a2 < 6)
  {
LABEL_61:
    int v25 = 0;
    int v26 = 0;
    int v27 = 0;
  }

  else
  {
    uint64_t result = (uint64_t)a3[12];
    if (!result) {
      return result;
    }
    CFTypeID v21 = CFGetTypeID((CFTypeRef)result);
    if (v21 != CFNumberGetTypeID()) {
      return 0LL;
    }
    uint64_t result = (uint64_t)a3[13];
    if (!result) {
      return result;
    }
    CFTypeID v22 = CFGetTypeID((CFTypeRef)result);
    if (v22 != CFNumberGetTypeID()) {
      return 0LL;
    }
    if ((unint64_t)a2 < 8)
    {
      int v25 = 0;
      int v27 = 0;
      int v26 = 1;
    }

    else
    {
      uint64_t result = (uint64_t)a3[14];
      if (!result) {
        return result;
      }
      CFTypeID v23 = CFGetTypeID((CFTypeRef)result);
      if (v23 != CFNumberGetTypeID()) {
        return 0LL;
      }
      if ((unint64_t)a2 < 9)
      {
        int v25 = 0;
      }

      else
      {
        uint64_t result = (uint64_t)a3[15];
        if (!result) {
          return result;
        }
        CFTypeID v24 = CFGetTypeID((CFTypeRef)result);
        if (v24 != CFNumberGetTypeID()) {
          return 0LL;
        }
        int v25 = 1;
      }

      int v26 = 1;
      int v27 = 1;
    }
  }

  uint64_t v28 = a3[7];
  if (v28)
  {
    CFTypeID v29 = CFGetTypeID(v28);
    if (v29 != CFDictionaryGetTypeID()) {
      return 0LL;
    }
  }

  if (!a2)
  {
    uint64_t v34 = 0LL;
    if (a4 != 12)
    {
LABEL_88:
      char v111 = 1;
      uint64_t v35 = 0LL;
      goto LABEL_115;
    }

    uint64_t v35 = 8LL;
LABEL_78:
    uint64_t v36 = v34 + v35;
    uint64_t result = (uint64_t)*(&a3[v35 + 1] + v34);
    if (!result) {
      return result;
    }
    CFTypeID v37 = CFGetTypeID((CFTypeRef)result);
    if (v37 == CFStringGetTypeID())
    {
      int v38 = &a3[v36];
      uint64_t v39 = v38[3];
      if (!v39 || (CFTypeID v40 = CFGetTypeID(v39), v40 == CFDataGetTypeID()))
      {
        unint64_t v41 = v38[2];
        if (!v41 || (CFTypeID v42 = CFGetTypeID(v41), v42 == CFDictionaryGetTypeID()))
        {
          if ((unint64_t)a2 >= 7 && (unint64_t v43 = a3[v35 + 5]) != 0LL)
          {
            CFTypeID v44 = CFGetTypeID(v43);
            CFTypeID TypeID = CFArrayGetTypeID();
            char v111 = 0;
            uint64_t result = 0LL;
            if (v44 != TypeID) {
              return result;
            }
          }

          else
          {
            char v111 = 0;
          }

LABEL_179:
          *(_WORD *)&this->fFlags |= 0x80u;
          if ((v60 & 0x10) == 0)
          {
LABEL_132:
            if ((v60 & 0x40) == 0) {
              goto LABEL_133;
            }
            goto LABEL_181;
          }

LABEL_181:
          *(_WORD *)&this->fFlags |= 0x200u;
          if ((v60 & 0x80) == 0)
          {
LABEL_134:
            if ((v60 & 0x100) == 0) {
              goto LABEL_135;
            }
            goto LABEL_183;
          }

LABEL_183:
          *(_WORD *)&this->fFlags |= 0x800u;
          if ((v60 & 0x200) == 0)
          {
LABEL_136:
            if ((v60 & 0x400) == 0) {
              goto LABEL_137;
            }
LABEL_185:
            *(_WORD *)&this->fFlags |= 0x2000u;
            if ((v60 & 0x1000) != 0) {
LABEL_138:
            }
              *(_WORD *)&this->fFlags |= 0x4000u;
LABEL_139:
            if (v26)
            {
              uint64_t v83 = (const __CFNumber *)a3[12];
              uint64_t valuePtr = 0LL;
              int v84 = CFNumberGetValue(v83, kCFNumberDoubleType, &valuePtr);
              double v85 = *(double *)&valuePtr;
              if (!v84) {
                double v85 = 0.0;
              }
              this->fTimeWindowDelay = v85;
              uint64_t v86 = (const __CFNumber *)a3[13];
              uint64_t valuePtr = 0LL;
              int v87 = CFNumberGetValue(v86, kCFNumberDoubleType, &valuePtr);
              double v88 = *(double *)&valuePtr;
              if (!v87) {
                double v88 = 0.0;
              }
              this->fTimeWindowDuration = v88;
              if (!v27)
              {
LABEL_141:
                if (!v25) {
                  goto LABEL_145;
                }
                goto LABEL_142;
              }
            }

            else if (!v27)
            {
              goto LABEL_141;
            }

            uint64_t v89 = (const __CFNumber *)a3[14];
            uint64_t valuePtr = 0LL;
            int v90 = CFNumberGetValue(v89, kCFNumberCFIndexType, &valuePtr);
            int v91 = valuePtr;
            if (!v90) {
              int v91 = 0;
            }
            this->fNetworkServiceType = v91;
            if (!v25)
            {
LABEL_145:
              uint64_t v64 = (void *)a3[7];
              if (!a2)
              {
                if (v64) {
                  uint64_t v64 = (void *)CFRetain(v64);
                }
                this->fSSLProps = (__CFDictionary *)v64;
                char v82 = v111;
                goto LABEL_196;
              }

              if (v64) {
                uint64_t v64 = (void *)CFRetain(v64);
              }
              this->fProxyDict = (__CFDictionary *)v64;
              unint64_t v65 = (const __CFDictionary *)a3[8];
              if (v65)
              {
                uint64_t v110 = v35;
                if (CFDictionaryContainsKey(v65, &unk_18C5AD2B8))
                {
                  uint64_t v66 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a3[8], &unk_18C5AD2B8);
                  if (v66)
                  {
                    unint64_t v67 = v66;
                    CFTypeID v68 = CFGetTypeID(v66);
                    if (v68 == CFArrayGetTypeID())
                    {
                      if (CFArrayGetValueAtIndex(v67, 0LL))
                      {
                        ValueAtIndex = CFArrayGetValueAtIndex(v67, 0LL);
                        CFTypeID v70 = CFGetTypeID(ValueAtIndex);
                        if (v70 == CFDataGetTypeID())
                        {
                          CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x189604DB0];
                          CFArrayRef theArray = CFArrayCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605228]);
                          CFIndex Count = CFArrayGetCount(v67);
                          if (Count >= 1)
                          {
                            CFIndex v72 = Count;
                            CFIndex v73 = 0LL;
                            do
                            {
                              CFIndex v74 = v73;
                              uint64_t v75 = (const __CFData *)CFArrayGetValueAtIndex(v67, v73);
                              if (v75)
                              {
                                uint64_t v76 = v75;
                                CFTypeID v77 = CFGetTypeID(v75);
                                if (v77 == CFDataGetTypeID())
                                {
                                  SecCertificateRef v78 = SecCertificateCreateWithData(allocator, v76);
                                  if (v78)
                                  {
                                    SecCertificateRef v79 = v78;
                                    CFArrayInsertValueAtIndex(theArray, v74, v78);
                                    CFRelease(v79);
                                  }
                                }
                              }

                              CFIndex v73 = v74 + 1;
                            }

                            while (v72 != v74 + 1);
                          }

                          if (theArray)
                          {
                            if (CFArrayGetCount(theArray) >= 1)
                            {
                              CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(allocator, 0LL, (CFDictionaryRef)a3[8]);
                              if (MutableCopy)
                              {
                                __int128 v81 = MutableCopy;
                                CFDictionaryReplaceValue(MutableCopy, &unk_18C5AD2B8, theArray);
                                CFRelease(theArray);
                                this->fSSLProps = (__CFDictionary *)CFRetain(v81);
                                CFRelease(v81);
                                uint64_t v35 = v110;
                                char v82 = v111;
LABEL_194:
                                if (a2 >= 3 && !CFBooleanGetValue((CFBooleanRef)a3[9]))
                                {
                                  __int16 fFlags = *(_WORD *)&this->fFlags & 0xFFF7;
LABEL_197:
                                  *(_WORD *)&this->__int16 fFlags = fFlags;
                                  if (a2 >= 4
                                    && (int v93 = CFBooleanGetValue((CFBooleanRef)a3[10]),
                                        __int16 fFlags = (__int16)this->fFlags,
                                        v93))
                                  {
                                    __int16 v94 = fFlags | 0x10;
                                  }

                                  else
                                  {
                                    __int16 v94 = fFlags & 0xFFEF;
                                  }

                                  *(_WORD *)&this->__int16 fFlags = v94;
                                  if ((v82 & 1) == 0)
                                  {
                                    if (a2 < 2)
                                    {
                                      unint64_t v96 = 0LL;
                                      uint64_t v97 = 0LL;
                                    }

                                    else
                                    {
                                      unint64_t v95 = (const __CFArray *)a3[v35];
                                      if (v95) {
                                        unint64_t v96 = _CFHTTPCookieStorageCreateFromArchive(0LL, v95, v58);
                                      }
                                      else {
                                        unint64_t v96 = 0LL;
                                      }
                                      uint64_t v97 = 1LL;
                                    }

                                    unint64_t v98 = &a3[v35] + v97;
                                    uint64_t v100 = (const __CFDictionary *)v98[2];
                                    CFMutableArrayRef v99 = v98[3];
                                    unint64_t v101 = (const __CFString *)v98[1];
                                    if (this->fHTTPRequest
                                      && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
                                    {
                                      LOWORD(valuePtr) = 0;
                                      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "can't be here",  (uint8_t *)&valuePtr,  2u);
                                    }

                                    uint64_t v102 = (const __CFAllocator *)*MEMORY[0x189604DB0];
                                    if (HTTPMessage::Class(void)::sOnce_HTTPMessage != -1)
                                    {
                                      uint64_t v107 = (const __CFAllocator *)*MEMORY[0x189604DB0];
                                      dispatch_once( &HTTPMessage::Class(void)::sOnce_HTTPMessage,  &__block_literal_global_5084);
                                      uint64_t v102 = v107;
                                    }

                                    uint64_t v112 = v102;
                                    uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
                                    fHTTPRequest = (HTTPRequest *)Instance;
                                    if (Instance)
                                    {
                                      Instance[1] = 0u;
                                      fHTTPRequest = (HTTPRequest *)(Instance + 1);
                                      Instance[13] = 0u;
                                      Instance[14] = 0u;
                                      Instance[11] = 0u;
                                      Instance[12] = 0u;
                                      Instance[9] = 0u;
                                      Instance[10] = 0u;
                                      Instance[7] = 0u;
                                      Instance[8] = 0u;
                                      Instance[5] = 0u;
                                      Instance[6] = 0u;
                                      Instance[3] = 0u;
                                      Instance[4] = 0u;
                                      Instance[2] = 0u;
                                    }

                                    HTTPMethodMixedValue::HTTPMethodMixedValue((HTTPMethodMixedValue *)&valuePtr, v101);
                                    HTTPRequest::HTTPRequest(fHTTPRequest, (CFTypeRef *)&valuePtr, this->fURL);
                                    this->fHTTPRequest = fHTTPRequest;
                                    uint64_t valuePtr = (uint64_t)off_189C16E38;
                                    if (cf)
                                    {
                                      CFRelease(cf);
                                      fHTTPRequest = this->fHTTPRequest;
                                    }

                                    HTTPMessage::ensureParserFinished((HTTPMessage *)fHTTPRequest);
                                    (*(void (**)(HTTPRequest *, const void *))(*(void *)this->fHTTPRequest
                                                                                        + 64LL))( this->fHTTPRequest,  v99);
                                    if (v96)
                                    {
                                      HTTPRequest::setCookieStorage(this->fHTTPRequest, v96);
                                      CFRelease(v96);
                                    }

                                    if (v100) {
                                      HTTPMessage::setMultipleHeaderFields((HTTPMessage *)this->fHTTPRequest, v100);
                                    }
                                    if (a2 >= 7)
                                    {
                                      uint64_t v105 = (const __CFArray *)a3[v35 + 5];
                                      if (v105)
                                      {
                                        CFMutableArrayRef v106 = CFArrayCreateMutableCopy(v112, 0LL, v105);
                                        HTTPRequest::setBodyParts(this->fHTTPRequest, v106);
                                        if (v106) {
                                          CFRelease(v106);
                                        }
                                      }
                                    }
                                  }

                                  if (a5) {
                                    this->fProtocolProperties = CFDictionaryCreateMutableCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  a5);
                                  }
                                  return 1LL;
                                }

          *(void *)(v3 + 256) = 1LL;
          *(_DWORD *)(v3 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 12;
          return;
        }
      }

      else
      {
        CFRelease(v96);
      }

LABEL_196:
                                __int16 fFlags = *(_WORD *)&this->fFlags | 8;
                                goto LABEL_197;
                              }
                            }

                            CFRelease(theArray);
                          }
                        }
                      }
                    }
                  }
                }

                unint64_t v65 = (const __CFDictionary *)a3[8];
                if (v65) {
                  unint64_t v65 = (const __CFDictionary *)CFRetain(v65);
                }
                uint64_t v35 = v110;
              }

              char v82 = v111;
              this->fSSLProps = v65;
              goto LABEL_194;
            }

void sub_182A6EA1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef HTTPRequest::setCookieStorage(HTTPRequest *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 24);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    CFTypeRef result = CFRetain(cf);
    *((void *)this + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = result;
  }

  return result;
}

CFTypeRef HTTPRequest::setBodyParts(HTTPRequest *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 26);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0LL;
    }
    *((void *)this + 26) = result;
  }

  return result;
}

uint64_t ___ZN10URLRequest10initializeEPK14__CFDictionary_block_invoke( uint64_t a1, const __CFString *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(void *)(a1 + 32);
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  uint64_t result = [a3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)v11;
    do
    {
      uint64_t v9 = 0LL;
      do
      {
        if (*(void *)v11 != v8) {
          objc_enumerationMutation(a3);
        }
        HTTPMessage::addHeaderFieldStringValue( *(HTTPMessage **)(v5 + 56),  a2,  *(const __CFString **)(*((void *)&v10 + 1) + 8 * v9++));
      }

      while (v7 != v9);
      uint64_t result = [a3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      uint64_t v7 = result;
    }

    while (result);
  }

  return result;
}

CFStringRef CoreStreamBase::copyDebugDesc(CoreStreamBase *this)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  int v2 = CFGetAllocator((char *)this - 16);
  uint64_t v3 = (SES *)*((void *)this + 4);
  uint64_t v4 = (SES *)*((void *)this + 5);
  uint64_t v5 = *((void *)this + 12);
  strcpy(v12, "e:");
  uint64_t v7 = &v12[SES::pushEvent(v3, (unint64_t)&v12[2], (char *)&v13, v6) + 2];
  unint64_t v8 = (unint64_t)&v7[snprintf(v7, (char *)&v13 - v7, " p:")];
  unint64_t v10 = SES::pushEvent(v4, v8, (char *)&v13, v9);
  snprintf((char *)(v8 + v10), (size_t)&v13 - v8 - v10, " s:%c", aNoorwecx[v5]);
  return CFStringCreateWithFormat(v2, 0LL, @"CoreStreamBase<%s>(%p %s)", "", this, v12);
}

void CoreStreamBase::~CoreStreamBase(CoreStreamBase *this)
{
}

{
  uint64_t v2;
  uint64_t v3;
  *(void *)this = &off_189C070A8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C070F8;
  *((void *)this + 3) = 0LL;
  int v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 26);
  uint64_t v3 = *((void *)this + 14);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 48LL))(v3);
    *((void *)this + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)this + 26);
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C19AE8;
}

uint64_t CoreStreamBase::streamSetClient(uint64_t this, uint64_t a2, CoreStreamClient *a3)
{
  uint64_t v3 = *(void *)(this + 16);
  *(void *)(this + CFRelease((char *)this - 16) = a3;
  if (a3)
  {
    uint64_t v5 = this;
    this = (*(uint64_t (**)(CoreStreamClient *))(*(void *)a3 + 16LL))(a3);
    if (*(void *)(v5 + 32) != a2)
    {
      *(void *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = a2;
      ++*(void *)(v5 + 80);
      this = (*(uint64_t (**)(void, uint64_t))(**(void **)(v5 + 24) + 48LL))(*(void *)(v5 + 24), a2);
      --*(void *)(v5 + 80);
    }
  }

  if (v3) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  return this;
}

void non-virtual thunk to'CoreStreamBase::~CoreStreamBase(CoreStreamBase *this)
{
}

{
  void *v1;
  CoreStreamBase::~CoreStreamBase((CoreStreamBase *)((char *)this - 8));
  operator delete(v1);
}

void sub_182A6EE74(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

unint64_t SES::pushEvent(SES *this, unint64_t a2, char *a3, char *a4)
{
  unint64_t v5 = a2;
  if (a2 < (unint64_t)a3)
  {
    int v7 = (int)this;
    unint64_t v8 = 0LL;
    do
    {
      __darwin_ct_rune_t v9 = aOrwedm[v8];
      if (((1 << v8) & v7) == 0) {
        LOBYTE(v9) = __tolower(v9);
      }
      *(_BYTE *)(a2 + v_Block_object_dispose(va, 8) = v9;
      unint64_t v10 = a2 + v8 + 1;
      unint64_t v11 = v8 + 1;
      if (v8 > 4) {
        break;
      }
      ++v8;
    }

    while (v10 < (unint64_t)a3);
    unint64_t v5 = a2 + v11;
  }

  return v5 - a2;
}

uint64_t CoreStreamBase::copySchedulingSet(os_unfair_lock_s *this)
{
  int v2 = this + 26;
  os_unfair_lock_lock(this + 26);
  uint64_t Empty = *(void *)&this[28]._os_unfair_lock_opaque;
  if (!Empty)
  {
    uint64_t Empty = CoreSchedulingSet::createEmpty(v3);
    *(void *)&this[28]._os_unfair_lock_opaque = Empty;
  }

  (*(void (**)(uint64_t))(*(void *)Empty + 40LL))(Empty);
  os_unfair_lock_unlock(v2);
  return Empty;
}

void CoreStreamBase::setSchedulingSet(os_unfair_lock_s *this, const CoreSchedulingSet *a2)
{
  uint64_t v4 = this + 26;
  os_unfair_lock_lock(this + 26);
  uint64_t v5 = *(void *)&this[28]._os_unfair_lock_opaque;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 48LL))(v5);
    *(void *)&this[28]._os_unfair_lock_opaque = 0LL;
  }

  if (a2) {
    *(void *)&this[28]._os_unfair_lock_opaque = (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)a2 + 88LL))(a2);
  }
  os_unfair_lock_unlock(v4);
}

uint64_t CoreStreamBase::_streamInterface_Open(CoreStreamBase *this)
{
  uint64_t v1 = 0LL;
  char v8 = 0;
  if (!*((void *)this + 12))
  {
    ++*((void *)this + 10);
    *((void *)this + 12) = 1LL;
    __int128 v7 = 0uLL;
    uint64_t v3 = (*(uint64_t (**)(void, __int128 *, char *))(**((void **)this + 3) + 56LL))( *((void *)this + 3),  &v7,  &v8);
    uint64_t v1 = v3;
    if (DWORD2(v7))
    {
      *((void *)this + 12) = 7LL;
      *(_OWORD *)((char *)this + 56) = v7;
      *((void *)this + 5) |= 8uLL;
      uint64_t v4 = 8LL;
    }

    else
    {
      if ((_DWORD)v3) {
        BOOL v5 = v8 == 0;
      }
      else {
        BOOL v5 = 1;
      }
      if (v5) {
        goto LABEL_12;
      }
      if (*((void *)this + 12) == 1LL) {
        *((void *)this + 12) = 2LL;
      }
      uint64_t v4 = 1LL;
    }

    CoreStreamBase::_streamSetEventAndScheduleDelivery(this, v4, 0);
LABEL_12:
    --*((void *)this + 10);
  }

  return v1;
}

void CoreStreamBase::_streamSetEventAndScheduleDelivery(CoreStreamBase *this, uint64_t a2, int a3)
{
  uint64_t v6 = *((void *)this + 4);
  __int128 v7 = (os_unfair_lock_s *)((char *)this + 104);
  os_unfair_lock_lock((os_unfair_lock_t)this + 26);
  uint64_t v8 = *((void *)this + 14);
  os_unfair_lock_unlock(v7);
  if (v8)
  {
    uint64_t v9 = v6 & a2;
    uint64_t v10 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)this);
    unint64_t v11 = (_DWORD *)v10;
    *((void *)this + 5) |= v9;
    if (*((void *)this + 2) && *(_DWORD *)(v10 + 40))
    {
      if (!a3 || *((void *)this + 10)) {
        goto LABEL_6;
      }
      if (CoreSchedulingSet::currentlyInContext((CoreSchedulingSet *)v10))
      {
        uint64_t v13 = *((void *)this + 2);
        if (v13)
        {
          CFRetain((char *)this - 16);
          (*(void (**)(uint64_t))(*(void *)v13 + 16LL))(v13);
          ++*((void *)this + 10);
          uint64_t v14 = *((void *)this + 4) & *((void *)this + 5);
          *((void *)this + 5) = 0LL;
          (*(void (**)(uint64_t, uint64_t))(*(void *)v13 + 40LL))(v13, v14);
          --*((void *)this + 10);
          (*(void (**)(uint64_t))(*(void *)v13 + 24LL))(v13);
          CFRelease((char *)this - 16);
        }

        goto LABEL_8;
      }

      if (v11[10])
      {
LABEL_6:
        uint64_t v12 = *((void *)this + 2);
        if (v12)
        {
          CFRetain((char *)this - 16);
          (*(void (**)(uint64_t))(*(void *)v12 + 16LL))(v12);
          v15[0] = MEMORY[0x1895F87A8];
          v15[1] = 3221225472LL;
          v15[2] = ___ZN14CoreStreamBase34_streamSetEventAndScheduleDeliveryEmh_block_invoke;
          void v15[3] = &__block_descriptor_48_e5_v8__0l;
          v15[4] = this;
          void v15[5] = v12;
          (*(void (**)(_DWORD *, void *))(*(void *)v11 + 96LL))(v11, v15);
        }
      }
    }

void ___ZN14CoreStreamBase34_streamSetEventAndScheduleDeliveryEmh_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 72))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void *)(v2 + 80);
    *(void *)(v2 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = v4 + 1;
    if (v3)
    {
      uint64_t v5 = *(void *)(v2 + 32) & *(void *)(v2 + 40);
      *(void *)(v2 + 40) = 0LL;
      (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 40LL))(v3, v5);
      uint64_t v4 = *(void *)(v2 + 80) - 1LL;
    }

    *(void *)(v2 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = v4;
  }

  (*(void (**)(void))(**(void **)(a1 + 40) + 24LL))(*(void *)(a1 + 40));
  CFRelease((CFTypeRef)(v2 - 16));
}

void CoreStreamBase::_streamInterface_Close(CoreStreamBase *this)
{
  uint64_t v1 = *((void *)this + 12);
  if (v1) {
    BOOL v2 = v1 == 6;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2 && (v1 != 7 || !*((_BYTE *)this + 72)))
  {
    *((_BYTE *)this + 72) = 1;
    ++*((void *)this + 10);
    (*(void (**)(void))(**((void **)this + 3) + 72LL))(*((void *)this + 3));
    *((void *)this + 12) = 6LL;
    --*((void *)this + 10);
    CoreStreamBase::setSchedulingSet((os_unfair_lock_s *)this, 0LL);
  }

uint64_t CoreStreamBase::_streamInterface_Deprecated_Schedule( os_unfair_lock_s *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = CoreStreamBase::copySchedulingSet(this);
  __int128 v7 = (const CoreSchedulingSet *)(*(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *))(*(void *)v6 + 56LL))( v6,  a2,  a3);
  CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)this, v7);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v7 + 48LL))(v7);
}

void CoreStreamBase::_streamInterface_UpdateScheduling(CoreStreamBase *this, const CoreSchedulingSet *a2)
{
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  uint64_t v17 = 0LL;
  uint64_t v10 = 0LL;
  unint64_t v11 = &v10;
  uint64_t v12 = 0x2020000000LL;
  uint64_t v13 = 0LL;
  uint64_t v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  uint64_t v5 = MEMORY[0x1895F87A8];
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke;
  v9[3] = &unk_189C07110;
  void v9[6] = this;
  CFDictionaryRef v9[7] = a2;
  v9[4] = &v10;
  void v9[5] = &v14;
  ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke((uint64_t)v9);
  uint64_t v6 = v15[3];
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t, const CoreSchedulingSet *))(*(void *)v6 + 144LL))(v6, v11[3], a2);
    v8[0] = v5;
    v8[1] = 3221225472LL;
    _DWORD v8[2] = ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2;
    void v8[3] = &unk_189C19850;
    v8[4] = &v10;
    void v8[5] = this;
    ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2((uint64_t)v8);
  }

  uint64_t v7 = v11[3];
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 48LL))(v7);
  }
  CFRelease(v4);
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
}

void sub_182A6F4E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)v2);
  if ((*(unsigned int (**)(uint64_t, void))(*(void *)v3 + 24LL))(v3, *(void *)(a1 + 56)))
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 48LL))(v3);
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v3;
    CoreStreamBase::setSchedulingSet((os_unfair_lock_s *)v2, *(const CoreSchedulingSet **)(a1 + 56));
    ++*(void *)(v2 + 88);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = *(void *)(v2 + 24);
  }

uint64_t ___ZN14CoreStreamBase33_streamInterface_UpdateSchedulingEPK17CoreSchedulingSet_block_invoke_2( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  --*(void *)(v2 + 88);
  uint64_t v3 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)v2);
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (v5)
  {
    if (!*(_DWORD *)(v5 + 40))
    {
      if (*(_DWORD *)(v3 + 40))
      {
        uint64_t v6 = *(void *)(v2 + 40);
        if (v6) {
          CoreStreamBase::_streamSetEventAndScheduleDelivery((CoreStreamBase *)v2, v6, 0);
        }
      }
    }
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 48LL))(v4);
}

uint64_t CoreStreamBase::_streamInterface_Deprecated_Unschedule( os_unfair_lock_s *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = CoreStreamBase::copySchedulingSet(this);
  uint64_t v7 = (const CoreSchedulingSet *)(*(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *))(*(void *)v6 + 64LL))( v6,  a2,  a3);
  CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)this, v7);
  return (*(uint64_t (**)(const CoreSchedulingSet *))(*(void *)v7 + 48LL))(v7);
}

uint64_t CoreStreamBase::_streamInterface_GetStatus(CoreStreamBase *this)
{
  uint64_t result = *((void *)this + 12);
  if (result == 1)
  {
    ++*((void *)this + 10);
    __int128 v5 = 0uLL;
    int v3 = (*(uint64_t (**)(void, __int128 *))(**((void **)this + 3) + 64LL))(*((void *)this + 3), &v5);
    --*((void *)this + 10);
    if (DWORD2(v5))
    {
      *((void *)this + 12) = 7LL;
      *(_OWORD *)((char *)this + 56) = v5;
      *((void *)this + 5) |= 8uLL;
      uint64_t v4 = 8LL;
    }

    else
    {
      if (!v3 || *((void *)this + 12) != 1LL) {
        return *((void *)this + 12);
      }
      *((void *)this + 12) = 2LL;
      uint64_t v4 = 1LL;
    }

    CoreStreamBase::_streamSetEventAndScheduleDelivery(this, v4, 0);
    return *((void *)this + 12);
  }

  return result;
}

void CoreStreamBase::_signalEvent(CoreStreamBase *this, uint64_t a2, CFStreamError a3, int a4)
{
  uint64_t v5 = *(void *)&a3.error;
  CFIndex domain = a3.domain;
  uint64_t v8 = *((void *)this + 12);
  uint64_t v9 = 0LL;
  switch(v8)
  {
    case 0LL:
    case 6LL:
    case 7LL:
      goto LABEL_21;
    case 1LL:
      if ((a2 & 1) != 0) {
        *((void *)this + 12) = 2LL;
      }
      BOOL v10 = 1;
      if ((a2 & 0x10) != 0) {
        goto LABEL_7;
      }
      goto LABEL_9;
    case 5LL:
      uint64_t v9 = a2 & 8;
      if ((a2 & 8) != 0) {
        goto LABEL_12;
      }
      goto LABEL_21;
    default:
      a2 &= ~1uLL;
      BOOL v10 = v8 < 5;
      if ((a2 & 0x10) != 0)
      {
LABEL_7:
        if (v10) {
          *((void *)this + 12) = 5LL;
        }
      }

uint64_t CoreStreamBase::_streamInterface_Read(CoreStreamBase *this, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6 = *((void *)this + 12);
  if (v6 == 1)
  {
    CoreStreamBase::blockingWaitForOpen(this);
    uint64_t v6 = *((void *)this + 12);
  }

  if ((unint64_t)(v6 - 2) >= 2)
  {
    if (v6 == 5) {
      return 0LL;
    }
    else {
      return -1LL;
    }
  }

  else
  {
    ++*((void *)this + 10);
    *((void *)this + 5) &= ~2uLL;
    *((void *)this + 12) = 3LL;
    __int128 v12 = 0uLL;
    char v11 = 0;
    uint64_t v7 = (*(uint64_t (**)(void, unsigned __int8 *, uint64_t, __int128 *, char *))(**((void **)this + 3)
                                                                                           + 80LL))( *((void *)this + 3),  a2,  a3,  &v12,  &v11);
    if (DWORD2(v12))
    {
      if (*((uint64_t *)this + 12) <= 5)
      {
        *(_OWORD *)((char *)this + 56) = v12;
        *((void *)this + 12) = 7LL;
        *((void *)this + 5) |= 8uLL;
        CoreStreamBase::_streamSetEventAndScheduleDelivery(this, 8LL, 0);
      }

      uint64_t v8 = -1LL;
    }

    else
    {
      uint64_t v8 = v7;
      uint64_t v10 = *((void *)this + 12);
      if (v11)
      {
        if (v10 <= 4)
        {
          *((void *)this + 12) = 5LL;
          *((void *)this + 5) |= 0x10uLL;
          CoreStreamBase::_streamSetEventAndScheduleDelivery(this, 16LL, 0);
        }
      }

      else if (v10 == 3)
      {
        *((void *)this + 12) = 2LL;
      }
    }

    --*((void *)this + 10);
  }

  return v8;
}

void CoreStreamBase::blockingWaitForOpen(CoreStreamBase *this)
{
  uint64_t v2 = (char *)this - 16;
  CFRetain((char *)this - 16);
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  uint64_t v15 = 0LL;
  ++*((void *)this + 11);
  uint64_t v3 = CoreStreamBase::copySchedulingSet((os_unfair_lock_s *)this);
  v13[3] = v3;
  double Current = (CoreSchedulingSet *)CFRunLoopGetCurrent();
  uint64_t v6 = (const CoreSchedulingSet *)CoreSchedulingSet::create(Current, @"CoreStreamOpenBlocking", v5);
  CoreStreamBase::_streamInterface_UpdateScheduling(this, v6);
  (*(void (**)(const CoreSchedulingSet *))(*(void *)v6 + 48LL))(v6);
  uint64_t v7 = CFGetAllocator(v2);
  CFAbsoluteTime v8 = CFAbsoluteTimeGetCurrent();
  uint64_t v9 = CFRunLoopTimerCreateWithHandler(v7, v8 + 1.0e30, 0.0, 0LL, 0LL, &__block_literal_global_3966);
  uint64_t v10 = CFRunLoopGetCurrent();
  CFRunLoopAddTimer(v10, v9, @"CoreStreamOpenBlocking");
  while (CoreStreamBase::_streamInterface_GetStatus(this) <= 1)
    CFRunLoopRunInMode(@"CoreStreamOpenBlocking", 1.0e30, 1u);
  CoreStreamBase::_streamInterface_UpdateScheduling(this, (const CoreSchedulingSet *)v13[3]);
  (*(void (**)(uint64_t))(*(void *)v13[3] + 48LL))(v13[3]);
  CFRunLoopTimerInvalidate(v9);
  CFRunLoopRunInMode(@"CoreStreamOpenBlocking", 1.0e30, 0);
  char v11 = CFRunLoopGetCurrent();
  CFRunLoopRemoveTimer(v11, v9, @"CoreStreamOpenBlocking");
  if (v9) {
    CFRelease(v9);
  }
  --*((void *)this + 11);
  CFRelease(v2);
  _Block_object_dispose(&v12, 8);
}

void sub_182A6FB9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CoreStreamBase::_streamInterface_CanRead(CoreStreamBase *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 3) + 88LL))(*((void *)this + 3));
  --*((void *)this + 10);
  return result;
}

uint64_t CoreStreamBase::_streamInterface_Write(CoreStreamBase *this, const unsigned __int8 *a2, uint64_t a3)
{
  if (CoreStreamBase::_streamInterface_GetStatus(this) == 1) {
    CoreStreamBase::blockingWaitForOpen(this);
  }
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (Status != 4 && Status != 2) {
    return -1LL;
  }
  ++*((void *)this + 10);
  *((void *)this + 12) = 4LL;
  uint64_t v7 = *((void *)this + 5);
  if (v7) {
    *((void *)this + 5) = v7 & 0xFFFFFFFFFFFFFFFBLL;
  }
  __int128 v13 = 0uLL;
  uint64_t v8 = (*(uint64_t (**)(void, const unsigned __int8 *, uint64_t, __int128 *))(**((void **)this + 3) + 96LL))( *((void *)this + 3),  a2,  a3,  &v13);
  uint64_t v9 = v8;
  if (DWORD2(v13))
  {
    *((void *)this + 12) = 7LL;
    *(_OWORD *)((char *)this + 56) = v13;
    *((void *)this + 5) |= 8uLL;
    uint64_t v10 = this;
    uint64_t v11 = 8LL;
  }

  else
  {
    if (v8)
    {
      if (*((void *)this + 12) == 4LL) {
        *((void *)this + 12) = 2LL;
      }
      goto LABEL_10;
    }

    *((void *)this + 12) = 5LL;
    *((void *)this + 5) |= 0x10uLL;
    uint64_t v10 = this;
    uint64_t v11 = 16LL;
  }

  CoreStreamBase::_streamSetEventAndScheduleDelivery(v10, v11, 0);
LABEL_10:
  --*((void *)this + 10);
  return v9;
}

uint64_t CoreStreamBase::_streamInterface_CanWrite(CoreStreamBase *this)
{
  uint64_t Status = CoreStreamBase::_streamInterface_GetStatus(this);
  if (Status != 4 && Status != 2) {
    return 0LL;
  }
  ++*((void *)this + 10);
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 3) + 104LL))(*((void *)this + 3));
  --*((void *)this + 10);
  return result;
}

_CFURLRequest *createCFRequest(const InternalInit *a1)
{
  uint64_t v2 = (_CFURLRequest *)[a1->var1 mutableCopy];
  if (v2)
  {
    uint64_t v3 = objc_msgSend((id)objc_msgSend(a1->var1, "URL"), "host");
    if (v3)
    {
      uint64_t v4 = v3;
      id v5 = +[NSURLRequest allowsSpecificHTTPSCertificateForHost:]( &OBJC_CLASS___NSURLRequest,  "allowsSpecificHTTPSCertificateForHost:",  v3);
      if (v5) {
        setSSLProp(v2, @"_kCFStreamSSLTrustedLeafCertificates", v5);
      }
      if (+[NSURLRequest allowsAnyHTTPSCertificateForHost:]( &OBJC_CLASS___NSURLRequest,  "allowsAnyHTTPSCertificateForHost:",  v4))
      {
        setSSLProp(v2, (const __CFString *)&unk_18C5AE550, (const void *)*MEMORY[0x189604DE0]);
      }
    }

    int v6 = [a1->var1 HTTPShouldHandleCookies];
    uint64_t v7 = -[_CFURLRequest _inner](v2, "_inner");
    __int16 v8 = *(_WORD *)(v7 + 64);
    __int16 v9 = v8 | 0x21;
    __int16 v10 = v8 & 0xFFDE | 0x20;
    if (v6) {
      __int16 v10 = v9;
    }
    *(_WORD *)(v7 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v10;
  }

  return v2;
}

__CFError *cfnTranslateCFError(__CFError *a1, void *a2)
{
  uint64_t v3 = a1;
  v31[15] = *MEMORY[0x1895F89C0];
  CFIndex Code = CFErrorGetCode(a1);
  CFErrorDomain Domain = CFErrorGetDomain(v3);
  if (!CFEqual(Domain, @"kCFErrorDomainCFNetwork") || Code > -998 || Code < -3999) {
    return v3;
  }
  int v6 = CFErrorCopyUserInfo(v3);
  if (a2)
  {
    v31[0] = *MEMORY[0x189607748];
    v30[0] = a2;
    if ([a2 absoluteString])
    {
      v31[1] = *MEMORY[0x189607758];
      v30[1] = [a2 absoluteString];
      uint64_t v7 = 2LL;
    }

    else
    {
      uint64_t v7 = 1LL;
    }

    __int16 v8 = CFURLCopyHostName((CFURLRef)a2);
  }

  else
  {
    uint64_t v7 = 0LL;
    __int16 v8 = 0LL;
  }

  int Value = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x189604F68]);
  if (!Value || (__int16 v10 = CFRetain(Value)) == 0LL) {
    __int16 v10 = _CFNetworkErrorCopyLocalizedDescriptionWithHostname(Code, v8);
  }
  v30[v7] = v10;
  if (v8) {
    CFRelease(v8);
  }
  if (v10) {
    v31[v7++] = *MEMORY[0x1896075E0];
  }
  uint64_t v11 = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x189604F70]);
  if (v11)
  {
    v30[v7] = v11;
  }

  else
  {
    LocalizedString = _CFNetworkErrorGetLocalizedString(Code, 2LL);
    v30[v7] = LocalizedString;
    if (!LocalizedString) {
      goto LABEL_21;
    }
  }

  v31[v7++] = *MEMORY[0x1896075F0];
LABEL_21:
  __int128 v13 = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x189604F78]);
  if (v13)
  {
    v30[v7] = v13;
LABEL_24:
    v31[v7++] = *MEMORY[0x189607618];
    goto LABEL_25;
  }

  uint64_t v14 = _CFNetworkErrorGetLocalizedString(Code, 3LL);
  v30[v7] = v14;
  if (v14) {
    goto LABEL_24;
  }
LABEL_25:
  if (v6)
  {
    uint64_t v15 = CFDictionaryGetValue(v6, @"kCFStreamPropertySSLPeerCertificates");
    v30[v7] = v15;
    if (v15)
    {
      v31[v7] = @"NSErrorPeerCertificateChainKey";
      uint64_t v16 = CFDictionaryGetValue(v6, &unk_18C5ACAD8);
      uint64_t v17 = v7 + 1;
      v30[v7 + 1] = v16;
      if (v16)
      {
        v31[v17] = @"NSErrorClientCertificateChainKey";
        uint64_t v17 = v7 + 2;
      }

      CFTypeID v18 = CFDictionaryGetValue(v6, &unk_18C5ACB10);
      v30[v17] = v18;
      if (v18)
      {
        v31[v17] = @"NSErrorClientCertificateStateKey";
        uint64_t v7 = v17 + 1;
      }

      else
      {
        uint64_t v7 = v17;
      }
    }

    CFTypeID v19 = CFDictionaryGetValue(v6, &unk_18C5AE010);
    v30[v7] = v19;
    if (v19) {
      v31[v7++] = *MEMORY[0x189607750];
    }
    CFTypeID v20 = CFDictionaryGetValue(v6, @"_kCFStreamErrorDomainKey");
    v30[v7] = v20;
    if (v20) {
      v31[v7++] = @"_kCFStreamErrorDomainKey";
    }
    CFTypeID v21 = CFDictionaryGetValue(v6, @"_kCFStreamErrorCodeKey");
    v30[v7] = v21;
    if (v21) {
      v31[v7++] = @"_kCFStreamErrorCodeKey";
    }
    CFTypeID v22 = CFDictionaryGetValue(v6, @"_kCFNetworkErrorConditionalRequestKey");
    v30[v7] = v22;
    if (v22) {
      v31[v7++] = @"_kCFNetworkErrorConditionalRequestKey";
    }
    CFTypeID v23 = CFDictionaryGetValue(v6, @"_kCFNetworkErrorCachedResponseKey");
    v30[v7] = v23;
    if (v23) {
      v31[v7++] = @"_kCFNetworkErrorCachedResponseKey";
    }
    uint64_t v24 = *MEMORY[0x189607768];
    int v25 = CFDictionaryGetValue(v6, (const void *)*MEMORY[0x189607768]);
    v30[v7] = v25;
    if (v25) {
      v31[v7++] = v24;
    }
  }

  v31[v7] = *MEMORY[0x189607798];
  v30[v7] = v3;
  int v26 = (void *)MEMORY[0x189607A70];
  uint64_t v27 = [MEMORY[0x189603F68] dictionaryWithObjects:v30 forKeys:v31 count:v7 + 1];
  if (Code == -998) {
    uint64_t v28 = -1LL;
  }
  else {
    uint64_t v28 = Code;
  }
  uint64_t v3 = (__CFError *)[v26 errorWithDomain:*MEMORY[0x189607740] code:v28 userInfo:v27];
  if (v6) {
    CFRelease(v6);
  }
  if (v10) {
    CFRelease(v10);
  }
  return v3;
}

void sub_182A70B04(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void setSSLProp(_CFURLRequest *a1, const __CFString *a2, const void *a3)
{
  int v6 = *(const __CFDictionary **)(-[_CFURLRequest _inner](a1, "_inner") + 72);
  if (v6) {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v6);
  }
  else {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(0LL, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  }
  __int16 v8 = MutableCopy;
  CFDictionarySetValue(MutableCopy, a2, a3);
  CFURLRequestSetSSLProperties(a1, v8);
  CFRelease(v8);
}

CFStringRef URLResponse::copyDebugDesc(URLResponse *this)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<URLResponse %p { url = %@ }",  this,  this->fURL);
}

CFStringRef URLResponse::copyDebugSummary(URLResponse *this)
{
  if (__CFNCanLogSensitiveContent::onceToken != -1) {
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4760);
  }
  if (__CFNCanLogSensitiveContent::ok) {
    uint64_t v2 = -[__CFURL absoluteString](this->fURL, "absoluteString");
  }
  else {
    uint64_t v2 = [NSString stringWithFormat:@"%@://%@/<redacted>", -[__CFURL scheme](this->fURL, "scheme"), -[__CFURL host](this->fURL, "host")];
  }
  uint64_t v3 = v2;
  fHTTP = this->fHTTP;
  if (!fHTTP) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"response from %@", v3);
  }
  id v5 = (const void *)(*(uint64_t (**)(HTTPResponse *))(*(void *)fHTTP + 32LL))(fHTTP);
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"response from %@, %@", v3, v5);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

void *URLResponse::initialize( uint64_t a1, CFTypeRef cf, const __CFString *a3, uint64_t a4, const __CFString *a5, int a6)
{
  uint64_t v11 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (cf) {
    uint64_t result = (void *)CFRetain(cf);
  }
  else {
    uint64_t result = 0LL;
  }
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = result;
  if (a3)
  {
    uint64_t result = (void *)CFStringCreateCopy(v11, a3);
    *(void *)(a1 + CFRelease((char *)this - 16) = result;
  }

  if (a5)
  {
    uint64_t result = (void *)CFStringCreateCopy(v11, a5);
    *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = result;
  }

  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = a4;
  *(_DWORD *)(a1 + 72) = a6;
  return result;
}

double URLResponse::getCreationTime(URLResponse *this)
{
  fHTTP = this->fHTTP;
  if (!fHTTP) {
    goto LABEL_10;
  }
  if ((*(_WORD *)((char *)fHTTP + 297) & 0x10) == 0)
  {
    uint64_t v3 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)fHTTP, 0x123092F7u);
    uint64_t v4 = this->fHTTP;
    int v5 = *(unsigned __int16 *)((char *)v4 + 297);
    unsigned int v6 = v5 & 0xFFFFFFF7 | (*((unsigned __int8 *)v4 + 299) << 16);
    *(_WORD *)((char *)v4 + 297) = v5 & 0xFFF7;
    *((_BYTE *)v4 + 299) = BYTE2(v6);
    *(_WORD *)((char *)this->fHTTP + 297) |= 0x10u;
    fHTTP = this->fHTTP;
    if (v3)
    {
      uint64_t v7 = v3;
      *((double *)fHTTP + 4__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = dateFromString(v3, &v10);
      if (v10) {
        *(_WORD *)((char *)this->fHTTP + 297) |= 8u;
      }
      CFRelease(v7);
      fHTTP = this->fHTTP;
    }
  }

  else {
LABEL_10:
  }
    p_fdouble CreationTime = &this->fCreationTime;
  return *p_fCreationTime;
}

double dateFromString(CFStringRef theString, unsigned __int8 *a2)
{
  uint64_t v3 = _CFGregorianDateCreateWithString(0LL, theString, (uint64_t)&v7, (CFTypeRef *)&tz);
  if (a2) {
    *a2 = 0;
  }
  if (v3 < 1)
  {
    double AbsoluteTime = 0.0;
  }

  else
  {
    double AbsoluteTime = CFGregorianDateGetAbsoluteTime(v7, tz);
    if (a2) {
      *a2 = 1;
    }
  }

  if (tz) {
    CFRelease(tz);
  }
  return AbsoluteTime;
}

void URLResponse::freshnessLifetimeForResponse(URLResponse *this)
{
  fHTTP = this->fHTTP;
  int v2 = *(unsigned __int16 *)((char *)fHTTP + 297);
  int v3 = v2 | (*((unsigned __int8 *)fHTTP + 299) << 16);
  if ((v2 & 0x800) == 0)
  {
    *((_BYTE *)fHTTP + 299) = BYTE2(v3);
    *(_WORD *)((char *)fHTTP + 297) = v3 | 0x800;
    int v5 = this->fHTTP;
    __int16 v6 = *(_WORD *)((char *)v5 + 297);
    if ((v6 & 0x80) == 0)
    {
      URLResponse::parseCacheControl(this);
      int v5 = this->fHTTP;
      LOBYTE(v6) = *((_BYTE *)v5 + 297);
    }

    if ((v6 & 1) != 0)
    {
      double v8 = 0.0;
    }

    else
    {
      uint64_t v7 = *((void *)v5 + 42);
      if (v7 == -1)
      {
        if ((v6 & 0x20) == 0)
        {
          __int16 v9 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)v5, 0x1280F30Au);
          *(_WORD *)((char *)this->fHTTP + 297) |= 0x20u;
          unsigned __int8 v10 = this->fHTTP;
          int v11 = *(unsigned __int16 *)((char *)v10 + 297);
          unsigned int v12 = v11 & 0xFFFFFFFD | (*((unsigned __int8 *)v10 + 299) << 16);
          *(_WORD *)((char *)v10 + 297) = v11 & 0xFFFD;
          *((_BYTE *)v10 + 299) = BYTE2(v12);
          int v5 = this->fHTTP;
          if (v9)
          {
            __int128 v13 = v9;
            *((double *)v5 + 39) = dateFromString(v9, &v16);
            if (v16) {
              *(_WORD *)((char *)this->fHTTP + 297) |= 2u;
            }
            CFRelease(v13);
            int v5 = this->fHTTP;
          }
        }

        if ((*(_WORD *)((char *)v5 + 297) & 2) != 0)
        {
          double CreationTime = URLResponse::getCreationTime(this);
          int v5 = this->fHTTP;
          double v8 = *((double *)v5 + 39) - CreationTime;
        }

        else
        {
          double LastModifiedDate = URLResponse::getLastModifiedDate(this);
          int v5 = this->fHTTP;
          double v8 = 0.0;
          if ((*(_WORD *)((char *)v5 + 297) & 4) != 0)
          {
            double v8 = (URLResponse::getCreationTime(this) - LastModifiedDate) * 0.1;
            int v5 = this->fHTTP;
          }
        }
      }

      else
      {
        double v8 = (double)v7;
      }
    }

    if (v8 < 1.0) {
      double v8 = 0.0;
    }
    *((double *)v5 + 40) = v8;
  }

uint64_t URLResponse::initialize(URLResponse *this, uint64_t a2, const void **a3, uint64_t a4)
{
  if (a2)
  {
    if (a2 != 1 || (a4 & 0xFFFFFFFFFFFFFFFDLL) != 5) {
      return 0LL;
    }
  }

  else if (a4 != 7)
  {
    return 0LL;
  }

  if (*a3)
  {
    CFTypeID v8 = CFGetTypeID(*a3);
    if (v8 != CFURLGetTypeID()) {
      return 0LL;
    }
  }

  uint64_t result = (uint64_t)a3[1];
  if (!result) {
    return result;
  }
  CFTypeID v10 = CFGetTypeID((CFTypeRef)result);
  if (v10 != CFNumberGetTypeID()) {
    return 0LL;
  }
  uint64_t result = (uint64_t)a3[2];
  if (!result) {
    return result;
  }
  CFTypeID v11 = CFGetTypeID((CFTypeRef)result);
  if (v11 != CFNumberGetTypeID()) {
    return 0LL;
  }
  uint64_t result = (uint64_t)a3[3];
  if (a2 != 1)
  {
    if (result)
    {
      CFTypeID v20 = CFGetTypeID((CFTypeRef)result);
      if (v20 != CFStringGetTypeID()) {
        return 0LL;
      }
    }

    CFTypeID v21 = a3[4];
    if (v21)
    {
      CFTypeID v22 = CFGetTypeID(v21);
      if (v22 != CFStringGetTypeID()) {
        return 0LL;
      }
    }

    uint64_t result = (uint64_t)a3[5];
    if (!result) {
      return result;
    }
    CFTypeID v23 = CFGetTypeID((CFTypeRef)result);
    if (v23 != CFNumberGetTypeID()) {
      return 0LL;
    }
    uint64_t result = (uint64_t)a3[6];
    if (!result) {
      return result;
    }
    CFTypeID v18 = CFGetTypeID((CFTypeRef)result);
    CFTypeID TypeID = CFNumberGetTypeID();
LABEL_31:
    if (v18 == TypeID) {
      goto LABEL_32;
    }
    return 0LL;
  }

  if (!result) {
    return result;
  }
  CFTypeID v12 = CFGetTypeID((CFTypeRef)result);
  if (v12 != CFNumberGetTypeID()) {
    return 0LL;
  }
  __int128 v13 = a3[4];
  if (v13)
  {
    CFTypeID v14 = CFGetTypeID(v13);
    if (v14 != CFDictionaryGetTypeID()) {
      return 0LL;
    }
  }

  if (a4 == 7)
  {
    uint64_t v15 = a3[5];
    if (v15)
    {
      CFTypeID v16 = CFGetTypeID(v15);
      if (v16 != CFNumberGetTypeID()) {
        return 0LL;
      }
    }

    uint64_t v17 = a3[6];
    if (!v17 || CFEqual(v17, (CFTypeRef)*MEMORY[0x189604DE0])) {
      goto LABEL_32;
    }
    CFTypeID v18 = CFGetTypeID(a3[6]);
    CFTypeID TypeID = CFStringGetTypeID();
    goto LABEL_31;
  }

const __CFString *URLResponse::copySuggestedFilename(URLResponse *this)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  fHTTP = this->fHTTP;
  if (fHTTP)
  {
    HeaderFieldint Value = HTTPMessage::copyLastHeaderFieldValue((HTTPMessage *)fHTTP, 0x11C272BFu);
    if (HeaderFieldValue)
    {
      uint64_t v4 = HeaderFieldValue;
      FilenameFromContentDispositionHeader = createFilenameFromContentDispositionHeader(HeaderFieldValue);
      CFRelease(v4);
      if (FilenameFromContentDispositionHeader) {
        goto LABEL_29;
      }
    }
  }

  CFHashCode fURL = this->fURL;
  if (!fURL)
  {
LABEL_28:
    FilenameFromContentDispositionHeader = (const __CFString *)CFRetain(@"Unknown");
    goto LABEL_29;
  }

  fMIMEType = this->fMIMEType;
  SemiColonEscapedURLIfParamterIsPresent = cfnCreateSemiColonEscapedURLIfParamterIsPresent(this->fURL);
  if (SemiColonEscapedURLIfParamterIsPresent)
  {
    __int16 v9 = SemiColonEscapedURLIfParamterIsPresent;
    CFStringRef PathComponent = CFURLCopyLastPathComponent(SemiColonEscapedURLIfParamterIsPresent);
    CFRelease(v9);
    if (!PathComponent) {
      goto LABEL_12;
    }
  }

  else
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(fURL);
    if (!PathComponent) {
      goto LABEL_12;
    }
  }

  if (CFStringGetLength(PathComponent) && !CFEqual(PathComponent, @"/")) {
    goto LABEL_17;
  }
  CFRelease(PathComponent);
LABEL_12:
  CFTypeID v11 = CFURLCopyHostName(fURL);
  if (!v11) {
    goto LABEL_28;
  }
  CFStringRef PathComponent = v11;
  if (CFStringCompare(v11, @"localhost", 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(PathComponent);
    goto LABEL_28;
  }

  if (fMIMEType)
  {
    CFTypeID v12 = copyPreferredExtensionForMIMEType(fMIMEType);
    if (v12)
    {
      __int128 v13 = v12;
      CFTypeID v14 = CFGetAllocator(fURL);
      CFStringRef v15 = CFStringCreateWithFormat(v14, 0LL, @"%@.%@", PathComponent, v13);
      CFRelease(PathComponent);
      CFRelease(v13);
      CFStringRef PathComponent = v15;
      if (!v15) {
        goto LABEL_28;
      }
    }
  }

CFStringRef copyExtensionFromName(const __CFString *a1)
{
  v10.CFIndex length = CFStringGetLength(a1);
  v10.CFIndex location = 0LL;
  if (!CFStringFindWithOptions(a1, @".", v10, 4uLL, &v9)) {
    return 0LL;
  }
  CFIndex location = v9.location;
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v4 = Length + ~v9.location;
  if (v4 < 1) {
    return 0LL;
  }
  CFIndex v5 = location + 1;
  v11.CFIndex location = v5;
  v11.CFIndex length = Length + ~v9.location;
  int v6 = CFStringFindWithOptions(a1, @" ", v11, 0LL, 0LL);
  CFStringRef result = 0LL;
  if (!v6)
  {
    CFTypeID v8 = CFGetAllocator(a1);
    v12.CFIndex location = v5;
    v12.CFIndex length = v4;
    return CFStringCreateWithSubstring(v8, a1, v12);
  }

  return result;
}

CFTypeRef copyMIMETypeForUnknown(const __CFData *a1)
{
  if (a1)
  {
    MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sScriptableTypeRules, 1);
    if (!MIMETypeForRuleArray)
    {
      MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sNonScriptableTypeRules, 1);
      if (!MIMETypeForRuleArray)
      {
        MIMETypeForRuleArray = getMIMETypeForRuleArray(a1, sImageTypeRules, 1);
        if (!MIMETypeForRuleArray)
        {
          MIMETypeForRuleArray = (const __CFData *)getMIMETypeForComplexNonScriptableTypeRules(a1);
          if (!MIMETypeForRuleArray)
          {
            else {
              MIMETypeForRuleArray = 0LL;
            }
          }
        }
      }
    }

    if (!MIMETypeForRuleArray) {
      MIMETypeForRuleArray = (const __CFData *)&unk_18C5B1928;
    }
  }

  else
  {
    MIMETypeForRuleArray = (const __CFData *)&unk_18C5B2178;
  }

  return CFRetain(MIMETypeForRuleArray);
}

uint64_t isAllText(const __CFData *a1)
{
  CFIndex Length = CFDataGetLength(a1);
  if (Length < 1) {
    return 1LL;
  }
  if (Length >= 512) {
    uint64_t v3 = 512LL;
  }
  else {
    uint64_t v3 = Length;
  }
  BytePtr = CFDataGetBytePtr(a1);
  unint64_t v5 = (unint64_t)&BytePtr[v3 - 1];
  while (1)
  {
    unsigned int v6 = *BytePtr;
    BOOL v7 = (v6 & 0xFC) != 0x1C && v6 >= 9;
    BOOL v8 = !v7 || v6 == 11;
    if (v8 || v6 - 14 <= 0xC) {
      break;
    }
  }

  return 0LL;
}

CFDataRef getMIMETypeForRuleArray(const __CFData *result, void *a2, int a3)
{
  if (result)
  {
    unint64_t v5 = result;
    CFIndex Length = CFDataGetLength(result);
    uint64_t v25 = Length;
    if (Length >= 512) {
      uint64_t v7 = 512LL;
    }
    else {
      uint64_t v7 = Length;
    }
    BOOL v8 = a2 + 1;
    if (!a2[1]) {
      return 0LL;
    }
    uint64_t v9 = 0LL;
    uint64_t v24 = 0LL;
    CFRange v10 = 0LL;
    int v26 = 0;
    if (v7 <= 1) {
      uint64_t v11 = 1LL;
    }
    else {
      uint64_t v11 = v7;
    }
    CFRange v12 = a2;
    while (1)
    {
      __int128 v13 = &a2[4 * v9];
      uint64_t v15 = v13[2];
      CFTypeID v14 = v13 + 2;
      if (v7 >= v15)
      {
        BytePtr = CFDataGetBytePtr(v5);
        int v17 = *(unsigned __int8 *)*v8;
        if (v17 == 60)
        {
          if (v26)
          {
            if (!v10) {
              goto LABEL_35;
            }
          }

          else
          {
            if (v25 < 1) {
              goto LABEL_34;
            }
            uint64_t v22 = 0LL;
            while (1)
            {
              CFRange v10 = &BytePtr[v22];
              if (v11 == ++v22) {
                goto LABEL_34;
              }
            }

            if (BytePtr[v22] != 60)
            {
LABEL_34:
              CFRange v10 = 0LL;
LABEL_35:
              int v26 = 1;
              goto LABEL_41;
            }

            uint64_t v24 = v7 - v22;
          }

          uint64_t v18 = *v14;
          int v26 = 1;
          BytePtr = v10;
          if (v24 < *v14) {
            goto LABEL_41;
          }
        }

        else
        {
          uint64_t v18 = *v14;
        }

        uint64_t v19 = 0LL;
        if (v18 >= 1)
        {
          while (1)
          {
            if (a3)
            {
              int v20 = BytePtr[v19];
              if (*v12) {
                int v20 = (*(_BYTE *)(*v12 + v19) & v20);
              }
            }

            else
            {
              int v20 = BytePtr[v19];
            }

            int v21 = *(unsigned __int8 *)(*v8 + v19);
            if (v17 == 60 && v20 != v21) {
              break;
            }
            if (v20 != v21) {
              goto LABEL_40;
            }
            if (v18 == ++v19) {
              return (const __CFData *)&gConstantCFStringValueTable[7 * ((LODWORD(a2[4 * v9 + 3]) >> 20) & 0x3FF)];
            }
          }

          if (v18 - 1 == v19 && v21 == 32 && (v20 == 32 || v20 == 62)) {
            return (const __CFData *)&gConstantCFStringValueTable[7 * ((LODWORD(a2[4 * v9 + 3]) >> 20) & 0x3FF)];
          }
        }

uint64_t getMIMETypeForComplexNonScriptableTypeRules(const __CFData *a1)
{
  CFIndex Length = CFDataGetLength(a1);
  if (Length >= 512) {
    uint64_t v3 = 512LL;
  }
  else {
    uint64_t v3 = Length;
  }
  BytePtr = CFDataGetBytePtr(a1);
  if (v3 < 4) {
    goto LABEL_56;
  }
  if (*(_WORD *)BytePtr == 17481 && BytePtr[2] == 51)
  {
    else {
      uint64_t v6 = 0x18C5B1D88LL;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  BOOL v7 = (unint64_t)v3 > 7;
  if (!v6 && (unint64_t)v3 >= 8)
  {
    if (*((_DWORD *)BytePtr + 1) == 1987014509
      || *((_DWORD *)BytePtr + 1) == 1952539757
      || *((_DWORD *)BytePtr + 1) == 1701079415)
    {
      uint64_t v6 = 0x18C5B23E0LL;
    }

    else
    {
      uint64_t v6 = 0LL;
    }
  }

  BOOL v8 = (unint64_t)v3 > 0xB;
  if (!v6 && (unint64_t)v3 >= 0xC)
  {
    if (*BytePtr || BytePtr[1] || *((_DWORD *)BytePtr + 1) != 1887007846) {
      goto LABEL_25;
    }
    if (*((_WORD *)BytePtr + 4) == 28781 && BytePtr[10] == 52)
    {
      else {
        uint64_t v6 = 0x18C5B23A8LL;
      }
      goto LABEL_26;
    }

    if (*((_WORD *)BytePtr + 4) == 29545 && BytePtr[10] == 111)
    {
      int v16 = BytePtr[11];
      if (v16 == 109 || v16 == 50)
      {
        uint64_t v15 = &kCFMIMETypeVideoMP4;
        goto LABEL_118;
      }

void sub_182A72E2C(_Unwind_Exception *a1)
{
}

void sub_182A72EE8(_Unwind_Exception *a1)
{
}

void sub_182A72FA8(_Unwind_Exception *a1)
{
}

void sub_182A73068(_Unwind_Exception *a1)
{
}

void sub_182A74DE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

void __Block_byref_object_copy__4352(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__4353(uint64_t a1)
{
}

void sub_182A78684(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_182A79004( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

LABEL_119:
        unint64_t v95 = 0LL;
        goto LABEL_90;
      }

      uint64_t v103 = [*((id *)v8 + 14) _isProxySession];
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      unint64_t v104 = (os_log_s *)CFNLog::logger;
      uint64_t v105 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
      if (v103)
      {
        if (v105)
        {
          CFMutableArrayRef v106 = *((void *)v8 + 16);
          LODWORD(v127) = 138543362;
          *(void *)((char *)&v127 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v106;
          uint64_t v107 = "ProxySession <%{public}@> failed to create a background AVAggregateAssetDownloadTask, as the URLAsset P"
                 "ropertyList could not be serialized.";
          goto LABEL_116;
        }
      }

      else if (v105)
      {
        char v111 = *((void *)v8 + 16);
        LODWORD(v127) = 138543362;
        *(void *)((char *)&v127 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v111;
        uint64_t v107 = "BackgroundSession <%{public}@> failed to create a background AVAggregateAssetDownloadTask, as the URLAsse"
               "t PropertyList could not be serialized.";
LABEL_116:
        _os_log_error_impl(&dword_18298D000, v104, OS_LOG_TYPE_ERROR, v107, (uint8_t *)&v127, 0xCu);
        if (!v3)
        {
LABEL_109:
          if (v3) {
            goto LABEL_110;
          }
          goto LABEL_111;
        }

        goto LABEL_107;
      }

      if (!v3) {
        goto LABEL_109;
      }
LABEL_107:
      receiver = v126;
      goto LABEL_108;
    }

    unint64_t v98 = [*((id *)v8 + 14) _isProxySession];
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    CFMutableArrayRef v99 = (os_log_s *)CFNLog::logger;
    uint64_t v100 = os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR);
    if (v98)
    {
      if (v100)
      {
        unint64_t v101 = (void *)*((void *)v8 + 16);
        LODWORD(v133.receiver) = 138543362;
        *(id *)((char *)&v133.receiver + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v101;
        uint64_t v102 = "ProxySession <%{public}@> failed to create a background AVAggregateAssetDownloadTask, as remote session is unavailable";
LABEL_114:
        _os_log_error_impl(&dword_18298D000, v99, OS_LOG_TYPE_ERROR, v102, (uint8_t *)&v133, 0xCu);
      }
    }

    else if (v100)
    {
      uint64_t v110 = (void *)*((void *)v8 + 16);
      LODWORD(v133.receiver) = 138543362;
      *(id *)((char *)&v133.receiver + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v110;
      uint64_t v102 = "BackgroundSession <%{public}@> failed to create a background AVAggregateAssetDownloadTask, as remote sessio"
             "n is unavailable";
      goto LABEL_114;
    }

    unint64_t v80 = (void *)MEMORY[0x189607870];
    __int128 v81 = *MEMORY[0x189607740];
    char v82 = v39;
LABEL_103:
    uint64_t v108 = (void *)objc_msgSend(v80, "_web_errorWithDomain:code:URL:", v81, -1, v82);
    if (v3)
    {
      objc_setProperty_atomic(v3, v109, v108, 776LL);
LABEL_110:
      objc_msgSend( *((id *)v8 + 23),  "setObject:forKeyedSubscript:",  v3,  objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedInteger:", objc_msgSend(v3, "taskIdentifier")));
    }

                int v62 = open(-[NSURL fileSystemRepresentation](v7, "fileSystemRepresentation"), 0);
                if ((_DWORD)v62 != -1)
                {
                  BOOL v7 = (NSURL *)[objc_alloc(MEMORY[0x189607898]) initWithFileDescriptor:v62 closeOnDealloc:1];
                  goto LABEL_130;
                }

                if ([*(id *)&v3->super.super.super._allowsConstrainedOverride _isProxySession])
                {
                  if (CFNLog::onceToken != -1) {
                    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
                  }
                  int64_t v63 = (os_log_s *)CFNLog::logger;
                  if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_129;
                  }
                  uint64_t v64 = *(void *)&v3->super.super.super._requiresDNSSECValidation;
                  unint64_t v65 = *__error();
                  *(_DWORD *)uint64_t v89 = 138543618;
                  *(void *)&v89[4] = v64;
                  *(_WORD *)&v89[12] = 1024;
                  *(_DWORD *)&v89[14] = v65;
                  uint64_t v66 = "ProxySession <%{public}@> Failed to open file to upload %{errno}d";
                }

                else
                {
                  if (CFNLog::onceToken != -1) {
                    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
                  }
                  int64_t v63 = (os_log_s *)CFNLog::logger;
                  if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_129;
                  }
                  uint64_t v76 = *(void *)&v3->super.super.super._requiresDNSSECValidation;
                  CFTypeID v77 = *__error();
                  *(_DWORD *)uint64_t v89 = 138543618;
                  *(void *)&v89[4] = v76;
                  *(_WORD *)&v89[12] = 1024;
                  *(_DWORD *)&v89[14] = v77;
                  uint64_t v66 = "BackgroundSession <%{public}@> Failed to open file to upload %{errno}d";
                }

                _os_log_error_impl(&dword_18298D000, v63, OS_LOG_TYPE_ERROR, v66, v89, 0x12u);
LABEL_129:
                BOOL v7 = 0LL;
LABEL_130:
                if ((v23 & 1) != 0)
                {
                  unint64_t v67 = -[NSURLSessionTask taskIdentifier](v38, "taskIdentifier");
                  CFTypeID v68 = -[NSURLSessionTask _uniqueIdentifier](v38, "_uniqueIdentifier");
                  *(void *)uint64_t v89 = v17;
                  *(void *)&v89[8] = 3221225472LL;
                  *(void *)&v89[16] = __56____NSURLBackgroundSession__onqueue_uploadTaskForClass___block_invoke_2;
                  int v90 = (NSURL *)&unk_189C07620;
                  int v91 = v38;
                  unint64_t v92 = v3;
                  int v93 = Property;
                  [v81 uploadTaskWithRequest:Property originalRequest:Property fromFile:v7 sandboxExtensionData:v47 identifier:v67 uniqueIdentifier:v68 pote ntialCredentials:0 reply:v89];
                }

                else
                {
                  uint64_t v69 = -[NSURLSessionTask taskIdentifier](v38, "taskIdentifier");
                  CFTypeID v70 = -[NSURLSessionTask _uniqueIdentifier](v38, "_uniqueIdentifier");
                  *(void *)uint64_t v89 = v17;
                  *(void *)&v89[8] = 3221225472LL;
                  *(void *)&v89[16] = __56____NSURLBackgroundSession__onqueue_uploadTaskForClass___block_invoke_109;
                  int v90 = (NSURL *)&unk_189C07620;
                  int v91 = v38;
                  unint64_t v92 = v3;
                  int v93 = Property;
                  [v81 uploadTaskWithResumableUploadState:v4 request:Property originalRequest:Property fromFile:v7 sandboxExtensionData:v47 identifier:v69  uniqueIdentifier:v70 potentialCredentials:0 reply:v89];
                }

                if (v38)
                {
LABEL_134:
                  objc_msgSend( (id)v3->super.super.super._countOfBytesClientExpectsToSend,  "setObject:forKeyedSubscript:",  v38,  objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[NSURLSessionTask taskIdentifier](v38, "taskIdentifier")));
                  internalDelegateWrapper = (uint64_t)v38->super.super.super._internalDelegateWrapper;
                  goto LABEL_137;
                }

                goto LABEL_136;
              }

              if ([*(id *)&v3->super.super.super._allowsConstrainedOverride _isProxySession])
              {
                if (CFNLog::onceToken != -1) {
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
                }
                CFTypeID v44 = (os_log_s *)CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v45 = *(void *)&v3->super.super.super._requiresDNSSECValidation;
                  LODWORD(buf) = 138543362;
                  *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v45;
                  uint64_t v46 = "ProxySession <%{public}@> failed to create a background NSURLSessionUploadTask, as remote sessio"
                        "n is unavailable";
LABEL_140:
                  _os_log_error_impl(&dword_18298D000, v44, OS_LOG_TYPE_ERROR, v46, (uint8_t *)&buf, 0xCu);
                }
              }

              else
              {
                if (CFNLog::onceToken != -1) {
                  dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
                }
                CFTypeID v44 = (os_log_s *)CFNLog::logger;
                if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
                {
                  CFIndex v72 = *(void *)&v3->super.super.super._requiresDNSSECValidation;
                  LODWORD(buf) = 138543362;
                  *(void *)((char *)&buf + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v72;
                  uint64_t v46 = "BackgroundSession <%{public}@> failed to create a background NSURLSessionUploadTask, as remote s"
                        "ession is unavailable";
                  goto LABEL_140;
                }
              }

              CFTypeID v49 = [Property URL];
              uint64_t v50 = (void *)objc_msgSend( MEMORY[0x189607870],  "_web_errorWithDomain:code:URL:",  *MEMORY[0x189607740],  -1,  v49);
              if (v38)
              {
                objc_setProperty_atomic(v38, v51, v50, 776LL);
                goto LABEL_134;
              }

void sub_182A7A09C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_182A7A394( _Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  if (a2 == 1)
  {
    *(void *)(*(void *)(*(void *)(v8 + 48) + 8LL) + 4std::unique_ptr<std::list<std::pair<std::shared_ptr<TLSCallbackServerTrust>,std::shared_ptr<TLSCallbackClientCertificate>>>>::reset[abi:nn180100]( v2, 0LL) = objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x182A7A324LL);
  }

  _Unwind_Resume(a1);
}

id copyDecodedResumeData(NSData *a1)
{
  if (!a1) {
    return 0LL;
  }
  id v2 = (id)[objc_alloc(MEMORY[0x189607908]) initForReadingFromData:a1 error:0];
  [v2 setDecodingFailurePolicy:1];
  uint64_t v3 = objc_msgSend( (id)objc_msgSend( v2,  "decodeObjectOfClasses:forKey:",  resumeDataClasses(void)::resumeDataClasses,  @"NSKeyedArchiveRootObjectKey"),  "copy");
  [v2 finishDecoding];
  if (!v3) {
    return (id)[MEMORY[0x1896079E8] propertyListWithData:a1 options:0 format:0 error:0];
  }
  return (id)v3;
}

uint64_t ___ZL17resumeDataClassesv_block_invoke_4506()
{
  os_log_t v0 = (void *)MEMORY[0x189603FE0];
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  resumeDataClasses(void)::resumeDataClasses = (uint64_t)(id)objc_msgSend( v0,  "setWithObjects:",  v1,  v2,  v3,  v4,  v5,  v6,  objc_opt_class(),  0);
  gotLoadHelper_x20__OBJC_CLASS___SZExtractor(v7);
  if (objc_opt_class())
  {
    uint64_t v9 = [*(id *)(v1 + 2616) knownSZExtractorImplementations];
    [(id)resumeDataClasses(void)::resumeDataClasses unionSet:v9];
  }

  gotLoadHelper_x20__OBJC_CLASS___STRemoteExtractor(v8);
  uint64_t result = objc_opt_class();
  if (result) {
    return [(id)resumeDataClasses(void)::resumeDataClasses addObject:objc_opt_class()];
  }
  return result;
}

void sub_182A7DFC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void (*a17)(char *))
{
}

CFStringRef URLDownload::copyDebugDesc(URLDownload *this)
{
  uint64_t v2 = (char *)this - 16;
  uint64_t v3 = CFGetAllocator((char *)this - 16);
  uint64_t v4 = *((void *)this + 21);
  if (!v4)
  {
    uint64_t v11 = *((void *)this + 3);
    CFRange v12 = (const __CFString *)*((void *)this + 26);
    if (!v12) {
      CFRange v12 = @"path not determined";
    }
    return CFStringCreateWithFormat( v3,  0LL,  @"<CFURLDownload %p [%p]> {nw_connection_t connection = %@, path = %@, client = %p}",  v2,  v3,  v11,  v12,  v4);
  }

  uint64_t v5 = *(uint64_t (**)(void))(v4 + 32);
  if (!v5)
  {
    uint64_t v11 = *((void *)this + 3);
    CFRange v12 = (const __CFString *)*((void *)this + 26);
    if (!v12) {
      CFRange v12 = @"path not determined";
    }
LABEL_16:
    uint64_t v4 = *(void *)(v4 + 8);
    return CFStringCreateWithFormat( v3,  0LL,  @"<CFURLDownload %p [%p]> {nw_connection_t connection = %@, path = %@, client = %p}",  v2,  v3,  v11,  v12,  v4);
  }

  uint64_t v6 = v5(*(void *)(v4 + 8));
  if (!v6)
  {
    uint64_t v4 = *((void *)this + 21);
    uint64_t v11 = *((void *)this + 3);
    CFRange v12 = (const __CFString *)*((void *)this + 26);
    if (!v12) {
      CFRange v12 = @"path not determined";
    }
    if (!v4) {
      return CFStringCreateWithFormat( v3,  0LL,  @"<CFURLDownload %p [%p]> {nw_connection_t connection = %@, path = %@, client = %p}",  v2,  v3,  v11,  v12,  v4);
    }
    goto LABEL_16;
  }

  double v7 = (const void *)v6;
  double v8 = (const __CFString *)*((void *)this + 26);
  if (!v8) {
    double v8 = @"path not determined";
  }
  CFStringRef v9 = CFStringCreateWithFormat( v3,  0LL,  @"<CFURLDownload %p [%p]> {connection = %@, path = %@, client = %@}",  v2,  v3,  *((void *)this + 3),  v8,  v6);
  CFRelease(v7);
  return v9;
}

void non-virtual thunk to'URLDownload::~URLDownload(URLDownload *this)
{
}

{
  URLDownload::~URLDownload((URLDownload *)((char *)this - 8));
}

void URLDownload::~URLDownload(URLDownload *this)
{
  *(void *)this = &off_189C07A68;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &unk_189C07AB0;
  URLDownload::_internal_releaseClient(this);
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 25);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)*((void *)this + 26);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 27);
  if (v6) {
    CFRelease(v6);
  }
  double v7 = (const void *)*((void *)this + 29);
  if (v7) {
    CFRelease(v7);
  }
  double v8 = (const void *)*((void *)this + 30);
  if (v8) {
    CFRelease(v8);
  }

  CFStringRef v9 = (const void *)*((void *)this + 32);
  if (v9) {
    CFRelease(v9);
  }
  CFRange v10 = (const void *)*((void *)this + 31);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = (const void *)*((void *)this + 28);
  if (v11) {
    CFRelease(v11);
  }
  (*(void (**)(void))(**((void **)this + 36) + 48LL))(*((void *)this + 36));
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = off_189C19AE8;
}

void sub_182A7F378(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

double URLDownload::_internal_releaseClient(URLDownload *this)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (*((void *)this + 21))
  {
    uint64_t v2 = (unsigned int *)((char *)this + 176);
    do
    {
      unsigned int v3 = __ldaxr(v2);
      unsigned int v4 = v3 - 1;
    }

    while (__stlxr(v4, v2));
    if (!v4)
    {
      if (!*((void *)this + 20) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        int v7 = 136315138;
        double v8 = "T *ClientContextHolder<CFURLDownloadClient>::forget() [T = CFURLDownloadClient]";
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "%s called before remember",  (uint8_t *)&v7,  0xCu);
      }

      if (*((void *)this + 5))
      {
        uint64_t v5 = (void (*)(void))*((void *)this + 7);
        if (v5) {
          v5();
        }
      }

      double result = 0.0;
      *((_OWORD *)this + 9) = 0u;
      *((_OWORD *)this + ++*((void *)this + 10) = 0u;
      *((_OWORD *)this + 7) = 0u;
      *((_OWORD *)this + _Block_object_dispose(va, 8) = 0u;
      *((_OWORD *)this + 5) = 0u;
      *((_OWORD *)this + 6) = 0u;
      *((_OWORD *)this + 3) = 0u;
      *((_OWORD *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
      *((_OWORD *)this + 2) = 0u;
    }
  }

  return result;
}

void ___ZN11URLDownload5ClassEv_block_invoke()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "CFURLDownload");
  URLDownload::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182A7F4C0(_Unwind_Exception *a1)
{
}

uint64_t URLDownload::_internal_setClient(uint64_t result, void *__src)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (__src)
  {
    uint64_t v3 = result;
    if (*__src && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v6) = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "you shouldn't be using CFURLDownload; use NSURLSession ",
        (uint8_t *)&v6,
        2u);
    }

    uint64_t v4 = v3 + 32;
    if (*(void *)(v3 + 160) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      int v6 = 136315138;
      int v7 = "T *ClientContextHolder<CFURLDownloadClient>::remember(const T *) [T = CFURLDownloadClient]";
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "%s called before forget",  (uint8_t *)&v6,  0xCu);
    }

    memmove((void *)(v3 + 32), __src, 0x80uLL);
    double result = *(void *)(v3 + 40);
    if (result)
    {
      uint64_t v5 = *(uint64_t (**)(void))(v3 + 48);
      if (v5)
      {
        double result = v5();
        *(void *)(v3 + 40) = result;
      }
    }

    *(void *)(v3 + 160) = v4;
    *(void *)(v3 + 16_Block_object_dispose(va, 8) = v4;
    *(_DWORD *)(v3 + 176) = 1;
  }

  return result;
}

DownloadConnectionClient *DownloadConnectionClient::_implRetain( DownloadConnectionClient *this, const void *a2)
{
  return this;
}

void DownloadConnectionClient::_implRelease(DownloadConnectionClient *this, const void *a2)
{
}

CFStringRef DownloadConnectionClient::_copyDescription(DownloadConnectionClient *this, const void *a2)
{
  CFStringRef v2 = CFCopyDescription((char *)this - 16);
  CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"CFURLConnectionClient[%@]", v2);
  CFRelease(v2);
  return v3;
}

CFTypeRef DownloadConnectionClient::_willSendRequestCallback( DownloadConnectionClient *this, CFTypeRef cf, const _CFURLRequest *a3, _CFURLResponse *a4, const void *a5)
{
  if (!*((_BYTE *)a4 + 286))
  {
    *((_BYTE *)a4 + 286) = 1;
    uint64_t v10 = *((void *)a4 + 21);
    if (v10)
    {
      uint64_t v11 = *(void (**)(char *, void))(v10 + 40);
      if (v11) {
        v11((char *)a4 - 16, *(void *)(v10 + 8));
      }
    }
  }

  uint64_t v8 = *((void *)a4 + 21);
  if (v8
    && (uint64_t v9 = *(uint64_t (**)(char *, CFTypeRef, const _CFURLRequest *, void, const void *))(v8 + 48)) != 0LL)
  {
    CFTypeRef cf = (CFTypeRef)v9((char *)a4 - 16, cf, a3, *(void *)(v8 + 8), a5);
    if (cf) {
      return cf;
    }
  }

  else if (cf)
  {
    CFRetain(cf);
    return cf;
  }

  if (a3) {
    URLDownload::_internal_downloadFinished((URLDownload *)a4);
  }
  else {
    URLDownload::_internal_downloadFailed((URLDownload *)a4, 0LL);
  }
  return 0LL;
}

void DownloadConnectionClient::_didReceiveResponseCallback( DownloadConnectionClient *this, _CFURLResponse *a2, _CFURLResponse *a3, const void *a4)
{
  if (!*((_BYTE *)a3 + 286))
  {
    *((_BYTE *)a3 + 286) = 1;
    uint64_t v12 = *((void *)a3 + 21);
    if (v12)
    {
      __int128 v13 = *(void (**)(char *, void))(v12 + 40);
      if (v13) {
        v13((char *)a3 - 16, *(void *)(v12 + 8));
      }
    }
  }

  URLDownload::_internal_setResponse((URLDownload *)a3, a2);
  int v6 = *((unsigned __int8 *)a3 + 285);
  uint64_t v7 = *(void *)(-[_CFURLResponse _inner](a2, "_inner") + 88);
  if (!v7)
  {
    if (v6)
    {
LABEL_14:
      *((void *)a3 + 3os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
      CFTypeID v14 = (const void *)*((void *)a3 + 25);
      if (v14)
      {
        CFRelease(v14);
        char v11 = 0;
        *((void *)a3 + 25) = 0LL;
      }

      else
      {
        char v11 = 0;
      }

void DownloadConnectionClient::_didReceiveDataCallback( DownloadConnectionClient *this, CFDataRef theData, const __CFData *a3, URLDownload *a4, const void *a5)
{
  if ((const __CFData *)CFDataGetLength(theData) != a3 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFIndex v9 = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "originalLength is not really necessary here.",  v9,  2u);
  }

  uint64_t v7 = URLDownload::_internal_downloadProcessData(a4, theData);
  if (v7)
  {
    uint64_t v8 = v7;
    URLDownload::_internal_downloadCancel(a4, v7);
    CFRelease(v8);
  }

void DownloadConnectionClient::_connectionDidFinishLoadingCallback( DownloadConnectionClient *this, _CFURLConnection *a2, const void *a3)
{
  uint64_t v4 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  *((_BYTE *)a2 + 28os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
  if (!*((_BYTE *)a2 + 280))
  {
    int v6 = (const __CFData *)*((void *)a2 + 31);
    if (v6)
    {
      *((_BYTE *)a2 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = 1;
      uint64_t v7 = URLDownload::_internal_downloadProcessData((URLDownload *)a2, v6);
      CFRelease(*((CFTypeRef *)a2 + 31));
      *((void *)a2 + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
      if (v7)
      {
        URLDownload::_internal_downloadCancel((URLDownload *)a2, v7);
        CFRelease(v7);
      }
    }

    else if (!*((void *)a2 + 33))
    {
      uint64_t v8 = URLDownload::_internal_downloadOpenTarget((URLDownload *)a2);
      *((void *)a2 + 33) = v8;
      if (!v8) {
        URLDownload::_internal_downloadFailedWithCFNetworkError((URLDownload *)a2, -3000LL);
      }
    }
  }

  uint64_t v5 = *((void *)a2 + 33);
  if (v5)
  {
    *((void *)a2 + 33) = 0LL;
    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    void v9[2] = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke;
    v9[3] = &__block_descriptor_48_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
    v9[4] = a2;
    void v9[5] = v5;
    URLDownload::_internal_withClientScheduling((uint64_t)a2, (uint64_t)v9);
  }

  CFRelease(v4);
}

void sub_182A7FAAC(_Unwind_Exception *a1)
{
}

void DownloadConnectionClient::_didFailCallback( DownloadConnectionClient *this, _CFURLConnection *a2, __CFError *a3, const void *a4)
{
  if (!*((_BYTE *)a3 + 286))
  {
    *((_BYTE *)a3 + 286) = 1;
    uint64_t v6 = *((void *)a3 + 21);
    if (v6)
    {
      uint64_t v7 = *(void (**)(char *, void))(v6 + 40);
      if (v7) {
        v7((char *)a3 - 16, *(void *)(v6 + 8));
      }
    }
  }

  URLDownload::_internal_downloadCancel(a3, (__CFError *)a2);
}

uint64_t DownloadConnectionClient::_willCacheResponseCallback( DownloadConnectionClient *this, _CFURLConnection *a2, const _CFCachedURLResponse *a3, const void *a4)
{
  return 0LL;
}

void DownloadConnectionClient::_didReceiveAuthenticationChallengeCallback( DownloadConnectionClient *this, const _CFURLCredential *cf, _CFURLAuthChallenge *a3, const void *a4)
{
  if (!*((_BYTE *)a3 + 286))
  {
    *((_BYTE *)a3 + 286) = 1;
    uint64_t v14 = *((void *)a3 + 21);
    if (v14)
    {
      uint64_t v15 = *(void (**)(char *, void))(v14 + 40);
      if (v15) {
        v15((char *)a3 - 16, *(void *)(v14 + 8));
      }
    }
  }

  uint64_t v6 = *((void *)a3 + 21);
  if (v6 && (uint64_t v7 = *(void (**)(char *, const _CFURLCredential *, void))(v6 + 56)) != 0LL)
  {
    if (cf)
    {
      CFTypeRef v8 = CFRetain(cf);
      uint64_t v6 = *((void *)a3 + 21);
      uint64_t v7 = *(void (**)(char *, const _CFURLCredential *, void))(v6 + 56);
    }

    else
    {
      CFTypeRef v8 = 0LL;
    }

    *((void *)a3 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v8;
    v7((char *)a3 - 16, cf, *(void *)(v6 + 8));
  }

  else
  {
    CFIndex v9 = (char *)cf + 16;
    if (!cf) {
      CFIndex v9 = 0LL;
    }
    uint64_t v10 = *((void *)v9 + 4);
    if (v10
      && (uint64_t v11 = URLCredential_PasswordBased::safelyCast(*((void *)v9 + 4), cf)) != 0
      && (*(unsigned int (**)(uint64_t))(*(void *)v11 + 136LL))(v11))
    {
      uint64_t v12 = *((void *)a3 + 2);
      uint64_t v13 = v10;
    }

    else
    {
      uint64_t v12 = *((void *)a3 + 2);
      uint64_t v13 = 0LL;
    }

    CFURLConnectionUseCredential(v12, v13, (uint64_t)cf);
  }

uint64_t DownloadConnectionClient::_shouldUseCredentialStorageCallback( DownloadConnectionClient *this, _CFURLConnection *a2, const void *a3)
{
  return *((unsigned __int8 *)a2 + 320);
}

__CFDictionary *createDownloadConnectionProperties(const __CFAllocator *a1)
{
  MutableDictionary = cfTypeCreateMutableDictionary(a1, 0x18C5AC598LL, *MEMORY[0x189604DE8], 0LL, 0LL);
  CFStringRef v3 = cfTypeCreateMutableDictionary(a1, @"kCFURLConnectionSocketStreamProperties", MutableDictionary, 0LL, 0LL);
  if (MutableDictionary) {
    CFRelease(MutableDictionary);
  }
  return v3;
}

void URLDownload::_internal_downloadCancel(URLDownload *this, __CFError *a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (!*((_BYTE *)this + 287))
  {
    *((_BYTE *)this + 287) = 1;
    uint64_t v4 = *((void *)this + 2);
    if (v4) {
      CFURLConnectionCancel(v4);
    }
    uint64_t v5 = (AsyncTargetFile *)*((void *)this + 33);
    if (v5)
    {
      AsyncTargetFile::close(v5, (uint64_t *)this + 34);
      (*(void (**)(void))(**((void **)this + 33) + 48LL))(*((void *)this + 33));
      *((void *)this + 33) = 0LL;
      if (*((_BYTE *)this + 281))
      {
        FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v6, *((CFURLRef *)this + 26), 0, 0, 1u);
        if (v6)
        {
          if (unlink(v7)) {
            __error();
          }
        }
      }
    }

    URLDownload::_internal_downloadFailed(this, a2);
  }

uint64_t AsyncTargetFile::close(AsyncTargetFile *this, uint64_t *a2)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000LL;
  int v9 = -1;
  *a2 = 0LL;
  CFStringRef v2 = (dispatch_queue_s *)*((void *)this + 3);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN15AsyncTargetFile5closeEPx_block_invoke;
  block[3] = &unk_189C18DE0;
  block[4] = &v6;
  void block[5] = this;
  void block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void URLDownload::_internal_downloadFailed(URLDownload *this, __CFError *a2)
{
  int v4 = URLDownload::_internal_downloadEnded(this);
  uint64_t v5 = *((void *)this + 21);
  if (v5)
  {
    if (a2)
    {
      uint64_t v6 = *(void (**)(char *, __CFError *, void))(v5 + 120);
      if (v6) {
        v6((char *)this - 16, a2, *(void *)(v5 + 8));
      }
    }
  }

  if (v4)
  {
    URLDownload::_internal_releaseClient(this);
    CFRelease((char *)this - 16);
  }

uint64_t URLDownload::_internal_downloadEnded(URLDownload *this)
{
  if (!*((_BYTE *)this + 282)) {
    return 0LL;
  }
  *((_BYTE *)this + 282) = 0;
  CFStringRef v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 2) = 0LL;
  uint64_t v3 = (const void *)*((void *)this + 24);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  return 1LL;
}

int *___ZN15AsyncTargetFile5closeEPx_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  double result = (int *)*(unsigned int *)(v2 + 20);
  if ((_DWORD)result == -1)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 22;
  }

  else
  {
    fstat((int)result, &v5);
    **(void **)(a1 + 4_Block_object_dispose(va, 8) = v5.st_size;
    double result = (int *)close(*(_DWORD *)(v2 + 20));
    if ((_DWORD)result)
    {
      double result = __error();
      int v4 = *result;
    }

    else
    {
      int v4 = 0;
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
    *(_DWORD *)(v2 + 20) = -1;
  }

  return result;
}

CFErrorRef URLDownload::_internal_downloadProcessData(URLDownload *this, CFDataRef theData)
{
  uint64_t v100 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFDataGetLength(theData);
  if (!*((_BYTE *)this + 280))
  {
    uint64_t v6 = (__CFData *)*((void *)this + 31);
    if (v6)
    {
      CFIndex v7 = Length;
      BytePtr = CFDataGetBytePtr(theData);
      CFDataAppendBytes(v6, BytePtr, v7);
      CFMutableDictionaryRef MutableCopy = (const __CFData *)*((void *)this + 31);
    }

    else
    {
      uint64_t v10 = CFGetAllocator((char *)this - 16);
      CFMutableDictionaryRef MutableCopy = CFDataCreateMutableCopy(v10, 0LL, theData);
      *((void *)this + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = MutableCopy;
      if (!MutableCopy)
      {
        unint64_t v41 = CFGetAllocator((char *)this - 16);
        return __cfnCreateCFError(v41, (CFErrorDomain)*MEMORY[0x189604F58], 12LL, v42, v43, v44, v45, v46, 0LL);
      }
    }

    if (CFDataGetLength(MutableCopy) > 0x2000)
    {
      stat v5 = (const __CFData *)*((void *)this + 31);
      *((void *)this + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
      *((_BYTE *)this + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = 1;
      goto LABEL_10;
    }

    goto LABEL_8;
  }

  if (!theData)
  {
LABEL_8:
    stat v5 = 0LL;
    goto LABEL_10;
  }

  stat v5 = (const __CFData *)CFRetain(theData);
LABEL_10:
  if (!*((void *)this + 33))
  {
    if (*((_BYTE *)this + 285))
    {
      uint64_t v19 = URLDownload::_internal_downloadOpenTarget(this);
      *((void *)this + 33) = v19;
      if (!v19)
      {
        uint64_t v20 = CFGetAllocator((char *)this - 16);
        return __cfnCreateCFError(v20, @"kCFErrorDomainCFNetwork", -3001LL, v21, v22, v23, v24, v25, 0LL);
      }
    }
  }

  if (!v5 || !CFDataGetLength(v5))
  {
    if (!*((_BYTE *)this + 287))
    {
      uint64_t v27 = *((void *)this + 21);
      if (v27)
      {
        CFStringRef v28 = *(void (**)(char *, void, void))(v27 + 80);
        if (v28) {
          v28((char *)this - 16, 0LL, *(void *)(v27 + 8));
        }
      }
    }

    CFErrorRef v18 = 0LL;
    if (!v5) {
      return v18;
    }
    goto LABEL_111;
  }

  double v88 = 0LL;
  uint64_t v89 = 0LL;
  uint64_t v11 = (const __CFArray *)*((void *)this + 32);
  if (!v11)
  {
    CFTypeID v29 = CFGetAllocator((char *)this - 16);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v29, 0LL, MEMORY[0x189605228]);
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = Mutable;
    if (!Mutable)
    {
      __int128 v47 = CFGetAllocator((char *)this - 16);
      CFErrorRef CFError = __cfnCreateCFError(v47, (CFErrorDomain)*MEMORY[0x189604F58], 12LL, v48, v49, v50, v51, v52, 0LL);
      goto LABEL_39;
    }

    if (!URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray)
    {
      values = &unk_18C5B1B90;
      uint64_t v91 = 0x18C5B18B8LL;
      unint64_t v92 = (uint64_t (*)(void *))@"application/macbinary";
      CFArrayRef v31 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)&values, 3LL, MEMORY[0x189605228]);
      while (!__ldaxr((unint64_t *)&URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray))
      {
        if (!__stlxr( (unint64_t)v31,  (unint64_t *)&URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray))
        {
          char v33 = 1;
          goto LABEL_42;
        }
      }

      char v33 = 0;
      __clrex();
LABEL_42:
      if ((v33 & 1) == 0 && v31) {
        CFRelease(v31);
      }
    }

    uint64_t v54 = *((void *)this + 21);
    if (v54) {
      BOOL v86 = *(void *)(v54 + 88) != 0LL;
    }
    else {
      BOOL v86 = 0;
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)URLDownload::_internal_decodeHeaderData(__CFData const*,__CFData const**,__CFData const**)::sSupportedDecoderMIMETypeArray);
    if (Count < 1)
    {
LABEL_81:
      if (CFArrayGetCount(*((CFArrayRef *)this + 32)))
      {
        unint64_t v67 = v88;
        CFTypeRef v53 = v89;
LABEL_85:
        if (!*((void *)this + 33))
        {
          uint64_t v68 = URLDownload::_internal_downloadOpenTarget(this);
          *((void *)this + 33) = v68;
          if (!v68)
          {
            unint64_t v80 = CFGetAllocator((char *)this - 16);
            CFErrorRef v18 = __cfnCreateCFError(v80, @"kCFErrorDomainCFNetwork", -3001LL, v81, v82, v83, v84, v85, 0LL);
            if (v18)
            {
LABEL_107:
              if (v53) {
                CFRelease(v53);
              }
              if (v67) {
                CFRelease(v67);
              }
              goto LABEL_111;
            }
          }
        }

        CFRetain((char *)this - 16);
        uint64_t v69 = (const void *)*((void *)this + 2);
        if (v69)
        {
          CFTypeRef v70 = CFRetain(v69);
          if (v53) {
            goto LABEL_89;
          }
        }

        else
        {
          CFTypeRef v70 = 0LL;
          if (v53)
          {
LABEL_89:
            CFIndex v71 = CFDataGetLength((CFDataRef)v53);
            if (v67)
            {
LABEL_90:
              CFIndex v72 = CFDataGetLength((CFDataRef)v67);
              goto LABEL_94;
            }

LABEL_93:
            CFIndex v72 = 0LL;
LABEL_94:
            CFIndex v73 = v72 + v71;
            os_unfair_lock_lock((os_unfair_lock_t)this + 76);
            *((void *)this + 37) += v73;
            os_unfair_lock_unlock((os_unfair_lock_t)this + 76);
            CFIndex v74 = (void *)*((void *)this + 33);
            uint64_t v75 = (void *)MEMORY[0x1895F87A8];
            v87[0] = MEMORY[0x1895F87A8];
            v87[1] = 3221225472LL;
            v87[2] = ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke;
            v87[3] = &__block_descriptor_48_e11_v20__0Q8i16l;
            v87[4] = this;
            v87[5] = v70;
            if (v53)
            {
              CFIndex v76 = CFDataGetLength((CFDataRef)v53);
              if (v67) {
                goto LABEL_96;
              }
            }

            else
            {
              CFIndex v76 = 0LL;
              if (v67)
              {
LABEL_96:
                CFIndex v77 = CFDataGetLength((CFDataRef)v67);
                if (!v53) {
                  goto LABEL_101;
                }
                goto LABEL_100;
              }
            }

            CFIndex v77 = 0LL;
            if (!v53)
            {
LABEL_101:
              if (v67) {
                CFRetain(v67);
              }
              (*(void (**)(void *))(*v74 + 40LL))(v74);
              SecCertificateRef v78 = (dispatch_queue_s *)v74[3];
              values = v75;
              uint64_t v91 = 3221225472LL;
              unint64_t v92 = ___ZN15AsyncTargetFile5writeEPK8__CFDataS2_U13block_pointerFvmiE_block_invoke;
              int v93 = &unk_189C07B90;
              CFTypeRef v96 = v53;
              CFIndex v97 = v76;
              unint64_t v98 = v67;
              CFIndex v99 = v77;
              __int16 v94 = v87;
              unint64_t v95 = v74;
              dispatch_async(v78, &values);
              if (*((void *)this + 37) > 0x200000uLL)
              {
                int v79 = *((_DWORD *)this + 77);
                *((_DWORD *)this + 77) = v79 + 1;
                if (!v79) {
                  CFURLConnectionHalt((uint64_t)v70);
                }
              }

              CFErrorRef v18 = 0LL;
              goto LABEL_107;
            }

void sub_182A8089C(_Unwind_Exception *a1)
{
  *(void *)(v1 + CFRelease((char *)this - 16) = off_189C048B0;
  _Unwind_Resume(a1);
}

uint64_t URLDownload::_internal_downloadOpenTarget(URLDownload *this)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (const __CFURL *)*((void *)this + 25);
  if (*((_BYTE *)this + 285)) {
    BOOL v3 = v2 == 0LL;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = !v3;
  if (v2) {
    goto LABEL_8;
  }
  uint64_t v7 = *((void *)this + 21);
  if (v7)
  {
    if (*(void *)(v7 + 96))
    {
      uint64_t v8 = (void *)*((void *)this + 23);
      if (v8)
      {
        int v9 = URLResponse::copySuggestedFilename((URLResponse *)[v8 _inner]);
        if (v9)
        {
          uint64_t v10 = v9;
          CFTypeRef v11 = URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(this, v9);
          (*(void (**)(char *, CFTypeRef, void))(*((void *)this + 21) + 96LL))( (char *)this - 16,  v11,  *(void *)(*((void *)this + 21) + 8LL));
          CFRelease(v10);
          CFRelease(v11);
          uint64_t v2 = (const __CFURL *)*((void *)this + 25);
          if (v2)
          {
LABEL_8:
            stat v5 = (char *)operator new(0x40CuLL);
            FilePathStorage<unsigned char>::FilePathStorage((uint64_t)v5, v2, 0, 0, 1u);
            if (*v5)
            {
              char v6 = 0;
              goto LABEL_40;
            }

            operator delete(v5);
          }
        }
      }
    }
  }

  if (!*((void *)this + 27)) {
    goto LABEL_31;
  }
  uint64_t v12 = [*((id *)this + 3) _inner];
  CFIndex v13 = *(const __CFURL **)(v12 + 8);
  if (!v13) {
    goto LABEL_31;
  }
  SemiColonEscapedURLIfParamterIsPresent = cfnCreateSemiColonEscapedURLIfParamterIsPresent(*(const __CFURL **)(v12 + 8));
  if (SemiColonEscapedURLIfParamterIsPresent)
  {
    CFIndex v15 = SemiColonEscapedURLIfParamterIsPresent;
    CFStringRef PathComponent = CFURLCopyLastPathComponent(SemiColonEscapedURLIfParamterIsPresent);
    CFRelease(v15);
    if (!PathComponent)
    {
LABEL_31:
      stat v5 = (char *)operator new(0x40CuLL);
      char *v5 = 1;
      *((_DWORD *)v5 + 257) = 0;
      uint64_t v21 = v5 + 1;
      size_t v22 = confstr(65537, v5 + 1, 0x400uLL);
      if (!v22 || v22 + 8 > 0x400) {
        goto LABEL_60;
      }
      uint64_t v23 = 0LL;
      char v44 = 0;
      *(void *)__source = 0LL;
      while (1)
      {
        do
          __source[v23++] = FilePathStorage<unsigned char>::makeTempPath(void)::validChars[arc4random() % 0x24];
        while (v23 != 8);
        strlcpy((char *)__dst, v21, 0x400uLL);
        strlcat((char *)__dst, __source, 0x400uLL);
        uint64_t v23 = 0LL;
      }

      if (*__error() != 2) {
        goto LABEL_60;
      }
      strlcpy(v21, (const char *)__dst, 0x400uLL);
      if (!*v5) {
        goto LABEL_60;
      }
      goto LABEL_39;
    }
  }

  else
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(v13);
    if (!PathComponent) {
      goto LABEL_31;
    }
  }

  if (!CFStringGetLength(PathComponent))
  {
    CFRelease(PathComponent);
    CFStringRef PathComponent = CFURLCopyHostName(v13);
    if (!PathComponent) {
      goto LABEL_31;
    }
  }

  int v17 = (const __CFString *)URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(this, PathComponent);
  CFErrorRef v18 = CFGetAllocator((char *)this - 16);
  CFURLRef v19 = CFURLCreateCopyAppendingPathComponent(v18, *((CFURLRef *)this + 27), v17, 0);
  if (v19)
  {
    uint64_t v20 = v19;
    stat v5 = (char *)operator new(0x40CuLL);
    FilePathStorage<unsigned char>::FilePathStorage((uint64_t)v5, v20, 0, 0, 1u);
    if (!*v5)
    {
      operator delete(v5);
      stat v5 = 0LL;
    }

    CFRelease(v20);
    if (v17) {
      goto LABEL_29;
    }
  }

  else
  {
    stat v5 = 0LL;
    if (v17) {
LABEL_29:
    }
      CFRelease(v17);
  }

  CFRelease(PathComponent);
  if (!v5) {
    goto LABEL_31;
  }
LABEL_39:
  char v6 = 1;
LABEL_40:
  if (v4) {
    BOOL v24 = *((void *)this + 34) != 0LL;
  }
  else {
    BOOL v24 = 0;
  }
  if (*((_BYTE *)this + 283)) {
    int v25 = 1537;
  }
  else {
    int v25 = 2561;
  }
  if (v4) {
    int v26 = open(v5 + 1, 1, 438LL);
  }
  else {
    int v26 = open(v5 + 1, v25, 438LL);
  }
  int v27 = v26;
  if (v26 < 0) {
    __error();
  }
  char v28 = !v24;
  if (v27 == -1) {
    char v28 = 1;
  }
  if ((v28 & 1) != 0)
  {
    if (v27 == -1)
    {
LABEL_60:
      operator delete(v5);
      return 0LL;
    }
  }

  else if (lseek(v27, 0LL, 2) == -1)
  {
    if (close(v27)) {
      __error();
    }
    goto LABEL_60;
  }

  if ((v6 & 1) != 0)
  {
    CFTypeID v29 = CFGetAllocator((char *)this - 16);
    size_t v30 = strlen(v5 + 1);
    CFArrayRef v31 = CFURLCreateFromFileSystemRepresentation(v29, (const UInt8 *)v5 + 1, v30, 0);
    goto LABEL_63;
  }

  char v33 = (const void *)*((void *)this + 25);
  if (v33)
  {
    CFArrayRef v31 = CFRetain(v33);
LABEL_63:
    *((void *)this + 26) = v31;
    if (v31) {
      char v34 = v4;
    }
    else {
      char v34 = 1;
    }
    if ((v34 & 1) == 0)
    {
      uint64_t v35 = *((void *)this + 21);
      if (v35)
      {
        if (*(void *)(v35 + 104))
        {
          CFTypeRef v36 = CFRetain(v31);
          (*(void (**)(char *, CFTypeRef, void))(*((void *)this + 21) + 104LL))( (char *)this - 16,  v36,  *(void *)(*((void *)this + 21) + 8LL));
          if (v36) {
            CFRelease(v36);
          }
        }
      }
    }

    goto LABEL_72;
  }

  *((void *)this + 26) = 0LL;
LABEL_72:
  operator delete(v5);
  uint64_t v37 = (char *)this - 16;
  CFAllocatorRef v38 = CFGetAllocator((char *)this - 16);
  uint64_t v32 = MEMORY[0x186E12804](v38, 48LL, 0LL);
  *(_OWORD *)uint64_t v32 = 0u;
  *(_OWORD *)(v32 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
  *(_OWORD *)(v32 + CFRelease((char *)this - 16) = 0u;
  CFAllocatorRef v39 = CFGetAllocator(v37);
  *(void *)uint64_t v32 = off_189C06BF8;
  *(void *)(v32 + _Block_object_dispose(va, 8) = v39;
  *(_DWORD *)(v32 + CFRelease((char *)this - 16) = 1;
  if (((v32 + 16) & 3) != 0) {
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  }
  *(void *)uint64_t v32 = off_189C07B50;
  *(_DWORD *)(v32 + 20) = v27;
  *(void *)(v32 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = dispatch_queue_create("com.apple.URLDownload", 0LL);
  *(void *)(v32 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0LL;
  if ((fstat(*(_DWORD *)(v32 + 20), __dst) & 0x80000000) == 0) {
    *(void *)(v32 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = __dst[0].st_size;
  }
  ssize_t v40 = fgetxattr(*(_DWORD *)(v32 + 20), "com.apple.ResourceFork", 0LL, 0LL, 0, 0);
  *(void *)(v32 + 40) = v40 & ~(v40 >> 63);
  return v32;
}

void sub_182A80E00(_Unwind_Exception *a1)
{
}

void URLDownload::_internal_downloadFailedWithCFNetworkError(URLDownload *this, CFIndex a2)
{
  int v4 = CFGetAllocator((char *)this - 16);
  CFErrorRef CFError = __cfnCreateCFError(v4, @"kCFErrorDomainCFNetwork", a2, v5, v6, v7, v8, v9, 0LL);
  URLDownload::_internal_downloadCancel(this, CFError);
  if (CFError) {
    CFRelease(CFError);
  }
}

uint64_t ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = AsyncTargetFile::close(*(AsyncTargetFile **)(a1 + 40), (uint64_t *)(v2 + 272));
  (*(void (**)(void))(**(void **)(a1 + 40) + 48LL))(*(void *)(a1 + 40));
  if (v3)
  {
    uint64_t v7 = MEMORY[0x1895F87A8];
    int v4 = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_3;
    uint64_t v5 = &v7;
  }

  else
  {
    uint64_t v8 = MEMORY[0x1895F87A8];
    int v4 = ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_2;
    uint64_t v5 = &v8;
  }

  v5[1] = 3221225472LL;
  void v5[2] = (uint64_t)v4;
  v5[3] = (uint64_t)&__block_descriptor_40_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
  v5[4] = v2;
  return URLDownload::_internal_withClientScheduling(v2, (uint64_t)v5);
}

uint64_t URLDownload::_internal_withClientScheduling(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD **)(a1 + 288);
  if (v4[10])
  {
    uint64_t v5 = (*(uint64_t (**)(_DWORD *))(*(void *)v4 + 88LL))(v4);
  }

  else
  {
    uint64_t v6 = +[NSURLConnection resourceLoaderRunLoop](&OBJC_CLASS___NSURLConnection, "resourceLoaderRunLoop");
    uint64_t v5 = CoreSchedulingSet::create((CoreSchedulingSet *)v6, (const __CFString *)*MEMORY[0x1896051B0], v7);
  }

  uint64_t v8 = v5;
  CFRetain((CFTypeRef)(a1 - 16));
  uint64_t v9 = (unsigned int *)(a1 + 176);
  do
    unsigned int v10 = __ldaxr(v9);
  while (__stlxr(v10 + 1, v9));
  if ((v10 & 0x80000000) != 0) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 168);
  }
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  v13[2] = ___ZN11URLDownload30_internal_withClientSchedulingEU13block_pointerFvP19CFURLDownloadClientE_block_invoke;
  v13[3] = &unk_189C19948;
  void v13[4] = a2;
  v13[5] = a1;
  v13[6] = v11;
  (*(void (**)(uint64_t, void *))(*(void *)v8 + 96LL))(v8, v13);
  return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48LL))(v8);
}

void ___ZN11URLDownload30_internal_withClientSchedulingEU13block_pointerFvP19CFURLDownloadClientE_block_invoke( void *a1)
{
  uint64_t v1 = (URLDownload *)a1[5];
  (*(void (**)(void, void))(a1[4] + 16LL))(a1[4], a1[6]);
  URLDownload::_internal_releaseClient(v1);
  CFRelease((char *)v1 - 16);
}

void ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_3(uint64_t a1)
{
}

void ___ZN11URLDownload28_connection_didFinishLoadingEv_block_invoke_2(uint64_t a1)
{
}

void URLDownload::_internal_downloadFinished(URLDownload *this)
{
  int v2 = URLDownload::_internal_downloadEnded(this);
  uint64_t v3 = *((void *)this + 21);
  if (v3)
  {
    int v4 = *(void (**)(char *, void))(v3 + 112);
    if (v4) {
      v4((char *)this - 16, *(void *)(v3 + 8));
    }
  }

  if (v2)
  {
    URLDownload::_internal_releaseClient(this);
    CFRelease((char *)this - 16);
  }

CFTypeRef URLDownload::_internal_copySuggestedFilenameFromOriginalFilename(URLDownload *this, CFTypeRef cf)
{
  CFTypeRef v3 = CFRetain(cf);
  int v4 = (const __CFArray *)*((void *)this + 32);
  if (!v4) {
    return v3;
  }
  CFIndex Count = CFArrayGetCount(v4);
  if (Count < 1) {
    return v3;
  }
  CFIndex v6 = Count;
  for (CFIndex i = 0LL; i != v6; ++i)
  {
    ValueAtIndex = (char *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), i);
    if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
      dispatch_once( &DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder,  &__block_literal_global_2512);
    }
    if (ValueAtIndex) {
      uint64_t v9 = ValueAtIndex + 16;
    }
    else {
      uint64_t v9 = 0LL;
    }
    unsigned int v10 = v9 - 16;
    uint64_t v11 = (*(uint64_t (**)(char *))(*(void *)v9 + 56LL))(v9);
    CFAllocatorRef v12 = CFGetAllocator(v10);
    uint64_t v13 = (*(uint64_t (**)(uint64_t, CFAllocatorRef, CFTypeRef))(*(void *)v11 + 48LL))(v11, v12, v3);
    if (v3) {
      CFRelease(v3);
    }
    CFTypeRef v3 = (CFTypeRef)v13;
  }

  return (CFTypeRef)v13;
}

void AsyncTargetFile::~AsyncTargetFile(AsyncTargetFile *this)
{
}

{
  uint8_t v2[16];
  *(void *)this = off_189C07B50;
  if (*((_DWORD *)this + 5) != -1 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "you should have closed the file by now",  v2,  2u);
  }

  dispatch_release(*((dispatch_object_t *)this + 3));
}

uint64_t AsyncTargetFile::equals(AsyncTargetFile *this, const CFAllocatedReferenceCountedObject *a2)
{
  return 0LL;
}

uint64_t ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke( uint64_t a1, uint64_t a2, int a3)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  void v5[2] = ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke_2;
  v5[3] = &__block_descriptor_60_e61_v16__0__CFURLDownloadClient_q_v_____________________________8l;
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = a2;
  uint64_t v8 = v3;
  int v9 = a3;
  return URLDownload::_internal_withClientScheduling(v6, (uint64_t)v5);
}

uint64_t ___ZN15AsyncTargetFile5writeEPK8__CFDataS2_U13block_pointerFvmiE_block_invoke(void *a1)
{
  uint64_t v2 = a1[5];
  if (*(_DWORD *)(v2 + 20) != -1)
  {
    uint64_t v3 = (const __CFData *)a1[6];
    if (!v3) {
      goto LABEL_13;
    }
    BytePtr = CFDataGetBytePtr(v3);
    uint64_t v5 = a1[7];
    if (v5 < 1) {
      goto LABEL_13;
    }
    uint64_t v6 = BytePtr;
    uint64_t v7 = &BytePtr[v5];
    do
    {
      while (1)
      {
        ssize_t v8 = write(*(_DWORD *)(v2 + 20), v6, v7 - v6);
        if (v8 == -1) {
          break;
        }
        v6 += v8;
        *(void *)(v2 + 32) += v8;
        if (v6 >= v7) {
          goto LABEL_13;
        }
      }

      int v9 = *__error();
      --v6;
      --*(void *)(v2 + 32);
    }

    while (v6 < v7);
    if (v9)
    {
      if (close(*(_DWORD *)(v2 + 20))) {
        __error();
      }
      *(_DWORD *)(v2 + 20) = -1;
    }

    else
    {
LABEL_13:
      unsigned int v10 = (const __CFData *)a1[8];
      if (v10)
      {
        int v11 = *(_DWORD *)(v2 + 20);
        CFAllocatorRef v12 = CFDataGetBytePtr(v10);
        if (fsetxattr(v11, "com.apple.ResourceFork", v12, a1[9], *(_DWORD *)(v2 + 40), 0))
        {
          if (close(*(_DWORD *)(v2 + 20))) {
            __error();
          }
          *(_DWORD *)(v2 + 20) = -1;
        }

        *(void *)(v2 + 40) += a1[9];
      }
    }
  }

  uint64_t v13 = (const void *)a1[6];
  if (v13) {
    CFRelease(v13);
  }
  CFTypeRef v14 = (const void *)a1[8];
  if (v14) {
    CFRelease(v14);
  }
  (*(void (**)(void))(a1[4] + 16LL))();
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
}

void ___ZN11URLDownload29_internal_downloadProcessDataEPK8__CFData_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 304));
  *(void *)(v2 + 296) -= v3;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 304));
  if (*(_DWORD *)(v2 + 308) && !(*(void *)(v2 + 296) >> 18))
  {
    *(_DWORD *)(v2 + 30_Block_object_dispose(va, 8) = 0;
    CFURLConnectionResume(*(void *)(a1 + 48));
  }

  if (!*(_BYTE *)(v2 + 287))
  {
    if (*(_DWORD *)(a1 + 56))
    {
      uint64_t v5 = CFGetAllocator((CFTypeRef)(v2 - 16));
      CFErrorRef CFError = __cfnCreateCFError(v5, @"kCFErrorDomainCFNetwork", -3003LL, v6, v7, v8, v9, v10, 0LL);
      URLDownload::_internal_downloadCancel((URLDownload *)v2, CFError);
      if (CFError) {
        CFRelease(CFError);
      }
    }

    else
    {
      uint64_t v12 = *(void *)(v2 + 168);
      if (v12)
      {
        uint64_t v13 = *(void (**)(uint64_t, void, void))(v12 + 80);
        if (v13) {
          v13(v2 - 16, *(void *)(a1 + 40), *(void *)(v12 + 8));
        }
      }
    }
  }

  int v4 = *(const void **)(a1 + 48);
  if (v4) {
    CFRelease(v4);
  }
  CFRelease((CFTypeRef)(v2 - 16));
}

void URLDownload::_internal_setResponse(URLDownload *this, _CFURLResponse *a2)
{
  uint64_t v2 = a2;
  int v4 = (_CFURLResponse *)*((void *)this + 23);
  if (v4 != a2)
  {

    uint64_t v2 = v2;
    *((void *)this + 23) = v2;
  }

  if (v2 && ((v5 = *(void *)(-[_CFURLResponse _inner](v2, "_inner") + 88)) != 0 ? (uint64_t v6 = v5 - 16) : (uint64_t v6 = 0LL), v5))
  {
    uint64_t v7 = (HTTPMessage *)(v6 + 16);
    uint64_t v8 = HTTPMessage::copyHeaderFieldValue(v7, 0x12609303u);
    if (v8)
    {
      uint64_t v9 = v8;
      URLDownload::_internal_setEntityTag(this, v8);
      CFRelease(v9);
    }

    uint64_t v10 = HTTPMessage::copyHeaderFieldValue(v7, 0x12E1B32Cu);
    if (v10)
    {
      int v11 = v10;
      URLDownload::_internal_setServerModificationDateString(this, v10);
      CFRelease(v11);
    }
  }

  else
  {
    uint64_t v12 = (const void *)*((void *)this + 29);
    if (v12)
    {
      CFRelease(v12);
      *((void *)this + 29) = 0LL;
    }

    uint64_t v13 = (const void *)*((void *)this + 30);
    if (v13)
    {
      CFRelease(v13);
      *((void *)this + 30) = 0LL;
    }
  }

CFStringRef URLDownload::_internal_setEntityTag(URLDownload *this, const __CFString *a2)
{
  CFStringRef result = (CFStringRef)*((void *)this + 29);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2)
    {
      uint64_t v5 = CFGetAllocator((char *)this - 16);
      CFStringRef result = CFStringCreateCopy(v5, a2);
    }

    else
    {
      CFStringRef result = 0LL;
    }

    *((void *)this + 29) = result;
  }

  return result;
}

CFStringRef URLDownload::_internal_setServerModificationDateString(URLDownload *this, const __CFString *a2)
{
  CFStringRef result = (CFStringRef)*((void *)this + 30);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2)
    {
      uint64_t v5 = CFGetAllocator((char *)this - 16);
      CFStringRef result = CFStringCreateCopy(v5, a2);
    }

    else
    {
      CFStringRef result = 0LL;
    }

    *((void *)this + 30) = result;
  }

  return result;
}

const _CFURLRequest *URLDownload::_internal_setRequest(URLDownload *this, _CFURLRequest *a2)
{
  CFStringRef result = (const _CFURLRequest *)*((void *)this + 3);
  if (result != a2)
  {
    if (result) {
      CFRelease(result);
    }
    if (a2)
    {
      CFGetAllocator((char *)this - 16);
      CFStringRef result = (const _CFURLRequest *)-[_CFURLRequest copy](a2, "copy");
    }

    else
    {
      CFStringRef result = 0LL;
    }

    *((void *)this + 3) = result;
  }

  return result;
}

void ___ZN9TCFObjectI13URLConnectionE5ClassEv_block_invoke_4687()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  qmemcpy(_PNAME<URLConnection>::GET(void)::p, "URLConnection", 13);
  CFClass::CFClass(v0, (const char *)_PNAME<URLConnection>::GET(void)::p);
  TCFObject<URLConnection>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182A817F0(_Unwind_Exception *a1)
{
}

BOOL objectExistsAtURL(CFURLRef url)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v3, url, 0, 0, 1u);
  return v3 && lstat(v4, &v2) == 0;
}

CFDictionaryRef URLDownload::_internal_downloadCreateResumeInfoDictionaryInternal( URLDownload *this, CFAllocatorRef allocator, const __CFURL *a3)
{
  CFNumberRef v6 = CFNumberCreate(allocator, kCFNumberSInt64Type, (char *)this + 272);
  if (v6)
  {
    CFNumberRef v7 = v6;
    CFStringRef v8 = CFURLGetString(a3);
    if (!v8) {
      goto LABEL_34;
    }
    CFStringRef v9 = v8;
    uint64_t v10 = (const __CFArray *)*((void *)this + 32);
    if (v10)
    {
      uint64_t Count = CFArrayGetCount(v10);
      if (Count)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x189605228]);
        if (Mutable)
        {
          if (Count >= 1)
          {
            for (CFIndex i = 0LL; i != Count; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), i);
              if (ValueAtIndex)
              {
                CFIndex v15 = ValueAtIndex;
                if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
                  dispatch_once( &DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder,  &__block_literal_global_2512);
                }
                uint64_t v16 = (*(uint64_t (**)(void *))(v15[2] + 56LL))(v15 + 2);
                CFAllocatorRef v17 = CFGetAllocator(v15);
                CFErrorRef v18 = (const void *)(*(uint64_t (**)(uint64_t, CFAllocatorRef))(*(void *)v16 + 80LL))( v16,  v17);
                if (v18)
                {
                  CFURLRef v19 = v18;
                  CFArrayAppendValue(Mutable, v18);
                  CFRelease(v19);
                }
              }
            }
          }

          if (Count == CFArrayGetCount(Mutable))
          {
            LOBYTE(Count) = 0;
            goto LABEL_22;
          }

          CFRelease(Mutable);
          CFMutableArrayRef Mutable = 0LL;
        }

        LOBYTE(Count) = 1;
LABEL_22:
        if (!*((void *)this + 28)
          || (uint64_t v21 = *(const void **)([*((id *)this + 3) _inner] + 32)) != 0
          && CFEqual(*((CFTypeRef *)this + 28), v21))
        {
          CFStringRef v22 = 0LL;
          if ((Count & 1) != 0) {
            goto LABEL_34;
          }
        }

        else
        {
          CFStringRef v22 = CFURLGetString(*((CFURLRef *)this + 28));
          if ((Count & 1) != 0) {
            goto LABEL_34;
          }
        }

        uint64_t v23 = CFDictionaryCreateMutable(allocator, 6LL, MEMORY[0x189604E40], MEMORY[0x189605250]);
        if (v23)
        {
          BOOL v24 = v23;
          CFDictionarySetValue(v23, @"NSURLDownloadURL", v9);
          CFDictionarySetValue(v24, @"NSURLDownloadBytesReceived", v7);
          CFDictionarySetValue(v24, @"NSURLDownloadServerModificationDate", *((const void **)this + 30));
          CFDictionarySetValue(v24, @"NSURLDownloadEntityTag", *((const void **)this + 29));
          if (v22) {
            CFDictionarySetValue(v24, @"NSURLDownloadOriginatingURLString", v22);
          }
          if (Mutable) {
            CFDictionarySetValue(v24, @"NSURLDownloadDecoders", Mutable);
          }
          CFDictionaryRef Copy = CFDictionaryCreateCopy(allocator, v24);
          CFRelease(v24);
          goto LABEL_35;
        }

CFDictionaryRef URLDownload::createResumeInformation(URLDownload *this, const __CFAllocator *a2)
{
  uint64_t v4 = [*((id *)this + 3) _inner];
  uint64_t v5 = *(const __CFURL **)(v4 + 8);
  if (v5)
  {
    CFStringRef v6 = CFURLCopyScheme(*(CFURLRef *)(v4 + 8));
    if (v6)
    {
      CFNumberRef v7 = v6;
      CFStringRef v8 = (const __CFArray *)*((void *)this + 32);
      if (v8 && (CFIndex Count = CFArrayGetCount(v8)) != 0)
      {
        CFIndex v10 = Count;
        if (Count < 1)
        {
          CFIndex v11 = 0LL;
        }

        else
        {
          CFIndex v11 = 0LL;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 32), v11);
            if (ValueAtIndex)
            {
              uint64_t v13 = ValueAtIndex;
              if (DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder != -1) {
                dispatch_once( &DownloadDataDecoderHolder::Class(void)::sOnce_DownloadDataDecoderHolder,  &__block_literal_global_2512);
              }
              uint64_t v14 = (*(uint64_t (**)(void *))(v13[2] + 56LL))(v13 + 2);
            }

            if (v10 == ++v11)
            {
              CFIndex v11 = v10;
              break;
            }
          }
        }

        BOOL v16 = v11 == v10;
      }

      else
      {
        BOOL v16 = 1;
      }

      if (!*((_BYTE *)this + 282) && !*((_BYTE *)this + 284) && *((void *)this + 29))
      {
        CFDictionaryRef ResumeInfoDictionaryInternal = 0LL;
        if (!v16 || !*((void *)this + 30)) {
          goto LABEL_20;
        }
        if (CFStringCompare(v7, @"http", 1uLL) == kCFCompareEqualTo
          || CFStringCompare(v7, (CFStringRef)&unk_18C5B2B50, 1uLL) == kCFCompareEqualTo)
        {
          CFErrorRef v18 = (const __CFString *)CFURLRequestCopyHTTPRequestMethod(*((void **)this + 3));
          if (v18)
          {
            CFURLRef v19 = v18;
            if (CFStringCompare(v18, @"GET", 1uLL)) {
              CFDictionaryRef ResumeInfoDictionaryInternal = 0LL;
            }
            else {
              CFDictionaryRef ResumeInfoDictionaryInternal = URLDownload::_internal_downloadCreateResumeInfoDictionaryInternal( this,  a2,  v5);
            }
            CFRelease(v19);
            goto LABEL_20;
          }
        }
      }

      CFDictionaryRef ResumeInfoDictionaryInternal = 0LL;
LABEL_20:
      CFRelease(v7);
      return ResumeInfoDictionaryInternal;
    }
  }

  return 0LL;
}

void URLDownload::useCredential(URLDownload *this, const _CFURLCredential *a2, CFTypeRef cf2)
{
  if (cf2)
  {
    uint64_t v4 = (const void *)*((void *)this + 24);
    if (v4)
    {
      if (CFEqual(v4, cf2))
      {
        CFRelease(*((CFTypeRef *)this + 24));
        *((void *)this + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
        CFURLConnectionUseCredential(*((void *)this + 2), (uint64_t)a2, (uint64_t)cf2);
      }
    }
  }

uint64_t _CFURLCreateDataAndPropertiesFromResource(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1895F8858](a1);
  char v3 = v2;
  uint64_t v5 = v4;
  CFNumberRef v7 = v6;
  CFStringRef v9 = v8;
  CFIndex v11 = v10;
  uint64_t v12 = (const __CFAllocator *)v1;
  valuePtr[4500] = *MEMORY[0x1895F89C0];
  uint64_t v13 = CFURLCopyScheme(v10);
  if (v13)
  {
    uint64_t v14 = v13;
    if (CFStringCompare(v13, @"http", 1uLL) && CFStringCompare(v14, (CFStringRef)&unk_18C5B2B50, 1uLL))
    {
      if (CFStringCompare(v14, @"ftp", 1uLL))
      {
        if (v9) {
          *CFStringRef v9 = 0LL;
        }
        if (v7) {
          CFMutableDictionaryRef *v7 = 0LL;
        }
        if (v3)
        {
          unsigned __int8 v15 = 0;
          int v16 = -11;
LABEL_69:
          *char v3 = v16;
LABEL_81:
          CFRelease(v14);
          return v15;
        }

        goto LABEL_70;
      }

      if (v7) {
        CFMutableDictionaryRef *v7 = 0LL;
      }
      if (!v9)
      {
        if (v3)
        {
          unsigned __int8 v15 = 0;
          int v16 = -15;
          goto LABEL_69;
        }

        goto LABEL_70;
      }

      *CFStringRef v9 = CFDataCreateMutable(v12, 0LL);
      uint64_t v35 = CFReadStreamCreateWithFTPURL(v12, v11);
      CFReadStreamSetProperty( v35,  @"kCFStreamPropertyFTPAttemptPersistentConnection",  (CFTypeRef)*MEMORY[0x189604DE0]);
      if (CFReadStreamOpen(v35))
      {
        while (1)
        {
          uint64_t v36 = CFReadStreamRead(v35, (UInt8 *)valuePtr, 36000LL);
          if (v36 < 1) {
            break;
          }
          CFDataAppendBytes(*v9, (const UInt8 *)valuePtr, v36);
        }

        CFReadStreamClose(v35);
      }

      CFStreamError Error = CFReadStreamGetError(v35);
      if (v3)
      {
        *char v3 = Error.error;
        CFRelease(v35);
        if (!*v3) {
          goto LABEL_74;
        }
LABEL_72:
        CFRelease(*v9);
        unsigned __int8 v15 = 0;
        *CFStringRef v9 = 0LL;
        goto LABEL_81;
      }

      CFRelease(v35);
      if (Error.error) {
        goto LABEL_72;
      }
LABEL_74:
      unsigned __int8 v15 = 1;
      goto LABEL_81;
    }

    if (v3) {
      *char v3 = 0;
    }
    if (v9)
    {
      CFAllocatorRef v17 = &kCFHTTPMethodGet;
    }

    else
    {
      if (!v7) {
        goto LABEL_74;
      }
      if (v5 && !CFArrayGetCount(v5))
      {
        CFMutableDictionaryRef *v7 = 0LL;
        goto LABEL_74;
      }

      CFAllocatorRef v17 = &kCFHTTPMethodHead;
    }

    Request = CFHTTPMessageCreateRequest(v12, (CFStringRef)*v17, v11, @"HTTP/1.0");
    CFURLRef v19 = _CFHTTPMessageSendRequest(Request);
    uint64_t v20 = Request;
    uint64_t v21 = v19;
    CFRelease(v20);
    if (!v21)
    {
      if (v9) {
        *CFStringRef v9 = 0LL;
      }
      if (v7) {
        CFMutableDictionaryRef *v7 = 0LL;
      }
      if (v3)
      {
        unsigned __int8 v15 = 0;
        int v16 = -14;
        goto LABEL_69;
      }

__CFHTTPMessage *_CFHTTPMessageSendRequest(__CFHTTPMessage *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  stat v2 = CFGetAllocator(a1);
  *(void *)CFStringInlineBuffer buffer = MEMORY[0x1895F87A8];
  uint64_t v15 = 3221225472LL;
  int v16 = __CFReadStreamCreateForHTTPRequest_block_invoke;
  CFAllocatorRef v17 = &__block_descriptor_48_e26__v16__0____CFReadStream__8l;
  CFErrorRef v18 = v2;
  CFURLRef v19 = a1;
  char v3 = (__CFReadStream *)CFReadStreamCreate();
  CFWriteStreamRef v4 = CFWriteStreamCreateWithAllocatedBuffers(v2, v2);
  uint64_t v5 = v4;
  if (v3 && v4)
  {
    CFReadStreamSetProperty(v3, (CFStreamPropertyKey)&unk_18C5B0D58, (CFTypeRef)*MEMORY[0x189604DE8]);
    if (!CFReadStreamOpen(v3) || !CFWriteStreamOpen(v5)) {
      goto LABEL_18;
    }
    CFStreamStatus Status = CFReadStreamGetStatus(v3);
    while ((Status | 2) != 7)
    {
      uint64_t v7 = CFReadStreamRead(v3, buffer, 512LL);
      BOOL v8 = v7 >= 1 && CFWriteStreamWrite(v5, buffer, v7) != v7;
      CFStreamStatus Status = CFReadStreamGetStatus(v3);
      if (v8)
      {
        CFReadStreamClose(v3);
        CFWriteStreamClose(v5);
        goto LABEL_18;
      }
    }

    CFStreamStatus v10 = CFReadStreamGetStatus(v3);
    CFReadStreamClose(v3);
    CFWriteStreamClose(v5);
    if (v10 != kCFStreamStatusError)
    {
      uint64_t v12 = (const __CFData *)CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1896051D0]);
      uint64_t v13 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v3, @"kCFStreamPropertyHTTPResponseHeader");
      CFStringRef v9 = v13;
      if (v13) {
        CFHTTPMessageSetBody(v13, v12);
      }
      if (v12) {
        CFRelease(v12);
      }
    }

    else
    {
LABEL_18:
      CFStringRef v9 = 0LL;
    }

    CFRelease(v3);
    CFRelease(v5);
  }

  else
  {
    if (v3) {
      CFRelease(v3);
    }
    if (v5) {
      CFRelease(v5);
    }
    return 0LL;
  }

  return v9;
}

unint64_t _CFURLWriteDataAndPropertiesToResource( const __CFURL *a1, const __CFData *a2, const __CFDictionary *a3, SInt32 *a4)
{
  BOOL v8 = CFURLCopyScheme(a1);
  if (v8)
  {
    CFStringRef v9 = v8;
    if (CFStringCompare(v8, @"http", 1uLL) && CFStringCompare(v9, (CFStringRef)&unk_18C5B2B50, 1uLL))
    {
      if (CFStringCompare(v9, @"ftp", 1uLL))
      {
        if (a4)
        {
          unint64_t v10 = 0LL;
          int v11 = -11;
          goto LABEL_39;
        }

CFTypeID _ApplyWriteStreamProperties(const __CFString *a1, const void *a2, __CFWriteStream *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  CFTypeID result = CFStringGetTypeID();
  if (v6 == result) {
    return CFWriteStreamSetProperty(a3, a1, a2);
  }
  return result;
}

unint64_t _CFURLDestroyResource(const __CFURL *a1, SInt32 *a2)
{
  CFWriteStreamRef v4 = CFURLCopyScheme(a1);
  if (v4)
  {
    uint64_t v5 = v4;
    if (CFStringCompare(v4, @"http", 1uLL) && CFStringCompare(v5, (CFStringRef)&unk_18C5B2B50, 1uLL))
    {
      if (CFStringCompare(v5, @"ftp", 1uLL) == kCFCompareEqualTo)
      {
        int v11 = CFGetAllocator(a1);
        uint64_t v12 = CFWriteStreamCreateWithFTPURL(v11, a1);
        CFWriteStreamSetProperty( v12,  @"kCFStreamPropertyFTPAttemptPersistentConnection",  (CFTypeRef)*MEMORY[0x189604DE0]);
        CFWriteStreamSetProperty(v12, @"_kCFStreamPropertyFTPRemoveResource", (CFTypeRef)*MEMORY[0x189604DE8]);
        if (CFWriteStreamOpen(v12))
        {
          UInt8 buffer = 0;
          CFWriteStreamWrite(v12, &buffer, 1LL);
          CFWriteStreamClose(v12);
        }

        CFStreamError Error = CFWriteStreamGetError(v12);
        SInt32 v14 = Error.error;
        if (a2)
        {
          *a2 = Error.error;
          CFRelease(v12);
          SInt32 v14 = *a2;
        }

        else
        {
          CFRelease(v12);
        }

        unint64_t v6 = v14 == 0;
        goto LABEL_24;
      }

      unint64_t v6 = 0LL;
      if (a2)
      {
        int v7 = -11;
LABEL_17:
        *a2 = v7;
      }
    }

    else
    {
      BOOL v8 = CFGetAllocator(a1);
      Request = CFHTTPMessageCreateRequest(v8, @"DELETE", a1, @"HTTP/1.0");
      unint64_t v6 = (unint64_t)_CFHTTPMessageSendRequest(Request);
      CFRelease(Request);
      if (v6)
      {
        int ResponseStatusCode = CFHTTPMessageGetResponseStatusCode((CFHTTPMessageRef)v6);
        CFRelease((CFTypeRef)v6);
        unint64_t v6 = (ResponseStatusCode - 200) < 0x64;
        else {
          int v7 = 0;
        }
        if (!a2) {
          goto LABEL_24;
        }
        goto LABEL_17;
      }

      if (a2)
      {
        int v7 = -14;
        goto LABEL_17;
      }
    }

os_log_t __CFNLog_block_invoke()
{
  os_log_t result = os_log_create("com.apple.CFNetwork", "Default");
  CFNLog::logger = (uint64_t)result;
  return result;
}

uint64_t __CFNIsMachServiceReachable(char *service_name)
{
  if (bootstrap_look_up(*MEMORY[0x1895F9630], service_name, &sp)) {
    BOOL v1 = 1;
  }
  else {
    BOOL v1 = sp == 0;
  }
  if (v1) {
    return 0LL;
  }
  mach_port_deallocate(*MEMORY[0x1895FBBE0], sp);
  return 1LL;
}

CFStringRef _CFNetworkCFStringCreateWithCFDataAddress(const __CFData *a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  BytePtr = (const sockaddr *)CFDataGetBytePtr(a1);
  socklen_t Length = CFDataGetLength(a1);
  int v4 = getnameinfo(BytePtr, Length, cStr, 0x401u, 0LL, 0, 2);
  CFStringRef result = 0LL;
  if (!v4) {
    return CFStringCreateWithCString(0LL, cStr, 0x600u);
  }
  return result;
}

char *_CFGregorianDateCreateWithBytes( const __CFAllocator *a1, char *a2, uint64_t a3, CFGregorianDate *a4, CFTypeRef *a5)
{
  uint64_t v7 = a2;
  uint64_t v93 = *MEMORY[0x1895F89C0];
  if (a3 >= 255) {
    size_t v8 = 255LL;
  }
  else {
    size_t v8 = a3;
  }
  memcpy(__dst, a2, v8);
  __dst[v8] = 0;
  *(void *)&a4->int year = 0LL;
  a4->double second = 0.0;
  if (a5) {
    *a5 = 0LL;
  }
  uint64_t v9 = 0LL;
  uint64_t v10 = MEMORY[0x1895F8770];
  while (1)
  {
    int v11 = __dst[v9];
    uint64_t v12 = __dst[v9];
    if (v11 < 0) {
      break;
    }
    if ((*(_DWORD *)(v10 + 4 * v12 + 60) & 0x4000) == 0) {
      goto LABEL_12;
    }
LABEL_11:
    ++v9;
  }

uint64_t _CFGregorianDateCreateWithString( const __CFAllocator *a1, CFStringRef theString, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  v12.CFIndex length = CFStringGetLength(theString);
  CFIndex usedBufLen = v12.length;
  v12.CFIndex location = 0LL;
  CFStringGetBytes(theString, v12, 0x600u, 0, 0, buffer, 256LL, &usedBufLen);
  if (usedBufLen) {
    return _CFGregorianDateCreateWithBytes(a1, (char *)buffer, usedBufLen, (CFGregorianDate *)a3, a4) - (char *)buffer;
  }
  *(void *)a3 = 0LL;
  *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t result = 0LL;
  if (a4) {
    *a4 = 0LL;
  }
  return result;
}

CFStringRef _CFStringCreateRFC1123DateStringWithGregorianDate( const __CFAllocator *a1, CFGregorianDate *a2, CFTimeZoneRef tz)
{
  if (tz)
  {
    CFTimeInterval SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, 0.0);
    uint64_t v6 = ((int)SecondsFromGMT / 3600);
    int v7 = (int)SecondsFromGMT % 3600;
    if (v7 >= 0) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = -v7;
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    uint64_t v6 = 0LL;
  }

  if (CFGregorianDateIsValid(*a2, 0xFFFFFFuLL)) {
    return CFStringCreateWithFormat( a1,  0LL,  @"%02d %s %04d %02d:%02d:%02d %+03d%02d",  a2->day,  kMonthStrs[a2->month + 11],  a2->year,  a2->hour,  a2->minute,  (int)a2->second,  v6,  v8);
  }
  else {
    return 0LL;
  }
}

CFStringRef _CFStringCreateRFC2616DateStringWithGregorianDate( const __CFAllocator *a1, CFGregorianDate *a2, const __CFTimeZone *a3)
{
  if (!CFGregorianDateIsValid(*a2, 0xFFFFFFuLL)) {
    return 0LL;
  }
  CFAbsoluteTime AbsoluteTime = CFGregorianDateGetAbsoluteTime(*a2, a3);
  SInt32 DayOfWeek = CFAbsoluteTimeGetDayOfWeek(AbsoluteTime, 0LL);
  return CFStringCreateWithFormat( a1,  0LL,  @"%s, %02d %s %04d %02d:%02d:%02d GMT",  kDayStrs[DayOfWeek + 6],  a2->day,  kMonthStrs[a2->month + 11],  a2->year,  a2->hour,  a2->minute,  (int)a2->second);
}

CFURLRef cfnCreateSemiColonEscapedURLIfParamterIsPresent(const __CFURL *a1)
{
  if (CFURLGetByteRangeForComponent(a1, kCFURLComponentParameterString, 0LL).location == -1) {
    return 0LL;
  }
  stat v2 = CFURLGetString(a1);
  if (!v2) {
    return 0LL;
  }
  char v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  int v4 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x189604DB0], v2, 0LL, @";", 0x8000100u);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  CFURLRef v6 = CFURLCreateWithString(v3, v4, 0LL);
  CFRelease(v5);
  return v6;
}

void __CFNetworkLogForAuthTimeoutIssueSync(uint64_t a1)
{
  if (__CFNetworkLogForAuthTimeoutIssueSync::sCheckDefault != -1) {
    dispatch_once(&__CFNetworkLogForAuthTimeoutIssueSync::sCheckDefault, &__block_literal_global_60_4856);
  }
  if (__CFNetworkLogForAuthTimeoutIssueSync::shouldLog) {
    (*(void (**)(uint64_t))(a1 + 16))(a1);
  }
}

const void *_CFNetworkErrorGetLocalizedDescription(uint64_t a1)
{
  return _CFNetworkErrorGetLocalizedString(a1, 0LL);
}

const void *_CFNetworkErrorGetLocalizedString(uint64_t a1, CFIndex a2)
{
  uint64_t valuePtr = a1;
  pthread_once( &_CFNetworkErrorInitLocalizedDescriptionsDictionaryControl,  (void (*)(void))_CFNetworkErrorInitLocalizedStringsDictionary);
  CFNumberRef v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberCFIndexType, &valuePtr);
  int Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_CFNetworkErrorLocalizedDescriptionsDict, v3);
  if (v3) {
    CFRelease(v3);
  }
  if (!Value) {
    return 0LL;
  }
  uint64_t result = CFArrayGetValueAtIndex(Value, a2);
  return result;
}

void _CFNetworkErrorInitLocalizedStringsDictionary( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const __CFString *a9)
{
  if (!_CFNetworkErrorLocalizedDescriptionsDict)
  {
    _CFNetworkErrorLocalizedDescriptionsDict = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    _CFNetworkErrorMapErrorCode( 306LL,  @"Err306",  @"There was a problem communicating with the web proxy server (HTTP).",  0LL,  0LL,  @"Please check your proxy settings. For help with this problem, contact your system administrator.",  @"Please check your proxy settings. For help with this problem, contact your system administrator.",  v9,  v59);
    _CFNetworkErrorMapErrorCode( 310LL,  @"Err310",  @"There was a problem communicating with the secure web proxy server (HTTPS).",  0LL,  0LL,  @"Please check your proxy settings. For help with this problem, contact your system administrator.",  @"Please check your proxy settings. For help with this problem, contact your system administrator.",  v10,  v60);
    _CFNetworkErrorMapErrorCode( 311LL,  @"Err311",  @"There was a problem establishing a secure tunnel through the web proxy server.",  0LL,  0LL,  @"Please check your proxy settings. For help with this problem, contact your system administrator.",  @"Please check your proxy settings. For help with this problem, contact your system administrator.",  v11,  v61);
    _CFNetworkErrorMapErrorCode( -996LL,  @"Err-996",  @"Could not communicate with background transfer service",  0LL,  0LL,  0LL,  0LL,  v12,  v62);
    _CFNetworkErrorMapErrorCode( -997LL,  @"Err-997",  @"Lost connection to background transfer service",  0LL,  0LL,  0LL,  0LL,  v13,  v63);
    _CFNetworkErrorMapErrorCode(-1LL, @"Err-998", @"unknown error", 0LL, 0LL, 0LL, 0LL, v14, v64);
    _CFNetworkErrorMapErrorCode(-998LL, @"Err-998", @"unknown error", 0LL, 0LL, 0LL, 0LL, v15, v65);
    _CFNetworkErrorMapErrorCode(-999LL, @"Err-999", @"cancelled", 0LL, 0LL, 0LL, 0LL, v16, v66);
    _CFNetworkErrorMapErrorCode(-1000LL, @"Err-1000", @"bad URL", 0LL, 0LL, 0LL, 0LL, v17, v67);
    _CFNetworkErrorMapErrorCode( -1001LL,  @"Err-1001",  @"The request timed out.",  0LL,  0LL,  0LL,  0LL,  v18,  v68);
    _CFNetworkErrorMapErrorCode(-1002LL, @"Err-1002", @"unsupported URL", 0LL, 0LL, 0LL, 0LL, v19, v69);
    _CFNetworkErrorMapErrorCode( -1003LL,  @"Err-1003",  @"A server with the specified hostname could not be found.",  0LL,  0LL,  0LL,  0LL,  v20,  v70);
    _CFNetworkErrorMapErrorCode( -1004LL,  @"Err-1004",  @"Could not connect to the server.",  0LL,  0LL,  0LL,  0LL,  v21,  v71);
    _CFNetworkErrorMapErrorCode( -1005LL,  @"Err-1005",  @"The network connection was lost.",  0LL,  0LL,  0LL,  0LL,  v22,  v72);
    _CFNetworkErrorMapErrorCode(-1006LL, @"Err-1006", @"DNS lookup error", 0LL, 0LL, 0LL, 0LL, v23, v73);
    _CFNetworkErrorMapErrorCode( -1007LL,  @"Err-1007",  @"too many HTTP redirects",  0LL,  0LL,  0LL,  0LL,  v24,  v74);
    _CFNetworkErrorMapErrorCode(-1008LL, @"Err-1008", @"resource unavailable", 0LL, 0LL, 0LL, 0LL, v25, v75);
    _CFNetworkErrorMapErrorCode( -1009LL,  @"Err-1009",  @"The Internet connection appears to be offline.",  0LL,  0LL,  0LL,  0LL,  v26,  v76);
    _CFNetworkErrorMapErrorCode( -1010LL,  @"Err-1010",  @"redirected to nowhere",  0LL,  0LL,  0LL,  0LL,  v27,  v77);
    _CFNetworkErrorMapErrorCode( -1011LL,  @"Err-1011",  @"There was a bad response from the server.",  0LL,  0LL,  0LL,  0LL,  v28,  v78);
    _CFNetworkErrorMapErrorCode(-1014LL, @"Err-1014", @"zero byte resource", 0LL, 0LL, 0LL, 0LL, v29, v79);
    _CFNetworkErrorMapErrorCode( -1015LL,  @"Err-1015",  @"cannot decode raw data",  0LL,  0LL,  0LL,  0LL,  v30,  v80);
    _CFNetworkErrorMapErrorCode( -1016LL,  @"Err-1016",  @"cannot decode content data",  0LL,  0LL,  0LL,  0LL,  v31,  v81);
    _CFNetworkErrorMapErrorCode( -1017LL,  @"Err-1017",  @"cannot parse response",  0LL,  0LL,  0LL,  0LL,  v32,  v82);
    _CFNetworkErrorMapErrorCode( -1018LL,  @"Err-1018",  @"International roaming is currently off.",  0LL,  0LL,  0LL,  0LL,  v33,  v83);
    _CFNetworkErrorMapErrorCode( -1019LL,  @"Err-1019",  @"A data connection cannot be established since a call is currently active.",  0LL,  0LL,  0LL,  0LL,  v34,  v84);
    _CFNetworkErrorMapErrorCode( -1020LL,  @"Err-1020",  @"A data connection is not currently allowed.",  0LL,  0LL,  0LL,  0LL,  v35,  v85);
    _CFNetworkErrorMapErrorCode( -1021LL,  @"Err-1021",  @"request body stream exhausted",  0LL,  0LL,  0LL,  0LL,  v36,  v86);
    _CFNetworkErrorMapErrorCode( -1022LL,  @"Err-1022",  @"The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.",  0LL,  0LL,  0LL,  0LL,  v37,  v87);
    _CFNetworkErrorMapErrorCode( -1100LL,  @"Err-1100",  @"The requested URL was not found on this server.",  0LL,  0LL,  0LL,  0LL,  v38,  v88);
    _CFNetworkErrorMapErrorCode(-1101LL, @"Err-1101", @"file is directory", 0LL, 0LL, 0LL, 0LL, v39, v89);
    _CFNetworkErrorMapErrorCode( -1102LL,  @"Err-1102",  @"You do not have permission to access the requested resource.",  0LL,  0LL,  0LL,  0LL,  v40,  v90);
    _CFNetworkErrorMapErrorCode( -1103LL,  @"Err-1103",  @"resource exceeds maximum size",  0LL,  0LL,  0LL,  0LL,  v41,  v91);
    _CFNetworkErrorMapErrorCode( -1104LL,  @"Err-1104",  @"file is outside of the safe area",  0LL,  0LL,  0LL,  0LL,  v42,  v92);
    _CFNetworkErrorMapErrorCode( -1200LL,  @"Err-1200",  @"An SSL error has occurred and a secure connection to the server cannot be made.",  0LL,  0LL,  @"Would you like to connect to the server anyway?",  @"Would you like to connect to the server anyway?",  v43,  v93);
    _CFNetworkErrorMapErrorCode( -1201LL,  @"Err-1201",  @"The certificate for this server has expired.",  @"Err-1201.w",  @"The certificate for this server has expired. You might be connecting to a server that is pretending to be %@ which could put your confidential information at risk.",  @"Would you like to connect to the server anyway?",  @"Would you like to connect to the server anyway?",  v44,  v94);
    _CFNetworkErrorMapErrorCode( -1202LL,  @"Err-1202",  @"The certificate for this server is invalid.",  @"Err-1202.w",  @"The certificate for this server is invalid. You might be connecting to a server that is pretending to be %@ which could put your confidential information at risk.",  @"Would you like to connect to the server anyway?",  @"Would you like to connect to the server anyway?",  v45,  v95);
    _CFNetworkErrorMapErrorCode( -1203LL,  @"Err-1203",  @"The certificate for this server was signed by an unknown certifying authority.",  @"Err-1203.w",  @"The certificate for this server was signed by an unknown certifying authority. You might be connecting to a server that is pretending to be %@ which could put your confidential information at risk.",  @"Would you like to connect to the server anyway?",  @"Would you like to connect to the server anyway?",  v46,  v96);
    _CFNetworkErrorMapErrorCode( -1204LL,  @"Err-1204",  @"The certificate for this server is not yet valid.",  @"Err-1204.w",  @"The certificate for this server is not yet valid. You might be connecting to a server that is pretending to be %@ which could put your confidential information at risk.",  @"Would you like to connect to the server anyway?",  @"Would you like to connect to the server anyway?",  v47,  v97);
    _CFNetworkErrorMapErrorCode( -1205LL,  @"Err-1205",  @"The server did not accept the certificate.",  @"Err-1205.w",  @"The server %@ did not accept the certificate.",  0LL,  0LL,  v48,  v98);
    _CFNetworkErrorMapErrorCode( -1206LL,  @"Err-1206",  @"The server requires a client certificate.",  @"Err-1206.w",  @"The server %@ requires a client certificate.",  0LL,  0LL,  v49,  v99);
    _CFNetworkErrorMapErrorCode( -2000LL,  @"Err-2000",  @"can't load from network",  0LL,  0LL,  0LL,  0LL,  v50,  v100);
    _CFNetworkErrorMapErrorCode(-3000LL, @"Err-3000", @"Cannot create file", 0LL, 0LL, 0LL, 0LL, v51, v101);
    _CFNetworkErrorMapErrorCode(-3001LL, @"Err-3001", @"Cannot open file", 0LL, 0LL, 0LL, 0LL, v52, v102);
    _CFNetworkErrorMapErrorCode( -3002LL,  @"Err-3002",  @"Failure occurred while closing file",  0LL,  0LL,  0LL,  0LL,  v53,  v103);
    _CFNetworkErrorMapErrorCode(-3003LL, @"Err-3003", @"Cannot write file", 0LL, 0LL, 0LL, 0LL, v54, v104);
    _CFNetworkErrorMapErrorCode(-3004LL, @"Err-3004", @"Cannot remove file", 0LL, 0LL, 0LL, 0LL, v55, v105);
    _CFNetworkErrorMapErrorCode(-3005LL, @"Err-3005", @"Cannot move file", 0LL, 0LL, 0LL, 0LL, v56, v106);
    _CFNetworkErrorMapErrorCode( -3006LL,  @"Err-3006",  @"Download decoding failed",  0LL,  0LL,  0LL,  0LL,  v57,  v107);
    _CFNetworkErrorMapErrorCode( -3007LL,  @"Err-3007",  @"Download decoding failed",  0LL,  0LL,  0LL,  0LL,  v58,  a9);
  }

void _CFNetworkErrorMapErrorCode( uint64_t a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, const __CFString *a8, const __CFString *a9)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v26 = a1;
  CFNumberRef v15 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v26);
  uint64_t v16 = (const void **)MEMORY[0x189605018];
  if (a2)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4714);
    }
    uint64_t v17 = (__CFString *)CFBundleCopyLocalizedString( (CFBundleRef)__CFNGetCFNetworkBundle::bundle,  a2,  a3,  @"Localizable");
  }

  else
  {
    uint64_t v17 = (__CFString *)*MEMORY[0x189605018];
  }

  values = v17;
  if (a4)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4714);
    }
    CFStringRef v18 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, a4, a5, @"Localizable");
    CFURLRef v19 = (const __CFString *)*v16;
  }

  else
  {
    CFURLRef v19 = (const __CFString *)*v16;
    CFStringRef v18 = (CFStringRef)*v16;
  }

  CFTypeRef cf = v18;
  CFTypeRef v29 = v19;
  CFStringRef v20 = v19;
  if (a6)
  {
    if (__CFNGetCFNetworkBundle::onceToken != -1) {
      dispatch_once(&__CFNGetCFNetworkBundle::onceToken, &__block_literal_global_4714);
    }
    CFStringRef v20 = CFBundleCopyLocalizedString((CFBundleRef)__CFNGetCFNetworkBundle::bundle, a6, a7, @"Localizable");
  }

  CFTypeRef v30 = v20;
  CFArrayRef v21 = CFArrayCreate(0LL, (const void **)&values, 4LL, MEMORY[0x189605228]);
  if (values != v19 && values != 0LL) {
    CFRelease(values);
  }
  if (cf != v19 && cf != 0LL) {
    CFRelease(cf);
  }
  if (v29 != v19 && v29 != 0LL) {
    CFRelease(v29);
  }
  if (v30 != v19 && v30 != 0LL) {
    CFRelease(v30);
  }
  CFDictionaryAddValue((CFMutableDictionaryRef)_CFNetworkErrorLocalizedDescriptionsDict, v15, v21);
  if (v15) {
    CFRelease(v15);
  }
  if (v21) {
    CFRelease(v21);
  }
}

CFMutableStringRef _CFNetworkErrorCopyLocalizedDescriptionWithHostname(uint64_t a1, const __CFString *a2)
{
  if (a2 && (int v4 = (const __CFString *)_CFNetworkErrorGetLocalizedString(a1, 1LL)) != 0LL)
  {
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v4);
    v8.CFIndex length = CFStringGetLength(MutableCopy);
    v8.CFIndex location = 0LL;
    CFStringFindAndReplace(MutableCopy, @"%@", a2, v8, 0LL);
  }

  else
  {
    LocalizedString = _CFNetworkErrorGetLocalizedString(a1, 0LL);
    if (LocalizedString) {
      return (CFMutableStringRef)CFRetain(LocalizedString);
    }
    return 0LL;
  }

  return MutableCopy;
}

const void *_CFNetworkErrorGetLocalizedFailureReason(uint64_t a1)
{
  return _CFNetworkErrorGetLocalizedString(a1, 2LL);
}

const void *_CFNetworkErrorGetLocalizedRecoverySuggestion(uint64_t a1)
{
  return _CFNetworkErrorGetLocalizedString(a1, 3LL);
}

CFErrorRef __cfnCreateCFError( CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  size_t v22 = &a9;
  unint64_t v12 = -1LL;
  do
  {
    uint64_t v13 = v22++;
    ++v12;
  }

  while (*v13);
  if (v12 <= 3) {
    return CFErrorCreate(allocator, domain, code, 0LL);
  }
  unint64_t v14 = v12 >> 1;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(allocator, v12 >> 1, MEMORY[0x189604E40], MEMORY[0x189605250]);
  uint64_t v23 = (const void **)&a9;
  if (v14 <= 1) {
    unint64_t v14 = 1LL;
  }
  while (1)
  {
    uint64_t v16 = v23;
    uint64_t v17 = *v23;
    v23 += 2;
    CFStringRef v18 = v16[1];
    if (!v17 || v18 == 0LL) {
      break;
    }
    CFDictionarySetValue(Mutable, v17, v18);
    if (!--v14) {
      goto LABEL_14;
    }
  }

  CFRelease(Mutable);
  CFMutableArrayRef Mutable = 0LL;
LABEL_14:
  CFErrorRef v20 = CFErrorCreate(allocator, domain, code, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v20;
}

CFErrorRef __cfnCreateCFErrorWithStreamError(CFAllocatorRef alloc, int *valuePtr)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)valuePtr;
  if (*(void *)valuePtr == 2LL) {
    goto LABEL_5;
  }
  if (v4 == 1)
  {
    uint64_t v5 = 0LL;
    CFURLRef v6 = (const __CFString **)MEMORY[0x189604F58];
    goto LABEL_6;
  }

  if (v4 == *MEMORY[0x1896051C0])
  {
LABEL_5:
    uint64_t v5 = 0LL;
    CFURLRef v6 = (const __CFString **)MEMORY[0x189604F50];
LABEL_6:
    int v7 = *v6;
LABEL_7:
    CFIndex v8 = valuePtr[2];
    goto LABEL_8;
  }

  if (v4 == 15)
  {
    uint64_t v5 = 0LL;
    CFIndex v8 = valuePtr[2];
LABEL_19:
    int v7 = @"kCFErrorDomainCFNetwork";
    goto LABEL_8;
  }

  if (v4 == 4)
  {
    int v14 = valuePtr[2];
    if (v14 > -1003)
    {
      uint64_t v5 = 0LL;
      int v7 = @"kCFErrorDomainCFNetwork";
      CFIndex v8 = -1017LL;
      switch(v14)
      {
        case -5:
        case -4:
          uint64_t v5 = 0LL;
          CFIndex v8 = -1005LL;
          break;
        case -3:
          uint64_t v5 = 0LL;
          CFIndex v8 = 305LL;
          break;
        case -2:
          uint64_t v5 = 0LL;
          CFIndex v8 = 304LL;
          break;
        case -1:
          goto LABEL_8;
        default:
          if ((v14 + 1002) >= 2)
          {
            if (v14 == -1000)
            {
              uint64_t v5 = 0LL;
              int v7 = @"kCFErrorDomainCFNetwork";
              CFIndex v8 = 300LL;
            }

            else
            {
LABEL_50:
              uint64_t v5 = 0LL;
              int v7 = @"kCFErrorDomainCFNetwork";
              CFIndex v8 = 303LL;
            }
          }

          else
          {
            uint64_t v5 = 0LL;
            int v7 = @"kCFErrorDomainCFNetwork";
            CFIndex v8 = 301LL;
          }

          break;
      }
    }

    else
    {
      switch(v14)
      {
        case -2106:
        case -2104:
        case -2102:
        case -2101:
        case -2100:
          uint64_t v5 = 0LL;
          int v7 = @"kCFErrorDomainCFNetwork";
          CFIndex v8 = -1001LL;
          break;
        case -2105:
        case -2103:
          goto LABEL_50;
        case -2099:
          uint64_t v5 = 0LL;
          int v7 = @"kCFErrorDomainCFNetwork";
          CFIndex v8 = 307LL;
          break;
        case -2098:
        case -2097:
          uint64_t v5 = 0LL;
          int v7 = @"kCFErrorDomainCFNetwork";
          CFIndex v8 = 311LL;
          break;
        case -2096:
          uint64_t v5 = 0LL;
          int v7 = @"kCFErrorDomainCFNetwork";
          CFIndex v8 = 310LL;
          break;
        case -2095:
          uint64_t v5 = 0LL;
          int v7 = @"kCFErrorDomainCFNetwork";
          CFIndex v8 = -2LL;
          break;
        case -2094:
          uint64_t v5 = 0LL;
          int v7 = @"kCFErrorDomainCFNetwork";
          CFIndex v8 = 306LL;
          break;
        default:
          if (v14 != -2200) {
            goto LABEL_50;
          }
          uint64_t v5 = 0LL;
          int v7 = @"kCFErrorDomainCFNetwork";
          CFIndex v8 = -1004LL;
          break;
      }
    }

    goto LABEL_8;
  }

  if (v4 == *MEMORY[0x1896051B8])
  {
    unsigned int v15 = HIWORD(valuePtr[2]);
    unsigned int valuePtra = (unsigned __int16)valuePtr[2];
    keys = @"kCFSOCKSStatusCodeKey";
    values = CFNumberCreate(alloc, kCFNumberSInt32Type, &valuePtra);
    switch(v15)
    {
      case 0u:
        uint64_t v5 = valuePtra;
        if (valuePtra == 1)
        {
          CFIndex v8 = 121LL;
        }

        else
        {
          if (valuePtra == 2) {
            goto LABEL_24;
          }
          uint64_t v5 = 1LL;
          CFIndex v8 = 100LL;
        }

        break;
      case 1u:
        CFArrayRef v21 = @"kCFSOCKSVersionKey";
        CFNumberRef v19 = CFNumberCreate(alloc, kCFNumberSInt32Type, valuePtr + 2);
        uint64_t v5 = 2LL;
        CFIndex v8 = 101LL;
        break;
      case 2u:
        uint64_t v16 = valuePtra - 91;
        if (v16 < 3)
        {
          CFIndex v8 = v16 + 110;
          goto LABEL_36;
        }

        uint64_t v5 = 1LL;
        CFIndex v8 = 113LL;
        break;
      case 3u:
        uint64_t v5 = 1LL;
        CFIndex v8 = 122LL;
        break;
      case 4u:
        if (valuePtra == 255)
        {
          uint64_t v5 = 1LL;
          CFIndex v8 = 124LL;
        }

        else
        {
          CFArrayRef v21 = @"kCFSOCKSNegotiationMethodKey";
          CFNumberRef v19 = CFNumberCreate(alloc, kCFNumberSInt32Type, &valuePtra);
          uint64_t v5 = 2LL;
          CFIndex v8 = 123LL;
        }

        break;
      case 5u:
LABEL_24:
        uint64_t v5 = 1LL;
        CFIndex v8 = 120LL;
        break;
      default:
        CFIndex v8 = 0LL;
LABEL_36:
        uint64_t v5 = 1LL;
        break;
    }

    goto LABEL_19;
  }

  uint64_t v5 = 0LL;
  int v7 = @"kCFErrorDomainCFNetwork";
  CFIndex v8 = -1LL;
  switch(v4)
  {
    case 6LL:
      keys = @"kCFFTPStatusCodeKey";
      values = (void *)CFStringCreateWithFormat(alloc, 0LL, @"%d", valuePtr[2]);
      uint64_t v5 = 1LL;
      CFIndex v8 = 200LL;
      break;
    case 7LL:
      uint64_t v5 = 0LL;
      CFIndex v8 = valuePtr[2];
      int v7 = @"kCFErrorDomainWinSock";
      break;
    case 10LL:
      uint64_t v5 = 0LL;
      goto LABEL_7;
    case 11LL:
      uint64_t v5 = 0LL;
      CFURLRef v6 = (const __CFString **)MEMORY[0x189604F48];
      goto LABEL_6;
    case 12LL:
      if (valuePtr[2] == 1)
      {
        uint64_t v5 = 0LL;
        CFIndex v8 = 1LL;
      }

      else
      {
        keys = @"kCFGetAddrInfoFailureKey";
        values = CFNumberCreate(alloc, kCFNumberSInt32Type, valuePtr + 2);
        uint64_t v5 = 1LL;
        CFIndex v8 = 2LL;
      }

      break;
    case 13LL:
      uint64_t v5 = 0LL;
      CFURLRef v6 = (const __CFString **)MEMORY[0x18960C520];
      goto LABEL_6;
    default:
      break;
  }

uint64_t _CFStreamErrorFromCFError(__CFError *a1)
{
  if (!a1) {
    return 0LL;
  }
  CFErrorDomain Domain = CFErrorGetDomain(a1);
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x189604F58])) {
    goto LABEL_3;
  }
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x189604F50]))
  {
    else {
      return (int)*MEMORY[0x1896051C0];
    }
  }

  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x189604F48]))
  {
    CFErrorGetCode(a1);
    return 11LL;
  }

  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x18960C520]))
  {
    CFErrorGetCode(a1);
    return 13LL;
  }

  if (CFEqual(Domain, @"kCFErrorDomainWinSock"))
  {
    CFErrorGetCode(a1);
    return 7LL;
  }

  if (CFEqual(Domain, @"kCFErrorDomainCFNetwork")) {
    return _CFStreamErrorFromCFNetworkErrorCode(a1);
  }
  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x189607740]))
  {
    CFErrorGetCode(a1);
    return 15LL;
  }

  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x189608F30]))
  {
LABEL_3:
    CFErrorGetCode(a1);
    return 1LL;
  }

  if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x189608F28])) {
    return _CFStreamErrorFromNWDNSErrorCode(a1);
  }
  if (!CFEqual(Domain, (CFTypeRef)*MEMORY[0x189608F38])) {
    return -1LL;
  }
  uint64_t v3 = (int)*MEMORY[0x1896051C0];
  CFErrorGetCode(a1);
  return v3;
}

uint64_t _CFStreamErrorFromCFNetworkErrorCode(__CFError *a1)
{
  unint64_t Code = CFErrorGetCode(a1);
  if ((uint64_t)Code <= 99)
  {
    if (Code + 72007 >= 8)
    {
      switch(Code)
      {
        case 0xFFFFFFFFFFFFFFFELL:
          int v3 = -2095;
          goto LABEL_66;
        case 0xFFFFFFFFFFFFFFFFLL:
          return -1LL;
        case 0uLL:
          goto LABEL_21;
        case 1uLL:
          goto LABEL_23;
        case 2uLL:
          uint64_t v17 = CFErrorCopyUserInfo(a1);
          if (!v17)
          {
            int v16 = -2;
            goto LABEL_52;
          }

          CFStringRef v18 = v17;
          int Value = (const __CFNumber *)CFDictionaryGetValue(v17, @"kCFGetAddrInfoFailureKey");
          if (Value) {
            CFNumberGetValue(Value, kCFNumberCFIndexType, &v23);
          }
          else {
            LODWORD(v23) = -2;
          }
          CFRelease(v18);
          return 12LL;
        default:
          if (Code == -73000LL) {
            break;
          }
LABEL_21:
          if ((Code & 0x8000000000000000LL) != 0)
          {
            if (Code + 73000 <= 0x3E8) {
              goto LABEL_7;
            }
          }

          else
          {
            if (Code <= 0x63)
            {
LABEL_23:
              int v16 = 1;
LABEL_52:
              LODWORD(v23) = v16;
              return 12LL;
            }

            if (Code <= 0xC7)
            {
              uint64_t result = (int)*MEMORY[0x1896051B8];
              LODWORD(v23) = 3;
              return result;
            }

            if (Code <= 0x12B)
            {
LABEL_62:
              LODWORD(v23) = -1;
              return 6LL;
            }

            if (Code <= 0x18F)
            {
LABEL_65:
              int v3 = -4;
LABEL_66:
              LODWORD(v23) = v3;
              return 4LL;
            }
          }

          return -1LL;
      }
    }

    LODWORD(Code) = CFErrorGetCode(a1);
LABEL_7:
    LODWORD(v23) = Code;
    return 10LL;
  }

  else if (Code - 100 <= 0x18 && ((1LL << (Code - 100)) & 0x1F03C03) != 0)
  {
    CFIndex v5 = CFErrorGetCode(a1);
    int v6 = 0;
    int v7 = 0x10000;
    int v8 = 3;
    switch(v5)
    {
      case 'd':
        break;
      case 'e':
        goto LABEL_42;
      case 'n':
        int v6 = 0x20000;
        int v8 = 91;
        break;
      case 'o':
        int v6 = 0x20000;
        int v8 = 92;
        break;
      case 'p':
        int v6 = 0x20000;
        int v8 = 93;
        break;
      case 'q':
        int v7 = 0x20000;
        goto LABEL_42;
      case 'x':
        int v6 = 0;
        int v8 = 2;
        break;
      case 'y':
        int v6 = 0;
        int v8 = 121;
        break;
      case 'z':
        int v7 = 196608;
        goto LABEL_42;
      case '{':
        int v7 = 0x40000;
LABEL_42:
        CFErrorRef v20 = CFErrorCopyUserInfo(a1);
        if (v20)
        {
          CFArrayRef v21 = v20;
          uint64_t v22 = (const __CFNumber *)CFDictionaryGetValue(v20, @"kCFSOCKSStatusCodeKey");
          if (v22) {
            CFNumberGetValue(v22, kCFNumberSInt32Type, &valuePtr);
          }
          else {
            int valuePtr = -1;
          }
          CFRelease(v21);
          int v8 = valuePtr;
        }

        else
        {
          int v8 = -1;
        }

        int v6 = v7;
        break;
      case '|':
        int v6 = 0x40000;
        int v8 = 255;
        break;
      default:
        int v6 = 0;
        int v8 = -1;
        break;
    }

    uint64_t result = (int)*MEMORY[0x1896051B8];
    uint64_t v23 = v6 | v8;
  }

  else
  {
    switch(Code)
    {
      case 0x12CuLL:
        int v3 = -1000;
        goto LABEL_66;
      case 0x12DuLL:
      case 0x133uLL:
        int v3 = -1002;
        goto LABEL_66;
      case 0x12EuLL:
        goto LABEL_65;
      case 0x12FuLL:
        int v3 = -1;
        goto LABEL_66;
      case 0x130uLL:
        int v3 = -2;
        goto LABEL_66;
      case 0x131uLL:
        int v3 = -3;
        goto LABEL_66;
      case 0x132uLL:
        int v3 = -2094;
        goto LABEL_66;
      case 0x134uLL:
      case 0x135uLL:
        goto LABEL_21;
      case 0x136uLL:
        int v3 = -2096;
        goto LABEL_66;
      case 0x137uLL:
        int v3 = -2098;
        goto LABEL_66;
      default:
        if (Code != 200) {
          goto LABEL_21;
        }
        uint64_t v9 = CFErrorCopyUserInfo(a1);
        if (!v9) {
          goto LABEL_62;
        }
        uint64_t v10 = v9;
        CFErrorRef v11 = (const __CFString *)CFDictionaryGetValue(v9, @"kCFFTPStatusCodeKey");
        if (v11 && (uint64_t v12 = v11, v13 = CFGetTypeID(v11), v13 == CFStringGetTypeID()))
        {
          Intint Value = CFStringGetIntValue(v12);
          if (IntValue) {
            int v15 = IntValue;
          }
          else {
            int v15 = -1;
          }
        }

        else
        {
          int v15 = -1;
        }

        LODWORD(v23) = v15;
        CFRelease(v10);
        break;
    }

    return 6LL;
  }

  return result;
}

uint64_t _CFStreamErrorFromNWDNSErrorCode(__CFError *a1)
{
  CFIndex Code = CFErrorGetCode(a1);
  if (Code == -65554) {
    return 12LL;
  }
  else {
    return 10LL;
  }
}

void HTTPMessage::visitAllHeaderFields(HTTPMessage *a1, uint64_t a2)
{
  uint64_t v4 = HTTPMessage::headers((os_unfair_lock_s *)a1);
  uint64_t context = a2;
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(v4 + 8), (CFDictionaryApplierFunction)visit, &context);
}

void HTTPMessage::parserAddHeader( HTTPMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  CFIndex v5 = (CFDictionaryRef *)HTTPMessage::mutableHeaders(this);
  HTTPHeaderDict::addValue(v5, a2, a3);
}

void non-virtual thunk to'HTTPMessage::parserAddHeader( HTTPMessage *this, const HTTPHeaderKeyMixedValue *a2, const HTTPHeaderValueMixedValue *a3)
{
  CFIndex v5 = (CFDictionaryRef *)HTTPMessage::mutableHeaders((HTTPMessage *)((char *)this - 16));
  HTTPHeaderDict::addValue(v5, a2, a3);
}

void ___ZN11HTTPMessage5ClassEv_block_invoke()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "CFHTTPMessage");
  HTTPMessage::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182A859F8(_Unwind_Exception *a1)
{
}

void HTTPHeaderValueMixedValue::~HTTPHeaderValueMixedValue(HTTPHeaderValueMixedValue *this)
{
  *(void *)this = off_189C16E38;
  BOOL v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C16E38;
  stat v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

void HTTPMessage::addHeaderFieldStringValue(HTTPMessage *this, const __CFString *a2, const __CFString *a3)
{
  CFIndex v5 = (CFDictionaryRef *)HTTPMessage::mutableHeaders(this);
  HTTPHeaderDict::addValue(v5, (const HTTPHeaderKeyMixedValue *)&v8, (const HTTPHeaderValueMixedValue *)&v6);
  int v6 = off_189C16E38;
  if (cf) {
    CFRelease(cf);
  }
  int v8 = off_189C16E38;
  if (v9) {
    CFRelease(v9);
  }
}

void sub_182A85AF4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef a10, uint64_t a11, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void HTTPMessage::setMultipleHeaderFields(HTTPMessage *this, CFDictionaryRef theDict)
{
  int Value = CFDictionaryGetValue(theDict, @"__hhaa__");
  if (!Value || (CFIndex v5 = (const __CFString *)CFRetain(Value)) == 0LL)
  {
    if (!theDict)
    {
      CFTypeRef v46 = 0LL;
      unint64_t v47 = 0LL;
      int v48 = (const void **)v49;
      CFTypeRef v50 = 0LL;
      unint64_t v51 = 0LL;
      SInt8 v52 = (const void **)v53;
      goto LABEL_28;
    }

    CFTypeRef v46 = CFRetain(theDict);
    unint64_t Count = CFDictionaryGetCount(theDict);
    unint64_t v47 = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      int v48 = 0LL;
    }

    else
    {
      if (Count <= 0x1E)
      {
        int v15 = (const void **)v49;
        int v48 = (const void **)v49;
LABEL_18:
        CFDictionaryGetKeysAndValues(theDict, v15, 0LL);
        goto LABEL_19;
      }

      int v15 = (const void **)malloc(8 * Count);
      int v48 = v15;
      if (v15) {
        goto LABEL_18;
      }
    }

void sub_182A86064( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFContainerEnumeratorBase *a10, uint64_t a11, CFTypeRef a12, uint64_t a13, CFTypeRef a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,CFTypeRef cf,char a52)
{
}

void HTTPMessage::appendToBodyData(HTTPMessage *this, const char *a2, CFIndex a3)
{
  if (a3 >= 1)
  {
    uint64_t v6 = *((void *)this + 6);
    if (!v6)
    {
      CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
      uint64_t v6 = MEMORY[0x186E12804](v7, 32LL, 0LL);
      *(_OWORD *)uint64_t v6 = 0u;
      *(_OWORD *)(v6 + CFRelease((char *)this - 16) = 0u;
      CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
      *(void *)uint64_t v6 = off_189C17A58;
      *(void *)(v6 + _Block_object_dispose(va, 8) = v8;
      *((void *)this + 6) = v6;
    }

    HTTPBodyData::logit((HTTPBodyData *)v6, a2);
    CFMutableStringRef MutableCopy = *(__CFData **)(v6 + 24);
    if (!MutableCopy)
    {
      CFTypeID v11 = *(const __CFAllocator **)(v6 + 8);
      unint64_t v12 = *(const __CFData **)(v6 + 16);
      if (v12)
      {
        CFMutableStringRef MutableCopy = CFDataCreateMutableCopy(v11, 0LL, v12);
        CFTypeID v13 = *(const void **)(v6 + 16);
        *(void *)(v6 + CFRelease((char *)this - 16) = 0LL;
        *(void *)(v6 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = MutableCopy;
        if (v13)
        {
          CFRelease(v13);
          CFMutableStringRef MutableCopy = *(__CFData **)(v6 + 24);
        }
      }

      else
      {
        CFMutableStringRef MutableCopy = CFDataCreateMutable(v11, 0LL);
        *(void *)(v6 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = MutableCopy;
      }
    }

    CFDataAppendBytes(MutableCopy, (const UInt8 *)a2, a3);
    HTTPBodyData::logit((HTTPBodyData *)v6, v10);
  }

__CFData *HTTPMessage::copySerializedHeaders(HTTPMessage *this, uint64_t a2)
{
  uint64_t v4 = (const char *)(*(uint64_t (**)(HTTPMessage *, uint64_t))(*(void *)this + 88LL))(this, a2);
  if (!v4) {
    return 0LL;
  }
  CFIndex v5 = v4;
  size_t v6 = strlen(v4);
  CFAllocatorRef v7 = (HTTPHeaderDict *)HTTPMessage::headers((os_unfair_lock_s *)this);
  CFIndex v8 = v6 + HTTPHeaderDict::sizeHeaders(v7) + 4;
  CFPropertyListRef v9 = CFGetAllocator((char *)this - 16);
  CFTypeRef cf = CFDataCreateMutable(v9, v8);
  CFDataSetLength((CFMutableDataRef)cf, v8);
  MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)cf);
  unint64_t v16 = MutableBytePtr;
  uint64_t v17 = &MutableBytePtr[v8];
  memcpy(MutableBytePtr, v5, v6);
  *(_WORD *)&MutableBytePtr[v6] = 2573;
  CFStringRef v18 = &MutableBytePtr[v6 + 2];
  uint64_t v11 = HTTPMessage::headers((os_unfair_lock_s *)this);
  v19[0] = MEMORY[0x1895F87A8];
  v19[1] = 3221225472LL;
  void v19[2] = ___ZNK14HTTPHeaderDict16serializeHeadersEPNS_6BufferE_block_invoke;
  v19[3] = &__block_descriptor_48_e36_v24__0____CFString__8____CFArray__16l;
  v19[4] = v11;
  v19[5] = &cf;
  HTTPHeaderDict::visitHeaders(v11, 1, (uint64_t)v19);
  *(_WORD *)CFStringRef v18 = 2573;
  unint64_t v12 = (__CFData *)cf;
  v18 += 2;
  CFTypeRef cf = 0LL;
  CFDataSetLength(v12, v18 - v16);
  CFTypeRef v13 = cf;
  CFTypeRef cf = 0LL;
  if (v13) {
    CFRelease(v13);
  }
  return v12;
}

void sub_182A86384( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN11HTTPMessage13logMsgHeadersEP17DiagnosticLoggingPKc_block_invoke( uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  if (__CFNCanLogSensitiveContent::onceToken != -1) {
    dispatch_once(&__CFNCanLogSensitiveContent::onceToken, &__block_literal_global_26_4760);
  }
  if (__CFNCanLogSensitiveContent::ok)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    uint64_t v7 = *(void *)(a1 + 32);
    if (Count != 1)
    {
      CFPropertyListRef v9 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *))(*(void *)v7 + 88LL);
      uint64_t v10 = v7;
      uint64_t v11 = a2;
      ValueAtIndex = (const __CFString *)theArray;
      return v9(v10, v11, ValueAtIndex);
    }

    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0LL);
    CFPropertyListRef v9 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *))(*(void *)v7 + 64LL);
    uint64_t v10 = v7;
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 32);
    CFPropertyListRef v9 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *))(*(void *)v10 + 64LL);
    ValueAtIndex = @"<redacted>";
  }

  uint64_t v11 = a2;
  return v9(v10, v11, ValueAtIndex);
}

void HTTPMessage::setTrailerFields(HTTPMessage *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v4 = (const void *)*((void *)this + 14);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = cf;
}

void std::__shared_ptr_pointer<__CFDictionary *,Deleter_CFRelease,std::allocator<__CFDictionary>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void DomainAndPartition::~DomainAndPartition(DomainAndPartition *this)
{
  *(void *)this = off_189C080A0;
  stat v2 = (char *)*((void *)this + 35);
  if (v2) {
    BOOL v3 = v2 == (char *)this + 24;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    free(v2);
  }
}

{
  char *v2;
  BOOL v3;
  *(void *)this = off_189C080A0;
  stat v2 = (char *)*((void *)this + 35);
  if (v2) {
    BOOL v3 = v2 == (char *)this + 24;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    free(v2);
  }
  operator delete(this);
}

uint64_t DomainAndPartition::init(void *a1, uint64_t a2, uint64_t a3, char *__s, uint64_t a5, uint64_t a6)
{
  a1[1] = a2;
  a1[2] = a3;
  a1[35] = 0LL;
  a1[38] = 0LL;
  a1[39] = 0LL;
  a1[37] = 0LL;
  if (!a5 || !a6) {
    __assert_rtn("init", "HTTPCookiePartitionHelpers.cpp", 137, "partition != nil && partitionLen > 0");
  }
  size_t v10 = strlen(__s);
  v14[0] = MEMORY[0x1895F87A8];
  unint64_t v11 = 2 * (v10 + a6) + 5;
  v14[1] = 3221225472LL;
  unsigned __int8 v14[2] = ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke;
  v14[3] = &__block_descriptor_72_e11_v24__0_8_16l;
  void v14[4] = a1;
  void v14[5] = __s;
  void v14[6] = v10;
  v14[7] = a5;
  v14[8] = a6;
  if (v11 > 0xFF)
  {
    a1[36] = v11;
    unint64_t v12 = (char *)malloc(2 * (v10 + a6) + 5);
  }

  else
  {
    unint64_t v12 = (char *)(a1 + 3);
  }

  a1[35] = v12;
  return ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke( (uint64_t)v14,  v12,  (uint64_t)&v12[v11]);
}

uint64_t ___ZN18DomainAndPartition4initE25CFAbsoluteTimeAsSpecifiedPKhS2_m_block_invoke( uint64_t a1, char *__dst, uint64_t a3)
{
  size_t v6 = *(void **)(a1 + 32);
  v6[37] = __dst;
  strncpy(__dst, *(const char **)(a1 + 40), *(void *)(a1 + 48));
  uint64_t v7 = *(void *)(a1 + 48);
  __dst[v7] = 0;
  CFIndex v8 = &__dst[v7 + 1];
  v6[38] = v8;
  CFPropertyListRef v9 = &strncpy(v8, *(const char **)(a1 + 56), *(void *)(a1 + 64))[*(void *)(a1 + 64)];
  *v9++ = 0;
  v6[39] = v9;
  return snprintf( v9,  a3 - (void)v9,  "%.*s{%.*s}",  *(void *)(a1 + 48),  *(const char **)(a1 + 40),  *(void *)(a1 + 64),  *(const char **)(a1 + 56));
}

void *DomainAndPartition::DomainAndPartition(void *a1, char *__s, char *a3, uint64_t a4, uint64_t a5)
{
  *a1 = off_189C080A0;
  if (a3 && *a3)
  {
    size_t v10 = strlen(a3);
    DomainAndPartition::init(a1, a4, a5, __s, (uint64_t)a3, v10);
  }

  else
  {
    DomainAndPartition::init(a1, a4, a5, __s);
  }

  return a1;
}

void HTTPCookieStoragePolicy::init( uint64_t a1, CFTypeRef cf, const void *a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, const __CFDictionary *a9, char a10)
{
  *(void *)(a1 + 56) = a7;
  *(void *)(a1 + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a8;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a1 + 40) = a5;
  if (cf) {
    CFTypeRef v14 = CFRetain(cf);
  }
  else {
    CFTypeRef v14 = 0LL;
  }
  *(void *)(a1 + CFRelease((char *)this - 16) = v14;
  if (a3) {
    CFTypeRef v15 = CFRetain(a3);
  }
  else {
    CFTypeRef v15 = 0LL;
  }
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v15;
  unint64_t v16 = (CFAllocatorRef *)MEMORY[0x189604DB0];
  if (a4) {
    CFStringRef v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"%@", a4);
  }
  else {
    CFStringRef v17 = 0LL;
  }
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v17;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a1 + 72) = a6;
  if (a9)
  {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(*v16, 0LL, a9);
    uint64_t v19 = operator new(0x20uLL);
    *uint64_t v19 = off_189C19FA8;
    v19[1] = 0LL;
    void v19[2] = 0LL;
    v19[3] = MutableCopy;
    *(void *)&__int128 v20 = MutableCopy;
    *((void *)&v20 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v19;
    uint64_t v21 = *(std::__shared_weak_count **)(a1 + 88);
    *(_OWORD *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = v20;
    if (v21)
    {
      p_uint64_t shared_owners = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v23 = __ldaxr(p_shared_owners);
      while (__stlxr(v23 - 1, p_shared_owners));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }

  if (*(_BYTE *)(a1 + 97)) {
    *(_BYTE *)(a1 + 97) = 0;
  }
  *(_BYTE *)(a1 + 9_Block_object_dispose(va, 8) = a10;
}

uint64_t HTTPCookieStoragePolicy::HTTPCookieStoragePolicy( uint64_t a1, const void *a2, const void *a3, uint64_t a4, int a5, int a6, const __CFDictionary *a7, char a8)
{
  *(void *)a1 = off_189C080E0;
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(_WORD *)(a1 + 96) = 0;
  HTTPCookieStoragePolicy::init(a1, a2, a3, a4, a5, a6, 0LL, 0LL, a7, a8);
  return a1;
}

void sub_182A86908(_Unwind_Exception *a1)
{
}

uint64_t HTTPCookieStoragePolicy::isTopLevelNavigation(HTTPCookieStoragePolicy *this)
{
  int valuePtr = 0;
  if (this
    && (int Value = (const __CFNumber *)CFDictionaryGetValue( this,  @"_kCFHTTPCookiePolicyPropertyIsTopLevelNavigation")) != 0LL)
  {
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    return valuePtr;
  }

  else
  {
    return 0;
  }

uint64_t HTTPCookieStoragePolicy::isURLInSiteForCookie( HTTPCookieStoragePolicy *this, uint64_t a2, const __CFURL *a3)
{
  if (*((_BYTE *)this + 97)) {
    return *((unsigned __int8 *)this + 96);
  }
  CFIndex v5 = (HTTPCookieStorage *)*((void *)this + 2);
  size_t v6 = (const __CFDictionary *)*((void *)this + 10);
  if (v6) {
    int Value = (const __CFURL *)CFDictionaryGetValue(v6, @"_kCFHTTPCookiePolicyPropertySiteForCookies");
  }
  else {
    int Value = 0LL;
  }
  uint64_t result = HTTPCookieStorage::isURLInMainDocumentDomain(v5, Value, a3);
  *((_WORD *)this + 4_Block_object_dispose(va, 8) = result | 0x100;
  return result;
}

void HTTP3Connection::~HTTP3Connection(HTTP3Connection *this)
{
}

{
  char *v2;
  HTTPStallTimer *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  FILE *v11;
  void *v12;
  void *v13;
  int v14;
  _DWORD *v15;
  int v16;
  unsigned int v17;
  int v18;
  FILE *v19;
  std::__shared_weak_count *v20;
  std::__shared_weak_count *v21;
  __int128 v22;
  *(void *)this = off_189C08100;
  *((void *)this + 3) = &unk_189C08150;
  stat v2 = (char *)this + 976;
  BOOL v3 = (HTTPStallTimer *)*((void *)this + 122);
  if (v3)
  {
    HTTPStallTimer::invalidate(v3);
    uint64_t v22 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v22);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)&v22 + 1);
    if (*((void *)&v22 + 1))
    {
      CFIndex v5 = (unint64_t *)(*((void *)&v22 + 1) + 8LL);
      do
        size_t v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

  uint64_t v7 = (void *)*((void *)this + 11);
  if (v7)
  {
    do
    {
      CFIndex v8 = (void *)v7[2];
      free(v7);
      uint64_t v7 = v8;
    }

    while (v8);
  }

  CFPropertyListRef v9 = (void *)*((void *)this + 14);
  if (v9)
  {
    do
    {
      size_t v10 = (void *)*v9;
      free(v9);
      CFPropertyListRef v9 = v10;
    }

    while (v10);
  }

  free(*((void **)this + 13));
  free(*((void **)this + 31));
  unint64_t v11 = (FILE *)*((void *)this + 29);
  if (v11)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
    fwrite("cleaned up", 0xAuLL, 1uLL, *((FILE **)this + 29));
    fputc(10, *((FILE **)this + 29));
  }

  unint64_t v12 = (void *)*((void *)this + 44);
  if (v12)
  {
    do
    {
      CFTypeRef v13 = (void *)*v12;
      free(v12);
      unint64_t v12 = v13;
    }

    while (v13);
  }

  CFTypeRef v14 = *((_DWORD *)this + 126);
  if ((v14 - 1) > 4)
  {
    CFTypeRef v15 = (_DWORD *)*((void *)this + 69);
    if (!v15) {
      goto LABEL_21;
    }
  }

  else
  {
    CFTypeRef v15 = (_DWORD *)*((void *)this + 70);
    if (!v15) {
      goto LABEL_21;
    }
  }

void HTTP3Connection::connEventReadClose(HTTP3Connection *this)
{
  *((_BYTE *)this + 920) |= 2u;
  if (*((void *)this + 142) == *((void *)this + 143)) {
    HTTP3Connection::_cleanupConnection(this, 256LL, 0LL);
  }
}

void HTTP3Connection::connEventDisconnected(HTTP3Connection *this)
{
  *((_BYTE *)this + 920) |= 2u;
  if (*((void *)this + 142) == *((void *)this + 143)) {
    HTTP3Connection::_cleanupConnection(this, 256LL, 0LL);
  }
}

void HTTP3Connection::connErrorOccurred(HTTP3Connection *this, CFStreamError a2)
{
  *(CFStreamError *)((char *)this + 1160) = a2;
  HTTP3Connection::_cleanupConnection(this, -1LL, 0LL);
}

uint64_t HTTP3Connection::connEventAlternatePathAvailable(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 920) |= 2u;
  BOOL v3 = *(char **)(a1 + 1136);
  uint64_t v4 = *(char **)(a1 + 1144);
  if (v3 == v4)
  {
    HTTP3Connection::_cleanupConnection((HTTP3Connection *)a1, 256LL, 0LL);
    BOOL v3 = *(char **)(a1 + 1136);
    uint64_t v4 = *(char **)(a1 + 1144);
  }

  uint64_t v20 = 0LL;
  uint64_t v21 = 4LL;
  LODWORD(v22) = -5;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>( &v18,  v3,  v4,  (v4 - v3) >> 4);
  uint64_t v6 = v18;
  for (uint64_t i = v19; v6 != i; v6 += 16LL)
  {
    CFPropertyListRef v9 = *(void ***)v6;
    CFIndex v8 = *(std::__shared_weak_count **)(v6 + 8);
    v17[0] = *(void ***)v6;
    v17[1] = (void **)&v8->__vftable;
    if (v8)
    {
      p_uint64_t shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }

    if ((a2 & 0xFFFFFFFD) == 1
      && (*(unsigned int (**)(void *, uint64_t *, void))(*(void *)v9[37] + 280LL))(v9[37], &v21, 0LL) - 5 <= 5)
    {
      unint64_t v12 = (void *)v21;
      CFTypeRef v13 = v22;
      HTTP3Stream::_cleanupStream((uint64_t)v9, 256LL, 0);
      v9[33] = v12;
      v9[34] = v13;
      HTTP3Stream::_protocolCallback((HTTP3Stream *)v9);
    }

    else
    {
      (*(void (**)(void *, uint64_t))(*(void *)v9[37] + 248LL))(v9[37], a2);
    }

    if (v8)
    {
      CFTypeRef v14 = (unint64_t *)&v8->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }

  v17[0] = (void **)&v18;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](v17);
  return 1LL;
}

void sub_182A86BD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  a10 = (void **)&a12;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a10);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'HTTP3Connection::~HTTP3Connection(HTTP3Connection *this)
{
}

{
  void *v1;
  HTTP3Connection::~HTTP3Connection((HTTP3Connection *)((char *)this - 24));
  operator delete(v1);
}

uint64_t std::deque<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL),std::allocator<void({block_pointer} {__strong})(std::shared_ptr<HTTP3Framer>,unsigned long long,BOOL)>>::~deque[abi:nn180100]( uint64_t a1)
{
  stat v2 = *(void ***)(a1 + 8);
  BOOL v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    BOOL v3 = *(void ***)(a1 + 8);
  }

  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = &v2[v5 >> 9];
    uint64_t v7 = (void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    if (v7 != (void **)v8)
    {
      do
      {
        CFPropertyListRef v9 = *v7++;

        if ((char *)v7 - (_BYTE *)*v6 == 4096)
        {
          size_t v10 = (void **)v6[1];
          ++v6;
          uint64_t v7 = v10;
        }
      }

      while (v7 != (void **)v8);
      stat v2 = *(void ***)(a1 + 8);
      BOOL v3 = *(void ***)(a1 + 16);
    }
  }

  void *v4 = 0LL;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = *(void ***)(a1 + 16);
      stat v2 = (void **)(*(void *)(a1 + 8) + 8LL);
      *(void *)(a1 + _Block_object_dispose(va, 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 256LL;
    goto LABEL_14;
  }

  if (v12 == 2)
  {
    uint64_t v13 = 512LL;
LABEL_14:
    *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v13;
  }

  if (v2 != v3)
  {
    do
    {
      CFTypeRef v14 = *v2++;
      operator delete(v14);
    }

    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + CFRelease((char *)this - 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void HTTP3Connection::_tryCreateBidirectionalStreams(HTTP3Connection *this)
{
  if (*((void *)this + 139))
  {
    stat v2 = (uint64_t *)((char *)this + 1120);
    do
    {
      uint64_t v3 = *v2;
      if (!*v2)
      {
        if (HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::onceToken != -1) {
          dispatch_once( &HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::onceToken,  &__block_literal_global_34);
        }
        connection_metaint data = (nw_protocol_metadata *)nw_quic_create_connection_metadata();
        nw_quic_connection_metadata_set_stream_options();
        unint64_t v5 = nw_content_context_create("request");
        nw_content_context_set_metadata_for_protocol(v5, connection_metadata);

        uint64_t v6 = operator new(0xB8uLL);
        uint64_t v7 = v6;
        v6[1] = 0LL;
        v6[2] = 0LL;
        *uint64_t v6 = off_189C087D8;
        uint64_t v8 = *((void *)this + 126);
        if (v8) {
          uint64_t v9 = v8 + 112;
        }
        else {
          uint64_t v9 = 0LL;
        }
        size_t v10 = (std::__shared_weak_count *)*((void *)this + 127);
        uint64_t v39 = v9;
        CFIndex v40 = v10;
        if (v10)
        {
          p_uint64_t shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            unint64_t v12 = __ldxr(p_shared_owners);
          while (__stxr(v12 + 1, p_shared_owners));
        }

        HTTP3Framer::HTTP3Framer((uint64_t)(v6 + 3), &v39, v5, 0LL, 0);
        if (v10)
        {
          uint64_t v13 = (unint64_t *)&v10->__shared_owners_;
          do
            unint64_t v14 = __ldaxr(v13);
          while (__stlxr(v14 - 1, v13));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }

        *(void *)&__int128 v38 = v7 + 3;
        *((void *)&v38 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v7;
        std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( (uint64_t)&v38,  v7 + 3,  (uint64_t)(v7 + 3));
        std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v38);
        uint64_t v15 = (std::__shared_weak_count *)*((void *)&v38 + 1);
        if (*((void *)&v38 + 1))
        {
          uint64_t v16 = (unint64_t *)(*((void *)&v38 + 1) + 8LL);
          do
            unint64_t v17 = __ldaxr(v16);
          while (__stlxr(v17 - 1, v16));
          if (!v17)
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
        }

        uint64_t v3 = *v2;
      }

      uint64_t StreamID = HTTP3Framer::getStreamID(*(HTTP3Framer **)(v3 + 48));
      if (StreamID == -1) {
        break;
      }
      uint64_t v19 = StreamID;
      uint64_t v20 = (void (**)(void *, uint64_t *, uint64_t, void))_Block_copy(*(const void **)(*(void *)(*((void *)this + 135) + ((*((void *)this + 138) >> 6) & 0x3FFFFFFFFFFFFF8LL))
                                                                                                 + 8
                                                                                                 * (*((void *)this + 138) & 0x1FFLL)));
      objc_release(*(id *)(*(void *)(*((void *)this + 135) + ((*((void *)this + 138) >> 6) & 0x3FFFFFFFFFFFFF8LL))
                         + 8 * (*((void *)this + 138) & 0x1FFLL)));
      int64x2_t v21 = vaddq_s64(*((int64x2_t *)this + 69), (int64x2_t)xmmword_182C9D770);
      *((int64x2_t *)this + 69) = v21;
      if (v21.i64[0] >= 0x400uLL)
      {
        operator delete(**((void ***)this + 135));
        *((void *)this + 135) += 8LL;
        *((void *)this + 138) -= 512LL;
      }

      uint64_t v22 = (std::__shared_weak_count *)*((void *)this + 141);
      uint64_t v39 = *((void *)this + 140);
      CFIndex v40 = v22;
      if (v22)
      {
        unint64_t v23 = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v24 = __ldxr(v23);
        while (__stxr(v24 + 1, v23));
      }

      __int128 v38 = 0uLL;
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v38);
      CFTypeID v25 = (std::__shared_weak_count *)*((void *)&v38 + 1);
      if (*((void *)&v38 + 1))
      {
        uint64_t v26 = (unint64_t *)(*((void *)&v38 + 1) + 8LL);
        do
          unint64_t v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }

      uint64_t v36 = v39;
      CFNumberRef v37 = v40;
      if (v40)
      {
        unint64_t v28 = (unint64_t *)&v40->__shared_owners_;
        do
          unint64_t v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }

      v20[2](v20, &v36, v19, 0LL);
      CFTypeRef v30 = v37;
      if (v37)
      {
        CFIndex v31 = (unint64_t *)&v37->__shared_owners_;
        do
          unint64_t v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }

      CFTypeID v33 = v40;
      if (v40)
      {
        char v34 = (unint64_t *)&v40->__shared_owners_;
        do
          unint64_t v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
    }

    while (*((void *)this + 139));
  }

void sub_182A87380( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<HTTP3Framer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C087D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3Framer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C087D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<HTTP3Framer>::__on_zero_shared(uint64_t a1)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
  stat v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t ___ZN15HTTP3Connection35_newClientBidirectionalStreamHandleEPKc_block_invoke()
{
  uint64_t stream_options = nw_quic_create_stream_options();
  uint64_t v1 = (void *)HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::options;
  HTTP3Connection::_newClientBidirectionalStreamHandle(char const*)::options = stream_options;

  return nw_quic_stream_set_is_unidirectional();
}

void HTTP3Connection::_cleanupConnection(HTTP3Connection *this, uint64_t a2, uint64_t a3)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  if ((*((_BYTE *)this + 920) & 4) != 0) {
    return;
  }
  if (*((void *)this + 124)) {
    HTTP3Connection::_stopStallRecovery(this);
  }
  uint64_t v6 = (HTTPStallTimer *)*((void *)this + 122);
  if (v6)
  {
    HTTPStallTimer::invalidate(v6);
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0LL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 976, (__int128 *)buf);
    uint64_t v7 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      uint64_t v8 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }

  if (a2 != -1) {
    (*(void (**)(void, uint64_t))(**((void **)this + 126) + 112LL))(*((void *)this + 126), a2);
  }
  uint64_t v10 = (*(uint64_t (**)(void))(**((void **)this + 126) + 120LL))(*((void *)this + 126));
  if (v10 != -1)
  {
    unint64_t v11 = (void *)v10;
    if (v10 != 256)
    {
      CFN_LOG_h3connection();
      unint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        uint64_t v52 = *((void *)this + 152);
        *(_DWORD *)__int128 buf = 134218496;
        *(void *)&uint8_t buf[4] = this;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v52;
        *(_WORD *)&_BYTE buf[22] = 2048;
        double v63 = v11;
        _os_log_error_impl(&dword_18298D000, v12, OS_LOG_TYPE_ERROR, "%p %llu closed with peer error %llu", buf, 0x20u);
      }
    }
  }

  uint64_t v13 = *((void *)this + 145);
  unint64_t v14 = *((void *)this + 146);
  uint64_t v57 = 0LL;
  uint64_t v58 = 0LL;
  uint64_t v59 = 0LL;
  std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>( &v57,  *((void **)this + 142),  *((void **)this + 143),  (uint64_t)(*((void *)this + 143) - *((void *)this + 142)) >> 4);
  uint64_t v15 = v57;
  uint64_t v16 = v58;
  if (v57 != v58)
  {
    uint64_t v17 = v13 | v14;
    if (v17) {
      unint64_t v18 = v14;
    }
    else {
      unint64_t v18 = v14 & 0xFFFFFFFF00000000LL | 0xFFFFFFFC;
    }
    if (v17) {
      uint64_t v19 = v13;
    }
    else {
      uint64_t v19 = 4LL;
    }
    do
    {
      int64x2_t v21 = *(HTTP3Stream **)v15;
      uint64_t v20 = *(std::__shared_weak_count **)(v15 + 8);
      *(void *)__int128 buf = *(void *)v15;
      *(void *)&uint8_t buf[8] = v20;
      if (v20)
      {
        p_uint64_t shared_owners = (unint64_t *)&v20->__shared_owners_;
        do
          unint64_t v23 = __ldxr(p_shared_owners);
        while (__stxr(v23 + 1, p_shared_owners));
      }

      HTTP3Stream::_cleanupStream((uint64_t)v21, 256LL, 1);
      *((void *)v21 + 33) = v19;
      *((void *)v21 + 3os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v18;
      HTTP3Stream::_protocolCallback(v21);
      if (v20)
      {
        unint64_t v24 = (unint64_t *)&v20->__shared_owners_;
        do
          unint64_t v25 = __ldaxr(v24);
        while (__stlxr(v25 - 1, v24));
        if (!v25)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }

      v15 += 16LL;
    }

    while (v15 != v16);
  }

  TransportConnection::rstConnectionDelegate(*((TransportConnection **)this + 126));
  (*(void (**)(void, uint64_t))(**((void **)this + 126) + 152LL))(*((void *)this + 126), a3);
  *((_BYTE *)this + 920) |= 4u;
  uint64_t v55 = 0LL;
  char v56 = 0LL;
  uint64_t v26 = (std::__shared_weak_count *)*((void *)this + 121);
  if (v26)
  {
    char v56 = std::__shared_weak_count::lock(v26);
    if (v56)
    {
      unint64_t v27 = (void *)*((void *)this + 120);
      uint64_t v55 = v27;
      if (v27)
      {
        std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v53,  *((void *)this + 1),  *((std::__shared_weak_count **)this + 2));
        uint64_t v29 = v27[1];
        unint64_t v28 = (std::__shared_weak_count *)v27[2];
        uint64_t v60 = v29;
        if (v28)
        {
          CFTypeRef v30 = std::__shared_weak_count::lock(v28);
          unsigned int v61 = v30;
          if (v30)
          {
            CFIndex v31 = v30;
            uint64_t v32 = v27[11];
            *(void *)__int128 buf = MEMORY[0x1895F87A8];
            *(void *)&uint8_t buf[8] = 3321888768LL;
            *(void *)&uint8_t buf[16] = ___ZN25HTTP3ConnectionCacheEntry16connectionClosedENSt3__110shared_ptrI15HTTP3ConnectionEE_block_invoke;
            double v63 = &__block_descriptor_64_ea8_32c53_ZTSNSt3__110shared_ptrI25HTTP3ConnectionCacheEntryEE48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
            uint64_t v64 = v29;
            uint64_t v65 = v31;
            CFTypeID v33 = (unint64_t *)&v31->__shared_owners_;
            do
              unint64_t v34 = __ldxr(v33);
            while (__stxr(v34 + 1, v33));
            uint64_t v66 = v53;
            uint64_t v67 = v54;
            if (v54)
            {
              unint64_t v35 = (unint64_t *)&v54->__shared_owners_;
              do
                unint64_t v36 = __ldxr(v35);
              while (__stxr(v36 + 1, v35));
            }

            (*(void (**)(uint64_t, _BYTE *))(*(void *)v32 + 96LL))(v32, buf);
            CFNumberRef v37 = v67;
            if (v67)
            {
              __int128 v38 = (unint64_t *)&v67->__shared_owners_;
              do
                unint64_t v39 = __ldaxr(v38);
              while (__stlxr(v39 - 1, v38));
              if (!v39)
              {
                ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                std::__shared_weak_count::__release_weak(v37);
              }
            }

            CFIndex v40 = v65;
            if (v65)
            {
              unsigned __int8 v41 = (unint64_t *)&v65->__shared_owners_;
              do
                unint64_t v42 = __ldaxr(v41);
              while (__stlxr(v42 - 1, v41));
              if (!v42)
              {
                ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
                std::__shared_weak_count::__release_weak(v40);
              }
            }

            CFIndex v43 = v61;
            if (v61)
            {
              char v44 = (unint64_t *)&v61->__shared_owners_;
              do
                unint64_t v45 = __ldaxr(v44);
              while (__stlxr(v45 - 1, v44));
              if (!v45)
              {
                ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
                std::__shared_weak_count::__release_weak(v43);
              }
            }

            CFTypeRef v46 = v54;
            if (v54)
            {
              unint64_t v47 = (unint64_t *)&v54->__shared_owners_;
              do
                unint64_t v48 = __ldaxr(v47);
              while (__stlxr(v48 - 1, v47));
              if (!v48)
              {
                ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
                std::__shared_weak_count::__release_weak(v46);
              }
            }

            goto LABEL_63;
          }
        }

        else
        {
          unsigned int v61 = 0LL;
        }

        std::__throw_bad_weak_ptr[abi:nn180100]();
        __break(1u);
        return;
      }
    }
  }

void sub_182A8792C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void **);
  uint64_t v10 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v11 = va_arg(va3, void);
  uint64_t v13 = va_arg(va3, void);
  uint64_t v14 = va_arg(va3, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  va_copy((va_list)v8, va2);
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)va1);
  _Unwind_Resume(a1);
}

void *std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>( void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 60) {
      abort();
    }
    uint64_t v6 = result;
    uint64_t result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>(a4);
    *uint64_t v6 = result;
    v6[1] = result;
    v6[2] = &result[2 * v7];
    while (a2 != a3)
    {
      uint64_t v8 = a2[1];
      *uint64_t result = *a2;
      result[1] = v8;
      if (v8)
      {
        unint64_t v9 = (unint64_t *)(v8 + 8);
        do
          unint64_t v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }

      a2 += 2;
      result += 2;
    }

    v6[1] = result;
  }

  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<HTTP3Stream>>>( unint64_t a1)
{
  if (a1 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a1);
}

void HTTP3Connection::_stopStallRecovery(HTTP3Connection *this)
{
  *((_BYTE *)this + 920) &= ~0x20u;
  uint64_t v2 = (dispatch_source_s *)*((void *)this + 124);
  if (v2)
  {
    dispatch_source_cancel(v2);
    uint64_t v3 = (void *)*((void *)this + 124);
    *((void *)this + 12os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0LL;
  }

id CFN_LOG_h3connection(void)
{
  return (id)CFN_LOG_h3connection(void)::log;
}

void ___ZL20CFN_LOG_h3connectionv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.cfnetwork", "h3connection");
  uint64_t v1 = (void *)CFN_LOG_h3connection(void)::log;
  CFN_LOG_h3connection(void)::log = (uint64_t)v0;
}

void HTTP3Connection::_decoderUnblocked(HTTP3Connection *this, void *a2)
{
  if (*((_DWORD *)this + 29) != 9)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v10,  *((void *)this + 1),  *((std::__shared_weak_count **)this + 2));
    int v3 = *((_DWORD *)this + 29);
    switch(v3)
    {
      case 2:
        int v4 = 1;
        break;
      case 8:
        int v4 = 7;
        break;
      case 5:
        int v4 = 4;
        break;
      default:
        __assert_rtn("responseUnblocked", "HTTP3Stream.mm", 440, "false");
    }

    *((_DWORD *)this + 29) = v4;
    id v5 = *((id *)this + 19);
    uint64_t v6 = (void *)*((void *)this + 19);
    *((void *)this + 19) = 0LL;

    uint64_t v7 = v11;
    if (v11)
    {
      p_uint64_t shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }

void sub_182A87C20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    p_uint64_t shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t HTTP3Connection::_decoderPrepareDecode(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v7 = *(void *)(a1 + 184);
  uint64_t v6 = *(void *)(a1 + 192);
  id v5 = (std::vector<char> *)(a1 + 184);
  unint64_t v8 = v6 - v7;
  if (v8 < a3)
  {
    unint64_t v9 = 2 * v8;
    if (2 * v8 <= a3) {
      unint64_t v9 = a3;
    }
    if (v9 <= 0x200) {
      unint64_t v9 = 512LL;
    }
    std::vector<char>::__append(v5, v9 - v8);
    uint64_t v7 = *(void *)(a1 + 184);
    unint64_t v8 = *(void *)(a1 + 192) - v7;
  }

  if (!a2)
  {
    *(_OWORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
    *(_OWORD *)(a1 + 2CFRelease((char *)this - 16) = 0u;
    if (v8 >= 0xFFFF) {
      LOWORD(v_Block_object_dispose(va, 8) = -1;
    }
  }

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = v7;
  uint64_t v10 = a1 + 208;
  *(_WORD *)(v10 + 26) = v8;
  return v10;
}

uint64_t HTTP3Connection::_decoderProcessHeader(uint64_t a1, uint64_t *a2)
{
  int v4 = *(_DWORD *)(a1 + 116);
  switch(v4)
  {
    case 7:
      if (*(_BYTE *)(a1 + 177)) {
        return 0LL;
      }
      unint64_t v12 = *(std::__shared_weak_count **)(a1 + 56);
      if (!v12) {
        return 0LL;
      }
      uint64_t v13 = std::__shared_weak_count::lock(v12);
      if (v13)
      {
        uint64_t v14 = *(void *)(a1 + 48);
        if (v14)
        {
          std::string::basic_string[abi:nn180100]( __dst,  (void *)(*a2 + *((int *)a2 + 4)),  *((unsigned __int16 *)a2 + 12));
          std::string::basic_string[abi:nn180100](__p, (void *)(*a2 + *((int *)a2 + 5)), *((unsigned __int16 *)a2 + 13));
          HTTP2ServerPush::addPromisedHeaderToStream( v14 + 624,  (__int128 *)__dst,  (__int128 *)__p,  *(_DWORD *)(a1 + 168));
          if (v37 < 0) {
            operator delete(__p[0]);
          }
          if (v39 < 0) {
            operator delete(__dst[0]);
          }
        }

        p_uint64_t shared_owners = (unint64_t *)&v13->__shared_owners_;
        do
          unint64_t v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }

        return 0LL;
      }

      break;
    case 4:
      id v5 = (__CFString *)[objc_alloc(NSString) initWithBytes:*a2 + *((int *)a2 + 4) length:*((unsigned __int16 *)a2 + 12) encoding:1];
      if (-[__CFString hasPrefix:](v5, "hasPrefix:", @":"))
      {
        *(void *)(a1 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 4LL;
        *(_DWORD *)(a1 + 272) = -1;
        HTTP3Stream::_cleanupStream(a1, 270LL, 0);
        HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
        uint64_t v17 = *(std::__shared_weak_count **)(a1 + 56);
        if (v17)
        {
          unint64_t v18 = std::__shared_weak_count::lock(v17);
          if (v18)
          {
            unint64_t v8 = v18;
            uint64_t v19 = *(void *)(a1 + 48);
            if (v19) {
              HTTP3Connection::reportServerProtocolViolation(v19, 53, *(void *)(a1 + 336));
            }
            uint64_t v20 = (unint64_t *)&v8->__shared_owners_;
            do
              unint64_t v11 = __ldaxr(v20);
            while (__stlxr(v11 - 1, v20));
            goto LABEL_32;
          }
        }

LABEL_46:
        unint64_t v28 = (void *)[objc_alloc(NSString) initWithBytes:*a2 + *((int *)a2 + 5) length:*((unsigned __int16 *)a2 + 13) encoding:1];
        uint64_t v29 = *(CFDictionaryRef **)(a1 + 256);
        HTTPHeaderKeyMixedValue::HTTPHeaderKeyMixedValue((HTTPHeaderKeyMixedValue *)__dst, v5);
        HTTPHeaderValueMixedValue::HTTPHeaderValueMixedValue((HTTPHeaderValueMixedValue *)__p, v28);
        HTTPHeaderDict::addValue(v29, (const HTTPHeaderKeyMixedValue *)__dst, (const HTTPHeaderValueMixedValue *)__p);
        __p[0] = off_189C16E38;
        if (__p[1]) {
          CFRelease(__p[1]);
        }
        __dst[0] = off_189C16E38;
        if (__dst[1]) {
          CFRelease(__dst[1]);
        }

        return 0LL;
      }

      uint64_t v21 = *a2;
      if (!strncmp(":status", (const char *)(*a2 + *((int *)a2 + 4)), *((unsigned __int16 *)a2 + 12)))
      {
        if (*((_WORD *)a2 + 13) == 3
          && (CFIndex v31 = (unsigned __int8 *)(v21 + *((int *)a2 + 5)),
              uint64_t v32 = *v31,
              (*(_DWORD *)(MEMORY[0x1895F8770] + 4 * v32 + 60) & 0x400) != 0)
          && (uint64_t v33 = v31[1], (*(_DWORD *)(MEMORY[0x1895F8770] + 4 * v33 + 60) & 0x400) != 0)
          && (uint64_t v34 = v31[2], (*(_DWORD *)(MEMORY[0x1895F8770] + 4 * v34 + 60) & 0x400) != 0))
        {
          int v35 = 10 * v33 + 100 * v32 + v34 - 5328;
        }

        else
        {
          int v35 = 0;
        }

        uint64_t v13 = 0LL;
        *(_DWORD *)(a1 + 24_Block_object_dispose(va, 8) = v35;
      }

      else
      {
        *(void *)(a1 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 4LL;
        uint64_t v13 = (std::__shared_weak_count *)0xFFFFFFFFLL;
        *(_DWORD *)(a1 + 272) = -1;
        HTTP3Stream::_cleanupStream(a1, 270LL, 0);
        HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
        uint64_t v22 = *(std::__shared_weak_count **)(a1 + 56);
        if (v22)
        {
          unint64_t v23 = std::__shared_weak_count::lock(v22);
          if (v23)
          {
            unint64_t v24 = v23;
            uint64_t v25 = *(void *)(a1 + 48);
            if (v25) {
              HTTP3Connection::reportServerProtocolViolation(v25, 51, *(void *)(a1 + 336));
            }
            uint64_t v26 = (unint64_t *)&v24->__shared_owners_;
            do
              unint64_t v27 = __ldaxr(v26);
            while (__stlxr(v27 - 1, v26));
            if (!v27)
            {
              ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
              std::__shared_weak_count::__release_weak(v24);
            }

            return 0xFFFFFFFFLL;
          }
        }
      }

      break;
    default:
      __assert_rtn("processHeader", "HTTP3Stream.mm", 520, "false");
  }

  return (uint64_t)v13;
}

void sub_182A88184( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, CFTypeRef cf, int a11, __int16 a12, char a13, char a14, void *a15, CFTypeRef a16, int a17, __int16 a18, char a19, char a20)
{
  p_uint64_t shared_owners = (unint64_t *)&v20->__shared_owners_;
  do
    unint64_t v23 = __ldaxr(p_shared_owners);
  while (__stlxr(v23 - 1, p_shared_owners));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }

  _Unwind_Resume(exception_object);
}

void ___ZN15HTTP3Connection10initializeEv_block_invoke(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      int v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && *(void *)(v5 + 1008))
      {
        if ((*(_BYTE *)(v5 + 920) & 8) != 0)
        {
          *(_DWORD *)int valuePtr = 3;
          CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, valuePtr);
          v30[0] = MEMORY[0x1895F87A8];
          uint64_t v7 = ___ZN15HTTP3Connection12_handleStallEv_block_invoke;
          v30[1] = 3221225472LL;
          CFIndex v31 = ___ZN15HTTP3Connection12_handleStallEv_block_invoke;
          uint64_t v32 = &__block_descriptor_40_e5_v8__0l;
          CFNumberRef v33 = v6;
          if (v6)
          {
            (*(void (**)(void, uint64_t, CFNumberRef))(**(void **)(v5 + 1008) + 200LL))( *(void *)(v5 + 1008),  0x18C5ABDB8LL,  v6);
            uint64_t v7 = v31;
          }

          v7((uint64_t)v30);
        }

        if (!*(void *)(v5 + 992))
        {
          CFN_LOG_h3connection();
          unint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            uint64_t v9 = *(void *)(v5 + 1216);
            *(_DWORD *)int valuePtr = 134218240;
            *(void *)&valuePtr[4] = v5;
            *(_WORD *)&valuePtr[12] = 2048;
            *(void *)&valuePtr[14] = v9;
            _os_log_impl(&dword_18298D000, v8, OS_LOG_TYPE_INFO, "%p %llu start stall recovery", valuePtr, 0x16u);
          }

          *(_BYTE *)(v5 + 920) |= 0x20u;
          dispatch_source_t v10 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *(dispatch_queue_t *)(v5 + 1000));
          unint64_t v11 = *(void **)(v5 + 992);
          *(void *)(v5 + 992) = v10;

          uint64_t v13 = *(void *)(v5 + 8);
          unint64_t v12 = *(std::__shared_weak_count **)(v5 + 16);
          if (v12)
          {
            p_shared_weak_owners = (unint64_t *)&v12->__shared_weak_owners_;
            do
              unint64_t v15 = __ldxr(p_shared_weak_owners);
            while (__stxr(v15 + 1, p_shared_weak_owners));
          }

          uint64_t v16 = MEMORY[0x1895F87A8];
          *(void *)int valuePtr = MEMORY[0x1895F87A8];
          *(void *)&valuePtr[8] = 3321888768LL;
          *(void *)&valuePtr[16] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke;
          unsigned __int8 v41 = &__block_descriptor_56_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE_e5_v8__0l;
          uint64_t v42 = v5;
          uint64_t v43 = v13;
          char v44 = v12;
          if (v12)
          {
            uint64_t v17 = (unint64_t *)&v12->__shared_weak_owners_;
            do
              unint64_t v18 = __ldxr(v17);
            while (__stxr(v18 + 1, v17));
          }

          uint64_t v19 = _Block_copy(valuePtr);
          uint64_t v20 = *(dispatch_source_s **)(v5 + 992);
          handler[0] = v16;
          handler[1] = 3221225472LL;
          handler[2] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_22;
          handler[3] = &unk_189C1A298;
          id v21 = v19;
          id v39 = v21;
          dispatch_source_set_cancel_handler(v20, handler);
          uint64_t v22 = *(dispatch_source_s **)(v5 + 992);
          v34[0] = v16;
          v34[1] = 3321888768LL;
          v34[2] = ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_2;
          v34[3] = &unk_189C08380;
          id v23 = v21;
          id v35 = v23;
          uint64_t v36 = v13;
          char v37 = v12;
          if (v12)
          {
            unint64_t v24 = (unint64_t *)&v12->__shared_weak_owners_;
            do
              unint64_t v25 = __ldxr(v24);
            while (__stxr(v25 + 1, v24));
          }

          dispatch_source_set_event_handler(v22, v34);
          uint64_t v26 = *(dispatch_source_s **)(v5 + 992);
          dispatch_time_t v27 = dispatch_time(0x8000000000000000LL, 4000000000LL);
          dispatch_source_set_timer(v26, v27, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
          (*(void (**)(void, void, uint64_t))(**(void **)(v5 + 1008) + 136LL))( *(void *)(v5 + 1008),  0LL,  1LL);
          dispatch_resume(*(dispatch_object_t *)(v5 + 992));
          if (v37) {
            std::__shared_weak_count::__release_weak(v37);
          }

          if (v44) {
            std::__shared_weak_count::__release_weak(v44);
          }
          if (v12) {
            std::__shared_weak_count::__release_weak(v12);
          }
        }
      }

      p_uint64_t shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v29 = __ldaxr(p_shared_owners);
      while (__stlxr(v29 - 1, p_shared_owners));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182A88690( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, void (*a14)(char *), uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, std::__shared_weak_count *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, std::__shared_weak_count *a35)
{
}

void ___ZN15HTTP3Connection10initializeEv_block_invoke_3(uint64_t a1, int a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v12[0]) = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)v12,  2u);
    }

    if ((CFTypeRef)*MEMORY[0x189604DE8] == cf)
    {
      CFNumberRef v6 = *(std::__shared_weak_count **)(a1 + 40);
      if (v6)
      {
        uint64_t v7 = std::__shared_weak_count::lock(v6);
        v12[1] = v7;
        if (v7)
        {
          unint64_t v8 = v7;
          uint64_t v9 = *(void *)(a1 + 32);
          v12[0] = v9;
          if (v9)
          {
            *(_BYTE *)(v9 + 920) |= 2u;
            if (*(void *)(v9 + 1136) == *(void *)(v9 + 1144)) {
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v9, 256LL, 0LL);
            }
          }

          p_uint64_t shared_owners = (unint64_t *)&v8->__shared_owners_;
          do
            unint64_t v11 = __ldaxr(p_shared_owners);
          while (__stlxr(v11 - 1, p_shared_owners));
          if (!v11)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
    }
  }

void sub_182A88824( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ___ZN15HTTP3Connection10initializeEv_block_invoke_6(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (!v2) {
    return 0LL;
  }
  int v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0LL;
  }
  int v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5 && (uint64_t v6 = *(void *)(v5 + 1008)) != 0) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 216LL))(v6, 0x18C5AB680LL);
  }
  else {
    uint64_t v7 = 0LL;
  }
  p_uint64_t shared_owners = (unint64_t *)&v4->__shared_owners_;
  do
    unint64_t v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }

  return v7;
}

void sub_182A888E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HTTP3Connection::_requestNewServerStreamHandle(HTTP3Connection *this)
{
  uint64_t v2 = *((void *)this + 126);
  if (v2 && (*((_BYTE *)this + 920) & 4) == 0)
  {
    uint64_t v3 = *MEMORY[0x189608E98];
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3321888768LL;
    void v12[2] = ___ZN15HTTP3Connection29_requestNewServerStreamHandleEv_block_invoke;
    v12[3] = &__block_descriptor_48_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    v12[4] = v14;
    uint64_t v13 = v15;
    if (v15)
    {
      p_uint64_t shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }

    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v2 + 56LL))( v2,  v3,  1LL,  132000LL,  v12);
    uint64_t v6 = v13;
    if (v13)
    {
      uint64_t v7 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

  unint64_t v9 = v15;
  if (v15)
  {
    dispatch_source_t v10 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

void sub_182A88A28(_Unwind_Exception *a1)
{
}

void ___ZN15HTTP3Connection29_requestNewServerStreamHandleEv_block_invoke( uint64_t a1, void *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  id v12 = a2;
  id v13 = a3;
  if (v12 && !(_DWORD)a6)
  {
    uint64_t v14 = *(void *)(a1 + 32);
    id v15 = v12;
    uint64_t v16 = (dispatch_data_s *)v13;
    uint64_t v17 = v16;
    if (v16 && (size_t size = dispatch_data_get_size(v16)) != 0)
    {
      size_t v19 = size;
      if (*(void *)(v14 + 992)) {
        HTTP3Connection::_stopStallRecovery((HTTP3Connection *)v14);
      }
      uint64_t v49 = 0LL;
      CFTypeRef v50 = &v49;
      uint64_t v20 = MEMORY[0x1895F87A8];
      uint64_t v51 = 0x2020000000LL;
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 3221225472LL;
      applier[2] = ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke;
      applier[3] = &unk_189C16CD0;
      applier[4] = &v49;
      dispatch_data_apply(v17, applier);
      dispatch_data_t subrange = dispatch_data_create_subrange(v17, 1uLL, v19);
      switch(*((_BYTE *)v50 + 24))
      {
        case 0:
          if (!HTTP3Framer::setReadHandleBeforeReading(*(void *)(v14 + 1024), v15, subrange, 0))
          {
            *(void *)(v14 + 1160) = 4LL;
            *(_DWORD *)(v14 + 116_Block_object_dispose(va, 8) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259LL, 0LL);
            int v39 = 1;
            goto LABEL_41;
          }

          HTTP3Connection::_readControlStream((HTTP3Connection *)v14);
          break;
        case 1:
          std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v46,  *(void *)(v14 + 8),  *(std::__shared_weak_count **)(v14 + 16));
          *(void *)__int128 buf = v20;
          *(void *)&uint8_t buf[8] = 3321888768LL;
          *(void *)&uint8_t buf[16] = ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke_2;
          uint64_t v53 = &unk_189C084B8;
          uint64_t v55 = v14;
          uint64_t v56 = v46;
          uint64_t v57 = v47;
          if (v47)
          {
            p_uint64_t shared_owners = (unint64_t *)&v47->__shared_owners_;
            do
              unint64_t v32 = __ldxr(p_shared_owners);
            while (__stxr(v32 + 1, p_shared_owners));
          }

          id v54 = v15;
          HTTP3Connection::_readPushID(v14, v54, subrange, a4, buf);

          CFNumberRef v33 = v57;
          if (v57)
          {
            uint64_t v34 = (unint64_t *)&v57->__shared_owners_;
            do
              unint64_t v35 = __ldaxr(v34);
            while (__stlxr(v35 - 1, v34));
            if (!v35)
            {
              ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
              std::__shared_weak_count::__release_weak(v33);
            }
          }

          uint64_t v36 = v47;
          if (v47)
          {
            char v37 = (unint64_t *)&v47->__shared_owners_;
            do
              unint64_t v38 = __ldaxr(v37);
            while (__stlxr(v38 - 1, v37));
            if (!v38)
            {
              ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
              std::__shared_weak_count::__release_weak(v36);
            }
          }

          break;
        case 2:
          if (*(void *)(v14 + 1048))
          {
            *(void *)(v14 + 1160) = 4LL;
            *(_DWORD *)(v14 + 116_Block_object_dispose(va, 8) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259LL, 0LL);
            int v39 = 17;
            goto LABEL_41;
          }

          objc_storeStrong((id *)(v14 + 1048), a2);
          HTTP3Connection::_readEncoderStream(v14, subrange);
          break;
        case 3:
          if (*(void *)(v14 + 1064))
          {
            *(void *)(v14 + 1160) = 4LL;
            *(_DWORD *)(v14 + 116_Block_object_dispose(va, 8) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v14, 259LL, 0LL);
            int v39 = 33;
LABEL_41:
            HTTP3Connection::reportServerProtocolViolation(v14, v39, -1LL);
          }

          else
          {
            objc_storeStrong((id *)(v14 + 1064), a2);
            HTTP3Connection::_readDecoderStream(v14, subrange);
          }

          break;
        default:
          CFN_LOG_h3connection();
          CFIndex v40 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
          {
            uint64_t v41 = *(void *)(v14 + 1216);
            int v42 = *((unsigned __int8 *)v50 + 24);
            *(_DWORD *)__int128 buf = 134218496;
            *(void *)&uint8_t buf[4] = v14;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v41;
            *(_WORD *)&_BYTE buf[22] = 1024;
            LODWORD(v53) = v42;
            _os_log_impl( &dword_18298D000,  v40,  OS_LOG_TYPE_INFO,  "%p %llu unknown incoming stream type (0x%02x)",  buf,  0x1Cu);
          }

          uint64_t v43 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
          nw_protocol_metadata_t v44 = nw_content_context_copy_protocol_metadata((nw_content_context_t)v15, v43);

          uint64_t v45 = (void *)nw_quic_connection_copy_stream_metadata();
          nw_quic_stream_set_application_error();
          (*(void (**)(void, id))(**(void **)(v14 + 1008) + 80LL))(*(void *)(v14 + 1008), v15);

          break;
      }

      _Block_object_dispose(&v49, 8);
    }

    else
    {
      CFN_LOG_h3connection();
      uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
      {
        uint64_t v27 = *(void *)(v14 + 1216);
        *(_DWORD *)__int128 buf = 134218240;
        *(void *)&uint8_t buf[4] = v14;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v27;
        _os_log_impl(&dword_18298D000, v26, OS_LOG_TYPE_INFO, "%p %llu ignore empty incoming stream", buf, 0x16u);
      }

      unint64_t v28 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
      nw_protocol_metadata_t v29 = nw_content_context_copy_protocol_metadata((nw_content_context_t)v15, v28);

      CFTypeRef v30 = (void *)nw_quic_connection_copy_stream_metadata();
      nw_quic_stream_set_application_error();
      (*(void (**)(void, id))(**(void **)(v14 + 1008) + 80LL))(*(void *)(v14 + 1008), v15);
    }

    uint64_t v22 = *(HTTP3Connection **)(a1 + 32);
    goto LABEL_44;
  }

  uint64_t v22 = *(HTTP3Connection **)(a1 + 32);
  if (a5 == 1 && (_DWORD)a6 == 54)
  {
LABEL_44:
    HTTP3Connection::_requestNewServerStreamHandle(v22);
    goto LABEL_45;
  }

  v59.CFIndex domain = a5;
  *(void *)&v59.uint64_t error = a6;
  if (HTTP3Connection::checkAndPerformFallback(v22, v59))
  {
    CFN_LOG_h3connection();
    id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = *(void *)(a1 + 32);
      uint64_t v25 = *(void *)(v24 + 1216);
      *(_DWORD *)__int128 buf = 134218240;
      *(void *)&uint8_t buf[4] = v24;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v25;
      _os_log_impl(&dword_18298D000, v23, OS_LOG_TYPE_DEFAULT, "%p %llu New stream fallback triggered", buf, 0x16u);
    }
  }

  else
  {
    HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 32), -1LL, 0LL);
  }

void sub_182A88FC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t HTTP3Connection::checkAndPerformFallback(HTTP3Connection *this, CFStreamError a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  char v2 = *((_BYTE *)this + 920);
  if ((v2 & 0x10) != 0) {
    return 1LL;
  }
  uint64_t result = 0LL;
  if ((v2 & 0x20) != 0 && a2.domain == 1 && a2.error == 60LL)
  {
    CFN_LOG_h3connection();
    unint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v25 = (HTTP3Stream *)*((void *)this + 152);
      *(_DWORD *)__int128 buf = 134218240;
      *(void *)&uint8_t buf[4] = this;
      __int16 v32 = 2048;
      CFNumberRef v33 = v25;
      _os_log_error_impl(&dword_18298D000, v5, OS_LOG_TYPE_ERROR, "%p %llu stalled, attempting fallback", buf, 0x16u);
    }

    *((_BYTE *)this + 920) |= 0x10u;
    HTTP3Connection::_stopStallRecovery(this);
    uint64_t v6 = *((void *)this + 126);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 128LL))(v6, 1LL);
    }
    uint64_t v28 = 0LL;
    uint64_t v29 = 4LL;
    LODWORD(v30) = -5;
    uint64_t v26 = 0LL;
    uint64_t v27 = 0LL;
    std::vector<std::shared_ptr<HTTP3Stream>>::__init_with_size[abi:nn180100]<std::shared_ptr<HTTP3Stream>*,std::shared_ptr<HTTP3Stream>*>( &v26,  *((void **)this + 142),  *((void **)this + 143),  (uint64_t)(*((void *)this + 143) - *((void *)this + 142)) >> 4);
    uint64_t v7 = v26;
    for (uint64_t i = v27; v7 != i; v7 += 16LL)
    {
      dispatch_source_t v10 = *(HTTP3Stream **)v7;
      unint64_t v9 = *(std::__shared_weak_count **)(v7 + 8);
      if (v9)
      {
        p_uint64_t shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          unint64_t v12 = __ldxr(p_shared_owners);
        while (__stxr(v12 + 1, p_shared_owners));
      }

      if ((*(unsigned int (**)(void, uint64_t *, void))(**((void **)v10 + 37) + 280LL))( *((void *)v10 + 37),  &v29,  0LL)
         - 5 <= 5)
      {
        CFN_LOG_h3stream();
        id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          uint64_t v23 = *((void *)v10 + 44);
          uint64_t v24 = *((void *)v10 + 42);
          *(_DWORD *)__int128 buf = 138543874;
          *(void *)&uint8_t buf[4] = v23;
          __int16 v32 = 2048;
          CFNumberRef v33 = v10;
          __int16 v34 = 2048;
          uint64_t v35 = v24;
          _os_log_error_impl( &dword_18298D000,  v13,  OS_LOG_TYPE_ERROR,  "%{public}@ %p ID=%llu handling fallback",  buf,  0x20u);
        }

        uint64_t v14 = *((void *)v10 + 37);
        if (v14) {
          uint64_t v15 = v14 - 176;
        }
        else {
          uint64_t v15 = 0LL;
        }
        id v16 = *(id *)(v15 + 80);
        [v16 session];
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue();
        [(id)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*((void *)v10 + 8) + 128)) host];
        unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
        -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:]((uint64_t)v17, v18, 64LL);

        uint64_t v19 = v29;
        uint64_t v20 = v30;
        HTTP3Stream::_cleanupStream((uint64_t)v10, 256LL, 0);
        *((void *)v10 + 33) = v19;
        *((void *)v10 + 3os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v20;
        HTTP3Stream::_protocolCallback(v10);
      }

      if (v9)
      {
        id v21 = (unint64_t *)&v9->__shared_owners_;
        do
          unint64_t v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }

    HTTP3Connection::_cleanupConnection(this, 256LL, 0LL);
    *(void *)__int128 buf = &v26;
    std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    return 1LL;
  }

  return result;
}

void sub_182A893A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  a17 = (void **)&a12;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a17);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *a4;
  return 0LL;
}

void HTTP3Connection::_readControlStream(HTTP3Connection *this)
{
  if (!*((void *)this + 126) || (*((_BYTE *)this + 920) & 4) != 0) {
    return;
  }
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v26,  *((void *)this + 1),  *((std::__shared_weak_count **)this + 2));
  uint64_t v2 = *((void *)this + 128);
  uint64_t v3 = MEMORY[0x1895F87A8];
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 3321888768LL;
  void v24[2] = ___ZN15HTTP3Connection18_readControlStreamEv_block_invoke;
  v24[3] = &__block_descriptor_56_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e65_v56__0_FrameMetadata_QQQ_8__NSObject_OS_dispatch_data__32___qi_40l;
  v24[4] = this;
  v24[5] = v26;
  uint64_t v25 = v27;
  if (v27)
  {
    p_uint64_t shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  uint64_t v6 = v24;
  if (*(_DWORD *)(v2 + 76))
  {
    unint64_t v22 = "_state == State::ReadingHeader";
    int v23 = 241;
    goto LABEL_34;
  }

  if (*(_BYTE *)(v2 + 72))
  {
    unint64_t v22 = "!_processingReadCall";
    int v23 = 242;
LABEL_34:
    __assert_rtn("readFrame", "HTTP3Frame.mm", v23, v22);
  }

  *(_BYTE *)(v2 + 72) = 1;
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v32,  *(void *)v2,  *(std::__shared_weak_count **)(v2 + 8));
  v28[0] = v3;
  v28[1] = 3321888768LL;
  v28[2] = ___ZN11HTTP3Framer9readFrameEmU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorE_block_invoke;
  v28[3] = &unk_189C03228;
  uint64_t v30 = v32;
  CFIndex v31 = v33;
  if (v33)
  {
    uint64_t v7 = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  unint64_t v9 = v6;
  id v29 = v9;
  HTTP3Framer::_readFrame(v2, 1024LL, MEMORY[0x1895F8AA8], v28);

  dispatch_source_t v10 = v31;
  if (v31)
  {
    unint64_t v11 = (unint64_t *)&v31->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  id v13 = v33;
  if (v33)
  {
    uint64_t v14 = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  id v16 = v25;
  if (v25)
  {
    uint64_t v17 = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  uint64_t v19 = v27;
  if (v27)
  {
    uint64_t v20 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

void sub_182A896C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id a22)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v23);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v24 - 64);

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection20_setupIncomingStreamEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_b_block_invoke_2( uint64_t a1, void *a2, int a3, unint64_t a4)
{
  id v62 = a2;
  if (*(int *)(*(void *)(a1 + 40) + 792LL) - 1LL < a4)
  {
    HTTP3Connection::_cleanupConnection(*(HTTP3Connection **)(a1 + 48), 264LL, 0LL);
    HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 48), 55, -1LL);
    goto LABEL_117;
  }

  uint64_t v7 = *(void *)(a1 + 48);
  unint64_t v8 = (std::__shared_weak_count *)operator new(0xB8uLL);
  unint64_t v9 = v8;
  v8->__shared_owners_ = 0LL;
  p_uint64_t shared_owners = (unint64_t)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0LL;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_189C087D8;
  unint64_t v11 = &v8[1].__vftable;
  uint64_t v12 = *(void *)(v7 + 1008);
  if (v12) {
    id v13 = (uint64_t *)(v12 + 112);
  }
  else {
    id v13 = 0LL;
  }
  uint64_t v14 = *(std::__shared_weak_count **)(v7 + 1016);
  uint64_t v68 = v13;
  uint64_t v69 = v14;
  if (v14)
  {
    unint64_t v15 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  HTTP3Framer::HTTP3Framer((uint64_t)&v8[1], (uint64_t *)&v68, 0LL, 1LL, 1);
  if (v14)
  {
    uint64_t v17 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  uint64_t v64 = v11;
  uint64_t v65 = v9;
  std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( (uint64_t)&v64,  v11,  (uint64_t)v11);
  HTTP3Framer::setReadHandleBeforeReading((uint64_t)v11, *(void **)(a1 + 32), v62, a3);
  uint64_t v19 = *(void *)(a1 + 48);
  double v63 = v9;
  do
    unint64_t v20 = __ldxr((unint64_t *)p_shared_owners);
  while (__stxr(v20 + 1, (unint64_t *)p_shared_owners));
  if (*(_DWORD *)(v19 + 792) <= (int)a4)
  {
    char v22 = 0;
    goto LABEL_105;
  }

  int v21 = *(_DWORD *)(v19 + 796);
  if (v21 <= (int)a4)
  {
    if (v21 < (int)a4)
    {
      do
      {
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>( v19 + 800,  v21,  v21);
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>( v19 + 840,  v21,  v21);
        ++v21;
      }

      while ((_DWORD)a4 != v21);
    }

    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>( v19 + 800,  a4,  a4);
    *(_DWORD *)(v19 + 796) = a4 + 1;
  }

  else if (!std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__erase_unique<int>( (uint64_t *)(v19 + 840),  a4))
  {
    char v22 = 0;
    goto LABEL_104;
  }

  int v66 = a4;
  *(void *)&__int128 v67 = v11;
  *((void *)&v67 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v9;
  do
    unint64_t v23 = __ldxr((unint64_t *)p_shared_owners);
  while (__stxr(v23 + 1, (unint64_t *)p_shared_owners));
  unint64_t v24 = *(void *)(v19 + 888);
  if (!v24) {
    goto LABEL_43;
  }
  uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v24);
  v25.i16[0] = vaddlv_u8(v25);
  if (v25.u32[0] > 1uLL)
  {
    p_uint64_t shared_owners = (int)a4;
  }

  else
  {
    p_uint64_t shared_owners = (v24 - 1) & (int)a4;
  }

  uint64_t v26 = *(uint64_t ***)(*(void *)(v19 + 880) + 8 * p_shared_owners);
  if (!v26 || (uint64_t v27 = *v26) == 0LL)
  {
LABEL_43:
    id v29 = operator new(0x28uLL);
    uint64_t v30 = (void *)(v19 + 896);
    uint64_t v68 = v29;
    uint64_t v69 = (std::__shared_weak_count *)(v19 + 896);
    void *v29 = 0LL;
    v29[1] = (int)a4;
    *((_DWORD *)v29 + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a4;
    *(_OWORD *)(v29 + 3) = v67;
    __int128 v67 = 0uLL;
    char v70 = 1;
    float v31 = (float)(unint64_t)(*(void *)(v19 + 904) + 1LL);
    float v32 = *(float *)(v19 + 912);
    if (v24 && (float)(v32 * (float)v24) >= v31)
    {
LABEL_89:
      uint64_t v49 = *(uint64_t **)(*(void *)(v19 + 880) + 8 * p_shared_owners);
      uint64_t v50 = (uint64_t)v68;
      if (v49)
      {
        *uint64_t v68 = *v49;
      }

      else
      {
        *uint64_t v68 = *(void *)(v19 + 896);
        *(void *)(v19 + 896) = v50;
        *(void *)(*(void *)(v19 + 880) + 8 * p_shared_owners) = v30;
        if (!*(void *)v50)
        {
LABEL_98:
          uint64_t v68 = 0LL;
          ++*(void *)(v19 + 904);
          std::unique_ptr<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,std::shared_ptr<HTTP3Framer>>,void *>>>>::reset[abi:nn180100]((uint64_t)&v68);
          goto LABEL_99;
        }

        unint64_t v51 = *(void *)(*(void *)v50 + 8LL);
        if ((v24 & (v24 - 1)) != 0)
        {
          if (v51 >= v24) {
            v51 %= v24;
          }
        }

        else
        {
          v51 &= v24 - 1;
        }

        uint64_t v49 = (uint64_t *)(*(void *)(v19 + 880) + 8 * v51);
      }

      *uint64_t v49 = v50;
      goto LABEL_98;
    }

    BOOL v33 = 1LL;
    if (v24 >= 3) {
      BOOL v33 = (v24 & (v24 - 1)) != 0;
    }
    unint64_t v34 = v33 | (2 * v24);
    unint64_t v35 = vcvtps_u32_f32(v31 / v32);
    if (v34 <= v35) {
      int8x8_t prime = (int8x8_t)v35;
    }
    else {
      int8x8_t prime = (int8x8_t)v34;
    }
    if (*(void *)&prime == 1LL)
    {
      int8x8_t prime = (int8x8_t)2LL;
    }

    else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }

    unint64_t v24 = *(void *)(v19 + 888);
    if (*(void *)&prime > v24) {
      goto LABEL_55;
    }
    if (*(void *)&prime < v24)
    {
      unint64_t v43 = vcvtps_u32_f32((float)*(unint64_t *)(v19 + 904) / *(float *)(v19 + 912));
      if (v24 < 3 || (uint8x8_t v44 = (uint8x8_t)vcnt_s8((int8x8_t)v24), v44.i16[0] = vaddlv_u8(v44), v44.u32[0] > 1uLL))
      {
        unint64_t v43 = std::__next_prime(v43);
      }

      else
      {
        uint64_t v45 = 1LL << -(char)__clz(v43 - 1);
        if (v43 >= 2) {
          unint64_t v43 = v45;
        }
      }

      if (*(void *)&prime <= v43) {
        int8x8_t prime = (int8x8_t)v43;
      }
      if (*(void *)&prime >= v24)
      {
        unint64_t v24 = *(void *)(v19 + 888);
      }

      else
      {
        if (prime)
        {
LABEL_55:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          char v37 = operator new(8LL * *(void *)&prime);
          unint64_t v38 = *(void **)(v19 + 880);
          *(void *)(v19 + 8std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = v37;
          if (v38) {
            operator delete(v38);
          }
          uint64_t v39 = 0LL;
          *(int8x8_t *)(v19 + 88_Block_object_dispose(va, 8) = prime;
          do
            *(void *)(*(void *)(v19 + 880) + 8 * v39++) = 0LL;
          while (*(void *)&prime != v39);
          CFIndex v40 = (void *)*v30;
          if (*v30)
          {
            unint64_t v41 = v40[1];
            uint8x8_t v42 = (uint8x8_t)vcnt_s8(prime);
            v42.i16[0] = vaddlv_u8(v42);
            if (v42.u32[0] > 1uLL)
            {
              if (v41 >= *(void *)&prime) {
                v41 %= *(void *)&prime;
              }
            }

            else
            {
              v41 &= *(void *)&prime - 1LL;
            }

            *(void *)(*(void *)(v19 + 880) + 8 * v4__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v30;
            uint64_t v46 = (void *)*v40;
            if (*v40)
            {
              do
              {
                unint64_t v47 = v46[1];
                if (v42.u32[0] > 1uLL)
                {
                  if (v47 >= *(void *)&prime) {
                    v47 %= *(void *)&prime;
                  }
                }

                else
                {
                  v47 &= *(void *)&prime - 1LL;
                }

                if (v47 != v41)
                {
                  uint64_t v48 = *(void *)(v19 + 880);
                  if (!*(void *)(v48 + 8 * v47))
                  {
                    *(void *)(v48 + 8 * v47) = v40;
                    goto LABEL_80;
                  }

                  *CFIndex v40 = *v46;
                  *uint64_t v46 = **(void **)(*(void *)(v19 + 880) + 8 * v47);
                  **(void **)(*(void *)(v19 + 880) + 8 * v47) = v46;
                  uint64_t v46 = v40;
                }

                unint64_t v47 = v41;
LABEL_80:
                CFIndex v40 = v46;
                uint64_t v46 = (void *)*v46;
                unint64_t v41 = v47;
              }

              while (v46);
            }
          }

          unint64_t v24 = (unint64_t)prime;
          goto LABEL_84;
        }

        unsigned int v61 = *(void **)(v19 + 880);
        *(void *)(v19 + 8std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = 0LL;
        if (v61) {
          operator delete(v61);
        }
        unint64_t v24 = 0LL;
        *(void *)(v19 + 88_Block_object_dispose(va, 8) = 0LL;
      }
    }

LABEL_84:
    if ((v24 & (v24 - 1)) != 0)
    {
      else {
        p_uint64_t shared_owners = (int)a4;
      }
    }

    else
    {
      p_uint64_t shared_owners = (v24 - 1) & (int)a4;
    }

    goto LABEL_89;
  }

  while (1)
  {
    unint64_t v28 = v27[1];
    if (v25.u32[0] > 1uLL)
    {
      if (v28 >= v24) {
        v28 %= v24;
      }
    }

    else
    {
      v28 &= v24 - 1;
    }

    if (v28 != p_shared_owners) {
      goto LABEL_43;
    }
LABEL_42:
    uint64_t v27 = (uint64_t *)*v27;
    if (!v27) {
      goto LABEL_43;
    }
  }

  if (*((_DWORD *)v27 + 4) != (_DWORD)a4) {
    goto LABEL_42;
  }
  CFStreamError v59 = (unint64_t *)&v9->__shared_owners_;
  do
    unint64_t v60 = __ldaxr(v59);
  while (__stlxr(v60 - 1, v59));
  if (!v60)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }

LABEL_99:
  uint64_t v52 = std::__hash_table<std::__hash_value_type<int,HTTP2ServerPushStream &>,std::__unordered_map_hasher<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,HTTP2ServerPushStream &>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,HTTP2ServerPushStream &>>>::find<int>( (void *)(v19 + 672),  a4);
  if (v52 && (uint64_t v53 = v52[3]) != 0 && HTTP2ServerPushStream::_invokeCompletionHadlers(v53, 0))
  {
    char v22 = 1;
    HTTP2ServerPush::_removeStream((HTTP2ServerPush *)(v19 + 624), a4, 1);
  }

  else
  {
    char v22 = 1;
  }

      HTTP3Stream::_reportResult((HTTP3Stream *)v12, 0);
      break;
    case 2u:
      *(void *)(v12 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a5;
      *(void *)(v12 + 272) = a6;
      goto LABEL_99;
    case 3u:
      goto LABEL_97;
    case 4u:
      *(void *)(v12 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 4LL;
      int v66 = -1;
      goto LABEL_98;
    case 5u:
      *(void *)(v12 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 4LL;
      double v73 = -2205;
      goto LABEL_117;
    case 6u:
      if (!*(_DWORD *)(v12 + 116)) {
        goto LABEL_116;
      }
      *(void *)__int128 buf = 0LL;
      *(void *)&uint8_t buf[8] = 0LL;
      char v74 = *(std::__shared_weak_count **)(v12 + 56);
      if (v74)
      {
        *(void *)&uint8_t buf[8] = std::__shared_weak_count::lock(v74);
        if (*(void *)&buf[8])
        {
          uint64_t v75 = *(void *)(v12 + 48);
          *(void *)__int128 buf = v75;
          if (v75)
          {
            *(void *)(v75 + 1160) = 4LL;
            *(_DWORD *)(v75 + 116_Block_object_dispose(va, 8) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v75, 257LL, 0LL);
            HTTP3Connection::reportServerProtocolViolation(*(uint64_t *)buf, 50, *(void *)(v12 + 336));
          }
        }
      }

      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)buf);
      *(void *)(v12 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 4LL;
      double v73 = -1;
      goto LABEL_117;
    case 7u:
      uint64_t v68 = *(void *)(v12 + 296);
      if (v68) {
        uint64_t v69 = v68 - 176;
      }
      else {
        uint64_t v69 = 0LL;
      }
      char v70 = *(id *)(v69 + 80);
      [v70 session];
      uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue();
      [(id)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*(void *)(v12 + 64) + 128)) host];
      uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue();
      if (v71) {
        -[NSURLSession addToHTTPFallbackHosts:forbiddenProtocols:]((uint64_t)v71, v72, 80LL);
      }

LABEL_116:
      *(void *)(v12 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 4LL;
      double v73 = -2200;
LABEL_117:
      *(_DWORD *)(v12 + 272) = v73;
      break;
    default:
      break;
  }

LABEL_104:
  unint64_t v9 = v63;
  if (v63)
  {
LABEL_105:
    id v54 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (v55) {
      goto LABEL_108;
    }
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if ((v22 & 1) == 0) {
LABEL_111:
    }
      HTTP3Framer::cancelStream((uint64_t)v64, 268LL);
  }

  else
  {
LABEL_108:
    if ((v22 & 1) == 0) {
      goto LABEL_111;
    }
  }

  uint64_t v56 = v65;
  if (v65)
  {
    uint64_t v57 = (unint64_t *)&v65->__shared_owners_;
    do
      unint64_t v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }

      if (!AuthenticationState::isValid(*((void *)this + 97), 0))
      {
        uint64_t v64 = 0LL;
        *((_DWORD *)this + 48) |= 0x40000u;
LABEL_355:
        unint64_t v4 = v64;
        goto LABEL_356;
      }

      __int128 buf = 0uLL;
      if (v8 == 407
        || !(*(unsigned int (**)(void))(**((void **)this + 35) + 88LL))(*((void *)this + 35))
        || (*(unsigned int (**)(void))(**((void **)this + 35) + 88LL))(*((void *)this + 35)) == 1)
      {
        double v63 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 35) + 72LL))(*((void *)this + 35));
        if (v63) {
          CFIndex v176 = (const __CFString *)CFRetain(v63);
        }
        else {
          CFIndex v176 = 0LL;
        }
        CFIndex v173 = (*(uint64_t (**)(void))(**((void **)this + 35) + 80LL))(*((void *)this + 35));
        uint64_t v65 = (*(uint64_t (**)(void))(**((void **)this + 35) + 88LL))(*((void *)this + 35));
        int v66 = *(uint64_t (**(void))(**((void **)this + 35) + 64LL))(*((void *)this + 35));
      }

      else
      {
        double v82 = *(const __CFURL **)([*((id *)this + 11) _inner] + 8);
        uint64_t v65 = connectionTypeFromURL(v82);
        CFIndex v176 = CFURLCopyHostName(v82);
        double v83 = CFURLGetPortNumber(v82);
        int v66 = 0LL;
        if (v65) {
          uint64_t v84 = 443;
        }
        else {
          uint64_t v84 = 80;
        }
        if (v83 != -1) {
          uint64_t v84 = v83;
        }
        CFIndex v173 = v84;
      }

      CFIndex v174 = 0LL;
      if (*v178) {
        __int128 v67 = v50 == 6;
      }
      else {
        __int128 v67 = 0;
      }
      uint64_t v68 = !v67;
      CFIndex v175 = v68;
      if (v50 == 9 && *v178)
      {
        CFIndex v174 = (const __CFString *)HTTPAuthentication::copyRealm((HTTPAuthentication *)v48);
        CFIndex v175 = 0;
      }

      else {
        uint64_t v69 = dword_182C9D950[v65 - 1];
      }
      char v70 = HTTPAuthentication::copyRealm((HTTPAuthentication *)v48);
      uint64_t v71 = (const __CFString *)v70;
      CFIndex v181 = 0LL;
      CFIndex v182 = 0LL;
      if (v69 == 6)
      {
        int valuePtr = 0;
        int Value = (const __CFDictionary *)CFDictionaryGetValue(v66, &unk_18C5B2450);
        double v73 = Value;
        if (Value
          && (char v74 = (const __CFString *)CFDictionaryGetValue(Value, &unk_18C5B2488),
              uint64_t v75 = (const __CFNumber *)CFDictionaryGetValue(v73, &unk_18C5B24C0),
              CFNumberGetValue(v75, kCFNumberSInt32Type, &valuePtr),
              v74))
        {
          int v76 = valuePtr;
          char v77 = v176;
        }

        else
        {
          int v76 = v173;
          int valuePtr = v173;
          char v77 = v176;
          char v74 = v176;
        }

        char v79 = v74;
        SecCertificateRef v78 = v71;
        HTTPAuthentication::buildProtectionSpacesFromAuthSchemes((CFArrayRef *)&cf, v48 - 16, v79, v76, 6, v71);
        std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>( &buf,  (uint64_t *)&cf);
        if ((void)cf) {
          CFRelease((CFTypeRef)cf);
        }
        if ((void)buf)
        {
          if (CFArrayGetValueAtIndex((CFArrayRef)buf, 0LL))
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)buf, 0LL);
            unsigned int v81 = CFRetain(ValueAtIndex);
          }

          else
          {
            unsigned int v81 = 0LL;
          }

          *(void *)&CFTypeRef cf = v81;
          int v85 = operator new(0x20uLL);
LABEL_172:
          *int v85 = off_189C17058;
          v85[1] = 0LL;
          void v85[2] = 0LL;
          v85[3] = v81;
          *((void *)&cf + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v85;
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)&v181, &cf);
          std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&cf);
          SecCertificateRef v78 = v71;
        }
      }

      else
      {
        SecCertificateRef v78 = (const __CFString *)v70;
        if (!v70)
        {
          if (v50 == 12 || v50 == 10) {
            SecCertificateRef v78 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, &stru_189C1D1D8);
          }
          else {
            SecCertificateRef v78 = 0LL;
          }
        }

        HTTPAuthentication::buildProtectionSpacesFromAuthSchemes((CFArrayRef *)&cf, v48 - 16, v176, v173, v69, v78);
        std::shared_ptr<__CFArray const>::operator=[abi:nn180100]<__CFArray const,Deleter_CFRelease,void>( &buf,  (uint64_t *)&cf);
        char v77 = v176;
        if ((void)cf) {
          CFRelease((CFTypeRef)cf);
        }
        if ((void)buf)
        {
          uint64_t v71 = v78;
          if (CFArrayGetValueAtIndex((CFArrayRef)buf, 0LL))
          {
            uint64_t v93 = CFArrayGetValueAtIndex((CFArrayRef)buf, 0LL);
            unsigned int v81 = CFRetain(v93);
          }

          else
          {
            unsigned int v81 = 0LL;
          }

          *(void *)&CFTypeRef cf = v81;
          int v85 = operator new(0x20uLL);
          goto LABEL_172;
        }
      }

      if (v77) {
        CFRelease(v77);
      }
      if (v78) {
        CFRelease(v78);
      }
      __int16 v94 = v78;
      unint64_t v95 = *(unsigned __int8 *)(v48 + 224);
      CFTypeRef v96 = v181;
      if (v8 == 407)
      {
        if (v181)
        {
          CFIndex v97 = v177;
          unint64_t v98 = *((_DWORD *)v96 + 18) == 6;
        }

        else
        {
          unint64_t v98 = 0;
          CFIndex v97 = v177;
        }

        if (v50 != 6 && !v98)
        {
          if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this))
          {
            uint64_t v100 = *((void *)this + 43);
            if (v100 != 0x7FFFFFFFFFFFFFFFLL) {
              *((void *)this + 43) = v100 + 1;
            }
          }

          if (a2) {
            unint64_t v101 = CFRetain(a2);
          }
          else {
            unint64_t v101 = 0LL;
          }
          uint64_t v109 = (const void *)*((void *)this + 42);
          *((void *)this + 42) = v101;
          if (v109) {
            CFRelease(v109);
          }
          if ((v175 & 1) == 0)
          {
            uint64_t v117 = CFGetAllocator((char *)this - 16);
            char v111 = (const void *)CFURLCredentialCreate((uint64_t)v117, &stru_189C1D1D8, &stru_189C1D1D8, v118, 1);
            (*(void (**)(HTTPProtocol *, const void *))(*(void *)this + 624LL))(this, v111);
            if (v111)
            {
              CFRelease(v111);
              LODWORD(v11__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
            }

            goto LABEL_216;
          }

          (*(void (**)(HTTPProtocol *, _CFURLProtectionSpace *))(*(void *)this + 632LL))(this, v181);
          uint64_t v128 = (void *)*((void *)this + 10);
          if (v128 && [v128 _preventsSystemHTTPProxyAuthentication])
          {
            goto LABEL_207;
          }

          __int128 v144 = *((void *)this + 46);
          if (v144 && (unint64_t v145 = *(_CFURLProtectionSpace **)(v144 + 48)) != 0LL && !*((void *)this + 43))
          {
            AuthBrokerAgentClient::cachedProxyCredentialForProtectionSpace((AuthBrokerAgentClient *)&cf, v145);
            uint64_t v171 = cf;
            if ((void)cf)
            {
              (*(void (**)(HTTPProtocol *, void))(*(void *)this + 608LL))(this, cf);
              *((_DWORD *)this + 48) |= 0x400000u;
              (*(void (**)(uint64_t))(*(void *)v171 + 48LL))(v171);
              goto LABEL_363;
            }
          }

          else
          {
            *(void *)&CFTypeRef cf = 0LL;
          }

          if (HTTPProtocol::asynchronouslyQueryAuthBroker(this))
          {
LABEL_207:
            LODWORD(v11__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0;
LABEL_208:
            uint64_t v112 = *((void *)this + 46);
            if (v112)
            {
              uint64_t v113 = *(void *)(v112 + 40);
              if (v113)
              {
                uint64_t v114 = *(void *)(v113 + 32);
                if (v114)
                {
                  int v115 = URLCredential_PasswordBased::safelyCast(v114, v110);
                  if (v115
                    && (uint64_t v116 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v115 + 128LL))(v115)) != 0LL)
                  {
                    CFRelease(v116);
                  }

                  else
                  {
                    (*(void (**)(void))(**((void **)this + 46) + 48LL))(*((void *)this + 46));
                    *((void *)this + 46) = 0LL;
                  }
                }
              }
            }

LABEL_117:
}

void sub_182A89DEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  _Unwind_Resume(a1);
}

void HTTP3Connection::_readPushID(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  dispatch_source_t v10 = a3;
  unint64_t v11 = a5;
  uint64_t v41 = 0LL;
  uint8x8_t v42 = &v41;
  uint64_t v43 = 0x2020000000LL;
  char v44 = 0;
  uint64_t v37 = 0LL;
  unint64_t v38 = &v37;
  uint64_t v39 = 0x2810000000LL;
  CFIndex v40 = &unk_182CE6F99;
  uint64_t v33 = 0LL;
  unint64_t v34 = &v33;
  uint64_t v35 = 0x2020000000LL;
  char v36 = 0;
  uint64_t v12 = MEMORY[0x1895F87A8];
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke;
  applier[3] = &unk_189C08458;
  applier[4] = &v33;
  void applier[5] = &v37;
  void applier[6] = &v41;
  dispatch_data_apply(v10, applier);
  if (*((_BYTE *)v42 + 24))
  {
    dispatch_data_t subrange = dispatch_data_create_subrange(v10, *((unsigned __int8 *)v34 + 24), 0xFFFFFFFFFFFFFFFFLL);

    dispatch_source_t v10 = subrange;
    v11[2](v11, subrange, a4, v38[4]);
  }

  else if ((_DWORD)a4)
  {
    (*(void (**)(void, id))(**(void **)(a1 + 1008) + 80LL))(*(void *)(a1 + 1008), v9);
  }

  else
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v30,  *(void *)(a1 + 8),  *(std::__shared_weak_count **)(a1 + 16));
    uint64_t v14 = *(void *)(a1 + 1008);
    v24[0] = v12;
    v24[1] = 3321888768LL;
    void v24[2] = ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke_2;
    v24[3] = &unk_189C08480;
    uint64_t v28 = v30;
    id v29 = v31;
    if (v31)
    {
      p_uint64_t shared_owners = (unint64_t *)&v31->__shared_owners_;
      do
        unint64_t v16 = __ldxr(p_shared_owners);
      while (__stxr(v16 + 1, p_shared_owners));
    }

    id v25 = v9;
    uint64_t v17 = v10;
    uint64_t v26 = v17;
    uint64_t v27 = v11;
    (*(void (**)(uint64_t, id, uint64_t, uint64_t, void *))(*(void *)v14 + 56LL))( v14,  v25,  1LL,  132000LL,  v24);

    uint64_t v18 = v29;
    if (v29)
    {
      uint64_t v19 = (unint64_t *)&v29->__shared_owners_;
      do
        unint64_t v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }

    int v21 = v31;
    if (v31)
    {
      char v22 = (unint64_t *)&v31->__shared_owners_;
      do
        unint64_t v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }

    dispatch_source_t v10 = v17;
  }

  _Block_object_dispose(&v33, 8);
  _Block_object_dispose(&v37, 8);
  _Block_object_dispose(&v41, 8);
}

void sub_182A8A110( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v31);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose((const void *)(v32 - 136), 8);
  _Block_object_dispose((const void *)(v32 - 96), 8);

  _Unwind_Resume(a1);
}

void HTTP3Connection::_readEncoderStream(uint64_t a1, dispatch_data_t data)
{
  uint64_t v3 = MEMORY[0x1895F87A8];
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = ___ZN15HTTP3Connection18_readEncoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  applier[3] = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
  applier[4] = a1;
  dispatch_data_apply(data, applier);
  int v4 = *(_DWORD *)(a1 + 304);
  int v5 = v4 - *(_DWORD *)(a1 + 308);
  if (!v5) {
    goto LABEL_15;
  }
  int v6 = *(_DWORD *)(a1 + 292);
  if (!v6)
  {
    LODWORD(v7) = 0;
    goto LABEL_10;
  }

  uint64_t v7 = (v5 + 2 * v6) % (2 * v6);
  if (v7 <= 0x3E)
  {
LABEL_10:
    uint64_t v14 = (char *)&buffer + 1;
    LOBYTE(buffer) = v7;
    goto LABEL_11;
  }

  LOBYTE(buffer) = 63;
  unint64_t v8 = v7 - 63;
  uint64_t v9 = 1LL;
  if ((unint64_t)(v7 - 63) >= 0x80)
  {
    while (v9 != 6)
    {
      unint64_t v10 = v9;
      *((_BYTE *)&buffer + v9) = v8 | 0x80;
      unint64_t v11 = v8 >> 7;
      ++v9;
      unint64_t v12 = v8 >> 14;
      v8 >>= 7;
      if (!v12)
      {
        if (v10 > 4) {
          goto LABEL_15;
        }
        p_uint64_t buffer = (char *)&buffer + v10;
        LOBYTE(v_Block_object_dispose(va, 8) = v11;
        goto LABEL_32;
      }
    }

    goto LABEL_15;
  }

  p_uint64_t buffer = (char *)&buffer;
LABEL_32:
  uint64_t v14 = p_buffer + 2;
  *((_BYTE *)&buffer + v9) = v8;
  if (p_buffer + 2 > (char *)&buffer)
  {
LABEL_11:
    unint64_t v15 = *(FILE **)(a1 + 320);
    if (v15)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v15);
      fprintf(*(FILE **)(a1 + 320), "wrote ICI: count=%u", v7);
      fputc(10, *(FILE **)(a1 + 320));
      int v4 = *(_DWORD *)(a1 + 304);
    }

    *(_DWORD *)(a1 + 30_Block_object_dispose(va, 8) = v4;
    *(_DWORD *)(a1 + 296) += v14 - (char *)&buffer;
    if (v14 - (char *)&buffer >= 1)
    {
      dispatch_data_t v16 = dispatch_data_create(&buffer, v14 - (char *)&buffer, 0LL, 0LL);
      HTTP3Connection::writeDecoderStream(a1, v16);
    }
  }

void sub_182A8A424(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;

  _Unwind_Resume(a1);
}

uint64_t HTTP3Connection::reportServerProtocolViolation(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  CFN_LOG_h3connection();
  int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  if (a3 == -1)
  {
    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v13 = *(void *)(a1 + 1216);
    *(_DWORD *)__int128 buf = 134218496;
    uint64_t v17 = a1;
    __int16 v18 = 2048;
    uint64_t v19 = v13;
    __int16 v20 = 1024;
    int v21 = a2;
    uint64_t v9 = "%p %llu Server protocol violation 0x%02hhx";
    unint64_t v10 = v6;
    uint32_t v11 = 28;
  }

  else
  {
    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v8 = *(void *)(a1 + 1216);
    *(_DWORD *)__int128 buf = 134218752;
    uint64_t v17 = a1;
    __int16 v18 = 2048;
    uint64_t v19 = v8;
    __int16 v20 = 1024;
    int v21 = a2;
    __int16 v22 = 2048;
    uint64_t v23 = a3;
    uint64_t v9 = "%p %llu Server protocol violation 0x%02hhx on stream ID=%llu";
    unint64_t v10 = v6;
    uint32_t v11 = 38;
  }

  _os_log_error_impl(&dword_18298D000, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
LABEL_5:

  uint64_t result = *(void *)(a1 + 1008);
  if (result)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    unsigned __int8 v14[2] = ___ZN15HTTP3Connection29reportServerProtocolViolationEN2H323ServerProtocolViolationEy_block_invoke;
    v14[3] = &__block_descriptor_33_e24_v20__0____CFString__8B16l;
    char v15 = a2;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 344LL))(result, v14);
  }

  return result;
}

void HTTP3Connection::_readDecoderStream(uint64_t a1, dispatch_data_t data)
{
  uint64_t v3 = MEMORY[0x1895F87A8];
  applier[0] = MEMORY[0x1895F87A8];
  applier[1] = 3221225472LL;
  applier[2] = ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  applier[3] = &__block_descriptor_40_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
  applier[4] = a1;
  dispatch_data_apply(data, applier);
  if (*(void *)(a1 + 1008) && (*(_BYTE *)(a1 + 920) & 4) == 0)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v16,  *(void *)(a1 + 8),  *(std::__shared_weak_count **)(a1 + 16));
    uint64_t v4 = *(void *)(a1 + 1008);
    uint64_t v5 = *(void *)(a1 + 1064);
    v14[0] = v3;
    v14[1] = 3321888768LL;
    unsigned __int8 v14[2] = ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2;
    v14[3] = &__block_descriptor_56_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e83_v44__0__NSObject_OS_nw_content_context__8__NSObject_OS_dispatch_data__16B24___qi_28l;
    void v14[4] = a1;
    void v14[5] = v16;
    char v15 = v17;
    if (v17)
    {
      p_uint64_t shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }

    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v4 + 56LL))( v4,  v5,  1LL,  132000LL,  v14);
    uint64_t v8 = v15;
    if (v15)
    {
      uint64_t v9 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    uint32_t v11 = v17;
    if (v17)
    {
      unint64_t v12 = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }

void sub_182A8A738( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  int v6 = a4;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v19 = a4;
  uint64_t v8 = *(FILE **)(v7 + 232);
  if (v8)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
    fprintf(*(FILE **)(v7 + 232), "got %zu bytes of decoder stream", a5);
    fputc(10, *(FILE **)(v7 + 232));
  }

  if (a5 < 1)
  {
LABEL_18:
    *(_DWORD *)(v7 + 228) += a5;
    return 1LL;
  }

  unint64_t v9 = (unint64_t)&v6[a5];
  uint32_t v11 = (_DWORD *)(v7 + 192);
  int v10 = *(_DWORD *)(v7 + 192);
  char v12 = -1;
  while (1)
  {
    if (v10 != 1)
    {
      if (v10) {
        goto LABEL_17;
      }
      int v13 = (char)*v6;
      if (v13 < 0)
      {
        char v12 = 7;
        char v15 = enc_proc_header_ack;
      }

      else
      {
        int v14 = v13 & 0xC0;
        if (v14)
        {
          if (v14 != 64) {
            __assert_rtn("lsqpack_enc_decoder_in", "lsqpack.c", 2459, "(buf[0] & 0xC0) == 0x40");
          }
          char v12 = 6;
          char v15 = enc_proc_stream_cancel;
        }

        else
        {
          char v12 = 6;
          char v15 = enc_proc_ici;
        }
      }

      *(void *)(v7 + 2CFRelease((char *)this - 16) = v15;
    }

    int v16 = lsqpack_dec_int(&v19, v9, v12, &v18, (int *)(v7 + 192));
    if (v16) {
      break;
    }
    int v10 = 0;
    *uint32_t v11 = 0;
    int v6 = v19;
LABEL_17:
  }

  if (v16 == -1)
  {
    *uint32_t v11 = 1;
    return 1LL;
  }

void ___ZN15HTTP3Connection18_readDecoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2( uint64_t a1, void *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v10 = a2;
  uint32_t v11 = a3;
  if (v11 && !(_DWORD)a6)
  {
    char v12 = *(HTTP3Connection **)(a1 + 40);
    if (*((void *)v12 + 124))
    {
      HTTP3Connection::_stopStallRecovery(v12);
      char v12 = *(HTTP3Connection **)(a1 + 40);
    }

    HTTP3Connection::_readDecoderStream((int)v12, v11);
    goto LABEL_19;
  }

  if (!(_DWORD)a6)
  {
    uint64_t v13 = *(void *)(a1 + 40);
    if ((*(_BYTE *)(v13 + 920) & 4) == 0)
    {
      uint64_t v14 = *(void *)(v13 + 1008);
      if (v14)
      {
        uint64_t v13 = *(void *)(a1 + 40);
      }

      *(void *)(v13 + 1160) = 4LL;
      *(_DWORD *)(v13 + 116_Block_object_dispose(va, 8) = -1;
      HTTP3Connection::_cleanupConnection((HTTP3Connection *)v13, 260LL, 0LL);
      HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 40), 34, -1LL);
      CFN_LOG_h3connection();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        uint64_t v19 = *(void *)(a1 + 40);
        uint64_t v20 = *(void *)(v19 + 1216);
        int v21 = 134218240;
        uint64_t v22 = v19;
        __int16 v23 = 2048;
        uint64_t v24 = v20;
        _os_log_fault_impl( &dword_18298D000,  v15,  OS_LOG_TYPE_FAULT,  "%p %llu Decoder stream closed but connection is alive",  (uint8_t *)&v21,  0x16u);
      }

      goto LABEL_18;
    }
  }

void sub_182A8AB2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 4_Block_object_dispose(va, 8) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_40c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void ___ZN15HTTP3Connection29reportServerProtocolViolationEN2H323ServerProtocolViolationEy_block_invoke( uint64_t a1, void *a2, char a3)
{
  if (a2 && (a3 & 1) == 0)
  {
    id v3 = a2;
    if (([v3 isEqualToString:@"localhost"] & 1) == 0)
    {
      id v5 = v3;
      AnalyticsSendEventLazy_delayInitStub(v4);
    }
  }

void sub_182A8AC0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection18_readEncoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke( uint64_t a1, int a2, int a3, unsigned __int8 *__src, uint64_t a5)
{
  int v6 = __src;
  uint64_t v7 = *(void *)(a1 + 32);
  *(void *)(v7 + 1208) += a5;
  uint64_t v103 = __src;
  uint64_t v8 = *(FILE **)(v7 + 320);
  if (v8)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v8);
    fprintf(*(FILE **)(v7 + 320), "got %zu bytes of encoder stream", a5);
    fputc(10, *(FILE **)(v7 + 320));
  }

  *(_DWORD *)(v7 + 296) += a5;
  if (a5 <= 0) {
    return 1LL;
  }
  unint64_t v9 = (unint64_t)&v6[a5];
  id v10 = (void *)(v7 + 564);
  uint32_t v11 = (const char **)(v7 + 552);
  unint64_t v101 = (uint64_t *)(v7 + 536);
  uint64_t v102 = v7 + 272;
  char v12 = -1;
  while (1)
  {
    switch(*(_DWORD *)(v7 + 504))
    {
      case 0:
        unsigned __int8 v13 = *v6;
        if ((char)*v6 < 0)
        {
          *(_BYTE *)(v7 + 593) = (v13 & 0x40) != 0;
          *(_DWORD *)(v7 + 512) = 0;
          *uint32_t v11 = 0LL;
          *(void *)(v7 + 560) = 0LL;
          char v12 = 6;
          *(_DWORD *)(v7 + 50os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
LABEL_95:
          int v14 = lsqpack_dec_int(&v103, v9, v12, (uint64_t *)&v104, (int *)(v7 + 512));
          if (v14) {
            goto LABEL_137;
          }
          unsigned int v78 = v104;
          if (v104 >> 24) {
            goto LABEL_137;
          }
          *(_DWORD *)(v7 + 54os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v104;
          if (*(_BYTE *)(v7 + 593))
          {
            if (v78 > 0x62) {
              goto LABEL_147;
            }
            *uint32_t v11 = 0LL;
          }

          else
          {
            uint64_t table_entry_rel = qdec_get_table_entry_rel(v102, v78);
            *uint32_t v11 = (const char *)table_entry_rel;
            if (!table_entry_rel) {
              goto LABEL_147;
            }
            ++*(_DWORD *)(table_entry_rel + 8);
          }

          int v52 = 2;
          goto LABEL_124;
        }

        if ((*v6 & 0x40) != 0)
        {
          *(_BYTE *)(v7 + 572) = (v13 & 0x20) != 0;
          *(_DWORD *)(v7 + 512) = 0;
          *(void *)(v7 + 552) = 0LL;
          *(_DWORD *)(v7 + 50os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 8;
          char v12 = 5;
LABEL_112:
          int v14 = lsqpack_dec_int(&v103, v9, v12, (uint64_t *)&v104, (int *)(v7 + 512));
          if (v14 || (unsigned int v85 = v104, v104 >> 24))
          {
LABEL_137:
            if (v14 != -1) {
              goto LABEL_147;
            }
            return 1LL;
          }

          *(_DWORD *)(v7 + 54os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v104;
          char v86 = *(_BYTE *)(v7 + 572);
          if (*(_DWORD *)(v7 + 280) << (2 * v86) < v85) {
            goto LABEL_147;
          }
          uint64_t v87 = v85 ? v85 + (v85 >> 1) : 16LL;
          *(_DWORD *)(v7 + 560) = v87;
          uint64_t v88 = malloc(v87 + 28);
          *(void *)(v7 + 552) = v88;
          if (!v88) {
            goto LABEL_147;
          }
          v88[6] = 0;
          *id v10 = 0LL;
          if (!v86)
          {
            int v52 = 10;
LABEL_124:
            *(_DWORD *)(v7 + 50os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v52;
            goto LABEL_135;
          }

          int v75 = 9;
LABEL_121:
          *(_DWORD *)(v7 + 50os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v75;
LABEL_122:
          *(_DWORD *)(v7 + 536) = 0;
        }

        else
        {
          *(_DWORD *)(v7 + 512) = 0;
          if ((v13 & 0x20) != 0)
          {
            *(_DWORD *)(v7 + 50os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 7;
            char v12 = 5;
LABEL_126:
            int v14 = lsqpack_dec_int(&v103, v9, v12, v101, (int *)(v7 + 512));
            if (v14) {
              goto LABEL_137;
            }
            unint64_t v89 = *(void *)(v7 + 536);
            *(_DWORD *)(v7 + 50os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
            size_t v90 = *(FILE **)(v7 + 320);
            if (v90)
            {
              fwrite("qdec: debug: ", 0xDuLL, 1uLL, v90);
              fprintf(*(FILE **)(v7 + 320), "got TSU=%llu", *(void *)(v7 + 536));
              fputc(10, *(FILE **)(v7 + 320));
              unint64_t v89 = *(void *)(v7 + 536);
            }

            *(_DWORD *)(v7 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = v89;
            int v91 = *(_DWORD *)(v7 + 292);
            unsigned int v92 = v89 >> 5;
            *(_DWORD *)(v7 + 292) = v89 >> 5;
            if (v91 != v89 >> 5)
            {
              int v93 = *(_DWORD *)(v7 + 304);
              if (v93 == *(_DWORD *)(v7 + 308) && v93 == 2 * v91 - 1)
              {
                int v94 = 2 * v92 - 1;
                *(_DWORD *)(v7 + 30os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v94;
                *(_DWORD *)(v7 + 30_Block_object_dispose(va, 8) = v94;
              }
            }

            qdec_remove_overflow_entries(v102);
          }

          else
          {
            *(_DWORD *)(v7 + 50os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 6;
            char v12 = 5;
LABEL_10:
            int v14 = lsqpack_dec_int(&v103, v9, v12, (uint64_t *)&v104, (int *)(v7 + 512));
            if (v14) {
              goto LABEL_137;
            }
            unsigned int v15 = v104;
            if (v104 >> 24) {
              goto LABEL_137;
            }
            *(_DWORD *)unint64_t v101 = v104;
            uint64_t v16 = (unsigned int *)qdec_get_table_entry_rel(v102, v15);
            if (!v16) {
              goto LABEL_147;
            }
            uint64_t v17 = v16;
            size_t v18 = *v16 + (unint64_t)v16[1] + 28;
            uint64_t v19 = malloc(v18);
            if (!v19) {
              goto LABEL_147;
            }
            uint64_t v20 = v19;
            memcpy(v19, v17, v18);
            _DWORD v20[2] = 1;
            if (lsqpack_dec_push_entry(v102, (const char *)v20))
            {
              int v100 = v20[2] - 1;
              _DWORD v20[2] = v100;
              if (!v100) {
                free(v20);
              }
              goto LABEL_147;
            }

            *(_DWORD *)(v7 + 50os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
          }
        }

void HTTP3Connection::writeDecoderStream(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 1008);
  if (v4 && (*(_BYTE *)(a1 + 920) & 4) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 1056);
    if (!v5)
    {
      uint64_t v6 = HTTP3Connection::_newClientUnidirectionalStreamHandle((HTTP3Connection *)"outbound decoder", 0LL);
      uint64_t v7 = *(void **)(a1 + 1056);
      *(void *)(a1 + 1056) = v6;

      char buffer = 3;
      uint64_t v8 = dispatch_data_create(&buffer, 1uLL, 0LL, 0LL);
      dispatch_data_t concat = dispatch_data_create_concat(v8, v3);

      uint64_t v4 = *(void *)(a1 + 1008);
      uint64_t v5 = *(void *)(a1 + 1056);
      id v3 = concat;
    }

    (*(void (**)(uint64_t, uint64_t, uint64_t, dispatch_data_s *, void *))(*(void *)v4 + 64LL))( v4,  v5,  1LL,  v3,  &__block_literal_global_15_5182);
  }
}

void sub_182A8B790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN15HTTP3Connection18_readEncoderStreamEPU27objcproto16OS_dispatch_data8NSObject_block_invoke_2( uint64_t a1, void *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v10 = a2;
  uint32_t v11 = a3;
  if (v11 && !(_DWORD)a6)
  {
    char v12 = *(HTTP3Connection **)(a1 + 40);
    if (*((void *)v12 + 124))
    {
      HTTP3Connection::_stopStallRecovery(v12);
      char v12 = *(HTTP3Connection **)(a1 + 40);
    }

    HTTP3Connection::_readEncoderStream((int)v12, v11);
    goto LABEL_36;
  }

  if (!(_DWORD)a6)
  {
    uint64_t v13 = *(void *)(a1 + 40);
    if ((*(_BYTE *)(v13 + 920) & 4) == 0)
    {
      uint64_t v14 = *(void *)(v13 + 1008);
      if (v14)
      {
        uint64_t v13 = *(void *)(a1 + 40);
      }

      *(void *)(v13 + 1160) = 4LL;
      *(_DWORD *)(v13 + 116_Block_object_dispose(va, 8) = -1;
      HTTP3Connection::_cleanupConnection((HTTP3Connection *)v13, 260LL, 0LL);
      HTTP3Connection::reportServerProtocolViolation(*(void *)(a1 + 40), 18, -1LL);
      CFN_LOG_h3connection();
      unsigned int v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
      {
        uint64_t v32 = *(void *)(a1 + 40);
        uint64_t v33 = *(void *)(v32 + 1216);
        *(_DWORD *)__int128 buf = 134218240;
        *(void *)&uint8_t buf[4] = v32;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = v33;
        _os_log_fault_impl( &dword_18298D000,  v15,  OS_LOG_TYPE_FAULT,  "%p %llu Encoder stream closed but connection is alive",  buf,  0x16u);
      }

      goto LABEL_35;
    }
  }

void sub_182A8BAB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_content_context *HTTP3Connection::_newClientUnidirectionalStreamHandle( HTTP3Connection *this, const char *a2)
{
  if (HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::onceToken != -1) {
    dispatch_once( &HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::onceToken,  &__block_literal_global_33);
  }
  connection_metaint data = (nw_protocol_metadata *)nw_quic_create_connection_metadata();
  nw_quic_connection_metadata_set_stream_options();
  uint64_t v4 = nw_content_context_create((const char *)this);
  nw_content_context_set_metadata_for_protocol(v4, connection_metadata);

  return v4;
}

void sub_182A8BB74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HTTP3Connection36_newClientUnidirectionalStreamHandleEPKc_block_invoke()
{
  uint64_t stream_options = nw_quic_create_stream_options();
  uint64_t v1 = (void *)HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::options;
  HTTP3Connection::_newClientUnidirectionalStreamHandle(char const*)::options = stream_options;

  return nw_quic_stream_set_is_unidirectional();
}

BOOL ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke( void *a1, int a2, int a3, void *__src, unint64_t a5)
{
  uint64_t v6 = *(unsigned __int8 *)(*(void *)(a1[4] + 8LL) + 24LL);
  if (8 - v6 >= a5) {
    size_t v7 = a5;
  }
  else {
    size_t v7 = 8 - v6;
  }
  memcpy((void *)(*(void *)(a1[5] + 8LL) + v6 + 32), __src, v7);
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) += v7;
  uint64_t v8 = (unint64_t *)(*(void *)(a1[5] + 8LL) + 32LL);
  uint64_t v9 = *(void *)(a1[4] + 8LL);
  char v12 = (const unsigned __int8 *)*(unsigned __int8 *)(v9 + 24);
  uint64_t v13 = v8;
  *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = QUICUtilities::quic_vle_decode( (QUICUtilities *)&v13,  &v12,  v8,  (unint64_t *)(v9 + 24),  v10);
  return *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) == 0;
}

void ___ZN15HTTP3Connection11_readPushIDEPU32objcproto21OS_nw_content_context8NSObjectPU27objcproto16OS_dispatch_dataS0_bU13block_pointerFvS4_byE_block_invoke_2( uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v11 = a2;
  size_t v7 = a3;
  uint64_t v8 = *(void *)(a1 + 56);
  if (v7)
  {
    if (*(void *)(v8 + 992))
    {
      HTTP3Connection::_stopStallRecovery(*(HTTP3Connection **)(a1 + 56));
      uint64_t v8 = *(void *)(a1 + 56);
    }

    uint64_t v9 = *(void *)(a1 + 32);
    dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(a1 + 40), v7);
    HTTP3Connection::_readPushID(v8, v9, concat, a4, *(void *)(a1 + 48));
  }

  else
  {
    (*(void (**)(void, void))(**(void **)(v8 + 1008) + 80LL))( *(void *)(v8 + 1008),  *(void *)(a1 + 32));
  }
}

void sub_182A8BD30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_56c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(result + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v2;
  if (v2)
  {
    id v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_56c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
}

uint64_t __copy_helper_block_ea8_48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2)
  {
    id v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_48c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN15HTTP3Connection18_readControlStreamEv_block_invoke( uint64_t a1, void **a2, void *a3, CFIndex a4, uint64_t a5)
{
  buffer_ptr[3] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v9 = a3;
  if (!v9 || (_DWORD)a5)
  {
    if (a4 != 4) {
      goto LABEL_20;
    }
    if ((_DWORD)a5 != -2300) {
      goto LABEL_20;
    }
    uint64_t v18 = *(void *)(a1 + 40);
    if ((*(_BYTE *)(v18 + 920) & 4) != 0) {
      goto LABEL_20;
    }
    uint64_t v19 = *(void *)(v18 + 1008);
    if (v19)
    {
      if ((*(uint64_t (**)(void))(*(void *)v19 + 120LL))(*(void *)(v18 + 1008)) != -1)
      {
LABEL_20:
        v63.CFIndex domain = a4;
        *(void *)&v63.uint64_t error = a5;
        if (!HTTP3Connection::checkAndPerformFallback(*(HTTP3Connection **)(a1 + 40), v63))
        {
          uint64_t v23 = *(void *)(a1 + 40);
          *(_BYTE *)(v23 + 920) |= 2u;
          if (*(void *)(v23 + 1136) == *(void *)(v23 + 1144)) {
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v23, 256LL, 0LL);
          }
          goto LABEL_30;
        }

        CFN_LOG_h3connection();
        uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v21 = *(void **)(a1 + 40);
          int v22 = (void *)v21[152];
          LODWORD(buffer_ptr[0]) = 134218240;
          *(void **)((char *)buffer_ptr + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v21;
          WORD2(buffer_ptr[1]) = 2048;
          *(void **)((char *)&buffer_ptr[1] + 6) = v22;
          _os_log_impl( &dword_18298D000,  v20,  OS_LOG_TYPE_DEFAULT,  "%p %llu Control stream fallback triggered",  (uint8_t *)buffer_ptr,  0x16u);
        }

void sub_182A8C500( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  a9 = (void **)&a15;
  std::vector<std::shared_ptr<HTTP3Connection>>::__destroy_vector::operator()[abi:nn180100](&a9);

  _Unwind_Resume(a1);
}

void HTTP3Connection::_settingsReceived(HTTP3Connection *this)
{
  unsigned int v2 = *((_DWORD *)this + 236);
  if (v2 >= 0x10000) {
    unint64_t v3 = 0x10000LL;
  }
  else {
    unint64_t v3 = v2;
  }
  *((void *)this + 11_Block_object_dispose(va, 8) = v3;
  if (*((void *)this + 119) >= 0x64uLL) {
    uint64_t v4 = 100LL;
  }
  else {
    uint64_t v4 = *((void *)this + 119);
  }
  *((void *)this + 119) = v4;
  if ((_DWORD)v3)
  {
    buffer[0] = 32;
    uint64_t v5 = lsqpack_enc_int(buffer, (unint64_t)&v23, v3, 5);
    if (v5 <= buffer)
    {
      *__error() = 55;
      size_t v8 = 6LL;
      goto LABEL_25;
    }

    uint64_t v6 = v5;
    size_t v7 = (FILE *)*((void *)this + 29);
    if (v7)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
      size_t v8 = v6 - buffer;
      fprintf(*((FILE **)this + 29), "generated TSU=%u instruction %zd byte%.*s in size", v3, v8, v8 != 1, "s");
      fputc(10, *((FILE **)this + 29));
    }

    else
    {
      size_t v8 = v5 - buffer;
    }
  }

  else
  {
    size_t v8 = 0LL;
  }

  unsigned int v9 = v3 / 0x60;
  *((_DWORD *)this + 65) = v9;
  uint64_t v10 = malloc(8 * v9 + 8);
  *((void *)this + 3__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v10;
  if (!v10)
  {
LABEL_24:
    if (!v8) {
      return;
    }
    goto LABEL_25;
  }

  if (v2 < 0x20)
  {
    id v11 = 0LL;
    int v12 = 0;
LABEL_23:
    *((_DWORD *)this + 1os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v2;
    *((_DWORD *)this + 15) = v2 >> 5;
    *((_DWORD *)this + 13) = v3;
    *((_DWORD *)this + 17) = v4;
    *((void *)this + 13) = v11;
    *((_DWORD *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v12;
    *((void *)this + 29) = 0LL;
    *((_DWORD *)this + 11) |= 2u;
    goto LABEL_24;
  }

  char v13 = v10;
  id v11 = (char *)malloc(0x80uLL);
  if (v11)
  {
    uint64_t v14 = 0LL;
    __int128 v15 = 0uLL;
    do
    {
      int v16 = (double *)&v11[v14];
      uint64_t v17 = (uint64_t)&v11[v14 + 32];
      uint64_t v18 = (uint64_t)&v11[v14 + 16];
      uint64_t v19 = (uint64_t)&v11[v14 + 48];
      __int128 v20 = 0uLL;
      vst4q_f64(v16, *(float64x2x4_t *)&v15);
      v14 += 64LL;
    }

    while (v14 != 128);
    int v12 = 2;
    goto LABEL_23;
  }

  free(v13);
  if (!v8) {
    return;
  }
LABEL_25:
  dispatch_data_t v21 = dispatch_data_create(buffer, v8, 0LL, 0LL);
  HTTP3Connection::writeEncoderStream((uint64_t)this, v21);
}

void sub_182A8C778(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t HTTP3Connection::_cleanupIfNoStreams(uint64_t this)
{
  *(_BYTE *)(this + 920) |= 2u;
  if (*(void *)(this + 1136) == *(void *)(this + 1144)) {
    return HTTP3Connection::_cleanupConnection((HTTP3Connection *)this);
  }
  return this;
}

void HTTP3Connection::writeEncoderStream(uint64_t a1, void *a2)
{
  unint64_t v3 = a2;
  uint64_t v4 = *(void *)(a1 + 1008);
  if (v4 && (*(_BYTE *)(a1 + 920) & 4) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 1040);
    if (!v5)
    {
      uint64_t v6 = HTTP3Connection::_newClientUnidirectionalStreamHandle((HTTP3Connection *)"outbound encoder", 0LL);
      size_t v7 = *(void **)(a1 + 1040);
      *(void *)(a1 + 1040) = v6;

      char buffer = 2;
      size_t v8 = dispatch_data_create(&buffer, 1uLL, 0LL, 0LL);
      dispatch_data_t concat = dispatch_data_create_concat(v8, v3);

      uint64_t v4 = *(void *)(a1 + 1008);
      uint64_t v5 = *(void *)(a1 + 1040);
      unint64_t v3 = concat;
    }

    (*(void (**)(uint64_t, uint64_t, uint64_t, dispatch_data_s *, void *))(*(void *)v4 + 64LL))( v4,  v5,  1LL,  v3,  &__block_literal_global_5191);
  }
}

void sub_182A8C87C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    unint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

void __destroy_helper_block_ea8_32c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void ___ZN15HTTP3Connection12_handleStallEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[4];
    unint64_t v4 = std::__shared_weak_count::lock(v2);
    if (v4)
    {
      uint64_t v5 = v4;
      uint64_t v6 = a1[5];
      if (v6)
      {
        CFN_LOG_h3connection();
        size_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          uint64_t v8 = *(void *)(v3 + 1216);
          unsigned int v9 = *(unsigned __int8 *)(v6 + 920);
          *(_DWORD *)__int128 buf = 134218752;
          uint64_t v15 = v3;
          __int16 v16 = 2048;
          uint64_t v17 = v8;
          __int16 v18 = 1024;
          int v19 = (v9 >> 4) & 1;
          __int16 v20 = 1024;
          int v21 = (v9 >> 5) & 1;
          _os_log_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_INFO,  "%p %llu stall recovery timer done (fb=%d sip=%d)",  buf,  0x22u);
        }

        char v10 = *(_BYTE *)(v6 + 920);
        if ((v10 & 0x30) == 0x20)
        {
          *(_BYTE *)(v6 + 920) = v10 & 0xDF;
          uint64_t v11 = *(void *)(v6 + 1008);
          if (v11) {
            (*(void (**)(uint64_t, void, void))(*(void *)v11 + 136LL))(v11, 0LL, 0LL);
          }
        }
      }

      p_uint64_t shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }

void sub_182A8CA3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_22(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___ZN15HTTP3Connection19_startStallRecoveryEv_block_invoke_2(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      unint64_t v4 = v3;
      uint64_t v5 = (HTTP3Connection *)a1[5];
      if (v5 && *((void *)v5 + 124)) {
        HTTP3Connection::_stopStallRecovery(v5);
      }
      p_uint64_t shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

uint64_t __copy_helper_block_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 4_Block_object_dispose(va, 8) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

void __destroy_helper_block_ea8_40c40_ZTSNSt3__18weak_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void std::__shared_ptr_emplace<HTTP3Stream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C08710;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3Stream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C08710;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<HTTP3Stream>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void HTTP3StreamWrapper::~HTTP3StreamWrapper(HTTP3StreamWrapper *this)
{
  *(void *)this = off_189C08568;
  *((void *)this + 3) = &unk_189C08640;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
}

{
  *(void *)this = off_189C08568;
  *((void *)this + 3) = &unk_189C08640;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t HTTP3StreamWrapper::copyProperty(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16LL))(*(void *)(a1 + 32));
}

uint64_t HTTP3StreamWrapper::setProperty(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24LL))(*(void *)(a1 + 32));
}

uint64_t HTTP3StreamWrapper::setBodyStreamBeforeOpening(HTTP3StreamWrapper *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(void, __CFReadStream *))(**((void **)this + 4) + 32LL))( *((void *)this + 4),  a2);
}

uint64_t HTTP3StreamWrapper::canScheduleAndOpenWithHandlerAsync(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 40LL))(*((void *)this + 4));
}

uint64_t HTTP3StreamWrapper::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48LL))(*(void *)(a1 + 32));
}

uint64_t HTTP3StreamWrapper::closeAndClearHandler(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 56LL))(*((void *)this + 4));
}

uint64_t HTTP3StreamWrapper::updateScheduling(HTTP3StreamWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(void, const CoreSchedulingSet *))(**((void **)this + 4) + 64LL))( *((void *)this + 4),  a2);
}

uint64_t HTTP3StreamWrapper::setPriorityHint(HTTP3StreamWrapper *this, float a2)
{
  return (*(uint64_t (**)(void, float))(**((void **)this + 4) + 72LL))(*((void *)this + 4), a2);
}

uint64_t HTTP3StreamWrapper::rawBytesSent(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 80LL))(*((void *)this + 4));
}

uint64_t HTTP3StreamWrapper::rawBytesReceived(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 88LL))(*((void *)this + 4));
}

uint64_t HTTP3StreamWrapper::getConnectionIdentifier(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 96LL))(*((void *)this + 4));
}

uint64_t HTTP3StreamWrapper::copyTrust(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 104LL))(*((void *)this + 4));
}

uint64_t HTTP3StreamWrapper::_conn_no_more_reqests_after_this_one_connectionLost(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 112LL))(*((void *)this + 4));
}

void HTTP3StreamWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  char v10 = v3;
  if (v3)
  {
    p_uint64_t shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 120LL))(v2, &v9);
  uint64_t v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A8CD38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HTTP3StreamWrapper::getProxy(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 128LL))(*((void *)this + 4));
}

uint64_t HTTP3StreamWrapper::setTransactionMetrics(HTTP3StreamWrapper *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(void, __CFN_TransactionMetrics *))(**((void **)this + 4) + 136LL))( *((void *)this + 4),  a2);
}

uint64_t HTTP3StreamWrapper::_meta_retain(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(HTTP3StreamWrapper *))(*(void *)this + 40LL))(this);
}

uint64_t HTTP3StreamWrapper::_meta_release(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(HTTP3StreamWrapper *))(*(void *)this + 48LL))(this);
}

void non-virtual thunk to'HTTP3StreamWrapper::~HTTP3StreamWrapper(HTTP3StreamWrapper *this)
{
  *((void *)this - 3) = off_189C08568;
  *(void *)this = &unk_189C08640;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

{
  char *v2;
  *((void *)this - 3) = off_189C08568;
  uint64_t v2 = (char *)this - 24;
  *(void *)this = &unk_189C08640;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::_meta_retain(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((void *)this - 3) + 40LL))((char *)this - 24);
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::_meta_release(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((void *)this - 3) + 48LL))((char *)this - 24);
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::copyProperty(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16LL))(*(void *)(a1 + 8));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::setProperty(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::canScheduleAndOpenWithHandlerAsync( HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 40LL))(*((void *)this + 1));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::scheduleAndOpenWithHandler(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48LL))(*(void *)(a1 + 8));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::closeAndClearHandler(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 56LL))(*((void *)this + 1));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::updateScheduling( HTTP3StreamWrapper *this, const CoreSchedulingSet *a2)
{
  return (*(uint64_t (**)(void, const CoreSchedulingSet *))(**((void **)this + 1) + 64LL))( *((void *)this + 1),  a2);
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::setPriorityHint(HTTP3StreamWrapper *this, float a2)
{
  return (*(uint64_t (**)(void, float))(**((void **)this + 1) + 72LL))(*((void *)this + 1), a2);
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::setBodyStreamBeforeOpening( HTTP3StreamWrapper *this, __CFReadStream *a2)
{
  return (*(uint64_t (**)(void, __CFReadStream *))(**((void **)this + 1) + 32LL))( *((void *)this + 1),  a2);
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::rawBytesSent(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 80LL))(*((void *)this + 1));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::rawBytesReceived(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 88LL))(*((void *)this + 1));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::getConnectionIdentifier(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 96LL))(*((void *)this + 1));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::copyTrust(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 104LL))(*((void *)this + 1));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::_conn_no_more_reqests_after_this_one_connectionLost( HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 112LL))(*((void *)this + 1));
}

void non-virtual thunk to'HTTP3StreamWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  char v10 = v3;
  if (v3)
  {
    p_uint64_t shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 120LL))(v2, &v9);
  uint64_t v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182A8CF50( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    p_uint64_t shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::getProxy(HTTP3StreamWrapper *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 128LL))(*((void *)this + 1));
}

uint64_t non-virtual thunk to'HTTP3StreamWrapper::setTransactionMetrics( HTTP3StreamWrapper *this, __CFN_TransactionMetrics *a2)
{
  return (*(uint64_t (**)(void, __CFN_TransactionMetrics *))(**((void **)this + 1) + 136LL))( *((void *)this + 1),  a2);
}

BOOL HTTP3Connection::willEnqueueRequests(HTTP3Connection *this)
{
  if (*((_DWORD *)this + 292) || (*((_BYTE *)this + 920) & 6) != 0) {
    return 0LL;
  }
  if (*((void *)this + 142) != *((void *)this + 143)) {
    return 1LL;
  }
  uint64_t v2 = *((void *)this + 148);
  if (!v2) {
    return 1LL;
  }
  __uint64_t v3 = v2 + *((void *)this + 147) - 1000000000;
  return v3 > clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW_APPROX);
}

uint64_t ___ZN15HTTP3Connection22logConnectionAtAPSleepEv_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 1008LL);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 432LL))(result);
  }
  return result;
}

void HTTP3Connection::stop(HTTP3Connection *this, char a2)
{
  unint64_t v4 = (dispatch_queue_s *)*((void *)this + 125);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3321888768LL;
  block[2] = ___ZN15HTTP3Connection4stopEb_block_invoke;
  block[3] = &__block_descriptor_49_ea8_32c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE_e5_v8__0l;
  block[4] = v16;
  uint64_t v14 = v17;
  if (v17)
  {
    p_uint64_t shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  char v15 = a2;
  dispatch_async(v4, block);
  unint64_t v7 = v14;
  if (v14)
  {
    unint64_t v8 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  char v10 = v17;
  if (v17)
  {
    uint64_t v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

void ___ZN15HTTP3Connection4stopEb_block_invoke(uint64_t a1)
{
}

uint64_t ___ZN15HTTP3Connection26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 1008LL);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 160LL))(result);
  }
  return result;
}

void ___ZN15HTTP3Connection21createFramerForStreamERK11HTTP3FieldsU13block_pointerFvNSt3__110shared_ptrI11HTTP3FramerEEybE_block_invoke( uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v147 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *a2;
  if (*a2)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    unint64_t v8 = (std::__shared_weak_count *)a2[1];
    uint64_t v143 = *a2;
    __int128 v144 = v8;
    if (v8)
    {
      p_uint64_t shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        unint64_t v10 = __ldxr(p_shared_owners);
      while (__stxr(v10 + 1, p_shared_owners));
      uint64_t v6 = *a2;
    }

    uint64_t StreamID = HTTP3Framer::getStreamID(*(HTTP3Framer **)(v6 + 48));
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(v7 + 16))(v7, &v143, StreamID, 1LL);
    unint64_t v12 = v144;
    if (v144)
    {
      unint64_t v13 = (unint64_t *)&v144->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }

    goto LABEL_54;
  }

  char v15 = *(void **)(a1 + 48);
  uint64_t v16 = (char *)v15[136];
  uint64_t v17 = (char *)v15[135];
  uint64_t v18 = v16 - v17;
  if (v16 == v17) {
    uint64_t v19 = 0LL;
  }
  else {
    uint64_t v19 = ((v16 - v17) << 6) - 1;
  }
  unint64_t v20 = v15[138];
  if (v19 == v15[139] + v20)
  {
    BOOL v21 = v20 >= 0x200;
    unint64_t v22 = v20 - 512;
    if (v21)
    {
      v15[138] = v22;
      uint64_t v25 = *(void *)v17;
      uint64_t v23 = v17 + 8;
      uint64_t v24 = v25;
      v15[135] = v23;
      if (v16 == (char *)v15[137])
      {
        unint64_t v26 = v15[134];
        uint64_t v27 = (uint64_t)&v23[-v26];
        if ((unint64_t)v23 <= v26)
        {
          uint64_t v55 = (uint64_t)&v16[-v26];
          BOOL v54 = v55 == 0;
          uint64_t v56 = v55 >> 2;
          if (v54) {
            unint64_t v57 = 1LL;
          }
          else {
            unint64_t v57 = v56;
          }
          uint64_t v58 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v57);
          size_t v60 = &v58[8 * (v57 >> 2)];
          unsigned int v61 = (uint64_t *)v15[135];
          uint64_t v16 = v60;
          uint64_t v62 = v15[136] - (void)v61;
          if (v62)
          {
            uint64_t v16 = &v60[v62 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v63 = 8 * (v62 >> 3);
            uint64_t v64 = &v58[8 * (v57 >> 2)];
            do
            {
              uint64_t v65 = *v61++;
              *(void *)uint64_t v64 = v65;
              v64 += 8;
              v63 -= 8LL;
            }

            while (v63);
          }

          unsigned int v66 = (void *)v15[134];
          v15[134] = v58;
          v15[135] = v60;
          v15[136] = v16;
          v15[137] = &v58[8 * v59];
          if (v66)
          {
            operator delete(v66);
            uint64_t v16 = (char *)v15[136];
          }
        }

        else
        {
          uint64_t v28 = v27 >> 3;
          BOOL v29 = v27 >> 3 < -1;
          uint64_t v30 = (v27 >> 3) + 2;
          if (v29) {
            uint64_t v31 = v30;
          }
          else {
            uint64_t v31 = v28 + 1;
          }
          uint64_t v32 = -(v31 >> 1);
          uint64_t v33 = v31 >> 1;
          char v34 = &v23[-8 * v33];
          int64_t v35 = v16 - v23;
          if (v16 != v23)
          {
            memmove(&v23[-8 * v33], v23, v16 - v23);
            uint64_t v16 = (char *)v15[135];
          }

          int v36 = &v16[8 * v32];
          uint64_t v16 = &v34[v35];
          v15[136] = &v34[v35];
          v15[135] = v36;
        }
      }

      *(void *)uint64_t v16 = v24;
    }

    else
    {
      uint64_t v37 = v18 >> 3;
      uint64_t v38 = (char *)v15[137];
      uint64_t v39 = (char *)v15[134];
      if (v18 >> 3 >= (unint64_t)((v38 - v39) >> 3))
      {
        uint64_t v135 = *(void *)(a1 + 40);
        if (v38 == v39) {
          unint64_t v42 = 1LL;
        }
        else {
          unint64_t v42 = (v38 - v39) >> 2;
        }
        uint64_t v43 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v42);
        uint64_t v45 = v44;
        unint64_t v46 = &v43[8 * v37];
        *(void *)&__int128 v47 = v43;
        *((void *)&v47 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v46;
        __int128 v139 = v47;
        unint64_t v48 = operator new(0x1000uLL);
        *(void *)&__int128 v49 = v46;
        *((void *)&v49 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &v43[8 * v45];
        if (v37 == v45)
        {
          uint64_t v50 = 8 * v37;
          *(void *)&__int128 v51 = v139;
          if (v18 < 1)
          {
            int v99 = v48;
            uint64_t v100 = v50 >> 2;
            if (v16 == v17) {
              unint64_t v101 = 1LL;
            }
            else {
              unint64_t v101 = v100;
            }
            uint64_t v102 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v101);
            unint64_t v46 = &v102[8 * (v101 >> 2)];
            *(void *)&__int128 v51 = v102;
            *((void *)&v51 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v46;
            *(void *)&__int128 v49 = v46;
            *((void *)&v49 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &v102[8 * v103];
            if (v43)
            {
              __int128 v136 = v49;
              __int128 v140 = v51;
              operator delete(v43);
              __int128 v49 = v136;
              __int128 v51 = v140;
            }

            unint64_t v48 = v99;
          }

          else
          {
            uint64_t v52 = v50 >> 3;
            if (v52 >= -1) {
              unint64_t v53 = v52 + 1;
            }
            else {
              unint64_t v53 = v52 + 2;
            }
            v46 -= 8 * (v53 >> 1);
            *(void *)&__int128 v49 = v46;
            *((void *)&v51 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v46;
          }
        }

        else
        {
          __int128 v51 = v139;
        }

        *(void *)unint64_t v46 = v48;
        *(void *)&__int128 v49 = v49 + 8;
        uint64_t v104 = v15[136];
        uint64_t v5 = v135;
        while (v104 != v15[135])
        {
          uint64_t v105 = (void *)*((void *)&v51 + 1);
          if (*((void *)&v51 + 1) == (void)v51)
          {
            uint64_t v107 = (_BYTE *)v49;
            if ((unint64_t)v49 >= *((void *)&v49 + 1))
            {
              if (*((void *)&v49 + 1) == *((void *)&v51 + 1)) {
                unint64_t v112 = 1LL;
              }
              else {
                unint64_t v112 = (uint64_t)(*((void *)&v49 + 1) - *((void *)&v51 + 1)) >> 2;
              }
              uint64_t v113 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v112);
              CFMutableArrayRef v106 = &v113[(2 * v112 + 6) & 0xFFFFFFFFFFFFFFF8LL];
              int v115 = v106;
              uint64_t v116 = v107 - (_BYTE *)v105;
              if (v107 != (_BYTE *)v105)
              {
                int v115 = &v106[v116 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v117 = 8 * (v116 >> 3);
                uint64_t v118 = v106;
                int v119 = v105;
                do
                {
                  uint64_t v120 = *v119++;
                  *(void *)uint64_t v118 = v120;
                  v118 += 8;
                  v117 -= 8LL;
                }

                while (v117);
              }

              *(void *)&__int128 v51 = v113;
              *((void *)&v51 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v106;
              *(void *)&__int128 v49 = v115;
              *((void *)&v49 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = &v113[8 * v114];
              if (v105)
              {
                __int128 v137 = v49;
                __int128 v142 = v51;
                operator delete(v105);
                __int128 v49 = v137;
                __int128 v51 = v142;
              }
            }

            else
            {
              uint64_t v108 = (uint64_t)(*((void *)&v49 + 1) - v49) >> 3;
              if (v108 >= -1) {
                uint64_t v109 = v108 + 1;
              }
              else {
                uint64_t v109 = v108 + 2;
              }
              uint64_t v110 = v109 >> 1;
              uint64_t v111 = v49 + 8 * (v109 >> 1);
              CFMutableArrayRef v106 = (char *)(v111 - (v49 - *((void *)&v51 + 1)));
              if ((void)v49 == *((void *)&v51 + 1))
              {
                uint64_t v107 = (_BYTE *)*((void *)&v51 + 1);
              }

              else
              {
                uint64_t v138 = *((void *)&v49 + 1);
                uint64_t v141 = v51;
                memmove( (void *)(v111 - (v49 - *((void *)&v51 + 1))),  *((const void **)&v51 + 1),  v49 - *((void *)&v51 + 1));
                *((void *)&v49 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v138;
                *(void *)&__int128 v51 = v141;
              }

              *((void *)&v51 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v106;
              *(void *)&__int128 v49 = &v107[8 * v110];
            }
          }

          else
          {
            CFMutableArrayRef v106 = (char *)*((void *)&v51 + 1);
          }

          uint64_t v121 = *(void *)(v104 - 8);
          v104 -= 8LL;
          *((void *)v106 - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v121;
          *((void *)&v51 + 1) -= 8LL;
        }

        unint64_t v122 = (void *)v15[134];
        *((_OWORD *)v15 + 67) = v51;
        *((_OWORD *)v15 + 6_Block_object_dispose(va, 8) = v49;
        if (v122)
        {
          operator delete(v122);
          uint64_t v16 = (char *)v15[136];
        }

        else
        {
          uint64_t v16 = (char *)v49;
        }

        goto LABEL_48;
      }

      uint64_t v40 = operator new(0x1000uLL);
      uint64_t v41 = v40;
      if (v38 == v16)
      {
        if (v17 == v39)
        {
          if (v16 == v17) {
            unint64_t v76 = 1LL;
          }
          else {
            unint64_t v76 = (v38 - v17) >> 2;
          }
          uint64_t v77 = 2 * v76;
          unsigned int v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v76);
          uint64_t v17 = &v78[(v77 + 6) & 0xFFFFFFFFFFFFFFF8LL];
          uint64_t v80 = (uint64_t *)v15[135];
          unsigned int v81 = v17;
          uint64_t v82 = v15[136] - (void)v80;
          if (v82)
          {
            unsigned int v81 = &v17[v82 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v83 = 8 * (v82 >> 3);
            uint64_t v84 = v17;
            do
            {
              uint64_t v85 = *v80++;
              *(void *)uint64_t v84 = v85;
              v84 += 8;
              v83 -= 8LL;
            }

            while (v83);
          }

          char v86 = (void *)v15[134];
          v15[134] = v78;
          v15[135] = v17;
          v15[136] = v81;
          v15[137] = &v78[8 * v79];
          if (v86)
          {
            operator delete(v86);
            uint64_t v17 = (char *)v15[135];
          }
        }

        *((void *)v17 - __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v41;
        uint64_t v87 = (char *)v15[135];
        v15[135] = v87 - 8;
        uint64_t v88 = *((void *)v87 - 1);
        v15[135] = v87;
        unint64_t v89 = (char *)v15[136];
        if (v89 == (char *)v15[137])
        {
          unint64_t v90 = v15[134];
          uint64_t v91 = (uint64_t)&v87[-v90];
          if ((unint64_t)v87 <= v90)
          {
            uint64_t v123 = (uint64_t)&v89[-v90];
            BOOL v54 = v123 == 0;
            uint64_t v124 = v123 >> 2;
            if (v54) {
              unint64_t v125 = 1LL;
            }
            else {
              unint64_t v125 = v124;
            }
            unint64_t v126 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<__CFURLCacheNode **>>(v125);
            uint64_t v128 = &v126[8 * (v125 >> 2)];
            uint64_t v129 = (uint64_t *)v15[135];
            unint64_t v89 = v128;
            uint64_t v130 = v15[136] - (void)v129;
            if (v130)
            {
              unint64_t v89 = &v128[v130 & 0xFFFFFFFFFFFFFFF8LL];
              uint64_t v131 = 8 * (v130 >> 3);
              unint64_t v132 = &v126[8 * (v125 >> 2)];
              do
              {
                uint64_t v133 = *v129++;
                *(void *)unint64_t v132 = v133;
                v132 += 8;
                v131 -= 8LL;
              }

              while (v131);
            }

            uint64_t v134 = (void *)v15[134];
            v15[134] = v126;
            v15[135] = v128;
            v15[136] = v89;
            v15[137] = &v126[8 * v127];
            if (v134)
            {
              operator delete(v134);
              unint64_t v89 = (char *)v15[136];
            }
          }

          else
          {
            uint64_t v92 = v91 >> 3;
            BOOL v29 = v91 >> 3 < -1;
            uint64_t v93 = (v91 >> 3) + 2;
            if (v29) {
              uint64_t v94 = v93;
            }
            else {
              uint64_t v94 = v92 + 1;
            }
            uint64_t v95 = -(v94 >> 1);
            uint64_t v96 = v94 >> 1;
            int v97 = &v87[-8 * v96];
            int64_t v98 = v89 - v87;
            if (v89 != v87)
            {
              memmove(&v87[-8 * v96], v87, v89 - v87);
              uint64_t v87 = (char *)v15[135];
            }

            unint64_t v89 = &v97[v98];
            v15[136] = &v97[v98];
            v15[135] = &v87[8 * v95];
          }
        }

        *(void *)unint64_t v89 = v88;
      }

      else
      {
        *(void *)uint64_t v16 = v40;
      }
    }

    uint64_t v16 = (char *)(v15[136] + 8LL);
    v15[136] = v16;
LABEL_48:
    uint64_t v17 = (char *)v15[135];
  }

  if (v16 == v17)
  {
    uint64_t v68 = 0LL;
  }

  else
  {
    unint64_t v67 = v15[139] + v15[138];
    uint64_t v68 = (void **)(*(void *)&v17[(v67 >> 6) & 0x3FFFFFFFFFFFFF8LL] + 8 * (v67 & 0x1FF));
  }

  *uint64_t v68 = _Block_copy(*(const void **)(a1 + 32));
  ++v15[139];
  int v69 = *(HTTP3Connection **)(a1 + 48);
  if (*((void *)v69 + 139) == 1LL) {
    HTTP3Connection::_tryCreateBidirectionalStreams(v69);
  }
LABEL_54:
  if (a3)
  {
    uint64_t v70 = *(void *)(*(void *)(a1 + 48) + 1008LL);
    if (v70)
    {
      if ((*(_BYTE *)(v5 + 920) & 4) == 0)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v70 + 96LL))(v70, *(int *)(v5 + 792) + 3LL);
        uint64_t v71 = *(void *)(a1 + 48);
        unint64_t __src = 0LL;
        size_t v73 = QUICUtilities::quic_vle_encode(*(int *)(v71 + 792) - 1LL, &__src, v72);
        memcpy(__dst, &__src, v73);
        uint64_t v74 = *(void *)(v71 + 1024);
        dispatch_data_t v75 = dispatch_data_create(__dst, v73, 0LL, 0LL);
        HTTP3Framer::writeFrame(v74, 0xDuLL, v75, 0, &__block_literal_global_25_5215);
      }
    }
  }

void sub_182A8D89C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, __int128 a13, uint64_t a14, char a15)
{
  if ((void)a13) {
    operator delete((void *)a13);
  }
  _Unwind_Resume(a1);
}

void HTTP3Connection::streamExitedStallableState(uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a2)
  {
    __uint64_t v3 = *(void **)(a1 + 976);
    if (v3)
    {
      v8[0] = a2;
      v8[1] = (uint64_t)a3;
      if (a3)
      {
        p_uint64_t shared_owners = (unint64_t *)&a3->__shared_owners_;
        do
          unint64_t v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
        HTTPStallTimer::remove(v3, v8);
        do
          unint64_t v7 = __ldaxr(p_shared_owners);
        while (__stlxr(v7 - 1, p_shared_owners));
        if (!v7)
        {
          ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
          std::__shared_weak_count::__release_weak(a3);
        }
      }

      else
      {
        HTTPStallTimer::remove(v3, v8);
      }
    }
  }

__CFString *NetConnection::copyDebugDesc(NetConnection *this)
{
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  (*(void (**)(NetConnection *))(*(void *)this + 40LL))(this);
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  (*(void (**)(NetConnection *))(*(void *)this + 48LL))(this);
  unint64_t v6 = (void *)*((void *)this + 14);
  if (v6)
  {
    LODWORD(v7) = 0;
    do
    {
      unint64_t v6 = (void *)*v6;
      uint64_t v7 = (v7 + 1);
    }

    while (v6);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  unint64_t v8 = CFStringCreateWithFormat( v2,  0LL,  @"<NetConnection@%p> { State = %s, Count = %d, requests = {",  this,  "",  v7);
  uint64_t v9 = *((void *)this + 12);
  if (v9) {
    pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
  }
  CFStringAppend(Mutable, v8);
  if (v8) {
    CFRelease(v8);
  }
  unint64_t v10 = (void *)*((void *)this + 14);
  if (v10)
  {
    uint64_t v11 = 0LL;
    do
    {
      unint64_t v12 = (const void *)(*(uint64_t (**)(NetConnection *, void))(*(void *)this + 184LL))(this, v10[1]);
      unint64_t v13 = CFStringCreateWithFormat(v2, 0LL, @"%d: %@, ", v11, v12);
      if (v12) {
        CFRelease(v12);
      }
      CFStringAppend(Mutable, v13);
      if (v13) {
        CFRelease(v13);
      }
      uint64_t v11 = (v11 + 1);
      unint64_t v10 = (void *)*v10;
    }

    while (v10);
  }

  CFStringAppend(Mutable, @"}  }");
  uint64_t v14 = *((void *)this + 12);
  if (v14) {
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
  }
  return Mutable;
}

BOOL NetConnection::equals(NetConnection *this, const CFAllocatedReferenceCountedObject *a2)
{
  return this == a2;
}

uint64_t NetConnection::copyDescription(NetConnection *this)
{
  return (*(uint64_t (**)(NetConnection *))(*(void *)this + 16LL))(this);
}

uint64_t NetConnection::errorOccurred(NetConnection *this, CFStreamError *a2)
{
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  *((_WORD *)this + 44) &= ~1u;
  uint64_t v5 = (uint64_t *)*((void *)this + 17);
  *((void *)this + CFRelease((char *)this - 16) = 0LL;
  *((void *)this + 17) = 0LL;
  NetConnection::sendStateChanged((uint64_t)this, v5, (uint64_t)a2);
  NetConnection::shutdownConnectionStreams((uint64_t)this, 0LL);
  *((_WORD *)this + 44) |= 0x800u;
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = (void (*)(NetConnection *, void))*((void *)this + 23);
  if (v7) {
    v7(this, *((void *)this + 27));
  }
  return (*(uint64_t (**)(NetConnection *))(*(void *)this + 48LL))(this);
}

uint64_t NetConnection::connectionLost(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = *((_WORD *)this + 44) & 0xFEFE | 0x100;
  __uint64_t v3 = (uint64_t **)*((void *)this + 17);
  if (v3)
  {
    uint64_t v4 = *v3;
    if (*v3)
    {
      uint64_t v9 = 4LL;
      int v10 = -4;
      uint64_t v5 = *((void *)this + 16);
      if (v5 && (uint64_t **)v5 != v3)
      {
        *((void *)this + CFRelease((char *)this - 16) = 0LL;
        NetConnection::scheduleNewRequest(this, 0LL, v5, 0);
      }

      NetConnection::sendStateChanged((uint64_t)this, v4, (uint64_t)&v9);
    }
  }

  NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = (void (*)(NetConnection *, void))*((void *)this + 23);
  if (v7) {
    v7(this, *((void *)this + 27));
  }
  return (*(uint64_t (**)(NetConnection *))(*(void *)this + 48LL))(this);
}

uint64_t NetConnection::pendingResponseCount(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  __uint64_t v3 = (void *)((char *)this + 136);
  LODWORD(vos_unfair_lock_lock((os_unfair_lock_t)cf + 4) = -1;
  do
  {
    __uint64_t v3 = (void *)*v3;
    uint64_t v4 = (v4 + 1);
  }

  while (v3);
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  return v4;
}

void NetConnection::closeConnectionStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    CoreStreamBase::_streamInterface_Close((CoreStreamBase *)(a3 + 16));
  }

  if (a4)
  {
    CoreStreamBase::_streamInterface_Close((CoreStreamBase *)(a4 + 16));
  }

uint64_t NetConnection::cleanAbortRequestTransmission(uint64_t this)
{
  *(_WORD *)(this + 88) &= ~0x20u;
  if (*(void *)(this + 128) == *(void *)(this + 136)) {
    *(void *)(this + 136) = 0LL;
  }
  return this;
}

uint64_t NetConnection::copyTrust(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
    uint64_t v3 = *((void *)this + 12);
    uint64_t v4 = *((void *)this + 18);
    if (v3) {
      pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
    }
    if (v4) {
      goto LABEL_5;
    }
    return 0LL;
  }

  uint64_t v4 = *((void *)this + 18);
  if (!v4) {
    return 0LL;
  }
LABEL_5:
  ++*(void *)(v4 + 96);
  uint64_t result = (*(uint64_t (**)(void, void *))(**(void **)(v4 + 40) + 40LL))( *(void *)(v4 + 40),  &unk_18C5AE010);
  --*(void *)(v4 + 96);
  return result;
}

void NetConnection::scheduleNewRequest(NetConnection *this, uint64_t **a2, uint64_t a3, int a4)
{
  char v8 = *((_BYTE *)this + 88);
  if (!a3 || (*((_BYTE *)this + 88) & 2) != 0)
  {
    uint64_t v9 = (char *)*((void *)this + 18);
    if (v9)
    {
      if (a2)
      {
        int v10 = a2;
        while (((_BYTE)v10[2] & 2) != 0)
        {
          int v10 = (uint64_t **)*v10;
          if (!v10)
          {
            int v10 = a2;
            break;
          }
        }

        uint64_t v11 = (const CoreSchedulingSet *)(*(uint64_t (**)(NetConnection *, uint64_t *))(*(void *)this + 160LL))( this,  v10[1]);
        NetConnection::rescheduleStream(*((char **)this + 18), v11);
        if (v11) {
          (*(void (**)(const CoreSchedulingSet *))(*(void *)v11 + 48LL))(v11);
        }
      }

      else
      {
        NetConnection::rescheduleStream(v9, 0LL);
      }
    }
  }

  __int16 v12 = *((_WORD *)this + 44);
  if ((v8 & 0x40) != 0)
  {
    if ((v12 & 0x80) == 0) {
      NetConnection::setClient((uint64_t)this);
    }
  }

  else
  {
    *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v12 | 0x40;
    NetConnection::openConnectionStreams((uint64_t)this);
  }

  if (a3)
  {
    (*(void (**)(NetConnection *, void, uint64_t, void))(*(void *)this + 120LL))( this,  *(void *)(a3 + 8),  3LL,  0LL);
    *((_WORD *)this + 44) &= ~0x20u;
    if (a4) {
      NetConnection::scheduleNewResponse(this, (uint64_t **)a3, 0LL);
    }
  }

  if (a2)
  {
    *((_WORD *)this + 44) |= 0x20u;
    (*(void (**)(NetConnection *, uint64_t *, uint64_t, void))(*(void *)this + 120LL))( this,  a2[1],  2LL,  0LL);
  }

uint64_t NetConnection::sendStateChanged(uint64_t result, uint64_t *a2, uint64_t a3)
{
LABEL_3:
  uint64_t v5 = i + 112;
  while (1)
  {
    uint64_t v5 = *(void *)v5;
    if (!v5) {
      return result;
    }
    if ((*(_BYTE *)(v5 + 16) & 1) != 0)
    {
      *(_BYTE *)(v5 + 16) &= ~1u;
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)i + 120LL))( i,  *(void *)(v5 + 8),  7LL,  a3);
      goto LABEL_3;
    }
  }

uint64_t NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 96);
  if (v2) {
    this = pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  if (*(_DWORD *)(v1 + 104) || *(_DWORD *)(v1 + 108)) {
    *(_WORD *)(v1 + 88) |= 0x800u;
  }
  else {
    this = NetConnection::shutdownConnectionStreams(v1, 0LL);
  }
  uint64_t v3 = *(void *)(v1 + 96);
  if (v3) {
    return pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  }
  return this;
}

uint64_t NetConnection::shutdownConnectionStreams(uint64_t this, void *a2)
{
  __int16 v2 = *(_WORD *)(this + 88);
  *(_WORD *)(this + 8_Block_object_dispose(va, 8) = v2 & 0xFF7F;
  if ((v2 & 0x2000) != 0)
  {
    uint64_t v4 = this;
    uint64_t v5 = *(void *)(this + 144);
    if (v5)
    {
      if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v5 + 16)) <= 1)
      {
        uint64_t v6 = *(void *)(v4 + 144);
        if (v6) {
          uint64_t v7 = (CoreStreamBase *)(v6 + 16);
        }
        else {
          uint64_t v7 = 0LL;
        }
        CoreStreamBase::_streamInterface_Open(v7);
      }

      uint64_t v8 = *(void *)(v4 + 144);
      if (v8) {
        uint64_t v9 = v8 + 16;
      }
      else {
        uint64_t v9 = 0LL;
      }
      (*(void (**)(uint64_t, void, void))(*(void *)v9 + 56LL))(v9, 0LL, 0LL);
      uint64_t v10 = *(void *)(v4 + 144);
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    uint64_t v11 = *(void *)(v4 + 152);
    if (v11)
    {
      if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v11 + 16)) <= 1)
      {
        uint64_t v12 = *(void *)(v4 + 152);
        if (v12) {
          unint64_t v13 = (CoreStreamBase *)(v12 + 16);
        }
        else {
          unint64_t v13 = 0LL;
        }
        CoreStreamBase::_streamInterface_Open(v13);
      }

      uint64_t v14 = *(void *)(v4 + 152);
      if (v14) {
        uint64_t v15 = v14 + 16;
      }
      else {
        uint64_t v15 = 0LL;
      }
      (*(void (**)(uint64_t, void, void))(*(void *)v15 + 56LL))(v15, 0LL, 0LL);
      uint64_t v16 = *(void *)(v4 + 152);
    }

    else
    {
      uint64_t v16 = 0LL;
    }

    this = (*(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)v4 + 176LL))(v4, a2, v16, v10);
    *(_WORD *)(v4 + 88) &= ~0x2000u;
  }

  return this;
}

void NetConnection::rescheduleStream(char *cf, const CoreSchedulingSet *a2)
{
  __int16 v2 = a2;
  if (!cf)
  {
    uint64_t v4 = 0LL;
    if (a2) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }

  CFRetain(cf);
  uint64_t v4 = (CoreStreamBase *)(cf + 16);
  if (!v2)
  {
LABEL_7:
    __int16 v2 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
  }

uint64_t NetConnection::openConnectionStreams(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 144);
  if (v2)
  {
    this = CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v2 + 16));
  }

  uint64_t v3 = *(void *)(v1 + 152);
  if (v3)
  {
    this = CoreStreamBase::_streamInterface_Open((CoreStreamBase *)(v3 + 16));
  }

  *(_WORD *)(v1 + 88) |= 0x2000u;
  return this;
}

uint64_t NetConnection::setClient(uint64_t this)
{
  uint64_t v1 = this;
  *(_WORD *)(this + 88) |= 0x80u;
  v4.version = 0LL;
  v4.mach_timebase_info info = (void *)this;
  v4.retain = (void *(__cdecl *)(void *))NetConnection::_retainFilter;
  v4.release = (void (__cdecl *)(void *))NetConnection::_releaseFilter;
  v4.copyDescription = (CFStringRef (__cdecl *)(void *))NetConnection::_copyDescription;
  uint64_t v2 = *(void *)(this + 144);
  if (v2)
  {
    this = CoreWriteStream::setClient(v2 + 16, -1LL, (uint64_t)NetConnection::_connectionRequestCallBack, &v4);
  }

  uint64_t v3 = *(void *)(v1 + 152);
  if (v3)
  {
    return CoreReadStream::setClient(v3 + 16, -1LL, (uint64_t)NetConnection::_connectionResponseCallBack, &v4);
  }

  return this;
}

void NetConnection::scheduleNewResponse(void *a1, uint64_t **a2, uint64_t a3)
{
  uint64_t v6 = (char *)a1[19];
  if (!v6) {
    goto LABEL_21;
  }
  if (!a2)
  {
    uint64_t v8 = 0LL;
LABEL_10:
    CFRetain(v6);
    char v10 = 0;
    uint64_t v9 = (CoreStreamBase *)(v6 + 16);
    goto LABEL_13;
  }

  uint64_t v7 = a2;
  while (((_BYTE)v7[2] & 2) != 0)
  {
    uint64_t v7 = (uint64_t **)*v7;
    if (!v7)
    {
      uint64_t v7 = a2;
      break;
    }
  }

  uint64_t v8 = (*(uint64_t (**)(void *, uint64_t *))(*a1 + 160LL))(a1, v7[1]);
  uint64_t v6 = (char *)a1[19];
  if (v6) {
    goto LABEL_10;
  }
  uint64_t v9 = 0LL;
  char v10 = 1;
LABEL_13:
  uint64_t v11 = (const CoreSchedulingSet *)v8;
  if (!v8)
  {
    if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
    {
      uint64_t v12 = v9;
      dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16893);
      uint64_t v9 = v12;
    }

    uint64_t v11 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
  }

  CoreStreamBase::_streamInterface_UpdateScheduling(v9, v11);
  if ((v10 & 1) == 0) {
    CFRelease(v6);
  }
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 48LL))(v8);
  }
LABEL_21:
  if (a3) {
    (*(void (**)(void *, void, uint64_t, void))(*a1 + 120LL))(a1, *(void *)(a3 + 8), 5LL, 0LL);
  }
  if (a2) {
    (*(void (**)(void *, uint64_t *, uint64_t, void))(*a1 + 120LL))(a1, a2[1], 4LL, 0LL);
  }
}

NetConnection *NetConnection::_retainFilter(NetConnection *this, void *a2)
{
  return this;
}

uint64_t NetConnection::_releaseFilter(NetConnection *this, void *a2)
{
  return (*(uint64_t (**)(NetConnection *))(*(void *)this + 48LL))(this);
}

uint64_t NetConnection::_copyDescription(NetConnection *this, void *a2)
{
  return (*(uint64_t (**)(NetConnection *))(*(void *)this + 16LL))(this);
}

uint64_t NetConnection::_connectionRequestCallBack(uint64_t result, uint64_t a2, void *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = a3[12];
  if (v6) {
    uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = a3[16];
  if (v7)
  {
    uint64_t result = (*(uint64_t (**)(void *, void, uint64_t, uint64_t))(*a3 + 152LL))( a3,  *(void *)(v7 + 8),  v5,  a2);
  }

  else if (!a3[17])
  {
    if (a2 == 8)
    {
      uint64_t v9 = v5 + 16;
      if (!v5) {
        uint64_t v9 = 0LL;
      }
      __int128 v10 = *(_OWORD *)(v9 + 56);
      uint64_t result = (*(uint64_t (**)(void *, __int128 *))(*a3 + 64LL))(a3, &v10);
    }

    else if (a2 == 16)
    {
      uint64_t result = (*(uint64_t (**)(void *))(*a3 + 72LL))(a3);
    }
  }

  uint64_t v8 = a3[12];
  if (v8) {
    return pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
  return result;
}

uint64_t NetConnection::_connectionResponseCallBack(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 96);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = *(void *)(a3 + 136);
  if (!v7 || (*(_WORD *)(a3 + 88) & 0x200) != 0)
  {
    if (a2 == 8)
    {
      uint64_t v8 = a1 + 16;
      if (!a1) {
        uint64_t v8 = 0LL;
      }
      __int128 v11 = *(_OWORD *)(v8 + 56);
      (*(void (**)(uint64_t, __int128 *))(*(void *)a3 + 64LL))(a3, &v11);
    }

    else if (a2 == 16)
    {
      (*(void (**)(uint64_t))(*(void *)a3 + 72LL))(a3);
    }
  }

  else
  {
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 144LL))(a3, *(void *)(v7 + 8), a1, a2);
  }

  uint64_t v9 = *(void *)(a3 + 96);
  if (v9) {
    pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 48LL))(a3);
}

uint64_t NetConnection::pendingRequestCount(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  uint64_t v3 = (void *)((char *)this + 128);
  LODWORD(vos_unfair_lock_lock((os_unfair_lock_t)cf + 4) = -1;
  do
  {
    uint64_t v3 = (void *)*v3;
    uint64_t v4 = (v4 + 1);
  }

  while (v3);
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
  }
  return v4;
}

void NetConnection::~NetConnection(NetConnection *this)
{
  *(void *)this = off_189C08810;
  *((void *)this + 3) = &unk_189C088F0;
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    uint64_t v3 = (const __CFAllocator *)*((void *)this + 1);
    while (v2)
    {
      uint64_t v4 = (void *)*v2;
      CFAllocatorDeallocate(v3, v2);
      uint64_t v2 = v4;
    }
  }

  uint64_t v5 = (const void *)*((void *)this + 30);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  NetConnection::shutdownConnectionStreams((uint64_t)this, 0LL);
  uint64_t v7 = (const void *)*((void *)this + 18);
  *((void *)this + 1_Block_object_dispose(va, 8) = 0LL;
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)*((void *)this + 19);
  *((void *)this + 19) = 0LL;
  if (v8) {
    CFRelease(v8);
  }
  *((void *)this + 3) = off_189C19AE8;
}

void sub_182A8EA00(_Unwind_Exception *a1)
{
  *(void *)(v1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = off_189C19AE8;
  _Unwind_Resume(a1);
}

uint64_t NetConnection::initialize(NetConnection *this, int a2)
{
  uint64_t v4 = (_CoreLockable *)operator new(0x48uLL);
  _CoreLockable::_CoreLockable(v4, 1);
  *(void *)uint64_t v4 = off_189C12688;
  *((void *)this + 12) = v4;
  if (a2) {
    *((_WORD *)this + 44) |= 0x400u;
  }
  *((CFAbsoluteTime *)this + 20) = CFAbsoluteTimeGetCurrent();
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 2_Block_object_dispose(va, 8) = 0LL;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + _Block_object_dispose(va, 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((void *)this + 30) = @"NEW CONNECTION";
  *((_DWORD *)this + 5_Block_object_dispose(va, 8) = 0;
  (*(void (**)(NetConnection *, char *, char *))(*(void *)this + 112LL))( this,  (char *)this + 144,  (char *)this + 152);
  if (!*((void *)this + 18) && !*((void *)this + 19)) {
    return 0LL;
  }
  NetConnection::setClient((uint64_t)this);
  *((_WORD *)this + 44) |= 1u;
  return 1LL;
}

void sub_182A8EAEC(_Unwind_Exception *a1)
{
}

uint64_t NetConnection::enqueue(NetConnection *this, void *a2, int a3)
{
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  int v7 = *((_DWORD *)this + 27);
  *((_DWORD *)this + 27) = v7 + 1;
  __int16 v8 = *((_WORD *)this + 44);
  if ((v8 & 1) == 0)
  {
    uint64_t v9 = 0LL;
    *((_DWORD *)this + 27) = v7;
    if (!*((_DWORD *)this + 26) && !v7 && (v8 & 0x800) != 0)
    {
      NetConnection::shutdownConnectionStreams((uint64_t)this, 0LL);
      uint64_t v9 = 0LL;
    }

    goto LABEL_74;
  }

  uint64_t v10 = MEMORY[0x186E12804](*((void *)this + 1), 24LL, 0LL);
  uint64_t v11 = v10;
  *(void *)uint64_t v10 = 0LL;
  *(void *)(v10 + _Block_object_dispose(va, 8) = a2;
  *(_BYTE *)(v10 + CFRelease((char *)this - 16) = 0;
  if (a3)
  {
    uint64_t v12 = (uint64_t *)*((void *)this + 16);
    if (v12)
    {
      uint64_t v13 = *v12;
      uint64_t *v12 = v10;
      *(void *)uint64_t v10 = v13;
      uint64_t v14 = (char *)this + 120;
      goto LABEL_15;
    }
  }

  uint64_t v15 = (uint64_t *)((char *)this + 112);
  if (*((void *)this + 14)) {
    uint64_t v15 = (uint64_t *)*((void *)this + 15);
  }
  *uint64_t v15 = v10;
  uint64_t v14 = (char *)this + 128;
  uint64_t v16 = *((void *)this + 16);
  *((void *)this + 15) = v10;
  *(void *)uint64_t v10 = 0LL;
  if (!v16) {
LABEL_15:
  }
    *(void *)uint64_t v14 = v10;
LABEL_16:
  if (!*((void *)this + 17)) {
    *((void *)this + 17) = v10;
  }
  ++*((_DWORD *)this + 26);
  ++_NetConnection_GlobalPendingResponses;
  if ((*((_BYTE *)this + 88) & 2) != 0) {
    NetConnection::doublecheckPipelining(this);
  }
  if (_pipelineShouldPackPackets(void)::haveChecked == 1)
  {
LABEL_24:
    if ((*((_WORD *)this + 44) & 2) != 0)
    {
      uint64_t v18 = *((void *)this + 18);
      if (v18) {
        uint64_t v19 = v18 + 16;
      }
      else {
        uint64_t v19 = 0LL;
      }
      ++*(void *)(v19 + 80);
      (*(void (**)(void, uint64_t))(**(void **)(v19 + 24) + 32LL))(*(void *)(v19 + 24), 0x18C5AC100LL);
      --*(void *)(v19 + 80);
    }

    goto LABEL_31;
  }

  BOOL v17 = getenv("CFNETWORK_PIPELINE_PACK") != 0LL;
  _pipelineShouldPackPackets(void)::shouldPackPackets = v17;
  _pipelineShouldPackPackets(void)::haveChecked = 1;
  if (v17) {
    goto LABEL_24;
  }
LABEL_31:
  (*(void (**)(NetConnection *, void *, uint64_t, void))(*(void *)this + 120LL))(this, a2, 1LL, 0LL);
  __int16 v20 = *((_WORD *)this + 44);
  if ((v20 & 0x400) == 0)
  {
    v20 &= ~1u;
    *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v20;
  }

  uint64_t v21 = *((void *)this + 16);
  if (v21 == *((void *)this + 17) || (v20 & 2) != 0)
  {
    if (v21 == v11)
    {
      NetConnection::scheduleNewRequest(this, (uint64_t **)v11, 0LL, 0);
    }

    else if (*((void *)this + 18))
    {
      if (v21)
      {
        unint64_t v22 = (uint64_t *)*((void *)this + 16);
        while ((v22[2] & 2) != 0)
        {
          unint64_t v22 = (uint64_t *)*v22;
          if (!v22)
          {
            unint64_t v22 = (uint64_t *)*((void *)this + 16);
            break;
          }
        }
      }

      else
      {
        unint64_t v22 = 0LL;
      }

      if (v22 == (uint64_t *)v11)
      {
        uint64_t v23 = (const CoreSchedulingSet *)(*(uint64_t (**)(NetConnection *, void))(*(void *)this + 160LL))( this,  *(void *)(v11 + 8));
        NetConnection::rescheduleStream(*((char **)this + 18), v23);
        if (v23) {
          (*(void (**)(const CoreSchedulingSet *))(*(void *)v23 + 48LL))(v23);
        }
        if ((*((_WORD *)this + 44) & 0x20) != 0) {
          (*(void (**)(NetConnection *, void))(*(void *)this + 128LL))( this,  *(void *)(*((void *)this + 16) + 8LL));
        }
      }
    }
  }

  if (*((void *)this + 19))
  {
    uint64_t v24 = *((void *)this + 17);
    if (*((void *)this + 16) != v24)
    {
      if (v24)
      {
        uint64_t v25 = (uint64_t *)*((void *)this + 17);
        while ((v25[2] & 2) != 0)
        {
          uint64_t v25 = (uint64_t *)*v25;
          if (!v25)
          {
            uint64_t v25 = (uint64_t *)*((void *)this + 17);
            break;
          }
        }
      }

      else
      {
        uint64_t v25 = 0LL;
      }

      if (v25 == (uint64_t *)v11)
      {
        uint64_t v26 = (*(uint64_t (**)(NetConnection *, void))(*(void *)this + 160LL))(this, *(void *)(v11 + 8));
        uint64_t v27 = (char *)*((void *)this + 19);
        if (v27)
        {
          CFRetain(*((CFTypeRef *)this + 19));
          uint64_t v28 = (CoreStreamBase *)(v27 + 16);
        }

        else
        {
          uint64_t v28 = 0LL;
        }

        BOOL v29 = (const CoreSchedulingSet *)v26;
        if (!v26)
        {
          BOOL v29 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
        }

        CoreStreamBase::_streamInterface_UpdateScheduling(v28, v29);
        if (v27) {
          CFRelease(v27);
        }
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v26 + 48LL))(v26);
        }
        if ((*((_WORD *)this + 44) & 0x200) == 0) {
          (*(void (**)(NetConnection *, void))(*(void *)this + 136LL))( this,  *(void *)(*((void *)this + 17) + 8LL));
        }
      }
    }
  }

  --*((_DWORD *)this + 27);
  uint64_t v9 = 1LL;
LABEL_74:
  uint64_t v30 = *((void *)this + 12);
  if (v30) {
    pthread_mutex_unlock((pthread_mutex_t *)(v30 + 8));
  }
  (*(void (**)(NetConnection *))(*(void *)this + 48LL))(this);
  return v9;
}

void NetConnection::doublecheckPipelining(NetConnection *this)
{
  __int16 v1 = *((_WORD *)this + 44);
  if ((v1 & 4) == 0)
  {
    if ((v1 & 0x10) != 0)
    {
      if ((v1 & 8) == 0) {
        return;
      }
      __int16 v11 = v1 & 0xFFFD;
      goto LABEL_17;
    }

    *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v1 | 0x10;
    *(_DWORD *)char buffer = -1;
    uint64_t v3 = *((void *)this + 18);
    if (v3)
    {
      ++*(void *)(v3 + 96);
      uint64_t v4 = (const __CFData *)(*(uint64_t (**)(void, void *))(**(void **)(v3 + 40) + 40LL))( *(void *)(v3 + 40),  &unk_18C5ADD70);
      --*(void *)(v3 + 96);
      if (v4)
      {
        uint64_t v5 = v4;
        if (CFDataGetLength(v4) != 4)
        {
          uint64_t v12 = v5;
LABEL_15:
          CFRelease(v12);
          goto LABEL_16;
        }

        v14.CFIndex location = 0LL;
        v14.CFIndex length = 4LL;
        CFDataGetBytes(v5, v14, buffer);
        uint64_t v6 = (CFNA *)SCNetworkSignatureCopyIdentifierForConnectedSocket();
        CFRelease(v5);
        if (v6)
        {
          __int16 v8 = CFNA::_CFNetworkAgentCopyOperationSupportStateFromDynamicStore( v6,  (const __CFString *)"HTTPPipelining",  v7);
          if (v8)
          {
            uint64_t v9 = v8;
            CFComparisonResult v10 = CFStringCompare(v8, @"TRUE", 0LL);
            CFRelease(v9);
            CFRelease(v6);
            if (v10 == kCFCompareEqualTo) {
              return;
            }
            goto LABEL_16;
          }

          if (CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once != -1) {
            dispatch_once( &CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::once,  &__block_literal_global_9658);
          }
          CFNA::CFNetworkAgentClient::executeLegacyQuery( (CFNA::CFNetworkAgentClient *)CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client,  (const __CFString *)v6,  1LL);
          uint64_t v12 = v6;
          goto LABEL_15;
        }
      }
    }

void **NetConnection::dequeue(NetConnection *this, void *a2)
{
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  uint64_t v6 = (void **)((char *)this + 112);
  uint64_t v5 = (void **)*((void *)this + 14);
  if (!v5) {
    goto LABEL_28;
  }
  if (v5[1] == a2)
  {
    if (v5 == *((void ***)this + 16))
    {
      CFComparisonResult v10 = 0LL;
      int v7 = 0;
      uint64_t v9 = (void **)*((void *)this + 14);
LABEL_19:
      __int16 v12 = *((_WORD *)this + 44);
      if (v12 & 0x100 | v7)
      {
        uint64_t v5 = v9;
        if (v10) {
          goto LABEL_24;
        }
        goto LABEL_30;
      }

      if ((v12 & 0x20) != 0 || v9 != v5) {
        goto LABEL_27;
      }
      *((void *)this + CFRelease((char *)this - 16) = *v5;
    }

    else
    {
      CFComparisonResult v10 = 0LL;
      __int16 v11 = (void **)*((void *)this + 17);
LABEL_16:
      uint64_t v9 = v11;
      if (v5 == v11)
      {
LABEL_27:
        if (*(void **)(*((void *)this + 15) + 8LL) != a2)
        {
LABEL_28:
          uint64_t v9 = 0LL;
          goto LABEL_78;
        }

        *((_WORD *)this + 44) &= ~1u;
        if (*((void *)this + 16))
        {
          CFRange v14 = (void **)*((void *)this + 16);
          while (((_BYTE)v14[2] & 2) != 0)
          {
            CFRange v14 = (void **)*v14;
            if (!v14)
            {
              CFRange v14 = (void **)*((void *)this + 16);
              break;
            }
          }

          if (v14 == v9)
          {
            NetConnection::rescheduleStream(*((char **)this + 18), 0LL);
            *((_WORD *)this + 44) &= ~0x20u;
            *((void *)this + CFRelease((char *)this - 16) = 0LL;
          }
        }

        uint64_t v15 = (void **)*((void *)this + 17);
        if (v15)
        {
          uint64_t v16 = (void **)*((void *)this + 17);
          while (((_BYTE)v16[2] & 2) != 0)
          {
            uint64_t v16 = (void **)*v16;
            if (!v16)
            {
              uint64_t v16 = (void **)*((void *)this + 17);
              break;
            }
          }

          if (v16 == v9)
          {
            NetConnection::rescheduleStream(*((char **)this + 19));
            uint64_t v15 = 0LL;
            *((void *)this + 17) = 0LL;
          }
        }

        if (v10)
        {
          char v17 = *((_BYTE *)v10 + 16);
          *CFComparisonResult v10 = *v9;
          *uint64_t v9 = 0LL;
          if ((v17 & 2) != 0)
          {
            uint64_t v18 = *v6;
            uint64_t v19 = (void *)**v6;
            if (!v19) {
              goto LABEL_65;
            }
            int v20 = 0;
            int v21 = 0;
            unint64_t v22 = 0LL;
            uint64_t v23 = (void **)*v6;
            do
            {
              uint64_t v24 = v19;
              if (((_BYTE)v23[2] & 2) != 0)
              {
                if (v23 == *((void ***)this + 16)) {
                  int v21 = 1;
                }
                if (v23 == v15) {
                  int v20 = 1;
                }
              }

              else
              {
                int v21 = 0;
                int v20 = 0;
                unint64_t v22 = v23;
              }

              uint64_t v19 = (void *)*v19;
              uint64_t v23 = (void **)v24;
            }

            while (*v24);
            if (v22)
            {
              uint64_t v18 = *v22;
              if (v21) {
                *((void *)this + CFRelease((char *)this - 16) = 0LL;
              }
              if (v20) {
                *((void *)this + 17) = 0LL;
              }
            }

            else
            {
LABEL_65:
              *(_OWORD *)uint64_t v6 = 0u;
              *((_OWORD *)this + _Block_object_dispose(va, 8) = 0u;
            }

            int v25 = 0;
            if (v18)
            {
              do
              {
                uint64_t v36 = 4LL;
                int v37 = -4;
                (*(void (**)(NetConnection *, void, uint64_t, uint64_t *))(*(void *)this + 120LL))( this,  v18[1],  7LL,  &v36);
                uint64_t v26 = (void *)*v18;
                CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), v18);
                ++v25;
                uint64_t v18 = v26;
              }

              while (v26);
            }

            *((_DWORD *)this + 26) -= v25;
            _NetConnection_GlobalPendingResponses -= v25;
          }

          goto LABEL_69;
        }

void NetConnection::rescheduleStream(char *cf)
{
  if (cf)
  {
    CFRetain(cf);
    uint64_t v2 = (CoreStreamBase *)(cf + 16);
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  CoreStreamBase::_streamInterface_UpdateScheduling( v2,  (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet);
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t NetConnection::responseIsComplete(NetConnection *this, void *a2)
{
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  ++*((void *)this + 28);
  uint64_t v5 = *((void *)this + 17);
  uint64_t v9 = (uint64_t **)*((void *)this + 16);
  if ((uint64_t **)v5 == v9)
  {
    *((_WORD *)this + 44) |= 0x200u;
    goto LABEL_5;
  }

  CFComparisonResult v10 = *(uint64_t ***)v5;
  *((void *)this + 17) = *(void *)v5;
  __int16 v11 = *((_WORD *)this + 44);
  if (!v10)
  {
    uint64_t v13 = 0LL;
    if ((v11 & 2) == 0) {
      goto LABEL_23;
    }
LABEL_31:
    if ((v11 & 4) == 0) {
      CFComparisonResult v10 = 0LL;
    }
    if (v13) {
      char v17 = v13;
    }
    else {
      char v17 = v10;
    }
    NetConnection::scheduleNewResponse(this, v17, v5);
    goto LABEL_5;
  }

  if ((*((_WORD *)this + 44) & 0x100) != 0)
  {
    CFComparisonResult v10 = 0LL;
    uint64_t v13 = 0LL;
    *((void *)this + 17) = 0LL;
    if ((v11 & 2) == 0) {
      goto LABEL_23;
    }
    goto LABEL_31;
  }

  if ((v11 & 2) != 0 && v10 == v9) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = v10;
  }
  if ((v11 & 2) != 0) {
    goto LABEL_31;
  }
LABEL_23:
  CFRange v14 = (char *)*((void *)this + 18);
  if (v14)
  {
    if (v13)
    {
      uint64_t v15 = v13;
      while (((_BYTE)v15[2] & 2) != 0)
      {
        uint64_t v15 = (uint64_t **)*v15;
        if (!v15)
        {
          uint64_t v15 = v13;
          break;
        }
      }

      uint64_t v16 = (const CoreSchedulingSet *)(*(uint64_t (**)(NetConnection *, uint64_t *))(*(void *)this + 160LL))( this,  v15[1]);
      CFRange v14 = (char *)*((void *)this + 18);
    }

    else
    {
      uint64_t v16 = 0LL;
    }

    NetConnection::rescheduleStream(v14, v16);
    uint64_t v18 = (char *)*((void *)this + 19);
    if (v18)
    {
      CFRetain(*((CFTypeRef *)this + 19));
      uint64_t v19 = (CoreStreamBase *)(v18 + 16);
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    int v20 = v16;
    if (!v16)
    {
      if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      {
        uint64_t v23 = v19;
        dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16893);
        uint64_t v19 = v23;
      }

      int v20 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
    }

    CoreStreamBase::_streamInterface_UpdateScheduling(v19, v20);
    if (v18) {
      CFRelease(v18);
    }
    if (v16) {
      (*(void (**)(const CoreSchedulingSet *))(*(void *)v16 + 48LL))(v16);
    }
  }

  __int16 v21 = *((_WORD *)this + 44);
  if ((v11 & 0x40) != 0)
  {
    if ((v21 & 0x80) == 0) {
      NetConnection::setClient((uint64_t)this);
    }
  }

  else
  {
    *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v21 | 0x40;
    NetConnection::openConnectionStreams((uint64_t)this);
  }

  (*(void (**)(NetConnection *, void, uint64_t, void))(*(void *)this + 120LL))( this,  *(void *)(v5 + 8),  5LL,  0LL);
  __int16 v22 = *((_WORD *)this + 44);
  *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v22 & 0xFFDF;
  if (v13)
  {
    *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v22 | 0x20;
    (*(void (**)(NetConnection *, uint64_t *, uint64_t, void))(*(void *)this + 120LL))( this,  v13[1],  2LL,  0LL);
  }

uint64_t NetConnection::requestIsComplete(NetConnection *this, void *a2)
{
  uint64_t v4 = (void (*)(NetConnection *, void))*((void *)this + 21);
  if (v4) {
    v4(this, *((void *)this + 27));
  }
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
  }
  uint64_t v6 = *((void *)this + 16);
  if (!v6 || *(void **)(v6 + 8) != a2)
  {
    CFLog();
    goto LABEL_18;
  }

  __int16 v7 = *((_WORD *)this + 44);
  BOOL v9 = (v7 & 0x200) == 0 && *(void *)(*((void *)this + 17) + 8LL) == (void)a2;
  if ((*((_WORD *)this + 44) & 0x100) != 0)
  {
    *((void *)this + CFRelease((char *)this - 16) = 0LL;
    __int16 v11 = this;
    CFComparisonResult v10 = 0LL;
  }

  else
  {
    CFComparisonResult v10 = *(uint64_t ***)v6;
    *((void *)this + CFRelease((char *)this - 16) = *(void *)v6;
    if ((v7 & 2) == 0 || !v10)
    {
      NetConnection::scheduleNewRequest(this, 0LL, v6, v9);
      if (_pipelineShouldPackPackets(void)::haveChecked == 1)
      {
        int v14 = _pipelineShouldPackPackets(void)::shouldPackPackets;
      }

      else
      {
        int v14 = getenv("CFNETWORK_PIPELINE_PACK") != 0LL;
        _pipelineShouldPackPackets(void)::shouldPackPackets = v14;
        _pipelineShouldPackPackets(void)::haveChecked = 1;
      }

      if (v14 && (*((_WORD *)this + 44) & 2) != 0)
      {
        uint64_t v15 = *((void *)this + 18);
        if (CoreWriteStream::Class(void)::sOnce_CoreWriteStream != -1)
        {
          uint64_t v17 = *((void *)this + 18);
          dispatch_once(&CoreWriteStream::Class(void)::sOnce_CoreWriteStream, &__block_literal_global_3111);
          uint64_t v15 = v17;
        }

        if (v15) {
          uint64_t v16 = v15 + 16;
        }
        else {
          uint64_t v16 = 0LL;
        }
        ++*(void *)(v16 + 80);
        (*(void (**)(void, uint64_t))(**(void **)(v16 + 24) + 32LL))(*(void *)(v16 + 24), 0x18C5AC100LL);
        --*(void *)(v16 + 80);
      }

      goto LABEL_23;
    }

    __int16 v11 = this;
  }

  NetConnection::scheduleNewRequest(v11, v10, v6, v9);
LABEL_23:
  if ((v7 & 0x200) != 0)
  {
    NetConnection::responseIsComplete(this, *(void **)(v6 + 8));
    *((_WORD *)this + 44) &= ~0x200u;
  }

void NetConnection::setShouldPipeline(NetConnection *this, int a2)
{
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  __int16 v5 = *((_WORD *)this + 44);
  if (a2)
  {
    if ((v5 & 2) == 0)
    {
      NetConnection::doublecheckPipelining(this);
      __int16 v6 = *((_WORD *)this + 44);
      if ((v6 & 8) == 0)
      {
        *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6 | 2;
        if ((v6 & 0x20) == 0)
        {
          __int16 v7 = (uint64_t **)*((void *)this + 16);
          if (v7) {
            NetConnection::scheduleNewRequest(this, v7, *((void *)this + 17), 0);
          }
        }
      }
    }
  }

  else if ((v5 & 2) != 0)
  {
    *((_WORD *)this + 4os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v5 & 0xFFFD;
  }

  uint64_t v8 = *((void *)this + 12);
  if (v8) {
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
}

double NetConnection::getLastAccessTime(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  if (*((void *)this + 14)) {
    double Current = CFAbsoluteTimeGetCurrent();
  }
  else {
    double Current = *((double *)this + 20);
  }
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  }
  return Current;
}

uint64_t NetConnection::getState(NetConnection *this, int a2, uint64_t *a3)
{
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  if (a2)
  {
    uint64_t v7 = *((void *)this + 16);
    if (v7 && (*((_WORD *)this + 44) & 0x20) != 0) {
      (*(void (**)(NetConnection *, void))(*(void *)this + 128LL))(this, *(void *)(v7 + 8));
    }
    uint64_t v8 = *((void *)this + 17);
    if (v8 && (v8 != *((void *)this + 16) || (*((_WORD *)this + 44) & 0x20) == 0)) {
      (*(void (**)(NetConnection *, void))(*(void *)this + 136LL))(this, *(void *)(v8 + 8));
    }
  }

  if (!*((void *)this + 18) && !*((void *)this + 19)) {
    goto LABEL_14;
  }
  __int16 v9 = *((_WORD *)this + 44);
  if ((v9 & 0x2000) == 0) {
    goto LABEL_14;
  }
  uint64_t v13 = (uint64_t **)*((void *)this + 16);
  if (v13 && v13[1] == a3)
  {
    if ((v9 & 0x20) != 0) {
      uint64_t v10 = 2LL;
    }
    else {
      uint64_t v10 = 1LL;
    }
  }

  else
  {
    int v14 = (uint64_t **)*((void *)this + 17);
    if (v14 && v14[1] == a3)
    {
      uint64_t v10 = 4LL;
    }

    else if (v13)
    {
      while (v13[1] != a3)
      {
        uint64_t v13 = (uint64_t **)*v13;
        if (!v13) {
          goto LABEL_25;
        }
      }

      if ((*((_WORD *)this + 44) & 0x100) != 0) {
        uint64_t v10 = 7LL;
      }
      else {
        uint64_t v10 = 1LL;
      }
    }

    else
    {
LABEL_25:
      if (v14)
      {
        while (v14[1] != a3)
        {
          int v14 = (uint64_t **)*v14;
          if (!v14) {
            goto LABEL_28;
          }
        }

        if ((*((_WORD *)this + 44) & 0x100) != 0) {
          uint64_t v10 = 7LL;
        }
        else {
          uint64_t v10 = 3LL;
        }
      }

      else
      {
LABEL_28:
        uint64_t v15 = (uint64_t **)*((void *)this + 14);
        if (!v15)
        {
LABEL_14:
          uint64_t v10 = 7LL;
          goto LABEL_15;
        }

        while (v15[1] != a3)
        {
          uint64_t v15 = (uint64_t **)*v15;
          if (!v15) {
            goto LABEL_14;
          }
        }

        uint64_t v10 = 5LL;
      }
    }
  }

uint64_t NetConnection::schedule(uint64_t this, uint64_t *a2, CoreSchedulingSet *a3, const __CFString *cf1)
{
  uint64_t v7 = (void *)this;
  uint64_t v8 = *(void *)(this + 96);
  if (v8) {
    this = pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
  }
  if (v7[16])
  {
    this = v7[18];
    if (this)
    {
      __int16 v9 = (uint64_t **)v7[16];
      while (((_BYTE)v9[2] & 2) != 0)
      {
        __int16 v9 = (uint64_t **)*v9;
        if (!v9)
        {
          __int16 v9 = (uint64_t **)v7[16];
          break;
        }
      }

      if (v9[1] == a2) {
        this = CoreWriteStreamScheduleWithRunLoop((CoreStreamBase *)this, a3, cf1);
      }
    }
  }

  if (v7[17])
  {
    this = v7[19];
    if (this)
    {
      uint64_t v10 = (uint64_t **)v7[17];
      while (((_BYTE)v10[2] & 2) != 0)
      {
        uint64_t v10 = (uint64_t **)*v10;
        if (!v10)
        {
          uint64_t v10 = (uint64_t **)v7[17];
          break;
        }
      }

      if (v10[1] == a2) {
        this = CoreReadStreamScheduleWithRunLoop((CoreStreamBase *)this, a3, cf1);
      }
    }
  }

  uint64_t v11 = v7[12];
  if (v11) {
    return pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
  }
  return this;
}

void NetConnection::unschedule(NetConnection *this, uint64_t *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v6 = *((void *)this + 12);
  if (v6) {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
  }
  uint64_t v7 = (CoreStreamBase *)*((void *)this + 18);
  if (v7)
  {
    uint64_t v8 = (uint64_t **)*((void *)this + 16);
    if (v8)
    {
      __int16 v9 = (uint64_t **)*((void *)this + 16);
      while (((_BYTE)v9[2] & 2) != 0)
      {
        __int16 v9 = (uint64_t **)*v9;
        if (!v9) {
          goto LABEL_8;
        }
      }
    }

    else
    {
      if ((*((_WORD *)this + 44) & 2) != 0) {
        goto LABEL_17;
      }
      uint64_t v8 = (uint64_t **)*((void *)this + 17);
      if (!v8) {
        goto LABEL_17;
      }
      __int16 v9 = (uint64_t **)*((void *)this + 17);
      while (((_BYTE)v9[2] & 2) != 0)
      {
        __int16 v9 = (uint64_t **)*v9;
        if (!v9)
        {
LABEL_8:
          __int16 v9 = v8;
          break;
        }
      }
    }

    if (v9[1] == a2) {
      CoreWriteStreamUnscheduleFromRunLoop(v7);
    }
  }

void NetConnectionCache::Key::~Key(NetConnectionCache::Key *this)
{
}

{
  const void *v2;
  const void *v3;
  *(void *)this = off_189C08910;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
}

BOOL NetConnectionCache::Key::equals( NetConnectionCache::Key *this, const CFAllocatedReferenceCountedObject *a2)
{
  if (*((_DWORD *)this + 9) != *((_DWORD *)a2 + 9)
    || *((_DWORD *)this + 8) != *((_DWORD *)a2 + 8)
    || CFStringCompare(*((CFStringRef *)this + 3), *((CFStringRef *)a2 + 3), 1uLL))
  {
    return 0LL;
  }

  uint64_t v5 = *((void *)this + 5);
  unint64_t v6 = *((void *)a2 + 5);
  BOOL result = (v5 | v6) == 0;
  if (v5)
  {
    if (v6) {
      return CFEqual(*((CFTypeRef *)this + 5), (CFTypeRef)v6) != 0;
    }
  }

  return result;
}

CFHashCode NetConnectionCache::Key::hash(CFTypeRef *this)
{
  return CFHash(this[3]) | (int)(*((_DWORD *)this + 8) << 17) | (8 * *((_DWORD *)this + 9)) | (this[5] == 0LL);
}

CFStringRef NetConnectionCache::Key::copyDescription(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat( this[1],  0LL,  @"Host %@, port %d, type %d, properties = %@",  this[3],  *((unsigned int *)this + 8),  *((unsigned int *)this + 9),  this[5]);
}

void NetConnectionCache::~NetConnectionCache(NetConnectionCache *this)
{
  *(void *)this = off_189C08960;
  __int16 v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C08960;
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

uint64_t NetConnection::willEnqueueRequests(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  }
  if ((*((_WORD *)this + 44) & 1) != 0)
  {
    uint64_t v4 = *((void *)this + 19);
    if (!v4) {
      goto LABEL_14;
    }
    ++*(void *)(v4 + 96);
    uint64_t v5 = (const void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 40) + 40LL))( *(void *)(v4 + 40),  0x18C5AB680LL);
    --*(void *)(v4 + 96);
    if (v5)
    {
      unint64_t v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t v10 = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  v10,  2u);
      }

      if ((const void *)*MEMORY[0x189604DE8] == v6)
      {
        *((_WORD *)this + 44) &= ~1u;
        NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)this);
        uint64_t v3 = 0LL;
      }

      else
      {
        uint64_t v3 = 1LL;
      }

      CFRelease(v6);
    }

    else
    {
LABEL_14:
      uint64_t v3 = 1LL;
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  uint64_t v8 = *((void *)this + 12);
  if (v8) {
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
  }
  return v3;
}

void NetConnection_Classic::~NetConnection_Classic(NetConnection_Classic *this)
{
}

{
  void (*v2)(void);
  *(void *)this = off_189C08980;
  *((void *)this + 3) = &unk_189C08A60;
  uint64_t v2 = *(void (**)(void))(*((void *)this + 31) + 16LL);
  if (v2 && *((void *)this + 32)) {
    v2(*((void *)this + 1));
  }
  NetConnection::~NetConnection(this);
}

uint64_t NetConnection_Classic::infoPointer(NetConnection_Classic *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (!v2) {
    return *((void *)this + 32);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  uint64_t v3 = *((void *)this + 12);
  uint64_t v4 = *((void *)this + 32);
  if (v3) {
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  }
  return v4;
}

uint64_t NetConnection_Classic::createStreams(void *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(a1[31] + 24LL))(a1[1], a1[32], a2, a3);
}

uint64_t NetConnection_Classic::requestStateChanged(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 248) + 32LL))( a2,  a3,  a4,  a1,  *(void *)(a1 + 256));
}

uint64_t NetConnection_Classic::transmitRequest(NetConnection_Classic *this, void *a2)
{
  return (*(uint64_t (**)(void *, NetConnection_Classic *, void))(*((void *)this + 31) + 40LL))( a2,  this,  *((void *)this + 32));
}

uint64_t NetConnection_Classic::receiveResponse(NetConnection_Classic *this, void *a2)
{
  return (*(uint64_t (**)(void *, NetConnection_Classic *, void))(*((void *)this + 31) + 48LL))( a2,  this,  *((void *)this + 32));
}

uint64_t NetConnection_Classic::responseStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 248) + 56LL))( a2,  a3,  a4,  a1,  *(void *)(a1 + 256));
}

uint64_t NetConnection_Classic::requestStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 248) + 64LL))( a2,  a3,  a4,  a1,  *(void *)(a1 + 256));
}

uint64_t NetConnection_Classic::copySchedulingSetForRequest(NetConnection_Classic *this, void *a2)
{
  uint64_t v2 = (CoreSchedulingSet *)(*(uint64_t (**)(void *, NetConnection_Classic *, void))(*((void *)this + 31)
                                                                                               + 72LL))( a2,  this,  *((void *)this + 32));
  uint64_t v4 = CoreSchedulingSet::create(v2, v3);
  if (v2) {
    CFRelease(v2);
  }
  return v4;
}

uint64_t NetConnection_Classic::callTestFunc( NetConnection_Classic *this, unsigned __int8 (*a2)(void *, NetConnection *, const void *), void *a3)
{
  return ((uint64_t (*)(void *, NetConnection_Classic *, void))a2)(a3, this, *((void *)this + 32));
}

CFStringRef NetConnection_Classic::copyReqestDebugDesc(CFAllocatorRef *this, void *a2)
{
  return CFStringCreateWithFormat(this[1], 0LL, @"<request@%p>", a2);
}

void non-virtual thunk to'NetConnection_Classic::~NetConnection_Classic(NetConnection_Classic *this)
{
}

void non-virtual thunk to'NetConnection_Classic::~NetConnection_Classic(CFAllocatorRef *this)
{
  uint64_t v2 = this - 3;
  NetConnection_Classic::~NetConnection_Classic((NetConnection_Classic *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_182A904EC(_Unwind_Exception *a1)
{
}

void NetConnection_Classic::Cache::Key::~Key(NetConnection_Classic::Cache::Key *this)
{
}

{
  const void *v2;
  const void *v3;
  *(void *)this = off_189C08A80;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t NetConnection_Classic::Cache::Key::equals( NetConnection_Classic::Cache::Key *this, const CFAllocatedReferenceCountedObject *a2)
{
  uint64_t result = *((void *)this + 3);
  if (result)
  {
    uint64_t v5 = (const void *)*((void *)a2 + 3);
    if (!v5) {
      return 0LL;
    }
    uint64_t result = CFEqual((CFTypeRef)result, v5);
    if (!(_DWORD)result) {
      return result;
    }
    if (*((_DWORD *)this + 8) == *((_DWORD *)a2 + 8) && *((_DWORD *)this + 9) == *((_DWORD *)a2 + 9))
    {
      unint64_t v6 = (const void *)*((void *)this + 5);
      CFTypeID v7 = (const void *)*((void *)a2 + 5);
      if (v6 == v7)
      {
        return 1LL;
      }

      else
      {
        uint64_t result = 0LL;
        if (v6)
        {
          if (v7) {
            return CFEqual(*((CFTypeRef *)this + 5), v7) != 0;
          }
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

CFHashCode NetConnection_Classic::Cache::Key::hash(NetConnection_Classic::Cache::Key *this)
{
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFHashCode v3 = CFHash(v2);
  }
  else {
    CFHashCode v3 = 0LL;
  }
  int v4 = *((_DWORD *)this + 9);
  uint64_t v5 = *((int *)this + 8);
  CFHashCode v6 = *((void *)this + 5);
  if (v6) {
    CFHashCode v6 = CFHash((CFTypeRef)v6);
  }
  return v3 | v5 | v6 | (v4 << 14);
}

void NetConnection_Classic::Cache::~Cache(NetConnection_Classic::Cache *this)
{
  *(void *)this = off_189C08AC8;
  __int16 v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C08AC8;
  uint64_t v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

NetConnection *createNewConnection(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = MEMORY[0x186E12804](a1, 264LL, 0LL);
  *(_OWORD *)(v8 + 20) = 0u;
  *(_OWORD *)(v8 + 36) = 0u;
  *(_OWORD *)(v8 + 52) = 0u;
  *(_OWORD *)(v8 + 6_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v8 + 8os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(v8 + 100) = 0u;
  *(_OWORD *)(v8 + 1CFRelease((char *)this - 16) = 0u;
  *(_OWORD *)(v8 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
  *(_OWORD *)(v8 + 14_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v8 + 16os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(_OWORD *)(v8 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15 - 80) = 0u;
  *(_OWORD *)(v8 + 196) = 0u;
  *(_OWORD *)(v8 + 212) = 0u;
  *(_OWORD *)(v8 + 22_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v8 + 24os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0u;
  *(void *)uint64_t v8 = off_189C06BF8;
  *(void *)(v8 + _Block_object_dispose(va, 8) = a1;
  *(_DWORD *)(v8 + 260) = 0;
  *(_DWORD *)(v8 + CFRelease((char *)this - 16) = 1;
  if (((v8 + 16) & 3) != 0) {
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  }
  __int16 v9 = (NetConnection *)v8;
  *(void *)uint64_t v8 = off_189C08980;
  *(void *)(v8 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C08A60;
  *(void *)(v8 + 24_Block_object_dispose(va, 8) = a2;
  if (a2)
  {
    uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 8);
    if (v10) {
      a3 = v10(a1, a3);
    }
  }

  *((void *)v9 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = a3;
  if (!a3 || !NetConnection::initialize(v9, a4))
  {
    (*(void (**)(NetConnection *))(*(void *)v9 + 48LL))(v9);
    return 0LL;
  }

  return v9;
}

void setConnectionProperties(NetConnection_Classic *a1, CFTypeRef cf)
{
  if (cf)
  {
    v21[0] = CFRetain(cf);
    unint64_t Count = CFDictionaryGetCount((CFDictionaryRef)cf);
    v21[1] = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      __int16 v22 = 0LL;
      goto LABEL_8;
    }

    if (Count > 0x1E)
    {
      uint64_t v5 = (const void **)malloc(8 * Count);
      __int16 v22 = v5;
      if (!v5) {
        goto LABEL_8;
      }
    }

    else
    {
      uint64_t v5 = (const void **)v23;
      __int16 v22 = (const void **)v23;
    }

    CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v5, 0LL);
LABEL_8:
    CFTypeRef v24 = CFRetain(cf);
    unint64_t v6 = CFDictionaryGetCount((CFDictionaryRef)cf);
    uint64_t v7 = v6;
    unint64_t v25 = v6;
    if (v6 - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      uint64_t v26 = 0LL;
    }

    else
    {
      if (v6 > 0x1E)
      {
        uint64_t v8 = (const void **)malloc(8 * v6);
        uint64_t v26 = v8;
        if (!v8) {
          goto LABEL_15;
        }
      }

      else
      {
        uint64_t v8 = (const void **)v27;
        uint64_t v26 = (const void **)v27;
      }

      CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, 0LL, v8);
      uint64_t v7 = v25;
    }

    if (v7 < 1)
    {
LABEL_37:
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v24);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v21);
      return;
    }

void sub_182A90A9C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t HTTPNetConnection::errorOccurred(HTTPNetConnection *this, CFStreamError *a2)
{
  uint64_t v4 = *((void *)this + 12);
  if (v4) {
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  }
  uint64_t v5 = *((void *)this + 16);
  if (v5) {
    unint64_t v6 = *(HTTPNetStreamInfo **)(v5 + 8);
  }
  else {
    unint64_t v6 = 0LL;
  }
  uint64_t v7 = *((void *)this + 12);
  if (v7) {
    pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
  }
  if (v6) {
    HTTPNetStreamInfo::closeAndReleasePayload(v6);
  }
  return NetConnection::errorOccurred(this, a2);
}

uint64_t HTTPNetConnection::createStreams(HTTPNetConnection *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = (const __CFAllocator *)*((void *)a1 + 1);
  uint64_t v52 = 0LL;
  unint64_t v53 = 0LL;
  uint64_t v7 = (void *)(*(uint64_t (**)(void *))(**((void **)a1 + 34) + 72LL))(*((void **)a1 + 34));
  *((void *)a1 + 30) = v7;
  CFRetain(v7);
  uint64_t v8 = (void *)*((void *)a1 + 38);
  if (v8)
  {
    *((_BYTE *)v8 + 176) = 0;
    uint64_t v9 = (__CFReadStream *)v8[29];
    uint64_t v52 = (__CFWriteStream *)v8[30];
    unint64_t v53 = v9;
    v8[29] = 0LL;
    v8[30] = 0LL;
    if (!*((void *)a1 + 35))
    {
      uint64_t v27 = v8[25];
      uint64_t v26 = (std::__shared_weak_count *)v8[26];
      uint64_t v50 = v27;
      __int128 v51 = v26;
      if (v26)
      {
        p_uint64_t shared_owners = (unint64_t *)&v26->__shared_owners_;
        do
          unint64_t v29 = __ldxr(p_shared_owners);
        while (__stxr(v29 + 1, p_shared_owners));
      }

      (*(void (**)(HTTPNetConnection *, uint64_t *))(*(void *)a1 + 232LL))(a1, &v50);
      uint64_t v30 = v51;
      if (v51)
      {
        uint64_t v31 = (unint64_t *)&v51->__shared_owners_;
        do
          unint64_t v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
    }

    (*(void (**)(void *))(**((void **)a1 + 38) + 48LL))(*((void **)a1 + 38));
    *((void *)a1 + 3_Block_object_dispose(va, 8) = 0LL;
    uint64_t v10 = v52;
    uint64_t v11 = v53;
    if (!v53 || !v52) {
      goto LABEL_15;
    }
  }

  else
  {
    uint64_t v12 = (void *)*((void *)a1 + 34);
    uint64_t v13 = (const __CFString *)v12[4];
    uint64_t v14 = (const __CFAllocator *)*((unsigned int *)v12 + 14);
    uint64_t v15 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect( v6,  v13,  (const __CFAllocator *)(unsigned __int16)*((_DWORD *)v12 + 14));
    if (!v15)
    {
      uint64_t v15 = CFHostCreateWithName(v6, v13);
      if (!v15) {
        return 1LL;
      }
    }

    __CFStreamCreatePairWithSocketToCFHost(v6, v15, v14, &v53, &v52, 0);
    CFRelease(v15);
    uint64_t v10 = v52;
    uint64_t v11 = v53;
    if (!v53 || !v52)
    {
LABEL_15:
      if (v11)
      {
        CFRelease(v11);
        uint64_t v10 = v52;
      }

      if (v10) {
        CFRelease(v10);
      }
      return 1LL;
    }

    CFWriteStreamSetProperty(v52, (CFStreamPropertyKey)&unk_18C5AD168, (CFTypeRef)*MEMORY[0x189604DE8]);
  }

  int v16 = (*(unsigned int (**)(void *))(**((void **)a1 + 34) + 88LL))(*((void **)a1 + 34)) == 2
     || (*(uint64_t (**)(void *))(**((void **)a1 + 34) + 88LL))(*((void **)a1 + 34)) == 3;
  uint64_t v18 = __CoreWriteStreamCreateHTTPStreamWithConnInfo(v6, 0LL, v16, v52, a1);
  *a2 = v18;
  uint64_t v19 = *MEMORY[0x189604DE8];
  if (v18) {
    uint64_t v20 = v18 + 16;
  }
  else {
    uint64_t v20 = 0LL;
  }
  ++*(void *)(v20 + 80);
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v20 + 24) + 32LL))( *(void *)(v20 + 24),  0x18C5B03F0LL,  v19);
  --*(void *)(v20 + 80);
  if (v52) {
    CFRelease(v52);
  }
  HTTPStreamWithConnInfo = __CoreReadStreamCreateHTTPStreamWithConnInfo(v6, v53, 1, a1);
  *a3 = (uint64_t)HTTPStreamWithConnInfo;
  if (HTTPStreamWithConnInfo) {
    __int16 v22 = HTTPStreamWithConnInfo + 1;
  }
  else {
    __int16 v22 = 0LL;
  }
  ++*((void *)v22 + 10);
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)v22 + 3) + 32LL))( *((void *)v22 + 3),  0x18C5B03F0LL,  v19);
  --*((void *)v22 + 10);
  if (v53) {
    CFRelease(v53);
  }
  uint64_t result = (*(uint64_t (**)(void *))(**((void **)a1 + 34) + 64LL))(*((void **)a1 + 34));
  if (result)
  {
    uint64_t v23 = (const __CFDictionary *)result;
    v43[0] = CFRetain((CFTypeRef)result);
    unint64_t Count = CFDictionaryGetCount(v23);
    v43[1] = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      uint64_t v44 = 0LL;
      goto LABEL_50;
    }

    if (Count > 0x1E)
    {
      unint64_t v25 = (const void **)malloc(8 * Count);
      uint64_t v44 = v25;
      if (!v25) {
        goto LABEL_50;
      }
    }

    else
    {
      unint64_t v25 = (const void **)v45;
      uint64_t v44 = (const void **)v45;
    }

    CFDictionaryGetKeysAndValues(v23, v25, 0LL);
LABEL_50:
    CFTypeRef v46 = CFRetain(v23);
    unint64_t v33 = CFDictionaryGetCount(v23);
    uint64_t v34 = v33;
    unint64_t v47 = v33;
    if (v33 - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      unint64_t v48 = 0LL;
    }

    else
    {
      if (v33 > 0x1E)
      {
        int64_t v35 = (const void **)malloc(8 * v33);
        unint64_t v48 = v35;
        if (!v35) {
          goto LABEL_57;
        }
      }

      else
      {
        int64_t v35 = (const void **)v49;
        unint64_t v48 = (const void **)v49;
      }

      CFDictionaryGetKeysAndValues(v23, 0LL, v35);
      uint64_t v34 = v47;
    }

    if (v34 < 1)
    {
LABEL_69:
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v46);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)v43);
      return 0LL;
    }

void sub_182A910B0(_Unwind_Exception *a1)
{
}

void HTTPNetConnection::requestStateChanged(void *a1, HTTPNetStreamInfo *this, int a3, uint64_t a4)
{
  uint64_t v153 = *MEMORY[0x1895F89C0];
  *((_DWORD *)this + _Block_object_dispose(va, 8) = *((_DWORD *)this + 8) & 0xFFFE1FFF | ((a3 & 0xF) << 13);
  uint64_t v8 = (__CFRunLoopSource *)*((void *)this + 17);
  if (v8) {
    CFRunLoopSourceSignal(v8);
  }
  switch(a3)
  {
    case 1:
      if (*((_BYTE *)a1 + 250)) {
        return;
      }
      *((_BYTE *)a1 + 250) = 1;
      uint64_t v9 = (__CFHTTPMessage *)*((void *)this + 5);
      uint64_t v10 = a1[12];
      if (v10)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v10 + 8));
        uint64_t v11 = a1[12];
        uint64_t v12 = a1[18];
        if (v11) {
          pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
        }
      }

      else
      {
        uint64_t v12 = a1[18];
      }

      *(_WORD *)(v12 + 240) &= ~0x20u;
      uint64_t v104 = (*(uint64_t (**)(void *, __CFHTTPMessage *))(*a1 + 264LL))(a1, v9);
      if (!v104) {
        return;
      }
      uint64_t v105 = v104;
      CFMutableArrayRef v106 = (const __CFAllocator *)a1[1];
      uint64_t v107 = a1[12];
      if (v107)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v107 + 8));
        uint64_t v108 = a1[12];
        uint64_t v109 = a1[19];
        if (v108) {
          pthread_mutex_unlock((pthread_mutex_t *)(v108 + 8));
        }
      }

      else
      {
        uint64_t v109 = a1[19];
      }

      if (v109) {
        uint64_t v118 = v109 + 16;
      }
      else {
        uint64_t v118 = 0LL;
      }
      ++*(void *)(v118 + 80);
      int v119 = *(uint64_t (**(void, uint64_t))(**(void **)(v118 + 24) + 40LL))( *(void *)(v118 + 24),  0x18C5B2450LL);
      uint64_t v120 = v119;
      --*(void *)(v118 + 80);
      if (v119)
      {
        int Value = (const __CFDictionary *)CFDictionaryGetValue(v119, &unk_18C5B2418);
        unint64_t v122 = Value;
        if (Value)
        {
          uint64_t v123 = CFDictionaryGetValue(Value, &unk_18C5AF430);
          char v124 = 0;
          goto LABEL_222;
        }
      }

      else
      {
        unint64_t v122 = 0LL;
      }

      uint64_t v123 = 0LL;
      char v124 = 1;
LABEL_222:
      CFHTTPMessageRef Copy = CFHTTPMessageCreateCopy(v106, v9);
      CFIndex v148 = (void (**)(AutoString *__hidden))(*(uint64_t (**)(void *, CFHTTPMessageRef, uint64_t))(*a1 + 256LL))( a1,  Copy,  v105);
      uint64_t v149 = v126;
      if ((_DWORD)v126)
      {
        (*(void (**)(void *, void (***)(AutoString *__hidden)))(*a1 + 64LL))(a1, &v148);
        context.version = 0LL;
        CFRelease(Copy);
      }

      else
      {
        CFStringRef v127 = HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Copy + 16), 0x1382736Bu);
        context.version = (CFIndex)v127;
        CFRelease(Copy);
        if (v127 && (!v123 || !CFEqual(v123, v127)))
        {
          uint64_t v128 = a1[12];
          if (v128)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v128 + 8));
            uint64_t v129 = a1[12];
            uint64_t v130 = a1[18];
            if (v129) {
              pthread_mutex_unlock((pthread_mutex_t *)(v129 + 8));
            }
          }

          else
          {
            uint64_t v130 = a1[18];
          }

          if ((v124 & 1) != 0)
          {
            CFMutableDictionaryRef MutableCopy = CFDictionaryCreate( v106,  (const void **)&kCFHTTPHeaderProxyAuthorization,  (const void **)&context,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
            values = MutableCopy;
          }

          else
          {
            CFIndex Count = CFDictionaryGetCount(v122);
            CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v106, Count + 1, v122);
            values = MutableCopy;
            CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, &unk_18C5AF430, v127);
          }

          if (v120)
          {
            CFIndex v138 = CFDictionaryGetCount(v120);
            __int128 v139 = CFDictionaryCreateMutableCopy(v106, v138 + 1, v120);
            CFDictionarySetValue(v139, &unk_18C5B2418, MutableCopy);
          }

          else
          {
            __int128 v139 = CFDictionaryCreate( v106,  (const void **)&kCFStreamPropertyCONNECTAdditionalHeaders,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
            CFMutableDictionaryRef MutableCopy = values;
          }

          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
          uint64_t v141 = *(void *)(v118 + 80);
          __int128 v140 = (void *)(v118 + 80);
          *__int128 v140 = v141 + 1;
          (*(void (**)(void, uint64_t, __CFDictionary *))(*(void *)*(v140 - 7) + 32LL))( *(v140 - 7),  0x18C5B2450LL,  v139);
          --*v140;
          if (v130) {
            uint64_t v142 = v130 + 16;
          }
          else {
            uint64_t v142 = 0LL;
          }
          uint64_t v144 = *(void *)(v142 + 80);
          uint64_t v143 = (void *)(v142 + 80);
          *uint64_t v143 = v144 + 1;
          (*(void (**)(void, uint64_t, __CFDictionary *))(*(void *)*(v143 - 7) + 32LL))( *(v143 - 7),  0x18C5B2450LL,  v139);
          --*v143;
          if (v139) {
            CFRelease(v139);
          }
        }
      }

      if (v120) {
        CFRelease(v120);
      }
      if (context.version) {
        CFRelease((CFTypeRef)context.version);
      }
      return;
    case 2:
      uint64_t v19 = a1[12];
      if (!v19)
      {
        uint64_t v21 = a1[18];
LABEL_48:
        uint64_t v24 = a1[19];
        goto LABEL_49;
      }

      pthread_mutex_lock((pthread_mutex_t *)(v19 + 8));
      uint64_t v20 = a1[12];
      uint64_t v21 = a1[18];
      if (!v20) {
        goto LABEL_48;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
      uint64_t v22 = a1[12];
      if (!v22) {
        goto LABEL_48;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v22 + 8));
      uint64_t v23 = a1[12];
      uint64_t v24 = a1[19];
      if (v23) {
        pthread_mutex_unlock((pthread_mutex_t *)(v23 + 8));
      }
LABEL_49:
      int64_t v35 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_5280, 2);
      if (v35)
      {
        uint64_t v36 = v35;
        if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v35 + 16LL))( v35,  "HTTPNetConnection::prepareTransmission",  0LL))
        {
          int v37 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          (*(void (**)(void *, const char *, const __CFString *))(*(void *)v36 + 72LL))( v36,  "streamInfo",  @"%p");
          (*(void (**)(void *, const char *, const __CFString *))(*(void *)v36 + 72LL))( v36,  "requestStream",  @"%p");
          uint64_t v38 = (const void *)*((void *)this + 5);
          CFIndex v148 = off_189C1A178;
          CFStringRef v39 = CFStringCreateWithCString(v37, "request: ", 0x8000100u);
          __int128 v150 = 0LL;
          uint64_t v151 = 0LL;
          uint64_t v149 = (uint64_t)v39;
          if (v38)
          {
            CFStringRef v40 = CFCopyDescription(v38);
            uint64_t v41 = v149;
          }

          else
          {
            uint64_t v41 = (uint64_t)v39;
            CFStringRef v40 = @"null";
          }

          (*(void (**)(void *, uint64_t, CFStringRef))(*(void *)v36 + 64LL))(v36, v41, v40);
          if (v38 && v40) {
            CFRelease(v40);
          }
          AutoString::~AutoString((AutoString *)&v148);
          (*(void (**)(void *))(*(void *)v36 + 8LL))(v36);
        }
      }

      uint64_t v145 = v24;
      uint64_t v50 = NetConnection::willEnqueueRequests((NetConnection *)a1);
      __int128 v51 = &TrustExceptionManager::_isSharingdProcess(void)::onceToken;
      if ((*(unsigned int (**)(void))(*(void *)a1[34] + 88LL))(a1[34]) == 2)
      {
        *((_BYTE *)a1 + 267) = 0;
LABEL_76:
        int v53 = 1;
        goto LABEL_77;
      }

      int v52 = (*(uint64_t (**)(void))(*(void *)a1[34] + 88LL))(a1[34]);
      *((_BYTE *)a1 + 267) = 0;
      if (v52 == 3) {
        goto LABEL_76;
      }
      int v53 = 0;
      if ((*((_BYTE *)this + 33) & 4) != 0 && (_DWORD)v50)
      {
        uint64_t v63 = *((void *)this + 5);
        if (v63) {
          uint64_t v64 = (HTTPMessage *)(v63 + 16);
        }
        else {
          uint64_t v64 = 0LL;
        }
        uint64_t v65 = HTTPMessage::copyHeaderFieldValue(v64, 0x11B152B9u);
        unsigned int v66 = v65;
        if (v65)
        {
          if (CFStringCompare(v65, @"close", 1uLL) == kCFCompareEqualTo)
          {
            uint64_t v67 = a1[12];
            if (v67) {
              pthread_mutex_lock((pthread_mutex_t *)(v67 + 8));
            }
            *((_WORD *)a1 + 44) &= ~1u;
            NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease((uint64_t)a1);
            uint64_t v68 = a1[12];
            if (v68) {
              pthread_mutex_unlock((pthread_mutex_t *)(v68 + 8));
            }
            uint64_t v50 = 0LL;
          }

          CFRelease(v66);
        }

        int v53 = 0;
      }

LABEL_77:
      uint64_t v54 = *((void *)this + 5);
      if (v54) {
        uint64_t v55 = (HTTPMessage *)(v54 + 16);
      }
      else {
        uint64_t v55 = 0LL;
      }
      uint64_t v56 = HTTPMessage::copyHeaderFieldValue(v55, 0x1270D306u);
      unint64_t v57 = v56;
      if (v56)
      {
        if (CFStringFind(v56, (CFStringRef)&unk_18C5AFAF8, 1uLL).location == -1
          || (uint64_t v58 = (*(uint64_t (**)(void *, HTTPNetStreamInfo *))(*a1 + 160LL))(a1, this)) == 0)
        {
          int v62 = 0;
        }

        else
        {
          *((_BYTE *)a1 + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
          uint64_t v59 = a1[12];
          if (v59)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v59 + 8));
            uint64_t v60 = a1[12];
            uint64_t v61 = a1[18];
            if (v60) {
              pthread_mutex_unlock((pthread_mutex_t *)(v60 + 8));
            }
          }

          else
          {
            uint64_t v61 = a1[18];
          }

          if (v61)
          {
            uint64_t v69 = v50;
            int v70 = v53;
            context.version = 0LL;
            context.mach_timebase_info info = a1;
            memset(&context.retain, 0, 24);
            uint64_t v71 = *MEMORY[0x189604DE8];
            uint64_t v73 = *(void *)(v61 + 96);
            uint64_t v72 = (void *)(v61 + 96);
            void *v72 = v73 + 1;
            (*(void (**)(void, uint64_t, uint64_t))(*(void *)*(v72 - 7) + 32LL))( *(v72 - 7),  0x18C5B04D0LL,  v71);
            int v53 = v70;
            uint64_t v50 = v69;
            --*v72;
            uint64_t v74 = (const __CFAllocator *)a1[1];
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            CFRunLoopTimerRef v76 = CFRunLoopTimerCreate( v74,  Current + 5.0,  -1.0,  0LL,  0LL,  (CFRunLoopTimerCallBack)HTTPNetConnection::_OneHundredContinueTimeout,  &context);
            uint64_t v77 = (void (**)(AutoString *__hidden))MEMORY[0x1895F87A8];
            a1[32] = v76;
            CFIndex v148 = v77;
            uint64_t v149 = 3221225472LL;
            __int128 v150 = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
            uint64_t v151 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
            CFRunLoopTimerRef v152 = v76;
            CoreSchedulingSet::applyBlockWithPossibleEmulation(v58, (void (**)(void, void, void))&v148);
          }

          (*(void (**)(uint64_t))(*(void *)v58 + 48LL))(v58);
          uint64_t v78 = a1[12];
          if (v78)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v78 + 8));
            uint64_t v79 = a1[12];
            uint64_t v80 = a1[19];
            if (v79) {
              pthread_mutex_unlock((pthread_mutex_t *)(v79 + 8));
            }
          }

          else
          {
            uint64_t v80 = a1[19];
          }

          if (v80 != v145) {
            __assert_rtn("prepareTransmission", "HTTPNetConnection.cpp", 899, "getResponseStream() == responseStream");
          }
          if (v145)
          {
            uint64_t v81 = *MEMORY[0x189604DE8];
            ++*(void *)(v145 + 96);
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v145 + 40) + 32LL))( *(void *)(v145 + 40),  0x18C5B04D0LL,  v81);
            __int128 v51 = &TrustExceptionManager::_isSharingdProcess(void)::onceToken;
            --*(void *)(v145 + 96);
            int v62 = 1;
          }

          else
          {
            int v62 = 0;
            __int128 v51 = &TrustExceptionManager::_isSharingdProcess(void)::onceToken;
          }
        }

        CFRelease(v57);
      }

      else
      {
        int v62 = 0;
      }

      uint64_t v82 = *((void *)this + 5);
      if (v51[238] != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5084);
      }
      if (v82) {
        uint64_t v83 = (HTTPMessage *)(v82 + 16);
      }
      else {
        uint64_t v83 = 0LL;
      }
      CFStringRef v84 = HTTPMessage::copyHeaderFieldValue(v83, 0x1490F3F6u);
      if (v84)
      {
        CFRelease(v84);
        *((_BYTE *)a1 + 269) = 1;
        uint64_t v85 = *MEMORY[0x189604DE8];
        if (v21) {
          uint64_t v86 = v21 + 16;
        }
        else {
          uint64_t v86 = 0LL;
        }
        uint64_t v88 = *(void *)(v86 + 80);
        uint64_t v87 = (void *)(v86 + 80);
        void *v87 = v88 + 1;
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*(v87 - 7) + 32LL))( *(v87 - 7),  0x18C5B0460LL,  v85);
        --*v87;
        if (v145) {
          uint64_t v89 = v145 + 16;
        }
        else {
          uint64_t v89 = 0LL;
        }
        uint64_t v91 = *(void *)(v89 + 80);
        unint64_t v90 = (void *)(v89 + 80);
        *unint64_t v90 = v91 + 1;
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*(v90 - 7) + 32LL))( *(v90 - 7),  0x18C5B0460LL,  v85);
        --*v90;
      }

      if (*((void *)this + 7) && (a1[11] & 2) == 0)
      {
        if (v21) {
          uint64_t v92 = v21 + 16;
        }
        else {
          uint64_t v92 = 0LL;
        }
        uint64_t v94 = *(void *)(v92 + 80);
        uint64_t v93 = (void *)(v92 + 80);
        void *v93 = v94 + 1;
        uint64_t v95 = (const __CFBoolean *)(*(uint64_t (**)(void, uint64_t))(*(void *)*(v93 - 7) + 40LL))( *(v93 - 7),  0x18C5B0268LL);
        uint64_t v96 = v95;
        --*v93;
        if (v95)
        {
          if (CFBooleanGetValue(v95))
          {
            int v62 = 1;
            *((_BYTE *)a1 + 265) = 1;
          }

          CFRelease(v96);
        }
      }

      if (!v62) {
        goto LABEL_167;
      }
      uint64_t v97 = (*(uint64_t (**)(void *, HTTPNetStreamInfo *))(*a1 + 160LL))(a1, this);
      uint64_t v98 = a1[12];
      if (v98)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v98 + 8));
        uint64_t v99 = a1[12];
        uint64_t v100 = a1[19];
        if (v99) {
          pthread_mutex_unlock((pthread_mutex_t *)(v99 + 8));
        }
        if (v100) {
          goto LABEL_157;
        }
      }

      else
      {
        uint64_t v100 = a1[19];
        if (v100)
        {
LABEL_157:
          CFRetain((CFTypeRef)v100);
          unint64_t v101 = (const CoreSchedulingSet *)v97;
          if (!v97)
          {
            unint64_t v101 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
          }

          CoreStreamBase::_streamInterface_UpdateScheduling((CoreStreamBase *)(v100 + 16), v101);
          CFRelease((CFTypeRef)v100);
          HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, v100);
          goto LABEL_166;
        }
      }

      HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, 0LL);
LABEL_166:
      (*(void (**)(uint64_t))(*(void *)v97 + 48LL))(v97);
LABEL_167:
      if (*((void *)this + 7) && !*((_BYTE *)this + 64)) {
        cleanUpRequest(*((__CFHTTPMessage **)this + 5), *((void *)this + 9), v50, v53, 0LL);
      }
      else {
        cleanUpRequest(*((__CFHTTPMessage **)this + 5), 0LL, v50, v53, 0LL);
      }
      (*(void (**)(void *, HTTPNetStreamInfo *, uint64_t))(*a1 + 248LL))(a1, this, v50);
      uint64_t v102 = *((void *)this + 5);
      if (v21) {
        uint64_t v103 = v21 + 16;
      }
      else {
        uint64_t v103 = 0LL;
      }
      ++*(void *)(v103 + 80);
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v103 + 24) + 32LL))( *(void *)(v103 + 24),  0x18C5B03B8LL,  v102);
      --*(void *)(v103 + 80);
      if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v103))
      {
        v155.CFIndex domain = 0LL;
        *(void *)&v155.uint64_t error = 0LL;
        CoreStreamBase::_signalEvent((CoreStreamBase *)v103, 4LL, v155, 0);
      }

      return;
    case 3:
      uint64_t v13 = a1[12];
      if (v13)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
        uint64_t v14 = a1[12];
        uint64_t v15 = a1[18];
        if (v14) {
          pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
        }
      }

      else
      {
        uint64_t v15 = a1[18];
      }

      *((_BYTE *)a1 + 265) = 0;
      HTTPNetStreamInfo::closeRequestResources(this);
      if (v15)
      {
        uint64_t v31 = v15 + 16;
      }

      else
      {
        uint64_t v31 = 0LL;
      }

      __int16 v32 = *(_WORD *)(v31 + 224);
      if ((v32 & 0x400) != 0)
      {
        __int16 v33 = v32 | 1;
        *(_WORD *)(v31 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v32 | 1;
        if ((v32 & 0x80) != 0)
        {
          if (*(void *)(v31 + 216))
          {
            uint64_t v34 = *(__CFWriteStream **)(v31 + 208);
            if (v34)
            {
              CFWriteStreamWrite(v34, (const UInt8 *)"\r\n0\r\n\r\n", 7LL);
              *(void *)(v31 + 288) += 7LL;
              __int16 v33 = *(_WORD *)(v31 + 224);
            }
          }
        }
      }

      else
      {
        __int16 v33 = *(_WORD *)(v31 + 224);
      }

      *(_WORD *)(v31 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v33 | 4;
      if ((*(unsigned int (**)(uint64_t))(*(void *)v31 + 72LL))(v31))
      {
        v154.CFIndex domain = 0LL;
        *(void *)&v154.uint64_t error = 0LL;
        CoreStreamBase::_signalEvent((CoreStreamBase *)v31, 4LL, v154, 0);
      }

      return;
    case 4:
      if (!*((void *)this + 22))
      {
        uint64_t v42 = *((void *)this + 21);
        if (v42)
        {
          if (*(_DWORD *)(v42 + 40))
          {
            uint64_t v43 = *((void *)this + 15);
            if (!v43 || (*(unsigned int (**)(uint64_t))(*(void *)v43 + 256LL))(v43))
            {
              uint64_t v44 = CFHTTPMessageCopyRequestMethod(*((CFHTTPMessageRef *)this + 5));
              if (v44)
              {
                uint64_t v45 = v44;
                if (CFStringCompare(v44, @"GET", 1uLL) == kCFCompareEqualTo)
                {
                  context.version = 0LL;
                  context.mach_timebase_info info = this;
                  memset(&context.retain, 0, 24);
                  CFTypeRef v46 = CFGetAllocator(*((CFTypeRef *)this + 1));
                  CFAbsoluteTime v47 = CFAbsoluteTimeGetCurrent();
                  CFRunLoopTimerRef v48 = CFRunLoopTimerCreate( v46,  v47 + 3.0,  -1.0,  0LL,  0LL,  (CFRunLoopTimerCallBack)HTTPNetStreamInfo::_stallTimerFired,  &context);
                  *((void *)this + 22) = v48;
                  uint64_t v49 = *((void *)this + 21);
                  CFIndex v148 = (void (**)(AutoString *__hidden))MEMORY[0x1895F87A8];
                  uint64_t v149 = 3221225472LL;
                  __int128 v150 = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
                  uint64_t v151 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
                  CFRunLoopTimerRef v152 = v48;
                  CoreSchedulingSet::applyBlockWithPossibleEmulation( v49,  (void (**)(void, void, void))&v148);
                }

                CFRelease(v45);
              }
            }
          }
        }
      }

      uint64_t v25 = a1[12];
      if (v25)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v25 + 8));
        uint64_t v26 = a1[12];
        uint64_t v27 = a1[19];
        if (v26) {
          pthread_mutex_unlock((pthread_mutex_t *)(v26 + 8));
        }
      }

      else
      {
        uint64_t v27 = a1[19];
      }

      HTTPNetConnection::prepareReception((HTTPNetConnection *)a1, (uint64_t)this, v27);
      return;
    case 5:
      uint64_t v28 = a1[12];
      if (v28)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v28 + 8));
        uint64_t v29 = a1[12];
        uint64_t v30 = a1[19];
        if (v29) {
          pthread_mutex_unlock((pthread_mutex_t *)(v29 + 8));
        }
      }

      else
      {
        uint64_t v30 = a1[19];
      }

      if ((*((_BYTE *)this + 32) & 0xC) != 0) {
        goto LABEL_63;
      }
      if (!*((void *)this + 6)
        && (HTTPNetStreamInfo *)HTTPNetConnection::updateForHeaders((HTTPNetConnection *)a1, (uint64_t)this, v30) != this)
      {
        goto LABEL_208;
      }

      goto LABEL_207;
    case 7:
      HTTPNetStreamInfo::closeRequestResources(this);
      if ((*((_BYTE *)this + 32) & 4) != 0)
      {
LABEL_63:
        HTTPNetStreamInfo::dequeueFromConnection((NetConnection **)this);
      }

      else
      {
        if (*(void *)a4 == 4LL && *(_DWORD *)(a4 + 8) == -2096)
        {
          uint64_t v16 = a1[12];
          if (v16)
          {
            pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
            uint64_t v17 = a1[12];
            uint64_t v18 = a1[18];
            if (v17) {
              pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
            }
          }

          else
          {
            uint64_t v18 = a1[18];
          }

          if (v18) {
            uint64_t v110 = v18 + 16;
          }
          else {
            uint64_t v110 = 0LL;
          }
          ++*(void *)(v110 + 80);
          uint64_t v111 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v110 + 24) + 40LL))( *(void *)(v110 + 24),  0x18C5B24F8LL);
          --*(void *)(v110 + 80);
          if (v111)
          {
            unint64_t v112 = (const void *)v111;
            uint64_t v113 = (const void *)*((void *)this + 6);
            if (v113 == v112) {
              goto LABEL_200;
            }
            if (v113) {
              CFRelease(v113);
            }
            CFTypeRef v114 = CFRetain(v112);
            *((void *)this + 6) = v114;
            if (v114) {
LABEL_200:
            }
              CFReadStreamSignalEvent();
            CFRelease(v112);
          }

          _CFReadStreamSignalEventDelayed();
          if (*(void *)a4 == 4LL && *(_DWORD *)(a4 + 8) == -2096)
          {
            uint64_t v115 = a1[12];
            if (v115)
            {
              pthread_mutex_lock((pthread_mutex_t *)(v115 + 8));
              uint64_t v116 = a1[12];
              uint64_t v117 = a1[18];
              if (v116) {
                pthread_mutex_unlock((pthread_mutex_t *)(v116 + 8));
              }
            }

            else
            {
              uint64_t v117 = a1[18];
            }

            if (v117) {
              uint64_t v131 = v117 + 16;
            }
            else {
              uint64_t v131 = 0LL;
            }
            ++*(void *)(v131 + 80);
            uint64_t v132 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v131 + 24) + 40LL))( *(void *)(v131 + 24),  0x18C5B24F8LL);
            --*(void *)(v131 + 80);
            if (v132)
            {
              uint64_t v133 = (void *)v132;
              uint64_t v134 = (const void *)*((void *)this + 6);
              if (v134 == v133) {
                goto LABEL_247;
              }
              if (v134) {
                CFRelease(v134);
              }
              CFTypeRef v135 = CFRetain(v133);
              *((void *)this + 6) = v135;
              if (v135) {
LABEL_247:
              }
                CFReadStreamSignalEvent();
              HTTPNetConnection::updateAuth((HTTPNetConnection *)a1, (CFHTTPMessageRef *)this, (__CFHTTPMessage *)v133);
              CFRelease(v133);
            }
          }
        }

    if (DelimiterInBytes != v34)
    {
      uint64_t v50 = *(unsigned int *)(v7 + 192);
      __int128 v51 = v50 | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32);
      if ((v50 & 0x400) != 0)
      {
        HTTPProtocol::fixupAndSendMultiPartData( (HTTPProtocol *)v7,  v34,  DelimiterInBytes - v34,  (v50 >> 12) & 1);
        __int128 v51 = *(unsigned int *)(v7 + 192) | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32);
      }

      *(_WORD *)(v7 + 196) = WORD2(v51);
      *(_DWORD *)(v7 + 192) = v51 & 0xFFFFEFFF;
    }

    if (!v45) {
      break;
    }
    *(_DWORD *)(v7 + 192) |= 0x1400u;
    if (v67)
    {
      HTTPProtocol::fixupAndSendMultiPartData((HTTPProtocol *)v7, 0LL, 0LL, 1);
      uint64_t v56 = *(void **)(v7 + 832);
      if (v56)
      {
        id Property = (CFAbsoluteTime *)objc_getProperty(v56, v55, 96LL, 1);
        if (Property)
        {
          uint64_t v58 = Property;
          Property[25] = CFAbsoluteTimeGetCurrent();
          *((_OWORD *)v58 + 2) = *((_OWORD *)v58 + 8);
        }
      }

      URLProtocol::sendDidFinishLoading((URLProtocol *)v7);
      goto LABEL_91;
    }

    uint64_t v27 = v39 - v45;
    BytePtr = v45;
    uint64_t v34 = v45;
    if (i) {
      goto LABEL_52;
    }
    DelimiterInCFIndex Bytes = 0LL;
  }

  if (DelimiterInBytes == v39)
  {
    uint64_t v59 = *(const void **)(v7 + 256);
    *(void *)(v7 + 256) = 0LL;
    uint64_t v21 = v63;
    if (v59) {
      CFRelease(v59);
    }
  }

  else
  {
    if (DelimiterInBytes != BytePtr)
    {
      int v52 = CFGetAllocator(cf);
      CFMutableArrayRef Mutable = CFDataCreateMutable(v52, 0LL);
      CFDataAppendBytes(Mutable, DelimiterInBytes, v39 - DelimiterInBytes);
      uint64_t v54 = *(const void **)(v7 + 256);
      if (v54) {
        CFRelease(v54);
      }
      *(void *)(v7 + 256) = Mutable;
LABEL_91:
      uint64_t v21 = v63;
      goto LABEL_92;
    }

    uint64_t v21 = v63;
    if (!*(void *)(v7 + 256))
    {
      uint64_t v60 = CFGetAllocator(cf);
      uint64_t v61 = CFDataCreateMutable(v60, 0LL);
      *(void *)(v7 + 256) = v61;
      CFDataAppendBytes(v61, v34, v27);
    }
  }

LABEL_207:
        _CFReadStreamSignalEventDelayed();
      }

LABEL_208:
      if ((*((_BYTE *)this + 32) & 4) != 0) {
        (*(void (**)(HTTPNetStreamInfo *))(*(void *)this + 168LL))(this);
      }
      return;
    default:
      CFLog();
      return;
  }

void sub_182A924D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

uint64_t HTTPNetConnection::transmitRequest(uint64_t this, void *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *(void *)(this + 96);
  if (v4)
  {
    this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    uint64_t v5 = *(void *)(v3 + 96);
    uint64_t v6 = *(void *)(v3 + 144);
    if (v5) {
      this = pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
    }
  }

  else
  {
    uint64_t v6 = *(void *)(this + 144);
  }

  if ((a2[4] & 0x40) == 0)
  {
    this = HTTPNetConnection::transmitRequest(v3);
    int v7 = v18;
    if (v18)
    {
      *(_BYTE *)(v3 + 265) = 0;
      if (v17 == 4 && v7 == -2096)
      {
        if (v6) {
          uint64_t v8 = v6 + 16;
        }
        else {
          uint64_t v8 = 0LL;
        }
        ++*(void *)(v8 + 80);
        uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(v8 + 24) + 40LL))(*(void *)(v8 + 24));
        --*(void *)(v8 + 80);
        if (v9)
        {
          uint64_t v10 = (const void *)v9;
          uint64_t v11 = (const void *)a2[6];
          if (v11 == v10) {
            goto LABEL_19;
          }
          if (v11) {
            CFRelease(v11);
          }
          CFTypeRef v12 = CFRetain(v10);
          a2[6] = v12;
          if (v12) {
LABEL_19:
          }
            CFReadStreamSignalEvent();
          CFRelease(v10);
        }

        uint64_t v13 = *(void *)(v3 + 128);
        if (v13) {
          uint64_t v14 = *(void **)(v13 + 8);
        }
        else {
          uint64_t v14 = 0LL;
        }
        NetConnection::requestIsComplete((NetConnection *)v3, v14);
        return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 72LL))(v3);
      }

      else
      {
        return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 64LL))(v3, &v17);
      }
    }

    else if ((_DWORD)this)
    {
      *(_BYTE *)(v3 + 265) = 0;
      uint64_t v15 = *(void *)(v3 + 128);
      if (v15) {
        uint64_t v16 = *(void **)(v15 + 8);
      }
      else {
        uint64_t v16 = 0LL;
      }
      return NetConnection::requestIsComplete((NetConnection *)v3, v16);
    }
  }

  return this;
}

void HTTPNetConnection::receiveResponse(HTTPNetConnection *this, void *a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](this);
  uint64_t v4 = v3;
  uint64_t v5 = (HTTPNetConnection *)v2;
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(v2 + 96);
  if (v6)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 8));
    uint64_t v7 = *((void *)v5 + 12);
    uint64_t v8 = *((void *)v5 + 19);
    if (v7) {
      pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
    }
  }

  else
  {
    uint64_t v8 = *(void *)(v2 + 152);
  }

  if ((*(_BYTE *)(v4 + 32) & 0x10) == 0 && (*(_BYTE *)(v4 + 32) & 0x40) == 0 && v8)
  {
    if ((CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v8 + 16)) & 0xFFFFFFFFFFFFFFFDLL) == 5) {
      goto LABEL_49;
    }
    if (CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v8 + 16))
      || _CFHTTPReadStreamIsAtMark(v8))
    {
LABEL_49:
      if (*(void *)(v4 + 48)
        || (*(_BYTE *)(v4 + 32) & 4) != 0
        || (uint64_t v4 = HTTPNetConnection::updateForHeaders(v5, v4, v8), (*(_BYTE *)(v4 + 32) & 2) == 0))
      {
        if (!CoreStreamBase::_streamInterface_CanRead((CoreStreamBase *)(v8 + 16)))
        {
          if (!_CFHTTPReadStreamIsAtMark(v8) || (*(_BYTE *)(v4 + 32) & 4) != 0)
          {
            if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v8 + 16)) != 5)
            {
              if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)(v8 + 16)) == 7)
              {
                *(_OWORD *)uint64_t v11 = *(_OWORD *)(v8 + 72);
                (*(void (**)(HTTPNetConnection *, unsigned __int8 *))(*(void *)v5 + 64LL))(v5, v11);
              }

              return;
            }

            (*(void (**)(HTTPNetConnection *))(*(void *)v5 + 72LL))(v5);
          }

          HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)v4);
          return;
        }

        if ((*(_BYTE *)(v4 + 32) & 4) != 0)
        {
          do
          {
            uint64_t v9 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)(v8 + 16), v11, 0x8000LL);
            if (v9 < 0)
            {
              __int128 v10 = *(_OWORD *)(v8 + 72);
              (*(void (**)(HTTPNetConnection *, __int128 *))(*(void *)v5 + 64LL))(v5, &v10);
              return;
            }
          }

          while (v9);
        }

        else
        {
          _CFReadStreamSignalEventDelayed();
        }
      }
    }
  }

void HTTPNetConnection::responseStreamCallback(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1895F8858](a1);
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v8 = v1;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v9 = *(__CFRunLoopTimer **)(v6 + 176);
  if (v9)
  {
    CFRunLoopTimerInvalidate(v9);
    CFRelease(*(CFTypeRef *)(v7 + 176));
    *(void *)(v7 + 176) = 0LL;
  }

  if (*(void *)(v8 + 216)) {
    (*(void (**)(uint64_t))(v8 + 192))(v8);
  }
  if (HTTPNetConnection::handleReadEventsDuringRequestBodyTransmission( (HTTPNetConnection *)v8,  (void *)v7,  v3)) {
    return;
  }
  int v10 = *(_DWORD *)(v7 + 32);
  if ((v10 & 0x20) == 0) {
    HTTPNetConnection::prepareReception((HTTPNetConnection *)v8, v7, v5);
  }
  if (!*(void *)(v7 + 48) && v3 != 32 && (*(_DWORD *)(v7 + 32) & 4) == 0) {
    uint64_t v7 = HTTPNetConnection::updateForHeaders((HTTPNetConnection *)v8, v7, v5);
  }
  int v11 = *(_DWORD *)(v7 + 32);
  if ((v11 & 0x100) == 0)
  {
    *(_DWORD *)(v7 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v11 | 0x100;
    if (v5) {
      uint64_t v12 = v5 + 16;
    }
    else {
      uint64_t v12 = 0LL;
    }
    ++*(void *)(v12 + 80);
    (*(void (**)(void, uint64_t))(**(void **)(v12 + 24) + 32LL))(*(void *)(v12 + 24), 0x18C5AC598LL);
    --*(void *)(v12 + 80);
    int v11 = *(_DWORD *)(v7 + 32);
  }

  if ((v11 & 0x200) == 0)
  {
    *(_DWORD *)(v7 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v11 | 0x200;
    if (v5) {
      uint64_t v13 = v5 + 16;
    }
    else {
      uint64_t v13 = 0LL;
    }
    ++*(void *)(v13 + 80);
    (*(void (**)(void, uint64_t))(**(void **)(v13 + 24) + 32LL))(*(void *)(v13 + 24), 0x18C5AC218LL);
    --*(void *)(v13 + 80);
  }

  if (v3 <= 15)
  {
    if (v3 != 2)
    {
      if (v3 == 8)
      {
        uint64_t v14 = v5 + 16;
        if (!v5) {
          uint64_t v14 = 0LL;
        }
        *(_OWORD *)int v18 = *(_OWORD *)(v14 + 56);
        HTTPNetStreamInfo::grabReadStreamProperties(v7, v5);
        uint64_t v15 = *(void *)(v7 + 128);
        if (v15) {
          (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)v15 + 64LL))(v15, v18);
        }
      }

      return;
    }

    if ((v10 & 0x20) == 0) {
      return;
    }
    if ((*(_BYTE *)(v7 + 32) & 4) != 0)
    {
      if (v5) {
        uint64_t v17 = (CoreStreamBase *)(v5 + 16);
      }
      else {
        uint64_t v17 = 0LL;
      }
      while (1)
      {
        CoreStreamBase::_streamInterface_Read(v17, v18, 0x8000LL);
      }

      return;
    }

    goto LABEL_47;
  }

  if (v3 != 16)
  {
    if (v3 == 32 && (v10 & 0x20) != 0 && *(void *)(v7 + 128)) {
      HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)v7);
    }
    return;
  }

  uint64_t v16 = *(void *)(v7 + 128);
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 72LL))(v16);
  }
  if ((*(_BYTE *)(v7 + 32) & 4) == 0) {
LABEL_47:
  }
    _CFReadStreamSignalEventDelayed();
}

uint64_t HTTPNetConnection::requestStreamCallback(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 == 16)
  {
    __int128 v14 = xmmword_182C9D920;
    uint64_t result = *(void *)(a2 + 128);
    if (!result) {
      return result;
    }
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(void *)result + 64LL))(result, &v14);
  }

  if (a4 != 8)
  {
    if (a4 != 4) {
      return result;
    }
    uint64_t v6 = (NetConnection *)result;
    uint64_t result = HTTPNetConnection::transmitRequest(result);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t result = *(void *)(a2 + 128);
    if (!result) {
      return result;
    }
    if (!DWORD2(v14))
    {
      uint64_t v7 = *((void *)v6 + 16);
      if (v7) {
        uint64_t v8 = *(void **)(v7 + 8);
      }
      else {
        uint64_t v8 = 0LL;
      }
      return NetConnection::requestIsComplete(v6, v8);
    }

    return (*(uint64_t (**)(uint64_t, __int128 *))(*(void *)result + 64LL))(result, &v14);
  }

  uint64_t v9 = a3 + 16;
  if (!a3) {
    uint64_t v9 = 0LL;
  }
  __int128 v13 = *(_OWORD *)(v9 + 56);
  uint64_t v10 = *(void *)(a2 + 96);
  if (!v10)
  {
    CFAllocatorRef v11 = CFGetAllocator(*(CFTypeRef *)(a2 + 8));
    uint64_t v10 = MEMORY[0x186E12804](v11, 48LL, 0LL);
    *(_OWORD *)uint64_t v10 = 0u;
    *(_OWORD *)(v10 + CFRelease((char *)this - 16) = 0u;
    *(_OWORD *)(v10 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
    uint64_t v12 = CFGetAllocator(*(CFTypeRef *)(a2 + 8));
    *(void *)uint64_t v10 = off_189C09128;
    *(void *)(v10 + _Block_object_dispose(va, 8) = v12;
    *(void *)(v10 + CFRelease((char *)this - 16) = off_189C04A50;
    if (v12) {
      uint64_t v12 = CFRetain(v12);
    }
    *(void *)(v10 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0LL;
    *(void *)(v10 + 40) = 0LL;
    *(void *)(v10 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v12;
    *(void *)(a2 + 96) = v10;
  }

  *(void *)&__int128 v14 = MEMORY[0x1895F87A8];
  *((void *)&v14 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 3221225472LL;
  uint64_t v15 = ___ZN16CapturedSSLState14grabFromStreamEP17__CoreWriteStream_block_invoke;
  uint64_t v16 = &__block_descriptor_40_e22__v16__0____CFString__8l;
  uint64_t v17 = a3;
  CapturedSSLState::grabFromStream((void *)v10, (uint64_t)&v14);
  uint64_t result = *(void *)(a2 + 128);
  if (result) {
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(void *)result + 64LL))(result, &v13);
  }
  return result;
}

uint64_t HTTPNetConnection::copySchedulingSetForRequest(HTTPNetConnection *this, void *a2)
{
  if (a2 && (uint64_t v2 = a2[21]) != 0) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 88LL))(v2);
  }
  else {
    return 0LL;
  }
}

uint64_t HTTPNetConnection::callTestFunc( HTTPNetConnection *this, uint64_t (*a2)(void *, HTTPNetConnection *, HTTPNetConnection *), void *a3)
{
  return a2(a3, this, this);
}

void HTTPNetConnection::closeConnectionStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && *(_BYTE *)(a1 + 269))
  {
    if (a3) {
      uint64_t v7 = a3 + 16;
    }
    else {
      uint64_t v7 = 0LL;
    }
    ++*(void *)(v7 + 80);
    uint64_t v8 = (__CFReadStream *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v7 + 24) + 40LL))( *(void *)(v7 + 24),  0x18C5B0498LL);
    --*(void *)(v7 + 80);
    if (a4) {
      uint64_t v9 = a4 + 16;
    }
    else {
      uint64_t v9 = 0LL;
    }
    ++*(void *)(v9 + 80);
    a1 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v9 + 24) + 40LL))( *(void *)(v9 + 24),  0x18C5B0498LL);
    uint64_t v10 = (__CFWriteStream *)a1;
    --*(void *)(v9 + 80);
    if (v8) {
      BOOL v11 = a1 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      ++*(void *)(v7 + 80);
      (*(void (**)(void, uint64_t, void))(**(void **)(v7 + 24) + 32LL))( *(void *)(v7 + 24),  0x18C5B0498LL,  0LL);
      --*(void *)(v7 + 80);
      ++*(void *)(v9 + 80);
      (*(void (**)(void, uint64_t, void))(**(void **)(v9 + 24) + 32LL))( *(void *)(v9 + 24),  0x18C5B0498LL,  0LL);
      --*(void *)(v9 + 80);
      uint64_t v12 = *(void *)(a2 + 120);
      if (v12)
      {
        (*(void (**)(uint64_t, __CFReadStream *, __CFWriteStream *))(*(void *)v12 + 264LL))(v12, v8, v10);
      }

      else
      {
        CFReadStreamClose(v8);
        CFWriteStreamClose(v10);
      }

      CFRelease(v8);
LABEL_30:
      CFRelease(v10);
      goto LABEL_31;
    }

    if (v8) {
      CFRelease(v8);
    }
    if (v10) {
      goto LABEL_30;
    }
  }

uint64_t HTTPNetConnection::copyReqestDebugDesc(HTTPNetConnection *this, void *a2)
{
  return (*(uint64_t (**)(void *))(*(void *)a2 + 104LL))(a2);
}

uint64_t HTTPNetConnection::cleanAbortRequestTransmission(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 128);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 8);
    if (v2)
    {
      uint64_t v3 = this;
      *(_WORD *)(this + 88) &= ~0x20u;
      if (v1 == *(void *)(this + 136)) {
        *(void *)(this + 136) = 0LL;
      }
      *(_DWORD *)(v2 + 32) |= 8u;
      uint64_t v4 = *(CoreSchedulingSet **)(v2 + 168);
      if (v4) {
        CoreSchedulingSet::unscheduleStream(v4, *(__CFReadStream **)(v2 + 8));
      }
      CFReadStreamSetClient(*(CFReadStreamRef *)(v2 + 8), 0LL, 0LL, 0LL);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v3 + 120LL))(v3, v2, 5LL, 0LL);
    }
  }

  return this;
}

uint64_t HTTPNetConnection::sentBytes(uint64_t this, uint64_t a2)
{
  if (*(_BYTE *)(this + 268))
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 96);
    if (v4) {
      this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    }
    uint64_t v5 = *(void *)(v3 + 128);
    if (v5) {
      uint64_t v6 = *(void *)(v5 + 8);
    }
    else {
      uint64_t v6 = 0LL;
    }
    uint64_t v7 = *(void *)(v3 + 96);
    if (v7) {
      this = pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
    }
    if (v6) {
      *(void *)(v6 + 104) += a2;
    }
  }

  return this;
}

uint64_t HTTPNetConnection::receivedBytes(uint64_t this, uint64_t a2)
{
  if (*(_BYTE *)(this + 268))
  {
    uint64_t v3 = this;
    uint64_t v4 = *(void *)(this + 96);
    if (v4) {
      this = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
    }
    uint64_t v5 = *(void *)(v3 + 136);
    if (v5) {
      uint64_t v6 = *(void *)(v5 + 8);
    }
    else {
      uint64_t v6 = 0LL;
    }
    uint64_t v7 = *(void *)(v3 + 96);
    if (v7) {
      this = pthread_mutex_unlock((pthread_mutex_t *)(v7 + 8));
    }
    if (v6) {
      *(void *)(v6 + 112) += a2;
    }
  }

  return this;
}

void HTTPNetConnection::setProxy(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (a1[35] == v3) {
    return;
  }
  uint64_t v5 = a1 + 35;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100](a1 + 35, v3, a2[1]);
  if (!*v5) {
    return;
  }
  uint64_t v6 = a1[34];
  uint64_t v7 = (std::__shared_weak_count *)a1[36];
  uint64_t v17 = *v5;
  int v18 = v7;
  if (v7)
  {
    p_uint64_t shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v6 + 56LL))(v6, &v17);
  uint64_t v10 = v18;
  if (v18)
  {
    BOOL v11 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  uint64_t v13 = a1[12];
  if (!v13)
  {
    uint64_t v15 = a1[18];
    if (!v15) {
      return;
    }
    goto LABEL_17;
  }

  pthread_mutex_lock((pthread_mutex_t *)(v13 + 8));
  uint64_t v14 = a1[12];
  uint64_t v15 = a1[18];
  if (v14) {
    pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
  }
  if (v15)
  {
LABEL_17:
    int v16 = (*(uint64_t (**)(void))(*(void *)*v5 + 56LL))(*v5);
    if (v16 == 3)
    {
      HTTPWriteFilter::prepareHTTPSProxy((HTTPWriteFilter *)(v15 + 16));
    }

    else if (v16 == 2)
    {
      *(_WORD *)(v15 + 240) |= 0x200u;
    }
  }

void sub_182A9358C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HTTPNetConnection::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 288);
  *a2 = *(void *)(this + 280);
  a2[1] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return this;
}

uint64_t HTTPNetConnection::transmitRequest(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1895F8858](a1);
  uint64_t v60 = *MEMORY[0x1895F89C0];
  *(_DWORD *)(v4 + _Block_object_dispose(va, 8) = 0;
  if ((*(_BYTE *)(v2 + 32) & 1) != 0) {
    return 1LL;
  }
  uint64_t v5 = v4;
  uint64_t v6 = v3;
  uint64_t v7 = v2;
  uint64_t v8 = v1;
  unint64_t v9 = &unk_18C5B2000;
  uint64_t v10 = v6 ? v6 + 16 : 0LL;
  ++*(void *)(v10 + 80);
  BOOL v11 = (const void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v10 + 24) + 40LL))( *(void *)(v10 + 24),  0x18C5B0428LL);
  --*(void *)(v10 + 80);
  if (v11)
  {
    unint64_t v12 = v11;
    CFTypeID v13 = CFGetTypeID(v11);
    if (v13 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      LOWORD(clientContext.version) = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&clientContext,  2u);
    }

    uint64_t v14 = (const void *)*MEMORY[0x189604DE8];
    CFRelease(v12);
    if (v14 == v12) {
      return 1LL;
    }
  }

  uint64_t v15 = *(__CFReadStream **)(v7 + 56);
  if (!v15) {
    goto LABEL_16;
  }
  if (CFReadStreamGetStatus(v15) == kCFStreamStatusNotOpen)
  {
    if (CoreStreamBase::_streamInterface_CanWrite((CoreStreamBase *)v10))
    {
      uint64_t v26 = *(__CFReadStream **)(v7 + 56);
      if (!v26) {
        goto LABEL_16;
      }
      if (!*(_BYTE *)(v7 + 64))
      {
        clientContext.version = 0LL;
        clientContext.mach_timebase_info info = (void *)v7;
        memset(&clientContext.retain, 0, 24);
        CFReadStreamSetClient( v26,  0x1AuLL,  (CFReadStreamClientCallBack)HTTPNetStreamInfo::_httpRequestPayloadCallBack,  &clientContext);
        uint64_t v27 = *(CoreSchedulingSet **)(v7 + 168);
        if (v27) {
          CoreSchedulingSet::scheduleStream(v27, *(__CFReadStream **)(v7 + 56));
        }
        CFReadStreamOpen(*(CFReadStreamRef *)(v7 + 56));
      }
    }
  }

  if (*(void *)(v7 + 56) && !*(_BYTE *)(v7 + 64))
  {
    char v18 = 0;
    int v17 = 1;
    goto LABEL_18;
  }

LABEL_129:
  if ((*(_BYTE *)(v7 + 33) & 8) != 0) {
    return 1LL;
  }
  if (v22) {
    char v56 = 1;
  }
  else {
    char v56 = v24;
  }
  uint64_t result = 1LL;
  if ((v56 & 1) == 0 && ResponseStatusCode != 407)
  {
    HTTPNetStreamInfo::closeRequestResources((HTTPNetStreamInfo *)v7);
    *(_DWORD *)(v7 + 32) |= 1u;
    return 1LL;
  }

  return result;
}

uint64_t HTTPNetConnection::isStreamReadyForWrite( HTTPNetConnection *a1, uint64_t a2, CFHTTPMessageRef *a3, void *a4)
{
  if (a2) {
    uint64_t v8 = a2 + 16;
  }
  else {
    uint64_t v8 = 0LL;
  }
  if (CoreStreamBase::_streamInterface_GetStatus((CoreStreamBase *)v8) != 7) {
    return 0LL;
  }
  uint64_t v11 = *(void *)(v8 + 56);
  uint64_t v10 = *(void *)(v8 + 64);
  *a4 = v11;
  a4[1] = v10;
  uint64_t result = 1LL;
  if (v11 == 4 && (v10 + 2097) <= 1)
  {
    ++*(void *)(v8 + 80);
    unint64_t v12 = (__CFHTTPMessage *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v8 + 24) + 40LL))( *(void *)(v8 + 24),  0x18C5B24F8LL);
    --*(void *)(v8 + 80);
    HTTPNetConnection::updateAuth(a1, a3, v12);
    if (v12) {
      CFRelease(v12);
    }
    uint64_t v13 = *((void *)a1 + 16);
    if (v13) {
      uint64_t v14 = *(void **)(v13 + 8);
    }
    else {
      uint64_t v14 = 0LL;
    }
    NetConnection::requestIsComplete(a1, v14);
    (*(void (**)(HTTPNetConnection *))(*(void *)a1 + 72LL))(a1);
    return 1LL;
  }

  return result;
}

uint64_t HTTPNetConnection::updateAuth(HTTPNetConnection *this, CFHTTPMessageRef *a2, __CFHTTPMessage *a3)
{
  CFURLRef v6 = CFHTTPMessageCopyRequestURL(a2[5]);
  _CFHTTPMessageSetResponseURL((uint64_t)a3, v6);
  if (CFHTTPMessageGetResponseStatusCode(a3) == 407)
  {
    uint64_t v7 = *((void *)this + 35);
    if (v7)
    {
      (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v7 + 48LL))(&cf);
      uint64_t v8 = cf;
      if (!cf) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }

    uint64_t v11 = (const __CFAllocator *)*((void *)this + 1);
    int v12 = (*(uint64_t (**)(void))(**((void **)this + 34) + 88LL))(*((void *)this + 34));
    uint64_t v13 = **((void **)this + 34);
    if (v12 == 2)
    {
      uint64_t v14 = (*(uint64_t (**)(void))(v13 + 72))();
      uint64_t v15 = (*(uint64_t (**)(void))(**((void **)this + 34) + 80LL))(*((void *)this + 34));
      int v16 = CFStringCreateWithFormat(v11, 0LL, @"http://%@:%d", v14, v15);
      if (!v16) {
        goto LABEL_5;
      }
    }

    else
    {
      int v17 = *(uint64_t (**(void))(**((void **)this + 34) + 64LL))(*((void *)this + 34));
      int Value = (const __CFDictionary *)CFDictionaryGetValue(v17, &unk_18C5B2450);
      uint64_t v19 = Value;
      if (!Value) {
        goto LABEL_5;
      }
      uint64_t v20 = CFDictionaryGetValue(Value, &unk_18C5B2488);
      uint64_t v21 = CFDictionaryGetValue(v19, &unk_18C5B24C0);
      if (!v20) {
        goto LABEL_5;
      }
      if (!v21) {
        goto LABEL_5;
      }
      int v16 = CFStringCreateWithFormat(v11, 0LL, @"https://%@:%@", v20, v21);
      if (!v16) {
        goto LABEL_5;
      }
    }

    uint64_t v8 = CFURLCreateWithString(v11, v16, 0LL);
    CFRelease(v16);
    if (v8)
    {
LABEL_4:
      _CFHTTPMessageSetResponseProxyURL((uint64_t)a3, v8);
      CFRelease(v8);
    }
  }

void sub_182A941D4(_Unwind_Exception *a1)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

CFTypeRef HTTPNetStreamInfo::setRequestFragment(HTTPNetStreamInfo *this, CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)*((void *)this + 10);
  if (result != cf)
  {
    if (result) {
      CFRelease(result);
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0LL;
    }
    *((void *)this + ++*((void *)this + 10) = result;
  }

  return result;
}

uint64_t HTTPNetConnection::handleReadEventsDuringRequestBodyTransmission( HTTPNetConnection *this, void *a2, uint64_t a3)
{
  if (!*((_BYTE *)this + 264))
  {
    unsigned int v6 = *((unsigned __int8 *)this + 265);
    if (!*((_BYTE *)this + 265)) {
      goto LABEL_66;
    }
  }

  if (a3 != 2 && a3 != 16)
  {
    if (a3 == 64)
    {
      *((_BYTE *)this + 26os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
      uint64_t v7 = (__CFRunLoopTimer *)*((void *)this + 32);
      if (v7)
      {
        CFRunLoopTimerInvalidate(v7);
        uint64_t v8 = (const void *)*((void *)this + 32);
        *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0LL;
        if (v8) {
          CFRelease(v8);
        }
      }

      uint64_t v9 = *((void *)this + 12);
      if (v9)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
        uint64_t v10 = *((void *)this + 12);
        uint64_t v11 = *((void *)this + 18);
        if (v10) {
          pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
        }
        if (!v11) {
          goto LABEL_52;
        }
        goto LABEL_49;
      }

      uint64_t v11 = *((void *)this + 18);
      if (v11)
      {
LABEL_49:
        ++*(void *)(v11 + 96);
        (*(void (**)(void, uint64_t, void))(**(void **)(v11 + 40) + 32LL))( *(void *)(v11 + 40),  0x18C5B04D0LL,  0LL);
        --*(void *)(v11 + 96);
        (*(void (**)(HTTPNetConnection *, void *))(*(void *)this + 128LL))(this, a2);
      }
    }

void HTTPNetConnection::prepareReception(HTTPNetConnection *a1, uint64_t a2, uint64_t a3)
{
  if (*((_BYTE *)a1 + 266))
  {
    *((_BYTE *)a1 + 266) = 0;
    if (a3) {
      unsigned int v6 = (CoreStreamBase *)(a3 + 16);
    }
    else {
      unsigned int v6 = 0LL;
    }
    v28.CFIndex domain = 0LL;
    *(void *)&v28.uint64_t error = 0LL;
    CoreStreamBase::_signalEvent(v6, 2LL, v28, 0);
  }

  int v7 = *(_DWORD *)(a2 + 32);
  if ((v7 & 0x20) != 0) {
    return;
  }
  *(_DWORD *)(a2 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v7 | 0x20;
  if (a3)
  {
    uint64_t v8 = a3 + 16;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  HIDWORD(v27) = 0;
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 136));
  if ((~*(unsigned __int16 *)(v8 + 232) & 0x201) == 0)
  {
    uint64_t v9 = CFGetAllocator(*(CFTypeRef *)(v8 + 224));
    Boolean IsRequest = CFHTTPMessageIsRequest(*(CFHTTPMessageRef *)(v8 + 224));
    CFHTTPMessageRef Empty = CFHTTPMessageCreateEmpty(v9, IsRequest);
    uint64_t v12 = *(const void **)(v8 + 224);
    if (v12) {
      CFRelease(v12);
    }
    int v13 = *(unsigned __int16 *)(v8 + 232);
    *(void *)(v8 + 22os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = Empty;
    *(_OWORD *)(v8 + 240) = xmmword_182C9D750;
    int v14 = v13 | (*(unsigned __int8 *)(v8 + 234) << 16);
    *(_WORD *)(v8 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v14 & 0x12DA;
    *(_BYTE *)(v8 + 23os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = (v14 & 0xFFFD12DA) >> 16;
    if ((v14 & 0x40) != 0)
    {
      uint64_t v15 = *(const void **)(v8 + 208);
      if (v15)
      {
        int v16 = v14 & 0xFD129A;
        *(_WORD *)(v8 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v16;
        *(_BYTE *)(v8 + 23os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = BYTE2(v16);
        CFRetain(v15);
        CFReadStreamSetProperty( *(CFReadStreamRef *)(v8 + 208),  (CFStreamPropertyKey)&unk_18C5AC598,  (CFTypeRef)*MEMORY[0x189604DE0]);
        int v17 = *(const void **)(v8 + 208);
        if (v17) {
          CFRelease(v17);
        }
      }
    }
  }

  BOOL v18 = *(const void **)(v8 + 208);
  if (v18 && !*(_BYTE *)(v8 + 216))
  {
    CFTypeRef cf = CFRetain(v18);
    if (HTTPReadFilter::canReadNoSignal(v8))
    {
      v24.CFIndex domain = 0LL;
      *(void *)&v24.uint64_t error = 0LL;
      uint64_t v25 = 2LL;
    }

    else
    {
      if (CFReadStreamGetStatus(*(CFReadStreamRef *)(v8 + 208)) != kCFStreamStatusAtEnd
        || *(void *)(v8 + 248) == *(void *)(v8 + 240) && (*(_WORD *)(v8 + 232) & 0x20) == 0)
      {
        goto LABEL_61;
      }

      LODWORD(v27) = -4;
      v24.CFIndex domain = 4LL;
      if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
      {
        dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16679);
        v24.CFIndex domain = 4LL;
      }

      *(void *)&v24.uint64_t error = v27;
      uint64_t v25 = 8LL;
    }

    CoreStreamBase::_signalEvent((CoreStreamBase *)v8, v25, v24, 0);
LABEL_61:
    *(void *)(v8 + 40) &= ~0x20uLL;
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_26;
  }

  LODWORD(v27) = -4;
  *(_WORD *)(v8 + 232) |= 0x4000u;
  *(void *)&v29.uint64_t error = v27;
  v29.CFIndex domain = 4LL;
  CoreStreamBase::_signalEvent((CoreStreamBase *)v8, 8LL, v29, 0);
LABEL_26:
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 136));
  CFStringRef v19 = CFHTTPMessageCopyRequestMethod(*(CFHTTPMessageRef *)(a2 + 40));
  if (v19)
  {
    CFStringRef v20 = v19;
    if (CFEqual(v19, &unk_18C5B0188))
    {
      if (a3) {
        uint64_t v21 = a3 + 16;
      }
      else {
        uint64_t v21 = 0LL;
      }
      ++*(void *)(v21 + 80);
      (*(void (**)(void, uint64_t))(**(void **)(v21 + 24) + 32LL))(*(void *)(v21 + 24), 0x18C5B0540LL);
      --*(void *)(v21 + 80);
    }

    CFRelease(v20);
  }

  if (a3) {
    uint64_t v22 = (CoreStreamBase *)(a3 + 16);
  }
  else {
    uint64_t v22 = 0LL;
  }
  if (CoreStreamBase::_streamInterface_CanRead(v22))
  {
    if (!*(void *)(a2 + 48)) {
      HTTPNetConnection::updateForHeaders(a1, a2, a3);
    }
    uint64_t v23 = 2LL;
  }

  else
  {
    if (!_CFHTTPReadStreamIsAtMark(a3)) {
      return;
    }
    uint64_t v23 = 32LL;
  }

  v30.CFIndex domain = 0LL;
  *(void *)&v30.uint64_t error = 0LL;
  CoreStreamBase::_signalEvent(v22, v23, v30, 0);
}

void sub_182A94B64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPNetConnection::updateForHeaders(HTTPNetConnection *a1, uint64_t updated, uint64_t a3)
{
  if (a3)
  {
    ++*(void *)(a3 + 96);
    unsigned int v6 = (__CFHTTPMessage *)(*(uint64_t (**)(void, __CFString *))(**(void **)(a3 + 40) + 40LL))( *(void *)(a3 + 40),  @"kCFStreamPropertyHTTPResponseHeader");
    int v7 = v6;
    --*(void *)(a3 + 96);
    if (v6)
    {
      DNSServiceErrorType updated = HTTPNetConnection::updateAuth(a1, (CFHTTPMessageRef *)updated, v7);
    }

    else
    {
      (*(void (**)(HTTPNetConnection *))(*(void *)a1 + 72LL))(a1);
    }

    uint64_t v8 = *(__CFHTTPMessage **)(updated + 48);
    CFTypeRef v9 = v7;
    if (v8 != v7)
    {
      if (v8) {
        CFRelease(*(CFTypeRef *)(updated + 48));
      }
      if (v7) {
        CFTypeRef v9 = CFRetain(v7);
      }
      else {
        CFTypeRef v9 = 0LL;
      }
      *(void *)(updated + 4_Block_object_dispose(va, 8) = v9;
    }

    if (v9) {
      CFReadStreamSignalEvent();
    }
    if (v7) {
      CFRelease(v7);
    }
    uint64_t v10 = *(void *)(updated + 48);
    if (v10)
    {
      uint64_t v11 = *(void *)(updated + 40);
      if (v11)
      {
        int v12 = *(unsigned __int8 *)(v10 + 40);
        if (*(_BYTE *)(v10 + 40)) {
          uint64_t v13 = v10 + 16;
        }
        else {
          uint64_t v13 = 0LL;
        }
        if (*(_BYTE *)(v11 + 40)) {
          uint64_t v14 = 0LL;
        }
        else {
          uint64_t v14 = v11 + 16;
        }
        if (v12 && !*(_BYTE *)(v11 + 40) && !*(void *)(v13 + 88) && *(int *)(v13 + 56) >= 2)
        {
          int v15 = *(_DWORD *)(v13 + 128);
          CFStringRef v16 = HTTPMessage::copyHeaderFieldValue((HTTPMessage *)v13, 0x11F1D2DBu);
          CFStringRef v17 = v16;
          if (v16) {
            CFRelease(v16);
          }
          if (v17) {
            BOOL v18 = 0;
          }
          else {
            BOOL v18 = v15 == 204;
          }
          char v19 = v18;
          if (v15 == 304
            || (v15 - 100) < 0x64
            || (v19 & 1) != 0
            || ((CFStringRef v20 = *(const __CFString **)(v14 + 152)) != 0LL
             || os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT)
             && (*(_WORD *)__int128 buf = 0,
                 _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "these should always be initialized now",  buf,  2u),  (CFStringRef v20 = *(const __CFString **)(v14 + 152)) != 0LL))
            && CFStringCompare(v20, (CFStringRef)&gConstantCFStringValueTable[2611], 0LL) == kCFCompareEqualTo)
          {
            *(_DWORD *)(updated + 32) |= 2u;
            HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)updated);
          }
        }
      }
    }
  }

  else
  {
    CFLog();
  }

  return updated;
}

uint64_t HTTPNetConnection::_OneHundredContinueTimeout( HTTPNetConnection *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v4 = *((void *)a2 + 12);
  if (!v4)
  {
    uint64_t v7 = *((void *)a2 + 18);
LABEL_7:
    uint64_t v10 = *((void *)a2 + 19);
    goto LABEL_8;
  }

  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(v4 + 8));
  uint64_t v6 = *((void *)a2 + 12);
  uint64_t v7 = *((void *)a2 + 18);
  if (!v6) {
    goto LABEL_7;
  }
  uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  uint64_t v8 = *((void *)a2 + 12);
  if (!v8) {
    goto LABEL_7;
  }
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(v8 + 8));
  uint64_t v9 = *((void *)a2 + 12);
  uint64_t v10 = *((void *)a2 + 19);
  if (v9) {
    uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(v9 + 8));
  }
LABEL_8:
  if (v10)
  {
    ++*(void *)(v10 + 96);
    uint64_t result = (*(uint64_t (**)(void, uint64_t, void))(**(void **)(v10 + 40) + 32LL))( *(void *)(v10 + 40),  0x18C5B04D0LL,  0LL);
    --*(void *)(v10 + 96);
  }

  if (v7)
  {
    ++*(void *)(v7 + 96);
    (*(void (**)(void, uint64_t, void))(**(void **)(v7 + 40) + 32LL))( *(void *)(v7 + 40),  0x18C5B04D0LL,  0LL);
    --*(void *)(v7 + 96);
    uint64_t v11 = *((void *)a2 + 12);
    if (v11) {
      pthread_mutex_lock((pthread_mutex_t *)(v11 + 8));
    }
    uint64_t v12 = *((void *)a2 + 16);
    if (v12) {
      uint64_t v13 = *(void *)(v12 + 8);
    }
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t v14 = *((void *)a2 + 12);
    if (v14) {
      pthread_mutex_unlock((pthread_mutex_t *)(v14 + 8));
    }
    return (*(uint64_t (**)(__CFRunLoopTimer *, uint64_t))(*(void *)a2 + 128LL))(a2, v13);
  }

  return result;
}

uint64_t ___ZN17HTTPNetConnection19prepareTransmissionEP17HTTPNetStreamInfoP17__CoreWriteStreamP16__CoreReadStream_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 856LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void HTTPNetConnection::HTTPNetConnection( HTTPNetConnection *this, const __CFAllocator *a2, HTTPConnectionCacheKey *a3)
{
  *(void *)this = off_189C06BF8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = a2;
  *((_DWORD *)this + os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
  *(void *)this = off_189C08AE8;
  *((void *)this + 3) = &unk_189C08C20;
  uint64_t v4 = (char *)this + 280;
  *((void *)this + 35) = 0LL;
  *((void *)this + 36) = 0LL;
  *((void *)this + 3os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = a3;
  (*(void (**)(HTTPConnectionCacheKey *))(*(void *)a3 + 40LL))(a3);
  *((void *)this + 3_Block_object_dispose(va, 8) = 0LL;
  *((_DWORD *)this + 62) = 0;
  *((_WORD *)this + 13os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
  __int128 v8 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v4, &v8);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)&v8 + 1);
  if (*((void *)&v8 + 1))
  {
    uint64_t v6 = (unint64_t *)(*((void *)&v8 + 1) + 8LL);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

void sub_182A95110(_Unwind_Exception *a1)
{
}

void HTTPNetConnection::~HTTPNetConnection(HTTPNetConnection *this)
{
  *(void *)this = off_189C08AE8;
  *((void *)this + 3) = &unk_189C08C20;
  uint64_t v2 = *((void *)this + 34);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
  }
  uint64_t v3 = (__CFRunLoopTimer *)*((void *)this + 32);
  if (v3)
  {
    CFRunLoopTimerInvalidate(v3);
    uint64_t v4 = (const void *)*((void *)this + 32);
    if (v4) {
      CFRelease(v4);
    }
  }

  if (*((void *)this + 38)) {
    __assert_rtn("~HTTPNetConnection", "HTTPNetConnection.cpp", 47, "!fTube");
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 280);
  NetConnection::~NetConnection(this);
}

void sub_182A951C0(_Unwind_Exception *a1)
{
}

void HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(HTTPNetConnection_NoAuth *this)
{
}

{
  const void *v2;
  *(void *)this = off_189C08C60;
  *((void *)this + 3) = &unk_189C08D98;
  CFSetApplyFunction(*((CFSetRef *)this + 39), (CFSetApplierFunction)_authDisassociate, this);
  uint64_t v2 = (const void *)*((void *)this + 39);
  if (v2) {
    CFRelease(v2);
  }
  HTTPNetConnection::~HTTPNetConnection(this);
}

uint64_t HTTPNetConnection_NoAuth::isConnectionWithAuth(HTTPNetConnection_NoAuth *this)
{
  return 0LL;
}

void HTTPNetConnection_NoAuth::applyAnyCredentials(CFMutableSetRef *this, HTTPNetStreamInfo *a2, int a3)
{
  v15[2] = *MEMORY[0x1895F89C0];
  uint64_t v6 = *((void *)a2 + 5);
  uint64_t v7 = 0LL;
  uint64_t v8 = v6 + 16;
  if (!v6) {
    uint64_t v8 = 0LL;
  }
  v15[0] = *(void *)(v8 + 72);
  uint64_t v9 = *((void *)a2 + 5);
  if (v9) {
    uint64_t v10 = v9 + 16;
  }
  else {
    uint64_t v10 = 0LL;
  }
  v15[1] = *(void *)(v10 + 80);
  char v11 = 1;
  do
  {
    char v12 = v11;
    uint64_t v13 = (const void *)v15[v7];
    if (v13)
    {
      if (a3)
      {
        _CFHTTPAuthenticationApplyHeaderToRequest((_CFHTTPAuthentication *)v15[v7], *((__CFHTTPMessage **)a2 + 5), this);
        if (!v14) {
          CFSetSetValue(this[39], v13);
        }
      }

      else
      {
        _CFHTTPAuthenticationDisassociateConnection(v15[v7], this);
        CFSetRemoveValue(this[39], v13);
      }
    }

    char v11 = 0;
    uint64_t v7 = 1LL;
  }

  while ((v12 & 1) != 0);
}

CFDictionaryRef HTTPNetConnection_NoAuth::applyCredentialsDictionary( HTTPNetConnection_NoAuth *this, __CFHTTPMessage *a2, _CFHTTPAuthentication *a3)
{
  return _CFHTTPAuthenticationApplyHeaderToRequest(a3, a2, this);
}

uint64_t HTTPNetConnection_NoAuth::getProxyAuth(HTTPNetConnection_NoAuth *this, __CFHTTPMessage *a2)
{
  uint64_t v3 = (char *)a2 + 16;
  if (!a2) {
    uint64_t v3 = 0LL;
  }
  return *((void *)v3 + 10);
}

HTTPNetStreamInfo *HTTPNetConnection_NoAuth::updateAuthForReal( CFMutableSetRef *this, HTTPNetStreamInfo *a2, __CFHTTPMessage *a3)
{
  int v6 = NetConnection::willEnqueueRequests((NetConnection *)this);
  uint64_t v7 = *((void *)a2 + 5);
  uint64_t v8 = v7 + 16;
  if (!v7) {
    uint64_t v8 = 0LL;
  }
  uint64_t v9 = *(const void **)(v8 + 72);
  if (v9)
  {
    if (!v6)
    {
      _CFHTTPAuthenticationDisassociateConnection(*(void *)(v8 + 72), this);
      CFSetRemoveValue(this[39], v9);
    }

    _CFHTTPAuthenticationUpdateFromResponse((uint64_t)v9, a3, this);
    uint64_t v10 = *((void *)a2 + 5);
  }

  else
  {
    uint64_t v10 = *((void *)a2 + 5);
  }

  uint64_t v11 = v10 + 16;
  if (!v10) {
    uint64_t v11 = 0LL;
  }
  char v12 = *(const void **)(v11 + 80);
  if (v12)
  {
    if (!v6)
    {
      _CFHTTPAuthenticationDisassociateConnection(*(void *)(v11 + 80), this);
      CFSetRemoveValue(this[39], v12);
    }

    _CFHTTPAuthenticationUpdateFromResponse((uint64_t)v12, a3, this);
  }

  return a2;
}

void non-virtual thunk to'HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth( HTTPNetConnection_NoAuth *this)
{
}

void non-virtual thunk to'HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth(CFAllocatorRef *this)
{
  uint64_t v2 = this - 3;
  HTTPNetConnection_NoAuth::~HTTPNetConnection_NoAuth((HTTPNetConnection_NoAuth *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_182A95544(_Unwind_Exception *a1)
{
}

void HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth( HTTPNetConnection_NoAuth *this, const __CFAllocator *a2, HTTPConnectionCacheKey *a3)
{
  *(void *)uint64_t v4 = off_189C08C60;
  *(void *)(v4 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = &unk_189C08D98;
  *((void *)this + 39) = CFSetCreateMutable(*(CFAllocatorRef *)(v4 + 8), 0LL, MEMORY[0x189605258]);
}

void sub_182A955AC(_Unwind_Exception *a1)
{
}

void HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(HTTPNetConnection_WithAuth *this)
{
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  *(void *)this = off_189C08DB8;
  *((void *)this + 3) = &unk_189C08EF0;
  uint64_t v2 = *((void *)this + 39);
  if (v2)
  {
    _CFHTTPAuthenticationDisassociateConnection(v2, this);
    uint64_t v3 = (const void *)*((void *)this + 39);
    if (v3) {
      CFRelease(v3);
    }
  }

  uint64_t v4 = (const void *)*((void *)this + 40);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *((void *)this + 41);
  if (v5)
  {
    _CFHTTPAuthenticationDisassociateConnection(v5, this);
    int v6 = (const void *)*((void *)this + 41);
    if (v6) {
      CFRelease(v6);
    }
  }

  uint64_t v7 = (const void *)*((void *)this + 42);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)*((void *)this + 44);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = (const void *)*((void *)this + 45);
  if (v9) {
    CFRelease(v9);
  }
  HTTPNetConnection::~HTTPNetConnection(this);
}

void *HTTPNetConnection_WithAuth::setRemoteCredsAndAuth( void *this, CFTypeRef cf, _CFHTTPAuthentication *a3)
{
  if (cf)
  {
    if (a3)
    {
      uint64_t v4 = (uint64_t)this;
      this[45] = CFRetain(cf);
      this = CFRetain(a3);
      *(void *)(v4 + 352) = this;
    }
  }

  return this;
}

CFDictionaryRef HTTPNetConnection_WithAuth::setConnectionCredsAndAuth( CFDictionaryRef this, const __CFDictionary *a2, CFTypeRef cf)
{
  if (!*((void *)this + 39))
  {
    CFDictionaryRef v3 = this;
    if (!*((void *)this + 40))
    {
      if (cf) {
        CFTypeRef v5 = CFRetain(cf);
      }
      else {
        CFTypeRef v5 = 0LL;
      }
      *((void *)v3 + 39) = v5;
      if (a2)
      {
        int v6 = CFGetAllocator(a2);
        this = CFDictionaryCreateCopy(v6, a2);
      }

      else
      {
        this = 0LL;
      }

      *((void *)v3 + 40) = this;
    }
  }

  return this;
}

void HTTPNetConnection_WithAuth::responseStreamCallback( void (**this)(HTTPNetConnection *), void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (this[27]) {
    this[24]((HTTPNetConnection *)this);
  }
  int v8 = *((_DWORD *)a2 + 8);
  if ((v8 & 0x20) == 0) {
    HTTPNetConnection::prepareReception((HTTPNetConnection *)this, (uint64_t)a2, a3);
  }
  if (!*((void *)a2 + 6) && (*((_BYTE *)a2 + 32) & 4) == 0) {
    a2 = (void *)HTTPNetConnection::updateForHeaders((HTTPNetConnection *)this, (uint64_t)a2, a3);
  }
  int v9 = *((_DWORD *)a2 + 8);
  if ((v9 & 0x100) == 0)
  {
    *((_DWORD *)a2 + _Block_object_dispose(va, 8) = v9 | 0x100;
    if (a3) {
      uint64_t v10 = a3 + 16;
    }
    else {
      uint64_t v10 = 0LL;
    }
    ++*(void *)(v10 + 80);
    (*(void (**)(void, uint64_t))(**(void **)(v10 + 24) + 32LL))(*(void *)(v10 + 24), 0x18C5AC598LL);
    --*(void *)(v10 + 80);
    int v9 = *((_DWORD *)a2 + 8);
  }

  if ((v9 & 0x200) == 0)
  {
    *((_DWORD *)a2 + _Block_object_dispose(va, 8) = v9 | 0x200;
    if (a3) {
      uint64_t v11 = a3 + 16;
    }
    else {
      uint64_t v11 = 0LL;
    }
    ++*(void *)(v11 + 80);
    (*(void (**)(void, uint64_t))(**(void **)(v11 + 24) + 32LL))(*(void *)(v11 + 24), 0x18C5AC218LL);
    --*(void *)(v11 + 80);
  }

  if (a4 <= 15)
  {
    if (a4 != 2)
    {
      if (a4 == 8)
      {
        uint64_t v12 = a3 + 16;
        if (!a3) {
          uint64_t v12 = 0LL;
        }
        *(_OWORD *)int v15 = *(_OWORD *)(v12 + 56);
        HTTPNetStreamInfo::grabReadStreamProperties((uint64_t)a2, a3);
        (*(void (**)(void, unsigned __int8 *))(**((void **)a2 + 16) + 64LL))(*((void *)a2 + 16), v15);
      }

      return;
    }

    if ((v8 & 0x20) == 0) {
      return;
    }
    if ((*((_BYTE *)a2 + 32) & 4) != 0)
    {
      if (a3) {
        int v14 = (CoreStreamBase *)(a3 + 16);
      }
      else {
        int v14 = 0LL;
      }
      while (1)
      {
        CoreStreamBase::_streamInterface_Read(v14, v15, 2048LL);
      }

      return;
    }

    goto LABEL_43;
  }

  if (a4 != 16)
  {
    if (a4 == 32 && (v8 & 0x20) != 0 && *((void *)a2 + 16)) {
      HTTPNetStreamInfo::sendStreamIsComplete((HTTPNetStreamInfo *)a2);
    }
    return;
  }

  uint64_t v13 = *((void *)a2 + 16);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 72LL))(v13);
  }
  if ((*((_BYTE *)a2 + 32) & 4) == 0) {
LABEL_43:
  }
    _CFReadStreamSignalEventDelayed();
}

uint64_t HTTPNetConnection_WithAuth::isConnectionWithAuth(HTTPNetConnection_WithAuth *this)
{
  return 1LL;
}

CFDictionaryRef HTTPNetConnection_WithAuth::applyAnyCredentials(CFDictionaryRef this, CFHTTPMessageRef *a2)
{
  uint64_t v3 = (uint64_t)this;
  uint64_t v4 = *((void *)this + 46);
  if (v4 == 407) {
    goto LABEL_10;
  }
  CFTypeRef v5 = (_CFHTTPAuthentication *)*((void *)this + 39);
  if (v5)
  {
    CFHTTPMessageApplyCredentialDictionary(a2[5], v5, *((CFDictionaryRef *)this + 40), &v6);
    this = _CFHTTPAuthenticationApplyHeaderToRequest(*(_CFHTTPAuthentication **)(v3 + 312), a2[5], (const void *)v3);
    uint64_t v4 = *(void *)(v3 + 368);
  }

  if (v4 != 401)
  {
LABEL_10:
    if (*(void *)(v3 + 328))
    {
      this = (CFDictionaryRef)(*(uint64_t (**)(void))(**(void **)(v3 + 272) + 88LL))(*(void *)(v3 + 272));
      if ((_DWORD)this != 3)
      {
        CFHTTPMessageApplyCredentialDictionary( a2[5],  *(CFHTTPAuthenticationRef *)(v3 + 328),  *(CFDictionaryRef *)(v3 + 336),  &v6);
        return _CFHTTPAuthenticationApplyHeaderToRequest(*(_CFHTTPAuthentication **)(v3 + 328), a2[5], (const void *)v3);
      }
    }
  }

  return this;
}

CFIndex HTTPNetConnection_WithAuth::applyCredentialsDictionary( CFHTTPAuthenticationRef *this, __CFHTTPMessage *a2, _CFHTTPAuthentication *a3)
{
  int v5 = CFHTTPAuthenticationRequiresOrderedRequests(this[41]);
  CFHTTPMessageApplyCredentialDictionary(a2, this[41], this[42], &v8);
  if (v5 && !v8.error)
  {
    v8.CFIndex domain = (CFIndex)_CFHTTPAuthenticationApplyHeaderToRequest(this[41], a2, this);
    *(void *)&v8.uint64_t error = v6;
  }

  return v8.domain;
}

uint64_t HTTPNetConnection_WithAuth::getProxyAuth(HTTPNetConnection_WithAuth *this, __CFHTTPMessage *a2)
{
  return *((void *)this + 41);
}

HTTPNetStreamInfo *HTTPNetConnection_WithAuth::updateAuthForReal( HTTPNetConnection_WithAuth *this, HTTPNetStreamInfo *a2, CFHTTPMessageRef response)
{
  if ((*((_BYTE *)a2 + 33) & 8) != 0) {
    return a2;
  }
  CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(response);
  uint64_t v7 = *((void *)this + 39);
  if (v7)
  {
    _CFHTTPAuthenticationUpdateFromResponse(v7, response, this);
    if (!CFHTTPAuthenticationIsValid(*((CFHTTPAuthenticationRef *)this + 39), &v35)) {
      *((_BYTE *)this + 24_Block_object_dispose(va, 8) = 1;
    }
  }

  uint64_t v8 = *((void *)this + 41);
  if (v8)
  {
    _CFHTTPAuthenticationUpdateFromResponse(v8, response, this);
    if (!CFHTTPAuthenticationIsValid(*((CFHTTPAuthenticationRef *)this + 41), 0LL)) {
      *((_BYTE *)this + 249) = 1;
    }
  }

  int v9 = NetConnection::willEnqueueRequests(this);
  *((void *)this + 46) = ResponseStatusCode;
  if (!v9
    || (*((_BYTE *)this + 248) || !*((void *)this + 39) || ResponseStatusCode != 401)
    && (*((_BYTE *)this + 249) || !*((void *)this + 41) || ResponseStatusCode != 407))
  {
    return a2;
  }

  uint64_t v10 = *((void *)this + 1);
  uint64_t v44 = 0LL;
  uint64_t v45 = &v44;
  uint64_t v46 = 0x2020000000LL;
  uint64_t v47 = 0LL;
  uint64_t v36 = MEMORY[0x1895F87A8];
  uint64_t v37 = 3221225472LL;
  uint64_t v38 = ___ZN17HTTPNetStreamInfo18createZombieDoubleEPK13__CFAllocatorP17HTTPNetConnection_block_invoke;
  CFTypeRef v39 = &unk_189C090F8;
  CFStringRef v40 = &v44;
  uint64_t v41 = a2;
  uint64_t v42 = v10;
  uint64_t v43 = this;
  CFReadStreamCreate();
  uint64_t v11 = v45[3];
  _Block_object_dispose(&v44, 8);
  if (!v11) {
    return a2;
  }
  *(_DWORD *)(v11 + 32) |= 0x840u;
  uint64_t v12 = *((void *)this + 12);
  if (v12) {
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
  }
  if (*((void *)this + 16) && (*((_WORD *)this + 44) & 0x20) != 0)
  {
    int v14 = (uint64_t *)*((void *)this + 16);
    while ((v14[2] & 2) != 0)
    {
      int v14 = (uint64_t *)*v14;
      if (!v14)
      {
        int v14 = (uint64_t *)*((void *)this + 16);
        break;
      }
    }

    uint64_t v16 = (HTTPNetStreamInfo *)v14[1];
    BOOL v13 = v16 == a2;
    if (v16 != a2) {
      int v14 = 0LL;
    }
  }

  else
  {
    BOOL v13 = 0;
    int v14 = 0LL;
  }

  if (!*((void *)this + 17) || (*((_WORD *)this + 44) & 0x200) != 0)
  {
    BOOL v19 = 0;
  }

  else
  {
    CFStringRef v17 = (uint64_t *)*((void *)this + 17);
    while ((v17[2] & 2) != 0)
    {
      CFStringRef v17 = (uint64_t *)*v17;
      if (!v17)
      {
        CFStringRef v17 = (uint64_t *)*((void *)this + 17);
        break;
      }
    }

    BOOL v18 = (HTTPNetStreamInfo *)v17[1];
    BOOL v19 = v18 == a2;
    if (v18 == a2) {
      int v14 = v17;
    }
  }

  if ((v19 || v13) && (CFStringRef v20 = (uint64_t *)*v14) != 0LL)
  {
    uint64_t v21 = (uint64_t *)*v14;
    while ((v21[2] & 2) != 0)
    {
      uint64_t v21 = (uint64_t *)*v21;
      if (!v21)
      {
        uint64_t v21 = v20;
        break;
      }
    }

    uint64_t v22 = (const CoreSchedulingSet *)(*(uint64_t (**)(HTTPNetConnection_WithAuth *, uint64_t))(*(void *)this + 160LL))( this,  v21[1]);
  }

  else
  {
    uint64_t v22 = 0LL;
  }

  uint64_t v23 = (char *)this + 112;
  while (1)
  {
    uint64_t v23 = *(char **)v23;
    if (!v23) {
      break;
    }
    if (*((HTTPNetStreamInfo **)v23 + 1) == a2)
    {
      *((void *)v23 + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v11;
      v23[16] |= 2u;
      break;
    }
  }

  if (v13)
  {
    NetConnection::rescheduleStream(*((char **)this + 18), v22);
    uint64_t v24 = *((void *)this + 16);
    if (!v24 || *(void *)(v24 + 8) != v11 || (*((_WORD *)this + 44) & 0x20) == 0) {
      goto LABEL_74;
    }
    uint64_t v25 = 16LL;
  }

  else
  {
    if (!v19) {
      goto LABEL_74;
    }
    uint64_t v26 = (char *)*((void *)this + 19);
    if (v26)
    {
      CFRetain(*((CFTypeRef *)this + 19));
      uint64_t v27 = (CoreStreamBase *)(v26 + 16);
    }

    else
    {
      uint64_t v27 = 0LL;
    }

    CFStreamError v28 = v22;
    if (!v22)
    {
      if (CoreSchedulingSet::getEmptySet(void)::sOnce != -1)
      {
        char v34 = v27;
        dispatch_once(&CoreSchedulingSet::getEmptySet(void)::sOnce, &__block_literal_global_16893);
        uint64_t v27 = v34;
      }

      CFStreamError v28 = (const CoreSchedulingSet *)CoreSchedulingSet::getEmptySet(void)::sEmptySet;
    }

    CoreStreamBase::_streamInterface_UpdateScheduling(v27, v28);
    if (v26) {
      CFRelease(v26);
    }
    uint64_t v29 = *((void *)this + 17);
    if (!v29 || *(void *)(v29 + 8) != v11 || (*((_WORD *)this + 44) & 0x200) != 0) {
      goto LABEL_74;
    }
    uint64_t v25 = 17LL;
  }

  (*(void (**)(HTTPNetConnection_WithAuth *, uint64_t))(*(void *)this + 8 * v25))(this, v11);
LABEL_74:
  if (v22) {
    (*(void (**)(const CoreSchedulingSet *))(*(void *)v22 + 48LL))(v22);
  }
  uint64_t v30 = *((void *)this + 12);
  if (v30) {
    pthread_mutex_unlock((pthread_mutex_t *)(v30 + 8));
  }
  *(_DWORD *)(v11 + 32) &= ~0x40u;
  unsigned int v31 = *((_DWORD *)a2 + 8) & 0xFFFFFFFE;
  *((_DWORD *)a2 + _Block_object_dispose(va, 8) = v31;
  CFStreamError v32 = (const void *)*((void *)a2 + 6);
  *((void *)a2 + 6) = 0LL;
  if (v32)
  {
    CFRelease(v32);
    unsigned int v31 = *((_DWORD *)a2 + 8);
  }

  *((_DWORD *)a2 + _Block_object_dispose(va, 8) = v31 & 0xFFFE1FDF | 0x2000;
  *((void *)a2 + 1__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  __int16 v33 = (NetConnection *)*((void *)a2 + 16);
  if (v33) {
    NetConnection::enqueue(v33, a2, 1);
  }
  return (HTTPNetStreamInfo *)v11;
}

void sub_182A95FB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void HTTPNetConnection_WithAuth::applyRemoteCredentials( HTTPNetConnection_WithAuth *this, _CFURLCredential *a2)
{
  uint64_t v2 = *((void *)this + 45);
  if (v2)
  {
    uint64_t v5 = URLCredential_PasswordBased::safelyCast(*((void *)this + 45), a2);
    if (v5) {
      uint64_t v6 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 128LL))(v5);
    }
    else {
      uint64_t v6 = 0LL;
    }
    uint64_t v7 = (_CFHTTPAuthentication *)*((void *)this + 44);
    if (v7)
    {
      Username = (const __CFString *)CFURLCredentialGetUsername(v2);
      CFHTTPMessageApplyCredentials((CFHTTPMessageRef)a2, v7, Username, v6, 0LL);
    }

    if (v6) {
      CFRelease(v6);
    }
  }

void non-virtual thunk to'HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth( HTTPNetConnection_WithAuth *this)
{
}

void non-virtual thunk to'HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth(CFAllocatorRef *this)
{
  uint64_t v2 = this - 3;
  HTTPNetConnection_WithAuth::~HTTPNetConnection_WithAuth((HTTPNetConnection_WithAuth *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_182A96130(_Unwind_Exception *a1)
{
}

void HTTPNetStreamInfo::~HTTPNetStreamInfo(HTTPNetStreamInfo *this)
{
}

{
  uint64_t v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  __CFReadStream *v6;
  CoreSchedulingSet *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  __CFRunLoopTimer *v12;
  uint64_t v13;
  uint8_t v14[16];
  *(void *)this = off_189C08F10;
  *((void *)this + 2) = &unk_189C09030;
  uint64_t v2 = *((void *)this + 15);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
    *((void *)this + 15) = 0LL;
  }

  HTTPNetStreamInfo::dequeueFromConnection((NetConnection **)this);
  uint64_t v3 = (const void *)*((void *)this + 6);
  if (v3) {
    CFRelease(v3);
  }
  HTTPNetStreamInfo::closeAndReleasePayload(this);
  uint64_t v4 = (const void *)*((void *)this + 5);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  if ((*((_BYTE *)this + 32) & 4) != 0)
  {
    uint64_t v6 = (__CFReadStream *)*((void *)this + 1);
    if (v6)
    {
      uint64_t v7 = (CoreSchedulingSet *)*((void *)this + 21);
      if (v7) {
        CoreSchedulingSet::unscheduleStream(v7, *((__CFReadStream **)this + 1));
      }
      CFReadStreamSetClient(v6, 0LL, 0LL, 0LL);
    }
  }

  uint64_t v8 = (const void *)*((void *)this + 10);
  if (v8) {
    CFRelease(v8);
  }
  int v9 = (const void *)*((void *)this + 17);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v10 = (const void *)*((void *)this + 18);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v11 = (const void *)*((void *)this + 7);
  if (v11)
  {
    if (*((_BYTE *)this + 64)
      || !os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT)
      || (*(_WORD *)int v14 = 0,
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "payload was never closed?",  v14,  2u),  (uint64_t v11 = (const void *)*((void *)this + 7)) != 0LL))
    {
      CFRelease(v11);
    }
  }

  uint64_t v12 = (__CFRunLoopTimer *)*((void *)this + 22);
  if (v12)
  {
    CFRunLoopTimerInvalidate(v12);
    CFRelease(*((CFTypeRef *)this + 22));
    *((void *)this + 22) = 0LL;
  }

  BOOL v13 = *((void *)this + 21);
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 48LL))(v13);
    *((void *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
  }

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 152);
  *(void *)this = off_189C19AE8;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = 0LL;
}

BOOL HTTPNetStreamInfo::_streamImpl_Open( HTTPNetStreamInfo *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  if ((*((_BYTE *)this + 32) & 4) != 0)
  {
    BOOL result = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    *(_WORD *)uint64_t v10 = 0;
    _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "Don't open zombies", v10, 2u);
    return 0LL;
  }

  *a4 = 0;
  a3->uint64_t error = 0;
  a3->CFIndex domain = 0LL;
  uint64_t v7 = (NetConnection *)*((void *)this + 16);
  if (!v7 || !NetConnection::enqueue(v7, this, 0))
  {
    BOOL result = 0LL;
    *a4 = 1;
    a3->CFIndex domain = 4LL;
    a3->uint64_t error = -4;
    return result;
  }

  int v8 = (*((_DWORD *)this + 8) >> 13) & 0xF;
  BOOL result = 1LL;
  if (v8 == 7)
  {
    *a4 = 1;
    a3->CFIndex domain = 4LL;
    a3->uint64_t error = -4;
    return 0LL;
  }

  if (v8 == 5) {
    goto LABEL_8;
  }
  if (v8 != 4) {
    return result;
  }
  if (*((void *)this + 6)) {
LABEL_8:
  }
    *a4 = 1;
  else {
    *a4 = 0;
  }
  return result;
}

uint64_t HTTPNetStreamInfo::_streamImpl_OpenCompleted( HTTPNetStreamInfo *this, __CFReadStream *a2, CFStreamError *a3)
{
  if ((*((_BYTE *)this + 32) & 4) != 0)
  {
    uint64_t result = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)uint64_t v7 = 0;
    _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "Don't open zombies", v7, 2u);
    return 0LL;
  }

  if ((*((_BYTE *)this + 32) & 8) != 0) {
    return 0LL;
  }
  uint64_t result = *((void *)this + 16);
  if (!result) {
    return result;
  }
  int State = NetConnection::getState((NetConnection *)result, 1, (uint64_t *)this);
  if ((State - 5) >= 2)
  {
    if (State != 7)
    {
      if (State == 4) {
        return *((void *)this + 6) != 0LL;
      }
      return 0LL;
    }

    a3->CFIndex domain = 4LL;
    a3->uint64_t error = -4;
  }

  return 1LL;
}

uint64_t HTTPNetStreamInfo::_streamImpl_Read( HTTPNetStreamInfo *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  unsigned int v6 = *((_DWORD *)this + 8);
  if ((v6 & 4) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "Don't open zombies", buf, 2u);
    }

    return -1LL;
  }

  if (!*((void *)this + 6) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uint64_t v22 = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "Then he shouldn't be reading.",  v22,  2u);
    unsigned int v6 = *((_DWORD *)this + 8);
  }

  int v12 = (v6 >> 13) & 0xF;
  if (v12 == 7) {
    goto LABEL_14;
  }
  if (v12 == 5)
  {
    uint64_t v13 = 0LL;
    a5->uint64_t error = 0;
LABEL_32:
    *a6 = 1;
    return v13;
  }

  uint64_t v14 = *((void *)this + 16);
  if (!v14)
  {
LABEL_14:
    CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 1));
    *a5 = Error;
    if (!Error.error)
    {
      a5->CFIndex domain = 1LL;
      a5->uint64_t error = 54;
    }

    return -1LL;
  }

  uint64_t v15 = *(void *)(v14 + 96);
  if (v15)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
    uint64_t v16 = *(void *)(v14 + 96);
    uint64_t v17 = *(void *)(v14 + 152);
    if (v16) {
      pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
    }
  }

  else
  {
    uint64_t v17 = *(void *)(v14 + 152);
  }

  a5->uint64_t error = 0;
  *a6 = 0;
  if (!v17)
  {
    a5->CFIndex domain = 4LL;
    a5->uint64_t error = -4;
LABEL_22:
    uint64_t v13 = -1LL;
    goto LABEL_31;
  }

  if (_CFHTTPReadStreamIsAtMark(v17))
  {
    HTTPNetStreamInfo::sendStreamIsComplete(this);
    uint64_t v13 = 0LL;
LABEL_30:
    *a6 = 1;
    goto LABEL_31;
  }

  uint64_t v19 = CoreStreamBase::_streamInterface_Read((CoreStreamBase *)(v17 + 16), a3, a4);
  uint64_t v13 = v19;
  if (CoreReadStream::Class(void)::sOnce_CoreReadStream != -1)
  {
    dispatch_once(&CoreReadStream::Class(void)::sOnce_CoreReadStream, &__block_literal_global_16679);
    if ((v13 & 0x8000000000000000LL) == 0) {
      goto LABEL_27;
    }
    goto LABEL_35;
  }

  if (v19 < 0)
  {
LABEL_35:
    *a5 = *(CFStreamError *)(v17 + 72);
    uint64_t v21 = *((void *)this + 16);
    if (v21) {
      (*(void (**)(uint64_t, CFStreamError *))(*(void *)v21 + 64LL))(v21, a5);
    }
    goto LABEL_22;
  }

BOOL HTTPNetStreamInfo::_streamImpl_CanRead(HTTPNetStreamInfo *this, __CFReadStream *a2)
{
  if ((*((_BYTE *)this + 32) & 4) != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "Don't open zombies", v13, 2u);
    }

    return 0LL;
  }

  uint64_t v3 = (NetConnection *)*((void *)this + 16);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = 1LL;
  unsigned int State = NetConnection::getState(v3, 1, (uint64_t *)this);
  if (State > 4) {
    return v4;
  }
  if (State != 4) {
    return 0LL;
  }
  uint64_t v6 = *((void *)this + 16);
  uint64_t v7 = *(void *)(v6 + 96);
  if (v7)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v7 + 8));
    uint64_t v8 = *(void *)(v6 + 96);
    uint64_t v9 = *(void *)(v6 + 152);
    if (v8) {
      pthread_mutex_unlock((pthread_mutex_t *)(v8 + 8));
    }
  }

  else
  {
    uint64_t v9 = *(void *)(v6 + 152);
  }

  uint64_t v11 = v9 ? (CoreStreamBase *)(v9 + 16) : 0LL;
  if (*((void *)this + 6)) {
    return 1LL;
  }
  int v12 = (HTTPNetConnection *)(*(uint64_t (**)(void))(**((void **)this + 16) + 80LL))(*((void *)this + 16));
  return HTTPNetConnection::updateForHeaders(v12, (uint64_t)this, v9) == (void)this;
}

CFNumberRef HTTPNetStreamInfo::_streamImpl_CopyProperty( CFTypeRef *this, __CFReadStream *a2, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 8u);
  if (ExactString == 446019561)
  {
    uint64_t v7 = CFGetAllocator(this[1]);
    return CFNumberCreate(v7, kCFNumberLongLongType, this + 11);
  }

  if (ExactString == 446986240)
  {
    CFNumberRef result = (CFNumberRef)this[6];
    if (result) {
      return (CFNumberRef)CFRetain(result);
    }
    return result;
  }

  CFTypeRef v8 = this[12];
  if (!v8) {
    goto LABEL_12;
  }
  EmptyDict = (const __CFDictionary *)*((void *)v8 + 5);
  if (!EmptyDict)
  {
    EmptyDict = (const __CFDictionary *)*((void *)v8 + 4);
    if (!EmptyDict) {
      EmptyDict = (const __CFDictionary *)AutoDict::getEmptyDict(0LL);
    }
  }

  int Value = CFDictionaryGetValue(EmptyDict, theString);
  if (!Value || (CFNumberRef result = (CFNumberRef)CFRetain(Value)) == 0LL)
  {
LABEL_12:
    uint64_t v11 = this[16];
    if (!v11) {
      return 0LL;
    }
    uint64_t v12 = v11[12];
    if (v12)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v12 + 8));
      uint64_t v13 = v11[12];
      uint64_t v14 = v11[19];
      if (v13) {
        pthread_mutex_unlock((pthread_mutex_t *)(v13 + 8));
      }
      if (!v14)
      {
LABEL_22:
        uint64_t v15 = this[16];
        uint64_t v16 = v15[12];
        if (v16)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
          uint64_t v17 = v15[12];
          uint64_t v18 = v15[18];
          if (v17) {
            pthread_mutex_unlock((pthread_mutex_t *)(v17 + 8));
          }
          if (v18) {
            goto LABEL_26;
          }
        }

        else
        {
          uint64_t v18 = v15[18];
          if (v18)
          {
LABEL_26:
            ++*(void *)(v18 + 96);
            CFNumberRef result = (CFNumberRef)(*(uint64_t (**)(void, CFStringRef))(**(void **)(v18 + 40) + 40LL))( *(void *)(v18 + 40),  theString);
            --*(void *)(v18 + 96);
            return result;
          }
        }

        return 0LL;
      }
    }

    else
    {
      uint64_t v14 = v11[19];
      if (!v14) {
        goto LABEL_22;
      }
    }

    ++*(void *)(v14 + 96);
    CFNumberRef result = (CFNumberRef)(*(uint64_t (**)(void, CFStringRef))(**(void **)(v14 + 40) + 40LL))( *(void *)(v14 + 40),  theString);
    --*(void *)(v14 + 96);
    if (!result) {
      goto LABEL_22;
    }
  }

  return result;
}

CFStreamStatus HTTPNetStreamInfo::_streamImpl_SetProperty( HTTPNetStreamInfo *this, __CFReadStream *a2, CFStringRef theString, const void *a4)
{
  int ExactString = _findExactString(theString, 0);
  int v8 = ExactString;
  if (ExactString > 119892108)
  {
    if (ExactString > 135580084)
    {
      if (ExactString == 135580085 || ExactString == 401003905) {
        goto LABEL_19;
      }
      int v9 = 408311313;
    }

    else
    {
      if (ExactString == 119892109 || ExactString == 120965283) {
        goto LABEL_19;
      }
      int v9 = 129296697;
    }

void HTTPNetStreamInfo::_streamImpl_deprecated_Schedule( HTTPNetStreamInfo *this, __CFReadStream *a2, CoreSchedulingSet *a3, const __CFString *cf1)
{
  uint64_t v7 = *((void *)this + 21);
  if (v7) {
    *((void *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = (*(uint64_t (**)(uint64_t, CoreSchedulingSet *, const __CFString *))(*(void *)v7 + 56LL))( v7,  a3,  cf1);
  }
  if (((*((_DWORD *)this + 8) >> 13) & 0xFu) <= 4)
  {
    uint64_t v8 = *((void *)this + 16);
    if (v8) {
      NetConnection::schedule(v8, (uint64_t *)this, a3, cf1);
    }
  }

  int v9 = (__CFReadStream *)*((void *)this + 7);
  if (v9 && !*((_BYTE *)this + 64)) {
    CFReadStreamScheduleWithRunLoop(v9, (CFRunLoopRef)a3, cf1);
  }
  int v10 = (__CFRunLoopTimer *)*((void *)this + 22);
  if (v10) {
    CFRunLoopAddTimer((CFRunLoopRef)a3, v10, cf1);
  }
}

void HTTPNetStreamInfo::_streamImpl_deprecated_Unschedule( HTTPNetStreamInfo *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7 = *((void *)this + 21);
  if (v7) {
    *((void *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(void *)v7 + 64LL))( v7,  rl,  mode);
  }
  if (((*((_DWORD *)this + 8) >> 13) & 0xFu) <= 4)
  {
    uint64_t v8 = (NetConnection *)*((void *)this + 16);
    if (v8)
    {
      NetConnection::unschedule(v8, (uint64_t *)this, rl, mode);
      int v9 = (__CFReadStream *)*((void *)this + 7);
      if (v9)
      {
        if (!*((_BYTE *)this + 64)) {
          CFReadStreamUnscheduleFromRunLoop(v9, rl, mode);
        }
      }
    }
  }

  int v10 = (__CFRunLoopTimer *)*((void *)this + 22);
  if (v10) {
    CFRunLoopRemoveTimer(rl, v10, mode);
  }
}

void HTTPNetStreamInfo::_readStreamClientCallBack(HTTPNetStreamInfo *this, __CFReadStream *a2, uint64_t a3)
{
  if (!*((void *)this + 3)) {
    return;
  }
  uint64_t v5 = (const void *)(*(uint64_t (**)(HTTPNetStreamInfo *, uint64_t))(*(void *)this + 192LL))(this, 34LL);
  if (a3 == 16)
  {
    (*(void (**)(void, const void *))(*((void *)this + 3) + 16LL))(*((void *)this + 3), v5);
    goto LABEL_15;
  }

  if (a3 == 8)
  {
    CFReadStreamGetError(*((CFReadStreamRef *)this + 1));
    (*(void (**)(void, const void *))(*((void *)this + 3) + 16LL))(*((void *)this + 3), v5);
LABEL_15:
    uint64_t v12 = (const void *)*((void *)this + 3);
    if (v12)
    {
      _Block_release(v12);
      *((void *)this + 3) = 0LL;
      if (!v5) {
        return;
      }
      goto LABEL_20;
    }

__CFString *HTTPNetStreamInfo::copyDebugDesc(CFHTTPMessageRef *this)
{
  CFURLRef v2 = CFHTTPMessageCopyRequestURL(this[5]);
  uint64_t v3 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  if (((_DWORD)this[4] & 4) != 0) {
    uint64_t v5 = "Yes";
  }
  else {
    uint64_t v5 = "No";
  }
  uint64_t v6 = CFStringCreateWithFormat( v3,  0LL,  @"<HTTP stream context %p>{url = %@, state = %s, conn=%p, isZombie=%s}",  this,  v2,  "",  this[16],  v5);
  CFStringAppend(Mutable, v6);
  if (v6) {
    CFRelease(v6);
  }
  if (v2) {
    CFRelease(v2);
  }
  return Mutable;
}

void HTTPNetStreamInfo::setBodyStreamBeforeOpening(HTTPNetStreamInfo *this, CFTypeRef cf)
{
  if (cf)
  {
    *((void *)this + 7) = CFRetain(cf);
    *((_BYTE *)this + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
    *((void *)this + 9) = -1LL;
  }

  else
  {
    uint64_t v3 = *((void *)this + 5);
    if (v3) {
      uint64_t v4 = (HTTPMessage *)(v3 + 16);
    }
    else {
      uint64_t v4 = 0LL;
    }
    HTTPMessage::ensureParserFinished(v4);
    uint64_t v5 = *((void *)v4 + 6);
    if (v5)
    {
      uint64_t v6 = *(const __CFData **)(v5 + 16);
      if (v6 || (uint64_t v6 = *(const __CFData **)(v5 + 24)) != 0LL)
      {
        CFIndex Length = CFDataGetLength(v6);
        *((void *)this + 9) = Length;
        if (Length >= 1)
        {
          size_t v8 = CFGetAllocator(v6);
          BytePtr = CFDataGetBytePtr(v6);
          *((void *)this + 7) = CFReadStreamCreateWithBytesNoCopy( v8,  BytePtr,  *((void *)this + 9),  (CFAllocatorRef)*MEMORY[0x189604DC8]);
          *((_BYTE *)this + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 0;
        }
      }
    }
  }

uint64_t HTTPNetStreamInfo::rawBytesSent(HTTPNetStreamInfo *this)
{
  return *((void *)this + 13);
}

uint64_t HTTPNetStreamInfo::rawBytesReceived(HTTPNetStreamInfo *this)
{
  return *((void *)this + 14);
}

void *HTTPNetStreamInfo::setProxy(void *result, uint64_t *a2)
{
  CFURLRef v2 = result + 19;
  if (result[19] != *a2)
  {
    uint64_t v4 = result[16];
    if (v4)
    {
      uint64_t v5 = a2[1];
      uint64_t v11 = *a2;
      uint64_t v12 = (std::__shared_weak_count *)v5;
      if (v5)
      {
        uint64_t v6 = (unint64_t *)(v5 + 8);
        do
          unint64_t v7 = __ldxr(v6);
        while (__stxr(v7 + 1, v6));
      }

      (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 232LL))(v4, &v11);
      size_t v8 = v12;
      if (v12)
      {
        p_uint64_t shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          unint64_t v10 = __ldaxr(p_shared_owners);
        while (__stlxr(v10 - 1, p_shared_owners));
        if (!v10)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }

    return std::shared_ptr<__CFString const>::operator=[abi:nn180100](v2, *a2, a2[1]);
  }

  return result;
}

void sub_182A972AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HTTPNetStreamInfo::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 152);
  if (!v2) {
    return (*(uint64_t (**)(void))(**(void **)(this + 128) + 240LL))(*(void *)(this + 128));
  }
  uint64_t v3 = *(void *)(this + 160);
  *a2 = v2;
  a2[1] = v3;
  if (v3)
  {
    uint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  return this;
}

CFTypeRef HTTPNetStreamInfo::retain(CFTypeRef *this)
{
  return CFRetain(this[1]);
}

void HTTPNetStreamInfo::release(CFTypeRef *this)
{
}

uint64_t HTTPNetStreamInfo::_meta_retain(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(HTTPNetStreamInfo *))(*(void *)this + 160LL))(this);
}

uint64_t HTTPNetStreamInfo::_meta_release(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(HTTPNetStreamInfo *))(*(void *)this + 168LL))(this);
}

CFTypeRef HTTPNetStreamInfo::copyProperty(uint64_t a1, int a2)
{
  uint64_t v2 = *(__CFReadStream **)(a1 + 8);
  uint64_t v3 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  return CFReadStreamCopyProperty(v2, v3);
}

uint64_t HTTPNetStreamInfo::setProperty(uint64_t a1, int a2, const void *a3)
{
  uint64_t v4 = *(__CFReadStream **)(a1 + 8);
  unint64_t v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  return CFReadStreamSetProperty(v4, v5, a3);
}

void HTTPNetStreamInfo::updateScheduling(HTTPNetStreamInfo *this, CoreSchedulingSet *a2)
{
  uint64_t v2 = a2;
  if (!CoreSchedulingSet::isEqualTo(*((CoreSchedulingSet **)this + 21), a2))
  {
    uint64_t v4 = *((void *)this + 22);
    unint64_t v5 = (void (*)(void, void, void))MEMORY[0x1895F87A8];
    if (v4)
    {
      uint64_t v6 = *((void *)this + 21);
      size_t v9 = (void (*)(void, void, void))MEMORY[0x1895F87A8];
      uint64_t v10 = 3221225472LL;
      uint64_t v11 = ___ZNK17CoreSchedulingSet15unscheduleTimerEP16__CFRunLoopTimer_block_invoke;
      uint64_t v12 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
      uint64_t v13 = v4;
      CoreSchedulingSet::applyBlockWithPossibleEmulation(v6, &v9);
    }

    CoreSchedulingSet::unscheduleStream(*((CoreSchedulingSet **)this + 21), *((__CFReadStream **)this + 1));
    uint64_t v7 = *((void *)this + 21);
    (*(void (**)(CoreSchedulingSet *))(*(void *)v2 + 40LL))(v2);
    (*(void (**)(uint64_t))(*(void *)v7 + 48LL))(v7);
    *((void *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = v2;
    uint64_t v8 = *((void *)this + 22);
    if (v8)
    {
      size_t v9 = v5;
      uint64_t v10 = 3221225472LL;
      uint64_t v11 = ___ZNK17CoreSchedulingSet13scheduleTimerEP16__CFRunLoopTimer_block_invoke;
      uint64_t v12 = &__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
      uint64_t v13 = v8;
      CoreSchedulingSet::applyBlockWithPossibleEmulation((uint64_t)v2, &v9);
      uint64_t v2 = (CoreSchedulingSet *)*((void *)this + 21);
    }

    CoreSchedulingSet::scheduleStream(v2, *((__CFReadStream **)this + 1));
  }

uint64_t HTTPNetStreamInfo::canScheduleAndOpenWithHandlerAsync(HTTPNetStreamInfo *this)
{
  return 0LL;
}

uint64_t HTTPNetStreamInfo::scheduleAndOpenWithHandler(uint64_t a1, uint64_t a2, void *aBlock)
{
  if (*(void *)(a1 + 24)) {
    __assert_rtn("scheduleAndOpenWithHandler", "HTTPNetStreamInfo.cpp", 925, "_metaClientCallback == NULL");
  }
  *(void *)(a1 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = _Block_copy(aBlock);
  clientContext.version = 0LL;
  clientContext.mach_timebase_info info = (void *)a1;
  clientContext.retain = (void *(__cdecl *)(void *))_CFNetworkReadStream_retain;
  clientContext.release = (void (__cdecl *)(void *))_CFNetworkReadStream_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_CFNetworkReadStream_copyDesc;
  CFReadStreamSetClient( *(CFReadStreamRef *)(a1 + 8),  0x1AuLL,  (CFReadStreamClientCallBack)CFNetworkReadStream::_readStreamClientCallBackCallBack,  &clientContext);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 208LL))(a1, a2);
  return CFReadStreamOpen(*(CFReadStreamRef *)(a1 + 8));
}

void HTTPNetStreamInfo::closeAndClearHandler(HTTPNetStreamInfo *this)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 1);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0LL, 0LL, 0LL);
    CFReadStreamClose(*((CFReadStreamRef *)this + 1));
  }

  uint64_t v3 = *((void *)this + 15);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  *((void *)this + 15) = 0LL;
  uint64_t v4 = (const void *)*((void *)this + 3);
  if (v4)
  {
    _Block_release(v4);
    *((void *)this + 3) = 0LL;
  }

uint64_t HTTPNetStreamInfo::getConnectionIdentifier(HTTPNetStreamInfo *this)
{
  return *((void *)this + 16);
}

uint64_t HTTPNetStreamInfo::copyTrust(HTTPNetStreamInfo *this)
{
  uint64_t result = *((void *)this + 16);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 200LL))(result);
  }
  return result;
}

uint64_t HTTPNetStreamInfo::_conn_no_more_reqests_after_this_one_connectionLost(HTTPNetStreamInfo *this)
{
  uint64_t result = *((void *)this + 16);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 288LL))(result);
  }
  return result;
}

void non-virtual thunk to'HTTPNetStreamInfo::~HTTPNetStreamInfo(HTTPNetStreamInfo *this)
{
}

{
  void *v1;
  HTTPNetStreamInfo::~HTTPNetStreamInfo((HTTPNetStreamInfo *)((char *)this - 16));
  operator delete(v1);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::_meta_retain(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(char *))(*((void *)this - 2) + 160LL))((char *)this - 16);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::_meta_release(HTTPNetStreamInfo *this)
{
  return (*(uint64_t (**)(char *))(*((void *)this - 2) + 168LL))((char *)this - 16);
}

CFTypeRef non-virtual thunk to'HTTPNetStreamInfo::copyProperty(uint64_t a1, int a2)
{
  uint64_t v2 = *(__CFReadStream **)(a1 - 8);
  uint64_t v3 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  return CFReadStreamCopyProperty(v2, v3);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::setProperty(uint64_t a1, int a2, const void *a3)
{
  uint64_t v4 = *(__CFReadStream **)(a1 - 8);
  unint64_t v5 = (const __CFString *)MetaNetStreamInfo::applicableToPropertyName(a2);
  return CFReadStreamSetProperty(v4, v5, a3);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::canScheduleAndOpenWithHandlerAsync(HTTPNetStreamInfo *this)
{
  return 0LL;
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::scheduleAndOpenWithHandler( uint64_t a1, uint64_t a2, void *a3)
{
  return HTTPNetStreamInfo::scheduleAndOpenWithHandler(a1 - 16, a2, a3);
}

void non-virtual thunk to'HTTPNetStreamInfo::closeAndClearHandler(HTTPNetStreamInfo *this)
{
}

void non-virtual thunk to'HTTPNetStreamInfo::updateScheduling( HTTPNetStreamInfo *this, CoreSchedulingSet *a2)
{
}

void non-virtual thunk to'HTTPNetStreamInfo::setBodyStreamBeforeOpening( HTTPNetStreamInfo *this, __CFReadStream *a2)
{
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::rawBytesSent(HTTPNetStreamInfo *this)
{
  return *((void *)this + 11);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::rawBytesReceived(HTTPNetStreamInfo *this)
{
  return *((void *)this + 12);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::getConnectionIdentifier(HTTPNetStreamInfo *this)
{
  return *((void *)this + 14);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::copyTrust(HTTPNetStreamInfo *this)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 200LL))(result);
  }
  return result;
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::_conn_no_more_reqests_after_this_one_connectionLost( HTTPNetStreamInfo *this)
{
  uint64_t result = *((void *)this + 14);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 288LL))(result);
  }
  return result;
}

void *non-virtual thunk to'HTTPNetStreamInfo::setProxy(uint64_t a1, uint64_t *a2)
{
  return HTTPNetStreamInfo::setProxy((void *)(a1 - 16), a2);
}

uint64_t non-virtual thunk to'HTTPNetStreamInfo::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 136);
  if (!v2) {
    return (*(uint64_t (**)(void))(**(void **)(this + 112) + 240LL))(*(void *)(this + 112));
  }
  uint64_t v3 = *(void *)(this + 144);
  *a2 = v2;
  a2[1] = v3;
  if (v3)
  {
    uint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  return this;
}

void sub_182A978D8(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  _Unwind_Resume(a1);
}

NetConnection **HTTPNetStreamInfo::dequeueFromConnection(NetConnection **this)
{
  uint64_t v1 = this[16];
  if (v1)
  {
    uint64_t v2 = this;
    this[16] = 0LL;
    uint64_t v3 = (__CFRunLoopTimer *)*((void *)v1 + 32);
    if (v3)
    {
      CFRunLoopTimerInvalidate(v3);
      uint64_t v4 = (const void *)*((void *)v1 + 32);
      *((void *)v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0LL;
      if (v4) {
        CFRelease(v4);
      }
    }

    if (!NetConnection::dequeue(v1, v2))
    {
      uint64_t v5 = 4LL;
      int v6 = -4;
      (*(void (**)(NetConnection *, uint64_t *))(*(void *)v1 + 64LL))(v1, &v5);
    }

    return (NetConnection **)(*(uint64_t (**)(NetConnection *))(*(void *)v1 + 48LL))(v1);
  }

  return this;
}

void HTTPNetStreamInfo::closeAndReleasePayload(HTTPNetStreamInfo *this)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 7);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0LL, 0LL, 0LL);
    CFReadStreamClose(*((CFReadStreamRef *)this + 7));
    *((_BYTE *)this + 6os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = 1;
  }

  *((void *)this + 9) = -1LL;
}

uint64_t NetConnection::getRequestStream(NetConnection *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (!v2) {
    return *((void *)this + 18);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 8));
  uint64_t v3 = *((void *)this + 12);
  uint64_t v4 = *((void *)this + 18);
  if (v3) {
    pthread_mutex_unlock((pthread_mutex_t *)(v3 + 8));
  }
  return v4;
}

void HTTPNetStreamInfo::sendStreamIsComplete(HTTPNetStreamInfo *this)
{
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2 && (int v3 = *((_DWORD *)this + 8), (v3 & 0x100) != 0))
  {
    *((_DWORD *)this + _Block_object_dispose(va, 8) = v3 & 0xFFFFFEFF;
    uint64_t v4 = (__CFReadStream *)CFRetain(v2);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  int v5 = *((_DWORD *)this + 8);
  if ((v5 & 0x200) != 0) {
    *((_DWORD *)this + _Block_object_dispose(va, 8) = v5 & 0xFFFFFDFF;
  }
  int v6 = (NetConnection *)*((void *)this + 16);
  if (v6) {
    NetConnection::responseIsComplete(v6, this);
  }
  if (v4)
  {
    CFReadStreamSetProperty(v4, (CFStreamPropertyKey)&unk_18C5AC598, (CFTypeRef)*MEMORY[0x189604DE0]);
    CFRelease(v4);
  }

void HTTPNetStreamInfo::HTTPNetStreamInfo( HTTPNetStreamInfo *this, __CFReadStream *a2, CFTypeRef cf, HTTPNetConnection *a4)
{
  *(void *)this = off_189C08F10;
  *((void *)this + __CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = a2;
  *((void *)this + 2) = &unk_189C09030;
  *((void *)this + 19) = 0LL;
  int v6 = (char *)this + 152;
  *((void *)this + 20) = 0LL;
  *((_DWORD *)this + 8) &= 0xFFFE1FFF;
  if (cf) {
    CFTypeRef v7 = CFRetain(cf);
  }
  else {
    CFTypeRef v7 = 0LL;
  }
  *((void *)this + 5) = v7;
  if (a4) {
    (*(void (**)(HTTPNetConnection *))(*(void *)a4 + 40LL))(a4);
  }
  *((void *)this + 6) = 0LL;
  *((void *)this + CFRelease((char *)this - 16) = a4;
  *((void *)this + 17) = 0LL;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  __int128 v12 = 0uLL;
  uint64_t v8 = (CoreSchedulingSet *)std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v6, &v12);
  size_t v9 = (std::__shared_weak_count *)*((void *)&v12 + 1);
  if (*((void *)&v12 + 1))
  {
    uint64_t v10 = (unint64_t *)(*((void *)&v12 + 1) + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  *((void *)this + 2__CFStreamCreatePairWithSocketToCFHost(alloc, host, *(const __CFAllocator **)&port, readStream, writeStream, 1) = CoreSchedulingSet::createEmpty(v8);
}

void sub_182A97BAC(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  _Unwind_Resume(a1);
}

void HTTPNetStreamInfo::grabReadStreamProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 96);
  if (!v3)
  {
    CFAllocatorRef v5 = CFGetAllocator(*(CFTypeRef *)(a1 + 8));
    uint64_t v3 = MEMORY[0x186E12804](v5, 48LL, 0LL);
    *(_OWORD *)uint64_t v3 = 0u;
    *(_OWORD *)(v3 + CFRelease((char *)this - 16) = 0u;
    *(_OWORD *)(v3 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
    int v6 = CFGetAllocator(*(CFTypeRef *)(a1 + 8));
    *(void *)uint64_t v3 = off_189C09128;
    *(void *)(v3 + _Block_object_dispose(va, 8) = v6;
    *(void *)(v3 + CFRelease((char *)this - 16) = off_189C04A50;
    if (v6) {
      int v6 = CFRetain(v6);
    }
    *(void *)(v3 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0LL;
    *(void *)(v3 + 40) = 0LL;
    *(void *)(v3 + 2os_unfair_lock_lock((os_unfair_lock_t)cf + 4) = v6;
    *(void *)(a1 + 96) = v3;
  }

  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  v7[2] = ___ZN16CapturedSSLState14grabFromStreamEP16__CoreReadStream_block_invoke;
  v7[3] = &__block_descriptor_40_e22__v16__0____CFString__8l;
  v7[4] = a2;
  CapturedSSLState::grabFromStream((void *)v3, (uint64_t)v7);
}