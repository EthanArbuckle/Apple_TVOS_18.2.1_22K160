uint64_t ___ZN16CapturedSSLState14grabFromStreamEP16__CoreReadStream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  v3 = *(void *)(a1 + 32);
  if (v3) {
    v4 = v3 + 16;
  }
  else {
    v4 = 0LL;
  }
  ++*(void *)(v4 + 80);
  result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 24) + 40LL))(*(void *)(v4 + 24), a2);
  --*(void *)(v4 + 80);
  return result;
}

void CapturedSSLState::grabFromStream(void *a1, uint64_t a2)
{
  {
    CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[0] = (uint64_t)&unk_18C5AE010;
    *(void *)algn_18C5B3108 = 0x18C5ACB10LL;
    qword_18C5B3110 = (uint64_t)&unk_18C5ADFA0;
  }

  for (uint64_t i = 0LL; i != 3; ++i)
  {
    v5 = (const void *)CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i];
    EmptyDict = (const __CFDictionary *)a1[5];
    if (!EmptyDict)
    {
      EmptyDict = (const __CFDictionary *)a1[4];
      if (!EmptyDict) {
        EmptyDict = (const __CFDictionary *)AutoDict::getEmptyDict(0LL);
      }
    }

    if (!CFDictionaryGetValue(EmptyDict, v5))
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))( a2,  CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i]);
      if (v7)
      {
        v8 = (const void *)v7;
        v9 = (const void *)CapturedSSLState::grabFromStream(void const*({block_pointer})(__CFString const*))::sKeys[i];
        MutableDict = AutoDict::getMutableDict((AutoDict *)(a1 + 2));
        CFDictionarySetValue(MutableDict, v9, v8);
        CFRelease(v8);
      }
    }
  }

void CapturedSSLState::~CapturedSSLState(CapturedSSLState *this)
{
  *(void *)this = off_189C09128;
  AutoDict::~AutoDict((CapturedSSLState *)((char *)this + 16));
}

void CapturedSSLState::~CapturedSSLState(CFAllocatorRef *this)
{
  *this = (CFAllocatorRef)off_189C09128;
  AutoDict::~AutoDict((AutoDict *)(this + 2));
  CFAllocatorDeallocate(this[1], this);
}

uint64_t ___ZN16CapturedSSLState14grabFromStreamEP17__CoreWriteStream_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    uint64_t v4 = v3 + 16;
  }
  else {
    uint64_t v4 = 0LL;
  }
  ++*(void *)(v4 + 80);
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 24) + 40LL))(*(void *)(v4 + 24), a2);
  --*(void *)(v4 + 80);
  return result;
}

uint64_t ___ZN17HTTPNetStreamInfo18createZombieDoubleEPK13__CFAllocatorP17HTTPNetConnection_block_invoke( void *a1, uint64_t a2)
{
  uint64_t v4 = a1[5];
  v5 = (void *)MEMORY[0x186E12804](a1[6], 184LL, 0LL);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  v5[22] = 0LL;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  uint64_t v6 = a1[7];
  void *v5 = off_189C08F10;
  v5[1] = a2;
  v5[2] = &unk_189C09030;
  v5[19] = 0LL;
  v5[20] = 0LL;
  *((_DWORD *)v5 + 8) = *(_DWORD *)(v4 + 32) | 4;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 40LL))(v6);
  }
  v5[16] = v6;
  v5[11] = *(void *)(v4 + 88);
  CFTypeRef v7 = *(CFTypeRef *)(v4 + 40);
  if (v7) {
    CFTypeRef v7 = CFRetain(v7);
  }
  v5[5] = v7;
  CFTypeRef v8 = *(CFTypeRef *)(v4 + 80);
  if (v8) {
    CFTypeRef v8 = CFRetain(v8);
  }
  v5[10] = v8;
  if (*(void *)(v4 + 56))
  {
    uint64_t v9 = *(void *)(v4 + 40);
    if (v9)
    {
      HTTPMessage::setHeaderFieldScalarValue((HTTPMessage *)(v9 + 16), *(void *)(v9 + 80));
    }

    v10 = (const void *)v5[16];
    uint64_t v11 = v5[5];
    uint64_t v12 = v11 + 16;
    if (!v11) {
      uint64_t v12 = 0LL;
    }
    uint64_t v13 = *(void *)(v12 + 72);
    if (v13 && v10)
    {
      v14 = *(const __CFDictionary **)(v13 + 168);
      if (v14)
      {
        Value = CFDictionaryGetValue(v14, v10);
        if (Value) {
          Value[24] = 0;
        }
      }
    }

    clientContext.version = 0LL;
    clientContext.info = v5;
    clientContext.retain = (void *(__cdecl *)(void *))_CFNetworkReadStream_retain;
    clientContext.release = (void (__cdecl *)(void *))_CFNetworkReadStream_release;
    clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))_CFNetworkReadStream_copyDesc;
    CFReadStreamSetClient( *(CFReadStreamRef *)(v4 + 56),  0x1AuLL,  (CFReadStreamClientCallBack)HTTPNetStreamInfo::_httpRequestPayloadCallBack,  &clientContext);
  }

  uint64_t v16 = *(void *)(v4 + 168);
  if (!v16)
  {
    v5[21] = 0LL;
    v18 = v5 + 21;
LABEL_28:
    void *v18 = CoreSchedulingSet::createEmpty(0LL);
    goto LABEL_29;
  }

  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 88LL))(v16);
  v5[21] = v17;
  v18 = v5 + 21;
  if (!v17) {
    goto LABEL_28;
  }
LABEL_29:
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = v5;
  return *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
}

void sub_182A98124(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  _Unwind_Resume(a1);
}

__CFReadStream *HTTPNetStreamInfo::_httpRequestPayloadCallBack( __CFReadStream *this, __CFReadStream *a2, void *a3, void *a4)
{
  if (a3)
  {
    uint64_t v6 = this;
    (*(void (**)(void *))(*a3 + 160LL))(a3);
    if (a2 == (__CFReadStream *)16) {
      goto LABEL_22;
    }
    if (a2 == (__CFReadStream *)8)
    {
      CFStreamError Error = CFReadStreamGetError(v6);
      uint64_t v12 = a3[16];
      if (v12) {
        (*(void (**)(uint64_t, CFStreamError *))(*(void *)v12 + 64LL))(v12, &Error);
      }
      return (__CFReadStream *)(*(uint64_t (**)(void *))(*a3 + 168LL))(a3);
    }

    if (a2 == (__CFReadStream *)2)
    {
LABEL_22:
      CFTypeRef v7 = (NetConnection *)a3[16];
      if (v7)
      {
        uint64_t v8 = (*(uint64_t (**)(void))(*(void *)v7 + 80LL))(a3[16]);
        uint64_t v9 = *((void *)v7 + 12);
        if (v9)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
          uint64_t v10 = *((void *)v7 + 12);
          uint64_t v11 = *((void *)v7 + 18);
          if (v10) {
            pthread_mutex_unlock((pthread_mutex_t *)(v10 + 8));
          }
          if (!v11) {
            return (__CFReadStream *)(*(uint64_t (**)(void *))(*a3 + 168LL))(a3);
          }
          goto LABEL_14;
        }

        uint64_t v11 = *((void *)v7 + 18);
        if (v11)
        {
LABEL_14:
          if (HTTPNetConnection::transmitRequest(v8, a3, v11, &Error))
          {
            if (Error.error) {
              (*(void (**)(NetConnection *, CFStreamError *))(*(void *)v7 + 64LL))(v7, &Error);
            }
            else {
              NetConnection::requestIsComplete(v7, a3);
            }
          }
        }
      }
    }

    return (__CFReadStream *)(*(uint64_t (**)(void *))(*a3 + 168LL))(a3);
  }

  return this;
}

void HTTPNetStreamInfo::closeRequestResources(HTTPNetStreamInfo *this)
{
  uint64_t v2 = *((void *)this + 16);
  if (!v2) {
    goto LABEL_16;
  }
  uint64_t v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 80LL))(v2);
  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = v4 + 16;
  if (!v4) {
    uint64_t v5 = 0LL;
  }
  uint64_t v6 = *(void *)(v5 + 72);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 5);
  }

  else
  {
    uint64_t v7 = *((void *)this + 5);
  }

  uint64_t v8 = v7 + 16;
  if (!v7) {
    uint64_t v8 = 0LL;
  }
  if (!_CFHTTPAuthenticationIsFirstNTLMTransaction(*(_CFHTTPAuthentication **)(v8 + 72), v3))
  {
LABEL_16:
    uint64_t v9 = (__CFReadStream *)*((void *)this + 7);
    if (v9 && !*((_BYTE *)this + 64))
    {
      CFReadStreamSetClient(v9, 0LL, 0LL, 0LL);
      CFReadStreamClose(*((CFReadStreamRef *)this + 7));
      *((_BYTE *)this + 64) = 1;
    }

    *((void *)this + 9) = -1LL;
    uint64_t v10 = (const void *)*((void *)this + 10);
    if (v10)
    {
      CFRelease(v10);
      *((void *)this + 10) = 0LL;
    }
  }

void HTTPNetStreamInfo::_stallTimerFired(HTTPNetStreamInfo *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v4 = *((void *)a2 + 16);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = *(void *)(v4 + 96);
  if (!v5)
  {
    uint64_t v7 = *(void *)(v4 + 152);
    if (!v7) {
      goto LABEL_12;
    }
    goto LABEL_8;
  }

  pthread_mutex_lock((pthread_mutex_t *)(v5 + 8));
  uint64_t v6 = *(void *)(v4 + 96);
  uint64_t v7 = *(void *)(v4 + 152);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 8));
  }
  if (v7)
  {
LABEL_8:
    int valuePtr = 3;
    CFNumberRef v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, &valuePtr);
    if (v8)
    {
      CFNumberRef v9 = v8;
      ++*(void *)(v7 + 96);
      (*(void (**)(void))(**(void **)(v7 + 40) + 32LL))(*(void *)(v7 + 40));
      --*(void *)(v7 + 96);
      CFRelease(v9);
    }
  }

uint64_t HTTPFilter::expectedSizeFromHeaders(HTTPFilter *this, __CFHTTPMessage *a2)
{
  if (CFHTTPMessageIsRequest(this))
  {
    uint64_t v3 = (char *)this + 16;
    uint64_t v4 = *((_BYTE *)this + 40) ? 0LL : (char *)this + 16;
    uint64_t v5 = (const __CFString *)*((void *)v4 + 19);
    if (v5
      || os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)v24 = 0,
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "these should always be initialized now",  v24,  2u),  (uint64_t v5 = (const __CFString *)*((void *)v4 + 19)) != 0LL))
    {
      if (CFStringCompare(v5, (CFStringRef)&gConstantCFStringValueTable[2604], 0LL) == kCFCompareEqualTo) {
        return 0LL;
      }
    }

    if (*((_BYTE *)this + 40)) {
      uint64_t v3 = 0LL;
    }
    uint64_t v6 = (const __CFString *)*((void *)v3 + 19);
    if (v6
      || os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT)
      && (*(_WORD *)buf = 0,
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "these should always be initialized now",  buf,  2u),  (uint64_t v6 = (const __CFString *)*((void *)v3 + 19)) != 0LL))
    {
      if (CFStringCompare(v6, (CFStringRef)&gConstantCFStringValueTable[2611], 0LL) == kCFCompareEqualTo) {
        return 0LL;
      }
    }
  }

  int IsRequest = CFHTTPMessageIsRequest(this);
  int ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(this);
  int v9 = ResponseStatusCode;
  if (!IsRequest && ResponseStatusCode == 304) {
    return 0LL;
  }
  if (this) {
    uint64_t v11 = (HTTPFilter *)((char *)this + 16);
  }
  else {
    uint64_t v11 = 0LL;
  }
  uint64_t v12 = HTTPMessage::copyHeaderFieldValue(v11, 0x11F1D2DBu);
  if (!v12) {
    goto LABEL_46;
  }
  uint64_t v13 = v12;
  CFIndex Length = CFStringGetLength(v12);
  if (Length < 1)
  {
    CFIndex v16 = 0LL;
    BOOL v15 = 1;
  }

  else
  {
    BOOL v15 = 0;
    CFIndex v16 = 0LL;
    while (1)
    {
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v13, v16);
      if (CharacterAtIndex != 32 && CharacterAtIndex != 9) {
        break;
      }
      BOOL v15 = ++v16 >= Length;
      if (Length == v16)
      {
        uint64_t v10 = 0LL;
        char v18 = v16 >= Length;
        goto LABEL_43;
      }
    }
  }

  char v18 = v15;
  if (v16 >= Length)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = 0LL;
    while (1)
    {
      unsigned int v19 = CFStringGetCharacterAtIndex(v13, v16);
      if (v19 - 48 > 9) {
        break;
      }
      ++v16;
      uint64_t v20 = 10 * v10 + v19;
      if (v16 < Length && v20 >= 0xCCCCCCCCCCCCCF3LL)
      {
        CFRelease(v13);
        goto LABEL_46;
      }

      uint64_t v10 = v20 - 48;
      char v18 = 1;
      if (Length == v16)
      {
        CFRelease(v13);
        return v10;
      }
    }
  }

void HTTP3Stream::~HTTP3Stream(id *this)
{
}

{
  char *v2;
  id v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  *this = off_189C09148;

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 44));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 39));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 37));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 35));
  uint64_t v2 = (char *)this[32];
  this[32] = 0LL;
  if (v2) {
    CFRelease(v2 - 16);
  }
  uint64_t v3 = this[23];
  if (v3)
  {
    this[24] = v3;
    operator delete(v3);
  }

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 12));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 10));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 8));
  uint64_t v4 = (std::__shared_weak_count *)this[7];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 3));
  *this = off_189C19AE8;
  uint64_t v5 = (std::__shared_weak_count *)this[2];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t HTTP3Stream::copyProperty(uint64_t a1, int a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (!v3) {
    return 0LL;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 48);
  if (v7 && (uint64_t v8 = *(void *)(v7 + 1008)) != 0)
  {
    uint64_t v9 = MetaNetStreamInfo::applicableToPropertyName(a2);
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 216LL))(v8, v9);
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  do
    unint64_t v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }

  return v10;
}

void sub_182A988B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HTTP3Stream::setProperty(uint64_t a1, int a2, void *aBlock)
{
  uint64_t v3 = 0LL;
  switch(a2)
  {
    case 1:
      BOOL v15 = *(HTTPMessage **)(a1 + 64);
      HTTPMessage::setHeaderFieldStringValue(v15, 0x1191B2ABu, aBlock);
      goto LABEL_24;
    case 3:
    case 4:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 20:
    case 23:
    case 27:
      uint64_t v6 = *(std::__shared_weak_count **)(a1 + 56);
      if (!v6) {
        return 0LL;
      }
      uint64_t v8 = std::__shared_weak_count::lock(v6);
      v21[1] = v8;
      if (!v8) {
        return 0LL;
      }
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(a1 + 48);
      v21[0] = v10;
      if (v10 && (uint64_t v11 = *(void *)(v10 + 1008)) != 0)
      {
        uint64_t v12 = MetaNetStreamInfo::applicableToPropertyName(a2);
        uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)v11 + 200LL))(v11, v12, aBlock);
      }

      else
      {
        uint64_t v3 = 0LL;
      }

      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(p_shared_owners);
      while (__stlxr(v14 - 1, p_shared_owners));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }

      return v3;
    case 14:
      CFIndex v16 = _Block_copy(aBlock);
      uint64_t v17 = *(void **)(a1 + 376);
      *(void *)(a1 + 376) = v16;

      goto LABEL_24;
    case 15:
      if (aBlock)
      {
        CFTypeID v18 = CFGetTypeID(aBlock);
        if (v18 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
        {
          LOWORD(v21[0]) = 0;
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)v21,  2u);
        }

        BOOL v19 = *MEMORY[0x189604DE8] == (void)aBlock;
      }

      else
      {
        BOOL v19 = 0;
      }

      *(_BYTE *)(a1 + 369) = v19;
LABEL_24:
      uint64_t v3 = 1LL;
      break;
    default:
      return v3;
  }

  return v3;
}

void sub_182A98AA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HTTP3Stream::setBodyStreamBeforeOpening(HTTP3Stream *this, CFTypeRef cf, uint64_t a3)
{
  if (cf) {
    uint64_t v5 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  }
  else {
    uint64_t v5 = 0LL;
  }
  v30 = v5;
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x20uLL);
  v6->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_189C177F0;
  v6->__shared_weak_owners_ = 0LL;
  v6[1].__vftable = v5;
  v31 = v6;
  if (v5)
  {
    uint64_t v8 = v6;
    uint64_t v9 = *((void *)this + 37);
    uint64_t v10 = operator new(0xE0uLL);
    uint64_t v11 = v10;
    v10[1] = 0LL;
    v10[2] = 0LL;
    void *v10 = off_189C17860;
    uint64_t v12 = (uint64_t)(v10 + 3);
    v32 = v5;
    v33 = v8;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
    RequestBodyStream::RequestBodyStream( (uint64_t)(v10 + 3),  (uint64_t *)&v32,  *((dispatch_object_t *)this + 5),  v9,  a3,  0,  0LL);
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }

    *(void *)&__int128 v29 = v12;
    *((void *)&v29 + 1) = v11;
    std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( (uint64_t)&v29,  v11 + 4,  v12);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 96, &v29);
    BOOL v15 = (std::__shared_weak_count *)*((void *)&v29 + 1);
    if (*((void *)&v29 + 1))
    {
      CFIndex v16 = (unint64_t *)(*((void *)&v29 + 1) + 8LL);
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      goto LABEL_14;
    }
  }

  else
  {
    CFTypeID v18 = CFHTTPMessageCopyBody((CFHTTPMessageRef)(*((void *)this + 8) - 16LL));
    BOOL v19 = (std::__shared_weak_count_vtbl *)v18;
    if (!v18) {
      goto LABEL_27;
    }
    if (CFDataGetLength(v18) < 1)
    {
      CFRelease(v19);
      goto LABEL_27;
    }

    uint64_t v20 = *((void *)this + 37);
    BOOL v21 = operator new(0x98uLL);
    v21[1] = 0LL;
    void v21[2] = 0LL;
    *BOOL v21 = off_189C17898;
    v32 = v19;
    uint64_t v22 = (std::__shared_weak_count *)operator new(0x20uLL);
    v22->__shared_owners_ = 0LL;
    v23 = (unint64_t *)&v22->__shared_owners_;
    v22->__vftable = (std::__shared_weak_count_vtbl *)off_189C178D0;
    v22->__shared_weak_owners_ = 0LL;
    v22[1].__vftable = v19;
    v33 = v22;
    RequestBody::RequestBody((uint64_t)(v21 + 3), *((dispatch_object_t *)this + 5), v20, a3);
    v21[17] = 0LL;
    v21[3] = off_189C13F20;
    v21[6] = &unk_189C13F90;
    v21[18] = 0LL;
    std::shared_ptr<__CFString const>::operator=[abi:nn180100](v21 + 17, (uint64_t)v19, (uint64_t)v22);
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }

    *(void *)&__int128 v29 = v21 + 3;
    *((void *)&v29 + 1) = v21;
    std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( (uint64_t)&v29,  v21 + 4,  (uint64_t)(v21 + 3));
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 96, &v29);
    BOOL v15 = (std::__shared_weak_count *)*((void *)&v29 + 1);
    if (*((void *)&v29 + 1))
    {
      v25 = (unint64_t *)(*((void *)&v29 + 1) + 8LL);
      do
        unint64_t v17 = __ldaxr(v25);
      while (__stlxr(v17 - 1, v25));
LABEL_14:
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }

void sub_182A98E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::__shared_weak_count::~__shared_weak_count(v3);
  operator delete(v5);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::canScheduleAndOpenWithHandlerAsync(HTTP3Stream *this)
{
  return 1LL;
}

uint64_t HTTP3Stream::scheduleAndOpenWithHandler(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = (void (**)(void, void))v8;
  if (*(_BYTE *)(a1 + 369))
  {
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 56);
    if (v10)
    {
      uint64_t v11 = std::__shared_weak_count::lock(v10);
      *((void *)&v146 + 1) = v11;
      if (v11)
      {
        uint64_t v12 = *(void *)(a1 + 48);
        *(void *)&__int128 v146 = v12;
        if (v12)
        {
          uint64_t v13 = *(void *)(v12 + 1008);
          unint64_t v14 = *(std::__shared_weak_count **)(v12 + 1016);
          uint64_t v154 = v13;
          uint64_t v155 = (uint64_t)v14;
          if (v14)
          {
            p_shared_owners = (unint64_t *)&v14->__shared_owners_;
            do
              unint64_t v16 = __ldxr(p_shared_owners);
            while (__stxr(v16 + 1, p_shared_owners));
          }

          if (v13)
          {
            uint64_t v17 = *(void *)(a1 + 296);
            if (v17) {
              uint64_t v18 = v17 - 176;
            }
            else {
              uint64_t v18 = 0LL;
            }
            id v19 = *(id *)(v18 + 80);
            (*(void (**)(uint64_t, id, uint64_t, void))(*(void *)v13 + 280LL))(v13, v19, 5LL, 0LL);
            *(_BYTE *)(a1 + 368) = 1;
          }

          if (v14)
          {
            uint64_t v20 = (unint64_t *)&v14->__shared_owners_;
            do
              unint64_t v21 = __ldaxr(v20);
            while (__stlxr(v21 - 1, v20));
            if (!v21)
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
          }

          uint64_t v22 = (std::__shared_weak_count *)*((void *)&v146 + 1);
          if (!*((void *)&v146 + 1)) {
            goto LABEL_41;
          }
        }

        else
        {
          uint64_t v22 = v11;
        }

        v37 = (unint64_t *)&v22->__shared_owners_;
        do
          unint64_t v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }
    }

LABEL_150:
  if (v143) {
    operator delete(v143);
  }
  if (v140) {
    operator delete(v140);
  }
LABEL_154:

  return 1LL;
}

void sub_182A99B38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, HTTP3Fields *a9, uint64_t a10, void *a11, void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34, uint64_t a35, char a36, uint64_t a37, void *a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, char a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,uint64_t a62)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 232);
  HTTP3Fields::~HTTP3Fields(v62);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  _Block_object_dispose(&a30, 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a34);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a36);
  HTTP3Fields::~HTTP3Fields((HTTP3Fields *)&a38);

  _Unwind_Resume(a1);
}

void HTTP3Stream::closeAndClearHandler(HTTP3Stream *this)
{
  uint64_t v3 = (char *)this + 96;
  uint64_t v2 = *((void *)this + 12);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 64LL))(v2);
    __int128 v8 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v8);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)&v8 + 1);
    if (*((void *)&v8 + 1))
    {
      uint64_t v5 = (unint64_t *)(*((void *)&v8 + 1) + 8LL);
      do
        unint64_t v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

  *((void *)this + 14) = 0x900000004LL;
  id v7 = (void *)*((void *)this + 41);
  *((void *)this + 41) = 0LL;

  HTTP3Stream::_cleanupStream((uint64_t)this, 268LL, 0);
}

void HTTP3Stream::updateScheduling(HTTP3Stream *this, const CoreSchedulingSet *a2)
{
  uint64_t v4 = (char *)this + 312;
  uint64_t v5 = *((void *)this + 39);
  if (!v5)
  {
    BOOL v6 = 0LL;
    if (!a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  BOOL v6 = *(_DWORD *)(v5 + 40) != 0;
  if (a2) {
LABEL_3:
  }
    (*(void (**)(const CoreSchedulingSet *))(*(void *)a2 + 40LL))(a2);
LABEL_4:
  *(void *)&__int128 v19 = a2;
  id v7 = operator new(0x20uLL);
  *id v7 = off_189C14168;
  v7[1] = 0LL;
  v7[2] = 0LL;
  v7[3] = a2;
  *((void *)&v19 + 1) = v7;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v4, &v19);
  __int128 v8 = (std::__shared_weak_count *)*((void *)&v19 + 1);
  if (*((void *)&v19 + 1))
  {
    uint64_t v9 = (unint64_t *)(*((void *)&v19 + 1) + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  uint64_t v11 = *((void *)this + 12);
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 13);
  *(void *)&__int128 v19 = v11;
  *((void *)&v19 + 1) = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  if (v11) {
    (*(void (**)(uint64_t, const CoreSchedulingSet *, BOOL))(*(void *)v11 + 40LL))(v11, a2, v6);
  }
  if (v12)
  {
    BOOL v15 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  char v17 = *((_BYTE *)this + 127);
  char v18 = *((_BYTE *)this + 128);
  *(_WORD *)((char *)this + 127) = 0;
  if ((v17 & 1) != 0) {
    HTTP3Stream::_read(this, 0);
  }
  if ((v18 & 1) != 0) {
    HTTP3Stream::_protocolCallback(this);
  }
}

void sub_182A99F5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HTTP3Stream::setPriorityHint(HTTP3Stream *this, float a2, int a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (a2 >= 0.5) {
    float v5 = (float)((float)(1.0 - a2) * 20.0) / 3.0;
  }
  else {
    float v5 = ceilf((float)(0.7 - a2) * 10.0);
  }
  int v6 = (int)v5;
  if (*((unsigned __int8 *)this + 124) != (int)v5 || *((unsigned __int8 *)this + 125) != a3)
  {
    *((_BYTE *)this + 124) = v6;
    *((_BYTE *)this + 125) = a3;
    if (!*((_BYTE *)this + 129) && (*((_BYTE *)this + 126) || *((void *)this + 42) != -1LL))
    {
      id v7 = (std::__shared_weak_count *)*((void *)this + 7);
      if (v7)
      {
        __int128 v8 = std::__shared_weak_count::lock(v7);
        if (v8)
        {
          unint64_t v10 = v8;
          uint64_t v11 = *((void *)this + 6);
          if (v11)
          {
            int v12 = *((unsigned __int8 *)this + 126);
            uint64_t v13 = 168LL;
            if (!*((_BYTE *)this + 126)) {
              uint64_t v13 = 336LL;
            }
            size_t v14 = QUICUtilities::quic_vle_encode(*(void *)((char *)this + v13), &__src, v9);
            memcpy(__dst, &__src, v14);
            BOOL v15 = &__dst[v14];
            *(_WORD *)BOOL v15 = 15733;
            v15[2] = v6 + 48;
            if (a3)
            {
              strcpy(v15 + 4, " i");
              char v16 = 44;
              uint64_t v17 = 6LL;
            }

            else
            {
              char v16 = 0;
              uint64_t v17 = 3LL;
            }

            v15[3] = v16;
            dispatch_data_t v18 = dispatch_data_create(__dst, v17 + v14, 0LL, 0LL);
            if (v12) {
              unint64_t v19 = 984833LL;
            }
            else {
              unint64_t v19 = 984832LL;
            }
            HTTP3Framer::writeFrame(*(void *)(v11 + 1024), v19, v18, 0, &__block_literal_global_17_5218);
          }

          p_shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            unint64_t v21 = __ldaxr(p_shared_owners);
          while (__stlxr(v21 - 1, p_shared_owners));
          if (!v21)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
      }
    }
  }

void sub_182A9A174( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t HTTP3Stream::rawBytesSent(HTTP3Stream *this)
{
  uint64_t v1 = *((void *)this + 43);
  if (v1) {
    return *(void *)(v1 + 112) + *(void *)(v1 + 96);
  }
  else {
    return 0LL;
  }
}

uint64_t HTTP3Stream::rawBytesReceived(HTTP3Stream *this)
{
  uint64_t v1 = *((void *)this + 43);
  if (v1) {
    return *(void *)(v1 + 136) + *(void *)(v1 + 120);
  }
  else {
    return 0LL;
  }
}

uint64_t HTTP3Stream::getConnectionIdentifier(HTTP3Stream *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)this + 6);
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    unint64_t v7 = __ldaxr(p_shared_owners);
  while (__stlxr(v7 - 1, p_shared_owners));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v4);
    if (v5) {
      return v5;
    }
    return 0LL;
  }

  if (!v5) {
    return 0LL;
  }
  return v5;
}

HTTP3Stream *HTTP3Stream::copyTrust(std::__shared_weak_count **this)
{
  uint64_t v1 = (HTTP3Stream *)this;
  uint64_t v2 = this[7];
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  uint64_t v5 = *((void *)v1 + 6);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 1008);
    if (v6) {
      uint64_t v1 = (HTTP3Stream *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 216LL))(v6, &unk_18C5AE010);
    }
    else {
      uint64_t v1 = 0LL;
    }
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (v10) {
      return v1;
    }
  }

  else
  {
    unint64_t v7 = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (v8) {
      return 0LL;
    }
  }

  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  if (!v5) {
    return 0LL;
  }
  return v1;
}

void sub_182A9A320( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *HTTP3Stream::setProxy(uint64_t a1, uint64_t *a2)
{
  return std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(a1 + 280), *a2, a2[1]);
}

uint64_t HTTP3Stream::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 288);
  *a2 = *(void *)(this + 280);
  a2[1] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return this;
}

void HTTP3Stream::setTransactionMetrics(id *this, __CFN_TransactionMetrics *a2)
{
}

void HTTP3Stream::_read(HTTP3Stream *this, char a2)
{
  uint64_t v3 = *((void *)this + 39);
  if (v3 && *(_DWORD *)(v3 + 40))
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v40,  *((void *)this + 1),  *((std::__shared_weak_count **)this + 2));
    uint64_t v36 = 0LL;
    v37 = &v36;
    uint64_t v38 = 0x2020000000LL;
    char v39 = a2;
    uint64_t v5 = MEMORY[0x1895F87A8];
    do
    {
      uint64_t v32 = 0LL;
      v33 = &v32;
      uint64_t v34 = 0x2020000000LL;
      char v35 = 1;
      uint64_t v28 = 0LL;
      uint64_t v29 = &v28;
      uint64_t v30 = 0x2020000000LL;
      char v31 = 1;
      uint64_t v6 = *((void *)this + 3);
      v26[0] = v5;
      v26[1] = 3321888768LL;
      v26[2] = ___ZN11HTTP3Stream5_readEb_block_invoke;
      v26[3] = &unk_189C093E0;
      v26[7] = v40;
      v27 = v41;
      if (v41)
      {
        p_shared_owners = (unint64_t *)&v41->__shared_owners_;
        do
          unint64_t v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }

      v26[4] = &v32;
      v26[5] = &v36;
      v26[6] = &v28;
      uint64_t v9 = v26;
      if (*(_BYTE *)(v6 + 72)) {
        __assert_rtn("read", "HTTP3Frame.mm", 210, "!_processingReadCall");
      }
      *(_BYTE *)(v6 + 72) = 1;
      std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v46,  *(void *)v6,  *(std::__shared_weak_count **)(v6 + 8));
      v42[0] = v5;
      v42[1] = 3321888768LL;
      v42[2] = ___ZN11HTTP3Framer4readEU13block_pointerFvN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamErrorE_block_invoke;
      v42[3] = &unk_189C031C8;
      uint64_t v44 = v46;
      v45 = v47;
      if (v47)
      {
        unint64_t v10 = (unint64_t *)&v47->__shared_owners_;
        do
          unint64_t v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }

      int v12 = v9;
      id v43 = v12;
      HTTP3Framer::_read(v6, v42);

      uint64_t v13 = v45;
      if (v45)
      {
        size_t v14 = (unint64_t *)&v45->__shared_owners_;
        do
          unint64_t v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }

      char v16 = v47;
      if (v47)
      {
        uint64_t v17 = (unint64_t *)&v47->__shared_owners_;
        do
          unint64_t v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }

      *((_BYTE *)v33 + 24) = 0;
      int v19 = *((unsigned __int8 *)v29 + 24);
      uint64_t v20 = v27;
      if (v27)
      {
        unint64_t v21 = (unint64_t *)&v27->__shared_owners_;
        do
          unint64_t v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }

      _Block_object_dispose(&v28, 8);
      _Block_object_dispose(&v32, 8);
    }

    while (!v19);
    if (*((_BYTE *)v37 + 24)) {
      HTTP3Stream::_protocolCallback(this);
    }
    _Block_object_dispose(&v36, 8);
    v23 = v41;
    if (v41)
    {
      uint64_t v24 = (unint64_t *)&v41->__shared_owners_;
      do
        unint64_t v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
  }

  else
  {
    *((_BYTE *)this + 127) = 1;
  }

void sub_182A9A66C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

void HTTP3Stream::_protocolCallback(HTTP3Stream *this)
{
  uint64_t v2 = (void (**)(void, void, void, void))*((void *)this + 41);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 39);
    if (v3 && *(_DWORD *)(v3 + 40))
    {
      int v4 = *((_DWORD *)this + 68);
      if (v4) {
        uint64_t v5 = (char *)this + 264;
      }
      else {
        uint64_t v5 = 0LL;
      }
      uint64_t v6 = *((void *)this + 10);
      if (v6)
      {
        uint64_t v7 = *((void *)this + 20);
        if (!v7
          || (v2[2](v2, v6 - 16, v7, 0LL),
              unint64_t v8 = (void *)*((void *)this + 20),
              *((void *)this + 20) = 0LL,
              v8,
              (uint64_t v2 = (void (**)(void, void, void, void))*((void *)this + 41)) != 0LL))
        {
          if (*((_DWORD *)this + 28) == 4 && *((_DWORD *)this + 29) == 9 || *((_DWORD *)this + 68))
          {
            unint64_t v11 = (void (**)(id, uint64_t, void, char *))_Block_copy(v2);
            uint64_t v9 = (void *)*((void *)this + 41);
            *((void *)this + 41) = 0LL;

            v11[2](v11, *((void *)this + 10) - 16LL, 0LL, v5);
LABEL_18:
          }
        }
      }

      else if (v4)
      {
        unint64_t v11 = (void (**)(id, uint64_t, void, char *))_Block_copy(v2);
        unint64_t v10 = (void *)*((void *)this + 41);
        *((void *)this + 41) = 0LL;

        v11[2](v11, 0LL, 0LL, (char *)this + 264);
        goto LABEL_18;
      }
    }

    else
    {
      *((_BYTE *)this + 128) = 1;
    }
  }

void sub_182A9A808( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void ___ZN11HTTP3Stream5_readEb_block_invoke( void *a1, uint64_t *a2, void *a3, uint64_t a4, CFIndex a5, uint64_t a6)
{
  uint64_t v101 = *MEMORY[0x1895F89C0];
  id v11 = a3;
  uint64_t v12 = a1[7];
  uint64_t v14 = *a2;
  uint64_t v13 = a2[1];
  uint64_t v15 = a2[2];
  data2 = (dispatch_data_s *)v11;
  if ((_DWORD)a6)
  {
    char v16 = *(std::__shared_weak_count **)(v12 + 56);
    if (v16)
    {
      uint64_t v17 = std::__shared_weak_count::lock(v16);
      *(void *)v90 = v17;
      if (v17)
      {
        unint64_t v18 = v17;
        int v19 = *(HTTP3Connection **)(v12 + 48);
        uint64_t v89 = (uint64_t)v19;
        if (v19)
        {
          v102.domain = a5;
          *(void *)&v102.error = a6;
          if (HTTP3Connection::checkAndPerformFallback(v19, v102))
          {
            CFN_LOG_h3stream();
            uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v21 = *(void *)(v12 + 336);
              uint64_t v22 = *(void *)(v12 + 352);
              *(_DWORD *)buf = 134218498;
              *(void *)&buf[4] = v12;
              *(_WORD *)&buf[12] = 2048;
              *(void *)&buf[14] = v21;
              *(_WORD *)&buf[22] = 2114;
              *(void *)&buf[24] = v22;
              _os_log_impl( &dword_18298D000,  v20,  OS_LOG_TYPE_DEFAULT,  "%p ID=%llu %{public}@ fallback triggered",  buf,  0x20u);
            }

            p_shared_owners = (unint64_t *)&v18->__shared_owners_;
            do
              unint64_t v24 = __ldaxr(p_shared_owners);
            while (__stlxr(v24 - 1, p_shared_owners));
            if (!v24)
            {
              ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
              unint64_t v25 = v18;
LABEL_43:
              std::__shared_weak_count::__release_weak(v25);
            }

            goto LABEL_72;
          }
        }

        unint64_t v26 = (unint64_t *)&v18->__shared_owners_;
        do
          unint64_t v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
    }
  }

  dispatch_data_t subrange = data2;
  if (*(_DWORD *)(v12 + 116) == 9) {
    goto LABEL_118;
  }
  if (data2)
  {
    uint64_t v29 = *(std::__shared_weak_count **)(v12 + 56);
    if (v29)
    {
      uint64_t v30 = std::__shared_weak_count::lock(v29);
      if (v30)
      {
        char v31 = v30;
        uint64_t v32 = *(HTTP3Connection **)(v12 + 48);
        if (v32 && *((void *)v32 + 124)) {
          HTTP3Connection::_stopStallRecovery(v32);
        }
        v33 = (unint64_t *)&v31->__shared_owners_;
        do
          unint64_t v34 = __ldaxr(v33);
        while (__stlxr(v34 - 1, v33));
        if (!v34)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }
    }

    switch(v14)
    {
      case 0LL:
        unsigned int v35 = *(_DWORD *)(v12 + 116);
        dispatch_data_t subrange = data2;
        if (v35 > 9) {
          goto LABEL_89;
        }
        if (!v35)
        {
          *(void *)buf = 0LL;
          *(void *)&buf[8] = 0LL;
          v56 = *(std::__shared_weak_count **)(v12 + 56);
          if (!v56) {
            goto LABEL_71;
          }
          *(void *)&buf[8] = std::__shared_weak_count::lock(v56);
          if (!*(void *)&buf[8]) {
            goto LABEL_71;
          }
          uint64_t v47 = *(void *)(v12 + 48);
          *(void *)buf = v47;
          if (!v47) {
            goto LABEL_71;
          }
          goto LABEL_70;
        }

        if (v35 != 3)
        {
          applier[6] = 0LL;
          __int128 v99 = 0u;
          __int128 v100 = 0u;
          __int128 v98 = 0u;
          memset(buf, 0, sizeof(buf));
          os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_ERROR);
          LODWORD(v89) = 67110144;
          HIDWORD(v89) = v35;
          *(_WORD *)v90 = 2048;
          *(void *)&v90[2] = 0LL;
          __int16 v91 = 2048;
          uint64_t v92 = v13;
          __int16 v93 = 2048;
          size_t size = dispatch_data_get_size(data2);
          __int16 v95 = 1024;
          int v96 = a4;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_153:
          __assert_rtn("_received", "HTTP3Stream.mm", v48, "false");
        }

        uint64_t v36 = *(dispatch_data_s **)(v12 + 160);
        if (v36) {
          dispatch_data_t concat = dispatch_data_create_concat(v36, data2);
        }
        else {
          dispatch_data_t concat = data2;
        }
        v61 = *(void **)(v12 + 160);
        *(void *)(v12 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = concat;

        uint64_t v62 = *(void *)(v12 + 344);
        dispatch_data_t subrange = data2;
        if (v62)
        {
          size_t v63 = dispatch_data_get_size(data2);
          if ((_DWORD)a4) {
            uint64_t v64 = v15;
          }
          else {
            uint64_t v64 = 0LL;
          }
          *(void *)(v62 + 136) += v63 + v64;
          goto LABEL_88;
        }

        goto LABEL_89;
      case 1LL:
        dispatch_data_t subrange = data2;
        int v48 = 1046;
        switch(*(_DWORD *)(v12 + 116))
        {
          case 0:
            uint64_t v49 = *(void *)(v12 + 344);
            if (v49) {
              *(void *)(v49 + 200) = 0x7FF8000000000000LL;
            }
            *(_DWORD *)(v12 + 116) = 1;
            *(_DWORD *)(v12 + 248) = -1;
            Instance = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
            if (Instance)
            {
              *((void *)Instance + 2) = 0LL;
              *((void *)Instance + 3) = 0LL;
              Instance = (HTTPHeaderDict *)((char *)Instance + 16);
            }

            HTTPHeaderDict::HTTPHeaderDict(Instance);
            uint64_t v51 = *(void *)(v12 + 256);
            *(void *)(v12 + 256) = v52;
            if (v51) {
              CFRelease((CFTypeRef)(v51 - 16));
            }
            goto LABEL_61;
          case 1:
LABEL_61:
            if ((_DWORD)a4)
            {
              uint64_t v53 = *(void *)(v12 + 344);
              if (v53) {
                *(void *)(v53 + 120) += v13 + v15;
              }
            }

            goto LABEL_79;
          case 2:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
            goto LABEL_153;
          case 3:
            *(_DWORD *)(v12 + 116) = 4;
            v57 = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
            if (v57)
            {
              *((void *)v57 + 2) = 0LL;
              *((void *)v57 + 3) = 0LL;
              v57 = (HTTPHeaderDict *)((char *)v57 + 16);
            }

            HTTPHeaderDict::HTTPHeaderDict(v57);
            uint64_t v58 = *(void *)(v12 + 256);
            *(void *)(v12 + 256) = v59;
            if (v58) {
              CFRelease((CFTypeRef)(v58 - 16));
            }
            goto LABEL_79;
          case 4:
LABEL_79:
            int v60 = HTTP3Stream::_handleHeaders(v12, v13, data2, a4);
            dispatch_data_t subrange = data2;
            if (v60) {
              goto LABEL_80;
            }
            goto LABEL_89;
          default:
            goto LABEL_89;
        }

      case 2LL:
      case 6LL:
      case 8LL:
      case 9LL:
      case 10LL:
      case 11LL:
      case 12LL:
        goto LABEL_44;
      case 3LL:
      case 4LL:
      case 7LL:
      case 13LL:
        goto LABEL_35;
      case 5LL:
        if (*(_BYTE *)(v12 + 126))
        {
          *(void *)buf = 0LL;
          *(void *)&buf[8] = 0LL;
          uint64_t v46 = *(std::__shared_weak_count **)(v12 + 56);
          if (v46)
          {
            *(void *)&buf[8] = std::__shared_weak_count::lock(v46);
            if (*(void *)&buf[8])
            {
              uint64_t v47 = *(void *)(v12 + 48);
              *(void *)buf = v47;
              if (v47)
              {
LABEL_70:
                *(void *)(v47 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 4LL;
                *(_DWORD *)(v47 + 1168) = -1;
                HTTP3Connection::_cleanupConnection((HTTP3Connection *)v47, 261LL, 0LL);
                HTTP3Connection::reportServerProtocolViolation(*(uint64_t *)buf, 48, *(void *)(v12 + 336));
              }
            }
          }

LABEL_118:
LABEL_119:
  HTTP3Stream::_protocolCallback((HTTP3Stream *)a1[7]);
  v65 = a1 + 5;
LABEL_120:
  *(_BYTE *)(*(void *)(*v65 + 8LL) + 24LL) = 0;
LABEL_121:
}

          CFWriteStreamSetProperty(v38, *v39, v36);
          uint64_t v36 = *(const void **)v37;
          *(void *)v37 = 0LL;
          if (!v36) {
            goto LABEL_122;
          }
          goto LABEL_121;
        }

void sub_182A9B3D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_56c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(result + 64) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_56c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
}

id CFN_LOG_h3stream(void)
{
  return (id)CFN_LOG_h3stream(void)::log;
}

uint64_t HTTP3Stream::_handleHeaders(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v112 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a3;
  size_t size = dispatch_data_get_size(v7);
  uint64_t v99 = 0LL;
  __int128 v100 = &v99;
  uint64_t v101 = 0x2020000000LL;
  int v102 = 2;
  uint64_t v95 = 0LL;
  int v96 = &v95;
  uint64_t v97 = 0x2020000000LL;
  uint64_t v98 = 0LL;
  v94[0] = MEMORY[0x1895F87A8];
  v94[1] = 3221225472LL;
  v94[2] = ___ZN11HTTP3Stream14_handleHeadersEmPU27objcproto16OS_dispatch_data8NSObjectb_block_invoke;
  v94[3] = &unk_189C093B8;
  v94[6] = a1;
  v94[7] = a2;
  v94[4] = &v99;
  v94[5] = &v95;
  dispatch_data_apply(v7, v94);
  switch(*((_DWORD *)v100 + 6))
  {
    case 0:
      if (!(_DWORD)a4 || v96[3] < size)
      {
        uint64_t v9 = *(std::__shared_weak_count **)(a1 + 56);
        if (v9)
        {
          unint64_t v10 = std::__shared_weak_count::lock(v9);
          *(void *)&buf[8] = v10;
          if (v10)
          {
            id v11 = v10;
            uint64_t v12 = *(void *)(a1 + 48);
            *(void *)buf = v12;
            if (v12)
            {
              *(void *)(v12 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 4LL;
              *(_DWORD *)(v12 + 1168) = -1;
              HTTP3Connection::_cleanupConnection((HTTP3Connection *)v12, 512LL, 0LL);
              HTTP3Connection::reportServerProtocolViolation(v12, 129, *(void *)(a1 + 336));
            }

            p_shared_owners = (unint64_t *)&v11->__shared_owners_;
            do
              unint64_t v14 = __ldaxr(p_shared_owners);
            while (__stlxr(v14 - 1, p_shared_owners));
LABEL_27:
            if (!v14)
            {
              ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
              std::__shared_weak_count::__release_weak(v11);
            }

            goto LABEL_29;
          }
        }

        goto LABEL_29;
      }

      int v29 = *(_DWORD *)(a1 + 116);
      switch(v29)
      {
        case 7:
          if (!*(_BYTE *)(a1 + 177))
          {
            uint64_t v52 = *(std::__shared_weak_count **)(a1 + 56);
            if (v52)
            {
              uint64_t v53 = std::__shared_weak_count::lock(v52);
              *(void *)&buf[8] = v53;
              if (v53)
              {
                int v54 = v53;
                uint64_t v55 = *(void *)(a1 + 48);
                *(void *)buf = v55;
                if (v55) {
                  HTTP2ServerPush::endPromisedHeadersWithCheckTheCacheBlock( (uint64_t *)(v55 + 624),  *(_DWORD *)(a1 + 168));
                }
                v56 = (unint64_t *)&v54->__shared_owners_;
                do
                  unint64_t v57 = __ldaxr(v56);
                while (__stlxr(v57 - 1, v56));
                if (!v57)
                {
                  ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
                  std::__shared_weak_count::__release_weak(v54);
                }
              }
            }
          }

          a4 = 0LL;
          *(_BYTE *)(a1 + 177) = 0;
          int v51 = *(_DWORD *)(a1 + 120);
          goto LABEL_77;
        case 4:
          CFMutableDictionaryRef v49 = HTTPHeaderDict::copyAsOrdinaryDict( *(CFDictionaryRef **)(a1 + 256),  (const __CFAllocator *)*MEMORY[0x189604DB0]);
          uint64_t v50 = *(void *)(a1 + 256);
          *(void *)(a1 + 256) = 0LL;
          if (v50) {
            CFRelease((CFTypeRef)(v50 - 16));
          }
          HTTPMessage::setTrailerFields(*(HTTPMessage **)(a1 + 80), v49);
          *(_DWORD *)(a1 + 116) = 9;

          goto LABEL_74;
        case 1:
          int v30 = *(_DWORD *)(a1 + 248);
          if (v30 == -1)
          {
            *(void *)(a1 + 264) = 4LL;
            *(_DWORD *)(a1 + 272) = -1;
            HTTP3Stream::_cleanupStream(a1, 270LL, 0);
            HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
            uint64_t v58 = *(std::__shared_weak_count **)(a1 + 56);
            if (v58)
            {
              uint64_t v59 = std::__shared_weak_count::lock(v58);
              *(void *)&buf[8] = v59;
              if (v59)
              {
                id v11 = v59;
                uint64_t v60 = *(void *)(a1 + 48);
                *(void *)buf = v60;
                if (v60) {
                  HTTP3Connection::reportServerProtocolViolation(v60, 51, *(void *)(a1 + 336));
                }
                v61 = (unint64_t *)&v11->__shared_owners_;
                do
                  unint64_t v14 = __ldaxr(v61);
                while (__stlxr(v14 - 1, v61));
                goto LABEL_27;
              }
            }

            goto LABEL_29;
          }

          if ((v30 - 100) <= 0x63)
          {
            if (v30 == 100) {
              HTTP3Stream::_100ContinueReceived((HTTP3Stream *)a1);
            }
            uint64_t v31 = *(void *)(a1 + 296);
            if (v31)
            {
              Instance = (_OWORD *)_CFRuntimeCreateInstance();
              v33 = (HTTPMessage *)Instance;
              if (Instance)
              {
                Instance[1] = 0u;
                v33 = (HTTPMessage *)(Instance + 1);
                Instance[18] = 0u;
                Instance[19] = 0u;
                Instance[16] = 0u;
                Instance[17] = 0u;
                Instance[14] = 0u;
                Instance[15] = 0u;
                Instance[12] = 0u;
                Instance[13] = 0u;
                Instance[10] = 0u;
                Instance[11] = 0u;
                Instance[8] = 0u;
                Instance[9] = 0u;
                Instance[6] = 0u;
                Instance[7] = 0u;
                Instance[4] = 0u;
                Instance[5] = 0u;
                Instance[2] = 0u;
                Instance[3] = 0u;
              }

              int v34 = *(_DWORD *)(a1 + 248);
              HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v103, @"HTTP/3.0");
              HTTPMessage::HTTPMessage(v33, "httpresponse", cf);
              *(void *)v33 = &off_189C15750;
              *((void *)v33 + 1) = &unk_189C157C0;
              *((void *)v33 + 2) = &unk_189C157E0;
              *((_DWORD *)v33 + 32) = v34;
              *((void *)v33 + 17) = 0LL;
              *((_OWORD *)v33 + 10) = 0u;
              *((_OWORD *)v33 + 11) = 0u;
              *((_OWORD *)v33 + 12) = 0u;
              *((_OWORD *)v33 + 13) = 0u;
              *((_OWORD *)v33 + 14) = 0u;
              *((_OWORD *)v33 + 15) = 0u;
              *((_OWORD *)v33 + 16) = 0u;
              *((_OWORD *)v33 + 17) = 0u;
              *((_BYTE *)v33 + 296) = 0;
              *(void *)buf = v33;
              unsigned int v35 = operator new(0x20uLL);
              *unsigned int v35 = off_189C16E78;
              v35[1] = 0LL;
              v35[2] = 0LL;
              v35[3] = v33;
              *(void *)&buf[8] = v35;
              std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 80, (__int128 *)buf);
              uint64_t v36 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8])
              {
                v37 = (unint64_t *)(*(void *)&buf[8] + 8LL);
                do
                  unint64_t v38 = __ldaxr(v37);
                while (__stlxr(v38 - 1, v37));
                if (!v38)
                {
                  ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
                  std::__shared_weak_count::__release_weak(v36);
                }
              }

              CFStreamError v103 = off_189C16E38;
              if (cf) {
                CFRelease(cf);
              }
              HTTPMessage::ensureParserFinished(*(HTTPMessage **)(a1 + 80));
              char v39 = *(HTTPResponseMessage **)(a1 + 80);
              HTTPResponseMessage::setResponseURL(v39, v40, 0);
              HTTPMessage::replaceHeaderFieldsWithExternalHeaderDict( *(HTTPMessage **)(a1 + 80),  *(HTTPHeaderDict **)(a1 + 256));
              uint64_t v41 = *(std::__shared_weak_count **)(a1 + 88);
              *(void *)buf = *(void *)(a1 + 80);
              *(void *)&buf[8] = v41;
              if (v41)
              {
                v42 = (unint64_t *)&v41->__shared_owners_;
                do
                  unint64_t v43 = __ldxr(v42);
                while (__stxr(v43 + 1, v42));
              }

              HTTPProtocol::handleInformationalResponse((void *)(v31 - 176), (uint64_t)buf);
              if (v41)
              {
                uint64_t v44 = (unint64_t *)&v41->__shared_owners_;
                do
                  unint64_t v45 = __ldaxr(v44);
                while (__stlxr(v45 - 1, v44));
                if (!v45)
                {
                  ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
                  std::__shared_weak_count::__release_weak(v41);
                }
              }
            }

            *(_DWORD *)(a1 + 116) = 0;
            *(_DWORD *)(a1 + 248) = -1;
            uint64_t v46 = (HTTPHeaderDict *)_CFRuntimeCreateInstance();
            if (v46)
            {
              *((void *)v46 + 2) = 0LL;
              *((void *)v46 + 3) = 0LL;
              uint64_t v46 = (HTTPHeaderDict *)((char *)v46 + 16);
            }

            HTTPHeaderDict::HTTPHeaderDict(v46);
            uint64_t v47 = *(void *)(a1 + 256);
            *(void *)(a1 + 256) = v48;
            if (v47) {
              CFRelease((CFTypeRef)(v47 - 16));
            }
LABEL_74:
            a4 = 0LL;
            goto LABEL_37;
          }

          uint64_t v62 = (_OWORD *)_CFRuntimeCreateInstance();
          size_t v63 = (HTTPMessage *)v62;
          if (v62)
          {
            v62[1] = 0u;
            size_t v63 = (HTTPMessage *)(v62 + 1);
            v62[18] = 0u;
            v62[19] = 0u;
            v62[16] = 0u;
            v62[17] = 0u;
            v62[14] = 0u;
            v62[15] = 0u;
            v62[12] = 0u;
            v62[13] = 0u;
            v62[10] = 0u;
            v62[11] = 0u;
            v62[8] = 0u;
            v62[9] = 0u;
            v62[6] = 0u;
            v62[7] = 0u;
            v62[4] = 0u;
            v62[5] = 0u;
            v62[2] = 0u;
            v62[3] = 0u;
          }

          int v64 = *(_DWORD *)(a1 + 248);
          HTTPVersionMixedValue::HTTPVersionMixedValue((HTTPVersionMixedValue *)&v103, @"HTTP/3.0");
          HTTPMessage::HTTPMessage(v63, "httpresponse", cf);
          *(void *)size_t v63 = &off_189C15750;
          *((void *)v63 + 1) = &unk_189C157C0;
          *((void *)v63 + 2) = &unk_189C157E0;
          *((_DWORD *)v63 + 32) = v64;
          *((void *)v63 + 17) = 0LL;
          *((_OWORD *)v63 + 10) = 0u;
          *((_OWORD *)v63 + 11) = 0u;
          *((_OWORD *)v63 + 12) = 0u;
          *((_OWORD *)v63 + 13) = 0u;
          *((_OWORD *)v63 + 14) = 0u;
          *((_OWORD *)v63 + 15) = 0u;
          *((_OWORD *)v63 + 16) = 0u;
          *((_OWORD *)v63 + 17) = 0u;
          *((_BYTE *)v63 + 296) = 0;
          *(void *)buf = v63;
          v65 = operator new(0x20uLL);
          void *v65 = off_189C16E78;
          v65[1] = 0LL;
          v65[2] = 0LL;
          v65[3] = v63;
          *(void *)&buf[8] = v65;
          int v66 = (HTTPMessage **)(a1 + 80);
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](a1 + 80, (__int128 *)buf);
          int v67 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8])
          {
            uint64_t v68 = (unint64_t *)(*(void *)&buf[8] + 8LL);
            do
              unint64_t v69 = __ldaxr(v68);
            while (__stlxr(v69 - 1, v68));
            if (!v69)
            {
              ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
              std::__shared_weak_count::__release_weak(v67);
            }
          }

          CFStreamError v103 = off_189C16E38;
          if (cf) {
            CFRelease(cf);
          }
          HTTPMessage::ensureParserFinished(*v66);
          id v70 = *(HTTPResponseMessage **)(a1 + 80);
          HTTPResponseMessage::setResponseURL(v70, v71, 0);
          HTTPMessage::replaceHeaderFieldsWithExternalHeaderDict( *(HTTPMessage **)(a1 + 80),  *(HTTPHeaderDict **)(a1 + 256));
          uint64_t v72 = *(void *)(a1 + 256);
          *(void *)(a1 + 256) = 0LL;
          if (v72) {
            CFRelease((CFTypeRef)(v72 - 16));
          }
          if ((HTTPResponseMessage::isValid((os_unfair_lock_s *)*v66) & 1) == 0)
          {
            *(void *)(a1 + 264) = 4LL;
            *(_DWORD *)(a1 + 272) = -1;
            HTTP3Stream::_cleanupStream(a1, 270LL, 0);
            HTTP3Stream::_protocolCallback((HTTP3Stream *)a1);
            int v87 = *(std::__shared_weak_count **)(a1 + 56);
            if (v87)
            {
              uint64_t v88 = std::__shared_weak_count::lock(v87);
              *(void *)&buf[8] = v88;
              if (v88)
              {
                id v11 = v88;
                uint64_t v89 = *(void *)(a1 + 48);
                *(void *)buf = v89;
                if (v89) {
                  HTTP3Connection::reportServerProtocolViolation(v89, 56, *(void *)(a1 + 336));
                }
                v90 = (unint64_t *)&v11->__shared_owners_;
                do
                  unint64_t v14 = __ldaxr(v90);
                while (__stlxr(v14 - 1, v90));
                goto LABEL_27;
              }
            }

void sub_182A9C0E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, CFTypeRef cf)
{
  _Unwind_Resume(a1);
}

BOOL ___ZN11HTTP3Stream9_receivedEN2H313FrameMetadataEPU27objcproto16OS_dispatch_data8NSObjectb13CFStreamError_block_invoke( uint64_t a1, int a2, int a3, void *__src, size_t a5)
{
  uint64_t v6 = *(void *)(a1 + 40);
  unsigned int v9 = *(unsigned __int8 *)(v6 + 176);
  unint64_t v8 = (unint64_t *)(v6 + 176);
  uint64_t v7 = v9;
  unint64_t v10 = 8LL - v9;
  if (v10 >= a5) {
    size_t v11 = a5;
  }
  else {
    size_t v11 = v10;
  }
  memcpy((char *)v8 + v7 - 8, __src, v11);
  unsigned __int8 v12 = *(_BYTE *)v8 + v11;
  *(_BYTE *)unint64_t v8 = v12;
  unint64_t v15 = v12;
  char v16 = v8 - 1;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = QUICUtilities::quic_vle_decode( (QUICUtilities *)&v16,  (const unsigned __int8 **)&v15,  v8 - 1,  v8,  v13);
  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

uint64_t HTTP3Stream::_translateError(HTTP3Stream *this, CFStreamError a2, int a3)
{
  uint64_t v3 = *(void *)&a2.error;
  if (a2.error)
  {
    uint64_t v6 = *(nw_content_context **)(*((void *)this + 3) + 48LL);
    uint64_t v7 = (nw_protocol_definition *)nw_protocol_copy_quic_connection_definition();
    nw_protocol_metadata_t v8 = nw_content_context_copy_protocol_metadata(v6, v7);

    unsigned int v9 = (void *)nw_quic_connection_copy_stream_metadata();
    uint64_t application_error = nw_quic_stream_get_application_error();

    uint64_t v3 = 5LL;
    switch(application_error)
    {
      case 257LL:
      case 259LL:
      case 260LL:
      case 261LL:
      case 262LL:
      case 264LL:
      case 265LL:
      case 266LL:
      case 270LL:
      case 271LL:
        return 4LL;
      case 258LL:
      case 268LL:
      case 269LL:
        return 3LL;
      case 263LL:
        return v3;
      case 267LL:
        return 6LL;
      case 272LL:
        return 7LL;
      default:
        if (application_error != -1)
        {
          if (a3) {
            return 1LL;
          }
          else {
            return 3LL;
          }
        }

        unsigned __int8 v12 = (std::__shared_weak_count *)*((void *)this + 7);
        if (!v12) {
          return 3LL;
        }
        uint64_t v13 = std::__shared_weak_count::lock(v12);
        if (!v13) {
          return 3LL;
        }
        unint64_t v14 = v13;
        uint64_t v15 = *((void *)this + 6);
        if (!v15) {
          goto LABEL_22;
        }
        uint64_t v16 = *(void *)(v15 + 1008);
        if (!v16
          || (*(_BYTE *)(v15 + 920) & 4) != 0
          || (uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 120LL))(v16), v17 == -1))
        {
          uint64_t v3 = 2LL;
        }

        else if (v17 == 272)
        {
          uint64_t v3 = 7LL;
        }

        else
        {
LABEL_22:
          uint64_t v3 = 3LL;
        }

        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          unint64_t v19 = __ldaxr(p_shared_owners);
        while (__stlxr(v19 - 1, p_shared_owners));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }

        break;
    }
  }

  return v3;
}

void sub_182A9C3F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HTTP3Stream::_reportResult(HTTP3Stream *this, int a2)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 7);
  if (!v3) {
    return;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  uint64_t v16 = v5;
  if (!v5) {
    return;
  }
  uint64_t v6 = *((void *)this + 6);
  if (!v6)
  {
    uint64_t v13 = v5;
LABEL_17:
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }

    return;
  }

  uint64_t v7 = *(void *)(v6 + 1008);
  nw_protocol_metadata_t v8 = *(std::__shared_weak_count **)(v6 + 1016);
  if (v8)
  {
    unsigned int v9 = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  if (v7) {
    (*(void (**)(uint64_t, void))(*(void *)v7 + 128LL))(v7, a2 ^ 1u);
  }
  if (v8)
  {
    size_t v11 = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  uint64_t v13 = v16;
  if (v16) {
    goto LABEL_17;
  }
}

void sub_182A9C53C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

BOOL ___ZN11HTTP3Stream14_handleHeadersEmPU27objcproto16OS_dispatch_data8NSObjectb_block_invoke( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1[6];
  nw_protocol_metadata_t v8 = *(std::__shared_weak_count **)(v7 + 56);
  if (!v8 || (v10 = a1[7], (size_t v11 = std::__shared_weak_count::lock(v8)) == 0LL))
  {
    int v16 = 3;
    goto LABEL_34;
  }

  unint64_t v12 = v11;
  uint64_t v13 = *(void *)(v7 + 48);
  if (v13)
  {
    uint64_t v27 = a4;
    size_t size = 10LL;
    if (*(_BYTE *)(v7 + 130))
    {
      uint64_t v14 = *(void *)(v7 + 336);
      if (v10 > 1)
      {
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        uint64_t v37 = 0LL;
        __int128 v38 = 0u;
        __int128 v34 = 0u;
        __int128 v35 = 0u;
        memset(v29, 0, sizeof(v29));
        uint64_t v30 = v7;
        uint64_t v31 = v14;
        unint64_t v32 = v10;
        unint64_t v33 = v10;
        uint64_t v36 = parse_header_prefix;
        unint64_t v19 = *(FILE **)(v13 + 320);
        if (v19)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v19);
          fprintf(*(FILE **)(v13 + 320), "begin reading header block for stream %llu", v14);
          fputc(10, *(FILE **)(v13 + 320));
        }

        int v16 = qdec_header_process(v13 + 272, v29, &v27, a5, buffer, &size);
      }

      else
      {
        unint64_t v15 = *(FILE **)(v13 + 320);
        if (v15)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v15);
          fprintf( *(FILE **)(v13 + 320),  "header block for stream %llu is too short (%zd byte%.*s)",  v14,  v10,  v10 != 1,  "s");
          fputc(10, *(FILE **)(v13 + 320));
        }

        *(void *)(v13 + 600) = 0x10AF00000000LL;
        *(void *)(v13 + 608) = 0LL;
        *(void *)(v13 + 616) = v14;
        int v16 = 3;
      }

      *(_BYTE *)(v7 + 130) = 0;
LABEL_20:
      a5 = v27 - a4;
      if (!v16)
      {
        *(void *)(v7 + 192) = *(void *)(v7 + 184);
        uint64_t v20 = *(void *)(v7 + 344);
        uint64_t v21 = *(void *)(v13 + 1208);
        *(void *)(v13 + 1208) = 0LL;
        if (v20) {
          *(void *)(v20 + 120) += v21;
        }
        if (size)
        {
          dispatch_data_t v22 = dispatch_data_create(buffer, size, 0LL, 0LL);
          HTTP3Connection::writeDecoderStream(v13, v22);
        }

        int v16 = 0;
        *(_BYTE *)(v7 + 130) = 1;
      }

      goto LABEL_30;
    }

    uint64_t v17 = (void *)(v13 + 352);
    while (1)
    {
      uint64_t v17 = (void *)*v17;
      if (!v17) {
        break;
      }
      if (v17[4] == v7)
      {
        unint64_t v18 = *(FILE **)(v13 + 320);
        if (v18)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v18);
          fprintf(*(FILE **)(v13 + 320), "continue reading header block for stream %llu", v17[5]);
          fputc(10, *(FILE **)(v13 + 320));
        }

        int v16 = qdec_header_process(v13 + 272, v17, &v27, a5, buffer, &size);
        goto LABEL_20;
      }
    }

    v23 = *(FILE **)(v13 + 320);
    if (v23)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v23);
      fwrite("could not find header block to continue reading", 0x2FuLL, 1uLL, *(FILE **)(v13 + 320));
      fputc(10, *(FILE **)(v13 + 320));
    }

    a5 = 0LL;
  }

  int v16 = 3;
LABEL_30:
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  do
    unint64_t v25 = __ldaxr(p_shared_owners);
  while (__stlxr(v25 - 1, p_shared_owners));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }

void sub_182A9C8AC(_Unwind_Exception *a1)
{
  p_shared_owners = (unint64_t *)&v1->__shared_owners_;
  do
    unint64_t v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }

  _Unwind_Resume(a1);
}

void HTTP3Stream::_cleanupStream(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  if (!*(_BYTE *)(a1 + 129))
  {
    uint64_t v5 = *(void *)(a1 + 24);
    if (v5 && (a3 & 1) == 0) {
      HTTP3Framer::cancelStream(v5, a2);
    }
    *(_BYTE *)(a1 + 129) = 1;
    uint64_t v54 = 0LL;
    uint64_t v55 = 0LL;
    uint64_t v6 = *(std::__shared_weak_count **)(a1 + 56);
    if (v6)
    {
      uint64_t v55 = std::__shared_weak_count::lock(v6);
      if (v55)
      {
        uint64_t v7 = *(void *)(a1 + 48);
        uint64_t v54 = v7;
        if (v7)
        {
          if ((a3 & 1) == 0)
          {
            nw_protocol_metadata_t v8 = (uint64_t *)(v7 + 352);
            while (1)
            {
              nw_protocol_metadata_t v8 = (uint64_t *)*v8;
              if (!v8) {
                break;
              }
              if (v8[4] == a1)
              {
                unint64_t v9 = v8[5];
                if (v9 <= 0x3E)
                {
                  unint64_t v10 = v53;
                  char buffer = v9 | 0x40;
                  size_t v11 = *(FILE **)(v7 + 320);
                  if (v11)
                  {
                    unint64_t v12 = (FILE **)(v7 + 320);
                    goto LABEL_26;
                  }

void sub_182A9CF34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void HTTP3Stream::_100ContinueReceived(HTTP3Stream *this)
{
  if (*((_DWORD *)this + 28) == 1)
  {
    *((_DWORD *)this + 28) = 2;
    HTTP3Stream::_resumeRequestBody(this);
    (*(void (**)(void, void, void))(**((void **)this + 12) + 40LL))( *((void *)this + 12),  *((void *)this + 39),  0LL);
  }

  uint64_t v2 = (dispatch_source_s *)*((void *)this + 17);
  if (v2)
  {
    dispatch_source_cancel(v2);
    uint64_t v3 = (void *)*((void *)this + 17);
    *((void *)this + 17) = 0LL;
  }

void HTTP3Stream::_resumeRequestBody(HTTP3Stream *this)
{
  uint64_t v2 = *((void *)this + 12);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 13);
  uint64_t v19 = v2;
  size_t v20 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3321888768LL;
  v17[2] = ___ZN11HTTP3Stream18_resumeRequestBodyEv_block_invoke;
  v17[3] = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e47_v36__0__NSObject_OS_dispatch_data__8___qi_16B32l;
  v17[4] = v21;
  unint64_t v18 = v22;
  if (v22)
  {
    uint64_t v6 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  (*(void (**)(uint64_t, void *))(*(void *)v2 + 16LL))(v2, v17);
  nw_protocol_metadata_t v8 = v18;
  if (v18)
  {
    unint64_t v9 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  size_t v11 = v20;
  if (v20)
  {
    unint64_t v12 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  unint64_t v14 = v22;
  if (v22)
  {
    uint64_t v15 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void sub_182A9D14C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void ___ZN11HTTP3Stream18_resumeRequestBodyEv_block_invoke( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8 = *(void *)(a1 + 32);
  unint64_t v9 = a2;
  if (*(_DWORD *)(v8 + 112) == 4) {
    goto LABEL_60;
  }
  if (a5) {
    unint64_t v10 = (void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v8 + 96) + 32LL))( *(void *)(v8 + 96),  0x18C5AC4F0LL);
  }
  else {
    unint64_t v10 = 0LL;
  }
  if (v10) {
    a5 = 0;
  }
  if (v9 && (size_t size = dispatch_data_get_size(v9)) != 0)
  {
    size_t v12 = size;
    -[__CFN_TransactionMetrics requestBody:](*(void *)(v8 + 344), v9);
    ++*(void *)(v8 + 144);
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v47,  *(void *)(v8 + 8),  *(std::__shared_weak_count **)(v8 + 16));
    uint64_t v13 = *(void *)(v8 + 24);
    v56 = (void (*)(void *))MEMORY[0x1895F87A8];
    uint64_t v57 = 3321888768LL;
    unint64_t v58 = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke;
    __int16 v59 = &__block_descriptor_57_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    uint64_t v60 = v47;
    uint64_t v61 = (std::__shared_weak_count *)v48;
    if (v48)
    {
      unint64_t v14 = (unint64_t *)(v48 + 8);
      do
        unint64_t v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }

    size_t v62 = v12;
    char v63 = a5;
    HTTP3Framer::writeFrame(v13, 0LL, v9, a5, &v56);
    if (*(_DWORD *)(v8 + 112) == 2 && *(void *)(v8 + 144) >= 4uLL)
    {
      *(_DWORD *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 3;
      (*(void (**)(void))(**(void **)(v8 + 96) + 24LL))(*(void *)(v8 + 96));
    }

    unint64_t v16 = v61;
    if (v61)
    {
      p_shared_owners = (unint64_t *)&v61->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    uint64_t v19 = (std::__shared_weak_count *)v48;
    if (v48)
    {
      size_t v20 = (unint64_t *)(v48 + 8);
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }

  else if (a5)
  {
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v56,  *(void *)(v8 + 8),  *(std::__shared_weak_count **)(v8 + 16));
    uint64_t v22 = *(void *)(v8 + 24);
    uint64_t v47 = MEMORY[0x1895F87A8];
    uint64_t v48 = 3321888768LL;
    uint64_t v49 = (uint64_t)___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_28;
    uint64_t v50 = (__n128 (*)(void *, uint64_t))&__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e13_v24__0___qi_8l;
    int v51 = v56;
    uint64_t v52 = (std::__shared_weak_count *)v57;
    if (v57)
    {
      uint64_t v23 = (unint64_t *)(v57 + 8);
      do
        unint64_t v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }

    uint64_t v25 = &v47;
    nw_content_context_set_is_final(*(nw_content_context_t *)(v22 + 56), 1);
    (*(void (**)(void, void, void, void, uint64_t *))(**(void **)(v22 + 16) + 32LL))( *(void *)(v22 + 16),  *(void *)(v22 + 56),  0LL,  0LL,  v25);

    int v26 = v52;
    if (v52)
    {
      unint64_t v27 = (unint64_t *)&v52->__shared_owners_;
      do
        unint64_t v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }

    int v29 = (std::__shared_weak_count *)v57;
    if (v57)
    {
      uint64_t v30 = (unint64_t *)(v57 + 8);
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    goto LABEL_57;
  }

  if (v10)
  {
    uint64_t v47 = 0LL;
    uint64_t v48 = (uint64_t)&v47;
    uint64_t v49 = 0x6012000000LL;
    uint64_t v50 = __Block_byref_object_copy__5359;
    int v51 = __Block_byref_object_dispose__5360;
    uint64_t v52 = (std::__shared_weak_count *)&unk_182CE6F99;
    HTTP3Fields::HTTP3Fields((HTTP3Fields *)v53);
    uint64_t v32 = MEMORY[0x1895F87A8];
    v46[0] = MEMORY[0x1895F87A8];
    v46[1] = 3221225472LL;
    v46[2] = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_32;
    v46[3] = &unk_189C09390;
    v46[4] = &v47;
    [v10 enumerateKeysAndObjectsUsingBlock:v46];
    std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v44,  *(void *)(v8 + 8),  *(std::__shared_weak_count **)(v8 + 16));
    uint64_t v33 = (void *)(v48 + 48);
    v42[0] = v32;
    v42[1] = 3321888768LL;
    v42[2] = ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_2;
    v42[3] = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    void v42[4] = v44;
    unint64_t v43 = v45;
    if (v45)
    {
      __int128 v34 = (unint64_t *)&v45->__shared_owners_;
      do
        unint64_t v35 = __ldxr(v34);
      while (__stxr(v35 + 1, v34));
    }

    HTTP3Stream::_sendHEADERS((void *)v8, v33, 1, v42);
    unint64_t v36 = v43;
    if (v43)
    {
      uint64_t v37 = (unint64_t *)&v43->__shared_owners_;
      do
        unint64_t v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }

    id v39 = v45;
    if (v45)
    {
      uint64_t v40 = (unint64_t *)&v45->__shared_owners_;
      do
        unint64_t v41 = __ldaxr(v40);
      while (__stlxr(v41 - 1, v40));
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
    }

    _Block_object_dispose(&v47, 8);
    if (__p)
    {
      uint64_t v55 = __p;
      operator delete(__p);
    }

    if (v53[0])
    {
      v53[1] = v53[0];
      operator delete(v53[0]);
    }
  }

void sub_182A9D600( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, std::__shared_weak_count *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, void *__p, uint64_t a33)
{
  uint64_t v37 = *(std::__shared_weak_count **)(v35 - 88);
  if (v37)
  {
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      unint64_t v39 = __ldaxr(p_shared_owners);
    while (__stlxr(v39 - 1, p_shared_owners));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }

  if (a24)
  {
    uint64_t v40 = (unint64_t *)&a24->__shared_owners_;
    do
      unint64_t v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))a24->__on_zero_shared)(a24);
      std::__shared_weak_count::__release_weak(a24);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v8 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke( uint64_t a1, uint64_t a2, CFIndex a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 48);
  v11.domain = a3;
  *(void *)&v11.error = a4;
  uint64_t result = HTTP3Stream::_handleSendError((HTTP3Stream *)v5, v11, *(unsigned __int8 *)(a1 + 56));
  if (!(_DWORD)result)
  {
    unint64_t v8 = *(void *)(v5 + 144) - 1LL;
    *(void *)(v5 + 144) = v8;
    uint64_t v9 = *(void *)(v5 + 344);
    if (v9) {
      *(void *)(v9 + 112) += v6 + a2;
    }
    if (*(_DWORD *)(v5 + 112) == 3 && v8 <= 2)
    {
      *(_DWORD *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 2;
      return HTTP3Stream::_resumeRequestBody((HTTP3Stream *)v5);
    }
  }

  return result;
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_28( uint64_t a1, CFStreamError a2)
{
  return HTTP3Stream::_handleSendError(*(HTTP3Stream **)(a1 + 32), a2, 1);
}

__n128 __Block_byref_object_copy__5359(void *a1, uint64_t a2)
{
  a1[6] = 0LL;
  a1[7] = 0LL;
  a1[8] = 0LL;
  *((_OWORD *)a1 + 3) = *(_OWORD *)(a2 + 48);
  a1[8] = *(void *)(a2 + 64);
  *(void *)(a2 + 48) = 0LL;
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  a1[9] = 0LL;
  a1[10] = 0LL;
  a1[11] = 0LL;
  __n128 result = *(__n128 *)(a2 + 72);
  *(__n128 *)(a1 + 9) = result;
  a1[11] = *(void *)(a2 + 88);
  *(void *)(a2 + 72) = 0LL;
  *(void *)(a2 + 80) = 0LL;
  *(void *)(a2 + 88) = 0LL;
  return result;
}

void __Block_byref_object_dispose__5360(void *a1)
{
  uint64_t v2 = (void *)a1[9];
  if (v2)
  {
    a1[10] = v2;
    operator delete(v2);
  }

  uint64_t v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }

void HTTP3Fields::HTTP3Fields(HTTP3Fields *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  uint64_t v2 = (char *)operator new(0x4000uLL);
  *(void *)this = v2;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2 + 0x4000;
}

void ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_32( uint64_t a1, NSString *a2, NSString *a3)
{
}

uint64_t ___ZN11HTTP3Stream19_requestBodyGotDataEPU27objcproto16OS_dispatch_data8NSObject13CFStreamErrorb_block_invoke_2( uint64_t a1, uint64_t a2, CFIndex a3, uint64_t a4)
{
  v5.domain = a3;
  *(void *)&v5.error = a4;
  return HTTP3Stream::_handleSendError(*(HTTP3Stream **)(a1 + 32), v5, 1);
}

void HTTP3Stream::_sendHEADERS(void *a1, void *a2, int a3, void *a4)
{
  v108[0] = *MEMORY[0x1895F89C0];
  uint64_t v7 = a4;
  uint64_t v105 = 0LL;
  __int16 v106 = 0LL;
  unint64_t v8 = (std::__shared_weak_count *)a1[7];
  if (!v8)
  {
    uint64_t v9 = 0LL;
    goto LABEL_12;
  }

  uint64_t v9 = std::__shared_weak_count::lock(v8);
  __int16 v106 = v9;
  if (!v9 || (uint64_t v10 = a1[6], (v105 = v10) == 0))
  {
LABEL_12:
    v7[2](v7, 0LL, 4LL, 4294967292LL);
    if (!v9) {
      goto LABEL_90;
    }
    goto LABEL_13;
  }

  v103[0] = 0LL;
  v103[1] = v103;
  v103[2] = 0x2020000000LL;
  v103[3] = 0LL;
  v102[0] = 0LL;
  v102[1] = v102;
  v102[2] = 0x2020000000LL;
  v102[3] = 0LL;
  uint64_t v98 = 0LL;
  uint64_t v99 = &v98;
  uint64_t v100 = 0x2020000000LL;
  uint64_t v101 = 22LL;
  uint64_t v94 = 0LL;
  uint64_t v95 = &v94;
  uint64_t v96 = 0x2020000000LL;
  uint64_t v97 = 0LL;
  v93[0] = 0LL;
  v93[1] = v93;
  v93[2] = 0x2020000000LL;
  v93[3] = 512LL;
  v92[0] = 0LL;
  v92[1] = v92;
  v92[2] = 0x2020000000LL;
  v92[3] = 512LL;
  uint64_t v86 = 0LL;
  int v87 = &v86;
  uint64_t v88 = 0x3032000000LL;
  uint64_t v89 = __Block_byref_object_copy__17;
  v90 = __Block_byref_object_dispose__18;
  id alloc = (id)dispatch_data_create_alloc();
  uint64_t v80 = 0LL;
  uint64_t v81 = &v80;
  uint64_t v82 = 0x3032000000LL;
  unint64_t v83 = __Block_byref_object_copy__17;
  uint64_t v84 = __Block_byref_object_dispose__18;
  id v85 = (id)dispatch_data_create_alloc();
  if ((*(_BYTE *)(v10 + 44) & 1) != 0) {
    __assert_rtn("_sendHEADERS", "HTTP3Stream.mm", 694, "status == 0");
  }
  uint64_t v11 = v104;
  uint64_t v12 = a1[42];
  uint64_t v13 = *(FILE **)(v10 + 232);
  if (v13)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v13);
    fprintf(*(FILE **)(v10 + 232), "Start header for stream %llu", v12);
    fputc(10, *(FILE **)(v10 + 232));
  }

  unint64_t v14 = (void *)(v10 + 112);
  while (1)
  {
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      break;
    }
    uint64_t v15 = v14[1];
    if (v15 != -1) {
      goto LABEL_21;
    }
  }

  if ((*(_BYTE *)(v10 + 44) & 4) != 0
    || 4112 * (unint64_t)*(unsigned int *)(v10 + 76) < *(unsigned int *)(v10 + 52))
  {
    unint64_t v14 = malloc(0x1010uLL);
    if (v14)
    {
      uint64_t v15 = 0LL;
      void *v14 = 0LL;
      v14[1] = 0LL;
      **(void **)(v10 + 120) = v14;
      *(void *)(v10 + 120) = v14;
      ++*(_DWORD *)(v10 + 76);
LABEL_21:
      unint64_t v18 = __clz(__rbit64(~v15));
      v14[1] = (1LL << v18) | v15;
      uint64_t v19 = &v14[8 * v18];
      v19[2] = 0LL;
      v19 += 2;
      *(_OWORD *)(v19 + 3) = 0u;
      *(_OWORD *)(v19 + 5) = 0u;
      v19[7] = 0LL;
      *(_OWORD *)(v19 + 1) = 0u;
      v19[4] = v19;
      size_t v20 = *(void **)(v10 + 136);
      v19[1] = v20;
      *size_t v20 = v19;
      *(void *)(v10 + 136) = v19;
      *(void *)(v10 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = v19;
      unint64_t v21 = (void *)(v10 + 160);
      v19[5] = v12;
      *((_DWORD *)v19 + 12) = a3;
      goto LABEL_22;
    }
  }

  *(void *)(v10 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0LL;
  unint64_t v21 = (void *)(v10 + 160);
  unint64_t v24 = *(FILE **)(v10 + 232);
  if (v24)
  {
    fwrite("qenc: info: ", 0xCuLL, 1uLL, v24);
    fprintf(*(FILE **)(v10 + 232), "could not allocate hinfo for stream %llu", v12);
    fputc(10, *(FILE **)(v10 + 232));
  }

LABEL_90:
}

        uint64_t v11 = *((_DWORD *)this + 66);
        uint64_t v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        goto LABEL_91;
      }

      int valuePtr = 0.0;
      unint64_t v21 = (IOLogger *)*((void *)this + 27);
      if (v21) {
        IOLogger::logBytesSent(v21, 1, a3, a4);
      }
      while (1)
      {
        while (1)
        {
          int v22 = SSLWrite(*((SSLContextRef *)this + 37), a3, a4, (size_t *)&valuePtr);
          uint64_t v23 = v22;
          unint64_t v24 = *((unsigned int *)this + 62);
          uint64_t v25 = v24 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          uint64_t v9 = *(void *)&valuePtr;
          if ((v24 & 0x20000) == 0 && valuePtr != 0.0)
          {
            int v26 = HIDWORD(v25);
            v25 |= 0x20000uLL;
            *((_WORD *)this + 126) = v26;
            *((_DWORD *)this + 62) = v25;
          }

          if (*((_DWORD *)this + 66)) {
            goto LABEL_89;
          }
          if ((_DWORD)v22 == -9803 && v9 != 0) {
            goto LABEL_51;
          }
          if ((_DWORD)v22 != -9842) {
            goto LABEL_88;
          }
          *((_WORD *)this + 126) = WORD2(v25);
          *((_DWORD *)this + 62) = v25 | 0x20000000;
          float v29 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184LL))(this);
          if (v29)
          {
            unsigned int v51 = v29;
            uint64_t v79 = 0LL;
            if (SSLCopyDistinguishedNames(*((SSLContextRef *)this + 37), (CFArrayRef *)&v79))
            {
              char v52 = v79;
              uint64_t v79 = 0LL;
              if (v52) {
                CFRelease(v52);
              }
            }

            CFRetain(cf);
            int v73 = (CFRunLoopRef)MEMORY[0x1895F87A8];
            size_t v74 = 3221225472LL;
            uint64_t v75 = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_3;
            uint64_t v76 = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            int v77 = this;
            (*(void (**)(uint64_t, CFTypeRef, CFRunLoopRef *))(*(void *)v51 + 48LL))(v51, v79, &v73);
            if (v79) {
              CFRelease(v79);
            }
            (*(void (**)(uint64_t))(*(void *)v51 + 24LL))(v51);
            SocketStream::unscheduleFromSSL(this);
            goto LABEL_89;
          }

          uint64_t v30 = *((_DWORD *)this + 62) & 0xDFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          *((_DWORD *)this + 62) &= ~0x20000000u;
          *((_WORD *)this + 126) = WORD2(v30);
        }

        if ((_DWORD)v22 != -9841) {
          goto LABEL_88;
        }
        float v28 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184LL))(this);
        if (v28)
        {
          unint64_t v44 = v28;
          *((_DWORD *)this + 62) |= 0x40000000u;
          uint64_t v79 = 0LL;
          if (SocketStream::_copyPeerTrustWithPinning_NoLock( (CFDictionaryRef *)this,  *((SSLContextRef *)this + 37),  (SecTrustRef *)&v79))
          {
            unint64_t v46 = v79;
            uint64_t v79 = 0LL;
            if (v46) {
              CFRelease(v46);
            }
          }

          uint64_t v47 = (const __CFDictionary *)CFDictionaryGetValue( *((CFDictionaryRef *)this + 42),  @"kCFStreamPropertySSLSettings");
          ATSVersion = StrictSecurity::getATSVersion(v47, v48);
          StrictSecurity::cloneSecTrust(&v78, (uint64_t)ATSVersion, (uint64_t)v79);
          BOOL v50 = (const void *)*((void *)this + 85);
          *((void *)this + 85) = v78;
          if (v50) {
            CFRelease(v50);
          }
          logPeerCertAvailable(*((SSLContext **)this + 37));
          CFRetain(cf);
          context.version = MEMORY[0x1895F87A8];
          context.info = (void *)3221225472LL;
          context.retain = (const void *(__cdecl *)(const void *))___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke;
          context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e8_v12__0i8l;
          context.copyDescription = (CFStringRef (__cdecl *)(const void *))this;
          (*(void (**)(uint64_t, CFTypeRef, CFRunLoopSourceContext *))(*(void *)v44 + 40LL))( v44,  v79,  &context);
          (*(void (**)(uint64_t))(*(void *)v44 + 24LL))(v44);
          SocketStream::unscheduleFromSSL(this);
          if (v79) {
            CFRelease(v79);
          }
          goto LABEL_89;
        }
      }

      if ((v22 + 9806) < 2)
      {
        *((_WORD *)this + 126) = WORD2(v25);
        *((_DWORD *)this + 62) = v25 | 0x100000;
        goto LABEL_90;
      }

      if (!(_DWORD)v22) {
        goto LABEL_90;
      }
      if ((_DWORD)v22 != -9803) {
        goto LABEL_88;
      }
      if ((v25 & 0x28000) != 0x8000)
      {
        uint64_t v23 = 4294957493LL;
LABEL_88:
        unsigned int v53 = translateSSLContextError(*((SSLContext **)this + 37), v23);
        *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v8 - 32) = v71;
        *((_DWORD *)this + 66) = v53;
LABEL_89:
        uint64_t v9 = -1LL;
        goto LABEL_90;
      }

void sub_182A9E3E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, id a43, char a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, id a49, char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v65);
  _Block_object_dispose(&a38, 8);

  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose(&a54, 8);
  _Block_object_dispose(&a58, 8);
  _Block_object_dispose(&a62, 8);
  _Block_object_dispose((const void *)(v66 - 232), 8);
  _Block_object_dispose((const void *)(v66 - 200), 8);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v66 - 152);

  _Unwind_Resume(a1);
}

void HTTP3Fields::~HTTP3Fields(HTTP3Fields *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }

uint64_t __Block_byref_object_copy__17(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
}

void ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke( void *a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, uint64_t a6)
{
  uint64_t v6 = a1;
  uint64_t v240 = *MEMORY[0x1895F89C0];
  v214 = a1 + 4;
  v215 = a1 + 6;
  v209 = a1 + 7;
  v210 = a1 + 9;
  unsigned int v208 = a4 + 414139866;
  size_t v229 = a4;
  unint64_t v205 = a4 & 0xF;
  size_t __n = a6;
  v233 = (char *)(a2 + a5);
  v227 = &v233[a6];
  int v207 = a6 + a4;
  unint64_t v206 = a6 + a4 + 32;
  unint64_t v204 = a4 + 32;
  if (a4) {
    uint64_t v7 = (char *)(a2 + a3);
  }
  else {
    uint64_t v7 = 0LL;
  }
  v236 = v7;
  v234 = &v7[a4];
  while (2)
  {
    unint64_t v8 = *(void *)(*(void *)(v6[4] + 8LL) + 24LL);
    uint64_t v9 = *(void *)(*(void *)(v6[5] + 8LL) + 24LL);
    uint64_t v10 = *(char **)(*(void *)(v6[6] + 8LL) + 24LL);
    uint64_t v11 = *(void *)(*(void *)(v6[7] + 8LL) + 24LL);
    uint64_t v231 = *(void *)(*(void *)(v6[8] + 8LL) + 24LL);
    uint64_t v12 = *(void *)(*(void *)(v6[9] + 8LL) + 24LL);
    uint64_t v13 = v6[12];
    uint64_t v14 = v6[14];
    uint64_t v15 = v6[15];
    unint64_t v16 = *(FILE **)(v13 + 232);
    if (v16)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v16);
      fputc(10, *(FILE **)(v13 + 232));
    }

    unint64_t v17 = (char *)(v9 + v8);
    unsigned int v30 = 414139866;
    if (v236)
    {
      unint64_t v31 = v229;
      unsigned int v30 = v208;
      float v32 = v236;
      if (a4 >= 0x10)
      {
        int v33 = 1679910008;
        int v34 = 39378473;
        int v35 = -2008766304;
        int v36 = 645669457;
        float v32 = v236;
        do
        {
          HIDWORD(v37) = v36 - 2048144777 * *(_DWORD *)v32;
          LODWORD(v37) = HIDWORD(v37);
          int v36 = -1640531535 * (v37 >> 19);
          HIDWORD(v37) = v35 - 2048144777 * *((_DWORD *)v32 + 1);
          LODWORD(v37) = HIDWORD(v37);
          int v35 = -1640531535 * (v37 >> 19);
          HIDWORD(v37) = v34 - 2048144777 * *((_DWORD *)v32 + 2);
          LODWORD(v37) = HIDWORD(v37);
          int v34 = -1640531535 * (v37 >> 19);
          HIDWORD(v37) = v33 - 2048144777 * *((_DWORD *)v32 + 3);
          LODWORD(v37) = HIDWORD(v37);
          int v33 = -1640531535 * (v37 >> 19);
          v32 += 16;
        }

        while (v32 < v234 - 15);
        HIDWORD(v39) = v36;
        LODWORD(v39) = v36;
        int v38 = v39 >> 31;
        HIDWORD(v39) = v35;
        LODWORD(v39) = v35;
        int v40 = v39 >> 25;
        HIDWORD(v39) = v34;
        LODWORD(v39) = v34;
        int v41 = v39 >> 20;
        HIDWORD(v39) = v33;
        LODWORD(v39) = v33;
        unsigned int v30 = v38 + a4 + v40 + v41 + (v39 >> 14);
        unint64_t v31 = v205;
      }

      if (v31 >= 4)
      {
        do
        {
          int v42 = *(_DWORD *)v32;
          v32 += 4;
          HIDWORD(v43) = v30 - 1028477379 * v42;
          LODWORD(v43) = HIDWORD(v43);
          unsigned int v30 = 668265263 * (v43 >> 15);
          v31 -= 4LL;
        }

        while (v31 > 3);
      }

      for (; v31; --v31)
      {
        int v44 = *v32++;
        HIDWORD(v45) = v30 + 374761393 * v44;
        LODWORD(v45) = HIDWORD(v45);
        unsigned int v30 = -1640531535 * (v45 >> 21);
      }
    }

    uint64_t v46 = v14;
    unsigned int v47 = -1028477379 * ((-2048144777 * (v30 ^ (v30 >> 15))) ^ ((-2048144777 * (v30 ^ (v30 >> 15))) >> 13));
    uint64_t v48 = v47 ^ HIWORD(v47);
    int v49 = XXH_INLINE_XXH32((int *)v233, __n, v47 ^ HIWORD(v47));
    BOOL v50 = *(FILE **)(v13 + 232);
    if (v50)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v50);
      fprintf(*(FILE **)(v13 + 232), "name hash: 0x%X; nameval hash: 0x%X", v48, v49);
      fputc(10, *(FILE **)(v13 + 232));
    }

    v226 = (_DWORD *)(v13 + 32);
    v221 = (_BYTE *)(v46 + v12 - v11);
    int64_t v224 = v231 + v11 - v12;
    unint64_t v218 = (unint64_t)&v221[v224];
    unint64_t v213 = v17 - v10;
    v216 = &v10[v15 - v8];
    unint64_t v217 = (unint64_t)&v17[v15 - v8];
    uint64_t v51 = a6;
    size_t v52 = v229;
    if (nameval2id_plus_one[v49 & 0x1FF])
    {
      unint64_t v8 = nameval2id_plus_one[v49 & 0x1FF] - 1;
      unsigned int v53 = &(&static_table)[3 * v8];
      if (*((_DWORD *)v53 + 4) == a4
        && *((_DWORD *)&static_table + 6 * v8 + 5) == (_DWORD)a6
        && !memcmp(*v53, v236, v229)
        && !memcmp((&static_table)[3 * v8 + 1], v233, __n))
      {
        uint64_t v230 = 0LL;
        BOOL v211 = 0;
        uint64_t v61 = 0LL;
        uint64_t v62 = 0LL;
        int v63 = 0;
        unsigned int v64 = v8;
        int v232 = v54;
        uint64_t v65 = 1LL;
        unint64_t v55 = (unint64_t)v227;
        unint64_t v58 = (unint64_t)v234;
        uint64_t v56 = v48;
        uint64_t v6 = a1;
        goto LABEL_150;
      }
    }

    unint64_t v55 = (unint64_t)v227;
    uint64_t v56 = v48;
    uint64_t v6 = a1;
    if (*(_DWORD *)(v13 + 60))
    {
      uint64_t v57 = *(void *)(v13 + 160);
      unint64_t v58 = (unint64_t)v234;
      if (v57 && *(_DWORD *)(v57 + 52) < *(_DWORD *)(v13 + 52) >> 1)
      {
        LODWORD(v10) = *v226 != -1;
        int v228 = 1;
      }

      else
      {
        int v228 = 0;
        LODWORD(v10) = 0;
      }
    }

    else
    {
      int v228 = 0;
      LODWORD(v10) = 0;
      unint64_t v58 = (unint64_t)v234;
    }

    if (*(void *)(v13 + 168) || *(_DWORD *)(v13 + 72) < *(_DWORD *)(v13 + 68))
    {
      BOOL v59 = 1;
    }

    else
    {
      uint64_t v60 = *(void *)(v13 + 160);
      if (!v60)
      {
        int v232 = 0;
        goto LABEL_37;
      }

      BOOL v59 = *(_DWORD *)(v60 + 60) > *(_DWORD *)(v13 + 36);
    }

    int v232 = v59;
LABEL_37:
    uint64_t v230 = 0LL;
    BOOL v211 = *(void *)(v13 + 248) != 0LL;
    while (2)
    {
      if (!v228) {
        goto LABEL_76;
      }
      unint64_t v8 = *(void *)(*(void *)(v13 + 104) + 32LL * (v49 & ~(-1 << *(_DWORD *)(v13 + 84))) + 16);
      if (!v8)
      {
        uint64_t v230 = 0LL;
        unint64_t v8 = 0LL;
        goto LABEL_76;
      }

      uint64_t v230 = 0LL;
      while (1)
      {
        if (v49 != *(_DWORD *)(v8 + 40) || *(void *)(v8 + 48) != __PAIR64__(v51, a4)) {
          goto LABEL_50;
        }
        unint64_t v58 = (unint64_t)v234;
LABEL_50:
        unint64_t v8 = *(void *)v8;
        if (!v8)
        {
          unint64_t v55 = (unint64_t)v227;
          if (v230 != 1) {
            goto LABEL_76;
          }
          unint64_t v8 = (unint64_t)v238;
          unsigned int v66 = v238[6];
          unsigned int v223 = v66;
          if (v232)
          {
            if (!(_DWORD)v10) {
              goto LABEL_75;
            }
          }

          else
          {
            unsigned int v67 = *(_DWORD *)(v13 + 36);
            if (v66 > v67 || (_DWORD)v10 == 0) {
              goto LABEL_72;
            }
          }

          if ((*(_BYTE *)(v13 + 44) & 2) != 0)
          {
            unint64_t v69 = (v238[12] + v238[13] + 32);
            float v70 = (float)*(unsigned int *)(v13 + 52);
            if ((float)((float)(v69 + *(_DWORD *)(v13 + 48)) / v70) >= 0.8
              && (float)((float)(v238[7] - *(_DWORD *)(v13 + 64) + v238[8]) / v70) < 0.2)
            {
              int can_evict_at_least = qenc_has_or_can_evict_at_least((uint64_t)v226, v69);
              unint64_t v58 = (unint64_t)v234;
              if (can_evict_at_least)
              {
                int v63 = 6;
                if (v232)
                {
                  uint64_t v65 = 0LL;
                  unsigned int v64 = v223;
                  int v228 = 1;
                  uint64_t v230 = 1LL;
                  int v232 = 1;
                  goto LABEL_69;
                }

                int v166 = *(_DWORD *)(v13 + 48);
                unsigned int v165 = *(_DWORD *)(v13 + 52);
                if (*(_DWORD *)(v8 + 28) - *(_DWORD *)(v13 + 64) + *(_DWORD *)(v8 + 32) + v165 - v166 >= v165 >> 2)
                {
                  unsigned int v167 = v166 + *(_DWORD *)(v8 + 48) + *(_DWORD *)(v8 + 52) + 32;
                  uint64_t v65 = 2LL;
                  int v63 = 2;
                  uint64_t v230 = 1LL;
                  int v232 = 0;
                  int v228 = 1;
                  if (v167 > v165)
                  {
                    uint64_t v168 = *(void *)(v13 + 88);
                    uint64_t v65 = 2LL;
                    int v63 = 2;
                    if (v168 != v8)
                    {
                      while (1)
                      {
                        unsigned int v167 = v167 - (*(_DWORD *)(v168 + 48) + *(_DWORD *)(v168 + 52)) - 32;
                        if (v167 <= v165) {
                          break;
                        }
                        uint64_t v168 = *(void *)(v168 + 16);
                        uint64_t v65 = 2LL;
                        if (v168 == v8)
                        {
                          uint64_t v230 = 1LL;
                          int v232 = 0;
                          uint64_t v61 = 0LL;
                          uint64_t v62 = 0LL;
                          unsigned int v64 = v223;
                          int v228 = 1;
LABEL_250:
                          int v63 = 2;
                          goto LABEL_150;
                        }
                      }

                      uint64_t v65 = 2LL;
                      uint64_t v230 = 1LL;
                      int v232 = 0;
                      unsigned int v64 = v223;
                      int v228 = 1;
                      uint64_t v61 = 1LL;
                      uint64_t v62 = 1LL;
                      goto LABEL_250;
                    }

                    uint64_t v61 = 0LL;
                    uint64_t v230 = 1LL;
                    int v232 = 0;
                    int v228 = 1;
                    unsigned int v64 = v223;
                    goto LABEL_145;
                  }

                  unsigned int v64 = v223;
LABEL_69:
                  uint64_t v61 = 1LL;
                  uint64_t v62 = 1LL;
                  goto LABEL_150;
                }

LABEL_268:
        qenc_remove_overflow_entries((uint64_t)v226);
        if (v211)
        {
          uint64_t v177 = *(void *)(v13 + 248);
          if (!v177) {
            __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 2132, "enc->qpe_hist_els");
          }
          unsigned int v178 = *(_DWORD *)(v13 + 260);
          if (*(_DWORD *)(v13 + 176) < v178)
          {
LABEL_273:
            *(_DWORD *)(v177 + 8LL * *(unsigned int *)(v13 + 256)) = v56;
            *(_DWORD *)(v177 + 8LL * *(unsigned int *)(v13 + 256) + 4) = v49;
            unsigned int v179 = (*(_DWORD *)(v13 + 256) + 1) % *(_DWORD *)(v13 + 260);
            *(_DWORD *)(v13 + 256) = v179;
            *(_DWORD *)(v13 + 264) |= v179 == 0;
          }

          else
          {
            qenc_hist_update_size((uint64_t)v226, v178 + 4);
            if (*(_DWORD *)(v13 + 260))
            {
              uint64_t v177 = *(void *)(v13 + 248);
              goto LABEL_273;
            }
          }

          ++*(_DWORD *)(v13 + 176);
        }

        if (v170 != v61)
        {
          v180 = (_DWORD *)(v13 + 32);
          while (1)
          {
            if ((*(_BYTE *)(v13 + 44) & 2) == 0
              || *v180 == -1
              || ((float v181 = *(float *)(v13 + 240), v181 != 0.0)
               || *(void *)(v13 + 168)
               || *(_DWORD *)(v13 + 72) < *(_DWORD *)(v13 + 68)
               || (uint64_t v182 = *(void *)(v13 + 160)) != 0 && *(_DWORD *)(v182 + 60) > *(_DWORD *)(v13 + 36))
              && v181 < *(float *)(v13 + 244)
              || (v183 = *(uint64_t **)(v13 + 88)) == 0LL)
            {
LABEL_316:
              int64_t v170 = v61;
              break;
            }

            v184 = 0LL;
            v185 = &v221[v61];
            while ((*((_DWORD *)v183 + 7)
                                 - *(_DWORD *)(v13 + 64)
                                 + *((_DWORD *)v183 + 8)
                                 + *(_DWORD *)(v13 + 52)
                                 - *(_DWORD *)(v13 + 48)) < *(_DWORD *)(v13 + 52) >> 2)
            {
              if (!v184
                || *((_DWORD *)v183 + 12) + *((_DWORD *)v183 + 13) + 32 >= (v184[12] + v184[13] + 32))
              {
                v186 = (uint64_t *)*v183;
                int v187 = *((_DWORD *)v183 + 10);
                if (*v183)
                {
                  while (1)
                  {
                    if (*((_DWORD *)v186 + 10) == v187)
                    {
                      uint64_t v188 = *((unsigned int *)v186 + 12);
                      if ((_DWORD)v188 == *((_DWORD *)v183 + 12))
                      {
                        size_t v189 = *((unsigned int *)v186 + 13);
                        if ((_DWORD)v189 == *((_DWORD *)v183 + 13)
                          && !memcmp(v186 + 7, v183 + 7, *((unsigned int *)v186 + 12))
                          && !memcmp((char *)v186 + v188 + 56, (char *)v183 + v188 + 56, v189))
                        {
                          break;
                        }
                      }
                    }

                    v186 = (uint64_t *)*v186;
                    if (!v186) {
                      goto LABEL_297;
                    }
                  }
                }

                else
                {
LABEL_297:
                  uint64_t v190 = *(void *)(v13 + 248);
                  if (!v190) {
                    goto LABEL_303;
                  }
                  uint64_t v191 = 260LL;
                  if (!*(_DWORD *)(v13 + 264)) {
                    uint64_t v191 = 256LL;
                  }
                  unint64_t v192 = v190 + 8LL * *(unsigned int *)(v13 + v191);
                  *(_DWORD *)(v192 + 4) = v187;
                  unint64_t v193 = v190 - 8;
                  do
                  {
                    int v194 = *(_DWORD *)(v193 + 12);
                    v193 += 8LL;
                  }

                  while (v194 != v187);
                  if (v193 < v192)
                  {
LABEL_303:
                    v180 = (_DWORD *)(v13 + 32);
                    if (qenc_has_or_can_evict_at_least( (uint64_t)v226,  (*((_DWORD *)v183 + 12) + *((_DWORD *)v183 + 13) + 32))) {
                      v184 = v183;
                    }
                    goto LABEL_307;
                  }
                }

                v180 = (_DWORD *)(v13 + 32);
              }

LABEL_307:
              v183 = (uint64_t *)v183[2];
              if (!v183) {
                break;
              }
            }

            if (!v184) {
              goto LABEL_316;
            }
            v195 = *(FILE **)(v13 + 232);
            if (v195)
            {
              fwrite("qenc: debug: ", 0xDuLL, 1uLL, v195);
              fwrite("dup draining", 0xCuLL, 1uLL, *(FILE **)(v13 + 232));
              fputc(10, *(FILE **)(v13 + 232));
            }

            _BYTE *v185 = 0;
            v196 = lsqpack_enc_int(v185, v218, (*v180 - v184[6]), 5);
            if (v196 <= v185) {
              goto LABEL_316;
            }
            int v197 = (int)v196;
            if (!lsqpack_enc_push_entry( (uint64_t)v180,  v184[11],  v184[10],  v184 + 14,  v184[12],  (char *)v184 + v184[12] + 56,  v184[13])
              || v197 == (_DWORD)v185)
            {
              goto LABEL_316;
            }

            v61 += (v197 - (_DWORD)v185);
            qenc_remove_overflow_entries((uint64_t)v180);
            if (v224 == v61)
            {
              int64_t v170 = v224;
              break;
            }
          }
        }

        unsigned int v198 = v207 + *(_DWORD *)(v13 + 224);
        unsigned int v199 = *(_DWORD *)(v13 + 228) + v170 + v237;
        *(_DWORD *)(v13 + 224) = v198;
        *(_DWORD *)(v13 + 228) = v199;
        if (v199 >= 0x80000001)
        {
          *(_DWORD *)(v13 + 224) = (int)(float)((float)((float)v198 / (float)v199) * 1000.0);
          *(_DWORD *)(v13 + 228) = 1000;
          v200 = *(FILE **)(v13 + 232);
          if (v200)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v200);
            v201 = *(FILE **)(v13 + 232);
            unsigned int v202 = *(_DWORD *)(v13 + 224);
            if (v202)
            {
              float v203 = (float)*(unsigned int *)(v13 + 228) / (float)v202;
              if (v201)
              {
                fwrite("qenc: debug: ", 0xDuLL, 1uLL, *(FILE **)(v13 + 232));
                fprintf( *(FILE **)(v13 + 232),  "bytes out: %u; bytes in: %u, ratio: %.3f",
                  *(_DWORD *)(v13 + 228),
                  *(_DWORD *)(v13 + 224),
                  v203);
                fputc(10, *(FILE **)(v13 + 232));
              }
            }

            else
            {
              float v203 = 0.0;
            }

            fprintf(v201, "reset bytes in/out counters, ratio: %.3f", v203);
            fputc(10, *(FILE **)(v13 + 232));
          }
        }

        *(void *)(*(void *)(*v215 + 8LL) + 24LL) += v237;
        *(void *)(*(void *)(*v210 + 8LL) + 24LL) += v170;
        return;
      case 4LL:
      case 5LL:
        if (v224 < 1) {
          goto LABEL_186;
        }
        _BYTE *v221 = 64;
        int v120 = lsqpack_enc_enc_str(5, v221, v224, (unsigned __int16 *)v236, a4);
        if (v120 < 0) {
          goto LABEL_186;
        }
        v121 = &v221[v120];
        unint64_t v122 = v218 - (void)v121;
        if (v61 == 4) {
          unsigned int v123 = v51;
        }
        else {
          unsigned int v123 = 0;
        }
        v124 = &v221[v120];
        v125 = (unsigned __int16 *)v233;
        goto LABEL_182;
      default:
        __assert_rtn("lsqpack_enc_encode", "lsqpack.c", 1989, "EEA_NONE == prog.ep_enc_action");
    }
  }

void HTTP3Fields::enumerateFields(void *a1, void *a2)
{
  id v6 = a2;
  uint64_t v3 = (unsigned __int16 *)a1[3];
  unint64_t v4 = (unsigned __int16 *)a1[4];
  if (v3 != v4)
  {
    int v5 = 0;
    do
    {
      (*((void (**)(id, void, void, void, void, void))v6 + 2))( v6,  *a1 + (unsigned __int16)v5,  0LL,  *v3,  *v3,  v3[1]);
      v5 += *v3 + v3[1];
      v3 += 2;
    }

    while (v3 != v4);
  }
}

void sub_182AA0068( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t ___ZN11HTTP3Stream12_sendHEADERSERK11HTTP3FieldsbU13block_pointerFvm13CFStreamErrorE_block_invoke_22( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 40);
  size_t v7 = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 32))
     + a2
     + *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  return (*(uint64_t (**)(uint64_t, size_t, uint64_t, uint64_t))(v6 + 16))(v6, v7, a3, a4);
}

uint64_t __copy_helper_block_ea8_96c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 104);
  *(void *)(result + 96) = *(void *)(a2 + 96);
  *(void *)(result + 104) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_ea8_96c43_ZTSNSt3__110shared_ptrI15HTTP3ConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 96);
}

uint64_t HTTP3Stream::_handleSendError(HTTP3Stream *this, CFStreamError a2, int a3)
{
  uint64_t v4 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  uint64_t v51 = *MEMORY[0x1895F89C0];
  switch(HTTP3Stream::_translateError(this, a2, 1))
  {
    case 0u:
      if (a3) {
        goto LABEL_3;
      }
      return 0LL;
    case 1u:
LABEL_3:
      uint64_t v7 = *((void *)this + 43);
      if (v7) {
        *(CFAbsoluteTime *)(v7 + 184) = CFAbsoluteTimeGetCurrent();
      }
      *((_DWORD *)this + 28) = 4;
      CFN_LOG_h3stream();
      unint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *((void *)this + 42);
        uint64_t v10 = *((void *)this + 44);
        uint64_t v11 = *((void *)this + 12);
        if (v11)
        {
          else {
            int v12 = 68;
          }
          uint64_t v13 = *((void *)this + 12);
          if (v13) {
            uint64_t v13 = *(void *)(v13 + 96);
          }
        }

        else
        {
          uint64_t v13 = 0LL;
          int v12 = 78;
        }

        *(_DWORD *)buf = 134219010;
        *(void *)&buf[4] = this;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v9;
        __int16 v45 = 2114;
        uint64_t v46 = v10;
        __int16 v47 = 1024;
        int v48 = v12;
        __int16 v49 = 2048;
        uint64_t v50 = v13;
        _os_log_impl( &dword_18298D000,  v8,  OS_LOG_TYPE_DEFAULT,  "%p ID=%llu %{public}@ sent request, body %c %lld",  buf,  0x30u);
      }

      if (*((int *)this + 29) <= 2)
      {
        uint64_t v42 = 0LL;
        unint64_t v43 = 0LL;
        unint64_t v27 = (std::__shared_weak_count *)*((void *)this + 7);
        if (v27)
        {
          unint64_t v43 = std::__shared_weak_count::lock(v27);
          if (v43)
          {
            uint64_t v28 = *((void *)this + 6);
            uint64_t v42 = v28;
            if (v28)
            {
              std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v40,  *((void *)this + 1),  *((std::__shared_weak_count **)this + 2));
              if (v40)
              {
                float v29 = *(void **)(v28 + 976);
                if (v29)
                {
                  unsigned int v30 = v41;
                  *(void *)buf = v40;
                  *(void *)&buf[8] = v41;
                  if (v41)
                  {
                    p_shared_owners = (unint64_t *)&v41->__shared_owners_;
                    do
                      unint64_t v32 = __ldxr(p_shared_owners);
                    while (__stxr(v32 + 1, p_shared_owners));
                    HTTPStallTimer::add(v29, (uint64_t *)buf);
                    do
                      unint64_t v33 = __ldaxr(p_shared_owners);
                    while (__stlxr(v33 - 1, p_shared_owners));
                    if (!v33)
                    {
                      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                      std::__shared_weak_count::__release_weak(v30);
                    }
                  }

                  else
                  {
                    HTTPStallTimer::add(v29, (uint64_t *)buf);
                  }
                }
              }

              int v34 = v41;
              if (v41)
              {
                int v35 = (unint64_t *)&v41->__shared_owners_;
                do
                  unint64_t v36 = __ldaxr(v35);
                while (__stlxr(v36 - 1, v35));
                if (!v36)
                {
                  ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
                  std::__shared_weak_count::__release_weak(v34);
                }
              }
            }
          }
        }

        unint64_t v37 = v43;
        if (v43)
        {
          int v38 = (unint64_t *)&v43->__shared_owners_;
          do
            unint64_t v39 = __ldaxr(v38);
          while (__stlxr(v39 - 1, v38));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
            std::__shared_weak_count::__release_weak(v37);
          }
        }
      }

      break;
    case 2u:
      *((void *)this + 33) = domain;
      *((void *)this + 34) = v4;
      break;
    case 3u:
      *((void *)this + 33) = 4LL;
      int v14 = -4;
      goto LABEL_32;
    case 4u:
      goto LABEL_24;
    case 5u:
      *((void *)this + 33) = 4LL;
      int v14 = -2205;
      goto LABEL_32;
    case 6u:
      if (!*((_DWORD *)this + 29)) {
        goto LABEL_31;
      }
      uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 7);
      if (v15)
      {
        unint64_t v16 = std::__shared_weak_count::lock(v15);
        *(void *)&buf[8] = v16;
        if (v16)
        {
          unint64_t v17 = v16;
          uint64_t v18 = *((void *)this + 6);
          *(void *)buf = v18;
          if (v18)
          {
            *(void *)(v18 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 4LL;
            *(_DWORD *)(v18 + 1168) = -1;
            HTTP3Connection::_cleanupConnection((HTTP3Connection *)v18, 257LL, 0LL);
            HTTP3Connection::reportServerProtocolViolation(v18, 50, *((void *)this + 42));
          }

          uint64_t v19 = (unint64_t *)&v17->__shared_owners_;
          do
            unint64_t v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
        }
      }

void sub_182AA04E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void HTTP3Fields::appendField(std::vector<char> *this, NSString *a2, NSString *a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  int v5 = a2;
  uint64_t v6 = a3;
  uint64_t v7 = v5;
  unint64_t v8 = -[NSString UTF8String](v7, "UTF8String");
  uint64_t v9 = (char *)v8;
  if (!v8)
  {
    CFN_LOG_h3stream();
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      unint64_t v39 = v7;
      _os_log_error_impl( &dword_18298D000,  v11,  OS_LOG_TYPE_ERROR,  "Dropping HTTP field due to invalid name %@",  buf,  0xCu);
    }

    goto LABEL_12;
  }

  size_t v10 = strlen(v8);
  if (v10 >= 0x10000)
  {
    CFN_LOG_h3stream();
    uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      unint64_t v39 = v7;
      _os_log_error_impl( &dword_18298D000,  v11,  OS_LOG_TYPE_ERROR,  "Dropping HTTP field due to overlong name %@",  buf,  0xCu);
    }

void sub_182AA08DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>( uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  if (a5 < 1) {
    return;
  }
  size_t v10 = *(_BYTE **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    uint64_t v11 = *(char **)a1;
    uint64_t v12 = (uint64_t)&v10[a5 - *(void *)a1];
    if (v12 < 0) {
      abort();
    }
    uint64_t v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - (void)v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15) {
      unint64_t v16 = (char *)operator new(v15);
    }
    else {
      unint64_t v16 = 0LL;
    }
    std::vector<char>::pointer v26 = &v13[(void)v16];
    memcpy(&v13[(void)v16], __src, a5);
    if (v11 == __dst)
    {
      uint64_t v27 = &v13[(void)v16];
    }

    else
    {
      do
      {
        v13[(void)v16 - 1] = v13[(void)(v11 - 1)];
        --v13;
      }

      while (v13);
      size_t v10 = *(_BYTE **)(a1 + 8);
      uint64_t v27 = v16;
    }

    unint64_t v28 = &v26[a5];
    uint64_t v29 = &v16[v15];
    if (v10 != __dst) {
      memmove(v28, __dst, v10 - __dst);
    }
    unint64_t v30 = *(char **)a1;
    *(void *)a1 = v27;
    *(void *)(a1 + 8) = &v28[v10 - __dst];
    *(void *)(a1 + 16) = v29;
    if (v30) {
      operator delete(v30);
    }
    return;
  }

  uint64_t v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    std::vector<char>::pointer v18 = &__src[a5];
    unint64_t v20 = *(_BYTE **)(a1 + 8);
LABEL_17:
    uint64_t v21 = &__dst[a5];
    uint64_t v22 = &v20[-a5];
    id v23 = v20;
    if (&v20[-a5] < v10)
    {
      unint64_t v24 = (char *)(&v10[a5] - v20);
      id v23 = v20;
      do
      {
        char v25 = *v22++;
        *v23++ = v25;
        --v24;
      }

      while (v24);
    }

    *(void *)(a1 + 8) = v23;
    if (v20 != v21) {
      memmove(&__dst[a5], __dst, v20 - v21);
    }
    if (v18 != __src) {
      memmove(__dst, __src, v18 - __src);
    }
    return;
  }

  std::vector<char>::pointer v18 = &__src[v17];
  int64_t v19 = a4 - &__src[v17];
  if (a4 != &__src[v17]) {
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  }
  unint64_t v20 = &v10[v19];
  *(void *)(a1 + 8) = &v10[v19];
  if (v17 >= 1) {
    goto LABEL_17;
  }
}

void std::vector<char>::__append(std::vector<char> *this, std::vector<char>::size_type __n)
{
  end = this->__end_;
  value = this->__end_cap_.__value_;
  if (value - end >= __n)
  {
    if (__n)
    {
      bzero(this->__end_, __n);
      end += __n;
    }

    this->__end_ = end;
  }

  else
  {
    std::vector<char>::pointer begin = this->__begin_;
    int64_t v7 = end - this->__begin_;
    unint64_t v8 = v7 + __n;
    unint64_t v9 = value - begin;
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      uint64_t v11 = (char *)operator new(v10);
    }
    else {
      uint64_t v11 = 0LL;
    }
    uint64_t v12 = &v11[v7];
    uint64_t v13 = &v11[v10];
    bzero(v12, __n);
    if (end == begin)
    {
      uint64_t v11 = v12;
    }

    else
    {
      unint64_t v14 = &end[~(unint64_t)begin];
      do
      {
        char v15 = *--end;
        (v14--)[(void)v11] = v15;
      }

      while (end != begin);
      end = this->__begin_;
    }

    this->__begin_ = v11;
    this->__end_ = &v12[__n];
    this->__end_cap_.__value_ = v13;
    if (end) {
      operator delete(end);
    }
  }

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned short,unsigned short>>>( unint64_t a1)
{
  if (a1 >> 62) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(4 * a1);
}

void ___ZL16CFN_LOG_h3streamv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.cfnetwork", "h3stream");
  uint64_t v1 = (void *)CFN_LOG_h3stream(void)::log;
  CFN_LOG_h3stream(void)::log = (uint64_t)v0;
}

void std::__shared_ptr_pointer<CoreSchedulingSet *,Deleter_release<CoreSchedulingSet>,std::allocator<CoreSchedulingSet>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke( uint64_t a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v11 = *a2;
  uint64_t v10 = a2[1];
  if (v10)
  {
    uint64_t v12 = (unint64_t *)(v10 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  unint64_t v14 = *(std::__shared_weak_count **)(v8 + 32);
  *(void *)(v8 + 24) = v11;
  *(void *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v8 - 32) = v10;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  uint64_t v17 = *a2;
  uint64_t v18 = *(void *)(*(void *)(a1 + 48) + 296LL);
  if (v18) {
    uint64_t v19 = v18 - 176;
  }
  else {
    uint64_t v19 = 0LL;
  }
  unint64_t v20 = *(std::__shared_weak_count_vtbl **)(v19 + 64);
  if (v20)
  {
    Throttler::getByteHeadroomInfoBlock(v20);
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
  }

  else
  {
    uint64_t v21 = 0LL;
  }

  uint64_t v22 = _Block_copy(v21);

  id v23 = _Block_copy(v22);
  unint64_t v24 = *(void **)(v17 + 64);
  *(void *)(v17 + 64) = v23;

  uint64_t v25 = *(void *)(a1 + 48);
  *(void *)(v25 + 336) = a3;
  *(_BYTE *)(v25 + 126) = a4;
  uint64_t v26 = *(void *)(v25 + 344);
  if (v26)
  {
    *(_BYTE *)(v26 + 10) = a4;
    if ((a4 & 1) != 0)
    {
      *(CFAbsoluteTime *)(v26 + 184) = CFAbsoluteTimeGetCurrent();
      uint64_t v25 = *(void *)(a1 + 48);
LABEL_18:
      *(_DWORD *)(v25 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 4;
LABEL_19:
      HTTP3Stream::_read(*(HTTP3Stream **)(a1 + 48), 0);
      return;
    }
  }

  else if ((a4 & 1) != 0)
  {
    goto LABEL_18;
  }

  if (a3 != -1)
  {
    uint64_t v27 = MEMORY[0x1895F87A8];
    uint64_t v54 = MEMORY[0x1895F87A8];
    uint64_t v55 = 3321888768LL;
    uint64_t v56 = ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke_1;
    uint64_t v57 = &__block_descriptor_48_ea8_32c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE_e16_v32__0Q8___qi_16l;
    unint64_t v28 = *(std::__shared_weak_count **)(a1 + 56);
    uint64_t v58 = v25;
    BOOL v59 = v28;
    if (v28)
    {
      uint64_t v29 = (unint64_t *)&v28->__shared_owners_;
      do
        unint64_t v30 = __ldxr(v29);
      while (__stxr(v30 + 1, v29));
    }

    HTTP3Stream::_sendHEADERS((void *)v25, (void *)(a1 + 64), 0, &v54);
    uint64_t v31 = *(void *)(a1 + 48);
    if (*(void *)(v31 + 96))
    {
      unint64_t v32 = (__CFString *)HTTPMessage::copyHeaderFieldValue( *(HTTPMessage **)(v31 + 64),  (const __CFString *)&unk_18C5AF078);
      uint64_t v33 = v32;
      if (v32
        && (-[__CFString rangeOfString:options:]( v32,  "rangeOfString:options:",  0x18C5AFAF8LL,  1LL,  v54,  v55,  v56,  v57,  v58),  v34))
      {
        uint64_t v35 = *(void *)(a1 + 48);
        *(_DWORD *)(v35 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 1;
        dispatch_source_t v36 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *(dispatch_queue_t *)(v35 + 40));
        int v37 = *(void **)(v35 + 136);
        *(void *)(v35 + 136) = v36;

        uint64_t v38 = *(void *)(v35 + 8);
        unint64_t v39 = *(std::__shared_weak_count **)(v35 + 16);
        if (v39)
        {
          p_shared_weak_owners = (unint64_t *)&v39->__shared_weak_owners_;
          do
            unint64_t v41 = __ldxr(p_shared_weak_owners);
          while (__stxr(v41 + 1, p_shared_weak_owners));
        }

        uint64_t v42 = *(dispatch_source_s **)(v35 + 136);
        *(void *)handler = v27;
        *(void *)&handler[8] = 3321888768LL;
        *(void *)&handler[16] = ___ZN11HTTP3Stream22_start100ContinueTimerEv_block_invoke;
        uint64_t v61 = &__block_descriptor_48_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE_e5_v8__0l;
        uint64_t v62 = v38;
        int v63 = v39;
        if (v39)
        {
          unint64_t v43 = (unint64_t *)&v39->__shared_weak_owners_;
          do
            unint64_t v44 = __ldxr(v43);
          while (__stxr(v44 + 1, v43));
        }

        dispatch_source_set_event_handler(v42, handler);
        __int16 v45 = *(dispatch_source_s **)(v35 + 136);
        dispatch_time_t v46 = dispatch_time(0LL, 5000000000LL);
        dispatch_source_set_timer(v45, v46, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        dispatch_resume(*(dispatch_object_t *)(v35 + 136));
        if (v63) {
          std::__shared_weak_count::__release_weak(v63);
        }
        if (v39) {
          std::__shared_weak_count::__release_weak(v39);
        }
      }

      else
      {
        int v48 = *(HTTP3Stream **)(a1 + 48);
        *((_DWORD *)v48 + 28) = 2;
        HTTP3Stream::_resumeRequestBody(v48);
        (*(void (**)(void, void, void))(**(void **)(*(void *)(a1 + 48) + 96LL) + 40LL))( *(void *)(*(void *)(a1 + 48) + 96LL),  *(void *)(a1 + 112),  0LL);
      }
    }

    __int16 v49 = v59;
    if (v59)
    {
      uint64_t v50 = (unint64_t *)&v59->__shared_owners_;
      do
        unint64_t v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (!v51)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }

    goto LABEL_19;
  }

  CFN_LOG_h3stream();
  __int16 v47 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    uint64_t v52 = *(void *)(v9 + 352);
    unsigned int v53 = *(void **)(v9 + 336);
    *(_DWORD *)handler = 138543874;
    *(void *)&handler[4] = v52;
    *(_WORD *)&handler[12] = 2048;
    *(void *)&handler[14] = v9;
    *(_WORD *)&handler[22] = 2048;
    uint64_t v61 = v53;
    _os_log_error_impl( &dword_18298D000,  v47,  OS_LOG_TYPE_ERROR,  "%{public}@ %p ID=%llu failed to create quic stream",  handler,  0x20u);
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
}

void sub_182AA1098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_DWORD *std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:nn180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>( _DWORD *result, int *a2, int *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 62) {
      abort();
    }
    uint64_t v6 = result;
    __n128 result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned short,unsigned short>>>(a4);
    *uint64_t v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    while (a2 != a3)
    {
      int v8 = *a2++;
      *result++ = v8;
    }

    v6[1] = result;
  }

  return result;
}

_DWORD *__copy_helper_block_ea8_48c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE64c17_ZTS11HTTP3Fields( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v4;
  if (v4)
  {
    int v5 = (unint64_t *)(v4 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  int v8 = *(_BYTE **)(a2 + 64);
  uint64_t v7 = *(_BYTE **)(a2 + 72);
  size_t v9 = v7 - v8;
  if (v7 != v8)
  {
    std::vector<char>::__vallocate[abi:nn180100]((void *)(a1 + 64), v7 - v8);
    uint64_t v10 = *(char **)(a1 + 72);
    memmove(v10, v8, v9);
    *(void *)(a1 + 72) = &v10[v9];
  }

  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  return std::vector<std::pair<unsigned short,unsigned short>>::__init_with_size[abi:nn180100]<std::pair<unsigned short,unsigned short>*,std::pair<unsigned short,unsigned short>*>( (_DWORD *)(a1 + 88),  *(int **)(a2 + 88),  *(int **)(a2 + 96),  (uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 2);
}

void sub_182AA11EC(_Unwind_Exception *a1)
{
}

uint64_t __destroy_helper_block_ea8_48c39_ZTSNSt3__110shared_ptrI11HTTP3StreamEE64c17_ZTS11HTTP3Fields( void *a1)
{
  uint64_t v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }

  uint64_t v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }

  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 6));
}

char *std::vector<char>::__vallocate[abi:nn180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000LL) != 0) {
    abort();
  }
  __n128 result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

uint64_t ___ZN11HTTP3Stream26scheduleAndOpenWithHandlerEPK17CoreSchedulingSetU13block_pointerFvP15__CFHTTPMessagePU27objcproto16OS_dispatch_data8NSObjectPK13CFStreamErrorEU13block_pointerFvhE_block_invoke_1( uint64_t a1, uint64_t a2, CFStreamError a3)
{
  uint64_t v3 = *(HTTP3Stream **)(a1 + 32);
  uint64_t v4 = *((void *)v3 + 43);
  if (v4) {
    *(void *)(v4 + 96) = a2;
  }
  return HTTP3Stream::_handleSendError(v3, a3, *((void *)v3 + 12) == 0LL);
}

void ___ZN11HTTP3Stream22_start100ContinueTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      int v5 = *(HTTP3Stream **)(a1 + 32);
      if (v5) {
        HTTP3Stream::_100ContinueReceived(v5);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(p_shared_owners);
      while (__stlxr(v7 - 1, p_shared_owners));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182AA1348( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __copy_helper_block_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v8 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

void __destroy_helper_block_ea8_32c36_ZTSNSt3__18weak_ptrI11HTTP3StreamEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void HTTP3Fields::appendField(std::vector<char> *this, char *a2, NSString *a3)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  int v5 = a3;
  size_t v6 = strlen(a2);
  uint64_t v7 = -[NSString lengthOfBytesUsingEncoding:](v5, "lengthOfBytesUsingEncoding:", 5LL);
  uint64_t v8 = v7;
  if (v7 + v6 >= 0x10000)
  {
    CFN_LOG_h3stream();
    size_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v34 = v5;
      _os_log_error_impl( &dword_18298D000,  v9,  OS_LOG_TYPE_ERROR,  "Dropping HTTP field due to overlong value %@",  buf,  0xCu);
    }

void sub_182AA169C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN11HTTP3Stream20_buildRequestHeadersEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  int v5 = a2;
  id v16 = a3;
  uint64_t v18 = v5;
  if ((HTTPUtilities::isHeaderAllowed((HTTPUtilities *)v5, v6) & 1) != 0)
  {
    uint64_t v7 = -[NSString caseInsensitiveCompare:](v5, "caseInsensitiveCompare:", 0x18C5AEF60LL);
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    obuint64_t j = v16;
    uint64_t v8 = [obj countByEnumeratingWithState:&v23 objects:v28 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v24;
      do
      {
        for (uint64_t i = 0LL; i != v8; ++i)
        {
          if (*(void *)v24 != v9) {
            objc_enumerationMutation(obj);
          }
          uint64_t v11 = *(NSString **)(*((void *)&v23 + 1) + 8 * i);
          if (v7)
          {
            HTTP3Fields::appendField((std::vector<char> *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL), v18, v11);
          }

          else
          {
            __int128 v21 = 0u;
            __int128 v22 = 0u;
            __int128 v19 = 0u;
            __int128 v20 = 0u;
            -[NSString componentsSeparatedByString:](v11, "componentsSeparatedByString:", @"; ");
            unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
            uint64_t v13 = [v12 countByEnumeratingWithState:&v19 objects:v27 count:16];
            if (v13)
            {
              uint64_t v14 = *(void *)v20;
              do
              {
                for (uint64_t j = 0LL; j != v13; ++j)
                {
                  if (*(void *)v20 != v14) {
                    objc_enumerationMutation(v12);
                  }
                  HTTP3Fields::appendField( (std::vector<char> *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL),  "cookie",  *(NSString **)(*((void *)&v19 + 1) + 8 * j));
                }

                uint64_t v13 = [v12 countByEnumeratingWithState:&v19 objects:v27 count:16];
              }

              while (v13);
            }
          }
        }

        uint64_t v8 = [obj countByEnumeratingWithState:&v23 objects:v28 count:16];
      }

      while (v8);
    }
  }
}

void sub_182AA18D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
}

void std::__shared_ptr_emplace<RequestBodyData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C17898;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RequestBodyData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C17898;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<RequestBodyData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<RequestBodyStream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C17860;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RequestBodyStream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C17860;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_pointer<__CFReadStream *,Deleter_CFRelease,std::allocator<__CFReadStream>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<MetaConnectionCacheClient *,Deleter_meta_release<MetaConnectionCacheClient>,std::allocator<MetaConnectionCacheClient>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<MetaConnectionCacheClient *,Deleter_meta_release<MetaConnectionCacheClient>,std::allocator<MetaConnectionCacheClient>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

void non-virtual thunk to'TubeManager::~TubeManager(TubeManager *this)
{
}

void non-virtual thunk to'TubeManager::~TubeManager(CFAllocatorRef *this)
{
  uint64_t v2 = this - 3;
  TubeManager::~TubeManager((TubeManager *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,MetaConnectionCache *>::~RetainableTypedDict( uint64_t a1)
{
  *(void *)a1 = off_189C18E58;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,MetaConnectionCache *>::~RetainableTypedDict( CFTypeRef *a1)
{
  *a1 = off_189C18E58;
  CFRelease(a1[1]);
  operator delete(a1);
}

uint64_t RetainableTypedDict<HTTPConnectionCacheKey const*,__CFString const*>::~RetainableTypedDict( uint64_t a1)
{
  *(void *)a1 = off_189C18E78;
  CFRelease(*(CFTypeRef *)(a1 + 8));
  return a1;
}

void RetainableTypedDict<HTTPConnectionCacheKey const*,__CFString const*>::~RetainableTypedDict( CFTypeRef *a1)
{
  *a1 = off_189C18E78;
  CFRelease(a1[1]);
  operator delete(a1);
}

uint64_t ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48LL))(*(void *)(a1 + 32));
}

CFMutableArrayRef __Block_byref_object_copy__5425(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = CFGetAllocator(*(CFTypeRef *)(a2 + 48));
  CFMutableArrayRef result = CFArrayCreateMutableCopy(v4, 0LL, *(CFArrayRef *)(a2 + 48));
  *(void *)(a1 + 48) = result;
  return result;
}

void __Block_byref_object_dispose__5426(uint64_t a1)
{
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_33( uint64_t a1, const void *a2)
{
  uint64_t v4 = (*(uint64_t (**)(const void *))(*(void *)a2 + 64LL))(a2);
  uint64_t v5 = 40LL;
  if (v4 == *(void *)(a1 + 48)) {
    uint64_t v5 = 32LL;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + v5) + 8LL) + 48LL), a2);
}

uint64_t RetainableTypedArray<BaseAwaitingTube *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_2( uint64_t a1, BaseAwaitingTube *a2)
{
}

uint64_t ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_3( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80LL))(a2);
  if (v4) {
    uint64_t v5 = (void *)(v4 - 176);
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 136LL);
  if (v6) {
    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v6 + 280LL))(v6, v5[10], 3LL, 0LL);
  }
  (*(void (**)(void *, uint64_t, uint64_t, void))(*v5 + 280LL))(v5, 4LL, 4294965096LL, 0LL);
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 56LL))(a2, 0LL);
}

__n128 __Block_byref_object_copy__37(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

void TubeManager::addNewFastPathCache(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(a1 + 152);
  if (!v5)
  {
    uint64_t v5 = operator new(0x10uLL);
    *(void *)uint64_t v5 = off_189C0F220;
    *((void *)v5 + 1) = CFArrayCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  &CFAllocatedReferenceCountedObject::skCFTypeArrayCallBacks);
    uint64_t v7 = *(void *)(a1 + 152);
    *(void *)(a1 + 152) = v5;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
      uint64_t v5 = *(void **)(a1 + 152);
    }
  }

  if (a2)
  {
    *(CFAbsoluteTime *)(a2 + 144) = CFAbsoluteTimeGetCurrent();
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)v5 + 1));
    if (Count == 200)
    {
      CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)v5 + 1), 0LL);
      uint64_t v9 = 199LL;
      double Current = CFAbsoluteTimeGetCurrent();
    }

    else
    {
      uint64_t v9 = Count;
      double Current = CFAbsoluteTimeGetCurrent();
      if (v9 < 1)
      {
LABEL_11:
        CFArrayAppendValue(*((CFMutableArrayRef *)v5 + 1), (const void *)a2);
        goto LABEL_12;
      }
    }

    double v11 = Current;
    uint64_t v12 = v9 + 1;
    do
    {
      CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)v5 + 1), 0LL);
      --v12;
    }

    while (v12 > 1);
    goto LABEL_11;
  }

void sub_182AA1FA8(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  operator delete(v1);
  _Unwind_Resume(a1);
}

void TubeManager::_onqueue_rdar53306264_logWaiters(CFArrayRef *this)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  CFIndex Count = CFArrayGetCount(this[17]);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v3 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    CFIndex v26 = Count;
    _os_log_error_impl(&dword_18298D000, v3, OS_LOG_TYPE_ERROR, "[rdar53306264-LW-S] %ld", buf, 0xCu);
  }

  if (Count >= 1)
  {
    for (CFIndex i = 0LL; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(this[17], i);
      uint64_t v6 = ValueAtIndex;
      if (ValueAtIndex)
      {
        uint64_t v7 = (*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 72LL))(ValueAtIndex);
        uint64_t v8 = (*(uint64_t (**)(const void *))(*(void *)v6 + 80LL))(v6);
        uint64_t v9 = v8;
        if (v8)
        {
          uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 32LL))(v8);
          (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v9 + 72LL))(&v23, v9);
        }

        else
        {
          uint64_t v10 = 0LL;
          uint64_t v23 = 0LL;
          __int128 v24 = 0LL;
        }

        uint64_t v13 = (*(uint64_t (**)(const void *))(*(void *)v6 + 64LL))(v6);
        uint64_t v11 = v13;
        if (v13) {
          uint64_t v12 = Tube::copyWaiter(*(Tube **)(v13 + 112));
        }
        else {
          uint64_t v12 = 0LL;
        }
      }

      else
      {
        uint64_t v11 = 0LL;
        uint64_t v10 = 0LL;
        uint64_t v7 = 0LL;
        uint64_t v9 = 0LL;
        uint64_t v12 = 0LL;
        uint64_t v23 = 0LL;
        __int128 v24 = 0LL;
      }

      v19[0] = MEMORY[0x1895F87A8];
      v19[1] = 3221225472LL;
      __int128 v20 = ___ZN11TubeManager32_onqueue_rdar53306264_logWaitersEv_block_invoke;
      __int128 v21 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v22 = v12;
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      uint64_t v14 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134219778;
        CFIndex v26 = i;
        __int16 v27 = 2048;
        uint64_t v28 = v6;
        __int16 v29 = 2048;
        uint64_t v30 = v7;
        __int16 v31 = 2048;
        uint64_t v32 = v9;
        __int16 v33 = 2048;
        uint64_t v34 = v10;
        __int16 v35 = 2114;
        uint64_t v36 = v23;
        __int16 v37 = 2048;
        uint64_t v38 = v11;
        __int16 v39 = 2048;
        uint64_t v40 = v12;
        _os_log_error_impl( &dword_18298D000,  v14,  OS_LOG_TYPE_ERROR,  "[rdar53306264-LW] W(%ld/%p) K(%p) C(%p) C.K(%p) C.T(%{public}@) T(%p) T.FW(%p)",  buf,  0x52u);
      }

      v20((uint64_t)v19);
      int v15 = v24;
      if (v24)
      {
        p_shared_owners = (unint64_t *)&v24->__shared_owners_;
        do
          unint64_t v17 = __ldaxr(p_shared_owners);
        while (__stlxr(v17 - 1, p_shared_owners));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
          std::__shared_weak_count::__release_weak(v15);
        }
      }
    }
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v18 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    CFIndex v26 = Count;
    _os_log_error_impl(&dword_18298D000, v18, OS_LOG_TYPE_ERROR, "[rdar53306264-LW-F] %ld", buf, 0xCu);
  }

void sub_182AA234C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void rdar46818402( uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  if (a9)
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a9 + 72LL))(a9);
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a9 + 64LL))(a9);
    uint64_t v15 = v14;
    BOOL v16 = a4 != 0;
    BOOL v17 = v13 != 0;
    BOOL v18 = v14 != 0;
    if (a4)
    {
      if (v13 && v14 != 0) {
        return;
      }
    }
  }

  else
  {
    BOOL v18 = 0;
    BOOL v17 = 0;
    uint64_t v15 = 0LL;
    uint64_t v13 = 0LL;
    BOOL v16 = a4 != 0;
  }

  uint64_t v46 = a8;
  uint64_t v47 = a7;
  uint64_t v20 = *(void *)(a1 + 136);
  if (v20) {
    uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 320LL))(v20);
  }
  else {
    uint64_t v21 = 0LL;
  }
  uint64_t v57 = v21;
  uint64_t v22 = (std::__shared_weak_count *)operator new(0x20uLL);
  v22->__vftable = (std::__shared_weak_count_vtbl *)off_189C17020;
  v22->__shared_owners_ = 0LL;
  v22->__shared_weak_owners_ = 0LL;
  v22[1].__vftable = (std::__shared_weak_count_vtbl *)v21;
  uint64_t v58 = v22;
  uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)a6 + 80LL))(a6);
  uint64_t v24 = v23;
  if (v23)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v23 + 72LL))(&v55, v23);
  }

  else
  {
    uint64_t v55 = 0LL;
    uint64_t v56 = 0LL;
  }

  BOOL v51 = v17;
  uint64_t v45 = a6;
  if (a9 && (v25 = (*(uint64_t (**)(uint64_t))(*(void *)a9 + 80LL))(a9), (uint64_t v26 = v25) != 0))
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v25 + 72LL))(&v53, v25);
  }

  else
  {
    uint64_t v26 = 0LL;
    uint64_t v53 = 0LL;
    uint64_t v54 = 0LL;
  }

  BOOL v27 = v18;
  BOOL v28 = v16;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  __int16 v29 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 138547202;
    uint64_t v60 = v21;
    __int16 v61 = 2048;
    uint64_t v62 = a1;
    __int16 v63 = 2048;
    uint64_t v64 = a2;
    __int16 v65 = 1024;
    int v66 = a3;
    __int16 v67 = 2048;
    uint64_t v68 = a4;
    __int16 v69 = 1024;
    int v70 = a5;
    __int16 v71 = 2048;
    uint64_t v72 = a9;
    __int16 v73 = 2048;
    uint64_t v74 = v46;
    __int16 v75 = 2048;
    uint64_t v76 = v47;
    __int16 v77 = 2048;
    uint64_t v78 = v13;
    __int16 v79 = 2048;
    uint64_t v80 = v15;
    __int16 v81 = 2048;
    uint64_t v82 = v26;
    __int16 v83 = 2114;
    uint64_t v84 = v53;
    __int16 v85 = 2048;
    uint64_t v86 = v45;
    __int16 v87 = 2048;
    uint64_t v88 = v24;
    __int16 v89 = 2114;
    uint64_t v90 = v55;
    _os_log_fault_impl( &dword_18298D000,  v29,  OS_LOG_TYPE_FAULT,  "[rdar46818402] C(%{public}@) T(%p) T.E(%ld:%d) T.K(%p) T.T(%d), W(%p [%ld/%ld]) W.K(%p) W.T(%p) W.C(%p) W.CT(%{pub lic}@), fW(%p) fW.C(%p) fW.CT(%{public}@)",  buf,  0x9Au);
  }

  int v30 = !v28;
  if (!a9) {
    int v30 = 1;
  }
  int v31 = v30 | !v51;
  if ((v31 & 1) != 0 || !v27)
  {
    uint64_t v41 = "waiterKey";
    if (a9)
    {
      int v42 = 615;
    }

    else
    {
      uint64_t v41 = "waiter";
      int v42 = 614;
    }

    if (!v28)
    {
      uint64_t v41 = "newTubeKey";
      int v42 = 613;
    }

    if (v31) {
      unint64_t v43 = v41;
    }
    else {
      unint64_t v43 = "waiterTube";
    }
    if (v31) {
      int v44 = v42;
    }
    else {
      int v44 = 616;
    }
    __assert_rtn("rdar46818402", "TubeManager.cpp", v44, v43);
  }

  uint64_t v32 = v54;
  if (v54)
  {
    p_shared_owners = (unint64_t *)&v54->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(p_shared_owners);
    while (__stlxr(v34 - 1, p_shared_owners));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

  __int16 v35 = v56;
  if (v56)
  {
    uint64_t v36 = (unint64_t *)&v56->__shared_owners_;
    do
      unint64_t v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }

  uint64_t v38 = v58;
  if (v58)
  {
    __int16 v39 = (unint64_t *)&v58->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

void sub_182AA2780( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_49(uint64_t a1)
{
  uint64_t v2 = *(CFArrayRef **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 80LL))(v3);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 88LL))(v3);
  (*(void (**)(__int128 *__return_ptr, uint64_t))(*(void *)v3 + 96LL))(&v7, v3);
  TubeManager::_onqueue_enqueueRequestForProtocol(v2, v4, v5, &v7, v3);
  (*(void (**)(void))(**(void **)(a1 + 40) + 48LL))(*(void *)(a1 + 40));
  return (*((uint64_t (**)(CFArrayRef *))*v2 + 6))(v2);
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_2_51( uint64_t a1, BaseAwaitingTube *a2)
{
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_3_52( void *a1, uint64_t a2)
{
  if (!a1[7]) {
    __assert_rtn("_onqueue_newTubeReady_block_invoke_3", "TubeManager.cpp", 919, "connCache != NULL");
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 104LL))( a2,  *(void *)(a1[4] + 8LL) + 24LL,  *(void *)(a1[5] + 8LL) + 24LL,  *(void *)(a1[6] + 8LL) + 48LL);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 56LL))(a2, 0LL);
  uint64_t v4 = a1[8];
  uint64_t v5 = *(void *)(v4 + 264);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 272);
  uint64_t v33 = v5;
  unint64_t v34 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    if (!v5) {
      goto LABEL_24;
    }
    uint64_t v9 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
    uint64_t v31 = v5;
    uint64_t v32 = v6;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  else
  {
    if (!v5) {
      goto LABEL_24;
    }
    uint64_t v9 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
    uint64_t v31 = v5;
    uint64_t v32 = 0LL;
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 40LL))(v9, &v31);
  uint64_t v11 = v32;
  if (v32)
  {
    uint64_t v12 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  uint64_t v14 = a1[9];
  uint64_t v29 = v33;
  int v30 = v34;
  if (v34)
  {
    uint64_t v15 = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v14 + 56LL))(v14, &v29);
  BOOL v17 = v30;
  if (v30)
  {
    BOOL v18 = (unint64_t *)&v30->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

void sub_182AA2A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t ___ZN11TubeManager22_onqueue_createNewTubeEP22HTTPConnectionCacheKey_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2) {
    (*(void (**)(void))(*(void *)v2 + 56LL))(*(void *)(a1 + 32));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
}

uint64_t ___ZN11TubeManager22_onqueue_createNewTubeEP22HTTPConnectionCacheKey_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = Tube::copyKey(*(Tube **)(v4 + 104));
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  unint64_t v10 = ___ZN11TubeManager31_onqueue_waitingForConnectivityEP4Tube40tcp_connection_unmet_conditions_reason_t_block_invoke;
  uint64_t v11 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v12 = v5;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZN11TubeManager31_onqueue_waitingForConnectivityEP4Tube40tcp_connection_unmet_conditions_reason_t_block_invoke_2;
  v8[3] = &__block_descriptor_56_e48_v16__0__BaseAwaitingTube________CFAllocator_iB_8l;
  v8[4] = v4;
  v8[5] = v5;
  v8[6] = a2;
  uint64_t v6 = *(const __CFArray **)(v3 + 136);
  v13.length = CFArrayGetCount(v6);
  v13.location = 0LL;
  CFArrayApplyFunction(v6, v13, (CFArrayApplierFunction)RetainableTypedArray<BaseAwaitingTube *>::_invoke, v8);
  return v10((uint64_t)v9);
}

void sub_182AA2BBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
}

uint64_t ___ZN11TubeManager31_onqueue_waitingForConnectivityEP4Tube40tcp_connection_unmet_conditions_reason_t_block_invoke( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48LL))(result);
  }
  return result;
}

uint64_t ___ZN11TubeManager31_onqueue_waitingForConnectivityEP4Tube40tcp_connection_unmet_conditions_reason_t_block_invoke_2( void *a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64LL))(a2);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 72LL))(a2);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80LL))(a2);
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7 && result != 0 && v4 == a1[4])
  {
    uint64_t v9 = result;
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v5 + 24LL))(v5, a1[5]);
    if ((_DWORD)result)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 176LL))(v9);
      if (!(_DWORD)result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 232LL))(v9);
        if ((_DWORD)result) {
          return (*(uint64_t (**)(uint64_t, void))(*(void *)v9 + 240LL))(v9, a1[6]);
        }
      }
    }
  }

  return result;
}

uint64_t ___ZN11TubeManager32_onqueue_rdar53306264_logWaitersEv_block_invoke(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48LL))(result);
  }
  return result;
}

void ___ZN11TubeManager21_onqueue_newTubeReadyEP4Tube13CFStreamError_block_invoke_41()
{
  os_log_t v0 = getenv("CFN_USE_HTTP2_CONNECTION_COALESCING");
  if (v0)
  {
    p_p = (char *)&__p;
    std::string::basic_string[abi:nn180100]<0>(&__p, v0);
    unsigned __int8 v2 = v8;
    if ((v8 & 0x80u) == 0) {
      uint64_t v3 = (char *)&__p + v8;
    }
    else {
      uint64_t v3 = (char *)__p + v7;
    }
    if ((v8 & 0x80u) != 0) {
      p_p = (char *)__p;
    }
    if (p_p != v3)
    {
      do
      {
        char *p_p = __tolower(*p_p);
        ++p_p;
      }

      while (p_p != v3);
      unsigned __int8 v2 = v8;
    }

    if ((v2 & 0x80) != 0)
    {
      uint64_t v4 = __p;
      switch(v7)
      {
        case 1LL:
          if (*(_BYTE *)__p != 48) {
            break;
          }
          goto LABEL_31;
        case 2LL:
          if (*(_WORD *)__p == 28526) {
            goto LABEL_31;
          }
          break;
        case 5LL:
          goto LABEL_18;
      }

void sub_182AA2E2C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCache>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C09728;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<HTTP3ConnectionCache>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C09728;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<HTTP3ConnectionCache>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void HTTP3ConnectionCacheWrapper::~HTTP3ConnectionCacheWrapper(id *this)
{
  *this = off_189C09678;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)(this + 4));
  *this = off_189C032B0;
}

void HTTP3ConnectionCacheWrapper::~HTTP3ConnectionCacheWrapper(HTTP3ConnectionCacheWrapper *this)
{
  *(void *)this = off_189C09678;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
  *(void *)this = off_189C032B0;

  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

CFStringRef HTTP3ConnectionCacheWrapper::copyDebugDesc(CFAllocatorRef *this)
{
  return CFStringCreateWithFormat( this[1],  0LL,  @"HTTP3ConnectionCacheWrapper<@%p> for HTTP3ConnectionCache<@%p>",  this,  this[4]);
}

void HTTP3ConnectionCacheWrapper::initWithSchedulingSet( HTTP3ConnectionCacheWrapper *this, const CoreSchedulingSet *a2, TubeManager *a3)
{
  uint64_t v4 = *((void *)this + 4);
  *(void *)(v4 + 64) = a2;
  (*(void (**)(const CoreSchedulingSet *))(*(void *)a2 + 40LL))(a2);
  *(void *)(v4 + 72) = a3;
  uint64_t v6 = *(void *)(v4 + 8);
  uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
  if (v5)
  {
    p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_weak_owners);
    while (__stxr(v8 + 1, p_shared_weak_owners));
    a3 = *(TubeManager **)(v4 + 72);
  }

  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(v4 + 64) + 80LL))(*(void *)(v4 + 64));
  unint64_t v10 = *(void **)(v4 + 104);
  *(void *)(v4 + 104) = v9;

  uint64_t v11 = *(dispatch_source_s **)(v4 + 104);
  uint64_t v12 = MEMORY[0x1895F87A8];
  handler[0] = MEMORY[0x1895F87A8];
  handler[1] = 3321888768LL;
  handler[2] = ___ZN20HTTP3ConnectionCache17_timersInitializeEv_block_invoke;
  handler[3] = &__block_descriptor_48_ea8_32c45_ZTSNSt3__18weak_ptrI20HTTP3ConnectionCacheEE_e5_v8__0l;
  handler[4] = v6;
  BOOL v18 = v5;
  if (v5)
  {
    CFRange v13 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  dispatch_source_set_event_handler(v11, handler);
  (*(void (**)(TubeManager *))(*(void *)a3 + 40LL))(a3);
  uint64_t v15 = *(dispatch_source_s **)(v4 + 104);
  v16[0] = v12;
  v16[1] = 3221225472LL;
  v16[2] = ___ZN20HTTP3ConnectionCache17_timersInitializeEv_block_invoke_2;
  v16[3] = &__block_descriptor_40_e5_v8__0l;
  v16[4] = a3;
  dispatch_source_set_cancel_handler(v15, v16);
  dispatch_source_set_timer(*(dispatch_source_t *)(v4 + 104), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  dispatch_resume(*(dispatch_object_t *)(v4 + 104));
  HTTP3ConnectionCache::enableCellTimer((HTTP3ConnectionCache *)v4);
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_182AA30AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (v20) {
    std::__shared_weak_count::__release_weak(v20);
  }
  _Unwind_Resume(exception_object);
}

void HTTP3ConnectionCacheWrapper::enqueueRequestForProtocol( uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  uint64_t v6 = *(const HTTPConnectionCacheKey **)(a1 + 32);
  __int128 v11 = *a4;
  uint64_t v12 = *((void *)a4 + 2);
  uint64_t v7 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 32LL))(a2);
  HTTP3ConnectionCache::_entryFindOrCreate((HTTP3ConnectionCache *)&v13, v6, v7);
  HTTP3ConnectionCacheEntry::enqueueRequestForProtocol(v13, a2, a3, (uint64_t)&v11);
  HTTP3ConnectionCache::_timersStart(v6);
  unint64_t v8 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

void sub_182AA3190( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14)
  {
    p_shared_owners = (unint64_t *)&a14->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
      std::__shared_weak_count::__release_weak(a14);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t HTTP3ConnectionCacheWrapper::ingestTube(HTTP3ConnectionCacheWrapper *this, Tube **a2, int a3)
{
  uint64_t v182 = *MEMORY[0x1895F89C0];
  uint64_t v3 = (const HTTPConnectionCacheKey *)*((void *)this + 4);
  uint64_t v4 = (const void *)Tube::copyKey(a2[13]);
  v159[0] = MEMORY[0x1895F87A8];
  v159[1] = 3221225472LL;
  unint64_t v160 = ___ZN20HTTP3ConnectionCache10ingestTubeEP4Tubeb_block_invoke;
  int v161 = &__block_descriptor_40_e5_v8__0l;
  unsigned int v162 = v4;
  char v151 = v3;
  HTTP3ConnectionCache::_entryFindOrCreate((HTTP3ConnectionCache *)&v157, v3, v4);
  uint64_t v5 = v157;
  uint64_t v6 = *(void *)(v157 + 104);
  uint64_t v7 = *(void *)(v157 + 112);
  if (v6 == v7) {
    goto LABEL_16;
  }
  LOBYTE(v8) = 0;
  do
  {
    uint64_t v9 = *(HTTP3Connection **)v6;
    unint64_t v10 = *(std::__shared_weak_count **)(v6 + 8);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }

    if (v8)
    {
      BOOL v8 = 1;
      if (!v10) {
        goto LABEL_14;
      }
    }

    else
    {
      BOOL v8 = HTTP3Connection::willEnqueueRequests(v9);
      if (!v10) {
        goto LABEL_14;
      }
    }

    CFRange v13 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }

void sub_182AA3F8C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, HTTP2ServerPush *a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19, char a20, uint64_t a21, void (*a22)(char *), uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, std::__shared_weak_count *a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, std::__shared_weak_count *a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, std::__shared_weak_count *a44)
{
  do
    unint64_t v47 = __ldaxr(v44);
  while (__stlxr(v47 - 1, v44));
  if (!v47)
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }

  if (a19)
  {
    p_shared_owners = (unint64_t *)&a19->__shared_owners_;
    do
      unint64_t v49 = __ldaxr(p_shared_owners);
    while (__stlxr(v49 - 1, p_shared_owners));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))a19->__on_zero_shared)(a19);
      std::__shared_weak_count::__release_weak(a19);
    }
  }

  a22(&a20);
  _Unwind_Resume(a1);
}

void HTTP3ConnectionCacheWrapper::logConnectionsAtAPSleep(HTTP3ConnectionCacheWrapper *this)
{
}

void HTTP3ConnectionCacheWrapper::invalidateAllConnections(HTTP3ConnectionCacheWrapper *this, char a2)
{
  uint64_t v3 = (CFTypeRef *)*((void *)this + 4);
  HTTP3ConnectionCache::_timersStop((HTTP3ConnectionCache *)v3);
  uint64_t v4 = CFGetAllocator(v3[11]);
  MutableCopy = CFDictionaryCreateMutableCopy(v4, 0LL, (CFDictionaryRef)v3[11]);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = ___ZN20HTTP3ConnectionCache21_connectionsRemoveAllEb_block_invoke;
  v6[3] = &__block_descriptor_41_e14_v24__0r_v8_v16l;
  v6[4] = v3;
  char v7 = a2;
  CFDictionaryApplyFunction( MutableCopy,  (CFDictionaryApplierFunction)RetainableTypedDict<HTTPConnectionCacheKey const*,HTTP3ConnectionCacheEntryWrapper *>::_visit,  v6);
  CFRelease(MutableCopy);
}

void sub_182AA43D4(_Unwind_Exception *a1)
{
}

void HTTP3ConnectionCacheWrapper::purgeIdleConnections(CFDictionaryRef **this)
{
}

void HTTP3ConnectionCacheWrapper::markReusedAfterAPSleepWake(HTTP3ConnectionCacheWrapper *this)
{
}

void HTTP3ConnectionCacheWrapper::enableCellTimer(HTTP3ConnectionCache **this)
{
}

uint64_t ___ZN11TubeManager24invalidateAllConnectionsEb_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 120LL))(a2, *(unsigned __int8 *)(a1 + 32));
}

uint64_t RetainableTypedArray<Tube *>::_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void ___ZN11TubeManager24invalidateAllConnectionsEb_block_invoke_2(int a1, Tube *this)
{
  *((_BYTE *)this + 216) = 0;
  Tube::_onqueue_cancel(this);
}

uint64_t ___ZN11TubeManager38invalidateUnpurgeableConnectionsForKeyEPK22HTTPConnectionCacheKey_block_invoke( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 128LL))(a2, *(void *)(a1 + 32));
}

uint64_t ___ZN11TubeManager32getPendingTubeForProtocolWithKeyEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKey_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80LL))(a2);
  if (result == *(void *)(a1 + 40))
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64LL))(a2);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  }

  return result;
}

uint64_t ___ZN11TubeManager14requestNewTubeEP16BaseAwaitingTubeU13block_pointerFvP4TubeE_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2) {
    (*(void (**)(void))(*(void *)v2 + 56LL))(*(void *)(a1 + 32));
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
}

const void *TubeManager::_onqueue_getValidAwaitingTubeForKey( CFArrayRef *this, const HTTPConnectionCacheKey *a2)
{
  CFIndex Count = CFArrayGetCount(this[17]);
  if (Count < 1) {
    return 0LL;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0LL;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(this[17], v6);
    uint64_t v8 = (*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 72LL))(ValueAtIndex);
    if ((*(unsigned int (**)(uint64_t, const HTTPConnectionCacheKey *))(*(void *)v8 + 24LL))(v8, a2))
    {
      if ((*(unsigned int (**)(const void *))(*(void *)ValueAtIndex + 112LL))(ValueAtIndex)
        && !(*(unsigned int (**)(const void *))(*(void *)ValueAtIndex + 128LL))(ValueAtIndex))
      {
        break;
      }
    }

    if (v5 == ++v6) {
      return 0LL;
    }
  }

  return ValueAtIndex;
}

CFIndex HTTPReadFilter::_streamImpl_Read( HTTPReadFilter *this, char *a2, CFIndex a3, CFStreamError *a4, unsigned __int8 *a5)
{
  unint64_t v10 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  __int16 v11 = *((_WORD *)this + 116);
  if ((v11 & 0x800) != 0)
  {
    a4->CFIndex domain = 4LL;
    SInt32 v13 = -1;
LABEL_12:
    a4->error = v13;
    *a5 = 1;
    pthread_mutex_unlock(v10);
    return -1LL;
  }

  if ((*((_WORD *)this + 116) & 0x4000) != 0)
  {
    a4->CFIndex domain = 4LL;
    SInt32 v13 = -4;
    goto LABEL_12;
  }

  if ((v11 & 1) != 0)
  {
    a4->CFIndex domain = 4LL;
    SInt32 v13 = -2095;
    goto LABEL_12;
  }

  unint64_t v12 = (const void *)*((void *)this + 26);
  if (v12 && !*((_BYTE *)this + 216))
  {
    CFTypeRef cf = CFRetain(v12);
    char v18 = 0;
    if (*((void *)this + 30) == -2LL
      && !HTTPReadFilter::readHeaderBytes((uint64_t)this, (uint64_t)&cf, 1, (UInt8 *)a2, a3, (uint64_t)a4))
    {
      char v16 = 1;
      *a5 = 1;
      pthread_mutex_unlock(v10);
    }

    else
    {
      if ((*((_WORD *)this + 116) & 0x20) != 0) {
        uint64_t v15 = HTTPReadFilter::doChunkedRead((uint64_t)this, (uint64_t)&cf, a2, a3, a4, a5);
      }
      else {
        uint64_t v15 = HTTPReadFilter::doPlainRead((uint64_t)this, (uint64_t)&cf, a2, a3, a4, a5);
      }
      a3 = v15;
      if (*a5)
      {
        if (!a4->error && (*((_WORD *)this + 116) & 0x200) != 0)
        {
          *a5 = 0;
          *((_WORD *)this + 116) |= 0x401u;
          v20.CFIndex domain = 0LL;
          *(void *)&v20.error = 0LL;
          CoreStreamBase::_signalEvent(this, 32LL, v20, 1);
          HTTPReadFilter::clearLargeDownloadFlag((uint64_t)this);
        }
      }

      else if (v15 >= 1 && HTTPReadFilter::canReadNoSignal((uint64_t)this))
      {
        v19.CFIndex domain = 0LL;
        *(void *)&v19.error = 0LL;
        CoreStreamBase::_signalEvent(this, 2LL, v19, 1);
      }

      char v16 = 0;
    }

    if (cf) {
      CFRelease(cf);
    }
    if ((v16 & 1) == 0) {
      goto LABEL_7;
    }
    return -1LL;
  }

  a4->CFIndex domain = 4LL;
  a4->error = -4;
  *((_WORD *)this + 116) |= 0x4000u;
  *a5 = 1;
  a3 = -1LL;
LABEL_7:
  pthread_mutex_unlock(v10);
  if (*((void *)this + 33))
  {
    (*(void (**)(void))(**((void **)this + 25) + 224LL))(*((void *)this + 25));
    *((void *)this + 33) = 0LL;
  }

  return a3;
}

void sub_182AA48B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPReadFilter::_streamImpl_CanRead(HTTPReadFilter *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v3 = (const void *)*((void *)this + 26);
  if (v3 && !*((_BYTE *)this + 216))
  {
    CFTypeRef cf = CFRetain(v3);
    uint64_t NoSignal = HTTPReadFilter::canReadNoSignal((uint64_t)this);
    if (cf) {
      CFRelease(cf);
    }
  }

  else
  {
    uint64_t NoSignal = 0LL;
    v7.CFIndex domain = 4LL;
    v7.error = -4;
    *((_WORD *)this + 116) |= 0x4000u;
  }

  pthread_mutex_unlock(v2);
  if (*((void *)this + 33))
  {
    (*(void (**)(void))(**((void **)this + 25) + 224LL))(*((void *)this + 25));
    *((void *)this + 33) = 0LL;
  }

  if (v7.error)
  {
    CoreStreamBase::_signalEvent(this, 8LL, v7, 1);
  }

  return NoSignal;
}

void sub_182AA49DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPReadFilter::_streamImpl_Open(CFReadStreamRef *this, CFStreamError *a2, unsigned __int8 *a3)
{
  clientContext.version = 0LL;
  clientContext.info = this;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFIndex v6 = (pthread_mutex_t *)(this + 17);
  pthread_mutex_lock((pthread_mutex_t *)(this + 17));
  CFReadStreamRef v7 = this[26];
  if (v7 && !*((_BYTE *)this + 216))
  {
    CFRetain(v7);
    CFReadStreamSetClient( this[26],  0x1BuLL,  (CFReadStreamClientCallBack)HTTPReadFilter::_httpRdFilterStreamCallBack,  &clientContext);
    uint64_t v8 = 1LL;
    if (CFReadStreamGetStatus(this[26]) || (uint64_t v8 = CFReadStreamOpen(this[26]), (_DWORD)v8))
    {
      a2->error = 0;
      *a3 = 1;
    }

    else
    {
      *a3 = 1;
      *a2 = CFReadStreamGetError(this[26]);
    }

    CFReadStreamRef v10 = this[26];
    if (v10) {
      CFRelease(v10);
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    a2->CFIndex domain = 4LL;
    a2->error = -4;
    *((_WORD *)this + 116) |= 0x4000u;
  }

  pthread_mutex_unlock(v6);
  return v8;
}

BOOL HTTPReadFilter::_streamImpl_OpenCompleted(HTTPReadFilter *this, CFStreamError *a2)
{
  uint64_t v3 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v4 = (__CFReadStream *)*((void *)this + 26);
  BOOL v5 = v4 && !*((_BYTE *)this + 216) && CFReadStreamGetStatus(v4) > kCFStreamStatusOpening;
  pthread_mutex_unlock(v3);
  return v5;
}

uint64_t HTTPReadFilter::_streamImpl_Close(HTTPReadFilter *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v3 = (__CFReadStream *)*((void *)this + 26);
  if (v3 && !*((_BYTE *)this + 216))
  {
    CFReadStreamSetClient(v3, 0LL, 0LL, 0LL);
    CFReadStreamClose(*((CFReadStreamRef *)this + 26));
    *((_BYTE *)this + 216) = 1;
  }

  return pthread_mutex_unlock(v2);
}

CFTypeRef HTTPReadFilter::_streamImpl_CopyProperty(HTTPReadFilter *this, const __CFString *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 406091237)
  {
    if (ExactString == 398808402)
    {
      uint64_t v9 = (const __CFData *)*((void *)this + 32);
      if (v9 && CFDataGetLength(v9) >= 1)
      {
        CFReadStreamRef v7 = (CFTypeRef *)MEMORY[0x189604DE8];
      }

      else
      {
        CFReadStreamRef v10 = (__CFReadStream *)*((void *)this + 26);
        if (v10 && !*((_BYTE *)this + 216))
        {
LABEL_25:
          CFTypeRef v8 = CFReadStreamCopyProperty(v10, a2);
          goto LABEL_26;
        }

        CFReadStreamRef v7 = (CFTypeRef *)MEMORY[0x189604DE0];
      }
    }

    else
    {
      if (ExactString != 402920877)
      {
LABEL_18:
        CFReadStreamRef v10 = (__CFReadStream *)*((void *)this + 26);
        if (!v10 || *((_BYTE *)this + 216)) {
          goto LABEL_20;
        }
        goto LABEL_25;
      }

      if ((*((_WORD *)this + 116) & 0x200) != 0) {
        CFReadStreamRef v7 = (CFTypeRef *)MEMORY[0x189604DE8];
      }
      else {
        CFReadStreamRef v7 = (CFTypeRef *)MEMORY[0x189604DE0];
      }
    }

    CFTypeRef v11 = *v7;
    goto LABEL_27;
  }

  if (ExactString == 446986240 || ExactString == 444831706)
  {
    if (!CFHTTPMessageIsHeaderComplete(*((CFHTTPMessageRef *)this + 28))) {
      goto LABEL_20;
    }
    CFIndex v6 = (const void *)*((void *)this + 28);
    if (!v6) {
      goto LABEL_20;
    }
    goto LABEL_14;
  }

  if (ExactString != 406091238) {
    goto LABEL_18;
  }
  CFIndex v6 = (const void *)*((void *)this + 26);
  if (v6)
  {
LABEL_14:
    CFTypeRef v8 = CFRetain(v6);
LABEL_26:
    CFTypeRef v11 = v8;
    goto LABEL_27;
  }

uint64_t HTTPReadFilter::_streamImpl_SetProperty(HTTPReadFilter *this, const __CFString *a2, const void *a3)
{
  CFIndex v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v7 = 0LL;
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 405050834)
  {
    if (ExactString <= 228814902)
    {
      if (ExactString != 104064896)
      {
        if (ExactString == 224669676) {
          goto LABEL_42;
        }
        goto LABEL_31;
      }

      int v10 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
      if ((const void *)*MEMORY[0x189604DE8] != a3)
      {
        *((_BYTE *)this + 234) = BYTE2(v10);
        *((_WORD *)this + 116) = v10 & 0x7FFF;
        unint64_t v12 = (const void *)*((void *)this + 26);
        if (v12)
        {
          if (!*((_BYTE *)this + 216))
          {
            CFRetain(v12);
            CFReadStreamSetProperty(*((CFReadStreamRef *)this + 26), a2, a3);
            SInt32 v13 = (const void *)*((void *)this + 26);
            if (v13) {
              CFRelease(v13);
            }
          }
        }

        goto LABEL_41;
      }

      __int16 v11 = *((_WORD *)this + 116) | 0x8000;
      goto LABEL_37;
    }

    if (ExactString == 228814903) {
      goto LABEL_42;
    }
    if (ExactString == 402920877)
    {
      int v10 = *((unsigned __int16 *)this + 116) | (*((unsigned __int8 *)this + 234) << 16);
      else {
        __int16 v11 = *((_WORD *)this + 116) & 0xFDFF;
      }
LABEL_37:
      *((_BYTE *)this + 234) = BYTE2(v10);
      *((_WORD *)this + 116) = v11;
LABEL_41:
      uint64_t v7 = 1LL;
      goto LABEL_42;
    }

uint64_t HTTPReadFilter::_streamImpl_deprecated_Schedule( HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFIndex v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v7 = (__CFReadStream *)*((void *)this + 26);
  if (v7 && !*((_BYTE *)this + 216)) {
    CFReadStreamScheduleWithRunLoop(v7, a2, a3);
  }
  return pthread_mutex_unlock(v6);
}

uint64_t HTTPReadFilter::_streamImpl_deprecated_Unschedule( HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  CFIndex v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v7 = (__CFReadStream *)*((void *)this + 26);
  if (v7 && !*((_BYTE *)this + 216)) {
    CFReadStreamUnscheduleFromRunLoop(v7, a2, a3);
  }
  return pthread_mutex_unlock(v6);
}

void non-virtual thunk to'HTTPReadFilter::~HTTPReadFilter(HTTPReadFilter *this)
{
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 8));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 120));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 120));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 128));
}

{
  HTTPReadFilter::~HTTPReadFilter((HTTPReadFilter *)((char *)this - 128));
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_SetProperty( HTTPReadFilter *this, const __CFString *a2, const void *a3)
{
  return HTTPReadFilter::_streamImpl_SetProperty((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

CFTypeRef non-virtual thunk to'HTTPReadFilter::_streamImpl_CopyProperty( HTTPReadFilter *this, const __CFString *a2)
{
  return HTTPReadFilter::_streamImpl_CopyProperty((HTTPReadFilter *)((char *)this - 120), a2);
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_Open( CFReadStreamRef *this, CFStreamError *a2, unsigned __int8 *a3)
{
  return HTTPReadFilter::_streamImpl_Open(this - 15, a2, a3);
}

BOOL non-virtual thunk to'HTTPReadFilter::_streamImpl_OpenCompleted( HTTPReadFilter *this, CFStreamError *a2)
{
  return HTTPReadFilter::_streamImpl_OpenCompleted((HTTPReadFilter *)((char *)this - 120), a2);
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_Close(HTTPReadFilter *this)
{
  return HTTPReadFilter::_streamImpl_Close((HTTPReadFilter *)((char *)this - 120));
}

CFIndex non-virtual thunk to'HTTPReadFilter::_streamImpl_Read( HTTPReadFilter *this, char *a2, CFIndex a3, CFStreamError *a4, unsigned __int8 *a5)
{
  return HTTPReadFilter::_streamImpl_Read((HTTPReadFilter *)((char *)this - 120), a2, a3, a4, a5);
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_CanRead(HTTPReadFilter *this)
{
  return HTTPReadFilter::_streamImpl_CanRead((HTTPReadFilter *)((char *)this - 120));
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_deprecated_Schedule( HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPReadFilter::_streamImpl_deprecated_Schedule((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

uint64_t non-virtual thunk to'HTTPReadFilter::_streamImpl_deprecated_Unschedule( HTTPReadFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPReadFilter::_streamImpl_deprecated_Unschedule((HTTPReadFilter *)((char *)this - 120), a2, a3);
}

void HTTPReadFilter::~HTTPReadFilter(HTTPReadFilter *this)
{
  *(void *)this = &off_189C09798;
  *((void *)this + 1) = &unk_189C09838;
  *((void *)this + 15) = &unk_189C09858;
  *((void *)this + 16) = &unk_189C09910;
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v3 = (__CFReadStream *)*((void *)this + 26);
  if (!v3)
  {
    *((void *)this + 26) = 0LL;
    goto LABEL_7;
  }

  if (*((_BYTE *)this + 216))
  {
    *((void *)this + 26) = 0LL;
  }

  else
  {
    CFReadStreamSetClient(v3, 0LL, 0LL, 0LL);
    CFReadStreamClose(*((CFReadStreamRef *)this + 26));
    uint64_t v3 = (__CFReadStream *)*((void *)this + 26);
    *((void *)this + 26) = 0LL;
    if (!v3) {
      goto LABEL_7;
    }
  }

  CFRelease(v3);
LABEL_7:
  uint64_t v4 = (const void *)*((void *)this + 28);
  *((void *)this + 28) = 0LL;
  if (v4) {
    CFRelease(v4);
  }
  BOOL v5 = (const void *)*((void *)this + 32);
  *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0LL;
  if (v5) {
    CFRelease(v5);
  }
  pthread_mutex_unlock(v2);
  *((void *)this + 16) = off_189C12668;
  pthread_mutex_destroy(v2);
  *(void *)this = &off_189C18298;
  *((void *)this + 1) = &unk_189C18300;
  *((void *)this + 15) = &unk_189C18320;
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_182AA51FC(_Unwind_Exception *a1)
{
  *((void *)v1 + 16) = off_189C12668;
  pthread_mutex_destroy(v2);
  *(void *)uint64_t v1 = &off_189C18298;
  *((void *)v1 + 1) = &unk_189C18300;
  *((void *)v1 + 15) = &unk_189C18320;
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

void HTTPReadFilter::_httpRdFilterStreamCallBack( HTTPReadFilter *this, __CFReadStream *a2, uint64_t a3, void *a4)
{
  uint64_t v7 = (pthread_mutex_t *)(a3 + 136);
  pthread_mutex_lock((pthread_mutex_t *)(a3 + 136));
  if (*(HTTPReadFilter **)(a3 + 208) != this || !this)
  {
    pthread_mutex_unlock(v7);
    return;
  }

  int v8 = *(unsigned __int8 *)(a3 + 216);
  pthread_mutex_unlock(v7);
  if (!v8)
  {
    uint64_t v9 = (const void *)(a3 - 16);
    CFRetain((CFTypeRef)(a3 - 16));
    if (a2 == (__CFReadStream *)16)
    {
      if (!(*(unsigned int (**)(uint64_t))(*(void *)a3 + 72LL))(a3))
      {
        v29.CFIndex domain = 0LL;
        *(void *)&v29.error = 0LL;
        CoreStreamBase::_signalEvent((CoreStreamBase *)a3, 16LL, v29, 1);
      }

      goto LABEL_37;
    }

    if (a2 == (__CFReadStream *)8)
    {
      pthread_mutex_lock(v7);
      unint64_t v12 = *(__CFReadStream **)(a3 + 208);
      if (v12 && !*(_BYTE *)(a3 + 216))
      {
        CFStreamError Error = CFReadStreamGetError(v12);
        CFIndex domain = Error.domain;
        unint64_t v14 = *(void *)&Error.error;
        if (Error.domain == 1 && (Error.error == 54 || Error.error == 32))
        {
          uint64_t v22 = *(void *)(a3 + 224);
          if (v22) {
            uint64_t v23 = (HTTPMessage *)(v22 + 16);
          }
          else {
            uint64_t v23 = 0LL;
          }
          HTTPMessage::ensureParserFinished(v23);
          if (!*((void *)v23 + 5)
            || (unint64_t v25 = (const __CFData **)*((void *)v23 + 6)) == 0LL
            || !HTTPBodyData::getLength(v25, v24))
          {
            unint64_t v14 = *(void *)&Error.error & 0xFFFFFFFF00000000LL | 0xFFFFFFFC;
            CFIndex domain = 4LL;
          }
        }
      }

      else
      {
        *(_WORD *)(a3 + 232) |= 0x4000u;
        CFIndex domain = 4LL;
        unint64_t v14 = 4294967292LL;
      }

      char v15 = (char *)CFRetain(v9);
      pthread_mutex_unlock(v7);
      if (!v15) {
        goto LABEL_37;
      }
      char v16 = (CoreStreamBase *)(v15 + 16);
      uint64_t v17 = 8LL;
      v18.CFIndex domain = domain;
      *(void *)&v18.error = v14;
    }

    else
    {
      if (a2 == (__CFReadStream *)2)
      {
        pthread_mutex_lock(v7);
        int v10 = (char *)CFRetain((CFTypeRef)(a3 - 16));
        pthread_mutex_unlock(v7);
        if (v10 && (*(unsigned int (**)(uint64_t))(*(void *)a3 + 72LL))(a3))
        {
          uint64_t v11 = 2LL;
          goto LABEL_11;
        }

        pthread_mutex_lock(v7);
        CFStreamError v20 = *(__CFReadStream **)(a3 + 208);
        if (v20 && !*(_BYTE *)(a3 + 216))
        {
          unint64_t v26 = CFReadStreamGetStatus(v20) - 8;
          pthread_mutex_unlock(v7);
          if (v26 <= 0xFFFFFFFFFFFFFFFCLL)
          {
            pthread_mutex_lock(v7);
            int v27 = *(unsigned __int16 *)(a3 + 232) | (*(unsigned __int8 *)(a3 + 234) << 16);
            if ((*(_WORD *)(a3 + 232) & 0x601) == 0x201)
            {
              *(_BYTE *)(a3 + 234) = BYTE2(v27);
              *(_WORD *)(a3 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v27 | 0x400;
              HTTPReadFilter::clearLargeDownloadFlag(a3);
              uint64_t v11 = 32LL;
            }

            else
            {
              uint64_t v11 = 0LL;
            }

            pthread_mutex_unlock(v7);
            if (v10)
            {
LABEL_11:
              if (v11)
              {
                v28.CFIndex domain = 0LL;
                *(void *)&v28.error = 0LL;
                CoreStreamBase::_signalEvent((CoreStreamBase *)(v10 + 16), v11, v28, 1);
                goto LABEL_35;
              }
            }
          }
        }

        else
        {
          pthread_mutex_unlock(v7);
        }

        if (v10)
        {
LABEL_35:
          CFStreamError v19 = v10;
          goto LABEL_36;
        }

uint64_t HTTPReadFilter::clearLargeDownloadFlag(uint64_t this)
{
  int v1 = *(unsigned __int16 *)(this + 232);
  if ((v1 & 0x40) != 0)
  {
    unsigned int v2 = v1 & 0xFFFFFFBF | (*(unsigned __int8 *)(this + 234) << 16);
    *(_WORD *)(this + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v1 & 0xFFBF;
    *(_BYTE *)(this + 234) = BYTE2(v2);
    if (*(void *)(this + 208))
    {
      if (!*(_BYTE *)(this + 216)) {
        return CFReadStreamSetProperty( *(CFReadStreamRef *)(this + 208),  (CFStreamPropertyKey)&unk_18C5AC598,  (CFTypeRef)*MEMORY[0x189604DE0]);
      }
    }
  }

  return this;
}

uint64_t HTTPReadFilter::canReadNoSignal(uint64_t a1)
{
  uint64_t v4 = MEMORY[0x1895F8858](a1);
  uint64_t result = 0LL;
  uint64_t v16 = *MEMORY[0x1895F89C0];
  *(_DWORD *)(v2 + 8) = 0;
  int v6 = *(unsigned __int16 *)(v4 + 232);
  unsigned int v7 = v6 | (*(unsigned __int8 *)(v4 + 234) << 16);
  if ((v6 & 1) == 0)
  {
    int v8 = v3;
    uint64_t v9 = (CFStreamError *)v2;
    int v10 = (CFReadStreamRef *)v1;
    uint64_t v11 = *(void *)(v4 + 240);
    if (v11 != -2)
    {
LABEL_6:
      if ((v7 & 0x20) != 0 && (v11 != -3 ? (BOOL v12 = v11 == *(void *)(v4 + 248)) : (BOOL v12 = 1), v12))
      {
        if ((v7 & 0x100) != 0) {
          return 1LL;
        }
        uint64_t result = HTTPReadFilter::readChunkedHeader(v4, (uint64_t)v10, 0, __dst, 4096LL, v9);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v11 = *(void *)(v4 + 240);
        if (v11 == -3) {
          return 0LL;
        }
        unsigned int v7 = *(unsigned __int16 *)(v4 + 232) | (*(unsigned __int8 *)(v4 + 234) << 16);
        int v13 = (v7 >> 8) & 1;
      }

      else
      {
        LOBYTE(v13) = 0;
      }

      if ((v13 & 1) == 0 && v11 == *(void *)(v4 + 248))
      {
        if ((v7 & 0x200) != 0)
        {
          uint64_t result = 0LL;
          *(_BYTE *)(v4 + 234) = BYTE2(v7);
          *(_WORD *)(v4 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v7 | 1;
          return result;
        }

        return 1LL;
      }

      unint64_t v14 = *(const __CFData **)(v4 + 256);
      if (v14 && CFDataGetLength(v14)) {
        return 1LL;
      }
      if (v8) {
        return CFReadStreamHasBytesAvailable(*v10) != 0;
      }
      return 0LL;
    }

    uint64_t result = HTTPReadFilter::readHeaderBytes(v4, v1, 0, __dst, 4096LL, v2);
    if ((_DWORD)result)
    {
      uint64_t result = CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(v4 + 224));
      if ((_DWORD)result)
      {
        unsigned int v7 = *(unsigned __int16 *)(v4 + 232) | (*(unsigned __int8 *)(v4 + 234) << 16);
        uint64_t v11 = *(void *)(v4 + 240);
        goto LABEL_6;
      }
    }
  }

  return result;
}

uint64_t HTTPReadFilter::readHeaderBytes(uint64_t a1, uint64_t a2, int a3, UInt8 *a4, CFIndex a5, uint64_t a6)
{
  BOOL v12 = (const __CFString *)&unk_18C5B24F8;
  int v13 = &TrustExceptionManager::_isSharingdProcess(void)::onceToken;
  while (2)
  {
    unint64_t v14 = *(const __CFData **)(a1 + 256);
    if (!v14)
    {
      CFStreamError v19 = (__CFHTTPMessage *)CFReadStreamCopyProperty(*(CFReadStreamRef *)a2, v12);
      if (!v19) {
        goto LABEL_18;
      }
      CFStreamError v20 = v19;
      CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v19);
      if (v13[238] != -1) {
        dispatch_once(&HTTPMessage::Class(void)::sOnce_HTTPMessage, &__block_literal_global_5084);
      }
      if (*((void *)v20 + 13))
      {
        CFRelease(v20);
        goto LABEL_18;
      }

      if (ResponseStatusCode == 200)
      {
        CFRelease(v20);
        int v22 = *(_WORD *)(a1 + 232) & 0xEFFF | (*(unsigned __int8 *)(a1 + 234) << 16);
        *(_WORD *)(a1 + 232) &= ~0x1000u;
        *(_BYTE *)(a1 + 234) = BYTE2(v22);
        goto LABEL_18;
      }

      uint64_t v23 = *(const void **)(a1 + 224);
      if (v23) {
        CFRelease(v23);
      }
      *(void *)(a1 + 224) = v20;
      int v24 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
      if (ResponseStatusCode == 407)
      {
        *(_BYTE *)(a1 + 234) = BYTE2(v24);
        *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v24 | 8;
        goto LABEL_18;
      }

      uint64_t result = 0LL;
      *(_BYTE *)(a1 + 234) = BYTE2(v24);
      *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v24 | 0x10;
      *(void *)a6 = 4LL;
      *(_DWORD *)(a6 + 8) = -2096;
      return result;
    }

    CFIndex Length = CFDataGetLength(v14);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
    int appended = CFHTTPMessageAppendBytes(*(CFHTTPMessageRef *)(a1 + 224), BytePtr, Length);
    CFStreamError v18 = *(const void **)(a1 + 256);
    if (v18) {
      CFRelease(v18);
    }
    *(void *)(a1 + 256) = 0LL;
    if (!appended)
    {
LABEL_81:
      uint64_t result = 0LL;
      *(void *)a6 = 4LL;
      *(_DWORD *)(a6 + 8) = -1;
      __int16 v54 = *(_WORD *)(a1 + 232);
      uint64_t v53 = (_WORD *)(a1 + 232);
      __int16 v55 = v54 | 0x800;
LABEL_95:
      *uint64_t v53 = v55;
      return result;
    }

LABEL_124:
    if (ArrayBySeparatingStrings) {
      CFRelease(ArrayBySeparatingStrings);
    }
    CFRelease(v68);
  }

  int v82 = *(unsigned __int16 *)(a1 + 232);
  int v83 = v82 | (*(unsigned __int8 *)(a1 + 234) << 16);
  if ((v82 & 0x20) != 0)
  {
    *(_BYTE *)(a1 + 234) = BYTE2(v83);
    *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v83 | 4;
    goto LABEL_137;
  }

  uint64_t v84 = HTTPFilter::expectedSizeFromHeaders(*(HTTPFilter **)(a1 + 224), v67);
  *(void *)(a1 + 240) = v84;
  if (v84 == -1)
  {
    if (CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusAtEnd
      || (__int16 v85 = *(const __CFData **)(a1 + 256)) != 0LL && CFDataGetLength(v85))
    {
      uint64_t v84 = *(void *)(a1 + 240);
      goto LABEL_133;
    }

uint64_t HTTPReadFilter::readChunkedHeader( uint64_t a1, uint64_t a2, int a3, _BYTE *__dst, CFIndex bufferLength, CFStreamError *a6)
{
  BOOL v12 = *(const __CFData **)(a1 + 256);
  if (!v12)
  {
    BytePtr = 0LL;
    CFIndex Length = 0LL;
LABEL_10:
    int v17 = 0;
    char v18 = 1;
    char v39 = 1;
LABEL_11:
    uint64_t v16 = 1LL;
    goto LABEL_15;
  }

  CFIndex Length = CFDataGetLength(v12);
  if (!Length)
  {
    BytePtr = 0LL;
    goto LABEL_10;
  }

  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
  if (!BytePtr)
  {
    char v39 = 0;
    int v17 = 0;
    char v18 = 1;
    goto LABEL_11;
  }

  if (HTTPReadFilter::setFilterForChunkedHeaderBytes((HTTPReadFilter *)a1, BytePtr, Length, &range, a6))
  {
    v15.location = range;
    uint64_t v16 = range != -1;
    if ((unint64_t)(range - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v15.length = Length - range;
      HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v15);
    }

    int v17 = 1;
  }

  else
  {
    int v17 = 0;
    uint64_t v16 = 1LL;
  }

  char v18 = 0;
  char v39 = 0;
LABEL_15:
  if (v17 | a3)
  {
    if (v17)
    {
LABEL_41:
      int v24 = 1;
      goto LABEL_44;
    }
  }

  else if (!CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2) {
         && CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusError)
  }
  {
    *(void *)(a1 + 240) = -3LL;
    goto LABEL_31;
  }

  unsigned int v38 = v16;
  CFIndex v19 = bufferLength - Length;
  if (bufferLength <= Length) {
    goto LABEL_43;
  }
  if ((v18 & 1) != 0)
  {
    CFIndex v20 = 0LL;
    CFIndex v19 = bufferLength;
  }

  else
  {
    memmove(__dst, BytePtr, Length);
    CFIndex v20 = Length;
  }

  *(_BYTE *)(a2 + 8) = 1;
  CFIndex v21 = CFReadStreamRead(*(CFReadStreamRef *)a2, &__dst[v20], v19);
  if (v21 < 0)
  {
    uint64_t v16 = 0LL;
    *a6 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
    goto LABEL_41;
  }

  CFIndex v22 = v21;
  if (!v21)
  {
    if (v20 == 2 && *__dst == 13 && __dst[1] == 10)
    {
      __int16 v25 = *(_WORD *)(a1 + 232);
      *(void *)(a1 + 240) = 0LL;
      *(void *)(a1 + 248) = 0LL;
      *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v25 | 0x100;
      goto LABEL_31;
    }

    uint64_t v16 = 0LL;
    a6->CFIndex domain = 4LL;
    a6->error = -1;
    *(_WORD *)(a1 + 232) |= 0x800u;
    goto LABEL_41;
  }

  *(void *)(a1 + 264) += v21;
  CFIndex v23 = v21 + Length;
  if (HTTPReadFilter::setFilterForChunkedHeaderBytes( (HTTPReadFilter *)a1,  __dst,  v21 + Length,  &range,  a6))
  {
    if (range != -1)
    {
      HTTPReadFilter::setDataForBytes((HTTPReadFilter *)a1, &__dst[range], v23 - range);
LABEL_31:
      int v24 = 1;
      uint64_t v16 = 1LL;
      goto LABEL_44;
    }

    uint64_t v16 = 0LL;
    goto LABEL_41;
  }

  if ((v39 & 1) == 0 && (*(_WORD *)(a1 + 232) & 2) != 0) {
    CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 256), &__dst[Length], v22);
  }
  else {
    HTTPReadFilter::setDataForBytes((HTTPReadFilter *)a1, __dst, v22 + Length);
  }
LABEL_43:
  int v24 = 0;
  uint64_t v16 = v38;
LABEL_44:
  uint64_t v26 = *(const void **)(a1 + 256);
  if (v26)
  {
    if ((*(_WORD *)(a1 + 232) & 2) != 0) {
      goto LABEL_50;
    }
    int v27 = CFGetAllocator(v26);
    CFMutableDataRef MutableCopy = CFDataCreateMutableCopy(v27, 0LL, *(CFDataRef *)(a1 + 256));
    int v29 = *(const void **)(a1 + 256);
    if (v29) {
      CFRelease(v29);
    }
  }

  else
  {
    int v30 = CFGetAllocator(*(CFTypeRef *)(a1 + 224));
    CFMutableDataRef MutableCopy = CFDataCreateMutable(v30, 0LL);
  }

  __int16 v31 = *(_WORD *)(a1 + 232);
  *(void *)(a1 + 256) = MutableCopy;
  *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v31 | 2;
LABEL_50:
  if (!v24)
  {
    if (a3) {
      goto LABEL_55;
    }
LABEL_53:
    if (CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)
      || CFReadStreamGetStatus(*(CFReadStreamRef *)a2) == kCFStreamStatusError)
    {
      while (1)
      {
LABEL_55:
        CFIndex v33 = CFDataGetLength(*(CFDataRef *)(a1 + 256));
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v33 + bufferLength);
        MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 256));
        *(_BYTE *)(a2 + 8) = 1;
        CFIndex v35 = CFReadStreamRead(*(CFReadStreamRef *)a2, &MutableBytePtr[v33], bufferLength);
        if (v35 < 0)
        {
          uint64_t v16 = 0LL;
          *a6 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
          return v16;
        }

        if (!v35)
        {
          uint64_t v16 = 0LL;
          a6->CFIndex domain = 4LL;
          a6->error = -1;
          *(_WORD *)(a1 + 232) |= 0x800u;
          return v16;
        }

        CFIndex v36 = v35 + v33;
        if (HTTPReadFilter::setFilterForChunkedHeaderBytes( (HTTPReadFilter *)a1,  MutableBytePtr,  v35 + v33,  &range,  a6)) {
          break;
        }
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v36);
        if (!a3) {
          goto LABEL_53;
        }
      }

      CFIndex v37 = range;
      uint64_t v16 = range != -1;
      if ((unint64_t)(range - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v41.location = 0LL;
        v41.length = range;
        CFDataDeleteBytes(*(CFMutableDataRef *)(a1 + 256), v41);
        CFDataSetLength(*(CFMutableDataRef *)(a1 + 256), v36 - v37);
      }
    }

    else
    {
      *(void *)(a1 + 240) = -3LL;
      return 1LL;
    }
  }

  return v16;
}

uint64_t HTTPReadFilter::setFilterForChunkedHeaderBytes( HTTPReadFilter *this, const unsigned __int8 *a2, uint64_t a3, uint64_t *a4, CFStreamError *a5)
{
  if ((*((_WORD *)this + 116) & 4) != 0)
  {
    uint64_t v8 = parseChunkedHeader(a2, a3, 1, a4);
    if (v8 == -3) {
      return 0LL;
    }
    int v9 = *((_WORD *)this + 116) & 0xFFFB | (*((unsigned __int8 *)this + 234) << 16);
    *((_WORD *)this + 116) &= ~4u;
    *((_BYTE *)this + 234) = BYTE2(v9);
  }

  else
  {
    uint64_t v8 = parseChunkedHeader(a2, a3, 0, a4);
  }

  if (v8 == -3) {
    return 0LL;
  }
  if (v8 == -1)
  {
    *a4 = -1LL;
    a5->CFIndex domain = 4LL;
    a5->error = -1;
    __int16 v10 = 2048;
LABEL_11:
    *((_WORD *)this + 116) |= v10;
    return 1LL;
  }

  a5->error = 0;
  *((void *)this + 30) = v8;
  *((void *)this + 31) = 0LL;
  if (!v8)
  {
    __int16 v10 = 256;
    goto LABEL_11;
  }

  return 1LL;
}

void HTTPReadFilter::setDataForRange(HTTPReadFilter *this, CFRange a2)
{
  if (a2.length <= 0)
  {
    uint64_t v11 = (const void *)*((void *)this + 32);
    if (v11) {
      CFRelease(v11);
    }
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0LL;
  }

  else
  {
    CFIndex length = a2.length;
    CFIndex location = a2.location;
    if ((*((_WORD *)this + 116) & 2) != 0)
    {
      if (a2.location >= 1)
      {
        v12.CFIndex location = 0LL;
        v12.CFIndex length = location;
        CFDataDeleteBytes(*((CFMutableDataRef *)this + 32), v12);
      }

      CFDataSetLength(*((CFMutableDataRef *)this + 32), length);
    }

    else
    {
      BOOL v5 = CFGetAllocator(*((CFTypeRef *)this + 32));
      Mutable = CFDataCreateMutable(v5, 0LL);
      BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 32));
      CFDataAppendBytes(Mutable, &BytePtr[location], length);
      uint64_t v8 = (const void *)*((void *)this + 32);
      if (v8) {
        CFRelease(v8);
      }
      __int16 v10 = *((_WORD *)this + 116);
      int v9 = (char *)this + 232;
      *((void *)v9 + 3) = Mutable;
      *(_WORD *)int v9 = v10 | 2;
    }
  }

void HTTPReadFilter::setDataForBytes(HTTPReadFilter *this, const unsigned __int8 *a2, CFIndex a3)
{
  int v6 = (const void *)*((void *)this + 32);
  if (v6) {
    CFRelease(v6);
  }
  if (a3)
  {
    unsigned int v7 = CFGetAllocator(*((CFTypeRef *)this + 28));
    Mutable = CFDataCreateMutable(v7, 0LL);
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = Mutable;
    CFDataAppendBytes(Mutable, a2, a3);
    *((_WORD *)this + 116) |= 2u;
  }

  else
  {
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0LL;
  }

uint64_t parseChunkedHeader(const unsigned __int8 *a1, uint64_t a2, int a3, uint64_t *a4)
{
  uint64_t v4 = &a1[a2];
  CFIndex i = a1;
  if (!a3)
  {
    CFIndex i = a1;
    if (a2)
    {
      uint64_t v10 = a2;
      for (CFIndex i = a1; ; ++i)
      {
        unsigned int v11 = *i;
        BOOL v12 = v11 > 0x20;
        uint64_t v13 = (1LL << v11) & 0x100002600LL;
        if (v12 || v13 == 0) {
          break;
        }
        if (!--v10) {
          return -3LL;
        }
      }
    }

    if (i == v4) {
      return -3LL;
    }
  }

  if (i >= v4)
  {
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 0LL;
    unsigned int v7 = (const unsigned __int8 *)(&a1[a2] - i);
    do
    {
      int v8 = *i;
      if ((v8 - 48) >= 0xA)
      {
        if ((v8 - 65) >= 6)
        {
          int v9 = -87;
        }

        else
        {
          int v9 = -55;
        }
      }

      else
      {
        int v9 = -48;
      }

      uint64_t v6 = (v9 + v8) + 16 * v6;
      ++i;
      --v7;
    }

    while (v7);
    CFIndex i = &a1[a2];
  }

uint64_t HTTPReadFilter::doChunkedRead( uint64_t a1, uint64_t a2, char *__dst, CFIndex bufferLength, CFStreamError *a5, _BYTE *a6)
{
  *a6 = 0;
  a5->error = 0;
  if (bufferLength < 1) {
    return 0LL;
  }
  CFIndex v7 = bufferLength;
  uint64_t v11 = 0LL;
  while ((*(_WORD *)(a1 + 232) & 0x100) == 0)
  {
    uint64_t v12 = *(void *)(a1 + 240);
    if (v12 == -3 || (uint64_t v13 = *(void *)(a1 + 248), v12 == v13))
    {
      uint64_t v12 = *(void *)(a1 + 240);
      if (v12 == -3) {
        return v11;
      }
      if (!v12) {
        break;
      }
      uint64_t v13 = *(void *)(a1 + 248);
    }

    CFIndex v14 = v12 - v13;
    CFRange v15 = *(const __CFData **)(a1 + 256);
    if (v15)
    {
      BytePtr = CFDataGetBytePtr(v15);
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 256));
      CFIndex v18 = Length;
      if (Length >= v14) {
        int64_t v19 = v14;
      }
      else {
        int64_t v19 = Length;
      }
      if (v19 >= v7) {
        size_t v20 = v7;
      }
      else {
        size_t v20 = v19;
      }
      memmove(__dst, BytePtr, v20);
      v7 -= v20;
      v11 += v20;
      *(void *)(a1 + 248) += v20;
      v25.CFIndex length = v18 - v20;
      v25.CFIndex location = v20;
      HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v25);
      if (!v7) {
        return v11;
      }
      __dst += v20;
      v14 -= v20;
    }

    if (v14)
    {
      if (v11 >= 1
        && !CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2)
        && CFReadStreamGetStatus(*(CFReadStreamRef *)a2) != kCFStreamStatusError)
      {
        return v11;
      }

      if (v14 >= v7) {
        CFIndex v21 = v7;
      }
      else {
        CFIndex v21 = v14;
      }
      *(_BYTE *)(a2 + 8) = 1;
      CFIndex v22 = CFReadStreamRead(*(CFReadStreamRef *)a2, (UInt8 *)__dst, v21);
      if (v22 < 0)
      {
        *a5 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
        return -1LL;
      }

      if (!v22)
      {
        a5->CFIndex domain = 4LL;
        a5->error = -1;
        *(_WORD *)(a1 + 232) |= 0x800u;
        return -1LL;
      }

      *(void *)(a1 + 264) += v22;
      __dst += v22;
      v7 -= v22;
      v11 += v22;
      *(void *)(a1 + 248) += v22;
    }

    if (v7 <= 0) {
      return v11;
    }
  }

  *a6 = 1;
  return -1LL;
}

uint64_t HTTPReadFilter::doPlainRead( uint64_t a1, uint64_t a2, void *a3, int64_t a4, CFStreamError *a5, _BYTE *a6)
{
  int64_t v8 = a4;
  *a6 = 0;
  a5->error = 0;
  uint64_t v12 = *(void *)(a1 + 240);
  if (v12 != -1)
  {
    int64_t v13 = v12 - *(void *)(a1 + 248);
    if (v13 < a4) {
      int64_t v8 = v13;
    }
  }

  if (!v8)
  {
    uint64_t v18 = 0LL;
    *a6 = 1;
    return v18;
  }

  CFIndex v14 = *(const __CFData **)(a1 + 256);
  if (!v14)
  {
    uint64_t v18 = 0LL;
    goto LABEL_15;
  }

  BytePtr = CFDataGetBytePtr(v14);
  int64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 256));
  CFIndex v17 = Length - v8;
  if (Length <= v8)
  {
    uint64_t v18 = Length;
    memcpy(a3, BytePtr, Length);
    int64_t v19 = *(const void **)(a1 + 256);
    if (v19) {
      CFRelease(v19);
    }
    *(void *)(a1 + 256) = 0LL;
    if (v18 && (v18 >= v8 || !CFReadStreamHasBytesAvailable(*(CFReadStreamRef *)a2))) {
      goto LABEL_19;
    }
LABEL_15:
    *(_BYTE *)(a2 + 8) = 1;
    CFIndex v20 = CFReadStreamRead(*(CFReadStreamRef *)a2, (UInt8 *)a3 + v18, v8 - v18);
    if (v20 < 0)
    {
      *a5 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
      *a6 = 1;
      return -1LL;
    }

    if (!v20
      || (*(void *)(a1 + 264) += v20, v18 += v20,
                                        CFReadStreamGetStatus(*(CFReadStreamRef *)a2) == kCFStreamStatusAtEnd))
    {
      *a6 = 1;
    }

    goto LABEL_19;
  }

  memcpy(a3, BytePtr, v8);
  v25.CFIndex location = v8;
  v25.CFIndex length = v17;
  HTTPReadFilter::setDataForRange((HTTPReadFilter *)a1, v25);
  uint64_t v18 = v8;
LABEL_19:
  if (v18 >= 1)
  {
    uint64_t v21 = *(void *)(a1 + 240);
    uint64_t v22 = *(void *)(a1 + 248) + v18;
    *(void *)(a1 + 248) = v22;
    if (v21 != -1 && v22 >= v21)
    {
      *a6 = 1;
      uint64_t v21 = *(void *)(a1 + 240);
    }

    if (v21 > 0x4000)
    {
      int v23 = *(unsigned __int16 *)(a1 + 232) | (*(unsigned __int8 *)(a1 + 234) << 16);
      if ((*(_WORD *)(a1 + 232) & 0x8040) == 0x8000)
      {
        *(_BYTE *)(a1 + 234) = BYTE2(v23);
        *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v23 | 0x40;
        CFReadStreamSetProperty( *(CFReadStreamRef *)a2,  (CFStreamPropertyKey)&unk_18C5AC598,  (CFTypeRef)*MEMORY[0x189604DE8]);
      }
    }
  }

  return v18;
}

uint64_t HTTPReadFilter::readChunkedTrailers(uint64_t a1, uint64_t a2, CFStreamError *a3)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v6 = CFGetAllocator((CFTypeRef)(a1 - 16));
  CFHTTPMessageRef Empty = CFHTTPMessageCreateEmpty(v6, 0);
  CFHTTPMessageAppendBytes(Empty, (const UInt8 *)"HTTP/1.0 200 OK\r\n", 17LL);
  int64_t v8 = *(const __CFData **)(a1 + 256);
  if (!v8)
  {
    LOBYTE(appended) = 1;
    goto LABEL_7;
  }

  CFIndex Length = CFDataGetLength(v8);
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 256));
  int appended = CFHTTPMessageAppendBytes(Empty, BytePtr, Length);
  uint64_t v12 = *(const void **)(a1 + 256);
  if (v12) {
    CFRelease(v12);
  }
  *(void *)(a1 + 256) = 0LL;
  if (appended)
  {
    while (1)
    {
LABEL_7:
      if (!*((void *)Empty + 13)) {
        break;
      }
      *(_BYTE *)(a2 + 8) = 1;
      uint64_t v13 = CFReadStreamRead(*(CFReadStreamRef *)a2, buffer, 2048LL);
      if (v13 <= 0)
      {
        if (v13)
        {
          *a3 = CFReadStreamGetError((CFReadStreamRef)*(void *)a2);
        }

        else
        {
          a3->CFIndex domain = 4LL;
          a3->error = -1;
          *(_WORD *)(a1 + 232) |= 0x800u;
        }

        LOBYTE(appended) = 0;
        goto LABEL_21;
      }

      *(void *)(a1 + 264) += v13;
      int v14 = CFHTTPMessageAppendBytes(Empty, buffer, v13);
      LOBYTE(appended) = v14;
      if (!v14) {
        goto LABEL_21;
      }
    }

    HTTPMessage::ensureParserFinished((CFHTTPMessageRef)((char *)Empty + 16));
    int v16 = (HTTPBodyData *)*((void *)Empty + 8);
    *((void *)Empty + 8) = 0LL;
    if (v16)
    {
      BOOL v17 = HTTPBodyData::captureData(v16, v15);
      uint64_t v19 = v18;
      (*(void (**)(HTTPBodyData *))(*(void *)v16 + 8LL))(v16);
      int v20 = *(_WORD *)(a1 + 232) & 0xFFFD | (*(unsigned __int8 *)(a1 + 234) << 16);
      *(_WORD *)(a1 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = *(_WORD *)(a1 + 232) & 0xFFFD | (2 * v17);
      *(_BYTE *)(a1 + 234) = BYTE2(v20);
      *(void *)(a1 + 256) = v19;
    }

    uint64_t v21 = CFHTTPMessageCopyAllHeaderFields(Empty);
    if (v21)
    {
      uint64_t v22 = v21;
      CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)_addTrailingHeader, *(void **)(a1 + 224));
      CFRelease(v22);
    }
  }

LABEL_21:
  CFRelease(Empty);
  return appended;
}

  BOOL v5 = CFGetAllocator((CFTypeRef)(v1 - 16));
  return __cfnCreateCFError(v5, v4, v3, v6, v7, v8, v9, v10, 0LL);
}

void _addTrailingHeader(CFStringRef headerField, CFStringRef a2, CFHTTPMessageRef message)
{
  CFStringRef v6 = CFHTTPMessageCopyHeaderFieldValue(message, headerField);
  if (v6)
  {
    CFStringRef v7 = v6;
    int64_t v8 = CFGetAllocator(message);
    a2 = CFStringCreateWithFormat(v8, 0LL, @"%@, %@", v7, a2);
    CFRelease(v7);
  }

  else
  {
    CFRetain(a2);
  }

  CFHTTPMessageSetHeaderFieldValue(message, headerField, a2);
  CFRelease(a2);
}

CFIndex HTTPWriteFilter::_streamImpl_Write( HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  a4->error = 0;
  int64_t v8 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  __int16 v9 = *((_WORD *)this + 112);
  if ((v9 & 0x20) != 0)
  {
    pthread_mutex_unlock(v8);
    return 0LL;
  }

  if ((v9 & 0x40) != 0)
  {
    a4->CFIndex domain = 4LL;
    SInt32 v10 = -2096;
    goto LABEL_8;
  }

  if ((*((_WORD *)this + 112) & 0x400) != 0 && (v9 & 1) != 0)
  {
    a4->CFIndex domain = 4LL;
    SInt32 v10 = -2095;
LABEL_8:
    a4->error = v10;
LABEL_9:
    pthread_mutex_unlock(v8);
    return -1LL;
  }

  if (!*((void *)this + 26)) {
    goto LABEL_9;
  }
  if ((v9 & 0x10) != 0)
  {
    if (a4->error) {
      goto LABEL_9;
    }
  }

  else
  {
    a4->CFIndex domain = HTTPWriteFilter::transmitHeader(this, (__CFHTTPMessage *)1);
    *(void *)&a4->error = v13;
    if ((_DWORD)v13) {
      goto LABEL_9;
    }
  }

  if ((*((_WORD *)this + 112) & 0x80) == 0)
  {
    uint64_t v15 = *((void *)this + 30);
    uint64_t v14 = *((void *)this + 31);
    BOOL v16 = __OFSUB__(v15, v14);
    uint64_t v17 = v15 - v14;
    if ((v17 < 0) ^ v16 | (v17 == 0))
    {
      pthread_mutex_unlock(v8);
      (*(void (**)(void, void))(**((void **)this + 25) + 216LL))( *((void *)this + 25),  *((void *)this + 36));
      CFIndex v11 = 0LL;
    }

    else
    {
      if (v17 >= a3) {
        CFIndex v18 = a3;
      }
      else {
        CFIndex v18 = v17;
      }
      CFIndex v19 = CFWriteStreamWrite(*((CFWriteStreamRef *)this + 26), a2, v18);
      if (v19 < 0)
      {
        *a4 = CFWriteStreamGetError((CFWriteStreamRef)*((void *)this + 26));
        goto LABEL_9;
      }

      CFIndex v11 = v19;
      *((void *)this + 31) += v19;
      *((void *)this + 36) += v19;
      pthread_mutex_unlock(v8);
      (*(void (**)(void, void))(**((void **)this + 25) + 216LL))( *((void *)this + 25),  *((void *)this + 36));
    }

    *((void *)this + 36) = 0LL;
    return v11;
  }

  uint64_t v20 = HTTPWriteFilter::doChunkedWrite(this, a2, a3, a4);
  pthread_mutex_unlock(v8);
  (*(void (**)(void, void))(**((void **)this + 25) + 216LL))( *((void *)this + 25),  *((void *)this + 36));
  *((void *)this + 36) = 0LL;
  return v20;
}

uint64_t HTTPWriteFilter::_streamImpl_Open(__CFWriteStream **this, CFStreamError *a2, unsigned __int8 *a3)
{
  clientContext.version = 0LL;
  clientContext.info = this;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFStringRef v6 = (pthread_mutex_t *)(this + 17);
  pthread_mutex_lock((pthread_mutex_t *)(this + 17));
  CFStringRef v7 = this[26];
  if (v7)
  {
    CFWriteStreamSetClient( v7,  0x1CuLL,  (CFWriteStreamClientCallBack)HTTPWriteFilter::_httpWrFilterSocketStreamCallBack,  &clientContext);
    uint64_t v8 = 1LL;
    if (CFWriteStreamGetStatus(this[26]) || (uint64_t v8 = CFWriteStreamOpen(this[26]), (_DWORD)v8))
    {
      a2->error = 0;
      *a3 = 1;
    }

    else
    {
      *a3 = 1;
      *a2 = CFWriteStreamGetError(this[26]);
    }
  }

  else
  {
    uint64_t v8 = 0LL;
    a2->CFIndex domain = 4LL;
    a2->error = -4;
  }

  pthread_mutex_unlock(v6);
  return v8;
}

BOOL HTTPWriteFilter::_streamImpl_OpenCompleted(HTTPWriteFilter *this, CFStreamError *a2)
{
  int v3 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  uint64_t v4 = (__CFWriteStream *)*((void *)this + 26);
  if (v4) {
    BOOL v5 = CFWriteStreamGetStatus(v4) > kCFStreamStatusOpening;
  }
  else {
    BOOL v5 = 0LL;
  }
  pthread_mutex_unlock(v3);
  return v5;
}

uint64_t HTTPWriteFilter::_streamImpl_Close(HTTPWriteFilter *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int v3 = (__CFWriteStream *)*((void *)this + 26);
  if (v3)
  {
    CFWriteStreamClose(v3);
    CFWriteStreamSetClient(*((CFWriteStreamRef *)this + 26), 0LL, 0LL, 0LL);
    uint64_t v4 = (const void *)*((void *)this + 26);
    *((void *)this + 26) = 0LL;
    if (v4) {
      CFRelease(v4);
    }
  }

  return pthread_mutex_unlock(v2);
}

CFTypeRef HTTPWriteFilter::_streamImpl_CopyProperty(HTTPWriteFilter *this, const __CFString *a2)
{
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 404035005)
  {
    if (ExactString <= 395834626)
    {
      if (ExactString == 224669676)
      {
        if ((*((_WORD *)this + 112) & 0x108) == 8) {
          goto LABEL_29;
        }
        CFStringRef v7 = (const void *)*((void *)this + 33);
        if (!v7) {
          goto LABEL_39;
        }
      }

      else
      {
        if (ExactString != 228814903 || (*((_WORD *)this + 112) & 0x108) == 8) {
          goto LABEL_29;
        }
        CFStringRef v7 = (const void *)*((void *)this + 34);
        if (!v7) {
          goto LABEL_39;
        }
      }

unint64_t HTTPWriteFilter::_streamImpl_SetProperty( HTTPWriteFilter *this, const __CFString *a2, unint64_t a3)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 401864092)
  {
    if (ExactString > 231968870)
    {
      if (ExactString != 231968871)
      {
        if (ExactString == 395834627)
        {
          __int16 v23 = *((_WORD *)this + 112);
          if (*MEMORY[0x189604DE8] == a3) {
            __int16 v12 = v23 | 0x8000;
          }
          else {
            __int16 v12 = v23 & 0x7FFF;
          }
          goto LABEL_73;
        }

        if (ExactString == 401003905)
        {
          SInt32 v10 = (const void *)*((void *)this + 29);
          if (v10) {
            _Block_release(v10);
          }
          if (a3) {
            CFTypeRef v11 = _Block_copy((const void *)a3);
          }
          else {
            CFTypeRef v11 = 0LL;
          }
          *((void *)this + 29) = v11;
          goto LABEL_74;
        }

        goto LABEL_64;
      }

      CFTypeID v20 = CFGetTypeID((CFTypeRef)a3);
      if (v20 != CFDictionaryGetTypeID()) {
        goto LABEL_66;
      }
      if ((*((_WORD *)this + 112) & 0x108) == 8) {
        goto LABEL_74;
      }
      uint64_t v21 = (const void *)*((void *)this + 35);
      if (v21 != (const void *)a3)
      {
        if (v21) {
          CFRelease(v21);
        }
        if (a3) {
          CFTypeRef v22 = CFRetain((CFTypeRef)a3);
        }
        else {
          CFTypeRef v22 = 0LL;
        }
        *((void *)this + 35) = v22;
      }

      BOOL v42 = (const void *)*((void *)this + 33);
      *((void *)this + 33) = 0LL;
      if (v42) {
        CFRelease(v42);
      }
      uint64_t v41 = (const void *)*((void *)this + 34);
      *((void *)this + 34) = 0LL;
      if (!v41) {
        goto LABEL_74;
      }
LABEL_107:
      CFRelease(v41);
      goto LABEL_74;
    }

    if (ExactString == 224669676)
    {
      CFTypeID v26 = CFGetTypeID((CFTypeRef)a3);
      if (v26 != CFDataGetTypeID()) {
        goto LABEL_66;
      }
      if ((*((_WORD *)this + 112) & 0x108) != 8)
      {
        unsigned int v27 = (const void *)*((void *)this + 33);
        if (v27 != (const void *)a3)
        {
          if (v27) {
            CFRelease(v27);
          }
          if (a3) {
            CFTypeRef v28 = CFRetain((CFTypeRef)a3);
          }
          else {
            CFTypeRef v28 = 0LL;
          }
          *((void *)this + 33) = v28;
        }

        unsigned int v40 = (const void *)*((void *)this + 34);
        *((void *)this + 34) = 0LL;
        if (v40) {
          goto LABEL_99;
        }
        goto LABEL_100;
      }
    }

    else
    {
      if (ExactString != 228814903) {
        goto LABEL_64;
      }
      CFTypeID v13 = CFGetTypeID((CFTypeRef)a3);
      if (v13 != SSLContextGetTypeID()) {
        goto LABEL_66;
      }
      if ((*((_WORD *)this + 112) & 0x108) != 8)
      {
        uint64_t v14 = (const void *)*((void *)this + 34);
        if (v14 != (const void *)a3)
        {
          if (v14) {
            CFRelease(v14);
          }
          if (a3) {
            CFTypeRef v15 = CFRetain((CFTypeRef)a3);
          }
          else {
            CFTypeRef v15 = 0LL;
          }
          *((void *)this + 34) = v15;
        }

        unsigned int v40 = (const void *)*((void *)this + 33);
        *((void *)this + 33) = 0LL;
        if (v40) {
LABEL_99:
        }
          CFRelease(v40);
LABEL_100:
        uint64_t v41 = (const void *)*((void *)this + 35);
        *((void *)this + 35) = 0LL;
        if (!v41) {
          goto LABEL_74;
        }
        goto LABEL_107;
      }
    }

LABEL_74:
    a3 = 1LL;
    goto LABEL_75;
  }

  if (ExactString > 407246327)
  {
    switch(ExactString)
    {
      case 407246328:
        __int16 v24 = *((_WORD *)this + 112);
        if (*MEMORY[0x189604DE8] == a3) {
          __int16 v12 = v24 | 0x1000;
        }
        else {
          __int16 v12 = v24 & 0xEFFF;
        }
        goto LABEL_73;
      case 408311313:
        __int16 v25 = *((_WORD *)this + 112);
        if (*MEMORY[0x189604DE8] == a3) {
          __int16 v12 = v25 | 0x4000;
        }
        else {
          __int16 v12 = v25 & 0xBFFF;
        }
        goto LABEL_73;
      case 558087215:
        if (*(_BYTE *)(*((void *)this + 25) + 251LL))
        {
          __int16 v12 = *((_WORD *)this + 112) & 0xFFCF;
LABEL_73:
          *((_WORD *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v12;
          goto LABEL_74;
        }

        goto LABEL_66;
    }

uint64_t HTTPWriteFilter::_streamImpl_deprecated_Schedule( HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  CFStringRef v7 = (__CFWriteStream *)*((void *)this + 26);
  if (v7) {
    CFWriteStreamScheduleWithRunLoop(v7, a2, a3);
  }
  return pthread_mutex_unlock(v6);
}

uint64_t HTTPWriteFilter::_streamImpl_deprecated_Unschedule( HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  CFStringRef v7 = (__CFWriteStream *)*((void *)this + 26);
  if (v7) {
    CFWriteStreamUnscheduleFromRunLoop(v7, a2, a3);
  }
  return pthread_mutex_unlock(v6);
}

void non-virtual thunk to'HTTPWriteFilter::~HTTPWriteFilter(HTTPWriteFilter *this)
{
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 8));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 120));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 120));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 128));
}

{
  HTTPWriteFilter::~HTTPWriteFilter((HTTPWriteFilter *)((char *)this - 128));
}

unint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_SetProperty( HTTPWriteFilter *this, const __CFString *a2, unint64_t a3)
{
  return HTTPWriteFilter::_streamImpl_SetProperty((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

CFTypeRef non-virtual thunk to'HTTPWriteFilter::_streamImpl_CopyProperty( HTTPWriteFilter *this, const __CFString *a2)
{
  return HTTPWriteFilter::_streamImpl_CopyProperty((HTTPWriteFilter *)((char *)this - 120), a2);
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_Open( __CFWriteStream **this, CFStreamError *a2, unsigned __int8 *a3)
{
  return HTTPWriteFilter::_streamImpl_Open(this - 15, a2, a3);
}

BOOL non-virtual thunk to'HTTPWriteFilter::_streamImpl_OpenCompleted( HTTPWriteFilter *this, CFStreamError *a2)
{
  return HTTPWriteFilter::_streamImpl_OpenCompleted((HTTPWriteFilter *)((char *)this - 120), a2);
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_Close(HTTPWriteFilter *this)
{
  return HTTPWriteFilter::_streamImpl_Close((HTTPWriteFilter *)((char *)this - 120));
}

CFIndex non-virtual thunk to'HTTPWriteFilter::_streamImpl_Write( HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  return HTTPWriteFilter::_streamImpl_Write((HTTPWriteFilter *)((char *)this - 120), a2, a3, a4);
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_CanWrite(HTTPWriteFilter *this)
{
  return HTTPWriteFilter::socketStreamCanWrite((HTTPWriteFilter *)((char *)this - 120));
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_deprecated_Schedule( HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPWriteFilter::_streamImpl_deprecated_Schedule((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

uint64_t non-virtual thunk to'HTTPWriteFilter::_streamImpl_deprecated_Unschedule( HTTPWriteFilter *this, __CFRunLoop *a2, const __CFString *a3)
{
  return HTTPWriteFilter::_streamImpl_deprecated_Unschedule((HTTPWriteFilter *)((char *)this - 120), a2, a3);
}

void HTTPWriteFilter::~HTTPWriteFilter(HTTPWriteFilter *this)
{
  *(void *)this = &off_189C09930;
  *((void *)this + 1) = &unk_189C099D0;
  *((void *)this + 15) = &unk_189C099F0;
  *((void *)this + 16) = &unk_189C09AA8;
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int v3 = (const void *)*((void *)this + 27);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 32);
  if (v4) {
    CFRelease(v4);
  }
  BOOL v5 = (__CFWriteStream *)*((void *)this + 26);
  if (v5)
  {
    CFWriteStreamClose(v5);
    CFWriteStreamSetClient(*((CFWriteStreamRef *)this + 26), 0LL, 0LL, 0LL);
    uint64_t v6 = (const void *)*((void *)this + 26);
    *((void *)this + 26) = 0LL;
    if (v6) {
      CFRelease(v6);
    }
  }

  CFStringRef v7 = (const void *)*((void *)this + 33);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)*((void *)this + 35);
  if (v8) {
    CFRelease(v8);
  }
  CFTypeRef v9 = (const void *)*((void *)this + 29);
  if (v9) {
    _Block_release(v9);
  }
  pthread_mutex_unlock(v2);
  *((void *)this + 16) = off_189C12668;
  pthread_mutex_destroy(v2);
  CoreStreamBase::~CoreStreamBase(this);
}

void sub_182AA7DE0(_Unwind_Exception *a1)
{
  *((void *)v1 + 16) = off_189C12668;
  pthread_mutex_destroy(v2);
  CoreStreamBase::~CoreStreamBase(v1);
  _Unwind_Resume(a1);
}

uint64_t HTTPWriteFilter::socketStreamCanWrite(HTTPWriteFilter *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 136);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 136));
  int v3 = (__CFWriteStream *)*((void *)this + 26);
  if (!v3) {
    goto LABEL_27;
  }
  CFStreamStatus Status = CFWriteStreamGetStatus(v3);
  BOOL v5 = (__CFWriteStream *)*((void *)this + 26);
  if (Status == kCFStreamStatusError)
  {
    CFStreamError Error = CFWriteStreamGetError(v5);
    CFIndex domain = Error.domain;
    unint64_t v8 = *(void *)&Error.error;
    if (Error.domain != *MEMORY[0x1896051C0])
    {
      if ((*((_WORD *)this + 112) & 0x100) != 0)
      {
        CFTypeRef v9 = &_kCFStreamErrorHTTPSProxyFailure;
        goto LABEL_16;
      }

      if ((*((_WORD *)this + 112) & 0x200) != 0)
      {
        CFTypeRef v9 = &_kCFStreamErrorHTTPProxyFailure;
LABEL_16:
        unint64_t v8 = *(void *)&Error.error & 0xFFFFFFFF00000000LL | *v9;
        CFIndex domain = 4LL;
      }
    }

    pthread_mutex_unlock(v2);
    CFTypeRef v15 = this;
    v16.CFIndex domain = domain;
    *(void *)&v16.error = v8;
LABEL_20:
    CoreStreamBase::_signalEvent(v15, 8LL, v16, 1);
    return 0LL;
  }

  if (!CFWriteStreamCanAcceptBytes(v5)) {
    goto LABEL_27;
  }
  int v10 = *((unsigned __int16 *)this + 112);
  if ((~v10 & 0x401) == 0 || !*((void *)this + 27)) {
    goto LABEL_27;
  }
  if ((v10 & 0x10) == 0)
  {
    CFIndex v11 = HTTPWriteFilter::transmitHeader(this, 0LL);
    uint64_t v13 = v12;
    if ((_DWORD)v12)
    {
      CFIndex v14 = v11;
      pthread_mutex_unlock(v2);
      CFTypeRef v15 = this;
      v16.CFIndex domain = v14;
      *(void *)&v16.error = v13;
      goto LABEL_20;
    }

    if ((*((_WORD *)this + 112) & 0x10) == 0) {
      goto LABEL_27;
    }
  }

  if (!CFWriteStreamCanAcceptBytes(*((CFWriteStreamRef *)this + 26)))
  {
LABEL_27:
    pthread_mutex_unlock(v2);
    return 0LL;
  }

  __int16 v17 = *((_WORD *)this + 112);
  pthread_mutex_unlock(v2);
  if ((v17 & 0x1000) != 0) {
    return 0LL;
  }
  if (*((void *)this + 36))
  {
    (*(void (**)(void))(**((void **)this + 25) + 216LL))(*((void *)this + 25));
    *((void *)this + 36) = 0LL;
  }

  return 1LL;
}

CFIndex HTTPWriteFilter::transmitHeader(HTTPWriteFilter *this, __CFHTTPMessage *a2)
{
  __int16 v2 = *((_WORD *)this + 112);
  if ((v2 & 0x10) != 0) {
    return 0LL;
  }
  if (!*((void *)this + 26)) {
    return 4LL;
  }
  if ((*((_WORD *)this + 112) & 0x4000) != 0)
  {
    *((_WORD *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v2 & 0xBFFF;
    unint64_t v8 = (const void *)*((void *)this + 27);
    *((void *)this + 27) = 0LL;
    if (v8) {
      CFRelease(v8);
    }
    CFTypeRef v9 = (const void *)*((void *)this + 32);
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0LL;
    if (v9) {
      CFRelease(v9);
    }
    uint64_t v10 = *((void *)this + 25);
    *(CFAbsoluteTime *)(v10 + 296) = CFAbsoluteTimeGetCurrent() + 10.0;
    (*(void (**)(void))(**((void **)this + 25) + 192LL))(*((void *)this + 25));
    uint64_t v11 = *((void *)this + 29);
    if (v11)
    {
      (*(void (**)(uint64_t, void))(v11 + 16))(v11, 0LL);
      _Block_release(*((const void **)this + 29));
      CFIndex domain = 0LL;
      *((void *)this + 29) = 0LL;
      return domain;
    }

    return 0LL;
  }

  int v4 = (int)a2;
  uint64_t v5 = *((void *)this + 29);
  if (v5)
  {
    (*(void (**)(uint64_t, void))(v5 + 16))(v5, 0LL);
    _Block_release(*((const void **)this + 29));
    *((void *)this + 29) = 0LL;
  }

  if (!*((void *)this + 27)) {
    return 4LL;
  }
  if ((*((_WORD *)this + 112) & 0x100) != 0)
  {
    uint64_t v13 = (__CFWriteStream *)*((void *)this + 26);
    if (!v13 || (CFIndex v14 = (__CFHTTPMessage *)CFWriteStreamCopyProperty(v13, (CFStreamPropertyKey)&unk_18C5B24F8)) == 0LL)
    {
      *((void *)this + 31) = 0LL;
      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0LL;
      return 4LL;
    }

    CFTypeRef v15 = v14;
    CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v14);
    CFRelease(v15);
    if (ResponseStatusCode != 200)
    {
      *((void *)this + 31) = 0LL;
      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0LL;
      if (ResponseStatusCode == 407)
      {
        CFIndex domain = 0LL;
        __int16 v23 = *((_WORD *)this + 112) | 0x30;
LABEL_99:
        *((_WORD *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v23;
        return domain;
      }

      return 4LL;
    }

    *((_WORD *)this + 112) &= ~0x100u;
    __int16 v17 = (const void *)*((void *)this + 34);
    if (v17)
    {
      CFTypeRef v18 = (__CFWriteStream *)*((void *)this + 26);
      if (v18)
      {
        CFWriteStreamSetProperty(v18, @"kCFStreamPropertySSLContext", v17);
        __int16 v17 = (const void *)*((void *)this + 34);
        *((void *)this + 34) = 0LL;
        if (!v17) {
          goto LABEL_142;
        }
      }

      else
      {
        *((void *)this + 34) = 0LL;
      }

      goto LABEL_141;
    }

    __int16 v17 = (const void *)*((void *)this + 33);
    if (v17)
    {
      int v37 = (__CFWriteStream *)*((void *)this + 26);
      if (!v37)
      {
        *((void *)this + 33) = 0LL;
        goto LABEL_141;
      }

      CFWriteStreamSetProperty(v37, @"kCFStreamPropertySocketSSLContext", v17);
      __int16 v17 = (const void *)*((void *)this + 33);
      *((void *)this + 33) = 0LL;
      if (!v17)
      {
LABEL_142:
        if ((*(unsigned int (**)(void))(**((void **)this + 25) + 208LL))(*((void *)this + 25))) {
          (*(void (**)(void, void))(**((void **)this + 25) + 280LL))( *((void *)this + 25),  *((void *)this + 27));
        }
        goto LABEL_8;
      }
    }

    else
    {
      __int16 v17 = (const void *)*((void *)this + 35);
      if (!v17)
      {
        uint64_t v60 = CFHTTPMessageCopyRequestURL(*((CFHTTPMessageRef *)this + 27));
        CFStringRef v61 = CFURLCopyHostName(v60);
        if (v61)
        {
          CFStringRef v62 = v61;
          int v63 = (__CFWriteStream *)*((void *)this + 26);
          if (v63) {
            CFWriteStreamSetProperty(v63, (CFStreamPropertyKey)&unk_18C5AC988, v62);
          }
          CFRelease(v62);
        }

        if (v60) {
          CFRelease(v60);
        }
        uint64_t v64 = (__CFWriteStream *)*((void *)this + 26);
        if (v64) {
          CFWriteStreamSetProperty(v64, @"kCFStreamPropertySocketSecurityLevel", &unk_18C5AE198);
        }
        goto LABEL_142;
      }

      BOOL v59 = (__CFWriteStream *)*((void *)this + 26);
      if (!v59)
      {
        *((void *)this + 35) = 0LL;
        goto LABEL_141;
      }

      CFWriteStreamSetProperty(v59, @"kCFStreamPropertySSLSettings", v17);
      __int16 v17 = (const void *)*((void *)this + 35);
      *((void *)this + 35) = 0LL;
      if (!v17) {
        goto LABEL_142;
      }
    }

LABEL_141:
    CFRelease(v17);
    goto LABEL_142;
  }

void HTTPWriteFilter::prepareHTTPSProxy(HTTPWriteFilter *this)
{
  uint64_t v2 = *((void *)this + 27);
  if (v2) {
    int v3 = (HTTPMessage *)(v2 + 16);
  }
  else {
    int v3 = 0LL;
  }
  CFStringRef v4 = HTTPMessage::copyHeaderFieldValue(v3, 0x1382736Bu);
  if (v4)
  {
    CFStringRef v5 = v4;
    uint64_t v6 = *((void *)this + 27);
    if (v6) {
      int v7 = (HTTPMessage *)(v6 + 16);
    }
    else {
      int v7 = 0LL;
    }
    HTTPMessage::removeHeaderFieldValue(v7, 0x1382736Bu);
    CFRelease(v5);
  }

  if ((*((_WORD *)this + 112) & 0x800) == 0) {
    *((_WORD *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = *((_WORD *)this + 112) & 0xF4FF | 0x900;
  }
}

void HTTPWriteFilter::_httpWrFilterSocketStreamCallBack( HTTPWriteFilter *this, __CFWriteStream *a2, uint64_t a3, void *a4)
{
  int v7 = (const void *)(a3 - 16);
  CFRetain((CFTypeRef)(a3 - 16));
  if (a2 != (__CFWriteStream *)4)
  {
    if (a2 == (__CFWriteStream *)8)
    {
      CFStreamError Error = CFWriteStreamGetError(this);
      CFIndex domain = Error.domain;
      unint64_t v10 = *(void *)&Error.error;
      pthread_mutex_lock((pthread_mutex_t *)(a3 + 136));
      if ((*(_WORD *)(a3 + 224) & 0x10) == 0)
      {
        if ((*(_WORD *)(a3 + 224) & 0x100) == 0)
        {
          if ((*(_WORD *)(a3 + 224) & 0x200) != 0)
          {
            unint64_t v10 = (*(void *)&Error.error & 0xFFFFFFFF00000000LL | 0xFFFFF7CE) + 4;
            CFIndex domain = 4LL;
          }

          goto LABEL_29;
        }

        CFIndex v14 = *(__CFWriteStream **)(a3 + 208);
        if (v14
          && (CFTypeRef v15 = (__CFHTTPMessage *)CFWriteStreamCopyProperty(v14, (CFStreamPropertyKey)&unk_18C5B24F8)) != 0LL)
        {
          CFStreamError v16 = v15;
          CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v15);
          CFRelease(v16);
          if (ResponseStatusCode == 200) {
            goto LABEL_29;
          }
        }

        else
        {
          CFIndex ResponseStatusCode = 500LL;
        }

        if (!*(void *)(a3 + 248))
        {
          CFTypeRef v18 = *(const void **)(a3 + 256);
          if (v18) {
            CFRelease(v18);
          }
          *(void *)(a3 + 256) = 0LL;
          *(_WORD *)(a3 + 224) |= 0x10u;
        }

        if (ResponseStatusCode == 407)
        {
          *(_WORD *)(a3 + 224) |= 0x20u;
        }

        else
        {
          uint64_t v19 = 4294965198LL;
          *(_WORD *)(a3 + 224) |= 0x40u;
          unint64_t v10 = *(void *)&Error.error & 0xFFFFFFFF00000000LL | v19;
          CFIndex domain = 4LL;
        }
      }

uint64_t HTTPWriteFilter::doChunkedWrite( HTTPWriteFilter *this, const unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  uint64_t v5 = a3;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v9 = *((void *)this + 30);
  CFIndex v8 = *((void *)this + 31);
  if (v9 <= v8)
  {
    unint64_t v10 = (__CFWriteStream *)*((void *)this + 26);
    __int16 v11 = *((_WORD *)this + 112);
    a4->error = 0;
    *(_WORD *)&v24[1] = 2573;
    uint64_t v12 = v24;
    if (a3 >= 1)
    {
      unint64_t v13 = a3;
      do
      {
        if ((v13 & 0xF) >= 0xA) {
          char v14 = (v13 & 0xF) + 55;
        }
        else {
          char v14 = v13 & 0xF | 0x30;
        }
        *v12-- = v14;
        BOOL v15 = v13 > 0xF;
        v13 >>= 4;
      }

      while (v15);
    }

    if ((v11 & 4) != 0)
    {
      CFStreamError v16 = v12 + 1;
    }

    else
    {
      *(_WORD *)(v12 - 1) = 2573;
      CFStreamError v16 = v12 - 1;
    }

    while (v16 < (const UInt8 *)&v25)
    {
      CFIndex v17 = CFWriteStreamWrite(v10, v16, (char *)&v25 - (char *)v16);
      if (v17 < 0)
      {
        *a4 = CFWriteStreamGetError(v10);
        break;
      }

      if (!v17)
      {
        a4->CFIndex domain = 4LL;
        a4->error = -1;
        break;
      }

      v16 += v17;
      *((void *)this + 36) += v17;
    }

    *((_WORD *)this + 112) &= ~4u;
    if (a4->error) {
      return -1LL;
    }
    CFIndex v8 = 0LL;
    *((void *)this + 30) = v5;
    *((void *)this + 31) = 0LL;
    uint64_t v9 = v5;
  }

  if (v9 <= v8)
  {
    uint64_t v18 = 0LL;
  }

  else
  {
    uint64_t v18 = 0LL;
    while (1)
    {
      uint64_t v19 = (__CFWriteStream *)*((void *)this + 26);
      if (!v19) {
        break;
      }
      if (v18)
      {
        if (!CFWriteStreamCanAcceptBytes(v19)) {
          break;
        }
        uint64_t v9 = *((void *)this + 30);
        CFIndex v8 = *((void *)this + 31);
        uint64_t v19 = (__CFWriteStream *)*((void *)this + 26);
      }

      uint64_t v20 = v9 - v8;
      if (v20 >= v5) {
        LODWORD(v20) = v5;
      }
      CFIndex v21 = CFWriteStreamWrite(v19, a2, (int)v20);
      if (v21 < 0)
      {
        *a4 = CFWriteStreamGetError((CFWriteStreamRef)*((void *)this + 26));
        return -1LL;
      }

      if (v21)
      {
        uint64_t v9 = *((void *)this + 30);
        CFIndex v8 = *((void *)this + 31) + v21;
        *((void *)this + 36) += v21;
        *((void *)this + 31) = v8;
        v18 += v21;
        a2 += v21;
        v5 -= v21;
        if (v9 > v8) {
          continue;
        }
      }

      break;
    }
  }

  if (v5 && CFWriteStreamCanAcceptBytes(*((CFWriteStreamRef *)this + 26)))
  {
    uint64_t v22 = HTTPWriteFilter::doChunkedWrite(this, a2, v5, a4);
    if (v22 < 0) {
      return -1LL;
    }
    else {
      v18 += v22;
    }
  }

  return v18;
}

void HTTPReadStream::~HTTPReadStream(CFReadStreamRef *this)
{
}

{
  CFReadStreamRef v2;
  CFReadStreamRef v3;
  __CFReadStream *v4;
  CFReadStreamRef v5;
  CFReadStreamRef v6;
  CFReadStreamRef v7;
  CFReadStreamRef v8;
  CFReadStreamRef v9;
  CFReadStreamRef v10;
  CFReadStreamRef v11;
  CFReadStreamRef v12;
  CFReadStreamRef v13;
  *this = (CFReadStreamRef)off_189C09AC8;
  HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
  uint64_t v2 = this[3];
  if (v2) {
    CFRelease((char *)v2 - 16);
  }
  int v3 = this[4];
  if (v3) {
    CFRelease((char *)v3 - 16);
  }
  CFStringRef v4 = this[5];
  if (((_WORD)this[2] & 0x10) != 0)
  {
    if (!v4) {
      goto LABEL_11;
    }
    CFReadStreamSetClient(this[5], 0LL, 0LL, 0LL);
    CFReadStreamClose(v4);
    goto LABEL_10;
  }

  if (v4) {
LABEL_10:
  }
    CFRelease(v4);
LABEL_11:
  uint64_t v5 = this[6];
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = this[11];
  if (v6) {
    CFRelease(v6);
  }
  if (((_WORD)this[2] & 4) == 0)
  {
    int v7 = this[12];
    if (v7) {
      CFRelease(v7);
    }
    CFIndex v8 = this[13];
    if (v8) {
      CFRelease(v8);
    }
  }

  uint64_t v9 = this[7];
  if (v9) {
    _Block_release(v9);
  }
  unint64_t v10 = this[8];
  if (v10) {
    _Block_release(v10);
  }
  __int16 v11 = this[9];
  if (v11) {
    _Block_release(v11);
  }
  uint64_t v12 = this[15];
  if (v12) {
    CFRelease(v12);
  }
  unint64_t v13 = this[18];
  if (v13)
  {
    (*(void (**)(CFReadStreamRef))(*(void *)v13 + 48LL))(v13);
    this[18] = 0LL;
  }

  *this = (CFReadStreamRef)off_189C19AE8;
  this[1] = 0LL;
}

BOOL HTTPReadStream::_streamImpl_Open( HTTPReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    Instance += 16LL;
    *(void *)(Instance + 176) = 0LL;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 16) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0u;
  }

  HTTPRequestMessage::HTTPRequestMessage((HTTPRequestMessage *)Instance, *((const HTTPRequestMessage **)this + 3));
  *((void *)this + 4) = v8;
  if ((*((_WORD *)this + 8) & 0x100) != 0)
  {
    uint64_t v9 = (const void *)*((void *)this + 11);
    if (v9) {
      CFRelease(v9);
    }
    *((void *)this + 11) = CFNetworkCopySystemProxySettings();
  }

  int v10 = HTTPReadStream::constructProxyList(this, a3);
  if (a3->error)
  {
    BOOL result = 0LL;
    *a4 = 1;
    return result;
  }

  if (v10)
  {
    *a4 = 0;
    return 1LL;
  }

  HTTPReadStream::startRequest(this, a3);
  if (!a3->error)
  {
    uint64_t v12 = (__CFReadStream *)*((void *)this + 10);
    if (v12) {
      BOOL v13 = CFReadStreamGetStatus(v12) > kCFStreamStatusOpening;
    }
    else {
      BOOL v13 = 0;
    }
    *a4 = v13;
    if (v13) {
      return a3->error == 0;
    }
    goto LABEL_15;
  }

  if (!*a4) {
LABEL_15:
  }
    *a4 = 1;
  return a3->error == 0;
}

BOOL HTTPReadStream::_streamImpl_OpenCompleted(HTTPReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  return (*((_WORD *)this + 8) & 4) == 0 && *((void *)this + 10) != 0LL;
}

uint64_t HTTPReadStream::_streamImpl_Read( HTTPReadStream *this, __CFReadStream *a2, UInt8 *buffer, CFIndex bufferLength, CFStreamError *a5, BOOL *a6)
{
  a5->CFIndex domain = 0LL;
  a5->error = 0;
  uint64_t v12 = (__CFReadStream *)*((void *)this + 10);
  if (!v12)
  {
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t v18 = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "httpRequestRead(): no stream to read from!",  v18,  2u);
      uint64_t v12 = (__CFReadStream *)*((void *)this + 10);
    }

    else
    {
      uint64_t v12 = 0LL;
    }
  }

  *((_WORD *)this + 8) |= 0x40u;
  CFIndex v13 = CFReadStreamRead(v12, buffer, bufferLength);
  __int16 v14 = *((_WORD *)this + 8);
  *((_WORD *)this + 8) = v14 & 0xFFBF;
  if (v13 < 0)
  {
    *a5 = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 10));
    goto LABEL_11;
  }

  uint64_t v15 = v13;
  if ((v14 & 8) == 0)
  {
    int Header = HTTPReadStream::readHeader(this, a5);
    if (!a5->error)
    {
      if (Header) {
        goto LABEL_8;
      }
LABEL_10:
      uint64_t v15 = (*(uint64_t (**)(HTTPReadStream *, __CFReadStream *, UInt8 *, CFIndex, CFStreamError *, BOOL *))(*(void *)this + 40LL))( this,  a2,  buffer,  bufferLength,  a5,  a6);
      goto LABEL_12;
    }

uint64_t HTTPReadStream::_streamImpl_CanRead(HTTPReadStream *this, __CFReadStream *a2)
{
  v6.CFIndex domain = 0LL;
  *(void *)&v6.error = 0LL;
  int v3 = (__CFReadStream *)*((void *)this + 10);
  if (!v3)
  {
    v6.CFIndex domain = 4LL;
    v6.error = -4;
    goto LABEL_9;
  }

  CFStreamStatus Status = CFReadStreamGetStatus(v3);
  if (Status < kCFStreamStatusOpen) {
    return 0LL;
  }
  uint64_t result = CFReadStreamHasBytesAvailable(*((CFReadStreamRef *)this + 10));
  if (!(_DWORD)result) {
    return result;
  }
  if ((*((_WORD *)this + 8) & 8) != 0) {
    return 1LL;
  }
  uint64_t result = HTTPReadStream::readHeader(this, &v6);
  if (v6.error)
  {
LABEL_9:
    CFReadStreamSignalEvent();
    return 0LL;
  }

  return result;
}

void HTTPReadStream::_streamImpl_Close(__CFRunLoopSource **this, __CFReadStream *a2)
{
  if (this[10]) {
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 1);
  }
  __int16 v3 = *((_WORD *)this + 8);
  if ((v3 & 4) != 0)
  {
    CFStringRef v4 = this[14];
    if (v4)
    {
      CFRunLoopSourceInvalidate(v4);
      uint64_t v5 = this[14];
      if (v5) {
        CFRelease(v5);
      }
      this[14] = 0LL;
      __int16 v3 = *((_WORD *)this + 8);
    }

    *((_WORD *)this + 8) = v3 & 0xFFFB;
  }

CFTypeRef HTTPReadStream::_streamImpl_CopyProperty( HTTPReadStream *this, __CFReadStream *a2, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 8u);
  if (ExactString > 442775482)
  {
    if (ExactString == 442775483)
    {
      AutoScalar::AutoScalar((AutoScalar *)&v12, (const __CFAllocator *)*((unsigned int *)this + 32));
      if (cf)
      {
        CFTypeRef v10 = CFRetain(cf);
        uint64_t v12 = off_189C04A90;
        if (cf) {
          CFRelease(cf);
        }
      }

      else
      {
        CFTypeRef v10 = 0LL;
        uint64_t v12 = off_189C04A90;
      }

      return v10;
    }

    if (ExactString != 443766732)
    {
      if (ExactString == 448067602)
      {
        uint64_t v8 = (const void **)MEMORY[0x189604DE8];
        if ((*((_WORD *)this + 8) & 1) == 0) {
          uint64_t v8 = (const void **)MEMORY[0x189604DE0];
        }
        int v7 = *v8;
        if (!*v8) {
          return 0LL;
        }
        return CFRetain(v7);
      }

void sub_182AA91E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HTTPReadStream::_streamImpl_SetProperty( CFReadStreamRef *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  valuePtr[7] = *MEMORY[0x1895F89C0];
  if (CFReadStreamGetStatus(this[1]) > kCFStreamStatusNotOpen) {
    return 0LL;
  }
  int ExactString = _findExactString(a3, 0);
  uint64_t result = 0LL;
  if (ExactString <= 223645656)
  {
    if (ExactString > 104064895)
    {
      if (ExactString > 107284407)
      {
        if (ExactString == 107284408) {
          return result;
        }
        int v32 = 216338253;
      }

      else
      {
        if (ExactString == 104064896)
        {
          if (!a4) {
            goto LABEL_81;
          }
          CFTypeID v46 = CFGetTypeID(a4);
          if (v46 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
          {
            LOWORD(valuePtr[0]) = 0;
            _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)valuePtr,  2u);
          }

          else {
LABEL_81:
          }
            __int16 v13 = (_WORD)this[2] & 0xFFDF;
          goto LABEL_116;
        }

        int v32 = 106203045;
      }
    }

    else
    {
      if (ExactString <= 96814833)
      {
        if (ExactString == 83273191)
        {
          CFReadStreamRef v44 = this[9];
          if (v44) {
            _Block_release(v44);
          }
          if (a4) {
            CFIndex v45 = (__CFReadStream *)_Block_copy(a4);
          }
          else {
            CFIndex v45 = 0LL;
          }
          this[9] = v45;
          return 1LL;
        }

        if (ExactString == 90506882)
        {
          CFReadStreamRef v14 = this[8];
          if (v14) {
            _Block_release(v14);
          }
          if (a4) {
            uint64_t v15 = (__CFReadStream *)_Block_copy(a4);
          }
          else {
            uint64_t v15 = 0LL;
          }
          this[8] = v15;
          return 1LL;
        }

        goto LABEL_61;
      }

      if (ExactString == 96814834) {
        return result;
      }
      int v32 = 97904392;
    }

    if (ExactString == v32) {
      return result;
    }
LABEL_61:
    int v37 = this[6];
    if (a4) {
      CFDictionarySetValue(v37, a3, a4);
    }
    else {
      CFDictionaryRemoveValue(v37, a3);
    }
    return 1LL;
  }

  if (ExactString <= 442775482)
  {
    if (ExactString > 399906151)
    {
      if (ExactString == 399906152)
      {
        CFReadStreamRef v49 = this[7];
        if (v49) {
          _Block_release(v49);
        }
        if (a4) {
          unsigned int v50 = (__CFReadStream *)_Block_copy(a4);
        }
        else {
          unsigned int v50 = 0LL;
        }
        this[7] = v50;
        return 1LL;
      }

      if (ExactString == 439752578)
      {
        if (!a4) {
          goto LABEL_57;
        }
        CFTypeID v36 = CFGetTypeID(a4);
        if (v36 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr[0]) = 0;
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)valuePtr,  2u);
        }

        else {
LABEL_57:
        }
          __int16 v13 = (_WORD)this[2] & 0xFFFD;
        goto LABEL_116;
      }

      goto LABEL_61;
    }

    if (ExactString == 223645657) {
      return result;
    }
    if (ExactString != 225669117) {
      goto LABEL_61;
    }
    if (a4)
    {
      CFTypeID v16 = CFGetTypeID(a4);
      if (v16 != CFDictionaryGetTypeID()) {
        return 0LL;
      }
      uint64_t v17 = 0LL;
      int v18 = 0;
      uint64_t v19 = *MEMORY[0x1896051F0];
      valuePtr[0] = *MEMORY[0x1896051E8];
      valuePtr[1] = v19;
      uint64_t v20 = *MEMORY[0x1896051F8];
      valuePtr[2] = *MEMORY[0x189605200];
      valuePtr[3] = v20;
      valuePtr[4] = *MEMORY[0x1896051E0];
      valuePtr[5] = 6649730000LL;
      valuePtr[6] = *MEMORY[0x18960C940];
      do
      {
        uint64_t v21 = valuePtr[v17];
        if (v21)
        {
          Value = CFDictionaryGetValue((CFDictionaryRef)a4, (const void *)valuePtr[v17]);
          if (Value)
          {
            v69[v18] = v21;
            v68[v18++] = Value;
          }
        }

        ++v17;
      }

      while (v17 != 7);
      uint64_t v23 = v18;
      CFReadStreamRef v24 = this[11];
      uint64_t v25 = CFGetAllocator(this[1]);
      uint64_t v26 = v25;
      if (v24 || !v18)
      {
        CFIndex Count = CFDictionaryGetCount(this[11]);
        CFMutableDataRef MutableCopy = CFDictionaryCreateMutableCopy(v26, Count + 4, this[11]);
        if (v18 >= 1)
        {
          CFStringRef v62 = (const void **)v68;
          int v63 = (const void **)v69;
          do
          {
            uint64_t v65 = *v63++;
            uint64_t v64 = v65;
            CFRange v66 = *v62++;
            CFDictionarySetValue(MutableCopy, v64, v66);
            --v23;
          }

          while (v23);
        }

        goto LABEL_120;
      }

      uint64_t v27 = (const CFDictionaryKeyCallBacks *)MEMORY[0x189605240];
      uint64_t v28 = (const CFDictionaryValueCallBacks *)MEMORY[0x189605250];
      uint64_t v29 = (const void **)v69;
      uint64_t v30 = (const void **)v68;
      CFIndex v31 = v18;
      goto LABEL_113;
    }

    unint64_t v52 = this[11];
    if (!v52) {
      return 1LL;
    }
    CFStringRef v53 = (const void *)*MEMORY[0x1896051E8];
    CFStringRef v54 = CFGetAllocator(this[1]);
    CFIndex v55 = CFDictionaryGetCount(this[11]);
    CFMutableDataRef MutableCopy = CFDictionaryCreateMutableCopy(v54, v55, this[11]);
    CFDictionaryRemoveValue(MutableCopy, v53);
    uint64_t v56 = (const void *)*MEMORY[0x1896051F0];
    uint64_t v57 = MutableCopy;
LABEL_103:
    CFDictionaryRemoveValue(v57, v56);
LABEL_120:
    CFReadStreamRef v67 = this[11];
    if (v67) {
      CFRelease(v67);
    }
    goto LABEL_122;
  }

  if (ExactString > 448067601)
  {
    if (ExactString != 457381991)
    {
      if (ExactString != 449148966)
      {
        if (ExactString == 448067602)
        {
          if (!a4) {
            goto LABEL_89;
          }
          CFTypeID v9 = CFGetTypeID(a4);
          if (v9 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
          {
            LOWORD(valuePtr[0]) = 0;
            _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)valuePtr,  2u);
          }

          if ((const void *)*MEMORY[0x189604DE0] == a4)
          {
LABEL_89:
            CFReadStreamRef v51 = this[15];
            if (v51) {
              CFRelease(v51);
            }
            this[15] = 0LL;
            __int16 v13 = (_WORD)this[2] & 0xFFFE;
          }

          else
          {
            if (!this[15])
            {
              CFTypeRef v10 = CFGetAllocator(this[1]);
              Mutable = CFArrayCreateMutable(v10, 0LL, MEMORY[0x189605228]);
              this[15] = Mutable;
              uint64_t v12 = (const void *)HTTPRequestParserClient::requestURL((CFReadStreamRef)((char *)this[3] + 128));
              CFArrayAppendValue(Mutable, v12);
            }

            __int16 v13 = *((_WORD *)this + 8) | 1;
          }

void HTTPReadStream::_streamImpl_deprecated_Schedule( HTTPReadStream *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7 = *((void *)this + 18);
  if (v7) {
    *((void *)this + 18) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(void *)v7 + 56LL))( v7,  rl,  mode);
  }
  if ((*((_WORD *)this + 8) & 4) != 0)
  {
    CFRunLoopAddSource(rl, *((CFRunLoopSourceRef *)this + 14), mode);
  }

  else
  {
    uint64_t v8 = (__CFReadStream *)*((void *)this + 10);
    if (v8) {
      CFReadStreamScheduleWithRunLoop(v8, rl, mode);
    }
  }

void HTTPReadStream::_streamImpl_deprecated_Unschedule( HTTPReadStream *this, __CFReadStream *a2, CFRunLoopRef rl, CFRunLoopMode mode)
{
  uint64_t v7 = *((void *)this + 18);
  if (v7) {
    *((void *)this + 18) = (*(uint64_t (**)(uint64_t, CFRunLoopRef, CFRunLoopMode))(*(void *)v7 + 64LL))( v7,  rl,  mode);
  }
  if ((*((_WORD *)this + 8) & 4) != 0)
  {
    CFRunLoopRemoveSource(rl, *((CFRunLoopSourceRef *)this + 14), mode);
  }

  else
  {
    uint64_t v8 = (__CFReadStream *)*((void *)this + 10);
    if (v8) {
      CFReadStreamUnscheduleFromRunLoop(v8, rl, mode);
    }
  }

CFStringRef HTTPReadStream::copyDebugDesc(HTTPReadStream *this)
{
  uint64_t v2 = (const __CFURL *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(*((void *)this + 3) + 128LL));
  __int16 v3 = CFGetAllocator(*((CFTypeRef *)this + 1));
  CFStringRef v4 = CFURLGetString(v2);
  return CFStringCreateWithFormat( v3,  0LL,  @"<HTTP request stream %p>{url = %@, flags=%p, connection stream = %p}",  this,  v4,  (char *)this + 16,  *((void *)this + 10));
}

CFStringRef HTTPReadStream::copyDebugSummary(HTTPReadStream *this)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 1);
  if (!v2) {
    return (CFStringRef)CFRetain(@"null response stream");
  }
  __int16 v3 = "NotOpen";
  switch(CFReadStreamGetStatus(v2))
  {
    case kCFStreamStatusNotOpen:
      goto LABEL_11;
    case kCFStreamStatusOpening:
      __int16 v3 = "Opening";
      goto LABEL_11;
    case kCFStreamStatusOpen:
      __int16 v3 = "Open";
      goto LABEL_11;
    case kCFStreamStatusReading:
      __int16 v3 = "Reading";
      goto LABEL_11;
    case kCFStreamStatusWriting:
      __int16 v3 = "Writing";
      goto LABEL_11;
    case kCFStreamStatusAtEnd:
      __int16 v3 = "AtEnd";
      goto LABEL_11;
    case kCFStreamStatusClosed:
      __int16 v3 = "Closed";
      goto LABEL_11;
    case kCFStreamStatusError:
      CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 1));
      uint64_t v7 = CFGetAllocator(*((CFTypeRef *)this + 1));
      return CFStringCreateWithFormat( v7,  0LL,  @"read stream error { %ld, %d }",  Error.domain,  *(void *)&Error.error);
    default:
      __int16 v3 = "?";
LABEL_11:
      uint64_t v5 = CFGetAllocator(*((CFTypeRef *)this + 1));
      CFStringRef result = CFStringCreateWithFormat(v5, 0LL, @"read stream status %s", v3);
      break;
  }

  return result;
}

void HTTPReadStream::dequeueRequestFromConnection(HTTPReadStream *this, int a2)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 10);
  if (v2)
  {
    if ((*((_WORD *)this + 8) & 2) == 0)
    {
      CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0LL, 0LL, 0LL);
      if (a2)
      {
        CFReadStreamClose(*((CFReadStreamRef *)this + 10));
      }

      else
      {
        CFReadStreamClose(v2);
        CFRelease(v2);
        *((void *)this + 10) = 0LL;
      }

      return;
    }

    uint64_t InfoPointer = CFReadStreamGetInfoPointer();
    uint64_t v6 = *(void *)(InfoPointer + 128);
    if (v6)
    {
      (*(void (**)(uint64_t))(*(void *)v6 + 40LL))(v6);
      uint64_t v7 = *(void *)(InfoPointer + 128);
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    uint64_t v8 = (__CFReadStream *)*((void *)this + 10);
    if (a2)
    {
      if (v8)
      {
        CFReadStreamClose(*((CFReadStreamRef *)this + 10));
        CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0LL, 0LL, 0LL);
      }

      if (v7) {
        goto LABEL_13;
      }
    }

    else
    {
      if (v8)
      {
        CFReadStreamSetClient(*((CFReadStreamRef *)this + 10), 0LL, 0LL, 0LL);
        CFReadStreamClose(v8);
        CFRelease(v8);
      }

      *((void *)this + 10) = 0LL;
      if (v7)
      {
LABEL_13:
        uint64_t v9 = *(void *)(v7 + 96);
        if (v9) {
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 8));
        }
        CFTypeRef v10 = (void *)(v7 + 136);
        do
          CFTypeRef v10 = (void *)*v10;
        while (v10
             && (*(unsigned int (**)(uint64_t, void, void))(*(void *)v7 + 168LL))( v7,  _checkIsZombie,  v10[1]));
        uint64_t v11 = *(void *)(v7 + 96);
        if (v11) {
          pthread_mutex_unlock((pthread_mutex_t *)(v11 + 8));
        }
        uint64_t v12 = *((void *)this + 4);
        __int16 v13 = *(_CFHTTPAuthentication **)(v12 + 72);
        if (v13)
        {
          if (!_CFHTTPAuthenticationRequiresPersistentConnection(*(CFHTTPAuthenticationRef *)(v12 + 72))) {
            __int16 v13 = 0LL;
          }
          uint64_t v12 = *((void *)this + 4);
        }

        CFReadStreamRef v14 = *(_CFHTTPAuthentication **)(v12 + 80);
        if (v14 && !_CFHTTPAuthenticationRequiresPersistentConnection(*(CFHTTPAuthenticationRef *)(v12 + 80))) {
          CFReadStreamRef v14 = 0LL;
        }
        if (!v13 && !v14 && !v10 || v13 && !CFHTTPAuthenticationIsValid(v13, 0LL)) {
          goto LABEL_31;
        }
        if (v14)
        {
          int IsValid = CFHTTPAuthenticationIsValid(v14, 0LL);
          if (!IsValid || v10)
          {
            if (!IsValid)
            {
LABEL_31:
              uint64_t v15 = *(void *)(v7 + 96);
              if (v15) {
                pthread_mutex_lock((pthread_mutex_t *)(v15 + 8));
              }
              *(_WORD *)(v7 + 88) &= ~1u;
              NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v7);
              uint64_t v16 = *(void *)(v7 + 96);
              if (v16) {
                pthread_mutex_unlock((pthread_mutex_t *)(v16 + 8));
              }
              uint64_t v17 = getNetConnectionCache(void)::gHTTPConnectionCache;
              uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 80LL))(v7);
              uint64_t v19 = *(NetConnectionCache **)(v7 + 8);
              uint64_t v20 = (const __CFString *)(*(uint64_t (**)(void))(**(void **)(v18 + 272) + 72LL))(*(void *)(v18 + 272));
              uint64_t v21 = (const __CFString *)(*(uint64_t (**)(void))(**(void **)(v18 + 272) + 80LL))(*(void *)(v18 + 272));
              uint64_t v22 = (*(uint64_t (**)(void))(**(void **)(v18 + 272) + 88LL))(*(void *)(v18 + 272));
              uint64_t v23 = *(uint64_t (**(void))(**(void **)(v18 + 272) + 64LL))(*(void *)(v18 + 272));
              uint64_t Key = NetConnectionCache::createKey(v19, v20, v21, v22, v23, v24);
              if (Key)
              {
                uint64_t v26 = (const void *)Key;
                os_unfair_lock_lock((os_unfair_lock_t)(v17 + 8));
                Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v17 + 16), v26);
                if (Value) {
                  BOOL v28 = Value == (const void *)v7;
                }
                else {
                  BOOL v28 = 0;
                }
                if (v28)
                {
                  uint64_t v29 = *(void *)(v7 + 96);
                  if (v29) {
                    pthread_mutex_lock((pthread_mutex_t *)(v29 + 8));
                  }
                  *(_WORD *)(v7 + 88) &= ~1u;
                  NetConnection::closeStreamsIfPossibleOrSignalThatThatNeedsToBeDonePrettyPlease(v7);
                  uint64_t v30 = *(void *)(v7 + 96);
                  if (v30) {
                    pthread_mutex_unlock((pthread_mutex_t *)(v30 + 8));
                  }
                  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v17 + 16), v26);
                }

                os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 8));
                (*(void (**)(const void *))(*(void *)v26 + 48LL))(v26);
              }
            }

uint64_t _checkIsZombie(unsigned __int8 *a1, NetConnection *a2, const void *a3)
{
  return (a1[32] >> 2) & 1;
}

uint64_t NetConnectionCache::createKey( NetConnectionCache *this, const __CFString *a2, const __CFString *a3, uint64_t a4, const __CFDictionary *a5, const __CFDictionary *a6)
{
  if (!a2) {
    return 0LL;
  }
  int v7 = a4;
  int v8 = (int)a3;
  uint64_t v11 = MEMORY[0x186E12804](this, 48LL, 0LL, a4, a5, a6);
  *(void *)(v11 + 20) = 0LL;
  *(void *)(v11 + 36) = 0LL;
  *(void *)(v11 + 28) = 0LL;
  *(_DWORD *)(v11 + 44) = 0;
  *(void *)uint64_t v11 = off_189C06BF8;
  *(void *)(v11 + 8) = this;
  *(_DWORD *)(v11 + 16) = 1;
  if (((v11 + 16) & 3) != 0) {
    __assert_rtn("CFAllocatedReferenceCountedObject", "CFObject.cpp", 25, "(ptrdiff_t(&fRetainCount) & 3) == 0");
  }
  uint64_t v12 = v11;
  *(void *)uint64_t v11 = off_189C08910;
  Copy = (AutoDict *)CFStringCreateCopy(this, a2);
  *(void *)(v12 + 24) = Copy;
  *(_DWORD *)(v12 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v8;
  *(_DWORD *)(v12 + 36) = v7;
  if (a5)
  {
    EmptyDict = CFDictionaryCreateCopy(this, a5);
  }

  else
  {
    EmptyDict = (const void *)AutoDict::getEmptyDict(Copy);
    if (EmptyDict) {
      EmptyDict = CFRetain(EmptyDict);
    }
  }

  *(void *)(v12 + 40) = EmptyDict;
  return v12;
}

CFMutableDictionaryRef ___ZL21getNetConnectionCachev_block_invoke()
{
  os_log_t v0 = operator new(0x18uLL);
  v0[2] = 0;
  *(void *)os_log_t v0 = off_189C08960;
  CFMutableDictionaryRef result = CFDictionaryCreateMutable( 0LL,  0LL,  &CFAllocatedReferenceCountedObject::skCFTypeDictionaryKeyCallBacks,  &CFAllocatedReferenceCountedObject::skCFTypeDictionaryValueCallBacks);
  *((void *)v0 + 2) = result;
  getNetConnectionCache(void)::gHTTPConnectionCache = (uint64_t)v0;
  return result;
}

void sub_182AAA228(_Unwind_Exception *a1)
{
}

uint64_t HTTPReadStream::readHeader(HTTPReadStream *this, CFStreamError *a2)
{
  if (!*((void *)this + 10) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFTypeID v33 = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "readHeader(): no stream to read from!",  v33,  2u);
  }

  __int16 v4 = *((_WORD *)this + 8);
  *((_WORD *)this + 8) = v4 | 8;
  if ((v4 & 1) == 0) {
    return 1LL;
  }
  uint64_t v5 = (const __CFURL *)CFReadStreamCopyProperty( *((CFReadStreamRef *)this + 10),  @"kCFStreamPropertyHTTPResponseHeader");
  if (!v5)
  {
    if (CFReadStreamGetStatus(*((CFReadStreamRef *)this + 10)) == kCFStreamStatusError)
    {
      CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*((void *)this + 10));
      uint64_t result = 0LL;
      *a2 = Error;
      return result;
    }

    return 0LL;
  }

  CFURLRef v6 = v5;
  uint64_t v7 = *((void *)this + 3);
  int v8 = *(const __CFString **)(v7 + 152);
  if (v8
    || os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT)
    && (*(_WORD *)buf = 0,
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "these should always be initialized now",  buf,  2u),  (int v8 = *(const __CFString **)(v7 + 152)) != 0LL))
  {
    if (CFStringCompare(v8, (CFStringRef)&gConstantCFStringValueTable[2611], 0LL) == kCFCompareEqualTo) {
      goto LABEL_49;
    }
  }

  CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v6);
  uint64_t v12 = HTTPMessage::copyHeaderFieldValue((CFURLRef)((char *)v6 + 16), 0x13011336u);
  CFRelease(v6);
  if (!v12) {
    return 1LL;
  }
  __int16 v13 = CFGetAllocator(v6);
  CFReadStreamRef v14 = (const __CFArray *)*((void *)this + 15);
  if (v14 && CFArrayGetCount(v14) >= 1)
  {
    uint64_t v15 = (const __CFArray *)*((void *)this + 15);
    CFIndex Count = CFArrayGetCount(v15);
    ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v15, Count - 1);
  }

  else
  {
    ValueAtIndex = 0LL;
  }

  CFIndex location = CFStringFind(v12, @", ", 0LL).location;
  if (location == -1)
  {
    CFStringEncoding v20 = 134217984;
    CFIndex Length = CFStringGetLength(v12);
    uint64_t v22 = (UInt8 *)malloc(Length + 1);
    if (CFStringGetCString(v12, (char *)v22, Length + 1, 0x8000100u)
      || (CFStringEncoding v20 = 513, CFStringGetCString(v12, (char *)v22, Length + 1, 0x201u)))
    {
      CFURLRef v6 = CFURLCreateAbsoluteURLWithBytes(v13, v22, Length, v20, ValueAtIndex, 1u);
    }

    else
    {
      CFURLRef v6 = 0LL;
    }

    free(v22);
  }

  else
  {
    v35.CFIndex length = location;
    v35.CFIndex location = 0LL;
    uint64_t v19 = CFStringCreateWithSubstring(v13, v12, v35);
    CFURLRef v6 = CFURLCreateWithString(v13, v19, ValueAtIndex);
    if (v19) {
      CFRelease(v19);
    }
  }

  CFRelease(v12);
  if (!v6) {
    return 1LL;
  }
  uint64_t v23 = (const __CFArray *)*((void *)this + 15);
  if (v23 && CFArrayGetCount(v23) >= *((void *)this + 16))
  {
    a2->CFIndex domain = 4LL;
    a2->error = -2;
LABEL_49:
    CFRelease(v6);
    return 1LL;
  }

  CFGetAllocator((CFTypeRef)(*((void *)this + 4) - 16LL));
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v25 = (void *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v25 = (void *)(Instance + 16);
    *(void *)(Instance + 192) = 0LL;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }

  uint64_t v26 = (HTTPMessage *)HTTPRequestMessage::HTTPRequestMessage(v25, *((void *)this + 4), v6);
  HTTPMessage::removeHeaderFieldValue(v26, (const __CFString *)&unk_18C5AF0E8);
  uint64_t v27 = (__CFArray *)*((void *)this + 15);
  if (v27) {
    CFArrayAppendValue(v27, v6);
  }
  BOOL v28 = (const __CFDictionary *)*((void *)this + 6);
  if (v28)
  {
    if (CFDictionaryContainsKey(v28, @"kCFStreamPropertySSLSettings"))
    {
      uint64_t v29 = CFURLCopyScheme(v6);
      if (v29)
      {
        uint64_t v30 = v29;
        if (CFStringCompare(v29, (CFStringRef)&unk_18C5B2B50, 1uLL)) {
          CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 6), @"kCFStreamPropertySSLSettings");
        }
        CFRelease(v30);
      }
    }
  }

  CFRelease(v6);
  HTTPReadStream::dequeueRequestFromConnection(this, 0);
  CFRelease((CFTypeRef)(*((void *)this + 4) - 16LL));
  *((void *)this + 4) = v25;
  CFIndex v31 = (const void *)*((void *)this + 12);
  if (v31)
  {
    CFRelease(v31);
    *((void *)this + 12) = 0LL;
  }

  int v32 = HTTPReadStream::constructProxyList(this, a2);
  if (!a2->error)
  {
    if (v32) {
      return 0LL;
    }
    HTTPReadStream::startRequest(this, a2);
    if (!a2->error) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t HTTPReadStream::constructProxyList(HTTPReadStream *this, CFStreamError *a2)
{
  __int16 v4 = (const void *)*((void *)this + 5);
  if (!v4) {
    __int16 v4 = (const void *)*((void *)this + 1);
  }
  uint64_t v5 = CFGetAllocator(v4);
  if (*((void *)this + 12) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(context.version) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "constructProxyList(): proxy list already constructed!",  (uint8_t *)&context,  2u);
  }

  uint64_t v6 = *((void *)this + 4);
  if (!v6)
  {
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      LOWORD(context.version) = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "constructproxyList(): no request!",  (uint8_t *)&context,  2u);
      uint64_t v6 = *((void *)this + 4);
    }

    else
    {
      uint64_t v6 = 0LL;
    }
  }

  uint64_t v7 = (const void *)HTTPRequestParserClient::requestURL((HTTPRequestParserClient *)(v6 + 128));
  if (v7 && (int v8 = (const __CFURL *)CFRetain(v7)) != 0LL)
  {
    uint64_t v9 = v8;
    CFStringRef v10 = CFURLCopyScheme(v8);
    if (v10)
    {
      CFRelease(v10);
      *((_WORD *)this + 8) &= ~4u;
      Value = (__CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 6), &unk_18C5AD7F8);
      uint64_t v12 = (const __CFArray *)__CFNetworkCopyProxiesForURLWithInterface(v9, *((__CFDictionary **)this + 11), Value);
      CFIndex Count = CFArrayGetCount(v12);
      CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(v5, Count, v12);
      if (v12) {
        CFRelease(v12);
      }
      if (MutableCopy)
      {
        if (!CFArrayGetCount(MutableCopy))
        {
          CFRelease(MutableCopy);
          uint64_t v24 = 0LL;
          a2->CFIndex domain = 4LL;
          a2->error = -1;
          goto LABEL_33;
        }

        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(MutableCopy, 0LL);
        uint64_t v16 = CFDictionaryGetValue(ValueAtIndex, @"kCFProxyTypeKey");
        if (!CFEqual(@"kCFProxyTypeAutoConfigurationURL", v16))
        {
          uint64_t v17 = CFDictionaryGetValue(ValueAtIndex, @"kCFProxyTypeKey");
          if (!CFEqual(@"kCFProxyTypeAutoConfigurationJavaScript", v17))
          {
            uint64_t v24 = 0LL;
            *((void *)this + 12) = MutableCopy;
            goto LABEL_33;
          }
        }

        v32[0] = 0LL;
        v32[1] = this;
        memset(&v32[2], 0, 24);
        uint64_t v18 = (PAC *)CFDictionaryGetValue(ValueAtIndex, @"kCFProxyAutoConfigurationURLKey");
        uint64_t v19 = (PAC *)CFDictionaryGetValue(ValueAtIndex, @"kCFProxyAutoConfigurationJavaScriptKey");
        if (!v19) {
          uint64_t v19 = v18;
        }
        *((void *)this + 14) = PAC::CreatePACTicket( v19,  v9,  0LL,  0LL,  (std::__shared_weak_count_vtbl *)HTTPReadStream::_PACExecutionComplete,  (void (*)(void *, const __CFArray *, __CFError *))v32,  v20);
        CFArrayRemoveValueAtIndex(MutableCopy, 0LL);
        *((void *)this + 12) = MutableCopy;
        __int16 v21 = *((_WORD *)this + 8);
        *((_WORD *)this + 8) = v21 | 4;
        uint64_t v22 = *((void *)this + 18);
        if (v22 && *(_DWORD *)(v22 + 40))
        {
          *((_WORD *)this + 8) = v21 | 0x84;
          uint64_t v23 = (CFStringRef (__cdecl *)(const void *))*((void *)this + 14);
          context.version = MEMORY[0x1895F87A8];
          context.info = (void *)3221225472LL;
          context.retain = (const void *(__cdecl *)(const void *))___ZNK17CoreSchedulingSet14scheduleSourceEP17__CFRunLoopSource_block_invoke;
          context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
          context.copyDescription = v23;
          CoreSchedulingSet::applyBlockWithPossibleEmulation(v22, &context);
          uint64_t v24 = 1LL;
LABEL_33:
          CFRelease(v9);
          return v24;
        }

        context.version = 0LL;
        context.info = this;
        memset(&context.retain, 0, 24);
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        uint64_t v26 = CFRunLoopTimerCreate( v5,  Current + 60.0,  -1.0,  0LL,  0LL,  (CFRunLoopTimerCallBack)HTTPReadStream::_PACExecutionCompleteTimer,  &context);
        uint64_t v27 = CFRunLoopGetCurrent();
        CFRunLoopAddTimer(v27, v26, @"_kProxySupportSyncPACExecutionRunLoopMode");
        BOOL v28 = CFRunLoopGetCurrent();
        CFRunLoopAddSource(v28, *((CFRunLoopSourceRef *)this + 14), @"_kProxySupportSyncPACExecutionRunLoopMode");
        while ((*((_WORD *)this + 8) & 4) != 0)
          CFRunLoopRunInMode(@"_kProxySupportSyncPACExecutionRunLoopMode", 1.0e10, 1u);
        CFRunLoopTimerInvalidate(v26);
        if (v26) {
          CFRelease(v26);
        }
        uint64_t v29 = (__CFError *)*((void *)this + 13);
        if (v29)
        {
          a2->CFIndex domain = _CFStreamErrorFromCFError(v29);
          *(void *)&a2->error = v30;
        }
      }

      uint64_t v24 = 0LL;
      goto LABEL_33;
    }

    a2->CFIndex domain = 4LL;
    a2->error = -3;
    CFRelease(v9);
    return 0LL;
  }

  else
  {
    uint64_t v24 = 0LL;
    a2->CFIndex domain = 4LL;
    a2->error = -3;
  }

  return v24;
}

void HTTPReadStream::startRequest(HTTPReadStream *this, CFStreamError *a2)
{
  if (!*((void *)this + 4) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.version) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "startRequest(): no current request!",  (uint8_t *)&buf,  2u);
  }

  __int16 v4 = *((_WORD *)this + 8);
  if ((v4 & 4) != 0 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf.version) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "startRequest(): called while waiting for proxy info!",  (uint8_t *)&buf,  2u);
    __int16 v4 = *((_WORD *)this + 8);
  }

  LOBYTE(v5) = v4 & 0xF7;
  *((_WORD *)this + 8) = v4 & 0xFFF7;
  if (*((void *)this + 10))
  {
    HTTPReadStream::dequeueRequestFromConnection(this, 0);
    __int16 v5 = *((_WORD *)this + 8);
  }

  if ((v5 & 2) == 0)
  {
    uint64_t v6 = *((void *)this + 4);
    uint64_t v7 = *(_CFHTTPAuthentication **)(v6 + 72);
    if (v7)
    {
      if (_CFHTTPAuthenticationRequiresPersistentConnection(v7))
      {
LABEL_15:
        *((_WORD *)this + 8) |= 2u;
        goto LABEL_16;
      }

      uint64_t v6 = *((void *)this + 4);
    }

    int v8 = *(_CFHTTPAuthentication **)(v6 + 80);
    if (!v8 || !_CFHTTPAuthenticationRequiresPersistentConnection(v8)) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }

uint64_t _constructNetConnection(const __CFAllocator *a1, const void *a2, int a3)
{
  uint64_t v6 = MEMORY[0x186E12804](a1, 152LL, 0LL);
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
  *(_OWORD *)(v6 + 128) = 0u;
  *(void *)(v6 + 144) = 0LL;
  HTTPConnectionCacheKey::HTTPConnectionCacheKey( v6,  (uint64_t)a1,  *(const __CFString **)a2,  *((_DWORD *)a2 + 2),  *((_DWORD *)a2 + 3),  *((const void **)a2 + 2),  0LL);
  uint64_t v7 = MEMORY[0x186E12804](a1, 320LL, 0LL);
  *(_OWORD *)uint64_t v7 = 0u;
  *(_OWORD *)(v7 + 16) = 0u;
  *(_OWORD *)(v7 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0u;
  *(_OWORD *)(v7 + 48) = 0u;
  *(_OWORD *)(v7 + 64) = 0u;
  *(_OWORD *)(v7 + 80) = 0u;
  *(_OWORD *)(v7 + 96) = 0u;
  *(_OWORD *)(v7 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
  *(_OWORD *)(v7 + 128) = 0u;
  *(_OWORD *)(v7 + 144) = 0u;
  *(_OWORD *)(v7 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0u;
  *(_OWORD *)(v7 + 176) = 0u;
  *(_OWORD *)(v7 + 192) = 0u;
  *(_OWORD *)(v7 + 208) = 0u;
  *(_OWORD *)(v7 + 224) = 0u;
  *(_OWORD *)(v7 + 240) = 0u;
  *(_OWORD *)(v7 + 256) = 0u;
  *(_OWORD *)(v7 + 272) = 0u;
  *(_OWORD *)(v7 + 288) = 0u;
  *(_OWORD *)(v7 + 304) = 0u;
  HTTPNetConnection_NoAuth::HTTPNetConnection_NoAuth((HTTPNetConnection_NoAuth *)v7, a1, (HTTPConnectionCacheKey *)v6);
  (*(void (**)(uint64_t))(*(void *)v6 + 48LL))(v6);
  if (NetConnection::initialize((NetConnection *)v7, a3))
  {
    *(_BYTE *)(v7 + 268) = 0;
  }

  else
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 48LL))(v7);
    return 0LL;
  }

  return v7;
}

uint64_t ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke(uint64_t a1, __CFReadStream *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = MEMORY[0x186E12804](*(void *)(*(void *)(a1 + 40) + 8LL), 184LL, 0LL);
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0u;
  *(void *)(v5 + 176) = 0LL;
  HTTPNetStreamInfo::HTTPNetStreamInfo( (HTTPNetStreamInfo *)v5,  a2,  (CFTypeRef)(*(void *)(v4 + 32) - 16LL),  *(HTTPNetConnection **)(a1 + 40));
  (*(void (**)(uint64_t, void, void))(*(void *)v6 + 112LL))(v6, *(void *)(v4 + 40), 0LL);
  return v5;
}

uint64_t ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_2(uint64_t a1, __CFReadStream *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = MEMORY[0x186E12804](*(void *)(*(void *)(a1 + 40) + 8LL), 184LL, 0LL);
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0u;
  *(void *)(v5 + 176) = 0LL;
  HTTPNetStreamInfo::HTTPNetStreamInfo( (HTTPNetStreamInfo *)v5,  a2,  (CFTypeRef)(*(void *)(v4 + 32) - 16LL),  *(HTTPNetConnection **)(a1 + 40));
  (*(void (**)(uint64_t, void, void))(*(void *)v6 + 112LL))(v6, 0LL, 0LL);
  return v5;
}

CFTypeRef *_httpreadstream_retain(CFTypeRef *a1)
{
  return a1;
}

void _httpreadstream_release(CFTypeRef *a1)
{
}

uint64_t _httpreadstream_copyDesc(void *a1)
{
  return (*(uint64_t (**)(void *))(*(void *)a1 + 104LL))(a1);
}

void HTTPReadStream::_streamCB(HTTPReadStream *this, __CFReadStream *a2, HTTPReadStream *a3, void *a4)
{
  __int16 v4 = *((_WORD *)a3 + 8);
  if ((v4 & 0x40) != 0) {
    return;
  }
  if ((uint64_t)a2 > 7)
  {
    if (a2 == (__CFReadStream *)8)
    {
      CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*((void *)a3 + 10));
      goto LABEL_18;
    }

    if (a2 != (__CFReadStream *)16) {
      return;
    }
    if ((v4 & 8) == 0)
    {
      Error.CFIndex domain = 0LL;
      *(void *)&Error.error = 0LL;
      int v7 = HTTPReadStream::readHeader(a3, &Error);
      if (Error.error || v7) {
        goto LABEL_18;
      }
      return;
    }

void ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  (*(void (**)(void))(*(void *)(v1 + 56) + 16LL))();
  _Block_release(*(const void **)(v1 + 56));
  *(void *)(v1 + 56) = 0LL;
}

uint64_t ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 64LL) + 16LL))();
}

uint64_t ___ZN14HTTPReadStream12startRequestEP13CFStreamError_block_invoke_5(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 32) + 72LL) + 16LL))();
}

const __CFArray *HTTPReadStream::reattemptAfterError(CFReadStreamRef *this, CFStreamError *a2)
{
  v4.CFIndex domain = 0LL;
  *(void *)&v4.error = 0LL;
  if (((_BYTE)this[2] & 2) != 0
    && a2->domain == 4
    && a2->error == -4
    && (((_BYTE)this[2] & 0x10) == 0 || CFReadStreamGetStatus(this[5]) == kCFStreamStatusNotOpen))
  {
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
  }

  else
  {
    uint64_t result = this[12];
    if (!result) {
      return result;
    }
    if (CFArrayGetCount(result) < 2 || ((_WORD)this[2] & 0x10) != 0 && CFReadStreamGetStatus(this[5])) {
      return 0LL;
    }
    HTTPReadStream::dequeueRequestFromConnection((HTTPReadStream *)this, 0);
    if (CFArrayGetCount(this[12]) >= 1) {
      CFArrayRemoveValueAtIndex(this[12], 0LL);
    }
  }

  HTTPReadStream::startRequest((HTTPReadStream *)this, &v4);
  return (const __CFArray *)(v4.error == 0);
}

void HTTPReadStream::_PACExecutionCompleteTimer(HTTPReadStream *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  CFStreamError v4 = (const void *)*((void *)a2 + 5);
  if (!v4) {
    CFStreamError v4 = (const void *)*((void *)a2 + 1);
  }
  uint64_t v5 = CFGetAllocator(v4);
  CFCFStreamError Error = __cfnCreateCFError(v5, @"kCFErrorDomainCFNetwork", 308LL, v6, v7, v8, v9, v10, 0LL);
  uint64_t v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_5545, 2);
  if (v12)
  {
    __int16 v13 = v12;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v12 + 16LL))( v12,  "Read Stream PAC Timeout",  0LL))
    {
      CFReadStreamRef v14 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      uint64_t v15 = *((void *)a2 + 3);
      uint64_t v29 = off_189C1A178;
      CFStringRef v16 = CFStringCreateWithCString(v14, "Original Request", 0x8000100u);
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      SInt32 v30 = v16;
      if (v15)
      {
        CFIndex v17 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 32LL))(v15);
        CFStringRef v18 = v30;
      }

      else
      {
        CFStringRef v18 = v16;
        CFIndex v17 = @"null";
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v13 + 64LL))(v13, v18, v17);
      if (v15 && v17) {
        CFRelease(v17);
      }
      AutoString::~AutoString((AutoString *)&v29);
      uint64_t v19 = *((void *)a2 + 4);
      uint64_t v29 = off_189C1A178;
      CFStringRef v20 = CFStringCreateWithCString(v14, "Current Request", 0x8000100u);
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      SInt32 v30 = v20;
      if (v19)
      {
        __int16 v21 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v19 + 32LL))(v19);
        CFStringRef v20 = v30;
      }

      else
      {
        __int16 v21 = @"null";
      }

      (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v13 + 64LL))(v13, v20, v21);
      if (v19 && v21) {
        CFRelease(v21);
      }
      AutoString::~AutoString((AutoString *)&v29);
      uint64_t v22 = (const void *)*((void *)a2 + 11);
      uint64_t v29 = off_189C1A178;
      CFStringRef v23 = CFStringCreateWithCString(v14, "Proxy Configuration", 0x8000100u);
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      SInt32 v30 = v23;
      if (v22)
      {
        CFStringRef v24 = CFCopyDescription(v22);
        CFStringRef v23 = v30;
      }

      else
      {
        CFStringRef v24 = @"null";
      }

      (*(void (**)(void *, CFStringRef, CFStringRef))(*(void *)v13 + 64LL))(v13, v23, v24);
      if (v22 && v24) {
        CFRelease(v24);
      }
      AutoString::~AutoString((AutoString *)&v29);
      uint64_t v25 = (const void *)*((void *)a2 + 12);
      uint64_t v29 = off_189C1A178;
      CFStringRef v26 = CFStringCreateWithCString(v14, "Proxy List", 0x8000100u);
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      SInt32 v30 = v26;
      if (v25)
      {
        CFStringRef v27 = CFCopyDescription(v25);
        CFStringRef v26 = v30;
      }

      else
      {
        CFStringRef v27 = @"null";
      }

      (*(void (**)(void *, CFStringRef, CFStringRef))(*(void *)v13 + 64LL))(v13, v26, v27);
      if (v25 && v27) {
        CFRelease(v27);
      }
      AutoString::~AutoString((AutoString *)&v29);
      (*(void (**)(void *, const char *, void))(*(void *)v13 + 56LL))( v13,  "Proxy Error",  *((void *)a2 + 13));
      (*(void (**)(void *, const char *, CFErrorRef))(*(void *)v13 + 56LL))(v13, "Error", CFError);
      (*(void (**)(void *))(*(void *)v13 + 8LL))(v13);
    }
  }

  HTTPReadStream::pacExecutionComplete((uint64_t)a2, 0LL, CFError);
  CFAbsoluteTime Current = CFRunLoopGetCurrent();
  CFRunLoopStop(Current);
  if (CFError) {
    CFRelease(CFError);
  }
}

void sub_182AAB878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t HTTPReadStream::pacExecutionComplete(uint64_t this, CFTypeRef cf, void *a3)
{
  v12.CFIndex domain = 0LL;
  *(void *)&v12.error = 0LL;
  __int16 v3 = *(_WORD *)(this + 16);
  if ((v3 & 4) != 0)
  {
    uint64_t v6 = this;
    *(_WORD *)(this + 16) = v3 & 0xFFFB;
    uint64_t v7 = *(__CFRunLoopSource **)(this + 112);
    if (v7)
    {
      CFRunLoopSourceInvalidate(v7);
      uint64_t v8 = *(const void **)(v6 + 112);
      if (v8) {
        CFRelease(v8);
      }
      *(void *)(v6 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0LL;
    }

    uint64_t v9 = *(const __CFArray **)(v6 + 96);
    if (a3)
    {
      if (!v9 || (this = CFArrayGetCount(v9), this <= 0))
      {
        CFRetain(a3);
        *(void *)(v6 + 104) = a3;
        v12.CFIndex domain = _CFStreamErrorFromCFError((__CFError *)a3);
        *(void *)&v12.error = v10;
        return CFReadStreamSignalEvent();
      }
    }

    else
    {
      if (v9) {
        CFRelease(v9);
      }
      uint64_t v11 = CFGetAllocator(cf);
      this = (uint64_t)CFArrayCreateMutableCopy(v11, 0LL, (CFArrayRef)cf);
      *(void *)(v6 + 96) = this;
    }

    if ((*(_WORD *)(v6 + 16) & 0x80) == 0) {
      return this;
    }
    HTTPReadStream::startRequest((HTTPReadStream *)v6, &v12);
    if (!v12.error) {
      return CFReadStreamSignalEvent();
    }
    return CFReadStreamSignalEvent();
  }

  return this;
}

uint64_t ___ZN14HTTPReadStream15pacTimerTimeoutEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 834LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

void sub_182AABB20(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  _Unwind_Resume(a1);
}

void HTTPReadStream::HTTPReadStream( HTTPReadStream *this, CFTypeRef cf, HTTPRequestMessage *a3, __CFReadStream *a4)
{
  *(void *)this = off_189C09AC8;
  *((void *)this + 1) = cf;
  *((_WORD *)this + 8) = 0;
  CFGetAllocator(cf);
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = (HTTPRequestMessage *)Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + 16) = 0u;
    uint64_t v8 = (HTTPRequestMessage *)(Instance + 16);
    *(void *)(Instance + 192) = 0LL;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0u;
    *(_OWORD *)(Instance + 176) = 0u;
    *(_OWORD *)(Instance + 128) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0u;
    *(_OWORD *)(Instance + 48) = 0u;
  }

  HTTPRequestMessage::HTTPRequestMessage(v8, a3);
  *((void *)this + 3) = v8;
  *((void *)this + 4) = 0LL;
  if (a4)
  {
    *((void *)this + 5) = CFRetain(a4);
    *((_WORD *)this + 8) |= 0x10u;
  }

  else
  {
    HTTPMessage::ensureParserFinished(v8);
    uint64_t v10 = (HTTPBodyData *)*((void *)v8 + 6);
    *((void *)v8 + 6) = 0LL;
    if (v10)
    {
      HTTPBodyData::captureData(v10, v9);
      uint64_t v12 = v11;
      (*(void (**)(HTTPBodyData *))(*(void *)v10 + 8LL))(v10);
      *((void *)this + 5) = v12;
    }
  }

  __int16 v13 = CFGetAllocator(*((CFTypeRef *)this + 1));
  Mutable = (CoreSchedulingSet *)CFDictionaryCreateMutable(v13, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 15) = 0LL;
  *((void *)this + 16) = 20LL;
  *((void *)this + 6) = Mutable;
  *((void *)this + 7) = 0LL;
  *((void *)this + 18) = CoreSchedulingSet::createEmpty(Mutable);
}

void sub_182AABC88(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  _Unwind_Resume(a1);
}

CFStringRef SocketStream::copyDebugDesc(SocketStream *this)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (__CFSocket *)*((void *)this + 36);
  if (v2) {
    CFSocketNativeHandle Native = CFSocketGetNative(v2);
  }
  else {
    CFSocketNativeHandle Native = -1;
  }
  snprintf(__str, 0x100uLL, "{ fd %d }", Native);
  CFStreamError v4 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v4, 0LL, @"<SocketStream@%p> %s", this, __str);
}

__CFHost *SocketStream::initialize( CFMutableDictionaryRef *this, const __CFString *a2, const __CFAllocator *a3)
{
  uint64_t v6 = this - 2;
  uint64_t v7 = CFGetAllocator(this - 2);
  uint64_t v8 = (__CFHost *)_CFHostCreateWithNameAndPortForConnect(v7, a2, (const __CFAllocator *)(unsigned __int16)a3);
  if (v8 || (v9 = CFGetAllocator(v6), uint64_t result = CFHostCreateWithName(v9, a2), (v8 = result) != 0LL))
  {
    SocketStream::initialize(this, v8, a3);
    CFRelease(v8);
    return (__CFHost *)1;
  }

  return result;
}

uint64_t SocketStream::captureStreams(SocketStream *this, __CFReadStream **a2, __CFWriteStream **a3)
{
  if (*((_BYTE *)this + 193)) {
    return 0LL;
  }
  if (a2)
  {
    CFGetAllocator((char *)this - 16);
    uint64_t v7 = (__CFReadStream *)CFReadStreamCreate();
    *a2 = v7;
    objc_storeWeak((id *)this + 34, v7);
    if (*a2) {
      CFRetain((char *)this - 16);
    }
  }

  if (a3)
  {
    CFGetAllocator((char *)this - 16);
    uint64_t v8 = (__CFWriteStream *)CFWriteStreamCreate();
    *a3 = v8;
    objc_storeWeak((id *)this + 35, v8);
    if (*a3) {
      CFRetain((char *)this - 16);
    }
  }

  if (!a2) {
    return 1LL;
  }
  uint64_t result = 1LL;
  if (a3 && *a2 && *a3)
  {
    int v10 = *((_DWORD *)this + 62);
    uint64_t v9 = (int *)((char *)this + 248);
    int *v9 = v10 | 0x80;
    CFRetain(v9 - 66);
    return 1LL;
  }

  return result;
}

void SocketStream::finalize(SocketStream *this, const void *a2)
{
  CFStreamError v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  (*(void (**)(SocketStream *, const void *))(*(void *)this + 104LL))(this, a2);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  uint64_t v5 = (id *)((char *)this + 272);
  if (*((const void **)this + 34) != a2)
  {
    uint64_t v5 = (id *)((char *)this + 280);
  }

  objc_storeWeak(v5, 0LL);
  CFRelease(v4);
LABEL_5:
  uint64_t v6 = *((unsigned int *)this + 62);
  if ((v6 & 0x80) != 0)
  {
    unint64_t v8 = v6 & 0xFFFFFFFFFFFFFF7FLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v6 & 0xFFFFFF7F;
    *((_WORD *)this + 126) = WORD2(v8);
    CFRelease(v4);
    goto LABEL_12;
  }

  if (!*((void *)this + 34) && !*((void *)this + 35))
  {
    uint64_t v7 = (const void *)*((void *)this + 37);
    if (v7)
    {
      if (*((_DWORD *)this + 66))
      {
        *((void *)this + 37) = 0LL;
      }

      else
      {
        do
        {
          if (SSLClose(*((SSLContextRef *)this + 37)) != -9803) {
            break;
          }
          uint64_t v9 = (const __CFArray *)*((void *)this + 40);
          if (!v9) {
            break;
          }
          if (!CFArrayGetCount(v9)) {
            break;
          }
          CFRunLoopRef Current = CFRunLoopGetCurrent();
          _SchedulesAddRunLoopAndMode( *((const __CFArray **)this + 40),  Current,  @"_kCFStreamSocketSecurityClosePrivateMode");
          uint64_t v11 = *((void *)this + 41);
          CFRunLoopRef context = Current;
          uint64_t v20 = (uint64_t)@"_kCFStreamSocketSecurityClosePrivateMode";
          v24.CFIndex length = *(void *)(v11 + 24);
          v24.CFIndex location = 0LL;
          CFArrayApplyFunction( *(CFArrayRef *)(v11 + 16),  v24,  (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction,  &context);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
          CFRunLoopRunInMode(@"_kCFStreamSocketSecurityClosePrivateMode", 1.0e20, 1u);
          pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
          uint64_t v12 = *((void *)this + 41);
          CFRunLoopRef context = Current;
          uint64_t v20 = (uint64_t)@"_kCFStreamSocketSecurityClosePrivateMode";
          v25.CFIndex length = *(void *)(v12 + 24);
          v25.CFIndex location = 0LL;
          CFArrayApplyFunction( *(CFArrayRef *)(v12 + 16),  v25,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction,  &context);
          _SchedulesRemoveRunLoopAndMode( *((const __CFArray **)this + 40),  Current,  @"_kCFStreamSocketSecurityClosePrivateMode");
        }

        while (!*((_DWORD *)this + 66));
        uint64_t v7 = (const void *)*((void *)this + 37);
        *((void *)this + 37) = 0LL;
        if (!v7) {
          goto LABEL_19;
        }
      }

      CFRelease(v7);
    }

CFStringRef SocketStream::copyDescription(SocketStream *this, const void *a2)
{
  CFStreamError v4 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat( v4,  0LL,  @"<SocketStream %p>{flags = %p, read = %p, write = %p, socket = %@, properties = %p }",  a2,  (char *)this + 248,  *((void *)this + 34),  *((void *)this + 35),  *((void *)this + 36),  *((void *)this + 42));
}

uint64_t SocketStream::open(SocketStream *this, const void *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  a3->CFIndex domain = 0LL;
  *(void *)&a3->error = 0LL;
  *a4 = 0;
  unint64_t v8 = (pthread_mutex_t *)((char *)this + 40);
  uint64_t v9 = (CoreSchedulingSet *)pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  uint64_t v10 = 1024LL;
  unint64_t v11 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | v10;
  *((_DWORD *)this + 62) |= v10;
  if (*((void *)this + 30))
  {
    if ((v11 & 2) == 0) {
      goto LABEL_5;
    }
LABEL_9:
    *a3 = *((CFStreamError *)this + 16);
    *a4 = 1;
    goto LABEL_55;
  }

  uint64_t v12 = CoreSchedulingSet::copyRunloopEmulationSet(v9);
  v61[0] = (void (*)(void, void, void))MEMORY[0x1895F87A8];
  v61[1] = (void (*)(void, void, void))3221225472LL;
  v61[2] = (void (*)(void, void, void))___ZN12SocketStream4openEPKvP13CFStreamErrorPh_block_invoke;
  v61[3] = (void (*)(void, void, void))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
  v61[4] = (void (*)(void, void, void))this;
  CoreSchedulingSet::applyBlockWithPossibleEmulation(v12, v61);
  (*(void (**)(uint64_t))(*(void *)v12 + 48LL))(v12);
  uint64_t v13 = *((unsigned int *)this + 62);
  unint64_t v11 = v13 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v13 & 2) != 0) {
    goto LABEL_9;
  }
LABEL_5:
  if ((v11 & 1) != 0) {
    goto LABEL_55;
  }
  *((_WORD *)this + 126) = WORD2(v11);
  *((_DWORD *)this + 62) = v11 | 1;
  if (!*((_DWORD *)this + 66))
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC7C8);
    if (!Value) {
      goto LABEL_38;
    }
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    int v15 = valuePtr;
    CFStringRef v16 = (CFStringRef (__cdecl *)(const void *))dispatch_queue_attr_make_with_qos_class( 0LL,  (dispatch_qos_class_t)valuePtr,  0);
    if (v15 > 20)
    {
      switch(v15)
      {
        case 21:
          v66[0].version = MEMORY[0x1895F87A8];
          v66[0].info = (void *)3221225472LL;
          v66[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_3;
          v66[0].release = (CFAllocatorReleaseCallBack)&unk_189C1A548;
          v66[0].copyDescription = v16;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, v66);
          }
          CFIndex v17 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sDefaultTCPConnWorkQueue;
          break;
        case 25:
          v66[0].version = MEMORY[0x1895F87A8];
          v66[0].info = (void *)3221225472LL;
          v66[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_2;
          v66[0].release = (CFAllocatorReleaseCallBack)&unk_189C1A548;
          v66[0].copyDescription = v16;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, v66);
          }
          CFIndex v17 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInitiatedTCPConnWorkQueue;
          break;
        case 33:
          v66[0].version = MEMORY[0x1895F87A8];
          v66[0].info = (void *)3221225472LL;
          v66[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke;
          v66[0].release = (CFAllocatorReleaseCallBack)&unk_189C1A548;
          v66[0].copyDescription = v16;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, v66);
          }
          CFIndex v17 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInteractiveTCPConnWorkQueue;
          break;
        default:
          goto LABEL_44;
      }
    }

    else if (v15)
    {
      if (v15 != 9)
      {
        if (v15 == 17)
        {
          v66[0].version = MEMORY[0x1895F87A8];
          v66[0].info = (void *)3221225472LL;
          v66[0].retain = (CFAllocatorRetainCallBack)___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_4;
          v66[0].release = (CFAllocatorReleaseCallBack)&unk_189C1A548;
          v66[0].copyDescription = v16;
          if (copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken != -1) {
            dispatch_once(&copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::onceToken, v66);
          }
          CFIndex v17 = &copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUtilityTCPConnWorkQueue;
          goto LABEL_36;
        }

uint64_t SocketStream::openCompleted(SocketStream *this, const void *a2, CFStreamError *a3)
{
  return SocketStream::streamCan((uint64_t)this, a2, 0, (const __CFString *)&unk_18C5AD0F8, a3);
}

void SocketStream::close(SocketStream *this, const void *a2)
{
  CFStreamError v4 = (char *)this - 16;
  CFRetain((char *)this - 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  uint64_t v5 = (__CFRunLoop *)*((void *)this + 30);
  if (v5) {
    SocketStream::unschedule_NoLock(this, a2, v5, (const __CFString *)&unk_18C5AD018);
  }
  if (*((const void **)this + 34) == a2)
  {
    uint64_t v6 = (void **)((char *)this + 304);
    uint64_t v7 = (__CFArray **)((char *)this + 312);
    uint64_t v8 = 0x1000000000LL;
  }

  else
  {
    uint64_t v6 = (void **)((char *)this + 312);
    uint64_t v7 = (__CFArray **)((char *)this + 304);
    uint64_t v8 = 0x2000000000LL;
  }

  uint64_t v9 = *v6;
  uint64_t v10 = *v7;
  unint64_t v11 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | v8;
  *((_DWORD *)this + 62) = v11;
  *((_WORD *)this + 126) = WORD2(v11);
  if (v9 && v10)
  {
    uint64_t v12 = *((void *)this + 41);
    v19.CFIndex length = *(void *)(v12 + 24);
    v19.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v12 + 16),  v19,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction,  v9);
    CFArrayRemoveAllValues((CFMutableArrayRef)v9);
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)this + 40));
    if (Count)
    {
      v20.CFIndex length = Count;
      v20.CFIndex location = 0LL;
      CFArrayAppendArray(v10, *((CFArrayRef *)this + 40), v20);
      CFArrayRemoveAllValues(*((CFMutableArrayRef *)this + 40));
    }

    *((_DWORD *)this + 103) = 0;
  }

CFDictionaryRef SocketStream::copyProperty(SocketStream *this, const void *a2, const __CFString *a3)
{
  uint64_t v5 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  CFDictionaryRef v7 = SocketStream::copyProperty_NoLock(this, a3, v6);
  pthread_mutex_unlock(v5);
  return v7;
}

void sub_182AACD90(_Unwind_Exception *a1)
{
}

uint64_t SocketStream::setProperty(SocketStream *this, const void *a2, const __CFString *a3, __CFString *a4)
{
  uint64_t v100 = 0LL;
  memset(v99, 0, sizeof(v99));
  uint64_t v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  int ExactString = _findExactString(a3, 0);
  uint64_t v11 = 0LL;
  if (ExactString > 129296696)
  {
    if (ExactString > 195382724)
    {
      if (ExactString <= 223645656)
      {
        if (ExactString > 213192471)
        {
          if (ExactString > 215166783)
          {
            if (ExactString == 215166784) {
              goto LABEL_162;
            }
            if (ExactString == 216338253)
            {
              CFIndex v72 = (__CFDictionary *)*((void *)this + 42);
              if (a4) {
                CFDictionarySetValue(v72, a3, a4);
              }
              else {
                CFDictionaryRemoveValue(v72, a3);
              }
              uint64_t v84 = (__CFSocket *)*((void *)this + 36);
              if (v84 && CFSocketIsValid(v84))
              {
                CFOptionFlags SocketFlags = CFSocketGetSocketFlags(*((CFSocketRef *)this + 36));
                if (a4)
                {
                  if ((__CFString *)*MEMORY[0x189604DE0] == a4) {
                    CFOptionFlags v86 = SocketFlags & 0xFFFFFFFFFFFFFF7FLL;
                  }
                  else {
                    CFOptionFlags v86 = SocketFlags | 0x80;
                  }
                }

                else if ((*((_DWORD *)this + 62) & 0x100) != 0)
                {
                  CFOptionFlags v86 = SocketFlags & 0xFFFFFFFFFFFFFF7FLL;
                }

                else
                {
                  CFOptionFlags v86 = SocketFlags | 0x80;
                }

                CFSocketSetSocketFlags(*((CFSocketRef *)this + 36), v86);
              }

              goto LABEL_305;
            }

            int v18 = 217460578;
            goto LABEL_161;
          }

          if (ExactString != 213192472)
          {
            if (ExactString != 214216493) {
              goto LABEL_306;
            }
            if ((*((_BYTE *)this + 248) & 1) != 0) {
              goto LABEL_305;
            }
            uint64_t v11 = 1LL;
            if (a4 && (*((_BYTE *)this + 248) & 2) == 0)
            {
              CFTypeID v45 = CFGetTypeID(a4);
              if (v45 == CFBooleanGetTypeID())
              {
                int Value = CFBooleanGetValue((CFBooleanRef)a4);
                unint64_t v47 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
                if (Value) {
                  __int16 v48 = WORD2(v47) | 1;
                }
                else {
                  __int16 v48 = WORD2(v47) & 0xFFFE;
                }
                *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
                *((_WORD *)this + 126) = v48;
              }

              goto LABEL_305;
            }

            goto LABEL_306;
          }
        }

        else
        {
          if (ExactString <= 203689578)
          {
            if (ExactString == 195382725) {
              goto LABEL_162;
            }
            int v18 = 196464091;
            goto LABEL_161;
          }

          if (ExactString != 203689579 && ExactString != 205827726)
          {
            if (ExactString != 212037386) {
              goto LABEL_306;
            }
            if ((*((_BYTE *)this + 248) & 1) != 0) {
              goto LABEL_305;
            }
            uint64_t v11 = 1LL;
            if (a4 && (*((_BYTE *)this + 248) & 2) == 0)
            {
              CFTypeID v16 = CFGetTypeID(a4);
              if (v16 == CFBooleanGetTypeID())
              {
                if (CFBooleanGetValue((CFBooleanRef)a4)) {
                  unsigned int v17 = *((_DWORD *)this + 62) | 0x80000000;
                }
                else {
                  unsigned int v17 = *((_DWORD *)this + 62) & 0x7FFFFFFF;
                }
                *((_WORD *)this + 126) = *((_WORD *)this + 126);
                *((_DWORD *)this + 62) = v17;
              }

              goto LABEL_305;
            }

            goto LABEL_306;
          }
        }

        goto LABEL_162;
      }

      if (ExactString > 228814902)
      {
        if (ExactString <= 233173109)
        {
          if (ExactString != 228814903)
          {
            if (ExactString != 231968871) {
              goto LABEL_306;
            }
            char v50 = dyld_program_sdk_at_least();
            if (a4) {
              char v52 = v50;
            }
            else {
              char v52 = 1;
            }
            if ((v52 & 1) == 0)
            {
              CFTypeID v53 = CFGetTypeID(a4);
              if (v53 == CFStringGetTypeID()) {
                a4 = (__CFString *)MEMORY[0x189604A60];
              }
            }

            if (!SocketStream::securitySetInfo_NoLock( (CFDictionaryRef *)this,  (const __CFDictionary *)a4,  v51)) {
              goto LABEL_278;
            }
            __int16 v43 = (__CFDictionary *)*((void *)this + 42);
            a3 = @"kCFStreamPropertySSLSettings";
            if (!a4) {
              goto LABEL_304;
            }
LABEL_164:
            CFDictionarySetValue(v43, a3, a4);
            goto LABEL_305;
          }

          uint64_t v30 = SocketStream::securitySetContext_NoLock(this, (SSLContextRef)a4, v10);
        }

        else
        {
          if (ExactString == 233173110)
          {
            uint64_t v11 = *((void *)this + 37);
            if (v11)
            {
              if (a4)
              {
                CFDataGetBytePtr((CFDataRef)a4);
                CFDataGetLength((CFDataRef)a4);
              }

              uint64_t v11 = _SSLSetDiffieHellmanParams() == 0;
            }

            goto LABEL_306;
          }

          if (ExactString == 257143274) {
            goto LABEL_163;
          }
          if (ExactString != 558087215) {
            goto LABEL_306;
          }
          uint64_t v30 = SocketStream::_CONNECTSetInfo_NoLock((CFDictionaryRef *)this, (CFDictionaryRef)a4);
        }

        goto LABEL_280;
      }

      if (ExactString > 225669116)
      {
        if (ExactString != 225669117)
        {
          if (ExactString == 226775051) {
            goto LABEL_162;
          }
          int v18 = 227954717;
          goto LABEL_161;
        }

        uint64_t v30 = SocketStream::_SOCKSSetInfo_NoLock((CFDictionaryRef *)this, (const __CFDictionary *)a4);
LABEL_280:
        uint64_t v11 = v30;
        goto LABEL_306;
      }

      if (ExactString != 223645657)
      {
        if (ExactString != 224669676) {
          goto LABEL_306;
        }
        CFTypeID v38 = CFGetTypeID(a4);
        if (v38 != CFDataGetTypeID()) {
          goto LABEL_278;
        }
        BytePtr = (SSLContextRef *)CFDataGetBytePtr((CFDataRef)a4);
        uint64_t v30 = SocketStream::securitySetContext_NoLock(this, *BytePtr, v40);
        goto LABEL_280;
      }

      CFIndex v73 = CFGetAllocator((char *)this - 16);
      Mutable = CFDictionaryCreateMutable(v73, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
      uint64_t v11 = (uint64_t)Mutable;
      if (!Mutable) {
        goto LABEL_306;
      }
      CFDictionaryAddValue(Mutable, &unk_18C5AE438, a4);
      int v76 = SocketStream::securitySetInfo_NoLock((CFDictionaryRef *)this, (const __CFDictionary *)v11, v75);
      CFRelease((CFTypeRef)v11);
      if (v76)
      {
        unint64_t v77 = (__CFDictionary *)*((void *)this + 42);
        if (a4) {
          CFDictionarySetValue(v77, @"kCFStreamPropertySocketSecurityLevel", a4);
        }
        else {
          CFDictionaryRemoveValue(v77, @"kCFStreamPropertySocketSecurityLevel");
        }
        goto LABEL_305;
      }

LABEL_278:
      uint64_t v11 = 0LL;
      goto LABEL_306;
    }

    if (ExactString > 157494065)
    {
      if (ExactString > 188075304)
      {
        if (ExactString <= 191171949)
        {
          if (ExactString == 188075305) {
            goto LABEL_162;
          }
          int v18 = 189107521;
        }

        else
        {
          if (ExactString == 191171950) {
            goto LABEL_163;
          }
          if (ExactString == 192228739)
          {
            uint64_t v69 = (__CFString *)*((void *)this + 67);
            if (v69 != a4)
            {
              if (v69) {
                CFRelease(v69);
              }
              if (a4) {
                CFTypeRef v70 = CFRetain(a4);
              }
              else {
                CFTypeRef v70 = 0LL;
              }
              *((void *)this + 67) = v70;
            }

            goto LABEL_305;
          }

          int v18 = 193334680;
        }

        goto LABEL_161;
      }

      if (ExactString > 161713009)
      {
        if (ExactString == 161713010)
        {
          if (a4)
          {
            CFTypeID v60 = CFGetTypeID(a4);
            if (v60 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
            {
              LOWORD(valuePtr[0]) = 0;
              _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)valuePtr,  2u);
            }

            BOOL v36 = *MEMORY[0x189604DE8] == (void)a4;
            *((_BYTE *)this + 406) = v36;
            if (v36)
            {
              CFStringRef v61 = (__CFSocket *)*((void *)this + 36);
              if (v61)
              {
                if (CFSocketIsValid(v61)) {
                  _CFSocketSetRecvAnyIf(*((__CFSocket **)this + 36));
                }
              }
            }
          }

          else
          {
            *((_BYTE *)this + 406) = 0;
          }

          goto LABEL_305;
        }

        if (ExactString == 174287922)
        {
          int v62 = stringToServiceType((uint64_t)a4);
          if (v62 != -1 && *((_DWORD *)this + 102) != v62)
          {
            *((_DWORD *)this + 102) = v62;
            if (*((void *)this + 69)) {
              tcp_connection_set_traffic_class();
            }
          }

          goto LABEL_305;
        }

        int v18 = 186928407;
        goto LABEL_161;
      }

      if (ExactString != 157494066)
      {
        if (ExactString != 160648036) {
          goto LABEL_306;
        }
        if (a4)
        {
          CFTypeID v35 = CFGetTypeID(a4);
          if (v35 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
          {
            LOWORD(valuePtr[0]) = 0;
            _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)valuePtr,  2u);
          }

          BOOL v36 = *MEMORY[0x189604DE8] == (void)a4;
          *((_BYTE *)this + 405) = v36;
          if (v36)
          {
            int v37 = (__CFSocket *)*((void *)this + 36);
            if (v37)
            {
              if (CFSocketIsValid(v37)) {
                _CFSocketSetNoDelay(*((__CFSocket **)this + 36));
              }
            }
          }
        }

        else
        {
          *((_BYTE *)this + 405) = 0;
        }

        goto LABEL_305;
      }

LABEL_318:
  pthread_mutex_unlock(v8);
  SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v99, v90);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v99);
  return v11;
}

void sub_182AAE324( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t SocketStream::schedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::schedule_NoLock(this, a2, a3, a4);
  return pthread_mutex_unlock(v8);
}

uint64_t SocketStream::unschedule(SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v8 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::unschedule_NoLock(this, a2, a3, a4);
  return pthread_mutex_unlock(v8);
}

uint64_t SocketStream::read( SocketStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  uint64_t v60 = *MEMORY[0x1895F89C0];
  xpc_object_t v55 = a6;
  a5->CFIndex domain = 0LL;
  *(void *)&a5->error = 0LL;
  *a6 = 0;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  int64_t v11 = 0LL;
  int v12 = (CFStreamError *)((char *)this + 256);
  for (int i = *((_DWORD *)this + 66); ; int i = 0)
  {
    unint64_t v14 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    CFRunLoopRef Current = CFRunLoopGetCurrent();
    context.version = 0LL;
    context.uint64_t info = Current;
    memset(&context.retain, 0, 56);
    context.perform = (void (__cdecl *)(void *))emptyPerform;
    CFTypeID v16 = CFGetAllocator((char *)this - 16);
    CFRunLoopSourceRef v17 = CFRunLoopSourceCreate(v16, 0LL, &context);
    *((void *)this + 71) = v17;
    if (!v17)
    {
      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
      *((_DWORD *)this + 66) = 12;
      uint64_t v27 = *((unsigned int *)this + 62);
      unint64_t v14 = v27 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if ((v27 & 0x800000) == 0) {
        goto LABEL_29;
      }
LABEL_32:
      unint64_t v28 = (__CFData *)*((void *)this + 29);
      if (v28)
      {
        MutableBytePtr = CFDataGetMutableBytePtr(v28);
        uint64_t v30 = *((void *)this + 28);
        if (v30 >= a4) {
          int64_t v11 = a4;
        }
        else {
          int64_t v11 = *((void *)this + 28);
        }
        *((void *)this + 28) = v30 - v11;
        memmove(a3, MutableBytePtr, v11);
        memmove(MutableBytePtr, &MutableBytePtr[v11], *((void *)this + 28));
        bzero(&MutableBytePtr[*((void *)this + 28)], 0x8000LL - *((void *)this + 28));
        if ((*((_DWORD *)this + 62) & 0x2000) != 0 && !*((void *)this + 28))
        {
          SocketStream::securityBufferedRead_NoLock(this);
          if (v11) {
            goto LABEL_39;
          }
        }

        else if (v11)
        {
LABEL_39:
          uint64_t v31 = *((unsigned int *)this + 62);
          if ((v31 & 0x2000000) != 0)
          {
            unint64_t v32 = v31 & 0xFFFFFFFFFDFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
            *((_DWORD *)this + 62) = v31 & 0xFDFFFFFF;
            *((_WORD *)this + 126) = WORD2(v32);
            uint64_t v33 = (__CFSocket *)*((void *)this + 36);
            if (v33)
            {
              if (CFSocketIsValid(v33)) {
                CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
              }
            }
          }

          goto LABEL_48;
        }
      }

      if (*((_DWORD *)this + 66) || (*((_DWORD *)this + 62) & 0x100000) != 0)
      {
        int64_t v11 = 0LL;
      }

      else
      {
        int64_t v11 = 0LL;
        *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
        *((_DWORD *)this + 66) = 35;
      }

      goto LABEL_48;
    }

    int Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC870);
    if (Value && CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr) && (double v19 = valuePtr, valuePtr <= 75.0))
    {
      double v20 = *((double *)this + 45);
      if (v20 > 0.0 && valuePtr == 0.0)
      {
        double valuePtr = *((double *)this + 45);
        double v19 = v20;
      }

      if (v19 == 0.0)
      {
        double v21 = 1.79769313e308;
        goto LABEL_19;
      }
    }

    else
    {
      double valuePtr = 75.0;
    }

    double v21 = CFAbsoluteTimeGetCurrent() + valuePtr;
LABEL_19:
    _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 38), Current, @"_kCFStreamSocketReadPrivateMode");
    uint64_t v22 = *((void *)this + 41);
    CFRunLoopRef v57 = Current;
    uint64_t v58 = 0x18C5AD130LL;
    v61.CFIndex length = *(void *)(v22 + 24);
    v61.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v22 + 16),  v61,  (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction,  &v57);
    CFRunLoopAddSource(Current, *((CFRunLoopSourceRef *)this + 71), @"_kCFStreamSocketReadPrivateMode");
    do
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
      CFRunLoopRunInMode(@"_kCFStreamSocketReadPrivateMode", valuePtr, 1u);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
      if (*((_DWORD *)this + 66)) {
        break;
      }
      if ((*((_DWORD *)this + 62) & 4) != 0) {
        break;
      }
      double valuePtr = v21 - CFAbsoluteTimeGetCurrent();
    }

    while (valuePtr > 0.0);
    CFRunLoopRemoveSource(Current, *((CFRunLoopSourceRef *)this + 71), @"_kCFStreamSocketReadPrivateMode");
    uint64_t v23 = *((void *)this + 41);
    CFRunLoopRef v57 = Current;
    uint64_t v58 = 0x18C5AD130LL;
    v62.CFIndex length = *(void *)(v23 + 24);
    v62.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v23 + 16),  v62,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction,  &v57);
    _SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 38), Current, @"_kCFStreamSocketReadPrivateMode");
    unint64_t v24 = (const void *)*((void *)this + 71);
    *((void *)this + 71) = 0LL;
    if (v24) {
      CFRelease(v24);
    }
    uint64_t v25 = *((unsigned int *)this + 62);
    unint64_t v14 = v25 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    if ((v25 & 4) == 0 && !*((_DWORD *)this + 66))
    {
      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
      *((_DWORD *)this + 66) = 60;
    }

uint64_t SocketStream::canRead(SocketStream *this, __CFReadStream *a2)
{
  CFStreamError v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  if (*((_DWORD *)this + 103)) {
    goto LABEL_3;
  }
  int v5 = *((_DWORD *)this + 62);
  if ((v5 & 0x800000) == 0) {
    goto LABEL_3;
  }
  if ((v5 & 0x100000) != 0 || *((void *)this + 29) && *((uint64_t *)this + 28) > 0)
  {
    BOOL v6 = 1LL;
LABEL_9:
    pthread_mutex_unlock(v4);
    return v6;
  }

  if ((v5 & 0x2000) != 0)
  {
    if ((*((_DWORD *)this + 62) & 0x60000000) != 0)
    {
      BOOL v6 = 0LL;
    }

    else
    {
      SocketStream::securityBufferedRead_NoLock(this);
      BOOL v6 = (*((_DWORD *)this + 62) & 0x100004LL) != 0;
    }

    goto LABEL_9;
  }

LABEL_3:
  pthread_mutex_unlock(v4);
  return SocketStream::streamCan((uint64_t)this, a2, 1, (const __CFString *)&unk_18C5AD050, &v8);
}

uint64_t SocketStream::write( SocketStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, int64_t a4, CFStreamError *a5)
{
  uint64_t v82 = *MEMORY[0x1895F89C0];
  a5->CFIndex domain = 0LL;
  *(void *)&a5->error = 0LL;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  int64_t v9 = 0LL;
  uint64_t v10 = (CFStreamError *)((char *)this + 256);
  CFTypeRef cf = (char *)this - 16;
  uint64_t v71 = (int)*MEMORY[0x1896051C0];
  while (1)
  {
    while (1)
    {
      int v11 = *((_DWORD *)this + 66);
      unint64_t v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if (v11) {
        goto LABEL_91;
      }
      if ((*((_DWORD *)this + 62) & 8) != 0) {
        goto LABEL_23;
      }
      CFRunLoopRef Current = CFRunLoopGetCurrent();
      context.version = 0LL;
      context.uint64_t info = Current;
      memset(&context.retain, 0, 56);
      context.perform = (void (__cdecl *)(void *))emptyPerform;
      unint64_t v14 = CFGetAllocator(cf);
      CFRunLoopSourceRef v15 = CFRunLoopSourceCreate(v14, 0LL, &context);
      *((void *)this + 72) = v15;
      if (!v15)
      {
        *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
        *((_DWORD *)this + 66) = 12;
        unint64_t v61 = *((_DWORD *)this + 62) & 0xFFFFFFF7 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
        *((_DWORD *)this + 62) &= ~8u;
        *((_WORD *)this + 126) = WORD2(v61);
        goto LABEL_113;
      }

      int Value = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5ACE90);
      if (!Value || !CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr))
      {
        double valuePtr = 75.0;
LABEL_12:
        double v17 = CFAbsoluteTimeGetCurrent() + valuePtr;
        goto LABEL_13;
      }

      if (valuePtr != 0.0) {
        goto LABEL_12;
      }
      double v17 = 1.79769313e308;
LABEL_13:
      _SchedulesAddRunLoopAndMode(*((const __CFArray **)this + 39), Current, @"_kCFStreamSocketWritePrivateMode");
      uint64_t v18 = *((void *)this + 41);
      CFRunLoopRef v73 = Current;
      uint64_t v74 = 0x18C5AD1D8LL;
      v83.CFIndex length = *(void *)(v18 + 24);
      v83.CFIndex location = 0LL;
      CFArrayApplyFunction( *(CFArrayRef *)(v18 + 16),  v83,  (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction,  &v73);
      CFRunLoopAddSource(Current, *((CFRunLoopSourceRef *)this + 72), @"_kCFStreamSocketWritePrivateMode");
      do
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 40));
        CFRunLoopRunInMode(@"_kCFStreamSocketWritePrivateMode", valuePtr, 1u);
        pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
        if (*((_DWORD *)this + 66)) {
          break;
        }
        if ((*((_DWORD *)this + 62) & 8) != 0) {
          break;
        }
        double valuePtr = v17 - CFAbsoluteTimeGetCurrent();
      }

      while (valuePtr > 0.0);
      CFRunLoopRemoveSource(Current, *((CFRunLoopSourceRef *)this + 72), @"_kCFStreamSocketWritePrivateMode");
      uint64_t v19 = *((void *)this + 41);
      CFRunLoopRef v73 = Current;
      uint64_t v74 = 0x18C5AD1D8LL;
      v84.CFIndex length = *(void *)(v19 + 24);
      v84.CFIndex location = 0LL;
      CFArrayApplyFunction( *(CFArrayRef *)(v19 + 16),  v84,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction,  &v73);
      _SchedulesRemoveRunLoopAndMode( *((const __CFArray **)this + 39),  Current,  @"_kCFStreamSocketWritePrivateMode");
      double v20 = (const void *)*((void *)this + 72);
      *((void *)this + 72) = 0LL;
      if (v20) {
        CFRelease(v20);
      }
      unint64_t v12 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      int v11 = *((_DWORD *)this + 66);
      if ((*((_DWORD *)this + 62) & 8) == 0) {
        break;
      }
      if (v11) {
        goto LABEL_91;
      }
LABEL_23:
      if ((v12 & 0x2000) == 0)
      {
        if ((v12 & 0x1000000) != 0)
        {
          uint64_t v31 = (void *)*((void *)this + 66);
          if (v31)
          {
            uint64_t v32 = v31[2];
            uint64_t v33 = v31[3];
            unint64_t v34 = v31[4];
          }

          else
          {
            CFAllocatorRef v37 = CFGetAllocator(cf);
            CFTypeID v38 = (void *)MEMORY[0x186E12804](v37, 36056LL, 0LL);
            bzero(v38, 0x8CD8uLL);
            CFAllocatorRef v39 = CFGetAllocator(cf);
            uint64_t v33 = 0LL;
            unint64_t v34 = ((unint64_t)(v38 + 5) & 0xFFFFFFFFFFFFFFF0LL) + 16;
            v38[4] = v34;
            *((_OWORD *)v38 + 1) = xmmword_182C9D7D0;
            *CFTypeID v38 = &off_189C0A358;
            v38[1] = v39;
            *((void *)this + 66) = v38;
            uint64_t v32 = 36000LL;
          }

          int64_t v40 = v32 - v33;
          if (v40 >= a4) {
            int64_t v9 = a4;
          }
          else {
            int64_t v9 = v40;
          }
          memcpy((void *)(v34 + v33), a3, v9);
          uint64_t v41 = *((void *)this + 66);
          *(void *)(v41 + 24) = v9 + v33;
          if (*(void *)(v41 + 16) == v9 + v33) {
            SocketStream::flushTransmissionBuffer_NoLock((CFStreamError *)this);
          }
          else {
            CFWriteStreamSignalEvent();
          }
        }

        else
        {
          int64_t v9 = SocketStream::sendToSocket(this, a3, a4, (CFStreamError *)this + 16);
        }

BOOL SocketStream::canWrite(SocketStream *this, __CFWriteStream *a2)
{
  return (*((_DWORD *)this + 62) & 0x60000000) == 0
      && SocketStream::streamCan((uint64_t)this, a2, 2, @"_kCFStreamSocketCanWritePrivateMode", &v3) != 0;
}

void SocketStream::setConnectionEstablishment(uint64_t a1, uint64_t a2)
{
  CFStreamError v4 = (os_unfair_lock_s *)(a1 + 424);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 424));
  uint64_t v5 = *(void *)(a1 + 416);
  if (v5 != a2)
  {
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
    }
    *(void *)(a1 + 416) = a2;
    if (a2) {
      (*(void (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
    }
  }

  os_unfair_lock_unlock(v4);
  if (*(void *)(a1 + 296))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 184LL))(a1);
    SSLSetSessionOption(*(SSLContextRef *)(a1 + 296), kSSLSessionOptionBreakOnCertRequested, v6 != 0);
    SSLSetSessionOption(*(SSLContextRef *)(a1 + 296), kSSLSessionOptionBreakOnServerAuth, v6 != 0);
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
    }
  }

uint64_t SocketStream::copyConnectionEstablishment(os_unfair_lock_s *this)
{
  uint64_t v2 = this + 106;
  os_unfair_lock_lock(this + 106);
  uint64_t v3 = *(void *)&this[104]._os_unfair_lock_opaque;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 16LL))(v3);
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t SocketStream::beginConnection(SocketStream *this)
{
  uint64_t v2 = (dispatch_queue_s *)*((void *)this + 70);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN12SocketStream15beginConnectionEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
  return 1LL;
}

uint64_t SocketStream::setProperty(id *this, const __CFString *a2, const void *a3)
{
  id WeakRetained = objc_loadWeakRetained(this + 34);
  if (!WeakRetained) {
    id WeakRetained = objc_loadWeakRetained(this + 35);
  }
  uint64_t v7 = (*((uint64_t (**)(id *, id, const __CFString *, const void *))*this + 15))(this, WeakRetained, a2, a3);
  if (WeakRetained) {
    CFRelease(WeakRetained);
  }
  return v7;
}

void SocketStream::setProperties(SocketStream *this, CFDictionaryRef theDict)
{
  context[0] = MEMORY[0x1895F87A8];
  context[1] = 3221225472LL;
  context[2] = ___ZN12SocketStream13setPropertiesEPK14__CFDictionary_block_invoke;
  context[3] = &__block_descriptor_40_e25_v24__0____CFString__8_v16l;
  context[4] = this;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)_apply_block, context);
}

void SocketStream::setNotificationProperty( SocketStream *this, int a2, CFStringRef theString, const void *a4)
{
  int ExactString = _findExactString(theString, 2u);
  if (ExactString > 90506881)
  {
    switch(ExactString)
    {
      case 106203045:
        uint64_t v8 = (const void **)((char *)this + 488);
        int64_t v9 = (const void **)((char *)this + 480);
        break;
      case 96814834:
        uint64_t v8 = (const void **)((char *)this + 472);
        int64_t v9 = (const void **)((char *)this + 464);
        break;
      case 90506882:
        uint64_t v8 = (const void **)((char *)this + 440);
        int64_t v9 = (const void **)((char *)this + 432);
        break;
      default:
        return;
    }

    goto LABEL_14;
  }

  if (ExactString == 83273191)
  {
    uint64_t v8 = (const void **)((char *)this + 456);
    int64_t v9 = (const void **)((char *)this + 448);
LABEL_14:
    if (a2) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v8;
    }
    goto LABEL_17;
  }

  if (ExactString != 84248066)
  {
    if (ExactString != 89532009) {
      return;
    }
    uint64_t v8 = (const void **)((char *)this + 504);
    int64_t v9 = (const void **)((char *)this + 496);
    goto LABEL_14;
  }

  uint64_t v10 = (const void **)((char *)this + 512);
LABEL_17:
  if (*v10)
  {
    _Block_release(*v10);
    CFStreamError *v10 = 0LL;
  }

  if (a4) {
    CFStreamError *v10 = _Block_copy(a4);
  }
}

uint64_t SocketStream::copyProperty(id *this, const __CFString *a2)
{
  id WeakRetained = objc_loadWeakRetained(this + 34);
  if (!WeakRetained) {
    id WeakRetained = objc_loadWeakRetained(this + 35);
  }
  uint64_t v5 = (*((uint64_t (**)(id *, id, const __CFString *))*this + 14))(this, WeakRetained, a2);
  if (WeakRetained) {
    CFRelease(WeakRetained);
  }
  return v5;
}

void SocketStream::closeStreams(SocketStream *this)
{
  uint64_t v2 = (dispatch_queue_s *)*((void *)this + 70);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN12SocketStream12closeStreamsEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_async(v2, block);
}

void non-virtual thunk to'SocketStream::~SocketStream(SocketStream *this)
{
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 8));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 16));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 16));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 24));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 24));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 32));
}

{
  SocketStream::~SocketStream((SocketStream *)((char *)this - 32));
}

void virtual thunk to'SocketStream::finalize(SocketStream *this, const void *a2)
{
}

CFStringRef virtual thunk to'SocketStream::copyDescription(SocketStream *this, const void *a2)
{
  return SocketStream::copyDescription((SocketStream *)((char *)this + *(void *)(*(void *)this - 40LL)), a2);
}

uint64_t virtual thunk to'SocketStream::open( SocketStream *this, const void *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  return SocketStream::open((SocketStream *)((char *)this + *(void *)(*(void *)this - 48LL)), a2, a3, a4);
}

uint64_t virtual thunk to'SocketStream::openCompleted(SocketStream *this, const void *a2, CFStreamError *a3)
{
  return SocketStream::streamCan( (uint64_t)this + *(void *)(*(void *)this - 56LL),  a2,  0,  (const __CFString *)&unk_18C5AD0F8,  a3);
}

void virtual thunk to'SocketStream::close(SocketStream *this, const void *a2)
{
}

CFDictionaryRef virtual thunk to'SocketStream::copyProperty( SocketStream *this, const void *a2, const __CFString *a3)
{
  return SocketStream::copyProperty((SocketStream *)((char *)this + *(void *)(*(void *)this - 72LL)), a2, a3);
}

uint64_t virtual thunk to'SocketStream::setProperty( SocketStream *this, const void *a2, const __CFString *a3, __CFString *a4)
{
  return SocketStream::setProperty((SocketStream *)((char *)this + *(void *)(*(void *)this - 80LL)), a2, a3, a4);
}

uint64_t virtual thunk to'SocketStream::schedule( SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v7 = (char *)this + *(void *)(*(void *)this - 88LL);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 40));
  SocketStream::schedule_NoLock((SocketStream *)v7, a2, a3, a4);
  return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 40));
}

uint64_t virtual thunk to'SocketStream::unschedule( SocketStream *this, const void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v7 = (char *)this + *(void *)(*(void *)this - 96LL);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 40));
  SocketStream::unschedule_NoLock((SocketStream *)v7, a2, a3, a4);
  return pthread_mutex_unlock((pthread_mutex_t *)(v7 + 40));
}

uint64_t virtual thunk to'SocketStream::read( SocketStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  return SocketStream::read((SocketStream *)((char *)this + *(void *)(*(void *)this - 104LL)), a2, a3, a4, a5, a6);
}

uint64_t virtual thunk to'SocketStream::canRead(SocketStream *this, __CFReadStream *a2)
{
  return SocketStream::canRead((SocketStream *)((char *)this + *(void *)(*(void *)this - 112LL)), a2);
}

uint64_t virtual thunk to'SocketStream::write( SocketStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, int64_t a4, CFStreamError *a5)
{
  return SocketStream::write((SocketStream *)((char *)this + *(void *)(*(void *)this - 120LL)), a2, a3, a4, a5);
}

BOOL virtual thunk to'SocketStream::canWrite(SocketStream *this, __CFWriteStream *a2)
{
  return SocketStream::canWrite((SocketStream *)((char *)this + *(void *)(*(void *)this - 128LL)), a2);
}

void SocketStream::~SocketStream(SocketStream *this)
{
  *(void *)this = &off_189C19C20;
  *((void *)this + 1) = &unk_189C19D20;
  *((void *)this + 2) = &unk_189C19DB8;
  *((void *)this + 3) = &unk_189C19EB8;
  *((void *)this + 4) = &unk_189C19F40;
  if (*((void *)this + 73))
  {
    tcp_connection_cancel();
    tcp_connection_release();
    *((void *)this + 73) = 0LL;
  }

  SocketStream::cleanupConnection_NoLock(this);
  if (*((_BYTE *)this + 636))
  {
    *((_BYTE *)this + 636) = 0;
    entr_act_end_delayInitStub(v2);
  }

  uint64_t v3 = (dispatch_object_s *)*((void *)this + 70);
  if (v3)
  {
    dispatch_release(v3);
    *((void *)this + 70) = 0LL;
  }

  CFStreamError v4 = (dispatch_source_s *)*((void *)this + 48);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*((dispatch_object_t *)this + 48));
    *((void *)this + 48) = 0LL;
  }

  uint64_t v5 = (dispatch_source_s *)*((void *)this + 49);
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((void *)this + 49) = 0LL;
  }

  uint64_t v6 = *((void *)this + 41);
  if (v6)
  {
    v40.CFIndex length = *(void *)(v6 + 24);
    v40.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v6 + 16),  v40,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction,  *((void **)this + 38));
    uint64_t v7 = *((void *)this + 41);
    v41.CFIndex length = *(void *)(v7 + 24);
    v41.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v7 + 16),  v41,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction,  *((void **)this + 39));
    uint64_t v8 = *((void *)this + 41);
    v42.CFIndex length = *(void *)(v8 + 24);
    v42.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v8 + 16),  v42,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleFromAllApplierFunction,  *((void **)this + 40));
    uint64_t v9 = *((void *)this + 41);
    v43.CFIndex length = *(void *)(v9 + 24);
    v43.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v9 + 16),  v43,  (CFArrayApplierFunction)Schedulables::_SchedulablesInvalidateApplierFunction,  0LL);
    uint64_t v10 = *((void *)this + 41);
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  int v11 = (__CFSocket *)*((void *)this + 36);
  if (v11)
  {
    *((_DWORD *)this + 62) |= 0x800u;
    CFSocketInvalidate(v11);
    CFRelease(*((CFTypeRef *)this + 36));
    *((void *)this + 36) = 0LL;
  }

  unint64_t v12 = (const void *)*((void *)this + 67);
  if (v12) {
    CFRelease(v12);
  }
  int v13 = (const void *)*((void *)this + 38);
  *((void *)this + 38) = 0LL;
  if (v13) {
    CFRelease(v13);
  }
  unint64_t v14 = (const void *)*((void *)this + 39);
  *((void *)this + 39) = 0LL;
  if (v14) {
    CFRelease(v14);
  }
  CFRunLoopSourceRef v15 = (const void *)*((void *)this + 40);
  *((void *)this + 40) = 0LL;
  if (v15) {
    CFRelease(v15);
  }
  CFTypeID v16 = (const void *)*((void *)this + 37);
  *((void *)this + 37) = 0LL;
  if (v16) {
    CFRelease(v16);
  }
  double v17 = (const void *)*((void *)this + 42);
  *((void *)this + 42) = 0LL;
  if (v17) {
    CFRelease(v17);
  }
  uint64_t v18 = (const void *)*((void *)this + 29);
  *((void *)this + 29) = 0LL;
  if (v18) {
    CFRelease(v18);
  }
  uint64_t v19 = (const void *)*((void *)this + 30);
  *((void *)this + 30) = 0LL;
  if (v19) {
    CFRelease(v19);
  }
  uint64_t v20 = *((void *)this + 65);
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  double v21 = (const void *)*((void *)this + 71);
  *((void *)this + 71) = 0LL;
  if (v21) {
    CFRelease(v21);
  }
  uint64_t v22 = (const void *)*((void *)this + 72);
  *((void *)this + 72) = 0LL;
  if (v22) {
    CFRelease(v22);
  }
  uint64_t v23 = *((void *)this + 66);
  if (v23)
  {
    (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
    *((void *)this + 66) = 0LL;
  }

  uint64_t v24 = *((void *)this + 74);
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
  }
  uint64_t v25 = *((void *)this + 27);
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
  }
  unint64_t v26 = (const void *)*((void *)this + 54);
  if (v26) {
    _Block_release(v26);
  }
  uint64_t v27 = (const void *)*((void *)this + 55);
  if (v27) {
    _Block_release(v27);
  }
  uint64_t v28 = (const void *)*((void *)this + 56);
  if (v28) {
    _Block_release(v28);
  }
  uint64_t v29 = (const void *)*((void *)this + 57);
  if (v29) {
    _Block_release(v29);
  }
  unint64_t v30 = (const void *)*((void *)this + 58);
  if (v30) {
    _Block_release(v30);
  }
  uint64_t v31 = (const void *)*((void *)this + 59);
  if (v31) {
    _Block_release(v31);
  }
  uint64_t v32 = (const void *)*((void *)this + 60);
  if (v32) {
    _Block_release(v32);
  }
  uint64_t v33 = (const void *)*((void *)this + 61);
  if (v33) {
    _Block_release(v33);
  }
  unint64_t v34 = (const void *)*((void *)this + 62);
  if (v34) {
    _Block_release(v34);
  }
  unint64_t v35 = (const void *)*((void *)this + 63);
  if (v35) {
    _Block_release(v35);
  }
  unsigned int v36 = (const void *)*((void *)this + 64);
  if (v36) {
    _Block_release(v36);
  }
  (*(void (**)(SocketStream *, void))(*(void *)this + 176LL))(this, 0LL);
  objc_storeWeak((id *)this + 34, 0LL);
  objc_storeWeak((id *)this + 35, 0LL);
  CFAllocatorRef v37 = (const void *)*((void *)this + 85);
  *((void *)this + 85) = 0LL;
  if (v37) {
    CFRelease(v37);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 656);
  CFTypeID v38 = (const void *)*((void *)this + 80);
  *((void *)this + 80) = 0LL;
  if (v38) {
    CFRelease(v38);
  }
  uint64_t v39 = *((void *)this + 22);
  *((void *)this + 22) = 0LL;
  if (v39) {
    (*((void (**)(void))this + 23))();
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 112));
  std::unique_ptr<std::map<std::unique_ptr<__CFString const,void (*)(__CFString const*)>,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>,CFStringRefComp,std::allocator<std::pair<std::unique_ptr<__CFString const,void (*)(__CFString const*)> const,std::unique_ptr<std::vector<std::weak_ptr<PropertyObserver>>>>>>>::reset[abi:nn180100]( (void *****)this + 13,  0LL);
  *((void *)this + 4) = off_189C12668;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 40));
  *((void *)this + 1) = off_189C19AE8;
}

void sub_182AB0174(_Unwind_Exception *a1)
{
  uint64_t v3 = *(const void **)(v1 + 680);
  *(void *)(v1 + 680) = 0LL;
  if (v3) {
    CFRelease(v3);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 656);
  CFStreamError v4 = *(const void **)(v1 + 640);
  *(void *)(v1 + 640) = 0LL;
  if (v4) {
    CFRelease(v4);
  }
  NotificationStation::~NotificationStation((NotificationStation *)(v1 + 104));
  *(void *)(v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = off_189C12668;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 40));
  *(void *)(v1 + 8) = off_189C19AE8;
  _Unwind_Resume(a1);
}

void SocketStream::cleanupConnection_NoLock(SocketStream *this)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (*((void *)this + 69))
  {
    *((_DWORD *)this + 62) |= 0x1000u;
    tcp_connection_cancel();
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    double v2 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *((void *)this + 69);
      int v4 = 134217984;
      uint64_t v5 = v3;
      _os_log_impl(&dword_18298D000, v2, OS_LOG_TYPE_DEFAULT, "TCP Conn %p canceled", (uint8_t *)&v4, 0xCu);
    }

    *((void *)this + 69) = 0LL;
  }

void SocketStream::unschedule_NoLock( SocketStream *this, CFTypeRef cf, __CFRunLoop *a3, const __CFString *a4)
{
  CFTypeID v7 = CFGetTypeID(cf);
  CFTypeID TypeID = CFReadStreamGetTypeID();
  uint64_t v9 = 312LL;
  if (v7 == TypeID) {
    uint64_t v10 = 304LL;
  }
  else {
    uint64_t v10 = 312LL;
  }
  if (v7 != TypeID) {
    uint64_t v9 = 304LL;
  }
  int v11 = *(const __CFArray **)((char *)this + v9);
  unint64_t v12 = *(const __CFArray **)((char *)this + v10);
  if (_SchedulesRemoveRunLoopAndMode(*((const __CFArray **)this + 40), a3, a4))
  {
    _SchedulesAddRunLoopAndMode(v11, a3, a4);
  }

  else if (_SchedulesRemoveRunLoopAndMode(v12, a3, a4))
  {
    uint64_t v13 = *((void *)this + 41);
    v14[0] = a3;
    v14[1] = a4;
    v15.CFIndex length = *(void *)(v13 + 24);
    v15.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v13 + 16),  v15,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction,  v14);
  }

void SocketStream::schedule_NoLock(SocketStream *this, CFTypeRef cf, __CFRunLoop *a3, const __CFString *a4)
{
  CFTypeID v8 = CFGetTypeID(cf);
  CFTypeID TypeID = CFReadStreamGetTypeID();
  if (v8 == TypeID) {
    CFTypeRef v10 = (CFTypeRef)*((void *)this + 34);
  }
  else {
    CFTypeRef v10 = (CFTypeRef)*((void *)this + 35);
  }
  if (v10 != cf && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v21[0]) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "What stream is this??",  (uint8_t *)v21,  2u);
  }

  uint64_t v11 = 312LL;
  if (v8 == TypeID) {
    uint64_t v12 = 304LL;
  }
  else {
    uint64_t v12 = 312LL;
  }
  if (v8 != TypeID) {
    uint64_t v11 = 304LL;
  }
  uint64_t v13 = *(const __CFArray **)((char *)this + v11);
  unint64_t v14 = *(const __CFArray **)((char *)this + v12);
  if (_SchedulesFind(*((const __CFArray **)this + 40), a3, a4) == -1 && _SchedulesFind(v14, a3, a4) == -1)
  {
    uint64_t v15 = _SchedulesFind(v13, a3, a4);
    CFTypeID v16 = v14;
    if (v15 != -1)
    {
      _SchedulesRemoveRunLoopAndMode(v13, a3, a4);
      CFTypeID v16 = (const __CFArray *)*((void *)this + 40);
    }

    _SchedulesAddRunLoopAndMode(v16, a3, a4);
    uint64_t v17 = *((void *)this + 41);
    v21[0] = a3;
    v21[1] = a4;
    v22.CFIndex length = *(void *)(v17 + 24);
    v22.CFIndex location = 0LL;
    CFArrayApplyFunction( *(CFArrayRef *)(v17 + 16),  v22,  (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction,  v21);
    int v18 = *((_DWORD *)this + 62);
    if (v8 == TypeID)
    {
      if ((v18 & 4) != 0)
      {
        CFIndex Count = CFArrayGetCount(v14);
        if (CFArrayGetCount(*((CFArrayRef *)this + 40)) + Count == 4) {
          CFReadStreamSignalEvent();
        }
      }
    }

    else if ((v18 & 8) != 0)
    {
      CFIndex v20 = CFArrayGetCount(v14);
      if (CFArrayGetCount(*((CFArrayRef *)this + 40)) + v20 == 4) {
        CFWriteStreamSignalEvent();
      }
    }
  }

uint64_t SocketStream::streamCan(uint64_t a1, const void *a2, int a3, const __CFString *a4, void *a5)
{
  *a5 = 0LL;
  a5[1] = 0LL;
  CFTypeRef v10 = (pthread_mutex_t *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
  CFTypeID TypeID = CFReadStreamGetTypeID();
  CFTypeID v12 = CFGetTypeID(a2);
  unsigned int v13 = *(unsigned __int8 *)(a1 + 248);
  uint64_t v14 = (v13 >> (a3 + 1)) & 1;
  int v15 = *(_DWORD *)(a1 + 264);
  if (v15) {
    BOOL v16 = 0;
  }
  else {
    BOOL v16 = (_DWORD)v14 == 0;
  }
  if (v16)
  {
    uint64_t v17 = 312LL;
    if (TypeID == v12) {
      uint64_t v17 = 304LL;
    }
    int v18 = *(const __CFArray **)(a1 + v17);
    if (((v13 >> a3) & 0x10) != 0
      || (CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 320)), CFArrayGetCount(v18) + Count < 3))
    {
      CFRunLoopRef Current = CFRunLoopGetCurrent();
      _SchedulesAddRunLoopAndMode(v18, Current, a4);
      CFRange v22 = *(__CFSocket **)(a1 + 288);
      if (v22
        && CFSocketIsValid(v22)
        && (uint64_t v23 = *(void *)(a1 + 328), *(void *)(v23 + 24) == 1LL)
        && (uint64_t v24 = *(const void **)(a1 + 288), v24 == CFArrayGetValueAtIndex(*(CFArrayRef *)(v23 + 16), 0LL)))
      {
        CFAllocatorRef v37 = CFGetAllocator((CFTypeRef)(a1 - 16));
        CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v37, *(CFSocketRef *)(a1 + 288), 0LL);
        if (RunLoopSource)
        {
          uint64_t v39 = RunLoopSource;
          CFRange v40 = CFRunLoopGetCurrent();
          CFRunLoopAddSource(v40, v39, a4);
          CFRelease(v39);
        }
      }

      else
      {
        uint64_t v25 = *(void *)(a1 + 328);
        CFRunLoopRef v45 = CFRunLoopGetCurrent();
        CFTypeRef v46 = a4;
        v47.CFIndex length = *(void *)(v25 + 24);
        v47.CFIndex location = 0LL;
        CFArrayApplyFunction( *(CFArrayRef *)(v25 + 16),  v47,  (CFArrayApplierFunction)Schedulables::_SchedulablesScheduleApplierFunction,  &v45);
      }

      pthread_mutex_unlock(v10);
      CFRunLoopRunInMode(a4, 0.0, 0);
      pthread_mutex_lock(v10);
      unint64_t v26 = *(__CFSocket **)(a1 + 288);
      if (v26
        && CFSocketIsValid(v26)
        && (uint64_t v27 = *(void *)(a1 + 328), *(void *)(v27 + 24) == 1LL)
        && (uint64_t v28 = *(const void **)(a1 + 288), v28 == CFArrayGetValueAtIndex(*(CFArrayRef *)(v27 + 16), 0LL)))
      {
        CFRange v41 = CFGetAllocator((CFTypeRef)(a1 - 16));
        CFRunLoopSourceRef v42 = CFSocketCreateRunLoopSource(v41, *(CFSocketRef *)(a1 + 288), 0LL);
        if (v42)
        {
          CFRange v43 = v42;
          uint64_t v44 = CFRunLoopGetCurrent();
          CFRunLoopRemoveSource(v44, v43, a4);
          CFRelease(v43);
        }
      }

      else
      {
        uint64_t v29 = *(void *)(a1 + 328);
        CFRunLoopRef v45 = CFRunLoopGetCurrent();
        CFTypeRef v46 = a4;
        v48.CFIndex length = *(void *)(v29 + 24);
        v48.CFIndex location = 0LL;
        CFArrayApplyFunction( *(CFArrayRef *)(v29 + 16),  v48,  (CFArrayApplierFunction)Schedulables::_SchedulablesUnscheduleApplierFunction,  &v45);
      }

      CFRunLoopRef v30 = CFRunLoopGetCurrent();
      _SchedulesRemoveRunLoopAndMode(v18, v30, a4);
      uint64_t v14 = (*(unsigned __int8 *)(a1 + 248) >> (a3 + 1)) & 1;
    }

    else
    {
      if (a3)
      {
        if (a3 == 2)
        {
          int v20 = 64;
        }

        else
        {
          if (a3 != 1) {
            goto LABEL_53;
          }
          int v20 = 32;
        }
      }

      else
      {
        int v20 = 16;
      }

      uint64_t v14 = 0LL;
      *(_DWORD *)(a1 + 248) |= v20;
    }

    int v15 = *(_DWORD *)(a1 + 264);
  }

  if (!v15) {
    goto LABEL_45;
  }
  *(_OWORD *)a5 = *(_OWORD *)(a1 + 256);
  if (a3)
  {
    if (a3 != 2)
    {
      if (a3 == 1)
      {
        int v31 = 4;
        goto LABEL_33;
      }

void ___ZN12SocketStream12closeStreamsEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  double v2 = *(__CFReadStream **)(v1 + 200);
  if (v2)
  {
    if (CFReadStreamGetStatus(v2) <= kCFStreamStatusOpening) {
      CFReadStreamOpen(*(CFReadStreamRef *)(v1 + 200));
    }
    CFReadStreamClose(*(CFReadStreamRef *)(v1 + 200));
  }

  uint64_t v3 = *(__CFWriteStream **)(v1 + 208);
  if (v3)
  {
    if (CFWriteStreamGetStatus(v3) <= kCFStreamStatusOpening) {
      CFWriteStreamOpen(*(CFWriteStreamRef *)(v1 + 208));
    }
    CFWriteStreamClose(*(CFWriteStreamRef *)(v1 + 208));
  }

  int v4 = *(const void **)(v1 + 200);
  *(void *)(v1 + 200) = 0LL;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(v1 + 208);
  *(void *)(v1 + 208) = 0LL;
  if (v5) {
    CFRelease(v5);
  }
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN12SocketStream13setPropertiesEPK14__CFDictionary_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 200LL))(*(void *)(a1 + 32));
}

void ___ZN12SocketStream15beginConnectionEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(CFWriteStreamRef **)(a1 + 32);
  (*((void (**)(CFWriteStreamRef *, _BYTE *, _BYTE *))*v1 + 8))(v1, (_BYTE *)v1 + 200, (_BYTE *)v1 + 208);
  *((_BYTE *)v1 + 193) = 1;
  clientContext.version = 0LL;
  clientContext.uint64_t info = v1;
  clientContext.retain = (void *(__cdecl *)(void *))CFObject::_cfobj_instance_retain;
  clientContext.release = (void (__cdecl *)(void *))CFObject::_cfobj_instance_release;
  clientContext.copyDescription = (CFStringRef (__cdecl *)(void *))CFObject::_cfobj_instance_copyDescription;
  CFWriteStreamSetClient( v1[26],  0xCuLL,  (CFWriteStreamClientCallBack)SocketStream::_beginConnection_streamEvent,  &clientContext);
  MEMORY[0x186E135C0](v1[26], v1[70]);
  CFWriteStreamOpen(v1[26]);
  CFRelease(v1 - 2);
}

void SocketStream::_beginConnection_streamEvent( SocketStream *this, __CFWriteStream *a2, uint64_t a3, void *a4)
{
  uint64_t v5 = (const void *)(a3 - 16);
  CFRetain((CFTypeRef)(a3 - 16));
  uint64_t v6 = *(void *)(a3 + 208);
  if (v6)
  {
    MEMORY[0x186E135C0](v6, 0LL);
    CFWriteStreamSetClient(*(CFWriteStreamRef *)(a3 + 208), 0LL, 0LL, 0LL);
  }

  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 184LL))(a3);
  if (v7)
  {
    uint64_t v8 = v7;
    (*(void (**)(uint64_t, void, void))(*(void *)v7 + 64LL))( v7,  *(void *)(a3 + 200),  *(void *)(a3 + 208));
    (*(void (**)(uint64_t))(*(void *)v8 + 24LL))(v8);
  }

  uint64_t v9 = *(const void **)(a3 + 200);
  *(void *)(a3 + 200) = 0LL;
  if (v9) {
    CFRelease(v9);
  }
  CFTypeRef v10 = *(const void **)(a3 + 208);
  *(void *)(a3 + 208) = 0LL;
  if (v10) {
    CFRelease(v10);
  }
  CFRelease(v5);
}

uint64_t SocketStream::sendToSocket( SocketStream *this, const unsigned __int8 *a2, size_t a3, CFStreamError *a4)
{
  uint64_t v5 = (__CFSocket *)*((void *)this + 36);
  a4->CFIndex domain = 0LL;
  *(void *)&a4->error = 0LL;
  if (!v5 || !CFSocketIsValid(v5))
  {
    SInt32 v15 = 22;
LABEL_12:
    a4->CFIndex domain = 1LL;
    a4->error = v15;
    return -1LL;
  }

  CFSocketNativeHandle Native = CFSocketGetNative(v5);
  ssize_t v10 = write(Native, a2, a3);
  if (v10 < 0)
  {
    SInt32 v15 = *__error();
    goto LABEL_12;
  }

  uint64_t v12 = v10;
  unsigned int v13 = (IOLogger *)*((void *)this + 27);
  BOOL v14 = v12 != 0;
  if (v13 && v12)
  {
    IOLogger::logBytes(v13, "RAW-SEND", 0x3Eu, a2, v12);
    BOOL v14 = 1;
  }

  if (*((_BYTE *)this + 636) && v14)
  {
    *((void *)this + 77) += v12;
    entr_act_modify_delayInitStub(v11);
  }

  return v12;
}

void SocketStream::touchWatchdogTimer_Locked(SocketStream *this, int a2)
{
  double v2 = *((double *)this + 45);
  if (v2 > 0.0)
  {
    if (!*((void *)this + 48))
    {
      *((void *)this + 48) = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *((dispatch_queue_t *)this + 70));
      CFRetain((char *)this - 16);
      uint64_t v5 = MEMORY[0x1895F87A8];
      uint64_t v6 = (dispatch_source_s *)*((void *)this + 48);
      handler[0] = MEMORY[0x1895F87A8];
      handler[1] = 3221225472LL;
      handler[2] = ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke;
      handler[3] = &__block_descriptor_40_e5_v8__0l;
      handler[4] = this;
      dispatch_source_set_event_handler(v6, handler);
      uint64_t v7 = (dispatch_source_s *)*((void *)this + 48);
      v11[0] = v5;
      v11[1] = 3221225472LL;
      v11[2] = ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke_2;
      v11[3] = &__block_descriptor_40_e5_v8__0l;
      v11[4] = this;
      dispatch_source_set_cancel_handler(v7, v11);
      dispatch_resume(*((dispatch_object_t *)this + 48));
      double v2 = *((double *)this + 45);
    }

    double v8 = 10.0;
    if (v2 < 10.0) {
      double v8 = v2;
    }
    if (a2) {
      double v2 = v8;
    }
    uint64_t v9 = (dispatch_source_s *)*((void *)this + 48);
    dispatch_time_t v10 = dispatch_time(0LL, (uint64_t)(v2 * 1000000000.0));
    dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
  }

BOOL _CFSocketCan(__CFSocket *a1, int a2)
{
  CFSocketNativeHandle Native = CFSocketGetNative(a1);
  int v4 = Native;
  if (a2)
  {
    v10.tv_sec = 0LL;
    *(void *)&v10.tv_usec = 0LL;
    memset(v11, 0, sizeof(v11));
    if (Native < 1024)
    {
      uint64_t v7 = (fd_set *)v11;
    }

    else
    {
      unsigned int v5 = (Native + 1) >> 5;
      if (((Native + 1) & 0x1F) != 0) {
        ++v5;
      }
      size_t v6 = 4 * v5;
      uint64_t v7 = (fd_set *)malloc(v6);
      bzero(v7, v6);
    }

    if (__darwin_check_fd_set_overflow(v4, v7, 0)) {
      *(__int32_t *)((char *)v7->fds_bits + (((unint64_t)v4 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v4;
    }
    int v9 = select(v4 + 1, 0LL, v7, 0LL, &v10);
    if (v7 != (fd_set *)v11) {
      free(v7);
    }
    return v9 > 0;
  }

  else
  {
    LODWORD(v10.tv_sec) = 4;
    getsockopt(Native, 0xFFFF, 4128, v11, (socklen_t *)&v10);
    return LODWORD(v11[0]) != 0;
  }

uint64_t ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(SocketStream **)(a1 + 32);
  CFLog();
  v3.CFIndex domain = 4LL;
  *(void *)&v3.error = 4294965192LL;
  return SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(v1, v3);
}

void ___ZN12SocketStream25touchWatchdogTimer_LockedEb_block_invoke_2(uint64_t a1)
{
}

uint64_t SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(SocketStream *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  uint64_t v22 = *MEMORY[0x1895F89C0];
  unsigned int v5 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  __int16 v6 = *((_WORD *)this + 126);
  *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
  *((_WORD *)this + 126) = v6 | 2;
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v7 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = *((void *)this + 69);
    int v16 = 134218496;
    uint64_t v17 = v15;
    __int16 v18 = 2048;
    CFIndex v19 = domain;
    __int16 v20 = 1024;
    int v21 = v2;
    _os_log_error_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_ERROR,  "TCP Conn %p timed out : error %ld %d",  (uint8_t *)&v16,  0x1Cu);
  }

  SocketStream::cleanupConnection_NoLock(this);
  if (*((_BYTE *)this + 544))
  {
    *((_BYTE *)this + 544) = 0;
    CFRelease((char *)this - 16);
  }

  double v8 = (dispatch_source_s *)*((void *)this + 48);
  if (v8)
  {
    dispatch_source_cancel(v8);
    dispatch_release(*((dispatch_object_t *)this + 48));
    *((void *)this + 48) = 0LL;
  }

  int v9 = (dispatch_source_s *)*((void *)this + 49);
  if (v9)
  {
    dispatch_source_cancel(v9);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((void *)this + 49) = 0LL;
  }

  *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = domain;
  *((void *)this + 33) = v2;
  id WeakRetained = objc_loadWeakRetained((id *)this + 34);
  double v11 = WeakRetained;
  if (*((void *)this + 29) && *((uint64_t *)this + 28) >= 1 || !WeakRetained)
  {
    if (!WeakRetained) {
      goto LABEL_18;
    }
  }

  else if ((*((_DWORD *)this + 62) & 0x200) != 0)
  {
    _CFReadStreamSignalEventDelayed();
  }

  CFRelease(v11);
LABEL_18:
  id v12 = objc_loadWeakRetained((id *)this + 35);
  if (v12)
  {
    unsigned int v13 = v12;
    if ((*((_DWORD *)this + 62) & 0x400) != 0) {
      _CFWriteStreamSignalEventDelayed();
    }
    CFRelease(v13);
  }

  return pthread_mutex_unlock(v5);
}

CFStreamError *SocketStream::flushTransmissionBuffer_NoLock(CFStreamError *this)
{
  if ((this[15].error & 8) != 0)
  {
    uint64_t v1 = this;
    CFIndex domain = this[33].domain;
    if (domain)
    {
      int64_t v3 = *(void *)(domain + 24);
      if (v3 >= 1)
      {
        int v4 = *(unsigned __int8 **)(domain + 32);
        this = (CFStreamError *)SocketStream::sendToSocket((SocketStream *)this, v4, v3, this + 16);
        unsigned int v5 = this;
        CFIndex v6 = v1[33].domain;
        uint64_t v7 = *(CFStreamError **)(v6 + 24);
        if (v7 == this)
        {
          double v8 = this;
        }

        else
        {
          this = (CFStreamError *)memmove(v4, (char *)this + (void)v4, (char *)v7 - (char *)this);
          CFIndex v6 = v1[33].domain;
          double v8 = *(CFStreamError **)(v6 + 24);
        }

        *(void *)(v6 + 24) = (char *)v8 - (char *)v5;
      }
    }
  }

  return this;
}

void CFBufferConstantSize<36000l>::~CFBufferConstantSize(CFAllocatorRef *ptr)
{
}

uint64_t SocketStream::_copyPeerTrustWithPinning_NoLock( CFDictionaryRef *this, SSLContextRef context, SecTrustRef *trust)
{
  uint64_t result = SSLCopyPeerTrust(context, trust);
  if (trust && !(_DWORD)result)
  {
    if (*trust)
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(this[42], &unk_18C5ACC28);
      if (result) {
        return SecTrustSetPinningPolicyName();
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void *logPeerCertAvailable(SSLContext *a1)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_206, 1);
  if (!result) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  uint64_t result = (void *)(*(uint64_t (**)(void *, const char *, void))(*(void *)result + 16LL))( result,  "Peer certificate",  0LL);
  if (!(_DWORD)result) {
    return result;
  }
  SecTrustRef trust = 0LL;
  if (SSLCopyPeerTrust(a1, &trust))
  {
    (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v3 + 72LL))( v3,  "Error",  @"can't obtain peer certs (%d)");
    goto LABEL_37;
  }

  int v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (!trust || !SecTrustGetCertificateCount(trust))
  {
    uint64_t v27 = off_189C1A178;
    CFStringRef v19 = CFStringCreateWithCString(v4, "Error", 0x8000100u);
    uint64_t v29 = 0LL;
    v30[0] = 0LL;
    CFIndex v28 = (CFIndex)v19;
    uint64_t v32 = off_189C1A178;
    CFStringRef v20 = CFStringCreateWithCString(v4, "NULL or empty trust returned", 0x8000100u);
    uint64_t v34 = 0LL;
    uint64_t v35 = 0LL;
    CFStringRef v33 = v20;
    (*(void (**)(uint64_t, CFIndex, CFStringRef))(*(void *)v3 + 64LL))(v3, v28, v20);
    AutoString::~AutoString((AutoString *)&v32);
    AutoString::~AutoString((AutoString *)&v27);
    goto LABEL_37;
  }

  unsigned int v5 = SecTrustCopyCertificateChain(trust);
  CFIndex v6 = v5;
  if (v5)
  {
    if (CFArrayGetCount(v5) < 1
      || (ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v6, 0LL), (double v8 = ValueAtIndex) == 0LL))
    {
LABEL_36:
      CFRelease(v6);
      goto LABEL_37;
    }

    CFStringRef v9 = SecCertificateCopySubjectSummary(ValueAtIndex);
    uint64_t v27 = off_189C1A178;
    CFStringRef v10 = CFStringCreateWithCString(v4, "Subject Sum", 0x8000100u);
    uint64_t v29 = 0LL;
    v30[0] = 0LL;
    CFIndex v28 = (CFIndex)v10;
    (*(void (**)(uint64_t))(*(void *)v3 + 64LL))(v3);
    AutoString::~AutoString((AutoString *)&v27);
    if (v9) {
      CFRelease(v9);
    }
    CFStringRef commonName = 0LL;
    CFArrayRef emailAddresses = 0LL;
    if (SecCertificateCopyEmailAddresses(v8, &emailAddresses))
    {
      CFArrayRef v11 = emailAddresses;
      CFArrayRef emailAddresses = 0LL;
      if (v11) {
        CFRelease(v11);
      }
    }

    OSStatus v12 = SecCertificateCopyCommonName(v8, &commonName);
    CFStringRef v13 = commonName;
    if (v12)
    {
      CFStringRef commonName = 0LL;
      if (v13) {
        CFRelease(v13);
      }
    }

    uint64_t v27 = off_189C1A178;
    CFStringRef v14 = CFStringCreateWithCString(v4, "Common Name", 0x8000100u);
    uint64_t v29 = 0LL;
    v30[0] = 0LL;
    CFIndex v28 = (CFIndex)v14;
    (*(void (**)(uint64_t))(*(void *)v3 + 64LL))(v3);
    AutoString::~AutoString((AutoString *)&v27);
    uint64_t v15 = emailAddresses;
    if (!emailAddresses)
    {
LABEL_30:
      if (commonName) {
        CFRelease(commonName);
      }
      if (emailAddresses) {
        CFRelease(emailAddresses);
      }
      uint64_t v22 = (const void *)SecCertificateCopyIssuerSummary();
      uint64_t v27 = off_189C1A178;
      CFStringRef v23 = CFStringCreateWithCString(v4, "Summary", 0x8000100u);
      uint64_t v29 = 0LL;
      v30[0] = 0LL;
      CFIndex v28 = (CFIndex)v23;
      (*(void (**)(uint64_t))(*(void *)v3 + 64LL))(v3);
      AutoString::~AutoString((AutoString *)&v27);
      if (v22) {
        CFRelease(v22);
      }
      goto LABEL_36;
    }

    uint64_t v27 = (void (**)(AutoString *__hidden))CFRetain(emailAddresses);
    unint64_t Count = CFArrayGetCount(v15);
    CFIndex v17 = Count;
    CFIndex v28 = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      uint64_t v29 = 0LL;
    }

    else
    {
      if (Count > 0x1E)
      {
        __int16 v18 = (const void **)malloc(8 * Count);
        uint64_t v29 = v18;
        if (!v18)
        {
          CFIndex v31 = 0LL;
          goto LABEL_27;
        }
      }

      else
      {
        __int16 v18 = (const void **)v30;
        uint64_t v29 = (const void **)v30;
      }

      v37.CFIndex location = 0LL;
      v37.CFIndex length = v17;
      CFArrayGetValues(v15, v37, v18);
      CFIndex v17 = v28;
    }

    CFIndex v31 = 0LL;
    if (v17 < 1)
    {
LABEL_29:
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v27);
      goto LABEL_30;
    }

void sub_182AB15E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 560))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    int v4 = *(dispatch_queue_s **)(v2 + 560);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    v5[2] = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_2;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v2;
    int v6 = a2;
    dispatch_async(v4, v5);
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void SocketStream::unscheduleFromSSL(SocketStream *this)
{
  uint64_t v2 = 0LL;
  uint64_t v5 = *MEMORY[0x1895F89C0];
  __int128 v3 = *((_OWORD *)this + 19);
  uint64_t v4 = *((void *)this + 40);
  do
  {
    _CFTypeUnscheduleFromMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v3 + v2));
    v2 += 8LL;
  }

  while (v2 != 24);
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_3(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 560))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2) {
      CFRetain(a2);
    }
    uint64_t v4 = *(dispatch_queue_s **)(v2 + 560);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    v5[2] = ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_4;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    void v5[5] = a2;
    dispatch_async(v4, v5);
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t translateSSLContextError(SSLContext *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if ((_DWORD)a2 == -9809)
  {
    if (!SSLGetClientCertificateState(a1, &v5) && v5 == kSSLClientCertSent) {
      return 4294957471LL;
    }
  }

  else if ((_DWORD)a2 == -9824 {
         && !SSLGetClientCertificateState(a1, &clientState)
  }
         && clientState == kSSLClientCertRequested)
  {
    return 4294957467LL;
  }

  return v2;
}

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  __int128 v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  CFRelease((char *)v2 - 16);
}

void SocketStream::securitySetPeerCert(SocketStream *this, const __CFArray *a2)
{
  uint64_t v7 = 0LL;
  memset(v6, 0, sizeof(v6));
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  SocketStream::securitySetPeerCert_NoLock(this, a2, (SocketStreamSignalHolder *)v6);
  pthread_mutex_unlock(v4);
  SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v6, v5);
  SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v6);
}

void sub_182AB1924( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void SocketStream::securitySetPeerCert_NoLock( SocketStream *this, const __CFArray *a2, SocketStreamSignalHolder *a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    SSLClientCertificateState v5 = (SSLContext *)*((void *)this + 37);
    if (v5) {
      SSLSetCertificate(v5, a2);
    }
  }

  uint64_t v6 = *((unsigned int *)this + 62);
  if ((v6 & 0x20000000) != 0)
  {
    uint64_t v7 = 0LL;
    unint64_t v8 = v6 & 0xFFFFFFFFDFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v6 & 0xDFFFFFFF;
    *((_WORD *)this + 126) = WORD2(v8);
    __int128 v9 = *((_OWORD *)this + 19);
    uint64_t v10 = *((void *)this + 40);
    do
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v9 + v7));
      v7 += 8LL;
    }

    while (v7 != 24);
    if (!*((_DWORD *)this + 103))
    {
      SocketStream::socketCallbackReadLocked(this, a3);
      SocketStream::prepareSignalFromSocketCallbackLocked(this, a3);
    }
  }

void SocketStream::dispatchSignalFromSocketCallbackUnlocked( CFRunLoopSourceRef *this, SocketStreamSignalHolder *a2)
{
  if (this[1])
  {
    if (this[5])
    {
      CFRunLoopSourceSignal(this[5]);
      CFRunLoopWakeUp(this[7]);
    }

    else
    {
      CFReadStreamSignalEvent();
    }
  }

  if (this[2])
  {
    if (this[6])
    {
      CFRunLoopSourceSignal(this[6]);
      CFRunLoopWakeUp(this[8]);
    }

    else
    {
      CFWriteStreamSignalEvent();
    }
  }

void SocketStreamSignalHolder::~SocketStreamSignalHolder(SocketStreamSignalHolder *this)
{
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  __int128 v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)*((void *)this + 5);
  if (v4) {
    CFRelease(v4);
  }
  SSLClientCertificateState v5 = (const void *)*((void *)this + 6);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 7);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)*((void *)this + 8);
  if (v7) {
    CFRelease(v7);
  }
}

void SocketStream::socketCallbackReadLocked(SocketStream *this, SocketStreamSignalHolder *a2)
{
  unsigned int v3 = *((_DWORD *)this + 103);
  if (v3)
  {
    for (uint64_t i = 0LL; i != 8; ++i)
    {
      if (((v3 >> i) & 1) != 0) {
        break;
      }
    }

    SocketStream::performHandshake((uint64_t)this);
    return;
  }

  uint64_t v6 = *((unsigned int *)this + 62);
  unint64_t v7 = v6 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v6 & 0x800000) != 0)
  {
    if ((v6 & 0x2000) != 0)
    {
      SocketStream::securityBufferedRead_NoLock(this);
      goto LABEL_23;
    }

    Mutable = (__CFData *)*((void *)this + 29);
    if (Mutable)
    {
      if (*((uint64_t *)this + 28) >= 0x8000)
      {
        int v9 = v7 | 0x2000000;
LABEL_21:
        *((_WORD *)this + 126) = WORD2(v7);
        *((_DWORD *)this + 62) = v9;
        goto LABEL_23;
      }
    }

    else
    {
      uint64_t v10 = CFGetAllocator((char *)this - 16);
      Mutable = CFDataCreateMutable(v10, 0x8000LL);
      *((void *)this + 28) = 0LL;
      *((void *)this + 29) = Mutable;
      if (!Mutable)
      {
        *((void *)this + 29) = 0LL;
        *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
        *((_DWORD *)this + 66) = 12;
        goto LABEL_23;
      }
    }

    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    uint64_t v12 = SocketStream::recvBytes( this,  &MutableBytePtr[*((void *)this + 28)],  0x8000LL - *((void *)this + 28),  (CFStreamError *)this + 16);
    unint64_t v7 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    unint64_t v13 = *((_DWORD *)this + 62) & 0xFDFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) &= ~0x2000000u;
    *((_WORD *)this + 126) = WORD2(v13);
    if (v12 < 1)
    {
      if (v12) {
        goto LABEL_23;
      }
      int v9 = v7 & 0xFDEFFFDB | 0x100004;
      goto LABEL_21;
    }

    *((void *)this + 28) += v12;
    CFStringRef v14 = (__CFSocket *)*((void *)this + 36);
    if (v14 && CFSocketIsValid(v14)) {
      CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
    }
    unint64_t v15 = *((_DWORD *)this + 62) & 0xFFFFFFDF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = *((_DWORD *)this + 62) & 0xFFFFFFDB | 4;
    *((_WORD *)this + 126) = WORD2(v15);
LABEL_23:
    if ((*((_DWORD *)this + 62) & 4) == 0) {
      return;
    }
    goto LABEL_24;
  }

  *((_WORD *)this + 126) = (v6 & 0xFFFFFFFFFFFFFFDFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) >> 32;
  *((_DWORD *)this + 62) = v6 & 0xFFFFFFDB | 4;
LABEL_24:
  *(void *)a2 = 2LL;
  id WeakRetained = objc_loadWeakRetained((id *)this + 34);
  CFIndex v17 = (const void *)*((void *)a2 + 1);
  if (v17) {
    CFRelease(v17);
  }
  *((void *)a2 + 1) = WeakRetained;
}

void SocketStream::prepareSignalFromSocketCallbackLocked(SocketStream *this, SocketStreamSignalHolder *a2)
{
  if (*((_DWORD *)this + 66))
  {
    *(_OWORD *)((char *)a2 + 24) = *((_OWORD *)this + 16);
    *(void *)a2 = 8LL;
    id WeakRetained = objc_loadWeakRetained((id *)this + 34);
    SSLClientCertificateState v5 = (const void *)*((void *)a2 + 1);
    if (v5) {
      CFRelease(v5);
    }
    *((void *)a2 + 1) = WeakRetained;
    id v6 = objc_loadWeakRetained((id *)this + 35);
    unint64_t v7 = (const void *)*((void *)a2 + 2);
    if (v7) {
      CFRelease(v7);
    }
    *((void *)a2 + 2) = v6;
  }

  unint64_t v8 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v8 & 0x1000000200LL) != 0x200)
  {
    int v9 = (const void *)*((void *)a2 + 1);
    if (v9) {
      CFRelease(v9);
    }
    *((void *)a2 + 1) = 0LL;
    unint64_t v8 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  }

  if ((v8 & 0x2000000400LL) != 0x400)
  {
    uint64_t v10 = (const void *)*((void *)a2 + 2);
    if (v10) {
      CFRelease(v10);
    }
    *((void *)a2 + 2) = 0LL;
  }

  if (*(void *)a2)
  {
    uint64_t v11 = (const void *)*((void *)this + 71);
    if (v11)
    {
      uint64_t v12 = (__CFRunLoopSource *)CFRetain(v11);
      *((void *)a2 + 5) = v12;
      if (v12)
      {
        memset(&cf, 0, sizeof(cf));
        CFRunLoopSourceGetContext(v12, &cf);
        uint64_t info = cf.info;
        if (cf.info) {
          uint64_t info = (void *)CFRetain(cf.info);
        }
        *((void *)a2 + 7) = info;
      }
    }

    else
    {
      *((void *)a2 + 5) = 0LL;
    }

    int v16 = (const void *)*((void *)this + 72);
    if (v16)
    {
      CFIndex v17 = (__CFRunLoopSource *)CFRetain(v16);
      *((void *)a2 + 6) = v17;
      if (v17)
      {
        memset(&cf, 0, sizeof(cf));
        CFRunLoopSourceGetContext(v17, &cf);
        __int16 v18 = cf.info;
        if (cf.info) {
          __int16 v18 = (void *)CFRetain(cf.info);
        }
        *((void *)a2 + 8) = v18;
      }
    }

    else
    {
      *((void *)a2 + 6) = 0LL;
    }

    if (*((void *)a2 + 1) && *(void *)a2 == 8LL && *((void *)this + 29) && *((uint64_t *)this + 28) >= 1)
    {
      *(void *)a2 = 2LL;
      *((void *)a2 + 3) = 0LL;
      *((void *)a2 + 4) = 0LL;
    }
  }

  else
  {
    CFStringRef v14 = (const void *)*((void *)a2 + 1);
    if (v14) {
      CFRelease(v14);
    }
    *((void *)a2 + 1) = 0LL;
    unint64_t v15 = (const void *)*((void *)a2 + 2);
    if (v15) {
      CFRelease(v15);
    }
    *((void *)a2 + 2) = 0LL;
  }

void SocketStream::performHandshake(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1895F8858](a1);
  uint64_t v221 = *MEMORY[0x1895F89C0];
  uint64_t v3 = v1;
  switch(v2)
  {
    case 1:
      int Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(v1 + 336), &unk_18C5ACA68);
      SSLClientCertificateState v5 = (__CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_18C5ACA30);
      if (v5)
      {
        id v6 = v5;
        MutableBytePtr = CFDataGetMutableBytePtr(v5);
        CFIndex Length = CFDataGetLength(v6);
        if (Length == 2) {
          goto LABEL_4;
        }
        CFIndex v73 = Length;
        *(void *)&buf[8] = 0LL;
        *(void *)CFStreamClientContext buf = 0LL;
        uint64_t v74 = SocketStream::recvBytes((SocketStream *)v3, &MutableBytePtr[Length], 2 - Length, (CFStreamError *)buf);
        if (v74)
        {
          if (v74 >= 1)
          {
            size_t v75 = v74 + v73;
            memcpy(__dst, MutableBytePtr, v75);
            CFDataSetLength(v6, v75);
            memcpy(MutableBytePtr, __dst, v75);
            int v76 = *(__CFSocket **)(v3 + 288);
            if (v76 && CFSocketIsValid(v76)) {
              CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 1uLL);
            }
            if (v75 == 2)
            {
LABEL_4:
              int v9 = MutableBytePtr[1];
              if (v9 == 2)
              {
                int v104 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_18C5ADEF8);
                unsigned int v105 = CFDictionaryGetValue(v104, (const void *)*MEMORY[0x1896051F8]);
                unint64_t v106 = CFDictionaryGetValue(v104, (const void *)*MEMORY[0x1896051E0]);
                CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_18C5ACA30);
                if (v105) {
                  BOOL v107 = v106 == 0LL;
                }
                else {
                  BOOL v107 = 1;
                }
                if (!v107)
                {
                  SocketStream::addHandshake_NoLock(v3, 2);
LABEL_168:
                  SocketStream::addHandshake_NoLock(v3, 3);
                  uint64_t v100 = v3;
                  char v101 = 1;
LABEL_169:
                  SocketStream::removeHandshake_NoLock(v100, v101);
                  goto LABEL_170;
                }

                int v9 = MutableBytePtr[1];
              }

              else if (!MutableBytePtr[1])
              {
                CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_18C5ACA30);
                goto LABEL_168;
              }

              int v16 = v9 | 0x40000;
              uint64_t v15 = (int)*MEMORY[0x1896051B8];
              goto LABEL_135;
            }

LABEL_170:
            if (*(_DWORD *)(v3 + 264)) {
              SocketStream::removeHandshake_NoLock(v3, 1);
            }
            return;
          }

          int v16 = *(_DWORD *)&buf[8];
          uint64_t v15 = *(void *)buf;
          if (*(_DWORD *)&buf[8] == 35 && *(void *)buf == 1LL) {
            goto LABEL_170;
          }
        }

        else
        {
          int v16 = 57;
          uint64_t v15 = 1LL;
        }

LABEL_284:
          if (v23)
          {
            if (!error) {
              goto LABEL_395;
            }
            if (error == 35 && __dst[0].domain == 1)
            {
              memcpy(buf, v20, v82);
              CFDataSetLength(v19, v82);
              memcpy(v20, buf, v82);
              uint64_t v157 = *(__CFSocket **)(v3 + 288);
              if (v157 && CFSocketIsValid(v157)) {
                CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 1uLL);
              }
              goto LABEL_395;
            }

            CFStreamError v124 = __dst[0];
LABEL_292:
            *(CFStreamError *)(v3 + 256) = v124;
            goto LABEL_395;
          }

LABEL_393:
          *(void *)(v3 + 256) = 1LL;
          int v83 = 57;
          goto LABEL_394;
        }

LABEL_395:
        if (*(_DWORD *)(v3 + 264)) {
          SocketStream::removeHandshake_NoLock(v3, 1);
        }
        return;
      }

      *(void *)&buf[8] = 0LL;
      *(void *)CFStreamClientContext buf = 0LL;
      if (v17) {
        goto LABEL_55;
      }
      LODWORD(__dst[0].domain) = 0;
      id v89 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_18C5ADDA8);
      uint64_t v90 = CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 336), &unk_18C5ADE50);
      Info = (const __CFArray *)CFHostGetInfo((uint64_t)v89, 1, 0LL);
      ValueAtIndex = Info;
      if (Info)
      {
        if (CFArrayGetCount(Info)) {
          ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0LL);
        }
        else {
          ValueAtIndex = 0LL;
        }
      }

      if (v90)
      {
        CFRetain(v90);
      }

      else
      {
        uint64_t v131 = (const __CFArray *)CFHostGetInfo((uint64_t)v89, 0, 0LL);
        if (!v131) {
          goto LABEL_229;
        }
        unint64_t v132 = v131;
        size_t v133 = CFGetAllocator(v89);
        CFIndex Count = CFArrayGetCount(v132);
        if (Count < 1) {
          goto LABEL_229;
        }
        CFIndex v135 = Count;
        uint64_t v136 = 1LL;
        do
        {
          uint64_t v137 = (const __CFData *)CFArrayGetValueAtIndex(v132, v136 - 1);
          if (v137)
          {
            LODWORD(number.domain) = bswap32(*((unsigned __int16 *)CFDataGetBytePtr(v137) + 1)) >> 16;
            uint64_t v90 = CFNumberCreate(v133, kCFNumberSInt32Type, &number);
            if (v90) {
              break;
            }
          }

          else
          {
            uint64_t v90 = 0LL;
          }
        }

        while (v136++ < v135);
        if (!v90) {
          goto LABEL_229;
        }
      }

      if (ValueAtIndex)
      {
        CFRetain(ValueAtIndex);
      }

      else
      {
        v139 = (const __CFArray *)CFHostGetInfo((uint64_t)v89, 0, 0LL);
        __int128 v140 = v139;
        if (!v139) {
          goto LABEL_228;
        }
        if (!CFArrayGetCount(v139)) {
          goto LABEL_228;
        }
        CFGetAllocator(v140);
        int64x2_t v141 = (const __CFData *)CFArrayGetValueAtIndex(v140, 0LL);
        ValueAtIndex = (const __CFArray *)_CFNetworkCFStringCreateWithCFDataAddress(v141);
        if (!ValueAtIndex) {
          goto LABEL_228;
        }
      }

      uint64_t v128 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
      uint64_t v129 = CFDataCreateMutable(v128, 262LL);
      CFIndex v17 = v129;
      if (v129)
      {
        CFDataSetLength(v129, 262LL);
        unint64_t v130 = CFDataGetMutableBytePtr(v17);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_18C5ACA68, v17);
        CFStringGetPascalString((CFStringRef)ValueAtIndex, v130 + 4, 256LL, 0x8000100u);
        *(_DWORD *)unint64_t v130 = 50331909;
        CFNumberGetValue((CFNumberRef)v90, kCFNumberSInt32Type, __dst);
        *(_WORD *)&v130[v130[4] + 5] = bswap32(LOWORD(__dst[0].domain)) >> 16;
        CFDataSetLength(v17, v130[4] + 7LL);
        CFRelease(v17);
        CFRelease(v90);
        CFRelease(ValueAtIndex);
LABEL_55:
        size_t v61 = CFDataGetLength(v17);
        CFRange v62 = CFDataGetBytePtr(v17);
        uint64_t v63 = SocketStream::sendToSocket((SocketStream *)v3, v62, v61, (CFStreamError *)buf);
        uint64_t v64 = v63;
        size_t v65 = v61 - v63;
        if (v65)
        {
          if (v63 >= 1)
          {
            unint64_t v102 = CFDataGetMutableBytePtr(v17);
            memmove(v102, &v102[v64], v65);
            CFDataSetLength(v17, v65);
            unint64_t v103 = *(__CFSocket **)(v3 + 288);
            if (v103 && CFSocketIsValid(v103)) {
              CFSocketEnableCallBacks(*(CFSocketRef *)(v3 + 288), 8uLL);
            }
            goto LABEL_395;
          }

          if (*(_DWORD *)&buf[8] != 35 || *(void *)buf != 1LL)
          {
            CFStreamError v124 = *(CFStreamError *)buf;
            goto LABEL_292;
          }

          goto LABEL_395;
        }

        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_18C5ACA68);
        unint64_t v66 = CFGetAllocator(*(CFTypeRef *)(v3 + 336));
        CFMutableDataRef v67 = CFDataCreateMutable(v66, 262LL);
        if (v67)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 336), &unk_18C5ACA30, v67);
          CFRelease(v67);
          goto LABEL_395;
        }

LABEL_312:
      unint64_t v40 = *(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
LABEL_313:
      int v161 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      while (2)
      {
        if ((v40 & 0x4000000000LL) == 0)
        {
          if ((v40 & 0x20000000000LL) != 0) {
            *(CFAbsoluteTime *)(v3 + 672) = CFAbsoluteTimeGetCurrent();
          }
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          unsigned int v162 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v163 = *(void *)(v3 + 552);
            *(_DWORD *)CFStreamClientContext buf = 134217984;
            *(void *)&uint8_t buf[4] = v163;
            _os_log_impl(&dword_18298D000, v162, OS_LOG_TYPE_DEFAULT, "TCP Conn %p starting SSL negotiation", buf, 0xCu);
          }

          uint64_t v164 = *(unsigned int *)(v3 + 248);
          unint64_t v165 = v164 | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32) | 0x4000000000LL;
          *(_DWORD *)(v3 + 248) = v164;
          *(_WORD *)(v3 + 252) = WORD2(v165);
        }

        uint64_t v166 = SSLHandshake(*(SSLContextRef *)(v3 + 296));
        int v167 = v166;
        if ((int)v166 > -9804)
        {
          if ((_DWORD)v166 != -9803)
          {
            if (!(_DWORD)v166)
            {
              SocketStream::removeSSLHandshake((SocketStream *)v3);
              if (((*(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32)) & 0x20000000000LL) != 0)
              {
                *(_DWORD *)CFStreamClientContext buf = (int)((CFAbsoluteTimeGetCurrent() - *(double *)(v3 + 672)) * 1000.0);
                unsigned int v175 = *(uint64_t (**(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 112LL))( v3,  v3 - 16,  0x18C5AC250LL);
                if (v175)
                {
                  __int128 v176 = CFGetAllocator((CFTypeRef)(v3 - 16));
                  CFMutableArrayRef MutableCopy = CFDictionaryCreateMutableCopy(v176, 0LL, v175);
                  unsigned int v178 = CFGetAllocator((CFTypeRef)(v3 - 16));
                  CFNumberRef v179 = CFNumberCreate(v178, kCFNumberSInt32Type, buf);
                  CFDictionaryAddValue(MutableCopy, @"_kCFStreamStatsTLS_HandshakeTimeMs", v179);
                  (*(void (**)(uint64_t, uint64_t, __CFDictionary *))(*(void *)v3 + 200LL))( v3,  0x18C5AC250LL,  MutableCopy);
                  CFRelease(v175);
                  if (v179) {
                    CFRelease(v179);
                  }
                  if (MutableCopy) {
                    CFRelease(MutableCopy);
                  }
                }
              }

              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
              }
              v180 = (os_log_s *)CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v181 = *(void *)(v3 + 552);
                *(_DWORD *)CFStreamClientContext buf = 134217984;
                *(void *)&uint8_t buf[4] = v181;
                _os_log_impl(&dword_18298D000, v180, OS_LOG_TYPE_DEFAULT, "TCP Conn %p SSL Handshake DONE", buf, 0xCu);
              }

              goto LABEL_375;
            }

          CFRelease(v107);
          goto LABEL_313;
        }
      }

      else if ((v175 & 1) == 0)
      {
        if (v50 == 10 && *((_BYTE *)this + 41) && *v178 && v106) {
          *((void *)this + 44) = (*(uint64_t (**)(void, _CFURLProtectionSpace *, void))(**((void **)this + 87) + 80LL))( *((void *)this + 87),  v181,  *((void *)this + 10));
        }
        goto LABEL_311;
      }

      if (*v178)
      {
        if (v106)
        {
          int v104 = v181;
          if (v181)
          {
            v139 = *((void *)this + 87);
            if (!v107)
            {
              if (v139) {
                v139 = (*(uint64_t (**)(uint64_t))(*(void *)v139 + 80LL))(v139);
              }
              *((void *)this + 44) = v139;
              if (!v139) {
                goto LABEL_311;
              }
LABEL_277:
              int v143 = (const void *)URLCredential_PasswordBased::safelyCast(v139, (const _CFURLCredential *)v104);
              if (v143) {
                int v143 = (const void *)(*(uint64_t (**)(const void *))(*(void *)v143 + 128LL))(v143);
              }
              if (!v143 && v50 != 9)
              {
                int v143 = (const void *)*((void *)this + 44);
                *((void *)this + 44) = 0LL;
              }

              if (v143) {
                CFRelease(v143);
              }
              goto LABEL_311;
            }

            __int128 v140 = *(uint64_t (**(uint64_t))(*(void *)v139 + 88LL))(v139);
            int64x2_t v141 = v140;
            if (v140)
            {
              uint64_t v142 = CFDictionaryGetValue(v140, v107);
              if (v142) {
                uint64_t v142 = CFRetain(v142);
              }
              *((void *)this + 44) = v142;
              CFRelease(v141);
            }
          }
        }
      }

      v139 = *((void *)this + 44);
      if (!v139) {
        goto LABEL_311;
      }
      goto LABEL_277;
    }

    if (v8 != 401) {
      goto LABEL_104;
    }
    if (*((_BYTE *)this + 857)) {
      goto LABEL_104;
    }
    if (v49 != 11) {
      goto LABEL_104;
    }
    if (!HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35))
      && ([*((id *)this + 11) _allowPrivateAccessTokensForThirdParty] & 1) == 0)
    {
      Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher = gotLoadHelper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher(v53);
      uint64_t v56 = *(void **)(v55 + 2656);
      uint64_t v57 = CFURLCopyHostName(*(CFURLRef *)(objc_msgSend( *((id *)this + 11),  "_inner",  Helper_x8__OBJC_CLASS___NSPPrivateAccessTokenFetcher)
                                          + 8));
      if (![v56 checkOriginAllowedAsThirdParty:(id)CFMakeCollectable(v57)]) {
        goto LABEL_104;
      }
    }

    if (!*((void *)this + 10))
    {
      uint64_t v4 = 0LL;
      *((_DWORD *)this + 48) |= 0x40000u;
      goto LABEL_356;
    }

    unint64_t v58 = (void *)*((void *)this + 11);
    CFMutableDataRef v59 = *(__CFArray **)(v48 + 232);
    isFirstPartyResource = HTTPConnectionCacheKey::isFirstPartyResource(*((HTTPConnectionCacheKey **)this + 35));
    HTTPProtocol::askPATForCreds( this,  a2,  v59,  !isFirstPartyResource,  [v58 _allowPrivateAccessTokensForThirdParty],  *(const __CFURL **)(objc_msgSend(v58, "_inner") + 32));
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    size_t v61 = (os_log_s *)CFNLog::logger;
    uint64_t v4 = 0LL;
    if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_356;
    }
    CFRange v62 = *((void *)this + 99);
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v62;
    _os_log_impl( &dword_18298D000,  v61,  OS_LOG_TYPE_DEFAULT,  "%{public}@ will wait on PAT for creds",  (uint8_t *)&buf,  0xCu);
  }

  uint64_t v4 = 0LL;
LABEL_356:
  uint64_t v168 = v184;
  if (v184)
  {
    uint64_t v169 = (unint64_t *)&v184->__shared_owners_;
    do
      int64_t v170 = __ldaxr(v169);
    while (__stlxr(v170 - 1, v169));
    if (!v170)
    {
      ((void (*)(std::__shared_weak_count *))v168->__on_zero_shared)(v168);
      std::__shared_weak_count::__release_weak(v168);
    }
  }

  return v4;
}

LABEL_383:
            int v198 = translateSSLContextError(*(SSLContext **)(v3 + 296), v166);
            if (v198 == v167)
            {
              CFLog();
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
              }
              uint64_t v199 = CFNLog::logger;
              if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
                goto LABEL_391;
              }
              uint64_t v200 = *(void *)(v3 + 552);
              *(_DWORD *)CFStreamClientContext buf = 134218240;
              *(void *)&uint8_t buf[4] = v200;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v167;
              v201 = "TCP Conn %p SSLHandshake failed (%d)";
              unsigned int v202 = (os_log_s *)v199;
              uint32_t v203 = 18;
            }

            else
            {
              CFLog();
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
              }
              uint64_t v204 = CFNLog::logger;
              if (!os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR)) {
                goto LABEL_391;
              }
              uint64_t v205 = *(void *)(v3 + 552);
              *(_DWORD *)CFStreamClientContext buf = 134218496;
              *(void *)&uint8_t buf[4] = v205;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v167;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v198;
              v201 = "TCP Conn %p SSLHandshake failed (%d -> %d)";
              unsigned int v202 = (os_log_s *)v204;
              uint32_t v203 = 24;
            }

            _os_log_error_impl(&dword_18298D000, v202, OS_LOG_TYPE_ERROR, v201, buf, v203);
LABEL_391:
            *(void *)(v3 + 256) = (int)*MEMORY[0x1896051C0];
            *(_DWORD *)(v3 + 264) = v198;
            SocketStream::removeSSLHandshake((SocketStream *)v3);
            return;
          }

LABEL_375:
          int v185 = 1;
          goto LABEL_376;
        }

        if ((_DWORD)v166 == -9842)
        {
          uint64_t v182 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 184LL))(v3);
          if (!v182) {
            goto LABEL_375;
          }
          *(_DWORD *)(v3 + 248) |= 0x20000000u;
          CFArrayRef names = 0LL;
          if (SSLCopyDistinguishedNames(*(SSLContextRef *)(v3 + 296), &names))
          {
            CFArrayRef v183 = names;
            CFArrayRef names = 0LL;
            if (!v183)
            {
              CFArrayRef v184 = 0LL;
              goto LABEL_356;
            }

            CFRelease(v183);
          }

          CFArrayRef v184 = names;
LABEL_356:
          v186 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_216, 1);
          int v187 = v186;
          if (!v186
            || !(*(unsigned int (**)(void *, const char *, void))(*(void *)v186 + 16LL))( v186,  "Client Cert Requested",  0LL))
          {
LABEL_373:
            CFRetain((CFTypeRef)(v3 - 16));
            valuePtr[0] = MEMORY[0x1895F87A8];
            valuePtr[1] = 3221225472LL;
            uint64_t valuePtr[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_3;
            valuePtr[3] = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            valuePtr[4] = v3;
            (*(void (**)(uint64_t, CFArrayRef, void *))(*(void *)v182 + 48LL))(v182, names, valuePtr);
            (*(void (**)(uint64_t))(*(void *)v182 + 24LL))(v182);
            SocketStream::unscheduleFromSSL((SocketStream *)v3);
            CFArrayRef v174 = names;
            if (names)
            {
LABEL_374:
              CFRelease(v174);
              goto LABEL_375;
            }

            goto LABEL_375;
          }

          if (!v184)
          {
LABEL_372:
            (*(void (**)(void *))(*(void *)v187 + 8LL))(v187);
            goto LABEL_373;
          }

          *(void *)CFStreamClientContext buf = CFRetain(v184);
          unint64_t v188 = CFArrayGetCount(v184);
          CFIndex v190 = v188;
          *(void *)&buf[8] = v188;
          if (v188 - 1 > 0x1FFFFFFFFFFFFFFDLL)
          {
            *(void *)&uint8_t buf[16] = 0LL;
          }

          else
          {
            if (v188 > 0x1E)
            {
              size_t v189 = (const void **)malloc(8 * v188);
              *(void *)&uint8_t buf[16] = v189;
              if (!v189) {
                goto LABEL_366;
              }
            }

            else
            {
              size_t v189 = (const void **)v213;
              *(void *)&uint8_t buf[16] = v213;
            }

            v222.CFIndex location = 0LL;
            v222.CFIndex length = v190;
            CFArrayGetValues(v184, v222, v189);
            CFIndex v190 = *(void *)&buf[8];
          }

          if (v190 <= 0)
          {
LABEL_371:
            CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)buf);
            goto LABEL_372;
          }

LABEL_366:
          (*(void (**)(void *, const char *, const __CFString *, const void **))(*(void *)v187 + 72LL))( v187,  "Distinguished Names",  @"%ld",  v189);
          uint64_t v191 = 0LL;
          do
          {
            unint64_t v192 = *(const void **)(*(void *)&buf[16] + 8 * v191);
            unint64_t v193 = CFGetAllocator(v192);
            CFStringRef v194 = CFStringCreateWithFormat(v193, 0LL, @"<< DATA %@ >>", v192);
            snprintf((char *)__dst, 0xFFuLL, "%d", v191);
            number.CFIndex domain = (CFIndex)off_189C1A178;
            *(void *)&number.SInt32 error = CFStringCreateWithCString(v161, (const char *)__dst, 0x8000100u);
            uint64_t v219 = 0LL;
            uint64_t v220 = 0LL;
            if (v194)
            {
              (*(void (**)(void *))(*(void *)v187 + 64LL))(v187);
              AutoString::~AutoString((AutoString *)&number);
              CFRelease(v194);
            }

            else
            {
              v214 = off_189C1A178;
              CFStringRef v215 = CFStringCreateWithCString(v161, "invalid name", 0x8000100u);
              uint64_t v216 = 0LL;
              uint64_t v217 = 0LL;
              (*(void (**)(void *, void, CFStringRef))(*(void *)v187 + 64LL))( v187,  *(void *)&number.error,  v215);
              AutoString::~AutoString((AutoString *)&v214);
              AutoString::~AutoString((AutoString *)&number);
            }

            ++v191;
          }

          while (v190 != v191);
          goto LABEL_371;
        }

        if ((_DWORD)v166 != -9841) {
          goto LABEL_383;
        }
        uint64_t v168 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 184LL))(v3);
        if (v168)
        {
          *(_DWORD *)(v3 + 248) |= 0x40000000u;
          *(void *)CFStreamClientContext buf = 0LL;
          if (SocketStream::_copyPeerTrustWithPinning_NoLock( (CFDictionaryRef *)v3,  *(SSLContextRef *)(v3 + 296),  (SecTrustRef *)buf))
          {
            uint64_t v169 = *(const void **)buf;
            *(void *)CFStreamClientContext buf = 0LL;
            if (v169) {
              CFRelease(v169);
            }
          }

          int64_t v170 = (const __CFDictionary *)CFDictionaryGetValue( *(CFDictionaryRef *)(v3 + 336),  @"kCFStreamPropertySSLSettings");
          ATSVersion = StrictSecurity::getATSVersion(v170, v171);
          StrictSecurity::cloneSecTrust(&__dst[0].domain, (uint64_t)ATSVersion, *(uint64_t *)buf);
          unsigned int v173 = *(const void **)(v3 + 680);
          *(void *)(v3 + 680) = __dst[0].domain;
          if (v173) {
            CFRelease(v173);
          }
          logPeerCertAvailable(*(SSLContext **)(v3 + 296));
          CFRetain((CFTypeRef)(v3 - 16));
          peerIDLen[0] = MEMORY[0x1895F87A8];
          peerIDLen[1] = 3221225472LL;
          peerIDLen[2] = (size_t)___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke;
          peerIDLen[3] = (size_t)&__block_descriptor_40_e8_v12__0i8l;
          peerIDLen[4] = v3;
          (*(void (**)(uint64_t, void, size_t *))(*(void *)v168 + 40LL))(v168, *(void *)buf, peerIDLen);
          (*(void (**)(uint64_t))(*(void *)v168 + 24LL))(v168);
          SocketStream::unscheduleFromSSL((SocketStream *)v3);
          CFArrayRef v174 = *(CFArrayRef *)buf;
          if (!*(void *)buf) {
            goto LABEL_375;
          }
          goto LABEL_374;
        }

        int v185 = 0;
LABEL_376:
        uint64_t v195 = *(unsigned int *)(v3 + 248);
        unint64_t v40 = v195 | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32);
        if ((v195 & 0x8000) == 0)
        {
          if (v185) {
            return;
          }
          continue;
        }

        break;
      }

      SocketStream::removeSSLHandshake((SocketStream *)v3);
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      v196 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v197 = *(void *)(v3 + 552);
        *(_DWORD *)CFStreamClientContext buf = 134217984;
        *(void *)&uint8_t buf[4] = v197;
        _os_log_impl(&dword_18298D000, v196, OS_LOG_TYPE_DEFAULT, "TCP Conn %p SSL Handshake DONE (fs)", buf, 0xCu);
      }

      return;
    default:
      int v10 = v2;
      if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)CFStreamClientContext buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v10;
        _os_log_fault_impl(&dword_18298D000, MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT, "h = %d", buf, 8u);
      }

      return;
  }

void sub_182AB40F0(_Unwind_Exception *a1)
{
  uint64_t v3 = (void *)STACK[0x4D0];
  if (STACK[0x4D0])
  {
    if (v1 != v3) {
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x4C0], v3);
    }
  }

  _Unwind_Resume(a1);
}

void SocketStream::securityBufferedRead_NoLock(SocketStream *this)
{
  CFMutableDataRef Mutable = (__CFData *)*((void *)this + 29);
  if (Mutable)
  {
    uint64_t v3 = (uint64_t *)((char *)this + 224);
    uint64_t v4 = *((void *)this + 28);
    if (v4 >= 0x8000)
    {
LABEL_59:
      int v30 = *((_DWORD *)this + 62);
      unint64_t v26 = (char *)this + 248;
      unint64_t v28 = v30 & 0xFFFFFFDF | ((unint64_t)*((unsigned __int16 *)v26 + 2) << 32);
      unsigned int v29 = v30 & 0xFFFFFFDB | 4;
      goto LABEL_60;
    }
  }

  else
  {
    SSLClientCertificateState v5 = CFGetAllocator((char *)this - 16);
    CFMutableDataRef Mutable = CFDataCreateMutable(v5, 0x8000LL);
    *((void *)this + 28) = 0LL;
    *((void *)this + 29) = Mutable;
    uint64_t v3 = (uint64_t *)((char *)this + 224);
    if (!Mutable)
    {
      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
      *((_DWORD *)this + 66) = 12;
      return;
    }

    uint64_t v4 = 0LL;
  }

  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  int v7 = *((_DWORD *)this + 66);
  uint64_t v8 = *((void *)this + 28);
  if (v7)
  {
    int v9 = 0;
    int v7 = 0;
  }

  else
  {
    int v10 = MutableBytePtr;
    int v9 = 0;
    uint64_t v32 = (int)*MEMORY[0x1896051C0];
    do
    {
      if (v8 >= 0x8000) {
        break;
      }
      uint64_t v11 = &v10[v8];
      size_t v12 = 0x8000 - v8;
      while (1)
      {
        while (1)
        {
          uint64_t v13 = SSLRead(*((SSLContextRef *)this + 37), v11, v12, &processed);
          uint64_t v14 = *((unsigned int *)this + 62);
          unint64_t v15 = v14 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          int64_t v16 = processed;
          if ((v14 & 0x40000) == 0 && processed)
          {
            unint64_t v17 = HIDWORD(v15);
            v15 |= 0x40000uLL;
            *((_WORD *)this + 126) = v17;
            *((_DWORD *)this + 62) = v15;
          }

          __int16 v18 = (IOLogger *)*((void *)this + 27);
          if (v18) {
            BOOL v19 = (_DWORD)v13 == 0;
          }
          else {
            BOOL v19 = 0;
          }
          if (v19 && v16 != 0)
          {
            IOLogger::logBytesRead(v18, 1, v11, v16);
            int v9 = 0;
            int v7 = 0;
            int64_t v16 = processed;
            goto LABEL_37;
          }

          if ((_DWORD)v13 != -9842) {
            goto LABEL_33;
          }
          *((_WORD *)this + 126) = WORD2(v15);
          *((_DWORD *)this + 62) = v15 | 0x20000000;
          uint64_t v21 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184LL))(this);
          if (v21)
          {
            uint64_t v23 = v21;
            CFArrayRef names = 0LL;
            if (SSLCopyDistinguishedNames(*((SSLContextRef *)this + 37), &names))
            {
              CFArrayRef v24 = names;
              CFArrayRef names = 0LL;
              if (v24) {
                CFRelease(v24);
              }
            }

            CFRetain((char *)this - 16);
            v33[0] = MEMORY[0x1895F87A8];
            v33[1] = 3221225472LL;
            v33[2] = ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke;
            v33[3] = &__block_descriptor_40_e20_v16__0____CFArray__8l;
            v33[4] = this;
            (*(void (**)(uint64_t, CFArrayRef, void *))(*(void *)v23 + 48LL))(v23, names, v33);
            if (names) {
              CFRelease(names);
            }
            (*(void (**)(uint64_t))(*(void *)v23 + 24LL))(v23);
            SocketStream::unscheduleFromSSL(this);
            goto LABEL_47;
          }

          unint64_t v22 = *((_DWORD *)this + 62) & 0xDFFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
          *((_DWORD *)this + 62) &= ~0x20000000u;
          *((_WORD *)this + 126) = WORD2(v22);
        }

        if ((_DWORD)v13 != -9841) {
          goto LABEL_33;
        }
        if (SocketStream::doSettingsOverrideTrustEvaluation((CFDictionaryRef *)this))
        {
          *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v32;
          *((_DWORD *)this + 66) = -9807;
LABEL_47:
          int v9 = 0;
          int v7 = 0;
          uint64_t v8 = *v3;
          goto LABEL_48;
        }
      }

      if ((v13 + 9806) < 2)
      {
        int v7 = 0;
        int v9 = 1;
      }

      else if ((_DWORD)v13 == -9803)
      {
        int v9 = 0;
        int v7 = 1;
      }

      else
      {
        if ((_DWORD)v13)
        {
LABEL_33:
          if (!*((_DWORD *)this + 66))
          {
            int v31 = translateSSLContextError(*((SSLContext **)this + 37), v13);
            *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v32;
            *((_DWORD *)this + 66) = v31;
            goto LABEL_47;
          }
        }

        int v9 = 0;
        int v7 = 0;
      }

uint64_t SocketStream::recvBytes(SocketStream *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  a4->CFIndex domain = 0LL;
  *(void *)&a4->SInt32 error = 0LL;
  id v6 = (__CFSocket *)*((void *)this + 36);
  if (v6 && CFSocketIsValid(v6)) {
    return SocketStream::socketRead(this, a2, a3, a4);
  }
  a4->CFIndex domain = 1LL;
  a4->SInt32 error = 22;
  return -1LL;
}

uint64_t SocketStream::socketRead(SocketStream *this, unsigned __int8 *a2, uint64_t a3, CFStreamError *a4)
{
  uint64_t v7 = __CFSocketRead();
  if (v7 < 0)
  {
    a4->CFIndex domain = 1LL;
    a4->SInt32 error = 0;
  }

  else
  {
    int v9 = (IOLogger *)*((void *)this + 27);
    BOOL v10 = v7 != 0;
    if (v9) {
      BOOL v11 = v7 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      IOLogger::logBytes(v9, "RAW-READ", 0x3Cu, a2, v7);
      BOOL v10 = 1;
    }

    if (*((_BYTE *)this + 636) && v10) {
      entr_act_modify_delayInitStub(v8);
    }
  }

  return v7;
}

uint64_t SocketStream::doSettingsOverrideTrustEvaluation(CFDictionaryRef *this)
{
  int Value = (const __CFDictionary *)CFDictionaryGetValue(this[42], @"kCFStreamPropertySSLSettings");
  CFTypeRef cf = 0LL;
  uint64_t v3 = SocketStream::_copyPeerTrustWithPinning_NoLock(this, this[37], (SecTrustRef *)&cf);
  if ((_DWORD)v3)
  {
    CFTypeRef v4 = cf;
    CFTypeRef cf = 0LL;
    if (!v4) {
      return 4294957494LL;
    }
    CFRelease(v4);
  }

  if (!cf) {
    return 4294957494LL;
  }
  if (Value)
  {
    SSLClientCertificateState v5 = CFDictionaryGetValue(Value, &unk_18C5AE550);
    if (v5)
    {
      id v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        LOWORD(v24) = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&v24,  2u);
      }
    }
  }

  BOOL v30 = 0;
  CFDataRef v8 = copyPeerID(this[37]);
  if (v8)
  {
    int v9 = v8;
    TrustExceptionManager::applyTrustExceptions( (TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton,  v9,  (__SecTrust *)cf,  &v30);
    CFRelease(v9);
    if (v30)
    {
LABEL_15:
      uint64_t v3 = 0LL;
      goto LABEL_45;
    }
  }

  CFTypeRef v10 = cf;
  CFArrayRef v24 = off_189C11C38;
  __int16 v28 = 0;
  if (cf) {
    CFTypeRef v10 = CFRetain(cf);
  }
  uint64_t v26 = 0LL;
  CFTypeRef v27 = 0LL;
  CFTypeRef v25 = v10;
  if (Value)
  {
    BOOL v11 = CFDictionaryGetValue(Value, @"kCFStreamSSLAllowsExpiredCertificates");
    size_t v12 = v11;
    uint64_t v13 = (const void **)MEMORY[0x189604DE8];
    if (v11)
    {
      CFTypeID v14 = CFGetTypeID(v11);
      if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFStreamClientContext buf = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  buf,  2u);
      }

      if (*v13 == v12) {
        HIBYTE(v28) |= 1u;
      }
    }

    unint64_t v15 = CFDictionaryGetValue(Value, @"kCFStreamSSLAllowsExpiredRoots");
    int64_t v16 = v15;
    if (v15)
    {
      CFTypeID v17 = CFGetTypeID(v15);
      if (v17 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFStreamClientContext buf = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  buf,  2u);
      }

      if (*v13 == v16) {
        HIBYTE(v28) |= 2u;
      }
    }

    __int16 v18 = CFDictionaryGetValue(Value, @"kCFStreamSSLAllowsAnyRoot");
    BOOL v19 = v18;
    if (v18)
    {
      CFTypeID v20 = CFGetTypeID(v18);
      if (v20 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFStreamClientContext buf = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  buf,  2u);
      }

      if (*v13 == v19) {
        HIBYTE(v28) |= 4u;
      }
    }

    uint64_t v21 = CFDictionaryGetValue(Value, @"_kCFStreamSSLTrustedLeafCertificates");
    if (v21) {
      CFTypeRef v27 = CFRetain(v21);
    }
  }

  if (MEMORY[0x186E13BB4](v25, buf))
  {
    LOBYTE(v28) = v28 | 0x20;
  }

  else
  {
    int v22 = CFNetworkTrust::processEvaluateResult((SecTrustRef *)&v24, *(SecTrustResultType *)buf);
    if ((v22 - 1) >= 2)
    {
      if (!v22) {
        uint64_t v3 = 0LL;
      }
      goto LABEL_44;
    }
  }

  uint64_t v3 = CFNetworkTrust::errorForEvaluationFalure((CFNetworkTrust *)&v24);
LABEL_44:
  CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)&v24);
LABEL_45:
  if (cf) {
    CFRelease(cf);
  }
  return v3;
}

void sub_182AB4A54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 560))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2) {
      CFRetain(a2);
    }
    CFTypeRef v4 = *(dispatch_queue_s **)(v2 + 560);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    v5[2] = ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke_2;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    void v5[5] = a2;
    dispatch_async(v4, v5);
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream19securityRead_NoLockEPhlS0_S0__block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  CFRelease((char *)v2 - 16);
}

CFDataRef copyPeerID(SSLContext *a1)
{
  peerID = 0LL;
  OSStatus v1 = SSLGetPeerID(a1, (const void **)&peerID, (size_t *)&length);
  CFDataRef result = 0LL;
  if (!v1)
  {
    if (peerID) {
      return CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)peerID, length);
    }
  }

  return result;
}

void SocketStream::_PerformSOCKSv4Handshake_NoLock(CFDictionaryRef *this)
{
  int Value = (const __CFData *)CFDictionaryGetValue(this[42], &unk_18C5ACA68);
  uint64_t v3 = (__CFData *)CFDictionaryGetValue(this[42], &unk_18C5ACA30);
  if (Value)
  {
    v26.CFIndex domain = 0LL;
    *(void *)&v26.SInt32 error = 0LL;
    size_t Length = CFDataGetLength(Value);
    BytePtr = CFDataGetBytePtr(Value);
    uint64_t v6 = SocketStream::sendToSocket((SocketStream *)this, BytePtr, Length, &v26);
    size_t v7 = Length - v6;
    if (!v7)
    {
      CFDataRef v8 = this[42];
      int v9 = &unk_18C5ACA68;
LABEL_32:
      CFDictionaryRemoveValue(v8, v9);
      goto LABEL_33;
    }

    uint64_t v16 = v6;
    if (v6 >= 1)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(Value);
      memmove(MutableBytePtr, &MutableBytePtr[v16], v7);
      CFDataSetLength(Value, v7);
      __int16 v18 = this[36];
      if (v18 && CFSocketIsValid(v18)) {
        CFSocketEnableCallBacks(this[36], 8uLL);
      }
      goto LABEL_33;
    }

    goto LABEL_21;
  }

  CFMutableDataRef v10 = v3;
  if (!v3)
  {
    BOOL v11 = CFGetAllocator(this[42]);
    CFMutableDataRef Mutable = CFDataCreateMutable(v11, 8LL);
    if (!Mutable)
    {
      this[32] = (CFDictionaryRef)1;
      int v24 = 12;
      goto LABEL_28;
    }

    CFMutableDataRef v10 = Mutable;
    CFDictionaryAddValue(this[42], &unk_18C5ACA30, Mutable);
    CFRelease(v10);
  }

  uint64_t v13 = CFDataGetMutableBytePtr(v10);
  CFIndex v14 = CFDataGetLength(v10);
  if (v14 == 8) {
    goto LABEL_8;
  }
  CFIndex v19 = v14;
  v26.CFIndex domain = 0LL;
  *(void *)&v26.SInt32 error = 0LL;
  uint64_t v20 = SocketStream::recvBytes((SocketStream *)this, &v13[v14], 8 - v14, &v26);
  if (!v20)
  {
    this[32] = (CFDictionaryRef)1;
    int v24 = 57;
LABEL_28:
    *((_DWORD *)this + 66) = v24;
    goto LABEL_33;
  }

  if (v20 < 1)
  {
LABEL_21:
    if (v26.error != 35 || v26.domain != 1) {
      *((CFStreamError *)this + CFRetain((char *)this - 16) = v26;
    }
    goto LABEL_33;
  }

  size_t v21 = v20 + v19;
  memcpy(__dst, v13, v21);
  CFDataSetLength(v10, v21);
  memcpy(v13, __dst, v21);
  int v22 = this[36];
  if (v22 && CFSocketIsValid(v22)) {
    CFSocketEnableCallBacks(this[36], 1uLL);
  }
  if (v21 == 8)
  {
LABEL_8:
    if (*v13)
    {
      int v15 = 196607;
    }

    else
    {
      int v23 = v13[1];
      if (v23 == 90)
      {
        SocketStream::removeHandshake_NoLock((uint64_t)this, 4);
LABEL_31:
        CFDataRef v8 = this[42];
        int v9 = &unk_18C5ACA30;
        goto LABEL_32;
      }

      int v15 = v23 | 0x20000;
    }

    this[32] = (CFDictionaryRef)(int)*MEMORY[0x1896051B8];
    *((_DWORD *)this + 66) = v15;
    goto LABEL_31;
  }

void SocketStream::removeSSLHandshake(SocketStream *this)
{
  *((_DWORD *)this + 62) |= 0x802000u;
  SocketStream::removeHandshake_NoLock((uint64_t)this, 7);
  uint64_t v2 = (SSLContext *)*((void *)this + 37);
  if (v2)
  {
    SSLGetNegotiatedProtocolVersion(v2, &protocol);
    setCFIndexProperty(*((__CFDictionary **)this + 42), @"_kCFStreamPropertySSLNegotiatedProtocol", protocol);
    SSLGetNegotiatedCipher(*((SSLContextRef *)this + 37), &cipherSuite);
    setCFIndexProperty(*((__CFDictionary **)this + 42), @"_kCFStreamPropertySSLNegotiatedCipher", cipherSuite);
    if ((((unint64_t)*((unsigned __int16 *)this + 126) << 32) & 0xC0000000000LL) != 0
      && (protocol < kTLSProtocol12 || !StrictSecurityPolicy::isATSCompliantCipher((StrictSecurityPolicy *)cipherSuite)))
    {
      int Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC988);
      logAppleATSViolation((*((unsigned __int16 *)this + 126) >> 10) & 1, Value, protocol, cipherSuite);
    }
  }

  else
  {
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), @"_kCFStreamPropertySSLNegotiatedProtocol");
    CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), @"_kCFStreamPropertySSLNegotiatedCipher");
  }

  if ((*((_DWORD *)this + 62) & 0x8000000) == 0) {
    ++gNonCellularSSLAttempts;
  }
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 560))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    CFTypeRef v4 = *(dispatch_queue_s **)(v2 + 560);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    v5[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_2;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v2;
    int v6 = a2;
    dispatch_async(v4, v5);
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_3(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 560))
  {
    CFRetain((CFTypeRef)(v2 - 16));
    if (a2) {
      CFRetain(a2);
    }
    CFTypeRef v4 = *(dispatch_queue_s **)(v2 + 560);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    v5[2] = ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_4;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v2;
    void v5[5] = a2;
    dispatch_async(v4, v5);
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_4(uint64_t a1)
{
  uint64_t v2 = *(SocketStream **)(a1 + 32);
  SocketStream::securitySetPeerCert(v2, *(const __CFArray **)(a1 + 40));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  CFRelease((char *)v2 - 16);
}

uint64_t ___ZL22logClientCertRequestedPK9__CFArray_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 8247LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12SocketStream32_PerformSecurityHandshake_NoLockEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(_DWORD *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  SocketStream::securityAcceptPeerTrust_NoLock((SocketStream *)v1, v2);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));
  CFRelease((CFTypeRef)(v1 - 16));
}

void SocketStream::securityAcceptPeerTrust_NoLock(SocketStream *this, int a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *((unsigned int *)this + 62);
  if ((v4 & 0x40000000) != 0)
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = v4 & 0xFFFFFFFFBFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) = v4 & 0xBFFFFFFF;
    *((_WORD *)this + 126) = WORD2(v6);
    *(_OWORD *)CFTypeRef cf = *((_OWORD *)this + 19);
    *(void *)&cf[16] = *((void *)this + 40);
    do
    {
      _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)&cf[v5]);
      v5 += 8LL;
    }

    while (v5 != 24);
  }

  if (a2 == 2)
  {
    CFTypeRef v30 = 0LL;
    SocketStream::_copyPeerTrustWithPinning_NoLock( (CFDictionaryRef *)this,  *((SSLContextRef *)this + 37),  (SecTrustRef *)&v30);
    int Value = (const __CFDictionary *)CFDictionaryGetValue( *((CFDictionaryRef *)this + 42),  @"kCFStreamPropertySSLSettings");
    if (v30)
    {
      ATSVersion = StrictSecurity::getATSVersion(Value, v13);
      uint64_t v15 = (uint64_t)ATSVersion;
      uint64_t v16 = *((_BYTE *)this + 253) & 1;
      CFTypeRef v31 = 0LL;
      CFTypeID v17 = (const void *)SecTrustDeserialize();
      __int16 v18 = v17;
      if (v31 || !v17)
      {
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        int v24 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
        {
          CFTypeRef v28 = v31;
          if (v31) {
            CFIndex Code = CFErrorGetCode((CFErrorRef)v31);
          }
          else {
            CFIndex Code = 0LL;
          }
          *(_DWORD *)CFTypeRef cf = 138412546;
          *(void *)&cf[4] = v28;
          *(_WORD *)&cf[12] = 2048;
          *(void *)&cf[14] = Code;
          _os_log_error_impl( &dword_18298D000,  v24,  OS_LOG_TYPE_ERROR,  "Failed to deserialize cloned ATS trust %@ [%ld]",  cf,  0x16u);
        }

        BOOL v22 = 1;
        int v20 = -9802;
      }

      else
      {
        *(void *)CFTypeRef cf = off_189C11C38;
        __int16 v36 = 0;
        CFTypeRef v19 = CFRetain(v17);
        *(void *)&cf[16] = 0LL;
        uint64_t v35 = 0LL;
        *(void *)&cf[8] = v19;
        int v20 = CFNetworkTrust::strictEvaluate((uint64_t)cf, 1LL, v16);
        if (CFNLog::onceToken != -1) {
          dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
        }
        size_t v21 = (os_log_s *)CFNLog::logger;
        if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CFStreamClientContext buf = 67109120;
          int v33 = v20;
          _os_log_impl( &dword_18298D000,  v21,  OS_LOG_TYPE_DEFAULT,  "System Trust Evaluation yielded status(%d)",  buf,  8u);
        }

        BOOL v22 = v20 == 0;
        if (v20)
        {
          if (CFNLog::onceToken != -1) {
            dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
          }
          int v23 = (os_log_s *)CFNLog::logger;
          if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)CFStreamClientContext buf = 0;
            _os_log_error_impl(&dword_18298D000, v23, OS_LOG_TYPE_ERROR, "ATS failed system trust", buf, 2u);
          }
        }

        CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)cf);
      }

      if (v31) {
        CFRelease(v31);
      }
      if (v18) {
        CFRelease(v18);
      }
      if (v22)
      {
LABEL_43:
        CFTypeRef v25 = v30;
        *(void *)CFTypeRef cf = off_189C11C38;
        __int16 v36 = 0;
        if (v30) {
          CFTypeRef v25 = CFRetain(v30);
        }
        *(void *)&cf[16] = 0LL;
        uint64_t v35 = 0LL;
        *(void *)&cf[8] = v25;
        int v20 = CFNetworkTrust::strictEvaluate((uint64_t)cf, v15, v16);
        CFNetworkTrust::~CFNetworkTrust((CFNetworkTrust *)cf);
      }

      CFRelease(v30);
    }

    else
    {
      int v20 = -9802;
    }
  }

  else
  {
    if (a2 == 1)
    {
      size_t v7 = (SSLContext *)*((void *)this + 37);
      if (v7)
      {
        CFDataRef v8 = copyPeerID(v7);
        if (v8)
        {
          int v9 = v8;
          int v10 = SocketStream::_copyPeerTrustWithPinning_NoLock( (CFDictionaryRef *)this,  *((SSLContextRef *)this + 37),  (SecTrustRef *)cf);
          BOOL v11 = *(const void **)cf;
          if (!v10 && *(void *)cf)
          {
            if (TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce != -1) {
              dispatch_once( &TrustExceptionManager::sharedTrustExceptionManager(void)::initOnce,  &__block_literal_global_1697);
            }
            TrustExceptionManager::storeTrustExceptions( (TrustExceptionManager *)TrustExceptionManager::sharedTrustExceptionManager(void)::singleton,  v9,  *(SecTrustRef *)cf);
            BOOL v11 = *(const void **)cf;
          }

          if (v11) {
            CFRelease(v11);
          }
          CFRelease(v9);
        }
      }

void sub_182AB55FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (v13) {
    CFRelease(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::_CreateNameAndPortForCONNECTProxy( SocketStream *this, const __CFDictionary *a2, const __CFString **a3, const __CFNumber **a4, CFStreamError *a5)
{
  int v9 = CFGetAllocator(this);
  *a4 = 0LL;
  a4[1] = 0LL;
  int Value = (const __CFString *)CFDictionaryGetValue(this, &unk_18C5ADE50);
  BOOL v11 = CFDictionaryGetValue(this, &unk_18C5ADE18);
  if (!v11)
  {
    uint64_t v15 = (const __CFArray *)CFDictionaryGetValue(this, &unk_18C5ADDA8);
    ValueAtIndex = v15;
    if (v15)
    {
      Info = (const __CFArray *)CFHostGetInfo((uint64_t)v15, 1, 0LL);
      if (Info && (CFTypeID v17 = Info, CFArrayGetCount(Info)))
      {
        ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v17, 0LL);
      }

      else
      {
        CFTypeRef v19 = (const __CFArray *)CFHostGetInfo((uint64_t)ValueAtIndex, 0, 0LL);
        ValueAtIndex = v19;
        if (v19)
        {
          if (CFArrayGetCount(v19))
          {
            CFIndex v14 = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0LL);
            ValueAtIndex = 0LL;
            goto LABEL_17;
          }

          ValueAtIndex = 0LL;
        }
      }
    }

    goto LABEL_16;
  }

  uint64_t v12 = (uint64_t)v11;
  ValueAtIndex = (const __CFArray *)CFNetServiceGetInfo((uint64_t)v11, 5u);
  if (Value)
  {
    CFRetain(Value);
    if (!ValueAtIndex)
    {
      CFIndex v14 = 0LL;
      goto LABEL_30;
    }

void SocketStream::removeHandshake_NoLock(uint64_t a1, char a2)
{
  int v3 = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 412) &= ~(1 << a2);
  *(_DWORD *)(a1 + 248) = v3 & 0xFDFFFFF3;
  uint64_t v4 = *(__CFSocket **)(a1 + 288);
  if (!v4) {
    return;
  }
  if (!CFSocketIsValid(v4)) {
    return;
  }
  int v5 = *(_DWORD *)(a1 + 248);
  if ((v5 & 2) == 0) {
    return;
  }
  if ((v5 & 0x800000) == 0 || *(_DWORD *)(a1 + 412)) {
    goto LABEL_24;
  }
  BOOL v6 = *(void *)(a1 + 232) && *(uint64_t *)(a1 + 224) >= 1;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
  CFDataRef v8 = WeakRetained;
  if ((*(_DWORD *)(a1 + 248) >> 20) & 1 | v6)
  {
    if (!WeakRetained) {
      goto LABEL_24;
    }
    if ((*(_DWORD *)(a1 + 248) & 0x200) == 0) {
      goto LABEL_23;
    }
LABEL_13:
    _CFReadStreamSignalEventDelayed();
LABEL_23:
    CFRelease(v8);
    goto LABEL_24;
  }

  if ((*(_DWORD *)(a1 + 248) & 0x2000) != 0)
  {
    SocketStream::securityBufferedRead_NoLock((SocketStream *)a1);
    int v9 = *(_DWORD *)(a1 + 248);
    if ((v9 & 4) != 0)
    {
      if (!v8) {
        goto LABEL_24;
      }
    }

    else if ((v9 & 0x100000) == 0 || !v8)
    {
      goto LABEL_15;
    }

    if ((v9 & 0x200) == 0) {
      goto LABEL_23;
    }
    goto LABEL_13;
  }

void setCFIndexProperty(__CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  if (v5) {
    CFRelease(v5);
  }
}

void _CONNECTHeaderApplier(CFStringRef headerField, CFStringRef value, CFHTTPMessageRef message)
{
}

void SocketStream::addHandshake_NoLock(uint64_t a1, int a2)
{
  uint64_t v3 = 0LL;
  unsigned int v4 = *(_DWORD *)(a1 + 412) | (1 << a2);
  *(_DWORD *)(a1 + 412) = v4;
  while (((v4 >> v3) & 1) == 0)
  {
    if (++v3 == 8)
    {
      LODWORD(v3) = 0;
      break;
    }
  }

  if ((_DWORD)v3 == a2)
  {
    *(_DWORD *)(a1 + 248) &= 0xFDFFFFF3;
    CFNumberRef v5 = *(__CFSocket **)(a1 + 288);
    if (v5)
    {
      if (CFSocketIsValid(v5))
      {
        if ((*(_DWORD *)(a1 + 248) & 2) != 0) {
          CFSocketEnableCallBacks(*(CFSocketRef *)(a1 + 288), 9uLL);
        }
      }
    }
  }

void ___ZN12SocketStream19securitySend_NoLockEPKhlPh_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(_DWORD *)(a1 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  SocketStream::securityAcceptPeerTrust_NoLock((SocketStream *)v1, v2);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZL20logPeerCertAvailableP10SSLContext_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 7822LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t _CFSocketSetNoDelay(__CFSocket *a1)
{
  int v3 = 1;
  CFSocketNativeHandle Native = CFSocketGetNative(a1);
  return setsockopt(Native, 6, 1, &v3, 4u);
}

uint64_t _CFSocketSetRecvAnyIf(__CFSocket *a1)
{
  int v3 = 1;
  CFSocketNativeHandle Native = CFSocketGetNative(a1);
  return setsockopt(Native, 0xFFFF, 4356, &v3, 4u);
}

uint64_t SocketStream::_CONNECTSetInfo_NoLock(CFDictionaryRef *this, CFDictionaryRef theDict)
{
  if (theDict)
  {
    int Value = CFDictionaryGetValue(theDict, &unk_18C5B2488);
    CFNumberRef v5 = CFDictionaryGetValue(theDict, &unk_18C5B24C0);
    BOOL v6 = CFDictionaryGetValue(this[42], &unk_18C5B2450);
    if (Value) {
      BOOL v7 = v5 == 0LL;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7) {
      return 0LL;
    }
    CFDataRef v8 = this + 42;
  }

  else
  {
    CFDataRef v8 = this + 42;
    BOOL v6 = CFDictionaryGetValue(this[42], &unk_18C5B2450);
  }

  uint64_t v9 = *((unsigned int *)this + 62);
  unint64_t v10 = v9 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
  if ((v9 & 0x100) != 0) {
    return 0LL;
  }
  if ((v9 & 3) != 0)
  {
    unsigned int v11 = *((_DWORD *)this + 103);
    if (v11)
    {
      uint64_t v12 = 0LL;
      while (((v11 >> v12) & 1) == 0)
      {
        if (++v12 == 8) {
          goto LABEL_18;
        }
      }

      if ((_DWORD)v12 == 5)
      {
        char v13 = 0;
        if (!v6) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }
    }

uint64_t SocketStream::securitySetInfo_NoLock( CFDictionaryRef *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    int Value = (const __CFBoolean *)CFDictionaryGetValue(a2, &unk_18C5AE400);
    BOOL v6 = CFGetAllocator(this - 2);
    if (Value) {
      BOOL v7 = CFBooleanGetValue(Value) != 0;
    }
    else {
      BOOL v7 = 0;
    }
    SSLContextRef v9 = SSLCreateContext(v6, (SSLProtocolSide)!v7, kSSLStreamType);
    if (v9)
    {
      unint64_t v10 = v9;
      unsigned int v11 = CFDictionaryGetValue(a2, &unk_18C5ACFA8);
      uint64_t v12 = (const void **)MEMORY[0x189604DE8];
      if (v11)
      {
        char v13 = v11;
        CFTypeID v14 = CFGetTypeID(v11);
        if (v14 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&valuePtr,  2u);
        }

        if (*v12 == v13)
        {
          uint64_t v15 = *((unsigned int *)this + 62);
          unint64_t v16 = v15 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x40000000000LL;
          *((_DWORD *)this + 62) = v15;
          *((_WORD *)this + 126) = WORD2(v16);
        }
      }

      CFTypeID v17 = CFDictionaryGetValue(a2, &unk_18C5ACF70);
      __int16 v18 = v17;
      if (v17)
      {
        CFTypeID v19 = CFGetTypeID(v17);
        if (v19 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&valuePtr,  2u);
        }

        if (*v12 == v18)
        {
          uint64_t v20 = *((unsigned int *)this + 62);
          unint64_t v21 = v20 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x80000000000LL;
          *((_DWORD *)this + 62) = v20;
          *((_WORD *)this + 126) = WORD2(v21);
        }
      }

      BOOL v22 = CFDictionaryGetValue(a2, &unk_18C5ACF38);
      int v23 = v22;
      if (v22)
      {
        CFTypeID v24 = CFGetTypeID(v22);
        if (v24 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
        {
          LOWORD(valuePtr) = 0;
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&valuePtr,  2u);
        }

        if (*v12 == v23)
        {
          uint64_t v25 = *((unsigned int *)this + 62);
          unint64_t v26 = v25 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x10000000000LL;
          *((_DWORD *)this + 62) = v25;
          *((_WORD *)this + 126) = WORD2(v26);
        }
      }

      uint64_t v27 = (const __CFString *)CFDictionaryGetValue(a2, &unk_18C5AE518);
      if (v27 && SSLSetSessionConfig(v10, v27)) {
        goto LABEL_96;
      }
      CFTypeRef v28 = (const __CFData *)CFDictionaryGetValue(a2, &unk_18C5ACEC8);
      unsigned int v29 = v28;
      if (v28)
      {
        BytePtr = CFDataGetBytePtr(v28);
        unint64_t Length = CFDataGetLength(v29);
        OSStatus v32 = SSLSetEnabledCiphers(v10, (const SSLCipherSuite *)BytePtr, Length >> 1);
        if (v32) {
          CFLog();
        }
      }

      else
      {
        OSStatus v32 = 0;
      }

      int v33 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_18C5AD398);
      CFIndex v34 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_18C5AD360);
      if ((unint64_t)v33 | (unint64_t)v34)
      {
        if (!v33) {
          goto LABEL_41;
        }
        CFAllocatorRef valuePtr = 0LL;
        CFNumberGetValue(v33, kCFNumberCFIndexType, &valuePtr);
        else {
          SSLProtocol v35 = (int)valuePtr;
        }
        if (SSLSetProtocolVersionMin(v10, v35)) {
          goto LABEL_96;
        }
        int v36 = setTLSMaxVersion_ifNeeded(v27, v10, v34, v35);
        uint64_t v8 = 0LL;
        if (!v36)
        {
          OSStatus v32 = 0;
LABEL_41:
          if (v34)
          {
            CFAllocatorRef valuePtr = 0LL;
            CFNumberGetValue(v34, kCFNumberCFIndexType, &valuePtr);
            if ((_DWORD)valuePtr)
            {
              CFAllocatorRef valuePtr = 0LL;
              CFNumberGetValue(v34, kCFNumberCFIndexType, &valuePtr);
              uint64_t v8 = 0LL;
              if (SSLSetProtocolVersionMax(v10, (SSLProtocol)valuePtr)) {
                goto LABEL_97;
              }
            }

            OSStatus v32 = 0;
          }

          goto LABEL_68;
        }

void sub_182AB69AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
  if (ptr)
  {
    if (v13 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::_SOCKSSetInfo_NoLock(CFDictionaryRef *this, const __CFDictionary *a2)
{
  int Value = CFDictionaryGetValue(this[42], &unk_18C5ADEF8);
  if (a2)
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(a2)) {
      return 0LL;
    }
  }

  if (((_DWORD)this[31] & 0x103LL) != 0) {
    return 0LL;
  }
  if (Value && CFEqual(Value, a2)) {
    return 1LL;
  }
  if (!a2)
  {
    CFDictionaryRemoveValue(this[42], &unk_18C5ADEF8);
    SocketStream::removeHandshake_NoLock((uint64_t)this, 4);
    uint64_t v6 = 1LL;
    SocketStream::removeHandshake_NoLock((uint64_t)this, 1);
    return v6;
  }

  uint64_t v8 = (const __CFString *)CFDictionaryGetValue(a2, (const void *)*MEMORY[0x1896051F8]);
  SSLContextRef v9 = (const __CFString *)CFDictionaryGetValue(a2, (const void *)*MEMORY[0x1896051E0]);
  unint64_t v10 = CFDictionaryGetValue(a2, (const void *)*MEMORY[0x189605200]);
  unsigned int v11 = (const void *)*MEMORY[0x189605210];
  if (v10) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = (const void *)*MEMORY[0x189605210];
  }
  char v13 = CFDictionaryGetValue(this[42], &unk_18C5ADDA8);
  CFTypeID v14 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_18C5AE5C0);
  int valuePtr = 0;
  uint64_t v15 = (const void *)*MEMORY[0x189605208];
  if (CFEqual(v12, (CFTypeRef)*MEMORY[0x189605208]) || CFEqual(v12, v11))
  {
    if (v14 && CFNumberGetValue(v14, kCFNumberSInt32Type, &valuePtr) && !valuePtr)
    {
      CFDictionaryRemoveValue(this[42], &unk_18C5ADEF8);
      return 1LL;
    }

    if (!v13)
    {
      if (CFDictionaryGetValue(this[42], &unk_18C5ADE18)) {
        return 0LL;
      }
      goto LABEL_33;
    }

    Info = (const __CFArray *)CFHostGetInfo((uint64_t)v13, 1, 0LL);
    if (Info && (CFTypeID v17 = Info, CFArrayGetCount(Info)))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v17, 0LL);
      if (!ValueAtIndex) {
        goto LABEL_33;
      }
      CFTypeID v19 = (const __CFString *)CFRetain(ValueAtIndex);
    }

    else
    {
      uint64_t v20 = (const __CFArray *)CFHostGetInfo((uint64_t)v13, 0, 0LL);
      if (!v20) {
        goto LABEL_33;
      }
      unint64_t v21 = v20;
      if (!CFArrayGetCount(v20)) {
        goto LABEL_33;
      }
      CFGetAllocator(v21);
      BOOL v22 = (const __CFData *)CFArrayGetValueAtIndex(v21, 0LL);
      CFTypeID v19 = _CFNetworkCFStringCreateWithCFDataAddress(v22);
    }

    int v23 = v19;
    if (v19)
    {
      CFIndex Length = CFStringGetLength(v19);
      CFTypeID v24 = (const __CFArray *)CFDictionaryGetValue(a2, &unk_18C5AD3D0);
      uint64_t v25 = CFDictionaryGetValue(a2, &unk_18C5AD408);
      LODWORD(v24) = _CFNetworkDoesNeedProxy(v23, v24, v25);
      CFRelease(v23);
LABEL_34:
      if ((!CFEqual(v12, v11) || !v9 || CFStringGetLength(v9) <= 255)
        && (!v8
         || (!CFEqual(v12, v15) || CFStringGetLength(v8) <= 512) && (!CFEqual(v12, v11) || CFStringGetLength(v8) < 256)))
      {
        if (CFEqual(v12, v15)) {
          int v26 = 4;
        }
        else {
          int v26 = 1;
        }
        SocketStream::addHandshake_NoLock((uint64_t)this, v26);
        CFDictionarySetValue(this[42], &unk_18C5ADEF8, a2);
        return 1LL;
      }

      return 0LL;
    }

uint64_t _CFSocketSetTrafficMgtBackground(__CFSocket *a1, int a2)
{
  BOOL v4 = a2 != 0;
  CFSocketNativeHandle Native = CFSocketGetNative(a1);
  return setsockopt(Native, 0xFFFF, 4357, &v4, 4u);
}

uint64_t SocketStream::securitySetContext_NoLock( SocketStream *this, SSLContextRef context, const __CFDictionary *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  CFNumberRef v5 = (SSLContext *)*((void *)this + 37);
  if (v5)
  {
    OSStatus v6 = SSLGetSessionState(v5, state);
    if (v6 | state[0]) {
      return 0LL;
    }
    SSLContextRef v8 = (SSLContextRef)*((void *)this + 37);
    if (v8 != context)
    {
      *((void *)this + 37) = 0LL;
      if (v8) {
        CFRelease(v8);
      }
    }
  }

  else if (context)
  {
    *((void *)this + 37) = 0LL;
  }

  uint64_t v9 = *((void *)this + 74);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    *((void *)this + 74) = 0LL;
  }

  if (context)
  {
    OSStatus v10 = SSLSetIOFuncs( context,  (SSLReadFunc)SocketStream::_SecurityReadFunc_NoLock,  (SSLWriteFunc)SocketStream::_SecurityWriteFunc_NoLock);
    *((_DWORD *)this + 66) = v10;
    if (v10) {
      goto LABEL_24;
    }
    OSStatus v10 = SSLSetConnection(context, this);
    *((_DWORD *)this + 66) = v10;
    if (v10) {
      goto LABEL_24;
    }
    int Value = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC6B0);
    if (Value)
    {
      uint64_t v12 = Value;
      SSLSetNPNFunc();
      memset(&v30, 0, sizeof(v30));
      int Count = CFArrayGetCount(v12);
      if (Count >= 1)
      {
        CFIndex v14 = 0LL;
        uint64_t v15 = Count;
        do
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v14);
          int Length = CFStringGetLength(ValueAtIndex);
          std::string::value_type v18 = Length;
          if (Length <= 31 && CFStringGetCString(ValueAtIndex, (char *)state, 32LL, 0x600u))
          {
            std::string::value_type __s = v18;
            std::string::append(&v30, &__s, 1uLL);
            std::string::append(&v30, (const std::string::value_type *)state);
          }

          ++v14;
        }

        while (v15 != v14);
      }

      SSLSetALPNFunc();
      SSLSetALPNData();
    }

    OSStatus v10 = *((_DWORD *)this + 66);
    if (v10)
    {
LABEL_24:
      uint64_t result = 0LL;
      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = (int)*MEMORY[0x1896051C0];
      *((_DWORD *)this + 66) = v10;
      return result;
    }

    if (*((void *)this + 27))
    {
      CFAllocatorRef v19 = CFGetAllocator((char *)this - 16);
      uint64_t v20 = MEMORY[0x186E12804](v19, 96LL, 0LL);
      *(_OWORD *)(v20 + 64) = 0u;
      *(_OWORD *)(v20 + 80) = 0u;
      *(_OWORD *)(v20 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 0u;
      *(_OWORD *)(v20 + 48) = 0u;
      *(_OWORD *)uint64_t v20 = 0u;
      *(_OWORD *)(v20 + CFRetain((char *)this - 16) = 0u;
      CFAllocatorRef v21 = CFGetAllocator((char *)this - 16);
      uint64_t v22 = *((void *)this + 27);
      uint64_t v23 = *(void *)(v22 + 272);
      CFTypeID v24 = (__int128 *)(v22 + 280);
      uint64_t v25 = *(void *)(v22 + 328);
      __int128 v27 = v24[1];
      __int128 v26 = v24[2];
      __int128 v28 = *v24;
      *(void *)uint64_t v20 = off_189C13B50;
      *(void *)(v20 + 8) = v21;
      *(void *)(v20 + 24) = 0LL;
      *(void *)(v20 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = v23;
      *(_OWORD *)(v20 + 40) = v28;
      *(_OWORD *)(v20 + 56) = v27;
      *(_OWORD *)(v20 + 72) = v26;
      *(void *)(v20 + 88) = v25;
      *(void *)(v20 + CFRetain((char *)this - 16) = 0LL;
      *((void *)this + 74) = v20;
    }

    SocketStream::addHandshake_NoLock((uint64_t)this, 7);
    *((void *)this + 37) = CFRetain(context);
  }

  else
  {
    SocketStream::removeHandshake_NoLock((uint64_t)this, 7);
  }

  return 1LL;
}

void sub_182AB706C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::setupMinimumThroughput(uint64_t this, int a2)
{
  if (*(void *)(this + 552))
  {
    int valuePtr = 0;
    this = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(this + 336), &unk_18C5AC640);
    if (this)
    {
      int v3 = (const __CFNumber *)this;
      CFTypeID v4 = CFGetTypeID((CFTypeRef)this);
      this = CFNumberGetTypeID();
      if (v4 != this) {
        return this;
      }
      CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
    }

    else if (!a2)
    {
      return this;
    }

    return tcp_connection_set_minimum_throughput();
  }

  return this;
}

uint64_t SocketStream::updateExcessiveKeepalivesParameters(uint64_t this, CFTypeRef cf)
{
  if (*(void *)(this + 552))
  {
    uint64_t valuePtr = 0LL;
    if (cf)
    {
      CFTypeID v3 = CFGetTypeID(cf);
      if (v3 == CFDictionaryGetTypeID())
      {
        int Value = (const __CFBoolean *)CFDictionaryGetValue( (CFDictionaryRef)cf,  @"_kExcessiveKeepalivesParametersEnabled");
        if (Value) {
          CFBooleanGetValue(Value);
        }
        CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue( (CFDictionaryRef)cf,  @"_kExcessiveKeepalivesParametersInterval");
        if (v5) {
          CFNumberGetValue(v5, kCFNumberSInt32Type, (char *)&valuePtr + 4);
        }
        OSStatus v6 = (const __CFNumber *)CFDictionaryGetValue( (CFDictionaryRef)cf,  @"_kExcessiveKeepalivesParametersCount");
        if (v6) {
          CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr);
        }
      }
    }

    return tcp_connection_add_event_excessive_keepalives();
  }

  return this;
}

uint64_t SocketStream::updateTCPKeepalivesParameters(uint64_t this, CFTypeRef cf)
{
  if (*(void *)(this + 552))
  {
    uint64_t valuePtr = 0LL;
    if (cf)
    {
      CFTypeID v3 = CFGetTypeID(cf);
      if (v3 == CFDictionaryGetTypeID())
      {
        int Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kTCPKeepAliveParametersEnabled");
        if (Value) {
          CFBooleanGetValue(Value);
        }
        CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kTCPKeepAliveParametersIdleTime");
        if (v5) {
          CFNumberGetValue(v5, kCFNumberSInt32Type, (char *)&valuePtr + 4);
        }
        OSStatus v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_kTCPKeepAliveParametersInterval");
        if (v6) {
          CFNumberGetValue(v6, kCFNumberSInt32Type, &valuePtr);
        }
      }
    }

    return tcp_connection_set_keepalive();
  }

  return this;
}

uint64_t SocketStream::updateTCPAdaptiveParamters(SocketStream *this, CFNumberRef number, CFNumberRef a3)
{
  uint64_t result = *((void *)this + 69);
  if (result)
  {
    CFNumberRef v5 = (CFNumberRef *)MEMORY[0x189605018];
    if (number)
    {
      if ((CFNumberRef)*MEMORY[0x189605018] == number)
      {
        uint64_t result = tcp_connection_add_event_adaptive_read_timeout();
      }

      else
      {
        CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
        tcp_connection_add_event_adaptive_read_timeout();
        uint64_t result = (uint64_t)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_108, 2);
        if (result)
        {
          uint64_t v6 = result;
          uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void))(*(void *)result + 16LL))( result,  "updateTCPAdaptiveParamters",  0LL);
          if ((_DWORD)result)
          {
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v6 + 72LL))( v6,  "conn",  @"%p");
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v6 + 72LL))( v6,  "read count",  @"%d");
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
          }
        }
      }
    }

    if (a3)
    {
      if (*v5 == a3)
      {
        return tcp_connection_add_event_adaptive_write_timeout();
      }

      else
      {
        CFNumberGetValue(a3, kCFNumberSInt32Type, &v8);
        tcp_connection_add_event_adaptive_write_timeout();
        uint64_t result = (uint64_t)DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_111, 2);
        if (result)
        {
          uint64_t v7 = result;
          uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void))(*(void *)result + 16LL))( result,  "updateTCPAdaptiveParamters",  0LL);
          if ((_DWORD)result)
          {
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v7 + 72LL))( v7,  "conn",  @"%p");
            (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v7 + 72LL))( v7,  "write count",  @"%d");
            return (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
          }
        }
      }
    }
  }

  return result;
}

void SocketStream::updateTCPConnectionPoolPriority( SocketStream *this, const __CFString *a2, const __CFNumber *a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a2 && *((void *)this + 69))
  {
    CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
    uint64_t v8 = 1023LL;
    CFNumberRef v5 = _CFStringGetOrCreateCString((uint64_t)allocator, a2, v10, &v8, 0x8000100u);
    ptr = v5;
    uint64_t valuePtr = 300LL;
    if (a3) {
      CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr);
    }
    if (v5) {
      tcp_connection_set_connection_pool();
    }
    if (ptr)
    {
      if (v10 != ptr) {
        CFAllocatorDeallocate(allocator, ptr);
      }
    }
  }

void sub_182AB75E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFAllocatorRef allocator, uint64_t a12, void *ptr)
{
}

CFDictionaryRef ___ZN12SocketStream11setPropertyEPKvPK10__CFStringS1__block_invoke( uint64_t a1, uint64_t a2, const __CFString *a3)
{
  return SocketStream::copyProperty_NoLock( *(SocketStream **)(a1 + 32),  *(const __CFString **)(*(void *)(a1 + 48) + 8LL),  a3);
}

CFDictionaryRef SocketStream::copyProperty_NoLock( SocketStream *this, const __CFString *a2, const __CFString *a3)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  CFArrayRef names = 0LL;
  int Value = (char *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), a2);
  if (Value)
  {
LABEL_2:
    CFTypeID v6 = CFGetTypeID(Value);
    if (*(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96) == v6)
    {
      uint64_t v7 = CFGetAllocator((char *)this - 16);
      return CFHostCreateCopy(v7, (CFHostRef)Value);
    }

    if (CFNetServiceGetTypeID() == v6)
    {
      char v13 = CFGetAllocator((char *)this - 16);
      return CFNetServiceCreateCopy(v13, (CFNetServiceRef)Value);
    }

    if (CFDictionaryGetTypeID() == v6)
    {
      uint64_t v15 = CFGetAllocator((char *)this - 16);
      return CFDictionaryCreateCopy(v15, (CFDictionaryRef)Value);
    }

    if (CFArrayGetTypeID() == v6)
    {
      CFAllocatorRef v19 = CFGetAllocator((char *)this - 16);
      return CFArrayCreateCopy(v19, (CFArrayRef)Value);
    }

    if (*(void *)(HTTPMessage::Class(void)::sClass_OBJTYPE + 96) == v6)
    {
      CFAllocatorRef v21 = CFGetAllocator((char *)this - 16);
      return CFHTTPMessageCreateCopy(v21, (CFHTTPMessageRef)Value);
    }

    uint64_t v8 = Value;
    return (CFDictionaryRef)CFRetain(v8);
  }

  int ExactString = _findExactString(a2, 0);
  if (ExactString <= 198495749)
  {
    if (ExactString <= 131443042)
    {
      if (ExactString <= 99878706)
      {
        if (ExactString <= 85255704)
        {
          if (ExactString != 31695365)
          {
            if (ExactString != 56869868) {
              return names;
            }
            uint64_t v22 = (__CFSocket *)*((void *)this + 36);
            if (v22 && CFSocketIsValid(v22)) {
              return CFSocketCopyPeerAddress(*((CFSocketRef *)this + 36));
            }
            return 0LL;
          }

          unint64_t v16 = (void **)MEMORY[0x189604DE8];
          CFTypeID v17 = (void **)MEMORY[0x189604DE0];
          BOOL v18 = ((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x200000000LL) == 0;
          goto LABEL_131;
        }

        if (ExactString == 85255705)
        {
LABEL_100:
          if (!*((void *)this + 69)) {
            return names;
          }
          int is_expensive = tcp_connection_is_expensive();
          goto LABEL_144;
        }

        int v26 = 88393301;
      }

      else
      {
        if (ExactString > 124045534)
        {
          if (ExactString == 124045535)
          {
            uint64_t v8 = (char *)this - 16;
            return (CFDictionaryRef)CFRetain(v8);
          }

          if (ExactString == 129296697)
          {
            if (*((void *)this + 37)) {
              SSLGetCertificate();
            }
            return names;
          }

          if (ExactString != 130378061) {
            return names;
          }
          CFIndex v14 = (SSLContext *)*((void *)this + 37);
          if (!v14) {
            return names;
          }
          *(_DWORD *)&clientState.sa_len = 0;
          if (SSLGetClientCertificateState(v14, (SSLClientCertificateState *)&clientState)) {
            return 0LL;
          }
LABEL_137:
          __int128 v27 = CFGetAllocator((char *)this - 16);
          CFNumberType v28 = kCFNumberIntType;
          return CFNumberCreate(v27, v28, &clientState);
        }

        if (ExactString == 99878707)
        {
          if (!*((void *)this + 69)) {
            return names;
          }
          int is_expensive = tcp_connection_has_better_route();
LABEL_144:
          unsigned int v29 = (void **)MEMORY[0x189604DE8];
          if (!is_expensive) {
            unsigned int v29 = (void **)MEMORY[0x189604DE0];
          }
          goto LABEL_154;
        }

        int v26 = 100902724;
      }

      if (ExactString == v26) {
        return (CFDictionaryRef)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), a2);
      }
      return names;
    }

    if (ExactString <= 161713009)
    {
      if (ExactString <= 140716566)
      {
        if (ExactString != 131443043)
        {
          if (ExactString != 132442490) {
            return names;
          }
          CFTypeID v24 = (SSLContext *)*((void *)this + 37);
          if (!v24 || !SSLCopyDistinguishedNames(v24, &names)) {
            return names;
          }
          return 0LL;
        }

        if (!*((void *)this + 37)) {
          return names;
        }
        *(_DWORD *)&clientState.sa_len = 0;
        goto LABEL_137;
      }

      if (ExactString == 140716567)
      {
        if (!*((void *)this + 69)) {
          return names;
        }
        uint64_t v46 = tcp_connection_copy_tcp_info();
        if (!v46) {
          return names;
        }
        unint64_t v47 = (void *)v46;
        if (MEMORY[0x186E16728]() == MEMORY[0x1895F9250] && xpc_dictionary_get_count(v47)) {
          CFArrayRef names = (CFArrayRef)_CFXPCCreateCFObjectFromXPCObject();
        }
        int v36 = v47;
        goto LABEL_175;
      }

      if (ExactString != 160648036) {
        return names;
      }
      unsigned int v29 = (void **)MEMORY[0x189604DE8];
      int v30 = *((unsigned __int8 *)this + 405);
    }

    else
    {
      if (ExactString > 192228738)
      {
        if (ExactString == 192228739)
        {
          int Value = (char *)*((void *)this + 67);
          if (!Value) {
            return names;
          }
          goto LABEL_2;
        }

        if (ExactString != 194301361)
        {
          if (ExactString != 197438963) {
            return names;
          }
          unint64_t v16 = (void **)MEMORY[0x189604DE8];
          CFTypeID v17 = (void **)MEMORY[0x189604DE0];
          BOOL v18 = (*((_DWORD *)this + 62) & 0x8000000) == 0LL;
LABEL_131:
          if (v18) {
            unsigned int v29 = v17;
          }
          else {
            unsigned int v29 = v16;
          }
          goto LABEL_154;
        }

        if (!*((void *)this + 69))
        {
          unsigned int v29 = (void **)MEMORY[0x189604DE0];
          goto LABEL_154;
        }

        int is_expensive = tcp_connection_did_fallback();
        goto LABEL_144;
      }

      if (ExactString != 161713010)
      {
        if (ExactString != 174287922) {
          return names;
        }
        uint64_t RemoteHostName_NoLock = serviceTypeToString(*((_DWORD *)this + 102));
        goto LABEL_104;
      }

      unsigned int v29 = (void **)MEMORY[0x189604DE8];
      int v30 = *((unsigned __int8 *)this + 406);
    }

    if (!v30) {
      unsigned int v29 = (void **)MEMORY[0x189604DE0];
    }
    goto LABEL_154;
  }

  if (ExactString <= 218394490)
  {
    if (ExactString > 209071817)
    {
      if (ExactString > 211103476)
      {
        if (ExactString != 211103477)
        {
          if (ExactString != 212037386)
          {
            if (ExactString != 214216493) {
              return names;
            }
            unint64_t v16 = (void **)MEMORY[0x189604DE8];
            CFTypeID v17 = (void **)MEMORY[0x189604DE0];
            BOOL v18 = ((*((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32)) & 0x100000000LL) == 0;
            goto LABEL_131;
          }

          unsigned int v29 = (void **)MEMORY[0x189604DE8];
LABEL_154:
          int Value = (char *)*v29;
          if (!*v29) {
            return names;
          }
          goto LABEL_2;
        }

        if (!*((void *)this + 69)) {
          return names;
        }
        uint64_t v31 = tcp_connection_multipath_copy_subflow_switch_counts();
        if (!v31) {
          return names;
        }
        uint64_t v32 = (void *)v31;
        if (MEMORY[0x186E16728]() == MEMORY[0x1895F9250] && xpc_dictionary_get_count(v32))
        {
          int v33 = CFGetAllocator((char *)this - 16);
          size_t count = xpc_dictionary_get_count(v32);
          CFMutableDataRef Mutable = CFDictionaryCreateMutable(v33, count, MEMORY[0x189605240], MEMORY[0x189605250]);
          v48[0] = MEMORY[0x1895F87A8];
          v48[1] = 3221225472LL;
          v48[2] = ___ZN12SocketStream19copyProperty_NoLockEPKvPK10__CFString_block_invoke;
          v48[3] = &__block_descriptor_48_e37_B24__0r_8__NSObject_OS_xpc_object__16l;
          v48[4] = this;
          v48[5] = Mutable;
          xpc_dictionary_apply(v32, v48);
          CFArrayRef names = Mutable;
        }

        int v36 = v32;
LABEL_175:
        xpc_release(v36);
        return names;
      }

      if (ExactString != 209071818)
      {
        if (ExactString != 209997539) {
          return names;
        }
        *(void *)&clientState.sa_len = 0LL;
        if (!*((void *)this + 69)) {
          goto LABEL_95;
        }
LABEL_94:
        *(void *)&clientState.sa_len = tcp_connection_multipath_get_subflow_count();
LABEL_95:
        __int128 v27 = CFGetAllocator((char *)this - 16);
        CFNumberType v28 = kCFNumberCFIndexType;
        return CFNumberCreate(v27, v28, &clientState);
      }

      if (!*((void *)this + 69)) {
        return names;
      }
      unsigned int primary_subflow_ifindex = tcp_connection_multipath_get_primary_subflow_ifindex();
      unint64_t v40 = CFGetAllocator((char *)this - 16);
      p_sockaddr clientState = &clientState;
      return (CFDictionaryRef)CFStringCreateWithCString(v40, (const char *)p_clientState, 0x8000100u);
    }

    if (ExactString > 206868128)
    {
      if (ExactString != 206868129)
      {
        if (ExactString != 207974068) {
          return names;
        }
        *(void *)&clientState.sa_len = 0LL;
        if (!*((void *)this + 69)) {
          goto LABEL_95;
        }
        goto LABEL_94;
      }

      CFRange v43 = (__CFSocket *)*((void *)this + 36);
      if (!v43) {
        return names;
      }
      if (!CFSocketIsValid(v43)) {
        return names;
      }
      CFSocketNativeHandle Native = CFSocketGetNative(*((CFSocketRef *)this + 36));
      socklen_t v51 = 128;
      if (getsockname(Native, &clientState, &v51)) {
        return names;
      }
      socklen_t v49 = 4;
      int v45 = clientState.sa_family == 30 ? 41 : 0;
      if (getsockopt(Native, v45, 9696, &v50, &v49) || !if_indextoname(v50, v53)) {
        return names;
      }
      unint64_t v40 = CFGetAllocator((char *)this - 16);
      p_sockaddr clientState = (sockaddr *)v53;
      return (CFDictionaryRef)CFStringCreateWithCString(v40, (const char *)p_clientState, 0x8000100u);
    }

    if (ExactString != 198495750)
    {
      if (ExactString != 199544346 || !*((void *)this + 69)) {
        return names;
      }
      int is_expensive = tcp_connection_is_multipath();
      goto LABEL_144;
    }

    goto LABEL_100;
  }

  if (ExactString > 228814902)
  {
    if (ExactString <= 230928471)
    {
      if (ExactString == 228814903)
      {
        uint64_t v8 = (char *)*((void *)this + 37);
        if (!v8) {
          return (CFDictionaryRef)v8;
        }
        return (CFDictionaryRef)CFRetain(v8);
      }
    }

    else
    {
      if (ExactString != 230928472)
      {
        if (ExactString == 233173110)
        {
          if (*((void *)this + 37))
          {
            *(void *)&clientState.sa_len = 0LL;
            *(void *)int v53 = 0LL;
            if (!_SSLGetDiffieHellmanParams())
            {
              OSStatus v10 = CFGetAllocator((char *)this - 16);
              uint64_t v11 = 0LL;
              CFIndex v12 = *(void *)v53;
              return CFDataCreate(v10, &v11->sa_len, v12);
            }
          }
        }

        else if (ExactString == 561257568 && CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5B2450))
        {
          uint64_t v20 = CFGetAllocator((char *)this - 16);
          return CFHTTPMessageCreateEmpty(v20, 0);
        }

        return names;
      }

      BOOL v37 = (SSLContext *)*((void *)this + 37);
    }

    if (!names) {
      return names;
    }
    CFRelease(names);
    return 0LL;
  }

  if (ExactString <= 222621636)
  {
    if (ExactString == 218394491)
    {
      BOOL v38 = (__CFSocket *)*((void *)this + 36);
      if (v38 && CFSocketIsValid(v38))
      {
        *(_DWORD *)&clientState.sa_len = CFSocketGetNative(*((CFSocketRef *)this + 36));
        OSStatus v10 = CFGetAllocator((char *)this - 16);
        uint64_t v11 = &clientState;
        CFIndex v12 = 4LL;
        return CFDataCreate(v10, &v11->sa_len, v12);
      }

      return names;
    }

    if (ExactString != 220508062) {
      return names;
    }
    uint64_t RemoteHostName_NoLock = (uint64_t)SocketStream::getRemoteHostName_NoLock((CFDictionaryRef *)this);
LABEL_104:
    int Value = (char *)RemoteHostName_NoLock;
    if (!RemoteHostName_NoLock) {
      return names;
    }
    goto LABEL_2;
  }

  switch(ExactString)
  {
    case 222621637:
      uint64_t RemoteHostName_NoLock = (uint64_t)SocketStream::getRemoteHostPort_NoLock((CFDictionaryRef *)this);
      goto LABEL_104;
    case 223645657:
      uint64_t RemoteHostName_NoLock = (uint64_t)SocketStream::securityGetProtocol(this);
      goto LABEL_104;
    case 224669676:
      if (*((void *)this + 37))
      {
        OSStatus v10 = CFGetAllocator((char *)this - 16);
        uint64_t v11 = (sockaddr *)((char *)this + 296);
        CFIndex v12 = 8LL;
        return CFDataCreate(v10, &v11->sa_len, v12);
      }

      return 0LL;
  }

  return names;
}

const void *SocketStream::getRemoteHostName_NoLock(CFDictionaryRef *this)
{
  int Value = CFDictionaryGetValue(this[42], &unk_18C5ADDA8);
  if (Value)
  {
    Info = (const __CFArray *)CFHostGetInfo((uint64_t)Value, 1, 0LL);
    if (Info)
    {
      CFTypeID v4 = Info;
      if (CFArrayGetCount(Info)) {
        return CFArrayGetValueAtIndex(v4, 0LL);
      }
    }
  }

  else
  {
    CFTypeID v6 = CFDictionaryGetValue(this[42], &unk_18C5ADE18);
    if (v6) {
      return CFNetServiceGetInfo((uint64_t)v6, 5u);
    }
  }

  return 0LL;
}

const __CFArray *SocketStream::getRemoteHostPort_NoLock(CFDictionaryRef *this)
{
  int Value = CFDictionaryGetValue(this[42], &unk_18C5ADDA8);
  if (!Value)
  {
    OSStatus v10 = CFDictionaryGetValue(this[42], &unk_18C5ADE18);
    if (v10)
    {
      int valuePtr = v10[14];
      uint64_t v8 = CFGetAllocator(this - 2);
      p_int valuePtr = (unsigned int *)&valuePtr;
      goto LABEL_9;
    }

    return 0LL;
  }

  Info = (const __CFArray *)CFHostGetInfo((uint64_t)Value, 0, 0LL);
  CFTypeID v4 = Info;
  if (!Info) {
    return v4;
  }
  if (!CFArrayGetCount(Info)) {
    return 0LL;
  }
  ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v4, 0LL);
  BytePtr = CFDataGetBytePtr(ValueAtIndex);
  int v7 = BytePtr[1];
  if (v7 != 30)
  {
    CFTypeID v4 = 0LL;
    if (v7 != 2) {
      return v4;
    }
  }

  unsigned int v13 = bswap32(*((unsigned __int16 *)BytePtr + 1)) >> 16;
  uint64_t v8 = CFGetAllocator(this - 2);
  p_int valuePtr = &v13;
LABEL_9:
  CFTypeID v4 = CFNumberCreate(v8, kCFNumberSInt32Type, p_valuePtr);
  if (v4)
  {
    CFDictionarySetValue(this[42], &unk_18C5ADE50, v4);
    CFRelease(v4);
  }

  return v4;
}

SSLContext *SocketStream::securityGetProtocol(SocketStream *this)
{
  uint64_t result = (SSLContext *)*((void *)this + 37);
  if (result)
  {
    *(void *)SSLProtocol protocol = 0LL;
    SSLProtocol maxVersion = kSSLProtocolUnknown;
    SSLGetNegotiatedProtocolVersion(result, &protocol[1]);
    SSLGetProtocolVersionMin(*((SSLContextRef *)this + 37), protocol);
    SSLGetProtocolVersionMax(*((SSLContextRef *)this + 37), &maxVersion);
    if (protocol[1] == kSSLProtocol3)
    {
      SSLProtocol v3 = maxVersion;
    }

    else
    {
      if (protocol[1] == kSSLProtocol2)
      {
LABEL_6:
        CFTypeID v4 = &kCFStreamSocketSecurityLevelSSLv2;
        return (SSLContext *)*v4;
      }

      if (protocol[1])
      {
LABEL_10:
        if (protocol[0] == kSSLProtocol2) {
          CFTypeID v4 = &kCFStreamSocketSecurityLevelNegotiatedSSL;
        }
        else {
          CFTypeID v4 = &kCFStreamSocketSecurityLevelTLSv1;
        }
        return (SSLContext *)*v4;
      }

      SSLProtocol v3 = maxVersion;
      if (maxVersion == kSSLProtocol2) {
        goto LABEL_6;
      }
    }

    if (v3 == kSSLProtocol3)
    {
      CFTypeID v4 = &kCFStreamSocketSecurityLevelSSLv3;
      return (SSLContext *)*v4;
    }

    goto LABEL_10;
  }

  return result;
}

uint64_t ___ZN12SocketStream19copyProperty_NoLockEPKvPK10__CFString_block_invoke( uint64_t a1, const char *a2, void *a3)
{
  CFTypeID v6 = (const void *)(*(void *)(a1 + 32) - 16LL);
  int v7 = CFGetAllocator(v6);
  CFStringRef v8 = CFStringCreateWithCString(v7, a2, 0x8000100u);
  uint64_t valuePtr = xpc_uint64_get_value(a3);
  uint64_t v9 = CFGetAllocator(v6);
  CFNumberRef v10 = CFNumberCreate(v9, kCFNumberCFIndexType, &valuePtr);
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), v8, v10);
  if (v8) {
    CFRelease(v8);
  }
  if (v10) {
    CFRelease(v10);
  }
  return 1LL;
}

uint64_t ___ZN12SocketStream26updateTCPAdaptiveParamtersEPK10__CFNumberS2__block_invoke_2@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 5943LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream26updateTCPAdaptiveParamtersEPK10__CFNumberS2__block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 5929LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t SocketStream::_SecurityReadFunc_NoLock( SocketStream *this, void *a2, size_t *a3, unint64_t *a4)
{
  int v7 = (char *)this - 16;
  CFRetain((char *)this - 16);
  size_t v8 = *a3;
  unsigned __int128 v28 = 0uLL;
  uint64_t v9 = (void *)*((void *)this + 65);
  if (v9)
  {
    uint64_t v11 = v9[2];
    size_t v10 = v9[3];
    size_t v12 = v8;
  }

  else
  {
    CFAllocatorRef v13 = CFGetAllocator(v7);
    uint64_t v9 = (void *)MEMORY[0x186E12804](v13, 32824LL, 0LL);
    bzero(v9, 0x8038uLL);
    CFAllocatorRef v14 = CFGetAllocator(v7);
    size_t v10 = 0LL;
    v9[4] = ((unint64_t)(v9 + 5) & 0xFFFFFFFFFFFFFFF0LL) + 16;
    *((_OWORD *)v9 + 1) = xmmword_182C9D7E0;
    void *v9 = &off_189C0A398;
    v9[1] = v14;
    *((void *)this + 65) = v9;
    size_t v12 = *a3;
    uint64_t v11 = 0x8000LL;
  }

  if (v10 >= v12)
  {
    *((_DWORD *)this + 62) |= 0x2000000u;
  }

  else
  {
    uint64_t v15 = SocketStream::recvBytes(this, (unsigned __int8 *)(v9[4] + v10), v11 - v10, (CFStreamError *)&v28);
    unint64_t v16 = *((_DWORD *)this + 62) & 0xFDFFFFFF | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
    *((_DWORD *)this + 62) &= ~0x2000000u;
    *((_WORD *)this + 126) = WORD2(v16);
    SInt32 v17 = DWORD2(v28);
    if (DWORD2(v28))
    {
      *a3 = 0LL;
      if (v17 == 35 && (void)v28 == 1LL)
      {
        BOOL v18 = (__CFSocket *)*((void *)this + 36);
        if (v18 && CFSocketIsValid(v18)) {
          CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
        }
        uint64_t v19 = 4294957493LL;
      }

      else
      {
        *((_OWORD *)this + CFRetain((char *)this - 16) = v28;
        uint64_t v19 = 4294957486LL;
      }

      goto LABEL_29;
    }

    size_t v20 = v15;
    CFAllocatorRef v21 = (CFAllocatorRef *)*((void *)this + 74);
    if (v21) {
      SSLDecoder::processBytes(v21, v21 + 3, (UInt8 *)(*(void *)(*((void *)this + 65) + 32LL) + v10), v20, "READ");
    }
    v10 += v20;
  }

  uint64_t v22 = *(char **)(*((void *)this + 65) + 32LL);
  if (*a3 >= v10) {
    size_t v23 = v10;
  }
  else {
    size_t v23 = *a3;
  }
  *a3 = v23;
  size_t v24 = v10 - v23;
  memmove(a2, v22, v23);
  memmove(v22, &v22[*a3], v24);
  bzero(&v22[v24], v11 - v24);
  *(void *)(*((void *)this + 65) + 24LL) = v24;
  if (*a3)
  {
    uint64_t v25 = (__CFSocket *)*((void *)this + 36);
    if (v25)
    {
      if (CFSocketIsValid(v25)) {
        CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 1uLL);
      }
    }
  }

  if (v8 == *a3) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = -9803;
  }
  if (*a3) {
    uint64_t v19 = v26;
  }
  else {
    uint64_t v19 = 4294957490LL;
  }
LABEL_29:
  CFRelease(v7);
  return v19;
}

uint64_t SocketStream::_SecurityWriteFunc_NoLock( CFAllocatorRef **this, unsigned __int8 *a2, size_t *a3, unint64_t *a4)
{
  int v7 = this - 2;
  CFRetain(this - 2);
  unsigned __int128 v16 = 0uLL;
  size_t v8 = *a3;
  uint64_t v9 = SocketStream::sendToSocket((SocketStream *)this, a2, *a3, (CFStreamError *)&v16);
  *a3 = v9;
  SInt32 v10 = DWORD2(v16);
  if (DWORD2(v16))
  {
    *a3 = 0LL;
    if (v10 == 35 && (void)v16 == 1LL)
    {
      uint64_t v12 = 4294957493LL;
    }

    else
    {
      *((_OWORD *)this + CFRetain((char *)this - 16) = v16;
      uint64_t v12 = 4294957486LL;
    }
  }

  else
  {
    size_t v13 = v9;
    CFAllocatorRef v14 = this[74];
    if (v14)
    {
      SSLDecoder::processBytes(v14, v14 + 2, a2, v13, "SENT");
      size_t v13 = *a3;
    }

    if (v8 == v13) {
      uint64_t v12 = 0LL;
    }
    else {
      uint64_t v12 = 4294957493LL;
    }
  }

  CFRelease(v7);
  return v12;
}

void SocketStream::_SecurityNPNFunc( SocketStream *this, SSLContext *a2, const UInt8 *a3, unint64_t a4)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  int v7 = (char *)a2 - 16;
  CFRetain((char *)a2 - 16);
  size_t v8 = (const __CFDictionary *)*((void *)a2 + 42);
  v26[0] = MEMORY[0x1895F87A8];
  v26[1] = 3221225472LL;
  __int128 v27 = ___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke;
  unsigned __int128 v28 = &__block_descriptor_40_e12_B24__0r_8Q16l;
  unsigned int v29 = this;
  uint64_t v30 = 0x2E312F7074746808LL;
  char v31 = 49;
  int Value = (const __CFArray *)CFDictionaryGetValue(v8, &unk_18C5AC6B0);
  if (Value)
  {
    SInt32 v10 = Value;
    CFIndex Count = CFArrayGetCount(Value);
    id alloc = (const __CFAllocator *)*MEMORY[0x189604DB0];
    if (a4)
    {
      uint64_t v12 = Count;
      theDict = v8;
      size_t v23 = v7;
      unint64_t v13 = 0LL;
      while (1)
      {
        CFIndex v14 = a3[v13];
        CFStringRef v15 = CFStringCreateWithBytes(alloc, &a3[v13 + 1], v14, 0x8000100u, 0);
        if (v12 < 1)
        {
LABEL_9:
          CFRelease(v15);
        }

        else
        {
          CFIndex v16 = 0LL;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v16);
            CFIndex Length = CFStringGetLength(v15);
            if (Length == CFStringGetLength(ValueAtIndex)
              && CFStringCompare(v15, ValueAtIndex, 1uLL) == kCFCompareEqualTo)
            {
              break;
            }

            if (v12 == ++v16) {
              goto LABEL_9;
            }
          }

          char v19 = ((uint64_t (*)(void *, const UInt8 *, CFIndex))v27)(v26, &a3[v13 + 1], v14);
          CFRelease(v15);
          if ((v19 & 1) != 0)
          {
            CFDictionarySetValue(theDict, &unk_18C5AC6E8, ValueAtIndex);
            int v7 = v23;
            goto LABEL_19;
          }
        }

        v13 += v14 + 1;
        if (v13 >= a4)
        {
          size_t v8 = theDict;
          int v7 = v23;
          ((void (*)(void *, uint64_t *, uint64_t))v27)(v26, &v30, 9LL);
          goto LABEL_15;
        }
      }
    }

    ((void (*)(void *, uint64_t *, uint64_t))___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke)( v26,  &v30,  9LL);
LABEL_15:
    CFStringRef v20 = CFStringCreateWithBytes(alloc, (const UInt8 *)&v30 + 1, 8LL, 0x8000100u, 0);
    if (v20)
    {
      CFStringRef v21 = v20;
      CFDictionarySetValue(v8, &unk_18C5AC6E8, v20);
      CFRelease(v21);
    }

    else
    {
      CFDictionarySetValue(v8, &unk_18C5AC6E8, &stru_189C1D1D8);
    }
  }

  else
  {
    ___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke();
  }

void SocketStream::_SecurityALPNFunc( SocketStream *this, CFMutableDictionaryRef *a2, const UInt8 *a3, const void *a4)
{
  CFTypeID v6 = a2 - 2;
  CFRetain(a2 - 2);
  if (a3)
  {
    CFStringRef v7 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x189604DB0], a3 + 1, *(char *)a3, 0x600u, 0);
    CFDictionarySetValue(a2[42], &unk_18C5AC6E8, v7);
    CFRelease(v7);
  }

  else
  {
    CFDictionarySetValue(a2[42], &unk_18C5AC6E8, &stru_189C1D1D8);
  }

  CFRelease(v6);
}

BOOL ___ZN12SocketStream16_SecurityNPNFuncEP10SSLContextPvPKvm_block_invoke()
{
  return SSLSetNPNData() == 0;
}

void CFBufferConstantSize<32768l>::~CFBufferConstantSize(CFAllocatorRef *ptr)
{
}

uint64_t setTLSMaxVersion_ifNeeded( CFStringRef theString2, SSLContext *a2, const __CFNumber *a3, SSLProtocol a4)
{
  if (a3 || CFStringCompare((CFStringRef)*MEMORY[0x18960B7F8], theString2, 0LL)) {
    return 0LL;
  }
  else {
    return SSLSetProtocolVersionMax(a2, a4);
  }
}

void ___ZN12SocketStream5closeEPKv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  if (*(_BYTE *)(v1 + 544))
  {
    *(_BYTE *)(v1 + 544) = 0;
    CFRelease((CFTypeRef)(v1 - 16));
  }

  if (*(_BYTE *)(v1 + 636))
  {
    *(_BYTE *)(v1 + 636) = 0;
    entr_act_end_delayInitStub(v2);
  }

  SSLProtocol v3 = *(dispatch_source_s **)(v1 + 384);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v1 + 384));
    *(void *)(v1 + 384) = 0LL;
  }

  CFTypeID v4 = *(dispatch_source_s **)(v1 + 392);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(v1 + 392));
    *(void *)(v1 + 392) = 0LL;
  }

  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));
  CFRelease((CFTypeRef)(v1 - 16));
}

CFTypeRef ___ZN12SocketStream4openEPKvP13CFStreamErrorPh_block_invoke(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (cf) {
    CFTypeRef result = CFRetain(cf);
  }
  else {
    CFTypeRef result = 0LL;
  }
  *(void *)(v2 + 240) = result;
  return result;
}

uint64_t SocketStream::attemptNextConnection_NoLock(SocketStream *this)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  __int128 v32 = *((_OWORD *)this + 19);
  uint64_t v33 = *((void *)this + 40);
  if (*((void *)this + 36)) {
    goto LABEL_2;
  }
  uint64_t result = (uint64_t)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5ADD70);
  if (!result)
  {
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
    int v29 = 22;
LABEL_37:
    *((_DWORD *)this + 66) = v29;
    return result;
  }

  SSLProtocol v3 = (const __CFData *)result;
  context.version = 0LL;
  context.uint64_t info = (char *)this - 16;
  context.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1896030F0];
  context.release = (void (__cdecl *)(const void *))MEMORY[0x1896030E0];
  context.copyDescription = (CFStringRef (__cdecl *)(const void *))MEMORY[0x189602A10];
  CFTypeID v4 = CFGetAllocator((char *)this - 16);
  BytePtr = (CFSocketNativeHandle *)CFDataGetBytePtr(v3);
  CFSocketRef v6 = CFSocketCreateWithNative(v4, *BytePtr, 0xDuLL, (CFSocketCallBack)SocketStream::_SocketCallBack_stream, &context);
  *((void *)this + 36) = v6;
  if (!v6)
  {
    uint64_t v30 = __error();
    uint64_t result = 0LL;
    int v29 = *v30;
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
    if (!v29) {
      int v29 = 12;
    }
    goto LABEL_37;
  }

  CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 42), &unk_18C5ADD70);
LABEL_2:
  if (*((void *)this + 69)) {
    tcp_connection_set_traffic_class();
  }
  *((_DWORD *)this + 62) = *((_DWORD *)this + 62) & 0xFFFFF7ED | 2;
  CFStringRef v7 = (__CFSocket *)*((void *)this + 36);
  LODWORD(context.version) = 1;
  CFSocketNativeHandle Native = CFSocketGetNative(v7);
  setsockopt(Native, 0xFFFF, 4130, &context, 4u);
  uint64_t v9 = (__CFSocket *)*((void *)this + 36);
  LODWORD(context.version) = 1;
  CFSocketNativeHandle v10 = CFSocketGetNative(v9);
  ioctl(v10, 0x8004667EuLL, &context);
  if (*((_DWORD *)this + 100) == 1)
  {
    uint64_t v11 = (__CFSocket *)*((void *)this + 36);
    LODWORD(context.version) = 1;
    CFSocketNativeHandle v12 = CFSocketGetNative(v11);
    setsockopt(v12, 0xFFFF, 4357, &context, 4u);
  }

  CFOptionFlags v13 = CFSocketGetSocketFlags(*((CFSocketRef *)this + 36)) & 0xFFFFFFFFFFFFFF76LL;
  int Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5ADD00);
  else {
    CFOptionFlags v16 = v13;
  }
  CFSocketSetSocketFlags(*((CFSocketRef *)this + 36), v16);
  CFSocketEnableCallBacks(*((CFSocketRef *)this + 36), 0xDuLL);
  for (uint64_t i = 0LL; i != 24; i += 8LL)
    _CFTypeScheduleOnMultipleRunLoops(*((void **)this + 36), *(const __CFArray **)((char *)&v32 + i));
  Schedulables::_add(*((Schedulables **)this + 41), *((const void **)this + 36));
  BOOL v18 = CFGetAllocator(*((CFTypeRef *)this + 36));
  CFRunLoopSourceRef RunLoopSource = CFSocketCreateRunLoopSource(v18, *((CFSocketRef *)this + 36), 0LL);
  if (RunLoopSource)
  {
    CFStringRef v20 = RunLoopSource;
    for (uint64_t j = 0LL; j != 3; ++j)
    {
      uint64_t v22 = (const __CFArray *)*((void *)&v32 + j);
      if (v22)
      {
        CFIndex Count = CFArrayGetCount(*((CFArrayRef *)&v32 + j));
        if (Count >= 1)
        {
          CFIndex v24 = Count;
          for (CFIndex k = 0LL; k < v24; k += 2LL)
          {
            ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v22, k);
            if (CFRunLoopIsWaiting(ValueAtIndex))
            {
              __int128 v27 = CFRunLoopCopyCurrentMode(ValueAtIndex);
              if (v27)
              {
                unsigned __int128 v28 = v27;
                if (CFRunLoopContainsSource(ValueAtIndex, v20, v27)) {
                  CFRunLoopWakeUp(ValueAtIndex);
                }
                CFRelease(v28);
              }
            }
          }
        }
      }
    }

    CFRelease(v20);
  }

  SocketStream::touchWatchdogTimer_Locked(this, 0);
  return 1LL;
}

void SocketStream::_SocketCallBack_stream( SocketStream *this, __CFSocket *a2, unint64_t a3, const __CFData *a4, char *cf, void *a6)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (cf)
  {
    CFRetain(cf);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    if ((*((_DWORD *)cf + 66) & 0x800) != 0)
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      goto LABEL_12;
    }

    if (*((SocketStream **)cf + 38) != this && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v40[0]) = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "What socket signalled us?",  (uint8_t *)v40,  2u);
    }

    uint64_t v44 = 0LL;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    *(_OWORD *)unint64_t v40 = 0u;
    *(_OWORD *)cfa = 0u;
    if (*((_DWORD *)cf + 70))
    {
LABEL_9:
      SocketStream::prepareSignalFromSocketCallbackLocked((SocketStream *)(cf + 16), (SocketStreamSignalHolder *)v40);
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      SocketStream::dispatchSignalFromSocketCallbackUnlocked((CFRunLoopSourceRef *)v40, v10);
      SocketStreamSignalHolder::~SocketStreamSignalHolder((SocketStreamSignalHolder *)v40);
LABEL_12:
      CFRelease(cf);
      return;
    }

    uint64_t v11 = cf + 264;
    if (a2 == (__CFSocket *)1)
    {
      SocketStream::socketCallbackReadLocked((SocketStream *)(cf + 16), (SocketStreamSignalHolder *)v40);
      if ((*v11 & 0x28000LL) != 0x8000) {
        goto LABEL_9;
      }
    }

    else if (a2 != (__CFSocket *)8)
    {
      if (a2 == (__CFSocket *)4)
      {
        uint64_t v12 = *v11;
        unint64_t v13 = v12 & 0xFFFFFFFFEFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
        *uint64_t v11 = v12 & 0xEFFFFFFF;
        if (a4 && (int v14 = *(_DWORD *)a4) != 0)
        {
          *(_OWORD *)size_t processed = *((_OWORD *)cf + 20);
          CFStringRef v15 = (Schedulables *)*((void *)cf + 43);
          uint64_t v46 = *((void *)cf + 42);
          *((_DWORD *)cf + 70) = v14;
          *((void *)cf + 34) = 1LL;
          Schedulables::_remove(v15, *((const void **)cf + 38));
          for (uint64_t i = 0LL; i != 3; ++i)
            _CFTypeUnscheduleFromMultipleRunLoops(*((void **)cf + 38), (const __CFArray *)processed[i]);
          _CFTypeInvalidate(*((char **)cf + 38));
          SInt32 v17 = (const void *)*((void *)cf + 38);
          *((void *)cf + 38) = 0LL;
          if (v17) {
            CFRelease(v17);
          }
          if (SocketStream::attemptNextConnection_NoLock((SocketStream *)(cf + 16)))
          {
            *((void *)cf + 34) = 0LL;
            *((void *)cf + 35) = 0LL;
          }
        }

        else
        {
          if (*((void *)cf + 71))
          {
            tcp_connection_set_traffic_class();
            unint64_t v13 = *v11 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
          }

          *((_WORD *)cf + 134) = WORD2(v13);
          *uint64_t v11 = v13 & 0xFFFFFFEC | 2;
          v40[0] = (CFTypeRef)1;
          id WeakRetained = objc_loadWeakRetained((id *)cf + 36);
          if (v40[1]) {
            CFRelease(v40[1]);
          }
          v40[1] = WeakRetained;
          id v34 = objc_loadWeakRetained((id *)cf + 37);
          if (cfa[0]) {
            CFRelease(cfa[0]);
          }
          cfa[0] = v34;
          if (*((void *)cf + 29))
          {
            uint64_t Native = CFSocketGetNative(*((CFSocketRef *)cf + 38));
            SocketStream::setLoggerPrefixWithNativeHandle((SocketStream *)(cf + 16), Native);
          }
        }
      }

      goto LABEL_9;
    }

    unsigned int v18 = *((_DWORD *)cf + 107);
    if (v18)
    {
      for (uint64_t j = 0LL; j != 8; ++j)
      {
        if (((v18 >> j) & 1) != 0) {
          break;
        }
      }

      SocketStream::performHandshake((uint64_t)(cf + 16));
      goto LABEL_9;
    }

    uint64_t v20 = *v11;
    unint64_t v21 = v20 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
    if ((v20 & 0x4000) == 0)
    {
      uint64_t v22 = *((void *)cf + 68);
      if (v22 && (uint64_t v23 = *(void *)(v22 + 24), v23 >= 1) && ((v21 & 0x800000) == 0 || *(void *)(v22 + 16) == v23))
      {
        SocketStream::flushTransmissionBuffer_NoLock((CFStreamError *)cf + 1);
      }

      else
      {
        unint64_t v31 = v21 & 0xFFFFFFFFFFFFFFBFLL;
        *((_WORD *)cf + 134) = WORD2(v31);
        *uint64_t v11 = v31 | 8;
        v40[0] = (CFTypeRef)4;
        id v32 = objc_loadWeakRetained((id *)cf + 37);
        if (cfa[0]) {
          CFRelease(cfa[0]);
        }
        cfa[0] = v32;
      }

      goto LABEL_9;
    }

    int v24 = *((_DWORD *)cf + 70);
    if (!v24 || (uint64_t v25 = *((void *)cf + 34), v24 == 35) && v25 == 1 || v24 == -9803 && v25 == *MEMORY[0x1896051C0])
    {
      uint64_t v26 = SSLWrite(*((SSLContextRef *)cf + 39), 0LL, 0LL, processed);
      int v27 = v26;
      if ((_DWORD)v26 != -9803 && (_DWORD)v26)
      {
        int v28 = translateSSLContextError(*((SSLContext **)cf + 39), v26);
        *((void *)cf + 34) = (int)*MEMORY[0x1896051C0];
        *((_DWORD *)cf + 70) = v28;
      }

      if (v27 == -9803)
      {
        int v29 = (__CFSocket *)*((void *)cf + 38);
        if (!v29 || !CFSocketIsValid(v29)) {
          goto LABEL_9;
        }
        CFOptionFlags v30 = 8LL;
        goto LABEL_67;
      }
    }

    uint64_t v36 = *v11;
    unint64_t v37 = v36 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
    if ((v36 & 0x2000) == 0 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      LOWORD(processed[0]) = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "we're blocked on SSLWrite, so we must be using SSL",  (uint8_t *)processed,  2u);
      uint64_t v39 = *v11;
      unint64_t v37 = v39 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
      if ((v39 & 2) == 0)
      {
LABEL_62:
        if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
        {
          LOWORD(processed[0]) = 0;
          _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "we've written bytes, so the socket must have been opened",  (uint8_t *)processed,  2u);
          unint64_t v37 = *v11 | ((unint64_t)*((unsigned __int16 *)cf + 134) << 32);
        }
      }
    }

    else if ((v37 & 2) == 0)
    {
      goto LABEL_62;
    }

    *uint64_t v11 = v37 & 0xFFFFBFFF;
    *((_WORD *)cf + 134) = (v37 & 0xFFFFFFFFFFFFBFFFLL) >> 32;
    BOOL v38 = (__CFSocket *)*((void *)cf + 38);
    if (!v38 || !CFSocketIsValid(v38)) {
      goto LABEL_9;
    }
    CFOptionFlags v30 = 9LL;
LABEL_67:
    CFSocketEnableCallBacks(*((CFSocketRef *)cf + 38), v30);
    goto LABEL_9;
  }

void sub_182AB9450( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void SocketStream::setLoggerPrefixWithNativeHandle(SocketStream *this, uint64_t a2)
{
  v13[19] = *MEMORY[0x1895F89C0];
  CFTypeID v4 = (char *)this - 16;
  CFNumberRef v5 = CFGetAllocator((char *)this - 16);
  v13[0] = off_189C1A178;
  v13[1] = createStringFromSomeAddr( v5,  (int (*)(int, sockaddr *, unsigned int *))MEMORY[0x1895FB6D0],  "local",  a2);
  v13[2] = 0LL;
  v13[3] = 0LL;
  CFSocketRef v6 = CFGetAllocator(v4);
  v12[0] = off_189C1A178;
  v12[1] = createStringFromSomeAddr( v6,  (int (*)(int, sockaddr *, unsigned int *))MEMORY[0x1895FB610],  "peer",  a2);
  v12[2] = 0LL;
  v12[3] = 0LL;
  if (*((void *)this + 69))
  {
    CFStringRef v7 = &v11;
    tcp_connection_get_hostname();
  }

  else
  {
    CFStringRef v7 = "";
  }

  uint64_t v8 = *((void *)this + 27);
  CString = (const char *)AutoString::getCString((AutoString *)v13);
  CFSocketNativeHandle v10 = (const char *)AutoString::getCString((AutoString *)v12);
  *(_DWORD *)(v8 + 8) = a2;
  snprintf((char *)(v8 + 12), 0x100uLL, "{ fd: %d, local %s => peer %s %s}", a2, CString, v10, v7);
  AutoString::~AutoString((AutoString *)v12);
  AutoString::~AutoString((AutoString *)v13);
}

void sub_182AB9598(_Unwind_Exception *a1)
{
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_5653()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  dword_18C5B2D48 = 1835099506;
  _PNAME<SocketStream>::GET(void)::p = *(void *)"SocketStream>::GET() [OBJTYPE = SocketStream]";
  CFClass::CFClass(v0, (const char *)&_PNAME<SocketStream>::GET(void)::p);
  TCFObject<SocketStream>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182AB9610(_Unwind_Exception *a1)
{
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_UserInteractive", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInteractiveTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_2(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_UserInitiated", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUserInitiatedTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_3(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_Default", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sDefaultTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_4(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_Utility", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUtilityTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_5(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_Background", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sBackgroundTCPConnWorkQueue = (uint64_t)result;
  return result;
}

dispatch_queue_t ___ZL37copyGlobalTCPConnWorkQueueForQOSClass11qos_class_t_block_invoke_6(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue_Unspecified", *(dispatch_queue_attr_t *)(a1 + 32));
  copyGlobalTCPConnWorkQueueForQOSClass(qos_class_t)::sUnspecifiedTCPConnWorkQueue = (uint64_t)result;
  return result;
}

uint64_t copyGlobalTCPConnWorkQueue(void)
{
  return copyGlobalTCPConnWorkQueue(void)::sTCPConnWorkQueue;
}

void SocketStream::startTCPConnection(SocketStream *this)
{
  v71[128] = *MEMORY[0x1895F89C0];
  tcp_connection_allow_client_socket_access();
  uint64_t v2 = (nw_parameters *)tcp_connection_copy_parameters();
  uint64_t v3 = MEMORY[0x1895F87A8];
  uint64_t v65 = MEMORY[0x1895F87A8];
  uint64_t v66 = 3221225472LL;
  CFMutableDataRef v67 = ___ZN12SocketStream18startTCPConnectionEh_block_invoke;
  OSStatus v68 = &__block_descriptor_40_e13_v20__0I8r_v12l;
  size_t v69 = this;
  tcp_connection_set_event_handler();
  uint64_t v4 = *((void *)this + 69);
  uint64_t v60 = v3;
  uint64_t v61 = 3221225472LL;
  CFRange v62 = ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2;
  uint64_t v63 = &unk_189C1A548;
  uint64_t v64 = v4;
  tcp_connection_set_cancel_handler();
  int Value = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AD750);
  CFSocketRef v6 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC020);
  if (Value && !CFBooleanGetValue(Value) || v6 && !CFBooleanGetValue(v6)) {
    tcp_connection_set_no_expensive();
  }
  CFStringRef v7 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AD718);
  uint64_t v8 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5ABFE8);
  if (v2)
  {
    if ((uint64_t v9 = v8, v7) && !CFBooleanGetValue(v7) || v9 && !CFBooleanGetValue(v9)) {
      nw_parameters_set_prohibit_constrained(v2, 1);
    }
  }

  CFSocketNativeHandle v10 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC058);
  if (v2 && v10 && CFBooleanGetValue(v10)) {
    nw_parameters_set_allow_ultra_constrained();
  }
  char v11 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC090);
  if (v2 && v11)
  {
    if (CFBooleanGetValue(v11)) {
      removeProhibitedNetworkType((uint64_t)v2, 0);
    }
    else {
      addProhibitedNetworkType((uint64_t)v2, 0);
    }
  }

  uint64_t v12 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC3A0);
  unint64_t v13 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC368);
  if ((unint64_t)v12 | (unint64_t)v13)
  {
    if (v12) {
      CFBooleanGetValue(v12);
    }
    if (v13) {
      CFBooleanGetValue(v13);
    }
    tcp_connection_override_obscure();
  }

  int v14 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC678);
  if (v14)
  {
    int v15 = CFBooleanGetValue(v14);
    if (v2)
    {
      if (v15) {
        addProhibitedNetworkSubtype((uint64_t)v2, 0x1389u);
      }
    }
  }

  CFOptionFlags v16 = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC5D0);
  if (v2)
  {
    if (v16)
    {
      if (CFNumberGetValue(v16, kCFNumberIntType, valuePtr))
      {
        SInt32 v17 = nw_parameters_copy_default_protocol_stack(v2);
        unsigned int v18 = v17;
        if (v17)
        {
          char v19 = nw_protocol_stack_copy_internet_protocol(v17);
          uint64_t v20 = v19;
          if (v19)
          {
            nw_ip_options_set_local_address_preference(v19, *(nw_ip_local_address_preference_t *)valuePtr);
            nw_release(v20);
          }

          nw_release(v18);
        }
      }
    }
  }

  unint64_t v21 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AC790);
  if (v21)
  {
    int v22 = CFBooleanGetValue(v21);
    if (v2)
    {
      if (v22) {
        addProhibitedNetworkSubtype((uint64_t)v2, 0x3E9u);
      }
    }
  }

  tcp_connection_set_no_cellular();
  uint64_t v23 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AD8A0);
  if (v23)
  {
    CFBooleanGetValue(v23);
    tcp_connection_set_no_fallback();
  }

  int v24 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AD8D8);
  if (v24)
  {
    CFBooleanGetValue(v24);
    tcp_connection_set_fallback_fast();
  }

  uint64_t v25 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5ADD38);
  if (v25)
  {
    CFBooleanGetValue(v25);
    tcp_connection_set_extended_background_idle();
  }

  tcp_connection_set_persistent();
  uint64_t v26 = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AD0C0);
  if (v26)
  {
    CFBooleanGetValue(v26);
    tcp_connection_set_ecn_enabled();
  }

  if (*((_BYTE *)this + 406)) {
    tcp_connection_set_receive_any_interface();
  }
  if (*((void *)this + 67))
  {
    CFAllocatorRef v27 = CFGetAllocator((char *)this - 16);
    int v28 = (const __CFString *)*((void *)this + 67);
    *(void *)uint64_t valuePtr = v27;
    *(void *)&void valuePtr[8] = 1023LL;
    if (v28)
    {
      *(void *)&valuePtr[16] = _CFStringGetOrCreateCString( (uint64_t)v27,  v28,  (UInt8 *)v71,  (uint64_t *)&valuePtr[8],  0x8000100u);
      if (!*(void *)&valuePtr[16]) {
        goto LABEL_62;
      }
    }

    else
    {
      LOBYTE(v71[0]) = 0;
      *(void *)&void valuePtr[8] = 0LL;
      *(void *)&valuePtr[16] = v71;
    }

    tcp_connection_set_interface_by_name();
    if (*(void *)&valuePtr[16] && v71 != *(void **)&valuePtr[16]) {
      CFAllocatorDeallocate(*(CFAllocatorRef *)valuePtr, *(void **)&valuePtr[16]);
    }
  }

void sub_182ABA1C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, CFAllocatorRef allocator, uint64_t a32, void *ptr)
{
  if (v33) {
    nw_release(v33);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN12SocketStream25startLookupForOpen_NoLockEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(SocketStream **)(a1 + 32);
  SocketStream::_onqueue_completeTCPConnection(v1);
  CFRelease((char *)v1 - 16);
}

uint64_t SocketStream::startTCPConnection_Proxy_Connect(SocketStream *this, const __CFDictionary *a2)
{
  uint64_t v4 = CFGetAllocator((char *)this - 16);
  int Value = (const __CFString *)CFDictionaryGetValue(a2, &unk_18C5B2488);
  CFSocketRef v6 = CFHostCreateWithName(v4, Value);
  CFStringRef v7 = (const __CFNumber *)CFDictionaryGetValue(a2, &unk_18C5B24C0);
  if (v6)
  {
    uint64_t started = SocketStream::startTCPConnection_Host(this, v6, v7);
    CFRelease(v6);
    return started;
  }

  else
  {
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
    *((_DWORD *)this + 66) = 22;
    return 0LL;
  }

uint64_t SocketStream::startTCPConnection_Host(SocketStream *this, __CFHost *a2, const __CFNumber *a3)
{
  v26[128] = *MEMORY[0x1895F89C0];
  Info = (const __CFArray *)CFHostGetInfo((uint64_t)a2, 0, 0LL);
  CFTypeRef v7 = CFHostGetInfo((uint64_t)a2, 1, 0LL);
  if (!((unint64_t)Info | (unint64_t)v7))
  {
    uint64_t result = 0LL;
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
    int v14 = 22;
LABEL_15:
    *((_DWORD *)this + 66) = v14;
    return result;
  }

  uint64_t v8 = (const __CFArray *)v7;
  __int16 valuePtr = 0;
  if (a3) {
    CFNumberGetValue(a3, kCFNumberSInt16Type, &valuePtr);
  }
  if (v8 && CFArrayGetCount(v8) >= 1 && (uint64_t v9 = (const __CFString *)CFArrayGetValueAtIndex(v8, 0LL), (v10 = v9) != 0LL))
  {
    if (hostnameIsValid(v9))
    {
      CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
      uint64_t v24 = 1023LL;
      ptr = _CFStringGetOrCreateCString((uint64_t)allocator, v10, (UInt8 *)v26, &v24, 0x8000100u);
      *((void *)this + 69) = tcp_connection_create();
      char v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_87_5661, 2);
      uint64_t v12 = v11;
      if (v11
        && (*(unsigned int (**)(void *, const char *, void))(*(void *)v11 + 16LL))( v11,  "TCP Connection Created",  0LL))
      {
        (*(void (**)(void *, const char *, const __CFString *))(*(void *)v12 + 72LL))( v12,  "conn",  @"%p for name %s, port %d");
        (*(void (**)(void *))(*(void *)v12 + 8LL))(v12);
      }

      if (ptr && v26 != ptr) {
        CFAllocatorDeallocate(allocator, ptr);
      }
    }

    else
    {
      unsigned int v18 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_91, 2);
      char v19 = v18;
      if (v18
        && (*(unsigned int (**)(void *, const char *, void))(*(void *)v18 + 16LL))( v18,  "TCP Connection Not Created - invalid host name",  0LL))
      {
        uint64_t v20 = (const __CFAllocator *)*MEMORY[0x189604DB0];
        CFAllocatorRef allocator = (CFAllocatorRef)off_189C1A178;
        CFStringRef v21 = CFStringCreateWithCString(v20, "host", 0x8000100u);
        ptr = 0LL;
        v26[0] = 0LL;
        uint64_t v24 = (uint64_t)v21;
        (*(void (**)(void *))(*(void *)v19 + 64LL))(v19);
        AutoString::~AutoString((AutoString *)&allocator);
        (*(void (**)(void *))(*(void *)v19 + 8LL))(v19);
      }

      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 12LL;
      *((_DWORD *)this + 66) = 1;
    }
  }

  else if (Info)
  {
    if (CFArrayGetCount(Info) >= 1)
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Info, 0LL);
      if (ValueAtIndex)
      {
        if (CFDataGetBytePtr(ValueAtIndex))
        {
          *((void *)this + 69) = tcp_connection_create_with_sockaddr();
          CFOptionFlags v16 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_94, 2);
          SInt32 v17 = v16;
          if (v16)
          {
            if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v16 + 16LL))( v16,  "TCP Connection Created",  0LL))
            {
              (*(void (**)(void *, const char *, const __CFString *))(*(void *)v17 + 72LL))( v17,  "conn",  @"%p for sockaddr %@");
              (*(void (**)(void *))(*(void *)v17 + 8LL))(v17);
            }
          }
        }
      }
    }
  }

  if (*((void *)this + 69))
  {
    SocketStream::startTCPConnection(this);
    return 1LL;
  }

  if (!*((_DWORD *)this + 66))
  {
    uint64_t result = 0LL;
    if (valuePtr) {
      int v14 = 12;
    }
    else {
      int v14 = 49;
    }
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
    goto LABEL_15;
  }

  return 0LL;
}

void sub_182ABA748( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFAllocatorRef allocator, uint64_t a14, void *ptr)
{
}

uint64_t SocketStream::startTCPConnection_NetService(SocketStream *this, __CFNetService *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  Info = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 2u);
  CFNumberRef v5 = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 4u);
  CFSocketRef v6 = (const __CFString *)CFNetServiceGetInfo((uint64_t)a2, 0);
  if (Info && v5 && (CFTypeRef v7 = v6) != 0LL)
  {
    CFAllocatorRef v26 = CFGetAllocator((char *)this - 16);
    uint64_t v27 = 1023LL;
    int v28 = _CFStringGetOrCreateCString((uint64_t)v26, Info, v29, &v27, 0x8000100u);
    CFAllocatorRef v22 = CFGetAllocator((char *)this - 16);
    uint64_t v23 = 1023LL;
    uint64_t v24 = _CFStringGetOrCreateCString((uint64_t)v22, v5, v25, &v23, 0x8000100u);
    CFAllocatorRef allocator = CFGetAllocator((char *)this - 16);
    uint64_t v19 = 1023LL;
    ptr = _CFStringGetOrCreateCString((uint64_t)allocator, v7, v21, &v19, 0x8000100u);
    *((void *)this + 69) = tcp_connection_create_with_service();
    uint64_t v8 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_97_5655, 2);
    uint64_t v9 = v8;
    if (v8
      && (*(unsigned int (**)(void *, const char *, void))(*(void *)v8 + 16LL))( v8,  "TCP Connection Created",  0LL))
    {
      (*(void (**)(void *, const char *, const __CFString *))(*(void *)v9 + 72LL))( v9,  "conn",  @"%p for netservice %s %s %s");
      (*(void (**)(void *))(*(void *)v9 + 8LL))(v9);
    }

    if (*((void *)this + 69))
    {
      CFSocketNativeHandle v10 = (const __CFBoolean *)CFNetServiceGetInfo((uint64_t)a2, 7u);
      if (v10 && CFBooleanGetValue(v10)) {
        tcp_connection_override_obscure();
      }
      char v11 = (const __CFBoolean *)CFNetServiceGetInfo((uint64_t)a2, 9u);
      if (v11 && CFBooleanGetValue(v11)) {
        tcp_connection_override_obscure();
      }
    }

    else
    {
      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 10LL;
      *((_DWORD *)this + 66) = -72004;
    }

    if (ptr && v21 != ptr) {
      CFAllocatorDeallocate(allocator, ptr);
    }
    if (v24 && v25 != v24) {
      CFAllocatorDeallocate(v22, v24);
    }
    if (v28 && v29 != v28) {
      CFAllocatorDeallocate(v26, v28);
    }
  }

  else
  {
    uint64_t v12 = (const __CFArray *)CFNetServiceGetInfo((uint64_t)a2, 3u);
    if (!v12) {
      goto LABEL_21;
    }
    unint64_t v13 = v12;
    if (CFArrayGetCount(v12) < 1) {
      goto LABEL_21;
    }
    ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v13, 0LL);
    if (!ValueAtIndex) {
      goto LABEL_21;
    }
    CFDataGetBytePtr(ValueAtIndex);
    *((void *)this + 69) = tcp_connection_create_with_sockaddr();
    int v15 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_100, 2);
    if (v15)
    {
      CFOptionFlags v16 = v15;
      if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v15 + 16LL))( v15,  "TCP Connection Created",  0LL))
      {
        (*(void (**)(void *, const char *, const __CFString *))(*(void *)v16 + 72LL))( v16,  "conn",  @"%p for sockaddr %@");
        (*(void (**)(void *))(*(void *)v16 + 8LL))(v16);
      }
    }

    if (!*((void *)this + 69))
    {
LABEL_21:
      *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 10LL;
      *((_DWORD *)this + 66) = -72004;
    }
  }

  if (!*((void *)this + 69)) {
    return 0LL;
  }
  SocketStream::startTCPConnection(this);
  return 1LL;
}

void sub_182ABAB18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const __CFAllocator *allocator, uint64_t a14, void *ptr)
{
  if (ptr && v17 != ptr) {
    CFAllocatorDeallocate(allocator, ptr);
  }
  uint64_t v19 = (void *)STACK[0x448];
  if (STACK[0x448] && v16 != v19) {
    CFAllocatorDeallocate((CFAllocatorRef)STACK[0x438], v19);
  }
  uint64_t v20 = (void *)STACK[0x860];
  if (STACK[0x860])
  {
    if (v15 != v20) {
      CFAllocatorDeallocate((CFAllocatorRef)STACK[0x850], v20);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t ___ZN12SocketStream29startTCPConnection_NetServiceEP14__CFNetService_block_invoke_2@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 4552LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream29startTCPConnection_NetServiceEP14__CFNetService_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 4529LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke_3@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 4489LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke_2@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 4474LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream23startTCPConnection_HostEP8__CFHostPK10__CFNumber_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 4470LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

void SocketStream::_SocksHostCallBack( SocketStream *this, __CFHost *a2, const __CFString *a3, char *cf, void *a5)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (cf)
  {
    CFRetain(cf);
    if (a2 != (__CFHost *)&unk_18C5B16F8) {
      goto LABEL_5;
    }
    uint64_t v8 = (pthread_mutex_t *)(cf + 56);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    int Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 44), &unk_18C5ADEF8);
    CFSocketNativeHandle v10 = (const __CFString *)CFDictionaryGetValue(Value, (const void *)*MEMORY[0x1896051F8]);
    CFStreamError number = (const __CFNumber *)CFDictionaryGetValue(*((CFDictionaryRef *)cf + 44), &unk_18C5ADE50);
    Schedulables::_remove(*((Schedulables **)cf + 43), this);
    _CFTypeInvalidate((char *)this);
    uint64_t v11 = 0LL;
    __int128 v34 = *((_OWORD *)cf + 20);
    uint64_t v35 = *((void *)cf + 42);
    do
    {
      _CFTypeUnscheduleFromMultipleRunLoops(this, *(const __CFArray **)((char *)&v34 + v11));
      v11 += 8LL;
    }

    while (v11 != 24);
    Info = (const __CFArray *)CFHostGetInfo((uint64_t)this, 0, 0LL);
    unint64_t v13 = Info;
    if (Info && CFArrayGetCount(Info))
    {
      ValueAtIndex = 0LL;
      if (!v10) {
        goto LABEL_12;
      }
    }

    else
    {
      SInt32 v17 = (const __CFArray *)CFHostGetInfo((uint64_t)this, 1, 0LL);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v17, 0LL);
      if (!v10)
      {
LABEL_12:
        CFIndex Bytes = 0LL;
        if (!ValueAtIndex)
        {
LABEL_13:
          CFIndex v16 = 0LL;
          goto LABEL_17;
        }

void SocketStream::_onqueue_completeTCPConnection(SocketStream *this)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (dispatch_source_s *)*((void *)this + 49);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*((dispatch_object_t *)this + 49));
    *((void *)this + 49) = 0LL;
  }

  uint64_t v3 = (*(uint64_t (**)(SocketStream *))(*(void *)this + 184LL))(this);
  if (v3)
  {
    uint64_t v4 = v3;
    CFRetain((char *)this - 16);
    int Value = (const __CFBoolean *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5ABBF8);
    if (Value && CFBooleanGetValue(Value))
    {
      CFSocketRef v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      CFStringRef v7 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"SocketStream %p", this);
      int v16 = 60;
      int valuePtr = 255;
      *(_OWORD *)keys = xmmword_189C0A2A8;
      __int128 v20 = *(_OWORD *)off_189C0A2B8;
      CFStringRef v21 = @"TimeoutAction";
      values[0] = (void *)CFRetain(@"PreventUserIdleSystemSleep");
      values[1] = CFNumberCreate(v6, kCFNumberIntType, &valuePtr);
      if (v7) {
        CFTypeRef v8 = CFRetain(v7);
      }
      else {
        CFTypeRef v8 = 0LL;
      }
      values[2] = (void *)v8;
      values[3] = CFNumberCreate(v6, kCFNumberIntType, &v16);
      values[4] = (void *)CFRetain(@"TimeoutActionTurnOff");
      uint64_t v9 = CFDictionaryCreate( v6,  (const void **)keys,  (const void **)values,  5LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      for (uint64_t i = 0LL; i != 5; ++i)
      {
        uint64_t v11 = values[i];
        if (v11) {
          CFRelease(v11);
        }
      }

      IOPMAssertionCreateWithProperties(v9, (IOPMAssertionID *)this + 151);
      if (v9) {
        CFRelease(v9);
      }
      if (v7) {
        CFRelease(v7);
      }
    }

    (*(void (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
    uint64_t v12 = (dispatch_object_s *)*((void *)this + 70);
    dispatch_retain(v12);
    uint64_t v13 = *((void *)this + 69);
    tcp_connection_retain();
    uint64_t v14 = *((void *)this + 69);
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke;
    v15[3] = &unk_189C09D98;
    v15[6] = this;
    v15[7] = v4;
    v15[4] = v12;
    v15[5] = v13;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v4 + 56LL))(v4, v14, v15);
    (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  }

  else
  {
    SocketStream::_onqueue_completeTCPConnection0((uint64_t)this, 0LL);
  }

void SocketStream::_onqueue_completeTCPConnection0(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a2 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)CFStreamClientContext buf = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "SocketStream doesn't know how to deal with leftover bytes here yet",  buf,  2u);
  }

  if (*(_BYTE *)(a1 + 544))
  {
    if (!*(void *)(a1 + 552))
    {
LABEL_58:
      *(_BYTE *)(a1 + 544) = 0;
      CFRelease((CFTypeRef)(a1 - 16));
      return;
    }

    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 336), &unk_18C5ADD70))
    {
      SocketStream::setupMinimumThroughput(a1, 0);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
      SocketStream::attemptNextConnection_NoLock((SocketStream *)a1);
      uint64_t v3 = (pthread_mutex_t *)(a1 + 40);
LABEL_57:
      pthread_mutex_unlock(v3);
      goto LABEL_58;
    }

    *(_DWORD *)bytes = tcp_connection_get_socket();
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v4 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 552);
      int error = tcp_connection_get_error();
      *(_DWORD *)CFStreamClientContext buf = 134218496;
      *(void *)&uint8_t buf[4] = v5;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = *(_DWORD *)bytes;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = error;
      _os_log_impl(&dword_18298D000, v4, OS_LOG_TYPE_DEFAULT, "TCP Conn %p complete. fd: %d, err: %d", buf, 0x18u);
    }

    CFStringRef v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_26_5687, 2);
    if (v7)
    {
      CFTypeRef v8 = v7;
      if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v7 + 16LL))( v7,  "SocketStream TCP Connection Complete",  0LL))
      {
        (*(void (**)(void *, const char *, const __CFString *))(*(void *)v8 + 72LL))( v8,  "conn",  @"%p");
        (*(void (**)(void *, const char *, const __CFString *))(*(void *)v8 + 72LL))(v8, "fd", @"%d");
        tcp_connection_get_error();
        (*(void (**)(void *, const char *, const __CFString *))(*(void *)v8 + 72LL))( v8,  "error",  @"%d");
        (*(void (**)(void *))(*(void *)v8 + 8LL))(v8);
      }
    }

    if (*(_DWORD *)bytes != -1)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 336), &unk_18C5ADD70)
        && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)CFStreamClientContext buf = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "Musn't have a native handle right now",  buf,  2u);
      }

      uint64_t v9 = CFGetAllocator((CFTypeRef)(a1 - 16));
      CFDataRef v10 = CFDataCreate(v9, bytes, 4LL);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 336), &unk_18C5ADD70, v10);
      if (v10) {
        CFRelease(v10);
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 336), &unk_18C5ADD00, (const void *)*MEMORY[0x189604DE8]);
      if (*(_BYTE *)(a1 + 405))
      {
        *(_DWORD *)CFStreamClientContext buf = 1;
        setsockopt(*(int *)bytes, 6, 1, buf, 4u);
      }

      SocketStream::setupMinimumThroughput(a1, 0);
      SocketStream::attemptNextConnection_NoLock((SocketStream *)a1);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40));
      if (*(_DWORD *)bytes != -1) {
        goto LABEL_58;
      }
    }

    int v11 = tcp_connection_get_error();
    uint64_t v12 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_39_5692, 1);
    if (v12)
    {
      uint64_t v13 = v12;
      if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v12 + 16LL))( v12,  "TCP Connection Failed",  0LL))
      {
        tcp_connection_get_error();
        (*(void (**)(void *, const char *, const __CFString *))(*(void *)v13 + 72LL))( v13,  "error",  @"%d [%d]");
        (*(void (**)(void *))(*(void *)v13 + 8LL))(v13);
      }
    }

    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v14 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = *(void *)(a1 + 552);
      int v23 = tcp_connection_get_error();
      *(_DWORD *)CFStreamClientContext buf = 134218752;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = 0LL;
      *(_WORD *)&_BYTE buf[22] = 1024;
      int v31 = v11;
      __int16 v32 = 1024;
      int v33 = v23;
      _os_log_error_impl(&dword_18298D000, v14, OS_LOG_TYPE_ERROR, "TCP Conn %p Failed : error %ld:%d [%d]", buf, 0x22u);
      if (v11)
      {
LABEL_31:
        if (v11 == 536870913)
        {
LABEL_39:
          int v11 = 57;
LABEL_47:
          uint64_t v19 = 1LL;
          goto LABEL_48;
        }

        if (v11 == 57)
        {
          int Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 336), &unk_18C5AD830);
          if (Value)
          {
            int v16 = Value;
            SInt32 v17 = CFDictionaryGetValue(Value, @"kConditionalConnectionRequirementTimeWindowStartTime");
            unsigned int v18 = (const __CFNumber *)CFDictionaryGetValue( v16,  @"kConditionalConnectionRequirementTimeWindowDuration");
            int v11 = 57;
            uint64_t v19 = 1LL;
            if (!v17 || !v18) {
              goto LABEL_48;
            }
            CFNumberGetValue(v18, kCFNumberDoubleType, buf);
            double v20 = MEMORY[0x186E12AB0](v17);
            CFAbsoluteTime v21 = v20 + *(double *)buf;
            if (v21 <= CFAbsoluteTimeGetCurrent()) {
              int v11 = 60;
            }
            else {
              int v11 = 57;
            }
            goto LABEL_47;
          }

          goto LABEL_39;
        }

        if (v11 > 0) {
          goto LABEL_47;
        }
        if (v11 > -65549)
        {
          if (v11 == -65548)
          {
            int v11 = -72001;
            goto LABEL_66;
          }

          if (v11 == -65540)
          {
            int v11 = -72004;
LABEL_66:
            uint64_t v19 = 10LL;
            goto LABEL_48;
          }
        }

        else
        {
          if (v11 == -65555)
          {
            int v11 = -72008;
            goto LABEL_66;
          }

          if (v11 == -65554)
          {
            int v11 = 8;
            uint64_t v19 = 12LL;
LABEL_48:
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
            int v24 = *(_DWORD *)(a1 + 248);
            *(void *)(a1 + 256) = v19;
            *(_DWORD *)(a1 + 264) = v11;
            *(_DWORD *)(a1 + 248) = v24 & 0xFFFFFFEC | 2;
            *(_OWORD *)CFStreamClientContext buf = *(_OWORD *)(a1 + 256);
            id WeakRetained = objc_loadWeakRetained((id *)(a1 + 272));
            if (WeakRetained)
            {
              CFIndex v26 = WeakRetained;
              if ((*(_DWORD *)(a1 + 248) & 0x200) != 0) {
                _CFReadStreamSignalEventDelayed();
              }
              CFRelease(v26);
            }

            id v27 = objc_loadWeakRetained((id *)(a1 + 280));
            if (v27)
            {
              int v28 = v27;
              if ((*(_DWORD *)(a1 + 248) & 0x400) != 0) {
                _CFWriteStreamSignalEventDelayed();
              }
              CFRelease(v28);
            }

            uint64_t v3 = (pthread_mutex_t *)(a1 + 40);
            goto LABEL_57;
          }
        }

        int v11 = -72000;
        goto LABEL_66;
      }
    }

    else if (v11)
    {
      goto LABEL_31;
    }

    int v11 = 2;
    goto LABEL_47;
  }

void ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke( uint64_t a1, dispatch_object_s *a2, const void *a3, char a4)
{
  uint64_t v8 = *(void *)(a1 + 48);
  (*(void (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
  if (a2) {
    dispatch_retain(a2);
  }
  if (a3) {
    CFRetain(a3);
  }
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke_2;
  block[3] = &unk_189C09D70;
  block[6] = v8;
  block[7] = a3;
  char v12 = a4;
  uint64_t v9 = *(dispatch_queue_s **)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  block[4] = a2;
  void block[5] = v10;
  dispatch_async(v9, block);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void ___ZN12SocketStream30_onqueue_completeTCPConnectionEv_block_invoke_2(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 48);
  IOPMAssertionID v3 = *(_DWORD *)(v2 + 604);
  if (v3)
  {
    IOPMAssertionRelease(v3);
    *(_DWORD *)(v2 + 604) = 0;
  }

  IOPMAssertionID v4 = *(_DWORD *)(v2 + 608);
  if (v4)
  {
    IOPMAssertionRelease(v4);
    *(_DWORD *)(v2 + 608) = 0;
  }

  uint64_t v5 = *(const void **)(a1 + 56);
  if (v5)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 40));
    int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 336), &unk_18C5B2450);
    if (Value) {
      uint64_t v5 = Value;
    }
    CFRetain(v5);
    SocketStream::removeHandshake_NoLock(v2, 7);
    uint64_t v7 = *(unsigned int *)(v2 + 248);
    unint64_t v8 = v7 | ((unint64_t)*(unsigned __int16 *)(v2 + 252) << 32) | 0x400000000LL;
    *(_DWORD *)(v2 + 248) = v7;
    *(_WORD *)(v2 + 252) = WORD2(v8);
    SocketStream::_CONNECTSetInfo_NoLock((CFDictionaryRef *)v2, (CFDictionaryRef)v5);
    CFRelease(v5);
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 40));
    CFRelease(*(CFTypeRef *)(a1 + 56));
  }

  if (*(_BYTE *)(a1 + 64))
  {
    *(void *)(v2 + 256) = 1LL;
    *(_DWORD *)(v2 + 264) = 57;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v9 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(v2 + 552);
      int v12 = 134217984;
      uint64_t v13 = v10;
      _os_log_impl(&dword_18298D000, v9, OS_LOG_TYPE_DEFAULT, "TCP Conn %p canceled by ceClient", (uint8_t *)&v12, 0xCu);
    }

    pthread_mutex_lock((pthread_mutex_t *)(v2 + 40));
    SocketStream::cleanupConnection_NoLock((SocketStream *)v2);
    pthread_mutex_unlock((pthread_mutex_t *)(v2 + 40));
  }

  else
  {
    SocketStream::_onqueue_completeTCPConnection0(v2, *(void *)(a1 + 32));
  }

  int v11 = *(dispatch_object_s **)(a1 + 32);
  if (v11) {
    dispatch_release(v11);
  }
  tcp_connection_release();
  CFRelease((CFTypeRef)(v2 - 16));
}

uint64_t ___ZN12SocketStream31_onqueue_completeTCPConnection0EPU27objcproto16OS_dispatch_data8NSObject_block_invoke_38@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 3515LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream31_onqueue_completeTCPConnection0EPU27objcproto16OS_dispatch_data8NSObject_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 3484LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke(uint64_t a1, int a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 40));
  int v4 = *(_DWORD *)(v3 + 248);
  pthread_mutex_unlock((pthread_mutex_t *)(v3 + 40));
  if ((v4 & 0x1000) == 0)
  {
    switch(a2)
    {
      case 1073741825:
        if (*(void *)(v3 + 464) || *(void *)(v3 + 472))
        {
          *(void *)CFTypeRef cf = 0LL;
          CFTypeRef v42 = 0LL;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v42);
          uint64_t v18 = *(void *)(v3 + 464);
          if (v18) {
            BOOL v19 = *(void *)cf == 0LL;
          }
          else {
            BOOL v19 = 1;
          }
          if (!v19) {
            (*(void (**)(void))(v18 + 16))();
          }
          uint64_t v20 = *(void *)(v3 + 472);
          if (v20 && v42) {
            (*(void (**)(void))(v20 + 16))();
          }
          if (*(void *)cf) {
            CFRelease(*(CFTypeRef *)cf);
          }
          CFTypeRef v21 = v42;
          if (v42) {
            goto LABEL_105;
          }
        }

        break;
      case 1073741826:
        if (*(void *)(v3 + 448) || *(void *)(v3 + 456))
        {
          uint64_t v22 = tcp_connection_conditions_met();
          *(void *)CFTypeRef cf = 0LL;
          CFTypeRef v42 = 0LL;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v42);
          uint64_t v23 = *(void *)(v3 + 448);
          if (v23) {
            BOOL v24 = *(void *)cf == 0LL;
          }
          else {
            BOOL v24 = 1;
          }
          if (!v24) {
            (*(void (**)(void))(v23 + 16))();
          }
          uint64_t v25 = *(void *)(v3 + 456);
          if (v25 && v42) {
            (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v25 + 16))(v25, v42, v22);
          }
          if (*(void *)cf) {
            CFRelease(*(CFTypeRef *)cf);
          }
          CFTypeRef v21 = v42;
          if (v42) {
            goto LABEL_105;
          }
        }

        break;
      case 1073741827:
      case 1073741831:
        return;
      case 1073741828:
      case 1073741829:
        if (a2 == 1073741828) {
          *(void *)&v5.int error = 4294965195LL;
        }
        else {
          *(void *)&v5.int error = 4294965196LL;
        }
        CFSocketRef v6 = (SocketStream *)v3;
        v5.CFIndex domain = 4LL;
        goto LABEL_68;
      case 1073741830:
        if (*(void *)(v3 + 480) || *(void *)(v3 + 488))
        {
          *(void *)CFTypeRef cf = 0LL;
          CFTypeRef v42 = 0LL;
          SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v42);
          uint64_t v26 = *(void *)(v3 + 480);
          if (v26) {
            BOOL v27 = *(void *)cf == 0LL;
          }
          else {
            BOOL v27 = 1;
          }
          if (!v27) {
            (*(void (**)(void))(v26 + 16))();
          }
          uint64_t v28 = *(void *)(v3 + 488);
          if (v28 && v42) {
            (*(void (**)(void))(v28 + 16))();
          }
          if (*(void *)cf) {
            CFRelease(*(CFTypeRef *)cf);
          }
          CFTypeRef v21 = v42;
          if (v42) {
LABEL_105:
          }
            CFRelease(v21);
        }

        break;
      case 1073741832:
        CFSocketRef v6 = (SocketStream *)v3;
        v5.CFIndex domain = 4LL;
        *(void *)&v5.int error = 4294965190LL;
LABEL_68:
        SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(v6, v5);
        break;
      default:
        switch(a2)
        {
          case 1:
            CFTypeRef v42 = 0LL;
            uint64_t v43 = 0LL;
            uint64_t v44 = 0LL;
            if (*(void *)(v3 + 552)
              && tcp_connection_get_statistics()
              && ((*(unsigned int *)(v3 + 248) | ((unint64_t)*(unsigned __int16 *)(v3 + 252) << 32)) & 0x20000000000LL) != 0)
            {
              uint64_t v7 = CFGetAllocator((CFTypeRef)(v3 - 16));
              CFMutableDataRef Mutable = CFDictionaryCreateMutable(v7, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
              *(void *)CFTypeRef cf = @"_kCFStreamStatsDNS_ResolutionTimeMs";
              *(_DWORD *)&cf[8] = (_DWORD)v42;
              *(void *)&v47[2] = @"_kCFStreamStatsConnectionEstablishmentTimeMs";
              int v48 = v43;
              uint64_t v9 = (char *)operator new(0x20uLL);
              uint64_t v10 = v9;
              for (uint64_t i = 0LL; i != 32; i += 16LL)
                *(_OWORD *)&v9[i] = *(_OWORD *)&cf[i];
              for (uint64_t j = 0LL; j != 32; j += 16LL)
              {
                uint64_t v13 = CFGetAllocator((CFTypeRef)(v3 - 16));
                CFNumberRef v14 = CFNumberCreate(v13, kCFNumberSInt32Type, &v10[j + 8]);
                CFDictionaryAddValue(Mutable, *(const void **)&v10[j], v14);
                if (v14) {
                  CFRelease(v14);
                }
              }

              operator delete(v10);
              (*(void (**)(uint64_t, uint64_t, __CFDictionary *))(*(void *)v3 + 200LL))( v3,  0x18C5AC250LL,  Mutable);
              if (Mutable) {
                CFRelease(Mutable);
              }
            }

            goto LABEL_19;
          case 3:
LABEL_19:
            SocketStream::cancelSIMScheduler((SocketStream *)v3);
            if (*(_BYTE *)(v3 + 544))
            {
              if (CFNLog::onceToken != -1) {
                dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
              }
              int v15 = (os_log_s *)CFNLog::logger;
              if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v16 = *(void *)(v3 + 552);
                if (v16) {
                  int error = tcp_connection_get_error();
                }
                else {
                  int error = 0;
                }
                *(_DWORD *)CFTypeRef cf = 134218496;
                *(void *)&cf[4] = v16;
                __int16 v46 = 1024;
                *(_DWORD *)uint64_t v47 = a2;
                *(_WORD *)&v47[4] = 1024;
                *(_DWORD *)&v47[6] = error;
                _os_log_impl(&dword_18298D000, v15, OS_LOG_TYPE_DEFAULT, "TCP Conn %p event %d. err: %d", cf, 0x18u);
              }

              SocketStream::_onqueue_completeTCPConnection((SocketStream *)v3);
            }

            break;
          case 5:
            int v29 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_67, 2);
            if (v29)
            {
              uint64_t v30 = (uint64_t)v29;
              if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v29 + 16LL))( v29,  "better route detected",  0LL))
              {
                diagnosticLogTCPConnectionInfo(v30, *(void *)(v3 + 552));
                (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
              }
            }

            uint64_t v31 = *(void *)(v3 + 512);
            if (v31) {
              (*(void (**)(void))(v31 + 16))();
            }
            SocketStream::terminateConnectionIfAppropriate((SocketStream *)v3, 1);
            break;
          case 6:
            uint64_t is_viable = tcp_connection_is_viable();
            int v33 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_60_5723, 2);
            if (v33)
            {
              uint64_t v34 = (uint64_t)v33;
              if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v33 + 16LL))( v33,  "Connection viability changed",  0LL))
              {
                diagnosticLogTCPConnectionInfo(v34, *(void *)(v3 + 552));
                (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v34 + 72LL))( v34,  "viable",  @"%s");
                (*(void (**)(uint64_t))(*(void *)v34 + 8LL))(v34);
              }
            }

            if (*(void *)(v3 + 496) || *(void *)(v3 + 504))
            {
              *(void *)CFTypeRef cf = 0LL;
              CFTypeRef v42 = 0LL;
              SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v42);
              uint64_t v35 = *(void *)(v3 + 496);
              if (v35 && *(void *)cf) {
                (*(void (**)(uint64_t, void, uint64_t))(v35 + 16))(v35, *(void *)cf, is_viable);
              }
              uint64_t v36 = *(void *)(v3 + 504);
              if (v36 && v42) {
                (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v36 + 16))(v36, v42, is_viable);
              }
              if (*(void *)cf) {
                CFRelease(*(CFTypeRef *)cf);
              }
              if (v42) {
                CFRelease(v42);
              }
            }

            if ((is_viable & 1) == 0) {
              SocketStream::terminateConnectionIfAppropriate((SocketStream *)v3, 0);
            }
            break;
          case 7:
            uint64_t unmet_reason = tcp_connection_conditions_get_unmet_reason();
            uint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 184LL))(v3);
            if (v38)
            {
              uint64_t v39 = v38;
              (*(void (**)(uint64_t, uint64_t))(*(void *)v38 + 72LL))(v38, unmet_reason);
              (*(void (**)(uint64_t))(*(void *)v39 + 24LL))(v39);
            }

            if (*(void *)(v3 + 432) || *(void *)(v3 + 440))
            {
              *(void *)CFTypeRef cf = 0LL;
              CFTypeRef v42 = 0LL;
              SocketStream::retainOpenClientStreamsSafer((id *)v3, (__CFReadStream **)cf, (__CFWriteStream **)&v42);
              uint64_t v40 = *(void *)(v3 + 432);
              if (v40 && *(void *)cf) {
                (*(void (**)(uint64_t, void, uint64_t))(v40 + 16))(v40, *(void *)cf, unmet_reason);
              }
              uint64_t v41 = *(void *)(v3 + 440);
              if (v41 && v42) {
                (*(void (**)(uint64_t, CFTypeRef, uint64_t))(v41 + 16))(v41, v42, unmet_reason);
              }
              if (*(void *)cf) {
                CFRelease(*(CFTypeRef *)cf);
              }
              CFTypeRef v21 = v42;
              if (v42) {
                goto LABEL_105;
              }
            }

            break;
          default:
            return;
        }

        break;
    }
  }

void sub_182ABC6A0(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v2 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = 134217984;
    uint64_t v6 = v4;
    _os_log_debug_impl(&dword_18298D000, v2, OS_LOG_TYPE_DEBUG, "TCP Conn %p released", (uint8_t *)&v5, 0xCu);
  }

  return tcp_connection_release();
}

void SocketStream::_onqueue_startTCPConnectionConditional(SocketStream *this, int a2, int a3)
{
  int Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AD830);
  if (Value)
  {
    unint64_t v8 = Value;
    gotLoadHelper_x8__OBJC_CLASS____DASActivity(v7);
    if (objc_opt_class())
    {
      CFRetain((char *)this - 16);
      uint64_t v9 = (std::__shared_weak_count *)operator new(0x20uLL);
      v9->__shared_owners_ = 0LL;
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      v9->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A320;
      v9->__shared_weak_owners_ = 0LL;
      v9[1].__vftable = (std::__shared_weak_count_vtbl *)this;
      int v11 = (const void *)tcp_connection_copy_endpoint();
      int v12 = (const void *)tcp_connection_copy_parameters();
      uint64_t v13 = (const __CFDictionary *)*((void *)this + 42);
      uint64_t v14 = *((void *)this + 70);
      uint64_t v15 = MEMORY[0x1895F87A8];
      uint64_t v50 = MEMORY[0x1895F87A8];
      uint64_t v51 = 3321888768LL;
      CFTypeRef v52 = ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke;
      uint64_t v53 = &__block_descriptor_50_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE_e9_C16__0_v8l;
      uint64_t v54 = this;
      uint64_t v55 = v9;
      do
        unint64_t v16 = __ldxr(p_shared_owners);
      while (__stxr(v16 + 1, p_shared_owners));
      char v56 = a2;
      char v57 = a3;
      uint64_t v43 = v15;
      uint64_t v44 = 3321888768LL;
      int v45 = ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_172;
      __int16 v46 = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12SocketStreamEE_e9_v16__0_v8l;
      uint64_t v47 = this;
      int v48 = this;
      uint64_t v49 = v9;
      do
        unint64_t v17 = __ldxr(p_shared_owners);
      while (__stxr(v17 + 1, p_shared_owners));
      *(void *)&__int128 v39 = v15;
      *((void *)&v39 + 1) = 3221225472LL;
      uint64_t v40 = ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_175;
      uint64_t v41 = &__block_descriptor_40_e12_v20__0C8_v12l;
      CFTypeRef v42 = this;
      __ConditionalConnectionDUETSupport_StartActivity( v13,  v14,  (uint64_t)v11,  (uint64_t)v12,  0LL,  (uint64_t)&v50,  (uint64_t)&v43,  (uint64_t)&v39);
      uint64_t v18 = v49;
      if (v49)
      {
        BOOL v19 = (unint64_t *)&v49->__shared_owners_;
        do
          unint64_t v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }

      CFTypeRef v21 = v55;
      if (v55)
      {
        uint64_t v22 = (unint64_t *)&v55->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      if (v12) {
        CFRelease(v12);
      }
      if (v11) {
        CFRelease(v11);
      }
      do
        unint64_t v24 = __ldaxr(p_shared_owners);
      while (__stlxr(v24 - 1, p_shared_owners));
    }

    else
    {
      CFRetain((char *)this - 16);
      uint64_t v9 = (std::__shared_weak_count *)operator new(0x20uLL);
      v9->__shared_owners_ = 0LL;
      uint64_t v25 = (unint64_t *)&v9->__shared_owners_;
      v9->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A320;
      v9->__shared_weak_owners_ = 0LL;
      v9[1].__vftable = (std::__shared_weak_count_vtbl *)this;
      uint64_t v26 = CFDictionaryGetValue(v8, @"kConditionalConnectionRequirementTimeWindowStartTime");
      BOOL v27 = (const __CFNumber *)CFDictionaryGetValue(v8, @"kConditionalConnectionRequirementTimeWindowDelay");
      uint64_t v28 = (const __CFNumber *)CFDictionaryGetValue(v8, @"kConditionalConnectionRequirementTimeWindowDuration");
      tcp_connection_set_indefinite();
      uint64_t v29 = MEMORY[0x1895F87A8];
      uint64_t v43 = MEMORY[0x1895F87A8];
      uint64_t v44 = 3321888768LL;
      int v45 = ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke;
      __int16 v46 = &__block_descriptor_50_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE_e5_v8__0l;
      uint64_t v47 = this;
      int v48 = (SocketStream *)v9;
      do
        unint64_t v30 = __ldxr(v25);
      while (__stxr(v30 + 1, v25));
      LOBYTE(v49) = a2;
      BYTE1(v49) = a3;
      uint64_t v50 = v29;
      uint64_t v51 = 3221225472LL;
      CFTypeRef v52 = ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke_178;
      uint64_t v53 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v54 = this;
      uint64_t v31 = operator new(0x80uLL);
      v31[1] = 0LL;
      v31[2] = 0LL;
      void *v31 = off_189C0A3B8;
      ConditionalConnectionSIMScheduler::ConditionalConnectionSIMScheduler( (uint64_t)(v31 + 3),  (uint64_t)v26,  v27,  v28,  *((dispatch_object_s **)this + 70),  &v43,  &v50);
      *(void *)&__int128 v39 = v31 + 3;
      *((void *)&v39 + 1) = v31;
      std::shared_ptr<HTTPEngine>::__enable_weak_this[abi:nn180100]<HTTPEngine,HTTPEngine,void>( (uint64_t)&v39,  (void *)v39,  v39);
      __int16 v32 = (ConditionalConnectionSIMScheduler **)((char *)this + 656);
      std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v32, &v39);
      int v33 = (std::__shared_weak_count *)*((void *)&v39 + 1);
      if (*((void *)&v39 + 1))
      {
        uint64_t v34 = (unint64_t *)(*((void *)&v39 + 1) + 8LL);
        do
          unint64_t v35 = __ldaxr(v34);
        while (__stlxr(v35 - 1, v34));
        if (!v35)
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }

      ConditionalConnectionSIMScheduler::start(*v32);
      uint64_t v36 = (std::__shared_weak_count *)v48;
      if (v48)
      {
        CFRange v37 = (unint64_t *)((char *)v48 + 8);
        do
          unint64_t v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }

      do
        unint64_t v24 = __ldaxr(v25);
      while (__stlxr(v24 - 1, v25));
    }

    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  else
  {
    SocketStream::_onqueue_startTCPConnectionCompletion(this, a2, a3);
  }

void sub_182ABCC1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27)
{
  if (a20)
  {
    p_shared_owners = (unint64_t *)&a20->__shared_owners_;
    do
      unint64_t v31 = __ldaxr(p_shared_owners);
    while (__stlxr(v31 - 1, p_shared_owners));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))a20->__on_zero_shared)(a20);
      std::__shared_weak_count::__release_weak(a20);
    }
  }

  do
    unint64_t v32 = __ldaxr(v28);
  while (__stlxr(v32 - 1, v28));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }

  _Unwind_Resume(exception_object);
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke_84(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(void))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48));
  uint64_t v3 = *(dispatch_queue_s **)(a1 + 32);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2_85;
  v4[3] = &__block_descriptor_42_e5_v8__0l;
  v4[4] = v2;
  __int16 v5 = *(_WORD *)(a1 + 56);
  dispatch_async(v3, v4);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void ___ZN12SocketStream18startTCPConnectionEh_block_invoke_2_85(uint64_t a1)
{
  uint64_t v1 = *(SocketStream **)(a1 + 32);
  SocketStream::_onqueue_startTCPConnectionConditional(v1, *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41));
  CFRelease((char *)v1 - 16);
}

void *SocketStream::_onqueue_startTCPConnectionCompletion(SocketStream *this, int a2, int a3)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  *((_BYTE *)this + 648) = 1;
  if (*((void *)this + 69))
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v6 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *((void *)this + 69);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v7;
      _os_log_impl(&dword_18298D000, v6, OS_LOG_TYPE_DEFAULT, "TCP Conn %p started", (uint8_t *)&buf, 0xCu);
    }

    tcp_connection_start();
    SocketStream::touchWatchdogTimer_Locked(this, 1);
    if (entr_shouldtrace_delayInitStub(v8))
    {
      do
        unint64_t v10 = __ldaxr(&gSocketStreamEnergyTraceIdentifier);
      while (__stlxr(v10 + 1, &gSocketStreamEnergyTraceIdentifier));
      *((void *)this + 78) = v10;
      *((_BYTE *)this + 636) = 1;
      int v11 = ~(*((_DWORD *)this + 62) >> 30) & 2;
      *((_DWORD *)this + 158) = v11;
      unsigned int v12 = *((_DWORD *)this + 102) - 1;
      if (v12 <= 9) {
        *((_DWORD *)this + 158) = (v11 | (v12 << 20)) + 0x100000;
      }
      entr_act_begin_delayInitStub(v9);
    }
  }

  double v13 = *((double *)this + 46);
  if (v13 > 0.0)
  {
    *((double *)this + 47) = v13;
    uint64_t v14 = dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, *((dispatch_queue_t *)this + 70));
    uint64_t v15 = MEMORY[0x1895F87A8];
    *((void *)this + 49) = v14;
    handler[0] = v15;
    handler[1] = 3221225472LL;
    handler[2] = ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = this;
    dispatch_source_set_event_handler(v14, handler);
    unint64_t v16 = (dispatch_source_s *)*((void *)this + 49);
    dispatch_time_t v17 = dispatch_time(0LL, (uint64_t)(*((double *)this + 47) * 1000000000.0));
    dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    dispatch_resume(*((dispatch_object_t *)this + 49));
  }

  uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_69, 2);
  uint64_t v19 = (uint64_t)result;
  if (result)
  {
    uint64_t result = (void *)(*(uint64_t (**)(void *, const char *, void))(*(void *)result + 16LL))( result,  "TCP Connection Start",  0LL);
    if ((_DWORD)result)
    {
      BOOL v20 = a2 == 0;
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v19 + 72LL))( v19,  "conn",  @"%p");
      CFTypeRef v21 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (!v20)
      {
        *(void *)&__int128 buf = off_189C1A178;
        CFStringRef v22 = CFStringCreateWithCString(v21, "from existing connection", 0x8000100u);
        uint64_t v41 = 0LL;
        uint64_t v42 = 0LL;
        *((void *)&buf + 1) = v22;
        uint64_t v36 = off_189C1A178;
        CFStringRef v23 = CFStringCreateWithCString(v21, "true", 0x8000100u);
        uint64_t v38 = 0LL;
        uint64_t v39 = 0LL;
        CFStringRef v37 = v23;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v19 + 64LL))(v19, *((void *)&buf + 1), v23);
        AutoString::~AutoString((AutoString *)&v36);
        AutoString::~AutoString((AutoString *)&buf);
      }

      uint64_t v24 = *((unsigned int *)this + 62);
      unint64_t v25 = v24 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      if ((v24 & 0x80000000) != 0)
      {
        *(void *)&__int128 buf = off_189C1A178;
        CFStringRef v26 = CFStringCreateWithCString(v21, "no cellular", 0x8000100u);
        uint64_t v41 = 0LL;
        uint64_t v42 = 0LL;
        *((void *)&buf + 1) = v26;
        uint64_t v36 = off_189C1A178;
        CFStringRef v27 = CFStringCreateWithCString(v21, "true", 0x8000100u);
        uint64_t v38 = 0LL;
        uint64_t v39 = 0LL;
        CFStringRef v37 = v27;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v19 + 64LL))(v19, *((void *)&buf + 1), v27);
        AutoString::~AutoString((AutoString *)&v36);
        AutoString::~AutoString((AutoString *)&buf);
        unint64_t v25 = *((unsigned int *)this + 62) | ((unint64_t)*((unsigned __int16 *)this + 126) << 32);
      }

      if ((v25 & 0x100000000LL) != 0)
      {
        *(void *)&__int128 buf = off_189C1A178;
        CFStringRef v28 = CFStringCreateWithCString(v21, "persistent connection", 0x8000100u);
        uint64_t v41 = 0LL;
        uint64_t v42 = 0LL;
        *((void *)&buf + 1) = v28;
        uint64_t v36 = off_189C1A178;
        CFStringRef v29 = CFStringCreateWithCString(v21, "true", 0x8000100u);
        uint64_t v38 = 0LL;
        uint64_t v39 = 0LL;
        CFStringRef v37 = v29;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v19 + 64LL))(v19, *((void *)&buf + 1), v29);
        AutoString::~AutoString((AutoString *)&v36);
        AutoString::~AutoString((AutoString *)&buf);
      }

      if (*((void *)this + 67))
      {
        *(void *)&__int128 buf = off_189C1A178;
        CFStringRef v30 = CFStringCreateWithCString(v21, "scoped interface", 0x8000100u);
        uint64_t v41 = 0LL;
        uint64_t v42 = 0LL;
        *((void *)&buf + 1) = v30;
        (*(void (**)(uint64_t))(*(void *)v19 + 64LL))(v19);
        AutoString::~AutoString((AutoString *)&buf);
      }

      if (*((_BYTE *)this + 406))
      {
        *(void *)&__int128 buf = off_189C1A178;
        CFStringRef v31 = CFStringCreateWithCString(v21, "SO_RECV_ANYIF", 0x8000100u);
        uint64_t v41 = 0LL;
        uint64_t v42 = 0LL;
        *((void *)&buf + 1) = v31;
        uint64_t v36 = off_189C1A178;
        CFStringRef v32 = CFStringCreateWithCString(v21, "set", 0x8000100u);
        uint64_t v38 = 0LL;
        uint64_t v39 = 0LL;
        CFStringRef v37 = v32;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v19 + 64LL))(v19, *((void *)&buf + 1), v32);
        AutoString::~AutoString((AutoString *)&v36);
        AutoString::~AutoString((AutoString *)&buf);
      }

      if (a3)
      {
        *(void *)&__int128 buf = off_189C1A178;
        CFStringRef v33 = CFStringCreateWithCString(v21, "opportunistic", 0x8000100u);
        uint64_t v41 = 0LL;
        uint64_t v42 = 0LL;
        *((void *)&buf + 1) = v33;
        uint64_t v36 = off_189C1A178;
        CFStringRef v34 = CFStringCreateWithCString(v21, "true", 0x8000100u);
        uint64_t v38 = 0LL;
        uint64_t v39 = 0LL;
        CFStringRef v37 = v34;
        (*(void (**)(uint64_t, void, CFStringRef))(*(void *)v19 + 64LL))(v19, *((void *)&buf + 1), v34);
        AutoString::~AutoString((AutoString *)&v36);
        AutoString::~AutoString((AutoString *)&buf);
      }

      return (void *)(*(uint64_t (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
    }
  }

  return result;
}

void sub_182ABD3A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

void ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  tcp_connection_retry();
  double v2 = *(double *)(v1 + 376) + *(double *)(v1 + 376);
  *(double *)(v1 + 376) = v2;
  uint64_t v3 = *(dispatch_source_s **)(v1 + 392);
  dispatch_time_t v4 = dispatch_time(0LL, (uint64_t)(v2 * 1000000000.0));
  dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
}

uint64_t ___ZN12SocketStream37_onqueue_startTCPConnectionCompletionEhh_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  double v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 4161LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

void *___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke(uint64_t a1)
{
  return SocketStream::_onqueue_startTCPConnectionCompletion( *(SocketStream **)(a1 + 32),  *(unsigned __int8 *)(a1 + 48),  *(unsigned __int8 *)(a1 + 49));
}

uint64_t ___ZN12SocketStream17setupSIMSchedulerEPK14__CFDictionaryhh_block_invoke_178(uint64_t a1)
{
  v2.CFIndex domain = 1LL;
  *(void *)&v2.int error = 60LL;
  return SocketStream::_onqueue_cancelTCPConnectionAfterTimeout(*(SocketStream **)(a1 + 32), v2);
}

uint64_t __copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void std::__shared_ptr_pointer<SocketStream *,Deleter_release<SocketStream>,std::allocator<SocketStream>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<SocketStream *,Deleter_release<SocketStream>,std::allocator<SocketStream>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    CFRelease((CFTypeRef)(v1 - 16));
  }
}

uint64_t ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke(uint64_t a1)
{
  return 1LL;
}

void ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_172(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (*(void *)(v3 + 448) || *(void *)(v3 + 456))
  {
    CFTypeRef v9 = 0LL;
    CFTypeRef cf = 0LL;
    SocketStream::retainOpenClientStreamsSafer(v2, (__CFReadStream **)&cf, (__CFWriteStream **)&v9);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(v4 + 448);
    if (v5) {
      BOOL v6 = cf == 0LL;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6)
    {
      (*(void (**)(void))(v5 + 16))();
      uint64_t v4 = *(void *)(a1 + 40);
    }

    uint64_t v7 = *(void *)(v4 + 456);
    if (v7) {
      BOOL v8 = v9 == 0LL;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8) {
      (*(void (**)(void))(v7 + 16))();
    }
    if (cf) {
      CFRelease(cf);
    }
    if (v9) {
      CFRelease(v9);
    }
  }

void ___ZN12SocketStream26setupDuetActivitySchedulerEhh_block_invoke_175(uint64_t a1, int a2, CFTypeRef cf)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (cf) {
      CFTypeRef v4 = CFRetain(cf);
    }
    else {
      CFTypeRef v4 = 0LL;
    }
    uint64_t v5 = *(const void **)(v3 + 640);
    *(void *)(v3 + 640) = v4;
    if (v5) {
      CFRelease(v5);
    }
  }

uint64_t __copy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_40c40_ZTSNSt3__110shared_ptrI12SocketStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t SocketStream::retainOpenClientStreamsSafer(id *this, __CFReadStream **a2, __CFWriteStream **a3)
{
  BOOL v6 = (pthread_mutex_t *)(this + 5);
  pthread_mutex_lock((pthread_mutex_t *)(this + 5));
  if (a2)
  {
    else {
      id WeakRetained = (__CFReadStream *)objc_loadWeakRetained(this + 34);
    }
    *a2 = WeakRetained;
  }

  if (a3)
  {
    else {
      BOOL v8 = (__CFWriteStream *)objc_loadWeakRetained(this + 35);
    }
    *a3 = v8;
  }

  return pthread_mutex_unlock(v6);
}

void SocketStream::cancelSIMScheduler(SocketStream *this)
{
  uint64_t v2 = (ConditionalConnectionSIMScheduler *)*((void *)this + 82);
  if (v2)
  {
    uint64_t v3 = (char *)this + 656;
    ConditionalConnectionSIMScheduler::cancel(v2);
    __int128 v7 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v7);
    unint64_t v4 = (std::__shared_weak_count *)*((void *)&v7 + 1);
    if (*((void *)&v7 + 1))
    {
      uint64_t v5 = (unint64_t *)(*((void *)&v7 + 1) + 8LL);
      do
        unint64_t v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

uint64_t diagnosticLogTCPConnectionInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    if ((tcp_connection_get_local() & 1) == 0)
    {
      uint64_t v8 = 0LL;
      uint64_t v9 = 0LL;
      int v11 = 0;
      uint64_t v10 = 0LL;
    }

    if ((tcp_connection_get_remote() & 1) == 0)
    {
      uint64_t v4 = 0LL;
      uint64_t v5 = 0LL;
      int v7 = 0;
      uint64_t v6 = 0LL;
    }

    tcp_connection_get_hostname();
  }

  else
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    int v11 = 0;
    uint64_t v10 = 0LL;
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    uint64_t v4 = 0LL;
    int v7 = 0;
  }

  IOLogger::addrToName((uint64_t)&v8, __str);
  IOLogger::addrToName((uint64_t)&v4, v12);
  return (*(uint64_t (**)(uint64_t, const char *, const __CFString *))(*(void *)a1 + 72LL))( a1,  "connection",  @"{ conn: %p, local %s => peer %s %s}");
}

uint64_t SocketStream::terminateConnectionIfAppropriate(SocketStream *this, int a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (pthread_mutex_t *)((char *)this + 40);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 40));
  int Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 42), &unk_18C5AD7C0);
  if (Value)
  {
    uint64_t v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  buf,  2u);
    }
  }

  if (*((void *)this + 62))
  {
LABEL_7:
    BOOL v8 = 0;
    if (a2) {
      goto LABEL_8;
    }
LABEL_16:
    if (!v8) {
      return pthread_mutex_unlock(v4);
    }
    uint64_t v9 = (unsigned int *)((char *)this + 248);
    int v10 = (*((unsigned __int16 *)this + 126) >> 1) & 1;
    goto LABEL_18;
  }

  BOOL v8 = *((void *)this + 63) == 0LL;
  if (!a2) {
    goto LABEL_16;
  }
LABEL_8:
  uint64_t v9 = (unsigned int *)((char *)this + 248);
  int v10 = (*((unsigned __int16 *)this + 126) >> 1) & 1;
  if (!tcp_connection_is_cellular())
  {
LABEL_18:
    double v13 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_53, 2);
    if (v13)
    {
      uint64_t v14 = (uint64_t)v13;
      if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v13 + 16LL))( v13,  "_networkReachabilityChanged",  0LL))
      {
        diagnosticLogTCPConnectionInfo(v14, *((void *)this + 69));
        (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v14 + 72LL))( v14,  "conn",  @"%p -- setting stream error to ENOTCONN");
        (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
      }
    }

    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v15 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *((void *)this + 69);
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v27 = v16;
      _os_log_impl( &dword_18298D000,  v15,  OS_LOG_TYPE_DEFAULT,  "TCP Conn %p network reachability changed : setting stream error to ENOTCONN",  buf,  0xCu);
    }

    __int16 v17 = *((_WORD *)this + 126);
    *((_DWORD *)this + 62) = *((_DWORD *)this + 62);
    *((_WORD *)this + 126) = v17 | 2;
    BOOL v18 = 1;
    *((void *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 1LL;
    *((_DWORD *)this + 66) = 57;
    SocketStream::cleanupConnection_NoLock(this);
    id WeakRetained = objc_loadWeakRetained((id *)this + 34);
    BOOL v20 = WeakRetained;
    if (*((void *)this + 29)) {
      BOOL v18 = *((void *)this + 28) < 1LL;
    }
    if (v18 && WeakRetained)
    {
      if ((*v9 & 0x200) != 0) {
        _CFReadStreamSignalEventDelayed();
      }
    }

    else if (!WeakRetained)
    {
      goto LABEL_33;
    }

    CFRelease(v20);
LABEL_33:
    id v21 = objc_loadWeakRetained((id *)this + 35);
    if (v21)
    {
      CFStringRef v22 = v21;
      if ((*v9 & 0x400) != 0) {
        _CFWriteStreamSignalEventDelayed();
      }
      CFRelease(v22);
    }

    goto LABEL_37;
  }

  int v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_49_5729, 2);
  if (v11)
  {
    uint64_t v12 = (uint64_t)v11;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v11 + 16LL))( v11,  "_networkReachabilityChanged",  0LL))
    {
      diagnosticLogTCPConnectionInfo(v12, *((void *)this + 69));
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v12 + 72LL))( v12,  "conn",  @"%p -- keeping alive");
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
  }

  if (!*((void *)this + 67)) {
    *((_WORD *)this + 126) = (*v9 | ((unint64_t)*((unsigned __int16 *)this + 126) << 32) | 0x200000000LL) >> 32;
  }
LABEL_37:
  unint64_t v23 = *v9 | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
  if (((v10 ^ ((v23 & 0x200000000LL) == 0)) & 1) == 0)
  {
    if ((v23 & 0x200000000LL) != 0) {
      uint64_t v24 = (const void **)MEMORY[0x189604DE8];
    }
    else {
      uint64_t v24 = (const void **)MEMORY[0x189604DE0];
    }
    NotificationStation::notifyPropertyChanged( (SocketStream *)((char *)this + 104),  @"__kCFStreamPropertyDoNotReuse",  *v24);
  }

  return pthread_mutex_unlock(v4);
}

uint64_t ___ZN12SocketStream33_onqueue_HandleTCPConnectionEventEjPKv_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 4024LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream32terminateConnectionIfAppropriateEh_block_invoke_2@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 3778LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream32terminateConnectionIfAppropriateEh_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 3764LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

uint64_t ___ZN12SocketStream33_onqueue_HandleTCPConnectionEventEjPKv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = 4000LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = "none";
  return result;
}

dispatch_queue_t ___ZL26copyGlobalTCPConnWorkQueuev_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("shared_tcpConnWorkQueue", 0LL);
  copyGlobalTCPConnWorkQueue(void)::sTCPConnWorkQueue = (uint64_t)result;
  return result;
}

void ___ZN12SocketStream31finalizeCancelConnection_LockedEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v1 + 40));
  if (*(_BYTE *)(v1 + 544))
  {
    *(_BYTE *)(v1 + 544) = 0;
    CFRelease((CFTypeRef)(v1 - 16));
  }

  if (*(_BYTE *)(v1 + 636))
  {
    *(_BYTE *)(v1 + 636) = 0;
    entr_act_end_delayInitStub(v2);
  }

  uint64_t v3 = *(dispatch_source_s **)(v1 + 384);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v1 + 384));
    *(void *)(v1 + 384) = 0LL;
  }

  uint64_t v4 = *(dispatch_source_s **)(v1 + 392);
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(*(dispatch_object_t *)(v1 + 392));
    *(void *)(v1 + 392) = 0LL;
  }

  uint64_t v5 = *(void *)(v1 + 640);
  if (v5)
  {
    int v6 = *(unsigned __int8 *)(v1 + 648);
    double Helper_x8__OBJC_CLASS____DASScheduler = gotLoadHelper_x8__OBJC_CLASS____DASScheduler(v2);
    uint64_t v9 = (void *)objc_msgSend(*(id *)(v8 + 584), "sharedScheduler", Helper_x8__OBJC_CLASS____DASScheduler);
    if (v6) {
      [v9 activityCompleted:v5];
    }
    else {
      [v9 activityCanceled:v5];
    }
    int v10 = *(const void **)(v1 + 640);
    *(void *)(v1 + 640) = 0LL;
    if (v10) {
      CFRelease(v10);
    }
  }

  SocketStream::cancelSIMScheduler((SocketStream *)v1);
  pthread_mutex_unlock((pthread_mutex_t *)(v1 + 40));
  CFRelease((CFTypeRef)(v1 - 16));
}

void SocketStream::initialize(CFMutableDictionaryRef *this, __CFHost *a2, const __CFAllocator *a3)
{
  int v6 = CFGetAllocator(this - 2);
  CFHostRef Copy = CFHostCreateCopy(v6, a2);
  CFDictionaryAddValue(this[42], &unk_18C5ADDA8, Copy);
  uint64_t v8 = this[42];
  AutoScalar::AutoScalar((AutoScalar *)&v9, a3);
  CFDictionaryAddValue(v8, &unk_18C5ADE50, value);
  uint64_t v9 = off_189C04A90;
  if (value) {
    CFRelease(value);
  }
  CFRelease(Copy);
}

void sub_182ABDFDC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

uint64_t SocketStream::commonInitialization(SocketStream *this)
{
  double v2 = CFGetAllocator((char *)this - 16);
  uint64_t v3 = (const CFArrayCallBacks *)MEMORY[0x189605228];
  *((void *)this + 38) = CFArrayCreateMutable(v2, 0LL, MEMORY[0x189605228]);
  *((void *)this + 39) = CFArrayCreateMutable(v2, 0LL, v3);
  *((void *)this + 40) = CFArrayCreateMutable(v2, 0LL, v3);
  uint64_t v4 = (void *)MEMORY[0x186E12804](v2, 32LL, 0LL);
  v4[2] = 0LL;
  v4[3] = 0LL;
  *uint64_t v4 = off_189C0A278;
  v4[1] = v2;
  v4[2] = CFArrayCreateMutable(v2, 0LL, v3);
  v4[3] = 0LL;
  *((void *)this + 41) = v4;
  *((void *)this + 42) = CFDictionaryCreateMutable(v2, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v5 = pthread_self();
  mach_port_t v9 = pthread_mach_thread_np(v5);
  pid_t v10 = getpid();
  int v11 = "CFSocketStream";
  uint64_t v12 = "ioLogger";
  uint64_t v13 = 0LL;
  uint64_t v14 = this;
  uint64_t v15 = "socketstream";
  *((void *)this + 27) = IOLogger::newLogger((IOLogger *)&Current, v6);
  uint64_t result = copyGlobalTCPConnWorkQueue();
  *((void *)this + 70) = result;
  return result;
}

void Schedulables::~Schedulables(Schedulables *this)
{
  *(void *)this = off_189C0A278;
  uint64_t v1 = (const void *)*((void *)this + 2);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C0A278;
  double v2 = (const void *)*((void *)this + 2);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

CFSetRef ___ZN12SocketStream20observablePropertiesEv_block_invoke()
{
  if ((_ZGVZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable & 1) == 0)
  {
    _ZZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable = 0x18C5AB680LL;
    _ZGVZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable = 1;
  }

  CFSetRef result = CFSetCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)&_ZZZN12SocketStream20observablePropertiesEvEUb_E34namesOfPropertiesThatAreObservable,  1LL,  MEMORY[0x189605258]);
  SocketStream::observableProperties(void)::observableProps = (uint64_t)result;
  return result;
}

void SocketStream::initialize(CFMutableDictionaryRef *this, __CFNetService *a2)
{
  uint64_t v4 = CFGetAllocator(this - 2);
  CFNetServiceRef Copy = CFNetServiceCreateCopy(v4, a2);
  CFDictionaryAddValue(this[42], &unk_18C5ADE18, Copy);
  CFRelease(Copy);
}

uint64_t ReadStreamCallbacks::_finalize(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(void *)((char *)a2
                                                                              + *(void *)(*(void *)a2 - 136LL))
                                                                  + 16LL))( (char *)a2 + *(void *)(*(void *)a2 - 136LL),  this);
}

uint64_t ReadStreamCallbacks::_copyDescription(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(void *)((char *)a2
                                                                              + *(void *)(*(void *)a2 - 136LL))
                                                                  + 24LL))( (char *)a2 + *(void *)(*(void *)a2 - 136LL),  this);
}

uint64_t ReadStreamCallbacks::_open( ReadStreamCallbacks *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, ReadStreamCallbacks *, __CFReadStream *, CFStreamError *))(*(void *)&a4[*(void *)(*(void *)a4 - 136LL)] + 32LL))( &a4[*(void *)(*(void *)a4 - 136LL)],  this,  a2,  a3);
}

uint64_t ReadStreamCallbacks::_openCompleted( ReadStreamCallbacks *this, __CFReadStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *, __CFReadStream *))(*(CFIndex *)((char *)&a3->domain
                                                                                                 + *(void *)(a3->domain - 136))
                                                                                    + 40))( (char *)a3 + *(void *)(a3->domain - 136),  this,  a2);
}

uint64_t ReadStreamCallbacks::_read( ReadStreamCallbacks *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6, void *a7)
{
  return (*(uint64_t (**)(unsigned __int8 *, ReadStreamCallbacks *, __CFReadStream *, unsigned __int8 *, uint64_t, CFStreamError *))(*(void *)&a6[*(void *)(*(void *)a6 - 136LL)] + 88LL))( &a6[*(void *)(*(void *)a6 - 136LL)],  this,  a2,  a3,  a4,  a5);
}

uint64_t ReadStreamCallbacks::_canRead(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(void *)((char *)a2
                                                                              + *(void *)(*(void *)a2 - 136LL))
                                                                  + 96LL))( (char *)a2 + *(void *)(*(void *)a2 - 136LL),  this);
}

uint64_t ReadStreamCallbacks::_close(ReadStreamCallbacks *this, __CFReadStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *))(*(void *)((char *)a2
                                                                              + *(void *)(*(void *)a2 - 136LL))
                                                                  + 48LL))( (char *)a2 + *(void *)(*(void *)a2 - 136LL),  this);
}

uint64_t ReadStreamCallbacks::_copyProperty( ReadStreamCallbacks *this, __CFReadStream *a2, const __CFString *a3, void *a4)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *))((char *)&a3->isa
                                                                                     + *((void *)a3->isa - 17)))[7]( (char *)a3 + *((void *)a3->isa - 17),  this,  a2);
}

uint64_t ReadStreamCallbacks::_setProperty( ReadStreamCallbacks *this, __CFReadStream *a2, const __CFString *a3, char *a4, void *a5)
{
  return (*(uint64_t (**)(char *, ReadStreamCallbacks *, __CFReadStream *, const __CFString *))(*(void *)&a4[*(void *)(*(void *)a4 - 136LL)] + 64LL))( &a4[*(void *)(*(void *)a4 - 136LL)],  this,  a2,  a3);
}

uint64_t ReadStreamCallbacks::_schedule( ReadStreamCallbacks *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *, __CFRunLoop *))((char *)&a4->isa + *((void *)a4->isa - 17)))[9]( (char *)a4 + *((void *)a4->isa - 17),  this,  a2,  a3);
}

uint64_t ReadStreamCallbacks::_unschedule( ReadStreamCallbacks *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, ReadStreamCallbacks *, __CFReadStream *, __CFRunLoop *))((char *)&a4->isa + *((void *)a4->isa - 17)))[10]( (char *)a4 + *((void *)a4->isa - 17),  this,  a2,  a3);
}

uint64_t WriteStreamCallbacks::_finalize(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(void *)((char *)a2
                                                                               + *(void *)(*(void *)a2 - 136LL))
                                                                   + 16LL))( (char *)a2 + *(void *)(*(void *)a2 - 136LL),  this);
}

uint64_t WriteStreamCallbacks::_copyDescription(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(void *)((char *)a2
                                                                               + *(void *)(*(void *)a2 - 136LL))
                                                                   + 24LL))( (char *)a2 + *(void *)(*(void *)a2 - 136LL),  this);
}

uint64_t WriteStreamCallbacks::_open( WriteStreamCallbacks *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4, void *a5)
{
  return (*(uint64_t (**)(unsigned __int8 *, WriteStreamCallbacks *, __CFWriteStream *, CFStreamError *))(*(void *)&a4[*(void *)(*(void *)a4 - 136LL)] + 32LL))( &a4[*(void *)(*(void *)a4 - 136LL)],  this,  a2,  a3);
}

uint64_t WriteStreamCallbacks::_openCompleted( WriteStreamCallbacks *this, __CFWriteStream *a2, CFStreamError *a3, void *a4)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *))(*(CFIndex *)((char *)&a3->domain + *(void *)(a3->domain - 136))
                                                                                      + 40))( (char *)a3 + *(void *)(a3->domain - 136),  this,  a2);
}

uint64_t WriteStreamCallbacks::_write( WriteStreamCallbacks *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, void *a6)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *, const unsigned __int8 *, uint64_t))(*(CFIndex *)((char *)&a5->domain + *(void *)(a5->domain - 136)) + 104))( (char *)a5 + *(void *)(a5->domain - 136),  this,  a2,  a3,  a4);
}

uint64_t WriteStreamCallbacks::_canWrite(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(void *)((char *)a2
                                                                               + *(void *)(*(void *)a2 - 136LL))
                                                                   + 112LL))( (char *)a2 + *(void *)(*(void *)a2 - 136LL),  this);
}

uint64_t WriteStreamCallbacks::_close(WriteStreamCallbacks *this, __CFWriteStream *a2, void *a3)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *))(*(void *)((char *)a2
                                                                               + *(void *)(*(void *)a2 - 136LL))
                                                                   + 48LL))( (char *)a2 + *(void *)(*(void *)a2 - 136LL),  this);
}

uint64_t WriteStreamCallbacks::_copyProperty( WriteStreamCallbacks *this, __CFWriteStream *a2, const __CFString *a3, void *a4)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *))((char *)&a3->isa
                                                                                       + *((void *)a3->isa - 17)))[7]( (char *)a3 + *((void *)a3->isa - 17),  this,  a2);
}

uint64_t WriteStreamCallbacks::_setProperty( WriteStreamCallbacks *this, __CFWriteStream *a2, const __CFString *a3, char *a4, void *a5)
{
  return (*(uint64_t (**)(char *, WriteStreamCallbacks *, __CFWriteStream *, const __CFString *))(*(void *)&a4[*(void *)(*(void *)a4 - 136LL)] + 64LL))( &a4[*(void *)(*(void *)a4 - 136LL)],  this,  a2,  a3);
}

uint64_t WriteStreamCallbacks::_schedule( WriteStreamCallbacks *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *, __CFRunLoop *))((char *)&a4->isa + *((void *)a4->isa - 17)))[9]( (char *)a4 + *((void *)a4->isa - 17),  this,  a2,  a3);
}

uint64_t WriteStreamCallbacks::_unschedule( WriteStreamCallbacks *this, __CFWriteStream *a2, __CFRunLoop *a3, const __CFString *a4, void *a5)
{
  return (*(uint64_t (***)(char *, WriteStreamCallbacks *, __CFWriteStream *, __CFRunLoop *))((char *)&a4->isa + *((void *)a4->isa - 17)))[10]( (char *)a4 + *((void *)a4->isa - 17),  this,  a2,  a3);
}

void sub_182ABEA4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
}

void sub_182ABEE30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
}

void sub_182AC0444(_Unwind_Exception *a1)
{
}

void sub_182AC09D0(_Unwind_Exception *a1)
{
}

void sub_182AC1320(_Unwind_Exception *a1, uint64_t a2, ...)
{
  if (v2) {
    CFRelease(v2);
  }
  _Unwind_Resume(a1);
}

void sub_182AC1C68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

void std::allocate_shared[abi:nn180100]<TCPIO_Delegate,std::allocator<TCPIO_Delegate>,std::shared_ptr<TransportConnectionObjCPP> &,void>( void *a1, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count *a3)
{
  int v6 = (std::__shared_weak_count *)operator new(0x78uLL);
  CFTypeID v7 = v6;
  v6->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v6->__shared_owners_;
  v6->__shared_weak_owners_ = 0LL;
  v6->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AB78;
  if (a3)
  {
    mach_port_t v9 = (unint64_t *)&a3->__shared_owners_;
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
    v6[1].__shared_owners_ = 0LL;
    v6[1].__shared_weak_owners_ = 0LL;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C0ABB0;
    int v11 = (unint64_t *)&a3->__shared_owners_;
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  else
  {
    v6[1].__shared_owners_ = 0LL;
    v6[1].__shared_weak_owners_ = 0LL;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C0ABB0;
  }

  uint64_t v13 = &v6[1].__vftable;
  v6[2].__vftable = a2;
  v6[2].__shared_owners_ = (uint64_t)a3;
  get_deleter = a2->__get_deleter;
  uint64_t v15 = *((void *)get_deleter + 15);
  if (v15) {
    dispatch_retain(*((dispatch_object_t *)get_deleter + 15));
  }
  v7[2].__shared_weak_owners_ = v15;
  v7[3].__vftable = 0LL;
  LODWORD(v7[3].__shared_owners_) = 0;
  LOWORD(v7[3].__shared_weak_owners_) = 0;
  BYTE2(v7[3].__shared_weak_owners_) = 0;
  v7[4].__vftable = 0LL;
  LODWORD(v7[4].__shared_owners_) = 0;
  LOWORD(v7[4].__shared_weak_owners_) = 0;
  if (a3)
  {
    uint64_t v16 = (unint64_t *)&a3->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }

  *a1 = v13;
  a1[1] = v7;
  shared_weak_owners = (std::__shared_weak_count *)v7[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      return;
    }
    do
      unint64_t v19 = __ldxr(p_shared_owners);
    while (__stxr(v19 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
    do
      unint64_t v21 = __ldxr(p_shared_weak_owners);
    while (__stxr(v21 + 1, p_shared_weak_owners));
    v7[1].__shared_owners_ = (uint64_t)v13;
    v7[1].__shared_weak_owners_ = (uint64_t)v7;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }

  else
  {
    do
      unint64_t v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
    unint64_t v23 = (unint64_t *)&v7->__shared_weak_owners_;
    do
      unint64_t v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
    v7[1].__shared_owners_ = (uint64_t)v13;
    v7[1].__shared_weak_owners_ = (uint64_t)v7;
  }

  do
    unint64_t v25 = __ldaxr(p_shared_owners);
  while (__stlxr(v25 - 1, p_shared_owners));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }

void sub_182AC232C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_182AC2410( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __copy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_40c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

uint64_t __NSCFTCPIOWriteStream::__NSCFTCPIOWriteStream(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  *(void *)(a1 + CFRetain((char *)this - 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)a1 = off_189C13058;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = off_189C0A620;
  uint64_t v6 = a1 + 32;
  *(void *)(a1 + 88) = a4;
  *(_DWORD *)(a1 + 96) = 1;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)a1 = off_189C0A7E8;
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = &unk_189C0A868;
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(a1 + 104), *a3, a3[1]);
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v8 = 16LL;
    if (!*(_DWORD *)(a1 + 96)) {
      uint64_t v8 = 8LL;
    }
    *(void *)(v7 + v8) = v6;
  }

  return a1;
}

void sub_182AC252C(_Unwind_Exception *exception_object)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  uint64_t v3 = (std::__shared_weak_count *)v1[3];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

void __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream(__NSCFTCPIOWriteStream *this)
{
}

{
  TCPIO_BlockCallbacks_Listener *v2;
  char *v3;
  uint64_t v4;
  dispatch_queue_s *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  __int128 v18;
  void (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  *((void *)this + 4) = &unk_189C0A868;
  uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)((char *)this + 32);
  *(void *)this = off_189C0A7E8;
  uint64_t v3 = (char *)this + 104;
  unint64_t v4 = *((void *)this + 13);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v23,  *(void *)(v4 + 8),  *(std::__shared_weak_count **)(v4 + 16));
  uint64_t v5 = *(dispatch_queue_s **)(v4 + 40);
  *(void *)&BOOL v18 = MEMORY[0x1895F87A8];
  *((void *)&v18 + 1) = 3321888768LL;
  unint64_t v19 = ___ZN14TCPIO_Delegate18writeSideFinalizedEv_block_invoke;
  BOOL v20 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  unint64_t v21 = v23;
  unint64_t v22 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      uint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  dispatch_async(v5, &v18);
  uint64_t v8 = v22;
  if (v22)
  {
    mach_port_t v9 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  int v11 = v24;
  if (v24)
  {
    unint64_t v12 = (unint64_t *)&v24->__shared_owners_;
    do
      uint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  BOOL v18 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v18);
  uint64_t v14 = (std::__shared_weak_count *)*((void *)&v18 + 1);
  if (*((void *)&v18 + 1))
  {
    uint64_t v15 = (unint64_t *)(*((void *)&v18 + 1) + 8LL);
    do
      uint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v3);
  *((void *)this + 4) = off_189C0A620;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(v2);

  *(void *)this = off_189C19AE8;
  *((void *)this + 1) = 0LL;
  unint64_t v17 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
}

CFStringRef __NSCFTCPIOWriteStream::copyDescription(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<TransportConnection@%p>",  *((void *)this + 13) + 24LL);
}

BOOL __NSCFTCPIOWriteStream::_streamImpl_Open( __NSCFTCPIOWriteStream *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  uint64_t v6 = *((void *)this + 13);
  uint64_t v7 = *(dispatch_queue_s **)(v6 + 40);
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  v9[3] = &__block_descriptor_48_e5_v8__0l;
  v9[4] = v6;
  v9[5] = a3;
  dispatch_sync(v7, v9);
  *a4 = 1;
  CFWriteStreamSignalEvent();
  return !a3->domain && a3->error == 0;
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_OpenCompleted( __NSCFTCPIOWriteStream *this, __CFWriteStream *a2, CFStreamError *a3)
{
  uint64_t v3 = *((void *)this + 13);
  unint64_t v4 = *(dispatch_queue_s **)(v3 + 40);
  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  v6[3] = &__block_descriptor_48_e5_v8__0l;
  _OWORD v6[4] = v3;
  void v6[5] = a3;
  dispatch_sync(v4, v6);
  return 1LL;
}

size_t __NSCFTCPIOWriteStream::_streamImpl_Write( __NSCFTCPIOWriteStream *this, __CFWriteStream *a2, const unsigned __int8 *a3, size_t a4, CFStreamError *a5)
{
  uint64_t v9 = *((void *)this + 13);
  unint64_t v10 = *(dispatch_queue_s **)(v9 + 40);
  uint64_t v11 = MEMORY[0x1895F87A8];
  blocCFIndex k = MEMORY[0x1895F87A8];
  uint64_t v27 = 3221225472LL;
  uint64_t v28 = ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke;
  CFStringRef v29 = &__block_descriptor_48_e5_v8__0l;
  dispatch_data_t v30 = (dispatch_data_t)v9;
  CFStringRef v31 = a5;
  dispatch_sync(v10, &block);
  if (a5->domain && a5->error) {
    return -1LL;
  }
  dispatch_data_t v12 = dispatch_data_create(a3, a4, 0LL, 0LL);
  uint64_t v13 = *((void *)this + 1);
  if (v13) {
    CFRetain(*((CFTypeRef *)this + 1));
  }
  uint64_t v14 = *((void *)this + 13);
  v25[0] = v11;
  v25[1] = 3221225472LL;
  v25[2] = ___ZN22__NSCFTCPIOWriteStream17_streamImpl_WriteEP15__CFWriteStreamPKhlP13CFStreamError_block_invoke;
  v25[3] = &__block_descriptor_40_e5_v8__0l;
  v25[4] = v13;
  dispatch_retain(v12);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v34,  *(void *)(v14 + 8),  *(std::__shared_weak_count **)(v14 + 16));
  uint64_t v15 = *(dispatch_queue_s **)(v14 + 40);
  blocCFIndex k = v11;
  uint64_t v27 = 3321888768LL;
  uint64_t v28 = ___ZN14TCPIO_Delegate9writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke;
  CFStringRef v29 = &unk_189C0A888;
  uint64_t v32 = v34;
  CFStringRef v33 = v35;
  if (v35)
  {
    p_shared_owners = (unint64_t *)&v35->__shared_owners_;
    do
      unint64_t v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
  }

  dispatch_data_t v30 = v12;
  CFStringRef v31 = (CFStreamError *)v25;
  dispatch_async(v15, &block);
  BOOL v18 = v33;
  if (v33)
  {
    unint64_t v19 = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  unint64_t v21 = v35;
  if (v35)
  {
    unint64_t v22 = (unint64_t *)&v35->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  dispatch_release(v12);
  return a4;
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_CanWrite(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
  return 1LL;
}

void __NSCFTCPIOWriteStream::_streamImpl_Close(__NSCFTCPIOWriteStream *this, __CFWriteStream *a2)
{
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_CopyProperty( TCPIO_Delegate **this, __CFWriteStream *a2, const __CFString *a3)
{
  return TCPIO_Delegate::copyProperty(this[13], a3);
}

uint64_t __NSCFTCPIOWriteStream::_streamImpl_SetProperty( __NSCFTCPIOWriteStream *this, __CFWriteStream *a2, const __CFString *a3, const void *a4)
{
  if (!TCPIO_BlockCallbacks_Listener::listenerSetProperty( (TCPIO_BlockCallbacks_Listener *)((char *)this + 32),  a3,  a4)) {
    TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 13), a3, a4);
  }
  return 1LL;
}

uint64_t __NSCFTCPIOWriteStream::streamObject(__NSCFTCPIOWriteStream *this)
{
  return *((void *)this + 1);
}

void non-virtual thunk to'__NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream(__NSCFTCPIOWriteStream *this)
{
}

{
  void *v1;
  __NSCFTCPIOWriteStream::~__NSCFTCPIOWriteStream((__NSCFTCPIOWriteStream *)((char *)this - 32));
  operator delete(v1);
}

uint64_t non-virtual thunk to'__NSCFTCPIOWriteStream::streamObject(__NSCFTCPIOWriteStream *this)
{
  return *((void *)this - 3);
}

void sub_182AC2AF0(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  uint64_t v5 = (std::__shared_weak_count *)v1[3];
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

void TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(TCPIO_BlockCallbacks_Listener *this)
{
  id var0 = this->var1.var0;
  if (var0)
  {
    _Block_release(var0);
    this->var1.id var0 = 0LL;
  }

  id var1 = this->var1.var1;
  if (var1)
  {
    _Block_release(var1);
    this->var1.id var1 = 0LL;
  }

  id var2 = this->var1.var2;
  if (var2)
  {
    _Block_release(var2);
    this->var1.id var2 = 0LL;
  }

  id var3 = this->var1.var3;
  if (var3)
  {
    _Block_release(var3);
    this->var1.id var3 = 0LL;
  }

  id var4 = this->var1.var4;
  if (var4)
  {
    _Block_release(var4);
    this->var1.id var4 = 0LL;
  }

  id var5 = this->var1.var5;
  if (var5)
  {
    _Block_release(var5);
    this->var1.id var5 = 0LL;
  }

  uint64_t v8 = (char *)this->var2;
  if (v8)
  {
    uint64_t v9 = 16LL;
    if (!this->var3) {
      uint64_t v9 = 8LL;
    }
    *(void *)&v8[v9] = 0LL;
  }

void TCPIO_BlockCallbacks_Listener::~TCPIO_BlockCallbacks_Listener(TCPIO_BlockCallbacks_Listener *this)
{
  this->id var0 = (void **)off_189C0A620;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(this);
}

void ___ZN14TCPIO_Delegate18writeSideFinalizedEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(TCPIO_Delegate **)(a1 + 32);
  *((_BYTE *)v1 + 89) = 1;
  if (*((_BYTE *)v1 + 66)) {
    TCPIO_Delegate::_onqueue_bothSidesFinalized(v1);
  }
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void TCPIO_Delegate::_onqueue_bothSidesFinalized(TCPIO_Delegate *this)
{
  if (!*((_BYTE *)this + 66) || !*((_BYTE *)this + 89)) {
    __assert_rtn("_onqueue_bothSidesFinalized", "LocalTCPIOStreamTask.mm", 769, "_readFinalized && _writeFinalized");
  }
  if (!*((_BYTE *)this + 65))
  {
    *((_BYTE *)this + 65) = 1;
    if (*((_BYTE *)this + 88))
    {
      uint64_t v11 = *((void *)this + 3);
      if (v11)
      {
        uint64_t v12 = *(void *)(v11 + 24);
        if (v12)
        {
          if (!*(_BYTE *)(v11 + 40))
          {
            *(_BYTE *)(v11 + 40) = 1;
            (*(void (**)(uint64_t, void))(*(void *)v12 + 152LL))(v12, 0LL);
          }
        }
      }
    }
  }

  if (!*((_BYTE *)this + 88))
  {
    *((_BYTE *)this + 88) = 1;
    if (*((_BYTE *)this + 65))
    {
      uint64_t v13 = *((void *)this + 3);
      if (v13)
      {
        uint64_t v14 = *(void *)(v13 + 24);
        if (v14)
        {
          if (!*(_BYTE *)(v13 + 40))
          {
            *(_BYTE *)(v13 + 40) = 1;
            (*(void (**)(uint64_t, void))(*(void *)v14 + 152LL))(v14, 0LL);
          }
        }
      }
    }
  }

  uint64_t v2 = (char *)this + 24;
  if (*((void *)this + 3))
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 4);
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        unint64_t v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }

    __int128 v15 = 0uLL;
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v2, &v15);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v15 + 1);
    if (!*((void *)&v15 + 1)) {
      goto LABEL_13;
    }
    uint64_t v7 = (unint64_t *)(*((void *)&v15 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
      if (!v3) {
        return;
      }
    }

    else
    {
LABEL_13:
      if (!v3) {
        return;
      }
    }

    uint64_t v9 = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void **TCPIO_BlockCallbacks_Listener::listenerSetProperty( TCPIO_BlockCallbacks_Listener *this, const __CFString *a2, const void *a3)
{
  CFSetRef result = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    unint64_t v5 = result;
    uint64_t v6 = *result;
    if (v6)
    {
      _Block_release(v6);
      std::__shared_weak_count *v5 = 0LL;
    }

    if (a3) {
      std::__shared_weak_count *v5 = _Block_copy(a3);
    }
    return (void **)1;
  }

  return result;
}

void TCPIO_Delegate::setProperty(TCPIO_Delegate *this, CFTypeRef cf, CFTypeRef a3)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  uint64_t v6 = *((void *)this + 3);
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  unint64_t v10 = (dispatch_queue_s *)*((void *)this + 5);
  v18[0] = MEMORY[0x1895F87A8];
  v18[1] = 3321888768LL;
  v18[2] = ___ZN14TCPIO_Delegate11setPropertyEPK10__CFStringPKv_block_invoke;
  v18[3] = &__block_descriptor_64_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE_e5_v8__0l;
  v18[4] = v6;
  unint64_t v19 = v7;
  if (v7)
  {
    uint64_t v11 = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  CFTypeRef v20 = cf;
  CFTypeRef v21 = a3;
  dispatch_async(v10, v18);
  uint64_t v13 = v19;
  if (!v19) {
    goto LABEL_15;
  }
  uint64_t v14 = (unint64_t *)&v19->__shared_owners_;
  do
    unint64_t v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if (!v7) {
      return;
    }
  }

  else
  {
LABEL_15:
    if (!v7) {
      return;
    }
  }

  uint64_t v16 = (unint64_t *)&v7->__shared_owners_;
  do
    unint64_t v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }

void ___ZN14TCPIO_Delegate11setPropertyEPK10__CFStringPKv_block_invoke(void *a1)
{
  uint64_t v2 = (const void *)a1[6];
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[7];
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t __copy_helper_block_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE( uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c53_ZTSNSt3__110shared_ptrI25TransportConnectionObjCPPEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

id *TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr( TCPIO_BlockCallbacks_Listener *this, CFStringRef theString)
{
  int ExactString = _findExactString(theString, 2u);
  p_id var1 = &this->var1;
  if (ExactString != 96814834) {
    p_id var1 = 0LL;
  }
  if (ExactString == 106203045) {
    p_id var0 = &this->var1.var1;
  }
  else {
    p_id var0 = &p_var1->var0;
  }
  if (ExactString == 90506882) {
    p_id var4 = &this->var1.var4;
  }
  else {
    p_id var4 = p_var0;
  }
  p_id var2 = &this->var1.var2;
  if (ExactString != 89532009) {
    p_id var2 = 0LL;
  }
  if (ExactString == 84248066) {
    p_id var3 = &this->var1.var3;
  }
  else {
    p_id var3 = p_var2;
  }
  if (ExactString == 83273191) {
    p_id var5 = &this->var1.var5;
  }
  else {
    p_id var5 = p_var3;
  }
  if (ExactString <= 90506881) {
    return p_var5;
  }
  else {
    return p_var4;
  }
}

uint64_t TCPIO_Delegate::copyProperty(TCPIO_Delegate *this, const __CFString *a2)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000LL;
  uint64_t v9 = 0LL;
  uint64_t v2 = (dispatch_queue_s *)*((void *)this + 5);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZNK14TCPIO_Delegate12copyPropertyEPK10__CFString_block_invoke;
  block[3] = &unk_189C18DE0;
  block[4] = &v6;
  void block[5] = this;
  block[6] = a2;
  dispatch_sync(v2, block);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t ___ZNK14TCPIO_Delegate12copyPropertyEPK10__CFString_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  uint64_t v3 = *(void *)(*(void *)(a1[5] + 24LL) + 24LL);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 216LL))(v3, v2);
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

void TCPIO_Delegate::closeWriteSide(TCPIO_Delegate *this)
{
  uint64_t v2 = (dispatch_queue_s *)*((void *)this + 5);
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3321888768LL;
  v11[2] = ___ZN14TCPIO_Delegate14closeWriteSideEv_block_invoke;
  v11[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v11[4] = v13;
  unint64_t v12 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }

  dispatch_async(v2, v11);
  unint64_t v5 = v12;
  if (v12)
  {
    uint64_t v6 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  uint64_t v8 = v14;
  if (v14)
  {
    uint64_t v9 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

void *___ZN14TCPIO_Delegate14closeWriteSideEv_block_invoke(void *result)
{
  uint64_t v1 = result[4];
  *(_BYTE *)(v1 + 88) = 1;
  if (*(_BYTE *)(v1 + 65))
  {
    uint64_t v2 = *(void *)(v1 + 24);
    if (v2)
    {
      uint64_t result = *(void **)(v2 + 24);
      if (result)
      {
        if (!*(_BYTE *)(v2 + 40))
        {
          *(_BYTE *)(v2 + 40) = 1;
          return (void *)(*(uint64_t (**)(void *, void))(*result + 152LL))(result, 0LL);
        }
      }
    }
  }

  return result;
}

__n128 ___ZN14TCPIO_Delegate14getWriteStatusEP13CFStreamError_block_invoke(uint64_t a1)
{
  __n128 result = *(__n128 *)(*(void *)(a1 + 32) + 72LL);
  *(__n128 *)*(void *)(a1 + 40) = result;
  return result;
}

void ___ZN22__NSCFTCPIOWriteStream17_streamImpl_WriteEP15__CFWriteStreamPKhlP13CFStreamError_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
}

void ___ZN14TCPIO_Delegate9writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke( uint64_t *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[4];
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v16,  *(void *)(v3 + 8),  *(std::__shared_weak_count **)(v3 + 16));
  uint64_t v5 = *(void *)(v3 + 24);
  v14[0] = MEMORY[0x1895F87A8];
  v14[1] = 3321888768LL;
  void v14[2] = ___ZN14TCPIO_Delegate18_onqueue_writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke;
  v14[3] = &unk_189C0A8C0;
  v14[5] = v16;
  unint64_t v15 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  v14[4] = v2;
  TransportConnectionObjCPP::write(v5, v4, (uint64_t)v14);
  uint64_t v8 = v15;
  if (v15)
  {
    uint64_t v9 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  uint64_t v11 = v17;
  if (v17)
  {
    unint64_t v12 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  dispatch_release((dispatch_object_t)a1[4]);
}

void sub_182AC3408( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    p_shared_owners = (unint64_t *)&a16->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }

  CFTypeRef v20 = *(std::__shared_weak_count **)(v16 - 40);
  if (v20)
  {
    CFTypeRef v21 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_48c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t ___ZN14TCPIO_Delegate18_onqueue_writeDataEPU27objcproto16OS_dispatch_data8NSObjectU13block_pointerFvvE_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  *(void *)(v3 + 72) = a2;
  *(void *)(v3 + 80) = a3;
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t __NSCFTCPIOReadStream::__NSCFTCPIOReadStream(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  *(void *)a1 = off_189C17090;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + CFRetain((char *)this - 16) = off_189C0A620;
  uint64_t v6 = a1 + 16;
  *(void *)(a1 + 72) = a4;
  *(_DWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_189C0A578;
  *(void *)(a1 + CFRetain((char *)this - 16) = &unk_189C0A5F8;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  unint64_t v7 = (CoreSchedulingSet *)std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(a1 + 88), *a3, a3[1]);
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0xFFFF00000000LL;
  *(void *)(a1 + 104) = 0LL;
  *(_BYTE *)(a1 + 128) = 1;
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 120) = CoreSchedulingSet::createEmpty(v7);
  uint64_t v8 = *(void *)(a1 + 72);
  if (v8)
  {
    uint64_t v9 = 16LL;
    if (!*(_DWORD *)(a1 + 80)) {
      uint64_t v9 = 8LL;
    }
    *(void *)(v8 + v9) = v6;
  }

  return a1;
}

void sub_182AC359C(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  _Unwind_Resume(a1);
}

void __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream(__NSCFTCPIOReadStream *this)
{
}

{
  TCPIO_BlockCallbacks_Listener *v2;
  char *v3;
  uint64_t v4;
  dispatch_queue_s *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  dispatch_object_s *v17;
  __int128 v18;
  void (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  *((void *)this + 2) = &unk_189C0A5F8;
  uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)((char *)this + 16);
  *(void *)this = off_189C0A578;
  uint64_t v3 = (char *)this + 88;
  unint64_t v4 = *((void *)this + 11);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v23,  *(void *)(v4 + 8),  *(std::__shared_weak_count **)(v4 + 16));
  uint64_t v5 = *(dispatch_queue_s **)(v4 + 40);
  *(void *)&BOOL v18 = MEMORY[0x1895F87A8];
  *((void *)&v18 + 1) = 3321888768LL;
  unint64_t v19 = ___ZN14TCPIO_Delegate17readSideFinalizedEv_block_invoke;
  CFTypeRef v20 = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  CFTypeRef v21 = v23;
  unint64_t v22 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  dispatch_async(v5, &v18);
  uint64_t v8 = v22;
  if (v22)
  {
    uint64_t v9 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  uint64_t v11 = v24;
  if (v24)
  {
    unint64_t v12 = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  BOOL v18 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)v3, &v18);
  uint64_t v14 = (std::__shared_weak_count *)*((void *)&v18 + 1);
  if (*((void *)&v18 + 1))
  {
    unint64_t v15 = (unint64_t *)(*((void *)&v18 + 1) + 8LL);
    do
      uint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  (*(void (**)(void))(**((void **)this + 15) + 48LL))(*((void *)this + 15));
  unint64_t v17 = (dispatch_object_s *)*((void *)this + 13);
  if (v17) {
    dispatch_release(v17);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v3);
  *((void *)this + 2) = off_189C0A620;
  TCPIO_BlockCallbacks_Listener::detachPropertyBlocks(v2);

  *(void *)this = off_189C19AE8;
  *((void *)this + 1) = 0LL;
}

CFStringRef __NSCFTCPIOReadStream::copyDescription(__NSCFTCPIOReadStream *this, __CFReadStream *a2)
{
  return CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"<TransportConnection@%p>",  *((void *)this + 11) + 24LL);
}

BOOL __NSCFTCPIOReadStream::_streamImpl_Open( __NSCFTCPIOReadStream *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  char v9 = 0;
  uint64_t v6 = *((void *)this + 11);
  unint64_t v7 = *(dispatch_queue_s **)(v6 + 40);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = v6;
  void block[5] = a3;
  block[6] = &v9;
  dispatch_sync(v7, block);
  *a4 = 1;
  if (*((void *)this + 13) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(block[0]) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "should only open this stream once",  (uint8_t *)block,  2u);
  }

  __NSCFTCPIOReadStream::issueDelegateRead(this);
  return v9 == 0;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_OpenCompleted( __NSCFTCPIOReadStream *this, __CFReadStream *a2, CFStreamError *a3)
{
  char v6 = 0;
  uint64_t v3 = *((void *)this + 11);
  unint64_t v4 = *(dispatch_queue_s **)(v3 + 40);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = v3;
  void block[5] = a3;
  block[6] = &v6;
  dispatch_sync(v4, block);
  return 1LL;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_Read( __NSCFTCPIOReadStream *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  a5->CFIndex domain = 0LL;
  a5->SInt32 error = 0;
  *a6 = 0;
  uint64_t v42 = 0LL;
  uint64_t v43 = &v42;
  uint64_t v44 = 0x2020000000LL;
  uint64_t v45 = 0LL;
  unint64_t v12 = (os_unfair_lock_s *)((char *)this + 112);
  os_unfair_lock_lock((os_unfair_lock_t)this + 28);
  if (*((_BYTE *)this + 129))
  {
    v43[3] = 0LL;
    unint64_t v13 = (dispatch_object_s *)*((void *)this + 13);
    if (v13)
    {
      dispatch_release(v13);
      int v14 = 0;
      *((void *)this + 13) = 0LL;
      goto LABEL_29;
    }

    goto LABEL_8;
  }

  unint64_t v15 = (dispatch_data_s *)*((void *)this + 13);
  if (v15)
  {
    size_t size = dispatch_data_get_size(*((dispatch_data_t *)this + 13));
    if (!size)
    {
LABEL_8:
      int v14 = 0;
      goto LABEL_29;
    }

    size_t v17 = size;
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke;
    applier[3] = &unk_189C13220;
    applier[4] = &v42;
    applier[5] = a4;
    applier[6] = a3;
    dispatch_data_apply(v15, applier);
    size_t v18 = v43[3];
    unint64_t v19 = (dispatch_data_s *)*((void *)this + 13);
    if (v17 == v18)
    {
      dispatch_data_t subrange = 0LL;
      int v14 = 1;
    }

    else
    {
      dispatch_data_t subrange = dispatch_data_create_subrange(v19, v18, v17 - v18);
      int v14 = 0;
      unint64_t v19 = (dispatch_data_s *)*((void *)this + 13);
    }

    dispatch_release(v19);
    *((void *)this + 13) = subrange;
    unint64_t v25 = v43;
    unint64_t v26 = v43[3];
    unint64_t v28 = *((void *)this + 17);
    uint64_t v27 = *((void *)this + 18);
    BOOL v29 = v28 >= v26;
    unint64_t v30 = v28 - v26;
    if (v30 != 0 && v29)
    {
      if (v27 != v28)
      {
        *((void *)this + 17) = v30;
        *((void *)this + 18) = v27 - v25[3];
      }

      goto LABEL_25;
    }

    if (v27 == v28)
    {
LABEL_25:
      TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 11), &unk_18C5ACDE8, (CFTypeRef)*MEMORY[0x189604DE0]);
      goto LABEL_29;
    }

    TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 11), &unk_18C5ACDE8, (CFTypeRef)*MEMORY[0x189604DE8]);
    *((void *)this + 17) = 0LL;
    unint64_t v31 = v43[3];
    unint64_t v32 = *((void *)this + 18);
    BOOL v29 = v32 >= v31;
    unint64_t v33 = v32 - v31;
    if (!v29) {
      unint64_t v33 = 0LL;
    }
    *((void *)this + 18) = v33;
  }

  else
  {
    CFTypeRef v21 = (const void *)(*(uint64_t (**)(__NSCFTCPIOReadStream *, __CFReadStream *))(*(void *)this + 16LL))( this,  a2);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    unint64_t v22 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v21;
      _os_log_impl(&dword_18298D000, v22, OS_LOG_TYPE_INFO, "StreamTask polling read of %@", (uint8_t *)&buf, 0xCu);
    }

    if (v21) {
      CFRelease(v21);
    }
    uint64_t v23 = *((void *)this + 11);
    unint64_t v24 = *(dispatch_queue_s **)(v23 + 40);
    *(void *)&__int128 buf = MEMORY[0x1895F87A8];
    *((void *)&buf + 1) = 3221225472LL;
    uint64_t v47 = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
    int v48 = &__block_descriptor_56_e5_v8__0l;
    uint64_t v49 = v23;
    uint64_t v50 = a5;
    uint64_t v51 = a6;
    dispatch_sync(v24, &buf);
    if (!a5->error && !a5->domain)
    {
      a5->CFIndex domain = 1LL;
      a5->SInt32 error = 57;
    }

    int v14 = 0;
    *a6 = 1;
    v43[3] = -1LL;
  }

void sub_182AC3BAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

BOOL __NSCFTCPIOReadStream::_streamImpl_CanRead(os_unfair_lock_s *this, __CFReadStream *a2)
{
  unint64_t v4 = this + 28;
  os_unfair_lock_lock(this + 28);
  if (*(void *)&this[26]._os_unfair_lock_opaque) {
    BOOL v5 = 1LL;
  }
  else {
    BOOL v5 = CFReadStreamGetStatus(a2) == kCFStreamStatusOpen;
  }
  os_unfair_lock_unlock(v4);
  return v5;
}

void __NSCFTCPIOReadStream::_streamImpl_Close(__NSCFTCPIOReadStream *this, __CFReadStream *a2)
{
  *((_BYTE *)this + 12_Block_object_dispose(va, 8) = 0;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_CopyProperty( TCPIO_Delegate **this, __CFReadStream *a2, const __CFString *a3)
{
  return TCPIO_Delegate::copyProperty(this[11], a3);
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_SetProperty( __NSCFTCPIOReadStream *this, __CFReadStream *a2, const __CFString *a3, const void *a4)
{
  if (!TCPIO_BlockCallbacks_Listener::listenerSetProperty( (TCPIO_BlockCallbacks_Listener *)((char *)this + 16),  a3,  a4)) {
    TCPIO_Delegate::setProperty(*((TCPIO_Delegate **)this + 11), a3, a4);
  }
  return 1LL;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_deprecated_Schedule( __NSCFTCPIOReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4)
{
  BOOL v5 = (_DWORD *)*((void *)this + 15);
  int v6 = v5[10];
  uint64_t result = (*(uint64_t (**)(_DWORD *, __CFRunLoop *, const __CFString *))(*(void *)v5 + 56LL))(v5, a3, a4);
  *((void *)this + 15) = result;
  if (!v6)
  {
    if (*(_DWORD *)(result + 40))
    {
      CFRetain(*((CFTypeRef *)this + 1));
      uint64_t v8 = *((void *)this + 15);
      v9[0] = MEMORY[0x1895F87A8];
      v9[1] = 3221225472LL;
      void v9[2] = ___ZN21__NSCFTCPIOReadStream31_streamImpl_deprecated_ScheduleEP14__CFReadStreamP11__CFRunLoopPK10__CFString_block_invoke;
      v9[3] = &__block_descriptor_40_e5_v8__0l;
      v9[4] = this;
      return (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96LL))(v8, v9);
    }
  }

  return result;
}

uint64_t __NSCFTCPIOReadStream::_streamImpl_deprecated_Unschedule( __NSCFTCPIOReadStream *this, __CFReadStream *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t result = (*(uint64_t (**)(void, __CFRunLoop *, const __CFString *))(**((void **)this + 15) + 64LL))( *((void *)this + 15),  a3,  a4);
  *((void *)this + 15) = result;
  return result;
}

uint64_t __NSCFTCPIOReadStream::streamObject(__NSCFTCPIOReadStream *this)
{
  return *((void *)this + 1);
}

void non-virtual thunk to'__NSCFTCPIOReadStream::~__NSCFTCPIOReadStream(__NSCFTCPIOReadStream *this)
{
}

{
  void *v1;
  __NSCFTCPIOReadStream::~__NSCFTCPIOReadStream((__NSCFTCPIOReadStream *)((char *)this - 16));
  operator delete(v1);
}

uint64_t non-virtual thunk to'__NSCFTCPIOReadStream::streamObject(__NSCFTCPIOReadStream *this)
{
  return *((void *)this - 1);
}

void sub_182AC3F78(_Unwind_Exception *a1)
{
  void *v1 = off_189C19AE8;
  v1[1] = 0LL;
  _Unwind_Resume(a1);
}

void ___ZN14TCPIO_Delegate17readSideFinalizedEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(TCPIO_Delegate **)(a1 + 32);
  *((_BYTE *)v1 + 66) = 1;
  if (*((_BYTE *)v1 + 89)) {
    TCPIO_Delegate::_onqueue_bothSidesFinalized(v1);
  }
}

void ___ZN21__NSCFTCPIOReadStream31_streamImpl_deprecated_ScheduleEP14__CFReadStreamP11__CFRunLoopPK10__CFString_block_invoke( uint64_t a1)
{
  CFStreamStatus v1 = *(void *)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite(v1);
  CFRelease(*(CFTypeRef *)(v1 + 8));
}

CFStreamStatus __NSCFTCPIOReadStream::_onss_excite(CFStreamStatus this)
{
  if (*(_DWORD *)(*(void *)(this + 120) + 40LL))
  {
    uint64_t v1 = this;
    this = CFReadStreamGetStatus(*(CFReadStreamRef *)(this + 8));
    if ((this & 0xFFFFFFFFFFFFFFFELL) == 2)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v1 + 112));
      uint64_t v2 = *(void *)(v1 + 104);
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 112));
      if (v2)
      {
        return CFReadStreamSignalEvent();
      }

      else
      {
        uint64_t v3 = *(void *)(v1 + 88);
        unint64_t v4 = *(dispatch_queue_s **)(v3 + 40);
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke;
        block[3] = &__block_descriptor_56_e5_v8__0l;
        block[4] = v3;
        void block[5] = &v5;
        block[6] = &v7;
        dispatch_sync(v4, block);
        if (v7 || v5 && v6) {
          return CFReadStreamSignalEvent();
        }
        else {
          return __NSCFTCPIOReadStream::issueDelegateRead((__NSCFTCPIOReadStream *)v1);
        }
      }
    }
  }

  return this;
}

__n128 ___ZN14TCPIO_Delegate13getReadStatusEP13CFStreamErrorPh_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(__n128 **)(a1 + 32);
  __n128 result = v1[3];
  *(__n128 *)*(void *)(a1 + 40) = result;
  **(_BYTE **)(a1 + 4_Block_object_dispose(va, 8) = v1[4].n128_u8[0];
  return result;
}

void __NSCFTCPIOReadStream::issueDelegateRead(__NSCFTCPIOReadStream *this)
{
  uint64_t v2 = (_DWORD *)*((void *)this + 15);
  if (v2[10])
  {
    uint64_t v3 = (*(uint64_t (**)(_DWORD *))(*(void *)v2 + 88LL))(v2);
    CFRetain(*((CFTypeRef *)this + 1));
    uint64_t v4 = *((void *)this + 11);
    int v5 = *((_DWORD *)this + 29);
    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 3221225472LL;
    v17[2] = ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_261;
    v17[3] = &__block_descriptor_48_e72_v24__0__NSObject_OS_dispatch_data__8__NSObject_OS_nw_content_context__16l;
    v17[4] = this;
    void v17[5] = v3;
    TCPIO_Delegate::bufferedRead(v4, v5, (uint64_t)v17);
  }

  else
  {
    CFRetain(*((CFTypeRef *)this + 1));
    CFTypeRef v20 = this;
    int v6 = (std::__shared_weak_count *)operator new(0x20uLL);
    v6->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A698;
    v6->__shared_weak_owners_ = 0LL;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)this;
    CFTypeRef v21 = v6;
    unint64_t v19 = v6;
    v6->__shared_owners_ = 0LL;
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    uint64_t v8 = *((void *)this + 11);
    int v9 = *((_DWORD *)this + 29);
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3321888768LL;
    v18[2] = ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke;
    v18[3] = &__block_descriptor_56_e8_40c49_ZTSNSt3__110shared_ptrI21__NSCFTCPIOReadStreamEE_e72_v24__0__NSObject_OS_dispatch_data__8__NSObject_OS_nw_content_context__16l;
    v18[4] = this;
    void v18[5] = this;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    TCPIO_Delegate::bufferedRead(v8, v9, (uint64_t)v18);
    uint64_t v11 = v19;
    if (v19)
    {
      unint64_t v12 = (unint64_t *)&v19->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }

    int v14 = v21;
    if (v21)
    {
      unint64_t v15 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }

void sub_182AC42A0(_Unwind_Exception *a1)
{
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke( uint64_t a1, dispatch_data_s *a2, uint64_t a3)
{
  if (*(_BYTE *)(*(void *)(a1 + 40) + 128LL))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 112));
    if (a2)
    {
      int v6 = *(dispatch_data_s **)(v5 + 104);
      if (v6)
      {
        if (a3)
        {
          int is_wake_packet = nw_content_context_get_is_wake_packet();
          int v6 = *(dispatch_data_s **)(v5 + 104);
          if (is_wake_packet)
          {
            size_t size = dispatch_data_get_size(*(dispatch_data_t *)(v5 + 104));
            *(void *)(v5 + 136) = size;
            *(void *)(v5 + 144) = dispatch_data_get_size(a2) + size;
          }
        }

        dispatch_data_t concat = dispatch_data_create_concat(v6, a2);
        dispatch_release(*(dispatch_object_t *)(v5 + 104));
        *(void *)(v5 + 104) = concat;
      }

      else
      {
        *(void *)(v5 + 104) = a2;
        dispatch_retain(a2);
        if (a3 && nw_content_context_get_is_wake_packet())
        {
          *(void *)(v5 + 136) = 0LL;
          *(void *)(v5 + 144) = dispatch_data_get_size(a2);
        }
      }
    }

    else
    {
      *(_BYTE *)(v5 + 129) = 1;
    }

    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 112));
  }

void TCPIO_Delegate::bufferedRead(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = *(dispatch_queue_s **)(a1 + 40);
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 3321888768LL;
  v15[2] = ___ZN14TCPIO_Delegate12bufferedReadEjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke;
  v15[3] = &unk_189C0A6C8;
  v15[5] = v18;
  unint64_t v16 = v19;
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  int v17 = a2;
  v15[4] = a3;
  dispatch_async(v6, v15);
  int v9 = v16;
  if (v16)
  {
    unint64_t v10 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  unint64_t v12 = v19;
  if (v19)
  {
    unint64_t v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_261( uint64_t a1, dispatch_object_t object, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (object)
  {
    dispatch_retain(object);
    CFRetain(*(CFTypeRef *)(v4 + 8));
    uint64_t v8 = *(void *)(a1 + 40);
    char v7 = (void *)(a1 + 40);
    v22[5] = a3;
    v22[6] = v4;
    v22[4] = object;
    (*(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, void (*)(uint64_t), void *))(*(void *)v8 + 96LL))( v8,  v22,  v9,  v10,  v11,  v12,  v13,  v14,  MEMORY[0x1895F87A8],  3221225472LL,  ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_3,  &unk_189C194B0);
  }

  else
  {
    CFRetain(*(CFTypeRef *)(v4 + 8));
    uint64_t v15 = *(void *)(a1 + 40);
    char v7 = (void *)(a1 + 40);
    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 3221225472LL;
    v23[2] = ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_2;
    v23[3] = &__block_descriptor_40_e5_v8__0l;
    v23[4] = v4;
    (*(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, void))(*(void *)v15 + 96LL))( v15,  v23,  v16,  v17,  v18,  v19,  v20,  v21,  v22[0],  v22[1],  v22[2],  v22[3]);
  }

  (*(void (**)(void))(*(void *)*v7 + 48LL))(*v7);
  CFRelease(*(CFTypeRef *)(v4 + 8));
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_2(uint64_t a1)
{
  CFStreamStatus v1 = *(void *)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite(v1);
  CFRelease(*(CFTypeRef *)(v1 + 8));
}

void ___ZN21__NSCFTCPIOReadStream17issueDelegateReadEv_block_invoke_3(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  CFStreamStatus v2 = *(void *)(a1 + 48);
  uint64_t v4 = *(dispatch_data_s **)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 112));
  uint64_t v5 = *(dispatch_data_s **)(v2 + 104);
  if (v5)
  {
    if (v3)
    {
      int is_wake_packet = nw_content_context_get_is_wake_packet();
      uint64_t v5 = *(dispatch_data_s **)(v2 + 104);
      if (is_wake_packet)
      {
        size_t size = dispatch_data_get_size(*(dispatch_data_t *)(v2 + 104));
        *(void *)(v2 + 136) = size;
        *(void *)(v2 + 144) = dispatch_data_get_size(v4) + size;
      }
    }

    dispatch_data_t concat = dispatch_data_create_concat(v5, v4);
    dispatch_release(*(dispatch_object_t *)(v2 + 104));
    *(void *)(v2 + 104) = concat;
  }

  else
  {
    *(void *)(v2 + 104) = v4;
    dispatch_retain(v4);
    if (v3 && nw_content_context_get_is_wake_packet())
    {
      *(void *)(v2 + 136) = 0LL;
      *(void *)(v2 + 144) = dispatch_data_get_size(v4);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 112));
  __NSCFTCPIOReadStream::_onss_excite(v2);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  CFRelease(*(CFTypeRef *)(v2 + 8));
}

void ___ZN14TCPIO_Delegate12bufferedReadEjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 56);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v15,  *(void *)(v3 + 8),  *(std::__shared_weak_count **)(v3 + 16));
  uint64_t v4 = *(void *)(v3 + 24);
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3321888768LL;
  v13[2] = ___ZN14TCPIO_Delegate13bufferedRead0EjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke;
  v13[3] = &unk_189C0A700;
  v13[5] = v15;
  uint64_t v14 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  v13[4] = v2;
  TransportConnectionObjCPP::read(v4, 1LL, v1, (uint64_t)v13);
  char v7 = v14;
  if (v14)
  {
    uint64_t v8 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  uint64_t v10 = v16;
  if (v16)
  {
    uint64_t v11 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

void sub_182AC47DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    p_shared_owners = (unint64_t *)&a16->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }

  uint64_t v20 = *(std::__shared_weak_count **)(v16 - 40);
  if (v20)
  {
    uint64_t v21 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t ___ZN14TCPIO_Delegate13bufferedRead0EjU13block_pointerFvPU27objcproto16OS_dispatch_data8NSObjectPU32objcproto21OS_nw_content_contextS0_E_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(v5 + 4_Block_object_dispose(va, 8) = a4;
  *(void *)(v5 + 56) = a5;
  if (!a2) {
    *(_BYTE *)(v5 + 64) = 1;
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t __copy_helper_block_e8_40c49_ZTSNSt3__110shared_ptrI21__NSCFTCPIOReadStreamEE( uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 4_Block_object_dispose(va, 8) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_40c49_ZTSNSt3__110shared_ptrI21__NSCFTCPIOReadStreamEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void std::__shared_ptr_pointer<__NSCFTCPIOReadStream *,__NSCFTCPIOReadStream::issueDelegateRead(void)::{lambda(__NSCFTCPIOReadStream *)#1},std::allocator<__NSCFTCPIOReadStream>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<__NSCFTCPIOReadStream *,__NSCFTCPIOReadStream::issueDelegateRead(void)::{lambda(__NSCFTCPIOReadStream *)#1},std::allocator<__NSCFTCPIOReadStream>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1) {
    CFRelease(*(CFTypeRef *)(v1 + 8));
  }
}

void TCPIO_Delegate::closeReadSide(TCPIO_Delegate *this)
{
  uint64_t v2 = (dispatch_queue_s *)*((void *)this + 5);
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3321888768LL;
  v11[2] = ___ZN14TCPIO_Delegate13closeReadSideEv_block_invoke;
  v11[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14TCPIO_DelegateEE_e5_v8__0l;
  v11[4] = v13;
  unint64_t v12 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }

  dispatch_async(v2, v11);
  uint64_t v5 = v12;
  if (v12)
  {
    unint64_t v6 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  uint64_t v8 = v14;
  if (v14)
  {
    unint64_t v9 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

void *___ZN14TCPIO_Delegate13closeReadSideEv_block_invoke(void *result)
{
  uint64_t v1 = result[4];
  *(_BYTE *)(v1 + 65) = 1;
  if (*(_BYTE *)(v1 + 88))
  {
    uint64_t v2 = *(void *)(v1 + 24);
    if (v2)
    {
      __n128 result = *(void **)(v2 + 24);
      if (result)
      {
        if (!*(_BYTE *)(v2 + 40))
        {
          *(_BYTE *)(v2 + 40) = 1;
          return (void *)(*(uint64_t (**)(void *, void))(*result + 152LL))(result, 0LL);
        }
      }
    }
  }

  return result;
}

BOOL ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke( void *a1, int a2, uint64_t a3, void *__src, size_t a5)
{
  size_t v5 = a1[5] - *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  if (!v5) {
    return 0LL;
  }
  if (v5 >= a5) {
    size_t v8 = a5;
  }
  else {
    size_t v8 = a1[5] - *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  }
  memcpy((void *)(a1[6] + a3), __src, v8);
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) += v8;
  return a1[5] > *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
}

void ___ZN21__NSCFTCPIOReadStream16_streamImpl_ReadEP14__CFReadStreamPhlP13CFStreamErrorS2__block_invoke_2( uint64_t a1)
{
  CFStreamStatus v1 = *(void *)(a1 + 32);
  __NSCFTCPIOReadStream::_onss_excite(v1);
  CFRelease(*(CFTypeRef *)(v1 + 8));
}

void TCPIO_Delegate::~TCPIO_Delegate(TCPIO_Delegate *this)
{
}

{
  uint64_t v2;
  char *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  dispatch_queue_s *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  void block[5];
  __int128 v16;
  void v17[7];
  std::__shared_weak_count *v18;
  *(void *)this = off_189C0ABB0;
  v17[0] = 0LL;
  v17[1] = v17;
  v17[2] = 0x4012000000LL;
  v17[3] = __Block_byref_object_copy__5961;
  v17[4] = __Block_byref_object_dispose__5962;
  uint64_t v3 = (char *)this + 24;
  uint64_t v2 = *((void *)this + 3);
  void v17[5] = &unk_182CE6F99;
  void v17[6] = v2;
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 4);
  uint64_t v18 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  uint64_t v16 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 24, &v16);
  unint64_t v7 = (std::__shared_weak_count *)*((void *)&v16 + 1);
  if (*((void *)&v16 + 1))
  {
    size_t v8 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  unint64_t v10 = (dispatch_queue_s *)*((void *)this + 5);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN14TCPIO_DelegateD2Ev_block_invoke;
  block[3] = &unk_189C17740;
  block[4] = v17;
  dispatch_async(v10, block);
  dispatch_release(*((dispatch_object_t *)this + 5));
  _Block_object_dispose(v17, 8);
  uint64_t v11 = v18;
  if (v18)
  {
    unint64_t v12 = (unint64_t *)&v18->__shared_owners_;
    do
      uint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v3);
  *(void *)this = off_189C19AE8;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
}

__n128 __Block_byref_object_copy__5961(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  return result;
}

uint64_t __Block_byref_object_dispose__5962(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
}

void ___ZN14TCPIO_DelegateD2Ev_block_invoke(uint64_t a1)
{
  __int128 v4 = 0uLL;
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL, &v4);
  CFStreamStatus v1 = (std::__shared_weak_count *)*((void *)&v4 + 1);
  if (*((void *)&v4 + 1))
  {
    uint64_t v2 = (unint64_t *)(*((void *)&v4 + 1) + 8LL);
    do
      unint64_t v3 = __ldaxr(v2);
    while (__stlxr(v3 - 1, v2));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

void std::__shared_ptr_emplace<TCPIO_Delegate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AB78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCPIO_Delegate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AB78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<TCPIO_Delegate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void __NSCFTCPIOErroredWriteStream::~__NSCFTCPIOErroredWriteStream(__NSCFTCPIOErroredWriteStream *this)
{
  *(void *)this = off_189C19AE8;
  *((void *)this + 1) = 0LL;
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_Open( CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a3 = this[1];
  *a4 = 1;
  return 0LL;
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_OpenCompleted( CFStreamError *this, __CFWriteStream *a2, CFStreamError *a3)
{
  *a3 = this[1];
  return 0LL;
}

uint64_t __NSCFTCPIOErroredWriteStream::_streamImpl_Write( CFStreamError *this, __CFWriteStream *a2, const unsigned __int8 *a3, uint64_t a4, CFStreamError *a5)
{
  *a5 = this[1];
  return -1LL;
}

void __NSCFTCPIOErroredReadStream::~__NSCFTCPIOErroredReadStream(__NSCFTCPIOErroredReadStream *this)
{
  *(void *)this = off_189C19AE8;
  *((void *)this + 1) = 0LL;
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_Open( CFStreamError *this, __CFReadStream *a2, CFStreamError *a3, unsigned __int8 *a4)
{
  *a3 = this[1];
  *a4 = 1;
  return 0LL;
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_OpenCompleted( CFStreamError *this, __CFReadStream *a2, CFStreamError *a3)
{
  *a3 = this[1];
  return 0LL;
}

uint64_t __NSCFTCPIOErroredReadStream::_streamImpl_Read( CFStreamError *this, __CFReadStream *a2, unsigned __int8 *a3, uint64_t a4, CFStreamError *a5, unsigned __int8 *a6)
{
  *a5 = this[1];
  *a6 = 1;
  return -1LL;
}

void std::__shared_ptr_pointer<HTTPProtocol *,Deleter_release<HTTPProtocol>,std::allocator<HTTPProtocol>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_5975()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(void *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182AC51D4(_Unwind_Exception *a1)
{
}

void sub_182AC58F8(_Unwind_Exception *a1)
{
}

void sub_182AC5A5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_182AC5B94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_182AC60C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_182AC63EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void std::allocate_shared[abi:nn180100]<TCPIO_Establish,std::allocator<TCPIO_Establish>,__NSCFTCPIOStreamTask *&,void>( void *a1, uint64_t a2)
{
  __int128 v4 = (std::__shared_weak_count *)operator new(0x60uLL);
  *(_OWORD *)&v4->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A938;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C0A970;
  unint64_t v6 = v4 + 1;
  *(_OWORD *)&v4[1].__shared_owners_ = 0u;
  v4[2].__vftable = (std::__shared_weak_count_vtbl *)&unk_189C0AA30;
  v4[2].__shared_weak_owners_ = a2;
  v4[2].__shared_owners_ = (uint64_t)objc_alloc_init(&OBJC_CLASS_____NSCFTCPIO_BlockCallbacks_Referent);
  v4[3].__vftable = 0LL;
  v4[3].__shared_owners_ = 0LL;
  LOWORD(v4[3].__shared_weak_owners_) = 0;
  *a1 = v4 + 1;
  a1[1] = v4;
  shared_weak_owners = (std::__shared_weak_count *)v4[1].__shared_weak_owners_;
  if (shared_weak_owners)
  {
    if (shared_weak_owners->__shared_owners_ != -1) {
      return;
    }
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_weak_owners);
    while (__stxr(v10 + 1, p_shared_weak_owners));
    v4[1].__shared_owners_ = (uint64_t)v6;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }

  else
  {
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
    unint64_t v12 = (unint64_t *)&v4->__shared_weak_owners_;
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    v4[1].__shared_owners_ = (uint64_t)v6;
    v4[1].__shared_weak_owners_ = (uint64_t)v4;
  }

  do
    unint64_t v14 = __ldaxr(p_shared_owners);
  while (__stlxr(v14 - 1, p_shared_owners));
  if (!v14)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }

void sub_182AC6614(_Unwind_Exception *a1)
{
  v1[1].__vftable = (std::__shared_weak_count_vtbl *)off_189C19AE8;
  shared_weak_owners = (std::__shared_weak_count *)v1[1].__shared_weak_owners_;
  if (shared_weak_owners) {
    std::__shared_weak_count::__release_weak(shared_weak_owners);
  }
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v4);
  _Unwind_Resume(a1);
}

void TCPIO_Establish::~TCPIO_Establish(TCPIO_Establish *this)
{
}

{
  std::__shared_weak_count *v2;
  *(void *)this = off_189C0A970;
  *((void *)this + 3) = &unk_189C0AA30;

  *(void *)this = off_189C19AE8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void TCPIO_Establish::initialize(TCPIO_Establish *this, NSString *a2, uint64_t a3)
{
  size_t v5 = (const void *)-[NSString copy](a2, "copy");
  *((void *)this + 6) = v5;
  *((void *)this + 7) = a3;
  uint64_t v6 = *((void *)this + 5);
  if (v6)
  {
    unint64_t v7 = (uint64_t *)(v6 + 784);
    uint64_t v8 = *v7;
    unint64_t v9 = (std::__shared_weak_count *)v7[1];
    uint64_t v47 = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
      size_t v5 = (const void *)*((void *)this + 6);
    }

    if (v5) {
      goto LABEL_7;
    }
LABEL_9:
    unint64_t v12 = 0LL;
    goto LABEL_10;
  }

  uint64_t v8 = 0LL;
  uint64_t v47 = 0LL;
  if (!v5) {
    goto LABEL_9;
  }
LABEL_7:
  unint64_t v12 = (std::__shared_weak_count_vtbl *)CFRetain(v5);
LABEL_10:
  unint64_t v13 = (std::__shared_weak_count *)operator new(0x20uLL);
  v13->__shared_owners_ = 0LL;
  unint64_t v14 = (unint64_t *)&v13->__shared_owners_;
  v13->__vftable = (std::__shared_weak_count_vtbl *)off_189C17020;
  v13->__shared_weak_owners_ = 0LL;
  v13[1].__vftable = v12;
  __int16 v46 = v13;
  uint64_t v15 = *((unsigned int *)this + 14);
  uint64_t v16 = *(void *)(v8 + 24);
  uint64_t v49 = v12;
  uint64_t v50 = v13;
  do
    unint64_t v17 = __ldxr(v14);
  while (__stxr(v17 + 1, v14));
  (*(void (**)(uint64_t, std::__shared_weak_count_vtbl **, uint64_t))(*(void *)v16 + 16LL))(v16, &v49, v15);
  uint64_t v18 = v50;
  if (v50)
  {
    unint64_t v19 = (unint64_t *)&v50->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  if (v46)
  {
    uint64_t v21 = (unint64_t *)&v46->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }

  if (v47)
  {
    uint64_t v23 = (unint64_t *)&v47->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }

  unint64_t v25 = (void *)*((void *)this + 5);
  if (v25)
  {
    uint64_t v26 = v25[98];
    uint64_t v27 = (std::__shared_weak_count *)v25[99];
    int v48 = v27;
    if (v27)
    {
      unint64_t v28 = (unint64_t *)&v27->__shared_owners_;
      do
        unint64_t v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
      unint64_t v25 = (void *)*((void *)this + 5);
    }
  }

  else
  {
    uint64_t v26 = 0LL;
    int v48 = 0LL;
  }

  uint64_t v30 = [v25 session];
  if (!v30)
  {
    unint64_t v31 = 0LL;
    uint64_t v45 = 0LL;
    goto LABEL_41;
  }

  unint64_t v31 = *(std::__shared_weak_count_vtbl **)(v30 + 16);
  unint64_t v32 = *(std::__shared_weak_count **)(v30 + 24);
  uint64_t v45 = v32;
  if (!v32)
  {
LABEL_41:
    uint64_t v35 = *(void *)(v26 + 24);
    uint64_t v49 = v31;
    uint64_t v50 = 0LL;
    goto LABEL_42;
  }

  unint64_t v33 = (unint64_t *)&v32->__shared_owners_;
  do
    unint64_t v34 = __ldxr(v33);
  while (__stxr(v34 + 1, v33));
  uint64_t v35 = *(void *)(v26 + 24);
  uint64_t v36 = (unint64_t *)&v32->__shared_owners_;
  uint64_t v49 = v31;
  uint64_t v50 = v32;
  do
    unint64_t v37 = __ldxr(v36);
  while (__stxr(v37 + 1, v36));
LABEL_42:
  (*(void (**)(uint64_t, std::__shared_weak_count_vtbl **))(*(void *)v35 + 240LL))(v35, &v49);
  uint64_t v38 = v50;
  if (v50)
  {
    uint64_t v39 = (unint64_t *)&v50->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

  if (v45)
  {
    uint64_t v41 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }

  if (v48)
  {
    uint64_t v43 = (unint64_t *)&v48->__shared_owners_;
    do
      unint64_t v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }

void sub_182AC6980( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
}

void TCPIO_Establish::beginConnection(TCPIO_Establish *this, int a2)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {
    size_t v5 = (uint64_t *)(v4 + 784);
    uint64_t v6 = *v5;
    uint64_t v66 = *v5;
    unint64_t v7 = (std::__shared_weak_count *)v5[1];
    CFMutableDataRef v67 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }
  }

  else
  {
    uint64_t v6 = 0LL;
    uint64_t v66 = 0LL;
    CFMutableDataRef v67 = 0LL;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  unint64_t v10 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *((void *)this + 5);
    *(_DWORD *)__int128 buf = 134218240;
    *(void *)&uint8_t buf[4] = this;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v11;
    _os_log_impl(&dword_18298D000, v10, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", buf, 0x16u);
  }

  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v64,  *((void *)this + 1),  *((std::__shared_weak_count **)this + 2));
  uint64_t v12 = MEMORY[0x1895F87A8];
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3321888768LL;
  aBlock[2] = ___ZN15TCPIO_Establish15beginConnectionEb_block_invoke;
  aBlock[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  aBlock[4] = v64;
  uint64_t v61 = v65;
  if (v65)
  {
    unint64_t v13 = (unint64_t *)&v65->__shared_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  uint64_t v15 = _Block_copy(aBlock);
  CFRange v62 = (char *)this + 24;
  uint64_t v16 = (std::__shared_weak_count *)operator new(0x30uLL);
  v16->__shared_owners_ = 0LL;
  unint64_t v17 = (unint64_t *)&v16->__shared_owners_;
  v16->__vftable = (std::__shared_weak_count_vtbl *)off_189C0B580;
  v16->__shared_weak_owners_ = 0LL;
  v16[1].__vftable = (std::__shared_weak_count_vtbl *)((char *)this + 24);
  v16[1].__shared_owners_ = (uint64_t)v15;
  v16[1].__shared_weak_owners_ = 0LL;
  uint64_t v63 = v16;
  uint64_t v18 = *(void *)(v6 + 24);
  do
    unint64_t v19 = __ldxr(v17);
  while (__stxr(v19 + 1, v17));
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v18 + 144), (uint64_t)this + 24, (uint64_t)v16);
  do
    unint64_t v20 = __ldaxr(v17);
  while (__stlxr(v20 - 1, v17));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }

  uint64_t v21 = (const __CFDictionary *)[*((id *)this + 5) _copySocketStreamProperties];
  unint64_t v22 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (v21)
  {
    CFMutableArrayRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, v21);
    CFRelease(v21);
  }

  else
  {
    CFMutableArrayRef MutableCopy = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  }

  int Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, @"kCFStreamPropertySSLSettings");
  if (Value) {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(v22, 0LL, Value);
  }
  else {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v22, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  }
  CFMutableDictionaryRef v26 = Mutable;
  CFDictionarySetValue(MutableCopy, @"kCFStreamPropertySSLSettings", Mutable);
  if (v26) {
    CFRelease(v26);
  }
  uint64_t v27 = v66;
  if (a2) {
    (*(void (**)(void, uint64_t))(**(void **)(v66 + 24) + 24LL))(*(void *)(v66 + 24), 1LL);
  }
  if (MutableCopy)
  {
    (*(void (**)(void, const __CFDictionary *))(**(void **)(v27 + 24) + 208LL))( *(void *)(v27 + 24),  MutableCopy);
    CFRelease(MutableCopy);
  }

  __int128 v59 = v67;
  if (v67)
  {
    unint64_t v28 = (unint64_t *)&v67->__shared_owners_;
    do
      unint64_t v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }

  uint64_t v30 = *((void *)this + 4);
  v72[0] = v12;
  v72[1] = 3221225472LL;
  v72[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke;
  v72[3] = &unk_189C0AAC0;
  void v72[4] = v30;
  (*(void (**)(void, uint64_t, void *))(**(void **)(v27 + 24) + 200LL))( *(void *)(v27 + 24),  0x18C5AC410LL,  v72);
  v71[0] = v12;
  v71[1] = 3221225472LL;
  v71[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_3;
  v71[3] = &unk_189C0AAC0;
  v71[4] = v30;
  (*(void (**)(void, uint64_t, void *))(**(void **)(v27 + 24) + 200LL))( *(void *)(v27 + 24),  0x18C5AC608LL,  v71);
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( buf,  *((void *)this + 1),  *((std::__shared_weak_count **)this + 2));
  uint64_t v32 = *(void *)buf;
  unint64_t v31 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    unint64_t v33 = (unint64_t *)(*(void *)&buf[8] + 16LL);
    do
      unint64_t v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
    uint64_t v35 = (unint64_t *)&v31->__shared_owners_;
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

  if (v59)
  {
    p_shared_weak_owners = (unint64_t *)&v59->__shared_weak_owners_;
    do
      unint64_t v38 = __ldxr(p_shared_weak_owners);
    while (__stxr(v38 + 1, p_shared_weak_owners));
  }

  *(void *)__int128 buf = v12;
  *(void *)&buf[8] = 3321888768LL;
  *(void *)&uint8_t buf[16] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5;
  uint64_t v74 = &unk_189C0AAE8;
  uint64_t v75 = v30;
  uint64_t v76 = v27;
  CFIndex v77 = v59;
  if (v59)
  {
    uint64_t v39 = (unint64_t *)&v59->__shared_weak_owners_;
    do
      unint64_t v40 = __ldxr(v39);
    while (__stxr(v40 + 1, v39));
  }

  uint64_t v78 = v32;
  size_t v79 = v31;
  if (v31)
  {
    uint64_t v41 = (unint64_t *)&v31->__shared_weak_owners_;
    do
      unint64_t v42 = __ldxr(v41);
    while (__stxr(v42 + 1, v41));
  }

  (*(void (**)(void, uint64_t, _BYTE *))(**(void **)(v27 + 24) + 200LL))( *(void *)(v27 + 24),  0x18C5AC288LL,  buf);
  v70[0] = v12;
  v70[1] = 3221225472LL;
  v70[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_276;
  v70[3] = &unk_189C0AB20;
  v70[4] = v30;
  (*(void (**)(void, uint64_t, void *))(**(void **)(v27 + 24) + 200LL))( *(void *)(v27 + 24),  0x18C5AC2C0LL,  v70);
  v69[0] = v12;
  v69[1] = 3221225472LL;
  v69[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_3_280;
  v69[3] = &unk_189C0AB48;
  v69[4] = v30;
  (*(void (**)(void, uint64_t, void *))(**(void **)(v27 + 24) + 200LL))( *(void *)(v27 + 24),  0x18C5AC138LL,  v69);
  v68[0] = v12;
  v68[1] = 3221225472LL;
  v68[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5_282;
  v68[3] = &unk_189C1A548;
  v68[4] = v30;
  (*(void (**)(void, uint64_t, void *))(**(void **)(v27 + 24) + 200LL))( *(void *)(v27 + 24),  0x18C5AC170LL,  v68);
  if (v79) {
    std::__shared_weak_count::__release_weak(v79);
  }
  if (v77) {
    std::__shared_weak_count::__release_weak(v77);
  }
  if (v59) {
    std::__shared_weak_count::__release_weak(v59);
  }
  if (v31) {
    std::__shared_weak_count::__release_weak(v31);
  }
  if (v59)
  {
    uint64_t v43 = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }

  uint64_t v45 = v66;
  (*(void (**)(void, uint64_t, void))(**(void **)(v66 + 24) + 200LL))( *(void *)(v66 + 24),  0x18C5ACC60LL,  *MEMORY[0x189604DE8]);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  __int16 v46 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_18298D000, v46, OS_LOG_TYPE_DEFAULT, "StreamTask opening connection", buf, 2u);
  }

  (*(void (**)(void))(**(void **)(v45 + 24) + 32LL))(*(void *)(v45 + 24));
  uint64_t v47 = v63;
  if (v63)
  {
    int v48 = (unint64_t *)&v63->__shared_owners_;
    do
      unint64_t v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }

  uint64_t v50 = v61;
  if (v61)
  {
    uint64_t v51 = (unint64_t *)&v61->__shared_owners_;
    do
      unint64_t v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }

  uint64_t v53 = v65;
  if (v65)
  {
    uint64_t v54 = (unint64_t *)&v65->__shared_owners_;
    do
      unint64_t v55 = __ldaxr(v54);
    while (__stlxr(v55 - 1, v54));
    if (!v55)
    {
      ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
      std::__shared_weak_count::__release_weak(v53);
    }
  }

  char v56 = v67;
  if (v67)
  {
    char v57 = (unint64_t *)&v67->__shared_owners_;
    do
      unint64_t v58 = __ldaxr(v57);
    while (__stlxr(v58 - 1, v57));
    if (!v58)
    {
      ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
      std::__shared_weak_count::__release_weak(v56);
    }
  }

void sub_182AC7130( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20, uint64_t a21, char a22)
{
  CFMutableDictionaryRef v26 = *(std::__shared_weak_count **)(v24 - 128);
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v24 - 144);
  if (v27)
  {
    std::__shared_weak_count::__release_weak(v27);
    if (!v23)
    {
LABEL_5:
      if (!v22)
      {
LABEL_10:
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
        std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
        _Unwind_Resume(a1);
      }

void TCPIO_Establish::endConnection(TCPIO_Establish *this)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v2 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 5);
    int v12 = 134218240;
    unint64_t v13 = this;
    __int16 v14 = 2048;
    uint64_t v15 = v3;
    _os_log_impl(&dword_18298D000, v2, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", (uint8_t *)&v12, 0x16u);
  }

  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {
    uint64_t v5 = v4 + 784;
    uint64_t v6 = *(void *)(v4 + 784);
    unint64_t v7 = *(std::__shared_weak_count **)(v5 + 8);
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v9 = __ldxr(p_shared_owners);
      while (__stxr(v9 + 1, p_shared_owners));
    }

    if (v6) {
      TransportConnection::rstConnectionEstablishmentDelegate(*(TransportConnection **)(v6 + 24));
    }
    if (*((void *)this + 5)) {
      *((void *)this + 5) = 0LL;
    }
    if (v7)
    {
      unint64_t v10 = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }

uint64_t TCPIO_Establish::connectionEstablished(id *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  uint64_t result = objc_msgSend(this[5], "_onqueue_cleanUpConnectionEstablishmentState");
  if (!*((_BYTE *)this + 65))
  {
    *((_BYTE *)this + 65) = 1;
    return objc_msgSend(this[5], "_onqueue_connectionEstablishedWithError:callbackReferent:", domain, v2, this[4]);
  }

  return result;
}

void TCPIO_Establish::beginSecureConnection(TCPIO_Establish *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = (uint64_t *)(v2 + 784);
    uint64_t v4 = *v3;
    uint64_t v33 = *v3;
    uint64_t v5 = (std::__shared_weak_count *)v3[1];
    unint64_t v34 = v5;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    uint64_t v33 = 0LL;
    unint64_t v34 = 0LL;
  }

  v29[0] = MEMORY[0x1895F87A8];
  v29[1] = 3321888768LL;
  _OWORD v29[2] = ___ZN15TCPIO_Establish21beginSecureConnectionEv_block_invoke;
  v29[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  v29[4] = v35;
  uint64_t v30 = v36;
  if (v36)
  {
    uint64_t v8 = (unint64_t *)&v36->__shared_owners_;
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  unint64_t v10 = _Block_copy(v29);
  unint64_t v11 = (std::__shared_weak_count_vtbl *)((char *)this + 24);
  unint64_t v31 = (char *)this + 24;
  int v12 = (std::__shared_weak_count *)operator new(0x30uLL);
  v12->__shared_owners_ = 0LL;
  unint64_t v13 = (unint64_t *)&v12->__shared_owners_;
  v12->__vftable = (std::__shared_weak_count_vtbl *)off_189C0B580;
  v12->__shared_weak_owners_ = 0LL;
  v12[1].__vftable = v11;
  v12[1].__shared_owners_ = (uint64_t)v10;
  v12[1].__shared_weak_owners_ = 0LL;
  uint64_t v32 = v12;
  uint64_t v14 = *(void *)(v4 + 24);
  do
    unint64_t v15 = __ldxr(v13);
  while (__stxr(v15 + 1, v13));
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v14 + 144), (uint64_t)v11, (uint64_t)v12);
  do
    unint64_t v16 = __ldaxr(v13);
  while (__stlxr(v16 - 1, v13));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }

  (*(void (**)(void, uint64_t))(**(void **)(v33 + 24) + 24LL))(*(void *)(v33 + 24), 1LL);
  unint64_t v17 = v32;
  if (v32)
  {
    uint64_t v18 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  unint64_t v20 = v30;
  if (v30)
  {
    uint64_t v21 = (unint64_t *)&v30->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  uint64_t v23 = v34;
  if (v34)
  {
    uint64_t v24 = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  CFMutableDictionaryRef v26 = v36;
  if (v36)
  {
    uint64_t v27 = (unint64_t *)&v36->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

void sub_182AC75D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 64);
  _Unwind_Resume(a1);
}

void TCPIO_Establish::endSecureConnection(TCPIO_Establish *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = (uint64_t *)(v2 + 784);
    uint64_t v4 = *v3;
    uint64_t v32 = *v3;
    uint64_t v5 = (std::__shared_weak_count *)v3[1];
    uint64_t v33 = v5;
    if (v5)
    {
      p_shared_owners = (unint64_t *)&v5->__shared_owners_;
      do
        unint64_t v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
  }

  else
  {
    uint64_t v4 = 0LL;
    uint64_t v32 = 0LL;
    uint64_t v33 = 0LL;
  }

  v28[0] = MEMORY[0x1895F87A8];
  v28[1] = 3321888768LL;
  v28[2] = ___ZN15TCPIO_Establish19endSecureConnectionEv_block_invoke;
  v28[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
  v28[4] = v34;
  unint64_t v29 = v35;
  if (v35)
  {
    uint64_t v8 = (unint64_t *)&v35->__shared_owners_;
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  uint64_t v10 = _Block_copy(v28);
  unint64_t v11 = (std::__shared_weak_count_vtbl *)((char *)this + 24);
  uint64_t v30 = (char *)this + 24;
  uint64_t v12 = (std::__shared_weak_count *)operator new(0x30uLL);
  v12->__shared_owners_ = 0LL;
  unint64_t v13 = (unint64_t *)&v12->__shared_owners_;
  v12->__vftable = (std::__shared_weak_count_vtbl *)off_189C0B580;
  v12->__shared_weak_owners_ = 0LL;
  v12[1].__vftable = v11;
  v12[1].__shared_owners_ = (uint64_t)v10;
  v12[1].__shared_weak_owners_ = 0LL;
  unint64_t v31 = v12;
  if (!v4) {
    goto LABEL_16;
  }
  uint64_t v14 = *(void *)(v4 + 24);
  do
    unint64_t v15 = __ldxr(v13);
  while (__stxr(v15 + 1, v13));
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v14 + 144), (uint64_t)v11, (uint64_t)v12);
  do
    unint64_t v16 = __ldaxr(v13);
  while (__stlxr(v16 - 1, v13));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }

  (*(void (**)(void, void))(**(void **)(v32 + 24) + 24LL))(*(void *)(v32 + 24), 0LL);
  uint64_t v12 = v31;
  if (v31)
  {
LABEL_16:
    unint64_t v17 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  unint64_t v19 = v29;
  if (v29)
  {
    unint64_t v20 = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  unint64_t v22 = v33;
  if (v33)
  {
    uint64_t v23 = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  unint64_t v25 = v35;
  if (v35)
  {
    CFMutableDictionaryRef v26 = (unint64_t *)&v35->__shared_owners_;
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

void sub_182AC786C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 64);
  _Unwind_Resume(a1);
}

uint64_t TCPIO_Establish::getBlockCallbackReferent(TCPIO_Establish *this)
{
  return *((void *)this + 4);
}

uint64_t TCPIO_Establish::needServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a1 + 40)) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t))(a3 + 16))(a3, 0LL, 1LL);
  }
  uint64_t v6 = *(const __CFString **)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = ___ZN22HTTPProtocolSSLSupport35CreateTrustChallengeWithHostAndPortEPK10__CFStringlP10__SecTrust_block_invoke;
  v10[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
  v10[4] = a2;
  Challenge = (const void *)createChallenge(8, v6, v5, (uint64_t)v10);
  id v8 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:]( &OBJC_CLASS___NSURLAuthenticationChallenge,  "_authenticationChallengeForCFAuthChallenge:sender:",  Challenge,  0LL);
  if (Challenge) {
    CFRelease(Challenge);
  }
  return objc_msgSend(*(id *)(a1 + 40), "_onqueue_needServerTrust:completionHandler:", v8, a3);
}

uint64_t TCPIO_Establish::needClientCert(void *a1, uint64_t a2, uint64_t a3)
{
  if (!a1[5]) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t))(a3 + 16))(a3, 0LL, 1LL);
  }
  uint64_t v5 = MEMORY[0x1895F87A8];
  uint64_t v7 = (const __CFString *)a1[6];
  uint64_t v6 = a1[7];
  v13[0] = MEMORY[0x1895F87A8];
  v13[1] = 3221225472LL;
  v13[2] = ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke;
  v13[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
  v13[4] = a2;
  Challenge = (const void *)createChallenge(7, v7, v6, (uint64_t)v13);
  id v9 = +[NSURLAuthenticationChallenge _authenticationChallengeForCFAuthChallenge:sender:]( &OBJC_CLASS___NSURLAuthenticationChallenge,  "_authenticationChallengeForCFAuthChallenge:sender:",  Challenge,  0LL);
  if (Challenge) {
    CFRelease(Challenge);
  }
  uint64_t v10 = (void *)a1[5];
  v12[0] = v5;
  v12[1] = 3221225472LL;
  v12[2] = ___ZN15TCPIO_Establish14needClientCertEPK9__CFArrayU13block_pointerFvS2_bE_block_invoke;
  v12[3] = &unk_189C15088;
  v12[4] = a3;
  return objc_msgSend(v10, "_onqueue_needClientCert:completionHandler:", v9, v12);
}

uint64_t TCPIO_Establish::preConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  id v8 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(a1 + 40);
    int v12 = 134218240;
    uint64_t v13 = a1;
    __int16 v14 = 2048;
    uint64_t v15 = v9;
    _os_log_impl(&dword_18298D000, v8, OS_LOG_TYPE_DEFAULT, "Establish Object : %p .Task : %p", (uint8_t *)&v12, 0x16u);
  }

  uint64_t v10 = *(void **)(a1 + 40);
  if (v10) {
    return objc_msgSend(v10, "_onqueue_preConnectionConfiguration:parameters:completionHandler:", a2, a3, a4);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
  }
}

uint64_t TCPIO_Establish::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a1 + 40);
  if (v4) {
    return objc_msgSend(v4, "_onqueue_postConnectConfiguration:parameters:completionHandler:", a2, a3, a4);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
  }
}

void TCPIO_Establish::setTransportConnection(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  objc_msgSend(v2, "_onqueue_setTransportConnection:", &v9);
  uint64_t v6 = v10;
  if (v10)
  {
    uint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182AC7C54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TCPIO_Establish::connectionTLSEnabled(id *this)
{
  return objc_msgSend(this[5], "_onqueue_tlsCompletion");
}

uint64_t TCPIO_Establish::connectionTLSDisabled(id *this)
{
  return objc_msgSend(this[5], "_onqueue_tlsDisabled");
}

void TCPIO_Establish::connectionWaitingNotification(uint64_t a1)
{
  if (objc_msgSend((id)objc_msgSend(*(id *)(a1 + 40), "_effectiveConfiguration"), "waitsForConnectivity")
    && !*(_BYTE *)(a1 + 64))
  {
    *(_BYTE *)(a1 + 64) = 1;
    uint64_t v2 = *(void **)(a1 + 40);
    if (v2)
    {
      uint64_t v3 = v2[88];
      if (!v3) {
        uint64_t v3 = v2[87];
      }
    }

    else
    {
      uint64_t v3 = 0LL;
    }

    -[__NSCFURLSessionDelegateWrapper taskIsWaitingForConnectivity:](v3, v2);
  }

void non-virtual thunk to'TCPIO_Establish::~TCPIO_Establish(TCPIO_Establish *this)
{
}

{
  void *v1;
  TCPIO_Establish::~TCPIO_Establish((TCPIO_Establish *)((char *)this - 24));
  operator delete(v1);
}

uint64_t non-virtual thunk to'TCPIO_Establish::preConnectConfiguration( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return TCPIO_Establish::preConnectConfiguration(a1 - 24, a2, a3, a4);
}

uint64_t non-virtual thunk to'TCPIO_Establish::postConnectConfiguration( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(a1 + 16);
  if (v4) {
    return objc_msgSend(v4, "_onqueue_postConnectConfiguration:parameters:completionHandler:", a2, a3, a4);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
  }
}

uint64_t non-virtual thunk to'TCPIO_Establish::needServerTrust(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return TCPIO_Establish::needServerTrust(a1 - 24, a2, a3);
}

uint64_t non-virtual thunk to'TCPIO_Establish::needClientCert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return TCPIO_Establish::needClientCert((void *)(a1 - 24), a2, a3);
}

uint64_t non-virtual thunk to'TCPIO_Establish::connectionEstablished(id *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  CFIndex domain = a2.domain;
  uint64_t result = objc_msgSend(this[2], "_onqueue_cleanUpConnectionEstablishmentState");
  if (!*((_BYTE *)this + 41))
  {
    *((_BYTE *)this + 41) = 1;
    return objc_msgSend(this[2], "_onqueue_connectionEstablishedWithError:callbackReferent:", domain, v2, this[1]);
  }

  return result;
}

uint64_t non-virtual thunk to'TCPIO_Establish::connectionTLSEnabled(id *this)
{
  return objc_msgSend(this[2], "_onqueue_tlsCompletion");
}

uint64_t non-virtual thunk to'TCPIO_Establish::connectionTLSDisabled(id *this)
{
  return objc_msgSend(this[2], "_onqueue_tlsDisabled");
}

void non-virtual thunk to'TCPIO_Establish::connectionWaitingNotification(uint64_t a1)
{
}

void non-virtual thunk to'TCPIO_Establish::setTransportConnection(uint64_t a1, uint64_t *a2)
{
}

void sub_182AC7E24(_Unwind_Exception *exception_object)
{
  void *v1 = off_189C19AE8;
  uint64_t v3 = (std::__shared_weak_count *)v1[2];
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN15TCPIO_Establish14needClientCertEPK9__CFArrayU13block_pointerFvS2_bE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t __copy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE( uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke( TCPIO_BlockCallbacks_Listener *result)
{
  id var3 = result->var1.var3;
  if (var3)
  {
    uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (v2) {
      TCPIO_BlockCallbacks_Listener::receiveEvent(v2, @"_kCFStreamPropertyExcessiveKeepalivesBlock");
    }
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 2);
    if (result) {
      return (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::receiveEvent( result,  @"_kCFStreamPropertyExcessiveKeepalivesBlock");
    }
  }

  return result;
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_3( TCPIO_BlockCallbacks_Listener *result)
{
  id var3 = result->var1.var3;
  if (var3)
  {
    uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (v2) {
      TCPIO_BlockCallbacks_Listener::receiveEvent(v2, @"_kCFStreamPropertyLowThroughputBlock");
    }
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 2);
    if (result) {
      return (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::receiveEvent( result,  @"_kCFStreamPropertyLowThroughputBlock");
    }
  }

  return result;
}

void ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5( void *a1, int a2, uint64_t a3)
{
  uint64_t v5 = a1[4];
  if (!v5)
  {
    char v7 = 0;
    if ((_DWORD)a3) {
      return;
    }
    goto LABEL_8;
  }

  uint64_t v6 = *(TCPIO_BlockCallbacks_Listener **)(v5 + 8);
  if (v6) {
    char v7 = TCPIO_BlockCallbacks_Listener::receiveEvent(v6, @"_kCFStreamPropertyConnectionViabilityChangedBlock", a3);
  }
  else {
    char v7 = 0;
  }
  unint64_t v8 = *(TCPIO_BlockCallbacks_Listener **)(v5 + 16);
  if (v8) {
    v7 |= TCPIO_BlockCallbacks_Listener::receiveEvent( v8,  @"_kCFStreamPropertyConnectionViabilityChangedBlock",  a3);
  }
  if (!(_DWORD)a3)
  {
LABEL_8:
    if ((v7 & 1) == 0)
    {
      uint64_t v9 = (std::__shared_weak_count *)a1[6];
      if (v9 && (uint64_t v10 = std::__shared_weak_count::lock(v9), (v31 = v10) != 0LL))
      {
        unint64_t v11 = v10;
        uint64_t v12 = a1[5];
        uint64_t v30 = v12;
        if (v12)
        {
          uint64_t v13 = *(dispatch_object_t **)(v12 + 24);
          __int16 v14 = (dispatch_queue_s *)v13[15];
          if (!v14 || (dispatch_retain(v13[15]), (uint64_t v13 = *(dispatch_object_t **)(v12 + 24)) != 0LL))
          {
            if (!*(_BYTE *)(v12 + 40))
            {
              *(_BYTE *)(v12 + 40) = 1;
              (*((void (**)(dispatch_object_t *, void))*v13 + 19))(v13, 0LL);
            }
          }
        }

        else
        {
          __int16 v14 = 0LL;
        }

        p_shared_owners = (unint64_t *)&v11->__shared_owners_;
        do
          unint64_t v16 = __ldaxr(p_shared_owners);
        while (__stlxr(v16 - 1, p_shared_owners));
        if (!v16)
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
      }

      else
      {
        __int16 v14 = 0LL;
      }

      unint64_t v17 = (std::__shared_weak_count *)a1[8];
      if (v17)
      {
        unint64_t v18 = std::__shared_weak_count::lock(v17);
        if (v18)
        {
          unint64_t v19 = v18;
          uint64_t v20 = a1[7];
          if (v20)
          {
            if (v14)
            {
              v28[0] = MEMORY[0x1895F87A8];
              v28[1] = 3321888768LL;
              v28[2] = ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_7;
              v28[3] = &__block_descriptor_48_e8_32c47_ZTSNSt3__110shared_ptrI19TCPIO_EstablishBaseEE_e5_v8__0l;
              v28[4] = v20;
              unint64_t v29 = v18;
              unint64_t v21 = (unint64_t *)&v18->__shared_owners_;
              do
                unint64_t v22 = __ldxr(v21);
              while (__stxr(v22 + 1, v21));
              dispatch_async(v14, v28);
              uint64_t v23 = v29;
              if (v29)
              {
                unint64_t v24 = (unint64_t *)&v29->__shared_owners_;
                do
                  unint64_t v25 = __ldaxr(v24);
                while (__stlxr(v25 - 1, v24));
                if (!v25)
                {
                  ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
                  std::__shared_weak_count::__release_weak(v23);
                }
              }
            }
          }

          CFMutableDictionaryRef v26 = (unint64_t *)&v19->__shared_owners_;
          do
            unint64_t v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
        }
      }

      if (v14) {
        dispatch_release(v14);
      }
    }
  }

void sub_182AC8148( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_276( TCPIO_BlockCallbacks_Listener *result, uint64_t a2, unsigned __int8 a3)
{
  id var3 = result->var1.var3;
  if (var3)
  {
    uint64_t v5 = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (v5) {
      TCPIO_BlockCallbacks_Listener::receiveEvent(v5, @"_kCFStreamPropertyConnectionWaitingBlock", a3);
    }
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 2);
    if (result) {
      return (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::receiveEvent( result,  @"_kCFStreamPropertyConnectionWaitingBlock",  a3);
    }
  }

  return result;
}

TCPIO_BlockCallbacks_Listener *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_3_280( TCPIO_BlockCallbacks_Listener *result, int a2, uint64_t a3)
{
  id var3 = result->var1.var3;
  if (var3)
  {
    uint64_t v5 = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 1);
    if (v5) {
      TCPIO_BlockCallbacks_Listener::receiveEvent(v5, (const __CFString *)&unk_18C5AC138, a3);
    }
    uint64_t result = (TCPIO_BlockCallbacks_Listener *)*((void *)var3 + 2);
    if (result) {
      return (TCPIO_BlockCallbacks_Listener *)TCPIO_BlockCallbacks_Listener::receiveEvent( result,  (const __CFString *)&unk_18C5AC138,  a3);
    }
  }

  return result;
}

id *___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_5_282( id *result)
{
  id v1 = result[4];
  if (v1)
  {
    uint64_t v2 = (TCPIO_BlockCallbacks_Listener *)*((void *)v1 + 1);
    if (v2)
    {
      PropertyBlockPtr = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(v2, (CFStringRef)&unk_18C5AC170);
      if (PropertyBlockPtr)
      {
        unint64_t v4 = (void (**)(void))*PropertyBlockPtr;
        if (v4) {
          v4[2]();
        }
      }
    }

    uint64_t result = (id *)*((void *)v1 + 2);
    if (result)
    {
      uint64_t result = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr( (TCPIO_BlockCallbacks_Listener *)result,  (CFStringRef)&unk_18C5AC170);
      if (result)
      {
        uint64_t result = (id *)*result;
        if (result) {
          return (id *)((uint64_t (*)(void))result[2])();
        }
      }
    }
  }

  return result;
}

uint64_t TCPIO_BlockCallbacks_Listener::receiveEvent( TCPIO_BlockCallbacks_Listener *this, const __CFString *a2, uint64_t a3)
{
  uint64_t result = (uint64_t)TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    uint64_t v6 = *(void *)result;
    if (*(void *)result)
    {
      uint64_t v7 = (*((uint64_t (**)(TCPIO_BlockCallbacks_Listener *))this->var0 + 2))(this);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16))(v6, v7, a3);
      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void *__copy_helper_block_e8_40c50_ZTSNSt3__18weak_ptrI25TransportConnectionObjCPPEE56c44_ZTSNSt3__18weak_ptrI19TCPIO_EstablishBaseEE( void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 16);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

void __destroy_helper_block_e8_40c50_ZTSNSt3__18weak_ptrI25TransportConnectionObjCPPEE56c44_ZTSNSt3__18weak_ptrI19TCPIO_EstablishBaseEE( uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t ___ZN15TCPIO_Establish20setupBlockPropertiesENSt3__110shared_ptrI25TransportConnectionObjCPPEE_block_invoke_7( uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 32) + 40LL))( *(void *)(a1 + 32),  1LL,  57LL);
}

id *TCPIO_BlockCallbacks_Listener::receiveEvent(TCPIO_BlockCallbacks_Listener *this, const __CFString *a2)
{
  uint64_t result = TCPIO_BlockCallbacks_Listener::findPropertyBlockPtr(this, a2);
  if (result)
  {
    unint64_t v4 = (uint64_t (**)(id, uint64_t))*result;
    if (*result)
    {
      uint64_t v5 = (*((uint64_t (**)(TCPIO_BlockCallbacks_Listener *))this->var0 + 2))(this);
      return (id *)v4[2](v4, v5);
    }
  }

  return result;
}

void std::__shared_ptr_emplace<TCPIO_Establish>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A938;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCPIO_Establish>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A938;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<TCPIO_Establish>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void std::__shared_ptr_emplace<TransportConnectionObjCPP>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A900;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TransportConnectionObjCPP>::~__shared_ptr_emplace( std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0A900;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<TransportConnectionObjCPP>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_182AC8548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t subclassMissingImplementation(objc_selector *a1, objc_class *a2)
{
  uint64_t v3 = (void *)MEMORY[0x189603F70];
  uint64_t v4 = *MEMORY[0x189603A60];
  Name = sel_getName((SEL)a1);
  return objc_msgSend( v3,  "raise:format:",  v4,  @"*** -%s cannot be sent to an abstract object of class %s: Create a concrete instance!",  Name,  class_getName(a2));
}

void HandySSLSettings::~HandySSLSettings(HandySSLSettings *this)
{
  *(void *)this = off_189C0ABF0;
  id v1 = (const void *)*((void *)this + 1);
  if (v1) {
    CFRelease(v1);
  }
}

{
  const void *v2;
  *(void *)this = off_189C0ABF0;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  operator delete(this);
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24LL)
  {
  }

  a1[1] = v2;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,0>( uint64_t a1)
{
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::shared_ptr<__CoalescingConnectionKey>>,0>( uint64_t a1)
{
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(24 * a1);
}

uint64_t std::set<std::string>::set[abi:nn180100](uint64_t a1, void *a2)
{
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t v3 = a1 + 8;
  *(void *)(a1 + CFRetain((char *)this - 16) = 0LL;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v6 = *(void *)(a1 + 8);
      unint64_t v7 = (void *)v3;
      if (*(void *)a1 == v3) {
        goto LABEL_8;
      }
      unint64_t v8 = *(void **)(a1 + 8);
      uint64_t v9 = (void *)v3;
      if (v6)
      {
        do
        {
          unint64_t v7 = v8;
          unint64_t v8 = (void *)v8[1];
        }

        while (v8);
      }

      else
      {
        do
        {
          unint64_t v7 = (void *)v9[2];
          BOOL v10 = *v7 == (void)v9;
          uint64_t v9 = v7;
        }

        while (v10);
      }

      if (std::less<std::string>::operator()[abi:nn180100](v7 + 4, v5 + 4))
      {
LABEL_8:
        if (!v6)
        {
          unint64_t v16 = (void *)v3;
          unint64_t v11 = (uint64_t **)v3;
LABEL_14:
          std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)&v15, a1, (uint64_t)(v5 + 4));
          std::__tree<std::string>::__insert_node_at((uint64_t **)a1, (uint64_t)v16, v11, v15);
          goto LABEL_15;
        }

        unint64_t v16 = v7;
        unint64_t v11 = (uint64_t **)(v7 + 1);
      }

      else
      {
        unint64_t v11 = (uint64_t **)std::__tree<std::string>::__find_equal<std::string>(a1, &v16, v5 + 4);
      }

      if (!*v11) {
        goto LABEL_14;
      }
LABEL_15:
      uint64_t v12 = (void *)v5[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          uint64_t v13 = (void *)v5[2];
          BOOL v10 = *v13 == (void)v5;
          uint64_t v5 = v13;
        }

        while (!v10);
      }

      uint64_t v5 = v13;
    }

    while (v13 != v4);
  }

  return a1;
}

void sub_182AC8BE0(_Unwind_Exception *a1)
{
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>( __int128 *a1, __int128 *a2, std::string *this)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      if (*((char *)v5 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v5, *((void *)v5 + 1));
      }

      else
      {
        __int128 v6 = *v5;
        this->__r_.__value_.__l.__cap_ = *((void *)v5 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
      }

      uint64_t v5 = (__int128 *)((char *)v5 + 24);
      ++this;
    }

    while (v5 != a2);
  }

  return this;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<std::string>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  id v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }

void std::unique_ptr<std::__tree_node<std::shared_ptr<__CoalescingConnectionKey>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::shared_ptr<__CoalescingConnectionKey>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  id v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<__CoalescingConnectionKey>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  id v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::shared_ptr<__CoalescingConnectionKey>>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }

void *std::__tree<std::string>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *uint64_t result = 0LL;
      while (1)
      {
        uint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          uint64_t result = v4;
          uint64_t v4 = (void *)*v4;
        }

        while (v4);
      }
    }

    else
    {
      for (result[1] = 0LL; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          uint64_t result = v3;
          uint64_t v3 = (void *)*v3;
        }

        while (v3);
      }
    }
  }

  return result;
}

uint64_t std::__tree<std::string>::_DetachedTreeCache::~_DetachedTreeCache[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = *(void *)(v3 + 16);
      }

      while (v3);
      *(void *)(a1 + _Block_object_dispose(va, 8) = v2;
    }

    std::__tree<std::string>::destroy((char *)v2);
  }

  return a1;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::string,void *>>>::operator()[abi:nn180100]( char a1, void **__p)
{
  if (a1)
  {
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  id v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::set<std::shared_ptr<__CoalescingConnectionKey>,CoalescingConnectionKeyComparator,std::allocator<std::shared_ptr<__CoalescingConnectionKey>>>>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }

void std::__shared_ptr_emplace<__CoalescingConnectionKey>::~__shared_ptr_emplace( std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AC10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<__CoalescingConnectionKey>::~__shared_ptr_emplace( std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AC10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t __NSURLSession_CoalescingHelperIsOnDNSNameList(void *a1, void *a2)
{
  uint64_t v3 = a1;
  uint64_t v29 = *MEMORY[0x1895F89C0];
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  uint64_t result = [a1 countByEnumeratingWithState:&v23 objects:v28 count:16];
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)v24;
    uint64_t v17 = *(void *)v24;
    unint64_t v18 = v3;
    do
    {
      for (uint64_t i = 0LL; i != v5; ++i)
      {
        if (*(void *)v24 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = (id)SecCertificateCopyDNSNames();
        __int128 v19 = 0u;
        __int128 v20 = 0u;
        __int128 v21 = 0u;
        __int128 v22 = 0u;
        uint64_t v9 = [v8 countByEnumeratingWithState:&v19 objects:v27 count:16];
        if (v9)
        {
          uint64_t v10 = v9;
          uint64_t v11 = *(void *)v20;
          while (2)
          {
            for (uint64_t j = 0LL; j != v10; ++j)
            {
              if (*(void *)v20 != v11) {
                objc_enumerationMutation(v8);
              }
              uint64_t v13 = *(void **)(*((void *)&v19 + 1) + 8 * j);
              if ((objc_msgSend(v13, "isEqualToString:", a2, v17) & 1) == 0)
              {
                uint64_t v14 = [v13 substringFromIndex:1];
                uint64_t v15 = [a2 rangeOfString:@"."];
                if (!v16
                  || (objc_msgSend((id)objc_msgSend(a2, "substringFromIndex:", v15), "isEqualToString:", v14) & 1) == 0)
                {
                  continue;
                }
              }

              return 1LL;
            }

            uint64_t v10 = [v8 countByEnumeratingWithState:&v19 objects:v27 count:16];
            if (v10) {
              continue;
            }
            break;
          }
        }

        uint64_t v6 = v17;
        uint64_t v3 = v18;
      }

      uint64_t v5 = [v18 countByEnumeratingWithState:&v23 objects:v28 count:16];
      uint64_t result = 0LL;
    }

    while (v5);
  }

  return result;
}

os_log_t ___ZL15H2CoalescingLogv_block_invoke()
{
  os_log_t result = os_log_create("com.apple.CFNetwork", "Coalescing");
  H2CoalescingLog(void)::onceLog = (uint64_t)result;
  return result;
}

void Schedulables::_SchedulablesScheduleApplierFunction(Schedulables *this, uint64_t *a2, void *a3)
{
}

void Schedulables::_SchedulablesUnscheduleApplierFunction(Schedulables *this, uint64_t *a2, void *a3)
{
}

void Schedulables::_SchedulablesInvalidateApplierFunction(Schedulables *this, const void *a2, void *a3)
{
  CFTypeID v4 = CFGetTypeID(this);
  _CFTypeInvalidate((char *)this);
  if (*(void *)(HostBase::Class(void)::sClass_OBJTYPE + 96) == v4)
  {
    CFHostCancelInfoResolution(this, kCFHostAddresses);
  }

  else if (CFNetServiceGetTypeID() == v4)
  {
    CFNetServiceCancel(this);
  }

void Schedulables::_add(Schedulables *this, const void *value)
{
  v4.CFIndex length = *((void *)this + 3);
  v4.CFIndex location = 0LL;
  if (!CFArrayContainsValue(*((CFArrayRef *)this + 2), v4, value))
  {
    CFArrayAppendValue(*((CFMutableArrayRef *)this + 2), value);
    ++*((void *)this + 3);
  }

void Schedulables::_remove(Schedulables *this, const void *value)
{
  v5.CFIndex length = *((void *)this + 3);
  v5.CFIndex location = 0LL;
  FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(*((CFArrayRef *)this + 2), v5, value);
  if (FirstIndexOfValue != -1)
  {
    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 2), FirstIndexOfValue);
    --*((void *)this + 3);
  }

CFStringRef createStringFromSomeAddr( const __CFAllocator *a1, int (*a2)(int, sockaddr *, unsigned int *), const char *a3, uint64_t a4)
{
  int v4 = a4;
  v17[31] = *MEMORY[0x1895F89C0];
  int v11 = 255;
  if (a2(a4, (sockaddr *)&v13, (unsigned int *)&v11))
  {
    __error();
    snprintf(__str, 0x400uLL, "error %d resolving %s address for socket %d");
    return CFStringCreateWithFormat(a1, 0LL, @"%s", __str, v10);
  }

  if (v14 == 2)
  {
    id v8 = &v16;
  }

  else
  {
    if (v14 != 30)
    {
      snprintf(__str, 0x400uLL, "[error %d converting %s address for socket %d]");
      return CFStringCreateWithFormat(a1, 0LL, @"%s", __str, v10);
    }

    id v8 = (int *)v17;
  }

  if (!inet_ntop(v14, v8, __str, 0x400u))
  {
    uint64_t v9 = __error();
    snprintf(__str, 0x400uLL, "[error %d converting %s address for socket %d]", *v9, a3, v4);
  }

  return CFStringCreateWithFormat(a1, 0LL, @"%s:%d", __str, bswap32(v15) >> 16);
}

void sub_182AC9E1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6229(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__6230(uint64_t a1)
{
}

uint64_t HTTP2ConnectionCacheEntry::equals(HTTP2ConnectionCacheEntry *this, const CFObject *a2)
{
  CFTypeID v4 = CFGetTypeID((char *)this - 16);
  uint64_t result = (*(uint64_t (**)(void, void))(**((void **)this + 3) + 24LL))( *((void *)this + 3),  *((void *)a2 + 3));
  if (!(_DWORD)result) {
    return result;
  }
  if (*((_DWORD *)this + 27) == *((_DWORD *)a2 + 27)
    && (CFIndex Count = CFArrayGetCount(*((CFArrayRef *)this + 11)), Count == CFArrayGetCount(*((CFArrayRef *)this + 11)))
    && *((unsigned __int8 *)this + 104) == *((unsigned __int8 *)a2 + 104))
  {
    return *((unsigned __int8 *)this + 105) == *((unsigned __int8 *)a2 + 105);
  }

  else
  {
    return 0LL;
  }

uint64_t HTTP2ConnectionCacheEntry::hash(HTTP2ConnectionCacheEntry *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 3) + 32LL))(*((void *)this + 3));
}

CFStringRef HTTP2ConnectionCacheEntry::copyDebugDesc(HTTP2ConnectionCacheEntry *this)
{
  uint64_t v2 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  uint64_t v3 = (const __CFString *)(*(uint64_t (**)(void))(**((void **)this + 3) + 16LL))(*((void *)this + 3));
  CFTypeID v4 = _cfnAutoreleaseInDebug(v3);
  return CFStringCreateWithFormat(v2, 0LL, @"HTTP2ConnectionCacheEntry(@%p, key=%s)", this, v4);
}

void non-virtual thunk to'HTTP2ConnectionCacheEntry::~HTTP2ConnectionCacheEntry( HTTP2ConnectionCacheEntry *this)
{
}

{
  HTTP2ConnectionCacheEntry::~HTTP2ConnectionCacheEntry((HTTP2ConnectionCacheEntry *)((char *)this - 8));
}

void ___ZN25HTTP2ConnectionCacheEntry21releaseAllConnectionsEv_block_invoke(uint64_t a1, uint64_t a2)
{
}

void ___ZN25HTTP2ConnectionCacheEntry5ClassEv_block_invoke()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  CFClass::CFClass(v0, "HTTP2ConnectionCacheEntry");
  HTTP2ConnectionCacheEntry::Class(void)::sClass_OBJTYPE = (uint64_t)v0;
}

void sub_182ACA018(_Unwind_Exception *a1)
{
}

void ___ZN25HTTP2ConnectionCacheEntry15shouldIdleCloseEdd_block_invoke(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)(a1 + 40);
  double v5 = *(double *)(a1 + 48);
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2020000000LL;
  uint64_t v11 = 0LL;
  uint64_t v6 = *(int *)(a2 + 304);
  uint64_t v7 = CFArrayGetCount(*(CFArrayRef *)(a2 + 232)) + v6;
  v9[3] = v7;
  _Block_object_dispose(&v8, 8);
  if (v7 > 0) {
    goto LABEL_2;
  }
  if (v4 != v5 && *(_BYTE *)(a2 + 597))
  {
LABEL_2:
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    return;
  }

void sub_182ACA104( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HTTP2ConnectionCacheEntry::stopConnections(HTTP2ConnectionCacheEntry *this, char a2)
{
  if (!*((_BYTE *)this + 105))
  {
    *((_BYTE *)this + 105) = 1;
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3221225472LL;
    context[2] = ___ZN25HTTP2ConnectionCacheEntry15stopConnectionsEb_block_invoke;
    context[3] = &__block_descriptor_33_e9_v16__0_v8l;
    char v5 = a2;
    uint64_t v3 = (const __CFArray *)*((void *)this + 11);
    v6.CFIndex length = CFArrayGetCount(v3);
    v6.CFIndex location = 0LL;
    CFArrayApplyFunction(v3, v6, (CFArrayApplierFunction)RetainableTypedArray<HTTP2Connection *>::_invoke, context);
    *((_BYTE *)this + 105) = 0;
  }

void ___ZN25HTTP2ConnectionCacheEntry15stopConnectionsEb_block_invoke(uint64_t a1, HTTP2Connection *this)
{
}

void ___ZN25HTTP2ConnectionCacheEntry25enqueueRequestForProtocolEP25MetaConnectionCacheClientPK18HTTPRequestMessage21MetaConnectionOptions_block_invoke( uint64_t a1)
{
  id v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t ___ZN25HTTP2ConnectionCacheEntry23shouldOpenNewConnectionEv_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(result + 32) + 8LL);
  if (*(_BYTE *)(v2 + 24)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = !*(_BYTE *)(a2 + 264)
  }
      && (*(_DWORD *)(a2 + 176) - 3) >= 2
      && (*(void *)(a2 + 144) | *(unsigned int *)(a2 + 152)) == 0LL;
  *(_BYTE *)(v2 + 24) = v3;
  return result;
}

void ___ZN25HTTP2ConnectionCacheEntry26markReusedAfterAPSleepWakeEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  if (v2 && *(_DWORD *)v2 == 1)
  {
    uint64_t v3 = *(void *)(v2 + 8);
    double v4 = *(std::__shared_weak_count **)(v2 + 16);
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }

    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 160LL))(v3);
    }
    if (v4)
    {
      uint64_t v7 = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182ACA2C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN25HTTP2ConnectionCacheEntry23logConnectionsAtAPSleepEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  if (v2 && *(_DWORD *)v2 == 1)
  {
    uint64_t v3 = *(void *)(v2 + 8);
    double v4 = *(std::__shared_weak_count **)(v2 + 16);
    if (v4)
    {
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }

    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 432LL))(v3);
    }
    if (v4)
    {
      uint64_t v7 = (unint64_t *)&v4->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }

void sub_182ACA37C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN25HTTP2ConnectionCacheEntry16connectionClosedEP15HTTP2Connection_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v1 = *(const void **)(a1 + 40);
  uint64_t v3 = *(const __CFArray **)(v2 + 88);
  v9.CFIndex length = CFArrayGetCount(v3);
  v9.CFIndex location = 0LL;
  FirstIndexOfint Value = CFArrayGetFirstIndexOfValue(v3, v9, v1);
  if ((FirstIndexOfValue & 0x8000000000000000LL) == 0)
  {
    CFIndex v5 = FirstIndexOfValue;
    CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 88), FirstIndexOfValue);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 88), v5);
  }

  if (!CFArrayGetCount(*(CFArrayRef *)(v2 + 88)))
  {
    unint64_t v6 = *(void **)(v2 + 16);
    (*(void (**)(void *))(*v6 + 40LL))(v6);
    CFRetain((CFTypeRef)(v2 - 16));
    uint64_t v7 = v6[10];
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    v8[2] = ___ZN20HTTP2ConnectionCache27cacheEntryDidBecomeUnusableEP25HTTP2ConnectionCacheEntry_block_invoke;
    v8[3] = &__block_descriptor_48_e5_v8__0l;
    v8[4] = v6;
    v8[5] = v2;
    (*(void (**)(uint64_t, void *))(*(void *)v7 + 96LL))(v7, v8);
  }

  CFRelease((CFTypeRef)(v2 - 16));
}

CFRunLoopSourceRef PAC::CreatePACTicket( PAC *this, const void *a2, const __CFURL *a3, const __CFData *a4, std::__shared_weak_count_vtbl *a5, void (*a6)(void *, const __CFArray *, __CFError *), CFStreamClientContext *a7)
{
  CFSocketContext context = (void *)MEMORY[0x186E1578C](this, a2, a3, a4, a5, a6, a7);
  CFRange v9 = (void *)[MEMORY[0x189607A50] componentsWithURL:a2 resolvingAgainstBaseURL:1];
  uint64_t v10 = (void *)[v9 string];
  uint64_t v11 = [v9 rangeOfHost];
  uint64_t v13 = v12;
  uint64_t v14 = [v9 rangeOfPort];
  uint64_t v16 = v15;
  uint64_t v17 = [v9 rangeOfScheme];
  __int128 v19 = (void *)NSString;
  if (v17 == 0x7FFFFFFFFFFFFFFFLL) {
    __int128 v20 = &stru_189C1D1D8;
  }
  else {
    __int128 v20 = (const __CFString *)objc_msgSend(v10, "substringWithRange:", v17, v18);
  }
  if (v11 == 0x7FFFFFFFFFFFFFFFLL) {
    __int128 v21 = &stru_189C1D1D8;
  }
  else {
    __int128 v21 = (const __CFString *)objc_msgSend(v10, "substringWithRange:", v11, v13);
  }
  if (v14 == 0x7FFFFFFFFFFFFFFFLL) {
    __int128 v22 = &stru_189C1D1D8;
  }
  else {
    __int128 v22 = (const __CFString *)[NSString stringWithFormat:@":%@", objc_msgSend(v10, "substringWithRange:", v14, v16)];
  }
  __int128 v23 = (const __CFString *)(id)[v19 stringWithFormat:@"%@://%@%@/", v20, v21, v22];
  objc_autoreleasePoolPop(context);
  CFURLRef contexta = CFURLCreateWithString(0LL, v23, 0LL);
  __int128 v24 = (std::__shared_weak_count *)operator new(0xE0uLL);
  __int128 v25 = *((_OWORD *)a6 + 1);
  *(_OWORD *)&v24[1].__shared_weak_owners_ = *(_OWORD *)a6;
  *(_OWORD *)&v24->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v24->__shared_owners_;
  v24->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AE40;
  v24[1].std::__shared_size_t count = 0u;
  *(_OWORD *)&v24[2].__shared_owners_ = v25;
  v24[3].__vftable = (std::__shared_weak_count_vtbl *)*((void *)a6 + 4);
  *(_OWORD *)&v24[3].__shared_owners_ = 0u;
  v24[4].__vftable = a5;
  *(_OWORD *)&v24[4].__shared_owners_ = 0u;
  v24[5].std::__shared_size_t count = 0u;
  *(_OWORD *)&v24[5].__shared_weak_owners_ = 0u;
  v24[6].__shared_weak_owners_ = 850045863LL;
  LOWORD(v24[6].__shared_owners_) = 0;
  v24[7].std::__shared_size_t count = 0u;
  *(_OWORD *)&v24[7].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v24[8].__shared_owners_ = 0u;
  v24[9].__vftable = 0LL;
  if (!v24[2].__vftable || (shared_owners = (void (*)(void))v24[2].__shared_owners_) == 0LL)
  {
    __int16 v85 = v24 + 1;
    CFOptionFlags v86 = v24;
    goto LABEL_19;
  }

  shared_owners();
  unint64_t v28 = (std::__shared_weak_count *)v24[1].__shared_owners_;
  __int16 v85 = v24 + 1;
  CFOptionFlags v86 = v24;
  if (!v28)
  {
    do
LABEL_19:
      unint64_t v32 = __ldxr(p_shared_owners);
    while (__stxr(v32 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v24->__shared_weak_owners_;
    do
      unint64_t v34 = __ldxr(p_shared_weak_owners);
    while (__stxr(v34 + 1, p_shared_weak_owners));
    v24[1].__vftable = (std::__shared_weak_count_vtbl *)&v24[1];
    v24[1].__shared_owners_ = (uint64_t)v24;
    goto LABEL_23;
  }

  if (v28->__shared_owners_ != -1) {
    goto LABEL_26;
  }
  do
    unint64_t v29 = __ldxr(p_shared_owners);
  while (__stxr(v29 + 1, p_shared_owners));
  uint64_t v30 = (unint64_t *)&v24->__shared_weak_owners_;
  do
    unint64_t v31 = __ldxr(v30);
  while (__stxr(v31 + 1, v30));
  v24[1].__vftable = (std::__shared_weak_count_vtbl *)&v24[1];
  v24[1].__shared_owners_ = (uint64_t)v24;
  std::__shared_weak_count::__release_weak(v28);
  do
LABEL_23:
    unint64_t v35 = __ldaxr(p_shared_owners);
  while (__stlxr(v35 - 1, p_shared_owners));
  if (!v35)
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }

void sub_182ACAAC8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFTypeRef a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, CFTypeRef cf, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23)
{
  shared_owners = (const void *)v24[2].__shared_owners_;
  v24[2].__shared_owners_ = 0LL;
  if (shared_owners) {
    CFRelease(shared_owners);
  }
  unint64_t v29 = v24[2].__vftable;
  v24[2].__vftable = 0LL;
  if (v29) {
    CFRelease(v29);
  }
  uint64_t v30 = *v23;
  CFStringRef v23 = 0LL;
  if (v30) {
    CFRelease(v30);
  }
  unint64_t v31 = (const void *)v24[1].__shared_owners_;
  v24[1].__shared_owners_ = 0LL;
  if (v31) {
    CFRelease(v31);
  }
  unint64_t v32 = *v25;
  std::__shared_weak_count *v25 = 0LL;
  if (v32) {
    CFRelease(v32);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 120);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 104);
  std::__shared_weak_count::~__shared_weak_count(v24);
  operator delete(v33);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 136);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v26 - 152);
  if (cf) {
    CFRelease(cf);
  }
  if (a13) {
    CFRelease(a13);
  }
  _Unwind_Resume(a1);
}

void PAC::rlsSchedule(PAC *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  std::shared_ptr<NetworkProxy>::shared_ptr[abi:nn180100]<NetworkProxy,void>( &v53,  *(void *)this,  *((std::__shared_weak_count **)this + 1));
  CFIndex v5 = v53;
  CFTypeRef v6 = CFRetain(a2);
  uint64_t v7 = (const void *)v5[11];
  v5[11] = v6;
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = CFNA::CFNetworkAgentClient::getCFNetworkAgentClient(void)::client;
  uint64_t v10 = v5[7];
  CFRange v9 = (std::__shared_weak_count *)v5[8];
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  uint64_t v13 = (std::__shared_weak_count_vtbl *)xpc_dictionary_create(0LL, 0LL, 0LL);
  uint64_t v14 = (std::__shared_weak_count *)operator new(0x20uLL);
  uint64_t v15 = v14;
  v14->__shared_owners_ = 0LL;
  uint64_t v16 = (unint64_t *)&v14->__shared_owners_;
  v14->__vftable = (std::__shared_weak_count_vtbl *)off_189C0D148;
  v14->__shared_weak_owners_ = 0LL;
  v14[1].__vftable = v13;
  if (*(_BYTE *)(v10 + 88))
  {
    unint64_t v55 = v13;
    uint64_t v56 = (uint64_t)v14;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    uint64_t v18 = CFURLGetString(*(CFURLRef *)v10);
    PAC::PACQuery::setStringInDict((xpc_object_t *)&v55, "source", v18);
    do
      unint64_t v19 = __ldaxr(v16);
    while (__stlxr(v19 - 1, v16));
    int64_t v20 = 1LL;
    if (!v19)
    {
LABEL_14:
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  else
  {
    unint64_t v55 = v13;
    uint64_t v56 = (uint64_t)v14;
    do
      unint64_t v24 = __ldxr(v16);
    while (__stxr(v24 + 1, v16));
    PAC::PACQuery::setStringInDict((xpc_object_t *)&v55, "source", *(CFStringRef *)v10);
    do
      unint64_t v25 = __ldaxr(v16);
    while (__stlxr(v25 - 1, v16));
    int64_t v20 = 2LL;
    if (!v25) {
      goto LABEL_14;
    }
  }

  xpc_dictionary_set_int64(v13, "dtype", v20);
  uint64_t v64 = v13;
  unint64_t v65 = v15;
  do
    unint64_t v21 = __ldxr(v16);
  while (__stxr(v21 + 1, v16));
  __int128 v22 = *(const __CFURL **)(v10 + 8);
  if (v22) {
    __int128 v23 = CFURLGetString(v22);
  }
  else {
    __int128 v23 = 0LL;
  }
  PAC::PACQuery::setStringInDict((xpc_object_t *)&v64, "target", v23);
  do
    unint64_t v26 = __ldaxr(v16);
  while (__stlxr(v26 - 1, v16));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }

  v63[0] = v13;
  v63[1] = v15;
  do
    unint64_t v27 = __ldxr(v16);
  while (__stxr(v27 + 1, v16));
  PAC::PACQuery::setStringInDict(v63, "user", *(CFStringRef *)(v10 + 16));
  do
    unint64_t v28 = __ldaxr(v16);
  while (__stlxr(v28 - 1, v16));
  if (!v28)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }

  v62[0] = v13;
  v62[1] = v15;
  do
    unint64_t v29 = __ldxr(v16);
  while (__stxr(v29 + 1, v16));
  PAC::PACQuery::setStringInDict(v62, "pass", *(CFStringRef *)(v10 + 24));
  do
    unint64_t v30 = __ldaxr(v16);
  while (__stlxr(v30 - 1, v16));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }

  v61[0] = v13;
  v61[1] = v15;
  do
    unint64_t v31 = __ldxr(v16);
  while (__stxr(v31 + 1, v16));
  PAC::PACQuery::setStringInDict(v61, "bundle", *(CFStringRef *)(v10 + 40));
  do
    unint64_t v32 = __ldaxr(v16);
  while (__stlxr(v32 - 1, v16));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }

  if (PAC::PACQuery::xpcDict(void)::prefix)
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v33 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v67 = PAC::PACQuery::xpcDict(void)::prefix;
      _os_log_impl(&dword_18298D000, v33, OS_LOG_TYPE_DEFAULT, "PAC found %s proc name", buf, 0xCu);
    }

    xpc_dictionary_set_string(v13, "prefix", (const char *)PAC::PACQuery::xpcDict(void)::prefix);
  }

  unint64_t v34 = *(const __CFData **)(v10 + 32);
  if (v34)
  {
    BytePtr = CFDataGetBytePtr(v34);
    size_t Length = CFDataGetLength(*(CFDataRef *)(v10 + 32));
    xpc_dictionary_set_data(v13, "audit", BytePtr, Length);
  }

  xpc_dictionary_set_int64(v13, "type", 3LL);
  do
    unint64_t v37 = __ldxr(v16);
  while (__stxr(v37 + 1, v16));
  unint64_t v55 = (std::__shared_weak_count_vtbl *)MEMORY[0x1895F87A8];
  uint64_t v56 = 3321888768LL;
  char v57 = ___ZN4CFNA20CFNetworkAgentClient10executePACENSt3__110shared_ptrIN3PAC8PACQueryEEE_block_invoke;
  unint64_t v58 = &__block_descriptor_48_e8_32c41_ZTSNSt3__110shared_ptrIN3PAC8PACQueryEEE_e36_v20__0B8__NSObject_OS_xpc_object__12l;
  uint64_t v59 = v10;
  uint64_t v60 = v9;
  if (v9)
  {
    unint64_t v38 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v39 = __ldxr(v38);
    while (__stxr(v39 + 1, v38));
  }

  SmartBlockWithArgs<BOOL,NSObject  {objcproto13OS_xpc_object}*>::SmartBlockWithArgs(&v64, &v55);
  CFNA::CFNetworkAgentClient::sendMessage(v8, (uint64_t)v13, v15, 3LL, (uint64_t *)&v64);
  unint64_t v40 = v65;
  if (v65)
  {
    uint64_t v41 = (unint64_t *)&v65->__shared_owners_;
    do
      unint64_t v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }

  do
    unint64_t v43 = __ldaxr(v16);
  while (__stlxr(v43 - 1, v16));
  if (!v43)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }

  unint64_t v44 = v60;
  if (v60)
  {
    uint64_t v45 = (unint64_t *)&v60->__shared_owners_;
    do
      unint64_t v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }

  do
    unint64_t v47 = __ldaxr(v16);
  while (__stlxr(v47 - 1, v16));
  if (!v47)
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }

  if (v9)
  {
    CFTypeRef v48 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v49 = __ldaxr(v48);
    while (__stlxr(v49 - 1, v48));
    if (!v49)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  uint64_t v50 = v54;
  if (v54)
  {
    uint64_t v51 = (unint64_t *)&v54->__shared_owners_;
    do
      unint64_t v52 = __ldaxr(v51);
    while (__stlxr(v52 - 1, v51));
    if (!v52)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }

void sub_182ACB268( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  do
    unint64_t v20 = __ldaxr(v18);
  while (__stlxr(v20 - 1, v18));
  if (!v20)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }

  do
    unint64_t v21 = __ldaxr(v18);
  while (__stlxr(v21 - 1, v18));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }

  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  if (a10)
  {
    unint64_t v24 = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  _Unwind_Resume(exception_object);
}

void PAC::rlsCancel(PAC *this, void *a2, __CFRunLoop *a3, const __CFString *a4)
{
  uint64_t v4 = v9;
  CFIndex v5 = (std::mutex *)(v9 + 136);
  std::mutex::lock((std::mutex *)(v9 + 136));
  if (*(_BYTE *)(v4 + 128)) {
    PAC::PACClient::invalidate(*(PAC::PACClient **)(v4 + 56));
  }
  else {
    *(_BYTE *)(v4 + 129) = 1;
  }
  std::mutex::unlock(v5);
  CFTypeRef v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_182ACB4EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  uint64_t v11 = v10;
  std::mutex::unlock(v11);
  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  _Unwind_Resume(a1);
}

void PAC::rlsPerform(PAC *this, void *a2)
{
  uint64_t v2 = v7;
  uint64_t v3 = (std::mutex *)(v7 + 136);
  std::mutex::lock((std::mutex *)(v7 + 136));
  *(_BYTE *)(v2 + 12_Block_object_dispose(&a9, 8) = 1;
  std::mutex::unlock(v3);
  (*(void (**)(void, void, void))(v2 + 72))( *(void *)(v2 + 24),  *(void *)(v2 + 96),  *(void *)(v2 + 112));
  uint64_t v4 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_182ACB5DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(p_shared_owners);
    while (__stlxr(v12 - 1, p_shared_owners));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  _Unwind_Resume(exception_object);
}

void PAC::PACClient::invalidate(PAC::PACClient *this)
{
  id v1 = (std::__shared_weak_count *)*((void *)this + 8);
  *((void *)this + 7) = 0LL;
  *((void *)this + _Block_object_dispose(&a9, 8) = 0LL;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      unint64_t v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

void ___ZN3PAC9PACClient10initializeEPKvPK7__CFURLPK8__CFDataPK10__CFString_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *a4;
  uint64_t v7 = a4[1];
  unint64_t v27 = (std::__shared_weak_count *)v7;
  if (v7)
  {
    unint64_t v8 = (unint64_t *)(v7 + 8);
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  uint64_t v10 = *a5;
  uint64_t v11 = (std::__shared_weak_count *)a5[1];
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }

  std::mutex::lock((std::mutex *)(v5 + 136));
  if (!*(void *)(v5 + 96) && !*(void *)(v5 + 112))
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v5 + 96), v6, v7);
    if (v11)
    {
      uint64_t v16 = (unint64_t *)&v11->__shared_owners_;
      do
        unint64_t v17 = __ldxr(v16);
      while (__stxr(v17 + 1, v16));
    }

    uint64_t v18 = *(std::__shared_weak_count **)(v5 + 120);
    *(void *)(v5 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v10;
    *(void *)(v5 + 120) = v11;
    if (v18)
    {
      unint64_t v19 = (unint64_t *)&v18->__shared_owners_;
      do
        unint64_t v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }

  std::mutex::unlock((std::mutex *)(v5 + 136));
  std::mutex::lock((std::mutex *)(v5 + 136));
  if (!*(_BYTE *)(v5 + 129))
  {
    unint64_t v14 = *(const void **)(v5 + 80);
    if (v14) {
      uint64_t v15 = (__CFRunLoopSource *)CFRetain(v14);
    }
    else {
      uint64_t v15 = 0LL;
    }
    unint64_t v21 = *(const void **)(v5 + 88);
    if (!v21)
    {
      std::mutex::unlock((std::mutex *)(v5 + 136));
      if (!v15) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }

    __int128 v22 = (__CFRunLoop *)CFRetain(v21);
    std::mutex::unlock((std::mutex *)(v5 + 136));
    if (v15)
    {
      if (!v22) {
        goto LABEL_30;
      }
      CFRunLoopSourceSignal(v15);
      CFRunLoopWakeUp(v22);
    }

    else if (!v22)
    {
      goto LABEL_31;
    }

    CFRelease(v22);
    if (!v15) {
      goto LABEL_31;
    }
LABEL_30:
    CFRelease(v15);
    goto LABEL_31;
  }

  PAC::PACClient::invalidate(*(PAC::PACClient **)(v5 + 56));
  std::mutex::unlock((std::mutex *)(v5 + 136));
LABEL_31:
  if (v11)
  {
    unint64_t v23 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  if (v27)
  {
    unint64_t v25 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

void sub_182ACB898( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  unint64_t v13 = v12;
  CFRelease(v13);
  CFRelease(v11);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  a1[1] = (uint64_t)BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_normal;
  a1[2] = 0LL;
  uint64_t v5 = *a1;
  uint64_t v6 = (std::__shared_weak_count *)a4[1];
  uint64_t v20 = *a4;
  unint64_t v21 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  unint64_t v9 = (std::__shared_weak_count *)a5[1];
  uint64_t v18 = *a5;
  unint64_t v19 = v9;
  if (v9)
  {
    uint64_t v10 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(v5 + 16))(v5, a2, a3, &v20, &v18);
  unint64_t v12 = v19;
  if (v19)
  {
    unint64_t v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  uint64_t v15 = v21;
  if (v21)
  {
    uint64_t v16 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_182ACB9E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>> *,SmartBlockWithArgs<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::Deleter,std::allocator<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>> *,SmartBlockWithArgs<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::Deleter,std::allocator<BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(void (**)(uint64_t *, uint64_t, uint64_t, uint64_t *, uint64_t *))(v1 + 8);
  if (*(void *)(v1 + 16)) {
    BOOL v3 = (*(void *)(v1 + 16) & 1LL | (unint64_t)v2) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = v3;
  if (v2 == BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_initial
    && v4 != 0)
  {
    v6[0] = 0LL;
    v6[1] = 0LL;
    BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke( v1,  0LL,  0LL,  0LL,  0LL,  v6);
  }

  _Block_release(*(const void **)v1);
  operator delete((void *)v1);
}

void BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, std::__shared_weak_count *a5, uint64_t *a6)
{
  uint64_t v6 = *(void (**)(void *, uint64_t, uint64_t, uint64_t *, uint64_t *))(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = (void *)(a1 + (v7 >> 1));
  if ((v7 & 1) != 0) {
    uint64_t v6 = *(void (**)(void *, uint64_t, uint64_t, uint64_t *, uint64_t *))(*v8 + v6);
  }
  uint64_t v22 = a4;
  unint64_t v23 = a5;
  if (a5)
  {
    p_shared_owners = (unint64_t *)&a5->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  unint64_t v11 = (std::__shared_weak_count *)a6[1];
  uint64_t v20 = *a6;
  unint64_t v21 = v11;
  if (v11)
  {
    unint64_t v12 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  v6(v8, a2, a3, &v22, &v20);
  unint64_t v14 = v21;
  if (v21)
  {
    uint64_t v15 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  unint64_t v17 = v23;
  if (v23)
  {
    uint64_t v18 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

void sub_182ACBB88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void BlockHolderVar<__CFString const*,__CFData const*,std::shared_ptr<__CFArray const>,std::shared_ptr<__CFError>>::invoke_normal( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a1;
  uint64_t v6 = (std::__shared_weak_count *)a4[1];
  uint64_t v20 = *a4;
  unint64_t v21 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  unint64_t v9 = (std::__shared_weak_count *)a5[1];
  uint64_t v18 = *a5;
  unint64_t v19 = v9;
  if (v9)
  {
    unint64_t v10 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *))(v5 + 16))(v5, a2, a3, &v20, &v18);
  unint64_t v12 = v19;
  if (v19)
  {
    unint64_t v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  uint64_t v15 = v21;
  if (v21)
  {
    unint64_t v16 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_182ACBC88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void std::__shared_ptr_emplace<PAC::PACQuery>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AE78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PAC::PACQuery>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AE78;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<PAC::PACQuery>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (const void *)a1[9];
  a1[9] = 0LL;
  if (v2) {
    CFRelease(v2);
  }
  BOOL v3 = (const void *)a1[8];
  a1[8] = 0LL;
  if (v3) {
    CFRelease(v3);
  }
  int v4 = (const void *)a1[7];
  a1[7] = 0LL;
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[6];
  a1[6] = 0LL;
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)a1[5];
  a1[5] = 0LL;
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[4];
  a1[4] = 0LL;
  if (v7) {
    CFRelease(v7);
  }
  unint64_t v8 = (const void *)a1[3];
  a1[3] = 0LL;
  if (v8) {
    CFRelease(v8);
  }
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3PAC9PACClientEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    BOOL v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrIN3PAC9PACClientEEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void std::__shared_ptr_emplace<PAC::PACClient>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AE40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PAC::PACClient>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0AE40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void std::__shared_ptr_emplace<PAC::PACClient>::__on_zero_shared(uint64_t a1)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v2 = *(void (**)(void))(a1 + 64);
    if (v2) {
      v2();
    }
  }

  std::mutex::~mutex((std::mutex *)(a1 + 160));
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 136);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 120);
  BOOL v3 = *(const void **)(a1 + 112);
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0LL;
  if (v3) {
    CFRelease(v3);
  }
  unint64_t v4 = *(const void **)(a1 + 104);
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 104) = 0LL;
  if (v4) {
    CFRelease(v4);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_182ACBE5C(_Unwind_Exception *a1)
{
  BOOL v3 = *(const void **)(v1 + 112);
  *(void *)(v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0LL;
  if (v3) {
    CFRelease(v3);
  }
  unint64_t v4 = *(const void **)(v1 + 104);
  *(void *)(v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 104) = 0LL;
  if (v4) {
    CFRelease(v4);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 80);
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 32);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  _Unwind_Resume(a1);
}

CFArrayRef CFNetworkCopyProxiesForAutoConfigurationScript( CFStringRef proxyAutoConfigurationScript, CFURLRef targetURL, CFErrorRef *error)
{
  unint64_t v10 = 0LL;
  CFTypeRef cf = 0LL;
  CFRunLoopRef rl = 0LL;
  v9[0] = 0LL;
  v9[1] = &v10;
  memset(&v9[2], 0, 24);
  CFRunLoopRef rl = CFRunLoopGetCurrent();
  PACTicket = PAC::CreatePACTicket( (PAC *)proxyAutoConfigurationScript,  targetURL,  0LL,  0LL,  (std::__shared_weak_count_vtbl *)CFNetworkCopyProxiesForAutoConfigurationScriptCallback,  (void (*)(void *, const __CFArray *, __CFError *))v9,  v6);
  CFRunLoopAddSource(rl, PACTicket, @"__CFNetworkCopyProxiesForAutoConfigurationScript_privatemode__");
  CFRunLoopRunInMode(@"__CFNetworkCopyProxiesForAutoConfigurationScript_privatemode__", 1.0e10, 0);
  CFRunLoopSourceInvalidate(PACTicket);
  CFRelease(PACTicket);
  if (error)
  {
    *SInt32 error = (CFErrorRef)cf;
  }

  else if (cf)
  {
    CFRelease(cf);
  }

  return v10;
}

void CFNetworkCopyProxiesForAutoConfigurationScriptCallback(void *a1, CFTypeRef cf, __CFError *a3)
{
  if (cf) {
    CFTypeRef v5 = CFRetain(cf);
  }
  else {
    CFTypeRef v5 = 0LL;
  }
  *(void *)a1 = v5;
  if (a3) {
    CFTypeRef v6 = CFRetain(a3);
  }
  else {
    CFTypeRef v6 = 0LL;
  }
  *((void *)a1 + 1) = v6;
  CFRunLoopStop(*((CFRunLoopRef *)a1 + 2));
}

CFPropertyListRef dep_CFPropertyListCreateFromStream( const __CFAllocator *a1, __CFReadStream *a2, CFStringRef *a3, unint64_t a4, CFPropertyListFormat *a5, const __CFString **a6)
{
  CFErrorRef error = 0LL;
  CFPropertyListRef v7 = CFPropertyListCreateWithStream(a1, a2, 0LL, 0LL, 0LL, &error);
  if (!v7)
  {
    CFErrorRef v8 = error;
    if (error)
    {
      if (a3)
      {
        *a3 = CFErrorCopyDescription(error);
        CFErrorRef v8 = error;
      }

      CFRelease(v8);
    }
  }

  return v7;
}

void ClassicStreamClient::~ClassicStreamClient(ClassicStreamClient *this)
{
  *(void *)this = off_189C0AEE8;
  if (*((void *)this + 4))
  {
    uint64_t v1 = (void (*)(void))*((void *)this + 6);
    if (v1) {
      v1();
    }
  }

{
  void (*v2)(void);
  *(void *)this = off_189C0AEE8;
  if (*((void *)this + 4))
  {
    uint64_t v2 = (void (*)(void))*((void *)this + 6);
    if (v2) {
      v2();
    }
  }

  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

void ClassicStreamClient::ClassicStreamClient( ClassicStreamClient *this, const __CFAllocator *a2, const CFStreamClientContext *a3)
{
  *(void *)this = off_189C06BF8;
  *((void *)this + 1) = a2;
  *((_DWORD *)this + 4) = 1;
  *(void *)this = off_189C0AEE8;
  copyDescription = a3->copyDescription;
  __int128 v4 = *(_OWORD *)&a3->retain;
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)&a3->version;
  *((void *)this + 7) = copyDescription;
  *(_OWORD *)((char *)this + 40) = v4;
  if (*((void *)this + 4))
  {
    CFTypeRef v5 = (uint64_t (*)(void))*((void *)this + 5);
    if (v5) {
      *((void *)this + 4) = v5();
    }
  }

CFStringRef ClassicStreamClient::clientCopyDescription(ClassicStreamClient *this)
{
  uint64_t v2 = (uint64_t (*)(void))*((void *)this + 7);
  if (!v2) {
    return CFStringCreateWithFormat( *((CFAllocatorRef *)this + 1),  0LL,  @"Classic Stream Client <%p>",  *((void *)this + 4));
  }
  CFStringRef result = (CFStringRef)v2(*((void *)this + 4));
  if (!result) {
    return CFStringCreateWithFormat( *((CFAllocatorRef *)this + 1),  0LL,  @"Classic Stream Client <%p>",  *((void *)this + 4));
  }
  return result;
}

void KerberosAccountStore::~KerberosAccountStore(KerberosAccountStore *this)
{
}

{
  dispatch_object_s *v2;
  dispatch_object_s *v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  *(void *)this = off_189C0AF30;
  *((void *)this + 3) = &unk_189C0AF88;
  uint64_t v2 = (dispatch_object_s *)*((void *)this + 12);
  if (v2) {
    dispatch_release(v2);
  }
  BOOL v3 = (dispatch_object_s *)*((void *)this + 11);
  if (v3) {
    dispatch_release(v3);
  }
  __int128 v4 = *((void *)this + 10);
  if (v4) {
    CFRelease((CFTypeRef)(v4 - 16));
  }
  CFTypeRef v5 = (const void *)*((void *)this + 9);
  if (v5) {
    CFRelease(v5);
  }
  CFTypeRef v6 = (const void *)*((void *)this + 8);
  if (v6) {
    CFRelease(v6);
  }
  CFPropertyListRef v7 = (const void *)*((void *)this + 7);
  if (v7) {
    CFRelease(v7);
  }
  CFErrorRef v8 = (const void *)*((void *)this + 6);
  if (v8) {
    CFRelease(v8);
  }
  CFNAccountStore::~CFNAccountStore(this);
}

CFStringRef KerberosAccountStore::copyDebugDesc(KerberosAccountStore *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<KerberosAccountStore@%p>", this);
}

void non-virtual thunk to'KerberosAccountStore::~KerberosAccountStore(KerberosAccountStore *this)
{
}

void non-virtual thunk to'KerberosAccountStore::~KerberosAccountStore(CFAllocatorRef *this)
{
  uint64_t v2 = this - 3;
  KerberosAccountStore::~KerberosAccountStore((KerberosAccountStore *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

void sub_182ACC2DC(_Unwind_Exception *a1)
{
}

uint64_t ___ZN20KerberosAccountStore42getKerberosCredentialWithCompletionHandlerEPK16_CFURLCredentialU13block_pointerFvS2_E_block_invoke( uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v2 = *(const void **)(a1 + 48);
  else {
    CFTypeRef v5 = 0LL;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 56), *(const void **)(a1 + 32));
  CFTypeRef v6 = *(const __CFArray **)(v3 + 56);
  if (!v6 || CFArrayGetCount(v6) <= 1) {
    KerberosAccountStore::fetchKerberosCredential((KerberosAccountStore *)v3, v5);
  }
  CFPropertyListRef v7 = *(const void **)(a1 + 48);
  if (v7) {
    CFRelease(v7);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48LL))(v3);
}

void KerberosAccountStore::fetchKerberosCredential(KerberosAccountStore *this, const __CFURL *a2)
{
  if ((_DWORD)a2)
  {
    if (*(_BYTE *)(*((void *)this + 10) + 48LL))
    {
      KerberosAccountStore::useCredentialFromNextAccountOrDieTrying(this, a2);
      return;
    }

    (*(void (**)(KerberosAccountStore *))(*(void *)this + 40LL))(this);
    __int128 v4 = (dispatch_queue_s *)*((void *)this + 12);
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke;
    v7[3] = &__block_descriptor_40_e5_v8__0l;
    v7[4] = this;
    CFTypeRef v5 = v7;
  }

  else
  {
    uint64_t v3 = (const _CFURLCredential *)*((void *)this + 9);
    if (v3)
    {
      KerberosAccountStore::sendKerberosCredentialToClients(this, v3);
      return;
    }

    (*(void (**)(KerberosAccountStore *))(*(void *)this + 40LL))(this);
    __int128 v4 = (dispatch_queue_s *)*((void *)this + 12);
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    uint64_t v6[2] = ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke;
    v6[3] = &__block_descriptor_40_e5_v8__0l;
    _OWORD v6[4] = this;
    CFTypeRef v5 = v6;
  }

  dispatch_async(v4, v5);
}

void KerberosAccountStore::sendKerberosCredentialToClients( KerberosAccountStore *this, const _CFURLCredential *a2)
{
  uint64_t v3 = (const __CFArray *)*((void *)this + 7);
  if (v3)
  {
    CFArrayRef Copy = CFArrayCreateCopy(*((CFAllocatorRef *)this + 1), v3);
    if (Copy)
    {
      CFArrayRef v6 = Copy;
      dispatch_queue_t v7 = dispatch_queue_create("com.apple.kerberosaccountstore.cbqueue", 0LL);
      if (v7)
      {
        CFErrorRef v8 = v7;
        if (a2) {
          CFRetain(a2);
        }
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = ___ZN20KerberosAccountStore31sendKerberosCredentialToClientsEPK16_CFURLCredential_block_invoke;
        block[3] = &unk_189C10E30;
        void block[5] = v6;
        block[6] = a2;
        block[4] = v8;
        dispatch_async(v8, block);
      }

      else
      {
        CFRelease(v6);
      }

      CFArrayRemoveAllValues(*((CFMutableArrayRef *)this + 7));
    }
  }

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void **)(a1 + 32);
  (*(void (**)(void *))(*v1 + 40LL))(v1);
  uint64_t v2 = v1[8];
  uint64_t v3 = (dispatch_object_s *)v1[11];
  uint64_t v4 = MEMORY[0x1895F87A8];
  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  v11[2] = ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_2;
  v11[3] = &__block_descriptor_40_e35_v24__0____CFArray__8____CFError__16l;
  v11[4] = v1;
  (*(void (**)(void *))(*v1 + 40LL))(v1);
  dispatch_retain(v3);
  CFTypeRef v5 = (void *)v1[4];
  *(void *)&__int128 buf = v4;
  *((void *)&buf + 1) = 3221225472LL;
  unint64_t v13 = ___ZN15CFNAccountStore32kerberosAccountsForDomainFromURLEPK7__CFURLPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvPK9__CFArrayP9__CFErrorE_block_invoke;
  unint64_t v14 = &unk_189C13450;
  uint64_t v15 = v3;
  unint64_t v16 = v11;
  unint64_t v17 = v1;
  [v5 kerberosAccountsForDomainFromURL:v2 completion:&buf];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  CFArrayRef v6 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = v1[8];
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_18298D000, v6, OS_LOG_TYPE_DEFAULT, "Fetching Account for domain %p", (uint8_t *)&buf, 0xCu);
  }

  CFErrorRef v8 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_14_6329, 3);
  if (v8)
  {
    unint64_t v9 = v8;
    if ((*(unsigned int (**)(void *, const char *, void))(*(void *)v8 + 16LL))( v8,  "Fetching Account for domain",  0LL))
    {
      (*(void (**)(void *, const char *, void))(*(void *)v9 + 40LL))(v9, "URL", v1[8]);
      (*(void (**)(void *))(*(void *)v9 + 8LL))(v9);
    }
  }

  return (*(uint64_t (**)(void *))(*v1 + 48LL))(v1);
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_2( uint64_t a1, const __CFArray *a2, __CFError *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *(void *)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  CFArrayRef v6 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    if (a2)
    {
      CFIndex Count = CFArrayGetCount(a2);
      if (a3)
      {
LABEL_6:
        CFIndex Code = CFErrorGetCode(a3);
LABEL_9:
        *(_DWORD *)unint64_t v16 = 134218498;
        *(void *)&v16[4] = Count;
        *(_WORD *)&v16[12] = 2112;
        *(void *)&v16[14] = a3;
        *(_WORD *)&v16[22] = 2048;
        CFIndex v17 = Code;
        _os_log_impl( &dword_18298D000,  v6,  OS_LOG_TYPE_DEFAULT,  "Accounts sent %ld account(s), error=%@ [%ld]",  v16,  0x20u);
        goto LABEL_10;
      }
    }

    else
    {
      CFIndex Count = 0LL;
      if (a3) {
        goto LABEL_6;
      }
    }

    CFIndex Code = 0LL;
    goto LABEL_9;
  }

void sub_182ACC964( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_13@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(&a9, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 112LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = "none";
  return result;
}

void KerberosAccountStore::useCredentialFromNextAccountOrDieTrying( KerberosAccountStore *this, const __CFURL *a2)
{
  uint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    CFRelease((CFTypeRef)(v3 - 16));
    *((void *)this + 10) = 0LL;
  }

  *((void *)this + 9) = 0LL;
  uint64_t v4 = (const __CFArray *)*((void *)this + 6);
  if (v4 && CFArrayGetCount(v4) >= 1)
  {
    ValueAtIndex = (objc_object *)CFArrayGetValueAtIndex(*((CFArrayRef *)this + 6), 0LL);
    if (ValueAtIndex)
    {
      CFArrayRef v6 = ValueAtIndex;
      uint64_t Instance = _CFRuntimeCreateInstance();
      *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
      *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
      Instance += 16LL;
      *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
      *(_OWORD *)(Instance + 4_Block_object_dispose(&a9, 8) = 0u;
      *(void *)(Instance + CFRetain((char *)this - 16) = 0LL;
      *(void *)(Instance + 24) = 0LL;
      *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0LL;
      *(void *)uint64_t Instance = &off_189C18C28;
      *(void *)(Instance + _Block_object_dispose(&a9, 8) = &unk_189C18C78;
      *(void *)(Instance + 56) = 0LL;
      *((void *)this + 10) = Instance;
      if (!CFNAccountKerberos::initialize((CFNAccountKerberos *)Instance, v6))
      {
        CFRelease((CFTypeRef)(*((void *)this + 10) - 16LL));
        *((void *)this + 10) = 0LL;
      }
    }

    CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 6), 0LL);
  }

  CFErrorRef v8 = (CFNAccountKerberos *)*((void *)this + 10);
  if (v8)
  {
    uint64_t v9 = CFNAccountKerberos::kerberosCredential(v8, a2);
    *((void *)this + 9) = v9;
    KerberosAccountStore::fetchKerberosCredential(this, v9 == 0);
  }

  else
  {
    unint64_t v10 = (const void *)*((void *)this + 6);
    *((void *)this + 6) = 0LL;
    if (v10) {
      CFRelease(v10);
    }
    KerberosAccountStore::sendKerberosCredentialToClients(this, 0LL);
  }

uint64_t ___ZN20KerberosAccountStore23fetchKerberosCredentialEh_block_invoke_4@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(&a9, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 101LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = "none";
  return result;
}

void ___ZN20KerberosAccountStore31sendKerberosCredentialToClientsEPK16_CFURLCredential_block_invoke( uint64_t a1)
{
  for (CFIndex i = 0LL; ; ++i)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    uint64_t v4 = *(const __CFArray **)(a1 + 40);
    if (i >= Count) {
      break;
    }
    ValueAtIndex = (void (**)(const void *, void))CFArrayGetValueAtIndex(v4, i);
    ValueAtIndex[2](ValueAtIndex, *(void *)(a1 + 48));
    _Block_release(ValueAtIndex);
  }

  if (v4) {
    CFRelease(v4);
  }
  CFArrayRef v6 = *(const void **)(a1 + 48);
  if (v6) {
    CFRelease(v6);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  (*(void (**)(void *))(*v1 + 40LL))(v1);
  uint64_t v2 = (dispatch_object_s *)v1[11];
  uint64_t v3 = *(void **)(v1[10] + 16LL);
  uint64_t v4 = MEMORY[0x1895F87A8];
  v9[0] = MEMORY[0x1895F87A8];
  v9[1] = 3221225472LL;
  void v9[2] = ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke_2;
  v9[3] = &__block_descriptor_40_e23_v24__0q8____CFError__16l;
  v9[4] = v1;
  (*(void (**)(void *))(*v1 + 40LL))(v1);
  dispatch_retain(v2);
  id v5 = v3;
  CFArrayRef v6 = (void *)v1[4];
  *(void *)__int128 buf = v4;
  uint64_t v11 = 3221225472LL;
  unint64_t v12 = ___ZN15CFNAccountStore26renewCredentialsForAccountEP11objc_objectPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvlP9__CFErrorE_block_invoke;
  CFStringRef v13 = &unk_189C13428;
  unint64_t v16 = v9;
  CFIndex v17 = v1;
  CFStringRef v14 = v2;
  uint64_t v15 = v3;
  [v6 renewCredentialsForAccount:v3 completion:buf];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v7 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl(&dword_18298D000, v7, OS_LOG_TYPE_DEFAULT, "Renewing current credential for account", buf, 2u);
  }

  return (*(uint64_t (**)(void *))(*v1 + 48LL))(v1);
}

uint64_t ___ZN20KerberosAccountStore40renewKerberosCredentialForCurrentAccountEv_block_invoke_2( uint64_t a1, uint64_t a2, __CFError *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v5 = *(KerberosAccountStore **)(a1 + 32);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  CFArrayRef v6 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      CFIndex Code = CFErrorGetCode(a3);
    }
    else {
      CFIndex Code = 0LL;
    }
    int v16 = 134218498;
    uint64_t v17 = a2;
    __int16 v18 = 2112;
    unint64_t v19 = a3;
    __int16 v20 = 2048;
    CFIndex v21 = Code;
    _os_log_impl( &dword_18298D000,  v6,  OS_LOG_TYPE_DEFAULT,  "Accounts renewed credential result=%ld, error=%@ [%ld]",  (uint8_t *)&v16,  0x20u);
  }

  if (a2 == 1)
  {
    CFStringRef v14 = v5;
    CFStringRef v13 = 0LL;
  }

  else
  {
    if (a2)
    {
      KerberosAccountStore::useCredentialFromNextAccountOrDieTrying(v5, v7);
      return (*(uint64_t (**)(KerberosAccountStore *))(*(void *)v5 + 48LL))(v5);
    }

    uint64_t v9 = *((void *)v5 + 10);
    unint64_t v10 = *(const void **)(v9 + 32);
    *(void *)(v9 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0LL;
    if (v10) {
      CFRelease(v10);
    }
    uint64_t v11 = *(void **)(v9 + 24);
    if (v11)
    {

      *(void *)(v9 + 24) = 0LL;
    }

    unint64_t v12 = (CFNAccountKerberos *)*((void *)v5 + 10);
    *((_BYTE *)v12 + 4_Block_object_dispose(&a9, 8) = 1;
    CFStringRef v13 = (const _CFURLCredential *)CFNAccountKerberos::kerberosCredential(v12, v7);
    *((void *)v5 + 9) = v13;
    CFStringRef v14 = v5;
  }

  KerberosAccountStore::sendKerberosCredentialToClients(v14, v13);
  return (*(uint64_t (**)(KerberosAccountStore *))(*(void *)v5 + 48LL))(v5);
}

uint64_t ___ZN20KerberosAccountStore24clearAccountRefreshStateEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t v2 = v1[10];
  if (v2) {
    *(_BYTE *)(v2 + 4_Block_object_dispose(&a9, 8) = 0;
  }
  return (*(uint64_t (**)(void *))(*v1 + 48LL))(v1);
}

unsigned __int8 *_DNSServiceConvertDomainLabelToCString_withescape( unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v5 = *a1;
  uint64_t v3 = a1 + 1;
  uint64_t v4 = v5;
  if (v5 > 0x3F) {
    return 0LL;
  }
  if ((_DWORD)v4)
  {
    CFArrayRef v6 = &v3[v4];
    do
    {
      unsigned __int8 v8 = *v3++;
      unsigned __int8 v7 = v8;
      if (a3)
      {
        if (v7 == 46 || v7 == a3)
        {
          *a2++ = a3;
        }

        else if (v7 <= 0x20u)
        {
          *a2 = a3;
          a2[1] = 48;
          a2[2] = (v7 / 0xAu) | 0x30;
          a2 += 3;
          unsigned __int8 v7 = (v7 % 0xAu) | 0x30;
        }
      }

      *a2++ = v7;
    }

    while (v3 < v6);
  }

  *a2 = 0;
  return a2;
}

unsigned __int8 *_DNSServiceConvertDomainNameToCString_withescape( unsigned __int8 *result, unsigned __int8 *a2)
{
  uint64_t v2 = result;
  unsigned int v3 = *result;
  if (*result || (*a2 = 46, ++a2, (unsigned int v3 = *result) != 0))
  {
    uint64_t v4 = 0LL;
    while (v4 + 1 + (unint64_t)v3 <= 0xFF)
    {
      uint64_t result = _DNSServiceConvertDomainLabelToCString_withescape(result, a2, 92);
      if (!result) {
        break;
      }
      v4 += 1LL + v2[v4];
      *uint64_t result = 46;
      a2 = result + 1;
      uint64_t result = &v2[v4];
      unsigned int v3 = v2[v4];
      if (!v2[v4]) {
        goto LABEL_7;
      }
    }
  }

  else
  {
LABEL_7:
    *a2 = 0;
  }

  return result;
}

uint64_t Tube::setConnectionProperty(Tube *this, CFTypeRef cf, CFTypeRef a3)
{
  uint64_t v9 = 0LL;
  unint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  char v12 = 0;
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZN4Tube21setConnectionPropertyEPK10__CFStringPKv_block_invoke;
  v8[3] = &unk_189C0B2C8;
  v8[4] = &v9;
  v8[5] = this;
  void v8[6] = cf;
  void v8[7] = a3;
  ___ZN4Tube21setConnectionPropertyEPK10__CFStringPKv_block_invoke(v8);
  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_182ACD0FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

CFTypeRef Tube::copyConnectionProperty(Tube *this, const __CFString *a2)
{
  uint64_t v3 = *((void *)this + 17);
  if (v3) {
    return (CFTypeRef)(*(uint64_t (**)(uint64_t, const __CFString *))(*(void *)v3 + 216LL))(v3, a2);
  }
  unsigned int v5 = (const __CFDictionary *)*((void *)this + 28);
  if (v5 && (int Value = CFDictionaryGetValue(v5, a2)) != 0LL) {
    return CFRetain(Value);
  }
  else {
    return 0LL;
  }
}

void Tube::clientCanceled(Tube *a1, uint64_t a2)
{
  uint64_t v3 = *((void *)a1 + 14);
  if (v3)
  {
  }

void Tube::generateProxyAuthentication(void **a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  if (a1[14])
  {
    ((void (*)(void **))(*a1)[5])(a1);
    uint64_t v50 = a1;
    unsigned __int8 v8 = (std::__shared_weak_count *)operator new(0x20uLL);
    v8->__shared_owners_ = 0LL;
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    v8->__vftable = (std::__shared_weak_count_vtbl *)off_189C0B4D8;
    v8->__shared_weak_owners_ = 0LL;
    v8[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
    uint64_t v51 = v8;
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1[14] + 80LL))(a1[14]);
    if (v10)
    {
      uint64_t v11 = (std::__shared_weak_count *)a2[1];
      uint64_t v48 = *a2;
      unint64_t v49 = v11;
      if (v11)
      {
        char v12 = (unint64_t *)&v11->__shared_owners_;
        do
          unint64_t v13 = __ldxr(v12);
        while (__stxr(v13 + 1, v12));
      }

      uint64_t v14 = v10 - 176;
      uint64_t v15 = (std::__shared_weak_count *)a3[1];
      uint64_t v46 = *a3;
      unint64_t v47 = v15;
      if (v15)
      {
        int v16 = (unint64_t *)&v15->__shared_owners_;
        do
          unint64_t v17 = __ldxr(v16);
        while (__stxr(v17 + 1, v16));
      }

      v40[0] = MEMORY[0x1895F87A8];
      v40[1] = 3321888768LL;
      CFTypeRef v40[2] = ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke;
      v40[3] = &__block_descriptor_64_e8_32c31_ZTSNSt3__110shared_ptrI4TubeEE48c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE_e85_v24__0_shared_ptr_AuthenticationState____AuthenticationState_____shared_weak_count__8l;
      v40[4] = a1;
      uint64_t v41 = v8;
      do
        unint64_t v18 = __ldxr(p_shared_owners);
      while (__stxr(v18 + 1, p_shared_owners));
      uint64_t v19 = a4[1];
      uint64_t v42 = *a4;
      unint64_t v43 = (std::__shared_weak_count *)v19;
      if (v19)
      {
        __int16 v20 = (unint64_t *)(v19 + 8);
        do
          unint64_t v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
      }

      SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs(&v44, v40);
      (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(void *)v14 + 248LL))(v14, &v48, &v46, &v44);
      uint64_t v22 = v45;
      if (v45)
      {
        unint64_t v23 = (unint64_t *)&v45->__shared_owners_;
        do
          unint64_t v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
          std::__shared_weak_count::__release_weak(v22);
        }
      }

      unint64_t v25 = v47;
      if (v47)
      {
        unint64_t v26 = (unint64_t *)&v47->__shared_owners_;
        do
          unint64_t v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }

      unint64_t v28 = v49;
      if (v49)
      {
        unint64_t v29 = (unint64_t *)&v49->__shared_owners_;
        do
          unint64_t v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }

      unint64_t v31 = v43;
      if (v43)
      {
        unint64_t v32 = (unint64_t *)&v43->__shared_owners_;
        do
          unint64_t v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }

      unint64_t v34 = v41;
      if (v41)
      {
        unint64_t v35 = (unint64_t *)&v41->__shared_owners_;
        do
          unint64_t v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }

    else
    {
      SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(*a4, 0LL, 0LL);
    }

    unint64_t v37 = v51;
    if (v51)
    {
      unint64_t v38 = (unint64_t *)&v51->__shared_owners_;
      do
        unint64_t v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }
  }

  else
  {
    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(*a4, 0LL, 0LL);
  }

void sub_182ACD490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t Tube::resetAuthState(Tube *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 14) + 80LL))(*((void *)this + 14));
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(result - 176) + 256LL))(result - 176);
  }
  return result;
}

uint64_t Tube::clientDescription(Tube *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 14) + 80LL))(*((void *)this + 14));
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(result - 176) + 264LL))(result - 176);
  }
  return result;
}

void Tube::needClientCert(int *a1, CFTypeRef cf, void *aBlock)
{
  if (*((void *)a1 + 31)) {
    __assert_rtn("needClientCert", "Tube.cpp", 1773, "!fSSLDistNames");
  }
  *((void *)a1 + 31) = cf;
  if (cf) {
    CFRetain(cf);
  }
  *((void *)a1 + 3_Block_object_dispose(va, 8) = _Block_copy(aBlock);
  if (a1[55] < 10)
  {
    a1[55] = 8;
    uint64_t v5 = (*(uint64_t (**)(void))(**((void **)a1 + 14) + 80LL))(*((void *)a1 + 14));
    uint64_t v6 = v5;
    if (v5) {
      uint64_t v7 = v5 - 176;
    }
    else {
      uint64_t v7 = 0LL;
    }
    if (v5) {
      CFRetain((CFTypeRef)(v5 - 192));
    }
    if (v6) {
      uint64_t v8 = v7 + 120;
    }
    else {
      uint64_t v8 = 0LL;
    }
    uint64_t v21 = v8;
    uint64_t v9 = (std::__shared_weak_count *)operator new(0x20uLL);
    v9->__shared_owners_ = 0LL;
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    v9->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE68;
    v9->__shared_weak_owners_ = 0LL;
    v9[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
    uint64_t v22 = v9;
    (*(void (**)(int *))(*(void *)a1 + 40LL))(a1);
    (*(void (**)(int *))(*(void *)a1 + 40LL))(a1);
    uint64_t v11 = *(void *)(v7 + 24);
    v19[0] = MEMORY[0x1895F87A8];
    v19[1] = 3321888768LL;
    void v19[2] = ___ZN4Tube23_onqueue_needClientCertEv_block_invoke;
    v19[3] = &__block_descriptor_56_e8_40c82_ZTSNSt3__110shared_ptrIN19TransportConnection31ConnectionEstablishmentDelegateEEE_e5_v8__0l;
    v19[4] = a1;
    v19[5] = v8;
    __int16 v20 = v9;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 96LL))(v11, v19);
    unint64_t v13 = v20;
    if (v20)
    {
      uint64_t v14 = (unint64_t *)&v20->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    int v16 = v22;
    if (v22)
    {
      unint64_t v17 = (unint64_t *)&v22->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }

  else
  {
    Tube::_onqueue_complete_needClientCert((Tube *)a1, 0LL, 1LL);
  }

void sub_182ACD770( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t Tube::connectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 220) != 10) {
    *(_DWORD *)(a1 + 220) = 5;
  }
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = a2;
  uint64_t v4 = *(void *)(a1 + 112);
  if (v4)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 80LL))(v4);
    if (v5) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 240LL))(v5, a2);
    }
  }

  uint64_t result = *(void *)(a1 + 280);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, a2);
  }
  return result;
}

void non-virtual thunk to'Tube::~Tube(Tube *this)
{
}

{
  Tube::~Tube((Tube *)((char *)this - 32));
}

{
  Tube::~Tube((Tube *)((char *)this - 40));
}

{
  Tube::~Tube((Tube *)((char *)this - 96));
}

void non-virtual thunk to'Tube::~Tube(CFAllocatorRef *this)
{
  uint64_t v2 = this - 3;
  Tube::~Tube((Tube *)(this - 3));
  CFAllocatorDeallocate(*(this - 2), v2);
}

{
  CFAllocatorRef *v2;
  uint64_t v2 = this - 4;
  Tube::~Tube((Tube *)(this - 4));
  CFAllocatorDeallocate(*(this - 3), v2);
}

{
  CFAllocatorRef *v2;
  uint64_t v2 = this - 5;
  Tube::~Tube((Tube *)(this - 5));
  CFAllocatorDeallocate(*(this - 4), v2);
}

{
  CFAllocatorRef *v2;
  uint64_t v2 = this - 12;
  Tube::~Tube((Tube *)(this - 12));
  CFAllocatorDeallocate(*(this - 11), v2);
}

void GlueConnectionEstablishment::ceRetain(GlueConnectionEstablishment *this)
{
}

void GlueConnectionEstablishment::ceRelease(GlueConnectionEstablishment *this)
{
}

void GlueConnectionEstablishment::ssPreConnectConfiguration()
{
}

void GlueConnectionEstablishment::ssNeedServerTrust()
{
}

void GlueConnectionEstablishment::ssNeedClientCert()
{
}

void GlueConnectionEstablishment::ssPostConnectConfiguration()
{
}

void GlueConnectionEstablishment::ssPostHandshakesStreamsAvailable( GlueConnectionEstablishment *this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

void GlueConnectionEstablishment::ssConnectionWaitingNotification()
{
}

void non-virtual thunk to'Tube::needClientCert(uint64_t a1, const void *a2, void *a3)
{
}

{
  Tube::needClientCert((int *)(a1 - 40), a2, a3);
}

uint64_t non-virtual thunk to'Tube::connectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  return Tube::connectionWaitingNotification(a1 - 32, a2);
}

{
  return Tube::connectionWaitingNotification(a1 - 40, a2);
}

void non-virtual thunk to'Tube::generateProxyAuthentication( uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
}

uint64_t non-virtual thunk to'Tube::resetAuthState(Tube *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 2) + 80LL))(*((void *)this + 2));
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(result - 176) + 256LL))(result - 176);
  }
  return result;
}

uint64_t non-virtual thunk to'Tube::clientDescription(Tube *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 2) + 80LL))(*((void *)this + 2));
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(result - 176) + 264LL))(result - 176);
  }
  return result;
}

void ___ZN4TubeD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if (*(_BYTE *)(a1 + 48))
    {
      (*(void (**)(uint64_t, void))(*(void *)v2 + 152LL))(v2, 0LL);
      TransportConnection::rstConnectionEstablishmentDelegate(*(TransportConnection **)(a1 + 32));
    }
  }

void Tube::_onqueue_complete_needClientCert(Tube *this, const __CFArray *a2, uint64_t a3)
{
  uint64_t v6 = (void (**)(void, void, void))*((void *)this + 38);
  *((void *)this + 3_Block_object_dispose(va, 8) = 0LL;
  uint64_t v7 = (const void *)*((void *)this + 31);
  *((void *)this + 31) = 0LL;
  if (v7) {
    CFRelease(v7);
  }
  if (v6)
  {
    ((void (**)(void, const __CFArray *, uint64_t))v6)[2](v6, a2, a3);
    _Block_release(v6);
  }

  if ((_DWORD)a3) {
    Tube::_onqueue_cancel(this);
  }
}

uint64_t ___ZN4Tube23_onqueue_needClientCertEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(int *)(v1 + 220) < 10)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void *)(v1 + 248);
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    uint64_t v6[2] = ___ZN4Tube23_onqueue_needClientCertEv_block_invoke_2;
    v6[3] = &__block_descriptor_40_e23_v20__0____CFArray__8B16l;
    _OWORD v6[4] = v1;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 40LL))(v3, v4, v6);
  }

  else
  {
    (*(void (**)(void))(*(void *)v1 + 40LL))(*(void *)(a1 + 32));
    uint64_t v2 = *(dispatch_queue_s **)(v1 + 160);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZN4Tube24_complete_needClientCertEPK9__CFArrayb_block_invoke;
    block[3] = &__block_descriptor_49_e5_v8__0l;
    block[4] = v1;
    void block[5] = 0LL;
    char v8 = 1;
    dispatch_async(v2, block);
    (*(void (**)(uint64_t))(*(void *)v1 + 48LL))(v1);
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48LL))(v1);
}

uint64_t ___ZN4Tube24_complete_needClientCertEPK9__CFArrayb_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(Tube **)(a1 + 32);
  Tube::_onqueue_complete_needClientCert(v2, *(const __CFArray **)(a1 + 40), *(unsigned __int8 *)(a1 + 48));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  return (*(uint64_t (**)(Tube *))(*(void *)v2 + 48LL))(v2);
}

uint64_t ___ZN4Tube23_onqueue_needClientCertEv_block_invoke_2(uint64_t a1, const void *a2, char a3)
{
  uint64_t v5 = *(void **)(a1 + 32);
  (*(void (**)(void *))(*v5 + 40LL))(v5);
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v6 = (dispatch_queue_s *)v5[20];
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN4Tube24_complete_needClientCertEPK9__CFArrayb_block_invoke;
  block[3] = &__block_descriptor_49_e5_v8__0l;
  block[4] = v5;
  void block[5] = a2;
  char v9 = a3;
  dispatch_async(v6, block);
  return (*(uint64_t (**)(void *))(*v5 + 48LL))(v5);
}

void Tube::_onqueue_cancel(Tube *this)
{
  if (*((_DWORD *)this + 55) != 10)
  {
    *((_DWORD *)this + 55) = 10;
    (*(void (**)(Tube *))(*(void *)this + 40LL))(this);
    uint64_t v2 = (dispatch_queue_s *)*((void *)this + 20);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZN4Tube15_onqueue_cancelEv_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v2, block);
  }

uint64_t ___ZN4Tube15_onqueue_cancelEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(Tube **)(a1 + 32);
  if (*((void *)v1 + 39)) {
    Tube::_onqueue_complete_needServerTrust(*(Tube **)(a1 + 32), 0LL, 1LL);
  }
  if (*((void *)v1 + 38)) {
    Tube::_onqueue_complete_needClientCert(v1, 0LL, 1LL);
  }
  Tube::_onqueue_cleanupConnection(v1);
  v3.CFIndex domain = 1LL;
  *(void *)&v3.CFErrorRef error = 89LL;
  Tube::_onqueue_invokeCB(v1, v3);
  return (*(uint64_t (**)(Tube *))(*(void *)v1 + 48LL))(v1);
}

void Tube::_onqueue_cleanupConnection(Tube *this)
{
  if (*((_BYTE *)this + 120) && *((void *)this + 17))
  {
    uint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 14) + 80LL))(*((void *)this + 14));
    uint64_t v3 = *((void *)this + 17);
    if (v3)
    {
      if (v2) {
        uint64_t v4 = v2 - 176;
      }
      else {
        uint64_t v4 = 0LL;
      }
      (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v3 + 280LL))( v3,  *(void *)(v4 + 80),  1LL,  0LL);
    }

    *((_BYTE *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 120) = 0;
  }

  if (!*((_BYTE *)this + 296))
  {
    uint64_t v5 = (TransportConnection *)*((void *)this + 17);
    if (v5)
    {
      if (*((_BYTE *)this + 240))
      {
        (*(void (**)(TransportConnection *, void))(*(void *)v5 + 152LL))(v5, 0LL);
        uint64_t v5 = (TransportConnection *)*((void *)this + 17);
      }

      TransportConnection::rstConnectionEstablishmentDelegate(v5);
      uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 18);
      *((void *)this + 17) = 0LL;
      *((void *)this + 1_Block_object_dispose(va, 8) = 0LL;
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          unint64_t v8 = __ldaxr(p_shared_owners);
        while (__stlxr(v8 - 1, p_shared_owners));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }
  }

void ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke(uint64_t a1)
{
}

uint64_t ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(int *)(v1 + 220) < 10)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(void *)(v1 + 256);
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    uint64_t v6[2] = ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke_3;
    v6[3] = &__block_descriptor_40_e11_v16__0i8B12l;
    _OWORD v6[4] = v1;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 32LL))(v3, v4, v6);
  }

  else
  {
    (*(void (**)(void))(*(void *)v1 + 40LL))(*(void *)(a1 + 32));
    uint64_t v2 = *(dispatch_queue_s **)(v1 + 160);
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = ___ZN4Tube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicyb_block_invoke;
    block[3] = &__block_descriptor_45_e5_v8__0l;
    block[4] = v1;
    int v8 = 0;
    char v9 = 1;
    dispatch_async(v2, block);
    (*(void (**)(uint64_t))(*(void *)v1 + 48LL))(v1);
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48LL))(v1);
}

uint64_t ___ZN4Tube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicyb_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(Tube **)(a1 + 32);
  Tube::_onqueue_complete_needServerTrust(v1, *(unsigned int *)(a1 + 40), *(unsigned __int8 *)(a1 + 44));
  return (*(uint64_t (**)(Tube *))(*(void *)v1 + 48LL))(v1);
}

uint64_t ___ZN4Tube24_onqueue_needServerTrustEv_block_invoke_3(uint64_t a1, int a2, char a3)
{
  uint64_t v5 = *(void **)(a1 + 32);
  (*(void (**)(void *))(*v5 + 40LL))(v5);
  uint64_t v6 = (dispatch_queue_s *)v5[20];
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZN4Tube25_complete_needServerTrustE28SSLPeerTrustAcceptancePolicyb_block_invoke;
  v8[3] = &__block_descriptor_45_e5_v8__0l;
  v8[4] = v5;
  int v9 = a2;
  char v10 = a3;
  dispatch_async(v6, v8);
  return (*(uint64_t (**)(void *))(*v5 + 48LL))(v5);
}

uint64_t ___ZN4Tube24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke( uint64_t a1, uint64_t *a2, int a3, CFIndex a4, uint64_t a5)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a1 + 40);
  if ((*(_DWORD *)(v6 + 220) & 0xFFFFFFFE) == 0xA) {
    goto LABEL_62;
  }
  uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(v6 + 112) + 80LL))(*(void *)(v6 + 112));
  if (!v11)
  {
    uint64_t v14 = 0LL;
    uint64_t v45 = 0LL;
    uint64_t v46 = 0LL;
    if ((_DWORD)a5)
    {
LABEL_14:
      std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v6 + 264), *a2, a2[1]);
      v50.CFIndex domain = a4;
      *(void *)&v50.CFErrorRef error = a5;
      Tube::_onqueue_errorHandler((Tube *)v6, v50);
      goto LABEL_15;
    }

    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v6 + 264), *a2, a2[1]);
    if (!a3) {
      goto LABEL_62;
    }
    uint64_t v14 = 0LL;
LABEL_43:
    if (*(_DWORD *)(v6 + 220) == 6)
    {
      if (*(void *)(v6 + 248))
      {
        uint64_t v41 = "!fSSLDistNames";
        int v42 = 565;
      }

      else if (*(void *)(v6 + 304))
      {
        uint64_t v41 = "!fSSLDistNamesCompletion";
        int v42 = 566;
      }

      else if (*(void *)(v6 + 256))
      {
        uint64_t v41 = "!fSSLTrust";
        int v42 = 567;
      }

      else if (*(void *)(v6 + 312))
      {
        uint64_t v41 = "!fSSLTrustCompletion";
        int v42 = 568;
      }

      else
      {
        unint64_t v35 = *(TransportConnection **)(v6 + 136);
        if (v35)
        {
          TransportConnection::rstConnectionEstablishmentDelegate(v35);
          (*(void (**)(void, void))(**(void **)(v6 + 136) + 152LL))(*(void *)(v6 + 136), 0LL);
          *(_DWORD *)(v6 + 184) = 0;
          *(_BYTE *)(v6 + 18_Block_object_dispose(va, 8) = 0;
          if (*(_DWORD *)(v6 + 220) != 10) {
            *(_DWORD *)(v6 + 220) = 1;
          }
          unint64_t v36 = *(const void **)(v6 + 232);
          *(void *)(v6 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0LL;
          if (v36) {
            CFRelease(v36);
          }
          GlueTubeManager::createTransportConnection( (std::__shared_weak_count **)buf,  *(dispatch_object_s **)(v6 + 160));
          std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v6 + 136, (__int128 *)buf);
          unint64_t v37 = *(std::__shared_weak_count **)&v48[4];
          if (*(void *)&v48[4])
          {
            unint64_t v38 = (unint64_t *)(*(void *)&v48[4] + 8LL);
            do
              unint64_t v39 = __ldaxr(v38);
            while (__stlxr(v39 - 1, v38));
            if (!v39)
            {
              ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
              std::__shared_weak_count::__release_weak(v37);
            }
          }

          Tube::_onqueue_connect((Tube *)v6);
LABEL_15:
          if (!v14) {
            goto LABEL_62;
          }
          goto LABEL_16;
        }

        uint64_t v41 = "fConnection";
        int v42 = 574;
      }
    }

    else
    {
      uint64_t v41 = "fState == kTubeStatePostConnectConfiguration";
      int v42 = 564;
    }

    __assert_rtn("_onqueue_resetAndReconnect", "Tube.cpp", v42, v41);
  }

  uint64_t v12 = v11;
  uint64_t v13 = *(void *)(v11 + 632);
  uint64_t v14 = *(std::__shared_weak_count **)(v11 + 640);
  uint64_t v45 = v13;
  uint64_t v46 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }

  if ((_DWORD)a5)
  {
    if (v13)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      unint64_t v17 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 134218240;
        *(void *)uint64_t v48 = a4;
        *(_WORD *)&v48[8] = 1024;
        *(_DWORD *)&v48[10] = a5;
        _os_log_error_impl( &dword_18298D000,  v17,  OS_LOG_TYPE_ERROR,  "Sending terminal establishment proxyError[%ld:%d]",  buf,  0x12u);
      }

      (*(void (**)(uint64_t, CFIndex, uint64_t))(*(void *)v13 + 48LL))(v13, a4, a5);
    }

    goto LABEL_14;
  }

  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v6 + 264), *a2, a2[1]);
  if ((a3 & 1) != 0) {
    goto LABEL_43;
  }
  if (!v13)
  {
    objc_msgSend(*(id *)(v12 - 96), "set_proxyHandshakePending:", 0);
    goto LABEL_15;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  __int16 v20 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = *(void *)(v6 + 136);
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)uint64_t v48 = v21;
    _os_log_impl( &dword_18298D000,  v20,  OS_LOG_TYPE_DEFAULT,  "Tube handing off connection %p to terminal delegate",  buf,  0xCu);
  }

  uint64_t v22 = *(std::__shared_weak_count **)(v6 + 144);
  uint64_t v43 = *(void *)(v6 + 136);
  uint64_t v44 = v22;
  if (v22)
  {
    unint64_t v23 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v13 + 80LL))(v13, &v43);
  unint64_t v25 = v44;
  if (v44)
  {
    unint64_t v26 = (unint64_t *)&v44->__shared_owners_;
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  uint64_t v28 = *(void *)(v6 + 136);
  uint64_t v29 = v45;
  unint64_t v30 = v46;
  if (v46)
  {
    unint64_t v31 = (unint64_t *)&v46->__shared_owners_;
    do
      unint64_t v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v28 + 144), v29, (uint64_t)v30);
    unint64_t v33 = (unint64_t *)&v30->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v28 + 144), v45, 0LL);
  }

  *(_BYTE *)(v6 + 296) = 1;
  uint64_t v14 = v46;
  if (v46)
  {
LABEL_16:
    unint64_t v18 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void sub_182ACE51C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void std::__shared_ptr_pointer<Tube *,Tube::postConnectConfiguration(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,void({block_pointer})(void))::$_0,std::allocator<Tube>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<Tube *,Tube::postConnectConfiguration(NSObject  {objcproto17OS_tcp_connection}*,NSObject {objcproto16OS_nw_parameters}*,void({block_pointer})(void))::$_0,std::allocator<Tube>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48LL))(result);
  }
  return result;
}

void Tube::_onqueue_errorHandler(Tube *this, CFStreamError a2)
{
  uint64_t v2 = *(void *)&a2.error;
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a2.error) {
    __assert_rtn("_onqueue_errorHandler", "Tube.cpp", 1120, "error.error != 0");
  }
  CFIndex domain = a2.domain;
  if ((unint64_t)(a2.domain - 5) <= 0xFFFFFFFFFFFFFFFDLL
    && (int v5 = (*(uint64_t (**)(void))(**((void **)this + 13) + 88LL))(*((void *)this + 13)),
        (v5 & 0xFFFFFFFE) == 2))
  {
    if (v5 == 2) {
      int v6 = -2094;
    }
    else {
      int v6 = -2096;
    }
    if ((_DWORD)v2 == 80 && domain == 1 && *((_DWORD *)this + 22) == 2) {
      unsigned int v9 = -2099;
    }
    else {
      unsigned int v9 = v6;
    }
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    char v10 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *((void *)this + 17);
      int v12 = 134219008;
      uint64_t v13 = v11;
      __int16 v14 = 2048;
      CFIndex v15 = domain;
      __int16 v16 = 1024;
      int v17 = v2;
      __int16 v18 = 2048;
      CFIndex domain = 4LL;
      uint64_t v19 = 4LL;
      __int16 v20 = 1024;
      unsigned int v21 = v9;
      _os_log_error_impl( &dword_18298D000,  v10,  OS_LOG_TYPE_ERROR,  "Tube connection %p received error %lu:%d => proxy error %lu:%d",  (uint8_t *)&v12,  0x2Cu);
    }

    else
    {
      CFIndex domain = 4LL;
    }
  }

  else
  {
    unsigned int v9 = v2;
  }

  if (*((_DWORD *)this + 55) != 10) {
    *((_DWORD *)this + 55) = 11;
  }
  Tube::_onqueue_cleanupConnection(this);
  *(void *)&v23.CFErrorRef error = v2 & 0xFFFFFFFF00000000LL | v9;
  v23.CFIndex domain = domain;
  Tube::_onqueue_invokeCB(this, v23);
}

void ___ZN4Tube16_onqueue_connectEv_block_invoke(uint64_t a1)
{
  uint64_t v71 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 136);
  if (!v2) {
    goto LABEL_40;
  }
  uint64_t v3 = *(const void **)(*(void *)(v1 + 104) + 32LL);
  if (v3) {
    CFTypeRef v4 = CFRetain(v3);
  }
  else {
    CFTypeRef v4 = 0LL;
  }
  CFTypeRef cf = v4;
  int v5 = operator new(0x20uLL);
  void *v5 = off_189C17020;
  v5[1] = 0LL;
  v5[2] = 0LL;
  v5[3] = v4;
  uint64_t v47 = (uint64_t)v5;
  (*(void (**)(uint64_t, CFTypeRef *, void))(*(void *)v2 + 16LL))( v2,  &cf,  *(unsigned int *)(*(void *)(v1 + 104) + 56LL));
  int v6 = (std::__shared_weak_count *)v47;
  if (v47)
  {
    uint64_t v7 = (unint64_t *)(v47 + 8);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  uint64_t v9 = *(void *)(v1 + 136);
  uint64_t v10 = *(void *)(v1 + 176);
  *(void *)&__int128 buf = *(void *)(v1 + 168);
  *((void *)&buf + 1) = v10;
  if (v10)
  {
    uint64_t v11 = (unint64_t *)(v10 + 8);
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  (*(void (**)(uint64_t, __int128 *))(*(void *)v9 + 240LL))(v9, &buf);
  uint64_t v13 = (std::__shared_weak_count *)*((void *)&buf + 1);
  if (*((void *)&buf + 1))
  {
    __int16 v14 = (unint64_t *)(*((void *)&buf + 1) + 8LL);
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  if (!*(void *)(v1 + 136))
  {
LABEL_40:
    uint64_t v29 = (Tube *)v1;
    v30.CFIndex domain = 1LL;
    *(void *)&v30.CFErrorRef error = 12LL;
LABEL_65:
    Tube::_onqueue_errorHandler(v29, v30);
    return;
  }

  if ((*(unsigned int (**)(void))(**(void **)(v1 + 104) + 88LL))(*(void *)(v1 + 104)) == 1
    || (*(unsigned int (**)(void))(**(void **)(v1 + 104) + 88LL))(*(void *)(v1 + 104)) == 3)
  {
    uint64_t v16 = *(void *)(v1 + 112);
    if (!v16) {
      goto LABEL_41;
    }
    uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 80LL))(v16);
    if (!v17) {
      goto LABEL_41;
    }
    uint64_t v18 = v17;
    uint64_t v19 = *(void *)(v17 + 632);
    __int16 v20 = *(std::__shared_weak_count **)(v17 + 640);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        unint64_t v22 = __ldxr(p_shared_owners);
      while (__stxr(v22 + 1, p_shared_owners));
      do
        unint64_t v23 = __ldaxr(p_shared_owners);
      while (__stlxr(v23 - 1, p_shared_owners));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }

    if (v19)
    {
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v18 + 72LL))(&cf, v18);
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      unint64_t v24 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = cf;
        _os_log_impl( &dword_18298D000,  v24,  OS_LOG_TYPE_DEFAULT,  "Stream%{public}@ not enabling TLS for terminal delegate",  (uint8_t *)&buf,  0xCu);
      }

      unint64_t v25 = (std::__shared_weak_count *)v47;
      if (v47)
      {
        unint64_t v26 = (unint64_t *)(v47 + 8);
        do
          unint64_t v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }

      BOOL v28 = 0;
    }

    else
    {
LABEL_41:
      BOOL v28 = 1;
    }

    *(_BYTE *)(v1 + 18_Block_object_dispose(va, 8) = v28;
  }

  else
  {
    BOOL v28 = *(_BYTE *)(v1 + 188) != 0;
  }

  unint64_t v31 = *(uint64_t **)(v1 + 104);
  unint64_t v32 = v31 + 9;
  if (*(_BYTE *)(v1 + 192)) {
    unint64_t v32 = (uint64_t *)(v1 + 200);
  }
  uint64_t v33 = *v32;
  CFTypeRef cf = 0LL;
  *(void *)&__int128 buf = 0LL;
  uint64_t v34 = *(void *)(v1 + 208);
  unint64_t v35 = *(uint64_t (**(uint64_t *))(*v31 + 64))(v31);
  int v36 = resolveTubeType(v33, v28, v34, v35, (int *)(v1 + 184), &cf, &buf);
  int v37 = v36;
  if (cf) {
    int v38 = v36;
  }
  else {
    int v38 = 0;
  }
  if (v38 == 1) {
    int v37 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 136) + 200LL))( *(void *)(v1 + 136),  0x18C5AC6B0LL);
  }
  if (v37) {
    BOOL v39 = (void)buf == 0LL;
  }
  else {
    BOOL v39 = 1;
  }
  if (!v39) {
    LOBYTE(v37) = (*(uint64_t (**)(void, uint64_t))(**(void **)(v1 + 136) + 200LL))( *(void *)(v1 + 136),  0x18C5ABD48LL);
  }
  if (cf) {
    CFRelease(cf);
  }
  if ((void)buf) {
    CFRelease((CFTypeRef)buf);
  }
  if ((v37 & 1) == 0)
  {
    uint64_t v29 = (Tube *)v1;
    v30.CFIndex domain = 1LL;
    *(void *)&v30.CFErrorRef error = 100LL;
    goto LABEL_65;
  }

  unint64_t v40 = (const void *)MEMORY[0x1895F87A8];
  v44[4] = v1;
  v45[0] = MEMORY[0x1895F87A8];
  v45[1] = 3221225472LL;
  v45[2] = ___ZN4Tube16_onqueue_connectEv_block_invoke_2;
  v45[3] = &__block_descriptor_40_e5_v8__0l;
  v45[4] = v1;
  v44[0] = MEMORY[0x1895F87A8];
  v44[1] = 3221225472LL;
  v44[2] = ___ZN4Tube16_onqueue_connectEv_block_invoke_3;
  v44[3] = &__block_descriptor_40_e8_v12__0i8l;
  uint64_t v60 = 0LL;
  uint64_t v61 = &v60;
  uint64_t v62 = 0x2020000000LL;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(v1 + 8), 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  CFDictionarySetValue((CFMutableDictionaryRef)v61[3], &unk_18C5AD168, (const void *)*MEMORY[0x189604DE8]);
  if ((*(uint64_t (**)(void))(**(void **)(v1 + 104) + 64LL))(*(void *)(v1 + 104)))
  {
    uint64_t v41 = *(uint64_t (**(void))(**(void **)(v1 + 104) + 64LL))(*(void *)(v1 + 104));
    context[0] = v40;
    context[1] = 3221225472LL;
    context[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke;
    context[3] = &unk_189C198A0;
    void context[4] = &v60;
    CFDictionaryApplyFunction(v41, (CFDictionaryApplierFunction)_apply_block, context);
  }

  v57[0] = 0LL;
  v57[1] = v57;
  v57[2] = 0x2020000000LL;
  char v58 = 1;
  v56[0] = 0LL;
  v56[1] = v56;
  v56[2] = 0x2020000000LL;
  v56[3] = 0LL;
  CFTypeRef cf = v40;
  uint64_t v47 = 3221225472LL;
  uint64_t v48 = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_2;
  uint64_t v49 = &unk_189C19920;
  unint64_t v52 = v56;
  unint64_t v53 = &v60;
  CFTypeID v54 = v57;
  uint64_t v55 = v1;
  CFStreamError v50 = v44;
  uint64_t v51 = v45;
  uint64_t v42 = (*(uint64_t (**)(void))(**(void **)(v1 + 112) + 80LL))(*(void *)(v1 + 112));
  (*(void (**)(uint64_t))(*(void *)v42 + 16LL))(v42);
  (*(void (**)(uint64_t))(*(void *)v1 + 40LL))(v1);
  uint64_t v43 = *(void *)(v42 - 152);
  *(void *)&__int128 buf = v40;
  *((void *)&buf + 1) = 3221225472LL;
  unint64_t v65 = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_2_26;
  uint64_t v66 = &unk_189C0B2F0;
  uint64_t v69 = v1;
  uint64_t v70 = v42;
  p_CFTypeRef cf = &cf;
  uint64_t v68 = v56;
  (*(void (**)(uint64_t, __int128 *))(*(void *)v43 + 96LL))(v43, &buf);
  _Block_object_dispose(v56, 8);
  _Block_object_dispose(v57, 8);
  _Block_object_dispose(&v60, 8);
}

void sub_182ACED64( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34)
{
  int v36 = *(std::__shared_weak_count **)(v34 - 136);
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      unint64_t v38 = __ldaxr(p_shared_owners);
    while (__stlxr(v38 - 1, p_shared_owners));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t ___ZN4Tube16_onqueue_connectEv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 128LL))(*(void *)(a1 + 32));
}

void ___ZN4Tube16_onqueue_connectEv_block_invoke_3(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    __assert_rtn("_onqueue_errorHandler", "Tube.cpp", 1112, "posixErrorCode != 0");
  }
  *(void *)&v2.CFErrorRef error = a2;
  v2.CFIndex domain = 1LL;
  Tube::_onqueue_errorHandler(*(Tube **)(a1 + 32), v2);
}

void ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke( uint64_t a1, const void *a2, const void *a3)
{
}

void ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[9];
  if (*(_DWORD *)(v2 + 220) == 10)
  {
    uint64_t v3 = *(void *)(a1[6] + 8LL);
    CFTypeRef v4 = *(const void **)(v3 + 24);
    *(void *)(v3 + 24) = 0LL;
    if (v4) {
      CFRelease(v4);
    }
    uint64_t v5 = *(void *)(a1[7] + 8LL);
    int v6 = *(const void **)(v5 + 24);
    *(void *)(v5 + 24) = 0LL;
    if (v6) {
      CFRelease(v6);
    }
    return;
  }

  uint64_t v7 = MEMORY[0x1895F87A8];
  if (*(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL))
  {
    values = 0LL;
    p_values = &values;
    uint64_t v46 = 0x2020000000LL;
    BOOL v8 = (*(unsigned int (**)(void))(**(void **)(v2 + 104) + 88LL))(*(void *)(v2 + 104)) == 1
      || (*(unsigned int (**)(void))(**(void **)(v2 + 104) + 88LL))(*(void *)(v2 + 104)) == 3;
    BOOL v47 = v8;
    uint64_t v9 = *(const __CFDictionary **)(*(void *)(a1[6] + 8LL) + 24LL);
    if (v9)
    {
      context[0] = v7;
      context[1] = 3221225472LL;
      context[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_3;
      context[3] = &unk_189C198F8;
      uint64_t v10 = a1[7];
      void context[4] = &values;
      void context[5] = v10;
      CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)_apply_block, context);
      uint64_t v11 = *(void *)(a1[6] + 8LL);
      unint64_t v12 = *(const void **)(v11 + 24);
      *(void *)(v11 + 24) = 0LL;
      if (v12) {
        CFRelease(v12);
      }
    }

    if (*((_BYTE *)p_values + 24)) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1[7] + 8LL) + 24LL), &unk_18C5ADE88, &unk_18C5AE198);
    }
    _Block_object_dispose(&values, 8);
    if (*(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL))
    {
      (*(void (**)(void, void))(**(void **)(v2 + 136) + 208LL))( *(void *)(v2 + 136),  *(void *)(*(void *)(a1[7] + 8LL) + 24LL));
      if (*(_BYTE *)(v2 + 188)) {
        *(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL) = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 136)
      }
                                                                                                 + 24LL))( *(void *)(v2 + 136),  1LL);
    }
  }

  uint64_t v13 = *(void *)(a1[7] + 8LL);
  __int16 v14 = *(const void **)(v13 + 24);
  *(void *)(v13 + 24) = 0LL;
  if (v14) {
    CFRelease(v14);
  }
  if (*(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL)
    && (*(unsigned int (**)(void))(**(void **)(v2 + 104) + 88LL))(*(void *)(v2 + 104)) == 3)
  {
    uint64_t v15 = *(void *)(v2 + 112);
    if (!v15 || !(*(uint64_t (**)(uint64_t))(*(void *)v15 + 88LL))(v15))
    {
LABEL_55:
      *(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL) = 0;
      goto LABEL_56;
    }

    uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(v2 + 112) + 88LL))(*(void *)(v2 + 112));
    uint64_t v17 = *(_CFHTTPAuthentication **)(v16 + 80);
    if (!v17) {
      goto LABEL_56;
    }
    uint64_t v18 = (__CFHTTPMessage *)(v16 - 16);
    uint64_t v19 = *(uint64_t (**(void))(**(void **)(v2 + 136) + 216LL))(*(void *)(v2 + 136));
    __int16 v20 = v19;
    if (v19)
    {
      int Value = (const __CFDictionary *)CFDictionaryGetValue(v19, &unk_18C5B2418);
      unint64_t v22 = Value;
      if (Value)
      {
        unint64_t v23 = CFDictionaryGetValue(Value, &unk_18C5AF430);
        char v41 = 0;
        goto LABEL_32;
      }
    }

    else
    {
      unint64_t v22 = 0LL;
    }

    unint64_t v23 = 0LL;
    char v41 = 1;
LABEL_32:
    CFHTTPMessageRef Copy = CFHTTPMessageCreateCopy(*(CFAllocatorRef *)(v2 + 8), v18);
    _CFHTTPAuthenticationApplyHeaderToRequest(v17, Copy, (const void *)v2);
    if (v25)
    {
      values = 0LL;
      CFRelease(Copy);
      int v26 = 0;
    }

    else
    {
      unint64_t v27 = (__CFString *)HTTPMessage::copyHeaderFieldValue((CFHTTPMessageRef)((char *)Copy + 16), 0x1382736Bu);
      values = v27;
      CFRelease(Copy);
      if (!v27 || v23 && CFEqual(v23, v27))
      {
        int v26 = 1;
      }

      else
      {
        BOOL v28 = *(const __CFAllocator **)(v2 + 8);
        if ((v41 & 1) != 0)
        {
          CFMutableArrayRef MutableCopy = CFDictionaryCreate( *(CFAllocatorRef *)(v2 + 8),  (const void **)&kCFHTTPHeaderProxyAuthorization,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
          uint64_t v48 = MutableCopy;
        }

        else
        {
          CFIndex Count = CFDictionaryGetCount(v22);
          CFMutableArrayRef MutableCopy = CFDictionaryCreateMutableCopy(v28, Count + 1, v22);
          uint64_t v48 = MutableCopy;
          CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, &unk_18C5AF430, v27);
        }

        unint64_t v31 = *(const __CFAllocator **)(v2 + 8);
        if (v20)
        {
          CFIndex v32 = CFDictionaryGetCount(v20);
          uint64_t v33 = CFDictionaryCreateMutableCopy(v31, v32 + 1, v20);
          CFDictionarySetValue(v33, &unk_18C5B2418, MutableCopy);
        }

        else
        {
          uint64_t v33 = CFDictionaryCreate( *(CFAllocatorRef *)(v2 + 8),  (const void **)&kCFStreamPropertyCONNECTAdditionalHeaders,  (const void **)&v48,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
          CFMutableArrayRef MutableCopy = v48;
        }

        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
        int v26 = (*(uint64_t (**)(void, uint64_t, __CFDictionary *))(**(void **)(v2 + 136) + 200LL))( *(void *)(v2 + 136),  0x18C5B2450LL,  v33);
        if (v33) {
          CFRelease(v33);
        }
      }
    }

    if (v20) {
      CFRelease(v20);
    }
    if (values) {
      CFRelease(values);
    }
    if (v26) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }

  if (!*(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL)) {
    goto LABEL_68;
  }
LABEL_56:
  (*(void (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  aBlock[0] = v7;
  aBlock[1] = 3221225472LL;
  aBlock[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_24;
  aBlock[3] = &__block_descriptor_40_e5_v8__0l;
  aBlock[4] = v2;
  uint64_t v34 = _Block_copy(aBlock);
  unint64_t v35 = (std::__shared_weak_count *)operator new(0x30uLL);
  v35->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v35->__shared_owners_;
  v35->__vftable = (std::__shared_weak_count_vtbl *)off_189C0B468;
  v35->__shared_weak_owners_ = 0LL;
  v35[1].__vftable = (std::__shared_weak_count_vtbl *)v2;
  v35[1].__shared_owners_ = (uint64_t)v34;
  v35[1].__shared_weak_owners_ = 0LL;
  uint64_t v37 = *(void *)(v2 + 136);
  do
    unint64_t v38 = __ldxr(p_shared_owners);
  while (__stxr(v38 + 1, p_shared_owners));
  std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v37 + 144), v2 + 40, (uint64_t)v35);
  do
    unint64_t v39 = __ldaxr(p_shared_owners);
  while (__stlxr(v39 - 1, p_shared_owners));
  if (!v39)
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }

  do
    unint64_t v40 = __ldaxr(p_shared_owners);
  while (__stlxr(v40 - 1, p_shared_owners));
  if (!v40)
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }

  if (*(_BYTE *)(*(void *)(a1[8] + 8LL) + 24LL)) {
    (*(void (**)(void))(a1[5] + 16LL))();
  }
  else {
LABEL_68:
  }
    (*(void (**)(void))(a1[4] + 16LL))();
}

void sub_182ACF480( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

uint64_t ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_2_26( void *a1)
{
  uint64_t v3 = (void *)a1[6];
  uint64_t v2 = a1[7];
  if (v2) {
    CFTypeRef v4 = (HTTPProtocol *)(v2 - 176);
  }
  else {
    CFTypeRef v4 = 0LL;
  }
  *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = HTTPProtocol::copyProtocolPropertiesForStream(v4);
  (*(void (**)(void *))(*v3 + 40LL))(v3);
  uint64_t v5 = (dispatch_queue_s *)v3[20];
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_3_28;
  block[3] = &unk_189C19948;
  block[4] = a1[4];
  void block[5] = v3;
  void block[6] = a1[7];
  dispatch_async(v5, block);
  return (*(uint64_t (**)(void *))(*v3 + 48LL))(v3);
}

uint64_t ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_3_28( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  (*(void (**)(void))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48));
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
}

void ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_3( uint64_t a1, CFStringRef theString1, const void *a3)
{
  if (CFStringCompare(theString1, (CFStringRef)&unk_18C5ADE88, 1uLL) == kCFCompareEqualTo)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
LABEL_18:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL), theString1, a3);
    return;
  }

  if (CFStringCompare(theString1, (CFStringRef)&unk_18C5AE048, 1uLL)) {
    goto LABEL_18;
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  int Value = (const __CFDictionary *)CFDictionaryGetValue( *(CFDictionaryRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  &unk_18C5AE048);
  if (!Value) {
    goto LABEL_18;
  }
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, Value);
  CFMutableDictionaryRef v19 = MutableCopy;
  BOOL v8 = (std::__shared_weak_count *)operator new(0x20uLL);
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_189C19FA8;
  v8->__shared_weak_owners_ = 0LL;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)MutableCopy;
  __int16 v20 = v8;
  v17[4] = MutableCopy;
  uint64_t v18 = v8;
  v8->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3321888768LL;
  v17[2] = ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_4;
  v17[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE_e25_v24__0____CFString__8_v16l;
  do
    unint64_t v10 = __ldxr(p_shared_owners);
  while (__stxr(v10 + 1, p_shared_owners));
  CFDictionaryApplyFunction((CFDictionaryRef)a3, (CFDictionaryApplierFunction)_apply_block, v17);
  CFDictionarySetValue( *(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL),  theString1,  MutableCopy);
  uint64_t v11 = v18;
  if (v18)
  {
    unint64_t v12 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  __int16 v14 = v20;
  if (v20)
  {
    uint64_t v15 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void sub_182ACF780( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_24( uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48LL))(*(void *)(a1 + 32));
}

void std::__shared_ptr_pointer<Tube *,Deleter_CustomBlock,std::allocator<Tube>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void ___ZN4Tube23_onqueue_prepConnectionEU13block_pointerFvvEU13block_pointerFviE_block_invoke_4( uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t __copy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void ___ZN4Tube23preConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke( uint64_t a1, const void *a2, int a3, std::__shared_weak_count_vtbl *cf, int a5, uint64_t *a6)
{
  uint64_t v7 = *(void *)(a1 + 40);
  if (!v7) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(*(void *)(a1 + 32) + 88LL) != 2)
  {
    unint64_t v13 = *(AuthBrokerAgentClient **)(v7 + 80);
    if (!v13
      || (unint64_t v13 = (AuthBrokerAgentClient *)-[AuthBrokerAgentClient _preventsSystemHTTPProxyAuthentication]( v13,  "_preventsSystemHTTPProxyAuthentication"),  (v13 & 1) == 0))
    {
      if (((*(unsigned int *)(v7 + 192) | ((unint64_t)*(unsigned __int16 *)(v7 + 196) << 32)) & 0x2000000000LL) == 0
        && (AuthBrokerAgentClient::AuthBrokerIsAvailable(v13) & 1) != 0)
      {
LABEL_7:
        uint64_t v14 = *a6;
        if (*a6)
        {
          uint64_t v15 = *(void (**)(void *, void, void))(v14 + 8);
          uint64_t v16 = *(void *)(v14 + 16);
          uint64_t v17 = (void *)(v14 + (v16 >> 1));
          if ((v16 & 1) != 0) {
            uint64_t v15 = *(void (**)(void *, void, void))(*v17 + v15);
          }
          v15(v17, 0LL, 0LL);
        }

        return;
      }
    }

    uint64_t v7 = *(void *)(a1 + 40);
  }

  uint64_t v18 = (std::__shared_weak_count *)a6[1];
  uint64_t v57 = *a6;
  char v58 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v20 = __ldxr(p_shared_owners);
    while (__stxr(v20 + 1, p_shared_owners));
  }

  if (cf) {
    CFTypeRef cf = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  }
  int v73 = cf;
  unsigned int v21 = (std::__shared_weak_count *)operator new(0x20uLL);
  v21->__shared_owners_ = 0LL;
  unint64_t v22 = (unint64_t *)&v21->__shared_owners_;
  v21->__vftable = (std::__shared_weak_count_vtbl *)off_189C17020;
  v21->__shared_weak_owners_ = 0LL;
  v21[1].__vftable = cf;
  uint64_t v74 = v21;
  if (a2) {
    unint64_t v23 = (std::__shared_weak_count_vtbl *)CFRetain(a2);
  }
  else {
    unint64_t v23 = 0LL;
  }
  uint64_t v71 = v23;
  unint64_t v24 = (std::__shared_weak_count *)operator new(0x20uLL);
  v24->__shared_owners_ = 0LL;
  int v25 = (unint64_t *)&v24->__shared_owners_;
  v24->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CDC0;
  v24->__shared_weak_owners_ = 0LL;
  v24[1].__vftable = v23;
  CFTypeRef v72 = v24;
  if (v7) {
    CFRetain((CFTypeRef)(v7 - 16));
  }
  uint64_t v69 = v7;
  int v26 = (std::__shared_weak_count *)operator new(0x20uLL);
  v26->__shared_owners_ = 0LL;
  unint64_t v27 = (unint64_t *)&v26->__shared_owners_;
  v26->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE68;
  v26->__shared_weak_owners_ = 0LL;
  v26[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
  uint64_t v70 = v26;
  uint64_t v28 = *(void *)(v7 + 24);
  v59[0] = MEMORY[0x1895F87A8];
  v59[1] = 3321888768LL;
  v59[2] = ___ZN12HTTPProtocol24handleProxyAuthChallengeEP15__CFHTTPMessagejPK10__CFStringi18SmartBlockWithArgsIJPK16_CFURLCredentialbEE_block_invoke;
  v59[3] = &__block_descriptor_120_e8_48c39_ZTSNSt3__110shared_ptrIK10__CFStringEE64c49_ZTS18SmartBlockWithArgsIJPK16_CFURLCredentialbEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  v59[4] = v7;
  v59[5] = a2;
  v59[6] = cf;
  uint64_t v60 = v21;
  do
    unint64_t v29 = __ldxr(v22);
  while (__stxr(v29 + 1, v22));
  int v67 = a5;
  uint64_t v61 = v57;
  uint64_t v62 = v58;
  if (v58)
  {
    CFStreamError v30 = (unint64_t *)&v58->__shared_owners_;
    do
      unint64_t v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }

  uint64_t v63 = v23;
  uint64_t v64 = v24;
  do
    unint64_t v32 = __ldxr(v25);
  while (__stxr(v32 + 1, v25));
  int v68 = a3;
  uint64_t v65 = v7;
  uint64_t v66 = v26;
  do
    unint64_t v33 = __ldxr(v27);
  while (__stxr(v33 + 1, v27));
  (*(void (**)(uint64_t, void *))(*(void *)v28 + 96LL))(v28, v59);
  uint64_t v34 = v66;
  if (v66)
  {
    unint64_t v35 = (unint64_t *)&v66->__shared_owners_;
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

  uint64_t v37 = v64;
  if (v64)
  {
    unint64_t v38 = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }

  unint64_t v40 = v62;
  if (v62)
  {
    char v41 = (unint64_t *)&v62->__shared_owners_;
    do
      unint64_t v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }

  uint64_t v43 = v60;
  if (v60)
  {
    uint64_t v44 = (unint64_t *)&v60->__shared_owners_;
    do
      unint64_t v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }

  uint64_t v46 = v70;
  if (v70)
  {
    BOOL v47 = (unint64_t *)&v70->__shared_owners_;
    do
      unint64_t v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }

  uint64_t v49 = v72;
  if (v72)
  {
    CFStreamError v50 = (unint64_t *)&v72->__shared_owners_;
    do
      unint64_t v51 = __ldaxr(v50);
    while (__stlxr(v51 - 1, v50));
    if (!v51)
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }

  unint64_t v52 = v74;
  if (v74)
  {
    unint64_t v53 = (unint64_t *)&v74->__shared_owners_;
    do
      unint64_t v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }

  if (v58)
  {
    uint64_t v55 = (unint64_t *)&v58->__shared_owners_;
    do
      unint64_t v56 = __ldaxr(v55);
    while (__stlxr(v56 - 1, v55));
    if (!v56)
    {
      ((void (*)(std::__shared_weak_count *))v58->__on_zero_shared)(v58);
      std::__shared_weak_count::__release_weak(v58);
    }
  }

void sub_182ACFC38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

void BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_normal( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v6 = *a1;
  uint64_t v7 = (std::__shared_weak_count *)a6[1];
  uint64_t v13 = *a6;
  uint64_t v14 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v6 + 16))(v6, a2, a3, a4, a5, &v13);
  unint64_t v10 = v14;
  if (v14)
  {
    uint64_t v11 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

void sub_182ACFD24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t BlockHolderVar<void *>::invoke_normal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16LL))();
}

void BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_initial( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  a1[1] = (uint64_t)BlockHolderVar<__CFHTTPMessage *,unsigned int,__CFString const*,int,SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::invoke_normal;
  a1[2] = 0LL;
  uint64_t v6 = *a1;
  uint64_t v7 = (std::__shared_weak_count *)a6[1];
  uint64_t v13 = *a6;
  uint64_t v14 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(v6 + 16))(v6, a2, a3, a4, a5, &v13);
  unint64_t v10 = v14;
  if (v14)
  {
    uint64_t v11 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

void sub_182ACFDDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ___ZN4Tube27_onqueue_saveSSLCertContextEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 136LL) + 216LL))(*(void *)(*(void *)(a1 + 32) + 136LL));
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_4(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_5(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN4Tube34_captureEstablishmentFailureReasonEv_block_invoke_6(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke( void *a1, uint64_t *a2)
{
  uint64_t v3 = *(dispatch_queue_s **)(a1[4] + 160LL);
  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3321888768LL;
  v17[2] = ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke_2;
  v17[3] = &__block_descriptor_64_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE_e5_v8__0l;
  uint64_t v5 = a1[6];
  unint64_t v4 = (std::__shared_weak_count *)a1[7];
  v17[4] = v5;
  uint64_t v18 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  BOOL v8 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  unint64_t v20 = v8;
  if (v8)
  {
    unint64_t v9 = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  dispatch_async(v3, v17);
  uint64_t v11 = v20;
  if (v20)
  {
    unint64_t v12 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  uint64_t v14 = v18;
  if (v18)
  {
    uint64_t v15 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()( uint64_t a1, uint64_t a2, std::__shared_weak_count *a3)
{
  if (a1)
  {
    if (a3)
    {
      p_shared_owners = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v4 = __ldxr(p_shared_owners);
      while (__stxr(v4 + 1, p_shared_owners));
    }

    uint64_t v5 = *(void (**)(void *, uint64_t *))(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 16);
    unint64_t v7 = (void *)(a1 + (v6 >> 1));
    if ((v6 & 1) != 0) {
      uint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
    }
    uint64_t v16 = a2;
    uint64_t v17 = a3;
    if (a3)
    {
      BOOL v8 = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }

    v5(v7, &v16);
    unint64_t v10 = v17;
    if (v17)
    {
      uint64_t v11 = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    if (a3)
    {
      unint64_t v13 = (unint64_t *)&a3->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
        std::__shared_weak_count::__release_weak(a3);
      }
    }
  }

void sub_182AD005C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void *__copy_helper_block_e8_32c31_ZTSNSt3__110shared_ptrI4TubeEE48c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c31_ZTSNSt3__110shared_ptrI4TubeEE48c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE( uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void ___ZN4Tube27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke_2( uint64_t *a1)
{
  uint64_t v1 = a1[6];
  uint64_t v2 = (std::__shared_weak_count *)a1[7];
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }

  SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(a1[4], v1, v2);
  if (v2)
  {
    uint64_t v5 = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

void sub_182AD0170( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *__copy_helper_block_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    unint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE48c47_ZTSNSt3__110shared_ptrI19AuthenticationStateEE( uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void std::__shared_ptr_pointer<Tube *,Tube::generateProxyAuthentication(std::shared_ptr<NetworkProxy>,std::shared_ptr<HTTPResponseMessage>,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>)::$_0,std::allocator<Tube>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<Tube *,Tube::generateProxyAuthentication(std::shared_ptr<NetworkProxy>,std::shared_ptr<HTTPResponseMessage>,SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>)::$_0,std::allocator<Tube>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48LL))(result);
  }
  return result;
}

void ___ZN4Tube21setConnectionPropertyEPK10__CFStringPKv_block_invoke(void *a1)
{
  uint64_t v2 = *(void *)(a1[5] + 136LL);
  if (v2) {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v2 + 200LL))( v2,  a1[6],  a1[7]);
  }
  uint64_t v3 = (const void *)a1[6];
  if (v3) {
    CFRelease(v3);
  }
  unint64_t v4 = (const void *)a1[7];
  if (v4) {
    CFRelease(v4);
  }
}

uint64_t ___ZN4Tube10initializeEP16BaseAwaitingTubeP7NSArrayIP30_NSHTTPAlternativeServiceEntryE_block_invoke( uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(_DWORD *)(v2 + 220) != 10) {
    *(_DWORD *)(v2 + 220) = 1;
  }
  uint64_t v3 = (uint64_t *)MEMORY[0x189604DE8];
  if (*(_BYTE *)(a1 + 64)) {
    (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 136) + 200LL))( *(void *)(v2 + 136),  0x18C5AB290LL,  *MEMORY[0x189604DE8]);
  }
  if (*(void *)(a1 + 32) && *(void *)(a1 + 40))
  {
    (*(void (**)(void, uint64_t))(**(void **)(v2 + 136) + 200LL))(*(void *)(v2 + 136), 0x18C5AB990LL);
    (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 136) + 200LL))( *(void *)(v2 + 136),  0x18C5AB9C8LL,  *(void *)(a1 + 40));
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    unint64_t v4 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = [*(id *)(a1 + 48) _loggableDescription];
      int v15 = 138543362;
      uint64_t v16 = v5;
      _os_log_impl(&dword_18298D000, v4, OS_LOG_TYPE_INFO, "%{public}@ Alt-Svc entry found", (uint8_t *)&v15, 0xCu);
    }
  }

  uint64_t v6 = *(void *)(v2 + 136);
  BOOL isFirstPartyResource = HTTPConnectionCacheKey::isFirstPartyResource(*(HTTPConnectionCacheKey **)(v2 + 104));
  uint64_t v8 = *v3;
  uint64_t v9 = *MEMORY[0x189604DE0];
  if (isFirstPartyResource) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = *MEMORY[0x189604DE0];
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 200LL))(v6, 0x18C5AB8E8LL, v10);
  uint64_t v11 = *(void *)(v2 + 136);
  uint64_t v12 = *(void *)(v2 + 104);
  unint64_t v13 = *(const void **)(v12 + 40);
  if (v13 && !CFEqual(*(CFTypeRef *)(v12 + 32), v13)) {
    uint64_t v8 = v9;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11 + 200LL))(v11, 0x18C5AB920LL, v8);
  Tube::_onqueue_connect((Tube *)v2);
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
}

uint64_t ___ZN4Tube24overrideAllowedProtocolsEm_block_invoke(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(int *)(v1 + 220) <= 1)
  {
    *(_BYTE *)(v1 + 192) = 1;
    *(void *)(v1 + 200) = *(void *)(result + 40);
  }

  return result;
}

void sub_182AD0EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_182AD1154( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_182AD29C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
}

void __Block_byref_object_copy__6603(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__6604(uint64_t a1)
{
}

void sub_182AD53D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL FTPProtocol::_canHandleRequest(FTPProtocol *this, const _CFURLRequest *a2, const void *a3)
{
  if (!this) {
    return 0LL;
  }
  uint64_t v3 = *(const __CFURL **)(-[FTPProtocol _inner](this, "_inner", a3) + 8);
  if (!v3) {
    return 0LL;
  }
  unint64_t v4 = CFURLCopyScheme(v3);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  BOOL v6 = CFStringCompare(v4, @"ftp", 1uLL) == kCFCompareEqualTo;
  CFRelease(v5);
  return v6;
}

const __CFAllocator *FTPProtocol::_createCanonicalRequest( FTPProtocol *this, const __CFAllocator *a2, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  uint64_t v5 = a2;
  BOOL v6 = *(const __CFURL **)(-[__CFAllocator _inner](a2, "_inner", a3, a4, a5) + 8);
  unsigned __int8 v11 = 0;
  uint64_t v7 = _createCanonicalURL(v6, 1LL, 0LL, &v11);
  uint64_t v8 = v7;
  if (v7) {
    BOOL v9 = v7 == v6;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (v7) {
      CFRelease(v7);
    }
    if (v5) {
      return (const __CFAllocator *)CFRetain(v5);
    }
  }

  else
  {
    uint64_t v5 = (const __CFAllocator *)-[__CFAllocator mutableCopy](v5, "mutableCopy");
    CFURLRequestSetURL(v5, v8);
    CFRelease(v8);
  }

  return v5;
}

uint64_t FTPProtocol::_requestsAreCacheEquivalent( FTPProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0LL;
}

uint64_t FTPProtocol::_instantiateProtocol( FTPProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    uint64_t v8 = Instance + 16;
    *(void *)(Instance + 176) = 0LL;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
    *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 64) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
  }

  *(_OWORD *)(v8 + 152) = 0u;
  *(_OWORD *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 136) = 0u;
  *(_OWORD *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30 - 120) = 0u;
  *(_OWORD *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30 - 104) = 0u;
  *(_OWORD *)(v8 + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 24) = 0u;
  *(void *)uint64_t v8 = &off_189C0B760;
  *(void *)(v8 + _Block_object_dispose(va, 8) = &unk_189C0B860;
  *(void *)(v8 + CFRetain((char *)this - 16) = &unk_189C0B880;
  URLProtocol::initialize((URLProtocol *)v8, a2, a3);
  return v8 - 16;
}

CFStringRef FTPProtocol::copyDebugDesc(FTPProtocol *this)
{
  uint64_t v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0LL, @"<FTP protocol instance %p>", this);
}

void FTPProtocol::_protocolInterface_startLoad(FTPProtocol *this, const _CFCachedURLResponse *a2)
{
  if ((*((_BYTE *)this + 112) & 4) == 0)
  {
    uint64_t v3 = (void *)*((void *)this + 11);
    CFTypeRef v4 = (CFTypeRef)[v3 cfURL];
    if (v4) {
      CFTypeRef v4 = CFRetain(v4);
    }
    *((void *)this + 20) = v4;
    CFURLRef v5 = _CFURLRequestCopyProtocolPropertyForKey(v3, @"kCFFTPProtocolPropertyReturnDirectoryListing");
    if (v5)
    {
      CFURLRef v6 = v5;
      CFTypeID v7 = CFGetTypeID(v5);
      if (v7 != CFBooleanGetTypeID() && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
      {
        LOWORD(clientContext.version) = 0;
        _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "pass kCFBooleanTrue or kCFBooleanFalse here",  (uint8_t *)&clientContext,  2u);
      }

      CFURLRef v8 = (CFURLRef)*MEMORY[0x189604DE0];
      CFRelease(v6);
      if (v8 == v6) {
        *((_BYTE *)this + 112) |= 0x10u;
      }
    }
  }

  BOOL v9 = CFURLCopyPath(*((CFURLRef *)this + 20));
  if (v9)
  {
    uint64_t v10 = v9;
    if (CFStringGetLength(v9) && !CFURLHasDirectoryPath(*((CFURLRef *)this + 20))) {
      char v11 = *((_BYTE *)this + 112) & 0xF7;
    }
    else {
      char v11 = *((_BYTE *)this + 112) | 8;
    }
    *((_BYTE *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v11;
    CFRelease(v10);
    char v12 = *((_BYTE *)this + 112);
  }

  else
  {
    char v12 = *((_BYTE *)this + 112) | 8;
    *((_BYTE *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v12;
  }

  if ((v12 & 0x1C) == 0x18)
  {
    FTPProtocol::checkAndSendDidReceiveResponse(this);
    URLProtocol::sendDidFinishLoading((URLProtocol *)this);
    return;
  }

  unint64_t v13 = CFGetAllocator((char *)this - 16);
  unint64_t v14 = CFReadStreamCreateWithFTPURL(v13, *((CFURLRef *)this + 20));
  *((void *)this + 1_Block_object_dispose(va, 8) = v14;
  if (v14)
  {
    clientContext.version = 0LL;
    clientContext.uint64_t info = this;
    memset(&clientContext.retain, 0, 24);
    CFReadStreamSetClient(v14, 0x1AuLL, (CFReadStreamClientCallBack)FTPProtocol::_ftpReadStreamCB, &clientContext);
    CFReadStreamSetProperty( *((CFReadStreamRef *)this + 18),  @"kCFStreamPropertyFTPFetchResourceInfo",  (CFTypeRef)*MEMORY[0x189604DE8]);
    *((void *)this + 19) = 0LL;
    CoreSchedulingSet::scheduleStream(*((CoreSchedulingSet **)this + 3), *((__CFReadStream **)this + 18));
    if (CFReadStreamOpen(*((CFReadStreamRef *)this + 18))) {
      return;
    }
    CFCFStreamError Error = CFReadStreamCopyError(*((CFReadStreamRef *)this + 18));
  }

  else
  {
    uint64_t v16 = CFGetAllocator((char *)this - 16);
    CFCFStreamError Error = __cfnCreateCFError(v16, @"kCFErrorDomainCFNetwork", -998LL, v17, v18, v19, v20, v21, 0LL);
  }

  unint64_t v22 = CFError;
  URLProtocol::sendDidFail((URLProtocol *)this, CFError);
  if (v22) {
    CFRelease(v22);
  }
}

void FTPProtocol::_protocolInterface_cancelLoad(FTPProtocol *this)
{
  if ((*((_BYTE *)this + 112) & 0x20) == 0)
  {
    *((_BYTE *)this + 112) |= 0x20u;
    FTPProtocol::destroyReadStream(this);
  }

uint64_t FTPProtocol::_protocolInterface_haltLoad(uint64_t this)
{
  *(_BYTE *)(this + 112) |= 1u;
  return this;
}

void FTPProtocol::_protocolInterface_resumeLoad(FTPProtocol *this)
{
  *((_BYTE *)this + 112) &= ~1u;
  if (*((void *)this + 18))
  {
    if (*((void *)this + 19))
    {
      FTPProtocol::ftpReadStreamEvent(this);
      *((void *)this + 19) = 0LL;
    }
  }

void FTPProtocol::subclassUpdateScheduling( FTPProtocol *this, const CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
  if ((*((_BYTE *)this + 112) & 1) != 0)
  {
    CFTypeRef v4 = (__CFReadStream *)*((void *)this + 18);
    if (v4)
    {
      CFURLRef v6 = (CoreSchedulingSet *)*((void *)this + 3);
      if (v6)
      {
        CoreSchedulingSet::unscheduleStream(v6, v4);
        CFTypeRef v4 = (__CFReadStream *)*((void *)this + 18);
      }

      CoreSchedulingSet::scheduleStream(a3, v4);
    }
  }

uint64_t FTPProtocol::needsThrottler(FTPProtocol *this)
{
  return 1LL;
}

void non-virtual thunk to'FTPProtocol::~FTPProtocol(FTPProtocol *this)
{
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 8));
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 16));
}

{
  FTPProtocol::~FTPProtocol((FTPProtocol *)((char *)this - 16));
}

void FTPProtocol::~FTPProtocol(FTPProtocol *this)
{
  *(void *)this = &off_189C0B760;
  *((void *)this + 1) = &unk_189C0B860;
  *((void *)this + 2) = &unk_189C0B880;
  uint64_t v2 = (const void *)*((void *)this + 15);
  if (v2) {
    CFRelease(v2);
  }
  FTPProtocol::destroyReadStream(this);
  uint64_t v3 = (const void *)*((void *)this + 20);
  if (v3) {
    CFRelease(v3);
  }
  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_182AD5AC8(_Unwind_Exception *a1)
{
}

void FTPProtocol::destroyReadStream(FTPProtocol *this)
{
  uint64_t v2 = (__CFReadStream *)*((void *)this + 18);
  if (v2)
  {
    CFReadStreamSetClient(v2, 0LL, 0LL, 0LL);
    CFReadStreamClose(*((CFReadStreamRef *)this + 18));
    uint64_t v3 = (const void *)*((void *)this + 18);
    if (v3) {
      CFRelease(v3);
    }
    *((void *)this + 1_Block_object_dispose(va, 8) = 0LL;
  }

void FTPProtocol::ftpReadStreamEvent(FTPProtocol *this)
{
  uint64_t v1 = MEMORY[0x1895F8858](this);
  unint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if ((v2 > 0x10 || ((1LL << v2) & 0x10104) == 0) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buffer = 136315138;
    uint64_t v30 = "ftpReadStreamEvent";
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "%s(): Called back for an event we don't recognize!",  buffer,  0xCu);
  }

  if ((*(_BYTE *)(v4 + 112) & 1) != 0)
  {
    *(void *)(v4 + 152) = v3;
    return;
  }

  if (v3 == 16)
  {
    if ((*(_BYTE *)(v4 + 112) & 4) == 0)
    {
      FTPProtocol::checkAndSendDidReceiveResponse((FTPProtocol *)v4);
      URLProtocol::sendDidFinishLoading((URLProtocol *)v4);
      return;
    }

    goto LABEL_28;
  }

  if (v3 != 8)
  {
    if (v3 != 2) {
      return;
    }
    if ((*(_BYTE *)(v4 + 112) & 4) == 0)
    {
      FTPProtocol::checkAndSendDidReceiveResponse((FTPProtocol *)v4);
      uint64_t v5 = CFReadStreamRead(*(CFReadStreamRef *)(v4 + 144), buffer, 0x10000LL);
      if (v5 >= 1)
      {
        CFURLRef v6 = CFGetAllocator((CFTypeRef)(v4 - 16));
        CFTypeID v7 = CFDataCreate(v6, buffer, v5);
        CFURLRef v8 = v7;
        if (v7)
        {
          BOOL v9 = *(Throttler **)(v4 + 64);
          if (v9)
          {
            CFIndex Length = CFDataGetLength(v7);
            Throttler::noteOutstandingBytes(v9, Length);
          }
        }

        uint64_t v11 = *(void *)(v4 + 96);
        if (v11)
        {
          uint64_t v12 = (*(uint64_t (**)(void))(*(void *)v11 + 16LL))(*(void *)(v4 + 96));
          unint64_t v13 = (void *)MEMORY[0x186E1578C](v12);
          (*(void (**)(void, const __CFData *, uint64_t))(**(void **)(v4 + 96) + 72LL))( *(void *)(v4 + 96),  v8,  v5);
          objc_autoreleasePoolPop(v13);
          (*(void (**)(uint64_t))(*(void *)v11 + 24LL))(v11);
        }

        CFRelease(v8);
      }

      return;
    }

void FTPProtocol::redirectToCurrentURL(FTPProtocol *this)
{
  unint64_t v2 = (void *)*((void *)this + 11);
  if (v2)
  {
    CFGetAllocator((char *)this - 16);
    unint64_t v2 = (void *)[v2 mutableCopy];
  }

  CFURLRequestSetURL(v2, *((const void **)this + 20));
  CFAllocatorRef v3 = CFGetAllocator((char *)this - 16);
  id v4 = CFURLResponseCreate((uint64_t)v3, *((const void **)this + 20), @"application/x-ftp-directory", -1LL, 0LL, 0);
  uint64_t v5 = *((void *)this + 12);
  if (v5)
  {
    uint64_t v6 = (*(uint64_t (**)(void))(*(void *)v5 + 16LL))(*((void *)this + 12));
    CFTypeID v7 = (void *)MEMORY[0x186E1578C](v6);
    (*(void (**)(void, void *, id))(**((void **)this + 12) + 40LL))(*((void *)this + 12), v2, v4);
    objc_autoreleasePoolPop(v7);
    (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  }

  if (v4) {
    CFRelease(v4);
  }
  if (v2) {
    CFRelease(v2);
  }
  *((_BYTE *)this + 112) &= ~4u;
}

void FTPProtocol::checkAndSendDidReceiveResponse(FTPProtocol *this)
{
  char v1 = *((_BYTE *)this + 112);
  if ((v1 & 2) == 0)
  {
    *((_BYTE *)this + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v1 | 2;
    if (!*((void *)this + 15))
    {
      uint64_t valuePtr = -1LL;
      if ((v1 & 8) != 0) {
        CFAllocatorRef v3 = (const __CFString *)CFRetain(&unk_18C5B1B58);
      }
      else {
        CFAllocatorRef v3 = 0LL;
      }
      id v4 = (__CFReadStream *)*((void *)this + 18);
      if (v4)
      {
        uint64_t v5 = (const __CFNumber *)CFReadStreamCopyProperty(v4, @"kCFStreamPropertyFTPResourceSize");
        if (v5)
        {
          uint64_t v6 = v5;
          CFNumberGetValue(v5, kCFNumberLongLongType, &valuePtr);
          CFRelease(v6);
        }
      }

      CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
      *((void *)this + 15) = CFURLResponseCreate((uint64_t)v7, *((const void **)this + 20), v3, valuePtr, 0LL, 0);
      if (v3) {
        CFRelease(v3);
      }
    }

    uint64_t v8 = *((void *)this + 12);
    if (v8)
    {
      uint64_t v9 = *((void *)this + 15);
      uint64_t v10 = (*(uint64_t (**)(void))(*(void *)v8 + 16LL))(*((void *)this + 12));
      uint64_t v11 = (void *)MEMORY[0x186E1578C](v10);
      (*(void (**)(void, uint64_t))(**((void **)this + 12) + 64LL))(*((void *)this + 12), v9);
      objc_autoreleasePoolPop(v11);
      (*(void (**)(uint64_t))(*(void *)v8 + 24LL))(v8);
    }
  }

void *URLProtocol::sendDidFail(URLProtocol *this, __CFError *a2)
{
  uint64_t result = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_17_6829, 1);
  if (result)
  {
    uint64_t v5 = (uint64_t)result;
    uint64_t result = (void *)(*(uint64_t (**)(void *, const char *, void))(*(void *)result + 16LL))( result,  "Response Error",  0LL);
    if ((_DWORD)result)
    {
      (*(void (**)(uint64_t, const char *, void))(*(void *)v5 + 48LL))( v5,  "Request",  *((void *)this + 11));
      (*(void (**)(uint64_t, const char *, __CFError *))(*(void *)v5 + 56LL))(v5, "Error", a2);
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  if (!a2)
  {
    CFLog();
    abort();
  }

  uint64_t v6 = *((void *)this + 12);
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(void))(*(void *)v6 + 16LL))(*((void *)this + 12));
    uint64_t v8 = (void *)MEMORY[0x186E1578C](v7);
    (*(void (**)(void, __CFError *))(**((void **)this + 12) + 96LL))(*((void *)this + 12), a2);
    objc_autoreleasePoolPop(v8);
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
  }

  uint64_t v9 = (void *)*((void *)this + 8);
  if (v9)
  {
    *((void *)this + _Block_object_dispose(va, 8) = 0LL;
    CFRetain((char *)this - 16);
    uint64_t v10 = MEMORY[0x1895F87A8];
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke_6834;
    v12[3] = &__block_descriptor_40_e5_v8__0l;
    v12[4] = this;
    (*(void (**)(void *))(*v9 + 40LL))(v9);
    uint64_t v11 = v9[9];
    v13[0] = v10;
    v13[1] = 3221225472LL;
    v13[2] = ___ZN9Throttler10invalidateEU13block_pointerFvvE_block_invoke;
    v13[3] = &unk_189C19878;
    v13[4] = v12;
    void v13[5] = v9;
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 96LL))(v11, v13);
    return (void *)(*(uint64_t (**)(void *))(*v9 + 48LL))(v9);
  }

  return result;
}

void ___ZN11URLProtocol19invalidateThrottlerEv_block_invoke_6834(uint64_t a1)
{
}

uint64_t ___ZN11URLProtocol11sendDidFailEP9__CFError_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  unint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRetain((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 231LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = "none";
  return result;
}

void FTPProtocol::_ftpReadStreamCB(FTPProtocol *this, __CFReadStream *a2, FTPProtocol *a3, void *a4)
{
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_6844()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(void *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182AD6370(_Unwind_Exception *a1)
{
}

BOOL DataProtocol::_canHandleRequest(DataProtocol *this, const _CFURLRequest *a2, const void *a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      int v8 = 136315138;
      uint64_t v9 = "_canHandleRequest";
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "%s(): called with a NULL request",  (uint8_t *)&v8,  0xCu);
    }

    return 0LL;
  }

  CFAllocatorRef v3 = *(const __CFURL **)(-[DataProtocol _inner](this, "_inner", a3) + 8);
  if (!v3) {
    return 0LL;
  }
  id v4 = CFURLCopyScheme(v3);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  BOOL v6 = CFStringCompare(v4, (CFStringRef)&unk_18C5B2A00, 1uLL) == kCFCompareEqualTo;
  CFRelease(v5);
  return v6;
}

CFTypeRef DataProtocol::_createCanonicalRequest( DataProtocol *this, CFTypeRef cf, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  if (cf) {
    return CFRetain(cf);
  }
  else {
    return 0LL;
  }
}

uint64_t DataProtocol::_requestsAreCacheEquivalent( DataProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0LL;
}

_OWORD *DataProtocol::_instantiateProtocol( DataProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  uint64_t Instance = (_OWORD *)_CFRuntimeCreateInstance();
  int v8 = Instance;
  if (Instance)
  {
    Instance[1] = 0u;
    int v8 = Instance + 1;
    Instance[6] = 0u;
    Instance[7] = 0u;
    Instance[4] = 0u;
    Instance[5] = 0u;
    Instance[2] = 0u;
    Instance[3] = 0u;
  }

  *((void *)v8 + 13) = 0LL;
  *(_OWORD *)((char *)v8 + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)((char *)v8 + 72) = 0u;
  *(_OWORD *)((char *)v8 + 56) = 0u;
  *(_OWORD *)((char *)v8 + 40) = 0u;
  *(_OWORD *)((char *)v8 + 24) = 0u;
  *(void *)int v8 = &off_189C0B910;
  *((void *)v8 + 1) = &unk_189C0BA10;
  *((void *)v8 + 2) = &unk_189C0BA30;
  URLProtocol::initialize((URLProtocol *)v8, a2, a3);
  return v8 - 1;
}

CFStringRef DataProtocol::copyDebugDesc(DataProtocol *this)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, @"<data URL instance at %p>", this);
}

void DataProtocol::_protocolInterface_startLoad(id *this, const _CFCachedURLResponse *a2)
{
  CFAllocatorRef v3 = (const void *)[this[11] cfURL];
  CFDictionaryRef properties = 0LL;
  CFDataRef resourceData = 0LL;
  id v4 = CFGetAllocator(this - 2);
  if (CFURLCreateDataAndPropertiesFromResource(v4, (CFURLRef)v3, &resourceData, &properties, 0LL, &errorCode))
  {
    int Value = (const __CFString *)CFDictionaryGetValue(properties, @"kCFDataURLMimeType");
    if (Value) {
      BOOL v6 = Value;
    }
    else {
      BOOL v6 = @"text/plain";
    }
    uint64_t v7 = (const __CFString *)CFDictionaryGetValue(properties, @"kCFDataURLTextEncodingName");
    CFIndex Length = CFDataGetLength(resourceData);
    CFAllocatorRef v9 = CFGetAllocator(this - 2);
    uint64_t v10 = (__CFError *)CFURLResponseCreate((uint64_t)v9, v3, v6, Length, v7, 2);
    if (v10)
    {
      CFCFStreamError Error = v10;
      id v12 = this[12];
      if (v12)
      {
        uint64_t v13 = (*(uint64_t (**)(id))(*(void *)v12 + 16LL))(this[12]);
        CFErrorRef v14 = (void *)MEMORY[0x186E1578C](v13);
        (*(void (**)(id, __CFError *))(*(void *)this[12] + 64LL))(this[12], CFError);
        objc_autoreleasePoolPop(v14);
        (*(void (**)(id))(*(void *)v12 + 24LL))(v12);
      }

      CFDataRef v15 = resourceData;
      if (resourceData)
      {
        CFIndex v16 = (Throttler *)this[8];
        if (v16)
        {
          CFIndex v17 = CFDataGetLength(resourceData);
          Throttler::noteOutstandingBytes(v16, v17);
        }
      }

      id v18 = this[12];
      if (v18)
      {
        uint64_t v19 = (*(uint64_t (**)(id))(*(void *)v18 + 16LL))(this[12]);
        uint64_t v20 = (void *)MEMORY[0x186E1578C](v19);
        (*(void (**)(id, CFDataRef, CFIndex))(*(void *)this[12] + 72LL))(this[12], v15, Length);
        objc_autoreleasePoolPop(v20);
        (*(void (**)(id))(*(void *)v18 + 24LL))(v18);
      }

      URLProtocol::sendDidFinishLoading((URLProtocol *)this);
    }

    else
    {
      uint64_t v28 = CFGetAllocator(this - 2);
      CFCFStreamError Error = __cfnCreateCFError(v28, @"kCFErrorDomainCFNetwork", -998LL, v29, v30, v31, v32, v33, 0LL);
      URLProtocol::sendDidFail((URLProtocol *)this, CFError);
      if (!CFError) {
        goto LABEL_18;
      }
    }

    CFRelease(CFError);
LABEL_18:
    CFRelease(properties);
    uint64_t v27 = resourceData;
    if (!resourceData) {
      return;
    }
    goto LABEL_19;
  }

  uint64_t v21 = CFGetAllocator(this - 2);
  uint64_t v27 = __cfnCreateCFError(v21, @"kCFErrorDomainCFNetwork", errorCode, v22, v23, v24, v25, v26, 0LL);
  URLProtocol::sendDidFail((URLProtocol *)this, v27);
  if (v27) {
LABEL_19:
  }
    CFRelease(v27);
}

void non-virtual thunk to'DataProtocol::~DataProtocol(DataProtocol *this)
{
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 8));
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 16));
}

{
  URLProtocol::~URLProtocol((URLProtocol *)((char *)this - 16));
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_6858()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(void *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182AD685C(_Unwind_Exception *a1)
{
}

BOOL FileURLProtocol::_canHandleRequest(FileURLProtocol *this, const _CFURLRequest *a2, const void *a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (!this)
  {
    if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
    {
      int v8 = 136315138;
      CFAllocatorRef v9 = "_canHandleRequest";
      _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "%s(): called with a NULL request",  (uint8_t *)&v8,  0xCu);
    }

    return 0LL;
  }

  CFAllocatorRef v3 = *(const __CFURL **)(-[FileURLProtocol _inner](this, "_inner", a3) + 8);
  if (!v3) {
    return 0LL;
  }
  id v4 = CFURLCopyScheme(v3);
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  BOOL v6 = CFStringCompare(v4, @"file", 1uLL) == kCFCompareEqualTo;
  CFRelease(v5);
  return v6;
}

CFTypeRef FileURLProtocol::_createCanonicalRequest( FileURLProtocol *this, const __CFAllocator *a2, const _CFURLRequest *a3, NSURLSessionTask *a4, const void *a5)
{
  BOOL v6 = *(const __CFURL **)(-[__CFAllocator _inner](a2, "_inner", a3, a4, a5) + 8);
  unsigned __int8 v12 = 0;
  uint64_t v7 = _createCanonicalURL(v6, 0LL, 0LL, &v12);
  if (v7)
  {
    int v8 = v7;
    if (v7 != v6)
    {
      CFAllocatorRef v9 = (void *)-[__CFAllocator mutableCopy](a2, "mutableCopy");
      if (v9)
      {
        uint64_t v10 = v9;
        CFURLRequestSetURL(v9, v8);
        CFRelease(v8);
        return v10;
      }
    }

    CFRelease(v8);
  }

  if (a2) {
    return CFRetain(a2);
  }
  return 0LL;
}

uint64_t FileURLProtocol::_requestsAreCacheEquivalent( FileURLProtocol *this, const _CFURLRequest *a2, const _CFURLRequest *a3, const void *a4)
{
  return 0LL;
}

uint64_t FileURLProtocol::_instantiateProtocol( FileURLProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3, URLProtocolClient *a4, const void *a5)
{
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = Instance;
  if (Instance)
  {
    *(_OWORD *)(Instance + CFRetain((char *)this - 16) = 0u;
    uint64_t v8 = Instance + 16;
    *(void *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v64 - 160) = 0LL;
    *(_OWORD *)(Instance + 12_Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(Instance + 144) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3 - 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 0u;
    *(_OWORD *)(Instance + 4_Block_object_dispose(va, 8) = 0u;
  }

  *(_OWORD *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 136) = 0u;
  *(_OWORD *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30 - 120) = 0u;
  *(_OWORD *)(v8 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30 - 104) = 0u;
  *(_OWORD *)(v8 + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 24) = 0u;
  *(void *)uint64_t v8 = &off_189C0BA90;
  *(void *)(v8 + _Block_object_dispose(va, 8) = &unk_189C0BB90;
  *(void *)(v8 + CFRetain((char *)this - 16) = &unk_189C0BBB0;
  URLProtocol::initialize((URLProtocol *)v8, a2, a3);
  return v8 - 16;
}

CFStringRef FileURLProtocol::copyDebugDesc(FileURLProtocol *this)
{
  unint64_t v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0LL, @"<File protocol instance %p>", this);
}

void FileURLProtocol::_protocolInterface_startLoad(FileURLProtocol *this, const _CFCachedURLResponse *a2)
{
  __darwin_ino64_t v2 = MEMORY[0x1895F8858](this);
  uint64_t v66 = *MEMORY[0x1895F89C0];
  CFAllocatorRef v3 = (const __CFURL *)[*(id *)(v2 + 88) cfURL];
  FilePathStorage<unsigned char>::FilePathStorage((uint64_t)&v63, v3, 0, 0, 0);
  *(void *)(v2 + 144) = _CFURLRequestCopyProtocolPropertyForKey( *(void **)(v2 + 88),  @"NSURLRequestFileProtocolExpectedDevice");
  if (!v63
    || stat(v64, &propertyValueTypeRefPtr)
    || (st_size_t size = propertyValueTypeRefPtr.st_size, propertyValueTypeRefPtr.st_size == -1))
  {
    CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)(v2 - 16));
    CFCFStreamError Error = __cfnCreateCFError(v9, @"kCFErrorDomainCFNetwork", -1100LL, v10, v11, v12, v13, v14, 0LL);
    URLProtocol::sendDidFail((URLProtocol *)v2, CFError);
    if (!CFError) {
      return;
    }
    goto LABEL_10;
  }

  uint64_t v5 = (const __CFURL *)-[__CFURL URLByResolvingSymlinksInPath](v3, "URLByResolvingSymlinksInPath");
  if (!CFURLCopyResourcePropertyForKey(v5, (CFStringRef)*MEMORY[0x189605478], &propertyValueTypeRefPtr, 0LL)
    || !*(void *)&propertyValueTypeRefPtr.st_dev
    || (BOOL v6 = UTTypeCopyPreferredTagWithClass( *(CFStringRef *)&propertyValueTypeRefPtr.st_dev,  (CFStringRef)*MEMORY[0x1896057A8]),  CFRelease(*(CFTypeRef *)&propertyValueTypeRefPtr.st_dev),  !v6))
  {
    uint64_t v7 = _CFURLCopyPathExtension_WorksWithMoreSchemes(v5);
    uint64_t v8 = v7;
    if (v7)
    {
      BOOL v6 = copyMIMETypeForExtension(v7);
      CFRelease(v8);
    }

    else
    {
      BOOL v6 = 0LL;
    }
  }

  CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)(v2 - 16));
  if (st_size) {
    uint64_t v17 = st_size;
  }
  else {
    uint64_t v17 = -1LL;
  }
  *(void *)(v2 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v30 - 120) = CFURLResponseCreate((uint64_t)v16, v3, v6, v17, 0LL, 2);
  if (v6) {
    CFRelease(v6);
  }
  if (st_size < 0x4000 && st_size)
  {
    if (!v63) {
      goto LABEL_58;
    }
    int v18 = open(v64, 0);
    if ((v18 & 0x80000000) == 0 || (uint64_t v19 = __error(), v18 != -1))
    {
      if (!*(void *)(v2 + 144)
        || !fstat(v18, &propertyValueTypeRefPtr)
        && (uint64_t v34 = *(const __CFNumber **)(v2 + 144)) != 0LL
        && CFNumberGetValue(v34, kCFNumberIntType, &valuePtr)
        && valuePtr == propertyValueTypeRefPtr.st_dev)
      {
        if ((*(_BYTE *)(v2 + 112) & 2) == 0)
        {
          *(_BYTE *)(v2 + 112) |= 2u;
          uint64_t v35 = *(void *)(v2 + 96);
          if (v35)
          {
            uint64_t v36 = *(void *)(v2 + 120);
            uint64_t v37 = (*(uint64_t (**)(void))(*(void *)v35 + 16LL))(*(void *)(v2 + 96));
            unint64_t v38 = (void *)MEMORY[0x186E1578C](v37);
            (*(void (**)(void, uint64_t))(**(void **)(v2 + 96) + 64LL))(*(void *)(v2 + 96), v36);
            objc_autoreleasePoolPop(v38);
            (*(void (**)(uint64_t))(*(void *)v35 + 24LL))(v35);
          }
        }

        ssize_t v39 = read(v18, &propertyValueTypeRefPtr, 0x4000uLL);
        if (v39 == -1)
        {
          int v55 = *__error();
          switch(v55)
          {
            case 2:
              CFIndex v20 = -1100LL;
              break;
            case 13:
              CFIndex v20 = -1102LL;
              break;
            case 21:
              CFIndex v20 = -1101LL;
              break;
            default:
              CFIndex v20 = v55;
              break;
          }
        }

        else
        {
          unint64_t v40 = CFGetAllocator((CFTypeRef)(v2 - 16));
          char v41 = CFDataCreate(v40, (const UInt8 *)&propertyValueTypeRefPtr, v39);
          unint64_t v42 = v41;
          if (v41)
          {
            uint64_t v43 = *(Throttler **)(v2 + 64);
            if (v43)
            {
              CFIndex Length = CFDataGetLength(v41);
              Throttler::noteOutstandingBytes(v43, Length);
            }
          }

          uint64_t v45 = *(void *)(v2 + 96);
          if (v45)
          {
            uint64_t v46 = (*(uint64_t (**)(void))(*(void *)v45 + 16LL))(*(void *)(v2 + 96));
            BOOL v47 = (void *)MEMORY[0x186E1578C](v46);
            (*(void (**)(void, const __CFData *, ssize_t))(**(void **)(v2 + 96) + 72LL))( *(void *)(v2 + 96),  v42,  v39);
            objc_autoreleasePoolPop(v47);
            (*(void (**)(uint64_t))(*(void *)v45 + 24LL))(v45);
          }

          if (v42) {
            CFRelease(v42);
          }
          URLProtocol::sendDidFinishLoading((URLProtocol *)v2);
          CFIndex v20 = 0LL;
        }
      }

      else
      {
        CFIndex v20 = -1104LL;
      }

      close(v18);
LABEL_52:
      if (!v20) {
        return;
      }
      goto LABEL_59;
    }

    CFIndex v20 = *v19;
    switch((_DWORD)v20)
    {
      case 2:
LABEL_58:
        CFIndex v20 = -1100LL;
        break;
      case 0xD:
        CFIndex v20 = -1102LL;
        break;
      case 0x15:
        CFIndex v20 = -1101LL;
        break;
      default:
        goto LABEL_52;
    }

void FileURLProtocol::_protocolInterface_cancelLoad(FileURLProtocol *this)
{
  if ((*((_BYTE *)this + 112) & 4) == 0)
  {
    *((_BYTE *)this + 112) |= 4u;
    if (*((void *)this + 16)) {
      FileURLProtocol::destroyReadStream(this);
    }
  }

uint64_t FileURLProtocol::_protocolInterface_haltLoad(uint64_t this)
{
  *(_BYTE *)(this + 112) |= 1u;
  return this;
}

void FileURLProtocol::_protocolInterface_resumeLoad(FileURLProtocol *this)
{
  *((_BYTE *)this + 112) &= ~1u;
  if (*((void *)this + 16))
  {
    if (*((void *)this + 17))
    {
      FileURLProtocol::fileStreamEvent(this);
      *((void *)this + 17) = 0LL;
    }
  }

void FileURLProtocol::subclassUpdateScheduling( FileURLProtocol *this, CoreSchedulingSet *a2, CoreSchedulingSet *a3)
{
  if ((*((_BYTE *)this + 112) & 1) != 0)
  {
    id v4 = (__CFReadStream *)*((void *)this + 16);
    if (v4)
    {
      CoreSchedulingSet::unscheduleStream(a2, v4);
      CoreSchedulingSet::scheduleStream(a3, *((__CFReadStream **)this + 16));
    }
  }

uint64_t FileURLProtocol::needsThrottler(FileURLProtocol *this)
{
  return 1LL;
}

void non-virtual thunk to'FileURLProtocol::~FileURLProtocol(FileURLProtocol *this)
{
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 8));
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 16));
}

{
  FileURLProtocol::~FileURLProtocol((FileURLProtocol *)((char *)this - 16));
}

void FileURLProtocol::~FileURLProtocol(FileURLProtocol *this)
{
  *(void *)this = &off_189C0BA90;
  *((void *)this + 1) = &unk_189C0BB90;
  *((void *)this + 2) = &unk_189C0BBB0;
  __darwin_ino64_t v2 = (const void *)*((void *)this + 15);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v3 = (const void *)*((void *)this + 18);
  if (v3) {
    CFRelease(v3);
  }
  FileURLProtocol::destroyReadStream(this);
  URLProtocol::~URLProtocol((URLProtocol *)this);
}

void sub_182AD7234(_Unwind_Exception *a1)
{
}

void FileURLProtocol::destroyReadStream(FileURLProtocol *this)
{
  char v1 = (__CFReadStream *)*((void *)this + 16);
  if (v1)
  {
    *((void *)this + CFRetain((char *)this - 16) = 0LL;
    __darwin_ino64_t v2 = (dispatch_queue_s *)MEMORY[0x186E12D50](v1);
    MEMORY[0x186E12E04](v1, 0LL);
    CFReadStreamSetClient(v1, 0LL, 0LL, 0LL);
    CFReadStreamClose(v1);
    if (v2)
    {
      dispatch_async_f(v2, v1, (dispatch_function_t)_release_ReadStream);
      dispatch_release(v2);
    }

    else
    {
      CFRelease(v1);
    }
  }

void FileURLProtocol::fileStreamEvent(FileURLProtocol *this)
{
  uint64_t v1 = MEMORY[0x1895F8858](this);
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if ((v2 > 0x10 || ((1LL << v2) & 0x10106) == 0) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    LOWORD(buffer[0].st_dev) = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "fileReadStreamCB(): unrecognized event",  (uint8_t *)buffer,  2u);
  }

  char v5 = *(_BYTE *)(v4 + 112);
  if ((v5 & 1) != 0)
  {
    *(void *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1 + 136) = v3;
  }

  else if (v3 > 7)
  {
    if (v3 == 8)
    {
      CFStreamError Error = CFReadStreamGetError((CFReadStreamRef)*(void *)(v4 + 128));
      *(void *)&buffer[0].st_dev = Error.domain;
      buffer[0].st_ino = *(void *)&Error.error;
      uint64_t v34 = CFGetAllocator((CFTypeRef)(v4 - 16));
      CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v34, &buffer[0].st_dev);
      URLProtocol::sendDidFail((URLProtocol *)v4, CFErrorWithStreamError);
      if (CFErrorWithStreamError) {
LABEL_17:
      }
        CFRelease(CFErrorWithStreamError);
    }

    else if (v3 == 16)
    {
      if ((*(_BYTE *)(v4 + 112) & 2) == 0)
      {
        *(_BYTE *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v5 | 2;
        uint64_t v19 = *(void *)(v4 + 96);
        if (v19)
        {
          uint64_t v20 = *(void *)(v4 + 120);
          uint64_t v21 = (*(uint64_t (**)(void))(*(void *)v19 + 16LL))(*(void *)(v4 + 96));
          uint64_t v22 = (void *)MEMORY[0x186E1578C](v21);
          (*(void (**)(void, uint64_t))(**(void **)(v4 + 96) + 64LL))(*(void *)(v4 + 96), v20);
          objc_autoreleasePoolPop(v22);
          (*(void (**)(uint64_t))(*(void *)v19 + 24LL))(v19);
        }
      }

      URLProtocol::sendDidFinishLoading((URLProtocol *)v4);
    }
  }

  else if (v3 == 1)
  {
    if (*(void *)(v4 + 144))
    {
      uint64_t v23 = (const __CFData *)CFReadStreamCopyProperty( *(CFReadStreamRef *)(v4 + 128),  (CFStreamPropertyKey)*MEMORY[0x189604B18]);
      uint64_t v24 = v23;
      if (v23)
      {
        BytePtr = (int *)CFDataGetBytePtr(v23);
        if (!fstat(*BytePtr, buffer)
          && (ssize_t v39 = *(const __CFNumber **)(v4 + 144)) != 0LL
          && CFNumberGetValue(v39, kCFNumberIntType, &valuePtr))
        {
          BOOL v40 = valuePtr == buffer[0].st_dev;
          CFRelease(v24);
          if (v40)
          {
            FileURLProtocol::checkAndSendDidReceiveResponse(v4);
            return;
          }
        }

        else
        {
          CFRelease(v24);
        }
      }

      FileURLProtocol::destroyReadStream((FileURLProtocol *)v4);
      uint64_t v26 = CFGetAllocator((CFTypeRef)(v4 - 16));
      CFCFStreamError Error = __cfnCreateCFError(v26, @"kCFErrorDomainCFNetwork", -1104LL, v27, v28, v29, v30, v31, 0LL);
      URLProtocol::sendDidFail((URLProtocol *)v4, CFError);
      if (CFError) {
        CFRelease(CFError);
      }
    }

    else if ((*(_BYTE *)(v4 + 112) & 2) == 0)
    {
      *(_BYTE *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v5 | 2;
      uint64_t v35 = *(void *)(v4 + 96);
      if (v35)
      {
        uint64_t v36 = *(void *)(v4 + 120);
        uint64_t v37 = (*(uint64_t (**)(void))(*(void *)v35 + 16LL))(*(void *)(v4 + 96));
        unint64_t v38 = (void *)MEMORY[0x186E1578C](v37);
        (*(void (**)(void, uint64_t))(**(void **)(v4 + 96) + 64LL))(*(void *)(v4 + 96), v36);
        objc_autoreleasePoolPop(v38);
        (*(void (**)(uint64_t))(*(void *)v35 + 24LL))(v35);
      }
    }
  }

  else if (v3 == 2)
  {
    if ((*(_BYTE *)(v4 + 112) & 2) == 0)
    {
      *(_BYTE *)(v4 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v27 - 112) = v5 | 2;
      uint64_t v6 = *(void *)(v4 + 96);
      if (v6)
      {
        uint64_t v7 = *(void *)(v4 + 120);
        uint64_t v8 = (*(uint64_t (**)(void))(*(void *)v6 + 16LL))(*(void *)(v4 + 96));
        CFAllocatorRef v9 = (void *)MEMORY[0x186E1578C](v8);
        (*(void (**)(void, uint64_t))(**(void **)(v4 + 96) + 64LL))(*(void *)(v4 + 96), v7);
        objc_autoreleasePoolPop(v9);
        (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
      }
    }

    uint64_t v10 = CFReadStreamRead(*(CFReadStreamRef *)(v4 + 128), (UInt8 *)buffer, 0x10000LL);
    if (v10 >= 1)
    {
      uint64_t v11 = CFGetAllocator((CFTypeRef)(v4 - 16));
      uint64_t v12 = CFDataCreate(v11, (const UInt8 *)buffer, v10);
      CFErrorWithStreamCFStreamError Error = v12;
      if (v12)
      {
        uint64_t v14 = *(Throttler **)(v4 + 64);
        if (v14)
        {
          CFIndex Length = CFDataGetLength(v12);
          Throttler::noteOutstandingBytes(v14, Length);
        }
      }

      uint64_t v16 = *(void *)(v4 + 96);
      if (v16)
      {
        uint64_t v17 = (*(uint64_t (**)(void))(*(void *)v16 + 16LL))(*(void *)(v4 + 96));
        int v18 = (void *)MEMORY[0x186E1578C](v17);
        (*(void (**)(void, __CFError *, uint64_t))(**(void **)(v4 + 96) + 72LL))( *(void *)(v4 + 96),  CFErrorWithStreamError,  v10);
        objc_autoreleasePoolPop(v18);
        (*(void (**)(uint64_t))(*(void *)v16 + 24LL))(v16);
      }

      if (CFErrorWithStreamError) {
        goto LABEL_17;
      }
    }
  }

uint64_t FileURLProtocol::checkAndSendDidReceiveResponse(uint64_t this)
{
  if ((*(_BYTE *)(this + 112) & 2) == 0)
  {
    uint64_t v1 = this;
    *(_BYTE *)(this + 112) |= 2u;
    uint64_t v2 = *(void *)(this + 96);
    if (v2)
    {
      uint64_t v3 = *(void *)(this + 120);
      uint64_t v4 = (*(uint64_t (**)(void))(*(void *)v2 + 16LL))(*(void *)(this + 96));
      char v5 = (void *)MEMORY[0x186E1578C](v4);
      (*(void (**)(void, uint64_t))(**(void **)(v1 + 96) + 64LL))(*(void *)(v1 + 96), v3);
      objc_autoreleasePoolPop(v5);
      return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
    }
  }

  return this;
}

void FileURLProtocol::_fileReadStreamCB( FileURLProtocol *this, __CFReadStream *a2, FileURLProtocol *a3, void *a4)
{
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_6869()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(void *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182AD77BC(_Unwind_Exception *a1)
{
}

void sub_182AD78F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182AD7B38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_182AD7C60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182AD80E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182AD84D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_182AD8768( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_182AD8854( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_182AD88DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_182AD8980(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182AD8C08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t HTTPProtocol::_requestsAreCacheEquivalent( HTTPProtocol *this, HTTPProtocol *a2, const _CFURLRequest *a3, const void *a4)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if ((!this || !a2) && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "httpRequestAreCacheEquivalent(): called with a NULL argument",  buf,  2u);
  }

  if (this == a2) {
    return 1LL;
  }
  uint64_t v6 = *(const __CFURL **)(-[HTTPProtocol _inner](this, "_inner", a3, a4) + 8);
  if (v6)
  {
    unsigned __int8 v48 = 0;
    uint64_t v7 = _createCanonicalURL(v6, 1LL, 0LL, &v48);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  CFAllocatorRef v9 = *(const __CFURL **)(-[HTTPProtocol _inner](a2, "_inner") + 8);
  if (v9)
  {
    unsigned __int8 v49 = 0;
    uint64_t v10 = _createCanonicalURL(v9, 1LL, 0LL, &v49);
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  int v11 = CFEqual(v7, v10);
  if (v7) {
    CFRelease(v7);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (!v11) {
    return 0LL;
  }
  unint64_t v12 = (unint64_t)CFURLRequestCopyHTTPRequestMethod(this);
  unint64_t v13 = (unint64_t)CFURLRequestCopyHTTPRequestMethod(a2);
  uint64_t v14 = (const void *)v13;
  if (v12 && v13)
  {
    BOOL v15 = CFEqual((CFTypeRef)v12, (CFTypeRef)v13) != 0;
  }

  else
  {
    BOOL v15 = (v12 | v13) == 0;
    if (!v12) {
      goto LABEL_23;
    }
  }

  CFRelease((CFTypeRef)v12);
LABEL_23:
  if (v14) {
    CFRelease(v14);
  }
  if (!v15) {
    return 0LL;
  }
  uint64_t v16 = _CFURLRequestCopyProtocolPropertyForKey(this, @"__SKIP_USER_AGENT_IN_REQUEST_EQUIVALENCY_CHECK__");
  uint64_t v17 = v16;
  if (!v16 || !CFBooleanGetValue(v16))
  {
    int v18 = *(HTTPMessage **)(-[HTTPProtocol _inner](this, "_inner") + 56);
    if (v18) {
      CFStringRef v19 = HTTPMessage::copyHeaderFieldValue(v18, 0x14E15421u);
    }
    else {
      CFStringRef v19 = 0LL;
    }
    uint64_t v20 = *(HTTPMessage **)(-[HTTPProtocol _inner](a2, "_inner") + 56);
    if (v20)
    {
      CFStringRef v21 = HTTPMessage::copyHeaderFieldValue(v20, 0x14E15421u);
      CFStringRef v22 = v21;
      BOOL v23 = v19 != 0LL;
      BOOL v24 = v21 != 0LL;
      if (v19 && v21)
      {
        int v25 = CFEqual(v19, v21) != 0;
LABEL_38:
        CFRelease(v19);
LABEL_39:
        if (v22) {
          CFRelease(v22);
        }
        if (!v25) {
          goto LABEL_73;
        }
        goto LABEL_42;
      }
    }

    else
    {
      BOOL v24 = 0;
      CFStringRef v22 = 0LL;
      BOOL v23 = v19 != 0LL;
    }

    int v25 = !v23 && !v24;
    if (!v19) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

void sub_182AD909C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef HTTPProtocol::copyDebugDesc(HTTPProtocol *this)
{
  uint64_t v2 = CFGetAllocator((char *)this - 16);
  return CFStringCreateWithFormat(v2, 0LL, @"<HTTP protocol instance %p>", this);
}

CFTypeRef HTTPProtocol::copyDebugSummary(HTTPProtocol *this)
{
  uint64_t v1 = (void *)*((void *)this + 11);
  if (!v1) {
    return CFRetain(@"nullptr request");
  }
  uint64_t v2 = [v1 _inner];
  return (CFTypeRef)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
}

uint64_t HTTPProtocol::initialize(HTTPProtocol *this, NSURLSessionTask *a2, URLProtocolClient *a3)
{
  return (*(uint64_t (**)(HTTPProtocol *, NSURLSessionTask *, URLProtocolClient *, void))(*(void *)this + 240LL))( this,  a2,  a3,  0LL);
}

void HTTPProtocol::_protocolInterface_cancelLoad(HTTPProtocol *this)
{
  uint64_t v2 = *((unsigned int *)this + 48);
  unint64_t v3 = v2 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
  if ((v2 & 0x100000) == 0)
  {
    *((_WORD *)this + 9_Block_object_dispose(va, 8) = WORD2(v3);
    *((_DWORD *)this + 4_Block_object_dispose(va, 8) = v2 | 0x100000;
    if ((v3 & 0x80) == 0)
    {
      uint64_t v4 = *((void *)this + 34);
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 128LL))(v4);
      }
    }

    HTTPProtocol::cleanupStreams(this);
  }

  char v5 = (void (**)(void, void, void))*((void *)this + 54);
  if (v5)
  {
    *((void *)this + 54) = 0LL;
    v5[2](v5, 0LL, 1LL);
    _Block_release(v5);
  }

  uint64_t v6 = (void (**)(void, void, void))*((void *)this + 52);
  if (v6)
  {
    *((void *)this + 52) = 0LL;
    v6[2](v6, 0LL, 1LL);
    _Block_release(v6);
  }

void HTTPProtocol::_protocolInterface_setIsDownload(HTTPProtocol *this, int a2)
{
  if (!*((void *)this + 34)) {
    return;
  }
  if (!*((void *)this + 10) || (uint64_t v4 = (const void *)*((void *)this + 94)) == 0LL)
  {
    uint64_t v6 = 0LL;
    goto LABEL_11;
  }

  char v5 = (const __CFDictionary *)CFRetain(v4);
  uint64_t v6 = v5;
  if (!v5)
  {
LABEL_11:
    char v7 = 1;
    goto LABEL_12;
  }

  if (CFDictionaryGetCount(v5)
    && (CFDictionaryContainsKey(v6, &unk_18C5AC8E0)
     || CFDictionaryContainsKey(v6, &unk_18C5AC918)
     || CFDictionaryContainsKey(v6, &unk_18C5AC598)))
  {
LABEL_18:
    CFRelease(v6);
    return;
  }

  char v7 = 0;
LABEL_12:
  int v9 = *((_DWORD *)this + 48);
  uint64_t v8 = (char *)this + 192;
  __int16 v10 = *((_WORD *)v8 + 2);
  *(_DWORD *)uint64_t v8 = v9 & 0xFFFDFFFF | ((a2 != 0) << 17);
  *((_WORD *)v8 + 2) = v10;
  int v11 = (void *)MEMORY[0x189604DE8];
  if (!a2) {
    int v11 = (void *)MEMORY[0x189604DE0];
  }
  (*(void (**)(void, uint64_t, void))(**((void **)v8 + 10) + 40LL))(*((void *)v8 + 10), 16LL, *v11);
  uint64_t v12 = *((void *)v8 + 10);
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 128LL))(v12);
  }
  if ((v7 & 1) == 0) {
    goto LABEL_18;
  }
}

void HTTPProtocol::setConnectionPoolPriority(HTTPProtocol *this, CFTypeRef cf)
{
  uint64_t v4 = (const void *)*((void *)this + 73);
  *((void *)this + 73) = 0LL;
  if (v4) {
    CFRelease(v4);
  }
  if (cf) {
    CFTypeRef v5 = CFRetain(cf);
  }
  else {
    CFTypeRef v5 = 0LL;
  }
  *((void *)this + 73) = v5;
  uint64_t v6 = *((void *)this + 34);
  if (v6)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 40LL))(v6, 27LL);
  }

  else if (*((void *)this + 10))
  {
    uint64_t v7 = *((void *)this + 93);
    if (v7)
    {
      uint64_t v8 = *((void *)this + 35);
      if (v8)
      {
        uint64_t v9 = *(void *)(v7 + 168);
        if (v9)
        {
          __int16 v10 = (const void *)*((void *)this + 3);
          uint64_t v13 = 0LL;
          uint64_t v14 = &v13;
          uint64_t v15 = 0x2020000000LL;
          uint64_t v16 = 0LL;
          v12[0] = MEMORY[0x1895F87A8];
          v12[1] = 3221225472LL;
          v12[2] = ___ZN12XTubeManager25getPendingTubeForProtocolEP25MetaConnectionCacheClientPK22HTTPConnectionCacheKeyPK17CoreSchedulingSet_block_invoke;
          v12[3] = &unk_189C0AD80;
          v12[4] = &v13;
          void v12[5] = (char *)this + 176;
          v12[6] = v8;
          XTubeManager::withTubeManager(v9, v10, (uint64_t)v12);
          uint64_t v11 = v14[3];
          _Block_object_dispose(&v13, 8);
          if (v11) {
            (*(void (**)(uint64_t, uint64_t, void))(*(void *)v11 + 56LL))( v11,  0x18C5AC218LL,  *((void *)this + 73));
          }
        }
      }
    }
  }

void sub_182AD94BC(_Unwind_Exception *a1)
{
}

uint64_t HTTPProtocol::expectedProgressTargetChanged(HTTPProtocol *this)
{
  uint64_t v2 = *((void *)this + 34);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v2 + 40LL))(v2, 7LL, *MEMORY[0x189604DE8]);
  }
  uint64_t result = *((void *)this + 111);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)result + 56LL))( result,  0x18C5AB840LL,  *MEMORY[0x189604DE8]);
  }
  return result;
}

uint64_t HTTPProtocol::attemptRedirection(HTTPProtocol *this, __CFHTTPMessage *a2)
{
  CFURLRef relativeURL = 0LL;
  if (a2)
  {
    if (*((_BYTE *)a2 + 40)) {
      uint64_t v6 = (__CFHTTPMessage *)((char *)a2 + 16);
    }
    else {
      uint64_t v6 = 0LL;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  HeaderFieldint Value = HTTPMessage::copyLastHeaderFieldValue(v6, 0x13011336u);
  if (!HeaderFieldValue)
  {
LABEL_18:
    int v15 = *((_DWORD *)this + 48);
    uint64_t v14 = (char *)this + 192;
    __int16 v16 = *((_WORD *)v14 + 2);
    *(_DWORD *)uint64_t v14 = v15 & 0xFFFFFFFB;
    *((_WORD *)v14 + 2) = v16;
    return 1LL;
  }

  uint64_t v8 = HeaderFieldValue;
  if (!CFStringGetLength(HeaderFieldValue))
  {
    CFRelease(v8);
    goto LABEL_18;
  }

  uint64_t v9 = CFGetAllocator((char *)this - 16);
  __int16 v10 = CFURLCreateStringByAddingPercentEscapes(v9, v8, @"%#?:;/@=&[]", 0LL, 0x201u);
  CFRelease(v8);
  if (!v10) {
    goto LABEL_31;
  }
  int v11 = dyld_program_sdk_at_least();
  uint64_t v12 = (void *)*((void *)this + 10);
  uint64_t v13 = v11 ? [v12 currentRequest] : objc_msgSend(v12, "originalRequest");
  uint64_t v17 = (NSURLRequest *)v13;
  int v18 = CFGetAllocator((char *)this - 16);
  CFStringRef v19 = CFURLCreateWithString(v18, v10, *(CFURLRef *)([*((id *)this + 11) _inner] + 8));
  if (v19)
  {
    uint64_t v20 = v19;
    CFURLRef relativeURL = CFURLCopyAbsoluteURL(v19);
    _ApplyOriginalComponents(v17, (CFTypeRef *)&relativeURL);
    CFRelease(v20);
  }

  else
  {
    CFIndex Length = CFStringGetLength(v10);
    CFStringRef v22 = (UInt8 *)malloc(Length + 1);
    CFStringEncoding v23 = 513;
    if (CFStringGetCString(v10, (char *)v22, Length + 1, 0x201u)
      || (CFStringEncoding v23 = 134217984, CFStringGetCString(v10, (char *)v22, Length + 1, 0x8000100u)))
    {
      BOOL v24 = *(const __CFURL **)([*((id *)this + 11) _inner] + 8);
      int v25 = CFGetAllocator((char *)this - 16);
      CFURLRef relativeURL = CFURLCreateAbsoluteURLWithBytes(v25, v22, Length, v23, v24, 0);
      _ApplyOriginalComponents(v17, (CFTypeRef *)&relativeURL);
    }

    free(v22);
  }

  CFRelease(v10);
  CFURLRef v26 = relativeURL;
  if (!relativeURL)
  {
LABEL_31:
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC0ELL);
    HTTPProtocol::destroyReadStream(this);
    return 0LL;
  }

  CFStringRef v27 = CFURLCopyAbsoluteURL(relativeURL);
  CFStringRef v28 = CFURLCopyScheme(v27);
  int v29 = v28;
  if (v28 && CFStringCompare(v28, @"file", 1uLL) == kCFCompareEqualTo)
  {
    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFBB2LL);
    BOOL v39 = 0;
  }

  else
  {
    CFGetAllocator((char *)this - 16);
    uint64_t v30 = (void *)[*((id *)this + 11) mutableCopy];
    CFURLRequestSetURL(v30, v27);
    CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(a2);
    if (ResponseStatusCode == 303
      || (unint64_t)(ResponseStatusCode - 301) <= 1
      && (CFHashCode v32 = (const __CFString *)CFURLRequestCopyHTTPRequestMethod(v30), (v33 = v32) != 0LL)
      && (CFComparisonResult v34 = CFStringCompare(v32, @"POST", 1uLL), CFRelease(v33), v34 == kCFCompareEqualTo))
    {
      CFURLRequestSetHTTPRequestMethod(v30, @"GET");
      CFURLRequestSetHTTPRequestBody(v30, 0LL);
      URLRequest::_setHTTPBodyParts((URLRequest *)[v30 _inner], 0, 0);
      CFURLRequestSetHTTPRequestBodyStream(v30, 0LL);
      CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_18C5AEEB8, 0LL);
      CFURLRequestSetHTTPHeaderFieldValue(v30, @"Content-Type", 0LL);
    }

    if (!haveTheSameOrigin(*(NSURL **)([*((id *)this + 11) _inner] + 8), (NSURL *)v27)) {
      CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_18C5AF318, 0LL);
    }
    CFURLRequestSetHTTPHeaderFieldValue(v30, (const __CFString *)&unk_18C5AED68, 0LL);
    CFURLRequestSetHTTPHeaderFieldValue(v30, @"Proxy-Authorization", 0LL);
    uint64_t v35 = *(void *)([*((id *)this + 11) _inner] + 56);
    if (v35 && *(_BYTE *)(v35 + 216))
    {
      uint64_t v36 = *(const __CFString **)(v35 + 152);
      char v38 = v36
         && (CFStringCompare(v36, (CFStringRef)&gConstantCFStringValueTable[2604], 0LL) == kCFCompareEqualTo
          || ((uint64_t v37 = *(const __CFString **)(v35 + 152)) != 0LL
           || os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT)
           && (*(_WORD *)__int128 buf = 0,
               _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "these should always be initialized now",  buf,  2u),  (uint64_t v37 = *(const __CFString **)(v35 + 152)) != 0LL))
          && CFStringCompare(v37, (CFStringRef)&gConstantCFStringValueTable[2611], 0LL) == kCFCompareEqualTo)
         || *(_BYTE *)(v35 + 218) != 0;
    }

    else
    {
      char v38 = 0;
    }

    CFURLRequestSetShouldPipelineHTTP(v30, v38, 1);
    uint64_t v40 = *(void *)([*((id *)this + 11) _inner] + 88);
    *(void *)([v30 _inner] + 8_Block_object_dispose((const void *)(v1 - 48), 8) = v40;
    uint64_t v41 = *((void *)this + 10);
    if (v41)
    {
      BOOL v42 = (const void *)[*((id *)this + 10) _copyHSTSPolicy];
      uint64_t v43 = [v30 _inner];
      if (v42) {
        CFTypeRef v44 = CFRetain(v42);
      }
      else {
        CFTypeRef v44 = 0LL;
      }
      uint64_t v45 = *(const void **)(v43 + 208);
      *(void *)(v43 + 20_Block_object_dispose((const void *)(v1 - 48), 8) = v44;
      if (v45) {
        CFRelease(v45);
      }
      if (v42) {
        CFRelease(v42);
      }
    }

    HTTPProtocol::updateForHeader(this, a2);
    uint64_t v46 = [v30 _inner];
    *(_WORD *)(v46 + 64) &= ~2u;
    id v47 =  -[NSURLRequest _initWithCFURLRequest:]( objc_alloc(&OBJC_CLASS___NSURLRequest),  "_initWithCFURLRequest:",  v30);
    unsigned __int8 v48 = -[__NSURLSessionLocal _protocolClassForRequest:](*((void *)this + 93), (uint64_t)v47);
    if (v41 && v48) {
      id v47 = (id)[v48 canonicalRequestForRequest:v47 task:v41];
    }
    uint64_t v49 = *((void *)this + 12);
    if (v49)
    {
      uint64_t v50 = *((void *)this + 26);
      uint64_t v51 = (*(uint64_t (**)(void))(*(void *)v49 + 16LL))(*((void *)this + 12));
      uint64_t v52 = (void *)MEMORY[0x186E1578C](v51);
      (*(void (**)(void, id, uint64_t))(**((void **)this + 12) + 40LL))(*((void *)this + 12), v47, v50);
      objc_autoreleasePoolPop(v52);
      (*(void (**)(uint64_t))(*(void *)v49 + 24LL))(v49);
    }

    __int16 v53 = *((_WORD *)this + 98);
    *((_DWORD *)this + 4_Block_object_dispose((const void *)(v1 - 48), 8) = *((_DWORD *)this + 48);
    *((_WORD *)this + 9_Block_object_dispose((const void *)(v1 - 48), 8) = v53 | 0x10;
    BOOL v39 = *((void *)this + 34) != 0LL;
    if (v30) {
      CFRelease(v30);
    }
  }

  if (v27) {
    CFRelease(v27);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v39)
  {
    unint64_t v54 = (void *)*((void *)this + 11);
    if (v54)
    {
      int v55 = (const __CFBoolean *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 34) + 32LL))( *((void *)this + 34),  32LL);
      if (v55)
      {
        unint64_t v56 = v55;
        if (!CFBooleanGetValue(v55))
        {
          [v54 _inner];
          __CFNReportRedirectSymptom(v57);
        }

        CFRelease(v56);
      }

      else
      {
        [v54 _inner];
        __CFNReportRedirectSymptom(v58);
      }
    }

    uint64_t v4 = 1LL;
  }

  else
  {
    HTTPProtocol::destroyReadStream(this);
    uint64_t v4 = 0LL;
  }

  CFRelease(v26);
  return v4;
}

void sub_182AD9C58(_Unwind_Exception *a1)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(a1);
}

void HTTPProtocol::generateProxyAuthentication( std::__shared_weak_count_vtbl *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  if (a1) {
    CFRetain(&a1[-1].__get_deleter);
  }
  uint64_t v45 = a1;
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x20uLL);
  v8->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE68;
  v8->__shared_weak_owners_ = 0LL;
  v8[1].__vftable = a1;
  uint64_t v46 = v8;
  get_deleter = a1->__get_deleter;
  v37[0] = MEMORY[0x1895F87A8];
  v37[1] = 3321888768LL;
  v37[2] = ___ZN12HTTPProtocol27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke;
  v37[3] = &__block_descriptor_104_e8_40c41_ZTSKNSt3__110shared_ptrI12NetworkProxyEE56c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE72c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE88c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE_e5_v8__0l;
  uint64_t v12 = *a2;
  int v11 = (std::__shared_weak_count *)a2[1];
  v37[4] = a1;
  void v37[5] = v12;
  char v38 = v11;
  if (v11)
  {
    uint64_t v13 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  int v15 = (std::__shared_weak_count *)a4[1];
  uint64_t v39 = *a4;
  uint64_t v40 = v15;
  if (v15)
  {
    __int16 v16 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  uint64_t v41 = a1;
  BOOL v42 = v8;
  do
    unint64_t v18 = __ldxr(p_shared_owners);
  while (__stxr(v18 + 1, p_shared_owners));
  CFStringRef v19 = (std::__shared_weak_count *)a3[1];
  uint64_t v43 = *a3;
  CFTypeRef v44 = v19;
  if (v19)
  {
    uint64_t v20 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }

  (*(void (**)(const void *(__cdecl *)(const std::__shared_weak_count *__hidden, const std::type_info *), void *))(*(void *)get_deleter + 96LL))( get_deleter,  v37);
  CFStringRef v22 = v44;
  if (v44)
  {
    CFStringEncoding v23 = (unint64_t *)&v44->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  int v25 = v42;
  if (v42)
  {
    CFURLRef v26 = (unint64_t *)&v42->__shared_owners_;
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  CFStringRef v28 = v40;
  if (v40)
  {
    int v29 = (unint64_t *)&v40->__shared_owners_;
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  uint64_t v31 = v38;
  if (v38)
  {
    CFHashCode v32 = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

  CFComparisonResult v34 = v46;
  if (v46)
  {
    uint64_t v35 = (unint64_t *)&v46->__shared_owners_;
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

void sub_182AD9F08(_Unwind_Exception *a1)
{
}

void HTTPProtocol::resetAuthState(HTTPProtocol *this)
{
  if (this) {
    CFRetain((char *)this - 16);
  }
  unint64_t v14 = this;
  uint64_t v2 = (std::__shared_weak_count *)operator new(0x20uLL);
  v2->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE68;
  v2->__shared_weak_owners_ = 0LL;
  v2[1].__vftable = (std::__shared_weak_count_vtbl *)this;
  int v15 = v2;
  v12[4] = this;
  uint64_t v13 = v2;
  v2->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  uint64_t v4 = *((void *)this + 3);
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3321888768LL;
  v12[2] = ___ZN12HTTPProtocol14resetAuthStateEv_block_invoke;
  v12[3] = &__block_descriptor_48_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  do
    unint64_t v5 = __ldxr(p_shared_owners);
  while (__stxr(v5 + 1, p_shared_owners));
  (*(void (**)(uint64_t, void *))(*(void *)v4 + 96LL))(v4, v12);
  uint64_t v6 = v13;
  if (v13)
  {
    uint64_t v7 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  uint64_t v9 = v15;
  if (v15)
  {
    __int16 v10 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

void sub_182ADA060(_Unwind_Exception *a1)
{
}

uint64_t HTTPProtocol::clientDescription(HTTPProtocol *this)
{
  return *((void *)this + 99);
}

uint64_t HTTPProtocol::canRetryRequestAfterError(HTTPProtocol *this, const CFStreamError *a2, int a3)
{
  uint64_t v77 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (void *)*((void *)this + 11);
  if (!v6)
  {
    __int16 v16 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_80, 1);
    uint64_t v11 = (uint64_t)v16;
    if (!v16) {
      goto LABEL_59;
    }
    if ((*(unsigned int (**)(void *, const char *, HTTPProtocol *))(*(void *)v16 + 24LL))( v16,  "Stream Error",  this))
    {
      (*(void (**)(uint64_t, const char *, const __CFString *))(*(void *)v11 + 72LL))( v11,  "HTTPProtocol",  @"Task and request are both nullptr; Error: %p [%ld:%d]");
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }

    goto LABEL_56;
  }

  if ((*((_DWORD *)this + 48) & 2) == 0)
  {
    if (objc_msgSend( (id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"),  "_allowsTLSFallback"))
    {
      uint64_t v7 = (void *)*((void *)this + 11);
      if ((!v7
         || (unint64_t v8 = (StrictSecurityPolicy *)*((void *)this + 92)) == 0LL
         || StrictSecurityPolicy::strictSecurityPolicyInEffectForURL( v8,  (CFURLRef)[*((id *)this + 11) cfURL],  *(const __CFDictionary **)(objc_msgSend(v7, "_inner") + 200)) != 2)
        && a2->domain == *MEMORY[0x1896051C0])
      {
        unsigned int v9 = a2->error + 9850;
        if (v9 > 0x2B || ((1LL << v9) & 0xC7803E80081LL) == 0)
        {
          if (HTTPProtocol::nextTLSFallbackMethod(this)) {
            uint64_t v11 = 5LL;
          }
          else {
            uint64_t v11 = 4LL;
          }
          if ((a3 & 1) != 0) {
            goto LABEL_69;
          }
LABEL_60:
          uint64_t v25 = CFNLog::onceToken;
          goto LABEL_61;
        }
      }
    }
  }

  uint64_t v10 = *((void *)this + 111);
  if (v10
    && (*(unsigned int (**)(uint64_t))(*(void *)v10 + 96LL))(v10)
    && a2->domain == 4
    && a2->error == -2200)
  {
    uint64_t v11 = 9LL;
    if ((a3 & 1) != 0) {
      goto LABEL_69;
    }
    goto LABEL_60;
  }

  LOWORD(v12) = *((_DWORD *)this + 48);
  if ((*((_DWORD *)this + 48) & 2) != 0)
  {
LABEL_44:
    if ((v12 & 2) != 0)
    {
      uint64_t v11 = 1LL;
      if ((a3 & 1) != 0) {
        goto LABEL_69;
      }
      goto LABEL_60;
    }

    if (a2->domain == 1)
    {
      SInt32 error = a2->error;
      if (((error - 53) > 0x2B || ((1LL << (error - 53)) & 0x80000000003LL) == 0)
        && error != 32)
      {
        goto LABEL_58;
      }
    }

    else if (a2->domain != 4 {
           || ((SInt32 v23 = a2->error, (v23 + 5) > 4) || ((1 << (v23 + 5)) & 0x13) == 0) && v23 != -2200)
    }
    {
LABEL_58:
      uint64_t v11 = 2LL;
LABEL_59:
      if ((a3 & 1) != 0) {
        goto LABEL_69;
      }
      goto LABEL_60;
    }

void HTTPProtocol::handleStreamError(HTTPProtocol *this, CFStreamError a2, CFTypeRef cf)
{
  CFStreamError v4 = a2;
  if (cf && !*((void *)this + 50)) {
    *((void *)this + 50) = CFRetain(cf);
  }
  HTTPProtocol::streamError(this, &v4);
}

CFTypeRef HTTPProtocol::ceRetain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 16);
}

void HTTPProtocol::ceRelease(HTTPProtocol *this)
{
}

uint64_t HTTPProtocol::ssPreConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZN12HTTPProtocol25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke;
  v8[3] = &unk_189C199F8;
  void v8[5] = a3;
  void v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96LL))(v6, v8);
}

uint64_t HTTPProtocol::ssNeedServerTrust(uint64_t a1, const void *a2, uint64_t a3)
{
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke;
  v8[3] = &unk_189C19948;
  void v8[5] = a1;
  void v8[6] = a2;
  v8[4] = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96LL))(v6, v8);
}

uint64_t HTTPProtocol::ssNeedClientCert(uint64_t a1, const void *a2, uint64_t a3)
{
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v6 = *(void *)(a1 + 24);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke;
  v8[3] = &unk_189C19948;
  void v8[5] = a1;
  void v8[6] = a2;
  v8[4] = a3;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96LL))(v6, v8);
}

uint64_t HTTPProtocol::ssPostConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke;
  v8[3] = &unk_189C199F8;
  void v8[5] = a3;
  void v8[6] = a1;
  v8[4] = a2;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96LL))(v6, v8);
}

void HTTPProtocol::ssPostHandshakesStreamsAvailable( HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

uint64_t HTTPProtocol::ssConnectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 392LL))(a1);
}

uint64_t HTTPProtocol::preConnectConfiguration(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = (void *)a1[11];
  if (!v8)
  {
    uint64_t v9 = 0LL;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v10 = 0LL;
    goto LABEL_6;
  }

  uint64_t v9 = *(void *)([v8 _inner] + 8);
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v10 = tcp_connection_id();
LABEL_6:
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, void))(a1[14] + 128LL))( a1 + 14,  v10,  a2,  a3,  v9,  a1[76]);
  return (*(uint64_t (**)(uint64_t))(a4 + 16))(a4);
}

void HTTPProtocol::needClientCert(uint64_t a1, uint64_t a2, void (**a3)(void, void, void))
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 520LL))(a1) || (uint64_t v6 = *(void **)(a1 + 88)) == 0LL)
  {
    a3[2](a3, 0LL, 1LL);
  }

  else
  {
    if (*(void *)(a1 + 408)) {
      __assert_rtn("needClientCert", "HTTPProtocol.cpp", 7157, "fClientCertChallenge == nullptr");
    }
    if (*(void *)(a1 + 416)) {
      __assert_rtn("needClientCert", "HTTPProtocol.cpp", 7158, "fClientCertChallengeCompletion == nullptr");
    }
    uint64_t v7 = *(const __CFURL **)([v6 _inner] + 8);
    unint64_t v8 = CFURLCopyHostName(v7);
    SInt32 v9 = CFURLGetPortNumber(v7);
    if (v9 == -1) {
      int v10 = 443;
    }
    else {
      int v10 = v9;
    }
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = ___ZN22HTTPProtocolSSLSupport40CreateClientCertChallengeWithHostAndPortEPK10__CFStringlPK9__CFArray_block_invoke;
    v12[3] = &__block_descriptor_40_e32_v16__0___CFURLProtectionSpace__8l;
    v12[4] = a2;
    uint64_t Challenge = createChallenge(7, v8, v10, (uint64_t)v12);
    if (v8) {
      CFRelease(v8);
    }
    *(void *)(a1 + 40_Block_object_dispose((const void *)(v1 - 48), 8) = Challenge;
    *(void *)(a1 + 4CFRelease((char *)this - 16) = _Block_copy(a3);
    HTTPProtocol::sendDidReceiveAuthChallenge((HTTPProtocol *)a1, *(_CFURLAuthChallenge **)(a1 + 408));
  }

void HTTPProtocol::postConnectConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFHTTPMessageRef v7 = CFURLRequestCopyHTTPRequest(*(void **)(a1 + 88));
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)(a1 - 16));
  uint64_t v9 = *(void *)(a1 + 280);
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = ___ZN12HTTPProtocol24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke;
  v10[3] = &unk_189C19A58;
  v10[4] = a4;
  void v10[5] = a1;
  (*(void (**)(uint64_t, CFAllocatorRef, uint64_t, CFHTTPMessageRef, uint64_t, void *))(*(void *)(a1 + 112)
                                                                                                + 144LL))( a1 + 112,  v8,  a2,  v7,  v9,  v10);
  if (v7) {
    CFRelease(v7);
  }
}

void HTTPProtocol::connectionEstablished(HTTPProtocol *this, CFStreamError a2)
{
}

uint64_t HTTPProtocol::connectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 408LL))(a1);
}

uint64_t HTTPProtocol::waitsForConnectivity(HTTPProtocol *this)
{
  else {
    return 0LL;
  }
}

uint64_t HTTPProtocol::handleConnectionWaitingNotification(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)(result + 43))
  {
    uint64_t v3 = result;
    CFRetain((CFTypeRef)(result - 16));
    uint64_t v4 = *(void *)(v3 + 24);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    v5[2] = ___ZN12HTTPProtocol35handleConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v5[4] = v3;
    void v5[5] = a2;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 96LL))(v4, v5);
  }

  return result;
}

uint64_t HTTPProtocol::handleAlternatePathNotification(uint64_t result, int a2)
{
  if (*(_BYTE *)(result + 45))
  {
    uint64_t v3 = result;
    CFRetain((CFTypeRef)(result - 16));
    uint64_t v4 = *(void *)(v3 + 24);
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    v5[2] = ___ZN12HTTPProtocol31handleAlternatePathNotificationE36nw_connection_alternate_path_state_t_block_invoke;
    v5[3] = &__block_descriptor_44_e5_v8__0l;
    v5[4] = v3;
    int v6 = a2;
    return (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 96LL))(v4, v5);
  }

  return result;
}

CFTypeRef HTTPProtocol::_meta_retain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 16);
}

void HTTPProtocol::_meta_release(HTTPProtocol *this)
{
}

uint64_t HTTPProtocol::creds(HTTPProtocol *this)
{
  return *((void *)this + 44);
}

uint64_t HTTPProtocol::authFailureResponse(HTTPProtocol *this)
{
  return *((void *)this + 39);
}

uint64_t HTTPProtocol::trustRef(HTTPProtocol *this)
{
  return *((void *)this + 57);
}

uint64_t HTTPProtocol::hcc_getUseCredentialStorage(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 40);
}

uint64_t HTTPProtocol::proxyAuthFailureResponse(HTTPProtocol *this)
{
  return *((void *)this + 42);
}

uint64_t HTTPProtocol::requiresConnectionBasedAuth(HTTPProtocol *this)
{
  uint64_t v2 = *((void *)this + 35);
  else {
    uint64_t v3 = 59LL;
  }
  uint64_t result = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 8 * v3))(this);
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(v5 + 40);
    if (v6)
    {
      return (*(_DWORD *)(v6 + 72) - 5) < 2;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

BOOL HTTPProtocol::isValidForTube(HTTPProtocol *this)
{
  return !(*(unsigned int (**)(HTTPProtocol *))(*(void *)this + 520LL))(this)
      && !*((void *)this + 34)
      && *((void *)this + 11) != 0LL;
}

void HTTPProtocol::hcc_touchProtocol(HTTPProtocol *this)
{
  *((CFAbsoluteTime *)this + 4) = CFAbsoluteTimeGetCurrent();
}

HTTPProtocol *HTTPProtocol::copyTaskLoggableDescription@<X0>(HTTPProtocol *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 100);
  *a2 = *((void *)this + 99);
  a2[1] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return this;
}

uint64_t HTTPProtocol::getUserName(HTTPProtocol *this)
{
  if (*((void *)this + 74)
    || (*(unsigned int (**)(void))(**((void **)this + 35) + 88LL))(*((void *)this + 35)) == 2
    || (*(unsigned int (**)(void))(**((void **)this + 35) + 88LL))(*((void *)this + 35)) == 3)
  {
    uint64_t v3 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this);
    if (!v3) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v3 = *((void *)this + 44);
    if (!v3) {
      return 0LL;
    }
  }

  uint64_t v4 = URLCredential_PasswordBased::safelyCast(v3, v2);
  if (v4) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 112LL))(v4);
  }
  return 0LL;
}

uint64_t HTTPProtocol::getUserPrincipal(HTTPProtocol *this)
{
  uint64_t v2 = (__CFHTTPMessage *)*((void *)this + 39);
  if (v2 && CFHTTPMessageGetResponseStatusCode(v2) == 407)
  {
    uint64_t v3 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this);
    if (!v3) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v3 = *((void *)this + 44);
    if (!v3) {
      return 0LL;
    }
  }

  if (*(_DWORD *)(v3 + 48) == 2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(v3 + 16) + 128LL))(v3 + 16);
  }
  return 0LL;
}

uint64_t HTTPProtocol::getServicePrincipal(HTTPProtocol *this)
{
  uint64_t v2 = (__CFHTTPMessage *)*((void *)this + 39);
  if (v2 && CFHTTPMessageGetResponseStatusCode(v2) == 407)
  {
    uint64_t v3 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this);
    if (!v3) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v3 = *((void *)this + 44);
    if (!v3) {
      return 0LL;
    }
  }

  if (*(_DWORD *)(v3 + 48) == 2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(v3 + 16) + 136LL))(v3 + 16);
  }
  return 0LL;
}

void HTTPProtocol::setProxy(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (a1[74] != v3)
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100](a1 + 74, v3, a2[1]);
    uint64_t v5 = a1[35];
    if (v5)
    {
      uint64_t v6 = (std::__shared_weak_count *)a1[75];
      uint64_t v12 = a1[74];
      uint64_t v13 = v6;
      if (v6)
      {
        p_shared_owners = (unint64_t *)&v6->__shared_owners_;
        do
          unint64_t v8 = __ldxr(p_shared_owners);
        while (__stxr(v8 + 1, p_shared_owners));
      }

      (*(void (**)(uint64_t, uint64_t *))(*(void *)v5 + 56LL))(v5, &v12);
      uint64_t v9 = v13;
      if (v13)
      {
        int v10 = (unint64_t *)&v13->__shared_owners_;
        do
          unint64_t v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
  }

void sub_182ADB5A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HTTPProtocol::setProxyCreds(HTTPProtocol *this, NetworkProxyCredential *a2)
{
  uint64_t v2 = *((void *)this + 46);
  if (a2)
  {
    if (v2)
    {
      uint64_t v4 = *(void *)(v2 + 40);
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 48LL))(v4);
      }
      *(void *)(v2 + 40) = a2;
      (*(void (**)(NetworkProxyCredential *))(*(void *)a2 + 40LL))(a2);
    }

    else
    {
      CFHTTPMessageRef v7 = (char *)this - 16;
      CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
      uint64_t v9 = (NetworkProxyAuthorizationElements *)MEMORY[0x186E12804](v8, 80LL, 0LL);
      *(_OWORD *)uint64_t v9 = 0u;
      *((_OWORD *)v9 + 1) = 0u;
      *((_OWORD *)v9 + 2) = 0u;
      *((_OWORD *)v9 + 3) = 0u;
      *((_OWORD *)v9 + 4) = 0u;
      int v10 = CFGetAllocator(v7);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements( v9,  v10,  a2,  0LL,  0LL,  *((CFTypeRef *)this + 99));
      *((void *)this + 46) = v9;
    }
  }

  else if (v2)
  {
    uint64_t v5 = *(void *)(v2 + 40);
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v5 + 48LL))(v5);
      *(void *)(v2 + 40) = 0LL;
    }
  }

uint64_t HTTPProtocol::setProxyCFCreds(HTTPProtocol *this, const _CFURLCredential *a2)
{
  if (!a2)
  {
    CFHTTPMessageRef v7 = 0LL;
LABEL_6:
    uint64_t result = (*(uint64_t (**)(HTTPProtocol *, NetworkProxyCredential *))(*(void *)this + 608LL))(this, v7);
    if (v7) {
      return (*(uint64_t (**)(NetworkProxyCredential *))(*(void *)v7 + 48LL))(v7);
    }
    return result;
  }

  if (!(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this)
    || (uint64_t v4 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this),
        uint64_t result = CFEqual(a2, v4),
        !(_DWORD)result))
  {
    CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
    CFHTTPMessageRef v7 = (NetworkProxyCredential *)MEMORY[0x186E12804](v6, 56LL, 0LL);
    *(_OWORD *)CFHTTPMessageRef v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    *((_OWORD *)v7 + 2) = 0u;
    *((void *)v7 + 6) = 0LL;
    CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
    NetworkProxyCredential::NetworkProxyCredential(v7, v8, a2);
    goto LABEL_6;
  }

  return result;
}

void HTTPProtocol::setProxyProtectionSpace(HTTPProtocol *this, CFTypeRef cf)
{
  uint64_t v3 = (NetworkProxyAuthorizationElements *)*((void *)this + 46);
  if (cf)
  {
    if (v3)
    {
      NetworkProxyAuthorizationElements::setProtectionSpace(v3, cf);
    }

    else
    {
      CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
      CFHTTPMessageRef v7 = (NetworkProxyAuthorizationElements *)MEMORY[0x186E12804](v6, 80LL, 0LL);
      *(_OWORD *)CFHTTPMessageRef v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *((_OWORD *)v7 + 4) = 0u;
      CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements( v7,  v8,  0LL,  cf,  0LL,  *((CFTypeRef *)this + 99));
      *((void *)this + 46) = v7;
    }
  }

  else if (v3)
  {
    uint64_t v5 = (const void *)*((void *)v3 + 6);
    *((void *)v3 + 6) = 0LL;
    if (v5) {
      CFRelease(v5);
    }
  }

void HTTPProtocol::setProxyChallenge(HTTPProtocol *this, CFTypeRef cf)
{
  uint64_t v3 = (NetworkProxyAuthorizationElements *)*((void *)this + 46);
  if (cf)
  {
    if (v3)
    {
      NetworkProxyAuthorizationElements::setChallenge(v3, cf);
    }

    else
    {
      CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
      CFHTTPMessageRef v7 = (NetworkProxyAuthorizationElements *)MEMORY[0x186E12804](v6, 80LL, 0LL);
      *(_OWORD *)CFHTTPMessageRef v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *((_OWORD *)v7 + 4) = 0u;
      CFAllocatorRef v8 = CFGetAllocator((char *)this - 16);
      NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements( v7,  v8,  0LL,  0LL,  cf,  *((CFTypeRef *)this + 99));
      *((void *)this + 46) = v7;
    }
  }

  else if (v3)
  {
    uint64_t v5 = (const void *)*((void *)v3 + 7);
    *((void *)v3 + 7) = 0LL;
    if (v5) {
      CFRelease(v5);
    }
  }

uint64_t HTTPProtocol::proxyChallenge(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 46);
  if (v1) {
    return *(void *)(v1 + 56);
  }
  else {
    return 0LL;
  }
}

HTTPProtocol *HTTPProtocol::markProxyAuthorizationUnviable(HTTPProtocol *this)
{
  if ((*((_DWORD *)this + 48) & 0x400000) != 0)
  {
    uint64_t v1 = *((void *)this + 46);
    if (v1)
    {
      uint64_t v2 = *(void *)(v1 + 40);
      if (v2) {
        *(_DWORD *)(v2 + 40) = 2;
      }
    }
  }

  return this;
}

uint64_t HTTPProtocol::failedProxyAuth(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 46);
  if (v1) {
    return *(unsigned __int8 *)(v1 + 32);
  }
  else {
    return 0LL;
  }
}

void HTTPProtocol::setFailedProxyAuth(HTTPProtocol *this, char a2)
{
  uint64_t v3 = (NetworkProxyAuthorizationElements *)*((void *)this + 46);
  if (!v3)
  {
    uint64_t v5 = (char *)this - 16;
    CFAllocatorRef v6 = CFGetAllocator((char *)this - 16);
    uint64_t v3 = (NetworkProxyAuthorizationElements *)MEMORY[0x186E12804](v6, 80LL, 0LL);
    *(_OWORD *)uint64_t v3 = 0u;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *((_OWORD *)v3 + 3) = 0u;
    *((_OWORD *)v3 + 4) = 0u;
    CFHTTPMessageRef v7 = CFGetAllocator(v5);
    NetworkProxyAuthorizationElements::NetworkProxyAuthorizationElements( v3,  v7,  0LL,  0LL,  0LL,  *((CFTypeRef *)this + 99));
    *((void *)this + 46) = v3;
  }

  *((_BYTE *)v3 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = a2;
}

uint64_t HTTPProtocol::proxyAuthenticationIsComplete(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 616);
}

BOOL HTTPProtocol::canRelinquishControlToTask(HTTPProtocol *this)
{
  uint64_t v1 = (void *)*((void *)this + 10);
  return v1
}

HTTPProtocol *HTTPProtocol::socketStreamsForUpgradeHeaderAvailable( HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 3221225472LL;
  v7[2] = ___ZN12HTTPProtocol38socketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke;
  v7[3] = &__block_descriptor_48_e31_v16__0__URLProtocolClient_____8l;
  v7[4] = a2;
  void v7[5] = a3;
  uint64_t v3 = *((void *)this + 12);
  if (v3)
  {
    uint64_t v4 = this;
    uint64_t v5 = (*(uint64_t (**)(void))(*(void *)v3 + 16LL))(*((void *)this + 12));
    CFAllocatorRef v6 = (void *)MEMORY[0x186E1578C](v5);
    ___ZN12HTTPProtocol38socketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke( (uint64_t)v7,  *((void *)v4 + 12));
    objc_autoreleasePoolPop(v6);
    return (HTTPProtocol *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }

  return this;
}

void HTTPProtocol::tcpConnectionForUpgradeHeaderAvailable(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3321888768LL;
  uint64_t v13 = ___ZN12HTTPProtocol38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke;
  SInt32 v14 = &unk_189C0C648;
  uint64_t v4 = (std::__shared_weak_count *)a2[1];
  uint64_t v16 = *a2;
  SInt32 v17 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  uint64_t v15 = a3;
  uint64_t v7 = *(void *)(a1 + 96);
  if (v7)
  {
    uint64_t v8 = (*(uint64_t (**)(void))(*(void *)v7 + 16LL))(*(void *)(a1 + 96));
    uint64_t v9 = (void *)MEMORY[0x186E1578C](v8);
    v13(v12, *(void *)(a1 + 96));
    objc_autoreleasePoolPop(v9);
    (*(void (**)(uint64_t))(*(void *)v7 + 24LL))(v7);
    uint64_t v4 = v17;
  }

  if (v4)
  {
    int v10 = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

void sub_182ADBBE0(_Unwind_Exception *a1)
{
}

id HTTPProtocol::getTransactionMetrics(HTTPProtocol *this, const char *a2)
{
  id result = (id)*((void *)this + 104);
  if (result) {
    return objc_getProperty(result, a2, 96LL, 1);
  }
  return result;
}

void non-virtual thunk to'HTTPProtocol::~HTTPProtocol(HTTPProtocol *this)
{
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 8));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 16));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 16));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 112));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 112));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 120));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 120));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 176));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 176));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 184));
}

{
  HTTPProtocol::~HTTPProtocol((HTTPProtocol *)((char *)this - 184));
}

CFTypeRef non-virtual thunk to'HTTPProtocol::ceRetain(HTTPProtocol *this)
{
  return CFRetain((char *)this - 128);
}

void non-virtual thunk to'HTTPProtocol::ceRelease(HTTPProtocol *this)
{
}

uint64_t non-virtual thunk to'HTTPProtocol::ssPreConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  return HTTPProtocol::ssPreConnectConfiguration(a1 - 112, a2, a3);
}

uint64_t non-virtual thunk to'HTTPProtocol::ssNeedServerTrust(uint64_t a1, const void *a2, uint64_t a3)
{
  return HTTPProtocol::ssNeedServerTrust(a1 - 112, a2, a3);
}

uint64_t non-virtual thunk to'HTTPProtocol::ssNeedClientCert(uint64_t a1, const void *a2, uint64_t a3)
{
  return HTTPProtocol::ssNeedClientCert(a1 - 112, a2, a3);
}

uint64_t non-virtual thunk to'HTTPProtocol::ssPostConnectConfiguration(uint64_t a1, void *a2, uint64_t a3)
{
  return HTTPProtocol::ssPostConnectConfiguration(a1 - 112, a2, a3);
}

void non-virtual thunk to'HTTPProtocol::ssPostHandshakesStreamsAvailable( HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
}

uint64_t non-virtual thunk to'HTTPProtocol::ssConnectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 - 112) + 392LL))(a1 - 112);
}

void non-virtual thunk to'HTTPProtocol::needClientCert( uint64_t a1, uint64_t a2, void (**a3)(void, void, void))
{
}

{
  HTTPProtocol::needClientCert(a1 - 120, a2, a3);
}

uint64_t non-virtual thunk to'HTTPProtocol::preConnectConfiguration( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return HTTPProtocol::preConnectConfiguration((void *)(a1 - 112), a2, a3, a4);
}

{
  return HTTPProtocol::preConnectConfiguration((void *)(a1 - 120), a2, a3, a4);
}

void non-virtual thunk to'HTTPProtocol::postConnectConfiguration( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

{
  HTTPProtocol::postConnectConfiguration(a1 - 120, a2, a3, a4);
}

uint64_t non-virtual thunk to'HTTPProtocol::connectionWaitingNotification(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 - 112) + 408LL))(a1 - 112);
}

{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 - 120) + 408LL))(a1 - 120);
}

void non-virtual thunk to'HTTPProtocol::connectionEstablished( HTTPProtocol *this, CFStreamError a2)
{
}

{
  abort();
}

void non-virtual thunk to'HTTPProtocol::setProxy(uint64_t a1, uint64_t *a2)
{
}

uint64_t non-virtual thunk to'HTTPProtocol::proxyAuthenticationIsComplete(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this + 440);
}

void non-virtual thunk to'HTTPProtocol::handleStreamError( HTTPProtocol *this, CFStreamError a2, const __CFDictionary *a3)
{
}

uint64_t non-virtual thunk to'HTTPProtocol::creds(HTTPProtocol *this)
{
  return *((void *)this + 22);
}

uint64_t non-virtual thunk to'HTTPProtocol::challenge(HTTPProtocol *this)
{
  return *((void *)this + 25);
}

uint64_t non-virtual thunk to'HTTPProtocol::authFailureResponse(HTTPProtocol *this)
{
  return *((void *)this + 17);
}

uint64_t non-virtual thunk to'HTTPProtocol::proxyCreds(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 24);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 40)) != 0) {
    return *(void *)(v2 + 32);
  }
  else {
    return 0LL;
  }
}

uint64_t non-virtual thunk to'HTTPProtocol::proxyChallenge(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 24);
  if (v1) {
    return *(void *)(v1 + 56);
  }
  else {
    return 0LL;
  }
}

uint64_t non-virtual thunk to'HTTPProtocol::proxyAuthFailureResponse(HTTPProtocol *this)
{
  return *((void *)this + 20);
}

uint64_t non-virtual thunk to'HTTPProtocol::requiresConnectionBasedAuth(HTTPProtocol *this)
{
  return HTTPProtocol::requiresConnectionBasedAuth((HTTPProtocol *)((char *)this - 176));
}

uint64_t non-virtual thunk to'HTTPProtocol::trustRef(HTTPProtocol *this)
{
  return *((void *)this + 35);
}

uint64_t non-virtual thunk to'HTTPProtocol::hcc_getUseCredentialStorage(HTTPProtocol *this)
{
  return *((unsigned __int8 *)this - 136);
}

uint64_t non-virtual thunk to'HTTPProtocol::isCancelled(HTTPProtocol *this)
{
  return (*((_DWORD *)this + 4) >> 20) & 1;
}

void non-virtual thunk to'HTTPProtocol::hcc_touchProtocol(HTTPProtocol *this)
{
  *((CFAbsoluteTime *)this - 1_Block_object_dispose((const void *)(v1 - 48), 8) = CFAbsoluteTimeGetCurrent();
}

uint64_t non-virtual thunk to'HTTPProtocol::getUserName(HTTPProtocol *this)
{
  return HTTPProtocol::getUserName((HTTPProtocol *)((char *)this - 176));
}

uint64_t non-virtual thunk to'HTTPProtocol::getUserPrincipal(HTTPProtocol *this)
{
  return HTTPProtocol::getUserPrincipal((HTTPProtocol *)((char *)this - 176));
}

uint64_t non-virtual thunk to'HTTPProtocol::getServicePrincipal(HTTPProtocol *this)
{
  return HTTPProtocol::getServicePrincipal((HTTPProtocol *)((char *)this - 176));
}

uint64_t non-virtual thunk to'HTTPProtocol::getUUID(HTTPProtocol *this)
{
  return HTTPProtocol::getUUID((HTTPProtocol *)((char *)this - 176));
}

uint64_t non-virtual thunk to'HTTPProtocol::waitsForConnectivity(HTTPProtocol *this)
{
  else {
    return 0LL;
  }
}

uint64_t non-virtual thunk to'HTTPProtocol::handleConnectionWaitingNotification(uint64_t a1, uint64_t a2)
{
  return HTTPProtocol::handleConnectionWaitingNotification(a1 - 176, a2);
}

uint64_t non-virtual thunk to'HTTPProtocol::handleAlternatePathNotification(uint64_t a1, int a2)
{
  return HTTPProtocol::handleAlternatePathNotification(a1 - 176, a2);
}

uint64_t non-virtual thunk to'HTTPProtocol::reportsDataStalls(HTTPProtocol *this)
{
  uint64_t v1 = (void *)[*((id *)this - 12) _effectiveConfiguration];
  if (v1) {
    return [v1 _reportsDataStalls];
  }
  else {
    return 1LL;
  }
}

HTTPProtocol *non-virtual thunk to'HTTPProtocol::socketStreamsForUpgradeHeaderAvailable( HTTPProtocol *this, __CFReadStream *a2, __CFWriteStream *a3)
{
  return HTTPProtocol::socketStreamsForUpgradeHeaderAvailable((HTTPProtocol *)((char *)this - 176), a2, a3);
}

void non-virtual thunk to'HTTPProtocol::tcpConnectionForUpgradeHeaderAvailable( uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

uint64_t non-virtual thunk to'HTTPProtocol::canRetryRequestAfterError( HTTPProtocol *this, const CFStreamError *a2, int a3)
{
  return HTTPProtocol::canRetryRequestAfterError((HTTPProtocol *)((char *)this - 176), a2, a3);
}

void non-virtual thunk to'HTTPProtocol::generateProxyAuthentication( uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
}

void non-virtual thunk to'HTTPProtocol::resetAuthState(HTTPProtocol *this)
{
}

uint64_t non-virtual thunk to'HTTPProtocol::clientDescription(HTTPProtocol *this)
{
  return *((void *)this + 76);
}

uint64_t std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v3 = *(void ***)(a1 + 8);
  }

  else
  {
    uint64_t v4 = (void *)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 32);
    unint64_t v6 = &v2[v5 >> 8];
    uint64_t v7 = (uint64_t)*v6 + 16 * v5;
    if (v7 != v8)
    {
      do
      {
        uint64_t v7 = std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v7) + 16;
        if (v7 - (void)*v6 == 4096)
        {
          uint64_t v9 = (uint64_t)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }

      while (v7 != v8);
      uint64_t v2 = *(void ***)(a1 + 8);
      uint64_t v3 = *(void ***)(a1 + 16);
    }
  }

  *uint64_t v4 = 0LL;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8LL);
      *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 48), 8) = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 128LL;
    goto LABEL_14;
  }

  if (v11 == 2)
  {
    uint64_t v12 = 256LL;
LABEL_14:
    *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v12;
  }

  if (v2 != v3)
  {
    do
    {
      uint64_t v13 = *v2++;
      operator delete(v13);
    }

    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + CFRelease((char *)this - 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void ___ZN9TCFObjectI12SocketStreamE5ClassEv_block_invoke_7079()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  dword_18C5B2D48 = 1835099506;
  _PNAME<SocketStream>::GET(void)::p = *(void *)"SocketStream>::GET() [OBJTYPE = SocketStream]";
  CFClass::CFClass(v0, (const char *)&_PNAME<SocketStream>::GET(void)::p);
  TCFObject<SocketStream>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182ADC020(_Unwind_Exception *a1)
{
}

void ___ZN9TCFObjectIN19TransportConnection17RefCountedWrapperEE5ClassEv_block_invoke()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  qmemcpy(_PNAME<TransportConnection::RefCountedWrapper>::GET(void)::p, "TransportConnection::RefCountedWrapper", 38);
  CFClass::CFClass(v0, (const char *)_PNAME<TransportConnection::RefCountedWrapper>::GET(void)::p);
  TCFObject<TransportConnection::RefCountedWrapper>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182ADC084(_Unwind_Exception *a1)
{
}

uint64_t ___ZN12HTTPProtocol17destroyReadStreamEv_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 48), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2457LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 48), 8) = "none";
  return result;
}

uint64_t ___ZN12HTTPProtocolD2Ev_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 48), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 563LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 48), 8) = "none";
  return result;
}

void ___ZN12HTTPProtocol38tcpConnectionForUpgradeHeaderAvailableENSt3__110shared_ptrI19TransportConnectionEEPU27objcproto16OS_dispatch_data8NSObject_block_invoke( void *a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (std::__shared_weak_count *)a1[6];
    uint64_t v8 = a1[5];
    uint64_t v9 = v2;
    if (v2)
    {
      p_shared_owners = (unint64_t *)&v2->__shared_owners_;
      do
        unint64_t v4 = __ldxr(p_shared_owners);
      while (__stxr(v4 + 1, p_shared_owners));
    }

    (*(void (**)(uint64_t, uint64_t *, void))(*(void *)a2 + 168LL))(a2, &v8, a1[4]);
    unint64_t v5 = v9;
    if (v9)
    {
      unint64_t v6 = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }

  else
  {
    (*(void (**)(void))(*(void *)a1[5] + 152LL))(a1[5]);
  }

void sub_182ADC210( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t __copy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE( uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 4_Block_object_dispose((const void *)(v1 - 48), 8) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_40c47_ZTSNSt3__110shared_ptrI19TransportConnectionEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 40);
}

void ___ZN12HTTPProtocol38socketStreamsForUpgradeHeaderAvailableEP14__CFReadStreamP15__CFWriteStream_block_invoke( uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (a2)
  {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 160LL))(a2, v4, *(void *)(a1 + 40));
  }

  else
  {
    if (v4) {
      CFReadStreamClose(*(CFReadStreamRef *)(a1 + 32));
    }
    unint64_t v5 = *(__CFWriteStream **)(a1 + 40);
    if (v5) {
      CFWriteStreamClose(v5);
    }
  }

URLProtocol *URLProtocol::sendNeedNewBodyStream(URLProtocol *this)
{
  uint64_t v1 = *((void *)this + 12);
  if (v1)
  {
    uint64_t v2 = this;
    uint64_t v3 = (*(uint64_t (**)(void))(*(void *)v1 + 16LL))(*((void *)this + 12));
    uint64_t v4 = (void *)MEMORY[0x186E1578C](v3);
    (*(void (**)(void))(**((void **)v2 + 12) + 112LL))(*((void *)v2 + 12));
    objc_autoreleasePoolPop(v4);
    return (URLProtocol *)(*(uint64_t (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }

  return this;
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke( void *a1, const void *a2)
{
  uint64_t v4 = a1[4];
  unint64_t v5 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_107, 2);
  if (v5)
  {
    unint64_t v6 = v5;
    if ((*(unsigned int (**)(void *, const char *, uint64_t))(*(void *)v5 + 24LL))( v5,  "_kCFStreamPropertyHTTPFilterEstablishedConnectionBlock called",  v4))
    {
      (*(void (**)(void *, const char *, void))(*(void *)v6 + 48LL))(v6, "Request", *(void *)(v4 + 88));
      (*(void (**)(void *))(*(void *)v6 + 8LL))(v6);
    }
  }

  if (a2) {
    CFRetain(a2);
  }
  uint64_t v8 = a1[5];
  unint64_t v7 = (std::__shared_weak_count *)a1[6];
  uint64_t v9 = *(void *)(v8 + 24);
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 3321888768LL;
  v15[2] = ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3;
  v15[3] = &__block_descriptor_64_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  v15[4] = v4;
  v15[5] = v8;
  uint64_t v16 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  SInt32 v17 = a2;
  (*(void (**)(uint64_t, void *))(*(void *)v9 + 96LL))(v9, v15);
  uint64_t v12 = v16;
  if (v16)
  {
    uint64_t v13 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_182ADC478(_Unwind_Exception *a1)
{
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_112( void *a1, uint64_t a2, int a3)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1[4];
  unint64_t v6 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_114, 2);
  if (v6)
  {
    unint64_t v7 = v6;
    if ((*(unsigned int (**)(void *, const char *, uint64_t))(*(void *)v6 + 24LL))( v6,  "_kCFStreamPropertyConditionalRequirementsChangedBlock called",  v5))
    {
      uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (a3) {
        uint64_t v9 = "true";
      }
      else {
        uint64_t v9 = "false";
      }
      (*(void (**)(void *, const char *, void))(*(void *)v7 + 48LL))(v7, "Request", *(void *)(v5 + 88));
      uint64_t v25 = off_189C1A178;
      uint64_t v27 = 0LL;
      uint64_t v28 = 0LL;
      CFStringRef v26 = CFStringCreateWithCString(v8, "satisfied", 0x8000100u);
      int v21 = off_189C1A178;
      uint64_t v23 = 0LL;
      uint64_t v24 = 0LL;
      CFStringRef v22 = CFStringCreateWithCString(v8, v9, 0x8000100u);
      (*(void (**)(void *, CFStringRef, CFStringRef))(*(void *)v7 + 64LL))(v7, v26, v22);
      AutoString::~AutoString((AutoString *)&v21);
      AutoString::~AutoString((AutoString *)&v25);
      (*(void (**)(void *))(*(void *)v7 + 8LL))(v7);
    }
  }

  uint64_t v11 = a1[5];
  unint64_t v10 = (std::__shared_weak_count *)a1[6];
  uint64_t v12 = *(void *)(v11 + 24);
  v18[0] = MEMORY[0x1895F87A8];
  v18[1] = 3321888768LL;
  v18[2] = ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3_119;
  v18[3] = &__block_descriptor_57_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  char v20 = a3;
  v18[4] = v5;
  void v18[5] = v11;
  CFStringRef v19 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, void *))(*(void *)v12 + 96LL))(v12, v18);
  uint64_t v15 = v19;
  if (v19)
  {
    uint64_t v16 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_182ADC6A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

void HTTPProtocol::sendError(HTTPProtocol *this, const __CFString *a2)
{
  if (*((void *)this + 59))
  {
    uint64_t v8 = (const void *)*((void *)this + 59);
    keys = @"NSErrorPeerAddressKey";
    uint64_t v4 = CFGetAllocator((char *)this - 16);
    uint64_t v5 = CFDictionaryCreate(v4, (const void **)&keys, &v8, 1LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  unint64_t v6 = CFGetAllocator((char *)this - 16);
  unint64_t v7 = CFErrorCreate(v6, @"kCFErrorDomainCFNetwork", (CFIndex)a2, v5);
  if (v5) {
    CFRelease(v5);
  }
  URLProtocol::sendDidFail((URLProtocol *)this, v7);
  if (v7) {
    CFRelease(v7);
  }
}

void ___ZN12HTTPProtocol10openStreamEv_block_invoke(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!a2) {
    HTTPProtocol::sendError((HTTPProtocol *)v3, (const __CFString *)0xFFFFFFFFFFFFFC14LL);
  }
  unint64_t v4 = *(unsigned int *)(v3 + 192) | ((unint64_t)*(unsigned __int16 *)(v3 + 196) << 32);
  if ((v4 & 0x400000000000LL) != 0)
  {
    *(void *)(v3 + 56) = 0LL;
    unint64_t v6 = v4 & 0xFFFFBFFFFFFFFFFFLL;
    *(_DWORD *)(v3 + 192) = v6;
    *(_WORD *)(v3 + 196) = WORD2(v6);
    goto LABEL_10;
  }

  uint64_t v5 = *(void *)(v3 + 56);
  if (v5 > 0)
  {
LABEL_11:
    unint64_t v7 = *(HTTPMessage **)([*(id *)(v3 + 88) _inner] + 56);
    if (v7)
    {
      uint64_t v8 = HTTPMessage::copyHeaderFieldValue(v7, 0x11F1D2DBu);
      if (v8)
      {
        uint64_t v9 = v8;
        CFIndex Length = CFStringGetLength(v8);
        if (Length < 1)
        {
          CFIndex v12 = 0LL;
          BOOL v11 = 1;
        }

        else
        {
          BOOL v11 = 0;
          CFIndex v12 = 0LL;
          while (1)
          {
            int CharacterAtIndex = CFStringGetCharacterAtIndex(v9, v12);
            if (CharacterAtIndex != 32 && CharacterAtIndex != 9) {
              break;
            }
            BOOL v11 = ++v12 >= Length;
            if (Length == v12)
            {
              uint64_t v14 = 0LL;
              char v15 = v12 >= Length;
              goto LABEL_35;
            }
          }
        }

        char v15 = v11;
        if (v12 >= Length)
        {
          uint64_t v14 = 0LL;
        }

        else
        {
          uint64_t v14 = 0LL;
          while (1)
          {
            unsigned int v18 = CFStringGetCharacterAtIndex(v9, v12);
            if (v18 - 48 > 9) {
              break;
            }
            ++v12;
            uint64_t v19 = 10 * v14 + v18;
            if (v12 < Length && v19 > 0xCCCCCCCCCCCCCF2LL) {
              goto LABEL_24;
            }
            uint64_t v14 = v19 - 48;
            char v15 = 1;
            if (Length == v12)
            {
              CFRelease(v9);
              goto LABEL_36;
            }
          }
        }

void sub_182ADCA20(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN12HTTPProtocol10openStreamEv_block_invoke_2( uint64_t a1, uint64_t a2, dispatch_data_s *a3, CFStreamError *a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(void *)(v5 + 272) == *(void *)(a1 + 40)) {
    HTTPProtocol::handleStreamEvent(v5, a2, a3, a4);
  }
}

void ___ZN12HTTPProtocol10openStreamEv_block_invoke_3( uint64_t a1, uint64_t a2, dispatch_data_s *a3, CFStreamError *a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(void *)(v5 + 272) == *(void *)(a1 + 40)) {
    HTTPProtocol::handleStreamEvent(v5, a2, a3, a4);
  }
}

void HTTPProtocol::streamError(HTTPProtocol *this, CFStreamError *a2)
{
  uint64_t v102 = *MEMORY[0x1895F89C0];
  unint64_t v4 = (void *)*((void *)this + 10);
  if (v4) {
    [v4 _releasePreventIdleSleepAssertionIfAppropriate];
  }
  int v5 = (*(uint64_t (**)(HTTPProtocol *, CFStreamError *, uint64_t))(*(void *)this + 272LL))(this, a2, 1LL);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  unint64_t v6 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)this + 99);
    CFIndex domain = a2->domain;
    else {
      int v9 = 89;
    }
    SInt32 error = a2->error;
    *(_DWORD *)__int128 buf = 138544386;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v9;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v5;
    LOWORD(v100) = 2048;
    *(void *)((char *)&v100 + 2) = domain;
    WORD5(v100) = 1024;
    HIDWORD(v100) = error;
    _os_log_impl( &dword_18298D000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}@ can retry(%c) with reason(%d) for error [%ld:%d]",  buf,  0x28u);
  }

  switch(v5)
  {
    case 4:
      uint64_t v11 = *((void *)this + 93);
      if (v11) {
        -[__NSURLSessionLocal _withConnectionCache_setCurrentSSLMethod:forKey:scheduling:]( v11,  0LL,  *((void *)this + 35),  *((const void **)this + 3));
      }
      HTTPProtocol::cleanupStreams(this);
      goto LABEL_15;
    case 5:
      uint64_t TLSFallbackMethod = HTTPProtocol::nextTLSFallbackMethod(this);
      uint64_t v34 = *((void *)this + 93);
      if (v34) {
        -[__NSURLSessionLocal _withConnectionCache_setCurrentSSLMethod:forKey:scheduling:]( v34,  TLSFallbackMethod,  *((void *)this + 35),  *((const void **)this + 3));
      }
      HTTPProtocol::cleanupStreams(this);
      if (*((void *)this + 11)) {
        (*(void (**)(HTTPProtocol *, void))(*(void *)this + 88LL))(this, 0LL);
      }
      return;
    case 6:
    case 7:
    case 9:
      HTTPProtocol::destroyReadStream(this);
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((void *)this + 104), 1025LL, 0LL);
      HTTPProtocol::createAndOpenStream(this, 0LL);
      return;
    case 8:
      CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)this + 37), 0LL);
      HTTPProtocol::destroyReadStream(this);
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((void *)this + 104), 1026LL, 0LL);
      HTTPProtocol::createAndOpenStream(this, 0LL);
      return;
    case 10:
      HTTPProtocol::destroyReadStream(this);
      *((void *)this + 6) = 0LL;
      *((void *)this + 7) = 0LL;
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*((void *)this + 104), 1025LL, 0LL);
      HTTPProtocol::createAndOpenStream(this, 0LL);
      return;
    default:
LABEL_15:
      if (*((_DWORD *)this + 206) == 1) {
        return;
      }
      __int128 v98 = (__int128)*a2;
      CFIndex v12 = (__CFDictionary *)MEMORY[0x1895F87A8];
      *(void *)__int128 buf = MEMORY[0x1895F87A8];
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&uint8_t buf[16] = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke;
      *(void *)&__int128 v100 = &__block_descriptor_56_e90_v32__0____CFError__8_shared_ptr___CFDictionary______CFDictionary_____shared_weak_count__16l;
      *((void *)&v100 + 1) = this;
      __int128 v101 = v98;
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
      uint64_t v96 = Mutable;
      uint64_t v14 = (std::__shared_weak_count *)operator new(0x20uLL);
      v14->__shared_owners_ = 0LL;
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      v14->__vftable = (std::__shared_weak_count_vtbl *)off_189C19FA8;
      v14->__shared_weak_owners_ = 0LL;
      v14[1].__vftable = (std::__shared_weak_count_vtbl *)Mutable;
      uint64_t v97 = v14;
      uint64_t v16 = (const void *)*((void *)this + 59);
      if (v16) {
        CFDictionarySetValue(Mutable, @"NSErrorPeerAddressKey", v16);
      }
      uint64_t v17 = *((void *)this + 111);
      if (v17)
      {
        unsigned int v18 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v17 + 64LL))(v17, 0x18C5AB4F8LL);
        v92[0] = v12;
        v92[1] = 3221225472LL;
        CFTypeID v93 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2_161;
        uint64_t v94 = &__block_descriptor_40_e5_v8__0l;
        __int16 v95 = v18;
        if (v18) {
          CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x189607768], v18);
        }
        uint64_t v19 = (const void *)(*(uint64_t (**)(void, uint64_t, const void *))(**((void **)this + 111) + 64LL))( *((void *)this + 111),  0x18C5AB5A0LL,  v18);
        v88[0] = v12;
        v88[1] = 3221225472LL;
        id v89 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_3;
        uint64_t v90 = &__block_descriptor_40_e5_v8__0l;
        unint64_t v91 = v19;
        if (v19) {
          CFDictionarySetValue(Mutable, @"_NSURLErrorPrivacyProxyFailureKey", v19);
        }
        char v20 = (const void *)(*(uint64_t (**)(void, uint64_t, const void *))(**((void **)this + 111) + 64LL))( *((void *)this + 111),  0x18C5AB530LL,  v19);
        v84[0] = v12;
        v84[1] = 3221225472LL;
        __int16 v85 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_4;
        CFOptionFlags v86 = &__block_descriptor_40_e5_v8__0l;
        __int128 v87 = v20;
        if (v20)
        {
          v83[0] = v12;
          v83[1] = 3221225472LL;
          v83[2] = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_5;
          v83[3] = &unk_189C1A548;
          v83[4] = nw_path_copy_parameters();
          nw_parameters_clear_proxy_options();
          CFDictionarySetValue(Mutable, @"_NSURLErrorNWPathKey", v20);
          ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_5((uint64_t)v83);
        }

        CFNumberRef v21 = (const void *)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 111) + 64LL))( *((void *)this + 111),  0x18C5AB4C0LL);
        v79[0] = v12;
        v79[1] = 3221225472LL;
        uint64_t v80 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_6;
        uint64_t v81 = &__block_descriptor_40_e5_v8__0l;
        unint64_t v82 = v21;
        if (v21) {
          CFDictionarySetValue(Mutable, @"_NSURLErrorBlockedTrackerFailureKey", v21);
        }
        CFStringRef v22 = (const void *)(*(uint64_t (**)(void, uint64_t, const void *))(**((void **)this + 111) + 64LL))( *((void *)this + 111),  0x18C5AB568LL,  v21);
        v75[0] = v12;
        v75[1] = 3221225472LL;
        SInt32 v76 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_7;
        uint64_t v77 = &__block_descriptor_40_e5_v8__0l;
        uint64_t v78 = v22;
        if (v22) {
          CFDictionarySetValue(Mutable, @"_NSURLErrorNWResolutionReportKey", v22);
        }
        uint64_t v23 = (const void *)(*(uint64_t (**)(void, uint64_t, const void *))(**((void **)this + 111) + 64LL))( *((void *)this + 111),  0x18C5AB5D8LL,  v22);
        v71[0] = v12;
        v71[1] = 3221225472LL;
        uint64_t v24 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_8;
        int v72 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_8;
        __int16 v73 = &__block_descriptor_40_e5_v8__0l;
        CFIndex v74 = v23;
        if (v23)
        {
          CFDictionarySetValue(Mutable, @"_NSURLErrorVPNInactiveFailureKey", v23);
          uint64_t v24 = v72;
        }

        v24((uint64_t)v71);
        v76((uint64_t)v75);
        v80((uint64_t)v79);
        v85((uint64_t)v84);
        v89((uint64_t)v88);
        v93((uint64_t)v92);
      }

      CFIndex v25 = a2->domain;
      if (a2->domain == 1)
      {
        uint64_t v35 = *(void *)&a2->error;
        values = Mutable;
        int v70 = v14;
        do
          unint64_t v36 = __ldxr(p_shared_owners);
        while (__stxr(v36 + 1, p_shared_owners));
        uint64_t valuePtr = v12;
        uint64_t v64 = 3221225472LL;
        uint64_t v65 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_9;
        int v66 = &__block_descriptor_56_e17_____CFError__8__0l;
        int v67 = this;
        __int128 v68 = v98;
        HTTPProtocol::asyncTransformError( (std::__shared_weak_count_vtbl *)this,  1LL,  v35,  (uint64_t *)&values,  (uint64_t)&valuePtr,  (uint64_t)buf);
        do
          unint64_t v37 = __ldaxr(p_shared_owners);
        while (__stlxr(v37 - 1, p_shared_owners));
      }

      else
      {
        if (v25 == 15 || v25 == 4)
        {
          CFStringRef v26 = CFGetAllocator((char *)this - 16);
          CFErrorWithStreamCFStreamError Error = __cfnCreateCFErrorWithStreamError(v26, (int *)a2);
LABEL_36:
          uint64_t v28 = CFErrorWithStreamError;
LABEL_37:
          if (v28) {
            HTTPProtocol::logLoadFailure(this, v28, a2);
          }
          uint64_t valuePtr = Mutable;
          uint64_t v64 = (uint64_t)v14;
          do
            unint64_t v29 = __ldxr(p_shared_owners);
          while (__stxr(v29 + 1, p_shared_owners));
          (*(void (**)(_BYTE *, __CFError *, __CFDictionary **))&buf[16])(buf, v28, &valuePtr);
          SInt32 v30 = (std::__shared_weak_count *)v64;
          if (v64)
          {
            uint64_t v31 = (unint64_t *)(v64 + 8);
            do
              unint64_t v32 = __ldaxr(v31);
            while (__stlxr(v32 - 1, v31));
            if (!v32)
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }

          if (v28) {
            CFRelease(v28);
          }
          goto LABEL_82;
        }

        if (v25 == *MEMORY[0x1896051C0])
        {
          unsigned int v38 = a2->error + 9853;
          if (v38 > 0x2E) {
            CFIndex v39 = -1200LL;
          }
          else {
            CFIndex v39 = qword_182BD7EC0[v38];
          }
          uint64_t valuePtr = (__CFDictionary *)a2->error;
          HTTPProtocol::constructSSLCertContext(this);
          BOOL v42 = CFGetAllocator((char *)this - 16);
          uint64_t v43 = CFNumberCreate(v42, kCFNumberCFIndexType, &valuePtr);
          values = v43;
          uint64_t v44 = *((void *)this + 50);
          uint64_t v45 = CFGetAllocator((char *)this - 16);
          char v46 = v45;
          if (v44)
          {
            CFIndex Count = CFDictionaryGetCount(*((CFDictionaryRef *)this + 50));
            CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v46, Count + 1, *((CFDictionaryRef *)this + 50));
            CFDictionarySetValue(MutableCopy, @"_kCFNetworkCFStreamSSLErrorOriginalValue", v43);
          }

          else
          {
            CFMutableDictionaryRef MutableCopy = CFDictionaryCreate( v45,  (const void **)&_kCFNetworkCFStreamSSLErrorOriginalValue,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
            uint64_t v43 = values;
          }

          if (v43) {
            CFRelease(v43);
          }
          uint64_t v49 = CFGetAllocator((char *)this - 16);
          uint64_t v28 = CFErrorCreate(v49, @"kCFErrorDomainCFNetwork", v39, MutableCopy);
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
          goto LABEL_37;
        }

        switch(v25)
        {
          case 13LL:
            uint64_t v50 = *(void *)&a2->error;
            values = Mutable;
            int v70 = v14;
            do
              unint64_t v51 = __ldxr(p_shared_owners);
            while (__stxr(v51 + 1, p_shared_owners));
            uint64_t valuePtr = v12;
            uint64_t v64 = 3221225472LL;
            uint64_t v65 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_12;
            int v66 = &__block_descriptor_40_e17_____CFError__8__0l;
            int v67 = this;
            HTTPProtocol::asyncTransformError( (std::__shared_weak_count_vtbl *)this,  13LL,  v50,  (uint64_t *)&values,  (uint64_t)&valuePtr,  (uint64_t)buf);
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&values);
            goto LABEL_82;
          case 12LL:
            uint64_t v55 = *(void *)&a2->error;
            values = Mutable;
            int v70 = v14;
            do
              unint64_t v56 = __ldxr(p_shared_owners);
            while (__stxr(v56 + 1, p_shared_owners));
            uint64_t valuePtr = v12;
            uint64_t v64 = 3221225472LL;
            uint64_t v65 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_11;
            int v66 = &__block_descriptor_40_e17_____CFError__8__0l;
            int v67 = this;
            HTTPProtocol::asyncTransformError( (std::__shared_weak_count_vtbl *)this,  12LL,  v55,  (uint64_t *)&values,  (uint64_t)&valuePtr,  (uint64_t)buf);
            do
              unint64_t v37 = __ldaxr(p_shared_owners);
            while (__stlxr(v37 - 1, p_shared_owners));
            break;
          case 10LL:
            uint64_t v40 = *(void *)&a2->error;
            values = Mutable;
            int v70 = v14;
            do
              unint64_t v41 = __ldxr(p_shared_owners);
            while (__stxr(v41 + 1, p_shared_owners));
            uint64_t valuePtr = v12;
            uint64_t v64 = 3221225472LL;
            uint64_t v65 = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_10;
            int v66 = &__block_descriptor_40_e17_____CFError__8__0l;
            int v67 = this;
            HTTPProtocol::asyncTransformError( (std::__shared_weak_count_vtbl *)this,  10LL,  v40,  (uint64_t *)&values,  (uint64_t)&valuePtr,  (uint64_t)buf);
            do
              unint64_t v37 = __ldaxr(p_shared_owners);
            while (__stlxr(v37 - 1, p_shared_owners));
            break;
          default:
            double v57 = CFGetAllocator((char *)this - 16);
            CFErrorWithStreamCFStreamError Error = __cfnCreateCFError( v57,  @"kCFErrorDomainCFNetwork",  -998LL,  v58,  v59,  v60,  v61,  v62,  0LL);
            goto LABEL_36;
        }
      }

      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }

void sub_182ADD3E4(_Unwind_Exception *a1)
{
}

uint64_t ___ZN12HTTPProtocol14bytesAvailableEPU27objcproto16OS_dispatch_data8NSObject_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, const UInt8 *a4, uint64_t a5)
{
  if (!a5) {
    return 1LL;
  }
  uint64_t v7 = *(void *)(a1 + 32);
  int v8 = *(_DWORD *)(v7 + 200);
  *(void *)(v7 + 520) += a5;
  if (v8 - 5 < 2 || v8 == 3)
  {
    if (*(void *)(v7 + 216) {
      || (unint64_t v10 = CFGetAllocator((CFTypeRef)(v7 - 16)),
    }
          uint64_t v11 = CFURLDataDecoderCreateWithContentEncoding(v10, v8),
          (*(void *)(v7 + 2CFRelease((char *)this - 16) = v11) != 0LL))
    {
      CFIndex v12 = *(const void **)(v7 + 224);
      if (v12)
      {
        CFIndex v13 = CFDataGetLength(*(CFDataRef *)(v7 + 224)) + a5;
        uint64_t v14 = CFGetAllocator(v12);
        CFMutableDictionaryRef MutableCopy = CFDataCreateMutableCopy(v14, v13, (CFDataRef)v12);
        uint64_t v16 = MutableCopy;
        if (MutableCopy)
        {
          CFDataAppendBytes(MutableCopy, a4, a5);
          CFIndex Length = CFDataGetLength(v16);
          if (Length != CFDataGetLength((CFDataRef)v12) + a5
            && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "unable to append to this buffer",  buf,  2u);
          }
        }

        unsigned int v18 = *(const void **)(v7 + 224);
        *(void *)(v7 + 224) = 0LL;
        if (v18) {
          CFRelease(v18);
        }
        if (!v16) {
          goto LABEL_38;
        }
      }

      else
      {
        uint64_t v23 = CFGetAllocator((CFTypeRef)(v7 - 16));
        uint64_t v16 = CFDataCreateWithBytesNoCopy(v23, a4, a5, (CFAllocatorRef)*MEMORY[0x189604DC8]);
        if (!v16)
        {
LABEL_38:
          uint64_t v22 = -998LL;
          goto LABEL_39;
        }
      }

      buf[0] = 0;
      uint64_t v24 = CFURLDataDecoderDecodeData(*(void *)(v7 + 216), (uint64_t)v16, (uint64_t)buf);
      if (v24) {
        BOOL v25 = 1;
      }
      else {
        BOOL v25 = buf[0] == 0;
      }
      if (!v25)
      {
        unint64_t v36 = CFGetAllocator((CFTypeRef)(v7 - 16));
        *(void *)(v7 + 224) = CFDataCreateCopy(v36, v16);
        unint64_t v37 = v16;
        goto LABEL_93;
      }

      CFNumberRef v21 = (const __CFData *)v24;
      CFRelease(v16);
      if (!v21)
      {
        uint64_t v22 = -1015LL;
        goto LABEL_39;
      }

      goto LABEL_30;
    }

LABEL_92:
  unint64_t v37 = v21;
LABEL_93:
  CFRelease(v37);
  return 1LL;
}

const unsigned __int8 *_findDelimiterInBytes( const unsigned __int8 *__s, size_t __n, const unsigned __int8 *a3, size_t a4, const unsigned __int8 **a5, unsigned __int8 *a6)
{
  size_t v10 = __n;
  uint64_t v11 = __s;
  CFIndex v12 = &__s[__n];
  *a5 = 0LL;
  *a6 = 0;
  int v13 = *a3;
  while (1)
  {
    uint64_t v14 = (char *)memchr(v11, v13, v10);
    unint64_t v15 = (unint64_t)v14;
    if (!v14) {
      break;
    }
    uint64_t v16 = (const unsigned __int8 *)&v14[a4];
    if (!memcmp(a3, v14, a4))
    {
      if (v16 + 2 < v12 && *v16 == 45 && v16[1] == 45)
      {
        *a5 = v16 + 2;
        *a6 = 1;
      }

      else
      {
        uint64_t v17 = (char *)memchr((const void *)(v15 + a4), 10, v12 - v16);
        if (!v17) {
          uint64_t v17 = (char *)memchr((const void *)(v15 + a4), 13, v12 - v16 - 1);
        }
        if (v17) {
          unsigned int v18 = (const unsigned __int8 *)(v17 + 1);
        }
        else {
          unsigned int v18 = 0LL;
        }
        *a5 = v18;
      }

      return (const unsigned __int8 *)v15;
    }

    v10 += (size_t)&v11[~v15];
    uint64_t v11 = (const unsigned __int8 *)(v15 + 1);
  }

  if (!v14) {
    return v12;
  }
  return (const unsigned __int8 *)v15;
}

void HTTPProtocol::fixupAndSendMultiPartData(HTTPProtocol *this, UInt8 *newBytes, CFIndex numBytes, int a4)
{
  if (a4)
  {
    unint64_t v7 = *((_DWORD *)this + 48) & 0xFFFFF7FF | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    *((_DWORD *)this + 48) &= ~0x800u;
    *((_WORD *)this + 9_Block_object_dispose((const void *)(v1 - 48), 8) = WORD2(v7);
    int v8 = (__CFHTTPMessage *)*((void *)this + 31);
    if (v8)
    {
      int v9 = CFHTTPMessageCopyBody(v8);
      CFDataRef theData = v9;
      size_t v10 = (const void *)*((void *)this + 31);
      *((void *)this + 31) = 0LL;
      if (v10) {
        CFRelease(v10);
      }
      if (v9)
      {
        uint64_t v11 = CFGetAllocator((char *)this - 16);
        BOOL v12 = _checkForDataToDeliver(v11, (uint64_t *)this + 33, &theData);
        int v13 = (char *)theData;
        if (v12)
        {
          CFIndex Length = CFDataGetLength(theData);
          HTTPProtocol::sendDidLoadData(this, v13, Length);
        }

        if (v13) {
          CFRelease(v13);
        }
      }
    }
  }

  if (numBytes)
  {
    if ((*((_DWORD *)this + 48) & 0x800) != 0)
    {
      BOOL v25 = (const __CFData *)*((void *)this + 32);
      if (v25 && CFDataGetLength(v25) == numBytes)
      {
        CFStringRef v26 = CFGetAllocator((char *)this - 16);
      }

      else
      {
        CFIndex v27 = CFGetAllocator((char *)this - 16);
        CFDataRef theData = CFDataCreate(v27, newBytes, numBytes);
        uint64_t v28 = CFGetAllocator((char *)this - 16);
        BOOL v29 = _checkForDataToDeliver(v28, (uint64_t *)this + 33, &theData);
        CFDataRef v30 = theData;
        if (v29) {
          HTTPProtocol::sendDidLoadData(this, (char *)theData, numBytes);
        }
        if (v30) {
          CFRelease(v30);
        }
      }
    }

    else
    {
      Response = (__CFHTTPMessage *)*((void *)this + 31);
      if (!Response)
      {
        uint64_t v16 = CFGetAllocator((char *)this - 16);
        Response = CFHTTPMessageCreateResponse(v16, 200LL, 0LL, @"HTTP/1.0");
        *((void *)this + 31) = Response;
      }

      CFHTTPMessageAppendBytes(Response, newBytes, numBytes);
      if (CFHTTPMessageIsHeaderComplete(*((CFHTTPMessageRef *)this + 31)))
      {
        *((_DWORD *)this + 48) |= 0x800u;
        uint64_t v17 = CFGetAllocator((char *)this - 16);
        uint64_t v18 = *(void *)([*((id *)this + 26) _inner] + 88);
        if (v18) {
          uint64_t v19 = (__CFHTTPMessage *)(v18 - 16);
        }
        else {
          uint64_t v19 = 0LL;
        }
        CFHTTPMessageRef Copy = CFHTTPMessageCreateCopy(v17, v19);
        CFDictionaryRef v21 = CFHTTPMessageCopyAllHeaderFields(*((CFHTTPMessageRef *)this + 31));
        uint64_t v22 = v21;
        if (!v21)
        {
          CFDataRef theData = 0LL;
          int64_t v53 = 0LL;
          unint64_t v54 = (const void **)v55;
          goto LABEL_34;
        }

        CFDataRef theData = (CFDataRef)CFRetain(v21);
        unint64_t Count = CFDictionaryGetCount(v22);
        int64_t v53 = Count;
        if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
        {
          unint64_t v54 = 0LL;
          goto LABEL_34;
        }

        if (Count > 0x1E)
        {
          uint64_t v24 = (const void **)malloc(8 * Count);
          unint64_t v54 = v24;
          if (!v24) {
            goto LABEL_34;
          }
        }

        else
        {
          uint64_t v24 = (const void **)v55;
          unint64_t v54 = (const void **)v55;
        }

        CFDictionaryGetKeysAndValues(v22, v24, 0LL);
LABEL_34:
        int64_t v56 = 0LL;
        while (1)
        {
          int64_t v31 = v56;
          if (v56 >= v53) {
            break;
          }
          ++v56;
          unint64_t v32 = (const __CFString *)v54[v31];
          int Value = (const __CFString *)CFDictionaryGetValue(v22, v32);
          CFHTTPMessageSetHeaderFieldValue(Copy, v32, Value);
        }

        if (v22) {
          CFRelease(v22);
        }
        CFGetAllocator((char *)this - 16);
        uint64_t v34 = [*((id *)this + 26) _inner];
        id v35 = CFURLResponseCreateWithHTTPResponse(v34, *(const void **)(v34 + 8), (uint64_t)Copy, 2);
        *((void *)this + 33) = CFURLResponseGetExpectedContentLength(v35);
        if (*((void *)this + 59))
        {
          uint64_t v36 = [v35 _inner];
          unint64_t v37 = (const void *)*((void *)this + 59);
          unsigned int v38 = *(const void **)(v36 + 80);
          if (v38 != v37)
          {
            if (v38) {
              CFRelease(v38);
            }
            if (v37) {
              CFTypeRef v39 = CFRetain(v37);
            }
            else {
              CFTypeRef v39 = 0LL;
            }
            *(void *)(v36 + 80) = v39;
          }
        }

        unint64_t v40 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        if ((v40 & 0x200000000LL) != 0)
        {
          *(_BYTE *)([v35 _inner] + 97) = 1;
          unint64_t v40 = *((unsigned int *)this + 48) | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
        }

        if ((v40 & 0x400000000LL) != 0) {
          *(_BYTE *)([v35 _inner] + 96) = 1;
        }
        CFRelease(Copy);
        uint64_t v41 = *((void *)this + 12);
        if (v41)
        {
          uint64_t v42 = (*(uint64_t (**)(void))(*(void *)v41 + 16LL))(*((void *)this + 12));
          uint64_t v43 = (void *)MEMORY[0x186E1578C](v42);
          (*(void (**)(void, id))(**((void **)this + 12) + 64LL))(*((void *)this + 12), v35);
          objc_autoreleasePoolPop(v43);
          (*(void (**)(uint64_t))(*(void *)v41 + 24LL))(v41);
        }

        uint64_t v44 = (__CFHTTPMessage *)*((void *)this + 31);
        if (v44)
        {
          uint64_t v45 = CFHTTPMessageCopyBody(v44);
          CFDataRef v51 = v45;
          BOOL v46 = (const void *)*((void *)this + 31);
          *((void *)this + 31) = 0LL;
          if (v46) {
            CFRelease(v46);
          }
          if (v45)
          {
            int v47 = CFGetAllocator((char *)this - 16);
            BOOL v48 = _checkForDataToDeliver(v47, (uint64_t *)this + 33, &v51);
            CFTypeRef v49 = (char *)v51;
            if (v48)
            {
              CFIndex v50 = CFDataGetLength(v51);
              HTTPProtocol::sendDidLoadData(this, v49, v50);
            }

            if (v49) {
              CFRelease(v49);
            }
          }
        }

        CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&theData);
      }
    }
  }

void sub_182ADE018(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL _checkForDataToDeliver(const __CFAllocator *a1, uint64_t *a2, const __CFData **a3)
{
  if (*a2 < 0)
  {
    CFIndex Length = CFDataGetLength(*a3);
  }

  else if (*a2)
  {
    CFIndex v6 = CFDataGetLength(*a3);
    CFIndex Length = *a2;
    if (v6 <= *a2)
    {
      CFIndex Length = CFDataGetLength(*a3);
    }

    else
    {
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(a1, *a2);
      BytePtr = CFDataGetBytePtr(*a3);
      CFDataAppendBytes(Mutable, BytePtr, Length);
      if (*a3) {
        CFRelease(*a3);
      }
      *a3 = Mutable;
    }

    *a2 -= Length;
  }

  else
  {
    CFIndex Length = 0LL;
  }

  return Length > 0;
}

void HTTPProtocol::deliverUnhandledResponse(HTTPProtocol *this)
{
  if ((*((_DWORD *)this + 183) | 2) == 2)
  {
    uint64_t v2 = (dispatch_data_s *)*((void *)this + 90);
    if (v2)
    {
      HTTPProtocol::bytesAvailable((uint64_t)this, v2);
      dispatch_release(*((dispatch_object_t *)this + 90));
      *((void *)this + 90) = 0LL;
    }

    uint64_t v3 = *((unsigned int *)this + 48);
    uint64_t v4 = *((unsigned __int16 *)this + 98);
    *((_DWORD *)this + 4_Block_object_dispose((const void *)(v1 - 48), 8) = v3;
    *((_WORD *)this + 9_Block_object_dispose((const void *)(v1 - 48), 8) = v4 & 0xDBFF;
    *((_DWORD *)this + 183) = 0;
    if ((v3 & 0x80) == 0)
    {
      *((_DWORD *)this + 4_Block_object_dispose((const void *)(v1 - 48), 8) = v3 & 0xFFFFFFFB;
      *((_WORD *)this + 9_Block_object_dispose((const void *)(v1 - 48), 8) = ((v3 | (v4 << 32)) & 0xDBFFFFFFFFFBuLL) >> 32;
      HTTPProtocol::endEncountered(this);
    }
  }

void HTTPProtocol::storeCredentials(HTTPProtocol *this)
{
  uint64_t v1 = *((void *)this + 44);
  if (v1 && *((void *)this + 47))
  {
    if (*(_DWORD *)(v1 + 52) != 1)
    {
      uint64_t v3 = *((void *)this + 47);
      uint64_t v4 = v3 + 16;
      if (!v3) {
        uint64_t v4 = 0LL;
      }
      (*(void (**)(void, void, void, void))(**((void **)this + 87) + 56LL))( *((void *)this + 87),  *((void *)this + 44),  *(void *)(v4 + 24),  *((void *)this + 10));
    }
  }

void _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_( std::__shared_weak_count_vtbl **a1)
{
  uint64_t v2 = (std::__shared_weak_count *)operator new(0xB0uLL);
  v2->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  v2->__shared_weak_owners_ = 0LL;
  v2->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DF90;
  AuthenticationState::AuthenticationState((AuthenticationState *)&v2[1]);
  *a1 = v4;
  a1[1] = (std::__shared_weak_count_vtbl *)v2;
  shared_owners = (std::__shared_weak_count *)v2[4].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1) {
      return;
    }
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    p_shared_weak_owners = (unint64_t *)&v2->__shared_weak_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_weak_owners);
    while (__stxr(v8 + 1, p_shared_weak_owners));
    v2[4].__vftable = v4;
    v2[4].__shared_owners_ = (uint64_t)v2;
    std::__shared_weak_count::__release_weak(shared_owners);
  }

  else
  {
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    size_t v10 = (unint64_t *)&v2->__shared_weak_owners_;
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    v2[4].__vftable = v4;
    v2[4].__shared_owners_ = (uint64_t)v2;
  }

  do
    unint64_t v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

void sub_182ADE34C(_Unwind_Exception *a1)
{
}

void ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke( void *a1, char a2, CFTypeRef cf, const void *a4)
{
  if (cf) {
    unint64_t v7 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  }
  else {
    unint64_t v7 = 0LL;
  }
  int v52 = v7;
  unint64_t v8 = (std::__shared_weak_count *)operator new(0x20uLL);
  v8->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DBC0;
  v8->__shared_weak_owners_ = 0LL;
  v8[1].__vftable = v7;
  int64_t v53 = v8;
  if (a4) {
    size_t v10 = (std::__shared_weak_count_vtbl *)CFRetain(a4);
  }
  else {
    size_t v10 = 0LL;
  }
  CFIndex v50 = v10;
  unint64_t v11 = (std::__shared_weak_count *)operator new(0x20uLL);
  v11->__shared_owners_ = 0LL;
  unint64_t v12 = (unint64_t *)&v11->__shared_owners_;
  v11->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE30;
  v11->__shared_weak_owners_ = 0LL;
  v11[1].__vftable = v10;
  CFDataRef v51 = v11;
  uint64_t v14 = a1[4];
  int v13 = (std::__shared_weak_count *)a1[5];
  uint64_t v15 = *(void *)(v14 + 24);
  v41[0] = MEMORY[0x1895F87A8];
  v41[1] = 3321888768LL;
  v41[2] = ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke_2;
  v41[3] = &__block_descriptor_97_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE64c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE_e5_v8__0l;
  v41[4] = v14;
  uint64_t v42 = v13;
  if (v13)
  {
    uint64_t v16 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }

  char v49 = a2;
  uint64_t v43 = v7;
  uint64_t v44 = v8;
  do
    unint64_t v18 = __ldxr(p_shared_owners);
  while (__stxr(v18 + 1, p_shared_owners));
  uint64_t v45 = v10;
  BOOL v46 = v11;
  do
    unint64_t v19 = __ldxr(v12);
  while (__stxr(v19 + 1, v12));
  char v20 = (std::__shared_weak_count *)a1[7];
  uint64_t v47 = a1[6];
  BOOL v48 = v20;
  if (v20)
  {
    CFDictionaryRef v21 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }

  (*(void (**)(uint64_t, void *))(*(void *)v15 + 96LL))(v15, v41);
  uint64_t v23 = v48;
  if (v48)
  {
    uint64_t v24 = (unint64_t *)&v48->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  CFStringRef v26 = v46;
  if (v46)
  {
    CFIndex v27 = (unint64_t *)&v46->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  BOOL v29 = v44;
  if (v44)
  {
    CFDataRef v30 = (unint64_t *)&v44->__shared_owners_;
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  unint64_t v32 = v42;
  if (v42)
  {
    CFIndex v33 = (unint64_t *)&v42->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

  id v35 = v51;
  if (v51)
  {
    uint64_t v36 = (unint64_t *)&v51->__shared_owners_;
    do
      unint64_t v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }

  unsigned int v38 = v53;
  if (v53)
  {
    CFTypeRef v39 = (unint64_t *)&v53->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

void sub_182ADE66C(_Unwind_Exception *a1)
{
}

void *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    unint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE( uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 48);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void ___ZN12HTTPProtocol48asynchronouslyAddAuthenticatorHeadersAndContinueEP15__CFHTTPMessage_block_invoke_2( uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v2 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 792LL);
    int v4 = *(unsigned __int8 *)(a1 + 96);
    uint64_t v5 = *(void *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 64);
    int v10 = 138544130;
    uint64_t v11 = v3;
    __int16 v12 = 1024;
    int v13 = v4;
    __int16 v14 = 2112;
    uint64_t v15 = v5;
    __int16 v16 = 2112;
    uint64_t v17 = v6;
    _os_log_impl( &dword_18298D000,  v2,  OS_LOG_TYPE_DEFAULT,  "%{public}@ protocol received continueLoad=%d, headers=%@ req=%@",  (uint8_t *)&v10,  0x26u);
  }

  if (*(_BYTE *)(a1 + 96))
  {
    unint64_t v7 = *(const __CFDictionary **)(a1 + 48);
    if (v7)
    {
      if (CFDictionaryGetCount(v7)) {
        _CFHTTPMessageSetMultipleHeaderFields(*(__CFHTTPMessage **)(a1 + 80), *(CFDictionaryRef *)(a1 + 48));
      }
    }

    HTTPProtocol::asynchronouslyCreateAndOpenStream_WithMessage_AfterCookiesAndAuthenticatorHeaders( *(HTTPProtocol **)(a1 + 32),  *(os_unfair_lock_s **)(a1 + 80));
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    unint64_t v8 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 792LL);
      int v10 = 138543362;
      uint64_t v11 = v9;
      _os_log_impl( &dword_18298D000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}@ authentication client does not want to continue load",  (uint8_t *)&v10,  0xCu);
    }

    HTTPProtocol::sendError(*(HTTPProtocol **)(a1 + 32), (const __CFString *)0xFFFFFFFFFFFFFC19LL);
  }

void *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE64c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  uint64_t v11 = a2[11];
  result[10] = a2[10];
  result[11] = v11;
  if (v11)
  {
    __int16 v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE64c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE80c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE( uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  uint64_t v2 = a1 + 48;
  uint64_t v3 = a1 + 64;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void std::__shared_ptr_pointer<_CFURLRequest const*,Deleter_CFRelease,std::allocator<_CFURLRequest const>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<_CFURLRequest const*,Deleter_CFRelease,std::allocator<_CFURLRequest const>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void std::__shared_ptr_emplace<APSRelayTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CD50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<APSRelayTransaction>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CD50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<APSRelayTransaction>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void APSRelayTransactionWrapper::~APSRelayTransactionWrapper(APSRelayTransactionWrapper *this)
{
  *(void *)this = off_189C0CBA8;
  *((void *)this + 3) = &unk_189C0CC80;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
}

{
  *(void *)this = off_189C0CBA8;
  *((void *)this + 3) = &unk_189C0CC80;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 32);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this + 1), this);
}

uint64_t APSRelayTransactionWrapper::copyProperty()
{
  return 0LL;
}

BOOL APSRelayTransactionWrapper::setProperty(uint64_t a1, int a2, const void *a3)
{
  return APSRelayTransaction::setProperty(*(void *)(a1 + 32), a2, a3);
}

uint64_t APSRelayTransactionWrapper::canScheduleAndOpenWithHandlerAsync(APSRelayTransactionWrapper *this)
{
  return 1LL;
}

uint64_t APSRelayTransactionWrapper::scheduleAndOpenWithHandler( uint64_t a1, const CoreSchedulingSet *a2, void *a3, void (**a4)(void, void))
{
  return 1LL;
}

void APSRelayTransactionWrapper::closeAndClearHandler(APSRelayTransaction **this)
{
}

void APSRelayTransactionWrapper::updateScheduling(APSRelayTransaction **this, const CoreSchedulingSet *a2)
{
}

void APSRelayTransactionWrapper::setBodyStreamBeforeOpening(APSRelayTransaction **this, __CFReadStream *a2)
{
}

uint64_t APSRelayTransactionWrapper::rawBytesSent(APSRelayTransactionWrapper *this)
{
  return *(void *)(*((void *)this + 4) + 248LL);
}

uint64_t APSRelayTransactionWrapper::rawBytesReceived(APSRelayTransactionWrapper *this)
{
  return *(void *)(*((void *)this + 4) + 256LL);
}

uint64_t APSRelayTransactionWrapper::getConnectionIdentifier(APSRelayTransactionWrapper *this)
{
  return 0LL;
}

uint64_t APSRelayTransactionWrapper::copyTrust(APSRelayTransactionWrapper *this)
{
  return 0LL;
}

void APSRelayTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *a2;
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v3 + 128), v4, (uint64_t)v5);
    uint64_t v8 = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v3 + 128), v4, 0LL);
  }

uint64_t APSRelayTransactionWrapper::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  uint64_t v4 = *(void *)(v2 + 128);
  uint64_t v3 = *(void *)(v2 + 136);
  *a2 = v4;
  a2[1] = v3;
  if (v3)
  {
    uint64_t v5 = (unint64_t *)(v3 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  return this;
}

uint64_t APSRelayTransactionWrapper::setTransactionMetrics(uint64_t this, __CFN_TransactionMetrics *a2)
{
  uint64_t v2 = *(void *)(this + 32);
  *(void *)(v2 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 80) = a2;
  *(void *)(*(void *)(v2 + 48) + 176LL) = a2;
  return this;
}

uint64_t APSRelayTransactionWrapper::_meta_retain(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(APSRelayTransactionWrapper *))(*(void *)this + 40LL))(this);
}

uint64_t APSRelayTransactionWrapper::_meta_release(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(APSRelayTransactionWrapper *))(*(void *)this + 48LL))(this);
}

void non-virtual thunk to'APSRelayTransactionWrapper::~APSRelayTransactionWrapper( APSRelayTransactionWrapper *this)
{
  *((void *)this - 3) = off_189C0CBA8;
  *(void *)this = &unk_189C0CC80;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

{
  char *v2;
  *((void *)this - 3) = off_189C0CBA8;
  uint64_t v2 = (char *)this - 24;
  *(void *)this = &unk_189C0CC80;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
  CFAllocatorDeallocate(*((CFAllocatorRef *)this - 2), v2);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::_meta_retain(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((void *)this - 3) + 40LL))((char *)this - 24);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::_meta_release(APSRelayTransactionWrapper *this)
{
  return (*(uint64_t (**)(char *))(*((void *)this - 3) + 48LL))((char *)this - 24);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::copyProperty()
{
  return 0LL;
}

BOOL non-virtual thunk to'APSRelayTransactionWrapper::setProperty(uint64_t a1, int a2, const void *a3)
{
  return APSRelayTransaction::setProperty(*(void *)(a1 + 8), a2, a3);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::canScheduleAndOpenWithHandlerAsync( APSRelayTransactionWrapper *this)
{
  return 1LL;
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::scheduleAndOpenWithHandler( uint64_t a1, const CoreSchedulingSet *a2, void *a3, void (**a4)(void, void))
{
  return 1LL;
}

void non-virtual thunk to'APSRelayTransactionWrapper::closeAndClearHandler(APSRelayTransaction **this)
{
}

void non-virtual thunk to'APSRelayTransactionWrapper::updateScheduling( APSRelayTransaction **this, const CoreSchedulingSet *a2)
{
}

void non-virtual thunk to'APSRelayTransactionWrapper::setBodyStreamBeforeOpening( APSRelayTransaction **this, __CFReadStream *a2)
{
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::rawBytesSent(APSRelayTransactionWrapper *this)
{
  return *(void *)(*((void *)this + 1) + 248LL);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::rawBytesReceived(APSRelayTransactionWrapper *this)
{
  return *(void *)(*((void *)this + 1) + 256LL);
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::getConnectionIdentifier( APSRelayTransactionWrapper *this)
{
  return 0LL;
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::copyTrust(APSRelayTransactionWrapper *this)
{
  return 0LL;
}

void non-virtual thunk to'APSRelayTransactionWrapper::setProxy(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *a2;
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v3 + 128), v4, (uint64_t)v5);
    uint64_t v8 = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  else
  {
    std::shared_ptr<__CFString const>::operator=[abi:nn180100]((void *)(v3 + 128), v4, 0LL);
  }

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::getProxy@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 8);
  uint64_t v4 = *(void *)(v2 + 128);
  uint64_t v3 = *(void *)(v2 + 136);
  *a2 = v4;
  a2[1] = v3;
  if (v3)
  {
    uint64_t v5 = (unint64_t *)(v3 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  return this;
}

uint64_t non-virtual thunk to'APSRelayTransactionWrapper::setTransactionMetrics( uint64_t this, __CFN_TransactionMetrics *a2)
{
  uint64_t v2 = *(void *)(this + 8);
  *(void *)(v2 + 2std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 80) = a2;
  *(void *)(*(void *)(v2 + 48) + 176LL) = a2;
  return this;
}

uint64_t ___ZN12HTTPProtocol81asynchronouslyCreateAndOpenStream_WithMessage_AfterCookiesAndAuthenticatorHeadersEP15__CFHTTPMessage_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 48), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 3196LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 48), 8) = "none";
  return result;
}

void std::__shared_ptr_pointer<__CFHTTPMessage *,Deleter_CFRelease,std::allocator<__CFHTTPMessage>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke_2( uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (theDict && CFDictionaryGetCount(theDict)) {
    _CFHTTPMessageSetMultipleHeaderFields(*(__CFHTTPMessage **)(a1 + 40), theDict);
  }
  uint64_t v5 = *(void *)(v3 + 24);
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  v8[2] = ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke_3;
  v8[3] = &__block_descriptor_48_e5_v8__0l;
  uint64_t v6 = *(void *)(a1 + 40);
  v8[4] = v3;
  void v8[5] = v6;
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v5 + 96LL))(v5, v8);
}

void ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(HTTPProtocol **)(a1 + 32);
  HTTPProtocol::asynchronouslyAddAuthenticatorHeadersAndContinue(v2, *(CFTypeRef *)(a1 + 40));
  uint64_t v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
  CFRelease((char *)v2 - 16);
}

uint64_t ___ZN12HTTPProtocol35asynchronouslyAddCookiesAndContinueEP15__CFHTTPMessage_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 48), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 3650LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 48), 8) = "none";
  return result;
}

void std::__shared_ptr_emplace<AuthenticationState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DF90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AuthenticationState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DF90;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge(HTTPProtocol *this, __CFHTTPMessage *a2)
{
  uint64_t v187 = *MEMORY[0x1895F89C0];
  CFIndex ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(a2);
  CFIndex v8 = ResponseStatusCode;
  BOOL v9 = ResponseStatusCode == 407;
  if (ResponseStatusCode != 407 && ResponseStatusCode != 401) {
    return 0LL;
  }
  if (ResponseStatusCode == 407)
  {
    uint64_t v183 = 0LL;
    CFArrayRef v184 = 0LL;
    BOOL v10 = CFHTTPMessageGetResponseStatusCode(a2) == 407;
    Authentication = (_CFHTTPAuthentication *)_CFHTTPMessageGetAuthentication(a2, v10);
    if (Authentication)
    {
      CFHTTPAuthenticationIsValid(Authentication, &error);
    }

    else
    {
      error.CFStreamError error = 0;
      error.CFIndex domain = 0LL;
    }
  }

  else
  {
    uint64_t v12 = *((void *)this + 34);
    if (v12)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v12 + 176LL))(&v183);
      if (v183)
      {
        CFIndex v13 = *(void *)(v183 + 104);
        __int16 v14 = *(std::__shared_weak_count **)(v183 + 112);
        error.CFIndex domain = v13;
        *(void *)&error.CFStreamError error = v14;
        if (v14)
        {
          p_shared_owners = (unint64_t *)&v14->__shared_owners_;
          do
            unint64_t v16 = __ldxr(p_shared_owners);
          while (__stxr(v16 + 1, p_shared_owners));
        }

        BOOL v18 = v13
           && (*(_DWORD *)(v13 + 24) & 0xFFFFFFFE) == 2
           && (uint64_t v17 = *(HTTPAuthentication **)(v13 + 8)) != 0LL
           && HTTPAuthentication::isConnectionBasedAuth(v17) != 0;
        if (v14)
        {
          unint64_t v19 = (unint64_t *)&v14->__shared_owners_;
          do
            unint64_t v20 = __ldaxr(v19);
          while (__stlxr(v20 - 1, v19));
          if (!v20)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }

        if (v18)
        {
          EndpointCred = (const void *)AuthenticationState::getEndpointCred( *(AuthenticationState **)(v183 + 104),  *(std::__shared_weak_count **)(v183 + 112));
          if (EndpointCred)
          {
            if (CFNLog::onceToken != -1) {
              dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
            }
            unint64_t v22 = (os_log_s *)CFNLog::logger;
            if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
            {
              CFIndex v23 = *((void *)this + 99);
              LODWORD(error.domain) = 138543362;
              *(CFIndex *)((char *)&error.domain + 4) = v23;
              _os_log_impl( &dword_18298D000,  v22,  OS_LOG_TYPE_DEFAULT,  "%{public}@ will use existing endpoint credentials",  (uint8_t *)&error,  0xCu);
            }

            setTypeProperty<_CFURLCredential const*>((CFTypeRef *)this + 44, EndpointCred);
            _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)&error);
            std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 776, (__int128 *)&error.domain);
            std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&error);
            uint64_t v24 = *((void *)this + 97);
            int v25 = (*(uint64_t (**)(void))(**((void **)this + 35) + 88LL))(*((void *)this + 35));
            AuthenticationState::setConnectionType(v24, v25);
            uint64_t v26 = *((void *)this + 97);
            if (a2)
            {
              if (*((_BYTE *)a2 + 40)) {
                CFIndex v27 = (char *)a2 + 16;
              }
              else {
                CFIndex v27 = 0LL;
              }
            }

            else
            {
              CFIndex v27 = 0LL;
            }

            (*(void (**)(uint64_t, char *, void))(*(void *)v26 + 16LL))(v26, v27, 0LL);
            (*(void (**)(void))(**((void **)this + 34) + 184LL))(*((void *)this + 34));
            goto LABEL_163;
          }
        }
      }
    }

    else
    {
      uint64_t v183 = 0LL;
      CFArrayRef v184 = 0LL;
    }
  }

  unsigned int v178 = (char *)this + 40;
  if (*((_BYTE *)this + 41)) {
    unint64_t v28 = (unsigned __int8 *)&HTTPProtocol::inUnitTestMode;
  }
  else {
    unint64_t v28 = (unsigned __int8 *)this + 40;
  }
  int v29 = *v28;
  uint64_t KerberosAccountBroker = KerberosAccountBroker::getKerberosAccountBroker(*((KerberosAccountBroker **)this + 10), v7);
  BOOL v31 = 0;
  int v177 = v9;
  if (v8 != 407 && KerberosAccountBroker) {
    BOOL v31 = (*((_DWORD *)this + 48) & 0x8000000) == 0LL;
  }
  for (char i = 0; ; char i = 1)
  {
    uint64_t v33 = *((void *)this + 97);
    int v34 = (*(uint64_t (**)(void))(**((void **)this + 35) + 88LL))(*((void *)this + 35));
    AuthenticationState::setConnectionType(v33, v34);
    AuthenticationState::setOption(*((void *)this + 97), 0, v29 != 0);
    AuthenticationState::setOption(*((void *)this + 97), 1, v31);
    AuthenticationState::setOption( *((void *)this + 97),  2,  objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_enableOAuthBearerTokenChallenges"));
    uint64_t v35 = *((void *)this + 97);
    if (a2)
    {
      uint64_t v36 = *((_BYTE *)a2 + 40) ? (char *)a2 + 16 : 0LL;
    }

    else
    {
      uint64_t v36 = 0LL;
    }

    uint64_t v37 = *((void *)this + 34);
    uint64_t v38 = v37 ? (*(uint64_t (**)(uint64_t))(*(void *)v37 + 112LL))(v37) : 0LL;
    (*(void (**)(uint64_t, char *, uint64_t))(*(void *)v35 + 16LL))(v35, v36, v38);
    if ((i & 1) != 0
      || AuthenticationState::isEmpty(*((AuthenticationState **)this + 97))
      || AuthenticationState::isValid(*((void *)this + 97), 0))
    {
      break;
    }

    if (v8 == 407 && (*((_DWORD *)this + 48) & 0x400000) == 0)
    {
      uint64_t Auth = AuthenticationState::getAuth(*((AuthenticationState **)this + 97), 1);
      if (Auth)
      {
        if (*(void *)(Auth + 88) == 4LL && *(_DWORD *)(Auth + 96) == 4294966295LL)
        {
          uint64_t v40 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648LL))(this);
          if (v40)
          {
            uint64_t v41 = *(void *)(v40 + 40);
            if (v41)
            {
              uint64_t v42 = (const void *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)this + 87) + 80LL))( *((void *)this + 87),  v41,  *((void *)this + 10));
              if (v42)
              {
                (*(void (**)(void, const void *, uint64_t, void))(**((void **)this + 87) + 72LL))( *((void *)this + 87),  v42,  v41,  *((void *)this + 10));
                CFRelease(v42);
              }
            }
          }
        }
      }
    }

    AuthenticationState::resetInvalid(*((AuthenticationState **)this + 97));
  }

  if (v8 == 407)
  {
  }

  else if (!*((void *)this + 44))
  {
    goto LABEL_86;
  }

  uint64_t v43 = (AuthenticationState *)*((void *)this + 97);
  if (a2)
  {
    if (*((_BYTE *)a2 + 40)) {
      uint64_t v44 = (__CFHTTPMessage *)((char *)a2 + 16);
    }
    else {
      uint64_t v44 = 0LL;
    }
  }

  else
  {
    uint64_t v44 = 0LL;
  }

  if (v8 == 407) {
    uint64_t v45 = (const _CFURLCredential *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this);
  }
  else {
    uint64_t v45 = (const _CFURLCredential *)*((void *)this + 44);
  }
  AuthenticationState::updateState(v43, v44, 0LL, v45, *((__SecTrust **)this + 57));
LABEL_86:
  uint64_t v46 = AuthenticationState::getAuth(*((AuthenticationState **)this + 97), v8 == 407);
  uint64_t v48 = v46;
  if (v46)
  {
    int v49 = URLProtectionSpace::authSchemeForAuth((URLProtectionSpace *)(v46 - 16), v47);
    int v50 = v49;
    if (v49 == 9)
    {
      if (!*((void *)this + 44) && (*((_DWORD *)this + 48) & 0x40000000) != 0)
      {
        CFDataRef v51 = *(const __CFURL **)([*((id *)this + 11) _inner] + 8);
        if (v51) {
          int v52 = CFURLCopyUserName(v51);
        }
        else {
          int v52 = 0LL;
        }
        CFOptionFlags v86 = (const __CFString *)HTTPAuthentication::copyRealm((HTTPAuthentication *)v48);
        CFAllocatorRef v87 = CFGetAllocator((char *)this - 16);
        uint64_t XMobileMeAuthToken = _CFURLCredentialCreateXMobileMeAuthToken((uint64_t)v87, v52, 0LL, v86);
        *((void *)this + 44) = XMobileMeAuthToken;
        if (XMobileMeAuthToken)
        {
          if (*(_DWORD *)(XMobileMeAuthToken + 48) != 4
            || !(*(unsigned int (**)(uint64_t))(*(void *)(XMobileMeAuthToken + 16) + 144LL))(XMobileMeAuthToken + 16))
          {
            id v89 = (const void *)*((void *)this + 44);
            *((void *)this + 44) = 0LL;
            if (v89) {
              CFRelease(v89);
            }
          }
        }

        else
        {
          *((void *)this + 44) = 0LL;
        }

        int v91 = *((_DWORD *)this + 48);
        uint64_t v90 = (char *)this + 192;
        __int16 v92 = *((_WORD *)v90 + 2);
        *(_DWORD *)uint64_t v90 = v91 & 0xBFFFFFFF;
        *((_WORD *)v90 + 2) = v92;
        if (v52) {
          CFRelease(v52);
        }
        if (v86) {
          CFRelease(v86);
        }
LABEL_163:
        uint64_t v4 = 1LL;
        goto LABEL_356;
      }

void sub_182AE04E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf, uint64_t a18, char a19, uint64_t a20, char a21, uint64_t a22, char a23)
{
}

void HTTPProtocol::sendDidReceiveAuthChallenge(HTTPProtocol *this, _CFURLAuthChallenge *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v3 = *((void *)this + 12);
    if (v3)
    {
      uint64_t v5 = (*(uint64_t (**)(void))(*(void *)v3 + 16LL))(*((void *)this + 12));
      uint64_t v6 = (void *)MEMORY[0x186E1578C](v5);
      (*(void (**)(void, _CFURLAuthChallenge *))(**((void **)this + 12) + 104LL))( *((void *)this + 12),  a2);
      objc_autoreleasePoolPop(v6);
      (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
    }
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    unint64_t v7 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *((void *)this + 99);
      int v9 = 138543362;
      uint64_t v10 = v8;
      _os_log_error_impl( &dword_18298D000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}@ does not have a valid challenge so canceling",  (uint8_t *)&v9,  0xCu);
    }

    HTTPProtocol::sendError(this, (const __CFString *)0xFFFFFFFFFFFFFC19LL);
  }

void setTypeProperty<_CFURLCredential const*>(CFTypeRef *a1, CFTypeRef cf)
{
  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = cf;
}

void HTTPProtocol::askPATForCreds( HTTPProtocol *this, __CFHTTPMessage *a2, __CFArray *a3, char a4, char a5, const __CFURL *a6)
{
  uint64_t v12 = *((void *)this + 93);
  if (v12 && (uint64_t v13 = *((void *)this + 35)) != 0 && (v14 = *(void *)(v12 + 168)) != 0)
  {
    uint64_t v15 = (const void *)*((void *)this + 3);
    BOOL v67 = 0LL;
    char v68 = &v67;
    uint64_t v69 = 0x3052000000LL;
    int v70 = __Block_byref_object_copy_;
    __int16 v71 = __Block_byref_object_dispose_;
    uint64_t v61 = (__CFHTTPMessage *)MEMORY[0x1895F87A8];
    uint64_t v62 = 3221225472LL;
    int v63 = ___ZN12XTubeManager22getPATTimestampsForKeyEPK22HTTPConnectionCacheKeyPK17CoreSchedulingSet_block_invoke;
    BOOL v64 = &unk_189C18E28;
    int v65 = &v67;
    uint64_t v66 = v13;
    XTubeManager::withTubeManager(v14, v15, (uint64_t)&v61);
    unint64_t v16 = v68[5];
    _Block_object_dispose(&v67, 8);
  }

  else
  {
    unint64_t v16 = 0LL;
  }

  CFURLRef v17 = CFHTTPMessageCopyRequestURL(a2);
  CFRetain((char *)this - 16);
  BOOL v67 = this;
  BOOL v18 = operator new(0x20uLL);
  double v53 = v16;
  v18[1] = 0LL;
  unint64_t v19 = v18 + 1;
  void *v18 = off_189C0CE68;
  v18[2] = 0LL;
  v18[3] = this;
  char v68 = (HTTPProtocol **)v18;
  if (a2) {
    a2 = (__CFHTTPMessage *)CFRetain(a2);
  }
  uint64_t v61 = a2;
  unint64_t v20 = (std::__shared_weak_count *)operator new(0x20uLL);
  char v49 = a5;
  char v50 = a4;
  CFDataRef v51 = a3;
  int v52 = a6;
  unint64_t v54 = v17;
  v20->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v20->__shared_owners_;
  v20->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CDC0;
  v20->__shared_weak_owners_ = 0LL;
  v20[1].__vftable = (std::__shared_weak_count_vtbl *)a2;
  uint64_t v62 = (uint64_t)v20;
  uint64_t v48 = *((void *)this + 99);
  unint64_t v22 = (const __CFData *)objc_msgSend( (id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"),  "_sourceApplicationAuditTokenData");
  uint64_t v23 = objc_msgSend( (id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"),  "_sourceApplicationBundleIdentifier");
  uint64_t v24 = *((void *)this + 3);
  if (*(_DWORD *)(v24 + 40) != 3) {
    __assert_rtn("getDispatchQueue", "CoreSchedulingSet.h", 64, "fKind == eDispatchQueueBased");
  }
  uint64_t v25 = v23;
  uint64_t v26 = *(void **)(v24 + 56);
  int v27 = objc_msgSend((id)objc_msgSend(*((id *)this + 10), "_effectiveConfiguration"), "_inPrivateBrowsing");
  v55[0] = MEMORY[0x1895F87A8];
  v55[1] = 3321888768LL;
  v55[2] = ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke;
  v55[3] = &__block_descriptor_64_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE_e40_v24__0____CFDictionary__8____CFError__16l;
  v55[4] = this;
  int64_t v56 = (std::__shared_weak_count *)v18;
  do
    unint64_t v28 = __ldxr(v19);
  while (__stxr(v28 + 1, v19));
  CFStringRef v57 = a2;
  uint64_t v58 = v20;
  do
    unint64_t v29 = __ldxr(p_shared_owners);
  while (__stxr(v29 + 1, p_shared_owners));
  SmartBlockWithArgs<__CFDictionary const*,__CFError *>::SmartBlockWithArgs(&v59, v55);
  PrivateAccessTokens::getPATAuthHeaders(v48, v51, v22, v25, v54, v52, v26, v27, v50, v49, v53, &v59);
  CFDataRef v30 = v60;
  if (v60)
  {
    BOOL v31 = (unint64_t *)&v60->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  int v34 = *((_DWORD *)this + 48);
  uint64_t v33 = (char *)this + 192;
  __int16 v35 = *((_WORD *)v33 + 2);
  *((_DWORD *)v33 + 135) = 1;
  *(_DWORD *)uint64_t v33 = v34;
  *((_WORD *)v33 + 2) = v35 | 0x3000;
  uint64_t v36 = v58;
  if (v58)
  {
    uint64_t v37 = (unint64_t *)&v58->__shared_owners_;
    do
      unint64_t v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }

  CFTypeRef v39 = v56;
  if (v56)
  {
    uint64_t v40 = (unint64_t *)&v56->__shared_owners_;
    do
      unint64_t v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }

  uint64_t v42 = (std::__shared_weak_count *)v62;
  if (v62)
  {
    uint64_t v43 = (unint64_t *)(v62 + 8);
    do
      unint64_t v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }

  uint64_t v45 = (std::__shared_weak_count *)v68;
  if (v68)
  {
    uint64_t v46 = (unint64_t *)(v68 + 1);
    do
      unint64_t v47 = __ldaxr(v46);
    while (__stlxr(v47 - 1, v46));
    if (!v47)
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }

  if (v54) {
    CFRelease(v54);
  }
}

void sub_182AE0BA0(_Unwind_Exception *a1)
{
}

BOOL connectionTypeFromURL(const __CFURL *a1)
{
  uint64_t v1 = CFURLCopyScheme(a1);
  CFComparisonResult v2 = CFStringCompare(v1, (CFStringRef)&unk_18C5B2B50, 1uLL);
  if (v1) {
    CFRelease(v1);
  }
  return v2 == kCFCompareEqualTo;
}

uint64_t HTTPProtocol::handleKerberosChallenge( HTTPProtocol *this, int a2, __CFHTTPMessage *a3, _CFURLProtectionSpace *a4, const __CFArray *a5, int a6)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (a6)
  {
    if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648LL))(this))
    {
      uint64_t v12 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648LL))(this);
      CFTypeRef v13 = CFRetain(v12);
    }

    else
    {
      CFTypeRef v13 = 0LL;
    }

    uint64_t v15 = (uint64_t *)((char *)this + 344);
    if ((*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this))
    {
      unint64_t v16 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 616LL))(this);
      goto LABEL_11;
    }

void sub_182AE11C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef a9, CFTypeRef cf, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (v18) {
    CFRelease(v18);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (a9) {
    CFRelease(a9);
  }
  _Unwind_Resume(exception_object);
}

void HTTPProtocol::RemoveCredentialPasswordForProtectionSpace( HTTPProtocol *this, const _CFURLCredential *a2, _CFURLProtectionSpace *a3, int a4)
{
  CFAllocatorRef v7 = CFGetAllocator((char *)this - 16);
  Username = (const __CFString *)CFURLCredentialGetUsername((uint64_t)a2);
  uint64_t v10 = CFURLCredentialCreate((uint64_t)v7, Username, 0LL, v9, 2);
  if (v10)
  {
    uint64_t v11 = (const void *)v10;
    uint64_t v12 = 56LL;
    if (!a4) {
      uint64_t v12 = 64LL;
    }
    (*(void (**)(void))(**((void **)this + 87) + v12))();
    CFRelease(v11);
  }

void HTTPProtocol::performAsyncCallout( HTTPProtocol *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, unsigned __int8 a5, __CFHTTPMessage *a6, double a7)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  Helper_x8__kAOSAuthTrustInfouint64_t Key = gotLoadHelper_x8__kAOSAuthTrustInfoKey(a7);
  uint64_t v12 = *(void **)(v11 + 3120);
  if (v12) {
    BOOL v13 = v8 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    uint64_t v14 = v9;
    uint64_t v15 = (void *)*((void *)this + 57);
    unint64_t v16 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    if (v15)
    {
      *(void *)keys = *v12;
      values = v15;
      CFDictionaryRef v17 = CFDictionaryCreate( v16,  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189604E40],  MEMORY[0x189605250]);
    }

    else
    {
      CFDictionaryRef v17 = 0LL;
    }

    uint64_t delayInitStub = AOSAccountCreate_delayInitStub(Helper_x8__kAOSAuthTrustInfoKey);
    uint64_t v19 = (const void *)delayInitStub;
    if (v14) {
      BOOL v20 = delayInitStub == 0;
    }
    else {
      BOOL v20 = 1;
    }
    int v21 = v20;
    if (v20) {
      goto LABEL_29;
    }
    CFHTTPMessageCopyRequestURL(v14);
    uint64_t v42 = 0LL;
    __int128 v41 = 0u;
    __int128 v40 = 0u;
    *(_OWORD *)&keys[8] = 0u;
    *(void *)keys = 1LL;
    CFRetain((char *)this - 16);
    values = this;
    uint64_t v22 = (std::__shared_weak_count *)operator new(0x20uLL);
    v22->__shared_owners_ = 0LL;
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    v22->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE68;
    v22->__shared_weak_owners_ = 0LL;
    v22[1].__vftable = (std::__shared_weak_count_vtbl *)this;
    unint64_t v38 = v22;
    v35[0] = MEMORY[0x1895F87A8];
    v35[1] = 3321888768LL;
    v35[2] = ___ZN12HTTPProtocol19performAsyncCalloutEPK10__CFStringS2_S2_hP15__CFHTTPMessage_block_invoke;
    v35[3] = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e26_v16__0__AOSTransactionC__8l;
    v35[4] = this;
    v35[5] = this;
    uint64_t v36 = v22;
    do
      unint64_t v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
    *((void *)&v41 + 1) = v35;
    uint64_t v25 = *((void *)this + 3);
    if (*(_DWORD *)(v25 + 40) != 3) {
      __assert_rtn("getDispatchQueue", "CoreSchedulingSet.h", 64, "fKind == eDispatchQueueBased");
    }
    uint64_t v42 = *(void *)(v25 + 56);
    inited = (const void *)_AOSAccountResolveAuthFailure_delayInitStub(COERCE_DOUBLE(3321888768LL));
    if (inited) {
      CFRelease(inited);
    }
    CFRelease(v19);
    int v27 = v36;
    if (v36)
    {
      uint64_t v28 = (unint64_t *)&v36->__shared_owners_;
      do
        unint64_t v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }

    CFDataRef v30 = v38;
    if (!v38) {
      goto LABEL_29;
    }
    unint64_t v31 = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (v32)
    {
LABEL_29:
      if (!v17) {
        goto LABEL_31;
      }
    }

    else
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
      if (!v17)
      {
LABEL_31:
        if (!v21) {
          return;
        }
        goto LABEL_32;
      }
    }

    CFRelease(v17);
    goto LABEL_31;
  }

void sub_182AE1628( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

char *HTTPProtocol::asynchronouslyQueryAuthBroker(HTTPProtocol *this)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  CFComparisonResult v2 = (AuthBrokerAgentClient *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 656LL))(this);
  uint64_t v3 = AuthBrokerAgentClient::AuthBrokerIsAvailable(v2);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v4 = (os_log_s *)CFNLog::logger;
  if ((_DWORD)v3)
  {
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *((void *)this + 99);
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_impl( &dword_18298D000,  v4,  OS_LOG_TYPE_DEFAULT,  "%{public}@ querying AuthBrokerAgent",  (uint8_t *)&buf,  0xCu);
    }

    CFRetain((char *)this - 16);
    *(void *)&__int128 buf = this;
    uint64_t v6 = (std::__shared_weak_count *)operator new(0x20uLL);
    v6->__shared_owners_ = 0LL;
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    v6->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE68;
    v6->__shared_weak_owners_ = 0LL;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)this;
    *((void *)&buf + 1) = v6;
    uint64_t v8 = *((void *)this + 46);
    v28[0] = MEMORY[0x1895F87A8];
    v28[1] = 3321888768LL;
    v28[2] = ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke;
    v28[3] = &__block_descriptor_56_e8_40c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e77_v16__0__NetworkProxyCredential________CFAllocator_i______CFURLCredential_iQ_8l;
    v28[4] = this;
    void v28[5] = this;
    unint64_t v29 = v6;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    SmartBlockWithArgs<NetworkProxyCredential *>::SmartBlockWithArgs(&v30, v28);
    AuthBrokerAgentClient::FetchProxyCredentials(v8, &v30);
    uint64_t v10 = v31;
    if (v31)
    {
      uint64_t v11 = (unint64_t *)&v31->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    uint64_t v13 = *((unsigned int *)this + 48);
    unint64_t v14 = v13 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32);
    *((_DWORD *)this + 4_Block_object_dispose((const void *)(v1 - 136), 8) = v13 | 0x200000;
    if ((v14 & 0x8000000000LL) == 0) {
      HTTPProtocol::destroyReadStream(this);
    }
    (*(void (**)(HTTPProtocol *, void))(*(void *)this + 608LL))(this, 0LL);
    uint64_t v15 = v29;
    if (v29)
    {
      unint64_t v16 = (unint64_t *)&v29->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }

    uint64_t v18 = (std::__shared_weak_count *)*((void *)&buf + 1);
    if (*((void *)&buf + 1))
    {
      uint64_t v19 = (unint64_t *)(*((void *)&buf + 1) + 8LL);
      do
        unint64_t v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }

  else
  {
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = *((void *)this + 99);
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v27;
      _os_log_error_impl( &dword_18298D000,  v4,  OS_LOG_TYPE_ERROR,  "Failed to query AuthBrokerAgent %{public}@",  (uint8_t *)&buf,  0xCu);
    }

    int v21 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_53_7145, 3);
    uint64_t v22 = v21;
    if (v21
      && (*(unsigned int (**)(void *, const char *, void))(*(void *)v21 + 16LL))( v21,  "Failed to query AuthBrokerAgent",  0LL))
    {
      uint64_t v23 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      *(void *)&__int128 buf = off_189C1A178;
      CFStringRef v24 = CFStringCreateWithCString(v23, "Protocol", 0x8000100u);
      uint64_t v33 = 0LL;
      uint64_t v34 = 0LL;
      *((void *)&buf + 1) = v24;
      uint64_t v25 = (const void *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 32LL))(this);
      (*(void (**)(void *, void, const void *))(*(void *)v22 + 64LL))(v22, *((void *)&buf + 1), v25);
      if (v25) {
        CFRelease(v25);
      }
      AutoString::~AutoString((AutoString *)&buf);
      (*(void (**)(void *))(*(void *)v22 + 8LL))(v22);
    }
  }

  return v3;
}

void sub_182AE19C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke( void *a1, std::__shared_weak_count_vtbl *a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a1[4];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v5 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1[5] + 792LL);
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl( &dword_18298D000,  v5,  OS_LOG_TYPE_DEFAULT,  "AuthBrokerAgent query finished %{public}@",  (uint8_t *)&buf,  0xCu);
  }

  if (a2) {
    (*((void (**)(std::__shared_weak_count_vtbl *))a2->~__shared_weak_count + 5))(a2);
  }
  *(void *)&__int128 buf = a2;
  CFAllocatorRef v7 = (std::__shared_weak_count *)operator new(0x20uLL);
  v7->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  v7->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CD88;
  v7->__shared_weak_owners_ = 0LL;
  v7[1].__vftable = a2;
  *((void *)&buf + 1) = v7;
  uint64_t v9 = a1[5];
  uint64_t v10 = *(void *)(v9 + 24);
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 3321888768LL;
  v24[2] = ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_44;
  _BYTE v24[3] = &__block_descriptor_72_e8_40c50_ZTSNSt3__110shared_ptrI22NetworkProxyCredentialEE56c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  v24[4] = v4;
  v24[5] = a2;
  uint64_t v25 = v7;
  do
    unint64_t v11 = __ldxr(p_shared_owners);
  while (__stxr(v11 + 1, p_shared_owners));
  unint64_t v12 = (std::__shared_weak_count *)a1[6];
  uint64_t v26 = v9;
  uint64_t v27 = v12;
  if (v12)
  {
    uint64_t v13 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  (*(void (**)(uint64_t, void *))(*(void *)v10 + 96LL))(v10, v24);
  uint64_t v15 = v27;
  if (v27)
  {
    unint64_t v16 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  uint64_t v18 = v25;
  if (v25)
  {
    uint64_t v19 = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  int v21 = (std::__shared_weak_count *)*((void *)&buf + 1);
  if (*((void *)&buf + 1))
  {
    uint64_t v22 = (unint64_t *)(*((void *)&buf + 1) + 8LL);
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

void sub_182AE1C5C(_Unwind_Exception *a1)
{
}

uint64_t ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_52@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 1219LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_44(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    uint64_t v4 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 16LL))(v2);
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v5 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(v3 + 792);
    *(_DWORD *)int v21 = 138412546;
    *(void *)&v21[4] = v4;
    *(_WORD *)&v21[12] = 2114;
    *(void *)&v21[14] = v6;
    _os_log_impl(&dword_18298D000, v5, OS_LOG_TYPE_DEFAULT, "AuthBrokerAgent sent cred %@ %{public}@", v21, 0x16u);
  }

  CFAllocatorRef v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_46_7152, 3);
  uint64_t v8 = v7;
  if (v7
    && (*(unsigned int (**)(void *, const char *, void))(*(void *)v7 + 16LL))( v7,  "AuthBrokerAgent Callback",  0LL))
  {
    uint64_t v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    uint64_t v10 = *(void *)(a1 + 56);
    *(void *)int v21 = off_189C1A178;
    CFStringRef v11 = CFStringCreateWithCString(v9, "Protocol", 0x8000100u);
    uint64_t v22 = 0LL;
    *(_OWORD *)&v21[8] = (unint64_t)v11;
    if (v10)
    {
      unint64_t v12 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 32LL))(v10);
      CFStringRef v11 = *(CFStringRef *)&v21[8];
    }

    else
    {
      unint64_t v12 = @"null";
    }

    (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v8 + 64LL))(v8, v11, v12);
    if (v10 && v12) {
      CFRelease(v12);
    }
    AutoString::~AutoString((AutoString *)v21);
    (*(void (**)(void *))(*(void *)v8 + 8LL))(v8);
  }

  uint64_t v13 = *(void *)(a1 + 56);
  int v14 = *(_DWORD *)(v13 + 192);
  v13 += 192LL;
  __int16 v15 = *(_WORD *)(v13 + 4);
  *(_DWORD *)uint64_t v13 = v14 & 0xFFDFFFFF;
  *(_WORD *)(v13 + 4) = v15;
  uint64_t v16 = *(void *)(a1 + 56);
  if (((*(unsigned int *)(v16 + 192) | ((unint64_t)*(unsigned __int16 *)(v16 + 196) << 32)) & 0x4000000000LL) == 0
    && !(*(unsigned int (**)(uint64_t))(*(void *)v16 + 520LL))(v16))
  {
    (*(void (**)(void, void))(**(void **)(a1 + 56) + 608LL))( *(void *)(a1 + 56),  *(void *)(a1 + 40));
    if (!*(void *)(a1 + 40)) {
      goto LABEL_26;
    }
    if ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 648LL))(*(void *)(a1 + 56)))
    {
      *(_DWORD *)(*(void *)(a1 + 56) + 192LL) |= 0x400000u;
      uint64_t v17 = *(void *)(a1 + 56);
      uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 32LL);
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 648LL))(v17);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 120LL))(v17, v18, v19);
      goto LABEL_19;
    }

    if (!*(void *)(a1 + 40)) {
LABEL_26:
    }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 56) + 672LL))(*(void *)(a1 + 56), 1LL);
    uint64_t v20 = *(void *)(a1 + 56);
    if (((*(unsigned int *)(v20 + 192) | ((unint64_t)*(unsigned __int16 *)(v20 + 196) << 32)) & 0x8000000000LL) != 0)
    {
      HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth((HTTPProtocol *)v20);
    }

    else
    {
      -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(void *)(v20 + 832), 3LL, 0LL);
      HTTPProtocol::createAndOpenStream(*(HTTPProtocol **)(a1 + 56), 0LL);
    }
  }

void sub_182AE1FE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (v9) {
    CFRelease(v9);
  }
  _Unwind_Resume(a1);
}

void *__copy_helper_block_e8_40c50_ZTSNSt3__110shared_ptrI22NetworkProxyCredentialEE56c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE( void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_40c50_ZTSNSt3__110shared_ptrI22NetworkProxyCredentialEE56c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE( uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 56);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth(HTTPProtocol *this)
{
  uint64_t v2 = *((unsigned int *)this + 48);
  unint64_t v3 = v2 | ((unint64_t)*((unsigned __int16 *)this + 98) << 32) | 0x10000000000LL;
  *((_DWORD *)this + 4_Block_object_dispose((const void *)(v1 - 136), 8) = v2;
  *((_WORD *)this + 9_Block_object_dispose((const void *)(v1 - 136), 8) = WORD2(v3);
  unint64_t v4 = (_CFURLAuthChallenge *)(*(uint64_t (**)(HTTPProtocol *))(*(void *)this + 648LL))(this);
  if (v4)
  {
    uint64_t v5 = v4;
    CFRetain(v4);
    HTTPProtocol::sendDidReceiveAuthChallenge(this, v5);
    CFRelease(v5);
  }

  else
  {
    *((_DWORD *)this + 48) |= 0x8000u;
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::operator()(*((void *)this + 78), 0LL, 0LL);
    SmartBlockWithArgs<std::shared_ptr<AuthenticationState>>::SmartBlockWithArgs(&v12, 0LL);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100]((uint64_t)this + 624, &v12);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    if (*((void *)&v12 + 1))
    {
      unint64_t v7 = (unint64_t *)(*((void *)&v12 + 1) + 8LL);
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }

    unsigned int v10 = *((_DWORD *)this + 48);
    uint64_t v9 = (char *)this + 192;
    uint64_t v11 = *((unsigned __int16 *)v9 + 2);
    *(_DWORD *)uint64_t v9 = v10;
    *((_WORD *)v9 + 2) = ((v10 | (unint64_t)(v11 << 32)) & 0xFFFFFF7FFFFFFFFFLL) >> 32;
  }

void sub_182AE2190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t ___ZN12HTTPProtocol29asynchronouslyQueryAuthBrokerEv_block_invoke_45@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 1183LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void std::__shared_ptr_pointer<NetworkProxyCredential *,Deleter_release<NetworkProxyCredential>,std::allocator<NetworkProxyCredential>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

uint64_t std::__shared_ptr_pointer<NetworkProxyCredential *,Deleter_release<NetworkProxyCredential>,std::allocator<NetworkProxyCredential>>::__on_zero_shared( uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 48LL))(result);
  }
  return result;
}

void ___ZN12HTTPProtocol19performAsyncCalloutEPK10__CFStringS2_S2_hP15__CFHTTPMessage_block_invoke( uint64_t a1, double a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  int v5 = *(_DWORD *)(v3 + 192);
  v3 += 192LL;
  __int16 v6 = *(_WORD *)(v3 + 4);
  *(_DWORD *)uint64_t v3 = v5 & 0xDFFFFFFF;
  *(_WORD *)(v3 + 4) = v6;
  if (AOSTransactionSuccessful_delayInitStub(a2))
  {
    *(_DWORD *)(*(void *)(a1 + 40) + 192LL) |= 0x40000000u;
    HTTPProtocol::createAndOpenStream(*(HTTPProtocol **)(a1 + 40), 0LL);
  }

  else
  {
    Error_uint64_t delayInitStub = AOSTransactionGetError_delayInitStub(v7);
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v9 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(v4 + 792);
      int v11 = 138543618;
      uint64_t v12 = v10;
      __int16 v13 = 2112;
      uint64_t v14 = Error_delayInitStub;
      _os_log_impl( &dword_18298D000,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}@ _AOSAccountResolveAuthFailure failed with error %@, canceling auth",  (uint8_t *)&v11,  0x16u);
    }

    HTTPProtocol::sendError((HTTPProtocol *)v4, (const __CFString *)0xFFFFFFFFFFFFFC0CLL);
  }

void ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 32);
  CFRetain((CFTypeRef)(v4 - 16));
  if (a2)
  {
    CFRetain(a2);
  }

  else
  {
    if (*(_BYTE *)(a1 + 40)) {
      int v5 = *(_DWORD *)(v4 + 192) | 0x10000000;
    }
    else {
      int v5 = *(_DWORD *)(v4 + 192) | 0x8000000;
    }
    *(_WORD *)(v4 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 96) = *(_WORD *)(v4 + 196);
    *(_DWORD *)(v4 + 192) = v5;
  }

  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  __int16 v6 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = a2;
    _os_log_impl(&dword_18298D000, v6, OS_LOG_TYPE_DEFAULT, "Accounts sent cred %p", (uint8_t *)&buf, 0xCu);
  }

  double v7 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_56, 3);
  unint64_t v8 = v7;
  if (v7
    && (*(unsigned int (**)(void *, const char *, void))(*(void *)v7 + 16LL))( v7,  "Accounts Completed Credential Fetch",  0LL))
  {
    uint64_t v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    *(void *)&__int128 buf = off_189C1A178;
    CFStringRef v10 = CFStringCreateWithCString(v9, "Protocol", 0x8000100u);
    uint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    *((void *)&buf + 1) = v10;
    if (v4)
    {
      int v11 = (const __CFString *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 32LL))(v4);
      CFStringRef v10 = (CFStringRef)*((void *)&buf + 1);
    }

    else
    {
      int v11 = @"null";
    }

    (*(void (**)(void *, CFStringRef, const __CFString *))(*(void *)v8 + 64LL))(v8, v10, v11);
    if (v4 && v11) {
      CFRelease(v11);
    }
    AutoString::~AutoString((AutoString *)&buf);
    *(void *)&__int128 buf = off_189C1A178;
    CFStringRef v12 = CFStringCreateWithCString(v9, "Credential", 0x8000100u);
    uint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    *((void *)&buf + 1) = v12;
    if (a2)
    {
      CFStringRef v13 = CFCopyDescription(a2);
      CFStringRef v12 = (CFStringRef)*((void *)&buf + 1);
    }

    else
    {
      CFStringRef v13 = @"null";
    }

    (*(void (**)(void *, CFStringRef, CFStringRef))(*(void *)v8 + 64LL))(v8, v12, v13);
    if (a2 && v13) {
      CFRelease(v13);
    }
    AutoString::~AutoString((AutoString *)&buf);
    (*(void (**)(void *))(*(void *)v8 + 8LL))(v8);
  }

  uint64_t v14 = *(void *)(v4 + 24);
  v15[0] = MEMORY[0x1895F87A8];
  v15[1] = 3221225472LL;
  v15[2] = ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_2;
  v15[3] = &__block_descriptor_49_e5_v8__0l;
  char v16 = *(_BYTE *)(a1 + 40);
  v15[4] = v4;
  v15[5] = a2;
  (*(void (**)(uint64_t, void *))(*(void *)v14 + 96LL))(v14, v15);
  CFRelease((CFTypeRef)(v4 - 16));
}

void sub_182AE2684( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_62@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 1316LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(HTTPProtocol **)(a1 + 32);
  int v3 = *((_DWORD *)v2 + 48);
  unint64_t v4 = v3 & 0xFBFFFFFF | ((unint64_t)*((unsigned __int16 *)v2 + 98) << 32);
  *((_DWORD *)v2 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = v3 & 0xFBFFFFFF;
  if (*(_BYTE *)(a1 + 48))
  {
    *((_WORD *)v2 + 9_Block_object_dispose((const void *)(v1 - 136), 8) = WORD2(v4);
    *((_DWORD *)v2 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = v4 | 0x1000000;
    (*(void (**)(HTTPProtocol *, void))(*(void *)v2 + 624LL))(v2, 0LL);
  }

  else
  {
    *((_WORD *)v2 + 9_Block_object_dispose((const void *)(v1 - 136), 8) = WORD2(v4);
    *((_DWORD *)v2 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = v4 | 0x800000;
    int v5 = (const void *)*((void *)v2 + 44);
    *((void *)v2 + 44) = 0LL;
    if (v5) {
      CFRelease(v5);
    }
  }

  uint64_t v6 = *(void *)(a1 + 40);
  int v7 = *(unsigned __int8 *)(a1 + 48);
  if (v6)
  {
    if (!*(_BYTE *)(a1 + 48))
    {
      uint64_t v9 = *((void *)v2 + 47);
      if (v9)
      {
LABEL_29:
        (*(void (**)(HTTPProtocol *, uint64_t, uint64_t))(*(void *)v2 + 120LL))(v2, v6, v9);
        goto LABEL_30;
      }

      goto LABEL_18;
    }

    uint64_t v8 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)v2 + 648LL))(v2);
    int v7 = *(unsigned __int8 *)(a1 + 48);
    if (v8)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      if (*(_BYTE *)(a1 + 48)) {
        uint64_t v9 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)v2 + 648LL))(v2);
      }
      else {
        uint64_t v9 = *((void *)v2 + 47);
      }
      goto LABEL_29;
    }
  }

  if (v7 && (*(uint64_t (**)(HTTPProtocol *))(*(void *)v2 + 648LL))(v2))
  {
    uint64_t v10 = (*(uint64_t (**)(HTTPProtocol *))(*(void *)v2 + 648LL))(v2);
    if (v10) {
      int v11 = (URLAuthChallenge *)(v10 + 16);
    }
    else {
      int v11 = 0LL;
    }
LABEL_22:
    URLAuthChallenge::tryNextProtectionSpace(v11);
    goto LABEL_23;
  }

uint64_t ___ZN12HTTPProtocol19askAccountsForCredsEh_block_invoke_55@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 1267LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void std::__shared_ptr_pointer<_CFURLProtectionSpace *,Deleter_CFRelease,std::allocator<_CFURLProtectionSpace>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<_CFURLProtectionSpace *,Deleter_CFRelease,std::allocator<_CFURLProtectionSpace>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke( void *a1, std::__shared_weak_count_vtbl *a2, std::__shared_weak_count_vtbl *a3)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v6 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1[4] + 792LL);
    *(_DWORD *)__int128 buf = 138543874;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = a2;
    __int16 v51 = 2112;
    uint64_t v52 = a3;
    _os_log_impl(&dword_18298D000, v6, OS_LOG_TYPE_DEFAULT, "%{public}@ received PAT headers %@ error %@", buf, 0x20u);
  }

  if (a2) {
    a2 = (std::__shared_weak_count_vtbl *)CFRetain(a2);
  }
  *(void *)__int128 buf = a2;
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x20uLL);
  v8->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DBC0;
  v8->__shared_weak_owners_ = 0LL;
  v8[1].__vftable = a2;
  *(void *)&uint8_t buf[8] = v8;
  if (a3) {
    a3 = (std::__shared_weak_count_vtbl *)CFRetain(a3);
  }
  char v48 = a3;
  uint64_t v10 = (std::__shared_weak_count *)operator new(0x20uLL);
  v10->__shared_owners_ = 0LL;
  int v11 = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)off_189C11280;
  v10->__shared_weak_owners_ = 0LL;
  v10[1].__vftable = a3;
  char v49 = v10;
  uint64_t v13 = a1[4];
  uint64_t v12 = (std::__shared_weak_count *)a1[5];
  uint64_t v14 = *(void *)(v13 + 24);
  v40[0] = MEMORY[0x1895F87A8];
  v40[1] = 3321888768LL;
  CFTypeRef v40[2] = ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke_65;
  v40[3] = &__block_descriptor_96_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE_e5_v8__0l;
  v40[4] = v13;
  __int128 v41 = v12;
  if (v12)
  {
    uint64_t v15 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  uint64_t v17 = (std::__shared_weak_count *)a1[7];
  uint64_t v42 = a1[6];
  uint64_t v43 = v17;
  if (v17)
  {
    uint64_t v18 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }

  unint64_t v44 = a2;
  CFTypeRef v45 = v8;
  do
    unint64_t v20 = __ldxr(p_shared_owners);
  while (__stxr(v20 + 1, p_shared_owners));
  uint64_t v46 = a3;
  unint64_t v47 = v10;
  do
    unint64_t v21 = __ldxr(v11);
  while (__stxr(v21 + 1, v11));
  (*(void (**)(uint64_t, void *))(*(void *)v14 + 96LL))(v14, v40);
  uint64_t v22 = v47;
  if (v47)
  {
    uint64_t v23 = (unint64_t *)&v47->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  uint64_t v25 = v45;
  if (v45)
  {
    uint64_t v26 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  uint64_t v28 = v43;
  if (v43)
  {
    uint64_t v29 = (unint64_t *)&v43->__shared_owners_;
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  unint64_t v31 = v41;
  if (v41)
  {
    unint64_t v32 = (unint64_t *)&v41->__shared_owners_;
    do
      unint64_t v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

  uint64_t v34 = v49;
  if (v49)
  {
    uint64_t v35 = (unint64_t *)&v49->__shared_owners_;
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

  uint64_t v37 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    unint64_t v38 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }

void sub_182AE2D10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v19 = va_arg(va1, void);
  uint64_t v21 = va_arg(va1, void);
  uint64_t v17 = v13;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v14);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v17);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v16);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v15);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol14askPATForCredsEP15__CFHTTPMessageP9__CFArraybbPK7__CFURL_block_invoke_65( void *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1[4];
  uint64_t v2 = (__CFHTTPMessage *)a1[6];
  int v3 = (const void *)a1[8];
  uint64_t v4 = a1[10];
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  int v5 = (os_log_s *)CFNLog::logger;
  if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(v1 + 792);
    int v14 = 138543874;
    uint64_t v15 = v6;
    __int16 v16 = 2112;
    *(void *)uint64_t v17 = v3;
    *(_WORD *)&v17[8] = 2112;
    *(void *)&v17[10] = v4;
    _os_log_impl( &dword_18298D000,  v5,  OS_LOG_TYPE_DEFAULT,  "%{public}@ handling PAT headers %@ error %@",  (uint8_t *)&v14,  0x20u);
  }

  unint64_t v7 = (*(unsigned int *)(v1 + 192) | ((unint64_t)*(unsigned __int16 *)(v1 + 196) << 32)) & 0xEFFFFFFFFFFDLL;
  *(_DWORD *)(v1 + 192) &= ~2u;
  *(_WORD *)(v1 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 96) = WORD2(v7);
  if (v4)
  {
    *(_BYTE *)(v1 + 857) = 1;
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    uint64_t v8 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(v1 + 792);
      int v10 = *(_DWORD *)(v1 + 732);
      size_t size = *(dispatch_data_s **)(v1 + 720);
      if (size) {
        size_t size = (dispatch_data_s *)dispatch_data_get_size(size);
      }
      int v14 = 138543874;
      uint64_t v15 = v9;
      __int16 v16 = 1024;
      *(_DWORD *)uint64_t v17 = v10;
      *(_WORD *)&v17[4] = 2048;
      *(void *)&void v17[6] = size;
      _os_log_impl( &dword_18298D000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}@ PAT default delivering response recorded(%d, %zu)",  (uint8_t *)&v14,  0x1Cu);
    }

    HTTPProtocol::performHeaderReadPostProcessing((HTTPProtocol *)v1, v2, 1);
    HTTPProtocol::deliverUnhandledResponse((HTTPProtocol *)v1);
  }

  else
  {
    if (v3) {
      CFTypeRef v12 = CFRetain(v3);
    }
    else {
      CFTypeRef v12 = 0LL;
    }
    uint64_t v13 = *(const void **)(v1 + 848);
    *(void *)(v1 + 84_Block_object_dispose((const void *)(v1 - 136), 8) = v12;
    if (v13) {
      CFRelease(v13);
    }
    -[__CFN_TaskMetrics nextTransaction:withNewRequest:](*(void *)(v1 + 832), 3LL, 0LL);
    HTTPProtocol::destroyReadStream((HTTPProtocol *)v1);
    HTTPProtocol::createAndOpenStream((HTTPProtocol *)v1, 0LL);
  }

void *__copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    int v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  uint64_t v11 = a2[11];
  result[10] = a2[10];
  result[11] = v11;
  if (v11)
  {
    CFTypeRef v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE48c43_ZTSNSt3__110shared_ptrI15__CFHTTPMessageEE64c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE80c36_ZTSNSt3__110shared_ptrI9__CFErrorEE( uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  uint64_t v2 = a1 + 48;
  uint64_t v3 = a1 + 64;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 80);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void std::__shared_ptr_pointer<__CFError *,Deleter_CFRelease,std::allocator<__CFError>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<__CFError *,Deleter_CFRelease,std::allocator<__CFError>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t ___ZN12HTTPProtocol30attemptToCacheMovedPermanentlyEP15__CFHTTPMessage23CFURLCacheStoragePolicyPK13_CFURLRequest_block_invoke( uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a2 + 24LL))( a2,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
}

HTTPProtocol *HTTPProtocol::setSSLCertContextOnResponseOrCachedResponse( HTTPProtocol *this, HTTPProtocol *a2, const _CFCachedURLResponse *a3)
{
  if (a2)
  {
    if ((*((_DWORD *)this + 48) & 0x4000) == 0) {
      return this;
    }
    uint64_t v3 = (const void *)*((void *)this + 50);
    if (!v3) {
      return this;
    }
    this = a2;
  }

  else
  {
    if (!a3) {
      return this;
    }
    if ((*((_DWORD *)this + 48) & 0x4000) == 0) {
      return this;
    }
    uint64_t v3 = (const void *)*((void *)this + 50);
    if (!v3) {
      return this;
    }
    this = (HTTPProtocol *)*((void *)a3->var1 + 4);
    if (!this) {
      return this;
    }
  }

  unint64_t v4 = (CFTypeRef *)(-[HTTPProtocol _inner](this, "_inner", a3) + 64);
  if (*v4) {
    CFRelease(*v4);
  }
  this = (HTTPProtocol *)CFRetain(v3);
  *unint64_t v4 = this;
  return this;
}

void ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke( uint64_t a1, char a2, CFTypeRef cf, std::__shared_weak_count_vtbl *a4)
{
  if (cf) {
    unint64_t v7 = (std::__shared_weak_count_vtbl *)CFRetain(cf);
  }
  else {
    unint64_t v7 = 0LL;
  }
  uint64_t v43 = v7;
  uint64_t v8 = (std::__shared_weak_count *)operator new(0x20uLL);
  v8->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__vftable = (std::__shared_weak_count_vtbl *)off_189C0DBC0;
  v8->__shared_weak_owners_ = 0LL;
  v8[1].__vftable = v7;
  unint64_t v44 = v8;
  if (a4) {
    a4 = (std::__shared_weak_count_vtbl *)CFRetain(a4);
  }
  __int128 v41 = a4;
  unint64_t v10 = (std::__shared_weak_count *)operator new(0x20uLL);
  v10->__shared_owners_ = 0LL;
  uint64_t v11 = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE30;
  v10->__shared_weak_owners_ = 0LL;
  v10[1].__vftable = a4;
  uint64_t v42 = v10;
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = *(void *)(v12 + 24);
  v34[0] = MEMORY[0x1895F87A8];
  v34[1] = 3321888768LL;
  v34[2] = ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke_2;
  v34[3] = &__block_descriptor_81_e8_32c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE48c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE64c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE_e5_v8__0l;
  char v40 = a2;
  v34[4] = v7;
  uint64_t v35 = v8;
  do
    unint64_t v14 = __ldxr(p_shared_owners);
  while (__stxr(v14 + 1, p_shared_owners));
  unint64_t v36 = a4;
  uint64_t v37 = v10;
  do
    unint64_t v15 = __ldxr(v11);
  while (__stxr(v15 + 1, v11));
  __int16 v16 = *(std::__shared_weak_count **)(a1 + 40);
  uint64_t v38 = v12;
  unint64_t v39 = v16;
  if (v16)
  {
    uint64_t v17 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }

  (*(void (**)(uint64_t, void *))(*(void *)v13 + 96LL))(v13, v34);
  uint64_t v19 = v39;
  if (v39)
  {
    unint64_t v20 = (unint64_t *)&v39->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  uint64_t v22 = v37;
  if (v37)
  {
    uint64_t v23 = (unint64_t *)&v37->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  uint64_t v25 = v35;
  if (v35)
  {
    uint64_t v26 = (unint64_t *)&v35->__shared_owners_;
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  uint64_t v28 = v42;
  if (v42)
  {
    uint64_t v29 = (unint64_t *)&v42->__shared_owners_;
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  unint64_t v31 = v44;
  if (v44)
  {
    unint64_t v32 = (unint64_t *)&v44->__shared_owners_;
    do
      unint64_t v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }

void sub_182AE33A8(_Unwind_Exception *a1)
{
}

uint64_t __copy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE(uint64_t a1)
{
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 32);
}

void ___ZN12HTTPProtocol42asynchronouslyHandleHTTPResponseExternallyEP15__CFHTTPMessage_block_invoke_2( uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 64);
  *(_DWORD *)(v2 + 72_Block_object_dispose((const void *)(v1 - 136), 8) = 3;
  if (*(_BYTE *)(a1 + 80))
  {
    unint64_t v4 = *(const void **)(a1 + 32);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
    unint64_t v30 = v4;
    unint64_t v31 = v3;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        unint64_t v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }

    uint64_t v8 = *(void *)(a1 + 48);
    unint64_t v7 = *(std::__shared_weak_count **)(a1 + 56);
    if (v7)
    {
      uint64_t v9 = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }

    unint64_t v11 = *(_DWORD *)(v2 + 192) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)(v2 + 196) << 32);
    *(_DWORD *)(v2 + 192) &= ~2u;
    *(_WORD *)(v2 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 96) = WORD2(v11);
    *(void *)(v2 + 72_Block_object_dispose((const void *)(v1 - 136), 8) = 1LL;
    uint64_t v12 = *(dispatch_object_s **)(v2 + 720);
    if (v12)
    {
      dispatch_release(v12);
      *(void *)(v2 + 720) = 0LL;
    }

    if (!v8)
    {
      if (v4)
      {
        if (CFDictionaryGetCount((CFDictionaryRef)v4))
        {
          CFTypeRef v13 = CFRetain(v4);
          unint64_t v14 = *(const void **)(v2 + 704);
          *(void *)(v2 + 704) = v13;
          if (v14) {
            CFRelease(v14);
          }
        }
      }
    }

    HTTPProtocol::destroyReadStream((HTTPProtocol *)v2);
    if (v8)
    {
      if (CFNLog::onceToken != -1) {
        dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
      }
      unint64_t v15 = (os_log_s *)CFNLog::logger;
      if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(v2 + 792);
        *(_DWORD *)__int128 buf = 138543618;
        uint64_t v33 = v16;
        __int16 v34 = 2112;
        uint64_t v35 = v8;
        _os_log_impl( &dword_18298D000,  v15,  OS_LOG_TYPE_DEFAULT,  "%{public}@ external auth will start new request %@",  buf,  0x16u);
      }

      uint64_t v17 = *(void **)(v2 + 80);
      if (v17) {
        objc_msgSend(v17, "set_appleIDContextRedirect:", 1, v8, v7, v30);
      }
      uint64_t v18 = *(void *)(v2 + 96);
      if (v18)
      {
        uint64_t v19 = (*(uint64_t (**)(void))(*(void *)v18 + 16LL))(*(void *)(v2 + 96));
        unint64_t v20 = (void *)MEMORY[0x186E1578C](v19);
        (*(void (**)(void, uint64_t, void))(**(void **)(v2 + 96) + 40LL))(*(void *)(v2 + 96), v8, 0LL);
        objc_autoreleasePoolPop(v20);
        (*(void (**)(uint64_t))(*(void *)v18 + 24LL))(v18);
      }
    }

    else
    {
      HTTPProtocol::createAndOpenStream((HTTPProtocol *)v2, 0LL);
    }

    if (v7)
    {
      uint64_t v26 = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }

    if (v31)
    {
      uint64_t v28 = (unint64_t *)&v31->__shared_owners_;
      do
        unint64_t v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
  }

  else
  {
    if (CFNLog::onceToken != -1) {
      dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
    }
    unint64_t v21 = (os_log_s *)CFNLog::logger;
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = *(void *)(*(void *)(a1 + 64) + 792LL);
      *(_DWORD *)__int128 buf = 138543362;
      uint64_t v33 = v22;
      _os_log_impl( &dword_18298D000,  v21,  OS_LOG_TYPE_DEFAULT,  "%{public}@ authentication client does not want to continue load",  buf,  0xCu);
    }

    uint64_t v23 = *(void *)(a1 + 64);
    HTTPProtocol::performHeaderReadPostProcessing((HTTPProtocol *)v23, *(__CFHTTPMessage **)(v23 + 712), 1);
    unint64_t v24 = *(dispatch_data_s **)(v23 + 720);
    if (v24) {
      HTTPProtocol::bytesAvailable(v23, v24);
    }
    if (*(_DWORD *)(v23 + 732) == 2)
    {
      HTTPProtocol::destroyReadStream((HTTPProtocol *)v23);
      if ((*(_DWORD *)(v23 + 192) & 0x80) == 0) {
        HTTPProtocol::endEncountered((HTTPProtocol *)v23);
      }
    }

    *(void *)(v23 + 72_Block_object_dispose((const void *)(v1 - 136), 8) = 1LL;
    uint64_t v25 = *(dispatch_object_s **)(v23 + 720);
    if (v25)
    {
      dispatch_release(v25);
      *(void *)(v23 + 720) = 0LL;
    }
  }

void sub_182AE37B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void *__copy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE48c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE64c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE( void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[7];
  result[6] = a2[6];
  result[7] = v5;
  if (v5)
  {
    unint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a2[9];
  result[8] = a2[8];
  result[9] = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_32c43_ZTSNSt3__110shared_ptrIK14__CFDictionaryEE48c42_ZTSNSt3__110shared_ptrIK13_CFURLRequestEE64c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE( uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  uint64_t v2 = a1 + 48;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 64);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void std::__shared_ptr_pointer<_CFURLResponse *,Deleter_CFRelease,std::allocator<_CFURLResponse>>::~__shared_ptr_pointer( std::__shared_weak_count *a1)
{
}

void std::__shared_ptr_pointer<_CFURLResponse *,Deleter_CFRelease,std::allocator<_CFURLResponse>>::__on_zero_shared( uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 24);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t ___ZN12HTTPProtocol23constructSSLCertContextEv_block_invoke(uint64_t a1, const __CFString *this)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 272LL);
  uint64_t v3 = MetaNetStreamInfo::propertyNameToApplicableProperty(this, this);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 32LL))(v2, v3);
}

uint64_t ___ZN12HTTPProtocol17performHeaderReadEP15__CFHTTPMessage_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 4111LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke( void *a1, void *cf, const __CFDictionary **a3)
{
  if (cf)
  {
    uint64_t v6 = a1[4];
    unint64_t v30 = (void *)CFRetain(cf);
    unint64_t v7 = CFErrorCopyUserInfo((CFErrorRef)cf);
    uint64_t v8 = CFGetAllocator((CFTypeRef)(v6 - 16));
    if (v7) {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(v8, 0LL, v7);
    }
    else {
      CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable(v8, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    }
    uint64_t v33 = MutableCopy;
    unint64_t v10 = (std::__shared_weak_count *)operator new(0x20uLL);
    v10->__shared_owners_ = 0LL;
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    v10->__vftable = (std::__shared_weak_count_vtbl *)off_189C19FA8;
    v10->__shared_weak_owners_ = 0LL;
    v10[1].__vftable = (std::__shared_weak_count_vtbl *)MutableCopy;
    __int16 v34 = v10;
    uint64_t v12 = CFGetAllocator((CFTypeRef)(v6 - 16));
    CFNumberRef v13 = CFNumberCreate(v12, kCFNumberCFIndexType, a1 + 5);
    unint64_t v14 = CFGetAllocator((CFTypeRef)(v6 - 16));
    CFNumberRef v15 = CFNumberCreate(v14, kCFNumberSInt32Type, a1 + 6);
    CFDictionarySetValue(MutableCopy, @"_kCFStreamErrorDomainKey", v13);
    CFDictionarySetValue(MutableCopy, @"_kCFStreamErrorCodeKey", v15);
    uint64_t v16 = *a3;
    context[0] = MEMORY[0x1895F87A8];
    context[1] = 3321888768LL;
    context[2] = ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2;
    context[3] = &__block_descriptor_48_e8_32c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE_e25_v24__0____CFString__8_v16l;
    void context[4] = MutableCopy;
    unint64_t v32 = v10;
    do
      unint64_t v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
    CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)_apply_block, context);
    if (MutableCopy)
    {
      uint64_t v18 = CFGetAllocator((CFTypeRef)(v6 - 16));
      Domain = CFErrorGetDomain((CFErrorRef)cf);
      CFIndex Code = CFErrorGetCode((CFErrorRef)cf);
      unint64_t v21 = CFErrorCreate(v18, Domain, Code, MutableCopy);
      if (v30) {
        CFRelease(v30);
      }
    }

    else
    {
      unint64_t v21 = (__CFError *)v30;
    }

    uint64_t v22 = *(unsigned int *)(v6 + 192);
    unint64_t v23 = v22 | ((unint64_t)*(unsigned __int16 *)(v6 + 196) << 32) | 0x4000000000LL;
    *(_DWORD *)(v6 + 192) = v22;
    *(_WORD *)(v6 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 96) = WORD2(v23);
    URLProtocol::sendDidFail((URLProtocol *)v6, v21);
    unint64_t v24 = v32;
    if (v32)
    {
      uint64_t v25 = (unint64_t *)&v32->__shared_owners_;
      do
        unint64_t v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }

    if (v15) {
      CFRelease(v15);
    }
    if (v13) {
      CFRelease(v13);
    }
    unint64_t v27 = v34;
    if (v34)
    {
      uint64_t v28 = (unint64_t *)&v34->__shared_owners_;
      do
        unint64_t v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }

    if (v7) {
      CFRelease(v7);
    }
    if (v21) {
      CFRelease(v21);
    }
  }

void sub_182AE3BF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (v20) {
    CFRelease(v20);
  }
  if (v18) {
    CFRelease(v18);
  }
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  if (v17) {
    CFRelease(v17);
  }
  if (v19) {
    CFRelease(v19);
  }
  _Unwind_Resume(a1);
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2_161(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_4(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_5(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_6(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_7(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_8(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_9(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(int *)(a1 + 48);
  CFIndex v3 = -1004LL;
  unint64_t v4 = @"kCFErrorDomainCFNetwork";
  if (v2 > 31)
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case '1':
      case '3':
      case ';':
      case '=':
      case '@':
      case 'A':
        goto LABEL_21;
      case '2':
LABEL_3:
        CFIndex v3 = -1009LL;
        goto LABEL_21;
      case '4':
      case '7':
      case '8':
      case ':':
      case '>':
      case '?':
        goto LABEL_20;
      case '5':
      case '6':
      case '9':
        goto LABEL_10;
      case '<':
LABEL_12:
        CFIndex v3 = -1001LL;
        goto LABEL_21;
      default:
        if (v2 == 89)
        {
LABEL_18:
          CFIndex v3 = -999LL;
          goto LABEL_21;
        }

        if (v2 != 32) {
          goto LABEL_20;
        }
LABEL_10:
        if ((*(_DWORD *)(v1 + 192) & 2) == 0)
        {
          switch(*(_DWORD *)(a1 + 48))
          {
            case '1':
            case '3':
            case ';':
            case '=':
            case '@':
            case 'A':
              goto LABEL_21;
            case '2':
              goto LABEL_3;
            case '4':
            case '7':
            case '8':
            case ':':
            case '>':
            case '?':
              goto LABEL_20;
            case '5':
            case '6':
            case '9':
              goto LABEL_19;
            case '<':
              goto LABEL_12;
            default:
              if (v2 == 32) {
                goto LABEL_19;
              }
              if (v2 == 89) {
                goto LABEL_18;
              }
              goto LABEL_20;
          }
        }

        break;
    }

    goto LABEL_19;
  }

  if (v2 > 12)
  {
    if (v2 != 13)
    {
      if (v2 != 22) {
        goto LABEL_20;
      }
      CFIndex v3 = -1000LL;
    }
  }

  else if (v2 != -1)
  {
    if (v2 == 9)
    {
LABEL_19:
      CFIndex v3 = -1005LL;
      goto LABEL_21;
    }

void HTTPProtocol::asyncTransformError( std::__shared_weak_count_vtbl *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  if (HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::onceToken == -1)
  {
    if (!a1) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  dispatch_once( &HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::onceToken,  &__block_literal_global_165_7187);
  if (a1) {
LABEL_3:
  }
    CFRetain(&a1[-1].__get_deleter);
LABEL_4:
  uint64_t v12 = (std::__shared_weak_count *)operator new(0x20uLL);
  v12->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v12->__shared_owners_;
  v12->__vftable = (std::__shared_weak_count_vtbl *)off_189C0CE68;
  v12->__shared_weak_owners_ = 0LL;
  v12[1].__vftable = a1;
  unint64_t v14 = (dispatch_queue_s *)HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::q;
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3321888768LL;
  block[2] = ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_2;
  block[3] = &unk_189C0C968;
  void block[6] = a1;
  void block[7] = a2;
  block[4] = a5;
  void block[5] = a6;
  uint64_t v16 = *a4;
  CFNumberRef v15 = (std::__shared_weak_count *)a4[1];
  void block[8] = a3;
  block[9] = v16;
  uint64_t v28 = v15;
  if (v15)
  {
    unint64_t v17 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }

  unint64_t v29 = a1;
  unint64_t v30 = v12;
  do
    unint64_t v19 = __ldxr(p_shared_owners);
  while (__stxr(v19 + 1, p_shared_owners));
  dispatch_async(v14, block);
  unint64_t v20 = v30;
  if (v30)
  {
    uint64_t v21 = (unint64_t *)&v30->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  unint64_t v23 = v28;
  if (v28)
  {
    unint64_t v24 = (unint64_t *)&v28->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  do
    unint64_t v26 = __ldaxr(p_shared_owners);
  while (__stlxr(v26 - 1, p_shared_owners));
  if (!v26)
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_10(uint64_t a1)
{
  uint64_t v1 = CFGetAllocator((CFTypeRef)(*(void *)(a1 + 32) - 16LL));
  return __cfnCreateCFError(v1, @"kCFErrorDomainCFNetwork", -1003LL, v2, v3, v4, v5, v6, 0LL);
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_11(uint64_t a1)
{
  uint64_t v1 = CFGetAllocator((CFTypeRef)(*(void *)(a1 + 32) - 16LL));
  return __cfnCreateCFError(v1, @"kCFErrorDomainCFNetwork", -1003LL, v2, v3, v4, v5, v6, 0LL);
}

CFErrorRef ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_12(uint64_t a1)
{
  uint64_t v1 = CFGetAllocator((CFTypeRef)(*(void *)(a1 + 32) - 16LL));
  return __cfnCreateCFError(v1, @"kCFErrorDomainCFNetwork", -1003LL, v2, v3, v4, v5, v6, 0LL);
}

void HTTPProtocol::logLoadFailure(HTTPProtocol *this, CFErrorRef err, const CFStreamError *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *((void *)this + 71);
  uint64_t v7 = *((void *)this + 72);
  uint64_t v8 = *((void *)this + 34);
  if (v8)
  {
    v6 += (*(uint64_t (**)(uint64_t))(*(void *)v8 + 96LL))(v8);
    v7 += (*(uint64_t (**)(void))(**((void **)this + 34) + 104LL))(*((void *)this + 34));
  }

  CFIndex Code = CFErrorGetCode(err);
  if (CFNLog::onceToken != -1) {
    dispatch_once(&CFNLog::onceToken, &__block_literal_global_1_4717);
  }
  uint64_t v10 = (os_log_s *)CFNLog::logger;
  if (Code == -999)
  {
    if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *((void *)this + 99);
      CFIndex v12 = CFErrorGetCode(err);
      CFIndex domain = a3->domain;
      SInt32 error = a3->error;
      int v19 = 138544642;
      uint64_t v20 = v11;
      __int16 v21 = 2048;
      uint64_t v22 = v6;
      __int16 v23 = 2048;
      uint64_t v24 = v7;
      __int16 v25 = 2048;
      CFIndex v26 = v12;
      __int16 v27 = 2048;
      CFIndex v28 = domain;
      __int16 v29 = 1024;
      SInt32 v30 = error;
      _os_log_impl( &dword_18298D000,  v10,  OS_LOG_TYPE_DEFAULT,  "%{public}@ HTTP load canceled, %lld/%lld bytes (error code: %ld [%ld:%d])",  (uint8_t *)&v19,  0x3Au);
    }
  }

  else if (os_log_type_enabled((os_log_t)CFNLog::logger, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = *((void *)this + 99);
    CFIndex v16 = CFErrorGetCode(err);
    CFIndex v17 = a3->domain;
    SInt32 v18 = a3->error;
    int v19 = 138544642;
    uint64_t v20 = v15;
    __int16 v21 = 2048;
    uint64_t v22 = v6;
    __int16 v23 = 2048;
    uint64_t v24 = v7;
    __int16 v25 = 2048;
    CFIndex v26 = v16;
    __int16 v27 = 2048;
    CFIndex v28 = v17;
    __int16 v29 = 1024;
    SInt32 v30 = v18;
    _os_log_error_impl( &dword_18298D000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}@ HTTP load failed, %lld/%lld bytes (error code: %ld [%ld:%d])",  (uint8_t *)&v19,  0x3Au);
  }

void ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_2( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  uint64_t v33 = v3;
  uint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0LL;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)off_189C11280;
  v4->__shared_weak_owners_ = 0LL;
  v4[1].__vftable = (std::__shared_weak_count_vtbl *)v3;
  __int16 v34 = v4;
  uint64_t v6 = *(void *)(v2 + 24);
  v26[0] = MEMORY[0x1895F87A8];
  v26[1] = 3321888768LL;
  void v26[2] = ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_3;
  v26[3] = &unk_189C0C930;
  v26[5] = v2;
  v26[6] = v3;
  __int16 v27 = v4;
  do
    unint64_t v7 = __ldxr(p_shared_owners);
  while (__stxr(v7 + 1, p_shared_owners));
  __int128 v28 = *(_OWORD *)(a1 + 56);
  v26[4] = *(void *)(a1 + 40);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 80);
  uint64_t v29 = *(void *)(a1 + 72);
  SInt32 v30 = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 96);
  uint64_t v31 = *(void *)(a1 + 88);
  unint64_t v32 = v11;
  if (v11)
  {
    CFIndex v12 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  (*(void (**)(uint64_t, void *))(*(void *)v6 + 96LL))(v6, v26);
  unint64_t v14 = v32;
  if (v32)
  {
    uint64_t v15 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  CFIndex v17 = v30;
  if (v30)
  {
    SInt32 v18 = (unint64_t *)&v30->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  uint64_t v20 = v27;
  if (v27)
  {
    __int16 v21 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  __int16 v23 = v34;
  if (v34)
  {
    uint64_t v24 = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

void sub_182AE449C(_Unwind_Exception *a1)
{
}

void *__copy_helper_block_e8_72c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE88c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE( void *result, void *a2)
{
  uint64_t v2 = a2[10];
  result[9] = a2[9];
  result[10] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[12];
  result[11] = a2[11];
  result[12] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_72c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE88c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE( uint64_t a1)
{
  uint64_t v1 = a1 + 72;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 88);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

void ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke_3( uint64_t a1)
{
  uint64_t v2 = *(__CFError **)(a1 + 48);
  if (v2)
  {
    HTTPProtocol::logLoadFailure(*(HTTPProtocol **)(a1 + 40), v2, (const CFStreamError *)(a1 + 64));
    uint64_t v2 = *(__CFError **)(a1 + 48);
  }

  uint64_t v3 = *(void *)(a1 + 32);
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  uint64_t v10 = *(void *)(a1 + 80);
  uint64_t v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, __CFError *, uint64_t *))(v3 + 16))(v3, v2, &v10);
  unint64_t v7 = v11;
  if (v11)
  {
    uint64_t v8 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

void sub_182AE45D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *__copy_helper_block_e8_48c36_ZTSNSt3__110shared_ptrI9__CFErrorEE80c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE( void *result, void *a2)
{
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[11];
  result[10] = a2[10];
  result[11] = v5;
  if (v5)
  {
    unint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a2[13];
  result[12] = a2[12];
  result[13] = v8;
  if (v8)
  {
    unint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_48c36_ZTSNSt3__110shared_ptrI9__CFErrorEE80c42_ZTSNSt3__110shared_ptrI14__CFDictionaryEE96c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE( uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  uint64_t v2 = a1 + 80;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 96);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

dispatch_queue_t ___ZN12HTTPProtocol19asyncTransformErrorE13CFStreamErrorNSt3__110shared_ptrI14__CFDictionaryEEU13block_pointerFP9__CFErrorvEU13block_pointerFvS6_S4_E_block_invoke()
{
  os_log_t v0 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t result = dispatch_queue_create("com.apple.CFNetwork.Async.SCNetworkReachability", v0);
  HTTPProtocol::asyncTransformError(CFStreamError,std::shared_ptr<__CFDictionary>,__CFError *({block_pointer})(void),void({block_pointer})(__CFError *,std::shared_ptr<__CFDictionary>))::q = (uint64_t)result;
  return result;
}

void ___ZN12HTTPProtocol19failWithStreamErrorEPK13CFStreamError_block_invoke_2( uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t HTTPProtocol::nextTLSFallbackMethod(HTTPProtocol *this)
{
  uint64_t v2 = HTTPProtocol::copySSLPropertiesForStream(this, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    int Value = (const __CFNumber *)CFDictionaryGetValue(v2, &unk_18C5AD398);
    uint64_t v5 = (const __CFNumber *)CFDictionaryGetValue(v3, &unk_18C5AD360);
    if (Value)
    {
      uint64_t valuePtr = 0LL;
      CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr);
      LODWORD(v2) = valuePtr;
    }

    else
    {
      LODWORD(v2) = 0;
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  unsigned int v6 = tlsProtocolVersionForSSLProtocol((SSLProtocol)v2, 1);
  if (v5)
  {
    uint64_t valuePtr = 0LL;
    CFNumberGetValue(v5, kCFNumberCFIndexType, &valuePtr);
    SSLProtocol v7 = (int)valuePtr;
  }

  else
  {
    SSLProtocol v7 = kSSLProtocolUnknown;
  }

  unsigned int v8 = tlsProtocolVersionForSSLProtocol(v7, 0);
  unint64_t v9 = (const void *)*((void *)this + 36);
  if (!v9)
  {
    uint64_t v13 = 0LL;
    if (!v3) {
      return v13;
    }
    goto LABEL_20;
  }

  int v10 = CFEqual(v9, (CFTypeRef)*MEMORY[0x18960B810]);
  if (v8 <= 0x302 || v6 >= 0x304 || v10 == 0) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = *MEMORY[0x18960B7D0];
  }
  if (v3) {
LABEL_20:
  }
    CFRelease(v3);
  return v13;
}

void sub_182AE47E8(_Unwind_Exception *a1)
{
}

uint64_t ___ZN12HTTPProtocol29setProtocolPropertiesToStreamEv_block_invoke( uint64_t a1, const __CFString *this, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t result = MetaNetStreamInfo::propertyNameToApplicableProperty(this, this);
  if ((_DWORD)result)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)(v5 + 272);
    if (v8)
    {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 40LL))(v8, v7, a3);
    }

    else
    {
      uint64_t result = *(void *)(v5 + 888);
      if (result) {
        return (*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(void *)result + 56LL))( result,  this,  a3);
      }
    }
  }

  return result;
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3_119( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 96);
  if (v3)
  {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 56);
    uint64_t v5 = (*(uint64_t (**)(void))(*(void *)v3 + 16LL))(*(void *)(v2 + 96));
    unsigned int v6 = (void *)MEMORY[0x186E1578C](v5);
    (*(void (**)(void, uint64_t))(**(void **)(v2 + 96) + 144LL))(*(void *)(v2 + 96), v4);
    objc_autoreleasePoolPop(v6);
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }

  uint64_t v7 = *(void *)(a1 + 40);
  *(CFAbsoluteTime *)(v7 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = CFAbsoluteTimeGetCurrent();
}

uint64_t ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_2_113@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 3494LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_3( void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = a1[5];
  uint64_t v4 = *(void *)(v3 + 96);
  if (v4)
  {
    uint64_t v5 = a1[7];
    uint64_t v6 = (*(uint64_t (**)(void))(*(void *)v4 + 16LL))(*(void *)(v3 + 96));
    uint64_t v7 = (void *)MEMORY[0x186E1578C](v6);
    (*(void (**)(void, uint64_t))(**(void **)(v3 + 96) + 128LL))(*(void *)(v3 + 96), v5);
    objc_autoreleasePoolPop(v7);
    (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  }

  if (*(_BYTE *)(v2 + 42)) {
    HTTPProtocol::cleanupStreams((HTTPProtocol *)v2);
  }
  *(CFAbsoluteTime *)(v2 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = CFAbsoluteTimeGetCurrent();
  uint64_t v8 = (const void *)a1[7];
  if (v8) {
    CFRelease(v8);
  }
}

uint64_t ___ZN12HTTPProtocol26useNetStreamInfoForRequestEP17MetaNetStreamInfoPK18HTTPRequestMessageh_block_invoke_2@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 3475LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void ___ZN12HTTPProtocol31handleAlternatePathNotificationE36nw_connection_alternate_path_state_t_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 96);
  if (v2)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 40);
    uint64_t v4 = (*(uint64_t (**)(void))(*(void *)v2 + 16LL))(*(void *)(v1 + 96));
    uint64_t v5 = (void *)MEMORY[0x186E1578C](v4);
    (*(void (**)(void, uint64_t))(**(void **)(v1 + 96) + 152LL))(*(void *)(v1 + 96), v3);
    objc_autoreleasePoolPop(v5);
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }

  *(CFAbsoluteTime *)(v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = CFAbsoluteTimeGetCurrent();
  CFRelease((CFTypeRef)(v1 - 16));
}

void ___ZN12HTTPProtocol35handleConnectionWaitingNotificationE40tcp_connection_unmet_conditions_reason_t_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 96);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = (*(uint64_t (**)(void))(*(void *)v2 + 16LL))(*(void *)(v1 + 96));
    uint64_t v5 = (void *)MEMORY[0x186E1578C](v4);
    (*(void (**)(void, uint64_t))(**(void **)(v1 + 96) + 136LL))(*(void *)(v1 + 96), v3);
    objc_autoreleasePoolPop(v5);
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }

  *(CFAbsoluteTime *)(v1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = CFAbsoluteTimeGetCurrent();
  CFRelease((CFTypeRef)(v1 - 16));
}

uint64_t ___ZN12HTTPProtocol24postConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectPU27objcproto16OS_nw_parametersS0_U13block_pointerFvvE_block_invoke( uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void **)(a1 + 40);
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  uint64_t v21 = *a2;
  unint64_t v22 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*v4 + 600LL))(v4, &v21);
  uint64_t v8 = v22;
  if (v22)
  {
    unint64_t v9 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  uint64_t v11 = v4[34];
  CFIndex v12 = (std::__shared_weak_count *)a2[1];
  uint64_t v19 = *a2;
  uint64_t v20 = v12;
  if (v12)
  {
    uint64_t v13 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v11 + 136LL))(v11, &v19);
  uint64_t v15 = v20;
  if (v20)
  {
    unint64_t v16 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))(*(void *)(a1 + 32));
}

void sub_182AE4CB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZN12HTTPProtocol15needServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicybE_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1[53]) {
    (*(void (**)(void, void))(*v1 + 120LL))(*(void *)(a1 + 32), 0LL);
  }
  CFRelease(v1 - 2);
}

void ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2;
  v5[3] = &unk_189C1A298;
  uint64_t v3 = *(void *)(a1 + 32);
  v5[4] = *(void *)(a1 + 40);
  uint64_t v4 = (const void *)(v2 - 16);
  (*(void (**)(uint64_t, uint64_t, void, void *))(*(void *)v2 + 376LL))(v2, v3, 0LL, v5);
  nw_release(*(void **)(a1 + 32));
  CFRelease(v4);
}

uint64_t ___ZN12HTTPProtocol26ssPostConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvPU27objcproto16OS_dispatch_dataS0_PK14__CFDictionaryhE_block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke(void *a1)
{
  uint64_t v3 = a1[5];
  uint64_t v2 = a1[6];
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke_2;
  v5[3] = &unk_189C0C9D0;
  v5[4] = a1[4];
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 368LL))(v3, v2, v5);
  uint64_t v4 = (const void *)a1[6];
  if (v4) {
    CFRelease(v4);
  }
  CFRelease((CFTypeRef)(v3 - 16));
}

uint64_t ___ZN12HTTPProtocol16ssNeedClientCertEPK9__CFArrayU13block_pointerFvS2_E_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke( void *a1)
{
  uint64_t v3 = a1[5];
  uint64_t v2 = a1[6];
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke_2;
  v5[3] = &unk_189C0C9F8;
  v5[4] = a1[4];
  (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v3 + 360LL))(v3, v2, v5);
  uint64_t v4 = (const void *)a1[6];
  if (v4) {
    CFRelease(v4);
  }
  CFRelease((CFTypeRef)(v3 - 16));
}

uint64_t ___ZN12HTTPProtocol17ssNeedServerTrustEP10__SecTrustU13block_pointerFv28SSLPeerTrustAcceptancePolicyE_block_invoke_2( uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___ZN12HTTPProtocol25ssPreConnectConfigurationEPU28objcproto17OS_tcp_connection8NSObjectU13block_pointerFvvE_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = (const void *)(v2 - 16);
  (*(void (**)(uint64_t, void, void, void))(*(void *)v2 + 352LL))( v2,  *(void *)(a1 + 32),  0LL,  *(void *)(a1 + 40));
  nw_release(*(void **)(a1 + 32));
  CFRelease(v3);
}

uint64_t ___ZN12HTTPProtocol25canRetryRequestAfterErrorEPK13CFStreamErrorb_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 2130LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void ___ZN12HTTPProtocol14resetAuthStateEv_block_invoke(uint64_t a1)
{
  std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](*(void *)(a1 + 32) + 776LL, &v5);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)&v5 + 1);
  if (*((void *)&v5 + 1))
  {
    uint64_t v3 = (unint64_t *)(*((void *)&v5 + 1) + 8LL);
    do
      unint64_t v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

void ___ZN12HTTPProtocol27generateProxyAuthenticationENSt3__110shared_ptrI12NetworkProxyEENS1_I19HTTPResponseMessageEE18SmartBlockWithArgsIJNS1_I19AuthenticationStateEEEE_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unsigned int v3 = *(_DWORD *)(v2 + 192);
  unint64_t v4 = v3 | ((unint64_t)*(unsigned __int16 *)(v2 + 196) << 32) | 0x8000000000LL;
  *(_DWORD *)(v2 + 192) = v3;
  *(_WORD *)(v2 + 1std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v5 - 96) = WORD2(v4);
  __int128 v5 = *(std::__shared_weak_count **)(a1 + 48);
  uint64_t v25 = *(void *)(a1 + 40);
  CFIndex v26 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 600LL))(v2, &v25);
  uint64_t v8 = v26;
  if (v26)
  {
    unint64_t v9 = (unint64_t *)&v26->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (!*(void *)(v2 + 776))
  {
    _ZNSt3__115allocate_sharedB8nn180100I19AuthenticationStateNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((std::__shared_weak_count_vtbl **)&v24);
    std::shared_ptr<CoreSchedulingSet>::operator=[abi:nn180100](v2 + 776, &v24);
    uint64_t v21 = (std::__shared_weak_count *)*((void *)&v24 + 1);
    if (*((void *)&v24 + 1))
    {
      unint64_t v22 = (unint64_t *)(*((void *)&v24 + 1) + 8LL);
      do
        unint64_t v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
  }

  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v11 = *(void *)(a1 + 64);
  if (v11)
  {
    uint64_t v13 = (unint64_t *)(v11 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  *(void *)(v2 + 624) = v12;
  uint64_t v15 = *(std::__shared_weak_count **)(v2 + 632);
  *(void *)(v2 + 6std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v11;
  if (v15)
  {
    unint64_t v16 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  HasCredentialsForuint64_t Challenge = HTTPProtocol::_CFHTTPProtHasCredentialsForChallenge( *(HTTPProtocol **)(a1 + 72),  (__CFHTTPMessage *)(*(void *)(a1 + 88) - 16LL));
  if ((*(_DWORD *)(v2 + 192) & 0x200000) == 0 && *(void *)(v2 + 776))
  {
    if (HasCredentialsForChallenge)
    {
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 616LL))(v2);
      uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 648LL))(v2);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 120LL))(v2, v19, v20);
    }

    else
    {
      HTTPProtocol::challengeDelegateOrFinishBrokeringProxyAuth((HTTPProtocol *)v2);
    }
  }

void sub_182AE51D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *__copy_helper_block_e8_40c41_ZTSKNSt3__110shared_ptrI12NetworkProxyEE56c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE72c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE88c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE( void *result, void *a2)
{
  uint64_t v2 = a2[6];
  result[5] = a2[5];
  result[6] = v2;
  if (v2)
  {
    unsigned int v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  uint64_t v5 = a2[8];
  result[7] = a2[7];
  result[8] = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  uint64_t v8 = a2[10];
  result[9] = a2[9];
  result[10] = v8;
  if (v8)
  {
    unint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  uint64_t v11 = a2[12];
  result[11] = a2[11];
  result[12] = v11;
  if (v11)
  {
    uint64_t v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  return result;
}

uint64_t __destroy_helper_block_e8_40c41_ZTSKNSt3__110shared_ptrI12NetworkProxyEE56c71_ZTS18SmartBlockWithArgsIJNSt3__110shared_ptrI19AuthenticationStateEEEE72c40_ZTSNSt3__110shared_ptrI12HTTPProtocolEE88c47_ZTSNSt3__110shared_ptrI19HTTPResponseMessageEE( uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  uint64_t v2 = a1 + 56;
  uint64_t v3 = a1 + 72;
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](a1 + 88);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2);
  return std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v1);
}

char *___ZN12HTTPProtocol14needsThrottlerEv_block_invoke()
{
  uint64_t result = getenv("CFNETWORK_NOTHROTTLE");
  HTTPProtocol::needsThrottler(void)::okToThrottle = result == 0LL;
  return result;
}

void _ApplyOriginalComponents(NSURLRequest *a1, CFTypeRef *a2)
{
  if (!a1) {
    return;
  }
  CFTypeRef v3 = *a2;
  unint64_t v4 = -[NSURLRequest cfURL](a1, "cfURL");
  if (!v3 || v4 == 0LL) {
    return;
  }
  __int128 v18 = 0u;
  *(_OWORD *)CFTypeRef cf = 0u;
  __int128 v17 = 0u;
  __int128 v15 = 0u;
  memset(theString1, 0, sizeof(theString1));
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  memset(theString2, 0, sizeof(theString2));
  if (_CFURLCopyComponents() && _CFURLCopyComponents())
  {
    if (cf[0]) {
      BOOL v6 = (void)v15 == 0LL;
    }
    else {
      BOOL v6 = 0;
    }
    int v7 = v6;
    if (v6) {
      *(void *)&__int128 v15 = CFRetain(cf[0]);
    }
    if (theString1[0])
    {
      if (theString2[0])
      {
        if (theString1[3])
        {
          if (theString2[3])
          {
            if (CFStringCompare(theString1[0], theString2[0], 1uLL) == kCFCompareEqualTo
              && CFStringCompare(theString1[3], theString2[3], 1uLL) == kCFCompareEqualTo)
            {
              int32x4_t v9 = (int32x4_t)vtstq_s64(*(int64x2_t *)&theString1[1], *(int64x2_t *)&theString1[1]);
              *(int32x2_t *)v9.i8 = vmovn_s64((int64x2_t)v9);
              v9.i32[0] = vmovn_s32(v9).u32[0];
              int64x2_t v10 = vceqzq_s64(*(int64x2_t *)&theString2[1]);
              v9.i32[1] = vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v10, v10)).i32[1];
              if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(*(int16x4_t *)v9.i8, 0xFuLL))) & 1) != 0
                && (void)v17 == (void)v13)
              {
                theString2[1] = (CFStringRef)CFRetain(theString1[1]);
                uint64_t v11 = theString1[2];
                if (theString1[2]) {
                  uint64_t v11 = (const __CFString *)CFRetain(theString1[2]);
                }
                theString2[2] = v11;
                goto LABEL_24;
              }
            }
          }
        }
      }
    }

    if (v7)
    {
LABEL_24:
      uint64_t v8 = (const void *)_CFURLCreateFromComponents();
      goto LABEL_26;
    }
  }

  uint64_t v8 = 0LL;
LABEL_26:
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString2);
  _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper((uint64_t)theString1);
  if (v8)
  {
    CFRetain(v8);
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = v8;
    CFRelease(v8);
  }

void sub_182AE547C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

uint64_t _CreateURLWithAddedComponentsIfNeeded(__CFURL const*,__CFURL const*)::ComponentsWrapper::~ComponentsWrapper( uint64_t a1)
{
  uint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  CFTypeRef v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  unint64_t v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRelease(v5);
  }
  BOOL v6 = *(const void **)(a1 + 40);
  if (v6) {
    CFRelease(v6);
  }
  int v7 = *(const void **)(a1 + 48);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(const void **)(a1 + 56);
  if (v8) {
    CFRelease(v8);
  }
  int32x4_t v9 = *(const void **)(a1 + 64);
  if (v9) {
    CFRelease(v9);
  }
  int64x2_t v10 = *(const void **)(a1 + 72);
  if (v10) {
    CFRelease(v10);
  }
  return a1;
}

__CFDictionary *HTTPProtocol::copyVaryState( HTTPProtocol *this, const __CFString *a2, void *cf, const _CFURLRequest *a4)
{
  BOOL v6 = CFGetAllocator(cf);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v6, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  uint64_t v8 = CFGetAllocator(cf);
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v8, a2, @",");
  if (ArrayBySeparatingStrings)
  {
    int64x2_t v10 = ArrayBySeparatingStrings;
    CFTypeRef v28 = CFRetain(ArrayBySeparatingStrings);
    unint64_t Count = CFArrayGetCount(v10);
    CFIndex v12 = Count;
    CFIndex v29 = Count;
    if (Count - 1 > 0x1FFFFFFFFFFFFFFDLL)
    {
      SInt32 v30 = 0LL;
    }

    else
    {
      if (Count > 0x1E)
      {
        __int128 v13 = (const void **)malloc(8 * Count);
        SInt32 v30 = v13;
        if (!v13)
        {
          CFIndex v32 = 0LL;
          goto LABEL_9;
        }
      }

      else
      {
        __int128 v13 = (const void **)v31;
        SInt32 v30 = (const void **)v31;
      }

      v38.CFIndex location = 0LL;
      v38.CFIndex length = v12;
      CFArrayGetValues(v10, v38, v13);
      CFIndex v12 = v29;
    }

    CFIndex v32 = 0LL;
    if (v12 < 1)
    {
LABEL_26:
      CFRelease(v10);
      CFContainerEnumeratorBase::~CFContainerEnumeratorBase((CFContainerEnumeratorBase *)&v28);
      return Mutable;
    }

void sub_182AE5878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t HTTPRequestParserClient::isGetMethod(HTTPRequestParserClient *this)
{
  uint64_t result = *((void *)this + 3);
  if (result) {
    return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2604], 0LL) == kCFCompareEqualTo;
  }
  uint64_t result = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
  {
    *(_WORD *)CFTypeRef v3 = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "these should always be initialized now",  v3,  2u);
    uint64_t result = *((void *)this + 3);
    if (result) {
      return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2604], 0LL) == kCFCompareEqualTo;
    }
  }

  return result;
}

uint64_t HTTPRequestParserClient::isHeadRequest(HTTPRequestParserClient *this)
{
  uint64_t result = *((void *)this + 3);
  if (result) {
    return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2611], 0LL) == kCFCompareEqualTo;
  }
  uint64_t result = os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
  {
    *(_WORD *)CFTypeRef v3 = 0;
    _os_log_fault_impl( &dword_18298D000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "these should always be initialized now",  v3,  2u);
    uint64_t result = *((void *)this + 3);
    if (result) {
      return CFStringCompare((CFStringRef)result, (CFStringRef)&gConstantCFStringValueTable[2611], 0LL) == kCFCompareEqualTo;
    }
  }

  return result;
}

uint64_t ___ZN12HTTPProtocol29validateCachedResponseForLoadEPK20_CFCachedURLResponse_block_invoke@<X0>( uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  uint64_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 755LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

uint64_t ___ZN12HTTPProtocol22copyCookiesForThisTaskEP16NSURLSessionTask_block_invoke( uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFTypeRef v3 = CFRetain(cf);
  }
  else {
    CFTypeRef v3 = 0LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v3;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void std::deque<SmartBlockWithArgs<_CFURLCredential const*,BOOL>>::pop_front(uint64_t a1)
{
  std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100]( *(void *)(*(void *)(a1 + 8) + ((*(void *)(a1 + 32) >> 5) & 0x7FFFFFFFFFFFFF8LL))
  + 16LL * *(void *)(a1 + 32));
  int64x2_t v2 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_182C9D770);
  *(int64x2_t *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = v2;
  if (v2.i64[0] >= 0x200uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 256LL;
  }

void setTypeProperty<_CFURLAuthChallenge *>(CFTypeRef *a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = cf;
}

void HTTPProtocol::executePACQuery(HTTPProtocol *this, void *cf, __CFString *a3)
{
  BOOL v6 = (void *)*((void *)this + 11);
  CFTypeRef v7 = (CFTypeRef)*((void *)this + 49);
  if (v7 != cf)
  {
    if (v7) {
      CFRelease(v7);
    }
    if (cf) {
      CFTypeRef v8 = CFRetain(cf);
    }
    else {
      CFTypeRef v8 = 0LL;
    }
    *((void *)this + 49) = v8;
  }

  int32x4_t v9 = *(const void **)(objc_msgSend(v6, "_inner", 0, this, 0, 0, 0) + 8);
  if (a3) {
    uint64_t v11 = (PAC *)a3;
  }
  else {
    uint64_t v11 = (PAC *)cf;
  }
  *((void *)this + 3_Block_object_dispose((const void *)(v1 - 136), 8) = PAC::CreatePACTicket( v11,  v9,  0LL,  0LL,  (std::__shared_weak_count_vtbl *)HTTPProtocol::_PACExecutionComplete,  (void (*)(void *, const __CFArray *, __CFError *))&v34,  v10);
  uint64_t v12 = *((void *)this + 45);
  if (v12)
  {
    Username = (const void *)CFURLCredentialGetUsername(v12);
    uint64_t v15 = URLCredential_PasswordBased::safelyCast(*((void *)this + 45), v14);
    if (v15) {
      unint64_t v16 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 128LL))(v15);
    }
    else {
      unint64_t v16 = 0LL;
    }
    __int128 v17 = (__CFRunLoopSource *)*((void *)this + 38);
    memset(&context, 0, sizeof(context));
    CFRunLoopSourceGetContext(v17, &context);
    uint64_t v18 = *((void *)context.info + 7);
    if (Username) {
      CFTypeRef v19 = CFRetain(Username);
    }
    else {
      CFTypeRef v19 = 0LL;
    }
    uint64_t v20 = *(const void **)(v18 + 16);
    *(void *)(v18 + CFRelease((char *)this - 16) = v19;
    if (v20) {
      CFRelease(v20);
    }
    if (v16) {
      CFTypeRef v21 = CFRetain(v16);
    }
    else {
      CFTypeRef v21 = 0LL;
    }
    unint64_t v22 = *(const void **)(v18 + 24);
    *(void *)(v18 + 24) = v21;
    if (v22) {
      CFRelease(v22);
    }
    if (v16) {
      CFRelease(v16);
    }
  }

  uint64_t v23 = *((void *)this + 3);
  if (v23 && *(_DWORD *)(v23 + 40))
  {
    __int128 v24 = (CFStringRef (__cdecl *)(const void *))*((void *)this + 38);
    context.version = MEMORY[0x1895F87A8];
    context.uint64_t info = (void *)3221225472LL;
    context.retain = (const void *(__cdecl *)(const void *))___ZNK17CoreSchedulingSet14scheduleSourceEP17__CFRunLoopSource_block_invoke;
    context.release = (void (__cdecl *)(const void *))&__block_descriptor_40_e38_v24__0____CFRunLoop__8____CFString__16l;
    context.copyDescription = v24;
    CoreSchedulingSet::applyBlockWithPossibleEmulation(v23, &context);
  }

  else
  {
    context.version = 0LL;
    memset(&context.retain, 0, 24);
    context.uint64_t info = this;
    uint64_t v25 = CFGetAllocator((char *)this - 16);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    __int16 v27 = CFRunLoopTimerCreate( v25,  Current + 60.0,  -1.0,  0LL,  0LL,  (CFRunLoopTimerCallBack)HTTPProtocol::_PacTimerCallback,  (CFRunLoopTimerContext *)&context);
    CFTypeRef v28 = CFRunLoopGetCurrent();
    CFRunLoopAddTimer(v28, v27, @"_kProxySupportSyncPACExecutionRunLoopMode");
    CFIndex v29 = CFRunLoopGetCurrent();
    CFRunLoopAddSource(v29, *((CFRunLoopSourceRef *)this + 38), @"_kProxySupportSyncPACExecutionRunLoopMode");
    SInt32 v30 = (const void *)*((void *)this + 38);
    if (v30)
    {
      CFTypeRef v31 = CFRetain(v30);
      while (*((void *)this + 38))
        CFRunLoopRunInMode(@"_kProxySupportSyncPACExecutionRunLoopMode", 1.0e10, 1u);
    }

    else
    {
      CFTypeRef v31 = 0LL;
    }

    CFIndex v32 = CFRunLoopGetCurrent();
    CFRunLoopRemoveTimer(v32, v27, @"_kProxySupportSyncPACExecutionRunLoopMode");
    uint64_t v33 = CFRunLoopGetCurrent();
    CFRunLoopRemoveSource(v33, *((CFRunLoopSourceRef *)this + 38), @"_kProxySupportSyncPACExecutionRunLoopMode");
    if (v27) {
      CFRelease(v27);
    }
    if (v31) {
      CFRelease(v31);
    }
  }

void HTTPProtocol::_PacTimerCallback(HTTPProtocol *this, __CFRunLoopTimer *a2, void *a3)
{
  unint64_t v4 = CFGetAllocator((char *)a2 - 16);
  CFCFStreamError Error = __cfnCreateCFError(v4, @"kCFErrorDomainCFNetwork", 308LL, v5, v6, v7, v8, v9, 0LL);
  uint64_t v11 = DiagnosticLogging::newMsg((uint64_t)&__block_literal_global_131, 2);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((*(unsigned int (**)(void *, const char *, __CFRunLoopTimer *))(*(void *)v11 + 24LL))( v11,  "Protocol PAC Timeout",  a2))
    {
      (*(void (**)(void *, const char *, void))(*(void *)v12 + 48LL))( v12,  "Request",  *((void *)a2 + 11));
      (*(void (**)(void *, const char *, __CFError *))(*(void *)v12 + 56LL))(v12, "Error", CFError);
      (*(void (**)(void *))(*(void *)v12 + 8LL))(v12);
    }
  }

  HTTPProtocol::pacExecutionComplete((HTTPProtocol *)a2, 0LL, CFError);
  if (CFError) {
    CFRelease(CFError);
  }
  CFAbsoluteTime Current = CFRunLoopGetCurrent();
  CFRunLoopStop(Current);
}

void HTTPProtocol::pacExecutionComplete(HTTPProtocol *this, const __CFArray *a2, CFErrorRef err)
{
  uint64_t v6 = (__CFRunLoopSource *)*((void *)this + 38);
  if (v6)
  {
    CFRunLoopSourceInvalidate(v6);
    uint64_t v7 = (const void *)*((void *)this + 38);
    if (v7) {
      CFRelease(v7);
    }
  }

  *((void *)this + 3_Block_object_dispose((const void *)(v1 - 136), 8) = 0LL;
  if (!err)
  {
    __int128 v24 = (const __CFArray *)*((void *)this + 37);
    if (v24)
    {
      CFIndex Count = CFArrayGetCount(v24);
      CFIndex v26 = CFArrayGetCount(a2);
      __int16 v27 = CFGetAllocator((char *)this - 16);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v27, v26 + Count, MEMORY[0x189605228]);
      v50.CFIndex location = 0LL;
      v50.CFIndex length = v26;
      CFArrayAppendArray(Mutable, a2, v50);
      v51.CFIndex location = 0LL;
      v51.CFIndex length = Count;
      CFArrayAppendArray(Mutable, *((CFArrayRef *)this + 37), v51);
      CFIndex v29 = (const void *)*((void *)this + 37);
      if (v29) {
        CFRelease(v29);
      }
    }

    else
    {
      SInt32 v30 = CFGetAllocator((char *)this - 16);
      CFIndex v31 = CFArrayGetCount(a2);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutableCopy(v30, v31, a2);
    }

    *((void *)this + 37) = Mutable;
    if (*((void *)this + 45))
    {
      uint64_t v32 = *((void *)this + 48);
      if (v32)
      {
        (*(void (**)(void, void, void, void))(**((void **)this + 87) + 56LL))( *((void *)this + 87),  *((void *)this + 45),  *(void *)(v32 + 40),  *((void *)this + 10));
      }
    }

uint64_t ___ZN12HTTPProtocol19pacExecutionTimeoutEP16__CFRunLoopTimer_block_invoke@<X0>(uint64_t a1@<X8>)
{
  *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent();
  int64x2_t v2 = pthread_self();
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v1 - 136), 8) = pthread_mach_thread_np(v2);
  uint64_t result = getpid();
  *(_DWORD *)(a1 + 12) = result;
  *(void *)(a1 + CFRelease((char *)this - 16) = "CFNetwork.f";
  *(void *)(a1 + 24) = "CFNetwork";
  *(void *)(a1 + std::shared_ptr<HTTPResponseMessage>::~shared_ptr[abi:nn180100](v2 - 32) = 3800LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 136), 8) = "none";
  return result;
}

void ___ZN12HTTPProtocol28_protocolInterface_startLoadEPK20_CFCachedURLResponse_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFTypeRef v3 = (const void *)(v2 - 16);
  (*(void (**)(uint64_t, void))(*(void *)v2 + 88LL))(v2, *(void *)(a1 + 40));
  CFRelease(v3);
  unint64_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    CFRelease(v4);
  }
}

void ___ZN9TCFObjectI11URLProtocolE5ClassEv_block_invoke_7265()
{
  os_log_t v0 = (CFClass *)operator new(0x68uLL);
  *(_DWORD *)((char *)_PNAME<URLProtocol>::GET(void)::p + 7) = 1819239279;
  _PNAME<URLProtocol>::GET(void)::p[0] = *(void *)"URLProtocol>::GET() [OBJTYPE = URLProtocol]";
  CFClass::CFClass(v0, (const char *)_PNAME<URLProtocol>::GET(void)::p);
  TCFObject<URLProtocol>::Class(void)::clazz = (uint64_t)v0;
}

void sub_182AE6490(_Unwind_Exception *a1)
{
}

BOOL equalData(CFDataRef cf1, CFDataRef theData)
{
  if (cf1 == theData) {
    return 1LL;
  }
  if (cf1 && theData)
  {
    if (CFEqual(cf1, theData)) {
      return 1LL;
    }
  }

  else if (!cf1)
  {
    unint64_t v4 = theData;
    return CFDataGetLength(v4) == 0;
  }

  unint64_t v4 = cf1;
  return CFDataGetLength(v4) == 0;
}

CFTypeRef ___ZN12HTTPProtocol30_createMutableCanonicalRequestEPK13__CFAllocatorPK13_CFURLRequestP16NSURLSessionTaskPKv_block_invoke_4()
{
  return CFRetain(@"application/x-www-form-urlencoded");
}

CFTypeRef ___ZN12HTTPProtocol30_createMutableCanonicalRequestEPK13__CFAllocatorPK13_CFURLRequestP16NSURLSessionTaskPKv_block_invoke_3()
{
  return CFRetain(@"gzip, deflate");
}

CFTypeRef ___ZN12HTTPProtocol30_createMutableCanonicalRequestEPK13__CFAllocatorPK13_CFURLRequestP16NSURLSessionTaskPKv_block_invoke()
{