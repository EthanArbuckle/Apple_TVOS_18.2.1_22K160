LABEL_27:
  v12 = 8196LL;
  if (!byte_18C4ABA02) {
    v12 = 0x2000LL;
  }
  v14 = v12;
  dispatch_sync_f( (dispatch_queue_t)self->_dispatchQueue,  context,  (dispatch_function_t)developerSubmittedBlockToNSManagedObjectContextPerform);
}

    v22 = -[NSPredicate predicateOperatorType](self->super._predicate, "predicateOperatorType");
    v23 = -[NSPredicate comparisonPredicateModifier](self->super._predicate, "comparisonPredicateModifier");
    v24 = self->_effectiveLeftExpression;
    v25 = self->_effectiveRightExpression;
    if (!self->_comparisonPredicateScopedItem) {
      self->_comparisonPredicateScopedItem = (NSMutableArray *)objc_alloc_init(MEMORY[0x189603FA8]);
    }
    if (v22 == 99) {
      v26 = v24;
    }
    else {
      v26 = v25;
    }
    if (v22 == 99) {
      v24 = v25;
    }
    v27 = -[NSExpression expressionType](v24, "expressionType");
    v28 = -[NSExpression expressionType](v26, "expressionType");
    if (v28 == 2)
    {
      v29 = -[NSExpression variable](v26, "variable");
      v30 = (NSExpression *)objc_msgSend( (id)objc_msgSend(a3, "objectForKey:", @"substitutionVariables"),  "objectForKey:",  v29);
      if (v30)
      {
        v31 = v30;
        v130 = v29;
        v32 = -[NSExpression expressionType](v30, "expressionType");
        v131 = [a3 objectForKey:@"duringPrefetching"] != 0;
        v26 = v31;
        v12 = 0x18C4A5000LL;
      }

      else
      {
        v131 = 0;
        v130 = 0LL;
        v32 = 2LL;
      }
    }

    else
    {
      v32 = v28;
      v131 = 0;
      v130 = 0LL;
    }

    if (v27 >= 5
      && ([(id)objc_opt_class() isSimpleKeypath:v24] & 1) == 0
      && (-[NSSQLIntermediate isVariableBasedKeypathScopedBySubquery:]((uint64_t)self, v24) & 1) == 0
      && (-[NSSQLIntermediate isSimpleNoIndexFunction:]((uint64_t)self, v24) & 1) == 0)
    {
      v49 = (void *)MEMORY[0x189603F70];
      v50 = *MEMORY[0x189603A60];
      v51 = [NSString stringWithFormat:@"unimplemented SQL generation for predicate : (%@) (bad LHS)", self->super._predicate];
      goto LABEL_74;
    }

    v48 = (unint64_t)v32 > 0x32 || ((1LL << v32) & 0x400000000600DLL) == 0;
    if (v48
      && ([(id)objc_opt_class() isSimpleKeypath:v24] & 1) == 0
      && (-[NSSQLIntermediate isVariableBasedKeypathScopedBySubquery:]((uint64_t)self, v26) & 1) == 0
      && !-[NSSQLIntermediate _functionExpressionIsSubqueryFollowedByKeypath:]((BOOL)self, v26))
    {
      v49 = (void *)MEMORY[0x189603F70];
      v50 = *MEMORY[0x189603A60];
      v51 = [NSString stringWithFormat:@"unimplemented SQL generation for predicate : (%@) (bad RHS)", self->super._predicate];
      goto LABEL_74;
    }

    if ((v27 == 3 || -[NSSQLIntermediate isVariableBasedKeypathScopedBySubquery:]((uint64_t)self, v24))
      && (v32 == 3 || -[NSSQLIntermediate isVariableBasedKeypathScopedBySubquery:]((uint64_t)self, v26)))
    {
      v49 = (void *)MEMORY[0x189603F70];
      v50 = *MEMORY[0x189603A60];
      v51 = [NSString stringWithFormat:@"unimplemented SQL generation for predicate : (%@) (LHS and RHS both keypaths)", self->super._predicate];
LABEL_74:
      objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(v49, "exceptionWithName:reason:userInfo:", v50, v51, 0),  @"NSUnderlyingException");
      v9 = 0LL;
      goto LABEL_103;
    }

    [*(id *)((char *)&self->super.super.super.isa + *(int *)(v12 + 1420)) addObject:v24];
    if (v32 > 13)
    {
      if (v32 == 50) {
        goto LABEL_132;
      }
      if (v32 == 14)
      {
        v52 = (__CFString *)-[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:]( self,  v24,  v23 == 2,  a3);
        v9 = v52;
        if (v52)
        {
          -[__CFString appendString:](v52, "appendString:", @" IN ");
          v53 = -[NSSQLIntermediate _generateSQLForExpressionCollection:allowToMany:inContext:]( self,  -[NSExpression constantValue](v26, "constantValue"),  0LL,  a3);
          if (v53)
          {
LABEL_135:
            v80 = v53;
            -[__CFString appendString:](v9, "appendString:", v53);

LABEL_193:
            LODWORD(v54) = 1;
            goto LABEL_221;
          }

          goto LABEL_83;
        }

        goto LABEL_220;
      }

    if (v23 <= v12 >> 16) {
      goto LABEL_35;
    }
    v12 = String.UTF8View._foreignIndex(after:)();
LABEL_29:
    *(_BYTE *)(a2 + v11) = v19;
    if (v26 == v11)
    {
      v11 = a3;
      goto LABEL_33;
    }

    ++v11;
    if (v10 == v12 >> 14) {
      goto LABEL_33;
    }
  }

  __break(1u);
LABEL_35:
  __break(1u);
LABEL_36:
  __break(1u);
  return result;
}

  objc_autoreleasePoolPop(v5);
  return v20;
}

    if (a3)
    {
      v20 = (void *)MEMORY[0x189607870];
      v27 = @"expression";
      v28 = a1;
      v21 = [MEMORY[0x189603F68] dictionaryWithObjects:&v28 forKeys:&v27 count:1];
      v11 = 0;
      *a3 = (id)[v20 errorWithDomain:*MEMORY[0x189607460] code:134097 userInfo:v21];
      goto LABEL_21;
    }

    v21 = (unint64_t *)(a1[19] + 40);
    while (!__ldaxr(v21))
    {
    }

    __clrex();
    if (v5)
    {
      v23 = v6;
      do
      {
        v24 = *v23++;

        --v5;
      }

      while (v5);
    }

    PF_FREE_OBJECT_ARRAY(v6);
    return *(void *)(a1[19] + 40);
  }

  return result;
}

    v12 = atomic_load((unsigned __int8 *)&self->_isMainThreadBlessed);
    if ((v12 & 1) == 0)
    {
      LOBYTE(v7) = v3 != 0;
      return v7;
    }

    v13 = atomic_load((unsigned __int8 *)&self->_isMainThreadBlessed);
    if ((v13 & 1) == 0 || !_PFIsSerializedWithMainQueue())
    {
      LOBYTE(v7) = 0;
      return v7;
    }

  return 0;
}

    +[NSPersistentStoreCoordinator _endPowerAssertionWithAssert:andApp:]( (uint64_t)&OBJC_CLASS___NSPersistentStoreCoordinator,  v32,  v27);
    [v26 drain];
    if (a6) {
      v24 = v15;
    }
    else {
      v24 = 1;
    }
    if ((v24 & 1) == 0) {
      *a6 = v33;
    }
  }

  else
  {
    objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"Invalid store URL: nil" userInfo:0]);
    objc_exception_rethrow();
    __break(1u);
  }

      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)) {
        break;
      }
      v4 = v32 + 1;
      if (v32 + 1 == v30)
      {
        v30 = [obj countByEnumeratingWithState:&v37 objects:v42 count:16];
        if (v30) {
          goto LABEL_3;
        }
        break;
      }
    }
  }

  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = [v3 copy];
  }
}

  v122.receiver = self;
  v122.super_class = (Class)&OBJC_CLASS___NSSQLCore;
  v20 = -[NSPersistentStore initWithPersistentStoreCoordinator:configurationName:URL:options:]( &v122,  sel_initWithPersistentStoreCoordinator_configurationName_URL_options_,  a3,  a4,  a5,  a6);
  val = v20;
  if (!v20) {
    return 0LL;
  }
  v20->_remoteNotificationToken = -1;
  if (HIBYTE(v123)
    && objc_msgSend( (id)objc_msgSend(a6, "objectForKey:", @"NSPersistentStoreRemoveStoreOnCleanup"),  "BOOLValue"))
  {
    -[NSPersistentStore doFilesystemCleanupOnRemove:](val, "doFilesystemCleanupOnRemove:", 1LL);
  }

  if (!a3)
  {
    v91 = 0LL;
    v92 = 0LL;
    v90 = 0LL;
    goto LABEL_48;
  }

  v92 = objc_alloc_init(MEMORY[0x189603FC8]);
  v91 = objc_alloc_init(MEMORY[0x189603FC8]);
  v90 = objc_alloc_init(MEMORY[0x189603FE0]);
  v120 = 0u;
  v121 = 0u;
  v118 = 0u;
  v119 = 0u;
  v21 = (void *)[a3 persistentStores];
  v22 = [v21 countByEnumeratingWithState:&v118 objects:v130 count:16];
  if (v22)
  {
    v23 = *(void *)v119;
LABEL_34:
    v24 = 0LL;
    while (1)
    {
      if (*(void *)v119 != v23) {
        objc_enumerationMutation(v21);
      }
      v25 = *(void **)(*((void *)&v118 + 1) + 8 * v24);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        break;
      }
      if (v22 == ++v24)
      {
        v22 = [v21 countByEnumeratingWithState:&v118 objects:v130 count:16];
        if (v22) {
          goto LABEL_34;
        }
        goto LABEL_44;
      }
    }

    v26 = (void *)[v25 model];
    if (!v26) {
      goto LABEL_44;
    }
    v27 = v26;
  }

  else
  {
LABEL_44:
    v27 = -[NSSQLModel initWithManagedObjectModel:configurationName:brokenHashVersion:]( [NSSQLModel alloc],  "initWithManagedObjectModel:configurationName:brokenHashVersion:",  [a3 managedObjectModel],  0,  0);
  }

  val->_model = v27;
  if (v27)
  {
LABEL_48:
    val->_sqlCoreFlags = (_sqlCoreFlags)(*(_DWORD *)&val->_sqlCoreFlags & 0xFFFFFFFE | +[NSSQLCore coloredLoggingDefault]( &OBJC_CLASS___NSSQLCore,  "coloredLoggingDefault"));
    v116 = 0u;
    v117 = 0u;
    v114 = 0u;
    v115 = 0u;
    model = val->_model;
    if (model) {
      entities = model->_entities;
    }
    else {
      entities = 0LL;
    }
    v31 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( entities,  "countByEnumeratingWithState:objects:count:",  &v114,  v129,  16LL);
    if (v31)
    {
      v32 = *(void *)v115;
      while (2)
      {
        for (i = 0LL; i != v31; ++i)
        {
          if (*(void *)v115 != v32) {
            objc_enumerationMutation(entities);
          }
          v34 = *(void *)(*((void *)&v114 + 1) + 8 * i);
          if (v34 && (*(_BYTE *)(v34 + 280) & 2) != 0)
          {
            *(_DWORD *)&val->_sqlCoreFlags |= 0x2000u;
            goto LABEL_61;
          }
        }

        v31 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( entities,  "countByEnumeratingWithState:objects:count:",  &v114,  v129,  16LL);
        if (v31) {
          continue;
        }
        break;
      }
    }

    *(void *)(*(void *)(a1[7] + 8) + 40LL) = v38;
LABEL_28:

    goto LABEL_29;
  }

  *(_BYTE *)(*(void *)(a1[6] + 8) + 24LL) = 0;
  v24 = objc_alloc(MEMORY[0x189607870]);
  v25 = *MEMORY[0x189607460];
  v39 = *MEMORY[0x1896075E8];
  v40 = @"Failed to initialize the asset storage url because the store was removed from the coordinator.";
  *(void *)(*(void *)(a1[7] + 8) + 40) = objc_msgSend( v24,  "initWithDomain:code:userInfo:",  v25,  134407,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjects:forKeys:count:",  &v40,  &v39,  1));
LABEL_30:
}

            v25 = -[NSSQLIndex sqlEntity](v12, "sqlEntity");
            v26 = [v18 name];
            if (!v25) {
              goto LABEL_47;
            }
            v24 = v26;
            v23 = *(void **)(v25 + 40);
            goto LABEL_29;
          }

          if ([v18 _isRelationship])
          {
            if ([v18 inverseRelationship] && (objc_msgSend(v18, "isToMany") & 1) != 0) {
              goto LABEL_47;
            }
            goto LABEL_27;
          }

          if (v19 != 5) {
            goto LABEL_47;
          }
          v31 = (void *)[v18 expression];
          v32 = [v31 expressionType];
          if (v32 == 3)
          {
            v33 = [v31 keyPath];
            v34 = -[NSSQLIndex sqlEntity](v12, "sqlEntity");
            if (!v34) {
              goto LABEL_47;
            }
            v35 = 136LL;
          }

          else
          {
            if (v32 != 1) {
              goto LABEL_47;
            }
LABEL_40:
            v34 = -[NSSQLIndex sqlEntity](v12, "sqlEntity");
            if (!v34) {
              goto LABEL_47;
            }
            v35 = 128LL;
          }

          v27 = *(void **)(v34 + v35);
          if (!v27) {
            goto LABEL_47;
          }
          goto LABEL_30;
        }

      v21 = v9;
      v22 = v19;
LABEL_30:
      [v21 appendString:v22];
      goto LABEL_31;
    }

    objc_msgSend(v9, "appendString:", -[__CFString columnName](a2, "columnName"));
    objc_msgSend(v9, "appendString:", @", ");
    [v9 appendString:-[NSSQLManyToMany inverseColumnName](a2)];
    if ((v11 & 1) != 0)
    {
LABEL_25:
      if (!v12)
      {
LABEL_31:
        [v9 appendString:@" FROM "];
        [v9 appendString:a4];
        v23 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  0LL,  v9);

        return v23;
      }

      v19 = -[NSSQLManyToMany inverseOrderColumnName](a2);
      objc_msgSend(v9, "appendString:", @", ");
      if (!v19)
      {
        v20 = -[NSSQLManyToMany inverseColumnName](a2);
        goto LABEL_29;
      }

      goto LABEL_27;
    }

    if (a2)
    {
      v16 = a2[2].data;
      objc_msgSend(v9, "appendString:", @", ");
      if (v16)
      {
        v17 = v9;
        v18 = (uint64_t)v16;
LABEL_24:
        [v17 appendString:v18];
        goto LABEL_25;
      }
    }

    else
    {
      objc_msgSend(v9, "appendString:", @", ");
    }

    v18 = -[__CFString columnName](a2, "columnName");
    v17 = v9;
    goto LABEL_24;
  }

  return result;
}

        ++v11;
      }

      while (v9 != v11);
      v62 = [v7 countByEnumeratingWithState:&v74 objects:v81 count:16];
      v9 = v62;
    }

    while (v62);
  }

      if (([v8 isEqual:@"FETCH_REQUEST_LIMIT_SUBSTITUTION"] & 1) == 0
        && ![v8 isEqual:@"FETCH_REQUEST_OFFSET_SUBSTITUTION"])
      {
        [v14 setInt64:v19];
        goto LABEL_30;
      }

void developerSubmittedBlockToNSManagedObjectContextPerform(void *a1)
{
  uint64_t v100 = *MEMORY[0x1895F89C0];
  v3 = (void (**)(void))*a1;
  v2 = (void *)a1[1];
  uint64_t v4 = a1[2];
  if ((v4 & 4) != 0)
  {
    v5 = (void *)MEMORY[0x186E3E5D8]();
    if ((v4 & 0x2000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  v5 = 0LL;
  if ((v4 & 0x2000) != 0) {
LABEL_5:
  }
    __dmb(0xBu);
LABEL_6:
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v7 = *(void **)(StatusReg + 712);
  uint64_t v8 = a1[3];
  p_cache = &OBJC_METACLASS___NSKnownKeysMappingStrategy1.cache;
  uint64_t v91 = v8;
  v90 = v7;
  if (!v8)
  {
    unint64_t v13 = 0LL;
    if (*(void **)(StatusReg + 712) == v2)
    {
      char v15 = 1;
      if (!_PF_Threading_Debugging_level) {
        goto LABEL_21;
      }
      goto LABEL_65;
    }

    goto LABEL_18;
  }

  v10 = *(dispatch_queue_s **)(v8 + 16);
  if (v10) {
    BOOL v11 = _PF_Threading_Debugging_level < 2;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11) {
    dispatch_assert_queue_V2(v10);
  }
  if (v7 != v2)
  {
    v12 = (unint64_t *)(v8 + 8);
    unint64_t v13 = atomic_load(v12);
    do
    {
      unint64_t v14 = __ldaxr(v12);
      if (v14 != v13)
      {
        v89 = v5;
        unint64_t v23 = 0x189607000uLL;
        v24 = "Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)";
        while (1)
        {
          __clrex();
          unint64_t v25 = v23;
          v26 = v24;
          uint64_t v27 = objc_msgSend(*(id *)(v23 + 2600), "stringWithUTF8String:");
          atomic_load((unint64_t *)(v91 + 8));
          _NSCoreDataLog(17LL, v27, v28, v29, v30, v31, v32, v33, v91);
          v34 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            uint64_t v36 = v91;
            unint64_t v37 = atomic_load((unint64_t *)(v91 + 8));
            *(_DWORD *)buf = 134218752;
            uint64_t v93 = v36;
            __int16 v94 = 2048;
            unint64_t v95 = (unint64_t)v2;
            __int16 v96 = 2048;
            unint64_t v97 = v13;
            __int16 v98 = 2048;
            unint64_t v99 = v37;
            _os_log_fault_impl( &dword_186681000,  v34,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
          }

          unint64_t v13 = atomic_load(v12);
          unint64_t v23 = v25;
          v5 = v89;
          v24 = v26;
          p_cache = (void **)(&OBJC_METACLASS___NSKnownKeysMappingStrategy1 + 16);
          while (1)
          {
            unint64_t v35 = __ldaxr(v12);
            if (v35 != v13) {
              break;
            }
          }
        }
      }
    }

    while (__stlxr((unint64_t)v2, v12));
LABEL_16:
    uint64_t v8 = v91;
LABEL_18:
    char v15 = 0;
    *(void *)(StatusReg + 712) = v2;
    goto LABEL_20;
  }

  unint64_t v13 = 0LL;
  char v15 = 1;
LABEL_20:
  if (!*((_BYTE *)p_cache + 3248)) {
    goto LABEL_21;
  }
LABEL_65:
  _PFAssertSafeMultiThreadedAccess_impl((uint64_t)v2, sel_performBlock_);
LABEL_21:
  v3[2](v3);
  if ((v4 & 0x1000) == 0)
  {
    if ((v4 & 1) != 0) {
      _Block_release(v3);
    }
    if ((v4 & 2) != 0)
    {
      [v2 processPendingChanges];
    }

    else if ((v4 & 4) == 0)
    {
LABEL_51:
      if ((v15 & 1) == 0)
      {
        *(void *)(StatusReg + 712) = v90;
        if (v91)
        {
          v21 = (unint64_t *)(v91 + 8);
          while (1)
          {
            unint64_t v22 = __ldaxr(v21);
            if (!__stlxr(v13, v21)) {
              goto LABEL_77;
            }
          }

          __clrex();
          uint64_t v48 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
          atomic_load((unint64_t *)(v91 + 8));
          _NSCoreDataLog(17LL, v48, v49, v50, v51, v52, v53, v54, v91);
          v55 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            unint64_t v88 = atomic_load((unint64_t *)(v91 + 8));
            *(_DWORD *)buf = 134218752;
            uint64_t v93 = v91;
            __int16 v94 = 2048;
            unint64_t v95 = v13;
            __int16 v96 = 2048;
            unint64_t v97 = (unint64_t)v2;
            __int16 v98 = 2048;
            unint64_t v99 = v88;
            _os_log_fault_impl( &dword_186681000,  v55,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
          }

          unint64_t v56 = atomic_load(v21);
          do
          {
            unint64_t v57 = __ldaxr(v21);
            if (v57 != v56)
            {
              while (1)
              {
                __clrex();
                uint64_t v77 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
                atomic_load((unint64_t *)(v91 + 8));
                _NSCoreDataLog(17LL, v77, v78, v79, v80, v81, v82, v83, v91);
                v84 = (os_log_s *)__pflogFaultLog;
                if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                {
                  unint64_t v86 = atomic_load(v21);
                  *(_DWORD *)buf = 134218752;
                  uint64_t v93 = v91;
                  __int16 v94 = 2048;
                  unint64_t v95 = v13;
                  __int16 v96 = 2048;
                  unint64_t v97 = v56;
                  __int16 v98 = 2048;
                  unint64_t v99 = v86;
                  _os_log_fault_impl( &dword_186681000,  v84,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
                }

                unint64_t v56 = atomic_load(v21);
                while (1)
                {
                  unint64_t v85 = __ldaxr(v21);
                  if (v85 != v56) {
                    break;
                  }
                  if (!__stlxr(v13, v21)) {
                    goto LABEL_77;
                  }
                }
              }
            }
          }

          while (__stlxr(v13, v21));
        }
      }

LABEL_77:
      if ((v4 & 1) != 0)
      {
        CFRelease(v2);
        free(a1);
      }

      else
      {
      }

      goto LABEL_80;
    }

    if (v5) {
      objc_autoreleasePoolPop(v5);
    }
    -[NSManagedObjectContext _processReferenceQueue:]((uint64_t)v2, 0);
    goto LABEL_51;
  }

  if ((v4 & 1) != 0)
  {
    _Block_release(v3);
    free(a1);
  }

  if ((v4 & 4) != 0 && v5) {
    objc_autoreleasePoolPop(v5);
  }
  if ((v15 & 1) != 0)
  {
    *(void *)(StatusReg + 712) = 0LL;
    if (v8 && (void *)v13 == v2)
    {
      v16 = (unint64_t *)(v8 + 8);
      while (1)
      {
        unint64_t v17 = __ldaxr(v16);
        if (!__stlxr(0LL, v16)) {
          goto LABEL_80;
        }
      }

      __clrex();
      uint64_t v58 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
      atomic_load((unint64_t *)(v8 + 8));
      _NSCoreDataLog(17LL, v58, v59, v60, v61, v62, v63, v64, v8);
      v65 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        unint64_t v66 = atomic_load((unint64_t *)(v8 + 8));
        *(_DWORD *)buf = 134218752;
        uint64_t v93 = v8;
        __int16 v94 = 2048;
        unint64_t v95 = 0LL;
        __int16 v96 = 2048;
        unint64_t v97 = (unint64_t)v2;
        __int16 v98 = 2048;
        unint64_t v99 = v66;
        _os_log_fault_impl( &dword_186681000,  v65,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
      }
    }
  }

  else
  {
    else {
      unint64_t v18 = v13;
    }
    *(void *)(StatusReg + 712) = v90;
    if (v8)
    {
      v19 = (unint64_t *)(v8 + 8);
      while (1)
      {
        unint64_t v20 = __ldaxr(v19);
        if (!__stlxr(v18, v19)) {
          goto LABEL_80;
        }
      }

      __clrex();
      uint64_t v38 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
      atomic_load((unint64_t *)(v8 + 8));
      _NSCoreDataLog(17LL, v38, v39, v40, v41, v42, v43, v44, v8);
      v45 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        unint64_t v87 = atomic_load((unint64_t *)(v8 + 8));
        *(_DWORD *)buf = 134218752;
        uint64_t v93 = v8;
        __int16 v94 = 2048;
        unint64_t v95 = v18;
        __int16 v96 = 2048;
        unint64_t v97 = (unint64_t)v2;
        __int16 v98 = 2048;
        unint64_t v99 = v87;
        _os_log_fault_impl( &dword_186681000,  v45,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
      }

      unint64_t v46 = atomic_load(v19);
      do
      {
        unint64_t v47 = __ldaxr(v19);
        if (v47 != v46)
        {
          while (1)
          {
            __clrex();
            uint64_t v67 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
            atomic_load((unint64_t *)(v91 + 8));
            _NSCoreDataLog(17LL, v67, v68, v69, v70, v71, v72, v73, v91);
            v74 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              unint64_t v76 = atomic_load(v19);
              *(_DWORD *)buf = 134218752;
              uint64_t v93 = v91;
              __int16 v94 = 2048;
              unint64_t v95 = v18;
              __int16 v96 = 2048;
              unint64_t v97 = v46;
              __int16 v98 = 2048;
              unint64_t v99 = v76;
              _os_log_fault_impl( &dword_186681000,  v74,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
            }

            unint64_t v46 = atomic_load(v19);
            while (1)
            {
              unint64_t v75 = __ldaxr(v19);
              if (v75 != v46) {
                break;
              }
              if (!__stlxr(v18, v19)) {
                goto LABEL_80;
              }
            }
          }
        }
      }

      while (__stlxr(v18, v19));
    }
  }

        uint64_t v52 = (void *)objc_msgSend( (id)objc_msgSend(a3, "valueForKey:", @"explicitRestrictingEntityQualifier"),  "lastObject");
        if ([v52 isEqual:MEMORY[0x189604A88]])
        {
          uint64_t v53 = (void *)[a3 valueForKey:@"persistentStore"];
          uint64_t v54 = (void *)[v53 model];
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            v55 = _sqlEntityForEntityDescription((uint64_t)v54, v12);
            if (!v55) {
              goto LABEL_85;
            }
            goto LABEL_84;
          }

          if ([v12 isNSString])
          {
            unint64_t v56 = (void *)[v54 entityNamed:v12];
            if (!v56)
            {
              if (v54) {
                uint64_t v63 = (void *)v54[3];
              }
              else {
                uint64_t v63 = 0LL;
              }
              uint64_t v64 = [v63 allKeys];
              v65 = (void *)MEMORY[0x189604A58];
              if (v64) {
                unint64_t v66 = v64;
              }
              else {
                unint64_t v66 = MEMORY[0x189604A58];
              }
              uint64_t v67 = [v53 identifier];
              if (v67) {
                uint64_t v68 = (const __CFString *)v67;
              }
              else {
                uint64_t v68 = @"no store ID";
              }
              uint64_t v69 = [v53 configurationName];
              if (v69) {
                uint64_t v70 = (const __CFString *)v69;
              }
              else {
                uint64_t v70 = @"no config";
              }
              uint64_t v71 = (void *)objc_msgSend( (id)objc_msgSend(v54, "managedObjectModel"),  "entitiesForConfiguration:",  objc_msgSend(v53, "configurationName"));
              if (v71) {
                v65 = (void *)[v71 valueForKey:@"name"];
              }
              v77[0] = @"KnownEntities";
              v77[1] = @"StoreID";
              v78[0] = v66;
              v78[1] = v68;
              v77[2] = @"Configuration";
              v77[3] = @"ConfigurationEntities";
              v78[2] = v70;
              v78[3] = v65;
              uint64_t v72 = [MEMORY[0x189603F68] dictionaryWithObjects:v78 forKeys:v77 count:4];
              if (!objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v54, "managedObjectModel"), "entitiesByName"),  "valueForKey:",  v12)
                || ([v65 containsObject:v12] & 1) != 0
                || (uint64_t v73 = [NSString stringWithFormat:@"%@ is not in current configuration - %@.", v12, v70]) == 0)
              {
                uint64_t v73 = [NSString stringWithFormat:@"%@ is not a valid entity name.", v73, v12];
              }

              objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A58], v73, v72),  @"NSUnderlyingException");
              unint64_t v22 = 0;
              goto LABEL_87;
            }

            v55 = (uint64_t)v56;
            v12 = (void *)[v56 entityDescription];
LABEL_84:
            unint64_t v57 = (void *)[a3 valueForKey:@"explicitRestrictingEntityQualifier"];
            objc_msgSend(v57, "replaceObjectAtIndex:withObject:", objc_msgSend(v57, "indexOfObject:", v52), v55);
          }
        }

            v5 = 0LL;
LABEL_78:
            ((void (*)(void *))v90)(v89);
            return v5;
          }

          char v15 = &unk_189F03360;
        }
      }

      else
      {
        char v15 = &unk_189F032E8;
      }
    }

    unint64_t v20 = 4866LL;
LABEL_76:
    objc_msgSend( a3,  "failWithError:",  objc_msgSend(MEMORY[0x189607870], "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], v20, v15));

    goto LABEL_77;
  }

  return v5;
}

    if (a14)
    {
      v26 = (void *)MEMORY[0x189607870];
      uint64_t v27 = *MEMORY[0x189607460];
      uint64_t v28 = (void *)MEMORY[0x189603F68];
      uint64_t v29 = @"Cant' read entity: Properties buffer has content";
LABEL_122:
      v129 = objc_msgSend( v26,  "errorWithDomain:code:userInfo:",  v27,  134060,  objc_msgSend(v28, "dictionaryWithObject:forKey:", v29, @"Root cause"));
      result = 0LL;
      *a14 = v129;
      return result;
    }

    return 0LL;
  }

    v136 = 0LL;
    goto LABEL_78;
  }

LABEL_80:
  if ((v4 & 0x2000) != 0) {
    __dmb(0xBu);
  }
}

  v92 = (v69 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v93 = v92 + 4;
  if (v92 + 4 <= a4)
  {
    __int16 v94 = bswap32(*(_DWORD *)(a2 + v92));
    v142 = v92 + 4;
    v92 = (v92 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v95 = v92 + 4;
    uint64_t v69 = v93;
  }

  else
  {
    __int16 v94 = 0;
    unint64_t v95 = v92 + 4;
  }

  if (v95 <= a4)
  {
    __int16 v96 = bswap32(*(_DWORD *)(a2 + v92));
    v142 = v95;
    uint64_t v69 = v95;
  }

  else
  {
    __int16 v96 = 0;
  }

  if (v94)
  {
    unint64_t v97 = *(id *)(a11 + 8LL * v96);
  }

  else
  {
    unint64_t v97 = *(id *)(v18 + 8LL * v96);
    uint64_t v69 = v142;
  }

  *(void *)(v20 + 48) = v97;
  __int16 v98 = (v69 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v99 = v98 + 4;
  if (v98 + 4 > a4) {
    goto LABEL_96;
  }
  uint64_t v100 = *(_DWORD *)(a2 + v98);
  v142 = v99;
  uint64_t v69 = v99;
  if (!v100) {
    goto LABEL_96;
  }
  v138 = (void **)v18;
  v101 = *(void *)(a10 + 8LL * bswap32(v100));
  callBacks.version = 0LL;
  v102 = (void *)MEMORY[0x189604010];
  v103 = objc_opt_class();
  v131 = objc_opt_class();
  v104 = +[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)_PFRoutines,  [v102 setWithObjects:v103],  v101,  (uint64_t)&callBacks);
  if (!v104)
  {
LABEL_123:
    v130 = @"Can't decode predicate for fetch request";
LABEL_125:
    _NSCoreDataLog(1LL, (uint64_t)v130, v59, v60, v61, v62, v63, v64, v131);
    if (a14) {
      *a14 = callBacks.version;
    }
    return 0LL;
  }

  v105 = (void *)v104;
  if (!byte_18C4ABDC6)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0) {
      [v105 allowEvaluation];
    }
  }

  *(void *)(v20 + 56) = v105;
  uint64_t v69 = v142;
  unint64_t v18 = (uint64_t)v138;
LABEL_96:
  v106 = (v69 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v107 = v106 + 4;
  if (v106 + 4 <= a4)
  {
    v108 = *(_DWORD *)(a2 + v106);
    v142 = v107;
    uint64_t v69 = v107;
    if (v108)
    {
      v136 = v20;
      v132 = v22;
      v109 = bswap32(v108);
      v110 = (void *)_newReadPFEncodedArrayFromData((uint64_t)a1, a2, &v142, a4, a10, 0LL);
      v111 = 0LL;
      while (1)
      {
        v112 = [v110 objectAtIndex:v111];
        callBacks.version = 0LL;
        v113 = [MEMORY[0x189604010] setWithObject:objc_opt_class()];
        v114 = +[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v113,  v112,  (uint64_t)&callBacks);
        if (!v114) {
          break;
        }
        v115 = (void *)v114;
        if (!byte_18C4ABDC6)
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0) {
            [v115 allowEvaluation];
          }
        }

        [v110 _replaceObject:v115 atIndex:v111++];
        if (v109 == v111)
        {
          unint64_t v22 = v132;
          unint64_t v20 = v136;
          *(void *)(v136 + 64) = v110;
          uint64_t v69 = v142;
          goto LABEL_105;
        }
      }

      v130 = @"Can't decode sortDescriptor for fetch request";
      goto LABEL_125;
    }
  }

    v10 = (void *)[v5 stringWithFormat:@"%@ (entity: %@; id: %@; data: %@)", v6, v7, v8, v9];
  }

  else
  {
    v50.receiver = v2;
    v50.super_class = (Class)&OBJC_CLASS___NSManagedObject;
    v10 = (void *)objc_msgSend( NSString,  "stringWithFormat:",  @"%@ (entity: <null>; id: %@; data: <fault>)",
                    -[NSManagedObject description](&v50, sel_description),
                    -[NSManagedObject objectID](v2, "objectID"),
                    v38,
                    v39);
  }

  unint64_t v35 = v10;
  uint64_t v36 = v10;
  objc_autoreleasePoolPop(v3);
  return (NSString *)v35;
}
}

        uint64_t v58 = 0LL;
        goto LABEL_59;
      }

      uint64_t v60 = (void *)a1[4];
      if (v60)
      {
        uint64_t v62 = v60[1];
        uint64_t v61 = v60[2];
        if (v62)
        {
          uint64_t v63 = *(void *)(v62 + 16);
          if (v63)
          {
            uint64_t v64 = *(void *)(v63 + 48);
LABEL_64:
            uint64_t v59 = [v60 createMirroringResultForRequest:v61 storeIdentifier:v64 success:0 madeChanges:v36 error:v5];
            goto LABEL_65;
          }
        }
      }

      else
      {
        uint64_t v61 = 0LL;
      }
    }

    else
    {
      uint64_t v61 = 0LL;
      uint64_t v60 = 0LL;
    }

    uint64_t v64 = 0LL;
    goto LABEL_64;
  }

  if ([v62 count]) {
    return v62;
  }
  else {
    return 0LL;
  }
}

void sub_186683D00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if ((v20 & 1) != 0) {
    objc_end_catch();
  }
  _Unwind_Resume(exception_object);
}

uint64_t _PFAssertSafeMultiThreadedAccess_impl(uint64_t result, const char *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 24);
    unint64_t v4 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 712);
    if (!v3)
    {
      v9 = *(void **)(*(void *)(result + 168) + 56LL);
      if (v4)
      {
        unint64_t v10 = 0LL;
        int v11 = 0;
        unint64_t v12 = v4;
        while (v12 != result)
        {
          if (v12 == v10) {
            goto LABEL_45;
          }
          if (!v10) {
            unint64_t v10 = v12;
          }
          unint64_t v12 = atomic_load((unint64_t *)(v12 + 8));
          if (!v12) {
            goto LABEL_48;
          }
        }

        int v11 = 1;
LABEL_45:
        if (v11)
        {
          unsigned __int8 v22 = atomic_load((unsigned __int8 *)(result + 49));
          if ((v22 & 1) == 0) {
            return result;
          }
          goto LABEL_63;
        }

LABEL_48:
        unint64_t v23 = 0LL;
        int v24 = 0;
        unint64_t v25 = result;
        do
        {
          BOOL v26 = v25 == v4;
          if (v25 == v4) {
            int v24 = 1;
          }
          if (v25 == v23) {
            BOOL v26 = 1;
          }
          if (v26) {
            break;
          }
          if (!v23) {
            unint64_t v23 = v25;
          }
          unint64_t v25 = atomic_load((unint64_t *)(v25 + 8));
        }

        while (v25);
        unsigned __int8 v27 = atomic_load((unsigned __int8 *)(result + 49));
        if ((v27 & 1) != 0) {
          goto LABEL_63;
        }
        if (v24) {
          BOOL v28 = v26;
        }
        else {
          BOOL v28 = 0;
        }
        if (v28) {
          return result;
        }
      }

      else
      {
        unsigned __int8 v21 = atomic_load((unsigned __int8 *)(result + 49));
        if ((v21 & 1) != 0)
        {
LABEL_63:
          result = _PFIsSerializedWithMainQueue();
          if ((result & 1) != 0) {
            return result;
          }
        }
      }

      uint64_t v29 = (_opaque_pthread_t *)v9[1];
      pthread_t v30 = pthread_self();
      if ([*(id *)(v2 + 136) tryLock])
      {
        if (v30 == v29) {
          return [*(id *)(v2 + 136) unlock];
        }
        uint64_t v32 = (void *)v9[2];
        uint64_t v31 = (dispatch_queue_global_s *)v9[3];
        uint64_t v33 = (void *)[MEMORY[0x189607988] currentQueue];
        v34 = [v33 maxConcurrentOperationCount] == 1 ? v33 : 0;
        if (v34 && v34 == v32) {
          return [*(id *)(v2 + 136) unlock];
        }
        current_queue = (dispatch_queue_global_s *)dispatch_get_current_queue();
        uint64_t v36 = current_queue == dispatch_get_global_queue(0LL, 0LL) ? 0LL : current_queue;
        if (v36 && v36 == v31) {
          return [*(id *)(v2 + 136) unlock];
        }
        NSStringFromSelector(a2);
        _NSCoreDataLog( 1LL,  (uint64_t)@"The current thread is not the recognized owner of this NSManagedObjectContext(%p).  Illegal access during %@",  v43,  v44,  v45,  v46,  v47,  v48,  v2);
      }

      else
      {
        NSStringFromSelector(a2);
        _NSCoreDataLog( 1LL,  (uint64_t)@"Multiple threads illegally accessing an NSManagedObjectContext (%p) during %@",  v37,  v38,  v39,  v40,  v41,  v42,  v2);
      }

      goto LABEL_79;
    }

    if (v4)
    {
      unint64_t v5 = 0LL;
      int v6 = 0;
      unint64_t v7 = v4;
      while (v7 != result)
      {
        if (v7 == v5) {
          goto LABEL_23;
        }
        if (!v5) {
          unint64_t v5 = v7;
        }
        unint64_t v7 = atomic_load((unint64_t *)(v7 + 8));
        if (!v7) {
          goto LABEL_26;
        }
      }

      int v6 = 1;
LABEL_23:
      if (v6)
      {
        unsigned __int8 v14 = atomic_load((unsigned __int8 *)(result + 49));
        if ((v14 & 1) != 0) {
          goto LABEL_41;
        }
        return result;
      }

        objc_autoreleasePoolPop(v15);
      }

      int v11 = [obj countByEnumeratingWithState:&v279 objects:v299 count:16];
    }

    while (v11);
  }

  v276 = 0u;
  v277 = 0u;
  v274 = 0u;
  v275 = 0u;
  v221 = *(id *)(a1 + 16);
  uint64_t v62 = [v221 countByEnumeratingWithState:&v274 objects:v298 count:16];
  if (!v62)
  {
    v223 = 1;
    goto LABEL_124;
  }

  v223 = 1;
  v224 = *(void *)v275;
  do
  {
    uint64_t v63 = 0LL;
    v226 = (char *)v62;
    do
    {
      if (*(void *)v275 != v224) {
        objc_enumerationMutation(v221);
      }
      v230 = v63;
      uint64_t v64 = *(void **)(*((void *)&v274 + 1) + 8LL * (void)v63);
      context = (void *)MEMORY[0x186E3E5D8]();
      obja = (id)[*(id *)(a1 + 16) objectForKey:v64];
      v236 = (uint64_t)v64;
      v272 = 0u;
      v273 = 0u;
      v270 = 0u;
      v271 = 0u;
      v65 = [obja countByEnumeratingWithState:&v270 objects:v297 count:16];
      if (v65)
      {
        unint64_t v66 = *(void *)v271;
        do
        {
          uint64_t v67 = 0LL;
          do
          {
            if (*(void *)v271 != v66) {
              objc_enumerationMutation(obja);
            }
            uint64_t v68 = *(void **)(*((void *)&v270 + 1) + 8 * v67);
            uint64_t v69 = (void *)MEMORY[0x186E3E5D8]();
            uint64_t v70 = __ckLoggingOverride;
            uint64_t v71 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Deleting record with id (%@): %@"];
            if (v70 >= 9) {
              uint64_t v78 = 9LL;
            }
            else {
              uint64_t v78 = v70;
            }
            _NSCoreDataLog( v78,  v71,  v72,  v73,  v74,  v75,  v76,  v77,  (uint64_t)"-[PFCloudKitImportZoneContext initializeCachesWithManagedObjectContext:andObservedStore:error:]");
            objc_autoreleasePoolPop(v69);
            if ([v64 hasPrefix:@"CD_M2M_"])
            {
              uint64_t v79 = +[PFMirroredRelationship mirroredRelationshipWithDeletedRecordType:recordID:andManagedObjectModel:]( (uint64_t)&OBJC_CLASS___PFMirroredRelationship,  (uint64_t)v64,  (uint64_t)v68,  (uint64_t)v244);
              [v243 addObject:v79];
              uint64_t v80 = -[PFMirroredManyToManyRelationship recordTypeToRecordID](v79);
              v269[0] = MEMORY[0x1895F87A8];
              v269[1] = 3221225472LL;
              v269[2] = __95__PFCloudKitImportZoneContext_initializeCachesWithManagedObjectContext_andObservedStore_error___block_invoke_2;
              v269[3] = &unk_189EA78E8;
              v269[4] = v247;
              v269[5] = v246;
              v269[6] = a1;
              v269[7] = v68;
              [v80 enumerateKeysAndObjectsUsingBlock:v269];
              goto LABEL_106;
            }

            if ([v64 isEqualToString:@"CDMR"])
            {
              uint64_t v81 = (void *)+[NSCKMirroredRelationship fetchMirroredRelationshipsMatchingPredicate:fromStore:inManagedObjectContext:error:]( (uint64_t)NSCKMirroredRelationship,  [MEMORY[0x1896079C8] predicateWithFormat:@"%K = %@", @"ckRecordID", objc_msgSend(v68, "recordName"), v64, v68],  (uint64_t)v234,  v239,  (uint64_t)&v287);
              if (!v81)
              {
                v111 = (void *)MEMORY[0x186E3E5D8]();
                v112 = __ckLoggingOverride;
                v113 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Import context failed to fetch mirrored relationships during import: %@"];
                _NSCoreDataLog( v112 != 0,  v113,  v114,  v115,  v116,  v117,  v118,  v119,  (uint64_t)"-[PFCloudKitImportZoneContext initializeCachesWithManagedObjectContext:andObservedStore:error:]");
                objc_autoreleasePoolPop(v111);
                v223 = 0;
                v120 = v287;
                goto LABEL_117;
              }

              uint64_t v82 = (void *)[v81 lastObject];
              uint64_t v83 = v82;
              if (!v82)
              {
                __int16 v98 = (void *)MEMORY[0x186E3E5D8]();
                unint64_t v99 = __ckLoggingOverride;
                uint64_t v100 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping mirrored relationship with record id (not found locally): %@"];
                if (v99 >= 9) {
                  v107 = 9LL;
                }
                else {
                  v107 = v99;
                }
                goto LABEL_105;
              }

              [v82 setNeedsDelete:MEMORY[0x189604A88]];
              [v83 setIsUploaded:MEMORY[0x189604A88]];
              if (!objc_msgSend(v247, "containsObject:", objc_msgSend(v83, "cdEntityName")))
              {
                __int16 v98 = (void *)MEMORY[0x186E3E5D8]();
                v108 = __ckLoggingOverride;
                uint64_t v100 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Skipping unknown deleted relationship recordID: %@ - %@"];
                if (v108 >= 3) {
                  v107 = 3LL;
                }
                else {
                  v107 = v108;
                }
LABEL_105:
                _NSCoreDataLog( v107,  v100,  v101,  v102,  v103,  v104,  v105,  v106,  (uint64_t)"-[PFCloudKitImportZoneContext initializeCachesWithManagedObjectContext:andObservedStore:error:]");
                objc_autoreleasePoolPop(v98);
                goto LABEL_106;
              }

              v84 = (void *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v244, "entitiesByName"),  "objectForKey:",  objc_msgSend(v83, "cdEntityName")),  "relationshipsByName"),  "objectForKey:",  objc_msgSend(v83, "relationshipName"));
              unint64_t v85 = -[NSCKMirroredRelationship createRecordIDForRecord](v83);
              unint64_t v86 = -[NSCKMirroredRelationship createRecordIDForRelatedRecord](v83);
              unint64_t v87 = -[PFMirroredManyToManyRelationshipV2 initWithRecordID:forRecordWithID:relatedToRecordWithID:byRelationship:withInverse:andType:]( [PFMirroredManyToManyRelationshipV2 alloc],  "initWithRecordID:forRecordWithID:relatedToRecordWithID:byRelationship:withInverse:andType:",  v68,  v85,  v86,  v84,  [v84 inverseRelationship],  1);
              [v243 addObject:v87];
              if (v87) {
                relationshipDescription = v87->super._relationshipDescription;
              }
              else {
                relationshipDescription = 0LL;
              }
              v89 = (id)objc_msgSend( v246,  "objectForKey:",  -[NSEntityDescription name]( -[NSPropertyDescription entity](relationshipDescription, "entity"),  "name"));
              if (!v89)
              {
                v89 = objc_alloc_init(MEMORY[0x189603FA8]);
                if (v87) {
                  v90 = v87->super._relationshipDescription;
                }
                else {
                  v90 = 0LL;
                }
                objc_msgSend( v246,  "setObject:forKey:",  v89,  -[NSEntityDescription name](-[NSPropertyDescription entity](v90, "entity"), "name"));
              }

              if (v87) {
                ckRecordID = v87->super._ckRecordID;
              }
              else {
                ckRecordID = 0LL;
              }
              [v89 addObject:ckRecordID];

              if (v87) {
                inverseRelationshipDescription = v87->super._inverseRelationshipDescription;
              }
              else {
                inverseRelationshipDescription = 0LL;
              }
              uint64_t v93 = (id)objc_msgSend( v246,  "objectForKey:",  -[NSEntityDescription name]( -[NSPropertyDescription entity](inverseRelationshipDescription, "entity"),  "name"));
              if (!v93)
              {
                uint64_t v93 = objc_alloc_init(MEMORY[0x189603FA8]);
                if (v87) {
                  __int16 v94 = v87->super._inverseRelationshipDescription;
                }
                else {
                  __int16 v94 = 0LL;
                }
                objc_msgSend( v246,  "setObject:forKey:",  v93,  -[NSEntityDescription name](-[NSPropertyDescription entity](v94, "entity"), "name"));
              }

              if (v87) {
                relatedCKRecordID = v87->super._relatedCKRecordID;
              }
              else {
                relatedCKRecordID = 0LL;
              }
              [v93 addObject:relatedCKRecordID];
            }

            else
            {
              if (![v247 containsObject:v236])
              {
                if ([v64 isEqualToString:getCloudKitCKRecordTypeShare[0]()])
                {
                  [v232 addObject:v68];
                  goto LABEL_106;
                }

                __int16 v98 = (void *)MEMORY[0x186E3E5D8]();
                v109 = __ckLoggingOverride;
                uint64_t v100 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Skipping unknown deleted record: %@ - %@"];
                if (v109 >= 3) {
                  v107 = 3LL;
                }
                else {
                  v107 = v109;
                }
                goto LABEL_105;
              }

              __int16 v96 = (id)[v246 objectForKey:v64];
              if (!v96)
              {
                __int16 v96 = objc_alloc_init(MEMORY[0x189603FA8]);
                [v246 setObject:v96 forKey:v64];
              }

              [v96 addObject:v68];

              unint64_t v97 = (id)[v233 objectForKey:v64];
              if (!v97)
              {
                unint64_t v97 = objc_alloc_init(MEMORY[0x189603FE0]);
                [v233 setObject:v97 forKey:v64];
              }

              [v97 addObject:v68];
            }

LABEL_26:
      unint64_t v15 = 0LL;
      int v16 = 0;
      unint64_t v17 = result;
      do
      {
        BOOL v18 = v17 == v4;
        if (v17 == v4) {
          int v16 = 1;
        }
        if (v17 == v15) {
          BOOL v18 = 1;
        }
        if (v18) {
          break;
        }
        if (!v15) {
          unint64_t v15 = v17;
        }
        unint64_t v17 = atomic_load((unint64_t *)(v17 + 8));
      }

      while (v17);
      unsigned __int8 v19 = atomic_load((unsigned __int8 *)(result + 49));
      if ((v19 & 1) != 0) {
        goto LABEL_41;
      }
      if (v16) {
        BOOL v20 = v18;
      }
      else {
        BOOL v20 = 0;
      }
      if (v20) {
        return result;
      }
      goto LABEL_79;
    }

    unsigned __int8 v13 = atomic_load((unsigned __int8 *)(result + 49));
    if ((v13 & 1) == 0)
    {
LABEL_79:
      result = objc_opt_self();
      __break(1u);
      return result;
    }

        [v13 addObject:v19];
        continue;
      }

      if (objc_msgSend((id)objc_msgSend(v19, "objectID"), "persistentStore") == v14) {
        goto LABEL_26;
      }
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        goto LABEL_25;
      }
    }

    int v16 = [v11 countByEnumeratingWithState:&v27 objects:v31 count:16];
  }

  while (v16);
LABEL_29:
  if ([v13 count])
  {
    BOOL v20 = [v11 count];
    if (v20 == [v13 count])
    {

      return (uint64_t)v4;
    }

    unint64_t v23 = [MEMORY[0x189607878] expressionForConstantValue:v13];

    int v24 = (void *)MEMORY[0x189607818];
    if (v26 == 10)
    {
      unint64_t v25 = [v4 leftExpression];
    }

    else
    {
      unint64_t v25 = v23;
      unint64_t v23 = [v4 rightExpression];
    }

    return objc_msgSend( v24,  "predicateWithLeftExpression:rightExpression:modifier:type:options:",  v25,  v23,  objc_msgSend(v4, "comparisonPredicateModifier"),  v26,  objc_msgSend(v4, "options"));
  }

  else
  {

    return [MEMORY[0x189607890] defaultInstance];
  }

    unsigned __int8 v21 = (void *)MEMORY[0x189607870];
    unint64_t v25 = @"objectID";
    v26[0] = a3;
    unsigned __int8 v22 = [MEMORY[0x189603F68] dictionaryWithObjects:v26 forKeys:&v25 count:1];
    unsigned __int8 v19 = (NSError *)[v21 errorWithDomain:*MEMORY[0x189607460] code:133000 userInfo:v22];
    goto LABEL_27;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if (a5)
    {
      unsigned __int8 v19 = (NSError *)-[NSException errorObjectWithUserInfo:](exception, "errorObjectWithUserInfo:", 0LL);
LABEL_27:
      unsigned __int8 v13 = 0LL;
      *a5 = v19;
      goto LABEL_28;
    }

    _NSCoreDataLog(1LL, (uint64_t)@"  MNT_JOURNALED", v129, v130, v131, v132, v133, v134, v196);
    if ((v198.f_flags & 0x2000000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

        if (v5 == ++v11) {
          goto LABEL_27;
        }
      }

      unsigned __int8 v19 = &OBJC_CLASS____NSFaultingMutableSetMutationMethods;
LABEL_24:
      BOOL v20 = -[__objc2_class _createMutationMethodsForClass:forKey:]( v19,  "_createMutationMethodsForClass:forKey:",  Superclass,  *(void *)(v4 + 8 * v11));
      if (v20) {
        v6[v11] = (void *)v20;
      }
      goto LABEL_26;
    }

  a1[4] &= ~0x800u;
}

      dispatch_sync_f(v2, context, (dispatch_function_t)internalBlockToNSManagedObjectContextPerform);
    }
  }

  uint64_t v42 = v17;
LABEL_27:
  uint64_t v53 = (v42 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v121 = v19;
  if (v53 + 4 <= a4)
  {
    uint64_t v54 = bswap32(*(_DWORD *)(v22 + v53));
    v135 = v53 + 4;
  }

  else
  {
    uint64_t v54 = 0;
  }

  for (i = (NSMutableDictionary *)[objc_alloc(MEMORY[0x189603FC8]) initWithCapacity:v116]; v54; --v54)
  {
    uint64_t v62 = (v135 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (v62 + 4 <= a4)
    {
      uint64_t v63 = bswap32(*(_DWORD *)(v22 + v62));
      v135 = v62 + 4;
    }

    else
    {
      uint64_t v63 = 0;
    }

    uint64_t v64 = (void *)_newReadPFEncodedArrayFromData(a1, v22, &v135, a4, a7, 0LL);
    -[NSMutableDictionary setObject:forKey:](i, "setObject:forKey:", v64, *(void *)(a9 + 8LL * v63));
  }

  v118 = v22;
  v114 = a4;
  v115 = (_PFVMData *)a1;
  v65 = v19;
  v19->_configurations = i;
  *((void *)v19->_additionalPrivateIvars + 3) = objc_alloc_init(MEMORY[0x189603FC8]);
  v133 = 0u;
  v134 = 0u;
  v131 = 0u;
  v132 = 0u;
  obj = (id)-[NSMutableDictionary allKeys](i, "allKeys");
  unint64_t v66 = [obj countByEnumeratingWithState:&v131 objects:v139 count:16];
  if (v66)
  {
    uint64_t v67 = v66;
    uint64_t v68 = *(void *)v132;
    do
    {
      for (j = 0LL; j != v67; ++j)
      {
        if (*(void *)v132 != v68) {
          objc_enumerationMutation(obj);
        }
        uint64_t v70 = *(void *)(*((void *)&v131 + 1) + 8 * j);
        uint64_t v71 = (void *)[MEMORY[0x189603FE0] set];
        v127 = 0u;
        v128 = 0u;
        v129 = 0u;
        v130 = 0u;
        uint64_t v72 = (void *)-[NSMutableDictionary objectForKeyedSubscript:](i, "objectForKeyedSubscript:", v70);
        uint64_t v73 = [v72 countByEnumeratingWithState:&v127 objects:v138 count:16];
        if (v73)
        {
          v74 = v73;
          unint64_t v75 = *(void *)v128;
          do
          {
            for (k = 0LL; k != v74; ++k)
            {
              if (*(void *)v128 != v75) {
                objc_enumerationMutation(v72);
              }
              objc_msgSend(v71, "addObject:", objc_msgSend(*(id *)(*((void *)&v127 + 1) + 8 * k), "name"));
            }

            v74 = [v72 countByEnumeratingWithState:&v127 objects:v138 count:16];
          }

          while (v74);
        }

        v65 = v121;
        [v121->_additionalPrivateIvars[3] setObject:v71 forKeyedSubscript:v70];
      }

      uint64_t v67 = [obj countByEnumeratingWithState:&v131 objects:v139 count:16];
    }

    while (v67);
  }

  obja = (id)_newReadPFEncodedArrayFromData((uint64_t)v115, v118, &v135, v114, a10, 0LL);
  versionIdentifiers = v65->_versionIdentifiers;
  if (versionIdentifiers) {

  }
  uint64_t v78 = (NSSet *)[objc_alloc(MEMORY[0x189603FE0]) initWithCapacity:v116];
  v123 = 0u;
  v124 = 0u;
  v125 = 0u;
  v126 = 0u;
  uint64_t v79 = [obja countByEnumeratingWithState:&v123 objects:v137 count:16];
  if (v79)
  {
    uint64_t v80 = v79;
    uint64_t v81 = *(void *)v124;
    while (2)
    {
      for (m = 0LL; m != v80; ++m)
      {
        if (*(void *)v124 != v81) {
          objc_enumerationMutation(obja);
        }
        uint64_t v83 = *(void *)(*((void *)&v123 + 1) + 8 * m);
        v122 = 0LL;
        v84 = (void *)MEMORY[0x189604010];
        v136[0] = objc_opt_class();
        v136[1] = objc_opt_class();
        v136[2] = objc_opt_class();
        unint64_t v85 = +[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)_PFRoutines,  objc_msgSend( v84,  "setWithArray:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v136, 3)),  v83,  (uint64_t)&v122);
        if (!v85)
        {
          _NSCoreDataLog( 1LL,  (uint64_t)@"Unable to decode versionIdentifiers for model: %@",  v86,  v87,  v88,  v89,  v90,  v91,  v122);

          return 0LL;
        }

        -[NSSet addObject:](v78, "addObject:", v85);
      }

      uint64_t v80 = [obja countByEnumeratingWithState:&v123 objects:v137 count:16];
      if (v80) {
        continue;
      }
      break;
    }
  }

  unsigned __int8 v19 = v121;
  v121->_versionIdentifiers = v78;

  v92 = (v135 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v93 = -[NSMutableDictionary count](v113, "count");
  uint64_t v100 = v118;
  v101 = v115;
  if (v93)
  {
    v102 = v93;
    v103 = v135;
    v104 = v93;
    do
    {
      v105 = (v103 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      v106 = v105 + 8;
      if (v105 + 8 <= v114)
      {
        v107 = *(void *)(v118 + v105);
        v135 = v106;
        v103 = v106;
        if (v107)
        {
          _NSCoreDataLog( 1LL,  (uint64_t)@"Corrupted archive (missing pointer space).",  v94,  v95,  v96,  v97,  v98,  v99,  v111);
          goto LABEL_75;
        }
      }

      --v104;
    }

    while (v104);
    v108 = v92;
    uint64_t v100 = v118;
    do
    {
      *(void *)(v118 + v108) = _newReadPFEncodedArrayFromData((uint64_t)v115, v118, &v135, v114, a9, 0LL);
      v108 += 8LL;
      --v102;
    }

    while (v102);
  }

  v121->_optimizationHints = (id *)(v100 + v92);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0) {
    v109 = v115;
  }
  else {
    v101 = -[_PFVMData initWithBytes:length:]( objc_alloc(&OBJC_CLASS____PFVMData),  "initWithBytes:length:",  -[_PFVMData bytes](v115, "bytes"),  -[_PFVMData length](v115, "length"));
  }
  v121->_dataForOptimization = v101;
  *a3 = v135;
  return v19;
}

    unsigned __int8 v19 = (void *)MEMORY[0x189603F70];
    BOOL v20 = *MEMORY[0x189603A60];
    unsigned __int8 v21 = @"Unsupported predicate, RHS of boundBy: must contain 2 values";
    goto LABEL_29;
  }

  if (v5 != NSAggregateExpressionType)
  {
    unsigned __int8 v19 = (void *)MEMORY[0x189603F70];
    BOOL v20 = *MEMORY[0x189603A60];
    unsigned __int8 v21 = @"Unsupported predicate, RHS of boundBy: must be an aggregate or constant";
    goto LABEL_29;
  }

  int v6 = -[NSExpression constantValue](self->_bounds, "constantValue");
  if ([v6 count] != 2) {
    goto LABEL_26;
  }
  unint64_t v7 = (void *)[v6 objectAtIndex:0];
  uint64_t v8 = [v7 expressionType];
  v9 = (void *)[v6 objectAtIndex:0];
  unint64_t v10 = [v9 expressionType];
  if (v8) {
    int v11 = v8 == 3;
  }
  else {
    int v11 = 1;
  }
  if (!v11)
  {
    unsigned __int8 v19 = (void *)MEMORY[0x189603F70];
    BOOL v20 = *MEMORY[0x189603A60];
    unsigned __int8 v21 = @"Unsupported predicate, topLeft parameter of boundBy: RHS must be a constant or keypath";
LABEL_29:
    objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(v19, "exceptionWithName:reason:userInfo:", v20, v21, 0),  @"NSUnderlyingException");
    return 0LL;
  }

  unint64_t v12 = v10;
  if (v10) {
    unsigned __int8 v13 = v10 == 3;
  }
  else {
    unsigned __int8 v13 = 1;
  }
  if (!v13)
  {
    unsigned __int8 v19 = (void *)MEMORY[0x189603F70];
    BOOL v20 = *MEMORY[0x189603A60];
    unsigned __int8 v21 = @"Unsupported predicate, bottomRight parameter of boundBy: RHS must be a constant or keypath";
    goto LABEL_29;
  }

  if (v8)
  {
    unsigned __int8 v14 = 0LL;
    if (v10)
    {
LABEL_16:
      unint64_t v15 = 0LL;
      goto LABEL_20;
    }
  }

  else
  {
    unsigned __int8 v14 = (void *)[v7 constantValue];
    if (v12) {
      goto LABEL_16;
    }
  }

  unint64_t v17 = [v9 constantValue];
LABEL_19:
  unint64_t v15 = (void *)v17;
LABEL_20:
  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
    unsigned __int8 v19 = (void *)MEMORY[0x189603F70];
    BOOL v20 = *MEMORY[0x189603A60];
    unsigned __int8 v21 = @"Unsupported predicate, constant topLeft parameter of boundBy: RHS must respond to coordinate";
    goto LABEL_29;
  }

  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
    unsigned __int8 v19 = (void *)MEMORY[0x189603F70];
    BOOL v20 = *MEMORY[0x189603A60];
    unsigned __int8 v21 = @"Unsupported predicate, constant lowerRight parameter of boundBy: RHS must respond to coordinate";
    goto LABEL_29;
  }

  BOOL v18 = -[NSDictionary objectForKey:]( -[NSPropertyDescription userInfo](self->_target, "userInfo"),  "objectForKey:",  @"_NSLocationAttributeDerivedComponents");
  if (([v18 isNSArray] & 1) == 0)
  {
    if ([v18 isNSString]) {
      BOOL v18 = (id)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v18, "description"),  "stringByReplacingOccurrencesOfString:withString:",  @" ",  &stru_189EAC2E8),  "componentsSeparatedByString:",  @",");
    }
    else {
      BOOL v18 = 0LL;
    }
  }

  entity = self->_entity;
  int v24 = [v18 firstObject];
  if (entity) {
    unint64_t v25 = (void *)-[NSMutableDictionary objectForKey:](entity->_properties, "objectForKey:", v24);
  }
  else {
    unint64_t v25 = 0LL;
  }
  BOOL v26 = [v25 columnName];
  unsigned __int8 v27 = self->_entity;
  BOOL v28 = [v18 lastObject];
  if (v27) {
    uint64_t v29 = (void *)-[NSMutableDictionary objectForKey:](v27->_properties, "objectForKey:", v28);
  }
  else {
    uint64_t v29 = 0LL;
  }
  pthread_t v30 = [v29 columnName];
  uint64_t v31 = -[NSSQLAliasGenerator initWithNestingLevel:]( [NSSQLAliasGenerator alloc],  "initWithNestingLevel:",  objc_msgSend((id)objc_msgSend(a3, "objectForKey:", @"nestingLevel"), "integerValue") + 1);
  uint64_t v32 = -[NSSQLAliasGenerator generateTableAlias](v31, "generateTableAlias");

  uint64_t v33 = (void *)+[NSSQLLocationAttributeRTreeExtension newRTReeTableNameForAttribute:onEntity:]( (uint64_t)&OBJC_CLASS___NSSQLLocationAttributeRTreeExtension,  self->_target,  (uint64_t)-[NSSQLEntity entityDescription](self->_entity, "entityDescription"));
  v34 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithFormat:@"SELECT %@.Z_PK FROM %@ %@ WHERE ? <= %@.%@_MAX AND %@.%@_MIN <= ? AND ? <= %@.%@_MAX AND %@.%@_MIN <= ?", v32, v33, v32, v32, v26, v32, v26, v32, v30, v32, v30];

  if (-[NSSQLIntermediate isWhereScoped](self, "isWhereScoped")) {
    unint64_t v35 = @"bindVars";
  }
  else {
    unint64_t v35 = @"selectBindVars";
  }
  uint64_t v36 = (void *)[a3 objectForKey:v35];
  [v14 coordinate];
  uint64_t v38 = v37;
  [v15 coordinate];
  uint64_t v40 = v39;
  [v15 coordinate];
  uint64_t v42 = v41;
  [v14 coordinate];
  uint64_t v44 = v43;
  uint64_t v45 = objc_alloc(&OBJC_CLASS___NSSQLBindVariable);
  uint64_t v46 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( v45,  "initWithValue:sqlType:propertyDescription:",  [MEMORY[0x189607968] numberWithDouble:v42],  7,  0);
  [v36 addObject:v46];

  uint64_t v47 = objc_alloc(&OBJC_CLASS___NSSQLBindVariable);
  uint64_t v48 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( v47,  "initWithValue:sqlType:propertyDescription:",  [MEMORY[0x189607968] numberWithDouble:v44],  7,  0);
  [v36 addObject:v48];

  uint64_t v49 = objc_alloc(&OBJC_CLASS___NSSQLBindVariable);
  uint64_t v50 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( v49,  "initWithValue:sqlType:propertyDescription:",  [MEMORY[0x189607968] numberWithDouble:v38],  7,  0);
  [v36 addObject:v50];

  uint64_t v51 = objc_alloc(&OBJC_CLASS___NSSQLBindVariable);
  uint64_t v52 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( v51,  "initWithValue:sqlType:propertyDescription:",  [MEMORY[0x189607968] numberWithDouble:v40],  7,  0);
  [v36 addObject:v52];

  return v34;
}

  unint64_t v15 = *(void *)(a1 + 40);
  if (v15)
  {
    int v16 = *(void **)(a1 + 32);
    os_unfair_lock_lock_with_options();
    unint64_t v17 = (void *)[*(id *)(v15 + 160) objectForKey:0x189EBA2C8];
    os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 152));
    [v17 unsignedIntegerValue];
    if ((int)[v17 intValue] >= 901
      && (int)[v17 intValue] <= 966
      && ([(id)v15 isReadOnly] & 1) == 0
      && objc_msgSend( (id)objc_msgSend((id)objc_msgSend((id)v15, "URL"), "path"),  "hasSuffix:",  @"com.apple.security.keychain-defaultContext.TrustedPeersHelper.db"))
    {
      BOOL v18 = objc_msgSend( (id)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend((id)v15, "metadata"),  "objectForKey:",  @"NSStoreModelVersionHashes"),  "allKeys"),  "containsObject:",  @"Machine");
      unsigned __int8 v19 = v16 ? v18 : 1;
      if ((v19 & 1) == 0
        && -[NSSQLiteConnection _hasTableWithName:isTemp:]((uint64_t)v16, (uint64_t)@"ZMACHINE", 0))
      {
        -[NSSQLiteConnection _dropTableWithName:]((uint64_t)v16, (uint64_t)@"ZMACHINE");
      }
    }

    if ((objc_msgSend( (id)objc_msgSend((id)objc_msgSend((id)v15, "options"), "allKeys"),  "containsObject:",  @"NSXPCStoreListener") & 1) != 0 || !objc_msgSend((id)v15, "_persistentStoreCoordinator")
      || ([(id)v15 isReadOnly] & 1) != 0
      || (int)[v17 intValue] >= 619
      && ((int)[v17 intValue] < 960 || (int)objc_msgSend(v17, "intValue") > 971))
    {
      BOOL v20 = 0;
    }

    else
    {
      os_unfair_lock_lock_with_options();
      [*(id *)(v15 + 160) setValue:MEMORY[0x189604A88] forKey:@"NSPersistentStoreRebuildIndicies"];
      atomic_store(0, (unsigned __int8 *)(v15 + 196));
      [(id)v15 _setMetadataDirty:1];
      os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 152));
      unint64_t v56 = [(id)v15 identifier];
      _NSCoreDataLog(2LL, (uint64_t)@"Rebuilding indicies for store - %@", v57, v58, v59, v60, v61, v62, v56);
      BOOL v20 = 1;
    }

    if ((int)[v17 intValue] >= 1002
      && (int)[v17 intValue] <= 1004
      && ([(id)v15 isReadOnly] & 1) == 0
      && [(id)v15 model])
    {
      unsigned __int8 v21 = getprogname();
      if (v21
        && (!strncmp("assetsd", v21, 7uLL) || !strncmp("photolibraryd", v21, 0xDuLL))
        && objc_msgSend( (id)objc_msgSend((id)objc_msgSend((id)v15, "URL"), "lastPathComponent"),  "isEqualToString:",  @"Photos.sqlite"))
      {
        unsigned __int8 v22 = -[NSSQLColumn initWithColumnName:sqlType:]( objc_alloc(&OBJC_CLASS___NSSQLColumn),  "initWithColumnName:sqlType:",  @"COUNT(*)",  1LL);
        unint64_t v23 = (id)objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v22, 0);

        v243 = @"ZSHAREPARTICIPANT";
        int v24 = -[NSSQLiteStatement initWithEntity:sqlString:]( [NSSQLiteStatement alloc],  "initWithEntity:sqlString:",  0,  [NSString stringWithFormat:@"SELECT COUNT(*) FROM (SELECT * FROM %@ WHERE Z_ENT = 0 LIMIT 1)"]);
        LODWORD(v22) = -[NSSQLiteConnection selectCountWithStatement:]((uint64_t)v16, v24);

        -[NSSQLiteConnection setColumnsToFetch:](v16, v23);
        if ((_DWORD)v22)
        {
          unint64_t v25 = -[NSSQLiteConnection newFetchedArray]((uint64_t)v16);
          if ([v25 count])
          {
            BOOL v26 = objc_msgSend((id)objc_msgSend(v25, "objectAtIndex:", 0), "unsignedIntValue");

            if (v26)
            {
              _NSCoreDataLog( 2LL,  (uint64_t)@"Corruption encountered during a past migration - DB integrity has been compromised.",  v27,  v28,  v29,  v30,  v31,  v32,  (uint64_t)@"ZSHAREPARTICIPANT");
              uint64_t v33 = (void *)[MEMORY[0x189603FA8] array];
              memset(&v285, 0, 64);
              v34 = [(id)v15 model];
              if (v34) {
                unint64_t v35 = *(void **)(v34 + 32);
              }
              else {
                unint64_t v35 = 0LL;
              }
              uint64_t v36 = [v35 countByEnumeratingWithState:&v285 objects:&v286 count:16];
              if (v36)
              {
                uint64_t v37 = **(void **)&v285.st_uid;
                do
                {
                  for (j = 0LL; j != v36; ++j)
                  {
                    if (**(void **)&v285.st_uid != v37) {
                      objc_enumerationMutation(v35);
                    }
                    uint64_t v39 = *(void **)(v285.st_ino + 8 * j);
                    if (objc_msgSend( (id)objc_msgSend(v39, "tableName"),  "isEqualToString:",  @"ZSHAREPARTICIPANT")) {
                      [v33 addObject:v39];
                    }
                  }

                  uint64_t v36 = [v35 countByEnumeratingWithState:&v285 objects:&v286 count:16];
                }

                while (v36);
              }

              if ([v33 count] == 1)
              {
                [v33 firstObject];
                _NSCoreDataLog( 2LL,  (uint64_t)@"Attempting Repair - One entity found for table - %@ setting Z_ENT = %u",  v46,  v47,  v48,  v49,  v50,  v51,  (uint64_t)@"ZSHAREPARTICIPANT");
                -[NSSQLiteConnection endFetchAndRecycleStatement:]((uint64_t)v16, 0);
                uint64_t v52 = (void *)NSString;
                uint64_t v53 = [v33 firstObject];
                if (v53) {
                  uint64_t v54 = *(unsigned int *)(v53 + 184);
                }
                else {
                  uint64_t v54 = 0LL;
                }
                v55 = -[NSSQLiteStatement initWithEntity:sqlString:]( [NSSQLiteStatement alloc],  "initWithEntity:sqlString:",  [v33 firstObject],  objc_msgSend( v52,  "stringWithFormat:",  @"UPDATE OR FAIL %@ SET Z_ENT = %u",  @"ZSHAREPARTICIPANT",  v54));
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:]((uint64_t)v16, v55);
              }

              else
              {
                _NSCoreDataLog( 2LL,  (uint64_t)@"Unable to Repair - More than one entity found for table - %@ Entites - %@",  v40,  v41,  v42,  v43,  v44,  v45,  (uint64_t)@"ZSHAREPARTICIPANT");
              }
            }
          }
        }

        -[NSSQLiteConnection endFetchAndRecycleStatement:]((uint64_t)v16, 0);
      }

      -[NSSQLiteConnection endFetchAndRecycleStatement:]((uint64_t)v16, 0);
    }

    if (v20) {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
    }
  }

  uint64_t v67 = *(void *)(a1 + 40);
  if (!v67) {
    goto LABEL_245;
  }
  uint64_t v68 = *(void *)(a1 + 32);
  os_unfair_lock_lock_with_options();
  uint64_t v69 = (void *)objc_msgSend(*(id *)(v67 + 160), "objectForKey:");
  os_unfair_lock_unlock((os_unfair_lock_t)(v67 + 152));
  uint64_t v70 = [v69 unsignedIntegerValue];
  if ([(id)v67 _persistentStoreCoordinator])
  {
    if (v70 <= 0xB9 && ([(id)v67 isReadOnly] & 1) == 0)
    {
      uint64_t v71 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:](v68, @"pragma auto_vacuum");
      uint64_t v72 = v71;
      if (v71)
      {
        if (*(uint64_t *)CFArrayGetValueAtIndex(v71, 0LL) < 1 || *(void *)CFArrayGetValueAtIndex(v72, 1LL))
        {
          CFRelease(v72);
        }

        else
        {
          CFRelease(v72);
          v132 = (const char *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend((id)v67, "URL"), "path"),  "fileSystemRepresentation");
          v133 = access(v132, 6);
          if (stat(v132, &v285) || (st_size = v285.st_size) == 0 || statfs(v132, &v286))
          {
            if (v133) {
              goto LABEL_89;
            }
          }

          else if (v133 || (int64_t)(v286.f_bavail * v286.f_bsize) <= st_size)
          {
            goto LABEL_89;
          }

          v135 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:](v68, @"pragma auto_vacuum=1");
          if (v135) {
            CFRelease(v135);
          }
          v136 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:](v68, @"vacuum");
          if (v136) {
            CFRelease(v136);
          }
          -[NSSQLiteConnection disconnect](v68);
          -[NSSQLiteConnection connect](v68);
        }
      }
    }
  }
}

        uint64_t v38 = *(void **)(a1 + 40);
        if (v38) {
          uint64_t v39 = v38[2];
        }
        else {
          uint64_t v39 = 0LL;
        }
        uint64_t v40 = [v2 identifier];
        int v16 = [v38 createMirroringResultForRequest:v39 storeIdentifier:v40 success:*((unsigned __int8 *)v51 + 24) madeChanges:v54 error:v56[5]];
      }
    }

    else
    {
      int v24 = (id)v56[5];
      unint64_t v25 = *(void **)(a1 + 40);
      if (v25) {
        BOOL v26 = v25[2];
      }
      else {
        BOOL v26 = 0LL;
      }
      unsigned __int8 v27 = [v2 identifier];
      int v16 = [v25 createMirroringResultForRequest:v26 storeIdentifier:v27 success:0 madeChanges:0 error:v56[5]];
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) = v16;
  }

  else
  {
    unint64_t v17 = (void *)MEMORY[0x189607870];
    uint64_t v61 = *MEMORY[0x1896075F0];
    BOOL v18 = *(void *)(a1 + 40);
    if (v18) {
      unsigned __int8 v19 = *(void **)(v18 + 16);
    }
    else {
      unsigned __int8 v19 = 0LL;
    }
    v62[0] = [NSString stringWithFormat:@"Request '%@' was cancelled because the store was removed from the coordinator.", objc_msgSend(v19, "requestIdentifier")];
    BOOL v20 = [MEMORY[0x189603F68] dictionaryWithObjects:v62 forKeys:&v61 count:1];
    unsigned __int8 v21 = [v17 errorWithDomain:*MEMORY[0x189607460] code:134407 userInfo:v20];
    unsigned __int8 v22 = *(void **)(a1 + 40);
    if (v22) {
      unint64_t v23 = v22[2];
    }
    else {
      unint64_t v23 = 0LL;
    }
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = objc_msgSend( v22,  "createMirroringResultForRequest:storeIdentifier:succ ess:madeChanges:error:",  v23,  objc_msgSend(0, "identifier"),  0,  0,  v21);
  }

  v56[5] = 0LL;
  _Block_object_dispose(&v50, 8);
  _Block_object_dispose(&v55, 8);
}

    return v9;
  }

  v16.receiver = self;
  v16.super_class = (Class)&OBJC_CLASS___NSCloudKitMirroringDelegatePreJazzkonMetadata;
  return -[NSCloudKitMirroringDelegatePreJazzkonMetadata isEqual:](&v16, sel_isEqual_, a3);
}

LABEL_41:
    result = _PFIsSerializedWithMainQueue();
    if ((result & 1) == 0) {
      goto LABEL_79;
    }
  }

  return result;
}

          unsigned __int8 v22 = 0LL;
          goto LABEL_188;
        }

        uint64_t v83 = (NSPersistentHistoryChangeRequest *)a3;
        if ([a3 token])
        {
          v84 = (void *)objc_msgSend((id)objc_msgSend(a3, "token"), "storeTokens");
          if (!objc_msgSend(v84, "objectForKey:", -[NSSQLCore identifier](self, "identifier")))
          {
            v134 = (void *)MEMORY[0x189607870];
            v180 = @"Reason";
            v135 = (void *)NSString;
            v136 = [a3 token];
            v179 = -[NSSQLCore identifier](self, "identifier");
            v181 = [v135 stringWithFormat:@"Unable to find stores referenced in History Token (%@) - %@", v136, objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v179, 1)];
            unsigned __int8 v21 = (NSError *)objc_msgSend( v134,  "errorWithDomain:code:userInfo:",  v169,  134501,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjects:forKeys:count:",  &v181,  &v180,  1));
            if (!v21)
            {
              v137 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
              _NSCoreDataLog( 17LL,  v137,  v138,  v139,  v140,  v141,  v142,  v143,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLCore.m");
              v144 = __pflogFaultLog;
              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136315394;
                v184 = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLCore.m";
                v185 = 1024;
                v186 = 2501;
                v145 = (os_log_s *)v144;
                goto LABEL_208;
              }

        uint64_t v36 = v28;

        [v45 drain];
        uint64_t v37 = 0LL;
        uint64_t v38 = v28;
        if (a3 && v28) {
          *a3 = v28;
        }
        goto LABEL_44;
      }

      *(_DWORD *)(a1 + 8) = v51;
      BOOL v20 = objc_msgSend(v7, "subdataWithRange:", v52, v53, v19);
      unsigned __int8 v21 = (void *)[objc_alloc(MEMORY[0x189607908]) initForReadingFromData:v20 error:&v46];
      unsigned __int8 v22 = v46;
      if (!v46)
      {
        unint64_t v23 = (id)+[_PFRoutines plistClassesForSecureCoding]();
        if (v18)
        {
          [v21 setRequiresSecureCoding:1];
          [v21 _allowDecodingCyclesInSecureMode];
          int v24 = [*(id *)(a1 + 40) objectForKey:@"NSBinaryStoreSecureDecodingClasses"];
          if (v24)
          {
            unint64_t v23 = (id)[v23 mutableCopy];
            [v23 unionSet:v24];
          }
        }

        else
        {
          [v21 setRequiresSecureCoding:0];
        }

        [v21 setDecodingFailurePolicy:1];
        uint64_t v29 = (void *)[v21 decodeObjectOfClasses:v23 forKey:@"metadata"];
        if ([v21 error])
        {
LABEL_48:
          uint64_t v46 = (id)[v21 error];
          uint64_t v42 = [v46 code];
          uint64_t v47 = *MEMORY[0x189607798];
          uint64_t v48 = v46;
          uint64_t v43 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:&v48 forKeys:&v47 count:1];
          uint64_t v44 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189607590],  v42,  (uint64_t)@"Keyed archiver failure",  v43);
          objc_exception_throw(v44);
          goto LABEL_49;
        }

        [v21 finishDecoding];

        if (*(void **)(a1 + 16) != v29)
        {
          pthread_t v30 = [v29 copy];

          *(void *)(a1 + 16) = v30;
        }

        uint64_t v31 = v55;
        *(void *)(a1 + 24) = v56;
        uint64_t v32 = objc_msgSend(v7, "subdataWithRange:", v54, v31);
        unsigned __int8 v21 = (void *)[objc_alloc(MEMORY[0x189607908]) initForReadingFromData:v32 error:&v46];
        unsigned __int8 v22 = v46;
        if (!v46)
        {
          uint64_t v33 = (id)+[NSBinaryObjectStore _classesForPropertyValues]();
          if (v18)
          {
            [v21 setRequiresSecureCoding:1];
            [v21 _allowDecodingCyclesInSecureMode];
            v34 = [*(id *)(a1 + 40) objectForKey:@"NSBinaryStoreSecureDecodingClasses"];
            if (v34)
            {
              uint64_t v33 = (id)[v33 mutableCopy];
              [v33 unionSet:v34];
            }
          }

          else
          {
            [v21 setRequiresSecureCoding:0];
          }

          [v21 setDecodingFailurePolicy:1];
          unint64_t v35 = (void *)[v21 decodeObjectOfClasses:v33 forKey:@"mapData"];
          if (![v21 error])
          {
            [v21 finishDecoding];

            -[NSXPCStoreServerConnectionContext setActiveStore:](a1, v35);
            BOOL v28 = 0LL;
            goto LABEL_41;
          }

          goto LABEL_48;
        }
      }

      uint64_t v39 = [v22 code];
      uint64_t v47 = *MEMORY[0x189607798];
      uint64_t v48 = v46;
      uint64_t v40 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:&v48 forKeys:&v47 count:1];
      uint64_t v41 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189607590],  v39,  (uint64_t)@"Keyed archiver failure",  v40);
      objc_exception_throw(v41);
LABEL_49:
      __break(1u);
    }
  }

  -[NSMutableDictionary setObject:forKey:]( self->_theMap,  "setObject:forKey:",  v54,  objc_msgSend((id)objc_msgSend(v4, "objectID"), "_referenceData"));
  -[NSStoreMapNode _setVersionNumber:](v54, "_setVersionNumber:", 1LL);
}

    unsigned __int8 v19 = 3LL;
    goto LABEL_26;
  }

  unint64_t v7 = [a2 rootEntity];
  if (v7) {
    uint64_t v8 = *(_DWORD *)(v7 + 184);
  }
  else {
    uint64_t v8 = 0;
  }
  v9 = [a3 rootEntity];
  if (v9) {
    unint64_t v10 = *(_DWORD *)(v9 + 184);
  }
  else {
    unint64_t v10 = 0;
  }
  if (v8 == v10) {
    return 0LL;
  }
  unsigned __int8 v14 = [a2 rootEntity];
  if (v14) {
    unint64_t v15 = *(_DWORD *)(v14 + 184);
  }
  else {
    unint64_t v15 = 0;
  }
  int v16 = [a3 rootEntity];
  if (v16) {
    unint64_t v17 = *(_DWORD *)(v16 + 184);
  }
  else {
    unint64_t v17 = 0;
  }
  if (v15 < v17) {
    return 1LL;
  }
  else {
    return -1LL;
  }
}

      if (!v29) {
        goto LABEL_46;
      }
      if ([v114 isToMany]
        && objc_msgSend((id)objc_msgSend(v114, "inverseRelationship"), "isToMany"))
      {
        v131[0] = [v119 recordName];
        v131[1] = [v119 relatedRecordName];
        uint64_t v50 = +[PFMirroredManyToManyRelationship ckRecordNameForOrderedRecordNames:]( (uint64_t)PFMirroredManyToManyRelationship,  (void *)[MEMORY[0x189603F18] arrayWithObjects:v131 count:2]);
        v130[0] = v114;
        v130[1] = [v114 inverseRelationship];
        uint64_t v51 = +[PFMirroredManyToManyRelationship ckRecordTypeForOrderedRelationships:]( (uint64_t)PFMirroredManyToManyRelationship,  (void *)[MEMORY[0x189603F18] arrayWithObjects:v130 count:2]);
        uint64_t v52 = v118;
        uint64_t v53 = (void *)[objc_alloc(getCloudKitCKRecordIDClass()) initWithRecordName:v50 zoneID:v118];
        if ([v119 needsDelete]) {
          uint64_t v54 = +[PFMirroredRelationship mirroredRelationshipWithDeletedRecordType:recordID:andManagedObjectModel:]( (uint64_t)&OBJC_CLASS___PFMirroredRelationship,  v51,  (uint64_t)v53,  *(void *)(a1 + 56));
        }
        else {
          uint64_t v54 =  -[PFMirroredManyToManyRelationship initWithRecordID:recordType:managedObjectModel:andType:]( objc_alloc(&OBJC_CLASS___PFMirroredManyToManyRelationship),  "initWithRecordID:recordType:managedObjectModel:andType:",  v53,  v51,  *(void *)(a1 + 56),  0LL);
        }
        uint64_t v67 = (PFMirroredOneToManyRelationship *)v54;

        int v6 = v110;
        uint64_t v8 = v111;
        unsigned __int8 v22 = a1;
      }

      else
      {
        *(void *)buf = 0LL;
        unint64_t v66 = [*(id *)(v22 + 32) existingObjectWithID:v25 error:buf];
        if (v66)
        {
          uint64_t v67 = +[PFMirroredRelationship mirroredRelationshipWithManagedObject:withRecordID:relatedToObjectWithRecordID:byRelationship:]( (uint64_t)&OBJC_CLASS___PFMirroredRelationship,  v66,  (uint64_t)v12,  (uint64_t)v120,  (uint64_t)v114);
        }

        else
        {
          if (objc_msgSend((id)objc_msgSend(*(id *)buf, "domain"), "isEqualToString:", v109)
            && [*(id *)buf code] == 133000)
          {
            uint64_t v68 = (void *)MEMORY[0x186E3E5D8]();
            else {
              uint64_t v69 = __ckLoggingOverride;
            }
            uint64_t v70 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping pending relationship because it's destination object has gone missing: %@\n%@"];
            _NSCoreDataLog( v69,  v70,  v71,  v72,  v73,  v74,  v75,  v76,  (uint64_t)"-[PFCloudKitSerializer applyUpdatedRecords:deletedRecordIDs:toStore:inManagedObjectContext:onlyUp datingAttributes:andRelationships:madeChanges:error:]_block_invoke");
            objc_autoreleasePoolPop(v68);

            v120 = 0LL;
            uint64_t v67 = 0LL;
            unint64_t v12 = 0LL;
          }

          else
          {
            uint64_t v77 = (void *)MEMORY[0x186E3E5D8]();
            else {
              uint64_t v78 = __ckLoggingOverride;
            }
            uint64_t v79 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping pending relationship because existingObjectWithID failed: %@\n%@"];
            _NSCoreDataLog( v78,  v79,  v80,  v81,  v82,  v83,  v84,  v85,  (uint64_t)"-[PFCloudKitSerializer applyUpdatedRecords:deletedRecordIDs:toStore:inManagedObjectContext:onlyUp datingAttributes:andRelationships:madeChanges:error:]_block_invoke");
            objc_autoreleasePoolPop(v77);
            uint64_t v67 = 0LL;
          }

          unsigned __int8 v22 = a1;
        }

        uint64_t v52 = v118;
      }

      *(void *)buf = 0LL;
      if (-[PFMirroredOneToManyRelationship updateRelationshipValueUsingImportContext:andManagedObjectContext:error:]( v67,  "updateRelationshipValueUsingImportContext:andManagedObjectContext:error:",  *(void *)(v22 + 40),  *(void *)(v22 + 32),  buf))
      {
        [*(id *)(v22 + 32) deleteObject:v119];
      }

      else
      {
        unint64_t v86 = (void *)MEMORY[0x186E3E5D8]();
        else {
          unint64_t v87 = __ckLoggingOverride;
        }
        unint64_t v88 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to resolve pending relationship: %@\n%@"];
        _NSCoreDataLog( v87,  v88,  v89,  v90,  v91,  v92,  v93,  v94,  (uint64_t)"-[PFCloudKitSerializer applyUpdatedRecords:deletedRecordIDs:toStore:inManagedObjectContext:onlyUpdati ngAttributes:andRelationships:madeChanges:error:]_block_invoke");
        objc_autoreleasePoolPop(v86);
      }

      v65 = v115;
      uint64_t v64 = context;

LABEL_73:
      objc_autoreleasePoolPop(v64);
      v9 = v65 + 1;
    }

    while (v9 != v8);
    __int16 v96 = [v6 countByEnumeratingWithState:&v126 objects:v138 count:16];
    uint64_t v8 = v96;
  }

  while (v96);
LABEL_83:
  if ([*(id *)(a1 + 32) hasChanges])
  {
    **(_BYTE **)(a1 + 80) = 1;
    if (objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "deletedObjects"), "count")) {
      *a5 = 1;
    }
  }

  result = [*(id *)(a1 + 32) save:*(void *)(*(void *)(a1 + 72) + 8) + 40];
  if ((result & 1) == 0)
  {
    *a4 = 1;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = 0;
    return (uint64_t)*(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
  }

  return result;
}

  uint64_t v36 = 0LL;
  if (v11) {
    goto LABEL_49;
  }
LABEL_42:
  uint64_t v37 = (void *)MEMORY[0x186E3E5D8]();
  uint64_t v38 = __ckLoggingOverride;
  uint64_t v39 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Fetch finished with error:\n%@"];
  _NSCoreDataLog( v38 != 0,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  (uint64_t)"-[PFCloudKitImportRecordsWorkItem fetchOperationFinishedWithError:completion:]_block_invoke");
  objc_autoreleasePoolPop(v37);
  if (!a1[6])
  {
LABEL_69:
    uint64_t v50 = 0LL;
    goto LABEL_70;
  }

  uint64_t v46 = (void *)a1[4];
  if (v46)
  {
    uint64_t v47 = v46[2];
    if (!v4)
    {
LABEL_76:
      uint64_t v49 = 0LL;
      goto LABEL_47;
    }
  }

  else
  {
    uint64_t v47 = 0LL;
    if (!v4) {
      goto LABEL_76;
    }
  }

  uint64_t v48 = v4[2];
  if (!v48) {
    goto LABEL_76;
  }
  uint64_t v49 = *(void *)(v48 + 48);
LABEL_47:
  uint64_t v50 = (void *)[v46 createMirroringResultForRequest:v47 storeIdentifier:v49 success:0 madeChanges:v36 error:v5];
  (*(void (**)(void))(a1[6] + 16))();
LABEL_70:
  -[PFCloudKitImportRecordsWorkItem removeDownloadedAssetFiles](a1[4]);

  [v2 drain];
  return 0LL;
}

void *PF_CALLOC_OBJECT_ARRAY(uint64_t a1)
{
  uint64_t v2 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v2 = malloc_default_zone();
  }
  return malloc_zone_calloc(v2, 1uLL, 8 * a1);
}
}

void sub_186685030(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186685000LL);
  }

  _Unwind_Resume(a1);
}

void sub_186685050(_Unwind_Exception *a1)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_186685068(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x186685074LL);
}

void sub_186685128(_Unwind_Exception *a1)
{
}

LABEL_11:
  flags = (_fetchRequestFlags)(*(_DWORD *)&self->_flags | 0x800);
  self->_flags = flags;
LABEL_12:
  if ((*(_WORD *)&flags & 0x1000) == 0)
  {
    unsigned __int8 v13 = self->_valuesToFetch;
    if (v13) {
      -[NSFetchRequest _bindExpressionDescriptionProperties:]((uint64_t)self, v13);
    }
    unsigned __int8 v14 = self->_groupByProperties;
    if (v14) {
      -[NSFetchRequest _bindExpressionDescriptionProperties:]((uint64_t)self, v14);
    }
    *(_DWORD *)&self->_flags |= 0x1000u;
  }

  if (context && (v12 & 1) == 0 && _PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl((uint64_t)context, a2);
  }
  unsigned __int8 v13 = PFInstrumentsRecordingEnabled();
  unsigned __int8 v14 = MEMORY[0x1895F87A8];
  if (!v13) {
    goto LABEL_27;
  }
  if (v10 == 1 || v10 == 3)
  {
    v87[0] = MEMORY[0x1895F87A8];
    v87[1] = 3221225472LL;
    v87[2] = __65__NSPersistentStoreCoordinator_executeRequest_withContext_error___block_invoke_381;
    v87[3] = &unk_189EA8DB8;
    v87[4] = v6;
    spid = __65__NSPersistentStoreCoordinator_executeRequest_withContext_error___block_invoke_381((uint64_t)v87);
    goto LABEL_29;
  }

  if (v10 != 2)
  {
LABEL_27:
    spid = 0LL;
LABEL_29:
    unint64_t v86 = 0LL;
    unint64_t v17 = 1;
    if (v10 > 7 || ((1LL << v10) & 0xE4) == 0) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }

  unint64_t v15 = MEMORY[0x1895F87A8];
  if (PFInstrumentsGetLog_logtoken != -1) {
    dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
  }
  spid = os_signpost_id_generate((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog);
  if (PFInstrumentsGetLog_logtoken != -1) {
    dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
  }
  int v16 = (os_log_s *)PFInstrumentsGetLog_coreDataInstrumentsLog;
  kdebug_trace();
  unsigned __int8 v14 = v15;
  if (spid - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_186681000, v16, OS_SIGNPOST_INTERVAL_BEGIN, spid, "Save", "", buf, 2u);
  }

  unint64_t v86 = 0LL;
LABEL_31:
  unint64_t v17 = 0;
LABEL_32:
  if (context) {
    persistentStoreIdentifiers = context->_persistentStoreIdentifiers;
  }
  else {
    persistentStoreIdentifiers = 0LL;
  }
  unsigned __int8 v19 = +[NSQueryGenerationToken currentQueryGenerationToken]( &OBJC_CLASS___NSQueryGenerationToken,  "currentQueryGenerationToken");
  if (v19 != (NSQueryGenerationToken *)-[NSManagedObjectContext _queryGenerationToken]( context,  "_queryGenerationToken"))
  {
    exception_object = 1;
    goto LABEL_36;
  }

  pthread_t v30 = -[NSPersistentStoreCoordinator _retainedCurrentQueryGeneration:](self, "_retainedCurrentQueryGeneration:");
  if (v30)
  {
    uint64_t v31 = -[NSManagedObjectContext _setQueryGenerationFromToken:error:]( context,  "_setQueryGenerationFromToken:error:",  v30,  &v86);

    if (v31)
    {
      exception_object = 1;
      unsigned __int8 v14 = MEMORY[0x1895F87A8];
      goto LABEL_36;
    }
  }

  else
  {
    unint64_t v86 = (NSError *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134502 userInfo:0];
  }

  if (!v17)
  {
    uint64_t v40 = +[NSQueryGenerationToken unpinnedQueryGenerationToken]( &OBJC_CLASS___NSQueryGenerationToken,  "unpinnedQueryGenerationToken");
    unsigned __int8 v14 = MEMORY[0x1895F87A8];
    -[NSManagedObjectContext _setQueryGenerationFromToken:error:]( context,  "_setQueryGenerationFromToken:error:",  v40,  0LL);
    exception_object = 0;
LABEL_36:
    if (v10 != 8 || !-[NSPersistentStoreRequest token](v6, "token"))
    {
LABEL_50:
      v80[0] = v14;
      v80[1] = 3221225472LL;
      v80[2] = __65__NSPersistentStoreCoordinator_executeRequest_withContext_error___block_invoke_386;
      v80[3] = &unk_189EA8DE0;
      v80[4] = v6;
      v80[5] = persistentStoreIdentifiers;
      v80[6] = self;
      v80[7] = context;
      uint64_t v81 = exception_object;
      v80[8] = &v93;
      v80[9] = &v89;
      v80[10] = &v99;
      v80[11] = v10;
      v80[12] = spid;
      v80[13] = error;
      -[NSPersistentStoreCoordinator _routeHeavyweightBlock:]((unint64_t)self, (uint64_t)v80);
      if (*((_BYTE *)v90 + 24))
      {
        pthread_yield_np();
        uint64_t v29 = -[NSPersistentStoreCoordinator executeRequest:withContext:error:]( self,  "executeRequest:withContext:error:",  v6,  context,  error);
LABEL_92:
        uint64_t v39 = v29;
        goto LABEL_93;
      }

      if (v6 && v10 == 2) {
        v6[3].super.isa = (Class)((unint64_t)v6[3].super.isa & 0xFFFFFF00);
      }
      uint64_t v32 = (id)v100[5];
      if (error && !v94[5]) {
        *error = (NSError *)v100[5];
      }
      if (spid)
      {
        if (v10 == 1 || v10 == 3)
        {
          if (PFInstrumentsGetLog_logtoken != -1) {
            dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
          }
          if (spid != -1LL)
          {
            uint64_t v44 = PFInstrumentsGetLog_coreDataInstrumentsLog;
            if (os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog))
            {
              uint64_t v45 = [(id)v94[5] count];
              *(_DWORD *)buf = 67109120;
              LODWORD(v109) = v45;
              v34 = "Fetch";
              unint64_t v35 = "%d";
              uint64_t v36 = (os_log_s *)v44;
              uint64_t v37 = spid;
              uint64_t v38 = 8;
              goto LABEL_84;
            }
          }
        }

        else if (v10 == 2)
        {
          if (PFInstrumentsGetLog_logtoken != -1) {
            dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
          }
          if (spid != -1LL)
          {
            uint64_t v33 = PFInstrumentsGetLog_coreDataInstrumentsLog;
            if (os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog))
            {
              *(_WORD *)buf = 0;
              v34 = "Save";
              unint64_t v35 = "";
              uint64_t v36 = (os_log_s *)v33;
              uint64_t v37 = spid;
              uint64_t v38 = 2;
LABEL_84:
              _os_signpost_emit_with_name_impl(&dword_186681000, v36, OS_SIGNPOST_INTERVAL_END, v37, v34, v35, buf, v38);
            }
          }
        }
      }

      uint64_t v46 = v100[5];
      if (v94[5])
      {
        if (!v46) {
          goto LABEL_91;
        }
      }

      else if (v46)
      {
LABEL_91:
        uint64_t v29 = (id)v94[5];
        goto LABEL_92;
      }

      uint64_t v47 = [NSString stringWithUTF8String:"Either a non nil result OR an error"];
      _NSCoreDataLog(17LL, v47, v48, v49, v50, v51, v52, v53, v71);
      uint64_t v54 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_186681000,  v54,  OS_LOG_TYPE_FAULT,  "CoreData: Either a non nil result OR an error",  buf,  2u);
      }

      goto LABEL_91;
    }

    v74 = (void *)-[NSPersistentStoreRequest token](v6, "token");
    BOOL v20 = (void *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithCapacity:",  objc_msgSend((id)objc_msgSend(v74, "storeTokens"), "count"));
    unsigned __int8 v21 = (void *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithCapacity:",  objc_msgSend((id)objc_msgSend(v74, "storeTokens"), "count"));
    uint64_t v72 = persistentStoreIdentifiers;
    uint64_t v73 = v6;
    v84 = 0u;
    unint64_t v85 = 0u;
    uint64_t v83 = 0u;
    uint64_t v82 = 0u;
    unsigned __int8 v22 = (void *)[v74 storeTokens];
    unint64_t v23 = [v22 countByEnumeratingWithState:&v82 objects:v107 count:16];
    if (v23)
    {
      int v24 = *(void *)v83;
      do
      {
        for (i = 0LL; i != v23; ++i)
        {
          if (*(void *)v83 != v24) {
            objc_enumerationMutation(v22);
          }
          BOOL v26 = *(void *)(*((void *)&v82 + 1) + 8 * i);
          unsigned __int8 v27 = -[NSPersistentStoreCoordinator persistentStoreForIdentifier:]( self,  "persistentStoreForIdentifier:",  v26);
          if (v27) {
            [v20 addObject:v27];
          }
          else {
            [v21 addObject:v26];
          }
        }

        unint64_t v23 = [v22 countByEnumeratingWithState:&v82 objects:v107 count:16];
      }

      while (v23);
    }

    BOOL v28 = [v20 count];
    persistentStoreIdentifiers = v72;
    int v6 = v73;
    unsigned __int8 v14 = MEMORY[0x1895F87A8];
    if (v28)
    {
      -[NSPersistentStoreRequest setAffectedStores:](v73, "setAffectedStores:", v20);
      goto LABEL_50;
    }

    uint64_t v41 = (void *)MEMORY[0x189607870];
    v105 = @"Reason";
    v106 = [NSString stringWithFormat:@"Unable to find stores referenced in History Token (%@) - %@", v74, v21];
    uint64_t v42 = [MEMORY[0x189603F68] dictionaryWithObjects:&v106 forKeys:&v105 count:1];
    uint64_t v43 = (NSError *)[v41 errorWithDomain:*MEMORY[0x189607460] code:134501 userInfo:v42];
    v100[5] = (uint64_t)v43;
    if (v43)
    {
      if (error)
      {
        uint64_t v39 = 0LL;
        *error = v43;
        goto LABEL_93;
      }

      goto LABEL_101;
    }

    uint64_t v64 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v64,  v65,  v66,  v67,  v68,  v69,  v70,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentStoreCoordinator.m");
    uint64_t v63 = (os_log_s *)__pflogFaultLog;
    if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
      goto LABEL_101;
    }
    *(_DWORD *)buf = 136315394;
    v109 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentStoreCoordinator.m";
    v110 = 1024;
    v111 = 2805;
LABEL_103:
    _os_log_fault_impl( &dword_186681000,  v63,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    goto LABEL_101;
  }

  if (v86)
  {
    if (error)
    {
      uint64_t v39 = 0LL;
      *error = v86;
      goto LABEL_93;
    }

    goto LABEL_101;
  }

  unint64_t v56 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
  _NSCoreDataLog( 17LL,  v56,  v57,  v58,  v59,  v60,  v61,  v62,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentStoreCoordinator.m");
  uint64_t v63 = (os_log_s *)__pflogFaultLog;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315394;
    v109 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentStoreCoordinator.m";
    v110 = 1024;
    v111 = 2782;
    goto LABEL_103;
  }

        while (!*v6)
        {
          ++v6;
          if (!--v3) {
            goto LABEL_13;
          }
        }

    [v8 setInterruptionHandler:&__block_literal_global_1];
    v76[0] = MEMORY[0x1895F87A8];
    v76[1] = 3221225472LL;
    v76[2] = __52__NSXPCStoreConnection_createConnectionWithOptions___block_invoke_2;
    v76[3] = &unk_189EA7758;
    v76[4] = a1;
    [v8 setInvalidationHandler:v76];
    int v24 = (const void *)[*(id *)(a1 + 16) _persistentStoreCoordinator];
    memset(&valueCallBacks, 0, 24);
    *(_OWORD *)&valueCallBacks.copyDescription = *(_OWORD *)(MEMORY[0x189605250] + 24LL);
    unint64_t v25 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605240], &valueCallBacks);
    CFDictionarySetValue(v25, @"PSCKey", v24);
    [*(id *)(a1 + 24) setUserInfo:v25];
    CFRelease(v25);
    objc_msgSend( v8,  "setRemoteObjectInterface:",  objc_msgSend(MEMORY[0x189607B48], "interfaceWithProtocol:", &unk_18C698588));
    [v8 resume];
    return (uint64_t)v8;
  }

  unint64_t v35 = [a2 valueForKey:@"NSXPCStoreServerEndpointFactory"];
  if (!v35)
  {
    uint64_t v44 = [NSString stringWithUTF8String:"Unable to create NSXPCConnection; no service name or endpoint factory."];
    _NSCoreDataLog(17LL, v44, v45, v46, v47, v48, v49, v50, v74);
    uint64_t v51 = __pflogFaultLog;
    if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
      goto LABEL_31;
    }
    LOWORD(valueCallBacks.version) = 0;
    unint64_t v23 = "CoreData: Unable to create NSXPCConnection; no service name or endpoint factory.";
    uint64_t v33 = (os_log_s *)v51;
    v34 = 2;
    goto LABEL_15;
  }

  uint64_t v36 = (void *)v35;
  uint64_t v77 = 0LL;
  if ((objc_opt_respondsToSelector() & 1) != 0) {
    uint64_t v37 = [v36 newEndpointWithError:&v77];
  }
  else {
    uint64_t v37 = [v36 newEndpoint];
  }
  uint64_t v52 = (void *)v37;
  if (v37)
  {
    uint64_t v53 = [objc_alloc(MEMORY[0x189607B30]) initWithListenerEndpoint:v37];
    if (!v53)
    {
      uint64_t v61 = [NSString stringWithUTF8String:"Unable to create token NSXPCConnection -initWithListenerEndpoint:%p returned nil"];
      _NSCoreDataLog(17LL, v61, v62, v63, v64, v65, v66, v67, (uint64_t)v52);
      uint64_t v68 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        LODWORD(valueCallBacks.version) = 134217984;
        *(CFIndex *)((char *)&valueCallBacks.version + 4) = (CFIndex)v52;
        _os_log_fault_impl( &dword_186681000,  v68,  OS_LOG_TYPE_FAULT,  "CoreData: Unable to create token NSXPCConnection -initWithListenerEndpoint:%p returned nil",  (uint8_t *)&valueCallBacks,  0xCu);
      }

      goto LABEL_31;
    }

    uint64_t v8 = (void *)v53;

    goto LABEL_11;
  }

  if (!v77)
  {
    uint64_t v54 = [NSString stringWithUTF8String:"Unable to create token NSXPCConnection.  NSXPCStoreServerEndpointFactory %p -newEndpoint returned nil"];
    _NSCoreDataLog(17LL, v54, v55, v56, v57, v58, v59, v60, (uint64_t)v36);
    int v16 = __pflogFaultLog;
    if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
      goto LABEL_31;
    }
    LODWORD(valueCallBacks.version) = 134217984;
    *(CFIndex *)((char *)&valueCallBacks.version + 4) = (CFIndex)v36;
    unint64_t v23 = "CoreData: Unable to create token NSXPCConnection.  NSXPCStoreServerEndpointFactory %p -newEndpoint returned nil";
    goto LABEL_14;
  }

  _NSCoreDataLog( 1LL,  (uint64_t)@"Unable to create token NSXPCConnection.  NSXPCStoreServerEndpointFactory %p -newEndpointWithError returned error %@",  v38,  v39,  v40,  v41,  v42,  v43,  (uint64_t)v36);
  uint64_t v70 = *MEMORY[0x1896075A8];
  uint64_t v71 = [v77 code];
  uint64_t v72 = [NSString stringWithFormat:@"NSXPCStoreServerEndpointFactory failed to provide an endpoint"];
  uint64_t v79 = *MEMORY[0x189607798];
  v80[0] = v77;
  uint64_t v73 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  v70,  v71,  v72,  (void *)[MEMORY[0x189603F68] dictionaryWithObjects:v80 forKeys:&v79 count:1]);
  -[_NSCoreDataException _setDomain:]((uint64_t)v73, (void *)[v77 domain]);
  objc_exception_throw(v73);
  return __52__NSXPCStoreConnection_createConnectionWithOptions___block_invoke();
}

    objc_opt_self();
    return +[NSSQLDerivedAttributeSQLGenerator _generateSQLForToOneDerivationForDerivedAttribute:toOneKeypath:]( (uint64_t)NSSQLDerivedAttributeSQLGenerator,  a2,  (void *)[a3 anyObject]);
  }

  -[NSEntityMapping setMappingType:](v4, "setMappingType:", v5);
  return v4;
}

        ++v9;
      }

      while (v6 != v9);
      result = [a2 countByEnumeratingWithState:&v19 objects:v23 count:16];
      int v6 = result;
    }

    while (result);
  }

  return result;
}

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0) {
    return obj;
  }
  if ([obj isNSArray])
  {
    unint64_t v5 = objc_alloc_init(MEMORY[0x189603FA8]);
    pthread_t v30 = 0u;
    uint64_t v31 = 0u;
    uint64_t v32 = 0u;
    uint64_t v33 = 0u;
    int v6 = [obj countByEnumeratingWithState:&v30 objects:v36 count:16];
    if (v6)
    {
      unint64_t v7 = v6;
      uint64_t v8 = *(void *)v31;
      do
      {
        for (i = 0LL; i != v7; ++i)
        {
          if (*(void *)v31 != v8) {
            objc_enumerationMutation(obj);
          }
          unint64_t v10 = (void *)-[_NSPersistentHistoryPredicateRemapper replacementValueForValue:]( a1,  *(void *)(*((void *)&v30 + 1) + 8 * i));
          [v5 addObject:v10];
        }

        unint64_t v7 = [obj countByEnumeratingWithState:&v30 objects:v36 count:16];
      }

      while (v7);
    }

    return v5;
  }

  if ([obj isNSSet])
  {
    unint64_t v5 = objc_alloc_init(MEMORY[0x189603FE0]);
    BOOL v26 = 0u;
    unsigned __int8 v27 = 0u;
    BOOL v28 = 0u;
    uint64_t v29 = 0u;
    int v11 = [obj countByEnumeratingWithState:&v26 objects:v35 count:16];
    if (v11)
    {
      unint64_t v12 = v11;
      unsigned __int8 v13 = *(void *)v27;
      do
      {
        for (j = 0LL; j != v12; ++j)
        {
          if (*(void *)v27 != v13) {
            objc_enumerationMutation(obj);
          }
          unint64_t v15 = (void *)-[_NSPersistentHistoryPredicateRemapper replacementValueForValue:]( a1,  *(void *)(*((void *)&v26 + 1) + 8 * j));
          [v5 addObject:v15];
        }

        unint64_t v12 = [obj countByEnumeratingWithState:&v26 objects:v35 count:16];
      }

      while (v12);
    }

    return v5;
  }

  if ([obj isNSOrderedSet])
  {
    unint64_t v5 = objc_alloc_init(MEMORY[0x189603FD0]);
    unsigned __int8 v22 = 0u;
    unint64_t v23 = 0u;
    int v24 = 0u;
    unint64_t v25 = 0u;
    int v16 = [obj countByEnumeratingWithState:&v22 objects:v34 count:16];
    if (v16)
    {
      unint64_t v17 = v16;
      BOOL v18 = *(void *)v23;
      do
      {
        for (k = 0LL; k != v17; ++k)
        {
          if (*(void *)v23 != v18) {
            objc_enumerationMutation(obj);
          }
          BOOL v20 = (void *)-[_NSPersistentHistoryPredicateRemapper replacementValueForValue:]( a1,  *(void *)(*((void *)&v22 + 1) + 8 * k));
          [v5 addObject:v20];
        }

        unint64_t v17 = [obj countByEnumeratingWithState:&v22 objects:v34 count:16];
      }

      while (v17);
    }

    return v5;
  }

  return (id)[obj copy];
}

    LOBYTE(v5) = 0;
  }

  return v5;
}

      unint64_t v17 = (NSPersistentCloudKitContainerEvent *)v30[0];
      BOOL v18 = *(void *)(a1 + 64);
      goto LABEL_12;
    }
  }

  if (v30[0]) {
    goto LABEL_11;
  }
  unsigned __int8 v19 = [NSString stringWithUTF8String:"No event was found for the identifier '%@' in this result: %@"];
  BOOL v20 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "request"), "requestIdentifier");
  _NSCoreDataLog(17LL, v19, v21, v22, v23, v24, v25, v26, v20);
  unsigned __int8 v27 = (os_log_s *)__pflogFaultLog;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    BOOL v28 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "request"), "requestIdentifier");
    uint64_t v29 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412546;
    uint64_t v32 = v28;
    uint64_t v33 = 2112;
    v34 = v29;
    _os_log_fault_impl( &dword_186681000,  v27,  OS_LOG_TYPE_FAULT,  "CoreData: No event was found for the identifier '%@' in this result: %@",  buf,  0x16u);
  }

  uint64_t v3 = *(void *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 41) & 4) != 0)
  {
    [(id)a1 willChangeValueForKey:@"hasChanges"];
    *(_DWORD *)(a1 + 40) &= ~0x400u;
    [(id)a1 didChangeValueForKey:@"hasChanges"];
  }

  if (*(_DWORD *)(a1 + 16))
  {
    unint64_t v5 = *(void ***)(a1 + 168);
    if (v5)
    {
      if (v5[7])
      {
        PF_FREE_OBJECT_ARRAY(v5[7]);
        *(void *)(*(void *)(a1 + 168) + 56LL) = 0LL;
        unint64_t v5 = *(void ***)(a1 + 168);
      }

      PF_FREE_OBJECT_ARRAY(v5);
      *(void *)(a1 + 168) = 0LL;
    }

    int v6 = *(void **)(a1 + 136);
    if (v6)
    {

      *(void *)(a1 + 136) = 0LL;
    }
  }

  else
  {
    *(_DWORD *)(a1 + 16) = 1;
    if (*(void *)(a1 + 168))
    {
      unint64_t v7 = (void *)[MEMORY[0x189607958] defaultCenter];
      -[NSManagedObjectContext _stopObservingUndoManagerNotifications](a1);

      *(void *)(*(void *)(a1 + 168) + 40LL) = 0LL;
      uint64_t v8 = [(id)a1 persistentStoreCoordinator];
      if (v8) {
        [v7 removeObserver:a1 name:@"_NSPersistentStoreCoordinatorStoresDidChangePrivateNotification" object:v8];
      }
      if ((*(_BYTE *)(a1 + 42) & 0x80) != 0 && *(void *)(a1 + 32)) {
        objc_msgSend( (id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"),  "removeObserver:name:object:",  a1,  @"_NSManagedObjectContextDidSaveObjectIDsPrivateNotification",  *(void *)(a1 + 32));
      }
    }

    v9 = *(void **)(*(void *)(a1 + 168) + 72LL);
    if (v9)
    {

      *(void *)(*(void *)(a1 + 168) + 72LL) = 0LL;
    }

    Count = _PFCMT_GetCount(*(void **)(a1 + 120));
    if (v3 || Count < 0x12C)
    {
      -[NSManagedObjectContext _dispose:](a1);
      if (!v3) {
        _PFDeallocateObject((id)a1);
      }
    }

    else
    {
      int v11 = -[_PFTask initWithFunction:withArgument:andPriority:]( objc_alloc(&OBJC_CLASS____PFTask),  "initWithFunction:withArgument:andPriority:",  _deallocateContextBackgroundThread,  a1,  0LL);
      if (v11) {
    }
      }
  }

  unsigned __int8 v19 = (void *)v30[5];
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&v29, 8);
  return v19;
}

  unint64_t v12 = strlen(CStringPtr);
  CC_SHA256_Update(&c, CStringPtr, v12);
LABEL_12:
  CC_SHA256_Update(&c, &data, 2u);
  versionHashModifier = self->_versionHashModifier;
  if (versionHashModifier)
  {
    unsigned __int8 v14 = CFStringGetCStringPtr((CFStringRef)versionHashModifier, 0x8000100u);
    if (!v14) {
      unsigned __int8 v14 = -[NSString UTF8String](self->_versionHashModifier, "UTF8String");
    }
    unint64_t v15 = strlen(v14);
    CC_SHA256_Update(&c, v14, v15);
  }

  CC_SHA256_Final((unsigned __int8 *)a3, &c);
}

  unint64_t v10 = *((_BYTE *)v20 + 24);
  _Block_object_dispose(&v19, 8);
  return v10;
}

  return v4;
}

    if (sqlite3_close_v2(*(sqlite3 **)(a1 + 72)))
    {
      unint64_t v10 = [NSString stringWithFormat:@"Disconnected from database with pending transactions: %@", objc_msgSend(NSString, "stringWithUTF8String:", sqlite3_errmsg(*(sqlite3 **)(a1 + 72)))];
      _NSCoreDataLog(1LL, (uint64_t)@"%@\n", v11, v12, v13, v14, v15, v16, v10);
      stmt = 0LL;
      while (1)
      {
        stmt = sqlite3_next_stmt(*(sqlite3 **)(a1 + 72), stmt);
        if (!stmt) {
          break;
        }
        BOOL v18 = objc_msgSend(NSString, "stringWithFormat:", @"Un-finalized statement: %p", stmt);
        _NSCoreDataLog(1LL, (uint64_t)@"%@\n", v19, v20, v21, v22, v23, v24, v18);
      }
    }

  if ([*(id *)(v1 + 48) hasChanges]
    && ([*(id *)(v1 + 48) save:v109] & 1) == 0)
  {
    int v6 = (void *)MEMORY[0x186E3E5D8]();
    unint64_t v7 = __ckLoggingOverride;
    uint64_t v8 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Failed to save metadata changes during import check: %@"];
    _NSCoreDataLog( v7 != 0,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)"-[NSCloudKitMirroringDelegate checkAndScheduleImportIfNecessaryFromPush:fromErrorRecovery:fromShareAccept :andStartAfterDate:]_block_invoke");
    objc_autoreleasePoolPop(v6);
  }

  if (v5)
  {
    if (!*(_BYTE *)(*(void *)(v1 + 32) + 89LL))
    {
      uint64_t v33 = (void *)MEMORY[0x186E3E5D8]();
      v34 = __ckLoggingOverride;
      unint64_t v35 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Deferring scheduling an import because not initialized yet: %@"];
      if (v34 >= 3) {
        uint64_t v42 = 3LL;
      }
      else {
        uint64_t v42 = v34;
      }
      _NSCoreDataLog( v42,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  (uint64_t)"-[NSCloudKitMirroringDelegate checkAndScheduleImportIfNecessaryFromPush:fromErrorRecovery:fromShareAcce pt:andStartAfterDate:]_block_invoke");
      objc_autoreleasePoolPop(v33);
      goto LABEL_80;
    }

    if (!v4
      && (unint64_t v15 = [NSString stringWithUTF8String:"Mirroring delegate is scheduling an import but didn't log why: %@"],  _NSCoreDataLog(17, v15, v16, v17, v18, v19, v20, v21, *(void *)(v1 + 32)),  v22 = (os_log_s *)__pflogFaultLog,  os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)))
    {
      unint64_t v76 = *(void *)(v1 + 32);
      *(_DWORD *)buf = 138412290;
      v111 = v76;
      _os_log_fault_impl( &dword_186681000,  v22,  OS_LOG_TYPE_FAULT,  "CoreData: Mirroring delegate is scheduling an import but didn't log why: %@",  buf,  0xCu);
      if ((v3 & 1) != 0) {
        goto LABEL_19;
      }
    }

    else if ((v3 & 1) != 0)
    {
LABEL_19:
      unint64_t v23 = (void *)MEMORY[0x186E3E5D8]();
      int v24 = __ckLoggingOverride;
      if (v95)
      {
        unint64_t v25 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Bypassing dasd for scheduling for voucher: %@\n%@"];
        if (v24 >= 3) {
          uint64_t v32 = 3LL;
        }
        else {
          uint64_t v32 = v24;
        }
        uint64_t v93 = v4;
        uint64_t v91 = 3427LL;
        v92 = *(void *)(v1 + 32);
        _NSCoreDataLog( v32,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  (uint64_t)"-[NSCloudKitMirroringDelegate checkAndScheduleImportIfNecessaryFromPush:fromErrorRecovery:fromShareAc cept:andStartAfterDate:]_block_invoke");
      }

      else
      {
        uint64_t v43 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Bypassing dasd for scheduling for HomeKit: %@"];
        if (v24 >= 3) {
          uint64_t v50 = 3LL;
        }
        else {
          uint64_t v50 = v24;
        }
        v92 = *(void *)(v1 + 32);
        uint64_t v93 = v4;
        uint64_t v91 = 3429LL;
        _NSCoreDataLog( v50,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  (uint64_t)"-[NSCloudKitMirroringDelegate checkAndScheduleImportIfNecessaryFromPush:fromErrorRecovery:fromShareAc cept:andStartAfterDate:]_block_invoke");
      }

      objc_autoreleasePoolPop(v23);
      -[NSCloudKitMirroringDelegate _scheduleAutomatedImportWithLabel:activity:voucher:completionHandler:]( *(void *)(v1 + 32),  [NSString stringWithFormat:@"InitialImport-BypassingDasd-%@", v4, v91, v92, v93],  0,  (uint64_t)v95,  0);
      goto LABEL_80;
    }

    uint64_t v77 = -[NSCloudKitMirroringDelegate newActivityWithIdentifier:andVoucher:]( *(void *)(v1 + 32),  *(void *)(*(void *)(v1 + 32) + 176LL),  v95);
    uint64_t v78 = v77;
    if (*(void *)(v1 + 56)) {
      objc_msgSend(v77, "setEarliestStartDate:");
    }
    uint64_t v79 = (void *)MEMORY[0x186E3E5D8]();
    uint64_t v80 = __ckLoggingOverride;
    uint64_t v81 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Scheduling automated import with activity (%@): %@"];
    if (v80 >= 3) {
      unint64_t v88 = 3LL;
    }
    else {
      unint64_t v88 = v80;
    }
    _NSCoreDataLog( v88,  v81,  v82,  v83,  v84,  v85,  v86,  v87,  (uint64_t)"-[NSCloudKitMirroringDelegate checkAndScheduleImportIfNecessaryFromPush:fromErrorRecovery:fromShareAccept :andStartAfterDate:]_block_invoke");
    objc_autoreleasePoolPop(v79);
    v89 = *(void *)(v1 + 32);
    if (v89) {
      v90 = *(void **)(v89 + 64);
    }
    else {
      v90 = 0LL;
    }
    [v90 submitActivity:v78];
  }

LABEL_101:
  uint64_t v39 = 0LL;
LABEL_93:
  if ((v77 & 1) != 0) {
    +[NSPersistentStoreCoordinator _endPowerAssertionWithAssert:andApp:]( (uint64_t)&OBJC_CLASS___NSPersistentStoreCoordinator,  v88,  v75);
  }
  _Block_object_dispose(&v89, 8);
  _Block_object_dispose(&v93, 8);
  _Block_object_dispose(&v99, 8);
  return v39;
}

      _NSCoreDataLog( 1LL,  (uint64_t)@"BufferAllocations Result Object has an invalid Object ID",  v84,  v85,  v86,  v87,  v88,  v89,  v106);
LABEL_102:
      uint64_t v45 = 0LL;
LABEL_106:
      uint64_t v91 = v45;
LABEL_123:
      objc_autoreleasePoolPop(v5);
      return v45;
    default:
      _NSCoreDataLog(1LL, (uint64_t)@"Unsupported property type: %@", v28, v29, v30, v31, v32, v33, (uint64_t)v17);
      goto LABEL_44;
  }

            uint64_t v100 = (sqlite3_int64 *)v22;
            if (BYTE1(v189[6 * v23 + 5]) == 3)
            {
              v101 = objc_msgSend((id)objc_msgSend(*(id *)&v189[6 * v23 + 6], "toOneRelationship"), "destinationEntity");
              if (v101) {
                v102 = *(unsigned int *)(v101 + 184);
              }
              else {
                v102 = 0LL;
              }
              *(void *)unsigned __int8 v22 = v102;
              uint64_t v100 = (sqlite3_int64 *)(v22 + 8);
            }

            *uint64_t v100 = v60;
            uint64_t v52 = (char *)(v100 + 1);
            v103 = v181;
            if ((v183 & (v23 == 5)) != 0) {
              v103 = v60;
            }
            v181 = v103;
            ++v186;
            BOOL v26 = v187;
            goto LABEL_117;
          case 4:
          case 5:
          case 6:
          case 9:
          case 12:
          case 13:
          case 14:
            plan_for_entity = v189;
            uint64_t v36 = &v189[6 * v23];
            uint64_t v38 = v36[3];
            uint64_t v37 = v36 + 3;
            uint64_t v39 = sqlite3_column_text(*(sqlite3_stmt **)(v185 + 80), v38);
            uint64_t v40 = v39;
            if ((v189[6 * v23 + 4] & 1) == 0) {
              goto LABEL_46;
            }
            if (v39 && *v39)
            {
              *(_DWORD *)unsigned __int8 v22 = 0;
            }

            else
            {
              uint64_t v41 = sqlite3_column_type(*(sqlite3_stmt **)(v185 + 80), *v37);
              *(_DWORD *)unsigned __int8 v22 = v41 == 5;
              if (v41 == 5)
              {
LABEL_45:
                BOOL v26 = v187;
                goto LABEL_118;
              }

              if (!*(_BYTE *)(*(void *)(*(void *)(v106 + 64) + 8LL) + 24LL)) {
                goto LABEL_125;
              }
            }

            uint64_t v100 = [v2 countByEnumeratingWithState:&v135 objects:v187 count:16];
            if (!v100) {
              goto LABEL_125;
            }
          }
        }
      }

      goto LABEL_125;
    }

    v107 = +[NSCKDatabaseMetadata databaseMetadataForScope:forStore:inContext:error:]( (uint64_t)&OBJC_CLASS___NSCKDatabaseMetadata,  *(void *)(v130 + 88),  *(void *)(v130 + 32),  *(void **)(v130 + 48),  (uint64_t)&v159);
    v108 = v107;
    if (v107)
    {
      -[NSManagedObject setCurrentChangeToken:](v107, "setCurrentChangeToken:", 0LL);
      -[NSManagedObject setHasSubscription:](v108, "setHasSubscription:", 0LL);
      v145 = 0u;
      v146 = 0u;
      v143 = 0u;
      v144 = 0u;
      v109 = (void *)-[NSManagedObject recordZones](v108, "recordZones");
      v110 = [v109 countByEnumeratingWithState:&v143 objects:v189 count:16];
      if (v110)
      {
        v111 = *(void *)v144;
        do
        {
          for (k = 0LL; k != v110; ++k)
          {
            if (*(void *)v144 != v111) {
              objc_enumerationMutation(v109);
            }
            v113 = *(void **)(*((void *)&v143 + 1) + 8 * k);
            [v113 setCurrentChangeToken:0];
            [v113 setHasRecordZone:0];
            [v113 setHasSubscription:0];
            [v113 setSupportsFetchChanges:0];
            [v113 setSupportsAtomicChanges:0];
            [v113 setSupportsRecordSharing:0];
          }

          v110 = [v109 countByEnumeratingWithState:&v143 objects:v189 count:16];
        }

        while (v110);
      }

      if ([*(id *)(v130 + 48) save:&v159])
      {
        v141 = 0u;
        v142 = 0u;
        v139 = 0u;
        v140 = 0u;
        v114 = [v2 countByEnumeratingWithState:&v139 objects:v188 count:16];
        if (!v114) {
          goto LABEL_125;
        }
        v115 = *(void *)v140;
LABEL_116:
        v116 = 0LL;
        while (1)
        {
          if (*(void *)v140 != v115) {
            objc_enumerationMutation(v2);
          }
          if (!-[PFCloudKitMetadataPurger _purgeZoneRelatedObjectsInZoneWithID:inDatabaseWithScope:withOptions:inStore:usingContext:error:]( *(void *)(v130 + 56),  *(void **)(*((void *)&v139 + 1) + 8 * v116),  *(void *)(v130 + 80),  *(void *)(v130 + 32),  *(void **)(v130 + 48),  &v159)) {
            break;
          }
          if (v114 == ++v116)
          {
            v114 = [v2 countByEnumeratingWithState:&v139 objects:v188 count:16];
            if (!v114) {
              goto LABEL_125;
            }
            goto LABEL_116;
          }
        }
      }
    }

    else if (!v159)
    {
      goto LABEL_125;
    }

    *(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8LL) + 24LL) = 0;
  }

void sub_1866866F8(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_terminate();
    if (v2) {
      JUMPOUT(0x18668672CLL);
    }
  }

  JUMPOUT(0x1866866C4LL);
}

void sub_186686708(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x18668672CLL);
  }
  JUMPOUT(0x1866866C4LL);
}

void sub_18668671C(void *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    if ((v2 & 1) != 0) {
      JUMPOUT(0x1866863ACLL);
    }
    JUMPOUT(0x1866866E4LL);
  }

  JUMPOUT(0x1866866C4LL);
}

uint64_t PFInstrumentsRecordingEnabled()
{
  uint64_t result = kdebug_is_enabled();
  if ((_DWORD)result)
  {
    if (PFInstrumentsGetLog_logtoken != -1) {
      dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
    }
    return os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog);
  }

  return result;
}

void sub_186686A04()
{
}

void sub_186686A10()
{
}

void sub_186686A1C()
{
  if (v0) {
    JUMPOUT(0x186686A24LL);
  }
  JUMPOUT(0x186686A28LL);
}

void gutsOfBlockToNSPersistentStoreCoordinatorPerform(void *a1)
{
  int v1 = a1;
  uint64_t v60 = *MEMORY[0x1895F89C0];
  uint64_t v3 = (void (**)(void))*a1;
  unint64_t v2 = a1[1];
  uint64_t v4 = a1[2];
  if (_PF_Threading_Debugging_level >= 2) {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 16));
  }
  atomic_store(1u, (unsigned __int8 *)(v2 + 28));
  if ((v4 & 4) != 0)
  {
    id v5 = objc_alloc_init(MEMORY[0x1896077E8]);
    if ((v4 & 0x2000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  id v5 = 0LL;
  if ((v4 & 0x2000) != 0) {
LABEL_7:
  }
    __dmb(0xBu);
LABEL_8:
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v7 = v1[3];
  uint64_t v51 = *(void *)(StatusReg + 712);
  if (v51 == v2)
  {
    unint64_t v9 = 0LL;
  }

  else
  {
    if (v7)
    {
      id v49 = v5;
      exception_object = (_Unwind_Exception *)StatusReg;
      uint64_t v8 = (unint64_t *)(v7 + 8);
      unint64_t v9 = atomic_load((unint64_t *)(v7 + 8));
      do
      {
        unint64_t v10 = __ldaxr(v8);
        if (v10 != v9)
        {
          uint64_t v13 = v7;
          unint64_t v14 = 0x189607000uLL;
          unint64_t v15 = "Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)";
          while (1)
          {
            __clrex();
            unint64_t v16 = v14;
            unint64_t v17 = v15;
            uint64_t v18 = objc_msgSend(*(id *)(v14 + 2600), "stringWithUTF8String:");
            atomic_load((unint64_t *)(v13 + 8));
            _NSCoreDataLog(17LL, v18, v19, v20, v21, v22, v23, v24, v13);
            unint64_t v25 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              unint64_t v27 = atomic_load((unint64_t *)(v13 + 8));
              *(_DWORD *)buf = 134218752;
              uint64_t v53 = v13;
              __int16 v54 = 2048;
              unint64_t v55 = v2;
              __int16 v56 = 2048;
              unint64_t v57 = v9;
              __int16 v58 = 2048;
              unint64_t v59 = v27;
              _os_log_fault_impl( &dword_186681000,  v25,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
            }

            unint64_t v9 = atomic_load(v8);
            unint64_t v14 = v16;
            uint64_t v7 = v13;
            unint64_t v15 = v17;
            while (1)
            {
              unint64_t v26 = __ldaxr(v8);
              if (v26 != v9) {
                break;
              }
              if (!__stlxr(v2, v8)) {
                goto LABEL_13;
              }
            }
          }
        }
      }

      while (__stlxr(v2, v8));
LABEL_13:
      id v5 = v49;
      unint64_t StatusReg = (unint64_t)exception_object;
    }

    else
    {
      unint64_t v9 = 0LL;
    }

    *(void *)(StatusReg + 712) = v2;
  }

  v3[2](v3);
  if ((v4 & 1) != 0)
  {
    _Block_release(v3);
    CFRelease((CFTypeRef)v2);
    free(v1);
    int v1 = 0LL;
  }

  if ((v4 & 4) != 0) {
    [v5 drain];
  }
  if (v51 != v2)
  {
    *(void *)(StatusReg + 712) = v51;
    if (v7)
    {
      int v11 = (unint64_t *)(v7 + 8);
      while (1)
      {
        unint64_t v12 = __ldaxr(v11);
        if (v12 != v2) {
          break;
        }
        if (!__stlxr(v9, v11)) {
          goto LABEL_39;
        }
      }

      __clrex();
      uint64_t v28 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
      atomic_load((unint64_t *)(v7 + 8));
      _NSCoreDataLog(17LL, v28, v29, v30, v31, v32, v33, v34, v7);
      unint64_t v35 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        unint64_t v48 = atomic_load((unint64_t *)(v7 + 8));
        *(_DWORD *)buf = 134218752;
        uint64_t v53 = v7;
        __int16 v54 = 2048;
        unint64_t v55 = v9;
        __int16 v56 = 2048;
        unint64_t v57 = v2;
        __int16 v58 = 2048;
        unint64_t v59 = v48;
        _os_log_fault_impl( &dword_186681000,  v35,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
      }

      unint64_t v36 = atomic_load(v11);
      do
      {
        unint64_t v37 = __ldaxr(v11);
        if (v37 != v36)
        {
          while (1)
          {
            __clrex();
            uint64_t v38 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
            atomic_load((unint64_t *)(v7 + 8));
            _NSCoreDataLog(17LL, v38, v39, v40, v41, v42, v43, v44, v7);
            uint64_t v45 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              unint64_t v47 = atomic_load(v11);
              *(_DWORD *)buf = 134218752;
              uint64_t v53 = v7;
              __int16 v54 = 2048;
              unint64_t v55 = v9;
              __int16 v56 = 2048;
              unint64_t v57 = v36;
              __int16 v58 = 2048;
              unint64_t v59 = v47;
              _os_log_fault_impl( &dword_186681000,  v45,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
            }

            unint64_t v36 = atomic_load(v11);
            while (1)
            {
              unint64_t v46 = __ldaxr(v11);
              if (v46 != v36) {
                break;
              }
              if (!__stlxr(v9, v11)) {
                goto LABEL_39;
              }
            }
          }
        }
      }

      while (__stlxr(v9, v11));
    }
  }

LABEL_39:
  if ((v4 & 1) == 0)
  {
    if ((v4 & 0x2000) == 0) {
      return;
    }
LABEL_43:
    __dmb(0xBu);
    return;
  }

  free(v1);
  if ((v4 & 0x2000) != 0) {
    goto LABEL_43;
  }
}

  if ((a3 & 0x1000) == 0) {
    uint64_t v18 = self;
  }
  context = a4;
  unint64_t v27 = self;
  uint64_t v28 = a3 | 0x2000;
  uint64_t v29 = v7;
  dispatch_sync_f( (dispatch_queue_t)self->_dispatchQueue,  &context,  (dispatch_function_t)developerSubmittedBlockToNSManagedObjectContextPerform);
}

  v160 = v14 + 24;
  uint64_t v34 = v161[6];
  unint64_t v35 = v161[7];
  unint64_t v36 = v35 + v34;
  unint64_t v37 = *(unsigned int *)(a2 + 20);
  if ((_DWORD)v37) {
    uint64_t v38 = a2 + v37;
  }
  else {
    uint64_t v38 = 0LL;
  }
  uint64_t v39 = v38 - (((unint64_t)*(unsigned int *)(a2 + 16) >> 22) & 0x3FC);
  v155 = v12;
  if (v34 < v36)
  {
    uint64_t v40 = v36 - 1;
    uint64_t v41 = (int)v34 >> 3;
    uint64_t v42 = ((int)v36 - 1) >> 3;
    uint64_t v43 = 255 << (v34 & 7);
    if (v42 == (int)v34 >> 3)
    {
      uint64_t v44 = (0xFFu >> (~(_BYTE)v40 & 7)) & v43;
    }

    else
    {
      *(_BYTE *)(v39 + v41) |= v43;
      if (v41 + 1 < v42) {
        memset((void *)(v41 + v39 + 1), 255, (v42 - v41 - 2) + 1LL);
      }
      uint64_t v44 = 0xFFu >> (~(_BYTE)v40 & 7);
      uint64_t v41 = v40 >> 3;
    }

    *(_BYTE *)(v39 + v41) |= v44;
    LOBYTE(v12) = v155;
  }

  v158 = v32;
  if ((v12 & 1) == 0)
  {
    unint64_t v47 = v144;
    if (HasCustomPrimitiveProperties)
    {
      if ((v158 & 1) != 0)
      {
        if (v34 < v36)
        {
          do
          {
            if (v159) {
              unint64_t v48 = *(void **)(v159 + 8 * v34);
            }
            else {
              unint64_t v48 = (void *)[v156 valueForKey:*(void *)(v47 + 8 * v34)];
            }
            id v49 = *(void *)(v16 + 8 * v34);
            _PF_CopyOnWrite_Snapshot((id)a2);
            if (v49)
            {
              _NSSetUsingKeyValueSetter();
            }

            else
            {
              uint64_t v50 = v48;
              snapshot_set_value_as_object(*(char **)(a2 + 24), v34, v50, v51, v52, v53, v54, v55);
            }

            ++v34;
            --v35;
          }

          while (v35);
        }
      }

      else if (v34 < v36)
      {
        uint64_t v60 = (void *)(v144 + 8 * v34);
        uint64_t v61 = v159 + 8 * v34;
        uint64_t v62 = (void *)(v16 + 8 * v34);
        do
        {
          if (*v62)
          {
            if (!v159) {
              [v156 valueForKey:*v60];
            }
            _PF_CopyOnWrite_Snapshot((id)a2);
            _NSSetUsingKeyValueSetter();
          }

          ++v60;
          v61 += 8LL;
          ++v62;
          --v35;
        }

        while (v35);
      }
    }

    goto LABEL_88;
  }

  if (HasCustomPrimitiveProperties)
  {
    if ((v32 & 1) != 0)
    {
      if (v34 < v36)
      {
        do
        {
          uint64_t v45 = *(void **)(v160 + 8 * v34);
          if ([v45 _propertyType] == 7) {
            unint64_t v46 = (void *)[v45 _buildDefaultValue];
          }
          else {
            unint64_t v46 = (void *)[v45 defaultValue];
          }
          unint64_t v26 = (uint64_t)v46;
          if (v46) {
            _PF_Handler_Primitive_Internal_SetProperty((char **)a2, v34, v46, *(void *)(v16 + 8 * v34));
          }
          ++v34;
          --v35;
        }

        while (v35);
LABEL_88:
        __int16 v58 = v161[12];
        uint64_t v63 = v161[13];
        unint64_t v59 = v63 + v58;
        uint64_t v64 = v155;
        if (!v156) {
          uint64_t v64 = 1;
        }
        if ((v64 & 1) != 0) {
          goto LABEL_91;
        }
        uint64_t v70 = v153;
        uint64_t v71 = v158;
        if (v58 >= v59) {
          goto LABEL_138;
        }
        v156 = (id)NSKeyValueCoding_NullValue;
        uint64_t v72 = v59 - 1;
        uint64_t v73 = (int)v58 >> 3;
        v74 = v72 >> 3;
        unint64_t v75 = 0xFFu >> (8 - (v58 & 7));
        if (v72 >> 3 == (int)v58 >> 3)
        {
          unint64_t v76 = (510 << (v72 & 7)) | v75;
        }

        else
        {
          *(_BYTE *)(v39 + v73) &= v75;
          if (v73 + 1 < v74) {
            bzero((void *)(v73 + v39 + 1), (v74 - v73 - 2) + 1LL);
          }
          unint64_t v76 = 510 << (v72 & 7);
          uint64_t v73 = v72 >> 3;
        }

        *(_BYTE *)(v39 + v73) &= v76;
        if (!HasCustomPrimitiveProperties) {
          goto LABEL_138;
        }
        while (1)
        {
          uint64_t v83 = *(void *)(v16 + 8 * v58);
          if (v83) {
            v84 = 1;
          }
          else {
            v84 = v71;
          }
          if (v84 != 1) {
            goto LABEL_135;
          }
          unint64_t v85 = *(void *)(v160 + 8 * v58);
          if (!v159 || (unint64_t v86 = *(id *)(v159 + 8 * v58), v86 == v156))
          {
            -[NSManagedObjectContext lockObjectStore](v70);
            if (v70) {
              unint64_t v88 = *(void **)(v70 + 32);
            }
            else {
              unint64_t v88 = 0LL;
            }
            unint64_t v86 = (id)[v88 newValueForRelationship:v85 forObjectWithID:v146 withContext:v70 error:0];
            -[NSManagedObjectContext unlockObjectStore](v70);
            if (v86 == v156 || (unint64_t v87 = 1, !v86))
            {
LABEL_129:
              if (v147 == 5)
              {
                _PF_CopyOnWrite_Snapshot((id)a2);
                if (v83) {
                  _NSSetUsingKeyValueSetter();
                }
                else {
                  snapshot_set_value_as_object(*(char **)(a2 + 24), v58, 0LL, v89, v90, v91, v92, v93);
                }
              }

              goto LABEL_135;
            }
          }

          else
          {
            unint64_t v87 = 0;
            if (!v86) {
              goto LABEL_129;
            }
          }

          _PF_CopyOnWrite_Snapshot((id)a2);
          if (v83) {
            break;
          }
          __int16 v94 = v86;
          snapshot_set_value_as_object(*(char **)(a2 + 24), v58, v94, v95, v96, v97, v98, v99);
          if (v87) {
            goto LABEL_133;
          }
LABEL_135:
          ++v58;
          --v63;
          uint64_t v71 = v158;
          if (!v63) {
            goto LABEL_138;
          }
        }

        _NSSetUsingKeyValueSetter();
        if (!v87) {
          goto LABEL_135;
        }
LABEL_133:

        goto LABEL_135;
      }
    }

    else if (v34 < v36)
    {
      do
      {
        if (*(void *)(v16 + 8 * v34))
        {
          __int16 v56 = *(void **)(v160 + 8 * v34);
          unint64_t v57 = (void *)([v56 _propertyType] == 7
                       ? [v56 _buildDefaultValue]
                       : [v56 defaultValue]);
          unint64_t v26 = (uint64_t)v57;
          if (v57) {
            _PF_Handler_Primitive_Internal_SetProperty((char **)a2, v34, v57, *(void *)(v16 + 8 * v34));
          }
        }

        ++v34;
        --v35;
      }

      while (v35);
      goto LABEL_88;
    }
  }

  __int16 v58 = v161[12];
  unint64_t v59 = v161[13] + v58;
LABEL_91:
  if (v58 < v59)
  {
    v65 = v59 - 1;
    unint64_t v66 = (int)v58 >> 3;
    uint64_t v67 = 255 << (v58 & 7);
    if ((int)v58 >> 3 == ((int)v59 - 1) >> 3)
    {
      uint64_t v68 = (0xFFu >> (~(_BYTE)v65 & 7)) & v67;
      uint64_t v69 = v147;
    }

    else
    {
      *(_BYTE *)(v39 + v66) |= v67;
      uint64_t v69 = v147;
      if (v66 + 1 < v65 >> 3) {
        memset((void *)(v66 + v39 + 1), 255, ((v65 >> 3) - v66 - 2) + 1LL);
      }
      uint64_t v68 = 0xFFu >> (~(_BYTE)v65 & 7);
      unint64_t v66 = v65 >> 3;
    }

    *(_BYTE *)(v39 + v66) |= v68;
    if (v69 == 5)
    {
      do
      {
        uint64_t v77 = *(void *)(v16 + 8 * v58);
        _PF_CopyOnWrite_Snapshot((id)a2);
        if (v77) {
          _NSSetUsingKeyValueSetter();
        }
        else {
          snapshot_set_value_as_object(*(char **)(a2 + 24), v58, 0LL, v78, v79, v80, v81, v82);
        }
        ++v58;
      }

      while (v59 != v58);
    }
  }

  uint64_t v52 = (v15 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v53 = v52 + 4;
  if (v52 + 4 <= a4)
  {
    __int16 v54 = *(_DWORD *)(a2 + v52);
    v142 = v53;
    if (v54)
    {
      unint64_t v55 = v20;
      v134 = *(void *)(a10 + 8LL * bswap32(v54));
      callBacks.version = 0LL;
      __int16 v56 = (void *)MEMORY[0x189604010];
      unint64_t v57 = objc_opt_class();
      v131 = objc_opt_class();
      __int16 v58 = (void *)+[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)_PFRoutines,  [v56 setWithObjects:v57],  v134,  (uint64_t)&callBacks);
      if (!v58) {
        goto LABEL_123;
      }
      uint64_t v20 = v55;
      *(void *)(v55 + 24) = v58;
    }
  }

  v65 = *(void **)(v20 + 32);
  if (!v65)
  {
    v65 = PF_CALLOC_OBJECT_ARRAY(3LL);
    *(void *)(v20 + 32) = v65;
  }

  unint64_t v66 = (v142 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v67 = v66 + 8;
  if (v66 + 8 <= a4)
  {
    uint64_t v68 = bswap64(*(void *)(a2 + v66));
    v142 = v67;
  }

  else
  {
    uint64_t v68 = 0LL;
  }

  os_log_s *v65 = v68;
  uint64_t v69 = v142;
  uint64_t v70 = (v142 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v71 = v70 + 4;
  if (v70 + 4 <= a4)
  {
    uint64_t v72 = *(_DWORD *)(a2 + v70);
    v142 = v70 + 4;
    if (v72)
    {
      uint64_t v73 = bswap32(v72);
      v74 = (void **)(a2 + ((v70 + 11) & 0xFFFFFFFFFFFFFFF8LL));
      unint64_t v75 = v73;
      do
      {
        unint64_t v76 = (v71 + 7) & 0xFFFFFFFFFFFFFFF8LL;
        uint64_t v77 = v76 + 8;
        if (v76 + 8 <= a4)
        {
          uint64_t v78 = *(void *)(a2 + v76);
          v142 = v77;
          uint64_t v71 = v77;
          if (v78) {
            goto LABEL_77;
          }
        }

        --v75;
      }

      while (v75);
      v135 = v20;
      v137 = v74;
      uint64_t v79 = v74;
      uint64_t v80 = v73;
      while (1)
      {
        uint64_t v81 = (v142 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v82 = v81 + 4;
        if (v81 + 4 > a4) {
          goto LABEL_60;
        }
        uint64_t v83 = bswap32(*(_DWORD *)(a2 + v81));
        v142 = v81 + 4;
        if (v83 == 2)
        {
          unint64_t v86 = (v81 + 7) & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v87 = v86 + 4;
          if (v86 + 4 <= a4)
          {
            unint64_t v88 = bswap32(*(_DWORD *)(a2 + v86));
            v142 = v87;
          }

          else
          {
            unint64_t v88 = 0;
          }

          unint64_t v85 = *(void **)(a7 + 8LL * v88);
          goto LABEL_64;
        }

        if (v83 == 1) {
          break;
        }
        if (!v83)
        {
          uint64_t v81 = (v81 + 7) & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v82 = v81 + 4;
LABEL_60:
          if (v82 <= a4)
          {
            v84 = bswap32(*(_DWORD *)(a2 + v81));
            v142 = v82;
          }

          else
          {
            v84 = 0;
          }

          unint64_t v85 = _newReadPropertyProxyFromBytes(a1, a2, &v142, a4, *(void *)(a11 + 8LL * v84), a7);
LABEL_64:
          *uint64_t v79 = v85;
          goto LABEL_65;
        }

        if (a14)
        {
          unint64_t v26 = (void *)MEMORY[0x189607870];
          unint64_t v27 = *MEMORY[0x189607460];
          uint64_t v28 = (void *)MEMORY[0x189603F68];
          uint64_t v29 = @"Invalid propertyToFetch type in archive";
          goto LABEL_122;
        }

    if (-[NSMutableSet count](self->_insertedObjects, "count"))
    {
      if (hasEntityWithUniqueness) {
        goto LABEL_46;
      }
    }

    else
    {
      if (-[NSMutableSet count](self->_changedObjects, "count")) {
        unint64_t v25 = hasEntityWithUniqueness;
      }
      else {
        unint64_t v25 = 0;
      }
      if ((v25 & 1) != 0)
      {
LABEL_46:
        unint64_t v26 = (void *)[objc_alloc(MEMORY[0x189603FE0]) initWithSet:self->_insertedObjects];
        [v26 unionSet:self->_changedObjects];
        unint64_t v27 = (void *)[v26 allObjects];

        if ((*((_BYTE *)&self->_flags + 3) & 1) == 0)
        {
          uint64_t v28 = (id)*((void *)self->_additionalPrivateIvars + 9);
          if (!v28)
          {
            uint64_t v28 = -[NSConstraintValidator initWithManagedObjectContext:]( objc_alloc(&OBJC_CLASS___NSConstraintValidator),  self);
            *((void *)self->_additionalPrivateIvars + 9) = v28;
          }

          -[NSConstraintValidator registerObjects:]((uint64_t)v28, v27);
          uint64_t v29 = (void *)-[NSConstraintValidator validateForSave]((uint64_t)v28);
          -[NSConstraintValidator reset]((uint64_t)v28);
          if (v29)
          {
            uint64_t v41 = (void *)-[NSManagedObjectContext _generateOptLockExceptionForConstraintFailure:]((uint64_t)self, v29);
            objc_exception_throw(v41);
            __break(1u);
            return result;
          }
        }
      }
    }

    unint64_t v16 = 1;
    if ([self->_parentObjectStore executeRequest:v56 withContext:self error:&v63])
    {
      parentObjectStore = self->_parentObjectStore;
      uint64_t v31 = (void *)-[NSMutableSet allObjects](self->_insertedObjects, "allObjects");
      if ([v31 count])
      {
        uint64_t v32 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FA8]), "initWithCapacity:", objc_msgSend(v31, "count"));
        uint64_t v33 = [v31 count];
        if (v33)
        {
          for (j = 0LL; j != v33; ++j)
          {
            unint64_t v35 = (_DWORD *)[v31 objectAtIndex:j];
            unint64_t v36 = (void *)[v35 objectID];
            if (([v36 isTemporaryID] & 1) == 0)
            {
              [v32 addObject:v36];
              if (v35) {
                v35[4] |= 0x200u;
              }
            }
          }
        }

        objc_msgSend( parentObjectStore,  "managedObjectContextDidRegisterObjectsWithIDs:generation:",  v32,  -[NSManagedObjectContext _queryGenerationToken](self, "_queryGenerationToken"));
      }

      -[NSManagedObjectContext unlockObjectStore]((uint64_t)self);
      unint64_t v16 = 0;
      unint64_t v37 = 0;
      unint64_t v57 = 0;
    }

    else
    {
      unint64_t v37 = 1;
    }

    uint64_t v38 = v63;
    [v17 drain];
    uint64_t v39 = 0LL;
    uint64_t v40 = v63;
    if ((v37 | 8) == 8) {
      unint64_t v37 = 0;
    }
    if (v37) {
      goto LABEL_69;
    }
  }

  unint64_t v37 = 0;
LABEL_69:
  uint64_t v44 = v57;
  uint64_t v43 = 1;
LABEL_70:
  uint64_t v45 = v63;

  [v54 drain];
  if (v63)
  {
    unint64_t v46 = v63;
    if (v55) {
      os_log_s *v55 = (NSError *)v63;
    }
  }

  if (v44) {
    -[NSManagedObjectContext unlockObjectStore]((uint64_t)self);
  }
  unint64_t v47 = self->_flags;
  self->_flags = (_managedObjectContextFlags)(*(_DWORD *)&v47 & 0xFDFF7F77);
  if (v43) {
    --self->_ignoreChangeNotification;
  }
  self->_flags = (_managedObjectContextFlags)(*(_DWORD *)&v47 & 0xFDFF7F73 | v53 & 4);
  uint64_t v8 = v37 == 0;
  if (!v37)
  {
    unint64_t v48 = v63;
    id v49 = objc_alloc_init(MEMORY[0x1896077E8]);
    -[NSManagedObjectContext _didSaveChanges]((uint64_t)self);
    if ((*((_BYTE *)&self->_flags + 3) & 4) != 0) {
      -[NSManagedObjectContext refreshAllObjects](self, "refreshAllObjects");
    }
    [v49 drain];
    -[NSManagedObjectContext _processReferenceQueue:]((uint64_t)self, 0);
    uint64_t v50 = v63;
    uint64_t v51 = (NSQueryGenerationToken *)*((void *)self->_additionalPrivateIvars + 12);
    if (-[NSQueryGenerationToken _isEnabled](v51, "_isEnabled")
      && v51 != +[NSQueryGenerationToken currentQueryGenerationToken]( &OBJC_CLASS___NSQueryGenerationToken,  "currentQueryGenerationToken"))
    {
      uint64_t v52 = v51;
      v58[0] = MEMORY[0x1895F87A8];
      v58[1] = 3221225472LL;
      v58[2] = __31__NSManagedObjectContext_save___block_invoke;
      v58[3] = &unk_189EA7648;
      v58[4] = self;
      v58[5] = v51;
      +[_PFAutoreleasePoolThunk thunkWithBlock:]((uint64_t)&OBJC_CLASS____PFAutoreleasePoolThunk, v58);
    }

    if (self->_dispatchQueue) {
      -[NSManagedObjectContext _registerAsyncReferenceCallback]((uint64_t)self);
    }
  }

  return v8;
}

  if (!v35)
  {
    if (v68)
    {
      if (a5) {
        *a5 = v68;
      }
    }

    else
    {
      uint64_t v43 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitStoreComparer.m");
      uint64_t v50 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        v74 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitStoreComparer.m";
        unint64_t v75 = 1024;
        LODWORD(v76) = 403;
        _os_log_fault_impl( &dword_186681000,  v50,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }
  }

  return v35;
}

void sub_186687104( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *exc_buf)
{
  if (a2)
  {
    objc_end_catch();
    objc_begin_catch(a1);
    JUMPOUT(0x186686B70LL);
  }

  _Unwind_Resume(v16);
}

void sub_186687124(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18668712CLL);
  }
  objc_terminate();
  __55__NSPersistentStoreCoordinator__routeHeavyweightBlock___block_invoke(v2);
}

void sub_1866871EC(_Unwind_Exception *a1)
{
}

void sub_18668720C()
{
}

LABEL_131:
              uint64_t v21 = 0LL;
              uint64_t v32 = 0LL;
LABEL_194:
              int v6 = 8LL;
              goto LABEL_200;
            }

            goto LABEL_41;
          }

          exceptiona = (id)[a3 resultType];
          unint64_t v85 = objc_msgSend(v84, "objectForKey:", -[NSSQLCore identifier](self, "identifier"));
          unint64_t v86 = [a3 fetchLimit];
          exception_object = (_Unwind_Exception *)[a3 fetchBatchSize];
          uint64_t v83 =  -[NSPersistentHistoryChangeRequest initWithTransactionID:delete:transactionOnly:percentageOfDB:]( [NSPersistentHistoryChangeRequest alloc],  "initWithTransactionID:delete:transactionOnly:percentageOfDB:",  v85,  [a3 isDelete],  objc_msgSend(a3, "isFetchTransactionForToken"),  objc_msgSend(a3, "percentageOfDB"));
          -[NSPersistentHistoryChangeRequest setResultType:](v83, "setResultType:", exceptiona);
          -[NSPersistentHistoryChangeRequest setFetchLimit:](v83, "setFetchLimit:", v86);
          -[NSPersistentHistoryChangeRequest setFetchBatchSize:](v83, "setFetchBatchSize:", exception_object);
          -[NSPersistentStoreRequest setAffectedStores:](v83, "setAffectedStores:", [a3 affectedStores]);
          -[NSPersistentHistoryChangeRequest setFetchRequest:]( v83,  "setFetchRequest:",  [a3 fetchRequest]);
        }

        unint64_t v87 = -[NSSQLPersistentHistoryChangeRequestContext initWithRequest:context:sqlCore:]( objc_alloc(&OBJC_CLASS___NSSQLPersistentHistoryChangeRequestContext),  "initWithRequest:context:sqlCore:",  v83,  a4,  self);
        -[NSSQLCore dispatchRequest:withRetries:]((uint64_t)self, v87, 0LL);
        unint64_t v88 = -[NSSQLStoreRequestContext result](v87, "result");
        if (v87) {
          v89 = v87->super._exception;
        }
        else {
          v89 = 0LL;
        }
        uint64_t v18 = v89;
        if (v87) {
          v90 = v87->super._error;
        }
        else {
          v90 = 0LL;
        }
        uint64_t v91 = v90;

        if (v88)
        {
          uint64_t v21 = 0LL;
        }

        else
        {
          if (v18)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
LABEL_240:
              v163 = v18;
              objc_exception_throw(v18);
              goto LABEL_248;
            }

            v125 = (NSError *)-[NSException errorObjectWithUserInfo:](v18, "errorObjectWithUserInfo:", 0LL);
          }

          else
          {
            v125 = v91;
          }

          uint64_t v21 = v125;
        }

        v157 = (NSSQLiteIndexStatisticsResult *)v88;
        uint64_t v32 = (NSPersistentCloudKitContainerEventResult *)v157;
        if (!v21) {
          goto LABEL_194;
        }
        uint64_t v22 = v157;
LABEL_188:
        if (-[NSError code](v21, "code") == 134091
          || -[NSError code](v21, "code") == 134501
          || -[NSError code](v21, "code") == 134301)
        {
          uint64_t v7 = 0;
        }

        int v6 = 8LL;
LABEL_193:
        uint64_t v32 = (NSPersistentCloudKitContainerEventResult *)v22;
        goto LABEL_200;
      case 9LL:
        if (self)
        {
          v173 = 0LL;
          uint64_t v50 = (NSPersistentStoreResult *)-[NSPersistentStore mirroringDelegate](self, "mirroringDelegate");
          uint64_t v51 = v50;
          if (v50) {
            uint64_t v52 = -[NSCloudKitMirroringDelegate executeMirroringRequest:error:](v50, a3, (uint64_t *)&v173);
          }
          else {
            uint64_t v52 = objc_alloc_init(&OBJC_CLASS___NSPersistentStoreResult);
          }
          uint64_t v32 = (NSPersistentCloudKitContainerEventResult *)v52;

          if (v32) {
            goto LABEL_117;
          }
          uint64_t v21 = v173;
          if (!v173)
          {
            v126 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
            _NSCoreDataLog( 17LL,  v126,  v127,  v128,  v129,  v130,  v131,  v132,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLCore.m");
            v133 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136315394;
              v184 = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLCore.m";
              v185 = 1024;
              v186 = 5076;
              _os_log_fault_impl( &dword_186681000,  v133,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
            }

      if (-[NSSQLIntermediate _functionExpressionIsSubqueryFollowedByKeypath:]((BOOL)self, v26))
      {
LABEL_132:
        unint64_t v76 = (__CFString *)-[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:]( self,  v24,  v23 == 2,  a3);
        unint64_t v9 = v76;
        if (v76)
        {
          -[__CFString appendString:](v76, "appendString:", @" IN ");
          uint64_t v77 = self;
          uint64_t v78 = v26;
          uint64_t v79 = 1LL;
          goto LABEL_134;
        }

            goto LABEL_140;
          }

          v137 = (void *)objc_msgSend( (id)-[__CFString userInfo](v230, "userInfo"),  "valueForKey:",  @"conflictList");
          v138 = -[NSGenerationalRowCache rowCacheForGeneration:]((uint64_t)self->_cache, 0LL);
          v225 = 0u;
          v226 = 0u;
          v223 = 0u;
          v224 = 0u;
          uint64_t v13 = (NSBatchInsertResult *)[v137 countByEnumeratingWithState:&v223 objects:buf count:16];
          if (v13)
          {
            v139 = *(void *)v224;
            do
            {
              for (i = 0LL; i != v13; i = (NSBatchInsertResult *)((char *)i + 1))
              {
                if (*(void *)v224 != v139) {
                  objc_enumerationMutation(v137);
                }
                -[NSPersistentStoreCache forgetRowForObjectID:]( (uint64_t)v138,  (const void *)objc_msgSend( (id)objc_msgSend(*(id *)(*((void *)&v223 + 1) + 8 * (void)i), "sourceObject"),  "objectID"));
              }

              uint64_t v13 = (NSBatchInsertResult *)[v137 countByEnumeratingWithState:&v223 objects:buf count:16];
            }

            while (v13);
          }
        }

        LOBYTE(v51) = 0;
        goto LABEL_128;
      case 5LL:
        if (!self) {
          goto LABEL_139;
        }
        *(void *)&v223 = 0LL;
        -[NSBatchInsertRequest _resolveEntityWithSQLCore:]((uint64_t)a3, self);
        uint64_t v62 = (void *)[a3 encodeForXPC];
        uint64_t v63 = objc_alloc_init(&OBJC_CLASS___NSCoreDataXPCMessage);
        v65 = v63;
        if (v63)
        {
          v63->_messageCode = 16LL;
          objc_setProperty_nonatomic(v63, v64, v62, 24LL);
        }

        unint64_t v66 = -[NSXPCStore sendMessage:fromContext:interrupts:error:]((uint64_t *)self, v65, a4, &v230, &v223);
        if (v66)
        {
          uint64_t v67 = (void *)MEMORY[0x189604010];
          uint64_t v68 = objc_opt_class();
          uint64_t v69 = objc_opt_class();
          uint64_t v70 = objc_opt_class();
          uint64_t v71 = objc_msgSend(v67, "setWithObjects:", v68, v69, v70, objc_opt_class(), 0);
          uint64_t v72 = +[_NSXPCStoreUtilities decodeSecureArchivedData:usingDelegate:classes:]( (uint64_t)&OBJC_CLASS____NSXPCStoreUtilities,  (uint64_t)v66,  (uint64_t)self,  v71);
          if (v72)
          {
            unint64_t v46 = -[NSBatchInsertResult initWithResultType:andObject:]( [NSBatchInsertResult alloc],  "initWithResultType:andObject:",  [a3 resultType],  v72);
            goto LABEL_136;
          }

          v113 = (void *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:&unk_189F022D0];
          *(void *)&v223 = v113;
          if (v113)
          {
LABEL_101:
            if (a5)
            {
              unint64_t v46 = 0LL;
              *a5 = v113;
              goto LABEL_136;
            }

  uint64_t v70 = v201;
LABEL_132:
  v167 = v70;
  [v147 drain];
  if (v2)
  {
    if (*(void *)(v2 + 40))
    {

      goto LABEL_135;
    }

    v148 = objc_alloc_init(MEMORY[0x1896077E8]);
    v161 = *(void *)(v2 + 24);
    v183 = *(void **)(v2 + 32);
    v189 = [*(id *)(v2 + 8) model];
    v170 = *(void **)(v2 + 8);
  }

  else
  {
    v148 = objc_alloc_init(MEMORY[0x1896077E8]);
    v189 = 0LL;
    v161 = 0LL;
    v183 = 0LL;
    v170 = 0LL;
  }

  v185 = (void *)[MEMORY[0x189603FA8] array];
  v225 = 0u;
  v226 = 0u;
  v227 = 0u;
  v228 = 0u;
  v157 = [obj countByEnumeratingWithState:&v225 objects:v246 count:16];
  if (!v157) {
    goto LABEL_250;
  }
  v152 = *(void *)v226;
  do
  {
    v155 = 0LL;
    do
    {
      if (*(void *)v226 != v152) {
        objc_enumerationMutation(obj);
      }
      v174 = *(id *)(*((void *)&v225 + 1) + 8 * v155);
      v150 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v73 = objc_msgSend((id)objc_msgSend(v174, "lastObject"), "entity");
      if (v73)
      {
        if ((*(_BYTE *)(v73 + 120) & 4) != 0)
        {
          v74 = *(void **)(v73 + 72);
        }

        else
        {
          do
          {
            v74 = (void *)v73;
            uint64_t v73 = [(id)v73 superentity];
          }

          while (v73);
        }
      }

      else
      {
        v74 = 0LL;
      }

      v196 = (void *)_sqlCoreLookupSQLEntityForEntityDescription(v170, v74);
      v194 = objc_msgSend((id)objc_msgSend(v74, "subentities"), "count");
      if (v196) {
        unint64_t v75 = (void *)v196[27];
      }
      else {
        unint64_t v75 = 0LL;
      }
      v223 = 0u;
      v224 = 0u;
      v221 = 0u;
      v222 = 0u;
      v159 = v75;
      v169 = (id)[v75 countByEnumeratingWithState:&v221 objects:v245 count:16];
      if (v169)
      {
        v165 = *(void *)v222;
        do
        {
          unint64_t v76 = 0LL;
          do
          {
            if (*(void *)v222 != v165)
            {
              uint64_t v77 = v76;
              objc_enumerationMutation(v159);
              unint64_t v76 = v77;
            }

            v172 = v76;
            v204 = *(id *)(*((void *)&v221 + 1) + 8 * v76);
            uint64_t v78 = objc_alloc_init(MEMORY[0x1896077E8]);
            uint64_t v79 = +[NSSQLiteAdapter generateStatementForCheckingMulticolumnConstraint:onObjects:usingSQLCore:]( (uint64_t)&OBJC_CLASS___NSSQLiteAdapter,  v204,  v174,  v170);
            uint64_t v80 = v79;
            [v78 drain];
            uint64_t v81 = v79;
            if (!v79) {
              goto LABEL_240;
            }
            v163 = objc_alloc_init(MEMORY[0x1896077E8]);
            uint64_t v82 = [v204 count];
            v187 = [v204 valueForKey:@"name"];
            uint64_t v83 = objc_alloc_init(MEMORY[0x189603FA8]);
            v84 = v83;
            if (!v196)
            {
              [v83 addObject:0];
              if (!v194) {
                goto LABEL_160;
              }
              unint64_t v85 = 0LL;
              goto LABEL_159;
            }

            [v83 addObject:v196[16]];
            if (v194)
            {
              unint64_t v85 = v196[17];
LABEL_159:
              [v84 addObject:v85];
            }

LABEL_117:
            uint64_t v21 = 0LL;
          }

          uint64_t v7 = 0;
          goto LABEL_129;
        }

        uint64_t v21 = 0LL;
        uint64_t v7 = 0;
        uint64_t v32 = 0LL;
LABEL_129:
        int v6 = 9LL;
LABEL_200:
        v159 = v172;
        if (v21) {
          v160 = v172 == 0LL;
        }
        else {
          v160 = 0;
        }
        if (v160) {
          v159 = v21;
        }
        v172 = v159;
        if (v32) {
          return v32;
        }
        break;
      case 10LL:
        if (self)
        {
          if ((*((_BYTE *)&self->_sqlCoreFlags + 2) & 1) == 0)
          {
            uint64_t v22 = 0LL;
            uint64_t v21 = (NSError *)[MEMORY[0x189607870] errorWithDomain:v169 code:134091 userInfo:&unk_189F03D88];
            goto LABEL_141;
          }

          unint64_t v75 = (void *)objc_msgSend( -[NSDictionary objectForKeyedSubscript:]( self->_ancillaryModels,  "objectForKeyedSubscript:",  @"NSPersistentStoreTrackIndexUseOptionKey"),  "entitiesByName");
          unint64_t v76 = (objc_class *)objc_opt_class();
          uint64_t v77 = [v75 objectForKeyedSubscript:NSStringFromClass(v76)];
          uint64_t v78 = objc_alloc_init(&OBJC_CLASS___NSFetchRequest);
          -[NSFetchRequest setEntity:](v78, "setEntity:", v77);
          -[NSFetchRequest setResultType:](v78, "setResultType:", 2LL);
          uint64_t v79 = -[NSSQLFetchRequestContext initWithRequest:context:sqlCore:]( objc_alloc(&OBJC_CLASS___NSSQLFetchRequestContext),  "initWithRequest:context:sqlCore:",  v78,  a4,  self);
          -[NSSQLCore dispatchRequest:withRetries:]((uint64_t)self, v79, 0LL);
          uint64_t v80 = -[NSSQLStoreRequestContext result](v79, "result");
          if (v79) {
            uint64_t v81 = v79->super._exception;
          }
          else {
            uint64_t v81 = 0LL;
          }
          uint64_t v82 = v81;

          if (v80)
          {
            if (![v80 count])
            {
              uint64_t v21 = 0LL;
              uint64_t v22 = (NSSQLiteIndexStatisticsResult *)NSArray_EmptyArray;
              goto LABEL_141;
            }
          }

          else if (v82)
          {
            objc_exception_throw(v82);
            goto LABEL_248;
          }

          v112 = objc_alloc_init(MEMORY[0x189603FA8]);
          v176 = 0u;
          v177 = 0u;
          v174 = 0u;
          v175 = 0u;
          v113 = [v80 countByEnumeratingWithState:&v174 objects:v182 count:16];
          if (v113)
          {
            v114 = *(void *)v175;
            do
            {
              for (i = 0LL; i != v113; ++i)
              {
                if (*(void *)v175 != v114) {
                  objc_enumerationMutation(v80);
                }
                objc_msgSend( v112,  "addObject:",   -[NSSQLiteIndexStatistics initWithResultDictionary:storeID:]( [NSSQLiteIndexStatistics alloc],  "initWithResultDictionary:storeID:",  *(void *)(*((void *)&v174 + 1) + 8 * i),  -[NSSQLCore identifier](self, "identifier")));
              }

              v113 = [v80 countByEnumeratingWithState:&v174 objects:v182 count:16];
            }

            while (v113);
          }

          v116 =  -[NSSQLiteIndexStatisticsResult initWithResult:]( objc_alloc(&OBJC_CLASS___NSSQLiteIndexStatisticsResult),  "initWithResult:",  v112);
          uint64_t v21 = 0LL;
          uint64_t v22 = v116;
        }

        else
        {
          uint64_t v21 = 0LL;
          uint64_t v22 = 0LL;
        }

    v103 = *(int *)(a2 + 28);
    if ((_DWORD)v103 != -1)
    {
      v104 = *(void *)(*(void *)(a2 + 64) + 8 * v103);
      if (v104)
      {
        v105 = *(void *)(a2 + 32);
        v106 = v104 + *(void *)(a2 + 40);
        *(_DWORD *)(v106 + 4) = *(_DWORD *)(a2 + 24);
        *(void *)(v106 + 16) = v105;
      }
    }

    ++*(_DWORD *)(v4 + 88);
    unint64_t v9 = (v9 + 1);
    _execute(v4);
    unint64_t v10 = v118 + 1;
    LOBYTE(v8) = v113;
    if (v118 + 1 == v115) {
      break;
    }
  }

  else {
    uint64_t result = 0LL;
  }
LABEL_127:
  *(_DWORD *)(a2 + 4) = result;
  if ((*(_BYTE *)(v4 + 312) & 2) == 0) {
    *(_DWORD *)(a2 + 48) |= 1u;
  }
  return result;
}

      objc_autoreleasePoolPop(context);
      uint64_t v63 = v230 + 1;
    }

    while (v230 + 1 != v226);
    uint64_t v62 = [v221 countByEnumeratingWithState:&v274 objects:v298 count:16];
  }

  while (v62);
  if ((v223 & 1) == 0)
  {
    v121 = v287;
    v122 = v287;
    if (v287)
    {
      v123 = a4;
      if (a4)
      {
        v231 = 0LL;
        objb = 0LL;
        goto LABEL_160;
      }
    }

    else
    {
      v197 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v197,  v198,  v199,  v200,  v201,  v202,  v203,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitImportZoneContext.m");
      v204 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        v289 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitImportZoneContext.m";
        v290 = 1024;
        v291 = 448;
        _os_log_fault_impl( &dword_186681000,  v204,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }

    v231 = 0LL;
    objb = 0LL;
    goto LABEL_207;
  }

  if (v60) {
    sqlite3_close_v2(v60);
  }
  uint64_t v70 = (void *)[a3 objectForKey:@"NSPersistentStoreUnlinkDestroyOption"];
  if (v70) {
    LODWORD(v70) = [v70 BOOLValue];
  }
  uint64_t v71 = v102;
  unint64_t v9 = v55 == 0;
  if (v55) {
    uint64_t v72 = v59;
  }
  else {
    uint64_t v72 = 1;
  }
  if ((v15 | v70) != 1 || !v72)
  {
    if (!v55) {
      return v9;
    }
    unint64_t v76 = (void *)MEMORY[0x189607870];
    uint64_t v77 = @"NSSQLiteErrorDomain";
    uint64_t v78 = v55;
    uint64_t v79 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Failed to truncate database",  @"reason",  v61,  *MEMORY[0x1896074F8],  0);
    uint64_t v80 = v76;
    goto LABEL_157;
  }

  if ((unlink(v8) & 0x80000000) == 0)
  {
    uint64_t v73 = 0;
    v74 = 0LL;
    unint64_t v75 = v100;
    goto LABEL_135;
  }

  unint64_t v75 = v100;
  if (*__error() == 2)
  {
    uint64_t v73 = 0;
  }

  else
  {
    uint64_t v73 = *__error();
    if (v73)
    {
      v74 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607688],  v73,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjectsAndKeys:", v46, *MEMORY[0x1896074F8], 0));
      goto LABEL_135;
    }
  }

  v74 = 0LL;
LABEL_135:
  if ((unlink(v75) & 0x80000000) == 0)
  {
    if (!v73) {
      goto LABEL_141;
    }
LABEL_137:
    if (!v74)
    {
      uint64_t v81 = (void *)MEMORY[0x189607870];
      uint64_t v82 = *MEMORY[0x189607688];
      uint64_t v83 = (void *)MEMORY[0x189603F68];
      v84 = [NSString stringWithUTF8String:v75];
      unint64_t v85 = v83;
      uint64_t v71 = v102;
      v74 = objc_msgSend( v81,  "errorWithDomain:code:userInfo:",  v82,  v73,  objc_msgSend(v85, "dictionaryWithObjectsAndKeys:", v84, *MEMORY[0x1896074F8], 0));
    }

    goto LABEL_141;
  }

  if (*__error() == 2)
  {
    uint64_t v73 = 0;
    goto LABEL_141;
  }

  uint64_t v73 = *__error();
  if (v73) {
    goto LABEL_137;
  }
LABEL_141:
  if ((unlink(v101) & 0x80000000) == 0)
  {
    if (!v73) {
      goto LABEL_147;
    }
LABEL_143:
    if (!v74)
    {
      unint64_t v86 = (void *)MEMORY[0x189607870];
      unint64_t v87 = *MEMORY[0x189607688];
      unint64_t v88 = (void *)MEMORY[0x189603F68];
      v89 = [NSString stringWithUTF8String:v101];
      v74 = objc_msgSend( v86,  "errorWithDomain:code:userInfo:",  v87,  v73,  objc_msgSend(v88, "dictionaryWithObjectsAndKeys:", v89, *MEMORY[0x1896074F8], 0));
    }

    goto LABEL_147;
  }

  if (*__error() == 2)
  {
    uint64_t v73 = 0;
    goto LABEL_147;
  }

  uint64_t v73 = *__error();
  if (v73) {
    goto LABEL_143;
  }
LABEL_147:
  v90 = (const char *)objc_msgSend( (id)objc_msgSend(v46, "stringByAppendingString:", @"-shm"),  "fileSystemRepresentation");
  if ((unlink(v90) & 0x80000000) == 0)
  {
    if (!v73) {
      goto LABEL_153;
    }
LABEL_149:
    if (!v74)
    {
      uint64_t v91 = (void *)MEMORY[0x189607870];
      v92 = *MEMORY[0x189607688];
      uint64_t v93 = (void *)MEMORY[0x189603F68];
      __int16 v94 = [NSString stringWithUTF8String:v90];
      v74 = objc_msgSend( v91,  "errorWithDomain:code:userInfo:",  v92,  v73,  objc_msgSend(v93, "dictionaryWithObjectsAndKeys:", v94, *MEMORY[0x1896074F8], 0));
    }

    goto LABEL_153;
  }

  if (*__error() == 2)
  {
    uint64_t v73 = 0;
    goto LABEL_153;
  }

  uint64_t v73 = *__error();
  if (v73) {
    goto LABEL_149;
  }
LABEL_153:
  unint64_t v95 = (const char *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v46, "stringByDeletingLastPathComponent"),  "stringByAppendingPathComponent:",  objc_msgSend( (id)objc_msgSend( @".",  "stringByAppendingString:",  objc_msgSend(v103, "lastPathComponent")),  "stringByAppendingString:",  @"-conch")),  "fileSystemRepresentation");
  if (unlink(v95) < 0)
  {
    if (*__error() == 2) {
      goto LABEL_158;
    }
    uint64_t v73 = *__error();
    if (!v73) {
      goto LABEL_158;
    }
  }

  else if (!v73)
  {
    goto LABEL_158;
  }

  if (!v74)
  {
    __int16 v96 = (void *)MEMORY[0x189607870];
    uint64_t v77 = (const __CFString *)*MEMORY[0x189607688];
    uint64_t v78 = v73;
    unint64_t v97 = (void *)MEMORY[0x189603F68];
    __int16 v98 = [NSString stringWithUTF8String:v95];
    uint64_t v79 = objc_msgSend(v97, "dictionaryWithObjectsAndKeys:", v98, *MEMORY[0x1896074F8], 0);
    uint64_t v80 = v96;
LABEL_157:
    v74 = [v80 errorWithDomain:v77 code:v78 userInfo:v79];
  }

LABEL_141:
        int v6 = 10LL;
        goto LABEL_193;
      case 11LL:
        if (self)
        {
          uint64_t v53 = [a3 resultType];
          __int16 v54 = -[NSPersistentStore mirroringDelegate](self, "mirroringDelegate");
          if (v54
            && v54[144]
            && (v55 = (void *)objc_msgSend( -[NSDictionary objectForKeyedSubscript:]( self->_ancillaryModels,  "objectForKeyedSubscript:",  @"NSPersistentStoreMirroringDelegateOptionKey"),  "entitiesByName"),  __int16 v56 = (objc_class *)objc_opt_class(),  (v57 = objc_msgSend(v55, "objectForKeyedSubscript:", NSStringFromClass(v56))) != 0))
          {
            if (a3)
            {
              [*((id *)a3 + 3) setEntity:v57];
              [*((id *)a3 + 3) setReturnsObjectsAsFaults:0];
              __int16 v58 = (void *)*((void *)a3 + 3);
            }

            else
            {
              [0 setEntity:v57];
              [0 setReturnsObjectsAsFaults:0];
              __int16 v58 = 0LL;
            }

            [v58 setResultType:4 * (v53 == 1)];
            unint64_t v59 = off_189EA5560;
            if (v53 != 1) {
              unint64_t v59 = off_189EA5580;
            }
            uint64_t v60 = objc_alloc(*v59);
            if (a3) {
              uint64_t v61 = *((void *)a3 + 3);
            }
            else {
              uint64_t v61 = 0LL;
            }
            uint64_t v62 = (void *)[v60 initWithRequest:v61 context:a4 sqlCore:self];
            -[NSSQLCore dispatchRequest:withRetries:]((uint64_t)self, v62, 0LL);
            uint64_t v63 = (id)[v62 result];
            if (v62) {
              uint64_t v64 = (void *)v62[6];
            }
            else {
              uint64_t v64 = 0LL;
            }
            uint64_t v13 = v64;

            if (!v63 && v13)
            {
LABEL_228:
              objc_exception_throw(v13);
LABEL_248:
              __break(1u);
              JUMPOUT(0x186689540LL);
            }

            if (!v63)
            {
              v117 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
              _NSCoreDataLog( 17LL,  v117,  v118,  v119,  v120,  v121,  v122,  v123,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLCore.m");
              v124 = (os_log_s *)__pflogFaultLog;
              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136315394;
                v184 = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLCore.m";
                v185 = 1024;
                v186 = 5132;
                _os_log_fault_impl( &dword_186681000,  v124,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
              }

              goto LABEL_144;
            }

            if (v53)
            {
              if (v53 == 1)
              {
                v65 = -[NSPersistentCloudKitContainerEventResult initWithResult:ofType:]( objc_alloc(&OBJC_CLASS___NSPersistentCloudKitContainerEventResult),  "initWithResult:ofType:",  v63,  1LL);
                goto LABEL_196;
              }

    uint64_t v70 = -[NSMutableDictionary objectForKey:](self->_variableToAliasMappings, "objectForKey:", v31);
    if (v70) {
      [v5 appendFormat:@" AS %@", v70];
    }
    ++v30;
    uint64_t v3 = v102;
    if (v30 == v103) {
      goto LABEL_44;
    }
  }

  uint64_t v45 = (void *)[v41 constantValue];
  if (([v45 isNSArray] & 1) == 0
    && ([v45 isNSSet] & 1) == 0
    && ([v45 isNSOrderedSet] & 1) == 0
    && ![v45 isNSDictionary])
  {
    unint64_t v46 = -[NSSQLConstantValueIntermediate initWithConstantValue:inScope:context:]( objc_alloc(&OBJC_CLASS___NSSQLConstantValueIntermediate),  "initWithConstantValue:inScope:context:",  v45,  self,  v102);
    unint64_t v47 = -[NSSQLConstantValueIntermediate generateSQLStringInContext:](v46, "generateSQLStringInContext:", v102);

    if (!v47)
    {
      if (v5) {

      }
      if (![v102 objectForKey:@"NSUnderlyingException"])
      {
        uint64_t v83 = (void *)MEMORY[0x189603F70];
        v84 = [NSString stringWithFormat:@"Can't generate select target token for constant: %@", v45];
        objc_msgSend( v102,  "setObject:forKey:",  objc_msgSend(v83, "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], v84, 0),  @"NSUnderlyingException");
      }

      return 0LL;
    }

    [v5 appendString:v47];

    unint64_t v48 = -[NSSQLAttribute initForReadOnlyFetchWithExpression:]( objc_alloc(&OBJC_CLASS___NSSQLAttribute),  "initForReadOnlyFetchWithExpression:",  v31);
    id v49 = v48;
    if (v48) {
      v48[1] = v31;
    }
    [v101 addObject:v48];

    goto LABEL_141;
  }

  if (v5) {

  }
  objc_msgSend( v102,  "setObject:forKey:",  objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A60],  @"Constant select targets must be values, not collections",  0),  @"NSUnderlyingException");
  return 0LL;
}

        uint64_t v93 = (id *)(v20 + 120);
        if (v92) {
          goto LABEL_142;
        }
LABEL_143:

        objc_autoreleasePoolPop(v1096);
        v1127 = (char *)v1127 + 1;
      }

      while (v1127 != (id)v86);
      v113 = [v85 countByEnumeratingWithState:&v1362 objects:&v1370 count:16];
      unint64_t v86 = v113;
    }

    while (v113);
  }

  v1346 = 0u;
  v1347 = 0u;
  v1348 = 0u;
  v1349 = 0u;
  v114 = *(void **)(v20 + 112);
  v115 = [v114 countByEnumeratingWithState:&v1346 objects:&v1372 count:16];
  if (v115)
  {
    v116 = *(void *)v1347;
    do
    {
      for (kk = 0LL; kk != v115; ++kk)
      {
        if (*(void *)v1347 != v116) {
          objc_enumerationMutation(v114);
        }
        v118 = *(void *)(*((void *)&v1346 + 1) + 8 * kk);
        v119 = (void *)MEMORY[0x186E3E5D8]();
        -[_NSSQLiteStoreMigrator _addEntityMigration:toTableMigrationForRootEntity:tableMigrationType:]( v20,  [*(id *)(v20 + 112) objectForKey:v118],  (void *)objc_msgSend((id)objc_msgSend(*(id *)(v20 + 16), "entityNamed:", v118), "rootEntity"),  3);
        objc_autoreleasePoolPop(v119);
      }

      v115 = [v114 countByEnumeratingWithState:&v1346 objects:&v1372 count:16];
    }

    while (v115);
  }

  v120 = objc_alloc(MEMORY[0x189603FE0]);
  v121 = *(void *)(v20 + 16);
  if (v121) {
    v122 = *(void **)(v121 + 32);
  }
  else {
    v122 = 0LL;
  }
  v123 = (void *)objc_msgSend(v120, "initWithCapacity:", objc_msgSend(v122, "count"));
  v1345 = 0u;
  v1344 = 0u;
  v1343 = 0u;
  v1342 = 0u;
  v124 = *(void **)(v20 + 120);
  v125 = [v124 countByEnumeratingWithState:&v1342 objects:&v1370 count:16];
  if (v125)
  {
    v126 = *(void *)v1343;
    do
    {
      for (mm = 0LL; mm != v125; ++mm)
      {
        if (*(void *)v1343 != v126) {
          objc_enumerationMutation(v124);
        }
        objc_msgSend( v123,  "addObject:",  objc_msgSend( (id)objc_msgSend(*(id *)(v20 + 16), "entityNamed:", *(void *)(*((void *)&v1342 + 1) + 8 * mm)),  "rootEntity"));
      }

      v125 = [v124 countByEnumeratingWithState:&v1342 objects:&v1370 count:16];
    }

    while (v125);
  }

  v1281 = 0u;
  v1280 = 0u;
  v1279 = 0u;
  v1278 = 0u;
  v128 = *(void **)(v20 + 112);
  v129 = [v128 countByEnumeratingWithState:&v1278 objects:&v1366 count:16];
  if (v129)
  {
    v130 = *(void *)v1279;
    do
    {
      for (nn = 0LL; nn != v129; ++nn)
      {
        if (*(void *)v1279 != v130) {
          objc_enumerationMutation(v128);
        }
        objc_msgSend( v123,  "addObject:",  objc_msgSend( (id)objc_msgSend(*(id *)(v20 + 16), "entityNamed:", *(void *)(*((void *)&v1278 + 1) + 8 * nn)),  "rootEntity"));
      }

      v129 = [v128 countByEnumeratingWithState:&v1278 objects:&v1366 count:16];
    }

    while (v129);
  }

  v1277 = 0u;
  v1276 = 0u;
  v1275 = 0u;
  v1274 = 0u;
  v132 = *(void **)(v20 + 96);
  v133 = [v132 countByEnumeratingWithState:&v1274 objects:&v1362 count:16];
  if (v133)
  {
    v134 = *(void *)v1275;
    do
    {
      for (i1 = 0LL; i1 != v133; ++i1)
      {
        if (*(void *)v1275 != v134) {
          objc_enumerationMutation(v132);
        }
        v136 = *(void *)(*((void *)&v1274 + 1) + 8 * i1);
        v137 = (void *)MEMORY[0x186E3E5D8]();
        v138 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(v20 + 16), "entityNamed:", v136), "rootEntity");
        v139 = [*(id *)(v20 + 96) objectForKey:v136];
        else {
          v140 = 0;
        }
        -[_NSSQLiteStoreMigrator _addEntityMigration:toTableMigrationForRootEntity:tableMigrationType:]( v20,  v139,  v138,  v140);
        objc_autoreleasePoolPop(v137);
      }

      v133 = [v132 countByEnumeratingWithState:&v1274 objects:&v1362 count:16];
    }

    while (v133);
  }

  v1273 = 0u;
  v1272 = 0u;
  v1271 = 0u;
  v1270 = 0u;
  v1128 = *(id *)(v20 + 104);
  v141 = [v1128 countByEnumeratingWithState:&v1270 objects:&v1358 count:16];
  if (v141)
  {
    v142 = *(void *)v1271;
    do
    {
      for (i2 = 0LL; i2 != v141; ++i2)
      {
        if (*(void *)v1271 != v142) {
          objc_enumerationMutation(v1128);
        }
        v144 = *(void *)(*((void *)&v1270 + 1) + 8 * i2);
        v145 = (void *)MEMORY[0x186E3E5D8]();
        v146 = (void *)[*(id *)(v20 + 24) entityNamed:v144];
        v147 = (void *)[v146 rootEntity];
        v148 = [*(id *)(v20 + 104) objectForKey:v144];
        if (v146 && !v146[20] || objc_msgSend(*(id *)(v20 + 104), "objectForKey:", objc_msgSend(v147, "name")))
        {
          v149 = 1;
        }

        else
        {
          v147 = (void *)objc_msgSend( (id)objc_msgSend(*(id *)(v20 + 88), "objectForKey:", objc_msgSend(v147, "name")),  "rootEntity");
          v149 = 3;
        }

        -[_NSSQLiteStoreMigrator _addEntityMigration:toTableMigrationForRootEntity:tableMigrationType:]( v20,  v148,  v147,  v149);
        objc_autoreleasePoolPop(v145);
      }

      v141 = [v1128 countByEnumeratingWithState:&v1270 objects:&v1358 count:16];
    }

    while (v141);
  }

  v1269 = 0u;
  v1268 = 0u;
  v1267 = 0u;
  v1266 = 0u;
  v150 = *(void **)(v20 + 80);
  v151 = [v150 countByEnumeratingWithState:&v1266 objects:&v1354 count:16];
  if (v151)
  {
    v152 = *(void *)v1267;
    do
    {
      for (i3 = 0LL; i3 != v151; ++i3)
      {
        if (*(void *)v1267 != v152) {
          objc_enumerationMutation(v150);
        }
        v154 = *(void *)(*((void *)&v1266 + 1) + 8 * i3);
        v155 = (void *)MEMORY[0x186E3E5D8]();
        v156 = (void *)[*(id *)(v20 + 16) entityNamed:v154];
        v157 = objc_msgSend(*(id *)(v20 + 120), "objectForKey:", objc_msgSend(v156, "name"));
        if (v157) {
          -[_NSSQLiteStoreMigrator _addEntityMigration:toTableMigrationForRootEntity:tableMigrationType:]( v20,  v157,  (void *)[v156 rootEntity],  3);
        }
        objc_autoreleasePoolPop(v155);
      }

      v151 = [v150 countByEnumeratingWithState:&v1266 objects:&v1354 count:16];
    }

    while (v151);
  }

  v1265 = 0u;
  v1264 = 0u;
  v1263 = 0u;
  v1262 = 0u;
  v1129 = *(id *)(v20 + 120);
  v158 = [v1129 countByEnumeratingWithState:&v1262 objects:&v1350 count:16];
  if (v158)
  {
    v159 = *(void *)v1263;
    do
    {
      for (i4 = 0LL; i4 != v158; ++i4)
      {
        if (*(void *)v1263 != v159) {
          objc_enumerationMutation(v1129);
        }
        v161 = *(void *)(*((void *)&v1262 + 1) + 8 * i4);
        v162 = (void *)MEMORY[0x186E3E5D8]();
        v163 = (void *)[*(id *)(v20 + 16) entityNamed:v161];
        if (![*(id *)(v20 + 80) objectForKey:v161])
        {
          v164 = (void *)[v163 rootEntity];
          v165 = objc_msgSend(*(id *)(v20 + 128), "objectForKey:", objc_msgSend(v164, "name"));
          if (v165 && *(_DWORD *)(v165 + 24) != 2) {
            v166 = 3;
          }
          else {
            v166 = 2;
          }
          -[_NSSQLiteStoreMigrator _addEntityMigration:toTableMigrationForRootEntity:tableMigrationType:]( v20,  [*(id *)(v20 + 120) objectForKey:v161],  v164,  v166);
        }

        objc_autoreleasePoolPop(v162);
      }

      v158 = [v1129 countByEnumeratingWithState:&v1262 objects:&v1350 count:16];
    }

    while (v158);
  }

  v1130 = (id)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  4 * objc_msgSend(*(id *)(v20 + 128), "count"));
  v1110 = (id)objc_msgSend( (id)objc_msgSend(*(id *)(v20 + 128), "allValues"),  "sortedArrayUsingComparator:",  &__block_literal_global_21);
  v167 = *(void *)(v20 + 48);
  if (!v167)
  {
    v1085 = 0;
    goto LABEL_999;
  }

  v1085 = -[NSSQLiteConnection _hasTableWithName:isTemp:](v167, (uint64_t)@"ANSCKRECORDMETADATA", 0);
  v168 = *(void *)(v20 + 48);
  if (!v168)
  {
LABEL_999:
    v1081 = 0;
    goto LABEL_217;
  }

  v1081 = -[NSSQLiteConnection _hasTableWithName:isTemp:](v168, (uint64_t)@"ANSCKHISTORYANALYZERSTATE", 0);
LABEL_217:
  *(_BYTE *)(v20 + 216) = v1085 | v1081;
  obja = objc_alloc_init(MEMORY[0x189603FA8]);
  v1281 = 0u;
  v1280 = 0u;
  v1279 = 0u;
  v1278 = 0u;
  v169 = [v1110 countByEnumeratingWithState:&v1278 objects:&v1372 count:16];
  if (v169)
  {
    v1097 = 0;
    v170 = *(void *)v1279;
    while (1)
    {
      for (i5 = 0LL; i5 != v169; ++i5)
      {
        if (*(void *)v1279 != v170) {
          objc_enumerationMutation(v1110);
        }
        v172 = *(_DWORD **)(*((void *)&v1278 + 1) + 8 * i5);
        v173 = (void *)MEMORY[0x186E3E5D8]();
        -[_NSSQLTableMigrationDescription appendStatementsToRenameTables:migrationContext:]((uint64_t)v172, v1130, v20);
        if (-[_NSSQLiteStoreMigrator enforceCloudKitConstraintsForEntity:]( v20,  (void *)[v172 rootEntity]))
        {
          if (!v172)
          {
            v174 = 0;
LABEL_231:
            v1097 |= v174 == 0;
            goto LABEL_232;
          }

          v174 = v172[6];
          v175 = v174 == 3;
          v176 = (void *)-[_NSSQLTableMigrationDescription newCloudKitMetadataUpdateStatements:]((uint64_t)v172, obja);
          if (v176)
          {
            [*(id *)(v20 + 208) addObjectsFromArray:v176];
          }

          else
          {
            v177 = [NSString stringWithUTF8String:"tableMigration returned nil cloudkit update statements: %@"];
            _NSCoreDataLog(17LL, v177, v178, v179, v180, v181, v182, v183, (uint64_t)v172);
            v184 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              v1370 = 138412290;
              v1371 = v172;
              _os_log_fault_impl( &dword_186681000,  v184,  OS_LOG_TYPE_FAULT,  "CoreData: tableMigration returned nil cloudkit update statements: %@",  (uint8_t *)&v1370,  0xCu);
            }
          }

          v1097 |= v175;
        }

LABEL_144:
              v74 = 0LL;
            }

            else if ([v63 count])
            {
              v146 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  objc_msgSend(v63, "count"));
              v178[0] = MEMORY[0x1895F87A8];
              v178[1] = 3221225472LL;
              v178[2] = __66__NSSQLCore_processCloudKitContainerEventRequest_inContext_error___block_invoke;
              v178[3] = &unk_189EA9960;
              v178[4] = v146;
              [v63 enumerateObjectsUsingBlock:v178];
              v147 = (void *)[v146 copy];
              v74 = -[NSPersistentCloudKitContainerEventResult initWithResult:ofType:]( objc_alloc(&OBJC_CLASS___NSPersistentCloudKitContainerEventResult),  "initWithResult:ofType:",  v147,  0LL);
            }

            else
            {
              v158 = objc_alloc(&OBJC_CLASS___NSPersistentCloudKitContainerEventResult);
              v65 = -[NSPersistentCloudKitContainerEventResult initWithResult:ofType:]( v158,  "initWithResult:ofType:",  NSArray_EmptyArray,  0LL);
LABEL_196:
              v74 = v65;
            }
          }

          else
          {
            uint64_t v73 = objc_alloc(&OBJC_CLASS___NSPersistentCloudKitContainerEventResult);
            v74 = -[NSPersistentCloudKitContainerEventResult initWithResult:ofType:]( v73,  "initWithResult:ofType:",  NSArray_EmptyArray,  v53);
          }

          uint64_t v32 = v74;
          goto LABEL_199;
        }

        uint64_t v32 = 0LL;
LABEL_199:
        uint64_t v21 = 0LL;
        int v6 = 11LL;
        goto LABEL_200;
      default:
        uint64_t v21 = 0LL;
        uint64_t v32 = 0LL;
        goto LABEL_200;
    }
  }

  uint64_t v32 = 0LL;
  if (a5 && v172)
  {
    uint64_t v32 = 0LL;
    *a5 = v172;
  }

  return v32;
}

void sub_186689548(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_terminate();
    objc_end_catch();
  }

  _Unwind_Resume(v2);
}

LABEL_6:
  unint64_t v10 = 0;
LABEL_7:
  if (![v7 fetchBatchSize]
    || (([v7 resultType] != 0) & ~v10) != 0
    || [v7 allocationType] == 1
    || [v7 allocationType] == 2)
  {
    int v11 = 0;
    unint64_t v12 = 0LL;
  }

  else
  {
    unint64_t v25 = (id)[v7 copy];
    int v11 = 1;
    [v25 setResultType:1];
    [v25 setIncludesPropertyValues:0];
    unint64_t v12 = v7;
    uint64_t v7 = v25;
  }

  if ([v7 resultType] == 1)
  {
    if (!v12)
    {
      unint64_t v12 = v7;
      uint64_t v7 = (id)[v7 copy];
    }

    [v7 setPropertiesToFetch:0];
  }

  v69.receiver = self;
  v69.super_class = (Class)&OBJC_CLASS___NSSQLFetchRequestContext;
  uint64_t v13 = -[NSSQLStoreRequestContext initWithRequest:context:sqlCore:]( &v69,  sel_initWithRequest_context_sqlCore_,  v7,  a4,  a5);
  unint64_t v14 = v13;
  if (v13)
  {
    if (a5)
    {
      v13->_storeIsUbiquitized = objc_msgSend( (id)objc_msgSend(a5, "options"),  "objectForKey:",  @"NSPersistentStoreUbiquitousContentNameKey") != 0;
      if ((*((_BYTE *)a5 + 201) & 0x40) != 0)
      {
LABEL_24:
        v14->_fileBackedFuturesDirectory = (NSString *)(id)[a5 fileBackedFuturesDirectory];
        if (a5)
        {
          v14->_fileProtectionLevel = (*((_DWORD *)a5 + 50) >> 2) & 7;
          v14->_faultHandler = (NSFaultHandler *)*((id *)a5 + 6);
          unint64_t v17 = (void *)_sqlCoreLookupSQLEntityForEntityDescription(a5, (void *)[v7 entity]);
        }

        else
        {
          v14->_fileProtectionLevel = 0;
          unint64_t v17 = 0LL;
          v14->_faultHandler = 0LL;
        }

        uint64_t v18 = v17;
        v14->_sqlEntity = v18;
        v14->_sqlModel = (NSSQLModel *)-[NSSQLEntity model](v18, "model");
        v14->_isFaultRequest = 0;
        v14->_originalRequest = (NSFetchRequest *)v12;
        v14->_shouldUseBatches = v11;
        v14->_fetchPlan = fetchPlanAllocateInitialize( -[NSSQLFetchRequestContext request](v14, "request"),  &v14->super._sqlCore->super,  v14->super._context);
        uint64_t v19 = [v7 resultType];
        uint64_t v20 = [v7 returnsObjectsAsFaults];
        if (v19 == 1)
        {
          uint64_t v21 = 4;
        }

        else if (v19 == 2)
        {
          uint64_t v21 = 16;
        }

        else
        {
          uint64_t v22 = v20;
          uint64_t v23 = objc_msgSend((id)objc_msgSend(v7, "propertiesToFetch"), "count");
          if (v22) {
            uint64_t v21 = 0;
          }
          else {
            uint64_t v21 = 12;
          }
          if (v23) {
            uint64_t v21 = 20;
          }
        }

        v14->_fetchPlan->flags = ($C6D29F7D67899FE11DE7F8953A7C3E5F)(*(_DWORD *)&v14->_fetchPlan->flags & 0xFFFFFFE3 | v21);
        return v14;
      }
    }

    else
    {
      v13->_storeIsUbiquitized = 0;
    }

    v14->_externalDataReferencesDirectory = (NSString *)(id)[a5 externalDataReferencesDirectory];
    if (a5)
    {
      unint64_t v16 = (void *)atomic_load((unint64_t *)a5 + 22);
    }

    else
    {
      unint64_t v16 = 0LL;
    }

    v14->_externalDataLinksDirectory = (NSString *)v16;
    goto LABEL_24;
  }

  return v14;
}

  cd_managedObjectContext = 0LL;
LABEL_7:
  if (cd_managedObjectContext == self)
  {
    if (-[NSManagedObject isFault](object, "isFault")) {
      -[NSFaultHandler fulfillFault:withContext:](_insertion_fault_handler, object, (uint64_t)self);
    }
    -[NSMutableSet addObject:](self->_lockedObjects, "addObject:", object);
  }

  else if (cd_managedObjectContext)
  {
    objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"An NSManagedObjectContext cannot detect conflicts for objects in other contexts." userInfo:0]);
    -[NSManagedObjectContext lock](v6, v7);
  }

      *(void *)(*(void *)(*(void *)(v1 + 56) + 8LL) + 40LL) = v89;
      *(void *)(*(void *)(*(void *)(v1 + 64) + 8LL) + 40LL) = v4;
      return [v3 drain];
    case 5LL:
    case 6LL:
    case 7LL:
    case 8LL:
    case 9LL:
    case 10LL:
    case 11LL:
      id v5 = (_PFBatchFaultingArray *)[*(id *)(v1 + 32) executeRequest:*(void *)(v1 + 40) error:&v89];
      goto LABEL_5;
    default:
      goto LABEL_6;
  }

  do
  {
    uint64_t v22 = v18;
    for (i = 0LL; i != v20; ++i)
    {
      if (*(void *)v95 != v21) {
        objc_enumerationMutation(v22);
      }
      uint64_t v24 = *(void **)(*((void *)&v94 + 1) + 8 * i);
      unint64_t v25 = objc_msgSend((id)objc_msgSend(v24, "type"), "isEqual:", @"SQLite");
      unint64_t v26 = objc_msgSend((id)objc_msgSend(v24, "type"), "isEqual:", @"NSXPCStore");
      if ((v25 & 1) == 0 && (v26 & 1) == 0)
      {
        unint64_t v27 = (void *)[v24 configurationName];
        if (([v27 isEqualToString:@"PF_DEFAULT_CONFIGURATION_NAME"] & 1) != 0
          || objc_msgSend( (id)objc_msgSend( (id)objc_msgSend( (id)-[_PFBatchFaultingArray persistentStoreCoordinator](v4, "persistentStoreCoordinator"),  "managedObjectModel"),  "entitiesForConfiguration:",  v27),  "indexOfObjectIdenticalTo:",  v85) != 0x7FFFFFFFFFFFFFFFLL)
        {
          [v80 setFetchBatchSize:0];
          unint64_t v15 = v81;
          uint64_t v13 = v79;
          goto LABEL_33;
        }
      }
    }

    uint64_t v18 = v22;
    uint64_t v20 = [v22 countByEnumeratingWithState:&v94 objects:v100 count:16];
    unint64_t v15 = v81;
    uint64_t v13 = v79;
  }

  while (v20);
LABEL_33:
  uint64_t v28 = v80;
  uint64_t v29 = [v80 includesPropertyValues];
  if (v15)
  {
    if (v15 == 1 && -[_PFBatchFaultingArray hasChanges](v4, "hasChanges"))
    {
      uint64_t v30 = 0LL;
LABEL_40:
      [v80 setResultType:v30];
    }
  }

  else if (!objc_msgSend((id)objc_msgSend(v80, "propertiesToFetch"), "count") {
         && (-[_PFBatchFaultingArray hasChanges](v4, "hasChanges") & 1) == 0)
  }
  {
    uint64_t v30 = 1LL;
    goto LABEL_40;
  }

  [v80 setIncludesPropertyValues:v29];
  uint64_t v31 = (void *)-[_PFBatchFaultingArray executeFetchRequest:error:](v4, "executeFetchRequest:error:", v80, &v98);
  uint64_t v32 = [v31 count];
  if (v32)
  {
    uint64_t v33 = v32;
    if ((!v15 && (_BYTE)dword_18C4ABDC0 || BYTE1(dword_18C4ABDC0) && v15 == 2) && [v80 fetchBatchSize])
    {
      uint64_t v34 = [v80 resultType];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        if (v31)
        {
          uint64_t v31 = (void *)[v31 newArrayFromObjectIDs];
          uint64_t v34 = 1LL;
          uint64_t v72 = v31;
        }

        else
        {
          uint64_t v72 = 0LL;
          uint64_t v34 = 1LL;
        }
      }

      else
      {
        uint64_t v72 = 0LL;
      }

      v74 = v33;
      uint64_t v83 = (char *)PF_ALLOCATE_OBJECT_ARRAY(v33);
      v90 = 0u;
      uint64_t v91 = 0u;
      v92 = 0u;
      uint64_t v93 = 0u;
      unint64_t v47 = [v31 countByEnumeratingWithState:&v90 objects:v99 count:16];
      if (v47)
      {
        unint64_t v48 = v47;
        id v49 = 0LL;
        uint64_t v50 = *(void *)v91;
        do
        {
          uint64_t v51 = 0LL;
          unint64_t v87 = v49;
          uint64_t v52 = &v83[8 * v49];
          do
          {
            if (*(void *)v91 != v50) {
              objc_enumerationMutation(v31);
            }
            uint64_t v53 = *(void **)(*((void *)&v90 + 1) + 8 * v51);
            if (v34 != 1) {
              uint64_t v53 = (void *)objc_msgSend(*(id *)(*((void *)&v90 + 1) + 8 * v51), "objectID", v72);
            }
            __int16 v54 = objc_msgSend(*(id *)(*((void *)v4[2]._entryFlags + 1) + 8), "objectForKey:", v53, v72);
            if (v54)
            {
              unint64_t v55 = (void *)v54;
              if ([v12 objectRegisteredForID:v54]) {
                uint64_t v53 = v55;
              }
            }

            *(void *)&v52[8 * v51++] = v53;
          }

          while (v48 != v51);
          unint64_t v48 = [v31 countByEnumeratingWithState:&v90 objects:v99 count:16];
          id v49 = v87 + v51;
        }

        while (v48);
      }

      __int16 v56 = -[_PFArray initWithObjects:count:andFlags:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:",  v83,  v74,  10LL);
      unint64_t v57 = -[_PFBatchFaultingArray initWithPFArray:andRequest:andContext:]( objc_alloc(&OBJC_CLASS____PFBatchFaultingArray),  "initWithPFArray:andRequest:andContext:",  v56,  v76,  v12);

      goto LABEL_98;
    }

    if (!v15)
    {
      unint64_t v75 = v33;
      v84 = (char *)PF_ALLOCATE_OBJECT_ARRAY(v33);
      __int16 v58 = [v80 resultType];
      v90 = 0u;
      uint64_t v91 = 0u;
      v92 = 0u;
      uint64_t v93 = 0u;
      unint64_t v59 = [v31 countByEnumeratingWithState:&v90 objects:v99 count:16];
      if (v59)
      {
        uint64_t v60 = v59;
        uint64_t v61 = 0LL;
        uint64_t v62 = *(void *)v91;
        do
        {
          uint64_t v63 = 0LL;
          unint64_t v88 = v61;
          uint64_t v64 = &v84[8 * v61];
          do
          {
            if (*(void *)v91 != v62) {
              objc_enumerationMutation(v31);
            }
            v65 = *(void **)(*((void *)&v90 + 1) + 8 * v63);
            if (v58 != 1) {
              v65 = (void *)[*(id *)(*((void *)&v90 + 1) + 8 * v63) objectID];
            }
            unint64_t v66 = [*(id *)(*((void *)v4[2]._entryFlags + 1) + 8) objectForKey:v65];
            if (v66)
            {
              uint64_t v67 = (void *)v66;
              if ([v12 objectRegisteredForID:v66]) {
                v65 = v67;
              }
            }

            if (v12) {
              uint64_t v68 = _PFRetainedObjectIDCore((uint64_t)v12, v65, 0LL, 1);
            }
            else {
              uint64_t v68 = 0LL;
            }
            *(void *)&v64[8 * v63++] = v68;
          }

          while (v60 != v63);
          uint64_t v69 = [v31 countByEnumeratingWithState:&v90 objects:v99 count:16];
          uint64_t v60 = v69;
          uint64_t v61 = v88 + v63;
        }

        while (v69);
      }

      unint64_t v46 = -[_PFArray initWithObjects:count:andFlags:andContext:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:andContext:",  v84,  v75,  42LL,  v12);
      goto LABEL_97;
    }

    if (v15 == 1)
    {
      uint64_t v73 = v33;
      uint64_t v82 = (char *)PF_ALLOCATE_OBJECT_ARRAY(v33);
      unint64_t v36 = [v80 resultType];
      v90 = 0u;
      uint64_t v91 = 0u;
      v92 = 0u;
      uint64_t v93 = 0u;
      unint64_t v37 = [v31 countByEnumeratingWithState:&v90 objects:v99 count:16];
      if (v37)
      {
        uint64_t v38 = v37;
        uint64_t v39 = 0LL;
        uint64_t v40 = *(void *)v91;
        do
        {
          uint64_t v41 = 0LL;
          unint64_t v86 = v39;
          uint64_t v42 = &v82[8 * v39];
          do
          {
            if (*(void *)v91 != v40) {
              objc_enumerationMutation(v31);
            }
            uint64_t v43 = *(void **)(*((void *)&v90 + 1) + 8 * v41);
            if (v36 != 1) {
              uint64_t v43 = (void *)[*(id *)(*((void *)&v90 + 1) + 8 * v41) objectID];
            }
            uint64_t v44 = [*(id *)(*((void *)v4[2]._entryFlags + 1) + 8) objectForKey:v43];
            if (v44)
            {
              uint64_t v45 = (void *)v44;
              if ([v12 objectRegisteredForID:v44]) {
                uint64_t v43 = v45;
              }
            }

            *(void *)&v42[8 * v41++] = v43;
          }

          while (v38 != v41);
          uint64_t v38 = [v31 countByEnumeratingWithState:&v90 objects:v99 count:16];
          uint64_t v39 = v86 + v41;
        }

        while (v38);
      }

      unint64_t v46 = -[_PFArray initWithObjects:count:andFlags:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:",  v82,  v73,  10LL);
LABEL_97:
      unint64_t v57 = (_PFBatchFaultingArray *)v46;
LABEL_98:
      uint64_t v13 = v79;
      uint64_t v28 = v80;
LABEL_101:
      uint64_t v70 = v98;

      [v13 drain];
      -[NSManagedObjectContext _processReferenceQueue:]((uint64_t)v4, 0);
      uint64_t v3 = v77;
      int v1 = v78;
      if (v98) {
        v89 = v98;
      }
      uint64_t v71 = v98;
      id v5 = v57;
      goto LABEL_5;
    }

    unint64_t v35 = v31;
  }

  else
  {
    unint64_t v35 = (_PFBatchFaultingArray *)MEMORY[0x189604A58];
  }

  unint64_t v57 = v35;
  goto LABEL_101;
}

  int v6 = (void *)[*(id *)(a1 + 8) objectForKey:v2];
  if (v6)
  {
    LODWORD(v7) = [v6 unsignedIntValue];
    do
    {
      uint64_t v7 = (v7 + 1);
      uint64_t v8 = objc_msgSend(v2, "stringByAppendingFormat:", @"%d", v7);
    }

    while ([*(id *)(a1 + 8) objectForKey:v8]);
  }

  else
  {
    LODWORD(v7) = 0;
    uint64_t v8 = (uint64_t)v2;
  }

  valuePtr = v7;
  unint64_t v9 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
  [*(id *)(a1 + 8) setObject:v9 forKey:v2];

  return v8;
}

LABEL_8:
    while (!__ldaxr(p_externalDataReferencesDirectory))
    {
    }

    __clrex();

LABEL_12:
    if ((*(_BYTE *)&self->_sqlCoreFlags & 0x80) != 0)
    {
      unint64_t v12 = atomic_load(p_externalDataReferencesDirectory);
      if (([&stru_189EAC2E8 isEqual:v12] & 1) == 0)
      {
        uint64_t v13 = (id)objc_msgSend( -[_PFGarbageManager temporaryLinksDirectoryForStore:]( (id *)+[_PFGarbageManager defaultInstance]( _PFGarbageManager,  "defaultInstance"),  self),  "path");
        p_externalDataLinksDirectory = (unint64_t *)&self->_externalDataLinksDirectory;
        while (!__ldaxr(p_externalDataLinksDirectory))
        {
        }

        __clrex();
      }
    }
  }

    while (!__ldaxr(p_fileBackedFuturesPath))
    {
    }

    __clrex();
  }

  v26[5] = 0LL;
  uint64_t v22 = v11;
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v31, 8);
  return v22;
}

  self->_connection = 0LL;
  v8.receiver = self;
  v8.super_class = (Class)&OBJC_CLASS___NSCachedFetchRequestThunk;
  -[NSCachedFetchRequestThunk dealloc](&v8, sel_dealloc);
}

  fcntl(v12, 48, 1LL);
  uint64_t v21 = pread(v12, a3, a5, a4);
  if (v21 < 0)
  {
    close(v12);
    unint64_t v15 = (void *)MEMORY[0x189603F70];
    unint64_t v16 = *MEMORY[0x189603A60];
    unint64_t v17 = objc_msgSend( NSString,  "stringWithFormat:",  @"Unable to read content of file with path: %s (%d)",  v11,  *__error());
    uint64_t v33 = @"com.apple.coredata.ubiquity.eat";
    uint64_t v34 = MEMORY[0x189604A88];
    uint64_t v18 = (void *)MEMORY[0x189603F68];
    uint64_t v19 = &v34;
    uint64_t v20 = &v33;
    goto LABEL_14;
  }

  uint64_t v22 = v21;
  uint64_t result = close(v12);
  if (v22 != a5)
  {
    uint64_t v23 = (void *)MEMORY[0x189603F70];
    uint64_t v24 = *MEMORY[0x189603A60];
    unint64_t v17 = objc_msgSend( NSString,  "stringWithFormat:",  @"Unable to read requested number of bytes from path: %s (got %lu)",  v11,  v22);
    uint64_t v31 = @"com.apple.coredata.ubiquity.eat";
    uint64_t v32 = MEMORY[0x189604A88];
    unint64_t v25 = [MEMORY[0x189603F68] dictionaryWithObjects:&v32 forKeys:&v31 count:1];
    unint64_t v26 = v23;
    unint64_t v27 = v24;
LABEL_15:
    objc_exception_throw((id)[v26 exceptionWithName:v27 reason:v17 userInfo:v25]);
    return +[_PFRoutines deleteFileForPFExternalReferenceData:](v29, v30);
  }

  return result;
}

  objc_autoreleasePoolPop(v6);
  objc_sync_exit(self);
}

  -[NSManagedObjectContext _sendCommitEditingSelectorToTarget:sender:selector:flag:contextInfo:delayed:]( (uint64_t)self,  a5->var0,  (uint64_t)self,  (uint64_t)a5->var1,  v6,  (uint64_t)a5->var2,  0);
  unint64_t v10 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    unint64_t v10 = malloc_default_zone();
  }
  malloc_zone_free(v10, a5);
}

  uint64_t v8 = (void *)atomic_load((unint64_t *)&self->_originalData);

  v10.receiver = self;
  v10.super_class = (Class)&OBJC_CLASS____PFExternalReferenceData;
  -[_PFExternalReferenceData dealloc](&v10, sel_dealloc);
}

LABEL_19:
  unint64_t v16 = atomic_load(p_externalDataReferencesDirectory);
  if ([&stru_189EAC2E8 isEqual:v16]) {
    return 0LL;
  }
  else {
    return (id)atomic_load(p_externalDataReferencesDirectory);
  }
}

  -[NSFetchRequest setFetchLimit:](v8->_request, "setFetchLimit:", batchSize);
  count = v8->_count;
  uint64_t v19 = v8->_batchSize;
  if (count % v19) {
    uint64_t v20 = count / v19 + 1;
  }
  else {
    uint64_t v20 = count / v19;
  }
  v8->_entryFlags = (unsigned int *)PF_CALLOC_SCANNED_BYTES(4LL * v20);
  *(_DWORD *)&v8->_flags &= 0xFFFFFF00;
  uint64_t v21 = (unsigned int *)PF_CALLOC_SCANNED_BYTES(4LL * v16);
  v8->_LRUBatches = v21;
  memset(v21, 255, 4LL * v16);
  return v8;
}

      _NSCoreDataLog(1LL, (uint64_t)@"  MNT_DEFWRITE", v129, v130, v131, v132, v133, v134, v196);
      goto LABEL_20;
    }

    [v8 addObject:v13];
    [a2 addObject:v13];
    [a1[7] removeObject:v13];
    if (v13) {
      *(_DWORD *)(v13 + 16) &= ~1u;
    }
  }

  if (v7 >= 0x201) {
    NSZoneFree(0LL, v11);
  }
  return v8;
}

          newValue = 0LL;
          uint64_t v24 = 1;
LABEL_20:
          objc_autoreleasePoolPop(v20);
          if (v24) {
            goto LABEL_68;
          }
          if (++v18 == v15)
          {
            unint64_t v25 = [v14 countByEnumeratingWithState:&v81 objects:v93 count:16];
            unint64_t v15 = v25;
            if (v25) {
              goto LABEL_8;
            }
            break;
          }
        }
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        newValue->_entities = (NSMutableDictionary *)-[NSMutableDictionary mutableCopy]( newValue->_entities,  "mutableCopy");
      }
    }

    unint64_t v26 = (id *)PF_CALLOC_OBJECT_ARRAY(4LL);
    newValue->_additionalPrivateIvars = v26;
    const char *v26 = 0LL;
    *((void *)newValue->_additionalPrivateIvars + 1) = 0LL;
    *((void *)newValue->_additionalPrivateIvars + 2) = 0LL;
    *((void *)newValue->_additionalPrivateIvars + 3) = 0LL;
    unint64_t v27 = (void *)MEMORY[0x189604010];
    uint64_t v28 = objc_opt_class();
    uint64_t v29 = objc_opt_class();
    uint64_t v30 = objc_opt_class();
    uint64_t v31 = objc_opt_class();
    uint64_t v32 = objc_opt_class();
    uint64_t v33 = (void *)objc_msgSend( a3,  "decodeObjectOfClasses:forKey:",  objc_msgSend(v27, "setWithObjects:", v28, v29, v30, v31, v32, objc_opt_class(), 0),  @"NSConfigurations");
    if (v33)
    {
      newValue->_configurations = (NSMutableDictionary *)objc_alloc_init(MEMORY[0x189603FC8]);
      *((void *)newValue->_additionalPrivateIvars + 3) = objc_alloc_init(MEMORY[0x189603FC8]);
      context = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v78 = 0u;
      uint64_t v79 = 0u;
      unint64_t v76 = 0u;
      uint64_t v77 = 0u;
      uint64_t v34 = [v33 countByEnumeratingWithState:&v76 objects:v92 count:16];
      if (v34)
      {
        unint64_t v35 = *(void *)v77;
        do
        {
          for (i = 0LL; i != v34; ++i)
          {
            if (*(void *)v77 != v35) {
              objc_enumerationMutation(v33);
            }
            unint64_t v37 = *(void *)(*((void *)&v76 + 1) + 8 * i);
            uint64_t v38 = (void *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v33, "objectForKey:", v37), "allObjects"),  "mutableCopy");
            -[NSMutableDictionary setObject:forKey:](newValue->_configurations, "setObject:forKey:", v38, v37);
            uint64_t v39 = (void *)[MEMORY[0x189603FE0] set];
            v74 = 0u;
            unint64_t v75 = 0u;
            uint64_t v72 = 0u;
            uint64_t v73 = 0u;
            uint64_t v40 = [v38 countByEnumeratingWithState:&v72 objects:v91 count:16];
            if (v40)
            {
              uint64_t v41 = *(void *)v73;
              do
              {
                for (j = 0LL; j != v40; ++j)
                {
                  if (*(void *)v73 != v41) {
                    objc_enumerationMutation(v38);
                  }
                  objc_msgSend(v39, "addObject:", objc_msgSend(*(id *)(*((void *)&v72 + 1) + 8 * j), "name"));
                }

                uint64_t v40 = [v38 countByEnumeratingWithState:&v72 objects:v91 count:16];
              }

              while (v40);
            }

            [newValue->_additionalPrivateIvars[3] setObject:v39 forKey:v37];
          }

          uint64_t v34 = [v33 countByEnumeratingWithState:&v76 objects:v92 count:16];
        }

        while (v34);
      }

      objc_autoreleasePoolPop(context);
    }

    uint64_t v43 = (void *)MEMORY[0x189604010];
    uint64_t v44 = objc_opt_class();
    uint64_t v45 = objc_opt_class();
    unint64_t v46 = objc_opt_class();
    unint64_t v47 = (NSMutableDictionary *)(id)objc_msgSend( a3,  "decodeObjectOfClasses:forKey:",  objc_msgSend( v43,  "setWithObjects:",  v44,  v45,  v46,  objc_opt_class(),  0),  @"NSFetchRequestTemplates");
    newValue->_fetchRequestTemplates = v47;
    if (!v47)
    {
LABEL_60:
      __int16 v56 = (void *)MEMORY[0x189604010];
      unint64_t v57 = objc_opt_class();
      __int16 v58 = objc_opt_class();
      unint64_t v59 = objc_opt_class();
      uint64_t v60 = objc_opt_class();
      uint64_t v61 = (NSSet *)(id)objc_msgSend( a3,  "decodeObjectOfClasses:forKey:",  objc_msgSend(v56, "setWithObjects:", v57, v58, v59, v60, objc_opt_class(), 0),  @"NSVersionIdentifiers");
      uint64_t v62 = newValue;
      newValue->_versionIdentifiers = v61;
      if (!v61)
      {
        uint64_t v63 = (NSSet *)objc_alloc_init(MEMORY[0x189604010]);
        uint64_t v62 = newValue;
        newValue->_versionIdentifiers = v63;
      }

      *(_DWORD *)&v62->_managedObjectModelFlags &= 0xFFFFFFFC;
      -[NSManagedObjectModel _finalizeIndexes](v62);
      goto LABEL_69;
    }

    if ((-[NSMutableDictionary isNSDictionary](v47, "isNSDictionary") & 1) != 0)
    {
      uint64_t v70 = 0u;
      uint64_t v71 = 0u;
      uint64_t v68 = 0u;
      uint64_t v69 = 0u;
      unint64_t v48 = (void *)-[NSMutableDictionary allKeys](newValue->_fetchRequestTemplates, "allKeys");
      id v49 = [v48 countByEnumeratingWithState:&v68 objects:v90 count:16];
      if (v49)
      {
        uint64_t v50 = *(void *)v69;
        while (2)
        {
          for (k = 0LL; k != v49; ++k)
          {
            if (*(void *)v69 != v50) {
              objc_enumerationMutation(v48);
            }
            uint64_t v52 = *(void **)(*((void *)&v68 + 1) + 8 * k);
            uint64_t v53 = (void *)-[NSMutableDictionary objectForKeyedSubscript:]( newValue->_fetchRequestTemplates,  "objectForKeyedSubscript:",  v52);
            if (![v52 isNSString]
              || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
            {
              objc_msgSend( a3,  "failWithError:",  objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  4866,  &unk_189F03860));

              goto LABEL_68;
            }

            __int16 v54 = (void *)[v53 entity];
            unint64_t v55 = v54;
            if (v54
              && (![v54 name]
               || (void *)-[NSMutableDictionary objectForKeyedSubscript:]( newValue->_entities,  "objectForKeyedSubscript:",  [v55 name]) != v55))
            {
              objc_msgSend( a3,  "failWithError:",  objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  4866,  &unk_189F03888));

              goto LABEL_68;
            }
          }

          id v49 = [v48 countByEnumeratingWithState:&v68 objects:v90 count:16];
          if (v49) {
            continue;
          }
          break;
        }
      }

      goto LABEL_60;
    }

    objc_msgSend( a3,  "failWithError:",  objc_msgSend(MEMORY[0x189607870], "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], 4866, &unk_189F03838));

LABEL_68:
    newValue = 0LL;
LABEL_69:
    v86((uint64_t)v85);
    return newValue;
  }

  return 0LL;
}

        LOBYTE(v13) = 0;
        return v13;
      }

    unint64_t v16 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:@" WHERE "];
    goto LABEL_20;
  }

  if ((v8 & 1) == 0)
  {
    if (*(void *)(v6 + 160)) {
      goto LABEL_19;
    }
    uint64_t v23 = *(void **)(v6 + 152);
    if (v23)
    {
      if ([v23 count]) {
        goto LABEL_19;
      }
    }
  }

  unint64_t v16 = 0LL;
LABEL_23:
  uint64_t v18 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:@"UPDATE OR FAIL "];
  objc_msgSend(v18, "appendString:", objc_msgSend((id)v6, "tableName"));
  [v18 appendString:@" SET "];
  objc_msgSend(v18, "appendString:", objc_msgSend(v3, "columnName"));
  [v18 appendString:@" = "];
  [v18 appendString:v12];
  if (v16) {
    [v18 appendString:v16];
  }
  if (a2) {
    uint64_t v19 = *(NSSQLiteStatement **)(a2 + 32);
  }
  else {
    uint64_t v19 = 0LL;
  }
  uint64_t v20 = -[NSSQLiteAdapter newStatementWithSQLString:](v19, (uint64_t)v18);
  uint64_t v13 = v20;
  if (v11)
  {
    -[NSSQLiteStatement addBindVariable:]((uint64_t)v20, v11);
  }

  if (v16) {

  }
  return v13;
}

    uint64_t v45 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFMirroredRelationship.m");
    uint64_t v52 = (os_log_s *)__pflogFaultLog;
    uint64_t v24 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!v24) {
      return v24;
    }
    *(_DWORD *)buf = 136315394;
    __int16 v56 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFMirroredRelationship.m";
    unint64_t v57 = 1024;
    LODWORD(v58) = 463;
    _os_log_fault_impl( &dword_186681000,  v52,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    goto LABEL_21;
  }

  unint64_t v12 = (void *)[a4 objectWithID:v11];
  relatedRecordID = self->_relatedRecordID;
  if (!relatedRecordID)
  {
    objc_msgSend(v12, "setValue:forKey:", 0, -[NSPropertyDescription name](self->_relationshipDescription, "name"));
    goto LABEL_19;
  }

  unint64_t v14 = objc_msgSend( (id)objc_msgSend( *((id *)a3 + 8),  "objectForKey:",  -[NSEntityDescription name]( -[NSPropertyDescription entity](self->_inverseRelationshipDescription, "entity"),  "name")),  "objectForKey:",  relatedRecordID);
  if (!v14)
  {
    unint64_t v35 = (void *)MEMORY[0x186E3E5D8]();
    else {
      unint64_t v36 = __ckLoggingOverride;
    }
    unint64_t v37 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Couldn't find related object to link for object with record name %@ to %@ via %@"];
    -[NSPropertyDescription name](self->_relationshipDescription, "name");
    _NSCoreDataLog( v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  (uint64_t)"-[PFMirroredOneToManyRelationship updateRelationshipValueUsingImportContext:andManagedObjectContext:error:]");
    objc_autoreleasePoolPop(v35);
    goto LABEL_16;
  }

  unint64_t v15 = (void *)[a4 objectWithID:v14];
  context = (void *)MEMORY[0x186E3E5D8]();
  else {
    unint64_t v16 = __ckLoggingOverride;
  }
  unint64_t v17 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Linking object with record name %@ to %@ via %@ on %@->%@"];
  -[NSPropertyDescription name](self->_relationshipDescription, "name");
  [v15 objectID];
  _NSCoreDataLog( v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  (uint64_t)"-[PFMirroredOneToManyRelationship updateRelationshipValueUsingImportContext:andManagedObjectContext:error:]");
  objc_autoreleasePoolPop(context);
  objc_msgSend(v12, "setValue:forKey:", v15, -[NSPropertyDescription name](self->_relationshipDescription, "name"));
  LOBYTE(v24) = 1;
  return v24;
}

  if (!v7->_payload && v7->_length)
  {
LABEL_21:

    return 0LL;
  }

  return v7;
}

  uint64_t v19 = (id)[v7 copy];

  uint64_t v20 = (void *)[objc_alloc(MEMORY[0x189607950]) initWithName:a2 object:a1 userInfo:v19];
  [a1 logResetSyncNotification:v20];
  objc_msgSend((id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"), "postNotification:", v20);

  objc_autoreleasePoolPop(v6);
}

      LOBYTE(v7) = 0;
      return v7;
    }

    unint64_t v15 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/source/NSFileBackedFuture.m");
    uint64_t v22 = (os_log_s *)__pflogFaultLog;
    uint64_t v7 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!v7) {
      return v7;
    }
    *(_DWORD *)buf = 136315394;
    unint64_t v35 = "/Library/Caches/com.apple.xbs/Sources/Persistence/source/NSFileBackedFuture.m";
    unint64_t v36 = 1024;
    unint64_t v37 = 28;
LABEL_18:
    _os_log_fault_impl( &dword_186681000,  v22,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    goto LABEL_19;
  }

  if (!a3) {
    goto LABEL_19;
  }
  uint64_t v31 = 0LL;
  int v6 = objc_msgSend( (id)objc_msgSend(MEMORY[0x1896078A8], "defaultManager"),  "removeItemAtURL:error:",  *((void *)a3 + 1),  &v31);
  LOBYTE(v7) = 1;
  if ((v6 & 1) == 0 && v31)
  {
    uint64_t v8 = (void *)[v31 domain];
    if ([v8 isEqualToString:*MEMORY[0x189607460]] && objc_msgSend(v31, "code") == 4)
    {
      LOBYTE(v7) = 1;
      return v7;
    }

    unint64_t v14 = v31;
    if (v31)
    {
      if (a4) {
        goto LABEL_15;
      }
      goto LABEL_19;
    }

    uint64_t v23 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/source/NSFileBackedFuture.m");
    uint64_t v22 = (os_log_s *)__pflogFaultLog;
    uint64_t v7 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!v7) {
      return v7;
    }
    *(_DWORD *)buf = 136315394;
    unint64_t v35 = "/Library/Caches/com.apple.xbs/Sources/Persistence/source/NSFileBackedFuture.m";
    unint64_t v36 = 1024;
    unint64_t v37 = 338;
    goto LABEL_18;
  }

  return v7;
}

LABEL_12:
  int v11 = atomic_load(p_fileBackedFuturesPath);
  if ([&stru_189EAC2E8 isEqual:v11]) {
    return 0LL;
  }
  else {
    return (id)atomic_load(p_fileBackedFuturesPath);
  }
}

      if (a8)
      {
        uint64_t v30 = 0LL;
        *a8 = v14;
        return v30;
      }

      return 0LL;
    }

    uint64_t v39 = *(unsigned int *)(v12 + 16);
    if ((_DWORD)v39)
    {
      uint64_t v40 = *(void *)(v12 + 24);
      uint64_t v41 = (char *)PF_CALLOC_SCANNED_BYTES(v40);
      memcpy(v41, (const void *)(v12 + 32), v40);
      uint64_t v42 = (objc_class *)objc_opt_class();
      object_setClass(v41 + 8, v42);
      uint64_t v43 = bufferResultSetAllocateWithBuffer(v40, (uint64_t)v41);
      *((_DWORD *)v43 + 10) |= 2u;
      uint64_t v44 = (void *)[a3 propertiesToFetch];
      if (![v44 count])
      {
        uint64_t v45 = (void *)[a3 entity];
        unint64_t v46 = v45 ? (void *)objc_msgSend((id)objc_msgSend(v45, "propertiesByName"), "allKeys") : 0;
        uint64_t v44 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(v46, "count"));
        uint64_t v63 = 0u;
        uint64_t v64 = 0u;
        v65 = 0u;
        unint64_t v66 = 0u;
        unint64_t v47 = [v46 countByEnumeratingWithState:&v63 objects:v67 count:16];
        if (v47)
        {
          unint64_t v48 = v47;
          id v49 = *(void *)v64;
          do
          {
            for (i = 0LL; i != v48; ++i)
            {
              if (*(void *)v64 != v49) {
                objc_enumerationMutation(v46);
              }
              uint64_t v51 = *(void *)(*((void *)&v63 + 1) + 8 * i);
              uint64_t v52 = (void *)[a3 entity];
              if (v52)
              {
                uint64_t v53 = (void *)objc_msgSend((id)objc_msgSend(v52, "propertiesByName"), "objectForKey:", v51);
                if (v53)
                {
                  __int16 v54 = v53;
                  if (([v53 isTransient] & 1) == 0 && (objc_msgSend(v54, "_isRelationship") & 1) == 0) {
                    [v44 addObject:v54];
                  }
                }
              }
            }

            unint64_t v48 = [v46 countByEnumeratingWithState:&v63 objects:v67 count:16];
          }

          while (v48);
        }
      }

      unint64_t v55 =  -[NSKnownKeysMappingStrategy initForKeys:]( [NSKnownKeysMappingStrategy alloc],  "initForKeys:",  [v44 valueForKey:@"name"]);
      __int16 v56 = [v44 count];
      unint64_t v57 = v56;
      if (v56 <= 1) {
        __int16 v58 = 1LL;
      }
      else {
        __int16 v58 = v56;
      }
      if (v56 >= 0x201) {
        unint64_t v59 = 1LL;
      }
      else {
        unint64_t v59 = v58;
      }
      uint64_t v60 = (char *)&v63 - ((8 * v59 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      if (v56 > 0x200) {
        uint64_t v60 = (char *)NSAllocateScannedUncollectable();
      }
      else {
        bzero((char *)&v63 - ((8 * v59 + 15) & 0xFFFFFFFFFFFFFFF0LL), 8 * v58);
      }
      if ([v44 count])
      {
        uint64_t v61 = 0LL;
        do
        {
          *(void *)&v60[8 * v61] = [v44 objectAtIndexedSubscript:v61];
          ++v61;
        }

        while ([v44 count] > v61);
      }

      uint64_t v62 = -[NSKnownKeysDictionary initWithSearchStrategy:]( objc_alloc(&OBJC_CLASS___NSKnownKeysDictionary),  "initWithSearchStrategy:",  v55);
      -[NSKnownKeysDictionary setValues:](v62, "setValues:", v60);
      if (v57 >= 0x201) {
        NSZoneFree(0LL, v60);
      }
      uint64_t v30 = -[_PFResultArray initWithObjects:count:store:metadata:]( objc_alloc(&OBJC_CLASS____PFResultArray),  "initWithObjects:count:store:metadata:",  v43,  v39,  a5,  v62);

      return v30;
    }
  }

  return (_PFResultArray *)(id)NSArray_EmptyArray;
}

  [v6 drain];
  return v10;
}

    uint64_t v8 = 0LL;
    unint64_t v9 = 0;
    unint64_t v10 = self;
    while (v10 != v4)
    {
      if (v10 == v8) {
        goto LABEL_20;
      }
      if (!v8) {
        uint64_t v8 = v10;
      }
      unint64_t v10 = (NSPersistentStoreCoordinator *)atomic_load((unint64_t *)&v10->_queueOwner);
      if (!v10) {
        goto LABEL_22;
      }
    }

    unint64_t v9 = 1;
LABEL_20:
    if (v9) {
      goto LABEL_21;
    }
  }

      uint64_t v8 = 0LL;
      unint64_t v9 = 0;
      while (v2 != v4)
      {
        if (v2 == v8) {
          goto LABEL_20;
        }
        if (!v8) {
          uint64_t v8 = v2;
        }
        unint64_t v2 = atomic_load((unint64_t *)(v2 + 8));
        if (!v2) {
          goto LABEL_22;
        }
      }

      unint64_t v9 = 1;
LABEL_20:
      if (v9) {
        goto LABEL_21;
      }
    }

      v102 = v14;
      if ([v13 count])
      {
        v108 = 0u;
        v109 = 0u;
        v106 = 0u;
        v107 = 0u;
        v103 = [v13 countByEnumeratingWithState:&v106 objects:v131 count:16];
        if (v103)
        {
          v104 = *(void *)v107;
          v101 = v3;
          __int16 v98 = v6;
          unint64_t v99 = v4;
          unint64_t v97 = v9;
          while (2)
          {
            uint64_t v18 = 0LL;
            do
            {
              if (*(void *)v107 != v104) {
                objc_enumerationMutation(v13);
              }
              uint64_t v19 = (void *)[*(id *)(*((void *)&v106 + 1) + 8 * v18) componentsSeparatedByString:@"."];
              uint64_t v20 = [v19 count];
              if (v20)
              {
                uint64_t v21 = v20;
                uint64_t v22 = 0LL;
                uint64_t v23 = v20 - 1;
                uint64_t v24 = v101;
                while (1)
                {
                  unint64_t v25 = (void *)[v19 objectAtIndexedSubscript:v22];
                  if (!v24
                    || (unint64_t v26 = (void *)-[objc_class objectForKey:](v24[1].super.isa, "objectForKey:", v25)) == 0LL)
                  {
                    uint64_t v33 = *MEMORY[0x189603A60];
                    v125[0] = @"derived attribute";
                    v125[1] = @"component";
                    v126[0] = v102;
                    v126[1] = v25;
                    uint64_t v34 = objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  v33,  @"Invalid keypaths found in derived attribute (can't find keypath component)",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", v126, v125, 2));
                    unint64_t v35 = *MEMORY[0x189607460];
                    v123 = @"NSUnderlyingException";
                    v124 = v34;
                    unint64_t v36 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v35,  134097,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v124, &v123, 1));
                    if (v36) {
                      goto LABEL_47;
                    }
                    unint64_t v37 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
                    _NSCoreDataLog( 17LL,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m");
                    uint64_t v44 = (os_log_s *)__pflogFaultLog;
                    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315394;
                      v137 = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m";
                      v138 = 1024;
                      v139 = 1546;
                      goto LABEL_65;
                    }

                    return 0LL;
                  }

                  unint64_t v27 = v26;
                  uint64_t v28 = objc_msgSend((id)objc_msgSend(v26, "propertyDescription"), "_propertyType");
                  if (v28 == 6)
                  {
                    uint64_t v45 = *MEMORY[0x189603A60];
                    v121 = @"derived attribute";
                    v122 = v102;
                    unint64_t v46 = objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  v45,  @"Invalid keypaths found in derived attribute (derived attribute found in dependency chain)",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v122, &v121, 1));
                    unint64_t v47 = *MEMORY[0x189607460];
                    v119 = @"NSUnderlyingException";
                    v120 = v46;
                    unint64_t v36 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v47,  134097,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v120, &v119, 1));
                    if (v36) {
                      goto LABEL_47;
                    }
                    unint64_t v48 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
                    _NSCoreDataLog( 17LL,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m");
                    uint64_t v44 = (os_log_s *)__pflogFaultLog;
                    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315394;
                      v137 = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m";
                      v138 = 1024;
                      v139 = 1553;
                      goto LABEL_65;
                    }

                    return 0LL;
                  }

                  if (v23 == v22)
                  {
                    uint64_t v29 = -[NSSQLEntity derivedAttributesExtension](v24);
                    -[NSSQLEntity_DerivedAttributesExtension addDerivationKeypath:forAttribute:]((uint64_t)v29, v19, v12);
                  }

                  else if (v28 == 2)
                  {
                    if ((objc_msgSend( (id)objc_msgSend(v19, "objectAtIndexedSubscript:", v22 + 1),  "hasPrefix:",  @"@") & 1) == 0)
                    {
                      unint64_t v66 = *MEMORY[0x189603A60];
                      v117 = @"derived attribute";
                      v118 = v102;
                      uint64_t v67 = objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  v66,  @"Invalid keypaths found in derived attribute (non-terminal attribute not followed by a function)",  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjects:forKeys:count:",  &v118,  &v117,  1));
                      uint64_t v68 = *MEMORY[0x189607460];
                      v115 = @"NSUnderlyingException";
                      v116 = v67;
                      unint64_t v36 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v68,  134097,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjects:forKeys:count:",  &v116,  &v115,  1));
                      if (v36) {
                        goto LABEL_47;
                      }
                      uint64_t v69 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
                      _NSCoreDataLog( 17LL,  v69,  v70,  v71,  v72,  v73,  v74,  v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m");
                      uint64_t v44 = (os_log_s *)__pflogFaultLog;
                      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 136315394;
                        v137 = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m";
                        v138 = 1024;
                        v139 = 1566;
                        goto LABEL_65;
                      }

                      return 0LL;
                    }
                  }

                  else if (v28 == 4)
                  {
                    uint64_t v24 = (NSSQLEntity_DerivedAttributesExtension *)[v27 destinationEntity];
                  }

                  if (v21 == ++v22) {
                    goto LABEL_35;
                  }
                }

                if ([@"@count" caseInsensitiveCompare:v25])
                {
                  if (v24)
                  {
                    uint64_t v30 = -[NSSQLEntity derivedAttributesExtension](v24);
                    -[NSSQLEntity_DerivedAttributesExtension addDerivationKeypath:forAttribute:]((uint64_t)v30, v19, v12);
                  }

                  goto LABEL_35;
                }

                unint64_t v87 = *MEMORY[0x189603A60];
                v129 = @"derived attribute";
                v130 = v102;
                unint64_t v88 = objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  v87,  @"Invalid keypaths found in derived attribute (unsupported function)",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v130, &v129, 1));
                v89 = *MEMORY[0x189607460];
                v127 = @"NSUnderlyingException";
                v128 = v88;
                unint64_t v36 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v89,  134097,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v128, &v127, 1));
                if (v36) {
                  goto LABEL_47;
                }
                v90 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
                _NSCoreDataLog( 17LL,  v90,  v91,  v92,  v93,  v94,  v95,  v96,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m");
                uint64_t v44 = (os_log_s *)__pflogFaultLog;
                if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136315394;
                  v137 = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m";
                  v138 = 1024;
                  v139 = 1535;
                  goto LABEL_65;
                }

                return 0LL;
              }

  [v18 appendString:@""]);
  return v18;
}

    v292 = 0;
LABEL_14:
    unint64_t v14 = 3;
    while (1)
    {
      v294 = v14 >= 0;
      if (v14 < 0) {
        return v294;
      }
      v296 = v14;
      context = (void *)MEMORY[0x186E3E5D8]();
      -[NSSQLiteConnection connect]((uint64_t)v302);
      if (v302[9]) {
        break;
      }
      v288 = 0;
LABEL_179:
      -[NSSQLiteConnection endFetchAndRecycleStatement:]((uint64_t)v302, 0);
      objc_autoreleasePoolPop(context);
      unint64_t v14 = v296 - 1;
      if ((v288 & 1) != 0) {
        return v294;
      }
    }

    unint64_t v15 = (void *)[MEMORY[0x189603FE0] set];
    unint64_t v16 = -[NSSQLiteConnection fetchCreationSQLForType:containing:]((uint64_t)v302, (uint64_t)@"table", 0LL);
    obj = (id)[MEMORY[0x189603FA8] array];
    v333 = 0u;
    v334 = 0u;
    v331 = 0u;
    v332 = 0u;
    unint64_t v17 = [v16 countByEnumeratingWithState:&v331 objects:v371 count:16];
    if (v17)
    {
      uint64_t v18 = *(void *)v332;
      do
      {
        for (i = 0LL; i != v17; ++i)
        {
          if (*(void *)v332 != v18) {
            objc_enumerationMutation(v16);
          }
          uint64_t v20 = *(void **)(*((void *)&v331 + 1) + 8 * i);
          if ([v20 count] == 2
            && objc_msgSend((id)objc_msgSend(v20, "lastObject"), "containsString:", @"_DEFERRED_"))
          {
            objc_msgSend(obj, "addObject:", objc_msgSend(v20, "firstObject"));
          }
        }

        unint64_t v17 = [v16 countByEnumeratingWithState:&v331 objects:v371 count:16];
      }

      while (v17);
    }

    v329 = 0u;
    v330 = 0u;
    v327 = 0u;
    v328 = 0u;
    uint64_t v21 = [obj countByEnumeratingWithState:&v327 objects:v370 count:16];
    if (v21)
    {
      v297 = *(void *)v328;
      do
      {
        uint64_t v22 = 0LL;
        do
        {
          if (*(void *)v328 != v297) {
            objc_enumerationMutation(obj);
          }
          uint64_t v23 = *(void *)(*((void *)&v327 + 1) + 8 * v22);
          v323 = 0u;
          v324 = 0u;
          v325 = 0u;
          v326 = 0u;
          uint64_t v24 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v302, "adapter"), "sqlCore"), "model");
          if (v24) {
            unint64_t v25 = *(void **)(v24 + 32);
          }
          else {
            unint64_t v25 = 0LL;
          }
          unint64_t v26 = [v25 countByEnumeratingWithState:&v323 objects:v369 count:16];
          if (v26)
          {
            unint64_t v27 = *(void *)v324;
            do
            {
              for (j = 0LL; j != v26; ++j)
              {
                if (*(void *)v324 != v27) {
                  objc_enumerationMutation(v25);
                }
                uint64_t v29 = *(void *)(*((void *)&v323 + 1) + 8 * j);
                if (v29
                  && !*(void *)(v29 + 160)
                  && objc_msgSend( (id)objc_msgSend(*(id *)(*((void *)&v323 + 1) + 8 * j), "tableName"),  "isEqualToString:",  v23))
                {
                  [v15 addObject:v29];
                }
              }

              unint64_t v26 = [v25 countByEnumeratingWithState:&v323 objects:v369 count:16];
            }

            while (v26);
          }

          ++v22;
        }

        while (v22 != v21);
        uint64_t v30 = [obj countByEnumeratingWithState:&v327 objects:v370 count:16];
        uint64_t v21 = v30;
      }

      while (v30);
    }

    uint64_t v31 = (void *)[v15 allObjects];
    if (![v31 count])
    {
LABEL_177:
      v288 = 1;
      goto LABEL_179;
    }

    uint64_t v32 = v31;
    if ((a2 & 1) == 0) {
      uint64_t v32 = (void *)objc_msgSend(MEMORY[0x189603F18], "arrayWithObject:", objc_msgSend(v31, "firstObject"));
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    uint64_t v34 = v33;
    obja = (id)[MEMORY[0x189603FC8] dictionary];
    if (v301)
    {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning lightweight migration on connection",  v35,  v36,  v37,  v38,  v39,  v40,  v290);
      if ((v292 & 1) == 0)
      {
LABEL_58:
        _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning creation of deferred schema migration statements",  v41,  v42,  v43,  v44,  v45,  v46,  v290);
LABEL_59:
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        __int16 v54 = v53;
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Create alter table migration statements",  v47,  v48,  v49,  v50,  v51,  v52,  v290);
        }
        v298 = v31;
        unint64_t v55 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(v32, "count"));
        v337 = 0u;
        v338 = 0u;
        v335 = 0u;
        v336 = 0u;
        __int16 v56 = [v32 countByEnumeratingWithState:&v335 objects:v372 count:16];
        if (v56)
        {
          unint64_t v57 = *(void *)v336;
          do
          {
            for (k = 0LL; k != v56; ++k)
            {
              if (*(void *)v336 != v57) {
                objc_enumerationMutation(v32);
              }
              unint64_t v59 = *(void **)(*((void *)&v335 + 1) + 8 * k);
              v290 = [v59 tableName];
              uint64_t v60 = -[NSSQLiteAdapter newRenameTableStatementFrom:to:]( (NSSQLiteStatement *)[v302 adapter],  objc_msgSend(v59, "tableName"),  objc_msgSend(NSString, "stringWithFormat:", @"_DEFERRED_TEMP__%@"));
              [v55 addObject:v60];
            }

            __int16 v56 = [v32 countByEnumeratingWithState:&v335 objects:v372 count:16];
          }

          while (v56);
        }

        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v368[0] = @"Creation of alter table migration statements";
        v368[1] = [MEMORY[0x189607968] numberWithDouble:v61 - v54];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v368, 2),  @"1.1");
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Create create table migration statements",  v62,  v63,  v64,  v65,  v66,  v67,  v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        uint64_t v69 = v68;
        uint64_t v70 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(v32, "count"));
        v341 = 0u;
        v342 = 0u;
        v339 = 0u;
        v340 = 0u;
        uint64_t v71 = [v32 countByEnumeratingWithState:&v339 objects:v373 count:16];
        if (v71)
        {
          uint64_t v72 = *(void *)v340;
          do
          {
            for (m = 0LL; m != v71; ++m)
            {
              if (*(void *)v340 != v72) {
                objc_enumerationMutation(v32);
              }
              v74 = -[NSSQLiteAdapter newCreateTableStatementForEntity:]( (const __CFString *)[v302 adapter],  *(void **)(*((void *)&v339 + 1) + 8 * m));
              [v70 addObject:v74];
            }

            uint64_t v71 = [v32 countByEnumeratingWithState:&v339 objects:v373 count:16];
          }

          while (v71);
        }

        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v367[0] = @"Creation of create table migration statements";
        v367[1] = [MEMORY[0x189607968] numberWithDouble:v75 - v69];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v367, 2),  @"1.2");
        if (v301) {
          _NSCoreDataLog(4LL, (uint64_t)@"Create insert migration statements", v76, v77, v78, v79, v80, v81, v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        uint64_t v83 = v82;
        v84 = -[NSSQLiteConnection _createInsertStatementsForEntities:](v302, v32);
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v366[0] = @"Creation of insert migration statements";
        v366[1] = [MEMORY[0x189607968] numberWithDouble:v85 - v83];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v366, 2),  @"1.3");
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Create drop table migration statements",  v86,  v87,  v88,  v89,  v90,  v91,  v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        uint64_t v93 = v92;
        __int16 v94 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(v32, "count"));
        v345 = 0u;
        v346 = 0u;
        v343 = 0u;
        v344 = 0u;
        unint64_t v95 = [v32 countByEnumeratingWithState:&v343 objects:v374 count:16];
        if (v95)
        {
          __int16 v96 = *(void *)v344;
          do
          {
            for (n = 0LL; n != v95; ++n)
            {
              if (*(void *)v344 != v96) {
                objc_enumerationMutation(v32);
              }
              v290 = [*(id *)(*((void *)&v343 + 1) + 8 * n) tableName];
              __int16 v98 = -[NSSQLiteAdapter newDropTableStatementForTableNamed:]( (NSSQLiteStatement *)[v302 adapter],  objc_msgSend(NSString, "stringWithFormat:", @"_DEFERRED_TEMP__%@"));
              [v94 addObject:v98];
            }

            unint64_t v95 = [v32 countByEnumeratingWithState:&v343 objects:v374 count:16];
          }

          while (v95);
        }

        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v365[0] = @"Creation of drop table migration statements";
        v365[1] = [MEMORY[0x189607968] numberWithDouble:v99 - v93];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v365, 2),  @"1.4");
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Finished creating deferred schema migration statements",  v100,  v101,  v102,  v103,  v104,  v105,  v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v364[0] = @"Total preparation time for schema migration statements";
        v364[1] = [MEMORY[0x189607968] numberWithDouble:v106 - v54];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v364, 2),  @"1.0");
        if (v301) {
          _NSCoreDataLog(4LL, (uint64_t)@"Beginning formal transaction", v107, v108, v109, v110, v111, v112, v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v114 = v113;
        v115 = v302[2];
        if (v115) {
          [*(id *)(v115 + 216) lock];
        }
        -[NSSQLiteConnection beginTransaction]((uint64_t)v302);
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v117 = v116;
        v363[0] = @"Beginning formal transaction";
        v363[1] = [MEMORY[0x189607968] numberWithDouble:v116 - v114];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v363, 2),  @"2.1");
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Execute alter table statements",  v118,  v119,  v120,  v121,  v122,  v123,  v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v125 = v124;
        v321 = 0u;
        v322 = 0u;
        v319 = 0u;
        v320 = 0u;
        v132 = [v55 countByEnumeratingWithState:&v319 objects:v362 count:16];
        if (v132)
        {
          v133 = *(void *)v320;
          do
          {
            for (ii = 0LL; ii != v132; ++ii)
            {
              if (*(void *)v320 != v133) {
                objc_enumerationMutation(v55);
              }
              v135 = *(void **)(*((void *)&v319 + 1) + 8 * ii);
              if (v301) {
                _NSCoreDataLog( 4LL,  (uint64_t)@"  Execute alter table statement: %@",  v126,  v127,  v128,  v129,  v130,  v131,  *(void *)(*((void *)&v319 + 1) + 8 * ii));
              }
              -[NSSQLiteConnection prepareAndExecuteSQLStatement:]((uint64_t)v302, v135);
            }

            v132 = [v55 countByEnumeratingWithState:&v319 objects:v362 count:16];
          }

          while (v132);
        }

        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v361[0] = @"Execute alter table statements";
        v361[1] = [MEMORY[0x189607968] numberWithDouble:v136 - v125];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v361, 2),  @"2.2");
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Execute create table statements",  v137,  v138,  v139,  v140,  v141,  v142,  v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v144 = v143;
        v317 = 0u;
        v318 = 0u;
        v315 = 0u;
        v316 = 0u;
        v151 = [v70 countByEnumeratingWithState:&v315 objects:v360 count:16];
        if (v151)
        {
          v152 = *(void *)v316;
          do
          {
            for (jj = 0LL; jj != v151; ++jj)
            {
              if (*(void *)v316 != v152) {
                objc_enumerationMutation(v70);
              }
              v154 = *(void **)(*((void *)&v315 + 1) + 8 * jj);
              if (v301) {
                _NSCoreDataLog( 4LL,  (uint64_t)@"  Execute create table statement: %@",  v145,  v146,  v147,  v148,  v149,  v150,  *(void *)(*((void *)&v315 + 1) + 8 * jj));
              }
              -[NSSQLiteConnection prepareAndExecuteSQLStatement:]((uint64_t)v302, v154);
            }

            v151 = [v70 countByEnumeratingWithState:&v315 objects:v360 count:16];
          }

          while (v151);
        }

        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v359[0] = @"Execute create table statements";
        v359[1] = [MEMORY[0x189607968] numberWithDouble:v155 - v144];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v359, 2),  @"2.3");
        if (v301) {
          _NSCoreDataLog(4LL, (uint64_t)@"Execute insert statements", v156, v157, v158, v159, v160, v161, v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v163 = v162;
        v313 = 0u;
        v314 = 0u;
        v311 = 0u;
        v312 = 0u;
        v170 = [v84 countByEnumeratingWithState:&v311 objects:v358 count:16];
        if (v170)
        {
          v171 = *(void *)v312;
          do
          {
            for (kk = 0LL; kk != v170; ++kk)
            {
              if (*(void *)v312 != v171) {
                objc_enumerationMutation(v84);
              }
              v173 = *(void **)(*((void *)&v311 + 1) + 8 * kk);
              if (v301) {
                _NSCoreDataLog( 4LL,  (uint64_t)@"  Execute insert statement: %@",  v164,  v165,  v166,  v167,  v168,  v169,  *(void *)(*((void *)&v311 + 1) + 8 * kk));
              }
              -[NSSQLiteConnection prepareAndExecuteSQLStatement:]((uint64_t)v302, v173);
            }

            v170 = [v84 countByEnumeratingWithState:&v311 objects:v358 count:16];
          }

          while (v170);
        }

        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v357[0] = @"Execute insert statements";
        v357[1] = [MEMORY[0x189607968] numberWithDouble:v174 - v163];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v357, 2),  @"2.4");
        if (v301) {
          _NSCoreDataLog(4LL, (uint64_t)@"Execute drop table statements", v175, v176, v177, v178, v179, v180, v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v182 = v181;
        v309 = 0u;
        v310 = 0u;
        v307 = 0u;
        v308 = 0u;
        v189 = [v94 countByEnumeratingWithState:&v307 objects:v356 count:16];
        if (v189)
        {
          v190 = *(void *)v308;
          do
          {
            for (mm = 0LL; mm != v189; ++mm)
            {
              if (*(void *)v308 != v190) {
                objc_enumerationMutation(v94);
              }
              v192 = *(void **)(*((void *)&v307 + 1) + 8 * mm);
              if (v301) {
                _NSCoreDataLog( 4LL,  (uint64_t)@"  Execute drop table statement: %@",  v183,  v184,  v185,  v186,  v187,  v188,  *(void *)(*((void *)&v307 + 1) + 8 * mm));
              }
              -[NSSQLiteConnection prepareAndExecuteSQLStatement:]((uint64_t)v302, v192);
            }

            v189 = [v94 countByEnumeratingWithState:&v307 objects:v356 count:16];
          }

          while (v189);
        }

        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v355[0] = @"Execute drop table statements";
        v355[1] = [MEMORY[0x189607968] numberWithDouble:v193 - v182];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v355, 2),  @"2.5");
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Execute create indexes statements",  v194,  v195,  v196,  v197,  v198,  v199,  v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v201 = v200;
        -[NSSQLiteConnection _createIndexesForEntities:](v302, v32);
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v354[0] = @"Execute create indexes statements";
        v354[1] = [MEMORY[0x189607968] numberWithDouble:v202 - v201];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v354, 2),  @"2.6");
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Execute create trigger statements",  v203,  v204,  v205,  v206,  v207,  v208,  v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v210 = v209;
        v211 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v302, "adapter"), "sqlCore"), "model");
        if (v211) {
          v212 = *(void **)(v211 + 32);
        }
        else {
          v212 = 0LL;
        }
        -[NSSQLiteConnection createTriggersForEntities:]((uint64_t)v302, v212);
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v353[0] = @"Execute create trigger statements";
        v353[1] = [MEMORY[0x189607968] numberWithDouble:v213 - v210];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v353, 2),  @"2.7");
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v221 = v220;
        if (v301) {
          _NSCoreDataLog(4LL, (uint64_t)@"Updating metadata", v214, v215, v216, v217, v218, v219, v290);
        }
        v222 = (void *)MEMORY[0x189603FC8];
        -[NSSQLiteConnection fetchMetadata]((uint64_t)v302);
        v224 = (__CFString *)[v222 dictionaryWithDictionary:v223];
        if ((a2 & 1) != 0 || (unint64_t)[v298 count] < 2) {
          -[__CFString removeObjectForKey:]( v224,  "removeObjectForKey:",  @"NSPersistentStoreDeferredLightweightMigrationOptionKey");
        }
        else {
          -[__CFString setValue:forKey:]( v224,  "setValue:forKey:",  MEMORY[0x189604A88],  @"NSPersistentStoreDeferredLightweightMigrationOptionKey");
        }
        -[NSSQLiteConnection saveMetadata:](v302, v224);
        if (v301) {
          _NSCoreDataLog(4LL, (uint64_t)@"Finished updating metadata", v225, v226, v227, v228, v229, v230, v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v232 = v231;
        v352[0] = @"Update store metadata";
        v352[1] = [MEMORY[0x189607968] numberWithDouble:v231 - v221];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v352, 2),  @"2.15");
        if (v301) {
          _NSCoreDataLog(4LL, (uint64_t)@"Committing formal transaction", v233, v234, v235, v236, v237, v238, v290);
        }
        -[NSSQLiteConnection commitTransaction]((uint64_t)v302);
        if (v301) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Finished committing formal transaction",  v239,  v240,  v241,  v242,  v243,  v244,  v290);
        }
        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v246 = v245;
        v351[0] = @"Time for COMMIT";
        v351[1] = [MEMORY[0x189607968] numberWithDouble:v245 - v232];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v351, 2),  @"2.16");
        v350[0] = @"Total formal transaction time";
        v350[1] = [MEMORY[0x189607968] numberWithDouble:v246 - v117];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v350, 2),  @"2.0");
        if (v301) {
          _NSCoreDataLog(4LL, (uint64_t)@"Checkpointing WAL journal", v247, v248, v249, v250, v251, v252, v290);
        }
        v253 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:]((uint64_t)v302, @"pragma wal_checkpoint(FULL)");
        if (v253) {
          CFRelease(v253);
        }
        v260 = v302[2];
        if (v260) {
          [*(id *)(v260 + 216) unlock];
        }
        if (v301)
        {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Finished checkpointing WAL journal",  v254,  v255,  v256,  v257,  v258,  v259,  v290);
          _NSCoreDataLog( 4LL,  (uint64_t)@"Successfully completed deferred lightweight migration on connection",  v261,  v262,  v263,  v264,  v265,  v266,  v291);
          if ((v292 & 1) != 0)
          {
            _NSCoreDataLog(4LL, (uint64_t)@"Reset SQLite cache size", v267, v268, v269, v270, v271, v272, v290);
LABEL_166:
            -[NSSQLiteConnection _executeSQLString:]((uint64_t)v302, @"pragma cache_size = 512");
          }
        }

        else if ((v292 & 1) != 0)
        {
          goto LABEL_166;
        }

        [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
        v274 = v273;
        v349[0] = @"Checkpoint time";
        v349[1] = [MEMORY[0x189607968] numberWithDouble:v273 - v246];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v349, 2),  @"3.0");
        v348[0] = @"Total migration time (on connection)";
        v348[1] = [MEMORY[0x189607968] numberWithDouble:v274 - v34];
        objc_msgSend( obja,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v348, 2),  @"0.0");
        if (v301)
        {
          v275 = (void *)objc_msgSend( (id)objc_msgSend(obja, "allKeys"),  "sortedArrayUsingSelector:",  sel_localizedStandardCompare_);
          v305 = 0u;
          v306 = 0u;
          v303 = 0u;
          v304 = 0u;
          v276 = [v275 countByEnumeratingWithState:&v303 objects:v347 count:16];
          if (v276)
          {
            v277 = *(void *)v304;
            do
            {
              for (nn = 0LL; nn != v276; ++nn)
              {
                if (*(void *)v304 != v277) {
                  objc_enumerationMutation(v275);
                }
                v279 = *(void *)(*((void *)&v303 + 1) + 8 * nn);
                v280 = (void *)[obja objectForKey:v279];
                [v280 firstObject];
                objc_msgSend((id)objc_msgSend(v280, "lastObject"), "doubleValue");
                if (v287 > 0.01) {
                  _NSCoreDataLog( 4LL,  (uint64_t)@"    Deferred Migration step %@ '%@' took %2.2f seconds",  v281,  v282,  v283,  v284,  v285,  v286,  v279);
                }
              }

              v276 = [v275 countByEnumeratingWithState:&v303 objects:v347 count:16];
            }

            while (v276);
          }
        }

        goto LABEL_177;
      }

      _NSCoreDataLog(4LL, (uint64_t)@"Increasing SQLite cache size to 148MB", v41, v42, v43, v44, v45, v46, v290);
    }

    else if ((v292 & 1) == 0)
    {
      goto LABEL_59;
    }

    -[NSSQLiteConnection _executeSQLString:]((uint64_t)v302, @"pragma cache_size = 38000");
    if (!v301) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }

  return 0;
}

  if (!a4 || (a5 & 1) != 0)
  {
    if ((a4 & 1) == 0 && (a5 & 1) == 0)
    {
      [a7 setValue:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", @"Unimplemented SQL generatio for predicate (%@)", a1[2]), 0), @"NSUnderlyingException" forKey];
      return 0LL;
    }
  }

  else
  {
    v17 |= 0xCuLL;
  }

        v59[5] = 0LL;
        v53[5] = 0LL;
        goto LABEL_13;
      }

      unint64_t v17 = v53[5];
      if (v16)
      {
        if (!v17
          || !-[PFCloudKitStoreComparer isValue:equalToValue:forAttribute:](self, "isValue:equalToValue:forAttribute:"))
        {
LABEL_19:
          uint64_t v21 = (void *)MEMORY[0x189607870];
          uint64_t v22 = *MEMORY[0x1896075F0];
          v69[0] = @"Attribute values do not match.";
          v68[0] = v22;
          v68[1] = @"storeObjectID";
          v69[1] = [a3 objectID];
          v68[2] = @"otherStoreObjectID";
          v69[2] = [a4 objectID];
          v68[3] = [NSString stringWithFormat:@"store-%@", objc_msgSend(v12, "name")];
          uint64_t v23 = (const __CFString *)v59[5];
          if (!v23) {
            uint64_t v23 = @"nil";
          }
          v69[3] = v23;
          v68[4] = [NSString stringWithFormat:@"otherStore-%@", objc_msgSend(v12, "name")];
          uint64_t v24 = (const __CFString *)v53[5];
          if (!v24) {
            uint64_t v24 = @"nil";
          }
          v69[4] = v24;
          unint64_t v25 = [MEMORY[0x189603F68] dictionaryWithObjects:v69 forKeys:v68 count:5];
          uint64_t v33 = [v21 errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:v25];
          goto LABEL_24;
        }

        goto LABEL_12;
      }

      if (v17) {
        goto LABEL_19;
      }
LABEL_13:
      ++v11;
    }

    while (v8 != v11);
    uint64_t v18 = [obj countByEnumeratingWithState:&v48 objects:v72 count:16];
    uint64_t v8 = v18;
  }

  while (v18);
LABEL_18:
  uint64_t v19 = 0LL;
  uint64_t v20 = 1;
LABEL_25:

  v59[5] = 0LL;
  v53[5] = 0LL;
  if (!v20)
  {
    if (v19)
    {
      if (a5) {
        *a5 = v19;
      }
    }

    else
    {
      uint64_t v34 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitStoreComparer.m");
      uint64_t v41 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        v65 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitStoreComparer.m";
        unint64_t v66 = 1024;
        uint64_t v67 = 468;
        _os_log_fault_impl( &dword_186681000,  v41,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }
  }

  _Block_object_dispose(&v52, 8);
  _Block_object_dispose(&v58, 8);
  return v20;
}

uint64_t _sqlCoreLookupSQLEntityForEntityDescription(void *a1, void *a2)
{
  uint64_t v2 = 0LL;
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = _sqlEntityForEntityDescription([a1 model], a2);
      if (!v2)
      {
        id v5 = (id)[a1 ancillarySQLModels];
        __int128 v12 = 0u;
        __int128 v13 = 0u;
        __int128 v14 = 0u;
        __int128 v15 = 0u;
        uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v6)
        {
          uint64_t v7 = v6;
          uint64_t v8 = *(void *)v13;
          while (2)
          {
            for (uint64_t i = 0LL; i != v7; ++i)
            {
              if (*(void *)v13 != v8) {
                objc_enumerationMutation(v5);
              }
              uint64_t v10 = _sqlEntityForEntityDescription( [v5 objectForKey:*(void *)(*((void *)&v12 + 1) + 8 * i)],  a2);
              if (v10)
              {
                uint64_t v2 = v10;
                goto LABEL_14;
              }
            }

            uint64_t v7 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
            if (v7) {
              continue;
            }
            break;
          }
        }

        uint64_t v2 = 0LL;
LABEL_14:
      }
    }
  }

  return v2;
}

uint64_t _sqlEntityForEntityDescription(uint64_t a1, void *a2)
{
  uint64_t result = 0LL;
  if (a1 && a2)
  {
    uint64_t v5 = objc_msgSend((id)objc_msgSend(a2, "managedObjectModel"), "_modelsReferenceIDOffset");
    else {
      return 0LL;
    }
  }

  return result;
}

_PFFetchPlanHeader *fetchPlanAllocateInitialize( NSFetchRequest *a1, NSPersistentStore *a2, NSManagedObjectContext *a3)
{
  unint64_t v6 = objc_alloc_init(&OBJC_CLASS____PFFetchPlanHeader);
  v6->fetch_request = a1;
  v6->requested_batch_size = -[NSFetchRequest fetchLimit](a1, "fetchLimit");
  v6->sql_core = a2;
  uint64_t v7 = (NSSQLEntity *)_sqlCoreLookupSQLEntityForEntityDescription(a2, (void *)-[NSFetchRequest entity](a1, "entity"));
  v6->statement_entity = v7;
  v6->sql_model = (NSSQLModel *)-[NSSQLEntity model](v7, "model");
  v6->current_context = a3;
  uint64_t v8 = objc_opt_class();
  if (v8 == objc_opt_class())
  {
    if (a2) {
      unint64_t v9 = (NSSQLRowCache *)-[NSSQLCore rowCacheForGeneration:]( a2,  (void *)-[NSManagedObjectContext _queryGenerationToken](a3, "_queryGenerationToken"));
    }
    else {
      unint64_t v9 = 0LL;
    }
    v6->row_cache = v9;
  }

  v6->entity_for_ek_funptr = (void *)-[NSSQLModel methodForSelector:]( v6->sql_model,  "methodForSelector:",  sel_entityForID_);
  int v10 = -[NSFetchRequest includesPropertyValues](a1, "includesPropertyValues");
  uint64_t v11 = -[NSFetchRequest resultType](a1, "resultType");
  uint64_t v12 = -[NSFetchRequest resultType](a1, "resultType");
  if (-[NSFetchRequest returnsObjectsAsFaults](a1, "returnsObjectsAsFaults")) {
    BOOL v13 = -[NSArray count]( -[NSFetchRequest relationshipKeyPathsForPrefetching](a1, "relationshipKeyPathsForPrefetching"),  "count") != 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (-[NSFetchRequest resultType](a1, "resultType"))
  {
    BOOL v14 = 1;
  }

  else
  {
    uint64_t v15 = -[NSArray count](-[NSFetchRequest propertiesToFetch](a1, "propertiesToFetch"), "count");
    BOOL v14 = v15 == 0;
    if (v15) {
      int v10 = 1;
    }
  }

  statement_entity = v6->statement_entity;
  if (statement_entity)
  {
    subentities = statement_entity->_subentities;
    if (subentities) {
      LODWORD(statement_entity) = -[NSMutableArray count](subentities, "count") != 0;
    }
    else {
      LODWORD(statement_entity) = 0;
    }
  }

  if (v11 == 1) {
    int v18 = 4;
  }
  else {
    int v18 = 16;
  }
  if (v11 != 1 && v12 != 2)
  {
    if ((v14 | v10 ^ 1) == 1)
    {
      if ((v13 & v10) != 0) {
        int v18 = 12;
      }
      else {
        int v18 = 0;
      }
    }

    else
    {
      int v18 = 20;
    }
  }

  if (v12 == 2) {
    int v19 = 1;
  }
  else {
    int v19 = v10;
  }
  if (v19) {
    int v20 = 0;
  }
  else {
    int v20 = 2;
  }
  v6->flags = ($C6D29F7D67899FE11DE7F8953A7C3E5F)(statement_entity | v20 | v18 | *(_DWORD *)&v6->flags & 0x20);
  return v6;
}

void sub_18668A9D0(_Unwind_Exception *a1)
{
}

void sub_18668AA0C(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x18668AA18LL);
  }
  JUMPOUT(0x18668A9F0LL);
}

void sub_18668AAAC(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18668AAB8LL);
  }

  JUMPOUT(0x18668A9F0LL);
}

void sub_18668B118( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

#error "18668B230: call analysis failed (funcsize=25)"
void sub_18668B284(void *exc_buf)
{
  os_unfair_lock_s *v1;
  objc_begin_catch(exc_buf);
  os_unfair_lock_unlock(v1 + 12);
  objc_exception_rethrow();
  __break(1u);
}

void sub_18668B2B4(_Unwind_Exception *a1)
{
}

void sub_18668B428( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18668B4F0(_Unwind_Exception *a1)
{
}

void sub_18668B50C()
{
  if (v2 == 2)
  {
    *(void *)(*(void *)(*(void *)(v0 + 40) + 8LL) + 40LL) = objc_begin_catch(v1);
    objc_end_catch();
    JUMPOUT(0x18668B4C8LL);
  }

  objc_begin_catch(v1);
  JUMPOUT(0x18668B4CCLL);
}

void sub_18668B5E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint8_t buf)
{
}

void sub_18668B954(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  BOOL v5 = v3 != 0;
  if (a2 == 3)
  {
    id v6 = objc_begin_catch(exception_object);
    if (!v2) {
      goto LABEL_8;
    }
  }

  else
  {
    id v6 = objc_begin_catch(exception_object);
    if (a2 != 2)
    {
      uint64_t v8 = (void *)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58] reason:@"Caught a non-object exception in the connectionManager" userInfo:0];
      if (v2) {
        objc_setProperty_nonatomic(v2, v9, v8, 48LL);
      }
      objc_end_catch();
      JUMPOUT(0x18668B830LL);
    }

    if (!v2)
    {
LABEL_8:
      objc_end_catch();
      if (!v5) {
        JUMPOUT(0x18668B854LL);
      }
      JUMPOUT(0x18668B83CLL);
    }
  }

  objc_setProperty_nonatomic(v2, v7, v6, 48LL);
  goto LABEL_8;
}

LABEL_18:
      if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault")) {
        _NSCoreDataLog( 4LL,  (uint64_t)@"Connecting to sqlite database file at %@",  v10,  v11,  v12,  v13,  v14,  v15,  *(void *)(a1 + 32));
      }
      v180 = (char *)v5;
      if ((v7 & 1) != 0)
      {
        unint64_t v16 = 0LL;
      }

      else
      {
        uint64_t v17 = stat(v5, (stat *)&v194);
        unint64_t v16 = *(void *)&v194.f_mntonname[8];
        if (v17) {
          unint64_t v16 = 0LL;
        }
      }

      if (v16) {
        int v18 = v7;
      }
      else {
        int v18 = 1;
      }
      v178 = v18;
      else {
        int v19 = 6;
      }
      v177 = v19;
      int v20 = (void *)objc_msgSend(v169, "objectForKey:");
      if (v20)
      {
        uint64_t v21 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FC8]), "initWithCapacity:", objc_msgSend(v20, "count"));
        v184 = 0u;
        v185 = 0u;
        v182 = 0u;
        v183 = 0u;
        uint64_t v22 = [v20 countByEnumeratingWithState:&v182 objects:v195 count:16];
        if (v22)
        {
          uint64_t v23 = *(void *)v183;
          do
          {
            for (uint64_t i = 0LL; i != v22; ++i)
            {
              if (*(void *)v183 != v23) {
                objc_enumerationMutation(v20);
              }
              unint64_t v25 = *(void **)(*((void *)&v182 + 1) + 8 * i);
              if (v25 != (void *)NSKeyValueCoding_NullValue) {
                objc_msgSend( v21,  "setObject:forKey:",  objc_msgSend(v20, "objectForKey:", *(void *)(*((void *)&v182 + 1) + 8 * i)),  objc_msgSend(v25, "lowercaseString"));
              }
            }

            uint64_t v22 = [v20 countByEnumeratingWithState:&v182 objects:v195 count:16];
          }

          while (v22);
        }

        [*(id *)(a1 + 160) setDictionary:v21];
      }

      [*(id *)(a1 + 160) removeObjectForKey:@"recursive_triggers"];
      if ((v7 & 1) != 0)
      {
        unint64_t v26 = *(_DWORD *)(a1 + 312) & 0xFFFFFFF3;
      }

      else
      {
        if (!statfs(v180, &v194))
        {
          f_flags = v194.f_flags;
          if ((v194.f_flags & 0x1000) != 0)
          {
            v140 = *(_DWORD *)(a1 + 312) & 0xFFFFFFF3 | 4;
          }

          else
          {
            v138 = *(_DWORD *)v194.f_fstypename == 1684170103 && *(_DWORD *)&v194.f_fstypename[3] == 7758180;
            v139 = *(_DWORD *)(a1 + 312);
            if (v138) {
              v140 = v139 | 0xC;
            }
            else {
              v140 = v139 & 0xFFFFFFF3 | 8;
            }
          }

          *(_DWORD *)(a1 + 312) = v140;
          if ((f_flags & 1) != 0) {
            v141 = 1;
          }
          else {
            v141 = v177;
          }
          v177 = v141;
LABEL_46:
          unint64_t v27 = [*(id *)(a1 + 160) objectForKey:@"lock_proxy_file"];
          if (v27 == [MEMORY[0x189603FE8] null])
          {
            uint64_t v28 = *(_DWORD *)(a1 + 312);
          }

          else
          {
            uint64_t v28 = *(_DWORD *)(a1 + 312);
            if (v27 || BYTE1(z9dsptsiQ80etb9782fsrs98bfdle88))
            {
              v177 |= 0x20u;
              v28 |= 0x10u;
              *(_DWORD *)(a1 + 312) = v28;
            }
          }

          *(_DWORD *)(a1 + 312) = v28 & 0xFFFFFFBF;
          uint64_t v29 = [*(id *)(a1 + 160) objectForKey:@"journal_mode"];
          if (byte_18C4ABDB8) {
            uint64_t v30 = @"wal";
          }
          else {
            uint64_t v30 = 0LL;
          }
          if (v29) {
            uint64_t v30 = (const __CFString *)v29;
          }
          uint64_t v31 = *(_DWORD *)(a1 + 312);
          if ((v31 & 8) != 0) {
            uint64_t v32 = @"delete";
          }
          else {
            uint64_t v32 = v30;
          }
          if ((v31 & 0x10) != 0) {
            uint64_t v33 = v30;
          }
          else {
            uint64_t v33 = v32;
          }
          if (objc_msgSend(*(id *)(a1 + 368), "objectForKey:")) {
            uint64_t v34 = @"delete";
          }
          else {
            uint64_t v34 = v33;
          }
          if (v7) {
            unint64_t v35 = @"memory";
          }
          else {
            unint64_t v35 = (__CFString *)v34;
          }
          if (v35 && v35 != (__CFString *)[MEMORY[0x189603FE8] null])
          {
            [*(id *)(a1 + 160) setObject:v35 forKey:@"journal_mode"];
            *(_DWORD *)(a1 + 312) = *(_DWORD *)(a1 + 312) & 0xFFFFFFBF | ((-[__CFString compare:options:]( v35,  "compare:options:",  @"wal",  1LL) == 0) << 6);
          }

          if ((v7 & 1) == 0)
          {
            unint64_t v36 = *(void *)(a1 + 16);
            if (v36)
            {
              unint64_t v36 = (((unint64_t)*(unsigned int *)(v36 + 200) >> 2) & 7) - 1;
              else {
                LODWORD(v36) = dword_1868D617C[v36];
              }
            }

            v177 |= v36;
          }

          if (objc_msgSend((id)objc_msgSend(*(id *)(a1 + 24), "query"), "length"))
          {
            unint64_t v37 = *(void **)(a1 + 24);
            objc_opt_self();
            v180 = (char *)objc_msgSend((id)objc_msgSend(v37, "absoluteString"), "fileSystemRepresentation");
          }

          uint64_t v38 = *(void *)(a1 + 16);
          if (v38) {
            uint64_t v39 = *(void **)(v38 + 248);
          }
          else {
            uint64_t v39 = 0LL;
          }
          uint64_t v40 = +[NSSQLiteConnection openAtPath:withKey:handle:flags:module:checkpointOnClose:]( (uint64_t)&OBJC_CLASS___NSSQLiteConnection,  v180,  v39,  v170,  v177,  0);
          if ((_DWORD)v40)
          {
            uint64_t v42 = *v170;
            if (*v170)
            {
LABEL_270:
              v145 = sqlite3_errmsg(v42);
              goto LABEL_271;
            }
          }

          else
          {
            if ((*(_BYTE *)(a1 + 313) & 8) != 0)
            {
              v167 = 0LL;
              sqlite3_db_config(*v170, 1001);
            }

            if ((v7 & 1) != 0 || (uint64_t v41 = *(void *)(a1 + 16)) != 0 && *(void *)(v41 + 248))
            {
              uint64_t v40 = 0LL;
            }

            else if (readMagicWordFromDBHandle(*v170))
            {
              uint64_t v40 = 26LL;
            }

            else
            {
              uint64_t v40 = 0LL;
            }

            uint64_t v42 = *v170;
            if (*v170 && !(_DWORD)v40)
            {
              if (*(void *)(a1 + 328))
              {
                v167 = 1LL;
                uint64_t v43 = sqlite3_db_config(v42, 1006);
                if ((_DWORD)v43) {
                  _NSCoreDataLog( 1LL,  (uint64_t)@"sqlite3_db_config for SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE failed (_qGTC): %d",  v44,  v45,  v46,  v47,  v48,  v49,  v43);
                }
              }

              if (objc_msgSend( (id)objc_msgSend( v169,  "objectForKey:",  @"NSPersistentStoreServiceConfigurationOptionKey"),  "intValue"))
              {
                v167 = 0LL;
                uint64_t v50 = sqlite3_db_config(*v170, 1001);
                if ((_DWORD)v50) {
                  _NSCoreDataLog( 1LL,  (uint64_t)@"sqlite3_db_config for SQLITE_DBCONFIG_LOOKASIDE failed: %d",  v51,  v52,  v53,  v54,  v55,  v56,  v50);
                }
                -[NSSQLiteConnection _executeSQLString:](a1, @"pragma cache_spill = 64");
              }

              *(void *)(a1 + 304) = objc_alloc_init(MEMORY[0x189603FA8]);
              *(_DWORD *)(a1 + 312) &= ~2u;
              unint64_t v57 = *(dispatch_queue_s **)(a1 + 8);
              if (v57) {
                dispatch_assert_queue_V2(v57);
              }
              if (NSSQLiteRegisterFunctions(*(sqlite3 **)(a1 + 72), (void **)a1))
              {
                objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58] reason:@"An internal error occurred while configuring functions in the SQLite database." userInfo:0]);
                goto LABEL_288;
              }

              sqlite3_extended_result_codes(*(sqlite3 **)(a1 + 72), 1);
              -[NSSQLiteConnection _restoreBusyTimeOutSettings](a1);
              *(_DWORD *)(a1 + 312) |= 0x80u;
              if ((v177 & 1) == 0) {
                [*(id *)(a1 + 160) objectForKey:@"synchronous"];
              }
              if ((v178 & 1) != 0) {
                __int16 v58 = 1;
              }
              else {
                __int16 v58 = -[NSSQLiteConnection _hasTableWithName:isTemp:](a1, (uint64_t)@"Z_METADATA", 0) ^ 1;
              }
              unint64_t v59 = (void *)[*(id *)(a1 + 160) objectForKey:@"integrity_check"];
              if ([v59 isNSString])
              {
                if (([v59 isEqualToString:@"1"] & 1) != 0
                  || ![v59 caseInsensitiveCompare:@"YES"])
                {
                  goto LABEL_108;
                }
              }

              else if (v59 == (void *)[MEMORY[0x189603FE8] null])
              {
LABEL_108:
                objc_msgSend( *(id *)(a1 + 160),  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603FE8], "null"),  @"integrity_check");
LABEL_111:
                if (!v58)
                {
                  objc_msgSend( *(id *)(a1 + 160),  "setValue:forKey:",  objc_msgSend(MEMORY[0x189603FE8], "null"),  @"auto_vacuum");
                  goto LABEL_158;
                }

                if ((v177 & 1) == 0)
                {
                  uint64_t v60 = *(dispatch_queue_s **)(a1 + 8);
                  if (v60) {
                    dispatch_assert_queue_V2(v60);
                  }
                  if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1) {
                    _NSCoreDataLog(4LL, (uint64_t)@"creating schema.", v61, v62, v63, v64, v65, v66, v167);
                  }
                  uint64_t v67 = (void *)[*(id *)(a1 + 16) model];
                  uint64_t v68 = *(void *)(a1 + 16);
                  if (v68) {
                    [*(id *)(v68 + 216) lock];
                  }
                  uint64_t v69 = (void *)[*(id *)(a1 + 160) objectForKey:@"lock_proxy_file"];
                  if (v69
                    && v69 != (void *)[MEMORY[0x189603FE8] null]
                    && ([v69 isEqual:@":auto:"] & 1) == 0)
                  {
                    uint64_t v70 = (NSSQLiteStatement *)[(id)a1 adapter];
                    uint64_t v71 = -[NSSQLiteAdapter newStatementWithSQLString:]( v70,  [NSString stringWithFormat:@"pragma lock_proxy_file='%@'", v69]);
                    -[NSSQLiteConnection prepareAndExecuteSQLStatement:](a1, v71);
                  }

                  uint64_t v72 = *(void **)(a1 + 368);
                  uint64_t v73 = objc_msgSend((id)objc_msgSend(v72, "objectForKey:", 0x189EBA268), "intValue");
                  if (!(_DWORD)v73)
                  {
                    uint64_t v73 = objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v72, "objectForKey:", @"NSSQLitePragmasOption"),  "objectForKey:",  @"page_size"),  "intValue");
                    if (!(_DWORD)v73)
                    {
                      if ((*(_DWORD *)(a1 + 312) & 0xC) == 8) {
                        uint64_t v73 = 0x2000LL;
                      }
                      else {
                        uint64_t v73 = 4096LL;
                      }
                    }
                  }

                  v74 = (NSSQLiteStatement *)[(id)a1 adapter];
                  unint64_t v75 = -[NSSQLiteAdapter newStatementWithSQLString:]( v74,  objc_msgSend(NSString, "stringWithFormat:", @"pragma page_size=%d", v73));
                  -[NSSQLiteConnection prepareAndExecuteSQLStatement:](a1, v75);

                  unint64_t v76 = (__CFString *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend( *(id *)(a1 + 368),  "objectForKey:",  @"NSSQLitePragmasOption"),  "objectForKey:",  @"auto_vacuum"),  "lowercaseString");
                  if (!v76 || v76 == (__CFString *)[MEMORY[0x189603FE8] null]) {
                    unint64_t v76 = @"2";
                  }
                  uint64_t v77 = (void *)[objc_alloc(NSString) initWithFormat:@"pragma auto_vacuum=%@"];
                  uint64_t v78 = -[NSSQLiteAdapter newStatementWithSQLString:]( (NSSQLiteStatement *)[(id)a1 adapter],  (uint64_t)v77);

                  -[NSSQLiteConnection prepareAndExecuteSQLStatement:](a1, v78);
                  if ((-[__CFString isEqualToString:](v76, "isEqualToString:", @"2") & 1) != 0)
                  {
                    uint64_t v79 = 0LL;
                  }

                  else
                  {
                    uint64_t v80 = -[__CFString isEqualToString:](v76, "isEqualToString:", @"incremental");
                    uint64_t v79 = 0x7FFFFFFFFFFFFFFFLL;
                    if (v80) {
                      uint64_t v79 = 0LL;
                    }
                  }

                  *(void *)(a1 + 296) = v79;
                  *(_DWORD *)(a1 + 312) &= ~0x20u;
                  v197 = @"_NSAutoVacuumLevel";
                  v198[0] = v76;
                  -[NSSQLCore _updateAutoVacuumMetadataWithValues:]( *(unsigned __int8 **)(a1 + 16),  (void *)[MEMORY[0x189603F68] dictionaryWithObjects:v198 forKeys:&v197 count:1]);
                  -[NSSQLiteConnection beginTransaction](a1);
                  if (-[NSSQLiteConnection _hasTableWithName:isTemp:]( a1,  (uint64_t)@"Z_METADATA",  0))
                  {
                    -[NSSQLiteConnection commitTransaction](a1);
                    -[NSSQLiteConnection didCreateSchema]((_BYTE *)a1);
                    uint64_t v81 = *(void *)(a1 + 16);
                    if (!v81) {
                      goto LABEL_157;
                    }
                  }

                  else
                  {
                    if (v67) {
                      uint64_t v82 = (void *)v67[4];
                    }
                    else {
                      uint64_t v82 = 0LL;
                    }
                    -[NSSQLiteConnection createTablesForEntities:](a1, v82);
                    uint64_t v83 = *(dispatch_queue_s **)(a1 + 8);
                    if (v83) {
                      dispatch_assert_queue_V2(v83);
                    }
                    if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1) {
                      _NSCoreDataLog( 4LL,  (uint64_t)@"Creating primary key table.",  v84,  v85,  v86,  v87,  v88,  v89,  (uint64_t)v76);
                    }
                    v90 = (NSSQLiteStatement *)[(id)a1 adapter];
                    PrimaryKeyTable = -[NSSQLiteAdapter newCreatePrimaryKeyTableStatement](v90);
                    -[NSSQLiteConnection prepareAndExecuteSQLStatement:](a1, PrimaryKeyTable);

                    if (v67) {
                      v92 = (void *)v67[4];
                    }
                    else {
                      v92 = 0LL;
                    }
                    uint64_t v93 = [v92 count];
                    __int16 v94 = v58;
                    if (v93)
                    {
                      for (j = 0LL; j != v93; ++j)
                      {
                        __int16 v96 = (void *)MEMORY[0x186E3E5D8]();
                        unint64_t v97 = -[NSSQLiteAdapter newPrimaryKeyInitializeStatementForEntity:withInitialMaxPK:]( v90,  [v92 objectAtIndex:j],  0);
                        -[NSSQLiteConnection prepareAndExecuteSQLStatement:](a1, v97);

                        objc_autoreleasePoolPop(v96);
                      }
                    }

                    LOBYTE(v5_Block_object_dispose(va, 8) = v94;
                    -[NSSQLiteConnection createMetadata]((void *)a1);
                    -[NSSQLiteConnection saveMetadata:]( (void *)a1,  (__CFString *)objc_msgSend( *(id *)(a1 + 16),  "_updatedMetadataWithSeed:includeVersioning:",  objc_msgSend(*(id *)(a1 + 16), "metadata"),  1));
                    __int16 v98 = -[NSSQLiteConnection saveCachedModel:](a1, [v67 managedObjectModel]);
                    unint64_t v99 = *(void *)(a1 + 16);
                    if (v99 && (*(_BYTE *)(v99 + 201) & 4) != 0)
                    {
                      uint64_t v100 = (void *)MEMORY[0x186E3E5D8](v98);
                      v101 = objc_msgSend( (id)objc_msgSend(*(id *)(a1 + 16), "ancillarySQLModels"),  "objectForKey:",  @"NSPersistentHistoryTrackingKey");
                      if (v101) {
                        v102 = *(void **)(v101 + 32);
                      }
                      else {
                        v102 = 0LL;
                      }
                      -[NSSQLiteConnection createTablesForEntities:](a1, v102);
                      objc_autoreleasePoolPop(v100);
                      LOBYTE(v5_Block_object_dispose(va, 8) = v94;
                    }

                    -[NSSQLiteConnection commitTransaction](a1);
                    -[NSSQLiteConnection didCreateSchema]((_BYTE *)a1);
                    uint64_t v81 = *(void *)(a1 + 16);
                    if (!v81) {
                      goto LABEL_157;
                    }
                  }

                  [*(id *)(v81 + 216) unlock];
LABEL_157:
                  -[NSSQLiteConnection endFetchAndRecycleStatement:](a1, 0);
LABEL_158:
                  v103 = [*(id *)(a1 + 160) objectForKey:@"page_size"];
                  if (v103)
                  {
                    if (v103 == [MEMORY[0x189603FE8] null]) {
                      v104 = (void *)[NSString stringWithFormat:@"pragma %@", @"page_size"];
                    }
                    else {
                      v104 = (void *)[NSString stringWithFormat:@"pragma %@=%@", @"page_size", v103];
                    }
                    -[NSSQLiteConnection _executeSQLString:](a1, v104);
                  }

                  if ((v177 & 1) == 0) {
                    -[NSSQLiteConnection _executeSQLString:]( a1,  (void *)[NSString stringWithFormat:@"pragma recursive_triggers=1"]);
                  }
                  v171 = (v58 & 1) == 0
                      && [*(id *)(a1 + 368) objectForKey:@"NSSQLiteManualVacuumOption"] != 0;
                  v188 = 0u;
                  v189 = 0u;
                  v186 = 0u;
                  v187 = 0u;
                  obj = *(id *)(a1 + 160);
                  v105 = [obj countByEnumeratingWithState:&v186 objects:v196 count:16];
                  if (v105)
                  {
                    v176 = *(void *)v187;
                    *(void *)&v106 = 138412290LL;
                    v168 = v106;
                    do
                    {
                      v179 = v105;
                      for (k = 0LL; k != v179; ++k)
                      {
                        if (*(void *)v187 != v176) {
                          objc_enumerationMutation(obj);
                        }
                        v108 = *(void **)(*((void *)&v186 + 1) + 8 * k);
                        v109 = [*(id *)(a1 + 160) objectForKey:v108];
                        if ((v177 & 1) != 0
                          && (([v108 isEqualToString:@"journal_mode"] & 1) != 0
                           || ([v108 isEqualToString:@"synchronous"] & 1) != 0)
                          || ([v108 isEqualToString:@"page_size"] & 1) != 0
                          || v171 && ([v108 isEqualToString:@"journal_mode"] & 1) != 0
                          || !+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault")
                          && v109 == [MEMORY[0x189603FE8] null]
                          && ([v108 isEqualToString:@"journal_mode"] & 1) != 0)
                        {
                          continue;
                        }

                        if (![v108 isEqualToString:@"integrity_check"])
                        {
                          if ([v108 isEqualToString:@"lock_proxy_file"])
                          {
                            v127 = [MEMORY[0x189603FE8] null];
                            v128 = (void *)NSString;
                            if (v109 != v127)
                            {
                              v129 = @"pragma %@='%@'";
                              goto LABEL_215;
                            }

                            v132 = @"pragma %@=''";
LABEL_224:
                            v131 = (void *)objc_msgSend(v128, "stringWithFormat:", v132, v108);
                            goto LABEL_225;
                          }

                          if (![v108 isEqualToString:@"auto_vacuum"])
                          {
                            v130 = [MEMORY[0x189603FE8] null];
                            v128 = (void *)NSString;
                            if (v109 == v130)
                            {
                              v132 = @"pragma %@";
                              goto LABEL_224;
                            }

                            v129 = @"pragma %@=%@";
LABEL_215:
                            v131 = (void *)objc_msgSend(v128, "stringWithFormat:", v129, v108, v109);
LABEL_225:
                            -[NSSQLiteConnection _executeSQLString:](a1, v131);
                            continue;
                          }

                          if ([*(id *)(a1 + 16) isReadOnly])
                          {
LABEL_212:
                            *(void *)(a1 + 296) = 0x7FFFFFFFFFFFFFFFLL;
                            continue;
                          }

                          v133 = objc_msgSend( (id)objc_msgSend(*(id *)(a1 + 16), "metadata"),  "objectForKey:",  @"_NSAutoVacuumLevel");
                          if (v133)
                          {
                            v134 = (void *)[*(id *)(a1 + 160) objectForKey:@"auto_vacuum"];
                            if ((void *)[MEMORY[0x189603FE8] null] == v134
                              || (v135 = (void *)[v134 lowercaseString]) == 0)
                            {
                              if (([@"2" isEqualToString:v133] & 1) == 0)
                              {
LABEL_230:
                              }

    if (a6)
    {
      unint64_t v16 = 0LL;
      *a6 = v20;
      goto LABEL_11;
    }

    if (a5)
    {
      BOOL v14 = 0LL;
      *a5 = v18;
      goto LABEL_11;
    }

    self->_hasDate = 1;
  }

  -[NSManagedObject didAccessValueForKey:](self, "didAccessValueForKey:", v3);
  if (v5) {
    CFRelease(v5);
  }
  return v17;
}

  if (a4) {
LABEL_19:
  }
    (*((void (**)(id, void *))a4 + 2))(a4, v15);
LABEL_20:
}

      uint64_t v12 = 0;
    }

    int v10 = [a2 countByEnumeratingWithState:&v64 objects:v73 count:16];
    uint64_t v12 = 0;
  }

  while (v10);
LABEL_20:
  unint64_t v16 = objc_alloc(MEMORY[0x189607940]);
  if (objc_msgSend((id)objc_msgSend(v7, "subentities"), "count")) {
    uint64_t v17 = @"Z_PK, Z_ENT";
  }
  else {
    uint64_t v17 = @"Z_PK";
  }
  int v18 = (void *)objc_msgSend( v16,  "initWithFormat:",  @"SELECT %@, %@ FROM %@ WHERE Z_PK IN ("),  v17,  v8,  objc_msgSend(v48, "tableName");

  id v49 = objc_alloc_init(MEMORY[0x189603FA8]);
  uint64_t v60 = 0u;
  uint64_t v61 = 0u;
  uint64_t v62 = 0u;
  uint64_t v63 = 0u;
  uint64_t v52 = [a2 countByEnumeratingWithState:&v60 objects:v72 count:16];
  if (!v52)
  {
    [v18 appendString:@""]);
    goto LABEL_72;
  }

  __int16 v54 = 1;
  uint64_t v50 = v18;
  uint64_t v51 = *(void *)v61;
  while (2)
  {
    int v19 = 0LL;
    while (2)
    {
      if (*(void *)v61 != v51) {
        objc_enumerationMutation(a2);
      }
      int v20 = *(unsigned __int8 **)(*((void *)&v60 + 1) + 8 * v19);
      objc_opt_self();
      uint64_t v21 = (void *)[v20 propertyDescription];
      uint64_t v22 = [v21 entity];
      __int16 v58 = v21;
      unint64_t v57 = [v21 name];
      uint64_t v23 = v20 != 0LL;
      unint64_t v55 = v19;
      if (!v20)
      {
        unint64_t v27 = 0LL;
        __int16 v56 = 0LL;
        goto LABEL_33;
      }

      uint64_t v24 = v20[24];
      unint64_t v25 = [v20 columnName];
      if (v24 == 7)
      {
        unint64_t v26 = v20;
        if (v20[24] == 3) {
          unint64_t v26 = (unsigned __int8 *)[v20 toOneRelationship];
        }
        __int16 v56 = objc_msgSend((id)objc_msgSend(v26, "propertyDescription"), "name");
        unint64_t v27 = (void *)[v20 foreignKey];
LABEL_33:
        uint64_t v28 = [v27 columnName];
      }

      else
      {
        uint64_t v28 = v25;
        uint64_t v23 = 0;
        __int16 v56 = 0LL;
      }

      uint64_t v29 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189607940]),  "initWithFormat:",  @"SELECT Z_PK FROM %@ WHERE %@ IN ("),  objc_msgSend((id)objc_msgSend(v20, "entity"), "tableName"),  v28;
      uint64_t v30 = objc_alloc_init(MEMORY[0x189603FA8]);
      uint64_t v31 = [v20 sqlType];
      uint64_t v68 = 0u;
      uint64_t v69 = 0u;
      uint64_t v70 = 0u;
      uint64_t v71 = 0u;
      uint64_t v32 = [v59 countByEnumeratingWithState:&v68 objects:v75 count:16];
      if (v32)
      {
        uint64_t v33 = v32;
        uint64_t v34 = *(void *)v69;
        unint64_t v35 = 1;
        do
        {
          for (j = 0LL; j != v33; ++j)
          {
            if (*(void *)v69 != v34) {
              objc_enumerationMutation(v59);
            }
            unint64_t v37 = *(void **)(*((void *)&v68 + 1) + 8 * j);
            if (objc_msgSend((id)objc_msgSend(v37, "entity"), "isKindOfEntity:", v22))
            {
              if ((v35 & 1) == 0) {
                objc_msgSend(v29, "appendString:", @", ");
              }
              if (v30)
              {
                [v29 appendString:@"?"];
                uint64_t v38 = objc_alloc(&OBJC_CLASS___NSSQLBindVariable);
                if (v23) {
                  uint64_t v39 = -[NSSQLBindVariable initWithInt64:sqlType:]( v38,  "initWithInt64:sqlType:",  objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v37, "valueForKey:", v56), "objectID"),  "_referenceData64"),  2);
                }
                else {
                  uint64_t v39 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( v38,  "initWithValue:sqlType:propertyDescription:",  [v37 valueForKey:v57],  v31,  v58);
                }
                uint64_t v40 = (void *)v39;
                [v30 addObject:v39];
              }

              unint64_t v35 = 0;
            }
          }

          uint64_t v33 = [v59 countByEnumeratingWithState:&v68 objects:v75 count:16];
        }

        while (v33);
        [v29 appendString:@""]);
        if ((v35 & 1) != 0)
        {
          uint64_t v41 = 0LL;
          int v18 = v50;
          goto LABEL_54;
        }

        uint64_t v42 = v55;
        if (v30)
        {
          v74[0] = v29;
          v74[1] = v30;
          uint64_t v43 = (void *)MEMORY[0x189603F18];
          uint64_t v44 = 2LL;
        }

        else
        {
          v74[0] = v29;
          uint64_t v43 = (void *)MEMORY[0x189603F18];
          uint64_t v44 = 1LL;
        }

        uint64_t v41 = (void *)[v43 arrayWithObjects:v74 count:v44];
        int v18 = v50;
      }

      else
      {
        [v29 appendString:@""]);
        uint64_t v41 = 0LL;
LABEL_54:
        uint64_t v42 = v55;
      }

      if (v41)
      {
        if ((v54 & 1) == 0) {
          [v18 appendString:@" INTERSECT "];
        }
        objc_msgSend(v18, "appendString:", objc_msgSend(v41, "objectAtIndex:", 0));
        __int16 v54 = 0;
      }

      int v19 = v42 + 1;
      if (v19 != v52) {
        continue;
      }
      break;
    }

    uint64_t v45 = [a2 countByEnumeratingWithState:&v60 objects:v72 count:16];
    uint64_t v52 = v45;
    if (v45) {
      continue;
    }
    break;
  }

  [v18 appendString:@""]);
  if ((v54 & 1) != 0)
  {
LABEL_72:
    unint64_t v46 = 0LL;
    goto LABEL_73;
  }

  unint64_t v46 =  -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  v48,  v18);
LABEL_73:

  -[NSSQLiteAdapter _useModel:]((uint64_t)v46, v49);
  return v46;
}

  int v18 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189607940]), "initWithString:", @" NSCoreDataStringSearch(");
  if ([a3 expressionType] == 2) {
    int v19 = -[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:](a1, a3, a6, a7);
  }
  else {
    int v19 = (id)[a1 _generateSQLForKeyPathExpression:a3 allowToMany:a6 inContext:a7];
  }
  int v20 = v19;
  if (!v19)
  {

    return 0LL;
  }

  [v18 appendString:v19];

  objc_msgSend(v18, "appendString:", @", ");
  uint64_t v21 = -[NSSQLConstantValueIntermediate initWithConstantValue:ofType:inScope:context:]( objc_alloc(&OBJC_CLASS___NSSQLConstantValueIntermediate),  "initWithConstantValue:ofType:inScope:context:",  a2,  5LL,  a1,  a7);
  uint64_t v22 = -[NSSQLConstantValueIntermediate generateSQLStringInContext:](v21, "generateSQLStringInContext:", a7);
  [v18 appendString:v22];

  objc_msgSend(v18, "appendString:", @", ");
  objc_msgSend(v18, "appendFormat:", @"%lu, %u"), v17, (v15 >> 3) & 1);
  return v18;
}

    objc_msgSend( a3,  "failWithError:",  objc_msgSend(MEMORY[0x189607870], "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], 4866, v9));

    uint64_t v4 = 0LL;
    goto LABEL_19;
  }

  return v4;
}

    [v7 setObject:v10 forKey:@"NSCloudKitMirroringDelegateResetSyncReasonKey"];
    goto LABEL_19;
  }

  if (v9 == 134301)
  {
    int v10 = &unk_189F04590;
    goto LABEL_18;
  }

  if (v9 == 134405)
  {
    int v10 = (void *)objc_msgSend( (id)objc_msgSend(a3, "userInfo"),  "objectForKey:",  @"NSCloudKitMirroringDelegateResetSyncReasonKey");
    if (v10) {
      goto LABEL_18;
    }
  }

LABEL_231:
                              *(void *)(a1 + 296) = 0LL;
                              continue;
                            }

                            if ([v135 isEqualToString:v133])
                            {
                              if (([@"2" isEqualToString:v133] & 1) == 0) {
                                goto LABEL_230;
                              }
                              goto LABEL_231;
                            }
                          }

                          *(_DWORD *)(a1 + 312) |= 0x20u;
                          continue;
                        }

                        v110 = *(dispatch_queue_s **)(a1 + 8);
                        if (v110) {
                          dispatch_assert_queue_V2(v110);
                        }
                        v174 = -[NSSQLiteAdapter newStatementWithSQLString:]( (NSSQLiteStatement *)[(id)a1 adapter],  (uint64_t)@"pragma integrity_check");
                        v173 = -[NSSQLColumn initWithColumnName:sqlType:]( objc_alloc(&OBJC_CLASS___NSSQLColumn),  "initWithColumnName:sqlType:",  @"*",  6LL);
                        v172 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v173, 0);
                        -[NSSQLiteConnection prepareSQLStatement:](a1, v174);
                        [(id)a1 execute];
                        -[NSSQLiteConnection setColumnsToFetch:]((void *)a1, v172);
                        v111 = 0;
                        v181 = 1;
                        while (1)
                        {
                          v112 = -[NSSQLiteConnection newFetchedArray](a1);
                          v113 = v112;
                          if (!v112) {
                            break;
                          }
                          v114 = (void *)[v112 objectAtIndex:0];
                          v115 = v114;
                          if (v111 || ([v114 isEqualToString:@"ok"] & 1) == 0)
                          {
                            v181 = 0;
                          }

                          else if ((v181 & 1) != 0)
                          {
                            goto LABEL_201;
                          }

                          if (!+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault")) {
                            break;
                          }
                          v116 = (void *)[v115 componentsSeparatedByString:@"\n"];
                          v192 = 0u;
                          v193 = 0u;
                          v190 = 0u;
                          v191 = 0u;
                          v123 = [v116 countByEnumeratingWithState:&v190 objects:&v194 count:16];
                          if (v123)
                          {
                            v124 = *(void *)v191;
                            do
                            {
                              for (m = 0LL; m != v123; ++m)
                              {
                                if (*(void *)v191 != v124) {
                                  objc_enumerationMutation(v116);
                                }
                                if (*(_BYTE *)(a1 + 42)) {
                                  v126 = @"\x1B[31m\x1B[47mERROR:\x1B[0m\x1B[31m %@\x1B[0m";
                                }
                                else {
                                  v126 = @"%@";
                                }
                                _NSCoreDataLog( 1LL,  (uint64_t)v126,  v117,  v118,  v119,  v120,  v121,  v122,  *(void *)(*((void *)&v190 + 1) + 8 * m));
                              }

                              v123 = [v116 countByEnumeratingWithState:&v190 objects:&v194 count:16];
                            }

                            while (v123);
                          }

          -[NSSQLiteConnection connect]((uint64_t)v156);
          if ((v164 & 1) != 0)
          {
            if ((-[NSSQLiteConnection _hasHistoryTransactionStringTable]((uint64_t)v156) & 1) == 0)
            {
              v186 = [v160 entityNamed:@"TRANSACTIONSTRING"];
              if (v186)
              {
                *(void *)&v299 = v186;
                -[NSSQLiteConnection createTablesForEntities:]( (uint64_t)v156,  (void *)[MEMORY[0x189603F18] arrayWithObjects:&v299 count:1]);
              }
            }
          }

          else
          {
            -[NSSQLiteConnection createMissingHistoryTables]((uint64_t)v156);
            LOBYTE(v174) = 0;
          }

          if ((v174 & 1) == 0) {
            goto LABEL_242;
          }
          goto LABEL_239;
        }

        -[NSSQLiteConnection connect](v76);
        -[NSSQLiteConnection _dropAllDATriggers](v76);
        -[NSSQLCore _rebuildDerivedAttributeTriggerSchemaUsingConnection:recomputeValues:error:](v75, v76);
LABEL_202:
        *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
        goto LABEL_203;
      }

      if (![(id)v75 isReadOnly] && v78 >= 0x385 && v78 <= 0x3BF)
      {
        v255 = v75;
        *(void *)&v299 = 0LL;
        v252 = v76;
        -[NSSQLiteConnection connect](v76);
        -[NSSQLiteConnection _dropAllTriggers](v76);
        if ((-[NSSQLCore _rebuildTriggerSchemaUsingConnection:recomputeValues:error:](v75, v76, (id *)&v299) & 1) == 0)
        {
          unint64_t v88 = v299;
          [(id)v299 userInfo];
          _NSCoreDataLog( 1LL,  (uint64_t)@"Repairing triggers failed with error = %@ and userInfo = %@",  v89,  v90,  v91,  v92,  v93,  v94,  v88);
        }

        v284 = 0LL;
        unint64_t v95 = objc_alloc_init(MEMORY[0x189603FA8]);
        v244 = objc_alloc_init(MEMORY[0x1896077E8]);
        v282 = 0u;
        v283 = 0u;
        v280 = 0u;
        v281 = 0u;
        __int16 v96 = *(void *)(v75 + 104);
        if (v96) {
          unint64_t v97 = *(void **)(v96 + 24);
        }
        else {
          unint64_t v97 = 0LL;
        }
        __int16 v98 = (void *)[v97 allValues];
        unint64_t v99 = [v98 countByEnumeratingWithState:&v280 objects:&v285 count:16];
        obj = v98;
        if (v99)
        {
          v247 = *(void *)v281;
          v250 = 1;
          while (2)
          {
            uint64_t v100 = 0LL;
            v246 = v99;
            do
            {
              if (*(void *)v281 != v247) {
                objc_enumerationMutation(obj);
              }
              v248 = v100;
              v101 = *(void **)(*((void *)&v280 + 1) + 8 * v100);
              v276 = 0u;
              v277 = 0u;
              v278 = 0u;
              v279 = 0u;
              v102 = (void *)objc_msgSend((id)objc_msgSend(v101, "entityDescription"), "properties");
              v103 = [v102 countByEnumeratingWithState:&v276 objects:buf count:16];
              v253 = v102;
              if (v103)
              {
                v254 = *(void *)v277;
LABEL_117:
                v104 = 0LL;
                while (1)
                {
                  if (*(void *)v277 != v254) {
                    objc_enumerationMutation(v253);
                  }
                  v105 = *(void **)(*((void *)&v276 + 1) + 8 * v104);
                  if ([v105 _propertyType] == 2 && !objc_msgSend(v105, "attributeType"))
                  {
                    if ([v105 isTransient])
                    {
                      v106 = objc_msgSend( (id)objc_msgSend( -[NSEntityDescription _attributeNamed:]( objc_msgSend(v101, "entityDescription"),  objc_msgSend(v105, "name")),  "userInfo"),  "objectForKey:",  @"_NSLocationAttributeDerivedComponents");
                      if (v106)
                      {
                        v107 = -[NSSQLLocationAttributeRTreeExtension initWithObjectFromUserInfo:onAttributeNamed:onEntity:]( [NSSQLLocationAttributeRTreeExtension alloc],  "initWithObjectFromUserInfo:onAttributeNamed:onEntity:",  v106,  [v105 name],  v101);
                        v108 = v107;
                        if (v107)
                        {
                          if (-[NSSQLLocationAttributeRTreeExtension validate:](v107, "validate:", &v284))
                          {
                            v274 = 0u;
                            v275 = 0u;
                            v272 = 0u;
                            v273 = 0u;
                            v251 = v108;
                            v109 = -[NSSQLLocationAttributeRTreeExtension dropSQLStrings](v108, "dropSQLStrings");
                            v110 = -[NSArray countByEnumeratingWithState:objects:count:]( v109,  "countByEnumeratingWithState:objects:count:",  &v272,  &v291,  16LL);
                            if (v110)
                            {
                              v111 = *(void *)v273;
                              do
                              {
                                for (k = 0LL; k != v110; ++k)
                                {
                                  if (*(void *)v273 != v111) {
                                    objc_enumerationMutation(v109);
                                  }
                                  v113 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  v101,  *(void *)(*((void *)&v272 + 1) + 8 * k));
                                  [v95 addObject:v113];
                                }

                                v110 = -[NSArray countByEnumeratingWithState:objects:count:]( v109,  "countByEnumeratingWithState:objects:count:",  &v272,  &v291,  16LL);
                              }

                              while (v110);
                            }

                            v270 = 0u;
                            v271 = 0u;
                            v268 = 0u;
                            v269 = 0u;
                            v114 = -[NSSQLLocationAttributeRTreeExtension insertSQLStrings](v251, "insertSQLStrings");
                            v115 = -[NSArray countByEnumeratingWithState:objects:count:]( v114,  "countByEnumeratingWithState:objects:count:",  &v268,  v290,  16LL);
                            if (v115)
                            {
                              v116 = *(void *)v269;
                              do
                              {
                                for (m = 0LL; m != v115; ++m)
                                {
                                  if (*(void *)v269 != v116) {
                                    objc_enumerationMutation(v114);
                                  }
                                  v118 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  v101,  *(void *)(*((void *)&v268 + 1) + 8 * m));
                                  [v95 addObject:v118];
                                }

                                v115 = -[NSArray countByEnumeratingWithState:objects:count:]( v114,  "countByEnumeratingWithState:objects:count:",  &v268,  v290,  16LL);
                              }

                              while (v115);
                            }

                            v266 = 0u;
                            v267 = 0u;
                            v264 = 0u;
                            v265 = 0u;
                            v108 = v251;
                            v119 = -[NSSQLLocationAttributeRTreeExtension bulkUpdateSQLStrings]( v251,  "bulkUpdateSQLStrings");
                            v120 = -[NSArray countByEnumeratingWithState:objects:count:]( v119,  "countByEnumeratingWithState:objects:count:",  &v264,  v289,  16LL);
                            if (v120)
                            {
                              v121 = *(void *)v265;
                              do
                              {
                                for (n = 0LL; n != v120; ++n)
                                {
                                  if (*(void *)v265 != v121) {
                                    objc_enumerationMutation(v119);
                                  }
                                  v123 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  v101,  *(void *)(*((void *)&v264 + 1) + 8 * n));
                                  [v95 addObject:v123];
                                }

                                v120 = -[NSArray countByEnumeratingWithState:objects:count:]( v119,  "countByEnumeratingWithState:objects:count:",  &v264,  v289,  16LL);
                              }

                              while (v120);
                              v108 = v251;
                            }
                          }

                          else
                          {
                            v250 = 0;
                          }

                          if ((v250 & 1) == 0) {
                            break;
                          }
                        }
                      }
                    }
                  }

                  if (++v104 == v103)
                  {
                    v103 = [v253 countByEnumeratingWithState:&v276 objects:buf count:16];
                    if (v103) {
                      goto LABEL_117;
                    }
                    break;
                  }
                }
              }

              if ((v250 & 1) == 0)
              {
                v131 = 0;
                goto LABEL_195;
              }

              v262 = 0u;
              v263 = 0u;
              v260 = 0u;
              v261 = 0u;
              v124 = (void *)[-[NSSQLEntity rtreeIndexes](v101) allValues];
              v125 = [v124 countByEnumeratingWithState:&v260 objects:v288 count:16];
              if (v125)
              {
                v126 = *(void *)v261;
                do
                {
                  for (iuint64_t i = 0LL; ii != v125; ++ii)
                  {
                    if (*(void *)v261 != v126) {
                      objc_enumerationMutation(v124);
                    }
                    objc_msgSend( v95,  "addObjectsFromArray:",  objc_msgSend(*(id *)(*((void *)&v260 + 1) + 8 * ii), "generateStatementsForStore:", v255));
                  }

                  v125 = [v124 countByEnumeratingWithState:&v260 objects:v288 count:16];
                }

                while (v125);
              }

              uint64_t v100 = v248 + 1;
            }

            while (v248 + 1 != v246);
            unint64_t v99 = [obj countByEnumeratingWithState:&v280 objects:&v285 count:16];
            if (v99) {
              continue;
            }
            break;
          }
        }

        if ([v95 count])
        {
          -[NSSQLiteConnection beginTransaction](v252);
          v258 = 0u;
          v259 = 0u;
          v256 = 0u;
          v257 = 0u;
          v128 = [v95 countByEnumeratingWithState:&v256 objects:v287 count:16];
          if (v128)
          {
            v129 = *(void *)v257;
            do
            {
              for (jj = 0LL; jj != v128; ++jj)
              {
                if (*(void *)v257 != v129) {
                  objc_enumerationMutation(v95);
                }
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:]( v252,  *(void **)(*((void *)&v256 + 1) + 8 * jj));
              }

              v128 = [v95 countByEnumeratingWithState:&v256 objects:v287 count:16];
            }

            while (v128);
          }

          v131 = 1;
          -[NSSQLiteConnection commitTransaction](v252);
        }

        else
        {
          v131 = 1;
        }

LABEL_201:
                          ++v111;
                        }

                        -[NSSQLiteConnection releaseSQLStatement](a1);
                        -[NSSQLiteConnection setColumnsToFetch:]((void *)a1, 0LL);
                        *(_DWORD *)(a1 + 312) &= ~2u;
                        *(void *)(a1 + 92) = 0LL;
                        *(void *)(a1 + 100) = 0LL;
                        *(_DWORD *)(a1 + 10_Block_object_dispose(va, 8) = 0;

                        if ((v181 & 1) == 0)
                        {
                          v142 = [NSString stringWithFormat:@"Database failed integrity check.  Corrupted SQLite database at path: %@", *(void *)(a1 + 32)];
                          v143 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  *(void *)(a1 + 32),  *MEMORY[0x1896074F8],  v142,  @"message",  0,  v168);
                          v144 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  259LL,  v142,  v143);
                          objc_exception_throw(v144);
                          goto LABEL_288;
                        }
                      }

                      v105 = [obj countByEnumeratingWithState:&v186 objects:v196 count:16];
                    }

                    while (v105);
                  }

                  if ((v177 & 1) != 0) {
                    goto LABEL_259;
                  }
                  if (([*(id *)(a1 + 16) isReadOnly] & 1) == 0
                    && [*(id *)(a1 + 368) objectForKey:@"NSPersistentStoreUbiquitousContentNameKey"])
                  {
                    -[NSSQLiteConnection _executeSQLString:]( a1,  @"CREATE TABLE IF NOT EXISTS Y_UBMETA (Y_PK INTEGER PRIMARY KEY ASC, YPEERID VARCHAR UNIQUE, YTRANSACTIONNUMBER INTEGER)");
                    -[NSSQLiteConnection _executeSQLString:]( a1,  @"CREATE TABLE IF NOT EXISTS Y_UBRANGE (Y_PK INTEGER PRIMARY_KEY ASC, YPEERID VARCHAR, YENTITYNAME VARCHAR, YRANGESTART INTEGER, YRANGEEND INTEGER, YPEERSTART INTEGER, YPEEREND INTEGER)");
                    -[NSSQLiteConnection _executeSQLString:]( a1,  @"CREATE TABLE IF NOT EXISTS Y_UBKVS (Y_PK INTEGER PRIMARY KEY ASC, YKEY VARCHAR UNIQUE, YVALUE VARCHAR)");
                  }

                  if ((v58 & 1) == 0)
                  {
                    if ([v169 objectForKey:@"NSSQLiteAnalyzeOption"]) {
                      -[NSSQLiteConnection _executeSQLString:](a1, @"ANALYZE");
                    }
                    if ([v169 objectForKey:@"NSSQLiteManualVacuumOption"]) {
                      -[NSSQLiteConnection _executeSQLString:](a1, @"VACUUM");
                    }
                  }

                  if ((*(_BYTE *)(a1 + 312) & 0x40) == 0) {
                    goto LABEL_259;
                  }
                  v194.f_bsize = 0;
                  v136 = (void *)[v169 objectForKey:@"NSSQLitePersistWALOption"];
                  if (v136)
                  {
                  }

                  else if (!byte_18C4ABDB8)
                  {
LABEL_259:
                    *(_DWORD *)(a1 + 312) &= ~0x80u;
                    return;
                  }

                  v194.f_bsize = 1;
LABEL_258:
                  sqlite3_file_control(*v170, 0LL, 10, &v194);
                  goto LABEL_259;
                }

                v159 = [NSString stringWithFormat:@"Cannot create a new database file with the read only option at path: %@", *(void *)(a1 + 32)];
                v160 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  *(void *)(a1 + 32),  *MEMORY[0x1896074F8],  0);
                v161 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  257LL,  v159,  v160);
                objc_exception_throw(v161);
LABEL_288:
                __break(1u);
                return;
              }

              [*(id *)(a1 + 160) removeObjectForKey:@"integrity_check"];
              goto LABEL_111;
            }

            if (v42) {
              goto LABEL_270;
            }
          }

          v145 = "unknown";
LABEL_271:
          if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1)
          {
            if (*(_BYTE *)(a1 + 42)) {
              v152 = @"\x1B[31m\x1B[47mERROR:\x1B[0m\x1B[31m (%d) %s\x1B[0m";
            }
            else {
              v152 = @"(%d) %s";
            }
            _NSCoreDataLog(1LL, (uint64_t)v152, v146, v147, v148, v149, v150, v151, v40);
          }

          if (*v170)
          {
            sqlite3_close_v2(*v170);
            *v170 = 0LL;
          }

          if ((_DWORD)v40 == 26)
          {
            v153 = [NSString stringWithFormat:@"File at path does not appear to be a SQLite database: %@", *(void *)(a1 + 32)];
            v154 = (void *)MEMORY[0x189603F68];
            v155 = *(void *)(a1 + 32);
            v156 = [MEMORY[0x189607968] numberWithInteger:26];
            v157 = (void *)objc_msgSend( v154,  "dictionaryWithObjectsAndKeys:",  v155,  *MEMORY[0x1896074F8],  v156,  @"NSSQLiteErrorDomain",  0);
            v158 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  259LL,  v153,  v157);
          }

          else
          {
            v162 = [NSString stringWithUTF8String:v145];
            v163 = (void *)MEMORY[0x189603F68];
            v164 = *(void *)(a1 + 32);
            v165 = [MEMORY[0x189607968] numberWithInt:v40];
            v166 = (void *)objc_msgSend( v163,  "dictionaryWithObjectsAndKeys:",  v164,  *MEMORY[0x1896074F8],  v165,  @"NSSQLiteErrorDomain",  0);
            v158 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  256LL,  v162,  v166);
          }

          objc_exception_throw(v158);
          goto LABEL_288;
        }

        unint64_t v26 = *(_DWORD *)(a1 + 312) | 0xC;
      }

      *(_DWORD *)(a1 + 312) = v26;
      goto LABEL_46;
    }
  }

void sub_18668D5F4()
{
}

void sub_18668D8B8(_Unwind_Exception *a1)
{
}

void sub_18668D8D4()
{
}

LABEL_110:
    unint64_t v75 = (void *)[v17 objectForKey:@"NSUnderlyingException"];
    if (v75) {
      goto LABEL_142;
    }
    unint64_t v76 = -[NSSQLFetchDictionaryCountIntermediate generateSQLStringInContext:](v66, "generateSQLStringInContext:", v17);
    if (v76) {
      break;
    }
    unint64_t v75 = (void *)[v17 objectForKey:@"NSUnderlyingException"];
    if (!v75) {
      goto LABEL_128;
    }
LABEL_142:
    uint64_t v28 = v75;
    v103 = v75;

    v104 = v28;
    objc_exception_throw(v28);
LABEL_143:
    ;
  }

  uint64_t v77 = (void *)v76;
  if (v26)
  {
    uint64_t v78 = v26->_sqlString;
    if (v78 != (NSString *)v76)
    {

      v26->_sqlString = (NSString *)[v77 copy];
    }
  }

  -[NSSQLiteStatement setBindIntarrays:]( (uint64_t)v26,  (void *)[v17 objectForKey:@"bindIntarrays"]);
  uint64_t v79 = (void *)[v17 objectForKey:@"selectBindVars"];
  objc_msgSend(v79, "addObjectsFromArray:", objc_msgSend(v17, "objectForKey:", @"bindVars"));
  uint64_t v80 = [v79 count];
  if (v80)
  {
    uint64_t v81 = v80;
    for (m = 0LL; m != v81; ++m)
      objc_msgSend((id)objc_msgSend(v79, "objectAtIndex:", m), "setIndex:", m);
  }

  -[NSSQLiteAdapter _useModel:]((uint64_t)v26, v79);
  if ([v17 objectForKey:@"fabricatedSQLEntityForReadOnlyFetch"]) {
    -[NSSQLiteStatement cacheFakeEntityForFetch:]( (uint64_t)v26,  (void *)[v17 objectForKey:@"fabricatedSQLEntityForReadOnlyFetch"]);
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    uint64_t v83 = objc_alloc_init(&OBJC_CLASS___NSCachedFetchRequestInfo);
    v84 = (void *)[v17 valueForKey:@"columnSubOrder"];
    unint64_t v85 = [v84 count];
    unint64_t v86 = (void *)[v17 valueForKey:@"subOrder"];
    unint64_t v88 = v86;
    if (v84 && v85 >= 2)
    {
      v109 = v15;
      v111 = v17;
      v89 = [v86 count];
      if (v89)
      {
        v90 = v89;
        uint64_t v91 = 0LL;
        v92 = v85 >> 1;
        do
        {
          uint64_t v93 = (void *)MEMORY[0x186E3E5D8]();
          __int16 v94 = (void *)[v88 objectAtIndex:v91 + 1];
          objc_msgSend( v88,  "replaceObjectAtIndex:withObject:",  v91 + 1,  objc_msgSend(MEMORY[0x189607968], "numberWithInteger:", objc_msgSend(v94, "integerValue") + v92));
          objc_autoreleasePoolPop(v93);
          v91 += 2LL;
        }

        while (v91 < v90);
      }

      [v84 addObjectsFromArray:v88];
      uint64_t v15 = v109;
      uint64_t v17 = v111;
    }

    else
    {
      v84 = v86;
    }

    if (v83)
    {
      objc_setProperty_nonatomic(v83, v87, v84, 8LL);
      __int16 v98 = (void *)[v17 valueForKey:@"bindIntarraysSubstitutionOrder"];
      objc_setProperty_nonatomic(v83, v99, v98, 16LL);
      if (v26) {
        goto LABEL_136;
      }
    }

    else
    {
      [v17 valueForKey:@"bindIntarraysSubstitutionOrder"];
      if (v26) {
LABEL_136:
      }
        objc_setProperty_nonatomic(v26, v100, v83, 56LL);
    }
  }

  [v101 drain];
  unint64_t v88 = v105;
  if (v103) {
    -[NSXPCStore decodePrefetchArray:forSources:context:](v113, v103, v105, a4);
  }
  v89 = v102;
  if (v102 >= 0x201) {
    v90 = 1LL;
  }
  else {
    v90 = v102;
  }
  uint64_t v91 = (8 * v90 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  v92 = (char *)&v100 - v91;
  if (v102 > 0x200) {
    v92 = (char *)NSAllocateScannedUncollectable();
  }
  else {
    bzero((char *)&v100 - v91, 8 * v102);
  }
  v116 = 0u;
  v117 = 0u;
  v114 = 0u;
  v115 = 0u;
  uint64_t v93 = [v88 countByEnumeratingWithState:&v114 objects:v135 count:16];
  if (v93)
  {
    __int16 v94 = v93;
    unint64_t v95 = 0LL;
    __int16 v96 = *(void *)v115;
    do
    {
      for (k = 0LL; k != v94; ++k)
      {
        if (*(void *)v115 != v96) {
          objc_enumerationMutation(v88);
        }
        *(void *)&v92[8 * v95 + 8 * k] = [*(id *)(*((void *)&v114 + 1) + 8 * k) objectID];
      }

      __int16 v94 = [v88 countByEnumeratingWithState:&v114 objects:v135 count:16];
      v95 += k;
    }

    while (v94);
  }

  __int16 v98 = v107;
  unint64_t v99 = (void *)+[_PFRoutines newArrayOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v107);
  -[NSPersistentStore managedObjectContextDidUnregisterObjectsWithIDs:generation:]( v113,  "managedObjectContextDidUnregisterObjectsWithIDs:generation:",  v99,  v111);

  if (v89 >= 0x201) {
    NSZoneFree(0LL, v92);
  }
}

LABEL_138:
  objc_autoreleasePoolPop(v15);
  return v26;
}

  uint64_t v100 = 0LL;
  v159 = v39 + 1;
  do
  {
    v101 = &v161[2 * dword_1868D5C8C[v100]];
    v102 = *v101;
    v103 = v101[1];
    v104 = v103 + *v101;
    if (v24)
    {
      if (v102 < v104)
      {
        do
        {
          Class = object_getClass(v24);
          v106 = *(void **)&v24[*((unsigned int *)object_getIndexedIvars(Class) + v102 + 19)];
          if (v106)
          {
            v107 = *(void *)(v16 + 8 * v102);
            _PF_CopyOnWrite_Snapshot((id)a2);
            if (v107)
            {
              _NSSetUsingKeyValueSetter();
            }

            else
            {
              v110 = v106;
              snapshot_set_value_as_object(*(char **)(a2 + 24), v102, v110, v111, v112, v113, v114, v115);
            }

            v108 = (int)v102 >> 3;
            v109 = *(unsigned __int8 *)(v39 + ((int)v102 >> 3)) | (1 << (v102 & 7));
          }

          else
          {
            v108 = (int)v102 >> 3;
            v109 = *(unsigned __int8 *)(v39 + ((int)v102 >> 3)) & ~(1 << (v102 & 7));
          }

          *(_BYTE *)(v39 + v10_Block_object_dispose(va, 8) = v109;
          ++v102;
          --v103;
        }

        while (v103);
      }
    }

    else if (v102 < v104)
    {
      v116 = v104 - 1;
      v117 = (int)v102 >> 3;
      v118 = v116 >> 3;
      v119 = 0xFFu >> (8 - (v102 & 7));
      if (v116 >> 3 == (int)v102 >> 3)
      {
        v120 = (510 << (v116 & 7)) | v119;
      }

      else
      {
        *(_BYTE *)(v39 + v117) &= v119;
        if (v117 + 1 < v118) {
          bzero((void *)(v159 + v117), (v118 - v117 - 2) + 1LL);
        }
        v120 = 510 << (v116 & 7);
        v117 = v116 >> 3;
      }

      *(_BYTE *)(v39 + v117) &= v120;
    }

    ++v100;
  }

  while (v100 != 3);
  v121 = v161[10];
  v122 = v161[11];
  v123 = v122 + v121;
  if ((HasCustomPrimitiveProperties & 1) != 0)
  {
    v124 = v158;
    if (v121 < v123)
    {
      do
      {
        v125 = (1 << (v121 & 7)) & *(unsigned __int8 *)(v39 + (v121 >> 3));
        v126 = *(void *)(v16 + 8 * v121);
        if (v125) {
          v127 = 1;
        }
        else {
          v127 = v124;
        }
        if ((v127 & 1) != 0 || v126)
        {
          if (v125)
          {
            snapshot_get_value_as_object((id *)v24, v121, v26, v27, v28, v29, v30, v31);
          }

          else
          {
            v129 = *(void **)(v160 + 8 * v121);
            v128 = (void *)([v129 _propertyType] == 7
                          ? [v129 _buildDefaultValue]
                          : [v129 defaultValue]);
          }

          unint64_t v26 = (uint64_t)v128;
          if (v128) {
            _PF_Handler_Primitive_Internal_SetProperty((char **)a2, v121, v128, v126);
          }
        }

        ++v121;
        --v122;
      }

      while (v122);
    }
  }

  else if (v121 < v123)
  {
    do
    {
      if (((*(unsigned __int8 *)(v39 + (v121 >> 3)) >> (v121 & 7)) & 1) != 0)
      {
        v130 = *(void *)(v16 + 8 * v121);
        snapshot_get_value_as_object((id *)v24, v121, v26, v27, v28, v29, v30, v31);
        if (v131) {
          _PF_Handler_Primitive_Internal_SetProperty((char **)a2, v121, v131, v130);
        }
      }

      ++v121;
      --v122;
    }

    while (v122);
  }

  v132 = v161[10];
  v133 = v161[11] + v132;
  v134 = v153;
  v135 = v155;
  if (v132 < v133)
  {
    v136 = v133 - 1;
    v137 = (int)v132 >> 3;
    v138 = v136 >> 3;
    v139 = 255 << (v132 & 7);
    if (v136 >> 3 == (int)v132 >> 3)
    {
      v140 = (0xFFu >> (~(_BYTE)v136 & 7)) & v139;
    }

    else
    {
      *(_BYTE *)(v39 + v137) |= v139;
      if (v137 + 1 < v138) {
        memset((void *)(v137 + v39 + 1), 255, (v138 - v137 - 2) + 1LL);
      }
      v140 = 0xFFu >> (~(_BYTE)v136 & 7);
      v137 = v136 >> 3;
    }

    *(_BYTE *)(v39 + v137) |= v140;
  }

  *(_DWORD *)(a2 + 16) &= 0xFFFC7FFF;
  if ((v148 & 1) == 0)
  {
    [(id)a2 _didChangeValuesForKeys:v145];
    *(_DWORD *)(a2 + 16) &= ~0x1000u;
    if (v134) {
      --*(_WORD *)(v134 + 46);
    }
  }

  if ((v149 & 0x100) == 0) {
    objc_msgSend((id)a2, "didFireFault", v26);
  }
  if ((v150 & 1) != 0) {
    v141 = v135;
  }
  else {
    v141 = 1;
  }
  if ((v141 & 1) == 0)
  {
    *(_DWORD *)(a2 + 16) |= 0x1000u;
    objc_msgSend((id)a2, "awakeFromFetch", v26);
    *(_DWORD *)(a2 + 16) &= ~0x1000u;
  }

  if (v24) {

  }
  objc_autoreleasePoolPop(context);
  v142 = v154;
  v143 = 0LL;
}

        goto LABEL_139;
      }
    }
  }

  else if (objc_msgSend((id)objc_msgSend(a3, "fetchRequest"), "predicate"))
  {
    v135 =  -[_NSPersistentHistoryTransactionPredicateParser initWithPredicate:]( [_NSPersistentHistoryTransactionPredicateParser alloc],  "initWithPredicate:",  objc_msgSend((id)objc_msgSend(a3, "fetchRequest"), "predicate"));
    *(void *)buf = 0LL;
    -[_NSPersistentHistoryTransactionPredicateParser parse:](v135, "parse:", buf);
    if (*(void *)buf)
    {
      if (a5) {
        *a5 = *(id *)buf;
      }
      goto LABEL_139;
    }

    v165 = objc_msgSend( -[_NSPersistentHistoryTransactionPredicateParser storeTokens](v135, "storeTokens"),  "objectForKey:",  -[NSPersistentStore identifier](self, "identifier"));
    if (v165)
    {
      v166 = -[NSFetchRequest initWithEntityName:]( [NSFetchRequest alloc],  "initWithEntityName:",  [NSString stringWithFormat:@"%@/%@", +[_PFPersistentHistoryModel ancillaryModelNamespace]( _PFPersistentHistoryModel, "ancillaryModelNamespace"), @"TRANSACTION"]);
      -[NSFetchRequest setIncludesSubentities:](v166, "setIncludesSubentities:", 0LL);
      -[NSFetchRequest setPredicate:]( v166,  "setPredicate:",  [MEMORY[0x1896079C8] predicateWithFormat:@"_pk = %@", v165]);
      -[NSFetchRequest setResultType:](v166, "setResultType:", 4LL);
      -[NSXPCStore executeFetchRequest:withContext:error:]((uint64_t *)self, (uint64_t)v166, v216, &v217);
      v168 = v167;

      if ([v168 count])
      {
        if ((objc_msgSend((id)objc_msgSend(v168, "firstObject"), "BOOLValue") & 1) == 0)
        {
          v169 = (__CFString *)[NSString stringWithFormat:@"Persistent History Token is expired for store at %@", -[NSURL path](-[NSPersistentStore URL](self, "URL"), "path")];
          v170 = (void *)MEMORY[0x189607870];
          v230 = v169;
          v227 = (NSString *)@"message";
          v228 = @"NSStoreUUID";
          v231 = -[NSPersistentStore identifier](self, "identifier");
          v229 = *MEMORY[0x1896074F8];
          v232 = -[NSURL path](-[NSPersistentStore URL](self, "URL"), "path");
          v171 = [MEMORY[0x189603F68] dictionaryWithObjects:&v230 forKeys:&v227 count:3];
          v172 = (void *)[v170 errorWithDomain:*MEMORY[0x189607460] code:134301 userInfo:v171];
          v217 = v172;
          if (v172)
          {
            if (a5) {
              *a5 = v172;
            }
            if (a4) {
              goto LABEL_84;
            }
            goto LABEL_138;
          }
        }
      }
    }
  }

  v173 = [a3 resultType] == 2
      || [a3 resultType] == 6
      || [a3 resultType] == 0;
  v174 = -[NSPersistentHistoryChangeRequest fetchRequestDescribingChangeRequestForStore:](a3, self);
  if (v173) {
    v175 = 4LL;
  }
  else {
    v175 = 2 * ([a3 fetchBatchSize] == 0);
  }
  -[NSFetchRequest setResultType:](v174, "setResultType:", v175);
  -[NSXPCStore executeFetchRequest:withContext:error:]((uint64_t *)self, (uint64_t)v174, v216, &v217);
  v177 = v176;
  v213 = v174;
  if ([a3 resultType] == 5
    && (objc_msgSend((id)objc_msgSend(a3, "entityNameToFetch"), "isEqualToString:", @"CHANGE") & 1) == 0
    && ![a3 fetchBatchSize])
  {
    v197 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(v177, "count"));
    v225 = 0u;
    v226 = 0u;
    v223 = 0u;
    v224 = 0u;
    v198 = [v177 countByEnumeratingWithState:&v223 objects:buf count:16];
    if (v198)
    {
      v199 = *(void *)v224;
      do
      {
        for (j = 0LL; j != v198; ++j)
        {
          if (*(void *)v224 != v199) {
            objc_enumerationMutation(v177);
          }
          objc_msgSend( v197,  "addObject:",  objc_msgSend(*(id *)(*((void *)&v223 + 1) + 8 * j), "objectForKey:", @"self"));
        }

        v198 = [v177 countByEnumeratingWithState:&v223 objects:buf count:16];
      }

      while (v198);
    }

    if ([v197 count])
    {
      v193 = -[NSPersistentHistoryChangeRequest initWithTransactionIDs:]( objc_alloc(&OBJC_CLASS___NSPersistentHistoryChangeRequest),  "initWithTransactionIDs:",  v197);
      v194 = -[NSPersistentHistoryChangeRequest fetchRequestDescribingChangeRequestForStore:](v193, self);
      -[NSFetchRequest setResultType:](v194, "setResultType:", 2LL);
      -[NSXPCStore executeFetchRequest:withContext:error:]((uint64_t *)self, (uint64_t)v194, v216, &v217);
      v188 = 0LL;
      if (!v217 && v201)
      {
        v218 = (uint64_t)v177;
        v219 = v201;
        v188 = [MEMORY[0x189603F18] arrayWithObjects:&v218 count:2];
      }

      goto LABEL_210;
    }

                    *(Class *)((char *)&self->super.super.super.isa + *v95) = selectEntityAlias;

LABEL_139:
                    if ([v3 objectForKey:@"NSUnderlyingException"])
                    {
LABEL_140:

                      uint64_t v17 = 0LL;
                      self->_fetchIntermediate = 0LL;
                      return v17;
                    }

                    __int16 v96 = -[NSExpression predicate](self->super._expression, "predicate");
                    if (v96)
                    {
                      unint64_t v97 = v96;
                      objc_opt_class();
                      if ((objc_opt_isKindOfClass() & 1) != 0)
                      {
                        __int16 v98 = -[NSSQLSimpleWhereIntermediate initWithPredicate:inScope:]( objc_alloc(&OBJC_CLASS___NSSQLSimpleWhereIntermediate),  "initWithPredicate:inScope:",  -[NSExpression predicate](self->super._expression, "predicate"),  self);
                      }

                      else
                      {
                        objc_opt_class();
                        if ((objc_opt_isKindOfClass() & 1) != 0)
                        {
                          __int16 v98 = -[NSSQLCompoundWhereIntermediate initWithPredicate:inScope:inContext:]( objc_alloc(&OBJC_CLASS___NSSQLCompoundWhereIntermediate),  "initWithPredicate:inScope:inContext:",  -[NSExpression predicate](self->super._expression, "predicate"),  self,  v3);
                          if (!v98) {
                            goto LABEL_140;
                          }
                        }

                        else
                        {
                          if ((NSPredicate *)[MEMORY[0x1896079C8] predicateWithValue:1] != v97)
                          {

                            self->_fetchIntermediate = 0LL;
                            objc_msgSend( v3,  "setObject:forKey:",  objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A60],  @"Unknown predicate type",  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  self->super._expression,  @"subquery")),  @"NSUnderlyingException");
                          }

                          __int16 v98 = 0LL;
                        }
                      }

                      if ([v3 objectForKey:@"NSUnderlyingException"])
                      {

                        return 0LL;
                      }

                      -[NSSQLStatementIntermediate setWhereIntermediate:]((uint64_t)self->_fetchIntermediate, v98);
                    }

                    unint64_t v99 = self->_trailingKeypath;
                    if (!v99)
                    {
                      variableColumn = self->_variableColumn;
                      goto LABEL_183;
                    }

                    uint64_t v100 = -[NSString componentsSeparatedByString:]( -[NSExpression keyPath](v99, "keyPath"),  "componentsSeparatedByString:",  @".");
                    if (objc_msgSend( -[NSArray objectAtIndex:](v100, "objectAtIndex:", 0),  "isEqual:",  &stru_189EAC2E8))
                    {
                      uint64_t v100 = (NSArray *)(id)-[NSArray mutableCopy](v100, "mutableCopy");
                      -[NSArray removeObjectAtIndex:](v100, "removeObjectAtIndex:", 0LL);
                    }

                    v101 = -[NSArray objectAtIndex:](v100, "objectAtIndex:", -[NSArray count](v100, "count") - 1);
                    if (self->_hasTrailingFunction)
                    {
                      v102 = (void *)v101;
                      if ([@"@count" isEqual:v101])
                      {
                        variableColumn = objc_alloc_init(&OBJC_CLASS___NSSQLColumn);
                        if (-[NSSQLIntermediate isUpdateColumnsScoped](self, "isUpdateColumnsScoped")) {
                          v104 = (void *)[NSString stringWithFormat:@"COUNT(%@)", -[NSSQLColumn columnName](self->_targetColumn, "columnName"), v141];
                        }
                        else {
                          v104 = (void *)[NSString stringWithFormat:@"COUNT(%@.%@)", self->_targetAlias, -[NSSQLColumn columnName](self->_targetColumn, "columnName")];
                        }
                        -[NSSQLColumn _setColumnName:]((uint64_t)variableColumn, v104);
                        if (!variableColumn)
                        {
LABEL_183:
                          v111 = self->_selectFromCorrelationTarget;
                          v112 = objc_alloc(&OBJC_CLASS___NSSQLSelectIntermediate);
                          v113 = self->_selectEntityAlias;
                          if (v111) {
                            v114 = -[NSSQLSelectIntermediate initForCorrelationTarget:alias:fetchColumns:inScope:]( v112,  "initForCorrelationTarget:alias:fetchColumns:inScope:",  self->_selectFromCorrelationTarget,  v113,  [MEMORY[0x189603F18] arrayWithObject:variableColumn],  self);
                          }
                          else {
                            v114 = -[NSSQLSelectIntermediate initWithEntity:alias:fetchColumns:inScope:]( v112,  "initWithEntity:alias:fetchColumns:inScope:",  self->_selectFromEntity,  v113,  [MEMORY[0x189603F18] arrayWithObject:variableColumn],  self);
                          }
                          v115 = (_BYTE *)v114;
                          -[NSSQLSelectIntermediate setColumnAlias:](v114, self->_variableAlias);
                          if (v115) {
                            v115[48] = self->_useDistinct;
                          }
                          -[NSSQLFetchIntermediate setSelectIntermediate:]((uint64_t)self->_fetchIntermediate, v115);

LABEL_189:
                          v116 = -[NSSQLFetchIntermediate generateSQLStringInContext:]( self->_fetchIntermediate,  "generateSQLStringInContext:",  v3);
                          if (v116)
                          {
                            v117 = v116;
                            uint64_t v17 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189607940]), "initWithString:", @"(");
                            [v17 appendString:v117];
                            [v17 appendString:@""]);

                            return v17;
                          }

                          return 0LL;
                        }

LABEL_23:
        uint64_t v12 = (void *)MEMORY[0x189607A48];
        return [v12 defaultInstance];
      }

    unint64_t v9 = 0LL;
    goto LABEL_88;
  }

  uint64_t v4 = (unint64_t *)[a4 destinationEntity];
  BOOL v13 = _PFFastEntityClass(v4);
  class_getSuperclass((Class)v13);
  uint64_t result = [a4 isToMany];
  if (!(_DWORD)result)
  {
    if (v10)
    {
      unint64_t v16 = (void *)[v10 managedObjectContext];
      uint64_t v17 = v16;
      if (!a1 || (*(_BYTE *)(a1 + 16) & 0x80) != 0) {
        int v18 = 0LL;
      }
      else {
        int v18 = *(void **)(a1 + 32);
      }
      if (([v16 _isSwiftBound] & 1) != 0
        || (uint64_t v24 = [v18 _isSwiftBound], v17 == v18)
        || (v24 & 1) != 0
        || (void *)[(id)a1 valueForKey:a3] == v10)
      {
        isKindOfClass = objc_opt_isKindOfClass();
        if (v4 && (isKindOfClass & 1) != 0) {
          goto LABEL_87;
        }
        goto LABEL_50;
      }

      uint64_t v7 = (void **)MEMORY[0x189603F70];
      a4 = (void *)*MEMORY[0x189603A60];
      uint64_t v43 = [NSString stringWithFormat:@"Illegal attempt to establish a relationship '%@' between objects in different contexts (source = %@, destination = %@)", a3, a1, v10, v46];
      goto LABEL_114;
    }

    goto LABEL_23;
  }

  if ([a4 isOrdered])
  {
    BOOL v14 = objc_opt_class();
    id v49 = (Class)objc_opt_class();
    if ([v10 isNSOrderedSet]) {
      goto LABEL_16;
    }
  }

  else
  {
    BOOL v14 = objc_opt_class();
    id v49 = (Class)objc_opt_class();
    if ([v10 isNSSet])
    {
LABEL_16:
      uint64_t v15 = 1;
      if (!v10) {
        goto LABEL_41;
      }
      goto LABEL_33;
    }
  }

  uint64_t v15 = [v10 count] == 0;
  if (!v10) {
    goto LABEL_41;
  }
LABEL_33:
  if (!v15)
  {
    uint64_t v7 = (void **)MEMORY[0x189603F70];
    unint64_t v9 = (void *)*MEMORY[0x189603A60];
    uint64_t v44 = (void *)NSString;
    uint64_t v4 = (unint64_t *)a3;
    else {
      a3 = @"to-many";
    }
    uint64_t v45 = objc_msgSend( v44,  "stringWithFormat:",  @"Unacceptable type of value for %@ relationship: property = %@; desired type = %@; given type = %@; value = %@.",
            a3,
            v4,
            v14,
            objc_opt_class(),
            v10);
LABEL_110:
    a4 = (void *)v45;
    for (uint64_t i = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  v4,  @"key",  v10,  @"value",  0);
          ;
          uint64_t i = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  a3,  @"key",  v10,  @"value",  0))
    {
      uint64_t v30 = i;
      uint64_t v31 = v7;
      uint64_t v32 = v9;
LABEL_85:
      uint64_t v42 = a4;
LABEL_86:
      objc_exception_throw((id)[v31 exceptionWithName:v32 reason:v42 userInfo:v30]);
LABEL_87:
      uint64_t result = [v4 _subentitiesIncludes:_PFEntityForManagedObject(v10)];
      if ((result & 1) != 0) {
        break;
      }
LABEL_50:
      uint64_t v7 = (void **)MEMORY[0x189603F70];
      unint64_t v9 = (void *)*MEMORY[0x189603A60];
      unint64_t v26 = (void *)NSString;
      -[NSEntityDescription _entityClass]((unint64_t *)[a4 destinationEntity]);
      unint64_t v27 = objc_opt_class();
      uint64_t v28 = objc_msgSend( v26,  "stringWithFormat:",  @"Unacceptable type of value for to-one relationship: property = %@; desired type = %@; given type = %@; value = %@.",
              a3,
              v27,
              objc_opt_class(),
              v10);
LABEL_51:
      a4 = (void *)v28;
    }

    goto LABEL_88;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    if ([v10 source] == a1)
    {
      uint64_t result = [v10 relationship];
    }
  }

  int v19 = [v10 count];
  if (!v19)
  {
LABEL_41:
    unint64_t v9 = (void *)[[v49 alloc] initWithSource:a1 forRelationship:a4 asFault:0];
    goto LABEL_42;
  }

  int v20 = v19;
  unint64_t v47 = (uint64_t)&v47;
  uint64_t v21 = MEMORY[0x1895F8858](v19);
  uint64_t v23 = (char *)&v47 - v22;
  unint64_t v48 = a3;
  if (v21 > 0x200) {
    uint64_t v23 = (char *)NSAllocateScannedUncollectable();
  }
  else {
    bzero((char *)&v47 - v22, 8 * v21);
  }
  objc_msgSend(v10, "getObjects:", v23, v47);
  for (j = 0LL; j != v20; ++j)
  {
    unint64_t v9 = *(void **)&v23[8 * j];
    unint64_t v36 = [v9 managedObjectContext];
    if (!a1 || (*(_BYTE *)(a1 + 16) & 0x80) != 0) {
      unint64_t v37 = 0LL;
    }
    else {
      unint64_t v37 = *(void *)(a1 + 32);
    }
    if (v36 != v37 && (objc_msgSend((id)objc_msgSend((id)a1, "valueForKey:", v48), "containsObject:", v9) & 1) == 0)
    {
      uint64_t v7 = (void **)MEMORY[0x189603F70];
      a4 = (void *)*MEMORY[0x189603A60];
      a3 = v48;
      uint64_t v43 = [NSString stringWithFormat:@"Illegal attempt to establish a relationship '%@' between objects in different contexts (source = %@, destination = %@)", v48, a1, v9, v46];
      goto LABEL_114;
    }

    uint64_t v38 = objc_opt_isKindOfClass();
    if (!v4
      || !v9
      || (v38 & 1) == 0
      || ([v4 _subentitiesIncludes:_PFEntityForManagedObject(v9)] & 1) == 0)
    {
      uint64_t v7 = (void **)MEMORY[0x189603F70];
      uint64_t v39 = (void *)*MEMORY[0x189603A60];
      uint64_t v4 = (unint64_t *)NSString;
      -[NSEntityDescription _entityClass]((unint64_t *)[a4 destinationEntity]);
      uint64_t v40 = objc_opt_class();
      uint64_t v41 = objc_opt_class();
      a3 = v48;
      a4 = (void *)objc_msgSend( v4,  "stringWithFormat:",  @"Unacceptable type of value in to-many relationship: property = %@; problem = %@; desired type = %@; given type = %@; value = %@.",
                     v48,
                     v10,
                     v40,
                     v41,
                     v9);
      uint64_t v30 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  a3,  @"key",  v10,  @"value",  0);
      uint64_t v31 = v7;
      uint64_t v32 = v39;
      goto LABEL_85;
    }
  }

  unint64_t v9 = (void *)[[v49 alloc] initWithSource:a1 forRelationship:a4 asFault:0];
  else {
    [v9 setSet:v10];
  }
  if (v20 >= 0x201) {
    NSZoneFree(0LL, v23);
  }
LABEL_42:
  uint64_t result = v9;
LABEL_88:
  const char *v7 = v9;
  return result;
}

    ++v14;
  }

  while (v6 != v14);
  if (v6 >= 0x201)
  {
    NSZoneFree(0LL, v10);
    NSZoneFree(0LL, v13);
  }

  if (rootentity) {
    int v19 = -[NSEntityDescription name](rootentity, "name");
  }
  else {
    int v19 = -[NSManagedObjectID entityName](self, "entityName");
  }
  int v20 = v19;
  if (v18) {
    uint64_t v21 = -[NSEntityDescription name](v18, "name");
  }
  else {
    uint64_t v21 = [a3 entityName];
  }
  uint64_t v17 = v21;
  if (v20 == (NSString *)v21) {
    goto LABEL_31;
  }
  uint64_t result = -[NSString compare:](v20, "compare:", v21);
  if (!result) {
    goto LABEL_31;
  }
  return result;
}

  int v19 = 0LL;
LABEL_24:
  unint64_t v37 = objc_alloc_init(&OBJC_CLASS___NSStoreMigrationPolicy);
  uint64_t v39 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a3, "stagedMigrationManager"), "stages"), "lastObject") != a2
     || v19 != 0;
  v110 = v39;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && [a2 willMigrateHandler])
  {
    v109 = a1;
    uint64_t v40 = a4;
    uint64_t v41 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "currentModel"), "resolvedModel"), "copy");
    uint64_t v42 = v41;
    if (v41)
    {
      v119 = 0u;
      v120 = 0u;
      v117 = 0u;
      v118 = 0u;
      uint64_t v43 = [v41 countByEnumeratingWithState:&v117 objects:v136 count:16];
      if (v43)
      {
        uint64_t v44 = *(void *)v118;
        do
        {
          for (uint64_t i = 0LL; i != v43; ++i)
          {
            if (*(void *)v118 != v44) {
              objc_enumerationMutation(v42);
            }
            unint64_t v46 = *(void *)(*((void *)&v117 + 1) + 8 * i);
            if (v46)
            {

              *(void *)(v46 + 4_Block_object_dispose(va, 8) = 0LL;
            }
          }

          uint64_t v43 = [v42 countByEnumeratingWithState:&v117 objects:v136 count:16];
        }

        while (v43);
      }
    }

    unint64_t v47 = [a3 stagedMigrationManager];
    a1 = v109;
    a4 = v40;
    v116[0] = MEMORY[0x1895F87A8];
    v116[1] = 3221225472LL;
    v116[2] = __70__NSPersistentStoreCoordinator_applyMigrationStage_withContext_error___block_invoke;
    v116[3] = &unk_189EA8E30;
    v116[4] = v47;
    v116[5] = a2;
    v116[6] = a3;
    v116[7] = &v121;
    v116[8] = &v127;
    -[NSPersistentStoreCoordinator createPersistentContainerForMigrationContext:withModel:andExecuteBlock:]( a3,  (uint64_t)v42,  (uint64_t)v116);
  }

  if (*((_BYTE *)v128 + 24))
  {
    if (v19) {
      unint64_t v48 = -[NSPersistentStoreCoordinator initWithManagedObjectModel:]( objc_alloc(&OBJC_CLASS___NSPersistentStoreCoordinator),  "initWithManagedObjectModel:",  v19);
    }
    else {
      unint64_t v48 = a1;
    }
    id v49 = v48;
    uint64_t v50 = v48;
    -[NSPersistentStoreCoordinator _setIsMigrating:]((unint64_t)v49, 1);
    -[NSStoreMigrationPolicy setPersistentStoreCoordinator:sourceURL:configuration:metadata:options:]( v37,  v49,  (void *)[a3 storeURL],  (void *)objc_msgSend(a3, "configurationName"),  (void *)objc_msgSend(a3, "metadata"),  (void *)objc_msgSend(a3, "options"));
    uint64_t v51 = [a3 forceMigration];
    if (v37) {
      v37->_forcedMigration = v51;
    }
    uint64_t v52 = [a2 label];
    if (v37)
    {
      uint64_t v53 = (void *)v52;
      stageLabel = v37->_stageLabel;
      if (stageLabel != (NSString *)v52)
      {

        v37->_stageLabel = 0LL;
        v37->_stageLabel = (NSString *)[v53 copy];
      }
    }

    unint64_t v55 = [a3 destinationConfigurationForCloudKitValidation];
    if (v37)
    {
      __int16 v56 = (void *)v55;
      destinationConfigurationForCloudKitValidation = v37->_destinationConfigurationForCloudKitValidation;
      if (destinationConfigurationForCloudKitValidation != (NSString *)v55)
      {

        v37->_destinationConfigurationForCloudKitValidation = 0LL;
        v37->_destinationConfigurationForCloudKitValidation = (NSString *)[v56 copy];
      }
    }

    __int16 v58 = -[NSStoreMigrationPolicy _gatherDataAndPerformMigration:]((uint64_t)v37, v122 + 5);
    if (v58)
    {
      [a3 setMigratedStore:v58];
      unint64_t v59 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603F68]),  "initWithObjectsAndKeys:",  objc_msgSend(a3, "storeURL"),  @"storeURL",  0);
      objc_msgSend( (id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"),  "postNotificationName:object:userInfo:",  @"NSPersistentStoreCoordinatorDidAutomigrateStoreNotification",  a1,  v59);

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0 && [a2 didMigrateHandler])
      {
        uint64_t v60 = a1;
        uint64_t v61 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "nextModel"), "resolvedModel"), "copy");
        uint64_t v62 = v61;
        if (v61)
        {
          v114 = 0u;
          v115 = 0u;
          v112 = 0u;
          v113 = 0u;
          uint64_t v63 = [v61 countByEnumeratingWithState:&v112 objects:v135 count:16];
          if (v63)
          {
            uint64_t v64 = *(void *)v113;
            do
            {
              for (j = 0LL; j != v63; ++j)
              {
                if (*(void *)v113 != v64) {
                  objc_enumerationMutation(v62);
                }
                unint64_t v66 = *(void *)(*((void *)&v112 + 1) + 8 * j);
                if (v66)
                {

                  *(void *)(v66 + 4_Block_object_dispose(va, 8) = 0LL;
                }
              }

              uint64_t v63 = [v62 countByEnumeratingWithState:&v112 objects:v135 count:16];
            }

            while (v63);
          }
        }

        uint64_t v67 = [a3 stagedMigrationManager];
        a1 = v60;
        v111[0] = MEMORY[0x1895F87A8];
        v111[1] = 3221225472LL;
        v111[2] = __70__NSPersistentStoreCoordinator_applyMigrationStage_withContext_error___block_invoke_2;
        v111[3] = &unk_189EA8E30;
        v111[4] = v67;
        v111[5] = a2;
        v111[6] = a3;
        v111[7] = &v121;
        v111[8] = &v127;
        -[NSPersistentStoreCoordinator createPersistentContainerForMigrationContext:withModel:andExecuteBlock:]( a3,  (uint64_t)v62,  (uint64_t)v111);
      }

      if (+[NSMappingModel migrationDebugLevel](&OBJC_CLASS___NSMappingModel, "migrationDebugLevel"))
      {
        uint64_t v68 = [a3 storeURL];
        if (a2) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"(migration)\t Automatic schema migration succeeded for store at '%@' with migration stage: %@",  v69,  v70,  v71,  v72,  v73,  v74,  v68);
        }
        else {
          _NSCoreDataLog( 4LL,  (uint64_t)@"(migration)\t Automatic schema migration succeeded for store at '%@'",  v69,  v70,  v71,  v72,  v73,  v74,  v68);
        }
      }
    }

    else
    {
      *((_BYTE *)v128 + 24) = 0;
      unint64_t v75 = (id)v122[5];
      if (v122[5]
        && +[NSStoreMigrationPolicy migrationDebugLevel](&OBJC_CLASS___NSStoreMigrationPolicy, "migrationDebugLevel") >= 1)
      {
        unint64_t v76 = objc_alloc_init(MEMORY[0x189607940]);
        [v76 appendFormat:@"CoreData: error: (migration) migration failed with error %@", v122[5]];
        uint64_t v83 = (id)[(id)v122[5] userInfo];
        if (v83)
        {
          v84 = *MEMORY[0x189607798];
          do
          {
            [v76 appendFormat:@"\nError User Info: %@", v83];
            unint64_t v85 = [v83 objectForKey:v84];
            unint64_t v86 = (void *)v85;
            if (!v85) {
              break;
            }
            [v76 appendFormat:@"\nUnderlying error: %@", v85];
            uint64_t v83 = (id)[v86 userInfo];
          }

          while (v83);
        }

        _NSCoreDataLog(1LL, (uint64_t)@"%@", v77, v78, v79, v80, v81, v82, (uint64_t)v76);
      }
    }
  }

  if (v110) {
    -[NSPersistentStoreCoordinator _removePersistentStore:]( (unint64_t)a1,  (unint64_t *)objc_msgSend(a1, "persistentStoreForURL:", objc_msgSend(a3, "storeURL")));
  }
  if (a2)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      unint64_t v87 = (void *)objc_msgSend((id)objc_msgSend(a2, "subsequentStage"), "currentModel");
LABEL_87:
      [v87 unresolve];
      goto LABEL_90;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      objc_msgSend((id)objc_msgSend(a2, "currentModel"), "unresolve");
      unint64_t v87 = (void *)[a2 nextModel];
      goto LABEL_87;
    }

    unint64_t v88 = [NSString stringWithUTF8String:"I don't know how to handle this stage type %@"];
    v89 = objc_opt_class();
    _NSCoreDataLog(17LL, v88, v90, v91, v92, v93, v94, v95, v89);
    __int16 v96 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      v108 = objc_opt_class();
      *(_DWORD *)buf = 138412290;
      v132 = (const char *)v108;
      _os_log_fault_impl( &dword_186681000,  v96,  OS_LOG_TYPE_FAULT,  "CoreData: I don't know how to handle this stage type %@",  buf,  0xCu);
    }
  }

    if (!*(void *)(*(void *)(a1[5] + 8LL) + 40LL)) {
      *(void *)(*(void *)(a1[6] + 8) + 40) = [v29 copy];
    }
  }

  else
  {
    unint64_t v27 = *(id *)(*(void *)(a1[5] + 8LL) + 40LL);
  }
}

  unint64_t v25 = *(void *)(*(void *)(a1 + 80) + 8LL);
  int v2 = v40;
  if (*(_BYTE *)(v25 + 24))
  {
    unint64_t v26 = *(void *)(a1 + 64);
    if (v26 && (unint64_t v27 = *(void *)(v26 + 8)) != 0 && (v28 = *(void *)(v27 + 136)) != 0)
    {
      uint64_t v29 = -[PFCloudKitArchivingUtilities encodeRecord:error:]( v28,  *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL),  &v49);
      if (v29)
      {
        -[NSManagedObject setEncodedShareData:](v38, "setEncodedShareData:", v29);
        -[NSManagedObject setNeedsShareUpdate:](v38, "setNeedsShareUpdate:", 1LL);
        uint64_t v30 = +[NSCKMirroredRelationship fetchMirroredRelationshipsMatchingRelatingRecords:andRelatingRecordIDs:fromStore:inManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMirroredRelationship,  MEMORY[0x189604A58],  v37,  *(void *)(a1 + 32),  v40,  &v49);
        if (v30)
        {
          uint64_t v31 = v30;
          uint64_t v43 = 0u;
          uint64_t v44 = 0u;
          uint64_t v41 = 0u;
          uint64_t v42 = 0u;
          uint64_t v32 = [v30 countByEnumeratingWithState:&v41 objects:v50 count:16];
          if (v32)
          {
            uint64_t v33 = v32;
            uint64_t v34 = *(void *)v42;
            unint64_t v35 = MEMORY[0x189604A88];
            do
            {
              for (j = 0LL; j != v33; ++j)
              {
                if (*(void *)v42 != v34) {
                  objc_enumerationMutation(v31);
                }
                [*(id *)(*((void *)&v41 + 1) + 8 * j) setNeedsDelete:v35];
              }

              uint64_t v33 = [v31 countByEnumeratingWithState:&v41 objects:v50 count:16];
            }

            while (v33);
          }

          int v2 = v40;
          if ([v40 save:&v49]) {
            goto LABEL_39;
          }
        }
      }

      unint64_t v25 = *(void *)(*(void *)(a1 + 80) + 8LL);
    }

    else
    {
      uint64_t v29 = 0LL;
    }

    *(_BYTE *)(v25 + 24) = 0;
    *(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL) = v49;
LABEL_39:
  }

LABEL_42:
LABEL_43:
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL)) {
    [v2 reset];
  }
}

        LOBYTE(v6) = 1;
      }
    }
  }

  return v6;
}

  return v8;
}

  return v20;
}

  BOOL v14 = v1[25];
  if (v14)
  {
    uint64_t v21 = 0u;
    uint64_t v22 = 0u;
    int v20 = 0u;
    int v19 = 0u;
    uint64_t v15 = -[dispatch_queue_s countByEnumeratingWithState:objects:count:]( v14,  "countByEnumeratingWithState:objects:count:",  &v19,  v23,  16LL);
    if (v15)
    {
      unint64_t v16 = v15;
      uint64_t v17 = *(void *)v20;
      do
      {
        for (uint64_t i = 0LL; i != v16; ++i)
        {
          if (*(void *)v20 != v17) {
            objc_enumerationMutation(v14);
          }
          -[NSSQLiteStatementCache clearCachedStatements](-[dispatch_queue_s objectForKey:](v1[25], "objectForKey:", *(void *)(*((void *)&v19 + 1) + 8 * i)));
        }

        unint64_t v16 = -[dispatch_queue_s countByEnumeratingWithState:objects:count:]( v14,  "countByEnumeratingWithState:objects:count:",  &v19,  v23,  16LL);
      }

      while (v16);
    }
  }

  return -[NSSQLiteConnection _clearOtherStatements](v1);
}

          uint64_t v28 = [v112 count];
          v27 += v28 + [v113 count];
          goto LABEL_52;
        }

        goto LABEL_8;
      }
    }

    uint64_t v24 = objc_msgSend((id)objc_msgSend(v23, "toOneRelationship"), "isConstrained");
    if ((a3 & 8) == 0 || !v24) {
      goto LABEL_17;
    }
LABEL_16:
    v15[(v22 + v21) >> 3] |= 1 << (~(v22 + v21) & 7);
    goto LABEL_17;
  }

  return result;
}

        objc_msgSend(v6, "addObject:", objc_msgSend(v17, "columnName"));
        uint64_t v23 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( [NSSQLBindVariable alloc],  "initWithValue:sqlType:propertyDescription:",  0,  [v17 sqlType],  0);
        [v67 addObject:v23];

        uint64_t v24 = @"?";
LABEL_24:
        [v7 addObject:v24];
        goto LABEL_28;
      }

      int v18 = v17[24];
      switch(v18)
      {
        case 6:
          objc_msgSend(v6, "addObject:", objc_msgSend(*(id *)(*((void *)&v72 + 1) + 8 * v16), "columnName"));
          int v19 = &OBJC_IVAR___NSSQLEntity__optLockKey;
          if (!v9) {
            goto LABEL_31;
          }
          break;
        case 5:
          objc_msgSend(v6, "addObject:", objc_msgSend(*(id *)(*((void *)&v72 + 1) + 8 * v16), "columnName"));
          int v19 = &OBJC_IVAR___NSSQLEntity__entityKey;
          if (!v9) {
            goto LABEL_31;
          }
          break;
        case 2:
          objc_msgSend(v6, "addObject:", objc_msgSend(*(id *)(*((void *)&v72 + 1) + 8 * v16), "columnName"));
          int v19 = &OBJC_IVAR___NSSQLEntity__primaryKey;
          if (!v9)
          {
LABEL_31:
            unint64_t v25 = 0LL;
            goto LABEL_27;
          }

          break;
        default:
          goto LABEL_18;
      }

      unint64_t v25 = *(void **)(v9 + *v19);
LABEL_27:
      objc_msgSend(v7, "addObject:", objc_msgSend(v25, "columnName"));
LABEL_28:
      ++v16;
    }

    while (v14 != v16);
    uint64_t v29 = [v13 countByEnumeratingWithState:&v72 objects:v77 count:16];
    BOOL v14 = v29;
    if (v29) {
      continue;
    }
    break;
  }

LABEL_24:
      uint64_t v12 = (void *)MEMORY[0x189607890];
      return [v12 defaultInstance];
    }
  }

  else if ((v9 & 0xFFFFFFFFFFFFFFFELL) == 4)
  {
    int v10 = 4LL;
    goto LABEL_5;
  }

  objc_exception_throw((id)objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A60],  @"Invalid predicate: nil RHS",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObject:forKey:", v4, @"predicate")));
  return -[NSFunctionExpression(_NSCoreDataSQLPredicateCategories) minimalFormInContext:]();
}

      uint64_t v71 = 0LL;
      uint64_t v28 = (void *)-[NSSQLKeypathExpressionIntermediate _propertyDescriptionsForKeypath:rootedAtEntity:allowToMany:allowToOne:lastKeyVisited:inContext:]( (uint64_t)self,  v16,  (uint64_t)v13,  v12,  (unint64_t)[v16 count] < 2,  &v71,  a5);
      if (!v28)
      {
        if (v23
          && *(_DWORD *)(v23 + 184) == 16001
          && [v15 isEqualToString:@"changedObjectID"])
        {
          [a5 setValue:&unk_189F04518 forKey:@"generatePairs"];
          uint64_t v38 = (void *)[*(id *)(v23 + 40) objectForKey:@"ENTITY"];
          uint64_t v39 = (void *)[*(id *)(v23 + 40) objectForKey:@"ENTITYPK"];
          uint64_t v30 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithFormat:@"(%@,%@)", objc_msgSend(v38, "columnName"), objc_msgSend(v39, "columnName")];
          goto LABEL_39;
        }

        uint64_t v17 = 0LL;
        uint64_t v30 = 0LL;
        if ([a5 valueForKey:@"NSUnderlyingException"]) {
          goto LABEL_39;
        }
        goto LABEL_53;
      }

      uint64_t v29 = v28;
      if ([v28 count] == 1)
      {
        uint64_t v17 = (unsigned __int8 *)[v29 anyObject];
        goto LABEL_53;
      }

      if ((unint64_t)[v29 count] < 2)
      {
        uint64_t v17 = 0LL;
        goto LABEL_53;
      }

      uint64_t v42 = (void *)MEMORY[0x189603F70];
      uint64_t v43 = *MEMORY[0x189603A60];
      uint64_t v44 = [NSString stringWithFormat:@"Ambiguous keypath %@", self->super._expression];
      uint64_t v72 = @"found";
      uint64_t v73 = [v29 valueForKey:@"propertyDescription"];
      uint64_t v45 = (void *)MEMORY[0x189603F68];
      unint64_t v46 = &v73;
      unint64_t v47 = &v72;
LABEL_115:
      uint64_t v34 = [v45 dictionaryWithObjects:v46 forKeys:v47 count:1];
      int v19 = v42;
      int v20 = v43;
      uint64_t v21 = (const __CFString *)v44;
      goto LABEL_36;
    }

    uint64_t v17 = (unsigned __int8 *)[v41 anyObject];
  }

  BOOL v13 = (id)v23;
  if (!v17) {
    goto LABEL_24;
  }
LABEL_53:
  unint64_t v48 = [v17 propertyType];
  id v49 = (void *)[(id)v23 entityDescription];
  if (v48 > 0xA) {
    goto LABEL_85;
  }
  if (((1 << v48) & 0x42E) != 0) {
    goto LABEL_62;
  }
  if (((1 << v48) & 0x300) != 0)
  {
    uint64_t v50 = [v17 entity];
    if (v50)
    {
      uint64_t v17 = *(unsigned __int8 **)(v50 + 128);
      if (!self) {
        goto LABEL_73;
      }
    }

    else
    {
      uint64_t v17 = 0LL;
      if (!self) {
        goto LABEL_73;
      }
    }

    goto LABEL_63;
  }

  if (v48 != 7)
  {
LABEL_85:
    uint64_t v61 = [v16 firstObject];
    else {
      uint64_t v63 = 0;
    }
    if ([a5 objectForKey:@"NSUnderlyingException"]) {
      goto LABEL_38;
    }
    [a5 setObject:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", @"keypath %@ not found in entity %@", a3, objc_msgSend(v13, "name")), 0), @"NSUnderlyingException" forKey];
    uint64_t v30 = 0LL;
    if (!v63) {
      goto LABEL_39;
    }
    unint64_t v35 = [MEMORY[0x189607968] numberWithBool:1];
    unint64_t v36 = @"LastKeyPathWasTransientProperty";
    goto LABEL_37;
  }

  if (!-[NSSQLIntermediate isTargetColumnsScoped](self, "isTargetColumnsScoped")) {
    uint64_t v17 = (unsigned __int8 *)[v17 foreignKey];
  }
LABEL_62:
  if (!self) {
    goto LABEL_73;
  }
LABEL_63:
  if (-[NSSQLIntermediate isUpdateScoped](self, "isUpdateScoped")) {
    uint64_t v51 = (id)[a5 objectForKey:@"outerFetch"];
  }
  else {
    uint64_t v51 = -[NSSQLIntermediate fetchIntermediateForKeypathExpression:]( self,  "fetchIntermediateForKeypathExpression:",  self->super._expression);
  }
  uint64_t v52 = (const __CFString **)+[NSSQLJoinIntermediate createJoinIntermediatesForKeypath:startEntity:startAlias:forScope:inStatementIntermediate:inContext:]( (uint64_t)&OBJC_CLASS___NSSQLJoinIntermediate,  v16,  (uint64_t)v13,  v14,  self,  (uint64_t)v51,  a5);
  if (!-[NSSQLIntermediate isUpdateScoped](self, "isUpdateScoped"))
  {
    if ([a5 objectForKey:@"NSUnderlyingException"])
    {

      goto LABEL_73;
    }

    if (v52 && *((_BYTE *)v52 + 56))
    {
      __int16 v56 = (id)[objc_alloc(MEMORY[0x189607940]) initWithString:@" "];
      [v56 appendString:v52[5]];
      [v56 appendString:@"."];
      unint64_t v59 = -[NSSQLManyToMany inverseColumnName](v52[2]);
    }

    else
    {
      if (-[NSSQLIntermediate isTargetColumnsScoped](self, "isTargetColumnsScoped")
        && [v17 propertyType] == 7)
      {
        if (v52) {
          BOOL v14 = (__CFString *)v52[4];
        }
        __int16 v56 = (id)[objc_alloc(MEMORY[0x189607940]) initWithString:@" "];
        uint64_t v64 = [v17 destinationEntity];
        if (v64)
        {
          v65 = *(void **)(v64 + 152);
          if (v65)
          {
            if ([v65 count])
            {
              [v56 appendString:v14];
              [v56 appendString:@"."];
              if (v17) {
                unint64_t v66 = (void *)*((void *)v17 + 9);
              }
              else {
                unint64_t v66 = 0LL;
              }
              objc_msgSend(v56, "appendString:", objc_msgSend(v66, "columnName"));
              objc_msgSend(v56, "appendString:", @", ");
            }
          }
        }

        [v56 appendString:v14];
        [v56 appendString:@"."];
        objc_msgSend(v56, "appendString:", objc_msgSend((id)objc_msgSend(v17, "foreignKey"), "columnName"));
        [a5 setObject:v17 forKey:@"keypathExpressionDestinationRelationship"];
        goto LABEL_84;
      }

      __int16 v56 = (id)[objc_alloc(MEMORY[0x189607940]) initWithString:@" "];
      if (![a5 objectForKeyedSubscript:@"fabricatedSQLEntityForReadOnlyFetch"]
        || (uint64_t v67 = [a5 objectForKeyedSubscript:@"fabricatedSQLEntityForReadOnlyFetch"],
            v67 != [v17 entity]))
      {
        if (v52) {
          BOOL v14 = (__CFString *)v52[4];
        }
        [v56 appendString:v14];
        [v56 appendString:@"."];
      }

      if (*(&self->super._allowToMany + 1))
      {
        uint64_t v60 = @"Z_PK";
        goto LABEL_83;
      }

      unint64_t v59 = (const __CFString *)[v17 columnName];
    }

    uint64_t v60 = v59;
LABEL_83:
    [v56 appendString:v60];
LABEL_84:

    goto LABEL_120;
  }

  if (!v52)
  {
    __int16 v56 = objc_alloc_init(MEMORY[0x189607940]);
    unint64_t v57 = [v17 propertyType];
    if ((v57 - 1) >= 3)
    {
      if (v57 == 7)
      {
        if (v17) {
          uint64_t v68 = (unsigned __int8 *)*((void *)v17 + 9);
        }
        else {
          uint64_t v68 = 0LL;
        }
        goto LABEL_118;
      }

      if (v57 != 5)
      {

        if ([a5 objectForKey:@"NSUnderlyingException"]) {
          goto LABEL_73;
        }
        uint64_t v53 = (void *)MEMORY[0x189603F70];
        __int16 v54 = *MEMORY[0x189603A60];
        unint64_t v55 = [NSString stringWithFormat:@"Unsupported property %@ in update", v17];
        goto LABEL_70;
      }
    }

    if (*(&self->super._allowToMany + 1))
    {
      __int16 v58 = @"Z_PK";
LABEL_119:
      [v56 appendString:v58];
      goto LABEL_120;
    }

    uint64_t v68 = v17;
LABEL_118:
    __int16 v58 = (const __CFString *)[v68 columnName];
    goto LABEL_119;
  }

  if (![a5 objectForKey:@"NSUnderlyingException"])
  {
    uint64_t v53 = (void *)MEMORY[0x189603F70];
    __int16 v54 = *MEMORY[0x189603A60];
    unint64_t v55 = [NSString stringWithFormat:@"Unsupported property %@ in update - no joins allowed here", v17];
LABEL_70:
    objc_msgSend( a5,  "setObject:forKey:",  objc_msgSend(v53, "exceptionWithName:reason:userInfo:", v54, v55, 0),  @"NSUnderlyingException");
  }

    uint64_t v23 = -[NSSQLiteAdapter sqlTypeForExpressionConstantValue:]( objc_msgSend((id)objc_msgSend(a3, "objectForKey:", @"persistentStore"), "adapter"),  v12);
    uint64_t v24 = -[NSSQLIntermediate _lastScopedItem](self->super._scope, "_lastScopedItem");
    if (!v24) {
      goto LABEL_77;
    }
    unint64_t v25 = v24;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0
      || ([(id)objc_opt_class() isSimpleKeypath:v25] & 1) == 0
      && !-[NSSQLIntermediate isVariableBasedKeypathScopedBySubquery:]((uint64_t)self, v25))
    {
      goto LABEL_77;
    }

    unint64_t v26 = (void *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v25, "arguments"), "objectAtIndex:", 0),  "constantValue");
    unint64_t v27 = -[NSSQLIntermediate governingEntityForKeypathExpression:](self, "governingEntityForKeypathExpression:", v25);
    uint64_t v28 = (void *)[v26 componentsSeparatedByString:@"."];
    uint64_t v29 = [v28 count];
    v74 = v23;
    if (v29)
    {
      uint64_t v30 = v29;
      uint64_t v31 = [v28 objectAtIndex:0];
      if (v27)
      {
        uint64_t v32 = 1LL;
        while (1)
        {
          uint64_t v33 = (unsigned __int8 *)[v27[5] objectForKey:v31];
          if (!v33) {
            break;
          }
          uint64_t v34 = v33;
          unint64_t v35 = v33[24];
          unint64_t v37 = v30 != v32 && v35 == 7;
          if (v30 == v32) {
            goto LABEL_61;
          }
          uint64_t v31 = [v28 objectAtIndex:v32++];
          if (!v27) {
            goto LABEL_44;
          }
        }

        if ([@"entity" isEqual:v31])
        {
          uint64_t v34 = (unsigned __int8 *)v27[17];
          goto LABEL_61;
        }
      }

      else
      {
LABEL_44:
        [@"entity" isEqual:v31];
      }
    }

    uint64_t v34 = 0LL;
LABEL_61:
    id v49 = [v34 propertyType];
    if (v49 <= 9)
    {
      if (((1 << v49) & 0x38C) != 0)
      {
        uint64_t v50 = 2LL;
LABEL_64:
        if ((void *)[MEMORY[0x189603FE8] null] == v12) {
          uint64_t v12 = 0LL;
        }
        if ((_DWORD)v50)
        {
          if ((_DWORD)v50 == 7 && v74 == 8)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              uint64_t v51 = (void *)MEMORY[0x189607968];
              [v12 timeIntervalSinceReferenceDate];
              uint64_t v12 = (void *)objc_msgSend(v51, "numberWithDouble:");
            }

            uint64_t v23 = 7LL;
          }

          else
          {
            uint64_t v23 = v50;
          }
        }

        else
        {
          uint64_t v23 = v74;
        }

    int v19 = 0x7FFFFFFFFFFFFFFFLL;
    location = v18;
    uint64_t v7 = v23;
    if (v11 <= v16) {
      return v19;
    }
  }

  int v19 = location;
  while (v8 != *(void **)(v12 + 8 * v19) && (v9(v8, sel_isEqual_) & 1) == 0)
  {
    if (v18 == ++v19) {
      goto LABEL_24;
    }
  }

  return v19;
}

    _NSCoreDataLog(1LL, (uint64_t)@"  MNT_ROOTFS", v129, v130, v131, v132, v133, v134, v196);
    f_flags = v198.f_flags;
    if ((v198.f_flags & 0x200000) == 0)
    {
LABEL_17:
      if ((f_flags & 0x800000) == 0) {
        goto LABEL_18;
      }
      goto LABEL_26;
    }

    uint64_t v21 = ppStmt;
  }

  unint64_t v27 = sqlite3_column_int64(v21, 0);
  uint64_t v28 = sqlite3_finalize(ppStmt);
  ppStmt = 0LL;
  if ((_DWORD)v28)
  {
    uint64_t v39 = v28;
    uint64_t v40 = [NSString stringWithUTF8String:sqlite3_errmsg(*(sqlite3 **)(a1 + 72))];
    uint64_t v41 = *MEMORY[0x189603A58];
    uint64_t v34 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithInt:", v39),  @"NSSQLiteErrorDomain");
    unint64_t v35 = v41;
    unint64_t v36 = (const __CFString *)v40;
LABEL_29:
    uint64_t v38 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  v35,  256LL,  (uint64_t)v36,  v34);
    objc_exception_throw(v38);
    return 0LL;
  }

  return v27;
}

    uint64_t v15 = (void *)v15[16];
    goto LABEL_32;
  }

  unint64_t v9 = -[NSSQLProperty isToMany](relationship, "isToMany");
  uint64_t v4 = objc_alloc_init(MEMORY[0x189607940]);
  int v10 = self->_sourceAlias;
  if (v9)
  {
    if (!v10) {
      int v10 = -[NSSQLIntermediate governingAlias](self, "governingAlias");
    }
    uint64_t v11 = self->_type;
    if (v11 == 1)
    {
      uint64_t v12 = @"INNER ";
    }

    else
    {
      if (v11 != 2)
      {
LABEL_27:
        [v4 appendString:@"JOIN "];
        objc_msgSend( v4,  "appendString:",  objc_msgSend(-[NSSQLRelationship destinationEntity](self->_relationship, "destinationEntity"), "tableName"));
        [v4 appendString:@" "];
        [v4 appendString:self->_destinationAlias];
        [v4 appendString:@" ON "];
        [v4 appendString:v10];
        [v4 appendString:@"."];
        unint64_t v16 = -[NSSQLRelationship sourceEntity](self->_relationship, "sourceEntity");
        if (v16) {
          unint64_t v16 = (void *)v16[16];
        }
        objc_msgSend(v4, "appendString:", objc_msgSend(v16, "columnName"));
        [v4 appendString:@" = "];
        [v4 appendString:self->_destinationAlias];
        [v4 appendString:@"."];
        uint64_t v17 = self->_relationship;
        if (v17) {
          inverse = v17->_inverse;
        }
        else {
          inverse = 0LL;
        }
        uint64_t v15 = -[NSSQLRelationship foreignKey](inverse, "foreignKey");
        goto LABEL_32;
      }

      uint64_t v12 = @"LEFT OUTER ";
    }

    [v4 appendString:v12];
    goto LABEL_27;
  }

  if (!v10) {
    int v10 = -[NSSQLIntermediate governingAlias](self, "governingAlias");
  }
  BOOL v13 = self->_type;
  if (v13 == 1)
  {
    BOOL v14 = @"INNER ";
  }

  else
  {
    if (v13 != 2) {
      goto LABEL_36;
    }
    BOOL v14 = @"LEFT OUTER ";
  }

  [v4 appendString:v14];
LABEL_36:
  [v4 appendString:@"JOIN "];
  objc_msgSend( v4,  "appendString:",  -[NSSQLRelationship correlationTableName](self->_relationship, "correlationTableName"));
  [v4 appendString:@" "];
  [v4 appendString:self->_correlationAlias];
  [v4 appendString:@" ON "];
  [v4 appendString:v10];
  [v4 appendString:@"."];
  int v20 = -[NSSQLRelationship sourceEntity](self->_relationship, "sourceEntity");
  if (v20) {
    int v20 = (void *)v20[16];
  }
  objc_msgSend(v4, "appendString:", objc_msgSend(v20, "columnName"));
  [v4 appendString:@" = "];
  [v4 appendString:self->_correlationAlias];
  [v4 appendString:@"."];
  objc_msgSend(v4, "appendString:", -[NSSQLProperty columnName](self->_relationship, "columnName"));
  if (!self->_direct)
  {
    uint64_t v21 = self->_type;
    if (v21 == 1)
    {
      uint64_t v22 = @" INNER";
    }

    else
    {
      if (v21 != 2) {
        goto LABEL_44;
      }
      uint64_t v22 = @" LEFT OUTER";
    }

    [v4 appendString:v22];
LABEL_44:
    [v4 appendString:@" JOIN "];
    objc_msgSend( v4,  "appendString:",  objc_msgSend(-[NSSQLRelationship destinationEntity](self->_relationship, "destinationEntity"), "tableName"));
    [v4 appendString:@" "];
    [v4 appendString:self->_destinationAlias];
    [v4 appendString:@" ON "];
    [v4 appendString:self->_correlationAlias];
    [v4 appendString:@"."];
    [v4 appendString:-[NSSQLManyToMany inverseColumnName]((const __CFString *)self->_relationship)];
    [v4 appendString:@" = "];
    [v4 appendString:self->_destinationAlias];
    [v4 appendString:@"."];
    uint64_t v15 = -[NSSQLRelationship destinationEntity](self->_relationship, "destinationEntity");
    if (!v15) {
      goto LABEL_32;
    }
    goto LABEL_24;
  }

  return v4;
}

                          id v6 = 0LL;
                          return v6;
                        }

LABEL_70:
        uint64_t v17 = -[NSSQLSelectIntermediate initWithEntity:alias:fetchColumns:inScope:]( [NSSQLReadOnlySelectIntermediate alloc],  "initWithEntity:alias:fetchColumns:inScope:",  v3,  [v2 governingAlias],  v18,  v2);
        goto LABEL_72;
      }

      int v18 = (void *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v4, "entity"), "attributesByName"),  "allValues"),  "mutableCopy");
      [v18 sortUsingFunction:_comparePropertiesByName context:0];
      uint64_t v39 = [v18 count];
      if (v39 - 1 < 0) {
        goto LABEL_70;
      }
      uint64_t v40 = v39;
      while (1)
      {
        uint64_t v41 = (void *)[v18 objectAtIndex:--v40];
        if (([v41 isTransient] & 1) == 0)
        {
          if (!v41 || [v41 attributeType] != 2100) {
            goto LABEL_69;
          }
          objc_msgSend( v18,  "addObjectsFromArray:",  objc_msgSend(v41, "_flattenElements:", objc_msgSend(v41, "elements")));
        }

        [v18 removeObjectAtIndex:v40];
LABEL_69:
        if (v40 <= 0) {
          goto LABEL_70;
        }
      }
    }

    if (([v4 includesPropertyValues] & 1) == 0)
    {
      unint64_t v36 = (void *)[MEMORY[0x189603FA8] arrayWithCapacity:2];
      unint64_t v37 = v36;
      if (v3)
      {
        [v36 insertObject:v3[17] atIndex:0];
        uint64_t v38 = v3[16];
      }

      else
      {
        [v36 insertObject:0 atIndex:0];
        uint64_t v38 = 0LL;
      }

      [v37 insertObject:v38 atIndex:1];
      if (!v3) {
        goto LABEL_84;
      }
      goto LABEL_81;
    }

    if ([v4 includesSubentities])
    {
      if (v3)
      {
        uint64_t v32 = (void *)v3[19];
        if (v32 && [v32 count])
        {
          uint64_t v33 = v3;
          while (v33)
          {
            uint64_t v34 = v33;
            uint64_t v33 = (void *)v33[21];
            if (v33 == v34) {
              goto LABEL_80;
            }
          }

          goto LABEL_90;
        }

  objc_autoreleasePoolPop(v12);
}

    *(_WORD *)(a5 + 72) |= 0x1000u;
    if ((v53 & 0x20) == 0)
    {
LABEL_62:
      if ((v53 & 0x40) == 0)
      {
LABEL_64:
        unint64_t v16 = v52;
        goto LABEL_65;
      }

          *(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8LL) + 24LL) = 0;
        }
      }

      goto LABEL_71;
    }

    if (![v2 count])
    {
      unint64_t v46 = [NSString stringWithUTF8String:"Asked to purge user rows without any zones from which to purge."];
      _NSCoreDataLog(17LL, v46, v47, v48, v49, v50, v51, v52, v122);
      uint64_t v53 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v160 = 0;
        _os_log_fault_impl( &dword_186681000,  v53,  OS_LOG_TYPE_FAULT,  "CoreData: Asked to purge user rows without any zones from which to purge.",  v160,  2u);
      }
    }

    v153 = 0u;
    v154 = 0u;
    v151 = 0u;
    v152 = 0u;
    v129 = [v2 countByEnumeratingWithState:&v151 objects:v191 count:16];
    if (!v129)
    {
LABEL_71:
      unint64_t v9 = v130;
      if ((*(_BYTE *)(v130 + 81) & 1) != 0)
      {
        +[NSCKMetadataEntry updateOrInsertMetadataEntryWithKey:BOOLValue:forStore:intoManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMetadataEntry,  (uint64_t)@"NSCloudKitMirroringDelegateBypassHistoryOnExportKey",  1,  *(void *)(v130 + 32),  *(void **)(v130 + 48),  &v159);
        unint64_t v9 = v130;
        if (v159 || (v90 = [*(id *)(v130 + 48) save:&v159], unint64_t v9 = v130, (v90 & 1) == 0)) {
          *(_BYTE *)(*(void *)(*(void *)(v9 + 64) + 8LL) + 24LL) = 0;
        }
      }

      goto LABEL_75;
    }

    v125 = *(void *)v152;
LABEL_42:
    __int16 v54 = 0LL;
    while (1)
    {
      if (*(void *)v152 != v125) {
        objc_enumerationMutation(v2);
      }
      unint64_t v55 = *(void **)(*((void *)&v151 + 1) + 8 * v54);
      __int16 v56 = (void *)MEMORY[0x186E3E5D8]();
      else {
        unint64_t v57 = __ckLoggingOverride;
      }
      __int16 v58 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Removing cloud metadata and client rows in zone: %@"];
      [*(id *)(v130 + 48) transactionAuthor];
      _NSCoreDataLog( v57,  v58,  v59,  v60,  v61,  v62,  v63,  v64,  (uint64_t)"-[PFCloudKitMetadataPurger purgeMetadataFromStore:inMonitor:withOptions:forRecordZones:inDatabaseWithSc ope:andTransactionAuthor:error:]_block_invoke");
      objc_autoreleasePoolPop(v56);
      v65 = *(uint64_t **)(v130 + 56);
      if (!v65) {
        goto LABEL_70;
      }
      v127 = *(void *)(v130 + 88);
      unint64_t v66 = *(void *)(v130 + 32);
      uint64_t v67 = *(void **)(v130 + 48);
      v182 = 0LL;
      v183 = &v182;
      v184 = 0x2020000000LL;
      v185 = 1;
      v176 = 0LL;
      v177 = &v176;
      v178 = 0x3052000000LL;
      v179 = __Block_byref_object_copy__30;
      v180 = __Block_byref_object_dispose__30;
      v181 = 0LL;
      uint64_t v68 = objc_alloc_init(MEMORY[0x189603FC8]);
      uint64_t v69 = +[NSFetchRequest fetchRequestWithEntityName:]( &OBJC_CLASS___NSFetchRequest,  "fetchRequestWithEntityName:",  +[NSCKRecordMetadata entityPath](&OBJC_CLASS___NSCKRecordMetadata, "entityPath"));
      uint64_t v70 = (void *)MEMORY[0x1896079C8];
      v122 = [v55 zoneName];
      [v55 ownerName];
      -[NSFetchRequest setPredicate:]( v69,  "setPredicate:",  [v70 predicateWithFormat:@"recordZone.ckRecordZoneName = %@ AND recordZone.ckOwnerName = %@ AND entityId != NULL AND entityPK != NULL"]);
      -[NSFetchRequest setPropertiesToFetch:](v69, "setPropertiesToFetch:", &unk_189F0B2C8);
      v200[0] = v66;
      -[NSFetchRequest setAffectedStores:]( v69,  "setAffectedStores:",  [MEMORY[0x189603F18] arrayWithObjects:v200 count:1]);
      -[NSFetchRequest setFetchBatchSize:](v69, "setFetchBatchSize:", 1000LL);
      v169 = MEMORY[0x1895F87A8];
      v170 = 3221225472LL;
      v171 = __113__PFCloudKitMetadataPurger__wipeUserRowsAndMetadataForZoneWithID_inDatabaseWithScope_inStore_usingContext_error___block_invoke;
      v172 = &unk_189EA8828;
      v173 = v68;
      v174 = &v182;
      v175 = &v176;
      +[_PFRoutines efficientlyEnumerateManagedObjectsInFetchRequest:usingManagedObjectContext:andApplyBlock:]( (uint64_t)&OBJC_CLASS____PFRoutines,  (uint64_t)v69,  v67,  (uint64_t)&v169);
      v199 = 0LL;
      uint64_t v71 = v183;
      if (*((_BYTE *)v183 + 24))
      {
        *(void *)v160 = MEMORY[0x1895F87A8];
        v161 = 3221225472LL;
        v162 = __113__PFCloudKitMetadataPurger__wipeUserRowsAndMetadataForZoneWithID_inDatabaseWithScope_inStore_usingContext_error___block_invoke_2;
        v163 = &unk_189EAA5B0;
        v164 = v66;
        v165 = v65;
        v166 = (uint64_t *)v67;
        v167 = &v182;
        v168 = &v176;
        [v68 enumerateKeysAndObjectsUsingBlock:v160];
        uint64_t v71 = v183;
        if (*((_BYTE *)v183 + 24))
        {
          uint64_t v72 = +[NSFetchRequest fetchRequestWithEntityName:]( &OBJC_CLASS___NSFetchRequest,  "fetchRequestWithEntityName:",  +[NSCKRecordMetadata entityPath](&OBJC_CLASS___NSCKRecordMetadata, "entityPath"));
          -[NSFetchRequest setReturnsObjectsAsFaults:](v72, "setReturnsObjectsAsFaults:", 0LL);
          -[NSFetchRequest setFetchBatchSize:](v72, "setFetchBatchSize:", 250LL);
          uint64_t v73 = (void *)MEMORY[0x1896079C8];
          v122 = [v55 zoneName];
          [v55 ownerName];
          -[NSFetchRequest setPredicate:]( v72,  "setPredicate:",  [v73 predicateWithFormat:@"recordZone.ckRecordZoneName = %@ AND recordZone.ckOwnerName = %@"]);
          v194 = v66;
          -[NSFetchRequest setAffectedStores:]( v72,  "setAffectedStores:",  [MEMORY[0x189603F18] arrayWithObjects:&v194 count:1]);
          if (!-[PFCloudKitMetadataPurger _purgeObjectsMatchingFetchRequest:fromStore:usingContext:error:]( (uint64_t)v72,  v67,  &v199)) {
            goto LABEL_56;
          }
          v74 = +[NSFetchRequest fetchRequestWithEntityName:]( &OBJC_CLASS___NSFetchRequest,  "fetchRequestWithEntityName:",  +[NSCKMirroredRelationship entityPath](&OBJC_CLASS___NSCKMirroredRelationship, "entityPath"));
          -[NSFetchRequest setReturnsObjectsAsFaults:](v74, "setReturnsObjectsAsFaults:", 0LL);
          -[NSFetchRequest setFetchBatchSize:](v74, "setFetchBatchSize:", 250LL);
          unint64_t v75 = (void *)MEMORY[0x1896079C8];
          v122 = [v55 zoneName];
          [v55 ownerName];
          -[NSFetchRequest setPredicate:]( v74,  "setPredicate:",  [v75 predicateWithFormat:@"recordZone.ckRecordZoneName = %@ AND recordZone.ckOwnerName = %@"]);
          v193 = v66;
          -[NSFetchRequest setAffectedStores:]( v74,  "setAffectedStores:",  [MEMORY[0x189603F18] arrayWithObjects:&v193 count:1]);
          if (!-[PFCloudKitMetadataPurger _purgeObjectsMatchingFetchRequest:fromStore:usingContext:error:]( (uint64_t)v74,  v67,  &v199))
          {
LABEL_56:
            *((_BYTE *)v183 + 24) = 0;
            uint64_t v78 = v199;
            goto LABEL_57;
          }

          unint64_t v76 = +[NSCKRecordZoneMetadata zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:error:]( (uint64_t)&OBJC_CLASS___NSCKRecordZoneMetadata,  v55,  v127,  v66,  v67,  (uint64_t)&v199);
          if (!v76)
          {
            uint64_t v71 = v183;
LABEL_67:
            *((_BYTE *)v71 + 24) = 0;
            uint64_t v78 = v199;
LABEL_57:
            v177[5] = (uint64_t)v78;
            uint64_t v71 = v183;
            goto LABEL_58;
          }

          [v67 deleteObject:v76];
          uint64_t v77 = [v67 save:&v199];
          uint64_t v71 = v183;
          if ((v77 & 1) == 0) {
            goto LABEL_67;
          }
        }
      }

LABEL_76:
        unint64_t v37 = (id)v3[10];
        if (v37)
        {
LABEL_81:
          if (v3[20] || (uint64_t v43 = (void *)v3[19]) != 0 && [v43 count])
          {
LABEL_87:
            uint64_t v17 = -[NSSQLSelectIntermediate initWithEntity:alias:fetchColumns:inScope:]( [NSSQLSelectIntermediate alloc],  "initWithEntity:alias:fetchColumns:inScope:",  v3,  [v2 governingAlias],  v37,  v2);
            goto LABEL_88;
          }

                uint64_t v24 = (__CFString *)v9;
                unint64_t v25 = v22;
                break;
              case 3LL:
                goto LABEL_29;
              case 4LL:
                if ([v19 isToMany])
                {
LABEL_29:
                  objc_opt_class();
                  if ((objc_opt_isKindOfClass() & 1) != 0
                    || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)
                    || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                  {
                    if (-[__CFString isFault](v22, "isFault"))
                    {
                      unint64_t v25 = (const __CFString *)[NSString stringWithFormat:@"<relationship fault: %p '%@'>", v22, objc_msgSend( (id)-[__CFString relationship](v22, "relationship"), "name")];
                      uint64_t v24 = (__CFString *)v9;
                      break;
                    }
                  }

                  unint64_t v26 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  -[__CFString count](v22, "count"));
                  uint64_t v52 = 0u;
                  uint64_t v53 = 0u;
                  __int16 v54 = 0u;
                  unint64_t v55 = 0u;
                  unint64_t v27 = -[__CFString countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v52,  v56,  16LL);
                  if (!v27) {
                    goto LABEL_54;
                  }
                  uint64_t v28 = v27;
                  uint64_t v29 = 0LL;
                  uint64_t v30 = *(void *)v53;
                  while (1)
                  {
                    uint64_t v31 = 0LL;
                    if (v29 <= 0xA) {
                      uint64_t v32 = 10 - v29;
                    }
                    else {
                      uint64_t v32 = 0LL;
                    }
                    do
                    {
                      if (*(void *)v53 != v30) {
                        objc_enumerationMutation(v22);
                      }
                      if (v32 == v31)
                      {
                        [v26 addObject:objc_msgSend( NSString, "stringWithFormat:", @"(...and %ld more...)", -[__CFString count](v22, "count") - 10)];
LABEL_54:
                        unint64_t v9 = v47;
                        -[__CFString setObject:forKey:](v47, "setObject:forKey:", v26, v20);

                        int v2 = v48;
                        uint64_t v17 = v49;
                        uint64_t v11 = v46;
                        goto LABEL_78;
                      }

                      objc_msgSend( v26,  "addObject:",  objc_msgSend(*(id *)(*((void *)&v52 + 1) + 8 * v31++), "objectID"));
                    }

                    while (v28 != v31);
                    uint64_t v28 = -[__CFString countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v52,  v56,  16LL);
                    v29 += v31;
                    if (!v28) {
                      goto LABEL_54;
                    }
                  }
                }

                uint64_t v33 = -[__CFString objectID](v22, "objectID");
                goto LABEL_75;
              default:
                uint64_t v24 = (__CFString *)v9;
                unint64_t v25 = @"(...not nil..)";
                break;
            }
          }

          else
          {
            uint64_t v24 = (__CFString *)v9;
            unint64_t v25 = @"nil";
          }

          -[__CFString setObject:forKey:](v24, "setObject:forKey:", v25, v20);
LABEL_78:
          objc_autoreleasePoolPop(v18);
          if (++v16 == v17)
          {
            BOOL v5 = v43;
            int v3 = v44;
            uint64_t v7 = v41;
            id v6 = v42;
            uint64_t v8 = v40;
            break;
          }
        }
      }
    }

    else
    {
      unint64_t v9 = 0LL;
    }

  uint64_t v60 = [v68 copy];

  return v60;
}

  v136 = 1LL;
LABEL_78:
  objc_autoreleasePoolPop(context);
  return v136;
}

LABEL_84:
          unint64_t v37 = (id)[v37 mutableCopy];
          uint64_t v44 = -[NSSQLColumn initWithColumnName:sqlType:]( objc_alloc(&OBJC_CLASS___NSSQLColumn),  "initWithColumnName:sqlType:",  @"0",  1LL);
          uint64_t v45 = v44;
          if (v44) {
            *(_WORD *)&v44->super._flags &= ~1u;
          }
          [v37 replaceObjectAtIndex:0 withObject:v44];

          goto LABEL_87;
        }

        uint64_t v42 = v3;
        while (v42)
        {
          uint64_t v34 = v42;
          uint64_t v42 = (void *)v42[21];
          if (v42 == v34)
          {
LABEL_80:
            unint64_t v37 = (id)v34[9];
            goto LABEL_81;
          }
        }

LABEL_90:
        unint64_t v37 = 0LL;
        goto LABEL_81;
      }
    }

    else if (v3)
    {
      goto LABEL_76;
    }

    unint64_t v37 = 0LL;
    goto LABEL_84;
  }

  if (!v8)
  {
    if (v3) {
      uint64_t v29 = v3[16];
    }
    else {
      uint64_t v29 = 0LL;
    }
    uint64_t v30 = -[NSSQLSelectIntermediate initWithEntity:alias:fetchColumns:inScope:]( [NSSQLSelectIntermediate alloc],  "initWithEntity:alias:fetchColumns:inScope:",  v3,  [v2 governingAlias],  objc_msgSend(MEMORY[0x189603FA8], "arrayWithObject:", v29),  v2);
    uint64_t v17 = (NSSQLReadOnlySelectIntermediate *)v30;
    if (v5 != 4 || !v30) {
      goto LABEL_88;
    }
    uint64_t v31 = &OBJC_IVAR___NSSQLSelectIntermediate__isCount;
    goto LABEL_74;
  }

  unint64_t v9 = objc_msgSend((id)objc_msgSend(v4, "propertiesToFetch"), "count");
  if (v9 == 1)
  {
    int v10 = (void *)[MEMORY[0x189603FA8] array];
    uint64_t v52 = 0u;
    uint64_t v53 = 0u;
    __int16 v54 = 0u;
    unint64_t v55 = 0u;
    uint64_t v11 = (void *)[v4 propertiesToFetch];
    uint64_t v12 = [v11 countByEnumeratingWithState:&v52 objects:v57 count:16];
    if (v12)
    {
      BOOL v13 = v12;
      BOOL v14 = *(void *)v53;
      do
      {
        for (j = 0LL; j != v13; ++j)
        {
          if (*(void *)v53 != v14) {
            objc_enumerationMutation(v11);
          }
          unint64_t v16 = *(void **)(*((void *)&v52 + 1) + 8 * j);
          if (([v16 isTransient] & 1) == 0) {
            [v10 addObject:v16];
          }
        }

        BOOL v13 = [v11 countByEnumeratingWithState:&v52 objects:v57 count:16];
      }

      while (v13);
    }

    uint64_t v17 = -[NSSQLSelectIntermediate initWithEntity:alias:fetchColumns:inScope:]( [NSSQLReadOnlySelectIntermediate alloc],  "initWithEntity:alias:fetchColumns:inScope:",  v3,  [v2 governingAlias],  v10,  v2);
LABEL_72:
    if (!v17)
    {
LABEL_88:
      -[NSSQLFetchIntermediate setSelectIntermediate:]((uint64_t)v2, v17);

      return;
    }

    uint64_t v31 = &OBJC_IVAR___NSSQLSelectIntermediate__useDistinct;
LABEL_74:
    *((_BYTE *)&v17->super.super.super.isa + *v31) = 1;
    goto LABEL_88;
  }

  unint64_t v35 = @"Too many";
  if (!v9) {
    unint64_t v35 = @"Too few";
  }
  [a1 setValue:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", @"Bad NSFetchRequestExpression (%@ propertiesToFetch)", v35), 0), @"NSUnderlyingException" forKey];
}

  if (!*((_BYTE *)v128 + 24))
  {
    [a3 setMigratedStore:0];
    unint64_t v99 = (id)v122[5];
    if (v99)
    {
      if (a4) {
        *a4 = v99;
      }
    }

    else
    {
      uint64_t v100 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v100,  v101,  v102,  v103,  v104,  v105,  v106,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentStoreCoordinator.m");
      v107 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        v132 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentStoreCoordinator.m";
        v133 = 1024;
        v134 = 4121;
        _os_log_fault_impl( &dword_186681000,  v107,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }
  }

  v122[5] = 0LL;
  unint64_t v97 = *((unsigned __int8 *)v128 + 24);
  _Block_object_dispose(&v121, 8);
  _Block_object_dispose(&v127, 8);
  return v97;
}

        ++v20;
      }

      while (v20 != v19);
      uint64_t v71 = [v17 countByEnumeratingWithState:&v139 objects:v144 count:16];
      int v19 = v71;
    }

    while (v71);
  }

  v137 = 0u;
  v138 = 0u;
  v135 = 0u;
  v136 = 0u;
  uint64_t v72 = (void *)[v123 subentities];
  uint64_t v73 = [v72 countByEnumeratingWithState:&v135 objects:v143 count:16];
  v74 = v124;
  if (v73)
  {
    unint64_t v75 = v73;
    unint64_t v76 = *(void *)v136;
    while (2)
    {
      for (uint64_t i = 0LL; i != v75; ++i)
      {
        if (*(void *)v136 != v76) {
          objc_enumerationMutation(v72);
        }
        if (!-[NSSQLiteAdapter generateTriggerForEntity:alreadyCreated:correlations:batchHistory:fragments:error:]( a1,  *(void *)(*((void *)&v135 + 1) + 8 * i),  a3,  a4,  a5,  v124,  a7))
        {
          uint64_t v15 = 0LL;
          goto LABEL_138;
        }
      }

      unint64_t v75 = [v72 countByEnumeratingWithState:&v135 objects:v143 count:16];
      if (v75) {
        continue;
      }
      break;
    }
  }

  if (!v122)
  {
    if ([v124 count])
    {
      uint64_t v78 = (void *)_sqlCoreLookupSQLEntityForEntityDescription(*(void **)(a1 + 8), v123);
      uint64_t v79 = [v78 tableName];
      uint64_t v80 = objc_alloc_init(MEMORY[0x189607940]);
      [v124 sortUsingComparator:&__block_literal_global_17];
      v153 = 0u;
      v154 = 0u;
      v151 = 0u;
      v152 = 0u;
      uint64_t v81 = [v124 countByEnumeratingWithState:&v151 objects:v150 count:16];
      if (v81)
      {
        uint64_t v82 = v81;
        uint64_t v83 = *(void *)v152;
        do
        {
          for (j = 0LL; j != v82; ++j)
          {
            if (*(void *)v152 != v83) {
              objc_enumerationMutation(v124);
            }
            objc_msgSend(v80, "appendString:", objc_msgSend(*(id *)(*((void *)&v151 + 1) + 8 * j), "lastObject"));
            [v80 appendString:@"; "];
          }

          uint64_t v82 = [v124 countByEnumeratingWithState:&v151 objects:v150 count:16];
        }

        while (v82);
      }

      unint64_t v85 = (NSString *)[NSString stringWithFormat:@"CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_%@_TRIGGER AFTER DELETE ON %@ FOR EACH ROW BEGIN %@ END", v79, v79, v80];

      unint64_t v86 = -[NSSQLiteStatement initWithEntity:](objc_alloc(&OBJC_CLASS___NSSQLiteStatement), "initWithEntity:", v78);
      unint64_t v87 = v86;
      if (v86)
      {
        sqlString = v86->_sqlString;
        if (sqlString != v85)
        {

          v87->_sqlString = (NSString *)-[NSString copy](v85, "copy");
        }
      }

      v89 = (NSString *)[NSString stringWithFormat:@"DROP TRIGGER IF EXISTS ZQ_%@_TRIGGER", v79];
      v90 = -[NSSQLiteStatement initWithEntity:](objc_alloc(&OBJC_CLASS___NSSQLiteStatement), "initWithEntity:", v78);
      uint64_t v91 = v90;
      a3 = theDict;
      if (v90)
      {
        v92 = v90->_sqlString;
        if (v92 != v89)
        {

          v91->_sqlString = (NSString *)-[NSString copy](v89, "copy");
        }
      }

      uint64_t v15 = objc_msgSend(MEMORY[0x189603FA8], "arrayWithObjects:", v87, v91, 0);

      a5 = v126;
    }

    else
    {
      uint64_t v15 = [MEMORY[0x189603FA8] array];
    }

    if (!v15) {
      return v15;
    }
    if ([(id)v15 count])
    {
      Value = (void *)CFDictionaryGetValue(a3, v14);
      else {
        [Value addObjectsFromArray:v15];
      }
    }

    if (a5)
    {
      v106 = *(void *)(a1 + 8);
      v107 = v106
           ? (void *)[*(id *)(v106 + 240) objectForKey:@"NSPersistentHistoryTrackingEntitiesToInclude"]
           : 0LL;
      if (objc_msgSend(v107, "containsObject:", objc_msgSend(v14, "name")))
      {
        v108 = objc_msgSend((id)objc_msgSend(v14, "managedObjectModel"), "_modelsReferenceIDOffset");
        if (v108 != +[_PFPersistentHistoryModel ancillaryEntityOffset]( &OBJC_CLASS____PFPersistentHistoryModel,  "ancillaryEntityOffset"))
        {
          v109 = (const void *)-[NSSQLiteAdapter generateDeleteHistoryTriggerForEntity:error:](a1, v14);
          v110 = (void *)CFDictionaryGetValue(a5, v14);
          v111 = [MEMORY[0x189603FE8] null];
          else {
            [v110 addObjectsFromArray:v109];
          }
        }
      }
    }

    v74 = 0LL;
  }

  uint64_t v15 = 1LL;
LABEL_138:

  return v15;
}

LABEL_104:
              if ([a3 objectForKey:@"LastKeyPathWasTransientProperty"])
              {
                [a3 removeObjectForKey:@"NSUnderlyingException"];
                [a3 removeObjectForKey:@"LastKeyPathWasTransientProperty"];
              }

              else if (![a3 objectForKey:@"NSUnderlyingException"])
              {
                uint64_t v63 = (void *)MEMORY[0x189603F70];
                uint64_t v64 = *MEMORY[0x189603A60];
                v65 = [NSString stringWithFormat:@"Unable to generate where clause for predicate (%@) (unknown problem)", self->super._predicate];
                objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend( v63,  "exceptionWithName:reason:userInfo:",  v64,  v65,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  self->super._predicate,  @"predicate")),  @"NSUnderlyingException");
              }

              unint64_t v9 = 0LL;
              goto LABEL_109;
            }

            unint64_t v59 = [MEMORY[0x189603FE8] null] == v60;
          }

          uint64_t v61 = v37 || v59;
          if (v37) {
            uint64_t v62 = v35;
          }
          else {
            uint64_t v62 = v34;
          }
          if (v61 != 1)
          {
            if (-[NSPredicate options](self->super._predicate, "options"))
            {
LABEL_101:
              uint64_t v21 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLType3InContext:]((uint64_t)self, a3);
              goto LABEL_102;
            }

            if (!self->_comparisonPredicateScopedItem) {
              self->_comparisonPredicateScopedItem = (NSMutableArray *)objc_alloc_init(MEMORY[0x189603FA8]);
            }
            if (-[NSExpression expressionType](v34, "expressionType") == NSKeyPathExpressionType
              && (v68 = -[NSExpression expressionType](v35, "expressionType"), uint64_t v67 = v34, !v68)
              || -[NSExpression expressionType](v35, "expressionType", v67) == NSKeyPathExpressionType
              && (v69 = -[NSExpression expressionType](v34, "expressionType"), uint64_t v67 = v35, !v69))
            {
              -[NSMutableArray addObject:](self->_comparisonPredicateScopedItem, "addObject:", v67);
              uint64_t v70 = v36 == 2;
              uint64_t v81 = (__CFString *)-[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:]( self,  v34,  v70,  a3);
              if (v81)
              {
                unint64_t v9 = v81;
                int v19 = 1;
                goto LABEL_139;
              }

              -[NSMutableArray removeLastObject](self->_comparisonPredicateScopedItem, "removeLastObject");
            }

            else
            {
              uint64_t v70 = v36 == 2;
              uint64_t v71 = (__CFString *)-[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:]( self,  v34,  v70,  a3);
              if (v71)
              {
                unint64_t v9 = v71;
                int v19 = 0;
LABEL_139:
                uint64_t v82 = -[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:](self, v35, v70, a3);
                if (v82)
                {
                  unint64_t v57 = v82;
                  __int16 v58 = -[NSSQLSimpleWhereIntermediate _sqlTokenForPredicateOperator:inContext:]( -[NSPredicate predicateOperatorType](self->super._predicate, "predicateOperatorType"),  a3);
                  if (v58)
                  {
LABEL_141:
                    uint64_t v83 = v58;
                    -[__CFString appendString:](v9, "appendString:", @" ");
                    -[__CFString appendString:](v9, "appendString:", v83);
                    -[__CFString appendString:](v9, "appendString:", @" ");
                    -[__CFString appendString:](v9, "appendString:", v57);

                    if (v19) {
                      -[NSMutableArray removeLastObject](self->_comparisonPredicateScopedItem, "removeLastObject");
                    }
                    goto LABEL_109;
                  }

                  [a3 setObject:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", @"Unable to generate SQL for predicate (%@) (problem with operator)", self->super._predicate), 0), @"NSUnderlyingException" forKey];

                  if (v19) {
                    -[NSMutableArray removeLastObject](self->_comparisonPredicateScopedItem, "removeLastObject");
                  }
                  goto LABEL_104;
                }

                if (v19) {
                  -[NSMutableArray removeLastObject](self->_comparisonPredicateScopedItem, "removeLastObject");
                }
                if ([a3 objectForKey:@"LastKeyPathWasTransientProperty"]
                  || [a3 objectForKey:@"NSUnderlyingException"])
                {
                  goto LABEL_104;
                }

                unint64_t v85 = (void *)MEMORY[0x189603F70];
                unint64_t v86 = *MEMORY[0x189603A60];
                unint64_t v87 = [NSString stringWithFormat:@"Unable to generate SQL for predicate (%@) (problem on RHS)", self->super._predicate];
LABEL_171:
                uint64_t v42 = (const __CFString *)v87;
                uint64_t v40 = v85;
                uint64_t v41 = v86;
LABEL_48:
                uint64_t v43 = 0LL;
                goto LABEL_57;
              }
            }

            if ([a3 objectForKey:@"LastKeyPathWasTransientProperty"]
              || [a3 objectForKey:@"NSUnderlyingException"])
            {
              goto LABEL_104;
            }

            unint64_t v85 = (void *)MEMORY[0x189603F70];
            unint64_t v86 = *MEMORY[0x189603A60];
            unint64_t v87 = [NSString stringWithFormat:@"Unable to generate SQL for predicate (%@) (problem on LHS)", self->super._predicate];
            goto LABEL_171;
          }

          goto LABEL_121;
        case 6LL:
          uint64_t v44 = CFSTR(" NSCoreDataMatches(");
          goto LABEL_54;
        case 7LL:
          uint64_t v44 = CFSTR(" NSCoreDataLike(");
LABEL_54:
          uint64_t v21 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLForMatchingOperator:inContext:]( (uint64_t)self,  v44,  a3);
          goto LABEL_102;
        case 8LL:
          uint64_t v21 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLBeginsWithStringInContext:]((uint64_t)self, a3);
          goto LABEL_102;
        case 9LL:
          uint64_t v21 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLSubstringWildStart:wildEnd:inContext:]( (uint64_t)self,  1,  0,  a3);
          goto LABEL_102;
        case 10LL:
          goto LABEL_27;
        default:
          goto LABEL_56;
      }
    }

    if (v5 != 99)
    {
      if (v5 == 100)
      {
        uint64_t v21 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLBetweenStringInContext:]((uint64_t)self, a3);
      }

      else
      {
        if (v5 != 2000)
        {
LABEL_56:
          uint64_t v45 = (void *)MEMORY[0x189603F70];
          unint64_t v46 = *MEMORY[0x189603A60];
          uint64_t v43 = [MEMORY[0x189603F68] dictionaryWithObject:self->super._predicate forKey:@"predicate"];
          uint64_t v42 = @"Unknown/unsupported comparison predicate operator type";
          uint64_t v40 = v45;
          uint64_t v41 = v46;
LABEL_57:
          objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(v40, "exceptionWithName:reason:userInfo:", v41, v42, v43),  @"NSUnderlyingException");
          goto LABEL_104;
        }

        uint64_t v21 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLBoundByStringInContext:]((uint64_t)self, a3);
      }

    __int16 v56 = 0LL;
    goto LABEL_105;
  }

  if ([0 isTemporaryID]) {
    goto LABEL_104;
  }
  int v18 = (id *)-[NSSQLCore entityForObjectID:](0LL, 0LL);
  uint64_t v17 = 0LL;
  int v19 = 0LL;
  __int16 v56 = 0LL;
  if (!v18) {
    goto LABEL_105;
  }
LABEL_19:
  int v20 = objc_msgSend(v18[5], "objectForKey:", objc_msgSend(v19, "name"));
  if (PFInstrumentsRecordingEnabled())
  {
    v113[0] = MEMORY[0x1895F87A8];
    v113[1] = 3221225472LL;
    v113[2] = ___newFetchedPKsForRelationshipFaultRequest_block_invoke;
    v113[3] = &unk_189EABC20;
    v113[4] = v17;
    v113[5] = v19;
    v106 = ___newFetchedPKsForRelationshipFaultRequest_block_invoke((uint64_t)v113);
  }

  else
  {
    v106 = 0LL;
  }

  if (a1) {
    uint64_t v23 = *(void *)(a1 + 24);
  }
  else {
    uint64_t v23 = 0LL;
  }
  v107 = -[NSSQLiteConnection statementCacheForEntity:](v23, v18);
  if (v107) {
    uint64_t v24 = (void *)-[NSMutableDictionary objectForKey:]( v107->_toManyRelationshipStatementCache,  "objectForKey:",  [(id)v20 name]);
  }
  else {
    uint64_t v24 = 0LL;
  }
  if ((unint64_t)[v24 count] < 2 || (unint64_t v25 = objc_msgSend(v24, "objectAtIndex:", 0)) == 0)
  {
    v110 = objc_alloc_init(&OBJC_CLASS___NSFetchRequest);
    -[NSFetchRequest setEntity:]( v110,  "setEntity:",  objc_msgSend((id)objc_msgSend((id)v20, "destinationEntity"), "entityDescription"));
    -[NSFetchRequest setIncludesPropertyValues:](v110, "setIncludesPropertyValues:", 0LL);
    v105 = [v17 _referenceData64];
    if (v20 && *(_BYTE *)(v20 + 24) == 9)
    {
      uint64_t v32 = (void *)objc_msgSend( objc_alloc(MEMORY[0x1896078E8]),  "initWithObject:",  objc_msgSend(*(id *)(v20 + 56), "name"));
      uint64_t v33 = (void *)[objc_alloc(MEMORY[0x1896078E0]) initWithKeyPath:v32];

      uint64_t v34 = (void *)[objc_alloc(MEMORY[0x189607830]) initWithObject:v17];
      unint64_t v35 = [objc_alloc(MEMORY[0x189607818]) initWithLeftExpression:v34 rightExpression:v33 modifier:0 type:10 options:0];
    }

    else
    {
      unint64_t v36 = [v17 _referenceData64];
      unint64_t v37 = objc_alloc(MEMORY[0x1896078E8]);
      if (v20) {
        uint64_t v38 = *(void **)(v20 + 56);
      }
      else {
        uint64_t v38 = 0LL;
      }
      uint64_t v39 = (void *)objc_msgSend(v37, "initWithObject:", objc_msgSend((id)objc_msgSend(v38, "foreignKey"), "name"));
      uint64_t v34 = (void *)[objc_alloc(MEMORY[0x1896078E0]) initWithKeyPath:v39];

      uint64_t v40 = (void *)[objc_alloc(MEMORY[0x189607968]) initWithLongLong:v36];
      uint64_t v33 = (void *)[objc_alloc(MEMORY[0x189607830]) initWithObject:v40];

      unint64_t v35 = [objc_alloc(MEMORY[0x189607818]) initWithLeftExpression:v34 rightExpression:v33 modifier:0 type:4 options:0];
    }

    uint64_t v41 = (void *)v35;

    -[NSFetchRequest setPredicate:](v110, "setPredicate:", v41);
    if (v20)
    {
      if (objc_msgSend((id)objc_msgSend((id)v20, "propertyDescription"), "isOrdered"))
      {
        uint64_t v42 = *(unsigned __int8 *)(v20 + 24);
        if (v42 == 9)
        {
          if (*(void *)(v20 + 56) == v20)
          {
            *(void *)buf = objc_msgSend( objc_alloc(MEMORY[0x189607A20]),  "initWithKey:ascending:",  objc_msgSend(*(id *)(v20 + 56), "name"),  1);
            uint64_t v43 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:buf count:1];

            -[NSFetchRequest setSortDescriptors:](v110, "setSortDescriptors:", v43);
            uint64_t v42 = *(unsigned __int8 *)(v20 + 24);
            uint64_t v31 = 1;
          }

          else
          {
            uint64_t v31 = 0;
            uint64_t v42 = 9;
          }
        }

        else
        {
          uint64_t v31 = 0;
        }

        uint64_t v44 = v42 == 9;
        goto LABEL_50;
      }

      uint64_t v28 = 0;
      uint64_t v31 = 0;
    }

    else
    {
      uint64_t v31 = 0;
      uint64_t v44 = 0;
      uint64_t v28 = 0;
      if ([0 isOrdered])
      {
LABEL_50:
        uint64_t v45 = objc_alloc_init(&OBJC_CLASS___NSExpressionDescription);
        -[NSPropertyDescription setName:](v45, "setName:", @"objectID");
        -[NSExpressionDescription setExpressionResultType:](v45, "setExpressionResultType:", 2000LL);
        -[NSExpressionDescription setExpression:]( v45,  "setExpression:",  [MEMORY[0x189607878] expressionForEvaluatedObject]);
        if (v44)
        {
          v104 = -[NSSQLManyToMany inverseOrderColumnName]((__CFString *)v20);
          unint64_t v46 = objc_alloc_init(&OBJC_CLASS___NSExpressionDescription);
          -[NSPropertyDescription setName:](v46, "setName:", @"orderKey");
          -[NSExpressionDescription setExpressionResultType:](v46, "setExpressionResultType:", 200LL);
          -[NSExpressionDescription setExpression:]( v46,  "setExpression:",  objc_msgSend( MEMORY[0x189607878],  "expressionForFunction:arguments:",  NSStringFromSelector(sel_inverseOrderKey_),  objc_msgSend( MEMORY[0x189603F18],  "arrayWithObject:",  objc_msgSend(MEMORY[0x189607878], "expressionForConstantValue:", v104))));
        }

        else
        {
          if (v20 && (unint64_t v47 = *(void *)(v20 + 56)) != 0) {
            v104 = *(__CFString **)(v47 + 80);
          }
          else {
            v104 = 0LL;
          }
          unint64_t v46 = objc_alloc_init(&OBJC_CLASS___NSExpressionDescription);
          -[NSPropertyDescription setName:](v46, "setName:", @"orderKey");
          -[NSExpressionDescription setExpressionResultType:](v46, "setExpressionResultType:", 200LL);
          v103[1] = MEMORY[0x189607878];
          -[NSExpressionDescription setExpression:]( v46,  "setExpression:",  objc_msgSend( MEMORY[0x189607878],  "expressionForFunction:arguments:",  NSStringFromSelector(sel_inverseOrderKey_),  objc_msgSend( MEMORY[0x189603F18],  "arrayWithObject:",  objc_msgSend( MEMORY[0x189607878],  "expressionForConstantValue:",  -[__CFString columnName](v104, "columnName")))));
        }

        -[NSFetchRequest setPropertiesToFetch:]( v110,  "setPropertiesToFetch:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:", v45, v46, 0));

        -[NSFetchRequest setResultType:](v110, "setResultType:", 2LL);
        uint64_t v28 = 1;
        -[NSFetchRequest setIncludesPropertyValues:](v110, "setIncludesPropertyValues:", 1LL);
      }
    }

    unint64_t v48 = objc_alloc(&OBJC_CLASS___NSSQLFetchRequestContext);
    if (a1) {
      id v49 = *(void *)(a1 + 8);
    }
    else {
      id v49 = 0LL;
    }
    uint64_t v30 = -[NSSQLFetchRequestContext initWithRequest:context:sqlCore:]( v48,  "initWithRequest:context:sqlCore:",  v110,  0LL,  v49);
    [(id)v30 setIsFaultRequest:1];
    uint64_t v50 = (void *)[(id)v30 fetchStatement];
    unint64_t v25 = (uint64_t)v50;
    if (v30) {
      *(_BYTE *)(v30 + 202) = 1;
    }
    if (!v28)
    {
      uint64_t v51 = _rawSQLForToManyFaultStatement(v50, 0, 0);
      if (v25)
      {
        uint64_t v52 = v51;
        uint64_t v53 = *(void **)(v25 + 32);
        if (v53 != v51)
        {

          *(void *)(v25 + 32) = [v52 copy];
        }
      }

      [(id)v30 setFetchStatement:v25];
    }

    if (v25) {
      [*(id *)(v25 + 16) removeAllObjects];
    }
    __int16 v54 = -[NSSQLBindVariable initWithInt64:sqlType:]( objc_alloc(&OBJC_CLASS___NSSQLBindVariable),  "initWithInt64:sqlType:",  v105,  2LL);
    -[NSSQLiteStatement addBindVariable:](v25, v54);

    -[NSSQLiteStatementCache cacheFaultingStatement:andFetchRequest:forRelationship:]( (uint64_t)v107,  (void *)v25,  (uint64_t)v110,  (void *)v20);
    goto LABEL_69;
  }

  v110 = (NSFetchRequest *)[v24 objectAtIndex:1];
  unint64_t v26 = v110;
  objc_msgSend( (id)objc_msgSend((id)objc_msgSend((id)v25, "bindVariables"), "objectAtIndex:", 0),  "setInt64:",  objc_msgSend(v17, "_referenceData64"));
  unint64_t v27 = *(void *)(v25 + 48);
  uint64_t v28 = v27 != 0;
  -[NSFetchRequest setIncludesPropertyValues:](v110, "setIncludesPropertyValues:", v27 != 0);
  uint64_t v29 = (id)v25;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0;
LABEL_69:
  LODWORD(v105) = v31;
  unint64_t v55 = 0;
  v107 = 0LL;
  __int16 v56 = 0LL;
  v104 = (__CFString *)sel_userInfo;
  while (!v56 && v55 != 1)
  {
    if (v30) {
      goto LABEL_77;
    }
    unint64_t v57 = objc_alloc(&OBJC_CLASS___NSSQLFetchRequestContext);
    if (a1) {
      __int16 v58 = *(void *)(a1 + 8);
    }
    else {
      __int16 v58 = 0LL;
    }
    unint64_t v59 = -[NSSQLFetchRequestContext initWithRequest:context:sqlCore:]( v57,  "initWithRequest:context:sqlCore:",  v110,  0LL,  v58);
    -[NSSQLFetchRequestContext setIsFaultRequest:](v59, "setIsFaultRequest:", 1LL);
    -[NSSQLFetchRequestContext setFetchStatement:](v59, "setFetchStatement:", v25);
    if (v59)
    {
      v59->_isUsingCachedStatement = 1;
      uint64_t v30 = (uint64_t)v59;
LABEL_77:
      if (a1) {
        goto LABEL_78;
      }
      goto LABEL_91;
    }

    uint64_t v30 = 0LL;
    if (a1)
    {
LABEL_78:
      uint64_t v60 = *(void **)(a1 + 24);
      goto LABEL_79;
    }

      if (([*(id *)(a1 + 48) save:*(void *)(*(void *)(a1 + 80) + 8) + 40] & 1) == 0)
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
        __int16 v98 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
      }
    }

    uint64_t v42 = v105;
  }

  else
  {
    v101 = 0LL;
    v102 = 0LL;
    obj = 0LL;
    v104 = 0LL;
    uint64_t v42 = 0LL;
  }
}

LABEL_102:
      unint64_t v9 = v21;
      goto LABEL_103;
    }

          uint64_t v53 = (void *)MEMORY[0x189603F70];
          __int16 v54 = *MEMORY[0x189603A60];
          unint64_t v55 = (void *)NSString;
          __int16 v56 = @"setPropertiesToFetch:";
          unint64_t v57 = a3 == 0;
          goto LABEL_103;
        }
      }

      else
      {
        uint64_t v15 = -[NSExpressionDescription _propertyType](v9, "_propertyType");
        if (v15 == 5)
        {
          if (a3)
          {
            unint64_t v16 = -[NSExpressionDescription expression](v9, "expression");
            uint64_t v17 = -[NSExpression expressionType](v16, "expressionType");
            if (v17 != 3)
            {

              uint64_t v53 = (void *)MEMORY[0x189603F70];
              __int16 v54 = *MEMORY[0x189603A60];
              __int16 v58 = [NSString stringWithFormat:@"Invalid keypath expression (%@) passed to setPropertiesToFetch:", v9, v67];
              goto LABEL_132;
            }
          }
        }

        else
        {
          uint64_t v29 = v15;
          if (v72 && -[NSPropertyDescription isTransient](v9, "isTransient"))
          {

            uint64_t v53 = (void *)MEMORY[0x189603F70];
            __int16 v54 = *MEMORY[0x189603A60];
            uint64_t v62 = @"setPropertiesToFetch:";
            if (a3) {
              uint64_t v62 = @"setPropertiesToGroupBy:";
            }
            __int16 v58 = [NSString stringWithFormat:@"Invalid property %@ passed to %@ (property is transient)", v9, v62];
            goto LABEL_132;
          }

          uint64_t v30 = (void *)[v70 entity];
          uint64_t v31 = (void *)objc_msgSend( -[NSPropertyDescription _qualifiedName](v9, "_qualifiedName"),  "componentsSeparatedByString:",  @".");
          uint64_t v79 = v9;
          uint64_t v69 = v30;
          if ((unint64_t)[v31 count] < 2)
          {
            unint64_t v47 = -[NSPropertyDescription name](v9, "name");
            if (!v30) {
              goto LABEL_109;
            }
            uint64_t v33 = (void *)objc_msgSend((id)objc_msgSend(v30, "propertiesByName"), "objectForKey:", v47);
          }

          else
          {
            uint64_t v32 = [v31 objectAtIndex:0];
            if (v30) {
              uint64_t v33 = (void *)objc_msgSend((id)objc_msgSend(v30, "propertiesByName"), "objectForKey:", v32);
            }
            else {
              uint64_t v33 = 0LL;
            }
            if ((unint64_t)[v31 count] >= 2)
            {
              unint64_t v35 = 1LL;
              do
              {
                unint64_t v36 = (void *)[v31 objectAtIndex:v35];
                uint64_t v80 = 0u;
                uint64_t v81 = 0u;
                uint64_t v82 = 0u;
                uint64_t v83 = 0u;
                unint64_t v37 = (void *)[v33 elements];
                uint64_t v38 = [v37 countByEnumeratingWithState:&v80 objects:v92 count:16];
                if (v38)
                {
                  uint64_t v39 = v38;
                  uint64_t v40 = *(void *)v81;
                  while (2)
                  {
                    for (uint64_t i = 0LL; i != v39; ++i)
                    {
                      if (*(void *)v81 != v40) {
                        objc_enumerationMutation(v37);
                      }
                      uint64_t v42 = *(void **)(*((void *)&v80 + 1) + 8 * i);
                      if (objc_msgSend(v36, "isEqualToString:", objc_msgSend(v42, "name")))
                      {
                        uint64_t v33 = v42;
                        goto LABEL_58;
                      }
                    }

                    uint64_t v39 = [v37 countByEnumeratingWithState:&v80 objects:v92 count:16];
                    if (v39) {
                      continue;
                    }
                    break;
                  }
                }

          unint64_t v97 = (os_log_s *)v71;
          __int16 v98 = 12;
LABEL_140:
          _os_log_fault_impl(&dword_186681000, v97, OS_LOG_TYPE_FAULT, v40, buf, v98);
          goto LABEL_149;
        }
      }

LABEL_220:
        LODWORD(v54) = 0;
        goto LABEL_221;
      }

      if ((([(id)objc_opt_class() isSimpleKeypath:v24] & 1) != 0
         || -[NSSQLIntermediate isVariableBasedKeypathScopedBySubquery:]((uint64_t)self, v24))
        && !-[NSSQLIntermediate keypathExpressionIsSafeLHSForIn:]( self->super.super._scope,  "keypathExpressionIsSafeLHSForIn:",  v24))
      {
        goto LABEL_84;
      }

      if (v27 || v32 == 2)
      {
        if (v27 || v32 != 2)
        {
          v110 = (__CFString *)-[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:](self, v26, 1LL, a3);
          unint64_t v9 = v110;
          if (!v110) {
            goto LABEL_220;
          }
          -[__CFString appendString:](v110, "appendString:", @" = ");
          uint64_t v77 = self;
          uint64_t v78 = v24;
          uint64_t v79 = v23 == 2;
        }

        else
        {
          v101 = -[NSExpression constantValue](v24, "constantValue");
          if ([v101 isNSString])
          {
            LODWORD(v54) = 1;
            unint64_t v9 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLForString:expressionPath:wildStart:wildEnd:allowToMany:inContext:]( (id *)&self->super.super.super.isa,  (uint64_t)v101,  v26,  1,  1,  1LL,  a3);
            goto LABEL_221;
          }

          v111 = -[NSSQLIntermediate _generateSQLForVariableExpression:allowToMany:inContext:]( self,  "_generateSQLForVariableExpression:allowToMany:inContext:",  v26,  0LL,  a3);
          unint64_t v9 = v111;
          if (!v111) {
            goto LABEL_220;
          }
          -[__CFString appendString:](v111, "appendString:", @" = ");
          uint64_t v77 = self;
          uint64_t v78 = v24;
          uint64_t v79 = 0LL;
        }

                    *(_BYTE *)(*(void *)(*(void *)(v376 + 96) + 8LL) + 24LL) = 0;
                    v243 = *(id *)(*(void *)(*(void *)(v376 + 88) + 8LL) + 40LL);
                    goto LABEL_221;
                  }

                  uint64_t v45 = v364;
LABEL_155:
                  if (v53 == ++v55)
                  {
                    v190 = -[NSArray countByEnumeratingWithState:objects:count:]( v45,  "countByEnumeratingWithState:objects:count:",  &v416,  v431,  16LL);
                    uint64_t v53 = v190;
                    if (!v190)
                    {
                      id v49 = v355;
                      goto LABEL_184;
                    }

                    continue;
                  }

                  goto LABEL_69;
                }

                break;
              }

              if ([v56 attributeType] == 1100)
              {

                unint64_t v97 = [objc_alloc(MEMORY[0x189607AB8]) initWithUUIDString:v62];
                if (v97) {
                  goto LABEL_119;
                }
                v155 = (void *)MEMORY[0x186E3E5D8]();
                v156 = __ckLoggingOverride;
                v157 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to initialize NSUUID from CKRecord with value: %@\n%@"];
                _NSCoreDataLog( v156 != 0,  v157,  v158,  v159,  v160,  v161,  v162,  v163,  (uint64_t)"-[PFCloudKitSerializer updateAttributes:andRelationships:onManagedObject:fromRecord:withRecor dMetadata:importContext:error:]");
                goto LABEL_167;
              }

              if ([v56 attributeType] != 700 && objc_msgSend(v56, "attributeType") != 1200) {
                goto LABEL_143;
              }
              getCloudKitCKAssetClass[0]();
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0)
              {
                if ([v56 attributeType] != 1200) {
                  goto LABEL_143;
                }

                unint64_t v97 = [objc_alloc(MEMORY[0x189604030]) initWithString:v62];
                if (v97)
                {
LABEL_119:
                  uint64_t v63 = (id)v97;
                  goto LABEL_143;
                }

                v155 = (void *)MEMORY[0x186E3E5D8]();
                v164 = __ckLoggingOverride;
                v165 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to initialize NSURL from CKRecord with value: %@\n%@"];
                _NSCoreDataLog( v164 != 0,  v165,  v166,  v167,  v168,  v169,  v170,  v171,  (uint64_t)"-[PFCloudKitSerializer updateAttributes:andRelationships:onManagedObject:fromRecord:withRecor dMetadata:importContext:error:]");
LABEL_167:
                uint64_t v63 = 0LL;
                objc_autoreleasePoolPop(v155);
                goto LABEL_143;
              }

              v144 = [v369 cloudKitSerializer:v374 safeSaveURLForAsset:v62];
              if (!v144)
              {
                v145 = [NSString stringWithUTF8String:"Delegate didn't return a file url for asset: %@"];
                _NSCoreDataLog(17LL, v145, v146, v147, v148, v149, v150, v151, (uint64_t)v62);
                v152 = (os_log_s *)__pflogFaultLog;
                if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 138412290;
                  *(void *)&uint8_t buf[4] = v62;
                  _os_log_fault_impl( &dword_186681000,  v152,  OS_LOG_TYPE_FAULT,  "CoreData: Delegate didn't return a file url for asset: %@",  buf,  0xCu);
                }
              }

              v153 = (void *)[objc_alloc(NSString) initWithContentsOfURL:v144 encoding:4 error:&v420];
              if (v153)
              {
                if ([v56 attributeType] == 700)
                {

                  v154 = v153;
                  goto LABEL_174;
                }

                if ([v56 attributeType] == 1200)
                {

                  v154 = (id)[objc_alloc(MEMORY[0x189604030]) initWithString:v153];
                  if (v154)
                  {
LABEL_174:
                    uint64_t v63 = v154;
                  }

                  else
                  {
                    v181 = (void *)MEMORY[0x186E3E5D8]();
                    v182 = __ckLoggingOverride;
                    v183 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to initialize NSURL from CKAsset with value: %@\n%@"];
                    _NSCoreDataLog( v182 != 0,  v183,  v184,  v185,  v186,  v187,  v188,  v189,  (uint64_t)"-[PFCloudKitSerializer updateAttributes:andRelationships:onManagedObject:fromRecord:withR ecordMetadata:importContext:error:]");
                    uint64_t v63 = 0LL;
                    objc_autoreleasePoolPop(v181);
                  }
                }
              }

              else
              {
                v172 = (void *)MEMORY[0x186E3E5D8]();
                v173 = __ckLoggingOverride;
                v174 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to read value from asset at URL: %@\n%@"];
                _NSCoreDataLog( v173 != 0,  v174,  v175,  v176,  v177,  v178,  v179,  v180,  (uint64_t)"-[PFCloudKitSerializer updateAttributes:andRelationships:onManagedObject:fromRecord:withRecor dMetadata:importContext:error:]");
                objc_autoreleasePoolPop(v172);
                v361 = 0;
              }

              goto LABEL_143;
            }

LABEL_134:
        uint64_t v53 = -[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:](v77, v78, v79, a3);
        if (v53) {
          goto LABEL_135;
        }
LABEL_83:

LABEL_84:
        LODWORD(v54) = 0;
        goto LABEL_85;
      }

      [*(id *)((char *)&self->super.super.super.isa + *(int *)(v12 + 1420)) addObject:v26];
      if (v32 == 3) {
        v84 = -[NSExpression keyPath](v26, "keyPath");
      }
      else {
        v84 = objc_msgSend( -[NSArray objectAtIndex:](-[NSExpression arguments](v26, "arguments"), "objectAtIndex:", 0),  "constantValue");
      }
      v103 = (void *)v84;
      v104 = -[NSExpression constantValue](v24, "constantValue");
      if ([v103 rangeOfString:@"."] != 0x7FFFFFFFFFFFFFFFLL)
      {
        if ([v104 isNSString])
        {
          LODWORD(v54) = 1;
          unint64_t v9 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLForString:expressionPath:wildStart:wildEnd:allowToMany:inContext:]( (id *)&self->super.super.super.isa,  (uint64_t)v104,  v26,  1,  1,  1LL,  a3);
        }

        else
        {
          v114 = -[NSSQLIntermediate _generateSQLForKeyPathExpression:allowToMany:inContext:]( self,  "_generateSQLForKeyPathExpression:allowToMany:inContext:",  v26,  1LL,  a3);
          unint64_t v9 = v114;
          if (v114)
          {
            -[__CFString appendString:](v114, "appendString:", @" = ");
            v115 = -[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:](self, v24, 0LL, a3);
            if (v115)
            {
              v116 = v115;
              -[__CFString appendString:](v9, "appendString:", v115);

              LODWORD(v54) = 1;
            }

            else
            {

              LODWORD(v54) = 0;
              unint64_t v9 = 0LL;
            }
          }

          else
          {
            LODWORD(v54) = 0;
          }
        }

        goto LABEL_260;
      }

      v105 = -[NSSQLIntermediate governingEntityForKeypathExpression:]( self,  "governingEntityForKeypathExpression:",  v26);
      if (v105)
      {
        unint64_t v9 = (__CFString *)[v105[5] objectForKey:v103];
        v106 = (void *)[a3 valueForKey:@"explicitRestrictingEntityQualifier"];
        if (v9)
        {
LABEL_212:
          if (LOBYTE(v9->length) == 9)
          {
            v109 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLForConst:inManyToMany:expression:inContext:]( self,  (uint64_t)v104,  v9,  (uint64_t)v26,  a3);
            goto LABEL_258;
          }

          if (!-[__CFString isToMany](v9, "isToMany"))
          {
            if (LOBYTE(v9->length) != 1)
            {
              LODWORD(v54) = 0;
              unint64_t v9 = 0LL;
LABEL_259:
              uint64_t v12 = 0x18C4A5000uLL;
LABEL_260:
              [*(id *)((char *)&self->super.super.super.isa + *(int *)(v12 + 1420)) removeLastObject];
              goto LABEL_221;
            }

            v109 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLForConst:inAttribute:expression:inContext:]( (uint64_t)self,  (uint64_t)v104,  (uint64_t)v26,  (uint64_t)a3);
LABEL_258:
            unint64_t v9 = v109;
            LODWORD(v54) = 1;
            goto LABEL_259;
          }

          objc_autoreleasePoolPop(context);
        }

        v141 = [obj countByEnumeratingWithState:&v178 objects:v232 count:16];
        if (!v141)
        {
LABEL_136:
          [v139 drain];
          return v147;
        }
      }
    }
  }

  return result;
}

  uint64_t v83 = v113;
LABEL_136:
  -[NSMigrationManager _doCleanupOnFailure:]((id *)&v103->super.isa);
  v116 = 0;
  if (v102) {
    [v102 drain];
  }
  uint64_t v82 = 0;
LABEL_139:
  v84 = v113;
  if (error)
  {
    if (v113) {
      *error = (NSError *)v113;
    }
  }

  unint64_t v85 = v84;
  if ((v82 & 1) != 0)
  {
    v115 = 0LL;
    if (-[NSManagedObjectContext save:](v103->_destinationManagedObjectContext, "save:", &v115))
    {

      v103->_mappingModel = 0LL;
      -[NSPersistentStoreCoordinator removePersistentStore:error:]( -[NSManagedObjectContext persistentStoreCoordinator]( v103->_destinationManagedObjectContext,  "persistentStoreCoordinator"),  "removePersistentStore:error:",  v94,  0LL);
      -[NSPersistentStoreCoordinator removePersistentStore:error:]( -[NSManagedObjectContext persistentStoreCoordinator]( v103->_sourceManagedObjectContext,  "persistentStoreCoordinator"),  "removePersistentStore:error:",  v98,  0LL);
      -[NSMigrationManager _doCleanupOnFailure:]((id *)&v103->super.isa);
      uint64_t v24 = 1;
      goto LABEL_146;
    }

    unint64_t v87 = (void *)MEMORY[0x189607870];
    unint64_t v88 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Failed to save new store.",  @"reason",  v115,  *MEMORY[0x189607798],  0);
    *error = (NSError *)[v87 errorWithDomain:*MEMORY[0x189607460] code:134110 userInfo:v88];
    -[NSMigrationManager _doCleanupOnFailure:]((id *)&v103->super.isa);
LABEL_131:
    uint64_t v24 = 0;
    goto LABEL_146;
  }

  uint64_t v24 = v116;
LABEL_146:
  +[NSPersistentStoreCoordinator _endPowerAssertionWithAssert:andApp:]( (uint64_t)&OBJC_CLASS___NSPersistentStoreCoordinator,  v104,  v97);
  return v24 & 1;
}

          v101 = (void *)objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:", v112, v61, Mutable, v110, 0);
          if (v109) {
            v102 = (void *)[MEMORY[0x189603F18] arrayWithObject:v85];
          }
          else {
            v102 = (void *)objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:", v82, v85, 0);
          }
          v108 = (void *)+[_PFRoutines _newObjectIDsArrayWithMapping:andEntries:andCoordinator:]( (uint64_t)_PFRoutines,  v101,  v102,  (void *)[*(id *)(v1 + 16) persistentStoreCoordinator]);
          v90 = v108;
          if (v108 && [v108 count] == v114)
          {
            *(void *)(v1 + 96) = -[_PFBatchFaultingArray initWithPFArray:andRequest:andContext:]( objc_alloc(&OBJC_CLASS____PFBatchFaultingArray),  "initWithPFArray:andRequest:andContext:",  v90,  *(void *)(v1 + 8),  *(void *)(v1 + 16));
            *(void *)(v1 + 136) = objc_msgSend( objc_alloc(MEMORY[0x189603FC8]),  "initWithCapacity:",  objc_msgSend(v90, "count"));
            *(void *)(v1 + 144) = objc_alloc_init(MEMORY[0x189603FA8]);
            *(_DWORD *)(v1 + 72) = *(_DWORD *)(v1 + 72) & 0xFFFFFFF9 | 2;
            v89 = 1;
          }

          else
          {
            v89 = 0;
          }

LABEL_257:
          v109 = (__CFString *)-[NSSQLSimpleWhereIntermediate _generateSQLForConst:inToMany:inContext:]( self,  (uint64_t)v104,  v9,  a3);
          goto LABEL_258;
        }
      }

      else
      {
        v106 = (void *)[a3 valueForKey:@"explicitRestrictingEntityQualifier"];
      }

      v107 = v106;
      if ([v106 count])
      {
        v108 = [v107 lastObject];
        if (v108)
        {
          unint64_t v9 = (__CFString *)[*(id *)(v108 + 40) objectForKey:v103];
          [v107 removeLastObject];
          if (v9) {
            goto LABEL_212;
          }
        }

        else
        {
          [v107 removeLastObject];
        }
      }

      unint64_t v9 = 0LL;
      if (([0 isToMany] & 1) == 0)
      {
        LODWORD(v54) = 0;
        goto LABEL_259;
      }

      goto LABEL_257;
    }

    if (v32)
    {
      if (v32 == 13) {
        goto LABEL_132;
      }
      goto LABEL_131;
    }

    v74 = (__CFString *)-[NSSQLIntermediate _generateSQLForExpression:allowToMany:inContext:](self, v24, v23 == 2, a3);
    unint64_t v9 = v74;
    if (!v74) {
      goto LABEL_220;
    }
    -[__CFString appendString:](v74, "appendString:", @" IN ");
    if (-[NSExpression expressionType](v24, "expressionType") == NSEvaluatedObjectExpressionType)
    {
      unint64_t v75 = (void *)objc_msgSend( (id)objc_msgSend( -[NSSQLIntermediate fetchIntermediate](self, "fetchIntermediate"),  "governingEntity"),  "entityDescription");
    }

    else if ([(id)objc_opt_class() isSimpleKeypath:v24] {
           && (unint64_t v88 = (void *)-[NSExpression predicateFormat](v24, "predicateFormat"),
    }
               unint64_t v75 = (void *)objc_msgSend( -[NSSQLIntermediate governingEntityForKeypathExpression:]( self,  "governingEntityForKeypathExpression:",  v24),  "entityDescription"),  obj = (id)objc_msgSend(v88, "componentsSeparatedByString:", @"."),  (v89 = objc_msgSend(obj, "count")) != 0))
    {
      v90 = 0LL;
      v125 = v89 - 1;
      while (1)
      {
        uint64_t v91 = [obj objectAtIndex:v90];
        v92 = v75 ? (void *)objc_msgSend((id)objc_msgSend(v75, "propertiesByName"), "objectForKey:", v91) : 0;
        uint64_t v93 = [v92 _propertyType];
        unint64_t v75 = 0LL;
        if (!v92) {
          break;
        }
        if (v93 != 4) {
          break;
        }
        unint64_t v75 = (void *)[v92 destinationEntity];
        if (v125 == v90) {
          break;
        }
        ++v90;
      }
    }

    else
    {
      unint64_t v75 = 0LL;
    }

    __int16 v94 = !v131;
    if (v75) {
      __int16 v94 = 1;
    }
    if ((v94 & 1) == 0)
    {
      unint64_t v95 = v130;
      __int16 v96 = (void *)-[NSExpression predicateFormat](v24, "predicateFormat");
      unint64_t v97 = -[NSSQLIntermediate governingEntityForKeypathExpression:](self, "governingEntityForKeypathExpression:", v24);
      __int16 v98 = objc_msgSend((id)objc_msgSend(v96, "componentsSeparatedByString:", @"."), "firstObject");
      if (v97) {
        unint64_t v97 = (id *)[v97[5] objectForKey:v98];
      }
      unint64_t v75 = (void *)objc_msgSend((id)objc_msgSend(v97, "destinationEntity"), "entityDescription");
    }

    unint64_t v95 = v130;
    if (v75)
    {
      unint64_t v99 = -[NSExpression constantValue](v26, "constantValue");
      uint64_t v12 = 0x18C4A5000LL;
      if ((int)objc_msgSend((id)objc_msgSend(a3, "objectForKey:", @"nestingLevel"), "intValue") <= 0
        && (([v99 isNSArray] & 1) != 0
         || ([v99 isNSSet] & 1) != 0
         || [v99 isNSOrderedSet]))
      {
        obja = v99;
        v102 = [v99 count];
        if (v130 || v102 >= 0x64)
        {
          +[_PFRoutines anyObjectFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v99);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0) {
            obja = (id)+[_PFRoutines newArrayOfObjectIDsFromCollection:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v99);
          }
          v135 = 0u;
          v136 = 0u;
          v133 = 0u;
          v134 = 0u;
          v117 = [obja countByEnumeratingWithState:&v133 objects:v132 count:16];
          if (v117)
          {
            v118 = v117;
            v126 = *(void *)v134;
            while (2)
            {
              for (uint64_t i = 0LL; i != v118; ++i)
              {
                if (*(void *)v134 != v126) {
                  objc_enumerationMutation(obja);
                }
                v120 = *(void **)(*((void *)&v133 + 1) + 8 * i);
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0
                  || !objc_msgSend((id)objc_msgSend(v120, "entity"), "isKindOfEntity:", v75))
                {
                  __int16 v54 = 0LL;
                  goto LABEL_249;
                }
              }

              v118 = [obja countByEnumeratingWithState:&v133 objects:v132 count:16];
              if (v118) {
                continue;
              }
              break;
            }
          }

          v121 = (id)[a3 objectForKey:@"bindIntarrays"];
          if (!v121)
          {
            v121 = objc_alloc_init(MEMORY[0x189603FA8]);
            [a3 setObject:v121 forKey:@"bindIntarrays"];
          }

          v127 = [v121 count];
          v122 = -[NSSQLBindIntarray initWithValue:]( objc_alloc(&OBJC_CLASS___NSSQLBindIntarray),  "initWithValue:",  obja);
          -[NSSQLBindIntarray setTableName:]( v122,  "setTableName:",  -[NSSQLAliasGenerator generateTempTableName]([a3 objectForKey:@"aliasGenerator"]));
          v123 = [v121 count];
          [v121 addObject:v122];
          -[NSSQLBindIntarray setIndex:](v122, "setIndex:", v123);

          if (v130)
          {
            v124 = (id)[a3 objectForKey:@"bindIntarraysSubstitutionOrder"];
            if (!v124)
            {
              v124 = objc_alloc_init(MEMORY[0x189603FA8]);
              [a3 setObject:v124 forKey:@"bindIntarraysSubstitutionOrder"];
            }

            [v124 addObject:v130];
            [v124 addObject:v75];
            objc_msgSend(v124, "addObject:", objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedInteger:", v127));
          }

          __int16 v54 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithFormat:@"(SELECT * FROM %@) ", -[NSSQLBindIntarray tableName](v122, "tableName")];
LABEL_249:
          uint64_t v12 = 0x18C4A5000LL;
        }

        else
        {
          __int16 v54 = 0LL;
        }

        unint64_t v95 = v130;
      }

      else
      {
        __int16 v54 = 0LL;
      }

      goto LABEL_186;
    }

LABEL_185:
    __int16 v54 = 0LL;
    uint64_t v12 = 0x18C4A5000LL;
LABEL_186:
    if (v54) {
      uint64_t v100 = 1;
    }
    else {
      uint64_t v100 = v131;
    }
    if ((v100 & 1) == 0) {
      __int16 v54 = (void *)-[NSSQLIntermediate _generateSQLForConstantCollection:reboundFrom:inContext:]( (uint64_t)self,  -[NSExpression constantValue](v26, "constantValue"),  v95,  a3);
    }
    if (v54)
    {
      -[__CFString appendString:](v9, "appendString:", v54);

      goto LABEL_193;
    }

LABEL_85:
    unint64_t v9 = 0LL;
LABEL_221:
    [*(id *)((char *)&self->super.super.super.isa + *(int *)(v12 + 1420)) removeLastObject];
    if (!(_DWORD)v54 || !v9)
    {
      v112 = [a3 valueForKey:@"NSUnderlyingException"];
      *(void *)&v133 = @"NSUnderlyingException";
      v132[0] = v112;
      v113 = [MEMORY[0x189603F68] dictionaryWithObjects:v132 forKeys:&v133 count:1];
      [a3 setObject:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", @"unimplemented SQL generation for predicate : (%@)", self->super._predicate), v113), @"NSUnderlyingException" forKey];
    }

    goto LABEL_103;
  }

  id v6 = (void *)MEMORY[0x189603F70];
  uint64_t v7 = *MEMORY[0x189603A60];
  uint64_t v8 = @"ALL modifier is not implemented";
LABEL_4:
  objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(v6, "exceptionWithName:reason:userInfo:", v7, v8, 0),  @"NSUnderlyingException");
  return 0LL;
}

LABEL_9:
  BOOL v13 = -[NSSQLIntermediate governingEntityForKeypathExpression:](self, "governingEntityForKeypathExpression:", a3);
  BOOL v14 = -[NSSQLIntermediate governingAliasForKeypathExpression:](self, "governingAliasForKeypathExpression:", a3);
  uint64_t v15 = (void *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(a3, "arguments"), "objectAtIndex:", 0),  "constantValue");
  unint64_t v16 = (void *)[v15 componentsSeparatedByString:@"."];
  uint64_t v71 = 0LL;
  uint64_t v17 = -[NSSQLKeypathExpressionIntermediate _propertyDescriptionForKeypath:startingAtEntity:allowToMany:allowToOne:lastKeyVisited:inContext:]( (uint64_t)self,  v16,  (uint64_t)v13,  v12,  1,  &v71,  a5);
  if (objc_msgSend((id)objc_msgSend(v17, "propertyDescription"), "_propertyType") != 7)
  {
    int v18 = (void *)[v17 propertyDescription];
    if ((!v18 || ![v18 superCompositeAttribute])
      && -[NSSQLIntermediate isUpdateScoped](self, "isUpdateScoped")
      && (unint64_t)[v16 count] >= 2)
    {
      int v19 = (void *)MEMORY[0x189603F70];
      int v20 = *MEMORY[0x189603A60];
      uint64_t v21 = @"keypaths (joins) not supported in batch update statements";
LABEL_35:
      uint64_t v34 = 0LL;
LABEL_36:
      unint64_t v35 = [v19 exceptionWithName:v20 reason:v21 userInfo:v34];
      unint64_t v36 = @"NSUnderlyingException";
LABEL_37:
      [a5 setObject:v35 forKey:v36];
      goto LABEL_38;
    }
  }

  uint64_t v22 = -[NSSQLIntermediate disambiguatingEntity](self, "disambiguatingEntity");
  if (v17 || (uint64_t v23 = (uint64_t)v22) == 0)
  {
    uint64_t v23 = (uint64_t)v13;
  }

  else
  {
    uint64_t v24 = -[NSSQLIntermediate disambiguationKeypath](self, "disambiguationKeypath");
    if (-[NSArray count](v24, "count"))
    {
      if (!objc_msgSend( v15,  "hasPrefix:",  -[NSArray componentsJoinedByString:](v24, "componentsJoinedByString:", @".")))
      {
        unint64_t v25 = (void *)MEMORY[0x189603F70];
        unint64_t v26 = *MEMORY[0x189603A60];
        unint64_t v27 = [NSString stringWithFormat:@"invalid keypath %@", self->super._expression];
LABEL_34:
        uint64_t v21 = (const __CFString *)v27;
        int v19 = v25;
        int v20 = v26;
        goto LABEL_35;
      }

      uint64_t v17 = -[NSSQLKeypathExpressionIntermediate _propertyDescriptionForKeypath:startingAtEntity:allowToMany:allowToOne:lastKeyVisited:inContext:]( (uint64_t)self,  (void *)objc_msgSend( v16,  "subarrayWithRange:",  -[NSArray count](v24, "count"),  objc_msgSend(v16, "count") - -[NSArray count](v24, "count")),  v23,  v12 & !-[NSSQLIntermediate disambiguationKeypathHasToMany]( self,  "disambiguationKeypathHasToMany"),  1,  &v71,  a5);
      uint64_t v23 = (uint64_t)v13;
      if (!v17)
      {
        if ([a5 objectForKey:@"NSUnderlyingException"])
        {
LABEL_38:
          uint64_t v30 = 0LL;
LABEL_39:
          objc_autoreleasePoolPop(context);
          return v30;
        }

        unint64_t v25 = (void *)MEMORY[0x189603F70];
        unint64_t v26 = *MEMORY[0x189603A60];
        unint64_t v27 = [NSString stringWithFormat:@"invalid keypath : %@", self->super._expression];
        goto LABEL_34;
      }

      goto LABEL_53;
    }

    uint64_t v71 = 0LL;
    uint64_t v31 = -[NSSQLKeypathExpressionIntermediate _propertyDescriptionForKeypath:startingAtEntity:allowToMany:allowToOne:lastKeyVisited:inContext:]( (uint64_t)self,  v16,  v23,  v12,  1,  &v71,  a5);
    if (v31)
    {
      uint64_t v17 = v31;
      BOOL v13 = (id)v23;
      goto LABEL_53;
    }

    uint64_t v71 = 0LL;
    uint64_t v40 = (void *)-[NSSQLKeypathExpressionIntermediate _propertyDescriptionsForKeypath:rootedAtEntity:allowToMany:allowToOne:lastKeyVisited:inContext:]( (uint64_t)self,  v16,  v23,  v12,  1LL,  &v71,  a5);
    if (!v40)
    {
      if ([a5 valueForKey:@"NSUnderlyingException"]) {
        goto LABEL_38;
      }
      goto LABEL_24;
    }

    uint64_t v41 = v40;
    if ([v40 count] != 1)
    {
      if ((unint64_t)[v41 count] >= 2)
      {
        uint64_t v42 = (void *)MEMORY[0x189603F70];
        uint64_t v43 = *MEMORY[0x189603A60];
        uint64_t v44 = [NSString stringWithFormat:@"ambiguous keypath %@", self->super._expression];
        v74 = @"found";
        v75[0] = [v41 valueForKey:@"propertyDescription"];
        uint64_t v45 = (void *)MEMORY[0x189603F68];
        unint64_t v46 = v75;
        unint64_t v47 = &v74;
        goto LABEL_115;
      }

  int v10 = 0;
LABEL_10:
  uint64_t v11 = [v6 expressionType];
  if (v11 == 14)
  {
    uint64_t v12 = (void *)[v6 collection];
  }

  else
  {
    if (v11) {
      goto LABEL_26;
    }
    uint64_t v12 = (void *)[v6 constantValue];
  }

  BOOL v13 = v12;
  if (([v12 isNSSet] & 1) == 0
    && ([v13 isNSArray] & 1) == 0
    && ![v13 isNSOrderedSet])
  {
LABEL_26:
    uint64_t v15 = [a1 expressionType];
    if (!v10) {
      return a1;
    }
LABEL_27:
    uint64_t v17 = v6;
    if (v15 == 5) {
      return v17;
    }
    if (v15 != 7)
    {
      uint64_t v17 = v5;
      goto LABEL_30;
    }

    return v5;
  }

  BOOL v14 = [v13 count];
  uint64_t v15 = [a1 expressionType];
  if (v14) {
    unint64_t v16 = 0;
  }
  else {
    unint64_t v16 = v10;
  }
  if (v16) {
    return v5;
  }
  if (v10) {
    goto LABEL_27;
  }
  if (v14) {
    return a1;
  }
  if (v15 == 5) {
    return v5;
  }
  uint64_t v17 = v5;
  if (v15 == 7) {
    return v17;
  }
  uint64_t v17 = v6;
LABEL_30:
  if (v15 != 6) {
    return a1;
  }
  return v17;
}

  atomic_store(0LL, (unint64_t *)&self->_coordinator);
  return result;
}

  uint64_t v29 = MEMORY[0x1895F87A8];
  uint64_t v30 = 3221225472LL;
  uint64_t v31 = __62__NSSQLCore__allOrderKeysForDestination_inRelationship_error___block_invoke;
  uint64_t v32 = &unk_189EA98A8;
  uint64_t v33 = v14;
  uint64_t v15 = -[NSSQLBlockRequestContext initWithBlock:context:sqlCore:]( objc_alloc(&OBJC_CLASS___NSSQLBlockRequestContext),  "initWithBlock:context:sqlCore:",  &v29,  0LL,  self);

  uint64_t v28 = v15;
  -[NSSQLCore dispatchRequest:withRetries:]((uint64_t)self, v15, 4LL);
  unint64_t v16 = -[NSSQLStoreRequestContext result](v15, "result");
  uint64_t v17 = v16;
  if (v16)
  {
    Count = CFArrayGetCount(v16);
    int v19 = objc_alloc_init(MEMORY[0x189603FA8]);
    if (Count >= 2)
    {
      CFArrayGetValueAtIndex(v17, 0LL);
      for (uint64_t i = 1LL; i != Count; ++i)
      {
        ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(v17, i);
        uint64_t v22 = *ValueAtIndex;
        if (*ValueAtIndex)
        {
          uint64_t v23 = ValueAtIndex[2];
          uint64_t v24 = (const void *)v10;
          if (v9) {
            uint64_t v24 = _sqlEntityForEntityID((uint64_t)self->_model, ValueAtIndex[1]);
          }
          unint64_t v25 = -[NSSQLCore newObjectIDForEntity:pk:]( self,  "newObjectIDForEntity:pk:",  v24,  v22,  v28,  v29,  v30,  v31,  v32,  v33);
          [v19 addObject:v25];

          objc_msgSend(v19, "addObject:", objc_msgSend(MEMORY[0x189607968], "numberWithLongLong:", v23));
        }
      }
    }

    return v19;
  }

  else
  {
    exception = v15;
    if (v15) {
      exception = v15->super._exception;
    }
    objc_exception_throw(exception);
    __break(1u);
  }

  return result;
}

  unint64_t v36 = 1;
LABEL_10:
  if ([v3 hasChanges] && (objc_msgSend(v3, "save:", v174) & 1) == 0)
  {
    unint64_t v37 = 0LL;
    uint64_t v39 = 0LL;
    __int16 v56 = v174[0];
    uint64_t v38 = 0LL;
    unint64_t v57 = 0;
    goto LABEL_55;
  }

  if ((v36 & 1) == 0)
  {
    uint64_t v40 = objc_alloc_init(&OBJC_CLASS___PFCloudKitHistoryAnalyzerOptions);
    uint64_t v39 = v40;
    if (v40)
    {
      *(&v40->_includePrivateTransactions + 1) = v24;
      objc_setProperty_nonatomic(v40, v41, v170[5], 32LL);
    }

    uint64_t v42 = -[PFCloudKitHistoryAnalyzer initWithOptions:managedObjectContext:]( objc_alloc(&OBJC_CLASS___PFCloudKitHistoryAnalyzer),  "initWithOptions:managedObjectContext:",  v39,  v3);
    uint64_t v43 = (void *)MEMORY[0x186E3E5D8]();
    unint64_t v37 = (uint64_t *)v42;
    uint64_t v44 = __ckLoggingOverride;
    uint64_t v45 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Exporting changes since (%d): %@"];
    if (v44 >= 0x10) {
      uint64_t v52 = 16LL;
    }
    else {
      uint64_t v52 = v44;
    }
    _NSCoreDataLog( v52,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  (uint64_t)"-[PFCloudKitExporter analyzeHistoryInStore:withManagedObjectContext:error:]");
    objc_autoreleasePoolPop(v43);
    uint64_t v53 = -[PFHistoryAnalyzer newAnalyzerContextForStore:sinceLastHistoryToken:inManagedObjectContext:error:]( (uint64_t)v37,  (uint64_t)v4,  v25,  v3,  v174);
    uint64_t v38 = (void *)v53;
    if (v53)
    {
      __int16 v54 = *(void *)(v53 + 48);
      if (v54)
      {
        +[NSCKMetadataEntry updateOrInsertMetadataEntryWithKey:transformedValue:forStore:intoManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMetadataEntry,  (uint64_t)@"NSCloudKitMirroringDelegateLastHistoryTokenKey",  v54,  (uint64_t)v4,  v3,  v174);
        if (v174[0])
        {
          unint64_t v55 = v174[0];
          goto LABEL_54;
        }

        uint64_t v80 = +[NSCKMetadataEntry entryForKey:fromStore:inManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMetadataEntry,  (uint64_t)@"NSCloudKitMirroringDelegateBypassHistoryOnExportKey",  (uint64_t)v4,  v3,  (uint64_t)v174);
        if (v174[0])
        {
          uint64_t v81 = (void *)MEMORY[0x186E3E5D8](v80);
          uint64_t v82 = __ckLoggingOverride;
          uint64_t v83 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Unable to read the bypass entry: %@"];
          _NSCoreDataLog( v82 != 0,  v83,  v84,  v85,  v86,  v87,  v88,  v89,  (uint64_t)"-[PFCloudKitExporter analyzeHistoryInStore:withManagedObjectContext:error:]");
          objc_autoreleasePoolPop(v81);
          v90 = v174[0];
          goto LABEL_54;
        }

        uint64_t v91 = v80;
        if (v80) {
          [v3 deleteObject:v80];
        }
        if (objc_msgSend(v3, "hasChanges", v91))
        {
          if (([v3 save:v174] & 1) == 0) {
            v92 = v174[0];
          }
          [v3 reset];
        }
      }

      unint64_t v57 = 1;
      goto LABEL_55;
    }

    if (!v174[0])
    {
      uint64_t v61 = [NSString stringWithUTF8String:"History analyzer should have set an error if the analyzer context is nil."];
      _NSCoreDataLog(17LL, v61, v62, v63, v64, v65, v66, v67, v168);
      uint64_t v68 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_186681000,  v68,  OS_LOG_TYPE_FAULT,  "CoreData: History analyzer should have set an error if the analyzer context is nil.",  buf,  2u);
      }
    }

    uint64_t v69 = v174[0];
    uint64_t v70 = (void *)[v174[0] domain];
    if ([v70 isEqualToString:*MEMORY[0x189607460]]
      && [v174[0] code] == 134419
      && v37
      && v37[3])
    {
      *(void *)buf = 0LL;
      if (!+[NSCKMetadataEntry updateOrInsertMetadataEntryWithKey:transformedValue:forStore:intoManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMetadataEntry,  (uint64_t)@"NSCloudKitMirroringDelegateLastHistoryTokenKey",  v37[3],  (uint64_t)v4,  v3,  buf))
      {
        uint64_t v71 = (void *)MEMORY[0x186E3E5D8]();
        uint64_t v93 = __ckLoggingOverride;
        __int16 v94 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Failed to update exporter history token after deferral: %@"];
        _NSCoreDataLog( v93 != 0,  v94,  v95,  v96,  v97,  v98,  v99,  v100,  (uint64_t)"-[PFCloudKitExporter analyzeHistoryInStore:withManagedObjectContext:error:]");
        goto LABEL_52;
      }

      if (([v3 save:buf] & 1) == 0)
      {
        uint64_t v71 = (void *)MEMORY[0x186E3E5D8]();
        uint64_t v72 = __ckLoggingOverride;
        uint64_t v73 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Failed to save exporter history token after deferral: %@"];
        _NSCoreDataLog( v72 != 0,  v73,  v74,  v75,  v76,  v77,  v78,  v79,  (uint64_t)"-[PFCloudKitExporter analyzeHistoryInStore:withManagedObjectContext:error:]");
LABEL_52:
        objc_autoreleasePoolPop(v71);
      }
    }

    uint64_t v38 = 0LL;
    goto LABEL_54;
  }

  unint64_t v37 = 0LL;
  uint64_t v38 = 0LL;
  uint64_t v39 = 0LL;
LABEL_54:
  unint64_t v57 = 0;
LABEL_55:

  int v1 = (void *)a1;
  if ((v57 & 1) == 0)
  {
    v101 = (id *)v174[0];
    if (v101)
    {
      v173 = v101;
    }

    else
    {
      v102 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v102,  v103,  v104,  v105,  v106,  v107,  v108,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitExporter.m");
      v109 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitExporter.m";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 629;
        _os_log_fault_impl( &dword_186681000,  v109,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }
  }

  if ((v57 & 1) == 0)
  {
    int v2 = v173;
LABEL_74:
    *(_BYTE *)(*(void *)(v1[7] + 8LL) + 24LL) = 0;
    v119 = v2;
    goto LABEL_75;
  }

  v110 = *(void *)(a1 + 32);
  if (v110)
  {
    v111 = *(void *)(v110 + 40);
    if (v111)
    {
      if (([*(id *)(v111 + 64) shouldDefer] & 1) != 0 || *(_BYTE *)(v111 + 40))
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
        v112 = objc_alloc(MEMORY[0x189607870]);
        v178 = *MEMORY[0x1896075F0];
        v179 = @"The request was aborted because it was deferred by the system.";
        v113 = [MEMORY[0x189603F68] dictionaryWithObjects:&v179 forKeys:&v178 count:1];
        v114 = (id *)[v112 initWithDomain:*MEMORY[0x189607460] code:134419 userInfo:v113];
LABEL_66:
        *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL) = v114;
        goto LABEL_67;
      }
    }
  }

  v120 = (void *)+[NSCKHistoryAnalyzerState countAnalyzerStatesInStore:withManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKHistoryAnalyzerState,  *(void *)(a1 + 40),  *(void *)(a1 + 48),  (id *)&v173);
  if (v120)
  {
    if ([v120 integerValue] >= 1)
    {
      v121 = a1 + 56;
      v122 = 1;
      goto LABEL_108;
    }

    v153 = (void *)+[NSCKMetadataEntry entryForKey:fromStore:inManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMetadataEntry,  (uint64_t)@"NSCloudKitMirroringDelegateScanForRowsMissingFromHistoryKey",  *(void *)(a1 + 40),  *(void **)(a1 + 48),  (uint64_t)&v173);
    if (v153)
    {
      v122 = [v153 BOOLValue];
      goto LABEL_104;
    }

    v161 = v173;
    if (!v173)
    {
      v122 = 0;
      goto LABEL_104;
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
    v151 = v161;
  }

  else
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
    v151 = v173;
  }

  v152 = v151;
  v122 = 0;
  *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL) = v152;
LABEL_104:
  v121 = a1 + 56;
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) && (v122 & 1) == 0)
  {
    v154 = +[NSCKRecordZoneMoveReceipt countMoveReceiptsInStore:matchingPredicate:withManagedObjectContext:error:]( NSCKRecordZoneMoveReceipt,  "countMoveReceiptsInStore:matchingPredicate:withManagedObjectContext:error:",  *(void *)(a1 + 40),  [MEMORY[0x1896079C8] predicateWithFormat:@"needsCloudDelete == 1"],  *(void *)(a1 + 48),  &v173);
    if (!v154)
    {
LABEL_111:
      *(_BYTE *)(*(void *)(*(void *)v121 + 8LL) + 24LL) = 0;
      v114 = v173;
      goto LABEL_66;
    }

    v122 = [v154 integerValue] > 0;
  }

  while (v4 < v5)
  {
    uint64_t v7 = *v4++;
    int v3 = 257 * v3 + v7;
  }

  return (v3 << (Length & 0x1F)) + v3;
}

  BOOL v5 = 0LL;
  uint64_t v11 = 1;
LABEL_27:
  if (v4 && (uint64_t v28 = v4[3]) != 0) {
    uint64_t v29 = *(void *)(v28 + 72);
  }
  else {
    uint64_t v29 = 0LL;
  }
  -[PFCloudKitMetricsClient logMetric:](v29, *(void **)(a1[4] + 64));
  if (v4 && (uint64_t v30 = v4[3]) != 0) {
    uint64_t v31 = *(void *)(v30 + 72);
  }
  else {
    uint64_t v31 = 0LL;
  }
  -[PFCloudKitMetricsClient logMetric:](v31, *(void **)(a1[4] + 56));
  uint64_t v69 = 0u;
  uint64_t v70 = 0u;
  uint64_t v67 = 0u;
  uint64_t v68 = 0u;
  uint64_t v32 = *(void **)(a1[4] + 104);
  uint64_t v33 = [v32 countByEnumeratingWithState:&v67 objects:v77 count:16];
  if (v33)
  {
    uint64_t v34 = *(void *)v68;
LABEL_35:
    unint64_t v35 = 0LL;
    while (1)
    {
      if (*(void *)v68 != v34) {
        objc_enumerationMutation(v32);
      }
      if ([*(id *)(*((void *)&v67 + 1) + 8 * v35) madeChanges]) {
        break;
      }
      if (v33 == ++v35)
      {
        uint64_t v33 = [v32 countByEnumeratingWithState:&v67 objects:v77 count:16];
        if (v33) {
          goto LABEL_35;
        }
        goto LABEL_41;
      }
    }

    unint64_t v36 = 1LL;
    if (!v11) {
      goto LABEL_42;
    }
LABEL_49:
    uint64_t v51 = (uint64_t *)a1[4];
    if (v51)
    {
      uint64_t v71 = 0LL;
      uint64_t v72 = &v71;
      uint64_t v73 = 0x3052000000LL;
      v74 = __Block_byref_object_copy__40;
      unint64_t v75 = __Block_byref_object_dispose__40;
      unint64_t v76 = 0LL;
      uint64_t v52 = (void *)v51[1];
      if (v52) {
        uint64_t v52 = (void *)v52[2];
      }
      uint64_t v53 = v52;
      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __81__PFCloudKitImportRecordsWorkItem_newMirroringResultByApplyingAccumulatedChanges__block_invoke;
      uint64_t v81 = &unk_189EA72B0;
      uint64_t v82 = v53;
      uint64_t v83 = v51;
      v84 = &v71;
      -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v53, (uint64_t)buf);

      __int16 v54 = (void *)v72[5];
      _Block_object_dispose(&v71, 8);
      if (v54)
      {
        if (![v54 success]
          || (([v54 madeChanges] | v36 ^ 1) & 1) != 0)
        {
          goto LABEL_66;
        }

        unint64_t v55 = (void *)a1[4];
        if (v55)
        {
          __int16 v56 = v55[2];
          if (!v4) {
            goto LABEL_80;
          }
        }

        else
        {
          __int16 v56 = 0LL;
          if (!v4) {
            goto LABEL_80;
          }
        }

        unint64_t v57 = v4[2];
        if (v57)
        {
          __int16 v58 = *(void *)(v57 + 48);
LABEL_59:
          unint64_t v59 = [v55 createMirroringResultForRequest:v56 storeIdentifier:v58 success:1 madeChanges:1 error:0];
LABEL_65:
          __int16 v54 = (void *)v59;
LABEL_66:
          v65 = a1[6];
          if (v65) {
            (*(void (**)(uint64_t, void *))(v65 + 16))(v65, v54);
          }

          goto LABEL_69;
        }

  -[NSSQLStoreRequestContext setConnection:]((uint64_t)v4, 0LL);

  return v7;
}

LABEL_73:
  __int16 v56 = 0LL;
LABEL_120:
  uint64_t v69 = v56;
  objc_autoreleasePoolPop(context);
  return v56;
}

                      uint64_t v34 = v22;
LABEL_74:
                      uint64_t v33 = -[__CFString description](v34, "description");
LABEL_75:
                      uint64_t v22 = (__CFString *)v33;
                      goto LABEL_76;
                    }

                    if (v23 != 400 && v23 != 500) {
                      goto LABEL_67;
                    }
                  }
                }

                else
                {
                  if (v23 > 1199)
                  {
                    if (v23 > 1999)
                    {
                      if (v23 != 2000 && v23 != 2100) {
                        goto LABEL_67;
                      }
                    }

                    else if (v23 != 1200 && v23 != 1800)
                    {
                      goto LABEL_67;
                    }

                    goto LABEL_73;
                  }

                  if (v23 > 999)
                  {
                    if (v23 != 1000)
                    {
                      if (v23 != 1100) {
                        goto LABEL_67;
                      }
                      goto LABEL_73;
                    }

                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) != 0
                      || !-[__CFString isNSData](v22, "isNSData")
                      || (unint64_t)-[__CFString length](v22, "length") < 0x33)
                    {
                      goto LABEL_73;
                    }

                    uint64_t v34 = (__CFString *)-[__CFString subdataWithRange:](v22, "subdataWithRange:", 0LL, 50LL);
                    goto LABEL_74;
                  }

                  if (v23 != 800 && v23 != 900) {
                    goto LABEL_67;
                  }
                }

          ++v52;
        }
      }

      int v1 = v74;
      uint64_t v21 = (void *)v77;
      uint64_t v43 = v71;
LABEL_90:
      *(void *)(v75 + 8 * v42) = v48;
LABEL_91:
      ++v42;
    }

    while (v42 != v43);
LABEL_92:
    uint64_t v38 = 1;
    uint64_t v39 = 7LL;
  }

  while ((v72 & 1) == 0);
  v65 = v69;
  unint64_t v66 = -[NSKnownKeysDictionary count](v69, "count");
  if (v66) {
    uint64_t v67 = v70;
  }
  else {
    uint64_t v67 = v69;
  }
  if (!v66) {
    v65 = v70;
  }

  return v65;
}

                  ++v27;
                  ++v28;
                }

                while (v25 != v28);
                id v49 = [v199 countByEnumeratingWithState:&v214 objects:v246 count:16];
                unint64_t v25 = v49;
              }

              while (v49);
            }

LABEL_22:
    unint64_t v26 = [v22 propertyType];
    if (objc_msgSend((id)objc_msgSend(v22, "propertyDescription"), "isTransient"))
    {
      uint64_t v28 = (void *)MEMORY[0x189603F70];
      uint64_t v29 = *MEMORY[0x189603A60];
      uint64_t v30 = @"transient property used in fetch request";
      goto LABEL_46;
    }

    if ([v22 isToMany]) {
      goto LABEL_26;
    }
    if (!v22) {
      goto LABEL_32;
    }
    unint64_t v27 = v22[24];
    if (v27 == 9)
    {
LABEL_26:
      if ((a4 & 1) == 0)
      {
        uint64_t v28 = (void *)MEMORY[0x189603F70];
        uint64_t v29 = *MEMORY[0x189603A60];
        uint64_t v30 = @"to-many key not allowed here";
        goto LABEL_46;
      }

      if (v16)
      {
        uint64_t v28 = (void *)MEMORY[0x189603F70];
        uint64_t v29 = *MEMORY[0x189603A60];
        uint64_t v30 = @"multiple to-many keys not allowed here";
LABEL_46:
        objc_msgSend( v36,  "setObject:forKey:",  objc_msgSend(v28, "exceptionWithName:reason:userInfo:", v29, v30, 0),  @"NSUnderlyingException");
        return 0LL;
      }

      if (!v22)
      {
        unint64_t v16 = 1LL;
        goto LABEL_32;
      }

      unint64_t v27 = v22[24];
      unint64_t v16 = 1LL;
    }

    if (v27 == 7 && (a5 & 1) == 0)
    {
      uint64_t v28 = (void *)MEMORY[0x189603F70];
      uint64_t v29 = *MEMORY[0x189603A60];
      uint64_t v30 = @"to-one key not allowed here";
      goto LABEL_46;
    }

    storeIdentifier = 0LL;
    goto LABEL_19;
  }

  objc_initWeak(location, self);
  if (-[NSCloudKitMirroringRequest options](self->super.super._request, "options")) {
    -[NSCloudKitMirroringRequestOptions applyToOperation:]( (uint64_t)-[NSCloudKitMirroringRequest options](self->super.super._request, "options"),  v18);
  }
  v29[0] = v8;
  v29[1] = 3221225472LL;
  v29[2] = __120__PFCloudKitCKQueryBackedImportWorkItem_executeImportOperationsAndAccumulateRecordsWithManagedObjectContext_completion___block_invoke;
  v29[3] = &unk_189EA7AB0;
  objc_copyWeak(&v30, location);
  [v18 setRecordMatchedBlock:v29];
  v27[0] = v8;
  v27[1] = 3221225472LL;
  v27[2] = __120__PFCloudKitCKQueryBackedImportWorkItem_executeImportOperationsAndAccumulateRecordsWithManagedObjectContext_completion___block_invoke_2;
  v27[3] = &unk_189EA7AD8;
  objc_copyWeak(&v28, location);
  v27[4] = a4;
  [v18 setQueryCompletionBlock:v27];
  objc_destroyWeak(&v28);
  objc_destroyWeak(&v30);
  objc_destroyWeak(location);
  int v19 = self->super.super._options;
  if (v19) {
    database = v19->_database;
  }
  else {
    database = 0LL;
  }
  -[CKDatabase addOperation:](database, "addOperation:", v18);
LABEL_20:
}

  else {
    return v11;
  }
}

        unint64_t v16 = (void *)[v10 objectAtIndexedSubscript:1];
        if ([@"binary" caseInsensitiveCompare:v16])
        {
          if ([@"rtree" caseInsensitiveCompare:v16]) {
            return;
          }
          BOOL v14 = 1LL;
        }

        else
        {
LABEL_26:
          BOOL v14 = 0LL;
        }

        BOOL v13 = (void *)[v10 objectAtIndexedSubscript:0];
        goto LABEL_28;
      }

      uint64_t v8 = 0LL;
LABEL_34:
      int v19 = -[NSFetchIndexDescription initWithName:elements:]( objc_alloc(&OBJC_CLASS___NSFetchIndexDescription),  "initWithName:elements:",  v7,  v8);
      -[NSFetchIndexDescription _setEntity:](v19, "_setEntity:", a1);
      if (!v19) {
        return;
      }
      int v3 = v23;
      if (!v23) {
        int v3 = (void *)[MEMORY[0x189603FA8] array];
      }
      [v3 addObject:v19];
    }

    int v20 = [a2 countByEnumeratingWithState:&v26 objects:v30 count:16];
  }

  while (v20);
  if (v3 && objc_msgSend(v3, "count", 0))
  {
    if (a3) {
      -[NSEntityDescription _addSupplementalIndexes:](a1, v3);
    }
    else {
      -[NSEntityDescription _setIndexes:](a1, v3);
    }
  }

  uint64_t v21 = [a3 _nonPredicateValidateValue:a2 forKey:a4 inObject:a1 error:v12];
  int v19 = v21;
  if (a6 && (v21 & 1) == 0)
  {
LABEL_24:
    -[NSManagedObject _chainNewError:toOriginalErrorDoublePointer:](a1, v62, v63);
LABEL_25:
    int v19 = 0;
  }

  if (!*a2) {
    goto LABEL_59;
  }
  if (a6) {
    uint64_t v22 = 1;
  }
  else {
    uint64_t v22 = v19;
  }
  if (v22 != 1) {
    goto LABEL_62;
  }
  uint64_t v23 = (void *)[a3 _rawValidationPredicates];
  __int16 v54 = (uint64_t)a3;
  uint64_t v60 = (void *)[a3 _rawValidationWarnings];
  uint64_t v24 = [v23 count];
  if (!v24)
  {
LABEL_59:
    if (a6)
    {
      if ((v19 & 1) == 0)
      {
        LOBYTE(v19) = 0;
        *a6 = v63[0];
      }
    }

    return v19 & 1;
  }

  unint64_t v25 = v24;
  unint64_t v59 = v20;
  unint64_t v26 = 0LL;
  __int16 v56 = *MEMORY[0x1896075E0];
  unint64_t v55 = *MEMORY[0x189607460];
  __int16 v58 = a4;
  while ((objc_msgSend((id)objc_msgSend(v23, "objectAtIndex:", v26), "evaluateWithObject:", *a2) & 1) != 0)
  {
LABEL_47:
    if (v25 == ++v26) {
      goto LABEL_59;
    }
  }

  if (!a6) {
    goto LABEL_62;
  }
  unint64_t v27 = (void *)[v60 objectAtIndex:v26];
  uint64_t v28 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  objc_msgSend(v23, "objectAtIndex:", v26),  @"NSValidationErrorPredicate",  0);
  if (!v27)
  {
    uint64_t v31 = *a2;
    uint64_t v32 = (uint64_t)a1;
    uint64_t v33 = 1550;
LABEL_44:
    uint64_t v30 = 0LL;
LABEL_45:
    uint64_t v34 = -[NSManagedObject _generateErrorWithCode:andMessage:forKey:andValue:additionalDetail:]( v32,  v33,  v30,  a4,  v31,  v28);
    uint64_t v62 = v34;
LABEL_46:
    -[NSManagedObject _chainNewError:toOriginalErrorDoublePointer:](a1, v34, v63);
    LOBYTE(v19) = 0;
    goto LABEL_47;
  }

  if ([v27 isNSString])
  {
    uint64_t v29 = objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v59, "managedObjectModel"), "_localizationPolicy"),  "localizedModelStringForKey:",  v27);
    if (v29) {
      uint64_t v30 = (void *)v29;
    }
    else {
      uint64_t v30 = v27;
    }
    uint64_t v31 = *a2;
    uint64_t v32 = (uint64_t)a1;
    uint64_t v33 = 1550;
    goto LABEL_45;
  }

  if ([v27 isNSNumber])
  {
    uint64_t v33 = [v27 intValue];
    uint64_t v31 = *a2;
    uint64_t v32 = (uint64_t)a1;
    goto LABEL_44;
  }

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    unint64_t v57 = (void *)objc_msgSend(MEMORY[0x189603FC8], "dictionaryWithDictionary:", objc_msgSend(v27, "userInfo"));
    unint64_t v35 = *a2;
    unint64_t v36 = (void *)MEMORY[0x189603FC8];
    if (!*a2) {
      unint64_t v35 = [MEMORY[0x189603FE8] null];
    }
    objc_msgSend( v57,  "addEntriesFromDictionary:",  objc_msgSend( v36,  "dictionaryWithObjectsAndKeys:",  a1,  @"NSValidationErrorObject",  v58,  @"NSValidationErrorKey",  v35,  @"NSValidationErrorValue",  0));
    [v57 addEntriesFromDictionary:v28];
    if ([v57 valueForKey:v56]
      || [v27 domain] == v55 && objc_msgSend(v27, "code") >= 1024 && objc_msgSend(v27, "code") < 2048)
    {
      unint64_t v37 = (void *)MEMORY[0x189607870];
      uint64_t v38 = [v27 domain];
      uint64_t v39 = [v27 code];
      uint64_t v40 = v37;
      uint64_t v41 = v38;
      uint64_t v42 = (uint64_t)v57;
    }

    else
    {
      uint64_t v43 = (void *)[MEMORY[0x189607870] errorWithDomain:v55 code:1550 userInfo:v57];
      objc_msgSend( v57,  "setObject:forKey:",  -[NSManagedObject _substituteEntityAndProperty:inString:]( a1,  v54,  (void *)objc_msgSend(v43, "localizedDescription")),  v56);
      uint64_t v44 = (void *)MEMORY[0x189607870];
      uint64_t v45 = [v27 domain];
      unint64_t v46 = [v27 code];
      uint64_t v42 = [v43 userInfo];
      uint64_t v40 = v44;
      uint64_t v41 = v45;
      uint64_t v39 = v46;
    }

    uint64_t v34 = [v40 errorWithDomain:v41 code:v39 userInfo:v42];
    uint64_t v62 = v34;
    a4 = v58;
    goto LABEL_46;
  }

  unint64_t v48 = (void *)MEMORY[0x189603F70];
  id v49 = *MEMORY[0x189603A58];
  uint64_t v50 = objc_msgSend( NSString,  "stringWithFormat:",  @"Illegal validation warning: property = %@; predicate/warning index = %lu; warning = %@.",
          v58,
          v26,
          v27);
  objc_exception_throw((id)objc_msgSend( v48,  "exceptionWithName:reason:userInfo:",  v49,  v50,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  v58,  @"NSValidationErrorKey",  objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedLong:", v26),  @"index",  v27,  @"warning",  *a2,  @"NSValidationErrorValue",  0)));
  return -[NSManagedObject validateForDelete:](v51, v52, v53);
}

  v49[5] = 0LL;
  v42[5] = 0LL;

  unint64_t v36 = *((_BYTE *)v55 + 24);
  _Block_object_dispose(&v41, 8);
  _Block_object_dispose(&v48, 8);
  _Block_object_dispose(&v54, 8);
  return v36;
}

  dispatch_sync_f( (dispatch_queue_t)self->_dispatchQueue,  v12,  (dispatch_function_t)developerSubmittedBlockToNSPersistentStoreCoordinatorPerform);
LABEL_23:
  int v3 = v13;
  if (v13)
  {
LABEL_26:
    uint64_t v11 = v3;
    objc_exception_throw(v3);
  }

    dispatch_sync_f(v3, v15, (dispatch_function_t)internalBlockToNSPersistentStoreCoordinatorPerform);
LABEL_23:
    int v10 = v16;
    if (v16)
    {
      uint64_t v11 = v16;
      objc_exception_throw(v10);
      -[NSPersistentStoreCoordinator setName:](v12, v13, v14);
    }
  }

  [*(id *)(*(void *)(a1 + 32) + 8) setReturnsObjectsAsFaults:*(unsigned __int8 *)(a1 + 57)];
  uint64_t v7 = *(id *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  uint64_t v8 = *(void *)(a1 + 32);
  if (!*(void *)(v8 + 96))
  {

    *(void *)(*(void *)(a1 + 32) + 104LL) = 0LL;
    *(void *)(*(void *)(a1 + 32) + 112LL) = 0LL;

    *(void *)(*(void *)(a1 + 32) + 120LL) = 0LL;
    *(void *)(*(void *)(a1 + 32) + 128LL) = 0LL;
    *(_DWORD *)(*(void *)(a1 + 32) + 72LL) &= ~4u;
    *(_DWORD *)(*(void *)(a1 + 32) + 72LL) &= ~2u;
  }

    int v20 = 1LL;
  }

  else
  {
    int v20 = 0LL;
  }

    -[NSFetchRequest setSortDescriptors:](v62, "setSortDescriptors:", v12);

    if (!v15)
    {
      if (!-[NSFetchRequest predicate](v61, "predicate")
        || (unint64_t v35 = (void *)+[NSPersistentCloudKitContainerEventRequest translatePredicate:orReturnFailureReason:]( (uint64_t)&OBJC_CLASS___NSPersistentCloudKitContainerEventRequest,  -[NSFetchRequest predicate](v61, "predicate"),  &v70),  -[NSFetchRequest setPredicate:](v62, "setPredicate:", v35),  v35,  !v70))
      {
        if (v62)
        {
          unint64_t v36 = (void *)[[v60 alloc] initWithCKEventFetchRequest:v62];

          return (NSPersistentCloudKitContainerEventRequest *)v36;
        }

        goto LABEL_28;
      }
    }
  }

  else
  {
    uint64_t v38 = (void *)NSString;
    uint64_t v39 = (objc_class *)objc_opt_class();
    uint64_t v40 = NSStringFromClass(v39);
    uint64_t v41 = (objc_class *)objc_opt_class();
    NSStringFromClass(v41);
    -[NSFetchRequest entityName](fetchRequest, "entityName");
    uint64_t v42 = (objc_class *)objc_opt_class();
    NSStringFromClass(v42);
    NSStringFromSelector(sel_fetchRequest);
    __int16 v56 = (uint64_t)v40;
    uint64_t v70 = [v38 stringWithFormat:@"Fetch requests for '%@' must use '%@' as the entity name, '%@' is not valid. Please consider using +[%@ %@]."];
    if (!v70)
    {
LABEL_28:
      uint64_t v43 = [NSString stringWithUTF8String:"Fetch request validation for NSPersistentCloudKitContainerEventRequest failed but did not report a failure reason."];
      _NSCoreDataLog(17LL, v43, v44, v45, v46, v47, v48, v49, v56);
      uint64_t v50 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_186681000,  v50,  OS_LOG_TYPE_FAULT,  "CoreData: Fetch request validation for NSPersistentCloudKitContainerEventRequest failed but did not report a failure reason.",  buf,  2u);
      }

      uint64_t v51 = (void *)MEMORY[0x189603F70];
      uint64_t v52 = *MEMORY[0x189603A60];
      uint64_t v53 = 0LL;
      goto LABEL_33;
    }

    uint64_t v62 = 0LL;
  }

      BOOL v13 = (void *)v16;
LABEL_23:
      [v4 addObject:v13];
    }

    uint64_t v7 = [v5 countByEnumeratingWithState:&v37 objects:v47 count:16];
  }

  while (v7);
LABEL_25:
  uint64_t v17 = *(void **)(v32 + 16);
  if (!v17) {
    uint64_t v17 = *(void **)(v32 + 8);
  }
  if ([v17 count] == 1)
  {
    int v18 = (id)[v4 firstObject];
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      int v19 = (id)[v18 objectID];

      int v18 = v19;
    }
  }

  else
  {
    int v20 = objc_alloc(&OBJC_CLASS___NSConstraintCacheKey);
    if (v20)
    {
      v45.receiver = v20;
      v45.super_class = (Class)&OBJC_CLASS___NSConstraintCacheKey;
      int v18 = objc_msgSendSuper2(&v45, sel_init);
      if (v18)
      {
        uint64_t v21 = objc_alloc_init(MEMORY[0x189603FA8]);
        uint64_t v41 = 0u;
        uint64_t v42 = 0u;
        uint64_t v43 = 0u;
        uint64_t v44 = 0u;
        uint64_t v22 = [v4 countByEnumeratingWithState:&v41 objects:v48 count:16];
        if (v22)
        {
          uint64_t v23 = v22;
          uint64_t v24 = *(void *)v42;
          do
          {
            for (j = 0LL; j != v23; ++j)
            {
              if (*(void *)v42 != v24) {
                objc_enumerationMutation(v4);
              }
              unint64_t v26 = *(void **)(*((void *)&v41 + 1) + 8 * j);
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0) {
                unint64_t v26 = (void *)[v26 objectID];
              }
              [v21 addObject:v26];
            }

            uint64_t v23 = [v4 countByEnumeratingWithState:&v41 objects:v48 count:16];
          }

          while (v23);
        }

        v18[1] = [v21 copy];
      }
    }

    else
    {
      int v18 = 0LL;
    }
  }

  unint64_t v27 = (id)[*(id *)(v32 + 32) objectForKey:v18];
  if (!v27)
  {
    unint64_t v27 = objc_alloc_init(MEMORY[0x189603FA8]);
    [*(id *)(v32 + 32) setObject:v27 forKey:v18];
  }

  [v27 addObject:a2];
  unint64_t v35 = 0u;
  unint64_t v36 = 0u;
  uint64_t v33 = 0u;
  uint64_t v34 = 0u;
  uint64_t v28 = *(void **)(v32 + 40);
  uint64_t result = [v28 countByEnumeratingWithState:&v33 objects:v46 count:16];
  if (result)
  {
    uint64_t v29 = result;
    uint64_t v30 = *(void *)v34;
    do
    {
      uint64_t v31 = 0LL;
      do
      {
        if (*(void *)v34 != v30) {
          objc_enumerationMutation(v28);
        }
        -[NSConstraintCache registerObject:](*(void *)(*((void *)&v33 + 1) + 8 * v31++), a2);
      }

      while (v29 != v31);
      uint64_t result = [v28 countByEnumeratingWithState:&v33 objects:v46 count:16];
      uint64_t v29 = result;
    }

    while (result);
  }

  return result;
}

                        uint64_t v23 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
                        _NSCoreDataLog( 17LL,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringDelegate.m");
                        uint64_t v30 = (os_log_s *)__pflogFaultLog;
                        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)buf = 136315394;
                          *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringDelegate.m";
                          *(_WORD *)&buf[12] = 1024;
                          *(_DWORD *)&buf[14] = 1005;
                          _os_log_fault_impl( &dword_186681000,  v30,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
                        }

                        goto LABEL_24;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      *(void *)buf = MEMORY[0x1895F87A8];
      *(void *)&buf[8] = 3221225472LL;
      *(void *)&buf[16] = __47__NSCloudKitMirroringDelegate__enqueueRequest___block_invoke;
      unint64_t v36 = &unk_189EAB0A8;
      unint64_t v37 = v5;
      uint64_t v38 = a2;
      -[NSCloudKitMirroringDelegate _openTransactionWithLabel:assertionLabel:andExecuteWorkBlock:]( v5,  (uint64_t)@"com.apple.coredata.cloudkit.schedule.enqueue",  (uint64_t)@"CoreData: CloudKit Scheduling",  (uint64_t)buf);
      if (v6) {
        return v6;
      }
    }

    else
    {
    }

    unint64_t v16 = v32;
    if (v32) {
      goto LABEL_19;
    }
    goto LABEL_22;
  }

  return result;
}

  if (!*((_BYTE *)v54 + 24))
  {
    uint64_t v29 = (id)v58[5];
    if (v29)
    {
      if (a8) {
        *a8 = v29;
      }
    }

    else
    {
      uint64_t v30 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringDelegate+CLI.m");
      unint64_t v37 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        uint64_t v64 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringDelegate+CLI.m";
        v65 = 1024;
        unint64_t v66 = 588;
        _os_log_fault_impl( &dword_186681000,  v37,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }
  }

  v58[5] = 0LL;
  unint64_t v27 = *((_BYTE *)v54 + 24);
  _Block_object_dispose(&v53, 8);
  _Block_object_dispose(&v57, 8);
  return v27;
}

    LOBYTE(v9) = 0;
    return v9;
  }

  uint64_t v12 = [a3 mirroringDelegate];
  BOOL v13 = [a4 mirroringDelegate];
  if (!v12 || !v13)
  {
    if (!(v12 | v13)) {
      goto LABEL_2;
    }
    uint64_t v28 = (void *)MEMORY[0x189607870];
    uint64_t v29 = *MEMORY[0x189607460];
    uint64_t v38 = *MEMORY[0x1896075F0];
    uint64_t v39 = [NSString stringWithFormat:@"Stores don't match because they do not have the same mirroring configuration:\n%@ - %@\n%@ - %@", a3, v12, a4, v13];
    unint64_t v25 = [MEMORY[0x189603F68] dictionaryWithObjects:&v39 forKeys:&v38 count:1];
    unint64_t v26 = v28;
    unint64_t v27 = v29;
LABEL_19:
    BOOL v14 = (void *)[v26 errorWithDomain:v27 code:134060 userInfo:v25];
    uint64_t v31 = v14;
    if (!v14) {
      goto LABEL_16;
    }
    goto LABEL_20;
  }

  if (!-[PFCloudKitStoreComparer compareCloudKitMetadataOfStore:toStore:error:]( self,  "compareCloudKitMetadataOfStore:toStore:error:",  a3,  a4,  &v31)) {
    goto LABEL_15;
  }
LABEL_2:
  LOBYTE(v9) = 1;
  return v9;
}

      if (v11 == ++v14)
      {
        uint64_t v11 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
        uint64_t result = 1;
        if (v11) {
          goto LABEL_10;
        }
        return result;
      }
    }

    int v18 = [v16 destinationEntity];
    if (v12) {
      return 0;
    }
    id v6 = (id *)v18;
    uint64_t v12 = 1LL;
    goto LABEL_22;
  }

  return 1;
}

      v175 = [v11 count];
      v239 = 0u;
      v240 = 0u;
      *(_OWORD *)v237 = 0u;
      v238 = 0u;
      BOOL v13 = [v199 countByEnumeratingWithState:v237 objects:v244 count:16];
      if (v13)
      {
        BOOL v14 = *(void *)v238;
        do
        {
          for (uint64_t i = 0LL; i != v13; ++i)
          {
            if (*(void *)v238 != v14) {
              objc_enumerationMutation(v199);
            }
            unint64_t v16 = *(void *)(*(void *)&v237[8] + 8 * i);
            if (v16)
            {
              uint64_t v17 = *(unsigned __int8 *)(v16 + 24);
              if (v17 == 7 || v17 == 1) {
                objc_msgSend(v11, "addObject:");
              }
            }
          }

          BOOL v13 = [v199 countByEnumeratingWithState:v237 objects:v244 count:16];
        }

        while (v13);
      }

      v177 = -[NSSQLiteConnection executeAttributeUniquenessCheckSQLStatement:returningColumns:](v154, v7, v11);

      int v19 = [v177 count];
      v162 = objc_alloc_init(MEMORY[0x1896077E8]);
      if (!v19) {
        goto LABEL_120;
      }
      v235 = 0u;
      v236 = 0u;
      v233 = 0u;
      v234 = 0u;
      v156 = [v168 countByEnumeratingWithState:&v233 objects:v243 count:16];
      if (!v156) {
        goto LABEL_120;
      }
      int v20 = *(void **)v234;
      v149 = *(void **)v234;
LABEL_39:
      uint64_t v21 = 0LL;
LABEL_40:
      if (*(void **)v234 != v20)
      {
        uint64_t v22 = v21;
        objc_enumerationMutation(v168);
        uint64_t v21 = v22;
      }

      v151 = v21;
      v203 = *(id *)(*((void *)&v233 + 1) + 8 * v21);
      v195 = _sqlCoreLookupSQLEntityForEntityDescription(v166, (void *)[v203 entity]);
      v231 = 0u;
      v232 = 0u;
      v229 = 0u;
      v230 = 0u;
      v186 = [v177 countByEnumeratingWithState:&v229 objects:&v225 count:16];
      if (v186)
      {
        v181 = *(void *)v230;
        while (1)
        {
          uint64_t v23 = 0LL;
          do
          {
            if (*(void *)v230 != v181)
            {
              uint64_t v24 = v23;
              objc_enumerationMutation(v177);
              uint64_t v23 = v24;
            }

            v188 = v23;
            v192 = *(void **)(*((void *)&v229 + 1) + 8 * v23);
            context = (void *)MEMORY[0x186E3E5D8]();
            v197 = (id)[MEMORY[0x189603FA8] array];
            v216 = 0u;
            v217 = 0u;
            v214 = 0u;
            v215 = 0u;
            unint64_t v25 = [v199 countByEnumeratingWithState:&v214 objects:v246 count:16];
            if (v25)
            {
              unint64_t v26 = *(void *)v215;
              unint64_t v27 = v175;
              do
              {
                uint64_t v28 = 0LL;
                do
                {
                  if (*(void *)v215 != v26) {
                    objc_enumerationMutation(v199);
                  }
                  uint64_t v29 = *(void *)(*((void *)&v214 + 1) + 8 * v28);
                  if (v29)
                  {
                    uint64_t v30 = (void *)v29;
                    if (*(_BYTE *)(v29 + 24) == 7) {
                      uint64_t v30 = (void *)[(id)v29 propertyDescription];
                    }
                  }

                  else
                  {
                    uint64_t v30 = 0LL;
                  }

                  uint64_t v31 = (void *)objc_msgSend(v203, "valueForKey:", objc_msgSend(v30, "name"));
                  if (!v29) {
                    goto LABEL_62;
                  }
                  uint64_t v32 = *(unsigned __int8 *)(v29 + 24);
                  if (v32 != 7)
                  {
                    if (v32 == 1)
                    {
                      uint64_t v33 = (id)[v192 objectAtIndex:v27];
                      goto LABEL_72;
                    }

LABEL_32:
    if ((v26 - 7) <= 2)
    {
      a3 = [v22 destinationEntity];
      if (v14 != ++v15) {
        continue;
      }
    }

    return v22;
  }

  if (a3)
  {
    uint64_t v31 = v36;
    if (*(_DWORD *)(a3 + 184) == 16001) {
      uint64_t v22 = (unsigned __int8 *)[*(id *)(a3 + 40) objectForKey:*a6];
    }
    else {
      uint64_t v22 = *(unsigned __int8 **)(a3 + 136);
    }
  }

  else
  {
    uint64_t v22 = 0LL;
    uint64_t v31 = v36;
  }

  objc_msgSend( v31,  "setValue:forKey:",  objc_msgSend(a2, "subarrayWithRange:", 0, v17),  @"entitySpecificationKeypath");
  if (v16) {
    uint64_t v33 = MEMORY[0x189604A88];
  }
  else {
    uint64_t v33 = MEMORY[0x189604A80];
  }
  [v31 setValue:v33 forKey:@"entitySpecificationKeypathContainsToMany"];
  uint64_t v34 = (void *)[v31 valueForKey:@"explicitRestrictingEntityQualifier"];
  if (v34)
  {
    [v34 addObject:MEMORY[0x189604A88]];
  }

  else
  {
    unint64_t v35 = objc_alloc_init(MEMORY[0x189603FA8]);
    [v35 addObject:MEMORY[0x189604A88]];
    [v31 setValue:v35 forKey:@"explicitRestrictingEntityQualifier"];
  }

  return v22;
}

  __dmb(0xBu);
  return result;
}

  uint64_t v51 = (void *)MEMORY[0x189603F70];
  uint64_t v52 = *MEMORY[0x189603A60];
  uint64_t v53 = v70;
LABEL_33:
  objc_exception_throw((id)[v51 exceptionWithName:v52 reason:v53 userInfo:0]);
  return (NSPersistentCloudKitContainerEventRequest *)+[NSPersistentCloudKitContainerEventRequest fetchRequestForEvents]( v54,  v55);
}

void sub_186694980( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t _PFRawIndexForKnownKey(void *a1, __CFString *a2)
{
  if (!a2) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unint64_t v4 = _PFRawFastIndexForKnownKey(a1, a2, &v7);
  if (v4 >= a1[3]) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  unint64_t v5 = v4;
  return v5;
}

uint64_t _PFRawFastIndexForKnownKey(void *a1, __CFString *theString, unint64_t *a3)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  if (!a1[3]) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (!CStringPtr)
  {
    int v19 = (uint64_t **)a1[2];
    int v20 = *v19;
    uint64_t v21 = -[__CFString length](theString, "length");
    if (v20)
    {
      unint64_t v22 = v21;
      int v23 = 0;
      uint64_t v24 = *v20;
      while (1)
      {
        if ((v24 & 0x1FF8) != 0)
        {
          unint64_t v25 = -[__CFString characterAtIndex:](theString, "characterAtIndex:");
        }

        else
        {
          *a3 = v22;
          unint64_t v25 = v22;
        }

        if ((v24 & 7) == 1)
        {
          unint64_t v26 = *((unsigned __int16 *)v20 + 4);
          BOOL v18 = v25 >= v26;
          unint64_t v27 = v25 - v26;
          if (v18)
          {
            if (v25 <= *((unsigned __int16 *)v20 + 6))
            {
              if (v27 <= 0xFFFE) {
                unint64_t v29 = v27;
              }
              else {
                unint64_t v29 = 0LL;
              }
              uint64_t v28 = (__int16 *)v20 + v29 + 8;
            }

            else
            {
              uint64_t v28 = (__int16 *)v20 + 7;
            }
          }

          else
          {
            uint64_t v28 = (__int16 *)v20 + 5;
          }

          int v23 = *v28;
        }

        if ((v23 & 0x80000000) == 0) {
          break;
        }
        int v20 = v19[-v23];
        uint64_t v24 = *v20;
      }

      uint64_t result = (v23 + HIDWORD(v24));
      if ((_DWORD)result != 0x200000) {
        return result;
      }
LABEL_46:
      [a1 length];
      _NSCoreDataLog( 1LL,  (uint64_t)@"NSKnownKeysDictionary: dumping bad mapping: %@ with length:\x05",  v32,  v33,  v34,  v35,  v36,  v37,  (uint64_t)a1);
      [a1 keys];
      if (a1[3])
      {
        unint64_t v44 = 0LL;
        do
          _NSCoreDataLog(1LL, (uint64_t)@" \t key[%d] = %@", v38, v39, v40, v41, v42, v43, v44++);
        while (a1[3] > v44);
      }

      uint64_t v45 = [NSString stringWithUTF8String:"NSKnownKeysDictionary: improper mapping detected with key '%@'"];
      _NSCoreDataLog(17LL, v45, v46, v47, v48, v49, v50, v51, (uint64_t)theString);
      uint64_t v52 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        __int16 v54 = theString;
        _os_log_fault_impl( &dword_186681000,  v52,  OS_LOG_TYPE_FAULT,  "CoreData: NSKnownKeysDictionary: improper mapping detected with key '%@'",  buf,  0xCu);
      }
    }

    return 0x7FFFFFFFFFFFFFFFLL;
  }

  unint64_t v7 = CStringPtr;
  unint64_t v8 = -[__CFString length](theString, "length");
  *a3 = v8;
  unint64_t v9 = (uint64_t **)a1[2];
  int v10 = *v9;
  if (!*v9) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  uint64_t v11 = *v10;
  while (1)
  {
    unint64_t v12 = v8;
    if ((v11 & 0x1FF8) != 0) {
      unint64_t v12 = v7[v11 >> 13];
    }
    unint64_t v13 = *((unsigned __int16 *)v10 + 4);
    BOOL v18 = v12 >= v13;
    unint64_t v14 = v12 - v13;
    if (v18)
    {
      if (v12 <= *((unsigned __int16 *)v10 + 6))
      {
        unint64_t v16 = v14 <= 0xFFFE ? v14 : 0LL;
        uint64_t v15 = (__int16 *)v10 + v16 + 8;
      }

      else
      {
        uint64_t v15 = (__int16 *)v10 + 7;
      }
    }

    else
    {
      uint64_t v15 = (__int16 *)v10 + 5;
    }

    int v17 = *v15;
    if ((v17 & 0x80000000) == 0) {
      break;
    }
    int v10 = v9[-v17];
    uint64_t v11 = *v10;
    BOOL v18 = (*v10 & 0x1FF8) != 0 && *v10 >> 13 >= v8;
    if (v18) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }

  return (v17 + HIDWORD(v11));
}

LABEL_85:
        unint64_t v13 = self;
        unint64_t v14 = v12;
        type = v23;
        goto LABEL_86;
      }

      if (v49 == 1)
      {
        uint64_t v50 = [v34 sqlType];
        if ((_DWORD)v50 == 15)
        {
          unint64_t v12 =  +[_PFRoutines retainedEncodeObjectValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)v12,  (void *)[v34 propertyDescription]);
          int v23 = 10LL;
          goto LABEL_77;
        }

        goto LABEL_64;
      }

      if (v49 == 5)
      {
        uint64_t v50 = 1LL;
        goto LABEL_64;
      }
    }

    uint64_t v50 = 0LL;
    goto LABEL_64;
  }

  unint64_t v13 = self;
  unint64_t v14 = self->_constantValue;
LABEL_86:
  unint64_t v22 = -[NSSQLConstantValueIntermediate _addBindVarForConstId:ofType:inContext:](v13, v14, type, a3);
LABEL_87:
  __int16 v58 = objc_msgSend((id)objc_msgSend(a3, "objectForKey:", @"generatePairs"), "BOOLValue");
  unint64_t v59 = @"(?, ?)";
  if (!v22) {
    unint64_t v59 = 0LL;
  }
  uint64_t v60 = @"?";
  if (!v22) {
    uint64_t v60 = 0LL;
  }
  if (v58) {
    int v10 = (__CFString *)v59;
  }
  else {
    int v10 = (__CFString *)v60;
  }
LABEL_94:
  uint64_t v61 = (void *)-[__CFString mutableCopy](v10, "mutableCopy");
  objc_autoreleasePoolPop(v5);
  return v61;
}

_PFArray *_executeFetchRequest(uint64_t a1)
{
  int v1 = (void *)a1;
  v12[1] = *MEMORY[0x1895F89C0];
  int v2 = _newFetchedRowsForRequest(a1);
  if (v2 && [v1 shouldUseBatches])
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      uint64_t v3 = -[_PFArray count](v2, "count");
      unint64_t v4 = v3;
      MEMORY[0x1895F8858](v3);
      unint64_t v7 = (char *)v12 - v6;
      else {
        bzero((char *)v12 - v6, 8 * v5);
      }
      -[_PFArray getObjects:range:](v2, "getObjects:range:", v7, 0LL, v3);
      unint64_t v8 = -[_PFArray initWithObjects:count:andFlags:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:",  v7,  v3,  27LL);
      if (v4 >= 0x201) {
        NSZoneFree(0LL, v7);
      }

      int v2 = v8;
    }

    if (v1)
    {
      uint64_t v9 = v1[4];
      int v1 = (void *)v1[24];
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    int v10 = -[_PFBatchFaultingArray initWithPFArray:andRequest:andContext:]( objc_alloc(&OBJC_CLASS____PFBatchFaultingArray),  "initWithPFArray:andRequest:andContext:",  v2,  v1,  v9);

    int v2 = (_PFArray *)v10;
  }

  return v2;
}

_PFArray *_newFetchedRowsForRequest(uint64_t a1)
{
  v191[1] = *MEMORY[0x1895F89C0];
  if (!a1 || !*(void *)(a1 + 120)) {
    return (_PFArray *)(id)NSArray_EmptyArray;
  }
  uint64_t v2 = *(void *)(a1 + 136);
  uint64_t v3 = [(id)a1 request];
  uint64_t v172 = a1;
  uint64_t v4 = [(id)a1 fetchStatement];
  if (!v4 || *(_BYTE *)(v4 + 40))
  {
    if ((int)-[NSSQLStoreRequestContext debugLogLevel](a1) >= 1)
    {
      if ((int)-[NSSQLStoreRequestContext debugLogLevel](a1) >= 2) {
        _NSCoreDataLog( 4LL,  (uint64_t)@"logically false fetch request %@ short circuits.",  v5,  v6,  v7,  v8,  v9,  v10,  v3);
      }
      if (*(_BYTE *)(a1 + 80)) {
        uint64_t v11 = @"total fetch execution time: \x1B[31m%.4f\x1B[0ms for %d rows.";
      }
      else {
        uint64_t v11 = @"total fetch execution time: %.4fs for %d rows.";
      }
      _NSCoreDataLog(4LL, (uint64_t)v11, v5, v6, v7, v8, v9, v10, 0LL);
    }

    return (_PFArray *)(id)NSArray_EmptyArray;
  }

  if (*(_BYTE *)(a1 + 81))
  {
    if ((*(_DWORD *)(v2 + 72) & 1) == 0 && (*(_DWORD *)(v2 + 72) & 0x18) != 16) {
      return newFetchedRowsForFetchPlan_MT((void *)a1);
    }
  }

  uint64_t v14 = *(void *)(a1 + 136);
  uint64_t v15 = (void *)[(id)a1 fetchStatement];
  v168 = *(void **)(a1 + 24);
  uint64_t v174 = v14;
  if ((*(_DWORD *)(v14 + 72) & 2) != 0) {
    unsigned int v16 = 4096;
  }
  else {
    unsigned int v16 = 512;
  }
  else {
    double Current = CFAbsoluteTimeGetCurrent();
  }
  uint64_t v18 = v14;
  if (*(_DWORD *)(v14 + 16)) {
    int v19 = *(_DWORD *)(v14 + 16);
  }
  else {
    int v19 = -1;
  }
  uint64_t v20 = +[NSSQLCore bufferedAllocationsOverride](&OBJC_CLASS___NSSQLCore, "bufferedAllocationsOverride");
  if (v20 < 1
    || (*(_DWORD *)(v174 + 72) & 0x1C) != 0x10
    || (v21 = *(void *)(v174 + 40)) != 0 && (uint64_t v18 = v174, *(_DWORD *)(v21 + 184) >> 3 >= 0x84Du))
  {
    BOOL v22 = [*(id *)(v18 + 8) allocationType] == 1 && (*(_DWORD *)(v18 + 72) & 0x1C) == 16;
  }

  else
  {
    BOOL v22 = 1;
  }

  objc_opt_self();
  if (v20 == 2 && (*(_DWORD *)(v174 + 72) & 0x1C) == 0x10)
  {
    uint64_t v23 = *(void *)(v174 + 40);
    if (v23)
    {
      int v176 = 1;
      if (_CoreData_debugVMBufferAllocations || *(_DWORD *)(v23 + 184) >> 3 < 0x84Du) {
        goto LABEL_46;
      }
      goto LABEL_44;
    }
  }

  else if (!_CoreData_debugVMBufferAllocations)
  {
LABEL_44:
    BOOL v24 = [*(id *)(v174 + 8) allocationType] == 2;
    goto LABEL_45;
  }

  BOOL v24 = 1;
LABEL_45:
  int v176 = v24;
LABEL_46:
  objc_opt_self();
  BOOL v31 = v20 != 3 && _CoreData_debugOneBufferAllocations == 0;
  int v32 = v31;
  if (!v31 && v176) {
    _NSCoreDataLog( 1LL,  (uint64_t)@"VM Memory is already One Buffer Row that grows!!!",  v25,  v26,  v27,  v28,  v29,  v30,  v153);
  }
  objc_opt_self();
  BOOL v39 = v20 != 4 && _CoreData_debuguseManyResultSetsAllocations == 0;
  int v40 = !v39;
  int v41 = v176;
  if (v39) {
    int v41 = 0;
  }
  if (v41 == 1) {
    _NSCoreDataLog( 1LL,  (uint64_t)@"VM Memory does not support multiple result sets!!!",  v33,  v34,  v35,  v36,  v37,  v38,  v153);
  }
  if ((*(_DWORD *)(v174 + 72) & 2) == 0 && (*(_DWORD *)(v174 + 72) & 0x18) != 0x10) {
    [*(id *)(v174 + 8) _disablePersistentStoreResultCaching];
  }
  int v159 = *(unsigned __int8 *)(v172 + 202);
  v173 = (void *)[*(id *)(v174 + 8) _asyncResultHandle];
  uint64_t v42 = (void *)[v173 progress];
  uint64_t v43 = v42;
  if (v42)
  {
    int v44 = [v42 totalUnitCount];
    int v167 = v44 & ~(v44 >> 31);
  }

  else
  {
    int v167 = 0;
  }

  int v170 = v176 | v22;
  v156 = v15;
  id v162 = objc_alloc_init(MEMORY[0x1896077E8]);
  id v166 = objc_alloc_init(MEMORY[0x189603FA8]);
  if ((*(_DWORD *)(v174 + 72) & 0x1C) == 0xC) {
    id v165 = objc_alloc_init(MEMORY[0x189603FA8]);
  }
  else {
    id v165 = 0LL;
  }
  -[NSSQLiteConnection selectRowsWithStatement:cached:](v168, v15, v159 != 0);
  double v45 = CFAbsoluteTimeGetCurrent();
  int v163 = v32;
  v169 = v43;
  unsigned int v46 = 0;
  uint64_t v47 = 0LL;
  int v171 = 0;
  else {
    double v48 = v45 - Current;
  }
  int v49 = v40 | v170 ^ 1;
LABEL_78:
  v175 = 0LL;
  unsigned int v50 = v19;
  do
  {
    if (v170)
    {
      Initialize = (double *)v175;
      if (!v175)
      {
        uint64_t v52 = *(void **)(v174 + 8);
        if (v176) {
          Initialize = (double *)bufferResultSetAllocateWithVMMemory( [v52 allocationSize],  objc_msgSend(*(id *)(v174 + 8), "purgeableResult"));
        }
        else {
          Initialize = (double *)bufferResultSetAllocateInitialize([v52 allocationSize], v174);
        }
        Initialize[1] = v45;
      }
    }

    else
    {
      Initialize = (double *)fetchResultSetAllocateInitialize(v46, (*(_DWORD *)(v174 + 72) >> 5) & 1);
      Initialize[1] = v45;
      *(_DWORD *)Initialize = v171;
    }

    v175 = (unsigned int *)Initialize;
    if (v50 >= v16) {
      unsigned int v53 = v16;
    }
    else {
      unsigned int v53 = v50;
    }
    if (v50 >= v16) {
      int v19 = v50 - v16;
    }
    else {
      int v19 = 0;
    }
    *(_DWORD *)(v174 + 16) = v53;
    else {
      double v54 = CFAbsoluteTimeGetCurrent();
    }
    if (v173 && [v173 _isCancelled])
    {
      v171 += v47;
      if (v170) {
        uint64_t v55 = 10LL;
      }
      else {
        uint64_t v55 = 12LL;
      }
      int v56 = (v175[v55] & 1) == 0;
LABEL_108:
      v56 &= ~[v173 _isCancelled];
      goto LABEL_109;
    }

    if (v170) {
      int v57 = -[NSSQLiteConnection fetchBufferResultSet:usingFetchPlan:]((uint64_t)v168, (uint64_t)v175, v174);
    }
    else {
      int v57 = -[NSSQLiteConnection fetchResultSet:usingFetchPlan:]((uint64_t)v168, (uint64_t)v175, v174);
    }
    uint64_t v47 = v57;
    v171 += v57;
    if (v170) {
      uint64_t v58 = 10LL;
    }
    else {
      uint64_t v58 = 12LL;
    }
    int v56 = (v175[v58] & 1) == 0;
    if (v173) {
      goto LABEL_108;
    }
LABEL_109:
    if (v169 && ([v169 isCancelled] & 1) == 0)
    {
      int v59 = v167;
      int v60 = 2 * v167;
      if (v171 >= 2 * v167) {
        int v60 = v171 + 1;
      }
      uint64_t v61 = *(void **)(v174 + 48);
      v186[0] = MEMORY[0x1895F87A8];
      v186[1] = 3221225472LL;
      v186[2] = ___newFetchedRowsForFetchPlan_ST_block_invoke;
      if (v167 > 0 && v171 >= v167) {
        int v59 = v60;
      }
      BOOL v189 = v167 > 0 && v171 >= v167;
      v186[3] = &unk_189EAA5D8;
      v186[4] = v169;
      int v167 = v59;
      int v187 = v59;
      int v188 = v171;
      [v61 performBlock:v186];
    }

    if (v49)
    {
      if (v47)
      {
        v190[0] = 0LL;
        if (v170)
        {
          uint64_t v63 = _prepareLargeDictionaryResults(v175, v172, 1);
        }

        else if ((*(_DWORD *)(v174 + 72) & 0x18) == 0x10)
        {
          uint64_t v63 = _prepareDictionaryResults((uint64_t)v175, v172);
        }

        else
        {
          uint64_t v63 = (uint64_t)_prepareResultsFromResultSet_0((uint64_t)v175, (uint64_t *)v190, (void *)v172);
        }

        uint64_t v64 = (void *)v63;
        [v166 addObject:v63];
        if (v190[0]) {
          objc_msgSend(v165, "addObject:");
        }

        if ((v170 & 1) == 0)
        {
LABEL_135:
          unsigned int v65 = v175[4];
          unsigned int v66 = v175[5];
          fetchResultSetDeallocate((uint64_t)v175);
          unsigned int v46 = v66 * v65;
        }
      }

      else if ((v170 & 1) == 0)
      {
        goto LABEL_135;
      }

      if (v50 > v16) {
        char v67 = v56;
      }
      else {
        char v67 = 0;
      }
      if ((v67 & 1) == 0)
      {
        v175 = 0LL;
        uint64_t v68 = v169;
        goto LABEL_144;
      }

      goto LABEL_78;
    }

    if (v50 > v16) {
      char v62 = v56;
    }
    else {
      char v62 = 0;
    }
    unsigned int v50 = v19;
  }

  while ((v62 & 1) != 0);
  uint64_t v69 = _prepareLargeDictionaryResults(v175, v172, 1);
  uint64_t v68 = v169;
  uint64_t v70 = (void *)v69;
  if (((v163 | v176) & 1) == 0)
  {
    v191[0] = v69;
    uint64_t v71 = _prepareBufferedDictionaryResult( (void *)[MEMORY[0x189603F18] arrayWithObjects:v191 count:1],  v172);

    uint64_t v70 = (void *)v71;
  }

  [v166 addObject:v70];

LABEL_144:
  -[NSSQLiteConnection endFetchAndRecycleStatement:]((uint64_t)v168, v159 != 0);
  if ((int)-[NSSQLStoreRequestContext debugLogLevel](v172) >= 1)
  {
    if (*(_BYTE *)(v172 + 80)) {
      uint64_t v78 = @"sql connection fetch time: \x1B[31m%.4f\x1B[0ms";
    }
    else {
      uint64_t v78 = @"sql connection fetch time: %.4fs";
    }
    _NSCoreDataLog(4LL, (uint64_t)v78, v72, v73, v74, v75, v76, v77, *(uint64_t *)&v48);
  }

  uint64_t v79 = [v166 count];
  uint64_t v80 = *(void *)(v174 + 48);
  uint64_t v81 = *(void *)(v172 + 128);
  if (v173 && ([v173 _isCancelled] & 1) != 0)
  {
    int v171 = 0;
    goto LABEL_154;
  }

  if (v79 == 1)
  {
    v105 = (_PFArray *)(id)[v166 objectAtIndex:0];
    if (v165)
    {
      v106 = (void *)[v165 objectAtIndex:0];
      v177 = malloc(-[_PFArray count](v105, "count"));
      __int128 v182 = 0u;
      __int128 v183 = 0u;
      __int128 v184 = 0u;
      __int128 v185 = 0u;
      uint64_t v107 = -[_PFArray countByEnumeratingWithState:objects:count:]( v105,  "countByEnumeratingWithState:objects:count:",  &v182,  v190,  16LL);
      if (v107)
      {
        uint64_t v108 = 0LL;
        int v109 = 0;
        uint64_t v110 = *(void *)v183;
        do
        {
          for (uint64_t i = 0LL; i != v107; ++i)
          {
            if (*(void *)v183 != v110) {
              objc_enumerationMutation(v105);
            }
            uint64_t v112 = *(void *)(*((void *)&v182 + 1) + 8 * i);
            v177[(v109 + i)] = (*(_DWORD *)(v112 + 16) & 0x18000) == 0x8000;
            _PFFaultHandlerFulfillFault(v81, v112, v80, (void *)[v106 objectAtIndex:v108 + i], 0);
          }

          uint64_t v107 = -[_PFArray countByEnumeratingWithState:objects:count:]( v105,  "countByEnumeratingWithState:objects:count:",  &v182,  v190,  16LL);
          v108 += i;
          v109 += i;
        }

        while (v107);
      }

      uint64_t v83 = v105;
      uint64_t v68 = v169;
    }

    else
    {
      v177 = 0LL;
      uint64_t v83 = v105;
    }
  }

  else
  {
    if (v79)
    {
      if ((v170 & 1) != 0)
      {
        v177 = 0LL;
        uint64_t v82 = (_PFArray *)_prepareBufferedDictionaryResult(v166, v172);
      }

      else
      {
        size_t v138 = 0LL;
        for (uint64_t j = 0LL; j != v79; ++j)
          v138 += objc_msgSend((id)objc_msgSend(v166, "objectAtIndex:", j), "count");
        v177 = malloc(v138);
        v155 = (char *)PF_ALLOCATE_OBJECT_ARRAY(v138);
        uint64_t v140 = [v166 objectAtIndex:0];
        unint64_t v141 = 0x18C68F000uLL;
        if (v140) {
          unsigned int v154 = *(_BYTE *)(v140 + 32) & 0x3B;
        }
        else {
          unsigned int v154 = 0;
        }
        int v142 = 0;
        uint64_t v143 = 0LL;
        v144 = v155;
        size_t v157 = v138;
        uint64_t v158 = v79;
        do
        {
          v145 = (void *)[v166 objectAtIndex:v143];
          [v145 getObjects:v144];
          uint64_t v164 = [v145 count];
          if (v145)
          {
            *((_BYTE *)v145 + *(int *)(v141 + 1708)) &= ~2u;
            *((_BYTE *)v145 + *(int *)(v141 + 1708)) &= ~4u;
          }

          if (v165)
          {
            v160 = v144;
            uint64_t v161 = v143;
            v146 = (void *)[v165 objectAtIndex:v143];
            __int128 v184 = 0u;
            __int128 v185 = 0u;
            __int128 v182 = 0u;
            __int128 v183 = 0u;
            uint64_t v147 = [v145 countByEnumeratingWithState:&v182 objects:v190 count:16];
            if (v147)
            {
              uint64_t v148 = 0LL;
              uint64_t v149 = *(void *)v183;
              do
              {
                uint64_t v150 = 0LL;
                int v151 = v142;
                do
                {
                  if (*(void *)v183 != v149) {
                    objc_enumerationMutation(v145);
                  }
                  uint64_t v152 = *(void *)(*((void *)&v182 + 1) + 8 * v150);
                  v177[(v151 + v150)] = (*(_DWORD *)(v152 + 16) & 0x18000) == 0x8000;
                  _PFFaultHandlerFulfillFault( v81,  v152,  v80,  (void *)[v146 objectAtIndex:v148 + v150++],  0);
                }

                while (v147 != v150);
                uint64_t v147 = [v145 countByEnumeratingWithState:&v182 objects:v190 count:16];
                v148 += v150;
                int v142 = v151 + v150;
              }

              while (v147);
              int v142 = v151 + v150;
              uint64_t v68 = v169;
              size_t v138 = v157;
              uint64_t v79 = v158;
              unint64_t v141 = 0x18C68F000LL;
            }

            else
            {
              uint64_t v68 = v169;
              size_t v138 = v157;
              uint64_t v79 = v158;
            }

            v144 = v160;
            uint64_t v143 = v161;
          }

          v144 += 8 * v164;
          ++v143;
        }

        while (v143 != v79);
        uint64_t v82 = -[_PFArray initWithObjects:count:andFlags:andContext:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:andContext:",  v155,  v138,  v154,  v80);
      }
    }

    else
    {
LABEL_154:
      v177 = 0LL;
      uint64_t v82 = (_PFArray *)(id)NSArray_EmptyArray;
    }

    uint64_t v83 = v82;
  }

  uint64_t v90 = -[_PFArray count](v83, "count");
  if (v68 && ([v68 isCancelled] & 1) == 0)
  {
    uint64_t v91 = *(void **)(v174 + 48);
    int v92 = 2 * v167;
    v178[0] = MEMORY[0x1895F87A8];
    v178[1] = 3221225472LL;
    if (v171 >= 2 * v167) {
      int v92 = v171 + 1;
    }
    v178[2] = ___newFetchedRowsForFetchPlan_ST_block_invoke_2;
    v178[3] = &unk_189EAA5D8;
    v178[4] = v68;
    if (v167 > 0 && v171 >= v167) {
      int v93 = v92;
    }
    else {
      int v93 = v167;
    }
    int v179 = v93;
    int v180 = v171;
    [v91 performBlock:v178];
  }

  if (v90 != v171) {
    _NSCoreDataLog( 1LL,  (uint64_t)@"result array has %lu entries, but we fetched %d rows",  v84,  v85,  v86,  v87,  v88,  v89,  v90);
  }
  if ((int)-[NSSQLStoreRequestContext debugLogLevel](v172) >= 2)
  {
    id v94 = objc_alloc_init(MEMORY[0x189607940]);
    [v94 appendFormat:@"fetch using %@ returned %lu rows", v156, v90];
    _NSCoreDataLog(4LL, (uint64_t)@"%@", v95, v96, v97, v98, v99, v100, (uint64_t)v94);
  }

  uint64_t v101 = [*(id *)(v174 + 8) relationshipKeyPathsForPrefetching];
  unsigned int v102 = *(_DWORD *)(v174 + 72);
  if (v90)
  {
    if (v101)
    {
      unsigned int v103 = (v102 >> 2) & 7;
      if (v103 <= 5 && ((1 << v103) & 0x29) != 0)
      {
        if ((*(_DWORD *)(v174 + 72) & 0x1C) == 4)
        {
          v104 = 0LL;
          goto LABEL_188;
        }

        v113 = (void *)+[_PFRoutines newArrayOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v83);
        v104 = v113;
        if ((*(_DWORD *)(v174 + 72) & 0x1C) == 4) {
LABEL_188:
        }
          v113 = v83;
        _prefetchForFetchRequest(v113, 0LL, (void *)v172);

        unsigned int v102 = *(_DWORD *)(v174 + 72);
      }
    }
  }

  if (v177 && (v102 & 0x1C) == 0xC)
  {
    v114 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FA8]), "initWithCapacity:", -[_PFArray count](v83, "count"));
    unint64_t v115 = 0LL;
    uint64_t v116 = MEMORY[0x189604A88];
    uint64_t v117 = MEMORY[0x189604A80];
    while (v115 < -[_PFArray count](v83, "count"))
    {
      if (v177[v115]) {
        uint64_t v118 = v116;
      }
      else {
        uint64_t v118 = v117;
      }
      [v114 addObject:v118];
      ++v115;
    }

    -[NSSQLFetchRequestContext addFaultsThatWereFired:]((void *)v172, v114);
  }

  [v162 drain];

  if (v173) {
    char v119 = [v173 _isCancelled];
  }
  else {
    char v119 = 0;
  }
  [*(id *)(v174 + 8) _setAsyncResultHandle:0];
  [0 drain];
  char v120 = v170;
  if (!v175) {
    char v120 = 1;
  }
  if ((v120 & 1) == 0) {
    fetchResultSetDeallocate((uint64_t)v175);
  }
  if (v177) {
    free(v177);
  }
  if ((int)-[NSSQLStoreRequestContext debugLogLevel](v172) >= 1)
  {
    if (v173) {
      char v121 = v119;
    }
    else {
      char v121 = 0;
    }
    if ((v121 & 1) != 0)
    {
      if (*(_BYTE *)(v172 + 80))
      {
        double v128 = CFAbsoluteTimeGetCurrent();
        v129 = @"Fetch cancelled.  Total fetch execution time: \x1B[31m%.4f\x1B[0ms.";
      }

      else
      {
        double v128 = CFAbsoluteTimeGetCurrent();
        v129 = @"Fetch cancelled.  Total fetch execution time: %.4fs.";
      }

      _NSCoreDataLog(4LL, (uint64_t)v129, v122, v123, v124, v125, v126, v127, COERCE__INT64(v128 - Current));
    }

    else
    {
      if (*(_BYTE *)(v172 + 80))
      {
        double v130 = CFAbsoluteTimeGetCurrent();
        -[_PFArray count](v83, "count");
        v137 = @"total fetch execution time: \x1B[31m%.4f\x1B[0ms for %d rows.";
      }

      else
      {
        double v130 = CFAbsoluteTimeGetCurrent();
        -[_PFArray count](v83, "count");
        v137 = @"total fetch execution time: %.4fs for %d rows.";
      }

      _NSCoreDataLog(4LL, (uint64_t)v137, v131, v132, v133, v134, v135, v136, COERCE__INT64(v130 - Current));
    }
  }

  return v83;
}

void sub_186697E40(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186697E04LL);
  }

  JUMPOUT(0x186697D7CLL);
}

_PFArray *newFetchedRowsForFetchPlan_MT(void *a1)
{
  uint64_t v191 = *MEMORY[0x1895F89C0];
  if (a1) {
    uint64_t v2 = a1[17];
  }
  else {
    uint64_t v2 = 0LL;
  }
  uint64_t v149 = (void *)[a1 fetchStatement];
  uint64_t v174 = (uint64_t)a1;
  int v3 = -[NSSQLStoreRequestContext debugLogLevel]((uint64_t)a1);
  int v4 = *(_DWORD *)(v2 + 72);
  if ((v4 & 2) != 0) {
    unsigned int v5 = 4096;
  }
  else {
    unsigned int v5 = 512;
  }
  int v176 = v3;
  if (v3 < 1)
  {
    double Current = 0.0;
    uint64_t v7 = v2;
    LOBYTE(v2) = *(_DWORD *)(v2 + 72);
  }

  else
  {
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v7 = v2;
    LODWORD(v2) = *(_DWORD *)(v2 + 72);
  }

  if (*(_DWORD *)(v7 + 16)) {
    unsigned int v8 = *(_DWORD *)(v7 + 16);
  }
  else {
    unsigned int v8 = -1;
  }
  uint64_t v147 = [*(id *)(v7 + 8) relationshipKeyPathsForPrefetching];
  uint64_t v177 = v7;
  BOOL v10 = (v4 & 2) == 0 && (*(_DWORD *)(v7 + 72) & 0x1C) == 12;
  BOOL v154 = v10;
  if (v174) {
    BOOL v151 = *(_BYTE *)(v174 + 202) != 0;
  }
  else {
    BOOL v151 = 0;
  }
  unsigned __int8 v189 = 1;
  v178 = (void *)[*(id *)(v7 + 8) _asyncResultHandle];
  uint64_t v11 = (void *)[v178 progress];
  ptr = v11;
  if (v11)
  {
    int v12 = [v11 totalUnitCount];
    int v164 = v12 & ~(v12 >> 31);
  }

  else
  {
    int v164 = 0;
  }

  id v13 = objc_alloc_init(MEMORY[0x1896077E8]);
  id v170 = objc_alloc_init(MEMORY[0x189603FA8]);
  CFRetain(v170);

  if (v154)
  {
    id v14 = objc_alloc_init(MEMORY[0x189603FA8]);
    CFRetain(v14);
    id v15 = v14;
  }

  else
  {
    id v15 = 0LL;
  }

  if (v174) {
    unsigned int v16 = *(void **)(v174 + 24);
  }
  else {
    unsigned int v16 = 0LL;
  }
  -[NSSQLiteConnection selectRowsWithStatement:cached:](v16, v149, v151);
  double v17 = CFAbsoluteTimeGetCurrent();
  cf = v15;
  uint64_t v150 = v13;
  uint64_t v161 = (uint64_t)v16;
  CFMutableArrayRef v162 = 0LL;
  uint64_t v18 = 0LL;
  unsigned int v19 = 0;
  theArray = 0LL;
  char v156 = 0;
  uint64_t v20 = 0LL;
  int v179 = 0;
  int v166 = v2 & 3;
  if (v176 <= 0) {
    double v21 = 0.0;
  }
  else {
    double v21 = v17 - Current;
  }
  allocator = (const __CFAllocator *)*MEMORY[0x189604DB0];
  do
  {
    Initialize = (double *)fetchResultSetAllocateInitialize(v19, (*(_DWORD *)(v177 + 72) >> 5) & 1);
    Initialize[1] = v17;
    *(_DWORD *)Initialize = v179;
    if (v8 >= v5) {
      unsigned int v23 = v5;
    }
    else {
      unsigned int v23 = v8;
    }
    if (v8 >= v5) {
      unsigned int v24 = v8 - v5;
    }
    else {
      unsigned int v24 = 0;
    }
    *(_DWORD *)(v177 + 16) = v23;
    if (v176 <= 0) {
      double v25 = 0.0;
    }
    else {
      double v25 = CFAbsoluteTimeGetCurrent();
    }
    if (v178 && [v178 _isCancelled])
    {
      v179 += v20;
      int v26 = ((_BYTE)Initialize[6] & 1) == 0;
LABEL_45:
      v26 &= ~[v178 _isCancelled];
      goto LABEL_46;
    }

    int v27 = -[NSSQLiteConnection fetchResultSet:usingFetchPlan:](v161, (uint64_t)Initialize, v177);
    uint64_t v20 = v27;
    v179 += v27;
    int v26 = ((_BYTE)Initialize[6] & 1) == 0;
    if (v178) {
      goto LABEL_45;
    }
LABEL_46:
    if (ptr && ([ptr isCancelled] & 1) == 0)
    {
      int v28 = v164;
      int v29 = 2 * v164;
      if (v179 >= 2 * v164) {
        int v29 = v179 + 1;
      }
      BOOL v30 = v164 > 0 && v179 >= v164;
      if (v30) {
        int v28 = v29;
      }
      int v164 = v28;
      if (v174) {
        BOOL v31 = *(void **)(v174 + 32);
      }
      else {
        BOOL v31 = 0LL;
      }
      v185[0] = MEMORY[0x1895F87A8];
      v185[1] = 3221225472LL;
      v185[2] = __newFetchedRowsForFetchPlan_MT_block_invoke;
      v185[3] = &unk_189EAA5D8;
      BOOL v188 = v30;
      v185[4] = ptr;
      int v186 = v28;
      int v187 = v179;
      [v31 performBlock:v185];
    }

    if (v18) {
      int v32 = 0;
    }
    else {
      int v32 = v26;
    }
    if (v32 == 1)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, 0LL, 0LL);
      if (v166 != 2) {
        CFMutableArrayRef v162 = CFArrayCreateMutable(allocator, 0LL, MEMORY[0x189605228]);
      }
      uint64_t v34 = PF_CALLOC_SCANNED_BYTES(0x28uLL);
      void *v34 = v174;
      v34[1] = Mutable;
      v34[2] = v170;
      v34[3] = &v189;
      v34[4] = v162;
      uint64_t v35 = objc_alloc(&OBJC_CLASS____PFTask);
      if (v166 == 2) {
        uint64_t v36 = _prepareObjectIDsOnBackgroundThread;
      }
      else {
        uint64_t v36 = _prepareRowsOnBackgroundThreads;
      }
      uint64_t v18 = -[_PFTask initWithFunction:withArgument:andPriority:]( v35,  "initWithFunction:withArgument:andPriority:",  v36,  v34,  2LL);
      if (cf) {
        CFRelease(cf);
      }
      cf = 0LL;
      char v156 = 1;
      theArray = Mutable;
    }

    if (v176 >= 1) {
      double v21 = v21 + CFAbsoluteTimeGetCurrent() - v25;
    }
    if (v20)
    {
      if (v18)
      {
        pthread_mutex_lock((pthread_mutex_t *)(v18 + 32));
        CFArrayAppendValue(theArray, Initialize);
        pthread_mutex_unlock((pthread_mutex_t *)(v18 + 32));
        pthread_cond_signal((pthread_cond_t *)(v18 + 96));
        goto LABEL_78;
      }

      *(void *)buf = 0LL;
      BOOL v39 = (void *)_prepareResultsFromResultSet((uint64_t)Initialize, buf, v174);
      [v170 addObject:v39];
      if (*(void *)buf)
      {
        objc_msgSend(cf, "addObject:");
        int v40 = *(void **)buf;
      }

      else
      {
        int v40 = 0LL;
      }

      int v37 = *((_DWORD *)Initialize + 4);
      int v38 = *((_DWORD *)Initialize + 5);
      fetchResultSetDeallocate((uint64_t)Initialize);
    }

    else
    {
      int v37 = *((_DWORD *)Initialize + 4);
      int v38 = *((_DWORD *)Initialize + 5);
      fetchResultSetDeallocate((uint64_t)Initialize);
    }

    unsigned int v19 = v38 * v37;
LABEL_78:
    if (v8 > v5) {
      char v41 = v26;
    }
    else {
      char v41 = 0;
    }
    unsigned int v8 = v24;
  }

  while ((v41 & 1) != 0);
  -[NSSQLiteConnection endFetchAndRecycleStatement:](v161, v151);
  if (v176 >= 1)
  {
    double v48 = @"sql connection fetch time: %.4fs";
    if (v174 && *(_BYTE *)(v174 + 80)) {
      double v48 = @"sql connection fetch time: \x1B[31m%.4f\x1B[0ms";
    }
    _NSCoreDataLog(4LL, (uint64_t)v48, v42, v43, v44, v45, v46, v47, *(uint64_t *)&v21);
  }

  if (v18)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v18 + 32));
    atomic_store(0, &v189);
    if (!*(_DWORD *)(v18 + 144)) {
      pthread_cond_signal((pthread_cond_t *)(v18 + 96));
    }
    while (!*(_DWORD *)(v18 + 144))
      pthread_cond_wait((pthread_cond_t *)(v18 + 96), (pthread_mutex_t *)(v18 + 32));
    pthread_mutex_unlock((pthread_mutex_t *)(v18 + 32));
  }

  uint64_t v49 = [v170 count];
  char v50 = v154;
  if (!v162) {
    char v50 = 1;
  }
  if ((v50 & 1) != 0)
  {
    uint64_t v51 = v162;
  }

  else
  {
    CFRelease(v162);
    uint64_t v51 = 0LL;
  }

  int v163 = v51;
  if (v178 && ([v178 _isCancelled] & 1) != 0)
  {
    int v179 = 0;
LABEL_109:
    CFAllocatorRef allocatora = 0LL;
    double v54 = v170;
    int v167 = (_PFArray *)(id)NSArray_EmptyArray;
    goto LABEL_147;
  }

  if (!v49) {
    goto LABEL_109;
  }
  if (v49 == 1)
  {
    uint64_t v52 = (_PFArray *)(id)[v170 objectAtIndex:0];
    if (v154)
    {
      if (cf)
      {
        ValueAtIndex = (const __CFAllocator *)[cf objectAtIndex:0];
        if (!ValueAtIndex) {
          goto LABEL_145;
        }
      }

      else
      {
        if (!v163) {
          goto LABEL_145;
        }
        ValueAtIndex = (const __CFAllocator *)CFArrayGetValueAtIndex(v163, 0LL);
        if (!ValueAtIndex) {
          goto LABEL_145;
        }
      }

      int v167 = v52;
      CFAllocatorRef allocatora = ValueAtIndex;
      double v54 = v170;
      CFRetain(ValueAtIndex);
      goto LABEL_147;
    }

LABEL_145:
    CFAllocatorRef allocatora = 0LL;
    int v167 = v52;
    goto LABEL_146;
  }

  uint64_t v55 = 0LL;
  for (uint64_t i = 0LL; i != v49; ++i)
    v55 += objc_msgSend((id)objc_msgSend(v170, "objectAtIndex:", i), "count");
  int v57 = (const __CFAllocator *)PF_ALLOCATE_OBJECT_ARRAY(v55);
  if (v154) {
    uint64_t v58 = (char *)PF_ALLOCATE_OBJECT_ARRAY(v55);
  }
  else {
    uint64_t v58 = 0LL;
  }
  uint64_t v59 = [v170 objectAtIndex:0];
  if (v59) {
    int v60 = *(_BYTE *)(v59 + 32) & 0x3B;
  }
  else {
    int v60 = 0;
  }
  CFIndex v61 = 0LL;
  unsigned int v62 = v60 & 0xFFFFFFE7;
  unsigned int v152 = v60 & 0xFFFFFFE7 | 8;
  v168 = v58;
  CFAllocatorRef allocatorb = v57;
  while (2)
  {
    uint64_t v63 = (_BYTE *)[v170 objectAtIndex:v61];
    [v63 getObjects:v57];
    uint64_t v64 = [v63 count];
    if (v63)
    {
      v63[32] &= ~2u;
      v63[32] &= ~4u;
    }

    if (v154)
    {
      if (cf)
      {
        unsigned int v65 = (void *)[cf objectAtIndex:v61];
        goto LABEL_125;
      }

      if (v163)
      {
        unsigned int v65 = (void *)CFArrayGetValueAtIndex(v163, v61);
LABEL_125:
        unsigned int v66 = v65;
      }

      else
      {
        unsigned int v66 = 0LL;
      }

      objc_msgSend(v66, "getObjects:range:", v58, 0, objc_msgSend(v66, "count"));
      v58 += 8 * [v66 count];
    }

    int v57 = (const __CFAllocator *)((char *)v57 + 8 * v64);
    if (v49 != ++v61) {
      continue;
    }
    break;
  }

  uint64_t v67 = 0LL;
  unsigned int v68 = (*(_DWORD *)(v177 + 72) >> 2) & 7;
  if (v68 > 5)
  {
    uint64_t v69 = v168;
    CFAllocatorRef v70 = allocatorb;
    uint64_t v71 = v152;
  }

  else
  {
    uint64_t v69 = v168;
    CFAllocatorRef v70 = allocatorb;
    uint64_t v71 = v152;
    if (((1 << v68) & 0x29) != 0)
    {
      if (v174) {
        uint64_t v67 = *(void *)(v174 + 32);
      }
      else {
        uint64_t v67 = 0LL;
      }
      uint64_t v71 = v62 | 0x28;
    }
  }

  int v167 = -[_PFArray initWithObjects:count:andFlags:andContext:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:andContext:",  v70,  v55,  v71,  v67);
  if (v154)
  {
    uint64_t v72 = objc_alloc(&OBJC_CLASS____PFArray);
    uint64_t v73 = v147 ? 11LL : 8LL;
    uint64_t v74 = -[_PFArray initWithObjects:count:andFlags:andContext:]( v72,  "initWithObjects:count:andFlags:andContext:",  v69,  v55,  v73,  0LL);
    CFAllocatorRef allocatora = (CFAllocatorRef)v74;
    if (v74)
    {
      double v54 = v170;
      CFRetain(v74);

      goto LABEL_147;
    }
  }

  CFAllocatorRef allocatora = 0LL;
LABEL_146:
  double v54 = v170;
LABEL_147:
  if (v54) {
    CFRelease(v54);
  }
  uint64_t v153 = -[_PFArray count](v167, "count");
  if (ptr && ([ptr isCancelled] & 1) == 0)
  {
    if (v174) {
      uint64_t v81 = *(void **)(v174 + 32);
    }
    else {
      uint64_t v81 = 0LL;
    }
    int v82 = 2 * v164;
    v181[0] = MEMORY[0x1895F87A8];
    v181[1] = 3221225472LL;
    if (v179 >= 2 * v164) {
      int v82 = v179 + 1;
    }
    v181[2] = __newFetchedRowsForFetchPlan_MT_block_invoke_57;
    v181[3] = &unk_189EAA5D8;
    v181[4] = ptr;
    if (v164 > 0 && v179 >= v164) {
      int v83 = v82;
    }
    else {
      int v83 = v164;
    }
    int v182 = v83;
    int v183 = v179;
    [v81 performBlock:v181];
  }

  if (v153 != v179) {
    _NSCoreDataLog( 1LL,  (uint64_t)@"result array has %lu entries, but we fetched %d rows",  v75,  v76,  v77,  v78,  v79,  v80,  v153);
  }
  if (v153)
  {
    if (v147)
    {
      unsigned int v84 = (*(_DWORD *)(v177 + 72) >> 2) & 7;
      if (v84 <= 5 && ((1 << v84) & 0x29) != 0)
      {
        [v150 drain];
        id v85 = objc_alloc_init(MEMORY[0x1896077E8]);
        if ((*(_DWORD *)(v177 + 72) & 0x1C) == 4)
        {
          uint64_t v86 = 0LL;
          goto LABEL_168;
        }

        uint64_t v87 = (void *)+[_PFRoutines newArrayOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v167);
        uint64_t v86 = v87;
        if ((*(_DWORD *)(v177 + 72) & 0x1C) == 4) {
LABEL_168:
        }
          uint64_t v87 = v167;
        _prefetchForFetchRequest(v87, 0LL, (void *)v174);

        uint64_t v150 = v85;
      }
    }
  }

  BOOL v88 = v154;
  if (!v153) {
    BOOL v88 = 0;
  }
  if (v88)
  {
    if ((v156 & 1) != 0) {
      int active = +[_PFTask getNumActiveProcessors]();
    }
    else {
      int active = 1;
    }
    size_t v90 = -[_PFArray count](v167, "count");
    uint64_t v91 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v91 = malloc_default_zone();
    }
    ptra = (unsigned __int8 *)malloc_zone_calloc(v91, 1uLL, v90);
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();
    if ((isKindOfClass & 1) != 0)
    {
      int v180 = -[_PFArray _objectsPointer](v167, "_objectsPointer");
    }

    else
    {
      int v92 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        int v92 = malloc_default_zone();
      }
      int v180 = (id *)malloc_zone_calloc(v92, 1uLL, 8 * v90);
      -[_PFArray getObjects:range:](v167, "getObjects:range:", v180, 0LL, v90);
    }

    objc_opt_class();
    char v93 = objc_opt_isKindOfClass();
    if ((v93 & 1) != 0)
    {
      int v171 = (void **)-[__CFAllocator _objectsPointer](allocatora, "_objectsPointer");
    }

    else
    {
      id v94 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        id v94 = malloc_default_zone();
      }
      int v171 = (void **)malloc_zone_calloc(v94, 1uLL, 8 * v90);
      -[__CFAllocator getObjects:range:]( allocatora,  "getObjects:range:",  v171,  0LL,  -[__CFAllocator count](allocatora, "count"));
    }

    unint64_t v95 = v90 / active;
    unint64_t v96 = v90 % active;
    uint64_t v97 = active - 1LL;
    char v155 = v93;
    if (active == 1LL)
    {
      uint64_t v98 = 0LL;
    }

    else
    {
      uint64_t v98 = PF_CALLOC_SCANNED_BYTES(8 * v97);
      uint64_t v99 = 0LL;
      do
      {
        uint64_t v100 = PF_CALLOC_SCANNED_BYTES(0x30uLL);
        *uint64_t v100 = v174;
        v100[1] = v180;
        v100[2] = v171;
        v100[3] = v96 + (v99 + 1) * v95;
        v100[4] = v95;
        v100[5] = ptra;
        v98[v99++] = -[_PFTask initWithFunction:withArgument:andPriority:]( objc_alloc(&OBJC_CLASS____PFTask),  "initWithFunction:withArgument:andPriority:",  _fireFaultsOnBackgroundThread,  v100,  2LL);
      }

      while (v97 != v99);
    }

    unint64_t v101 = v95 + v96;
    if (v174)
    {
      uint64_t v102 = *(void *)(v174 + 32);
      uint64_t v103 = *(void *)(v174 + 128);
    }

    else
    {
      uint64_t v102 = 0LL;
      uint64_t v103 = 0LL;
    }

    uint64_t v148 = v102;
    uint64_t v165 = v103;
    if (v101)
    {
      for (unint64_t j = 0LL; j < v101; ++j)
      {
        uint64_t v105 = (uint64_t)v180[j];
        if (((*(_DWORD *)(v105 + 16) >> 15) & 3 | 4) == 5)
        {
          v106 = *(void **)(v105 + 48);
          if (v106 && *v106)
          {
            char v107 = 3;
          }

          else
          {
            _PFFaultHandlerFulfillFault(v103, v105, v102, v171[j], 0);
            char v107 = 1;
          }

          ptra[j] = v107;
        }
      }
    }

    if (v98)
    {
      if (v97)
      {
        for (uint64_t k = 0LL; k != v97; ++k)
        {
          uint64_t v109 = v98[k];
          pthread_mutex_lock((pthread_mutex_t *)(v109 + 32));
          while (!*(_DWORD *)(v109 + 144))
            pthread_cond_wait((pthread_cond_t *)(v109 + 96), (pthread_mutex_t *)(v109 + 32));
          pthread_mutex_unlock((pthread_mutex_t *)(v109 + 32));
        }
      }

      PF_FREE_OBJECT_ARRAY(v98);
    }

    id v110 = objc_alloc_init(MEMORY[0x189603FA8]);
    if (v90)
    {
      uint64_t v111 = MEMORY[0x189604A88];
      uint64_t v112 = MEMORY[0x189604A80];
      v114 = v171;
      v113 = ptra;
      unint64_t v115 = (uint64_t *)v180;
      do
      {
        int v117 = *v113++;
        int v116 = v117;
        if (v117)
        {
          uint64_t v118 = v111;
          if (v116 != 1)
          {
            _PFFaultHandlerFulfillFault(v165, *v115, v148, *v114, 1);
            uint64_t v118 = v112;
          }
        }

        else
        {
          uint64_t v118 = v112;
        }

        [v110 addObject:v118];
        ++v114;
        ++v115;
        --v90;
      }

      while (v90);
    }

    -[NSSQLFetchRequestContext addFaultsThatWereFired:]((void *)v174, v110);

    char v119 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      char v119 = malloc_default_zone();
    }
    malloc_zone_free(v119, ptra);
    if ((isKindOfClass & 1) == 0)
    {
      char v120 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        char v120 = malloc_default_zone();
      }
      malloc_zone_free(v120, v180);
    }

    if ((v155 & 1) == 0)
    {
      char v121 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        char v121 = malloc_default_zone();
      }
      malloc_zone_free(v121, v171);
    }
  }

  if (allocatora) {
    CFRelease(allocatora);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v176 >= 2)
  {
    _NSCoreDataLog(4LL, (uint64_t)@"fetch using %@ returned %lu rows", v75, v76, v77, v78, v79, v80, (uint64_t)v149);
    if (v176 >= 3)
    {
      if (v167) {
        _NSCoreDataLog(4LL, (uint64_t)@" with values: %@", v122, v123, v124, v125, v126, v127, (uint64_t)v167);
      }
    }
  }

  [v150 drain];
  if (theArray) {
    CFRelease(theArray);
  }
  if (v163) {
    CFRelease(v163);
  }
  if (v178) {
    char v128 = [v178 _isCancelled];
  }
  else {
    char v128 = 0;
  }
  [*(id *)(v177 + 8) _setAsyncResultHandle:0];
  [0 drain];
  if (v176 >= 1)
  {
    if (v178) {
      char v129 = v128;
    }
    else {
      char v129 = 0;
    }
    if ((v129 & 1) != 0)
    {
      if (v174 && *(_BYTE *)(v174 + 80))
      {
        double v136 = CFAbsoluteTimeGetCurrent();
        v137 = @"Fetch cancelled.  Total fetch execution time: \x1B[31m%.4f\x1B[0ms.";
      }

      else
      {
        double v136 = CFAbsoluteTimeGetCurrent();
        v137 = @"Fetch cancelled.  Total fetch execution time: %.4fs.";
      }

      _NSCoreDataLog(4LL, (uint64_t)v137, v130, v131, v132, v133, v134, v135, COERCE__INT64(v136 - Current));
    }

    else
    {
      if (v174 && *(_BYTE *)(v174 + 80))
      {
        double v138 = CFAbsoluteTimeGetCurrent();
        -[_PFArray count](v167, "count");
        v145 = @"total fetch execution time: \x1B[31m%.4f\x1B[0ms for %d rows.";
      }

      else
      {
        double v138 = CFAbsoluteTimeGetCurrent();
        -[_PFArray count](v167, "count");
        v145 = @"total fetch execution time: %.4fs for %d rows.";
      }

      _NSCoreDataLog(4LL, (uint64_t)v145, v139, v140, v141, v142, v143, v144, COERCE__INT64(v138 - Current));
    }
  }

  return v167;
}

void sub_18669967C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866996C8LL);
  }

  JUMPOUT(0x1866996B0LL);
}

void sub_186699694(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1866996C4LL);
  }
  JUMPOUT(0x1866996B0LL);
}

LABEL_29:
        BOOL v39 = sqlite3_bind_int64(v36, v37, v38);
        goto LABEL_46;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0) {
        break;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        uint64_t v105 = v13;
        _NSCoreDataLog(7LL, (uint64_t)@"SQLite bind[%ld] = %@", v30, v31, v32, v33, v34, v35, v9);
      }

      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          [v13 timeIntervalSinceReferenceDate];
          uint64_t v105 = v49;
          _NSCoreDataLog(7LL, (uint64_t)@"SQLite bind[%ld] = (timestamp)%f", v50, v51, v52, v53, v54, v55, v9);
        }

        else
        {
          uint64_t v105 = v13;
          _NSCoreDataLog(7LL, (uint64_t)@"SQLite bind[%ld] = %@", v43, v44, v45, v46, v47, v48, v9);
        }
      }

      if (v15) {
        goto LABEL_27;
      }
LABEL_38:
      if (!v13) {
        goto LABEL_43;
      }
      if (v11)
      {
        if (v14) {
          goto LABEL_41;
        }
      }

      else
      {
        int v60 = -[NSSQLiteAdapter sqlTypeForExpressionConstantValue:]( (uint64_t)-[NSSQLiteConnection adapter](v2, "adapter"),  v13);
        if (v60)
        {
          uint64_t v11 = v60;
          if (v14) {
            goto LABEL_41;
          }
        }

        else
        {
          id v13 = (void *)[v13 description];
          uint64_t v11 = 6;
          if (v14)
          {
LABEL_41:
            int v56 = v2->_vmstatement;
            int v57 = v9 + 1;
            uint64_t v58 = "<null>";
LABEL_42:
            BOOL v39 = sqlite3_bind_text(v56, v57, v58, -1, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
LABEL_46:
            uint64_t v59 = v39;
            if ((_DWORD)v39) {
              goto LABEL_96;
            }
            goto LABEL_47;
          }
        }
      }

      switch(v11)
      {
        case 1u:
          unsigned int v65 = v2->_vmstatement;
          uint64_t v42 = [v13 intValue];
          vmstatement = v65;
          uint64_t v6 = v106;
          char v41 = v9 + 1;
          goto LABEL_32;
        case 2u:
        case 3u:
          uint64_t v63 = v2->_vmstatement;
          int v38 = [v13 longLongValue];
          uint64_t v36 = v63;
          uint64_t v6 = v106;
          int v37 = v9 + 1;
          goto LABEL_29;
        case 4u:
          CFIndex v61 = v2->_vmstatement;
          unsigned int v62 = (void *)[v13 stringValue];
          goto LABEL_62;
        case 5u:
        case 6u:
        case 9u:
          CFIndex v61 = v2->_vmstatement;
          unsigned int v62 = v13;
LABEL_62:
          uint64_t v58 = (const char *)[v62 UTF8String];
          int v56 = v61;
          uint64_t v6 = v106;
          int v57 = v9 + 1;
          goto LABEL_42;
        case 7u:
          unsigned int v66 = v2->_vmstatement;
          [v13 doubleValue];
          goto LABEL_65;
        case 8u:
          unsigned int v66 = v2->_vmstatement;
          [v13 timeIntervalSinceReferenceDate];
LABEL_65:
          unsigned int v68 = v66;
          uint64_t v6 = v106;
          BOOL v39 = sqlite3_bind_double(v68, v9 + 1, v67);
          goto LABEL_46;
        case 0xAu:
        case 0x11u:
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            if (v13) {
              -[_PFEvanescentData _openMapping]((uint64_t)v13);
            }
            [v13 length];
            uint64_t v64 = sqlite3_bind_blob_b();
            goto LABEL_74;
          }

          unsigned int v84 = [v13 bytes];
          id v85 = v2->_vmstatement;
          if (v84) {
            uint64_t v86 = (const void *)v84;
          }
          else {
            uint64_t v86 = v13;
          }
          uint64_t v79 = [v13 length];
          uint64_t v80 = v85;
          uint64_t v6 = v106;
          uint64_t v81 = v9 + 1;
          int v82 = v86;
          int v83 = -1LL;
LABEL_86:
          BOOL v39 = sqlite3_bind_blob(v80, v81, v82, v79, (void (__cdecl *)(void *))v83);
          goto LABEL_46;
        case 0xBu:
          uint64_t v69 = v13;
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            uint64_t v2 = (NSSQLiteConnection *)MEMORY[0x189603F70];
            unsigned int v5 = *MEMORY[0x189603A60];
            uint64_t v100 = (void *)NSString;
            unint64_t v101 = (objc_class *)objc_opt_class();
            uint64_t v102 = [v100 stringWithFormat:@"Unexpected or improperly formatted UUID parameter with type %@, expected NSUUID or well-formed NSString", NSStringFromClass(v101), v105];
            goto LABEL_104;
          }

          CFAllocatorRef v70 = malloc(0x10uLL);
          [v69 getUUIDBytes:v70];
          uint64_t v64 = sqlite3_bind_blob(v2->_vmstatement, v9 + 1, v70, 16, (void (__cdecl *)(void *))MEMORY[0x1895FB398]);
          goto LABEL_74;
        case 0xCu:
          objc_opt_class();
          uint64_t v71 = v13;
          if ((objc_opt_isKindOfClass() & 1) != 0) {
            uint64_t v71 = (void *)[v13 absoluteString];
          }
          if (([v71 isNSString] & 1) == 0)
          {
            uint64_t v2 = (NSSQLiteConnection *)MEMORY[0x189603F70];
            unsigned int v5 = *MEMORY[0x189603A60];
            uint64_t v103 = (void *)NSString;
            v104 = (objc_class *)objc_opt_class();
            uint64_t v102 = [v103 stringWithFormat:@"Unexpected or improperly formatted URI parameter type %@, expected NSURL or well-formed NSString", NSStringFromClass(v104), v105];
LABEL_104:
            unint64_t v95 = v102;
            uint64_t v98 = MEMORY[0x189604A60];
            unint64_t v96 = v2;
            uint64_t v97 = v5;
LABEL_100:
            objc_exception_throw((id)-[NSSQLiteConnection exceptionWithName:reason:userInfo:]( v96,  "exceptionWithName:reason:userInfo:",  v97,  v95,  v98));
LABEL_101:
            v2->_sqliteConnectionFlags = (__sqliteConnectionFlags)(*(_DWORD *)&sqliteConnectionFlags & 0xFFFFFFFD);
            -[NSSQLiteConnection releaseSQLStatement]((uint64_t)v2);
            uint64_t v2 = (NSSQLiteConnection *)[NSString stringWithUTF8String:sqlite3_errmsg(v2->_db)];
            uint64_t v99 = *MEMORY[0x189603A58];
            uint64_t v91 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithInt:", v5),  @"NSSQLiteErrorDomain");
            char v93 = v99;
            int v92 = (const __CFString *)v2;
LABEL_97:
            id v94 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  v93,  134180LL,  (uint64_t)v92,  v91);
            objc_exception_throw(v94);
LABEL_98:
            uint64_t v89 = 0LL;
LABEL_94:
            -[NSSQLiteConnection setColumnsToFetch:](v2, v89);
            return;
          }

          uint64_t v64 = sqlite3_bind_text( v2->_vmstatement,  v9 + 1,  (const char *)[v71 UTF8String],  -1,  (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
LABEL_74:
          uint64_t v59 = v64;
LABEL_79:
          uint64_t v6 = v106;
          if ((_DWORD)v59)
          {
LABEL_96:
            uint64_t v2 = (NSSQLiteConnection *)&OBJC_CLASS____NSCoreDataException;
            size_t v90 = *MEMORY[0x189603A58];
            uint64_t v91 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithInt:", v59),  @"NSSQLiteErrorDomain");
            int v92 = @"sqlite3_bind* failed";
            char v93 = v90;
            goto LABEL_97;
          }

          break;
        case 0xDu:
          uint64_t v72 = objc_alloc(NSString);
          uint64_t v73 = [v13 rangeValue];
          [v13 rangeValue];
          uint64_t v75 = (void *)objc_msgSend(v72, "initWithFormat:", @"%lu/%lu", v73, v74);
          uint64_t v59 = sqlite3_bind_text( v2->_vmstatement,  v9 + 1,  (const char *)[v75 UTF8String],  -1,  (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);

          goto LABEL_79;
        case 0xFu:
          uint64_t v76 = (void *)[v10 tombstonedPropertyDescription];
          if (!v76) {
            uint64_t v76 = (void *)[v10 propertyDescription];
          }
          uint64_t v77 = +[_PFRoutines retainedEncodeObjectValue:forTransformableAttribute:]( (uint64_t)&OBJC_CLASS____PFRoutines,  (uint64_t)v13,  v76);
          uint64_t v59 = sqlite3_bind_blob( v2->_vmstatement,  v9 + 1,  (const void *)[v77 bytes],  objc_msgSend(v77, "length"),  (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);

          [v10 setTombstonedPropertyDescription:0];
          goto LABEL_79;
        case 0x10u:
          uint64_t v78 = [v13 _bytesPtrForStore];
          uint64_t v79 = [v13 _bytesLengthForStore];
          uint64_t v80 = v2->_vmstatement;
          uint64_t v81 = v9 + 1;
          int v82 = (const void *)v78;
          uint64_t v6 = v106;
          int v83 = 0LL;
          goto LABEL_86;
        default:
          goto LABEL_99;
      }

        break;
    }
  }

  else
  {
    _NSCoreDataLog( 1LL,  (uint64_t)@"warning snapshot_set_value_as_object called on NULL",  (uint64_t)a3,  a4,  a5,  a6,  a7,  a8,  v27);
    __break(1u);
  }

    uint64_t v11 = 0;
    goto LABEL_21;
  }

            objc_autoreleasePoolPop(v12);
            return 0;
          }

          callBacks.version = v30;
          *(_OWORD *)&callBacks.retain = v29;
          callBacks.copyDescription = v28;
          callBacks.equal = 0LL;
          callBacks.hash = 0LL;
          id v15 = CFSetCreateMutable(v27, 0LL, &callBacks);
          unsigned int v16 = [v11 inverseRelationship];
          if (v16)
          {
            double v17 = (void *)v16;
            while ((-[__CFSet containsObject:](v15, "containsObject:", v17) & 1) == 0)
            {
              uint64_t v18 = [v17 entity];
              if (!v18
                || (unsigned int v19 = (id *)v18, objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
                || ![v17 name]
                || (void *)objc_msgSend(v19[12], "objectForKeyedSubscript:", objc_msgSend(v17, "name")) != v17
                || ![v19 name]
                || (id *)objc_msgSend( (id)objc_msgSend(a3, "entitiesByName"),  "objectForKeyedSubscript:",  objc_msgSend(v19, "name")) != v19)
              {
                double v21 = v26;
                if (!v26) {
                  goto LABEL_29;
                }
                BOOL v22 = (void *)MEMORY[0x189607870];
                unsigned int v23 = *MEMORY[0x189607460];
                unsigned int v24 = &unk_189F034F0;
                goto LABEL_28;
              }

              -[__CFSet addObject:](v15, "addObject:", v17);
              double v17 = (void *)[v17 inverseRelationship];
              if (!v17) {
                break;
              }
            }
          }

          uint64_t v9 = v25;
        }

        objc_autoreleasePoolPop(v12);
      }

      unsigned int v8 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( properties,  "countByEnumeratingWithState:objects:count:",  &v32,  v36,  16LL);
      a4 = v26;
      if (v8) {
        continue;
      }
      break;
    }
  }

  if (a4) {
    *a4 = 0LL;
  }
  return 1;
}

    if (self->_parentObjectStore)
    {
      BOOL v31 = objc_alloc_init(MEMORY[0x1896077E8]);
      v113[0] = 0LL;
      -[NSManagedObjectContext lockObjectStore]((uint64_t)self);
      int v32 = (id)[self->_parentObjectStore executeRequest:request withContext:self error:v113];
      -[NSManagedObjectContext unlockObjectStore]((uint64_t)self);
      if (v113[0])
      {
        uint64_t v33 = v113[0];
        if (v113[0])
        {
          if (error) {
            *error = (NSError *)v113[0];
          }
        }

        else
        {
          uint64_t v46 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
          _NSCoreDataLog( 17LL,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSManagedObjectContext.m");
          unsigned int v53 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSManagedObjectContext.m";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 2023;
            _os_log_fault_impl( &dword_186681000,  v53,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
          }
        }
      }

      [v31 drain];
      double v54 = 0LL;
      uint64_t v55 = v113[0];
      if (self->_dispatchQueue && v32) {
        -[NSManagedObjectContext _registerAsyncReferenceCallback]((uint64_t)self);
      }
      if ((!v32 || v113[0]) && (!v113[0] || v32))
      {
        int v56 = [NSString stringWithUTF8String:"Either a non nil result OR an error OR an exception"];
        _NSCoreDataLog(17LL, v56, v57, v58, v59, v60, v61, v62, v103);
        uint64_t v63 = (os_log_s *)__pflogFaultLog;
        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl( &dword_186681000,  v63,  OS_LOG_TYPE_FAULT,  "CoreData: Either a non nil result OR an error OR an exception",  buf,  2u);
        }
      }

      return (NSPersistentStoreResult *)v32;
    }

    if (v10 - 5 <= 2)
    {
      if ((_BYTE)dword_18C4ABDC0)
      {
        objc_exception_throw((id)objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A58],  @"Context does not have a coordinator; cannot perform executeRequest:error:.",
                                   0LL));
        uint64_t v102 = v101;
        _Block_object_dispose(v112, 8);
        _Block_object_dispose(v113, 8);
        _Block_object_dispose(&v114, 8);
        _Unwind_Resume(v102);
      }

      _NSCoreDataLog( 2LL,  (uint64_t)@"Context does not have a coordinator; cannot perform executeRequest:error:.",
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        v103);
      switch(v10)
      {
        case 7uLL:
          uint64_t v34 = &OBJC_CLASS___NSBatchDeleteResult;
          goto LABEL_84;
        case 6uLL:
          uint64_t v34 = &OBJC_CLASS___NSBatchUpdateResult;
          goto LABEL_84;
        case 5uLL:
          uint64_t v34 = &OBJC_CLASS___NSBatchInsertResult;
LABEL_84:
          uint64_t v86 = objc_alloc(v34);
          uint64_t v87 = -[NSPersistentStoreRequest resultType](request, "resultType");
          int v37 = (NSPersistentCloudKitContainerEventResult *)[v86 initWithResultType:v87 andObject:NSArray_EmptyArray];
          return (NSPersistentStoreResult *)v37;
      }

      BOOL v88 = [NSString stringWithUTF8String:"Unknown batch request - %@ - %lu"];
      _NSCoreDataLog(17LL, v88, v89, v90, v91, v92, v93, v94, (uint64_t)request);
      unsigned int v84 = (os_log_s *)__pflogFaultLog;
      if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
LABEL_86:
        int v37 = 0LL;
        return (NSPersistentStoreResult *)v37;
      }

      *(_DWORD *)buf = 138412546;
      *(void *)&uint8_t buf[4] = request;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v10;
      id v85 = "CoreData: Unknown batch request - %@ - %lu";
LABEL_97:
      _os_log_fault_impl(&dword_186681000, v84, OS_LOG_TYPE_FAULT, v85, buf, 0x16u);
      goto LABEL_86;
    }

    switch(v10)
    {
      case 0xBuLL:
        uint64_t v76 = objc_alloc(&OBJC_CLASS___NSPersistentCloudKitContainerEventResult);
        int v37 = -[NSPersistentCloudKitContainerEventResult initWithResult:ofType:]( v76,  "initWithResult:ofType:",  NSArray_EmptyArray,  -[NSPersistentStoreRequest resultType](request, "resultType"));
        break;
      case 0xAuLL:
        uint64_t v75 = objc_alloc(&OBJC_CLASS___NSSQLiteIndexStatisticsResult);
        int v37 = -[NSSQLiteIndexStatisticsResult initWithResult:](v75, "initWithResult:", NSArray_EmptyArray);
        break;
      case 8uLL:
        uint64_t v35 = objc_alloc(&OBJC_CLASS___NSPersistentHistoryResult);
        uint64_t v36 = -[NSPersistentStoreRequest resultType](request, "resultType");
        int v37 = -[NSPersistentHistoryResult initWithResultType:andResult:]( v35,  "initWithResultType:andResult:",  v36,  NSArray_EmptyArray);
        break;
      default:
        uint64_t v77 = [NSString stringWithUTF8String:"Unknown request - %@ - %lu"];
        _NSCoreDataLog(17LL, v77, v78, v79, v80, v81, v82, v83, (uint64_t)request);
        unsigned int v84 = (os_log_s *)__pflogFaultLog;
        if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
          goto LABEL_86;
        }
        *(_DWORD *)buf = 138412546;
        *(void *)&uint8_t buf[4] = request;
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v10;
        id v85 = "CoreData: Unknown request - %@ - %lu";
        goto LABEL_97;
    }

    return (NSPersistentStoreResult *)v37;
  }

  double v17 = -[NSAsynchronousFetchRequest initWithFetchRequest:completionBlock:]( objc_alloc(&OBJC_CLASS___NSAsynchronousFetchRequest),  "initWithFetchRequest:completionBlock:",  request,  0LL);
  uint64_t v9 = -[NSAsynchronousFetchResult initForFetchRequest:withContext:andProgress:completetionBlock:]( objc_alloc(&OBJC_CLASS___NSAsynchronousFetchResult),  "initForFetchRequest:withContext:andProgress:completetionBlock:",  v17,  self,  0LL,  0LL);

  uint64_t v18 = v9;
  v113[0] = 0LL;
  unsigned int v19 = -[NSManagedObjectContext executeFetchRequest:error:](self, "executeFetchRequest:error:", request, v113);
  unsigned int v8 = (NSError *)v113[0];
  if (v19)
  {
    if (v113[0])
    {
      uint64_t v20 = [NSString stringWithUTF8String:"Fetching generated a result AND an error: %@"];
      _NSCoreDataLog(17LL, v20, v21, v22, v23, v24, v25, v26, (uint64_t)v113[0]);
      int v27 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(id *)&uint8_t buf[4] = v113[0];
        _os_log_fault_impl( &dword_186681000,  v27,  OS_LOG_TYPE_FAULT,  "CoreData: Fetching generated a result AND an error: %@",  buf,  0xCu);
      }

      -[NSPersistentStoreResult setOperationError:](v9, "setOperationError:", v113[0]);
    }

    -[NSAsynchronousFetchResult setFinalResult:]((uint64_t)v9, v19);
  }

  else
  {
    if (!v113[0])
    {
      int v38 = [NSString stringWithUTF8String:"Fetching returned nil AND failed to generate an error"];
      _NSCoreDataLog(17LL, v38, v39, v40, v41, v42, v43, v44, v103);
      uint64_t v45 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl( &dword_186681000,  v45,  OS_LOG_TYPE_FAULT,  "CoreData: Fetching returned nil AND failed to generate an error",  buf,  2u);
      }

      unsigned int v8 = (NSError *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:&unk_189F03720];
    }

    uint64_t v9 = 0LL;
    if (error) {
      goto LABEL_7;
    }
  }

  return v9;
}

              if (v16 != (void *)v22)
              {
                uint64_t v75 = 0LL;
                uint64_t v49 = (void *)[objc_alloc(MEMORY[0x189603F48]) initWithContentsOfFile:v16 options:0 error:&v75];
                if (v75)
                {
                  char v50 = NSStringFromSelector(a2);
                  _NSCoreDataLog( 1LL,  (uint64_t)@"Failed reading data in %@ from path %@, error, %@",  v51,  v52,  v53,  v54,  v55,  v56,  (uint64_t)v50);
                }

                uint64_t v74 = 0LL;
                if ([v49 length])
                {
                  uint64_t v63 = (void *)[objc_alloc(MEMORY[0x189607908]) initForReadingFromData:v49 error:&v74];
                  uint64_t v64 = v63;
                  if ((v4 & 1) != 0)
                  {
                    [v63 setRequiresSecureCoding:1];
                    [v64 _allowDecodingCyclesInSecureMode];
                  }

                  else
                  {
                    [v63 setRequiresSecureCoding:0];
                  }

                  [v64 setDecodingFailurePolicy:1];
                  unsigned int v24 = (NSManagedObjectModel *)(id)objc_msgSend( v64,  "decodeObjectOfClasses:forKey:",  objc_msgSend( MEMORY[0x189604010],  "setWithObject:",  objc_opt_class()),  @"root");
                  if ([v64 error]) {
                    uint64_t v74 = (id)[v64 error];
                  }

                  if (v24)
                  {

                    goto LABEL_41;
                  }

                  _NSCoreDataLog( 1LL,  (uint64_t)@" Failed to load keyed archive model at path '%@' with error '%@'",  v65,  v66,  v67,  v68,  v69,  v70,  (uint64_t)v16);
                }

                else
                {
                  _NSCoreDataLog( 1LL,  (uint64_t)@"Unable model at path (file is zero bytes) '%@'",  v57,  v58,  v59,  v60,  v61,  v62,  (uint64_t)v16);
                }
              }

      id v15 = *(_DWORD *)(a1 + 72);
LABEL_30:
      *(_DWORD *)(a1 + 72) = v15 & 0xFFFFFFFE;
      if ((v7 & 1) == 0
        && ([v6 createDirectoryAtPath:v5 withIntermediateDirectories:1 attributes:0 error:&v157] & 1) == 0)
      {
        uint64_t v74 = objc_opt_class();
        _NSCoreDataLog( 1LL,  (uint64_t)@" (%@): couldn't create section info cache directory at %@ : %@",  v75,  v76,  v77,  v78,  v79,  v80,  v74);
        return;
      }

      if (!v12 || (BOOL v30 = open(v12, 1538, 384LL), v30 < 0))
      {
        __error();
        id v110 = objc_opt_class();
        _NSCoreDataLog( 1LL,  (uint64_t)@" (%@): couldn't create section info file at %@ : %d",  v68,  v69,  v70,  v71,  v72,  v73,  v110);
        return;
      }

      BOOL v31 = v30;
      unint64_t v115 = objc_alloc_init(MEMORY[0x1896077E8]);
      int v32 = (void *)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:4096];
      [v32 appendBytes:"41b5a6b5c6e848c462a8480cd24caef3" length:32];
      _writeInt64IntoData(v32, 0LL);
      __buf = 0LL;
      _writeInt64IntoData(v32, 0LL);
      _writeStringIntoData((void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 8), "entity"), "name"), v32, &v168);
      _writeDataIntoData((void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 8), "entity"), "versionHash"), v32);
      _writeStringIntoData(*(void **)(a1 + 24), v32, &v168);
      _writeInt32IntoData(v32, [*(id *)(a1 + 96) count]);
      uint64_t v33 = (void *)[*(id *)(a1 + 8) sortDescriptors];
      _writeInt32IntoData(v32, [v33 count]);
      char v155 = 0u;
      char v156 = 0u;
      uint64_t v153 = 0u;
      BOOL v154 = 0u;
      uint64_t v34 = [v33 countByEnumeratingWithState:&v153 objects:v167 count:16];
      if (v34)
      {
        uint64_t v35 = v34;
        uint64_t v36 = *(void *)v154;
        do
        {
          for (uint64_t i = 0LL; i != v35; ++i)
          {
            if (*(void *)v154 != v36) {
              objc_enumerationMutation(v33);
            }
            _writeStringIntoData((void *)[*(id *)(*((void *)&v153 + 1) + 8 * i) key], v32, &v168);
          }

          uint64_t v35 = [v33 countByEnumeratingWithState:&v153 objects:v167 count:16];
        }

        while (v35);
      }

      -[NSFetchedResultsController _appendAffectedStoreInfoToData:adjustedOffset:](a1, v32, &__buf);
      _writeInt32IntoData(v32, [*(id *)(a1 + 104) count]);
      BOOL v151 = 0u;
      unsigned int v152 = 0u;
      uint64_t v149 = 0u;
      uint64_t v150 = 0u;
      int v38 = *(void **)(a1 + 104);
      BOOL v39 = [v38 countByEnumeratingWithState:&v149 objects:v166 count:16];
      if (v39)
      {
        int v40 = v39;
        char v41 = *(void *)v150;
        do
        {
          uint64_t v42 = 0LL;
          do
          {
            if (*(void *)v150 != v41) {
              objc_enumerationMutation(v38);
            }
            uint64_t v43 = *(void **)(*((void *)&v149 + 1) + 8 * v42);
            _writeStringIntoData((void *)[v43 name], v32, &v168);
            _writeStringIntoData((void *)[v43 indexTitle], v32, &v168);
            _writeInt32IntoData(v32, [v43 numberOfObjects]);
            if (v43) {
              uint64_t v44 = v43[4];
            }
            else {
              LODWORD(v44) = 0;
            }
            _writeInt32IntoData(v32, v44);
            ++v42;
          }

          while (v40 != v42);
          uint64_t v45 = [v38 countByEnumeratingWithState:&v149 objects:v166 count:16];
          int v40 = v45;
        }

        while (v45);
      }

      v113 = (char *)v12;
      uint64_t v148 = 0LL;
      uint64_t v147 = 0LL;
      uint64_t v46 = (void *)-[NSFetchedResultsController _fetchedObjectsArrayOfObjectIDs](a1);
      if (+[_PFRoutines _generateObjectIDMaptableForArray:withMapping:andEntries:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v46,  (uint64_t *)&v148,  (uint64_t *)&v147))
      {
        uint64_t v111 = v31;
        _writeInt32IntoData(v32, 1u);
        uint64_t v47 = (void *)[v148 objectAtIndex:0];
        double v48 = (void *)[v148 objectAtIndex:1];
        uint64_t v49 = (void *)[v148 objectAtIndex:2];
        uint64_t v112 = (void *)[v148 objectAtIndex:3];
        char v50 = (void *)[v147 objectAtIndex:0];
        uint64_t v51 = v50;
        _writeInt32IntoData(v32, [v47 count]);
        v145 = 0u;
        v146 = 0u;
        uint64_t v143 = 0u;
        uint64_t v144 = 0u;
        uint64_t v52 = [v47 countByEnumeratingWithState:&v143 objects:v165 count:16];
        if (v52)
        {
          unsigned int v53 = v52;
          double v54 = *(void *)v144;
          do
          {
            for (unint64_t j = 0LL; j != v53; ++j)
            {
              if (*(void *)v144 != v54) {
                objc_enumerationMutation(v47);
              }
              _writeStringIntoData(*(void **)(*((void *)&v143 + 1) + 8 * j), v32, &v168);
            }

            unsigned int v53 = [v47 countByEnumeratingWithState:&v143 objects:v165 count:16];
          }

          while (v53);
        }

        _writeInt32IntoData(v32, [v48 count]);
        uint64_t v141 = 0u;
        uint64_t v142 = 0u;
        uint64_t v139 = 0u;
        uint64_t v140 = 0u;
        int v56 = [v48 countByEnumeratingWithState:&v139 objects:v164 count:16];
        if (v56)
        {
          int v57 = v56;
          uint64_t v58 = *(void *)v140;
          do
          {
            for (uint64_t k = 0LL; k != v57; ++k)
            {
              if (*(void *)v140 != v58) {
                objc_enumerationMutation(v48);
              }
              _writeStringIntoData(*(void **)(*((void *)&v139 + 1) + 8 * k), v32, &v168);
            }

            int v57 = [v48 countByEnumeratingWithState:&v139 objects:v164 count:16];
          }

          while (v57);
        }

        _writeInt32IntoData(v32, [v49 count]);
        v137 = 0u;
        double v138 = 0u;
        uint64_t v135 = 0u;
        double v136 = 0u;
        int v60 = [v49 countByEnumeratingWithState:&v135 objects:v163 count:16];
        if (v60)
        {
          CFIndex v61 = v60;
          unsigned int v62 = *(void *)v136;
          do
          {
            for (m = 0LL; m != v61; ++m)
            {
              if (*(void *)v136 != v62) {
                objc_enumerationMutation(v49);
              }
              _writeInt32IntoData(v32, *(void *)(*((void *)&v135 + 1) + 8 * m));
            }

            CFIndex v61 = [v49 countByEnumeratingWithState:&v135 objects:v163 count:16];
          }

          while (v61);
        }

        _writeInt64IntoData(v32, [v112 longLongValue]);
        if ((unint64_t)[v147 count] >= 2)
        {
          _writeInt32IntoData(v32, [v50 count]);
          if ((unint64_t)[v49 count] > 0xFE)
          {
            char v129 = 0uLL;
            uint64_t v130 = 0uLL;
            uint64_t v127 = 0uLL;
            char v128 = 0uLL;
            int v82 = [v50 countByEnumeratingWithState:&v127 objects:v161 count:16];
            if (v82)
            {
              int v83 = v82;
              unsigned int v84 = *(void *)v128;
              do
              {
                for (n = 0LL; n != v83; ++n)
                {
                  if (*(void *)v128 != v84) {
                    objc_enumerationMutation(v50);
                  }
                  _writeInt16IntoData(v32, (unsigned __int16)*(void *)(*((void *)&v127 + 1) + 8 * n));
                }

                int v83 = [v50 countByEnumeratingWithState:&v127 objects:v161 count:16];
              }

              while (v83);
            }
          }

          else
          {
            uint64_t v133 = 0uLL;
            uint64_t v134 = 0uLL;
            uint64_t v131 = 0uLL;
            uint64_t v132 = 0uLL;
            uint64_t v64 = [v50 countByEnumeratingWithState:&v131 objects:v162 count:16];
            if (v64)
            {
              unsigned int v65 = v64;
              unsigned int v66 = *(void *)v132;
              do
              {
                for (iuint64_t i = 0LL; ii != v65; ++ii)
                {
                  if (*(void *)v132 != v66) {
                    objc_enumerationMutation(v50);
                  }
                  LOBYTE(v11_Block_object_dispose(va, 8) = *(void *)(*((void *)&v131 + 1) + 8 * ii);
                  [v32 appendBytes:&v118 length:1];
                }

                unsigned int v65 = [v50 countByEnumeratingWithState:&v131 objects:v162 count:16];
              }

              while (v65);
            }
          }
        }

        _writeInt32IntoData(v32, [v51 count]);
        if ([v112 longLongValue] > 4294967294)
        {
          char v121 = 0uLL;
          uint64_t v122 = 0uLL;
          char v119 = 0uLL;
          char v120 = 0uLL;
          size_t v90 = [v51 countByEnumeratingWithState:&v119 objects:v159 count:16];
          BOOL v31 = v111;
          uint64_t v81 = v115;
          if (v90)
          {
            uint64_t v91 = v90;
            int v92 = *(void *)v120;
            do
            {
              for (junint64_t j = 0LL; jj != v91; ++jj)
              {
                if (*(void *)v120 != v92) {
                  objc_enumerationMutation(v51);
                }
                _writeInt64IntoData(v32, *(void *)(*((void *)&v119 + 1) + 8 * jj));
              }

              uint64_t v91 = [v51 countByEnumeratingWithState:&v119 objects:v159 count:16];
            }

            while (v91);
          }
        }

        else
        {
          uint64_t v125 = 0uLL;
          uint64_t v126 = 0uLL;
          uint64_t v123 = 0uLL;
          uint64_t v124 = 0uLL;
          uint64_t v86 = [v51 countByEnumeratingWithState:&v123 objects:v160 count:16];
          BOOL v31 = v111;
          uint64_t v81 = v115;
          if (v86)
          {
            uint64_t v87 = v86;
            BOOL v88 = *(void *)v124;
            do
            {
              for (kuint64_t k = 0LL; kk != v87; ++kk)
              {
                if (*(void *)v124 != v88) {
                  objc_enumerationMutation(v51);
                }
                _writeInt32IntoData(v32, *(void *)(*((void *)&v123 + 1) + 8 * kk));
              }

              uint64_t v87 = [v51 countByEnumeratingWithState:&v123 objects:v160 count:16];
            }

            while (v87);
          }
        }
      }

      else
      {
        _writeInt32IntoData(v32, 0);
        uint64_t v81 = v115;
      }

      id v94 = [v32 length];
      uint64_t v118 = bswap64(v94);
      objc_msgSend(v32, "replaceBytesInRange:withBytes:", 32, 8, &v118);
      int v117 = bswap64(__buf);
      objc_msgSend(v32, "replaceBytesInRange:withBytes:", 40, 8, &v117);
      unint64_t v95 = pwrite(v31, (const void *)[v32 bytes], v94, 0);
      if (!v94 || v95 != v94)
      {
        __error();
        unint64_t v96 = objc_opt_class();
        _NSCoreDataLog( 1LL,  (uint64_t)@" (%@): error writing section cached info at %@ with error %d",  v97,  v98,  v99,  v100,  v101,  v102,  v96);
        ftruncate(v31, 0LL);
        unlink(v113);
      }

      close(v31);
      BOOL v22 = v81;
      goto LABEL_116;
    }
  }

          int v28 = [NSString stringWithUTF8String:"Unsupported property type for unique attribute on entity '%@': %@"];
          int v29 = [v60 name];
          _NSCoreDataLog(17LL, v28, v30, v31, v32, v33, v34, v35, v29);
          uint64_t v36 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            int v37 = [v60 name];
            *(_DWORD *)buf = 138412546;
            uint64_t v87 = v37;
            BOOL v88 = 2112;
            uint64_t v89 = v12;
            _os_log_fault_impl( &dword_186681000,  v36,  OS_LOG_TYPE_FAULT,  "CoreData: Unsupported property type for unique attribute on entity '%@': %@",  buf,  0x16u);
          }

          continue;
        }

        int v38 = (void *)[*(id *)(*((void *)&v81 + 1) + 8 * i) propertyDescription];
        BOOL v39 = [v38 name];
        int v40 = [(id)v12 columnName];
        char v41 = [v38 entity];
        [v10 appendFormat:@", %@", v40];
        uint64_t v42 = *(void **)(v12 + 72);
        if (v42) {
          [v10 appendFormat:@", %@", objc_msgSend(v42, "columnName")];
        }
        uint64_t v43 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189607940]), "initWithFormat:", @"%@ IN ("), v40;
        uint64_t v73 = 0u;
        uint64_t v74 = 0u;
        uint64_t v75 = 0u;
        uint64_t v76 = 0u;
        uint64_t v44 = [a3 countByEnumeratingWithState:&v73 objects:v90 count:16];
        if (v44)
        {
          uint64_t v45 = v44;
          uint64_t v46 = *(void *)v74;
          uint64_t v47 = 1;
          do
          {
            for (uint64_t k = 0LL; k != v45; ++k)
            {
              if (*(void *)v74 != v46) {
                objc_enumerationMutation(a3);
              }
              uint64_t v49 = *(void **)(*((void *)&v73 + 1) + 8 * k);
              if (objc_msgSend((id)objc_msgSend(v49, "entity"), "isKindOfEntity:", v41))
              {
                if ((v47 & 1) == 0) {
                  objc_msgSend(v43, "appendString:", @", ");
                }
                [v43 appendString:@"? "];
                char v50 = -[NSSQLBindVariable initWithInt64:sqlType:]( [NSSQLBindVariable alloc],  "initWithInt64:sqlType:",  objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v49, "valueForKey:", v39), "objectID"),  "_referenceData64"),  2);
                [v68 addObject:v50];

                uint64_t v47 = 0;
              }
            }

            uint64_t v45 = [a3 countByEnumeratingWithState:&v73 objects:v90 count:16];
          }

          while (v45);
        }

        [v43 appendString:@""]);
        [v66 addObject:v43];

        BOOL v10 = v63;
      }

      unsigned int v65 = [a2 countByEnumeratingWithState:&v81 objects:v92 count:16];
    }

    while (v65);
  }

  uint64_t v51 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189607940]),  "initWithFormat:",  @"SELECT %@ FROM %@ WHERE ("),  v10,  objc_msgSend(v60, "tableName");

  uint64_t v71 = 0u;
  uint64_t v72 = 0u;
  uint64_t v69 = 0u;
  CFAllocatorRef v70 = 0u;
  uint64_t v52 = [v66 countByEnumeratingWithState:&v69 objects:v85 count:16];
  if (v52)
  {
    unsigned int v53 = v52;
    double v54 = *(void *)v70;
    uint64_t v55 = 1;
    do
    {
      for (m = 0LL; m != v53; ++m)
      {
        if (*(void *)v70 != v54) {
          objc_enumerationMutation(v66);
        }
        int v57 = *(void *)(*((void *)&v69 + 1) + 8 * m);
        if ((v55 & 1) == 0) {
          [v51 appendString:@" OR "];
        }
        [v51 appendFormat:@"%@", v57];
        uint64_t v55 = 0;
      }

      unsigned int v53 = [v66 countByEnumeratingWithState:&v69 objects:v85 count:16];
      uint64_t v55 = 0;
    }

    while (v53);
  }

  [v51 appendString:@""]);
  uint64_t v58 =  -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  v60,  v51);

  -[NSSQLiteAdapter _useModel:]((uint64_t)v58, v68);
  return v58;
}

      if (([*(id *)(a1 + 48) save:*(void *)(*(void *)(a1 + 64) + 8) + 40] & 1) == 0)
      {
        unsigned int v23 = *(id *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
        *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
      }

      [*(id *)(a1 + 48) reset];

      unsigned int v24 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
      objc_autoreleasePoolPop(context);
      if (!v24) {
        break;
      }
      if (++v3 == v26)
      {
        int v26 = [obj countByEnumeratingWithState:&v37 objects:v46 count:16];
        if (v26) {
          goto LABEL_3;
        }
        break;
      }
    }
  }
}

    uint64_t v18 = (void *)MEMORY[0x186E3E5D8]();
    unsigned int v19 = __ckLoggingOverride != 0;
    goto LABEL_30;
  }

  if ([v15 code] == 111 || objc_msgSend(v15, "code") == 20 || objc_msgSend(v15, "code") == 6) {
    goto LABEL_29;
  }
  if ([v15 code] == 2)
  {
    double v17 = -[NSCloudKitMirroringDelegate shouldAttemptSetupRecoveryFromError:viaPush:](v11, v15, 1);
    uint64_t v18 = (void *)MEMORY[0x186E3E5D8]();
    unsigned int v19 = __ckLoggingOverride != 0;
    if (!v17) {
      goto LABEL_35;
    }
LABEL_30:
    double v21 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Reviving the mirroring delegate after notification for subscription: %@\n%@"];
    _NSCoreDataLog( v19,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  (uint64_t)"-[NSCloudKitMirroringDelegate _respondToPushNotification:forSubscription:]_block_invoke");
    objc_autoreleasePoolPop(v18);
    id v14 = *(void *)(a1 + 32);
    if (!v14) {
      return;
    }
    BOOL v39 = MEMORY[0x1895F87A8];
    int v40 = 3221225472LL;
    char v41 = __73__NSCloudKitMirroringDelegate_setupMirroringDelegateFromPushNotification__block_invoke;
    uint64_t v42 = &unk_189EAB260;
    uint64_t v43 = v14;
    int v12 = @"com.apple.coredata.cloudkit.setup.push";
    id v13 = @"CoreData: CloudKit Setup From Push";
    goto LABEL_32;
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
  {
    if ([v80 count])
    {
      v124[0] = @"needsUpload";
      v125[0] = [MEMORY[0x189607878] expressionForConstantValue:MEMORY[0x189604A88]];
      v124[1] = @"needsCloudDelete";
      v125[1] = [MEMORY[0x189607878] expressionForConstantValue:MEMORY[0x189604A88]];
      unsigned int v23 = +[NSCKRecordMetadata batchUpdateMetadataMatchingEntityIdsAndPKs:withUpdates:inStore:withManagedObjectContext:error:]( (uint64_t)NSCKRecordMetadata,  v80,  [MEMORY[0x189603F68] dictionaryWithObjects:v125 forKeys:v124 count:2],  *(void *)(a1 + 48),  *(void *)(a1 + 40),  (void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40));
      if (v23)
      {
        [v78 minusSet:v23];
      }

      else
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
        unsigned int v24 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
      }
    }

    if ([*(id *)(a1 + 40) hasChanges]
      && ([*(id *)(a1 + 40) save:*(void *)(*(void *)(a1 + 80) + 8) + 40] & 1) == 0)
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
      double v25 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
    }
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL)
    && (+[NSCKHistoryAnalyzerState purgeAnalyzedHistoryFromStore:withManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKHistoryAnalyzerState,  *(void *)(a1 + 48),  *(void **)(a1 + 40),  (void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL)) & 1) == 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
    int v26 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
  }

  [*(id *)(a1 + 40) reset];
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
  {
    if (objc_msgSend( (id)+[NSCKMetadataEntry entryForKey:fromStore:inManagedObjectContext:error:]( (uint64_t)NSCKMetadataEntry,  (uint64_t)@"NSCloudKitMirroringDelegateScanForRowsMissingFromHistoryKey",  *(void *)(a1 + 48),  *(void **)(a1 + 40),  *(void *)(*(void *)(a1 + 80) + 8) + 40),  "BOOLValue")
      && ((int v27 = *(void *)(*(void *)(a1 + 56) + 8LL)) == 0 ? (v28 = 0LL) : (v28 = *(void **)(v27 + 8)),
          [v28 databaseScope] == 2
       || ((int v29 = *(void *)(*(void *)(a1 + 56) + 8LL)) == 0 ? (v30 = 0LL) : (v30 = *(void **)(v29 + 8)),
           [v30 databaseScope] == 1)))
    {
      BOOL v31 = *(void *)(*(void *)(a1 + 56) + 8LL);
      if (v31) {
        int v32 = *(void **)(v31 + 8);
      }
      else {
        int v32 = 0LL;
      }
      unsigned int v68 = +[PFCloudKitSerializer defaultRecordZoneIDForDatabaseScope:]( PFCloudKitSerializer,  "defaultRecordZoneIDForDatabaseScope:",  [v32 databaseScope]);
      uint64_t v33 = *(void *)(*(void *)(a1 + 56) + 8LL);
      if (v33) {
        uint64_t v34 = *(void **)(v33 + 8);
      }
      else {
        uint64_t v34 = 0LL;
      }
      if (+[NSCKRecordZoneMetadata zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:error:]( (uint64_t)NSCKRecordZoneMetadata,  v68,  [v34 databaseScope],  *(void *)(a1 + 48),  *(void **)(a1 + 40),  *(void *)(*(void *)(a1 + 80) + 8) + 40))
      {
        uint64_t v97 = 0LL;
        uint64_t v98 = &v97;
        uint64_t v99 = 0x3052000000LL;
        uint64_t v100 = __Block_byref_object_copy__44;
        unint64_t v101 = __Block_byref_object_dispose__44;
        uint64_t v102 = 0LL;
        uint64_t v77 = (id)[*(id *)(a1 + 48) model];
        uint64_t v69 = objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(*(id *)(a1 + 48), "ancillarySQLModels"),  "objectForKey:",  @"NSPersistentStoreMirroringDelegateOptionKey"),  "entityNamed:",  @"NSCKRecordMetadata");
        uint64_t v35 = (void *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(*(id *)(a1 + 40), "persistentStoreCoordinator"),  "managedObjectModel"),  "entitiesForConfiguration:",  objc_msgSend(*(id *)(a1 + 48), "configurationName"));
        unint64_t v95 = 0u;
        unint64_t v96 = 0u;
        char v93 = 0u;
        id v94 = 0u;
        CFAllocatorRef v70 = v35;
        uint64_t v75 = [v35 countByEnumeratingWithState:&v93 objects:v123 count:16];
        if (v75)
        {
          uint64_t v73 = *(void *)v94;
LABEL_56:
          uint64_t v36 = 0LL;
          while (1)
          {
            if (*(void *)v94 != v73) {
              objc_enumerationMutation(v70);
            }
            obja = v36;
            int v37 = *(void **)(*((void *)&v93 + 1) + 8LL * (void)v36);
            uint64_t v81 = (void *)MEMORY[0x186E3E5D8]();
            int v38 = objc_msgSend(v77, "entityNamed:", objc_msgSend(v37, "name"));
            if (!v38 || *(void *)(v38 + 160)) {
              goto LABEL_88;
            }
            v92[0] = MEMORY[0x1895F87A8];
            v92[1] = 3221225472LL;
            v92[2] = __86__PFCloudKitExportContext_processAnalyzedHistoryInStore_inManagedObjectContext_error___block_invoke_9;
            v92[3] = &unk_189EAB870;
            v92[6] = &v97;
            v92[4] = v38;
            v92[5] = v69;
            BOOL v39 = -[NSSQLBlockRequestContext initWithBlock:context:sqlCore:]( objc_alloc(&OBJC_CLASS___NSSQLBlockRequestContext),  "initWithBlock:context:sqlCore:",  v92,  *(void *)(a1 + 40),  *(void *)(a1 + 48));
            -[NSSQLCore dispatchRequest:withRetries:](*(void *)(a1 + 48), v39, 0LL);
            uint64_t v79 = v39;
            int v40 = objc_alloc_init(MEMORY[0x189603FA8]);
            size_t v90 = 0u;
            uint64_t v91 = 0u;
            BOOL v88 = 0u;
            uint64_t v89 = 0u;
            unsigned int v84 = (id)v98[5];
            char v41 = [v84 countByEnumeratingWithState:&v88 objects:v122 count:16];
            if (v41)
            {
              uint64_t v42 = 0LL;
              uint64_t v43 = *(void *)v89;
              uint64_t v44 = v40;
              while (2)
              {
                uint64_t v45 = 0LL;
                uint64_t v46 = v42 + 1;
                uint64_t v71 = v41 + v42;
                do
                {
                  if (*(void *)v89 != v43) {
                    objc_enumerationMutation(v84);
                  }
                  uint64_t v47 = *(void **)(*((void *)&v88 + 1) + 8 * v45);
                  double v48 = (void *)MEMORY[0x186E3E5D8]();
                  if ([v47 count] != 2)
                  {

                    unsigned int v66 = (void *)MEMORY[0x189603F70];
                    uint64_t v67 = [NSString stringWithFormat:@"Unexpected number of items in the pk / ent array: %@", v47];
                    objc_exception_throw((id)[v66 exceptionWithName:*MEMORY[0x189603A58] reason:v67 userInfo:0]);
                    __break(1u);
                    return;
                  }

                  uint64_t v49 = (void *)objc_msgSend( *(id *)(a1 + 48),  "newObjectIDForEntity:pk:",  _sqlCoreLookupSQLEntityForEntityID( *(void **)(a1 + 48),  objc_msgSend( (id)objc_msgSend(v47, "objectAtIndexedSubscript:", 1),  "unsignedLongValue")),  objc_msgSend((id)objc_msgSend(v47, "objectAtIndexedSubscript:", 0), "integerValue"));
                  [v44 addObject:v49];

                  if (!(v46 % 0x64))
                  {
                    if (-[PFCloudKitExportContext insertRecordMetadataForObjectIDsInBatch:inManagedObjectContext:withPendingTransactionNumber:error:]( *(void *)(a1 + 56),  v44,  *(void **)(a1 + 40),  *(void *)(a1 + 64),  (void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL)))
                    {
                      if (([*(id *)(a1 + 40) save:*(void *)(*(void *)(a1 + 80) + 8) + 40] & 1) == 0)
                      {
                        *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
                        char v50 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
                      }

                      uint64_t v44 = objc_alloc_init(MEMORY[0x189603FA8]);
                    }

                    else
                    {
                      *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
                      uint64_t v51 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
                    }

                    [*(id *)(a1 + 40) reset];
                  }

                  uint64_t v52 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL);
                  objc_autoreleasePoolPop(v48);
                  if (!v52) {
                    goto LABEL_79;
                  }
                  ++v45;
                  ++v46;
                }

                while (v41 != v45);
                char v41 = [v84 countByEnumeratingWithState:&v88 objects:v122 count:16];
                uint64_t v42 = v71;
                if (v41) {
                  continue;
                }
                break;
              }
            }

            else
            {
              uint64_t v44 = v40;
            }

      [v14 setValue:v13];
LABEL_30:
      uint64_t v7 = v9 + 1;
    }

    while (v7 < v52);
  }

  unsigned int v53 = (void *)[a2 bindIntarrays];
  char v50 = [v53 count];
  if (v50)
  {
    BOOL v22 = 0LL;
    while (1)
    {
      BOOL v10 = (void *)[v51 objectAtIndex:v22];
      unsigned int v23 = (void *)[v51 objectAtIndex:v22 + 1];
      unsigned int v24 = (void *)[v51 objectAtIndex:v22 + 2];
      double v25 = (void *)[a3 valueForKey:v10];
      if (!v25) {
        break;
      }
      int v26 = v25;
      if ([v25 expressionType])
      {
        int v40 = (void *)MEMORY[0x189603F70];
        char v41 = *MEMORY[0x189603A60];
        uint64_t v43 = (void *)NSString;
        uint64_t v45 = v10;
LABEL_68:
        uint64_t v44 = @"bad substitution variable for %@, must be a constant value";
LABEL_69:
        uint64_t i = objc_msgSend(v43, "stringWithFormat:", v44, v45, ClassName, v47);
        goto LABEL_70;
      }

      int v27 = (void *)[v26 constantValue];
      if (([v27 isNSArray] & 1) == 0
        && ([v27 isNSSet] & 1) == 0
        && ([v27 isNSOrderedSet] & 1) == 0)
      {
        int v40 = (void *)MEMORY[0x189603F70];
        char v41 = *MEMORY[0x189603A60];
        for (uint64_t i = [NSString stringWithFormat:@"bad substitution variable for %@, must be a collection", v10, ClassName, v47];
              ;
              uint64_t i = [NSString stringWithFormat:@"bad substitution variable for %@, must be a collection of objects or objectIDs", v10, ClassName, v47])
        {
LABEL_70:
          objc_exception_throw((id)[v40 exceptionWithName:v41 reason:i userInfo:a3]);
LABEL_71:
          int v40 = (void *)MEMORY[0x189603F70];
          char v41 = *MEMORY[0x189603A60];
        }
      }

      int v28 = (void *)objc_msgSend(v53, "objectAtIndex:", objc_msgSend(v24, "unsignedIntegerValue"));
      if ([v27 count])
      {
        memset(v59, 0, sizeof(v59));
        [v27 countByEnumeratingWithState:v59 objects:v61 count:16];
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          int v29 = (id)+[_PFRoutines newArrayOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v27);
        }

        else
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0) {
            goto LABEL_71;
          }
          int v29 = v27;
        }

        BOOL v10 = v29;
      }

      else
      {
        BOOL v10 = 0LL;
      }

      int v57 = 0u;
      uint64_t v58 = 0u;
      uint64_t v55 = 0u;
      int v56 = 0u;
      BOOL v30 = [v10 countByEnumeratingWithState:&v55 objects:v60 count:16];
      if (v30)
      {
        BOOL v31 = v30;
        int v32 = *(void *)v56;
        do
        {
          for (unint64_t j = 0LL; j != v31; ++j)
          {
            if (*(void *)v56 != v32) {
              objc_enumerationMutation(v10);
            }
            unsigned int v8 = *(void **)(*((void *)&v55 + 1) + 8 * j);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
              || (objc_msgSend((id)objc_msgSend(v8, "entity"), "isKindOfEntity:", v23) & 1) == 0)
            {
              ClassName = object_getClassName(v8);
              uint64_t v47 = [v23 name];
              _NSCoreDataLog( 1LL,  (uint64_t)@"oid = %@ [oid class] = %s expecting entity %@",  v34,  v35,  v36,  v37,  v38,  v39,  (uint64_t)v8);
              __break(1u);
              goto LABEL_62;
            }
          }

          BOOL v31 = [v10 countByEnumeratingWithState:&v55 objects:v60 count:16];
        }

        while (v31);
      }

      [v28 setValue:v10];

      v22 += 3LL;
      if (v22 >= v50) {
        return;
      }
    }

    int v40 = (void *)MEMORY[0x189603F70];
    char v41 = *MEMORY[0x189603A58];
    uint64_t v43 = (void *)NSString;
    uint64_t v45 = v10;
LABEL_66:
    uint64_t v44 = @"missing variable binding for %@";
    goto LABEL_69;
  }

LABEL_47:
      if (v8 == ++v9) {
        goto LABEL_88;
      }
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0) {
      unsigned int v23 = [NSString stringWithFormat:@"<FBF url=%@>", objc_getProperty(v13, v22, 16, 1), v105];
    }
    else {
      unsigned int v23 = objc_msgSend( NSString,  "stringWithFormat:",  @"<NSData len=%lu>",  objc_msgSend(v13, "length"),  v105);
    }
    uint64_t v105 = (void *)v23;
    _NSCoreDataLog(7LL, (uint64_t)@"SQLite bind[%ld] = %@", v24, v25, v26, v27, v28, v29, v9);
    uint64_t v6 = v106;
LABEL_26:
    if (v15) {
      goto LABEL_27;
    }
    goto LABEL_38;
  }

  uint64_t v51 = 0LL;
  flags = v320->flags;
  unsigned int v53 = (flags >> 2) & 7;
  double v54 = **(void **)(v15 + 96);
  v311 = v53;
  if (v324 && (_DWORD)v53 == 3) {
    uint64_t v51 = v324[6];
  }
  uint64_t v55 = v320;
  int v56 = -[NSFetchRequest _disablePersistentStoreResultCaching]( v320->fetch_request,  "_disablePersistentStoreResultCaching");
  v295 = v43;
  v296 = v51;
  v294 = v56;
  int v57 = (a4 & 1) != 0 || (*(_BYTE *)&v320->flags & 1) == 0;
  v309 = &v276;
  v306 = flags;
  v301 = v57;
  uint64_t v75 = v57 & (v333 ^ 1);
  uint64_t v76 = v333 | ((flags & 2) >> 1);
  MEMORY[0x1895F8858](v56);
  v310 = v79;
  if (v79 > 0x200)
  {
    uint64_t v80 = (void *)NSAllocateScannedUncollectable();
    v317 = v80;
  }

  else
  {
    v317 = (uint64_t *)((char *)&v276 - v78);
    bzero((char *)&v276 - v78, 8 * v77);
  }

  MEMORY[0x1895F8858](v80);
  int v83 = 8 * v81;
  v308 = v84;
  if (v84 > 0x200)
  {
    v315 = (char *)NSAllocateScannedUncollectable();
    v307 = (char *)NSAllocateScannedUncollectable();
  }

  else
  {
    v315 = (char *)&v276 - v82;
    bzero((char *)&v276 - v82, 8 * v81);
    MEMORY[0x1895F8858](v85);
    v307 = (char *)&v276 - ((v83 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    bzero(v307, v83);
  }

  uint64_t v86 = v75 & (v317 == 0LL);
  uint64_t v87 = v323;
  BOOL v88 = v336;
  if ((v86 & 1) != 0 || (v76 & 1) == 0 && (!v315 || !v307))
  {
    PF_FREE_OBJECT_ARRAY(v322);
    v321 = 0LL;
    v322 = 0LL;
  }

  if ((uint64_t)(v87 - v54) <= 31)
  {
    uint64_t v89 = v337;
    size_t v90 = v322;
    uint64_t v91 = v308;
    if (a8) {
      *a8 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  134060,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  @"CoreData: XPC: Suspect response from server (not enough room for first row)",  @"Reason"));
    }
    goto LABEL_394;
  }

  if ((v333 & 1) != 0) {
    v293 = 0LL;
  }
  else {
    v293 = (objc_class *)[v324 objectIDFactoryForSQLEntity:v55->statement_entity];
  }
  v283 = sel_setForeignEntityKeySlot_entityKey_;
  v282 = (void (*)(id, char *, void, void))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  v281 = sel_setForeignOrderKeySlot_orderKey_;
  v280 = (void (*)(id, char *, void, void))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  v287 = sel_setForeignKeySlot_int64_;
  v286 = (void (*)(id, char *, void, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  v285 = sel_setOptLock_;
  char v93 = +[NSSQLRow instanceMethodForSelector:](&OBJC_CLASS___NSSQLRow, "instanceMethodForSelector:");
  v284 = (void (*)(id, char *, uint64_t))v93;
  if (v333)
  {
    id v94 = v320;
    entity_for_ek_funptr = (uint64_t (*)(uint64_t, char *, void))v320->entity_for_ek_funptr;
    v302 = sel_entityForID_;
    v303 = entity_for_ek_funptr;
    goto LABEL_112;
  }

  id v94 = v320;
  if (v301)
  {
    unint64_t v96 = v321;
    char v93 = -[objc_class allocateBatch:count:](v293, "allocateBatch:count:", v317, v321);
    if (v96 == (_DWORD)v93)
    {
      uint64_t v103 = v321;
      if ((v306 & 2) != 0 || !(_DWORD)v321)
      {
        if (!(_DWORD)v321) {
          goto LABEL_334;
        }
      }

      else
      {
        char v93 = +[NSSQLRow newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:]( &OBJC_CLASS___NSSQLRow,  "newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:",  v315,  v321,  v94->statement_entity,  v317,  *(double *)(v15 + 40));
        if (v103 != (_DWORD)v93)
        {
          v104 = @"Decoding failed: No rows.";
LABEL_333:
          _NSCoreDataLog(8LL, (uint64_t)v104, v97, v98, v99, v100, v101, v102, v276);
LABEL_334:
          v239 = v322;
          goto LABEL_335;
        }
      }

      v302 = 0LL;
      v303 = 0LL;
      char v107 = v321;
      BOOL v88 = v336;
      goto LABEL_113;
    }

    v104 = @"Decoding failed: No oids.";
    goto LABEL_333;
  }

  v302 = 0LL;
  v303 = 0LL;
LABEL_112:
  char v107 = v321;
  if (!(_DWORD)v321)
  {
    v239 = v322;
    if (!v322)
    {
LABEL_336:
      v241 = v337;
      v242 = v317;
      if (v308 >= 0x201 && v315)
      {
        NSZoneFree(0LL, v315);
        NSZoneFree(0LL, v307);
      }

      if (v310 >= 0x201 && v242) {
        NSZoneFree(0LL, v242);
      }

      return (id)NSArray_EmptyArray;
    }

  objc_autoreleasePoolPop(context);
  return v23;
}

      objc_autoreleasePoolPop(v8);
      return;
    }

    [a3 didAccessValueForKey:v10];
    goto LABEL_33;
  }

  uint64_t result = a1[7];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, void))(result + 16))(result, a1[6], 0LL);
  }
  return result;
}

        if (v100) {
          *uint64_t v100 = v36;
        }
        return 0LL;
      }

      objc_msgSend(v13, "addObjectsFromArray:", objc_msgSend(v15, "allObjects"));
      if (v14)
      {
        unsigned int v16 = *(void **)&v14[v10[340]];
        if (v16)
        {
          double v17 = (void *)[v16 _keypathsForDerivedPropertyValidation:&v110];
          if (v17)
          {
            objc_msgSend(v13, "addObjectsFromArray:", objc_msgSend(v17, "allObjects"));
            goto LABEL_12;
          }

          uint64_t v76 = *MEMORY[0x189603A60];
          uint64_t v77 = *MEMORY[0x189607798];
          v134[0] = @"derived attribute";
          v134[1] = v77;
          v135[0] = v14;
          v135[1] = v110;
          uint64_t v78 = objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  v76,  @"Invalid keypaths found in derived attribute (filteringPredicate)",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", v135, v134, 2));
          uint64_t v79 = *MEMORY[0x189607460];
          uint64_t v132 = @"NSUnderlyingException";
          uint64_t v133 = v78;
          uint64_t v36 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v79,  134097,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v133, &v132, 1));
          if (!v36)
          {
            uint64_t v80 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
            _NSCoreDataLog( 17LL,  v80,  v81,  v82,  v83,  v84,  v85,  v86,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m");
            uint64_t v44 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136315394;
              v137 = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLEntity.m";
              double v138 = 1024;
              uint64_t v139 = 1513;
              goto LABEL_65;
            }

            return 0LL;
          }

          goto LABEL_47;
        }
      }

        objc_autoreleasePoolPop(v17);
      }

      uint64_t v11 = -[NSArray countByEnumeratingWithState:objects:count:]( v9,  "countByEnumeratingWithState:objects:count:",  &v43,  v47,  16LL);
      if (!v11)
      {
        uint64_t v6 = v40;
        unsigned int v5 = v41;
        if ((v13 & 1) != 0)
        {
          [v42 appendString:@""]);
          uint64_t v36 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  -[NSSQLIndex sqlEntity](v12, "sqlEntity"),  v42);
          [v41 addObject:v36];
          goto LABEL_53;
        }

        goto LABEL_54;
      }
    }
  }

  uint64_t v36 = -[NSSQLGenerator initWithPersistentStore:]( objc_alloc(&OBJC_CLASS___NSSQLGenerator),  "initWithPersistentStore:",  a3);
  int v37 = -[NSSQLGenerator newSQLStatmentForBinaryIndex:inStore:](v36, self, (uint64_t)a3);
  if (v37)
  {
    int v38 = v37;
    [v5 addObject:v37];
  }

  int v37 = [v28 errorWithDomain:v29 code:134060 userInfo:v27];
  if (v37) {
    goto LABEL_23;
  }
  unint64_t v96 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
  _NSCoreDataLog( 17LL,  v96,  v97,  v98,  v99,  v100,  v101,  v102,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitOptionsValidator.m");
  uint64_t v45 = (os_log_s *)__pflogFaultLog;
  if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
    goto LABEL_23;
  }
  *(_DWORD *)buf = 136315394;
  v106 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitOptionsValidator.m";
  char v107 = 1024;
  uint64_t v108 = 200;
LABEL_38:
  _os_log_fault_impl( &dword_186681000,  v45,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
LABEL_23:
  if (v37)
  {
    if (a4)
    {
      uint64_t result = 0LL;
      *a4 = v37;
      return result;
    }
  }

  else
  {
    uint64_t v46 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitOptionsValidator.m");
    unsigned int v53 = (os_log_s *)__pflogFaultLog;
    uint64_t result = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    v106 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitOptionsValidator.m";
    char v107 = 1024;
    uint64_t v108 = 56;
    _os_log_fault_impl( &dword_186681000,  v53,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
  }

  return 0LL;
}

                int v3 = (void *)MEMORY[0x189603F70];
                uint64_t v18 = *MEMORY[0x189603A60];
                unsigned int v19 = [NSString stringWithFormat:@"%@ does not yet support elements of type %@. Please file a radar for this support and assign it to CoreData | (New Bugs).", +[NSAttributeDescription stringForAttributeType:]( NSAttributeDescription, "stringForAttributeType:", 2100), +[NSAttributeDescription stringForAttributeType:]( NSAttributeDescription, "stringForAttributeType:", v9)];
                BOOL v31 = @"offendingAttribute";
                int v32 = v7;
                uint64_t v20 = [MEMORY[0x189603F68] dictionaryWithObjects:&v32 forKeys:&v31 count:1];
                double v21 = v3;
                BOOL v22 = v18;
                unsigned int v23 = (const __CFString *)v19;
                while (1)
                {
                  objc_exception_throw((id)[v21 exceptionWithName:v22 reason:v23 userInfo:v20]);
LABEL_49:
                  int v3 = (void *)MEMORY[0x189603F70];
                  unsigned int v24 = *MEMORY[0x189603A60];
                  int v29 = @"Attribute";
                  BOOL v30 = v7;
                  uint64_t v20 = [MEMORY[0x189603F68] dictionaryWithObjects:&v30 forKeys:&v29 count:1];
                  unsigned int v23 = @"Unsupported attribute type for composite.";
                  double v21 = v3;
                  BOOL v22 = v24;
                }
              }
            }

            else if (v8 != 200 && v8 != 300)
            {
              goto LABEL_45;
            }
          }

          else if (v8 > 599)
          {
            if (v8 != 600 && v8 != 700) {
              goto LABEL_45;
            }
          }

          else if (v8 != 400 && v8 != 500)
          {
            goto LABEL_45;
          }

          ++v6;
        }

        while (v4 != v6);
        uint64_t result = [a2 countByEnumeratingWithState:&v25 objects:v35 count:16];
        int v4 = result;
      }

      while (result);
    }
  }

  return result;
}

LABEL_88:
  _execute((uint64_t)v2);
  if ((*(_BYTE *)&v2->_sqliteConnectionFlags & 2) != 0 && !v2->_columnsToFetch)
  {
    uint64_t v87 = objc_msgSend(-[NSSQLiteConnection sqlStatement](v2, "sqlStatement"), "entity");
    while (v87)
    {
      BOOL v88 = v87;
      uint64_t v87 = *(void *)(v87 + 168);
      if (v87 == v88)
      {
        uint64_t v89 = *(void **)(v88 + 72);
        goto LABEL_94;
      }
    }

    goto LABEL_98;
  }

              if ([v67 sqlType] != 16)
              {
LABEL_96:
                id v94 = v77;
                goto LABEL_97;
              }

              int v92 = object_getClass(v65);
              char v93 = *(id *)((char *)v65 + *((unsigned int *)object_getIndexedIvars(v92) + v85 + 19));
              if ((([v67 isFileBackedFuture] & 1) != 0 || v77 == v93)
                && (![v67 isFileBackedFuture]
                 || [v77 isEqual:v93]))
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0)
                {
                  uint64_t v122 = v77;
                  goto LABEL_152;
                }
              }

              objc_opt_class();
              unsigned int v8 = (_BYTE *)v139;
              uint64_t v133 = v93;
              if (![v67 isFileBackedFuture])
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0
                  && [v77 isNSData]
                  && [v93 isEqualToData:v77])
                {
                  uint64_t v77 = v93;
                }

                else
                {
                  uint64_t v102 = a1[1];
                  if (v102 && (uint64_t v103 = *(void *)(v102 + 8)) != 0 && (*(_BYTE *)(v103 + 201) & 0x40) != 0
                    || v136 >= [v77 length])
                  {
                    uint64_t v108 = 0LL;
                    v113 = 0LL;
                  }

                  else
                  {
                    v104 = CFUUIDCreate(0LL);
                    uint64_t v105 = CFUUIDCreateString(0LL, v104);
                    CFRelease(v104);
                    v106 = a1[1];
                    if (v106) {
                      char v107 = *(void **)(v106 + 152);
                    }
                    else {
                      char v107 = 0LL;
                    }
                    uint64_t v108 = [v107 stringByAppendingPathComponent:v105];
                    unsigned int v8 = (_BYTE *)v139;
                    uint64_t v109 = a1[1];
                    if (v109) {
                      id v110 = *(void **)(v109 + 160);
                    }
                    else {
                      id v110 = 0LL;
                    }
                    uint64_t v111 = [v110 stringByAppendingPathComponent:v105];
                    uint64_t v112 = v105;
                    v113 = v111;
                    CFRelease(v112);
                  }

                  if (v133)
                  {
                    unint64_t v115 = objc_opt_class();
                    uint64_t v33 = v115 == objc_opt_class();
                    unsigned int v8 = (_BYTE *)v139;
                    if (v33)
                    {
                      int v116 = (id)a1[13];
                      if (!v116)
                      {
                        int v116 = objc_alloc_init(MEMORY[0x189603FA8]);
                        a1[13] = v116;
                      }

                      [v116 addObject:v133];
                    }
                  }

                  int v117 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                  uint64_t v118 = a1[1];
                  if (v118 && (char v119 = *(void *)(v118 + 8)) != 0) {
                    char v120 = (*(_DWORD *)(v119 + 200) >> 2) & 7;
                  }
                  else {
                    char v120 = 0LL;
                  }
                  uint64_t v77 = -[_PFExternalReferenceData initForExternalLocation:safeguardLocation:data:protectionLevel:]( v117,  "initForExternalLocation:safeguardLocation:data:protectionLevel:",  v108,  v113,  v77,  v120);
                  char v121 = (id)a1[12];
                  if (!v121)
                  {
                    char v121 = objc_alloc_init(MEMORY[0x189603FA8]);
                    a1[12] = v121;
                  }

                  [v121 addObject:v77];
                }

                goto LABEL_97;
              }

              uint64_t v98 = a1[1];
              if (v98) {
                uint64_t v99 = *(void **)(v98 + 168);
              }
              else {
                uint64_t v99 = 0LL;
              }
              Property = objc_getProperty(v77, v97, 16LL, 1);
              if (v133) {
                unint64_t v101 = [v133 fileURL] != 0;
              }
              else {
                unint64_t v101 = 0;
              }
              uint64_t v131 = v101;
              if ([v77 _isCloudKitSupportOriginated])
              {
                if (Property) {
                  uint64_t v123 = 0;
                }
                else {
                  uint64_t v123 = v101;
                }
                if (v123
                  && objc_msgSend((id)objc_msgSend(v77, "UUID"), "isEqual:", objc_msgSend(v133, "UUID")))
                {
LABEL_151:
                  uint64_t v77 = v133;
LABEL_152:
                  unsigned int v8 = (_BYTE *)v139;
LABEL_97:
                  snapshot_set_object((char *)v65, v85, (uint64_t)v77);
                  break;
                }

                uint64_t v127 = (id)a1[14];
                if (!v127)
                {
                  uint64_t v127 = objc_alloc_init(MEMORY[0x189603FA8]);
                  a1[14] = v127;
                }

                [v127 addObject:v77];
                char v128 = objc_msgSend( v99,  "stringByAppendingPathComponent:",  objc_msgSend((id)objc_msgSend(v77, "UUID"), "UUIDString"));
                uint64_t v77 = -[_NSDataFileBackedFuture initWithURL:UUID:size:]( [_NSDataFileBackedFuture alloc],  (void *)[MEMORY[0x189604030] fileURLWithPath:v128 isDirectory:0],  (void *)objc_msgSend(v77, "UUID"),  objc_msgSend(v77, "fileSize"));
                unsigned int v8 = (_BYTE *)v139;
                uint64_t v126 = (uint64_t)v133;
                if (!v131) {
                  goto LABEL_97;
                }
              }

              else
              {
                if (![v77 fileURL]
                  && objc_msgSend((id)objc_msgSend(v77, "UUID"), "isEqual:", objc_msgSend(v133, "UUID")))
                {
                  goto LABEL_151;
                }

                uint64_t v124 = objc_alloc(&OBJC_CLASS____NSDataFileBackedFuture);
                uint64_t v77 = -[_NSDataFileBackedFuture initWithDirectoryURL:UUID:originalURL:]( v124,  (void *)[MEMORY[0x189604030] fileURLWithPath:v99 isDirectory:1],  (void *)objc_msgSend(v77, "UUID"),  Property);
                uint64_t v125 = (id)a1[14];
                if (!v125)
                {
                  uint64_t v125 = objc_alloc_init(MEMORY[0x189603FA8]);
                  a1[14] = v125;
                }

                [v125 addObject:v77];
                unsigned int v8 = (_BYTE *)v139;
                uint64_t v126 = (uint64_t)v133;
                if (!v131) {
                  goto LABEL_97;
                }
              }

              -[NSSQLSavePlan _addFileBackedFutureToDelete:]((uint64_t)a1, v126);
              goto LABEL_97;
            }

            snapshot_set_int64((char *)v65, v85, [v77 longLongValue]);
            break;
        }
      }

      else if (((*((unsigned __int8 *)v65 + ((unint64_t)v78 >> 3) + 28) >> (v78 & 7)) & 1) == 0)
      {
        if ([v67 sqlType] == 16)
        {
          uint64_t v89 = object_getClass(v65);
          size_t v90 = *(uint64_t *)((char *)v65 + *((unsigned int *)object_getIndexedIvars(v89) + v85 + 19));
          uint64_t v91 = objc_opt_class();
          uint64_t v33 = v91 == objc_opt_class();
          unsigned int v8 = (_BYTE *)v139;
          if (v33)
          {
            if ([v67 isFileBackedFuture])
            {
              -[NSSQLSavePlan _addFileBackedFutureToDelete:]((uint64_t)a1, v90);
            }

            else
            {
              v114 = (id)a1[13];
              if (!v114)
              {
                v114 = objc_alloc_init(MEMORY[0x189603FA8]);
                a1[13] = v114;
              }

              [v114 addObject:v90];
            }
          }
        }

        snapshot_set_null((char *)v65, v85);
      }

      objc_autoreleasePoolPop(v66);
      ++v64;
    }

    while (v63 != v64);
  }

  -[NSSQLSavePlan _recordToManyChangesForObject:inRow:usingTimestamp:inserted:]( (uint64_t)a1,  (uint64_t)v8,  (uint64_t)v141,  v134,  a6);
}

__objc2_class *_execute(uint64_t a1)
{
  int v1 = (__objc2_class *)a1;
  v60[1] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 8);
  if (v2) {
    dispatch_assert_queue_V2(v2);
  }
  unsigned int v3 = 0;
  unsigned int v4 = 0;
  int v5 = 0;
  unsigned int v54 = 0;
  uint64_t v53 = (uint64_t)&v1[2].superclass + 4;
  double v6 = 0.0;
LABEL_4:
  int v7 = 3 * v4 - 29999;
  while (1)
  {
    uint64_t result = (__objc2_class *)sqlite3_step((sqlite3_stmt *)v1[2].isa);
    uint64_t v9 = result;
    switch((char)result)
    {
      case 1:
      case 7:
      case 10:
      case 17:
      case 21:
        goto LABEL_38;
      case 2:
      case 3:
      case 4:
      case 8:
      case 9:
      case 12:
      case 13:
      case 15:
      case 16:
      case 18:
      case 20:
      case 22:
      case 23:
      case 24:
      case 25:
        goto LABEL_58;
      case 5:
        if (v4 < 0x2711) {
          goto LABEL_29;
        }
        if (v4 - 10000 >= 0xB) {
          useconds_t v10 = v4 - 8899;
        }
        else {
          useconds_t v10 = v7;
        }
        goto LABEL_28;
      case 6:
        goto LABEL_25;
      case 11:
      case 26:
        goto LABEL_43;
      case 14:
        if (v5 > 2)
        {
LABEL_38:
          int v12 = result;
          uint64_t v13 = [NSString stringWithUTF8String:sqlite3_errmsg((sqlite3 *)v1[1].info)];
          if (v12 == 10 && (sqlite3_file_control((sqlite3 *)v1[1].info, 0LL, 4, &v54), v54)) {
            uint64_t v14 = [NSString stringWithFormat:@"I/O error for database at %@.  SQLite error code:%d, '%@' errno:%d", v1->info, v9, v13, v54];
          }
          else {
            uint64_t v14 = [NSString stringWithFormat:@"I/O error for database at %@.  SQLite error code:%d, '%@'", v1->info, v9, v13, v52];
          }
          id v15 = (__objc2_class *)v14;
          if (!v14) {
LABEL_43:
          }
            id v15 = (__objc2_class *)[NSString stringWithFormat:@"Fatal error.  The database at %@ is corrupted.  SQLite error code:%d, '%s'", v1->info, v9, sqlite3_errmsg((sqlite3 *)v1[1].info)];
          unsigned int v16 = @"NSSQLiteErrorDomain";
          uint64_t v17 = (int)v9;
          -[NSSQLiteConnection _forceDisconnectOnError]((uint64_t)v1);
          while (1)
          {
            if ((_DWORD)v9 == 1555)
            {
              LODWORD(v1[7].info) &= ~2u;
              -[NSSQLiteConnection _endFetch](v1);
              -[NSSQLiteConnection releaseSQLStatement]((uint64_t)v1);
              int v1 = &OBJC_CLASS____NSCoreDataOptimisticLockingException;
              uint64_t v9 = (__objc2_class *)*MEMORY[0x189603A60];
              uint64_t v55 = @"_NSCoreDataOptimisticLockingFailureConflictsKey";
              uint64_t v56 = MEMORY[0x189604A58];
              uint64_t v20 = [MEMORY[0x189603F68] dictionaryWithObjects:&v56 forKeys:&v55 count:1];
              unsigned int v23 = @"Constraint primary key violation";
              double v21 = &OBJC_CLASS____NSCoreDataOptimisticLockingException;
              BOOL v22 = v9;
            }

            else
            {
              uint64_t v53 = v17;
              if ((_DWORD)v9 == 1811)
              {
                unsigned int v24 = sqlite3_errmsg((sqlite3 *)v1[1].info);
                LODWORD(v1[7].info) &= ~2u;
                -[NSSQLiteConnection _endFetch](v1);
                -[NSSQLiteConnection releaseSQLStatement]((uint64_t)v1);
                double v25 = "no message";
                if (v24) {
                  double v25 = v24;
                }
                int v1 = (__objc2_class *)objc_msgSend( NSString,  "stringWithFormat:",  @"Constraint trigger violation: %s",  v25);
                uint64_t v9 = &OBJC_CLASS____NSCoreDataConstraintViolationException;
                id v15 = (__objc2_class *)*MEMORY[0x189603A60];
                v57[0] = *MEMORY[0x1896075F0];
                v57[1] = @"_NSCoreDataOptimisticLockingFailureConflictsKey";
                v58[0] = v1;
                v58[1] = MEMORY[0x189604A58];
                uint64_t v20 = [MEMORY[0x189603F68] dictionaryWithObjects:v58 forKeys:v57 count:2];
                double v21 = &OBJC_CLASS____NSCoreDataConstraintViolationException;
                BOOL v22 = v15;
                unsigned int v23 = (const __CFString *)v1;
              }

              else
              {
                if ((_DWORD)v9 != 2067) {
                  goto LABEL_56;
                }
                uint64_t v18 = sqlite3_errmsg((sqlite3 *)v1[1].info);
                LODWORD(v1[7].info) &= ~2u;
                -[NSSQLiteConnection _endFetch](v1);
                -[NSSQLiteConnection releaseSQLStatement]((uint64_t)v1);
                int v1 = &OBJC_CLASS____NSCoreDataConstraintViolationException;
                id v15 = (__objc2_class *)*MEMORY[0x189603A60];
                unsigned int v19 = "no message";
                if (v18) {
                  unsigned int v19 = v18;
                }
                uint64_t v9 = (__objc2_class *)objc_msgSend( NSString,  "stringWithFormat:",  @"Constraint unique violation: %s",  v19);
                uint64_t v59 = @"_NSCoreDataOptimisticLockingFailureConflictsKey";
                v60[0] = MEMORY[0x189604A58];
                uint64_t v20 = [MEMORY[0x189603F68] dictionaryWithObjects:v60 forKeys:&v59 count:1];
                double v21 = &OBJC_CLASS____NSCoreDataConstraintViolationException;
                BOOL v22 = v15;
                unsigned int v23 = (const __CFString *)v9;
              }
            }

            objc_exception_throw((id)-[__objc2_class exceptionWithName:reason:userInfo:]( v21,  "exceptionWithName:reason:userInfo:",  v22,  v23,  v20));
LABEL_56:
            if (v15)
            {
              int v32 = (const char *)-[__objc2_class UTF8String](v15, "UTF8String");
              char v33 = 0;
            }

            else
            {
LABEL_59:
              int v32 = sqlite3_errmsg((sqlite3 *)v1[1].info);
              id v15 = 0LL;
              char v33 = 1;
            }

            if (BYTE2(v1[1].isa)) {
              uint64_t v34 = @"\x1B[31m\x1B[47mERROR:\x1B[0m\x1B[31m (%d) %s\x1B[0m";
            }
            else {
              uint64_t v34 = @"(%d) %s";
            }
            _NSCoreDataLog(1LL, (uint64_t)v34, v26, v27, v28, v29, v30, v31, (uint64_t)v9);
            if ((v33 & 1) != 0)
            {
              id v15 = (__objc2_class *)objc_msgSend( NSString,  "stringWithFormat:",  @"error during SQL execution : %s",  v32,  v32);
              uint64_t v53 = (int)v9;
              unsigned int v16 = @"NSSQLiteErrorDomain";
            }

            -[NSSQLiteConnection _forceDisconnectOnError]((uint64_t)v1);
            uint64_t v35 = *MEMORY[0x189603A58];
            uint64_t v36 = (void *)MEMORY[0x189603F68];
            info = v1->info;
            uint64_t v38 = *MEMORY[0x1896074F8];
            uint64_t v9 = (__objc2_class *)[MEMORY[0x189607968] numberWithInt:v9];
            if (v54) {
              uint64_t v39 = objc_msgSend(MEMORY[0x189607968], "numberWithInteger:");
            }
            else {
              uint64_t v39 = 0LL;
            }
            int v40 = (__objc2_class *)+[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  v35,  v53,  (uint64_t)v15,  (void *)objc_msgSend( v36,  "dictionaryWithObjectsAndKeys:",  info,  v38,  v9,  @"NSSQLiteErrorDomain",  v39,  *MEMORY[0x189607688],  0));
            int v1 = v40;
            if (v16) {
              -[_NSCoreDataException _setDomain:]((uint64_t)v40, v16);
            }
            objc_exception_throw(v1);
LABEL_71:
            uint64_t v17 = 0LL;
            unsigned int v16 = 0LL;
            id v15 = 0LL;
          }
        }

        ++v5;
LABEL_25:
        if (v4 <= 0xA) {
          useconds_t v10 = 3 * v4 + 1;
        }
        else {
          useconds_t v10 = v4 + 1101;
        }
LABEL_28:
        usleep(v10);
LABEL_29:
        if (v6 != 0.0)
        {
          double Current = CFAbsoluteTimeGetCurrent();
          if (Current > v6)
          {
            if (v3 > 7)
            {
              uint64_t v41 = [NSString stringWithFormat:@"The database operation timed out after %.2f seconds.", Current - v6 + *(double *)&v1[5].info];
              if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1)
              {
                if (BYTE2(v1[1].isa)) {
                  double v48 = @"\x1B[31m\x1B[47mERROR:\x1B[0m\x1B[31m (%d) %@\x1B[0m";
                }
                else {
                  double v48 = @"(%d) %@";
                }
                uint64_t v51 = v41;
                _NSCoreDataLog(1LL, (uint64_t)v48, v42, v43, v44, v45, v46, v47, (uint64_t)v9);
              }

              uint64_t v49 = [NSString stringWithFormat:@"error during SQL execution : %@", v41, v51];
              LODWORD(v1[7].info) &= ~2u;
              -[NSSQLiteConnection releaseSQLStatement]((uint64_t)v1);
              id v50 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  *MEMORY[0x189603A58],  134090,  v49,  (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithInt:", v9),  @"NSSQLiteErrorDomain"));
              objc_exception_throw(v50);
            }

            ++v4;
            double v6 = Current + *(double *)&v1[6].isa;
            ++v3;
            goto LABEL_4;
          }
        }

        v7 += 3;
        ++v4;
        break;
      case 19:
        goto LABEL_71;
      default:
        if (result == 100)
        {
          LODWORD(v1[7].info) |= 2u;
        }

        else
        {
          if (result != 101)
          {
LABEL_58:
            unsigned int v16 = 0LL;
            uint64_t v53 = 0LL;
            goto LABEL_59;
          }

          uint64_t result = (__objc2_class *)-[NSSQLiteConnection setColumnsToFetch:](v1, 0LL);
          LODWORD(v1[7].info) &= ~2u;
          *(void *)uint64_t v53 = 0LL;
          *(void **)((char *)&v1[2].cache + 4) = 0LL;
          HIDWORD(v1[2].vtable) = 0;
        }

        return result;
    }
  }

_DWORD *fetchResultSetAllocateInitialize(unsigned int a1, int a2)
{
  if (a1 >= 0x20000) {
    unsigned int v3 = 0x20000;
  }
  else {
    unsigned int v3 = a1;
  }
  if (a1) {
    size_t v4 = v3;
  }
  else {
    size_t v4 = 15359LL;
  }
  int v5 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    int v5 = malloc_default_zone();
  }
  double v6 = malloc_zone_calloc(v5, 1uLL, 0x60uLL);
  v6[4] = v4;
  v6[5] = 1;
  int v7 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    int v7 = malloc_default_zone();
  }
  unsigned int v8 = malloc_zone_malloc(v7, 0x10uLL);
  *((void *)v6 + _Block_object_dispose(va, 8) = v8;
  v8[1] = 0LL;
  uint64_t v9 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (a2)
  {
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v9 = malloc_default_zone();
    }
    useconds_t v10 = malloc_zone_calloc(v9, 1uLL, v4);
  }

  else
  {
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v9 = malloc_default_zone();
    }
    useconds_t v10 = malloc_zone_malloc(v9, v4);
  }

  *((void *)v6 + 10) = v10;
  **((void **)v6 + _Block_object_dispose(va, 8) = v10;
  *((void *)v6 + 11) = *((void *)v6 + 10);
  v6[6] = 0;
  *((void *)v6 + 4) = 0LL;
  uint64_t v11 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v11 = malloc_default_zone();
  }
  int v12 = malloc_zone_malloc(v11, 0x10uLL);
  *((void *)v6 + 9) = v12;
  void *v12 = v4;
  v12[1] = 0LL;
  uint64_t v13 = (void *)*((void *)v6 + 8);
  *((void *)v6 + 11) = *v13;
  uint64_t v14 = (_OWORD *)(v13[v6[6]] + *((void *)v6 + 4));
  *uint64_t v14 = 0u;
  v14[1] = 0u;
  v6[7] = -1;
  *(_DWORD *)uint64_t v14 = -1;
  if (a2) {
    int v15 = 4;
  }
  else {
    int v15 = 0;
  }
  v6[12] = v6[12] & 0xFFFFFFFB | v15;
  return v6;
}

LABEL_20:
    *(_DWORD *)(v12 + _Block_object_dispose(va, 8) = v14;
    uint64_t v118 = v10;
    if (v114 == 16)
    {
      *(void *)(v12 + 24) = 0LL;
      if ((v8 & 2) == 0)
      {
        plan_for_entity = (int *)_sql_read_only_fetch_plan_for_entity((unint64_t *)v13);
        goto LABEL_26;
      }
    }

    else
    {
      uint64_t v17 = sqlite3_column_int64(*(sqlite3_stmt **)(v4 + 80), 1);
      *(void *)(v12 + 24) = v17;
      if (!v17)
      {
        char v107 = @"The database appears corrupt.  (invalid primary key)";
        goto LABEL_132;
      }

      if ((v8 & 2) == 0)
      {
        plan_for_entity = (int *)_sql_fetch_plan_for_entity((unint64_t *)v13);
LABEL_26:
        uint64_t v18 = *plan_for_entity;
        char v119 = plan_for_entity[1];
        if ((_DWORD)v119)
        {
          int v116 = v12;
          unsigned int v19 = 0LL;
          uint64_t v20 = plan_for_entity + 3;
          while (1)
          {
            double v21 = *((unsigned __int8 *)v20 + 8) - 2;
            if (v21 > 6) {
              BOOL v22 = 3LL;
            }
            else {
              BOOL v22 = qword_1868D6198[(char)v21];
            }
            unsigned int v23 = ~v22;
            unsigned int v24 = (v22 + *(void *)(a2 + 88)) & ~v22;
            if (*(void *)(a2 + 80) - v24 + *(int *)(a2 + 16) > 15)
            {
              *(void *)(a2 + 8_Block_object_dispose(va, 8) = v24;
            }

            else
            {
              fetchResultSetReallocCurrentRow(a2, 16);
              double v25 = *(void *)(a2 + 80);
              uint64_t v26 = (v22 + *(void *)(a2 + 88)) & v23;
              *(void *)(a2 + 8_Block_object_dispose(va, 8) = v26;
              if (v25 - v26 + *(int *)(a2 + 16) <= 15)
              {
                uint64_t v27 = [NSString stringWithUTF8String:"less space allocated for fetch result (%ld) than we asked for (%u)!"];
                _NSCoreDataLog( 17LL,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  *(void *)(a2 + 80) - *(void *)(a2 + 88) + *(int *)(a2 + 16));
                uint64_t v34 = (os_log_s *)__pflogFaultLog;
                if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                {
                  uint64_t v35 = *(void *)(a2 + 80) - *(void *)(a2 + 88) + *(int *)(a2 + 16);
                  *(_DWORD *)buf = 134218240;
                  char v121 = v35;
                  uint64_t v122 = 1024;
                  uint64_t v123 = 16;
                  _os_log_fault_impl( &dword_186681000,  v34,  OS_LOG_TYPE_FAULT,  "CoreData: less space allocated for fetch result (%ld) than we asked for (%u)!",  buf,  0x12u);
                }
              }
            }

            [*(id *)(v20 + 3) propertyDescription];
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0) {
              objc_msgSend((id)objc_msgSend(*(id *)(v20 + 3), "propertyDescription"), "isOptional");
            }
            switch(*((_BYTE *)v20 + 8))
            {
              case 1:
                unsigned int v62 = sqlite3_column_int(*(sqlite3_stmt **)(v4 + 80), *v20);
                uint64_t v63 = v62;
                uint64_t v64 = *(_BYTE **)(a2 + 88);
                if ((v20[1] & 1) == 0) {
                  goto LABEL_98;
                }
                if (v62) {
                  unsigned int v65 = 1;
                }
                else {
                  unsigned int v65 = sqlite3_column_type(*(sqlite3_stmt **)(v4 + 80), *v20) != 5;
                }
                *uint64_t v64 = !v65;
                id v94 = *(void *)(a2 + 88) + 1LL;
                *(void *)(a2 + 8_Block_object_dispose(va, 8) = v94;
                if (!*v64)
                {
                  uint64_t v64 = (_BYTE *)((v94 + v22) & v23);
LABEL_98:
                  *(_DWORD *)uint64_t v64 = v63;
                  uint64_t v89 = v64 + 4;
                  goto LABEL_99;
                }

                goto LABEL_100;
              case 2:
              case 3:
                uint64_t v45 = sqlite3_column_int64(*(sqlite3_stmt **)(v4 + 80), *v20);
                uint64_t v46 = v45;
                uint64_t v47 = *(_BYTE **)(a2 + 88);
                if ((v20[1] & 1) == 0) {
                  goto LABEL_83;
                }
                if (v45) {
                  double v48 = 1;
                }
                else {
                  double v48 = sqlite3_column_type(*(sqlite3_stmt **)(v4 + 80), *v20) != 5;
                }
                *uint64_t v47 = !v48;
                BOOL v88 = *(void *)(a2 + 88) + 1LL;
                *(void *)(a2 + 8_Block_object_dispose(va, 8) = v88;
                if (!*v47)
                {
                  uint64_t v47 = (_BYTE *)((v88 + v22) & v23);
LABEL_83:
                  *(void *)uint64_t v47 = v46;
                  uint64_t v89 = v47 + 8;
LABEL_99:
                  *(void *)(a2 + 8_Block_object_dispose(va, 8) = v89;
                }

                goto LABEL_100;
              case 4:
              case 5:
              case 6:
              case 9:
              case 0xC:
              case 0xD:
              case 0xE:
                uint64_t v36 = sqlite3_column_text(*(sqlite3_stmt **)(v4 + 80), *v20);
                int v37 = (const char *)v36;
                if ((v20[1] & 1) == 0) {
                  goto LABEL_48;
                }
                uint64_t v38 = *(BOOL **)(a2 + 88);
                uint64_t v39 = v36 && *v36 || sqlite3_column_type(*(sqlite3_stmt **)(v4 + 80), *v20) != 5;
                *uint64_t v38 = !v39;
                int v40 = *(void *)(a2 + 88) + 1LL;
                *(void *)(a2 + 8_Block_object_dispose(va, 8) = v40;
                if (!*v38)
                {
                  *(void *)(a2 + 8_Block_object_dispose(va, 8) = (v40 + v22) & v23;
LABEL_48:
                  if (v37)
                  {
                    uint64_t v41 = strlen(v37) + 1;
                    uint64_t v42 = *(int **)(a2 + 88);
                    *uint64_t v42 = v41;
                    uint64_t v43 = v42 + 1;
                    *(void *)(a2 + 8_Block_object_dispose(va, 8) = v43;
                    uint64_t v44 = v41;
                    if (*(void *)(a2 + 80) - (void)v43 + *(int *)(a2 + 16) < v41)
                    {
                      fetchResultSetReallocCurrentRow(a2, v41);
                      uint64_t v43 = *(void **)(a2 + 88);
                    }

                    memcpy(v43, v37, v44);
                    *(void *)(a2 + 88) += v44;
                  }

                  else
                  {
                    uint64_t v53 = [NSString stringWithFormat:@"Row (pk = %lld) for entity '%@' is missing mandatory text data for property '%@'", *(void *)(v116 + 24), objc_msgSend( (id)objc_msgSend( (id)_sqlEntityForEntityID(v117, *(unsigned int *)(v116 + 8)), "entityDescription"), "name"), objc_msgSend((id)objc_msgSend(*(id *)(v20 + 3), "propertyDescription"), "name")];
                    _NSCoreDataLog(1LL, (uint64_t)@"%@\n", v54, v55, v56, v57, v58, v59, v53);
                    int v60 = *(unsigned int *)(a2 + 24);
                    if ((v60 & 0x80000000) != 0) {
                      CFIndex v61 = 0LL;
                    }
                    else {
                      CFIndex v61 = *(void *)(*(void *)(a2 + 64) + 8 * v60) + *(void *)(a2 + 32);
                    }
                    char v119 = 0LL;
                    *(_DWORD *)CFIndex v61 = -1;
                    *(void *)(v61 + 24) = 0LL;
                    *(_DWORD *)(v61 + _Block_object_dispose(va, 8) = 0;
                    --*(_DWORD *)a2;
                    *(void *)(a2 + 8_Block_object_dispose(va, 8) = v61;
                    uint64_t v9 = (v9 - 1);
                  }
                }

                goto LABEL_100;
              case 7:
              case 8:
                uint64_t v49 = sqlite3_column_double(*(sqlite3_stmt **)(v4 + 80), *v20);
                id v50 = v49;
                uint64_t v51 = *(double **)(a2 + 88);
                if ((v20[1] & 1) == 0) {
                  goto LABEL_87;
                }
                uint64_t v52 = v49 != 0.0 || sqlite3_column_type(*(sqlite3_stmt **)(v4 + 80), *v20) != 5;
                *(_BYTE *)uint64_t v51 = !v52;
                size_t v90 = *(void *)(a2 + 88) + 1LL;
                *(void *)(a2 + 8_Block_object_dispose(va, 8) = v90;
                if (!*(_BYTE *)v51)
                {
                  uint64_t v51 = (double *)((v90 + v22) & v23);
LABEL_87:
                  *uint64_t v51 = v50;
                  *(void *)(a2 + 8_Block_object_dispose(va, 8) = v51 + 1;
                }

                goto LABEL_100;
              case 0x10:
                if (!v111) {
                  goto LABEL_75;
                }
                if (objc_msgSend((id)objc_msgSend(*(id *)(v20 + 3), "propertyDescription"), "_isFileBackedFuture")) {
                  goto LABEL_75;
                }
                unsigned int v66 = (const char *)sqlite3_column_blob(*(sqlite3_stmt **)(v4 + 80), *v20);
                uint64_t v67 = sqlite3_column_bytes(*(sqlite3_stmt **)(v4 + 80), *v20);
                unsigned int v68 = (v67 - 1);
                if (v67 < 1) {
                  goto LABEL_75;
                }
                uint64_t v109 = v67;
                uint64_t result = [MEMORY[0x1896078A8] defaultManager];
                uint64_t v69 = *(unsigned __int8 *)v66;
                id v110 = v9;
                if (v69 == 1)
                {
                  uint64_t v76 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                  unint64_t v95 = *(void *)(v4 + 16);
                  if (v95) {
                    uint64_t v78 = (*(_DWORD *)(v95 + 200) >> 2) & 7;
                  }
                  else {
                    uint64_t v78 = 0LL;
                  }
                  uint64_t v79 = v109;
                  uint64_t v80 = v66;
                  uint64_t v81 = 0LL;
                  int v82 = 0LL;
                }

                else
                {
                  if (v69 == 3)
                  {
                    __break(1u);
                    return result;
                  }

                  uint64_t v108 = v66;
                  CFAllocatorRef v70 = objc_msgSend( (id)result,  "stringWithFileSystemRepresentation:length:",  v66 + 1,  strnlen(v66 + 1, v68));
                  uint64_t v71 = (void *)[*(id *)(v4 + 16) externalDataReferencesDirectory];
                  uint64_t v72 = *(unint64_t **)(v4 + 16);
                  if (v72)
                  {
                    if (!atomic_load(v72 + 21)) {
                      [*(id *)(v4 + 16) externalDataReferencesDirectory];
                    }
                    uint64_t v72 = (unint64_t *)atomic_load(v72 + 22);
                  }

                  uint64_t v74 = [v71 stringByAppendingPathComponent:v70];
                  uint64_t v75 = [v72 stringByAppendingPathComponent:v70];
                  uint64_t v76 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                  uint64_t v77 = *(void *)(v4 + 16);
                  if (v77) {
                    uint64_t v78 = (*(_DWORD *)(v77 + 200) >> 2) & 7;
                  }
                  else {
                    uint64_t v78 = 0LL;
                  }
                  uint64_t v79 = v109;
                  uint64_t v80 = v108;
                  uint64_t v81 = v74;
                  int v82 = v75;
                }

                unint64_t v96 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v76,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  v80,  v79,  v81,  v82,  v78);
                uint64_t v97 = -[_PFExternalReferenceData length](v96, "length");
                uint64_t v98 = v97;
                uint64_t v99 = *(_BYTE **)(a2 + 88);
                if ((v20[1] & 1) == 0) {
                  goto LABEL_111;
                }
                if (v97) {
                  uint64_t v100 = 1;
                }
                else {
                  uint64_t v100 = sqlite3_column_type(*(sqlite3_stmt **)(v4 + 80), *v20) != 5;
                }
                *uint64_t v99 = !v100;
                unint64_t v101 = *(void *)(a2 + 88) + 1LL;
                *(void *)(a2 + 8_Block_object_dispose(va, 8) = v101;
                if (!*v99)
                {
                  uint64_t v99 = (_BYTE *)((v101 + v22) & v23);
LABEL_111:
                  *(_DWORD *)uint64_t v99 = v98;
                  uint64_t v102 = v99 + 4;
                  *(void *)(a2 + 8_Block_object_dispose(va, 8) = v102;
                  if (*(void *)(a2 + 80) - (void)v102 + *(int *)(a2 + 16) < v98)
                  {
                    fetchResultSetReallocCurrentRow(a2, v98);
                    uint64_t v102 = *(void **)(a2 + 88);
                  }

                  memcpy(v102, -[_PFExternalReferenceData bytes](v96, "bytes"), v98);
                  *(void *)(a2 + 88) += v98;
                }

                uint64_t v9 = v110;
LABEL_100:
                ++v19;
                v20 += 6;
                if (v19 >= v119) {
                  goto LABEL_117;
                }
                break;
              default:
LABEL_75:
                int v83 = v9;
                unsigned int v84 = sqlite3_column_bytes(*(sqlite3_stmt **)(v4 + 80), *v20);
                id v85 = v84;
                uint64_t v86 = *(_BYTE **)(a2 + 88);
                if ((v20[1] & 1) == 0) {
                  goto LABEL_91;
                }
                if (v84) {
                  uint64_t v87 = 1;
                }
                else {
                  uint64_t v87 = sqlite3_column_type(*(sqlite3_stmt **)(v4 + 80), *v20) != 5;
                }
                *uint64_t v86 = !v87;
                uint64_t v91 = *(void *)(a2 + 88) + 1LL;
                *(void *)(a2 + 8_Block_object_dispose(va, 8) = v91;
                if (!*v86)
                {
                  uint64_t v86 = (_BYTE *)((v91 + v22) & v23);
LABEL_91:
                  *(_DWORD *)uint64_t v86 = v85;
                  int v92 = v86 + 4;
                  *(void *)(a2 + 8_Block_object_dispose(va, 8) = v92;
                  if (*(void *)(a2 + 80) - (void)v92 + *(int *)(a2 + 16) < v85)
                  {
                    fetchResultSetReallocCurrentRow(a2, v85);
                    int v92 = *(void **)(a2 + 88);
                  }

                  char v93 = sqlite3_column_blob(*(sqlite3_stmt **)(v4 + 80), *v20);
                  memcpy(v92, v93, v85);
                  *(void *)(a2 + 88) += v85;
                }

                uint64_t v9 = v83;
                goto LABEL_100;
            }
          }
        }
      }
    }

    unsigned int v16 = 0LL;
    goto LABEL_11;
  }

  unsigned int v19 = [a5 _setQueryGenerationFromToken:v18 error:&v30];

  if ((v19 & 1) == 0)
  {
    uint64_t v20 = v30;
    if (!v30) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }

    uint64_t v14 = 0LL;
    goto LABEL_11;
  }

  uint64_t v17 = [a4 _setQueryGenerationFromToken:v16 error:&v28];

  if ((v17 & 1) == 0)
  {
    uint64_t v18 = v28;
    if (!v28) {
      goto LABEL_15;
    }
    goto LABEL_18;
  }

        __clrex();
        os_unfair_lock_unlock((os_unfair_lock_t)&_extraRetainsLock);
        continue;
      }

      break;
    }

  uint64_t v11 = 1;
LABEL_21:
  int v15 = v26;
  if (a3 && v26) {
    *a3 = v26;
  }
  [0 drain];
  unsigned int v16 = 0LL;
  uint64_t v17 = v26;
  uint64_t v18 = v5;
  if (v11) {
    return v5;
  }
  else {
    return 0LL;
  }
}

    uint64_t v9 = v13;
    useconds_t v10 = v14;
    if (count <= v12) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }

  int v15 = v9;
  while (v8[v15] != a3 && (v5(a3, sel_isEqual_) & 1) == 0)
  {
    if (v13 == ++v15) {
      goto LABEL_20;
    }
  }

  return v15;
}

      uint64_t v14 = 0;
      goto LABEL_34;
    }

      if (a2)
      {
        if ((v12 & 1) == 0) {
          *a2 = v16;
        }
      }

      if (!v12) {
        goto LABEL_29;
      }
      uint64_t v14 = *(_DWORD *)(a1 + 40);
      *(_DWORD *)(a1 + 40) = v14 & 0xFFFFFDFF | ((v8 == 998) << 9);
      if (v8 == 1000)
      {
        objc_exception_throw((id)objc_msgSend( MEMORY[0x189603F70],  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A58],  @"Failed to process pending changes before save.  The context is still dirty after 1000 attempts.  Typically this recursive dirtying is caused by a bad validation method, -willSave, or notification handler.",  0));
        __break(1u);
        return;
      }

      *(_DWORD *)(a1 + 40) = v14 & 0xFFFFFDF7 | ((v8 == 998) << 9);
      --v7;
      ++v8;
      if ((v14 & 0x100) == 0) {
        goto LABEL_29;
      }
    }
  }

    uint64_t v18 = (void *)objc_msgSend( (id)objc_msgSend(v7, "stages"),  "subarrayWithRange:",  v10,  objc_msgSend((id)objc_msgSend(v7, "stages"), "count") - v10);
    goto LABEL_21;
  }

  return v3;
}

        if ((a3 & 1) != 0)
        {
          _NSCoreDataLog(2LL, (uint64_t)@"PostSaveMaintenance: Full Vacuum", v8, v9, v10, v11, v12, v13, v33);
          unsigned int v19 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:](a1, @"vacuum");
          if (v19) {
            CFRelease(v19);
          }
          goto LABEL_43;
        }

        uint64_t v20 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:](a1, @"pragma page_count");
        double v21 = v20;
        if (v20)
        {
          if (CFArrayGetCount(v20))
          {
            BOOL v22 = *(void *)CFArrayGetValueAtIndex(v21, 0LL);
            if (!v22)
            {
              __CFString *v16 = 10LL;
              CFRelease(v21);
              double v21 = 0LL;
            }

            unsigned int v23 = *(void *)CFArrayGetValueAtIndex(v21, 1LL);
            if (v21) {
              CFRelease(v21);
            }
            if (v22)
            {
              unsigned int v24 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:](a1, @"pragma freelist_count");
              double v25 = v24;
              if (v24)
              {
                if (CFArrayGetCount(v24))
                {
                  uint64_t v26 = *(void *)CFArrayGetValueAtIndex(v25, 0LL);
                  if (!v26)
                  {
                    __CFString *v16 = 10LL;
                    CFRelease(v25);
                    double v25 = 0LL;
                  }

                  uint64_t v27 = *(void *)CFArrayGetValueAtIndex(v25, 1LL);
                  if (v25) {
                    CFRelease(v25);
                  }
                  __CFString *v16 = 10LL;
                  if (v27)
                  {
                    if ((a2 & 1) != 0)
                    {
                      _NSCoreDataLog( 4LL,  (uint64_t)@"PostSaveMaintenance: forced incremental_vacuum - %ld",  v8,  v9,  v10,  v11,  v12,  v13,  v27);
                      char v33 = v27;
                      uint64_t v28 = (void *)[objc_alloc(NSString) initWithFormat:@"pragma incremental_vacuum(%d)"];
                      uint64_t v29 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:](a1, v28);

                      if (!v29) {
                        goto LABEL_45;
                      }
                      goto LABEL_39;
                    }

                    if (v26)
                    {
                      uint64_t v30 = (double)(v23 - v27) / (double)v23;
                      if (v27 > 1023 || v30 <= 0.85)
                      {
                        uint64_t v31 = v30 >= 0.4 ? v27 / 5 : v27 - (v23 - v27);
                        _NSCoreDataLog( 9LL,  (uint64_t)@"PostSaveMaintenance: incremental_vacuum with freelist_count - %ld and pages_to_free %lld",  v8,  v9,  v10,  v11,  v12,  v13,  v27);
                        char v33 = v31;
                        int v32 = (void *)[objc_alloc(NSString) initWithFormat:@"pragma incremental_vacuum(%d)"];
                        uint64_t v29 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:](a1, v32);

                        if (v29) {
LABEL_39:
                        }
                          CFRelease(v29);
                      }
                    }
                  }

    ++v11;
  }

  while (v7 != v11);
  unsigned int v16 = -[NSSQLBoundedByIntermediate initWithWorkingEntity:target:bounds:scope:]( [NSSQLBoundedByIntermediate alloc],  "initWithWorkingEntity:target:bounds:scope:",  objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v34, "objectForKey:", @"persistentStore"), "model"),  "entityNamed:",  objc_msgSend(v9, "name")),  v14,  *(void *)(a1 + 40),  a1);
  uint64_t v17 = -[NSSQLBoundedByIntermediate generateSQLStringInContext:](v16, "generateSQLStringInContext:", v34);

  if (!v17) {
    return 0LL;
  }
  if (v7 == 1)
  {
    uint64_t v18 = (id)[objc_alloc(MEMORY[0x189607940]) initWithFormat:@"%@.Z_PK IN ", objc_msgSend((id)a1, "governingAliasForKeypathExpression:", *(void *)(a1 + 32))];
    if (!v18) {
      goto LABEL_44;
    }
LABEL_43:
    [v18 appendFormat:@"(%@) ", v17];
    goto LABEL_44;
  }

  uint64_t v31 = [(id)objc_msgSend( (id)objc_msgSend(v5 subarrayWithRange:0, v35), "componentsJoinedByString:", @"."), "stringByAppendingFormat:", @".%@", objc_msgSend(v10, "firstObject")];
  int v32 = -[NSSQLExpressionIntermediate initWithExpression:allowToMany:inScope:]( [NSSQLKeypathExpressionIntermediate alloc],  "initWithExpression:allowToMany:inScope:",  [MEMORY[0x189607878] expressionForKeyPath:v31],  1,  a1);
  char v33 = v32;
  if (v32) {
    *(&v32->super._allowToMany + 1) = 1;
  }
  uint64_t v18 = -[NSSQLKeypathExpressionIntermediate generateSQLStringInContext:](v32, "generateSQLStringInContext:", v34);

  if (v18)
  {
    [v18 appendString:@" IN "];
    goto LABEL_43;
  }

        if (v10 == ++v13)
        {
          useconds_t v10 = [v8 countByEnumeratingWithState:&v19 objects:v23 count:16];
          uint64_t result = 1;
          if (v10) {
            goto LABEL_8;
          }
          return result;
        }
      }

      uint64_t v17 = [v15 destinationEntity];
      if (v11) {
        return 0;
      }
      int v5 = (id *)v17;
      uint64_t v11 = 1LL;
      goto LABEL_20;
    }

    return 1;
  }

  else
  {
    v18.receiver = self;
    v18.super_class = (Class)&OBJC_CLASS___NSSQLSubqueryExpressionIntermediate;
    return -[NSSQLIntermediate keypathExpressionIsSafeLHSForIn:](&v18, sel_keypathExpressionIsSafeLHSForIn_, a3);
  }

  unsigned int v16 = 1;
  while (1)
  {
    Class = objc_getClass(__str);
    if (!Class) {
      break;
    }
    uint64_t v11 = Class;
    uint64_t v18 = v16;
LABEL_26:
    BOOL v22 = (unsigned int *)object_getIndexedIvars(v11);
    if (!*((void *)v22 + 1))
    {
      while (1)
      {
        unsigned int v23 = __ldaxr(v22);
        if (v23 != -1) {
          break;
        }
        if (!__stlxr(0, v22)) {
          goto LABEL_17;
        }
      }

      __clrex();
    }

    unsigned int v24 = class_getName((Class)a1);
    unsigned int v16 = v18 + 1;
    snprintf(__str, 0x100uLL, "%s_%x", v24, v18);
  }

  while (1)
  {
    ClassPair = objc_allocateClassPair((Class)a1, __str, 0x18uLL);
    if (ClassPair) {
      break;
    }
    uint64_t v20 = class_getName((Class)a1);
    uint64_t v18 = v16 + 1;
    snprintf(__str, 0x100uLL, "%s_%x", v20, v16);
    double v21 = objc_getClass(__str);
    ++v16;
    if (v21)
    {
      uint64_t v11 = v21;
      goto LABEL_26;
    }
  }

  uint64_t v11 = ClassPair;
  double v25 = object_getClass(ClassPair);
  ClassMethod = class_getClassMethod(v11, sel__retain_1);
  Implementation = method_getImplementation(ClassMethod);
  TypeEncoding = method_getTypeEncoding(ClassMethod);
  class_addMethod(v25, sel_retain, Implementation, TypeEncoding);
  uint64_t v29 = class_getClassMethod(v11, sel__release_1);
  uint64_t v30 = method_getImplementation(v29);
  uint64_t v31 = method_getTypeEncoding(v29);
  class_addMethod(v25, sel_release, v30, v31);
  objc_registerClassPair(v11);
  CFArrayAppendValue((CFMutableArrayRef)qword_18C4ABC90, v11);
LABEL_33:
  int v32 = object_getIndexedIvars(v11);
  if (!v32[1])
  {
    char v33 = v32;
    *(_DWORD *)int v32 = 0;
    v32[1] = a3;
    uint64_t v34 = (void *)objc_msgSend((id)objc_msgSend(a3, "identifier"), "copy");
    if (v34)
    {
      uint64_t v35 = v34;
      v33[2] = CFRetain(v34);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&_MergedGlobals_7);
  return v11;
}

    LOBYTE(v5) = 0;
    return v5;
  }

  if (a3) {
    int v7 = *((void *)a3 + 2);
  }
  else {
    int v7 = 0LL;
  }
  LOBYTE(v5) = -[NSString isEqualToString:](keypath, "isEqualToString:", v7);
  return v5;
}

  uint64_t result = [*(id *)(a1 + 48) hasChanges];
  if ((_DWORD)result)
  {
    uint64_t result = [*(id *)(a1 + 48) save:v34];
    if ((result & 1) == 0)
    {
      double v21 = (void *)MEMORY[0x186E3E5D8]();
      BOOL v22 = __ckLoggingOverride;
      unsigned int v23 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Failed to save metadata while marking zones needing recovery from Manatee identity loss: %@"];
      _NSCoreDataLog( v22 != 0,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  (uint64_t)"-[NSCloudKitMirroringDelegate _markZonesNeedingRecoveryFromManateeIdentityLoss:databaseScope:inStore:er ror:]_block_invoke");
      objc_autoreleasePoolPop(v21);
      uint64_t result = (uint64_t)v34[0];
      *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL) = result;
      *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
    }
  }

  return result;
}

    objc_initWeak(&location, v2);
    unsigned int v8 = objc_alloc(&OBJC_CLASS___PFCloudKitThrottledNotificationObserver);
    uint64_t v9 = MEMORY[0x1895F87A8];
    v34[0] = MEMORY[0x1895F87A8];
    v34[1] = 3221225472LL;
    v34[2] = __33__PFApplicationStateMonitor_init__block_invoke;
    v34[3] = &unk_189EAB3A0;
    BOOL v22 = &v35;
    objc_copyWeak(&v35, &location);
    useconds_t v10 = -[PFCloudKitThrottledNotificationObserver initWithLabel:handlerBlock:]( v8,  "initWithLabel:handlerBlock:",  @"AppActivateObserver",  v34);
    v2->_appActivateLifecycleObserver = (PFCloudKitThrottledNotificationObserver *)v10;
    if (v10) {
      *(void *)(v10 + 32) = 1LL;
    }
    uint64_t v11 = objc_alloc(&OBJC_CLASS___PFCloudKitThrottledNotificationObserver);
    v32[0] = v9;
    v32[1] = 3221225472LL;
    v32[2] = __33__PFApplicationStateMonitor_init__block_invoke_2;
    v32[3] = &unk_189EAB3A0;
    unsigned int v23 = &v33;
    objc_copyWeak(&v33, &location);
    int v12 = -[PFCloudKitThrottledNotificationObserver initWithLabel:handlerBlock:]( v11,  "initWithLabel:handlerBlock:",  @"AppDeactivateObserver",  v32);
    v2->_appDeactivateLifecycleObserver = (PFCloudKitThrottledNotificationObserver *)v12;
    if (v12) {
      *(void *)(v12 + 32) = 1LL;
    }
    atomic_store(0, (unsigned int *)&v2->_transitionCounter);
    uint64_t v30 = 0u;
    uint64_t v31 = 0u;
    uint64_t v28 = 0u;
    uint64_t v29 = 0u;
    uint64_t v13 = +[_PFRoutines applicationActivateLifecyleNotifications]();
    uint64_t v14 = [v13 countByEnumeratingWithState:&v28 objects:v43 count:16];
    if (v14)
    {
      int v15 = *(void *)v29;
      do
      {
        for (unint64_t j = 0LL; j != v14; ++j)
        {
          if (*(void *)v29 != v15) {
            objc_enumerationMutation(v13);
          }
          objc_msgSend( (id)objc_msgSend(MEMORY[0x189607958], "defaultCenter", v22, v23),  "addObserver:selector:name:object:",  v2,  sel_applicationDidActivate_,  *(void *)(*((void *)&v28 + 1) + 8 * j),  0);
        }

        uint64_t v14 = [v13 countByEnumeratingWithState:&v28 objects:v43 count:16];
      }

      while (v14);
    }

    uint64_t v26 = 0u;
    uint64_t v27 = 0u;
    unsigned int v24 = 0u;
    double v25 = 0u;
    uint64_t v17 = +[_PFRoutines applicationDeactivateLifecyleNotifications]();
    uint64_t v18 = [v17 countByEnumeratingWithState:&v24 objects:v42 count:16];
    if (v18)
    {
      unsigned int v19 = *(void *)v25;
      do
      {
        for (uint64_t k = 0LL; k != v18; ++k)
        {
          if (*(void *)v25 != v19) {
            objc_enumerationMutation(v17);
          }
          objc_msgSend( (id)objc_msgSend(MEMORY[0x189607958], "defaultCenter", v22),  "addObserver:selector:name:object:",  v2,  sel_applicationWillDeactivate_,  *(void *)(*((void *)&v24 + 1) + 8 * k),  0);
        }

        uint64_t v18 = [v17 countByEnumeratingWithState:&v24 objects:v42 count:16];
      }

      while (v18);
    }

    objc_destroyWeak(v23);
    objc_destroyWeak(v22);
    objc_destroyWeak(&location);
  }

  return v2;
}

    if (a5)
    {
      LOBYTE(v9) = 0;
      *a5 = v14;
      return v9;
    }

void fetchResultSetDeallocate(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 20);
  if ((_DWORD)v2)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = 8 * v2;
    do
    {
      int v5 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        int v5 = malloc_default_zone();
      }
      malloc_zone_free(v5, *(void **)(*(void *)(a1 + 64) + v3));
      v3 += 8LL;
    }

    while (v4 != v3);
  }

  double v6 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    double v6 = malloc_default_zone();
  }
  malloc_zone_free(v6, *(void **)(a1 + 64));
  int v7 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    int v7 = malloc_default_zone();
  }
  malloc_zone_free(v7, *(void **)(a1 + 72));
  unsigned int v8 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    unsigned int v8 = malloc_default_zone();
  }
  malloc_zone_free(v8, (void *)a1);
}

void PF_FREE_OBJECT_ARRAY(void *ptr)
{
  uint64_t v2 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v2 = malloc_default_zone();
  }
  malloc_zone_free(v2, ptr);
}

void sub_18669CEB4(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18669CE90LL);
  }

  JUMPOUT(0x18669CE3CLL);
}

CFIndex _PFCMT_GetCount(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = (const __CFDictionary *)a1[2];
  if (v2) {
    CFIndex Count = CFDictionaryGetCount(v2);
  }
  else {
    CFIndex Count = 0LL;
  }
  if (a1[3])
  {
    unint64_t v4 = a1[1];
    if (v4)
    {
      for (unint64_t i = 0LL; i < v4; ++i)
      {
        double v6 = *(const __CFDictionary **)(a1[3] + 8 * i);
        if (v6)
        {
          Count += CFDictionaryGetCount(v6);
          unint64_t v4 = a1[1];
        }
      }
    }
  }

  if (a1[4])
  {
    unint64_t v7 = a1[1];
    if (v7)
    {
      for (unint64_t j = 0LL; j < v7; ++j)
      {
        uint64_t v9 = *(const __CFDictionary **)(a1[4] + 8 * j);
        if (v9)
        {
          Count += CFDictionaryGetCount(v9);
          unint64_t v7 = a1[1];
        }
      }
    }
  }

  return Count;
}

void _PFCMT_RemoveAllValues(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (__CFDictionary *)a1[2];
    if (v2) {
      CFDictionaryRemoveAllValues(v2);
    }
    if (a1[3])
    {
      unint64_t v3 = a1[1];
      if (v3)
      {
        for (unint64_t i = 0LL; i < v3; ++i)
        {
          int v5 = *(__CFDictionary **)(a1[3] + 8 * i);
          if (v5)
          {
            CFDictionaryRemoveAllValues(v5);
            unint64_t v3 = a1[1];
          }
        }
      }
    }

    if (a1[4])
    {
      unint64_t v6 = a1[1];
      if (v6)
      {
        for (unint64_t j = 0LL; j < v6; ++j)
        {
          unsigned int v8 = *(__CFDictionary **)(a1[4] + 8 * j);
          if (v8)
          {
            CFDictionaryRemoveAllValues(v8);
            unint64_t v6 = a1[1];
          }
        }
      }
    }
  }

LABEL_5:
    return 0LL;
  }

  return v5;
}

    unsigned int v8 = 0LL;
  }

  *(void *)(v247 + 40) = 0LL;
  uint64_t v9 = *(unsigned __int8 *)(v228 + 24);
  _Block_object_dispose(v246, 8);
  _Block_object_dispose(&v227, 8);
  if (!v9)
  {
LABEL_70:
    uint64_t v11 = v8;
    goto LABEL_71;
  }

  *a3 = 1;
  if (v6) {
    goto LABEL_9;
  }
  *(void *)v239 = 0LL;
  *(void *)&v239[8] = v239;
  *(void *)&v239[16] = 0x2020000000LL;
  LOBYTE(v240) = 1;
  v227 = 0LL;
  v228 = (uint64_t)&v227;
  v229 = 0x3052000000LL;
  v230 = __Block_byref_object_copy__25;
  v231 = __Block_byref_object_dispose__25;
  v232 = 0LL;
  int v12 = *(void **)(v4 + 8);
  if (v12) {
    uint64_t v13 = (void *)v12[10];
  }
  else {
    uint64_t v13 = 0LL;
  }
  uint64_t v14 = (id)objc_msgSend( v13,  "containerWithIdentifier:options:",  objc_msgSend(v12, "containerIdentifier"),  objc_msgSend(*(id *)(v4 + 8), "containerOptions"));
  -[PFCloudKitSetupAssistant beginActivityForPhase:](v4, 2LL);
  *(void *)buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x3052000000LL;
  v275 = __Block_byref_object_copy__25;
  v276 = __Block_byref_object_dispose__25;
  v277 = 0LL;
  int v15 = (void (*)(uint64_t))*(id *)(v4 + 56);
  *(void *)v246 = MEMORY[0x1895F87A8];
  v247 = 3221225472LL;
  v248 = (uint64_t)__48__PFCloudKitSetupAssistant__checkAccountStatus___block_invoke;
  v249 = (void (*)(uint64_t, uint64_t))&unk_189EA9CD8;
  v250 = v15;
  v251 = &v227;
  v252 = (uint64_t *)buf;
  v253 = v239;
  -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v15, (uint64_t)v246);
  if (*(_BYTE *)(*(void *)&v239[8] + 24LL))
  {
    if (v14)
    {
      unsigned int v16 = *(dispatch_semaphore_s **)(v4 + 48);
      uint64_t v17 = [*(id *)(v4 + 8) useDeviceToDeviceEncryption];
      uint64_t v18 = *(void **)(v4 + 56);
      if (v18) {
        uint64_t v18 = (void *)v18[6];
      }
      unsigned int v19 = v18;
      *(void *)v259 = MEMORY[0x1895F87A8];
      *(void *)&v259[8] = 3221225472LL;
      *(void *)&v259[16] = __48__PFCloudKitSetupAssistant__checkAccountStatus___block_invoke_31;
      v260 = &unk_189EA9D28;
      LOBYTE(v267) = v17;
      v265 = (uint64_t)buf;
      v266 = (uint64_t)&v227;
      v261 = v19;
      v262 = (uint64_t *)v4;
      v263 = (uint64_t *)v16;
      v264 = v239;
      [v14 accountInfoWithCompletionHandler:v259];
      dispatch_semaphore_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
    }

    else
    {
      *(_BYTE *)(*(void *)&v239[8] + 24LL) = 0;
      uint64_t v29 = (void *)MEMORY[0x189607870];
      *(void *)v272 = *MEMORY[0x1896075F0];
      uint64_t v30 = (void *)NSString;
      v225 = [*(id *)(v4 + 8) containerIdentifier];
      *(void *)v259 = [v30 stringWithFormat:@"Failed to get a container back for the identifier: %@"];
      uint64_t v31 = [MEMORY[0x189603F68] dictionaryWithObjects:v259 forKeys:v272 count:1];
      int v32 = (id)[v29 errorWithDomain:*MEMORY[0x189607460] code:134400 userInfo:v31];
      *(void *)(v228 + 40) = v32;
    }
  }

  *(void *)(v4 + 16) = v14;
  if (*(_BYTE *)(*(void *)&v239[8] + 24LL))
  {
    char v33 = [*(id *)(v4 + 8) databaseScope];
    switch(v33)
    {
      case 3LL:
        uint64_t v34 = (id)[*(id *)(v4 + 16) sharedCloudDatabase];
        break;
      case 2LL:
        uint64_t v34 = (id)[*(id *)(v4 + 16) privateCloudDatabase];
        break;
      case 1LL:
        uint64_t v34 = (id)[*(id *)(v4 + 16) publicCloudDatabase];
        break;
      default:
        *(_BYTE *)(*(void *)&v239[8] + 24LL) = 0;
        uint64_t v43 = (void *)MEMORY[0x189607870];
        *(void *)v237 = *MEMORY[0x1896075F0];
        uint64_t v44 = (void *)NSString;
        v225 = softLinkCKDatabaseScopeString([*(id *)(v4 + 8) databaseScope]);
        v268 = [v44 stringWithFormat:@"CloudKit integration does not support the '%@' database scope."];
        uint64_t v45 = [MEMORY[0x189603F68] dictionaryWithObjects:&v268 forKeys:v237 count:1];
        uint64_t v46 = (id)[v43 errorWithDomain:*MEMORY[0x189607460] code:134400 userInfo:v45];
        *(void *)(v228 + 40) = v46;
        goto LABEL_36;
    }

    *(void *)(v4 + 24) = v34;
LABEL_36:
    if (*(_BYTE *)(*(void *)&v239[8] + 24LL) && !*(void *)(v4 + 24))
    {
      *(_BYTE *)(*(void *)&v239[8] + 24LL) = 0;
      uint64_t v47 = (void *)MEMORY[0x189607870];
      v258 = *MEMORY[0x1896075F0];
      double v48 = (void *)NSString;
      v225 = softLinkCKDatabaseScopeString([*(id *)(v4 + 8) databaseScope]);
      *(void *)v243 = [v48 stringWithFormat:@"Failed to get a database back for scope '%@' from container: %@"];
      uint64_t v49 = [MEMORY[0x189603F68] dictionaryWithObjects:v243 forKeys:&v258 count:1];
      id v50 = (id)[v47 errorWithDomain:*MEMORY[0x189607460] code:134400 userInfo:v49];
      *(void *)(v228 + 40) = v50;
    }
  }

  -[PFCloudKitSetupAssistant endActivityForPhase:withError:](v4, 2LL, *(void *)(v228 + 40));
  if (*(_BYTE *)(*(void *)&v239[8] + 24LL))
  {
LABEL_40:
    uint64_t v11 = v8;
    goto LABEL_42;
  }

  uint64_t v11 = (__CFString *)*(id *)(v228 + 40);
  if (!v11)
  {
    uint64_t v89 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v89,  v90,  v91,  v92,  v93,  v94,  v95,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
    unint64_t v96 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v278 = 136315394;
      *(void *)&v278[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m";
      *(_WORD *)&v278[12] = 1024;
      *(_DWORD *)&v278[14] = 479;
      _os_log_fault_impl( &dword_186681000,  v96,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v278,  0x12u);
    }

    goto LABEL_40;
  }

    v114 = 0u;
    unint64_t v115 = 0u;
    uint64_t v112 = 0u;
    v113 = 0u;
    unsigned int v8 = (void *)-[_NSSQLTableMigrationDescription _transformedManyToManys](v6);
    uint64_t result = [v8 countByEnumeratingWithState:&v112 objects:v143 count:16];
    if (!result) {
      return result;
    }
    uint64_t v9 = result;
    useconds_t v10 = &OBJC_IVAR____NSPersistentHistoryToken__storeTokens;
    uint64_t v11 = *(void *)v113;
    unint64_t v101 = *(void *)v113;
    uint64_t v98 = v8;
LABEL_7:
    int v12 = 0LL;
    uint64_t v100 = v9;
    while (1)
    {
      if (*(void *)v113 != v11) {
        objc_enumerationMutation(v8);
      }
      uint64_t v13 = *(__CFString **)(*((void *)&v112 + 1) + 8LL * (void)v12);
      obunint64_t j = v12;
      uint64_t v14 = (_BYTE *)-[NSSQLEntity _sqlPropertyWithRenamingIdentifier:]( objc_msgSend( (id)objc_msgSend( *(id *)(v6 + 64),  "objectForKey:",  objc_msgSend((id)-[__CFString entity](v13, "entity"), "name")),  "sourceEntity"),  objc_msgSend( (id)-[__CFString propertyDescription](v13, "propertyDescription"),  "renamingIdentifier"));
      unint64_t v3 = v14;
      if (!v14)
      {
        if (([0 isToMany] & 1) == 0) {
          goto LABEL_133;
        }
        goto LABEL_79;
      }

      if (v14[24] != 9)
      {
        if (([v14 isToMany] & 1) == 0 && v3[24] != 7) {
          goto LABEL_133;
        }
        goto LABEL_79;
      }

      int v15 = objc_msgSend((id)-[__CFString propertyDescription](v13, "propertyDescription"), "isOrdered");
      if (v15 == objc_msgSend((id)objc_msgSend(v3, "propertyDescription"), "isOrdered"))
      {
        unsigned int v16 = 0;
      }

      else if (objc_msgSend( (id)-[__CFString propertyDescription](v13, "propertyDescription"),  "isOrdered"))
      {
        unsigned int v16 = objc_msgSend((id)objc_msgSend(v3, "propertyDescription"), "isOrdered");
      }

      else
      {
        unsigned int v16 = 1;
      }

      length = (void *)v13[1].length;
      if (length)
      {
        uint64_t v18 = objc_msgSend((id)objc_msgSend(length, "propertyDescription"), "isOrdered");
        unsigned int v19 = v18;
        uint64_t v20 = (void *)*((void *)v3 + 7);
        if (!v20)
        {
          if ((v18 & 1) == 0)
          {
LABEL_34:
            LODWORD(length) = 0;
            goto LABEL_35;
          }

          goto LABEL_25;
        }
      }

      else
      {
        unsigned int v19 = 0;
        uint64_t v20 = (void *)*((void *)v3 + 7);
        if (!v20) {
          goto LABEL_35;
        }
      }

    -[NSManagedObjectContext executeFetchRequest:error:]( -[NSManagedObject managedObjectContext](self->_source, "managedObjectContext"),  "executeFetchRequest:error:",  v13,  0LL);
    goto LABEL_6;
  }

  char v33 = 12LL;
  int v15 = -[NSManagedObject valueForKey:](self->_source, "valueForKey:", v11);
  unsigned int v16 = [v15 count];
  if (length == 0x7FFFFFFFFFFFFFFFLL) {
    length = v16;
  }
  if (v16)
  {
    uint64_t v17 = v16;
    uint64_t v31 = &v29;
    int v32 = a4;
    uint64_t v18 = MEMORY[0x1895F8858](v16);
    uint64_t v20 = (char *)&v29 - v19;
    if (v18 > 0x200) {
      uint64_t v20 = (char *)NSAllocateScannedUncollectable();
    }
    else {
      bzero((char *)&v29 - v19, 8 * v18);
    }
    [v15 getObjects:v20];
    if (location >= v17 + location)
    {
      double v21 = 0LL;
    }

    else
    {
      uint64_t v29 = location;
      uint64_t v30 = a5;
      double v21 = 0LL;
      BOOL v22 = 8 * location;
      unsigned int v23 = v17;
      do
      {
        unsigned int v24 = *(_DWORD **)&v20[v22];
        double v25 = (v24[4] >> 15) & 7;
        if (v25) {
          uint64_t v26 = v25 == 5;
        }
        else {
          uint64_t v26 = 1;
        }
        if (!v26)
        {
          uint64_t v27 = (void *)[v24 objectID];
          if (([v27 isTemporaryID] & 1) == 0) {
            *(void *)&v20[8 * v21++] = v27;
          }
        }

        v22 += 8LL;
        --v23;
      }

      while (v23);
      if (v21) {
        double v21 = [objc_alloc(MEMORY[0x189603F18]) initWithObjects:v20 count:v21];
      }
      location = v29;
      a5 = v30;
    }

    if (v17 >= 0x201) {
      NSZoneFree(0LL, v20);
    }
    int v12 = location;
    if (objc_msgSend((id)v21, "count", v29, v30))
    {
      uint64_t v28 = -[NSDictionary objectForKey:]( -[NSEntityDescription relationshipsByName]( -[NSManagedObject entity](self->_source, "entity"),  "relationshipsByName"),  "objectForKey:",  v11);
      uint64_t v13 = objc_alloc_init(&OBJC_CLASS___NSFetchRequest);
      -[NSFetchRequest setEntity:](v13, "setEntity:", [v28 destinationEntity]);
      -[NSFetchRequest setPredicate:]( v13,  "setPredicate:",  [MEMORY[0x1896079C8] predicateWithFormat:@"self IN %@", v21]);
      -[NSFetchRequest setReturnsObjectsAsFaults:](v13, "setReturnsObjectsAsFaults:", 0LL);
      -[NSFetchRequest setIncludesPendingChanges:](v13, "setIncludesPendingChanges:", 0LL);
    }

    else
    {
      uint64_t v13 = 0LL;
    }

    a4 = v32;

    useconds_t v10 = v33;
    if (!v13) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  useconds_t v10 = v33;
LABEL_7:
  -[_NSFaultingMutableOrderedSet willChange](self);
  if ((*((_BYTE *)&self->super.super.super.isa + v10) & 8) != 0)
  {
    uint64_t v14 = (void *)[self->_realSet mutableCopy];

    self->_realSet = v14;
    *(_DWORD *)((char *)&self->super.super.super.isa + v10) &= ~8u;
  }

  if (length == 0x7FFFFFFFFFFFFFFFLL) {
    length = [self->_realSet count];
  }
  v34.receiver = self;
  v34.super_class = (Class)&OBJC_CLASS____NSFaultingMutableOrderedSet;
  -[_NSFaultingMutableOrderedSet sortRange:options:usingComparator:]( &v34,  sel_sortRange_options_usingComparator_,  location,  length,  a4,  a5);
}

  -[NSMutableDictionary setObject:forKey:]( self->_activitiesByPhaseNum,  "setObject:forKey:",  v6,  [MEMORY[0x189607968] numberWithUnsignedInteger:a3]);
  return v6;
}

LABEL_65:
            ;
          }
        }

        if ((v9 & 1) != 0 || ![v49 count])
        {
          uint64_t v31 = 0;
        }

        else
        {
          -[NSManagedObjectContext lockObjectStore](v7);
          uint64_t v30 = *(void **)(v7 + 32);
          uint64_t v31 = 1;
          int v32 = [(id)v7 _queryGenerationToken];
          [v30 managedObjectContextDidUnregisterObjectsWithIDs:v49 generation:v32];
        }

        if (v49) {

        }
        if (v31) {
          -[NSManagedObjectContext unlockObjectStore](v7);
        }
        if (v41) {

        }
        if (v44) {
          objc_autoreleasePoolPop(v44);
        }
        *(_DWORD *)(v50 + 4_Block_object_dispose(va, 8) = 0;
        __dmb(0xBu);
        char v33 = 0LL;
        CFRelease(v45);
        if (v42-- <= 0) {
          return;
        }
      }
    }

    os_unfair_lock_lock_with_options();
    unint64_t v3 = *(void *)(v50 + 32);
    os_unfair_lock_unlock((os_unfair_lock_t)(v50 + 12));
    if (v3)
    {
      uint64_t v2 = 9;
      goto LABEL_6;
    }
  }

      uint64_t v69 = (unsigned int *)&v44->super._externalReferenceCount;
      do
        CFAllocatorRef v70 = __ldxr(v69);
      while (__stxr(v70 + 1, v69));
      goto LABEL_67;
    }

    if (v78)
    {
      int v40 = 0LL;
      *uint64_t v78 = (id)objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  134060,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  @"Unexpected number of property values returned from server",  @"Reason"));
      goto LABEL_69;
    }

        ++v79;
        if (!--v80)
        {
          callBacks.version = 0LL;
          *(_OWORD *)&callBacks.retain = *(_OWORD *)(MEMORY[0x189605228] + 8LL);
          callBacks.copyDescription = *(CFArrayCopyDescriptionCallBack *)(MEMORY[0x189605228] + 24LL);
          callBacks.equal = 0LL;
          uint64_t v20 = v135;
          *(void *)(v135 + 40) = CFArrayCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)v137,  v73,  &callBacks);
          uint64_t v69 = v142;
          goto LABEL_80;
        }
      }

      uint64_t v89 = (v81 + 7) & 0xFFFFFFFFFFFFFFFCLL;
      size_t v90 = v89 + 4;
      if (v89 + 4 <= a4)
      {
        uint64_t v91 = bswap32(*(_DWORD *)(a2 + v89));
        uint64_t v142 = v90;
      }

      else
      {
        uint64_t v91 = 0;
      }

      id v85 = *(void **)(v18 + 8LL * v91);
      goto LABEL_64;
    }

    uint64_t v69 = v70 + 4;
  }

            if (v44) {
              [v15 removeItemAtURL:v77 error:0];
            }
            uint64_t v26 = v43 != 0;
            +[NSPersistentStoreCoordinator _endPowerAssertionWithAssert:andApp:]( (uint64_t)&OBJC_CLASS___NSPersistentStoreCoordinator,  v80,  v74);
            return v26;
          }
        }

        else
        {
          uint64_t v63 = v43 == 0;
        }

        if ((v63 & v28) == 1) {
          [v15 removeItemAtURL:v78 error:0];
        }
        goto LABEL_65;
      }
    }
  }

  uint64_t v26 = 0;
  if (a7) {
    *a7 = (id)objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  134060,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Both source and destination stores must be backed by files",  a4,  *MEMORY[0x1896075E0],  0));
  }
  return v26;
}

void sub_18669E3E8(_Unwind_Exception *a1)
{
}

void sub_18669E400(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x18669E40CLL);
}

LABEL_37:
              ++v22;
            }

            while ([v10 count] > v22);
            uint64_t v9 = v78;
            uint64_t v14 = v78;
            if ((v21 & 1) != 0) {
              goto LABEL_86;
            }
          }

          uint64_t v53 = (void *)MEMORY[0x189603F70];
          unsigned int v54 = *MEMORY[0x189603A60];
          uint64_t v55 = (void *)NSString;
          uint64_t v56 = @"setPropertiesToFetch:";
          int v57 = v75 == 0;
LABEL_103:
          if (!v57) {
            uint64_t v56 = @"setPropertiesToGroupBy:";
          }
          uint64_t v58 = [v55 stringWithFormat:@"Invalid keypath %@ passed to %@:", v9, v56];
          goto LABEL_132;
        }

        if (v18)
        {
          uint64_t v43 = objc_msgSend( (id)objc_msgSend(v11, "propertiesByName"),  "objectForKey:",  objc_msgSend(v10, "objectAtIndex:", 0));
          if (v43)
          {
            uint64_t v44 = (void *)v43;
            uint64_t v45 = 1LL;
            while (1)
            {
              uint64_t v46 = [v44 _propertyType];
              if ((v46 & 0xFFFFFFFFFFFFFFFBLL) == 2) {
                break;
              }
              if (v46 != 4)
              {

                uint64_t v53 = (void *)MEMORY[0x189603F70];
                unsigned int v54 = *MEMORY[0x189603A60];
                uint64_t v59 = @"setPropertiesToFetch:";
                if (a3) {
                  uint64_t v59 = @"setPropertiesToGroupBy:";
                }
                uint64_t v58 = [NSString stringWithFormat:@"Invalid keypath %@ passed to %@ (invalid property type)", v9, v59];
                goto LABEL_132;
              }

              if ((a3 & 1) == 0 && [v44 isToMany])
              {

                uint64_t v53 = (void *)MEMORY[0x189603F70];
                unsigned int v54 = *MEMORY[0x189603A60];
                uint64_t v58 = [NSString stringWithFormat:@"Invalid to many relationship in setPropertiesToFetch: (%@)", v9, v67];
                goto LABEL_132;
              }

              if (v18 == v45)
              {
                uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSExpressionDescription);
                -[NSPropertyDescription setName:](v14, "setName:", v9);
                -[NSExpressionDescription setExpression:]( v14,  "setExpression:",  [MEMORY[0x189607878] expressionForKeyPath:v9]);
                uint64_t v51 = v14;
                id v50 = 2000LL;
                goto LABEL_97;
              }

              uint64_t v44 = (void *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v44, "destinationEntity"), "propertiesByName"),  "objectForKey:",  objc_msgSend(v10, "objectAtIndex:", v45++));
              if (!v44) {
                goto LABEL_102;
              }
            }

            if (v18 == v45)
            {
              uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSExpressionDescription);
              -[NSPropertyDescription setName:](v14, "setName:", v9);
              -[NSExpressionDescription setExpression:]( v14,  "setExpression:",  [MEMORY[0x189607878] expressionForKeyPath:v9]);
              id v50 = [v44 attributeType];
              uint64_t v51 = v14;
LABEL_97:
              -[NSExpressionDescription setExpressionResultType:](v51, "setExpressionResultType:", v50);
              goto LABEL_86;
            }

            uint64_t v53 = (void *)MEMORY[0x189603F70];
            unsigned int v54 = *MEMORY[0x189603A60];
            uint64_t v64 = @"setPropertiesToFetch:";
            if (a3) {
              uint64_t v64 = @"setPropertiesToGroupBy:";
            }
            uint64_t v58 = [NSString stringWithFormat:@"Invalid keypath %@ passed to %@ (non-terminal attribute)", v9, v64];
            goto LABEL_132;
          }

          int v40 = v56;
        }

        v66[5] = 0LL;
        uint64_t v41 = *((_BYTE *)v72 + 24) != 0;
        uint64_t v56 = v40;
        goto LABEL_41;
      }

      uint64_t v41 = v75;
LABEL_41:
      _Block_object_dispose(&v65, 8);
      _Block_object_dispose(&v71, 8);
      if (!v41) {
        goto LABEL_49;
      }
      if (v3 == ++v5)
      {
        id v50 = [obj countByEnumeratingWithState:&v57 objects:v76 count:16];
        unint64_t v3 = v50;
        if (v50) {
          goto LABEL_3;
        }
        goto LABEL_47;
      }
    }

    useconds_t v10 = objc_alloc_init(&OBJC_CLASS____PFRequestExecutor);
    if ([v9[1] databaseScope] != 3)
    {
      double v25 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResetZoneRequest);
      v61[0] = MEMORY[0x1895F87A8];
      v61[1] = 3221225472LL;
      v61[2] = __110__NSPersistentCloudKitContainer__doPurgeForObjectsAndRecordsInZoneWithID_inPersistentStore_withContext_error___block_invoke_3;
      v61[3] = &unk_189EA93F8;
      v61[6] = &v65;
      v61[4] = v10;
      v61[5] = &v71;
      int v12 = -[NSCloudKitMirroringResetZoneRequest initWithOptions:completionBlock:]( v25,  "initWithOptions:completionBlock:",  0LL,  v61);
      uint64_t v80 = v8;
      -[NSCloudKitMirroringResetZoneRequest setRecordZoneIDsToReset:]( (uint64_t)v12,  (void *)[MEMORY[0x189603F18] arrayWithObjects:&v80 count:1]);
      *(void *)buf = 0LL;
      if (-[_PFRequestExecutor executeRequest:onMirroringDelegate:error:]( v10,  "executeRequest:onMirroringDelegate:error:",  v12,  v9,  buf))
      {
        if (-[_PFRequestExecutor wait](v10, "wait")) {
          goto LABEL_33;
        }
        *((_BYTE *)v72 + 24) = 0;
        uint64_t v26 = (id)-[NSPersistentCloudKitContainer createTimeoutErrorForRequest:withLabel:]( v6,  (uint64_t)v12,  (uint64_t)@"Zone-Purge-Reset");
      }

      else
      {
        *((_BYTE *)v72 + 24) = 0;
        uint64_t v26 = *(id *)buf;
      }

      v66[5] = (uint64_t)v26;
      goto LABEL_33;
    }

    *(void *)buf = 0LL;
    -[NSManagedObject setNeedsShareDelete:]( +[NSCKRecordZoneMetadata zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:error:]( (uint64_t)NSCKRecordZoneMetadata,  v8,  [v9[1] databaseScope],  (uint64_t)v7,  a2,  (uint64_t)buf),  "setNeedsShareDelete:",  1);
    if (![a2 save:buf])
    {
      uint64_t v27 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v28 = __ckLoggingOverride;
      uint64_t v29 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Encountered an error trying to update the store metadata while attempting to purge zone '%@': %@"];
      _NSCoreDataLog( v28 != 0,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  (uint64_t)"-[NSPersistentCloudKitContainer _doPurgeForObjectsAndRecordsInZoneWithID:inPersistentStore:withContext:error:]");
      objc_autoreleasePoolPop(v27);
      *((_BYTE *)v72 + 24) = 0;
      uint64_t v36 = objc_alloc(MEMORY[0x189607870]);
      uint64_t v81 = v53;
      int v37 = *(void *)buf;
      if (!*(void *)buf) {
        int v37 = [MEMORY[0x189603FE8] null];
      }
      int v82 = v37;
      uint64_t v38 = objc_msgSend( v36,  "initWithDomain:code:userInfo:",  v52,  134060,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v82, &v81, 1));
      v66[5] = v38;
      goto LABEL_34;
    }

    uint64_t v11 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringExportRequest);
    v64[0] = MEMORY[0x1895F87A8];
    v64[1] = 3221225472LL;
    v64[2] = __110__NSPersistentCloudKitContainer__doPurgeForObjectsAndRecordsInZoneWithID_inPersistentStore_withContext_error___block_invoke;
    v64[3] = &unk_189EA93F8;
    v64[6] = &v65;
    v64[4] = v10;
    v64[5] = &v71;
    int v12 = -[NSCloudKitMirroringRequest initWithOptions:completionBlock:]( v11,  "initWithOptions:completionBlock:",  0LL,  v64);
    uint64_t v63 = 0LL;
    if (-[_PFRequestExecutor executeRequest:onMirroringDelegate:error:]( v10,  "executeRequest:onMirroringDelegate:error:",  v12,  v9,  &v63))
    {
      if (-[_PFRequestExecutor wait](v10, "wait"))
      {
        uint64_t v13 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResetZoneRequest);
        v62[0] = MEMORY[0x1895F87A8];
        v62[1] = 3221225472LL;
        v62[2] = __110__NSPersistentCloudKitContainer__doPurgeForObjectsAndRecordsInZoneWithID_inPersistentStore_withContext_error___block_invoke_2;
        v62[3] = &unk_189EA93F8;
        v62[6] = &v65;
        v62[4] = v10;
        v62[5] = &v71;
        uint64_t v14 = -[NSCloudKitMirroringResetZoneRequest initWithOptions:completionBlock:]( v13,  "initWithOptions:completionBlock:",  0LL,  v62);
        v83[0] = v8;
        -[NSCloudKitMirroringResetZoneRequest setRecordZoneIDsToReset:]( (uint64_t)v14,  (void *)[MEMORY[0x189603F18] arrayWithObjects:v83 count:1]);
        if (-[_PFRequestExecutor executeRequest:onMirroringDelegate:error:]( v10,  "executeRequest:onMirroringDelegate:error:",  v14,  v9,  &v63))
        {
          if (-[_PFRequestExecutor wait](v10, "wait"))
          {
LABEL_32:

            goto LABEL_33;
          }

          *((_BYTE *)v72 + 24) = 0;
          int v15 = (id)-[NSPersistentCloudKitContainer createTimeoutErrorForRequest:withLabel:]( v6,  (uint64_t)v14,  (uint64_t)@"Zone-Purge-PostExportReset");
        }

        else
        {
          *((_BYTE *)v72 + 24) = 0;
          int v15 = v63;
        }

        v66[5] = (uint64_t)v15;
        goto LABEL_32;
      }

      *((_BYTE *)v72 + 24) = 0;
      uint64_t v39 = (id)-[NSPersistentCloudKitContainer createTimeoutErrorForRequest:withLabel:]( v6,  (uint64_t)v12,  (uint64_t)@"Zone-Purge-Export");
    }

    else
    {
      *((_BYTE *)v72 + 24) = 0;
      uint64_t v39 = v63;
    }

    v66[5] = (uint64_t)v39;
LABEL_33:

LABEL_34:
    unsigned int v24 = 1;
    goto LABEL_35;
  }

  v75[0] = MEMORY[0x1895F87A8];
  v75[1] = 3221225472LL;
  v75[2] = __72__NSPersistentCloudKitContainer_shareManagedObjects_toShare_completion___block_invoke_2;
  v75[3] = &unk_189EA9498;
  v75[4] = self;
  v75[5] = v31;
  v75[9] = v65;
  v75[10] = &v96;
  v75[11] = &v84;
  v75[6] = v14;
  v75[7] = managedObjects;
  v75[12] = &v100;
  v75[8] = v64;
  [v65 performBlockAndWait:v75];

  if (!*((_BYTE *)v97 + 24)) {
    goto LABEL_57;
  }
  v74[0] = MEMORY[0x1895F87A8];
  v74[1] = 3221225472LL;
  v74[2] = __72__NSPersistentCloudKitContainer_shareManagedObjects_toShare_completion___block_invoke_3;
  v74[3] = &unk_189EA94C0;
  v74[10] = &v96;
  v74[11] = &v100;
  v74[12] = v67;
  v74[4] = v14;
  v74[5] = v64;
  v74[6] = self;
  v74[7] = v29;
  v74[8] = v26;
  v74[9] = &v84;
  -[NSPersistentCloudKitContainer doWorkOnMetadataContext:withBlock:]((uint64_t)self, 0, (uint64_t)v74);
  if (!*((_BYTE *)v97 + 24)) {
    goto LABEL_57;
  }
LABEL_38:
  uint64_t v44 = 0LL;
  CFAllocatorRef v70 = 0LL;
  uint64_t v71 = &v70;
  uint64_t v72 = 0x2020000000LL;
  uint64_t v73 = 0;
  do
  {
    *((_BYTE *)v97 + 24) = 1;
    uint64_t v45 = (void *)v101[5];
    if (v45)
    {

      v101[5] = 0LL;
    }

    uint64_t v46 = objc_alloc_init(&OBJC_CLASS____PFRequestExecutor);
    uint64_t v47 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringExportRequest);
    v69[0] = MEMORY[0x1895F87A8];
    v69[1] = 3221225472LL;
    v69[2] = __72__NSPersistentCloudKitContainer_shareManagedObjects_toShare_completion___block_invoke_4;
    v69[3] = &unk_189EA94E8;
    v69[4] = v14;
    v69[5] = self;
    v69[9] = &v100;
    v69[10] = v44 + 1;
    v69[7] = &v70;
    v69[8] = &v96;
    v69[6] = v46;
    double v48 = -[NSCloudKitMirroringRequest initWithOptions:completionBlock:]( v47,  "initWithOptions:completionBlock:",  0LL,  v69);
    uint64_t v49 = (void *)v48;
    if (v48) {
      *(_BYTE *)(v48 + 56) = 1;
    }
    if (*((_BYTE *)v97 + 24))
    {
      if (-[_PFRequestExecutor executeRequest:inContext:error:]( v46,  "executeRequest:inContext:error:",  v48,  v65,  v101 + 5))
      {
        if (-[_PFRequestExecutor wait](v46, "wait"))
        {
          if (*((_BYTE *)v97 + 24))
          {
            v68[0] = MEMORY[0x1895F87A8];
            v68[1] = 3221225472LL;
            v68[2] = __72__NSPersistentCloudKitContainer_shareManagedObjects_toShare_completion___block_invoke_5;
            v68[3] = &unk_189EA9510;
            v68[9] = &v100;
            v68[10] = v67;
            v68[6] = &v78;
            v68[7] = &v90;
            v68[8] = &v96;
            v68[4] = v14;
            v68[5] = v26;
            -[NSPersistentCloudKitContainer doWorkOnMetadataContext:withBlock:]((uint64_t)self, 0, (uint64_t)v68);
          }
        }

        else
        {
          *((_BYTE *)v97 + 24) = 0;
          uint64_t v51 = -[NSPersistentCloudKitContainer createTimeoutErrorForRequest:withLabel:]( (uint64_t)self,  (uint64_t)v49,  (uint64_t)@"Share-Export");
          v101[5] = v51;
          *((_BYTE *)v71 + 24) = 1;
        }
      }

      else
      {
        *((_BYTE *)v97 + 24) = 0;
        id v50 = (id)v101[5];
      }
    }

    if (*((_BYTE *)v71 + 24)) {
      break;
    }
  }

  while (v44++ < 9);
  _Block_object_dispose(&v70, 8);
  if (*((_BYTE *)v97 + 24))
  {
    uint64_t v53 = 0LL;
    unsigned int v54 = v91[5];
    uint64_t v55 = v29;
    uint64_t v56 = v28;
  }

  else
  {
LABEL_57:
    uint64_t v53 = (id)v101[5];
    uint64_t v55 = 0LL;
    unsigned int v54 = 0LL;
    uint64_t v56 = 0LL;
  }

  (*((void (**)(void *, id, uint64_t, id, id))completion + 2))(completion, v55, v54, v56, v53);

  v91[5] = 0LL;
  v101[5] = 0LL;

  v85[5] = 0LL;
  v79[5] = 0LL;

  _Block_object_dispose(&v78, 8);
  _Block_object_dispose(&v84, 8);
  _Block_object_dispose(&v90, 8);
  _Block_object_dispose(&v96, 8);
  _Block_object_dispose(&v100, 8);
}

      uint64_t v31 = 0LL;
      goto LABEL_38;
    }

    uint64_t v77 = 0u;
    uint64_t v78 = 0u;
    uint64_t v75 = 0u;
    uint64_t v76 = 0u;
    int v32 = [v28 countByEnumeratingWithState:&v75 objects:v87 count:16];
    if (!v32) {
      goto LABEL_37;
    }
    char v33 = v32;
    uint64_t v34 = *(void *)v76;
    do
    {
      uint64_t v35 = 0LL;
      do
      {
        if (*(void *)v76 != v34) {
          objc_enumerationMutation(v28);
        }
        if (entity) {
          uint64_t v31 = (void *)-[NSMutableDictionary objectForKey:]( entity->_properties,  "objectForKey:",  *(void *)(*((void *)&v75 + 1) + 8 * v35));
        }
        else {
          uint64_t v31 = 0LL;
        }
        ++v35;
      }

      while (v33 != v35);
      uint64_t v36 = [v28 countByEnumeratingWithState:&v75 objects:v87 count:16];
      char v33 = v36;
    }

    while (v36);
LABEL_38:
    if ([v31 propertyType] != 1)
    {
      uint64_t v53 = (void *)MEMORY[0x189603F70];
      unsigned int v54 = *MEMORY[0x189603A60];
      uint64_t v55 = [NSString stringWithFormat:@"Invalid ranged property (relationship?!?) %@", v21];
      v85[0] = @"entity";
      unsigned int v62 = objc_msgSend(-[NSSQLEntity entityDescription](self->_entity, "entityDescription"), "name");
      v85[1] = @"properties";
      v86[0] = v62;
      v86[1] = -[NSArray valueForKey:](self->_properties, "valueForKey:", @"name");
      int v57 = (void *)MEMORY[0x189603F68];
      uint64_t v58 = v86;
      uint64_t v59 = v85;
      goto LABEL_70;
    }

    int v37 = -[NSSQLEntity rtreeIndexForIndexNamed:]((uint64_t)entity, v68);
    if (!v37)
    {
      if (v68) {
        uint64_t v63 = (const __CFString *)[NSString stringWithFormat:@"(no index found for name %@)", v68];
      }
      else {
        uint64_t v63 = @"(no index name specified, multiple indices available)";
      }
      uint64_t v53 = (void *)MEMORY[0x189603F70];
      unsigned int v54 = *MEMORY[0x189603A60];
      uint64_t v55 = [NSString stringWithFormat:@"Can't find index for rtree query %@", v63];
      v83[0] = @"entity";
      uint64_t v67 = objc_msgSend(-[NSSQLEntity entityDescription](self->_entity, "entityDescription"), "name");
      v83[1] = @"properties";
      v84[0] = v67;
      v84[1] = -[NSArray valueForKey:](self->_properties, "valueForKey:", @"name");
      int v57 = (void *)MEMORY[0x189603F68];
      uint64_t v58 = v84;
      uint64_t v59 = v83;
      goto LABEL_70;
    }

    uint64_t v38 = v74;
    if (v74)
    {
      uint64_t v39 = v72;
      if (([v74 isEqual:*(void *)(v37 + 48)] & 1) == 0)
      {
        int v12 = (void *)MEMORY[0x189603F70];
        uint64_t v13 = *MEMORY[0x189603A58];
        v81[0] = @"entity";
        uint64_t v64 = objc_msgSend(-[NSSQLEntity entityDescription](self->_entity, "entityDescription"), "name");
        v81[1] = @"properties";
        v82[0] = v64;
        v82[1] = -[NSArray valueForKey:](self->_properties, "valueForKey:", @"name");
        useconds_t v10 = [MEMORY[0x189603F68] dictionaryWithObjects:v82 forKeys:v81 count:2];
        uint64_t v11 = @"Can't generate SQL; crosscheck failed";
        goto LABEL_7;
      }
    }

    else
    {
      uint64_t v38 = *(void **)(v37 + 48);
      uint64_t v39 = v72;
    }

    int v40 = [v39 expressionType];
    uint64_t v74 = v38;
    if (v40 == 14)
    {
      uint64_t v44 = (void *)[v39 collection];
      uint64_t v45 = (void *)[v44 firstObject];
      uint64_t v46 = (void *)[v44 lastObject];
      if (!-[NSSQLRTreeIndexQueryIntermediate _validateExpression:context:]((uint64_t)self, v45, a3)
        || !-[NSSQLRTreeIndexQueryIntermediate _validateExpression:context:]((uint64_t)self, v46, a3))
      {
        return 0LL;
      }

      uint64_t v42 = [v45 constantValue];
      uint64_t v43 = [v46 constantValue];
    }

    else
    {
      if (v40)
      {
        uint64_t v53 = (void *)MEMORY[0x189603F70];
        unsigned int v54 = *MEMORY[0x189603A60];
        uint64_t v55 = [NSString stringWithFormat:@"Invalid RHS for rtree query %@", v39];
        v79[0] = @"entity";
        unsigned int v65 = objc_msgSend(-[NSSQLEntity entityDescription](self->_entity, "entityDescription"), "name");
        v79[1] = @"properties";
        v80[0] = v65;
        v80[1] = -[NSArray valueForKey:](self->_properties, "valueForKey:", @"name");
        int v57 = (void *)MEMORY[0x189603F68];
        uint64_t v58 = v80;
        uint64_t v59 = v79;
        goto LABEL_70;
      }

      uint64_t v41 = (void *)[v39 constantValue];
      uint64_t v42 = [v41 firstObject];
      uint64_t v43 = [v41 lastObject];
    }

    uint64_t v47 = v43;
    double v48 = (void *)-[NSSQLIntermediate _generateSQLForConstantValue:inContext:]((uint64_t)self, v42, (uint64_t)a3);
    uint64_t v49 = (void *)-[NSSQLIntermediate _generateSQLForConstantValue:inContext:]((uint64_t)self, v47, (uint64_t)a3);
    id v50 = [NSString stringWithFormat:@"%@ <= %@.%@_MIN AND %@.%@_MAX <= %@", v48, v70, objc_msgSend(v31, "columnName"), v70, objc_msgSend(v31, "columnName"), v49];

    [v69 addObject:v50];
    uint64_t v20 = v71 + 1;
    if (v71 + 1 >= -[NSArray count](self->_properties, "count")) {
      goto LABEL_59;
    }
  }

  if ([a3 objectForKey:@"NSUnderlyingException"]) {
    return 0LL;
  }
  uint64_t v53 = (void *)MEMORY[0x189603F70];
  unsigned int v54 = *MEMORY[0x189603A60];
  uint64_t v55 = [NSString stringWithFormat:@"Unable to generate SQL for keypath %@", v21];
  v88[0] = @"entity";
  unsigned int v66 = objc_msgSend(-[NSSQLEntity entityDescription](self->_entity, "entityDescription"), "name");
  v88[1] = @"properties";
  v89[0] = v66;
  v89[1] = -[NSArray valueForKey:](self->_properties, "valueForKey:", @"name");
  int v57 = (void *)MEMORY[0x189603F68];
  uint64_t v58 = v89;
  uint64_t v59 = v88;
LABEL_70:
  useconds_t v10 = [v57 dictionaryWithObjects:v58 forKeys:v59 count:2];
  unsigned int v16 = v53;
  uint64_t v17 = v54;
  uint64_t v11 = (const __CFString *)v55;
LABEL_56:
  objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(v16, "exceptionWithName:reason:userInfo:", v17, v11, v10),  @"NSUnderlyingException");
  return 0LL;
}

  uint64_t v26 = 0;
LABEL_38:
  if (v48)
  {
    uint64_t v27 = v48;
    uint64_t v26 = 0;
  }

  else
  {
    uint64_t v27 = 0LL;
  }

    if (*((_BYTE *)v82 + 24))
    {
      uint64_t v35 = (void *)[objc_alloc(getCloudKitCKFetchRecordZoneChangesOperationClass()) initWithRecordZoneIDs:v42->_changedRecordZoneIDs configurationsByRecordZoneID:v46];
      if (-[NSCloudKitMirroringRequest options](v42->super.super._request, "options")) {
        -[NSCloudKitMirroringRequestOptions applyToOperation:]( (uint64_t)-[NSCloudKitMirroringRequest options](v42->super.super._request, "options"),  v35);
      }
      objc_initWeak(&location, v42);
      v58[0] = MEMORY[0x1895F87A8];
      v58[1] = 3221225472LL;
      void v58[2] = __120__PFCloudKitImporterZoneChangedWorkItem_executeImportOperationsAndAccumulateRecordsWithManagedObjectContext_completion___block_invoke_2;
      v58[3] = &unk_189EA7AB0;
      objc_copyWeak(&v59, &location);
      [v35 setRecordWasChangedBlock:v58];
      v56[0] = MEMORY[0x1895F87A8];
      v56[1] = 3221225472LL;
      v56[2] = __120__PFCloudKitImporterZoneChangedWorkItem_executeImportOperationsAndAccumulateRecordsWithManagedObjectContext_completion___block_invoke_3;
      v56[3] = &unk_189EAAEA8;
      objc_copyWeak(&v57, &location);
      [v35 setRecordWithIDWasDeletedBlock:v56];
      v54[0] = MEMORY[0x1895F87A8];
      v54[1] = 3221225472LL;
      v54[2] = __120__PFCloudKitImporterZoneChangedWorkItem_executeImportOperationsAndAccumulateRecordsWithManagedObjectContext_completion___block_invoke_4;
      v54[3] = &unk_189EAAED0;
      objc_copyWeak(&v55, &location);
      [v35 setRecordZoneChangeTokensUpdatedBlock:v54];
      v52[0] = MEMORY[0x1895F87A8];
      v52[1] = 3221225472LL;
      v52[2] = __120__PFCloudKitImporterZoneChangedWorkItem_executeImportOperationsAndAccumulateRecordsWithManagedObjectContext_completion___block_invoke_5;
      v52[3] = &unk_189EAAEF8;
      objc_copyWeak(&v53, &location);
      [v35 setRecordZoneFetchCompletionBlock:v52];
      v50[0] = MEMORY[0x1895F87A8];
      v50[1] = 3221225472LL;
      v50[2] = __120__PFCloudKitImporterZoneChangedWorkItem_executeImportOperationsAndAccumulateRecordsWithManagedObjectContext_completion___block_invoke_6;
      v50[3] = &unk_189EAAF20;
      objc_copyWeak(&v51, &location);
      v50[4] = v41;
      [v35 setFetchRecordZoneChangesCompletionBlock:v50];
      -[CKDatabase addOperation:](v48, "addOperation:", v35);
      objc_destroyWeak(&v51);
      objc_destroyWeak(&v53);
      objc_destroyWeak(&v55);
      objc_destroyWeak(&v57);
      objc_destroyWeak(&v59);
      objc_destroyWeak(&location);
      uint64_t v34 = v35;
      goto LABEL_48;
    }

    if (!v41)
    {
LABEL_47:
      uint64_t v34 = 0LL;
LABEL_48:

      v76[5] = 0LL;
      _Block_object_dispose(&v75, 8);
      _Block_object_dispose(&v81, 8);
      goto LABEL_49;
    }

    uint64_t v36 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResult);
    if (v42)
    {
      request = v42->super.super._request;
      if (!v9) {
        goto LABEL_57;
      }
    }

    else
    {
      request = 0LL;
      if (!v9) {
        goto LABEL_57;
      }
    }

    uint64_t v38 = v9->_monitor;
    if (v38)
    {
      storeIdentifier = (uint64_t)v38->_storeIdentifier;
LABEL_46:
      int v40 = -[NSCloudKitMirroringResult initWithRequest:storeIdentifier:success:madeChanges:error:]( v36,  "initWithRequest:storeIdentifier:success:madeChanges:error:",  request,  storeIdentifier,  0LL,  0LL,  v76[5]);
      v41[2](v41, v40);

      goto LABEL_47;
    }
}

    uint64_t v35 = 0;
LABEL_38:
    int v12 = v59;
    goto LABEL_39;
  }

  uint64_t v55 = 0LL;
  int v37 = v42;
  return v42;
}
}

LABEL_58:
                ++v35;
              }

              while ([v31 count] > v35);
            }
          }

          if (!v33)
          {
LABEL_109:

            uint64_t v53 = (void *)MEMORY[0x189603F70];
            unsigned int v54 = *MEMORY[0x189603A60];
            int v60 = @"setPropertiesToFetch:";
            if (v75) {
              int v60 = @"setPropertiesToGroupBy:";
            }
            uint64_t v58 = [NSString stringWithFormat:@"Attribute/relationship description names passed to %@ must match name on fetch entity (%@)", v60, v79];
            goto LABEL_132;
          }

          uint64_t v9 = v79;
          if ((v75 & 1) != 0 || BYTE2(z9dsptsiQ80etb9782fsrs98bfdle88))
          {
            double v48 = -[NSPropertyDescription entity](v79, "entity");
            if (v69)
            {
              uint64_t v34 = v48;
              if (v69 != (void *)v48 && ([v69 _subentitiesIncludes:v48] & 1) == 0)
              {

                uint64_t v53 = (void *)MEMORY[0x189603F70];
                unsigned int v54 = *MEMORY[0x189603A60];
                uint64_t v58 = [NSString stringWithFormat:@"Invalid property (%@) passed to setPropertiesToFetch: (entity mismatch)", v79, v67];
                goto LABEL_132;
              }
            }
          }

          if (v29 == 4 && -[NSExpressionDescription isToMany](v79, "isToMany", v34))
          {

            uint64_t v53 = (void *)MEMORY[0x189603F70];
            unsigned int v54 = *MEMORY[0x189603A60];
            uint64_t v63 = @"setPropertiesToFetch:";
            if (v75) {
              uint64_t v63 = @"setPropertiesToGroupBy:";
            }
            uint64_t v58 = [NSString stringWithFormat:@"Invalid to many relationship (%@) passed to %@:", v79, v63];
            goto LABEL_132;
          }
        }
      }

      uint64_t v14 = v9;
LABEL_86:
      if ([v76 indexOfObjectIdenticalTo:v14] == 0x7FFFFFFFFFFFFFFFLL) {
        [v76 addObject:v14];
      }
      unsigned int v8 = v77 + 1;
      a3 = v75;
      a2 = v71;
      if (v77 + 1 == v73)
      {
        uint64_t v52 = [v71 countByEnumeratingWithState:&v88 objects:v94 count:16];
        uint64_t v73 = v52;
        if (v52) {
          goto LABEL_7;
        }
        return v76;
      }
    }
  }

  return v76;
}

      snapshot_set_value_as_object((char *)a1[3], a2, v5, v57, v58, v59, v60, v61);
      goto LABEL_68;
    }

      a3 = v32;
      goto LABEL_23;
    }

    int v32 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(a3, "count"));
    CFIndex v61 = 0u;
    unsigned int v62 = 0u;
    uint64_t v63 = 0u;
    uint64_t v64 = 0u;
    uint64_t v43 = [a3 countByEnumeratingWithState:&v61 objects:v73 count:16];
    if (!v43) {
      goto LABEL_58;
    }
    uint64_t v44 = v43;
    uint64_t v45 = *(void *)v62;
LABEL_48:
    uint64_t v46 = 0LL;
    while (1)
    {
      if (*(void *)v62 != v45) {
        objc_enumerationMutation(a3);
      }
      uint64_t v47 = *(void **)(*((void *)&v61 + 1) + 8 * v46);
      if ([a4 resultType] == 3) {
        break;
      }
      if ([a4 resultType] == 4)
      {
        double v48 = +[NSPersistentHistoryResult _changeFromResult:withTransaction:]( (uint64_t)&OBJC_CLASS___NSPersistentHistoryResult,  v47,  0LL);
        goto LABEL_55;
      }

  unsigned int v23 = *(_BYTE **)(a1 + 32);
  if ((v23[17] & 0x80) != 0) {
    [v23 willAccessValueForKey:0];
  }
  unsigned int v24 = *MEMORY[0x189605258];
  v89[1] = 0LL;
  v89[2] = 0LL;
  v89[0] = v24;
  v89[4] = _PFObjectIDFastEquals64;
  v89[5] = _PFObjectIDFastHash64;
  v86[1] = 0LL;
  v86[2] = 0LL;
  v86[0] = v24;
  double v25 = *(_OWORD *)(MEMORY[0x189605258] + 24LL);
  v89[3] = *(void *)(MEMORY[0x189605258] + 24LL);
  uint64_t v87 = v25;
  BOOL v88 = *(void *)(MEMORY[0x189605258] + 40LL);
  objc_opt_class();
  uint64_t v26 = v69;
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v28 = (CFSetCallBacks *)v86;
  if ((isKindOfClass & 1) != 0) {
    uint64_t v28 = (CFSetCallBacks *)v89;
  }
  callBacks = v28;
  uint64_t v30 = *(void *)(v67 + 144);
  uint64_t v29 = *(void *)(v67 + 152);
  uint64_t v31 = v29 + v30;
  if (v30 < v29 + v30)
  {
    int v32 = 0x18C68F000uLL;
    uint64_t v63 = v29 + v30;
    do
    {
      char v33 = *(void **)(v26[12] + *(int *)(v32 + 2268) + 8 * v30);
      uint64_t v34 = [v33 deleteRule];
      if ((unint64_t)(v34 - 1) <= 1)
      {
        uint64_t v76 = (void *)[v33 inverseRelationship];
        if (v76)
        {
          uint64_t v74 = [v76 name];
          uint64_t v35 = (void *)[*(id *)(a1 + 64) newValueForRelationship:v33 forObjectWithID:v72 withContext:*(void *)(a1 + 56) error:0];
          uint64_t v36 = v35;
          if (v35 && [v35 count])
          {
            _PF_Handler_Primitive_GetProperty( *(id ***)(a1 + 32),  v30,  0LL,  *(void *)(v65 + 8 * v30),  v37,  v38,  v39,  v40);
            uint64_t v42 = v41;
            uint64_t v43 = _PFStackAllocatorCreate(v92, 1024LL);
            CFMutableArrayRef Mutable = CFSetCreateMutable(v43, 0LL, callBacks);
            uint64_t v71 = v34;
            unsigned int v84 = 0u;
            id v85 = 0u;
            int v82 = 0u;
            int v83 = 0u;
            uint64_t v45 = [v42 countByEnumeratingWithState:&v82 objects:v91 count:16];
            if (v45)
            {
              uint64_t v46 = *(void *)v83;
              do
              {
                for (unint64_t i = 0LL; i != v45; ++i)
                {
                  if (*(void *)v83 != v46) {
                    objc_enumerationMutation(v42);
                  }
                  CFSetAddValue(Mutable, *(const void **)(*(void *)(*((void *)&v82 + 1) + 8 * i) + 40LL));
                }

                uint64_t v45 = [v42 countByEnumeratingWithState:&v82 objects:v91 count:16];
              }

              while (v45);
            }

            unsigned int v66 = v30;
            unsigned int v68 = v33;
            uint64_t v80 = 0u;
            uint64_t v81 = 0u;
            uint64_t v78 = 0u;
            uint64_t v79 = 0u;
            double v48 = [v36 countByEnumeratingWithState:&v78 objects:v90 count:16];
            if (v48)
            {
              uint64_t v49 = *(void *)v79;
              do
              {
                for (unint64_t j = 0LL; j != v48; ++j)
                {
                  if (*(void *)v79 != v49) {
                    objc_enumerationMutation(v36);
                  }
                  uint64_t v51 = *(void **)(*((void *)&v78 + 1) + 8 * j);
                  if (!CFSetContainsValue(Mutable, v51))
                  {
                    uint64_t v52 = -[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( *(void ***)(a1 + 56),  v51,  0LL);
                    uint64_t v53 = v52;
                    if (v52)
                    {
                      unsigned int v54 = (void *)[v52 primitiveValueForKey:v74];
                      uint64_t v55 = [v76 isToMany];
                      uint64_t v56 = *(void **)(a1 + 64);
                      if (v55)
                      {
                        int v57 = (void *)[v56 newValueForRelationship:v76 forObjectWithID:v51 withContext:*(void *)(a1 + 56) error:0];
                        if (([v57 containsObject:v72] & 1) != 0
                          || [v54 containsObject:*(void *)(a1 + 32)])
                        {
                          [*(id *)(a1 + 56) refreshObject:v53 mergeChanges:1];
                          if (v71 == 2)
                          {
                            [*(id *)(a1 + 56) deleteObject:v53];
                          }

                          else
                          {
                            else {
                              unsigned int v62 = (void *)[v53 mutableSetValueForKey:v74];
                            }
                            [v62 removeObject:*(void *)(a1 + 32)];
                          }
                        }
                      }

                      else
                      {
                        uint64_t v58 = (void *)[v56 newValuesForObjectWithID:v51 withContext:*(void *)(a1 + 56) error:0];
                        if (!v58 || (uint64_t v59 = objc_opt_class(), v59 == objc_opt_class()))
                        {
                          int v60 = (id)[v58 valueForKey:v74];
                        }

                        else
                        {
                          int v60 = (id)[v58 valueForPropertyDescription:v76];
                          uint64_t v77 = 0LL;
                          CFIndex v61 = v76;
                          if (!v60)
                          {
                            int v60 = (id)[*(id *)(a1 + 64) newValueForRelationship:v76 forObjectWithID:v72 withContext:*(void *)(a1 + 56) error:&v77];
                            if (!v60)
                            {
                              NSLog( (NSString *)@"That was unexpected. Error trying to get %@ from %@ (%@)",  v68,  v72,  v77);
                              int v60 = 0LL;
                            }
                          }

                          if ((id)objc_msgSend(MEMORY[0x189603FE8], "null", v61) == v60) {
                            int v60 = 0LL;
                          }
                        }

                        if ([v72 isEqual:v60])
                        {
                          [*(id *)(a1 + 56) refreshObject:v53 mergeChanges:1];
                          if ([v53 primitiveValueForKey:v74] == *(void *)(a1 + 32))
                          {
                            if (v71 == 2) {
                              [*(id *)(a1 + 56) deleteObject:v53];
                            }
                            else {
                              [v53 setValue:0 forKey:v74];
                            }
                          }
                        }
                      }
                    }
                  }
                }

                double v48 = [v36 countByEnumeratingWithState:&v78 objects:v90 count:16];
              }

              while (v48);
            }

            if (v92[3])
            {
              uint64_t v26 = v69;
              uint64_t v30 = v66;
              uint64_t v31 = v63;
              int v32 = 0x18C68F000LL;
              if (Mutable) {
                CFRelease(Mutable);
              }
            }

            else
            {
              v92[1] = v92[0];
              uint64_t v26 = v69;
              uint64_t v30 = v66;
              uint64_t v31 = v63;
              int v32 = 0x18C68F000LL;
            }
          }
        }
      }

      ++v30;
    }

    while (v30 != v31);
  }

  *(void *)(v228 + 40) = 0LL;
  *(void *)(*(void *)&buf[8] + 40LL) = 0LL;

  uint64_t v69 = *(unsigned __int8 *)(*(void *)&v278[8] + 24LL);
  _Block_object_dispose(buf, 8);
  _Block_object_dispose(&v227, 8);
  _Block_object_dispose(v278, 8);
  if (!v69) {
    goto LABEL_70;
  }
  v268 = 0LL;
  v269 = &v268;
  v270 = 0x2020000000LL;
  v271 = 1;
  v257 = 0LL;
  *(void *)v239 = 0LL;
  *(void *)&v239[8] = v239;
  *(void *)&v239[16] = 0x3052000000LL;
  v240 = __Block_byref_object_copy__25;
  v241 = __Block_byref_object_dispose__25;
  v242 = 0LL;
  CFAllocatorRef v70 = (void (*)(uint64_t))*(id *)(v4 + 56);
  *(void *)v237 = 0LL;
  *(void *)&v237[8] = v237;
  *(void *)&v237[16] = 0x2020000000LL;
  v238 = 0;
  uint64_t v71 = [*(id *)(v4 + 8) databaseScope];
  -[PFCloudKitSetupAssistant beginActivityForPhase:](v4, 4LL);
  *(void *)v278 = 0LL;
  *(void *)&v278[8] = v278;
  *(void *)&v278[16] = 0x2020000000LL;
  v279 = 1;
  *(void *)buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x3052000000LL;
  v275 = __Block_byref_object_copy__25;
  v276 = __Block_byref_object_dispose__25;
  v277 = 0LL;
  uint64_t v72 = [*(id *)(v4 + 8) databaseScope];
  if (v72 == 3)
  {
    uint64_t v97 = (uint64_t *)objc_alloc_init(MEMORY[0x189603FE0]);
    uint64_t v98 = (uint64_t *)objc_alloc_init(MEMORY[0x189603FE0]);
    uint64_t v99 = (void (*)(uint64_t))*(id *)(v4 + 56);
    *(void *)v246 = MEMORY[0x1895F87A8];
    v247 = 3221225472LL;
    v248 = (uint64_t)__71__PFCloudKitSetupAssistant__recoverFromManateeIdentityLossIfNecessary___block_invoke_70;
    v249 = (void (*)(uint64_t, uint64_t))&unk_189EA9D78;
    v254 = 3LL;
    v252 = (uint64_t *)buf;
    v253 = v278;
    v250 = v99;
    v251 = v98;
    -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v99, (uint64_t)v246);

    if (!*(void *)(*(void *)&buf[8] + 40) && [v98 count])
    {
      uint64_t v100 = dispatch_semaphore_create(0LL);
      unint64_t v101 = (void *)objc_msgSend( objc_alloc((Class)getCloudKitCKModifyRecordsOperationClass[0]()),  "initWithRecordsToSave:recordIDsToDelete:",  0,  objc_msgSend(v98, "allObjects"));
      -[NSCloudKitMirroringRequestOptions applyToOperation:]([*(id *)(v4 + 72) options], v101);
      [v101 setMarkAsParticipantNeedsNewInvitationToken:1];
      v227 = MEMORY[0x1895F87A8];
      v228 = 3221225472LL;
      v229 = (uint64_t)__71__PFCloudKitSetupAssistant__recoverFromManateeIdentityLossIfNecessary___block_invoke_3_74;
      v230 = (void (*)(uint64_t, uint64_t))&unk_189EA9DF0;
      v232 = v278;
      v233 = buf;
      v231 = (void (*)(uint64_t))v100;
      [v101 setModifyRecordsCompletionBlock:&v227];
      [*(id *)(v4 + 24) addOperation:v101];

      dispatch_semaphore_wait(v100, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v100);
    }

    if (!*(void *)(*(void *)&buf[8] + 40) && [v97 count])
    {
      uint64_t v102 = *(id *)(v4 + 56);
      *(void *)v259 = MEMORY[0x1895F87A8];
      *(void *)&v259[8] = 3221225472LL;
      *(void *)&v259[16] = __71__PFCloudKitSetupAssistant__recoverFromManateeIdentityLossIfNecessary___block_invoke_4_77;
      v260 = &unk_189EA9D50;
      v261 = v102;
      v262 = v97;
      v265 = (uint64_t)v278;
      v266 = 3LL;
      v263 = (uint64_t *)v4;
      v264 = buf;
      -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v102, (uint64_t)v259);
    }

    uint64_t v103 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v103)
    {
      v104 = v103;
      if (v104)
      {
        v257 = v104;
      }

      else
      {
        uint64_t v132 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
        _NSCoreDataLog( 17LL,  v132,  v133,  v134,  v135,  v136,  v137,  v138,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
        uint64_t v139 = (os_log_s *)__pflogFaultLog;
        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)v272 = 136315394;
          *(void *)&v272[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKi"
                                "tSetupAssistant.m";
          *(_WORD *)&v272[12] = 1024;
          *(_DWORD *)&v272[14] = 770;
          _os_log_fault_impl( &dword_186681000,  v139,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v272,  0x12u);
        }
      }

      goto LABEL_100;
    }
  }

  else if (v72 == 2)
  {
    uint64_t v73 = (uint64_t *)objc_alloc_init(MEMORY[0x189603FE0]);
    uint64_t v74 = (void (*)(uint64_t))*(id *)(v4 + 56);
    *(void *)v246 = MEMORY[0x1895F87A8];
    v247 = 3221225472LL;
    v248 = (uint64_t)__71__PFCloudKitSetupAssistant__recoverFromManateeIdentityLossIfNecessary___block_invoke;
    v249 = (void (*)(uint64_t, uint64_t))&unk_189EA9D78;
    v254 = 2LL;
    v252 = (uint64_t *)buf;
    v253 = v278;
    v250 = v74;
    v251 = v73;
    -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v74, (uint64_t)v246);

    if (!*(void *)(*(void *)&buf[8] + 40) && [v73 count])
    {
      uint64_t v75 = [v73 allObjects];
      uint64_t v76 = dispatch_semaphore_create(0LL);
      uint64_t v77 = (void *)[objc_alloc((Class)getCloudKitCKModifyRecordZonesOperationClass[0]()) initWithRecordZonesToSave:0 recordZoneIDsToDelete:v75];
      -[NSCloudKitMirroringRequestOptions applyToOperation:]([*(id *)(v4 + 72) options], v77);
      v227 = MEMORY[0x1895F87A8];
      v228 = 3221225472LL;
      v229 = (uint64_t)__71__PFCloudKitSetupAssistant__recoverFromManateeIdentityLossIfNecessary___block_invoke_3;
      v230 = (void (*)(uint64_t, uint64_t))&unk_189EA9DA0;
      v233 = v278;
      v234 = (uint64_t *)buf;
      v231 = (void (*)(uint64_t))v75;
      v232 = v76;
      [v77 setModifyRecordZonesCompletionBlock:&v227];
      [*(id *)(v4 + 24) addOperation:v77];

      dispatch_semaphore_wait(v76, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v76);
    }

    if (!*(void *)(*(void *)&buf[8] + 40) && [v73 count])
    {
      uint64_t v78 = *(id *)(v4 + 56);
      *(void *)v259 = MEMORY[0x1895F87A8];
      *(void *)&v259[8] = 3221225472LL;
      *(void *)&v259[16] = __71__PFCloudKitSetupAssistant__recoverFromManateeIdentityLossIfNecessary___block_invoke_4;
      v260 = &unk_189EA9D50;
      v261 = v78;
      v262 = v73;
      v265 = (uint64_t)v278;
      v266 = 2LL;
      v263 = (uint64_t *)v4;
      v264 = buf;
      -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v78, (uint64_t)v259);
    }

    uint64_t v79 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v79)
    {
      uint64_t v80 = v79;
      if (v80)
      {
        v257 = v80;
      }

      else
      {
        uint64_t v124 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
        _NSCoreDataLog( 17LL,  v124,  v125,  v126,  v127,  v128,  v129,  v130,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
        uint64_t v131 = (os_log_s *)__pflogFaultLog;
        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)v272 = 136315394;
          *(void *)&v272[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKi"
                                "tSetupAssistant.m";
          *(_WORD *)&v272[12] = 1024;
          *(_DWORD *)&v272[14] = 630;
          _os_log_fault_impl( &dword_186681000,  v131,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v272,  0x12u);
        }
      }

      if (!*((_BYTE *)v71 + 24))
      {
        if (v177[5])
        {
          int v159 = (id)v177[5];
        }

        else
        {
          uint64_t v79 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
          _NSCoreDataLog( 17LL,  v79,  v80,  v81,  v82,  v83,  v84,  v85,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitMetadataPurger.m");
          uint64_t v86 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315394;
            v196 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitMetadataPurger.m";
            v197 = 1024;
            v198 = 485;
            _os_log_fault_impl( &dword_186681000,  v86,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
          }
        }
      }

      uint64_t v87 = (id)v177[5];
      v177[5] = 0LL;
      BOOL v88 = *((unsigned __int8 *)v183 + 24);
      _Block_object_dispose(&v176, 8);
      _Block_object_dispose(&v182, 8);
      if (!v88) {
        goto LABEL_70;
      }
      if (v129 == ++v54)
      {
        uint64_t v89 = [v2 countByEnumeratingWithState:&v151 objects:v191 count:16];
        char v129 = v89;
        if (v89) {
          goto LABEL_42;
        }
        goto LABEL_71;
      }
    }
  }

        if (![a3 objectForKey:@"NSUnderlyingException"])
        {
          uint64_t v45 = (void *)MEMORY[0x189603F70];
          uint64_t v46 = *MEMORY[0x189603A60];
          uint64_t v69 = @"indexDescription";
          CFAllocatorRef v70 = -[NSSQLIndex indexDescription](v60->_index, "indexDescription");
          objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend( v45,  "exceptionWithName:reason:userInfo:",  v46,  @"SQL generation failure for index",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v70, &v69, 1)),  @"NSUnderlyingException");
        }

        unsigned int v8 = 0LL;
LABEL_61:
        v60->_isHandlingExpressions = 0;
        uint64_t v47 = -[NSFetchIndexDescription partialIndexPredicate]( -[NSSQLIndex indexDescription](v60->_index, "indexDescription"),  "partialIndexPredicate");
        if (v8)
        {
          double v48 = v47;
          if (v47)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              uint64_t v49 = -[NSSQLCompoundWhereIntermediate initWithPredicate:inScope:inContext:]( objc_alloc(&OBJC_CLASS___NSSQLCompoundWhereIntermediate),  "initWithPredicate:inScope:inContext:",  v48,  v60,  a3);
              goto LABEL_67;
            }

            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {

              uint64_t v52 = (void *)MEMORY[0x189603F70];
              uint64_t v53 = *MEMORY[0x189603A60];
              uint64_t v67 = @"predicate";
              unsigned int v68 = -[NSFetchIndexDescription partialIndexPredicate]( -[NSSQLIndex indexDescription](v60->_index, "indexDescription"),  "partialIndexPredicate");
              objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend( v52,  "exceptionWithName:reason:userInfo:",  v53,  @"SQL generation failure for index with predicate (1)",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v68, &v67, 1)),  @"NSUnderlyingException");
              return 0LL;
            }

            uint64_t v49 = -[NSSQLSimpleWhereIntermediate initWithPredicate:inScope:]( objc_alloc(&OBJC_CLASS___NSSQLSimpleWhereIntermediate),  "initWithPredicate:inScope:",  v48,  v60);
LABEL_67:
            id v50 = v49;
            if (v49)
            {
              uint64_t v51 = -[NSSQLCompoundWhereIntermediate generateSQLStringInContext:]( v49,  "generateSQLStringInContext:",  a3);

              if (v51)
              {
                [v8 appendFormat:@" WHERE %@", v51];

                return v8;
              }

              if (![a3 objectForKey:@"NSUnderlyingException"])
              {
                unsigned int v54 = (void *)MEMORY[0x189603F70];
                uint64_t v55 = *MEMORY[0x189603A60];
                unsigned int v65 = @"predicate";
                unsigned int v66 = -[NSFetchIndexDescription partialIndexPredicate]( -[NSSQLIndex indexDescription](v60->_index, "indexDescription"),  "partialIndexPredicate");
                objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend( v54,  "exceptionWithName:reason:userInfo:",  v55,  @"SQL generation failure for index with predicate (2)",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v66, &v65, 1)),  @"NSUnderlyingException");
              }

              return 0LL;
            }
          }
        }

        return v8;
      case 5LL:
        unsigned int v23 = (void *)[v15 expression];
        unsigned int v24 = [v23 expressionType];
        switch(v24)
        {
          case 4LL:
            uint64_t v26 = &OBJC_CLASS___NSSQLFunctionExpressionIntermediate;
LABEL_30:
            unsigned int v19 = (NSSQLKeypathExpressionIntermediate *)objc_alloc(v26);
            uint64_t v18 = (uint64_t)v23;
            goto LABEL_12;
          case 3LL:
            uint64_t v27 = (void *)[v23 keyPath];
            [v27 rangeOfString:@"."];
            if (v28)
            {
              uint64_t v29 = (void *)MEMORY[0x189603F70];
              uint64_t v86 = @"expression";
              v87[0] = v23;
              uint64_t v30 = [MEMORY[0x189603F68] dictionaryWithObjects:v87 forKeys:&v86 count:1];
              uint64_t v31 = v29;
              int v32 = v58;
              char v33 = @"Joins not supported in index";
            }

            else
            {
              uint64_t v35 = -[NSSQLEntity entityDescription]( -[NSSQLIndex sqlEntity](v60->_index, "sqlEntity"),  "entityDescription");
              if (v35
                && (uint64_t v36 = (void *)objc_msgSend((id)objc_msgSend(v35, "propertiesByName"), "objectForKey:", v27)) != 0)
              {
                int v37 = v36;
                int v57 = [v36 _propertyType];
                if ([v37 _propertyType] == 4 && objc_msgSend(v37, "isToMany"))
                {
                  uint64_t v38 = (void *)MEMORY[0x189603F70];
                  int v82 = @"property";
                  int v83 = v37;
                  uint64_t v30 = [MEMORY[0x189603F68] dictionaryWithObjects:&v83 forKeys:&v82 count:1];
                  uint64_t v31 = v38;
                  int v32 = v58;
                  char v33 = @"Indexes cannot contain to many relationships";
                }

                else
                {
                  if (v57 <= 7 && ((1LL << v57) & 0xD4) != 0)
                  {
                    uint64_t v26 = &OBJC_CLASS___NSSQLKeypathExpressionIntermediate;
                    goto LABEL_30;
                  }

                  int v40 = (void *)MEMORY[0x189603F70];
                  uint64_t v80 = @"property";
                  uint64_t v81 = v37;
                  uint64_t v30 = [MEMORY[0x189603F68] dictionaryWithObjects:&v81 forKeys:&v80 count:1];
                  uint64_t v31 = v40;
                  int v32 = v58;
                  char v33 = @"Indexes can only contain attribute/relationship properties";
                }
              }

              else
              {
                if (![@"entity" caseInsensitiveCompare:v27])
                {
                  double v25 = @"Z_ENT";
                  goto LABEL_28;
                }

                if (![@"self" caseInsensitiveCompare:v27])
                {
LABEL_27:
                  double v25 = @"Z_PK";
LABEL_28:
                  double v21 = (id)-[__CFString mutableCopy](v25, "mutableCopy");
                  goto LABEL_13;
                }

                uint64_t v39 = (void *)MEMORY[0x189603F70];
                unsigned int v84 = @"expression";
                id v85 = v23;
                uint64_t v30 = [MEMORY[0x189603F68] dictionaryWithObjects:&v85 forKeys:&v84 count:1];
                uint64_t v31 = v39;
                int v32 = v58;
                char v33 = @"Can't find property for keypath";
              }
            }

            break;
          case 1LL:
            goto LABEL_27;
          default:
            uint64_t v34 = (void *)MEMORY[0x189603F70];
            uint64_t v78 = @"expression";
            uint64_t v79 = v23;
            uint64_t v30 = [MEMORY[0x189603F68] dictionaryWithObjects:&v79 forKeys:&v78 count:1];
            uint64_t v31 = v34;
            int v32 = v58;
            char v33 = @"Unsupported expression type in index";
            break;
        }

        objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(v31, "exceptionWithName:reason:userInfo:", v32, v33, v30),  @"NSUnderlyingException");
        double v21 = 0LL;
        goto LABEL_13;
      default:
        uint64_t v42 = (void *)MEMORY[0x189603F70];
        uint64_t v73 = @"property";
        uint64_t v74 = v15;
        uint64_t v43 = [MEMORY[0x189603F68] dictionaryWithObjects:&v74 forKeys:&v73 count:1];
        uint64_t v44 = @"Unsupported property in index";
        goto LABEL_53;
    }
  }

double fetchResultSetPrepareNextRow(int *a1)
{
  uint64_t v2 = a1[6];
  uint64_t v3 = *((void *)a1 + 4);
  unint64_t v4 = (void *)*((void *)a1 + 8);
  uint64_t v5 = v4[v2] + v3;
  if ((*(_DWORD *)v5 & 0x80000000) != 0)
  {
    if (a1[7] < 0) {
      goto LABEL_5;
    }
    *(_DWORD *)(v5 + 4) = v2;
    *(void *)(v5 + 16) = v3;
  }

  a1[7] = v2;
  *((void *)a1 + 5) = v3;
LABEL_5:
  uint64_t v6 = *((void *)a1 + 10);
  unint64_t v7 = (_OWORD *)((*((void *)a1 + 11) + 7LL) & 0xFFFFFFFFFFFFFFF8LL);
  if (a1[4] + (int)v6 - (int)v7 <= 31)
  {
    int v8 = a1[5];
    a1[4] = 15359;
    a1[5] = v8 + 1;
    uint64_t v9 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone)
    {
      uint64_t v9 = malloc_default_zone();
      unint64_t v4 = (void *)*((void *)a1 + 8);
    }

    useconds_t v10 = malloc_zone_realloc(v9, v4, 8LL * (v8 + 2));
    *((void *)a1 + _Block_object_dispose(va, 8) = v10;
    v10[v8 + 1] = 0LL;
    uint64_t v11 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if ((a1[12] & 4) != 0)
    {
      if (!_PF_Private_Malloc_Zone) {
        uint64_t v11 = malloc_default_zone();
      }
      int v12 = malloc_zone_calloc(v11, 1uLL, 0x3BFFuLL);
    }

    else
    {
      if (!_PF_Private_Malloc_Zone) {
        uint64_t v11 = malloc_default_zone();
      }
      int v12 = malloc_zone_malloc(v11, 0x3BFFuLL);
    }

    *((void *)a1 + 10) = v12;
    *(void *)(*((void *)a1 + 8) + 8LL * v_Block_object_dispose(va, 8) = v12;
    unint64_t v7 = (_OWORD *)*((void *)a1 + 10);
    *((void *)a1 + 11) = v7;
    uint64_t v13 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v13 = malloc_default_zone();
    }
    uint64_t v14 = malloc_zone_realloc(v13, *((void **)a1 + 9), 8LL * (v8 + 2));
    *((void *)a1 + 9) = v14;
    v14[v8] = 15359LL;
    a1[6] = v8;
    uint64_t v6 = *((void *)a1 + 10);
  }

  *((void *)a1 + 4) = (char *)v7 - v6;
  double result = 0.0;
  _OWORD *v7 = 0u;
  v7[1] = 0u;
  uint64_t v16 = *(void *)(*((void *)a1 + 8) + 8LL * a1[6]) + *((void *)a1 + 4);
  int v17 = *a1;
  *(_DWORD *)uint64_t v16 = *a1;
  *(_DWORD *)(v16 + 4) = -1;
  *(void *)(v16 + 16) = 0LL;
  *a1 = v17 + 1;
  *((void *)a1 + 11) = v16 + 32;
  return result;
}

uint64_t _prepareResultsFromResultSet(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v190 = *MEMORY[0x1895F89C0];
  char v155 = a2;
  if (a3) {
    uint64_t v5 = *(void *)(a3 + 136);
  }
  else {
    uint64_t v5 = 0LL;
  }
  if (*(_DWORD *)(a1 + 4) <= 0x40000000u) {
    unsigned int v6 = *(_DWORD *)(a1 + 4);
  }
  else {
    unsigned int v6 = 0;
  }
  unint64_t v7 = PF_ALLOCATE_OBJECT_ARRAY((int)v6);
  if (v7) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t v165 = a1;
  if (v3)
  {
    uint64_t v9 = *(void *)(v3 + 112);
    uint64_t v164 = *(void *)(v5 + 56);
    id v156 = (id)[MEMORY[0x1896078A8] defaultManager];
    BOOL v154 = *(_BYTE *)(v3 + 201) != 0;
    uint64_t v10 = *(void *)(v3 + 32);
    if (v10) {
      int v176 = *(_BYTE *)(v10 + 43) & 1;
    }
    else {
      int v176 = 0;
    }
    unsigned int v188 = *(_DWORD *)(v5 + 72);
    unsigned int v11 = (v188 >> 2) & 7;
    uint64_t v12 = **(void **)(a1 + 64);
    int v183 = (void *)(a1 + 64);
    if (v11 == 3)
    {
      uint64_t v166 = *(void *)(v3 + 128);
      BOOL v174 = 1;
    }

    else
    {
      BOOL v174 = 0;
      uint64_t v166 = 0LL;
    }
  }

  else
  {
    uint64_t v164 = *(void *)(v5 + 56);
    id v156 = (id)[MEMORY[0x1896078A8] defaultManager];
    uint64_t v10 = 0LL;
    uint64_t v9 = 0LL;
    BOOL v154 = 0;
    int v176 = 0;
    uint64_t v166 = 0LL;
    unsigned int v188 = *(_DWORD *)(v5 + 72);
    unsigned int v11 = (v188 >> 2) & 7;
    BOOL v174 = v11 == 3;
    uint64_t v147 = *(uint64_t **)(a1 + 64);
    int v183 = (void *)(a1 + 64);
    uint64_t v12 = *v147;
  }

  int v182 = (void **)v10;
  int v175 = [*(id *)(v5 + 8) _disablePersistentStoreResultCaching];
  unsigned int v13 = v188;
  if ((v188 & 1) != 0) {
    unsigned int v14 = 0;
  }
  else {
    unsigned int v14 = v8;
  }
  MEMORY[0x1895F8858]();
  if (v14 > 0x200)
  {
    int v180 = (void *)NSAllocateScannedUncollectable();
  }

  else
  {
    int v180 = (uint64_t *)((char *)&v148 - v16);
    bzero((char *)&v148 - v16, 8LL * v15);
  }

  MEMORY[0x1895F8858]();
  unsigned int v19 = (char *)&v148 - v18;
  unsigned int v161 = v20;
  if (v20 > 0x200) {
    unsigned int v19 = (char *)NSAllocateScannedUncollectable();
  }
  else {
    bzero((char *)&v148 - v18, 8LL * v17);
  }
  v181 = v19;
  if (v180) {
    BOOL v21 = v19 == 0LL;
  }
  else {
    BOOL v21 = 1;
  }
  if (v21)
  {
    PF_FREE_OBJECT_ARRAY(v7);
    unint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
  }

  BOOL v22 = v182;
  unsigned int v162 = v14;
  v160 = sel_setForeignEntityKeySlot_entityKey_;
  uint64_t v159 = +[NSSQLRow instanceMethodForSelector:](&OBJC_CLASS___NSSQLRow, "instanceMethodForSelector:");
  id v170 = sel_setForeignKeySlot_int64_;
  v169 = (void (*)(id, char *, void, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  uint64_t v158 = sel_setForeignOrderKeySlot_orderKey_;
  uint64_t v157 = +[NSSQLRow instanceMethodForSelector:](&OBJC_CLASS___NSSQLRow, "instanceMethodForSelector:");
  v168 = sel_setOptLock_;
  int v167 = (void (*)(id, char *, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  if (v3)
  {
    unsigned int v23 = (objc_class *)[*(id *)(v3 + 8) objectIDFactoryForSQLEntity:*(void *)(v5 + 40)];
    if ((v13 & 1) != 0) {
      goto LABEL_40;
    }
  }

  else
  {
    unsigned int v23 = 0LL;
    if ((v13 & 1) != 0) {
      goto LABEL_40;
    }
  }

  unsigned int v24 = v23;
  else {
    uint64_t v25 = 0LL;
  }
  if ((v13 & 2) != 0 || !(_DWORD)v25)
  {
    unsigned int v23 = v24;
    BOOL v22 = v182;
    if (!(_DWORD)v25)
    {
      PF_FREE_OBJECT_ARRAY(v7);
      uint64_t v26 = 0LL;
      unint64_t v7 = 0LL;
      BOOL v150 = 0;
      if ((v13 & 2) == 0) {
        goto LABEL_217;
      }
      goto LABEL_227;
    }

LABEL_40:
    int v186 = v23;
    BOOL v150 = (int)v8 > 0;
    uint64_t v163 = v8;
    uint64_t v27 = v183;
    if ((int)v8 >= 1)
    {
      uint64_t v28 = 0LL;
      BOOL v151 = 0LL;
      unsigned int v152 = 0LL;
      uint64_t v153 = 0LL;
      uint64_t v29 = 0LL;
      uint64_t v179 = v163;
      unsigned int v172 = v11;
      v173 = v7;
      uint64_t v177 = v3;
      uint64_t v171 = v9;
      while (1)
      {
        while ((*(_DWORD *)v12 & 0x80000000) != 0)
        {
          uint64_t v30 = *(unsigned int *)(v12 + 4);
          if ((v30 & 0x80000000) != 0) {
            uint64_t v12 = 0LL;
          }
          else {
            uint64_t v12 = *(void *)(*v27 + 8 * v30) + *(void *)(v12 + 16);
          }
        }

        uint64_t v31 = (unint64_t *)_sqlEntityForEntityID(v9, *(unsigned int *)(v12 + 8));
        int v32 = v186;
        if (v31 != v29) {
          int v32 = 0LL;
        }
        int v187 = v31;
        if (v3 && v31 != v29) {
          int v32 = (objc_class *)objc_msgSend(*(id *)(v3 + 8), "objectIDFactoryForSQLEntity:");
        }
        int v186 = v32;
        if ((v13 & 1) != 0)
        {
          uint64_t v36 = (void *)[[v32 alloc] initWithPK64:*(void *)(v12 + 24)];
          if ((v13 & 2) == 0)
          {
            uint64_t v38 = v187;
            uint64_t v39 = v36;
            int v40 = +[NSSQLRow allocForSQLEntity:]((uint64_t)&OBJC_CLASS___NSSQLRow, v187);
            double v41 = *(double *)(v165 + 8);
            v178 = v39;
            uint64_t v42 = (void *)[v40 initWithSQLEntity:v38 ownedObjectID:v39 andTimestamp:v41];
            *(void *)&v181[8 * v28] = v42;
LABEL_59:
            id v185 = v42;
            uint64_t v43 = (char *)v42[5];
            unint64_t plan_for_entity = _sql_fetch_plan_for_entity(v38);
            uint64_t v45 = *(unsigned int *)(plan_for_entity + 4);
            unsigned __int8 v189 = v43;
            if ((_DWORD)v45)
            {
              uint64_t v46 = (__int16 *)(v12 + 32);
              __int128 v184 = v43 + 28;
              uint64_t v47 = (id *)(plan_for_entity + 24);
              while (1)
              {
                int v48 = *((unsigned __int8 *)v47 - 4);
                else {
                  uint64_t v49 = qword_1868D6220[(char)(v48 - 2)];
                }
                uint64_t v46 = (__int16 *)(((unint64_t)v46 + v49) & ~v49);
                if ((*(_BYTE *)(v47 - 1) & 1) != 0)
                {
                  int v51 = *(unsigned __int8 *)v46;
                  uint64_t v46 = (__int16 *)((char *)v46 + 1);
                  BOOL v50 = v51 != 0;
                }

                else
                {
                  BOOL v50 = 0;
                }

                uint64_t v52 = (unsigned int *)(v47 - 2);
                uint64_t v53 = ~v49;
                switch(*((_BYTE *)v47 - 4))
                {
                  case 1:
                    uint64_t v78 = (__int16 *)(((unint64_t)v46 + v49) & v53);
                    uint64_t v63 = v78 + 2;
                    if (v50) {
                      uint64_t v79 = v46;
                    }
                    else {
                      uint64_t v79 = v78 + 2;
                    }
                    int v80 = *((unsigned __int8 *)v47 - 3);
                    if (v80 == 10)
                    {
                      if (v50) {
                        uint64_t v98 = 0LL;
                      }
                      else {
                        uint64_t v98 = *(unsigned int *)v78;
                      }
                      uint64_t v102 = *v52;
                      id v103 = v185;
                      v104 = v158;
                      uint64_t v105 = (void (**)(id, char *, uint64_t, uint64_t))&v191;
                      goto LABEL_143;
                    }

                    if (v80 == 4)
                    {
                      if (v50) {
                        uint64_t v98 = 0LL;
                      }
                      else {
                        uint64_t v98 = *(unsigned int *)v78;
                      }
                      uint64_t v102 = *v52;
                      id v103 = v185;
                      v104 = v160;
                      uint64_t v105 = (void (**)(id, char *, uint64_t, uint64_t))&v192;
LABEL_143:
                      (*(v105 - 32))(v103, v104, v102, v98);
LABEL_144:
                      uint64_t v46 = v79;
                      goto LABEL_155;
                    }

                    if (v80 != 1) {
                      goto LABEL_144;
                    }
                    uint64_t v81 = objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute");
                    if (v50)
                    {
                      unsigned int v13 = v188;
                      if (v81) {
                        goto LABEL_94;
                      }
LABEL_104:
                      v184[(unint64_t)*v52 >> 3] |= 1 << (*v52 & 7);
                      goto LABEL_156;
                    }

                    unsigned int v13 = v188;
                    if (v81)
                    {
                      id v110 = (void *)[MEMORY[0x189607968] numberWithInt:*(unsigned int *)v78];
                      setMultiColumnValueDictionary(v189, v47 - 2, v110);
                    }

                    else
                    {
                      uint64_t v115 = *v52;
                      Class Class = object_getClass(v189);
                      int v117 = *(char *)(*((void *)object_getIndexedIvars(Class) + 7) + v115);
                      if (v117 == 115)
                      {
                        snapshot_set_int16(v189, *v52, *v78);
                      }

                      else if (v117 == 99)
                      {
                        snapshot_set_int8(v189, *v52, *(_BYTE *)v78);
                      }

                      else
                      {
                        snapshot_set_int32(v189, *v52, *(_DWORD *)v78);
                      }
                    }

                    goto LABEL_130;
                  case 2:
                  case 3:
                    unsigned int v62 = (void *)(((unint64_t)v46 + v49) & v53);
                    if (v50) {
                      uint64_t v63 = v46;
                    }
                    else {
                      uint64_t v63 = (__int16 *)(v62 + 1);
                    }
                    int v64 = *((unsigned __int8 *)v47 - 3);
                    if (v64 == 6)
                    {
                      if (v50) {
                        uint64_t v90 = 0LL;
                      }
                      else {
                        uint64_t v90 = *v62;
                      }
                      unsigned int v13 = v188;
                      v167(v185, v168, v90);
                      goto LABEL_130;
                    }

                    if (v64 == 3)
                    {
                      if (v50) {
                        uint64_t v89 = 0LL;
                      }
                      else {
                        uint64_t v89 = *v62;
                      }
                      unsigned int v13 = v188;
                      v169(v185, v170, *v52, v89);
LABEL_130:
                      uint64_t v46 = v63;
                      goto LABEL_156;
                    }

                    if (v64 != 1)
                    {
                      uint64_t v46 = v63;
LABEL_155:
                      unsigned int v13 = v188;
                      goto LABEL_156;
                    }

                    uint64_t v65 = objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute");
                    if (!v50)
                    {
                      uint64_t v99 = *v62;
                      if (v65) {
                        setMultiColumnValueDictionary( v189,  v47 - 2,  (void *)[MEMORY[0x189607968] numberWithLongLong:v99]);
                      }
                      else {
                        snapshot_set_int64(v189, *v52, v99);
                      }
                      uint64_t v46 = (__int16 *)(v62 + 1);
                      goto LABEL_155;
                    }

                    unsigned int v13 = v188;
                    if (!v65) {
                      goto LABEL_104;
                    }
                    unsigned int v66 = v189;
LABEL_95:
                    setMultiColumnValueNullFlag(v66, (_DWORD *)v47 - 4);
                    goto LABEL_156;
                  case 4:
                  case 5:
                  case 6:
                  case 9:
                  case 0xC:
                    if (v50) {
                      goto LABEL_93;
                    }
                    unsigned int v54 = (const char *)(((unint64_t)v46 + v49) & v53);
                    uint64_t v55 = (int *)(v54 + 4);
                    uint64_t v56 = (__CFString *)CFStringCreateWithCString(0LL, v54 + 4, 0x8000100u);
                    uint64_t v57 = *(int *)v54;
                    int v58 = *((unsigned __int8 *)v47 - 4);
                    if (v58 == 12)
                    {
                      uint64_t v59 = (__CFString *)(id)[MEMORY[0x189604030] URLWithString:v56];
                    }

                    else
                    {
                      if (v58 != 4) {
                        goto LABEL_107;
                      }
                      uint64_t v59 = (__CFString *)[objc_alloc(MEMORY[0x189607858]) initWithString:v56];
                    }

                    goto LABEL_106;
                  case 7:
                  case 8:
                    if (v50) {
                      goto LABEL_93;
                    }
                    int v60 = (double *)(((unint64_t)v46 + v49) & v53);
                    uint64_t v46 = (__int16 *)(v60 + 1);
                    if (objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute"))
                    {
                      CFIndex v61 = (void *)[MEMORY[0x189607968] numberWithDouble:*v60];
                      setMultiColumnValueDictionary(v189, v47 - 2, v61);
                      goto LABEL_156;
                    }

                    uint64_t v91 = *((unsigned int *)v47 - 4);
                    int v92 = v189;
                    if (*((_BYTE *)v47 - 4) == 7)
                    {
                      Class v93 = object_getClass(v189);
                      IndexedIvars = object_getIndexedIvars(v93);
                      unsigned int v95 = *v52;
                      double v96 = *v60;
                      if (*(_BYTE *)(IndexedIvars[7] + v91) == 102)
                      {
                        float v97 = v96;
                        snapshot_set_float(v92, v95, v97);
                        goto LABEL_156;
                      }

                      uint64_t v100 = v92;
                    }

                    else
                    {
                      double v96 = *v60;
                      uint64_t v100 = v189;
                      unsigned int v95 = *((_DWORD *)v47 - 4);
                    }

                    snapshot_set_double(v100, v95, v96);
                    goto LABEL_156;
                  case 0xD:
                  case 0xE:
                    goto LABEL_156;
                  case 0x10:
                    uint64_t v67 = (void *)[*v47 propertyDescription];
                    if (v50) {
                      goto LABEL_93;
                    }
                    unsigned int v68 = (const char *)(((unint64_t)v46 + v49) & v53);
                    CFAllocatorRef v70 = (int *)(v68 + 4);
                    int v69 = *((unsigned __int8 *)v68 + 4);
                    if (v69 == 3)
                    {
                      unsigned int v188 = v13;
                      if (v177)
                      {
                        uint64_t v101 = v153;
                        if (!v153) {
                          uint64_t v101 = *(void *)(v177 + 104);
                        }
                      }

                      else
                      {
                        uint64_t v101 = v153;
                      }

                      uint64_t v118 = [MEMORY[0x189603F48] dataWithBytes:v68 + 4 length:*(int *)v68];
                      char v119 = v68;
                      char v120 = objc_alloc(&OBJC_CLASS____NSDataFileBackedFuture);
                      uint64_t v153 = v101;
                      uint64_t v121 = [MEMORY[0x189604030] fileURLWithPath:v101 isDirectory:1];
                      uint64_t v122 = v120;
                      unsigned int v68 = v119;
                      v114 = -[_NSDataFileBackedFuture initWithStoreMetadata:directory:]( v122,  "initWithStoreMetadata:directory:",  v118,  v121);
                      unsigned int v13 = v188;
                      goto LABEL_173;
                    }

                    uint64_t v71 = v177;
                    if (v69 == 1)
                    {
                      uint64_t v72 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                      if (v71) {
                        uint64_t v73 = *(unsigned int *)(v71 + 184);
                      }
                      else {
                        uint64_t v73 = 0LL;
                      }
                      uint64_t v74 = *(int *)v68;
                      uint64_t v75 = (int *)(v68 + 4);
                      uint64_t v76 = 0LL;
                      uint64_t v77 = 0LL;
LABEL_167:
                      v114 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v72,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  v75,  v74,  v76,  v77,  v73);
                      goto LABEL_173;
                    }

                    size_t v106 = strnlen(v68 + 5, *(int *)v68 - 1LL);
                    uint64_t v107 = [v156 stringWithFileSystemRepresentation:v68 + 5 length:v106];
                    uint64_t v108 = v151;
                    uint64_t v149 = v68;
                    if (v151)
                    {
                      if (v71) {
                        goto LABEL_160;
                      }
                    }

                    else
                    {
                      if (v71)
                      {
                        uint64_t v108 = *(void **)(v71 + 88);
LABEL_160:
                        uint64_t v109 = v152;
                        if (!v152) {
                          uint64_t v109 = *(void **)(v71 + 96);
                        }
                        goto LABEL_162;
                      }

                      uint64_t v108 = 0LL;
                    }

                    uint64_t v109 = v152;
LABEL_162:
                    BOOL v151 = v108;
                    uint64_t v111 = v109;
                    uint64_t v112 = [v108 stringByAppendingPathComponent:v107];
                    unsigned int v152 = v111;
                    uint64_t v113 = [v111 stringByAppendingPathComponent:v107];
                    if (!v154 || [v156 fileExistsAtPath:v112])
                    {
                      uint64_t v72 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                      if (v177) {
                        uint64_t v73 = *(unsigned int *)(v177 + 184);
                      }
                      else {
                        uint64_t v73 = 0LL;
                      }
                      uint64_t v74 = *(int *)v149;
                      uint64_t v75 = v70;
                      uint64_t v76 = v112;
                      unsigned int v68 = v149;
                      uint64_t v77 = v113;
                      goto LABEL_167;
                    }

                    v114 = 0LL;
                    unsigned int v68 = v149;
LABEL_173:
                    uint64_t v46 = (__int16 *)((char *)v70 + *(int *)v68);
                    if (objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute"))
                    {
                      setMultiColumnValueDictionary(v189, v47 - 2, v114);
                    }

                    else
                    {
                      unsigned int v83 = *v52;
                      unsigned int v84 = v189;
                      uint64_t v85 = (uint64_t)v114;
LABEL_110:
                      snapshot_set_object(v84, v83, v85);
                    }

        int v17 = (void *)[objc_alloc(NSString) initWithFormat:a2 arguments:&a9];
        uint64_t v16 = (const char *)[v17 UTF8String];
        if (_pflogging_catastrophic_mode) {
          unsigned int v19 = 1LL;
        }
        else {
          unsigned int v19 = a1;
        }
        switch(v19)
        {
          case 1LL:
            BOOL v22 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_ERROR)) {
              goto LABEL_72;
            }
            break;
          case 2LL:
            BOOL v22 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_ERROR)) {
              goto LABEL_72;
            }
            break;
          case 3LL:
            unsigned int v20 = qword_18C4AB810;
            if (os_log_type_enabled((os_log_t)qword_18C4AB810, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_61;
            }
            break;
          case 4LL:
          case 5LL:
            unsigned int v20 = qword_18C4AB818;
            if (os_log_type_enabled((os_log_t)qword_18C4AB818, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_61;
            }
            break;
          case 6LL:
          case 7LL:
            BOOL v21 = qword_18C4AB820;
            if (os_log_type_enabled((os_log_t)qword_18C4AB820, OS_LOG_TYPE_INFO)) {
              goto LABEL_57;
            }
            break;
          case 8LL:
            unsigned int v20 = qword_18C4AB828;
            if (os_log_type_enabled((os_log_t)qword_18C4AB828, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_61;
            }
            break;
          case 9LL:
            BOOL v21 = qword_18C4AB838;
            if (os_log_type_enabled((os_log_t)qword_18C4AB838, OS_LOG_TYPE_INFO))
            {
LABEL_57:
              *(_DWORD *)buf = 136446466;
              uint64_t v29 = v11;
              uint64_t v30 = 2082;
              uint64_t v31 = v16;
              unsigned int v23 = "%{public}s: %{public}s\n";
              unsigned int v24 = (os_log_s *)v21;
              uint64_t v25 = OS_LOG_TYPE_INFO;
              goto LABEL_63;
            }

            break;
          case 16LL:
            unsigned int v20 = qword_18C4AB830;
            if (os_log_type_enabled((os_log_t)qword_18C4AB830, OS_LOG_TYPE_DEFAULT))
            {
LABEL_61:
              *(_DWORD *)buf = 136446466;
              uint64_t v29 = v11;
              uint64_t v30 = 2082;
              uint64_t v31 = v16;
              unsigned int v23 = "%{public}s: %{public}s\n";
              unsigned int v24 = (os_log_s *)v20;
              goto LABEL_62;
            }

            break;
          case 17LL:
            BOOL v22 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_ERROR))
            {
LABEL_72:
              *(_DWORD *)buf = 136446466;
              uint64_t v29 = v11;
              uint64_t v30 = 2082;
              uint64_t v31 = v16;
              _os_log_error_impl(&dword_186681000, v22, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s\n", buf, 0x16u);
            }

            break;
          default:
            if (os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v29 = v11;
              uint64_t v30 = 2082;
              uint64_t v31 = v16;
              unsigned int v24 = (os_log_s *)MEMORY[0x1895F8DA0];
              unsigned int v23 = "CoreData: %{public}s: %{public}s\n";
LABEL_62:
              uint64_t v25 = OS_LOG_TYPE_DEFAULT;
LABEL_63:
              _os_log_impl(&dword_186681000, v24, v25, v23, buf, 0x16u);
            }

            break;
        }

        if (_pflogging_enable_stderr <= 0) {
          goto LABEL_70;
        }
        if (!v17) {
          goto LABEL_66;
        }
        goto LABEL_67;
    }
  }

  uint64_t v16 = 0LL;
  int v17 = 0LL;
  if (_pflogging_enable_stderr > 0)
  {
LABEL_66:
    int v17 = (void *)[objc_alloc(NSString) initWithFormat:a2 arguments:&a9];
LABEL_67:
    if (!v16) {
      uint64_t v16 = (const char *)[v17 UTF8String];
    }
    os_unfair_lock_lock_with_options();
    fprintf((FILE *)*MEMORY[0x1895F89D0], "CoreData: %s: %s\n", v11, v16);
    os_unfair_lock_unlock((os_unfair_lock_t)&_MergedGlobals_60);
  }

LABEL_156:
                    v47 += 3;
                    if (!--v45) {
                      goto LABEL_182;
                    }
                    break;
                  default:
LABEL_92:
                    if (v50)
                    {
LABEL_93:
                      if (!objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute")) {
                        goto LABEL_104;
                      }
LABEL_94:
                      unsigned int v66 = v189;
                      goto LABEL_95;
                    }

                    uint64_t v86 = (const UInt8 *)(((unint64_t)v46 + v49) & v53);
                    uint64_t v55 = (int *)(v86 + 4);
                    CFDataRef v87 = CFDataCreate(0LL, v86 + 4, *(int *)v86);
                    uint64_t v56 = (__CFString *)v87;
                    uint64_t v57 = *(int *)v86;
                    int v88 = *((unsigned __int8 *)v47 - 4);
                    if (v88 == 11)
                    {
                      if (-[__CFData length](v87, "length") == 16)
                      {
                        uint64_t v59 = (__CFString *)objc_msgSend( objc_alloc(MEMORY[0x189607AB8]),  "initWithUUIDBytes:",  -[__CFString bytes](v56, "bytes"));
                        goto LABEL_106;
                      }

                      uint64_t v56 = 0LL;
                    }

                    else if (v88 == 15)
                    {
                      uint64_t v59 = (__CFString *)+[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)v87,  (void *)[*v47 propertyDescription]);
LABEL_106:
                      int v82 = v59;
                      CFRelease(v56);
                      uint64_t v56 = v82;
                    }

LABEL_107:
                    uint64_t v46 = (__int16 *)((char *)v55 + v57);
                    if (objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute"))
                    {
                      setMultiColumnValueDictionary(v189, v47 - 2, v56);

                      goto LABEL_156;
                    }

                    unsigned int v83 = *v52;
                    unsigned int v84 = v189;
                    uint64_t v85 = (uint64_t)v56;
                    goto LABEL_110;
                }
              }
            }

  if (v121[3])
  {
    int v82 = 0x18C4A5000LL;
    if (v53) {
      CFRelease(v53);
    }
  }

  else
  {
    v121[1] = v121[0];
    int v82 = 0x18C4A5000uLL;
  }

  *(_DWORD *)(*(void *)(v6 + 24) + 4 * v4) |= v86;
  if ((_MergedGlobals_39 & 1) == 0 && ((v85 ^ 1) & 1) == 0) {
    -[NSManagedObjectContext _processReferenceQueue:](*(void *)(v6 + *(int *)(v82 + 772)), 0);
  }
  objc_autoreleasePoolPop(v58);
}

  -[PFCloudKitSetupAssistant endActivityForPhase:withError:](v4, 4LL, *(void *)(*(void *)&v239[8] + 40LL));
  if (*((_BYTE *)v269 + 24))
  {
LABEL_108:
    unsigned int v11 = v8;
    goto LABEL_109;
  }

  v145 = *(void **)(*(void *)&v239[8] + 40LL);
  if (v145)
  {
    unsigned int v11 = v145;
    v257 = v11;
    if (!v11)
    {
LABEL_123:
      BOOL v151 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v151,  v152,  v153,  v154,  v155,  v156,  v157,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
      uint64_t v158 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)v259 = 136315394;
        *(void *)&v259[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m";
        *(_WORD *)&v259[12] = 1024;
        *(_DWORD *)&v259[14] = 897;
        _os_log_fault_impl( &dword_186681000,  v158,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v259,  0x12u);
      }

      goto LABEL_108;
    }
  }

  else
  {
    unsigned int v11 = v257;
    if (!v257) {
      goto LABEL_123;
    }
  }

        uint64_t v52 = [NSString stringWithFormat:@"The database operation timed out after %.2f seconds.", Current - v15 + *(double *)(v3 + 232)];
        if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1)
        {
          if (*(_BYTE *)(v3 + 42)) {
            uint64_t v59 = @"\x1B[31m\x1B[47mERROR:\x1B[0m\x1B[31m (%d) %@\x1B[0m";
          }
          else {
            uint64_t v59 = @"(%d) %@";
          }
          unsigned int v62 = v52;
          _NSCoreDataLog(1LL, (uint64_t)v59, v53, v54, v55, v56, v57, v58, v19);
        }

        if (ppStmt) {
          sqlite3_finalize(ppStmt);
        }
        int v60 = [NSString stringWithFormat:@"error during SQL execution : %@", v52, v62];
        CFIndex v61 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  *MEMORY[0x189603A58],  134090,  v60,  (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithInt:", v19),  @"NSSQLiteErrorDomain"));
        objc_exception_throw(v61);
        -[NSSQLiteConnection beginReadTransaction]();
        return;
      default:
        int v32 = 0LL;
        uint64_t v67 = 0LL;
        goto LABEL_75;
    }
  }

            if (v26)
            {
              os_unfair_lock_unlock((os_unfair_lock_t)&_MergedGlobals_81);
              [v9 drain];
              return v26;
            }

            goto LABEL_29;
          }

          goto LABEL_41;
        }
      }

      uint64_t v38 = *(void *)v78;
LABEL_46:
      uint64_t v39 = 0LL;
      while (1)
      {
        if (*(void *)v78 != v38) {
          objc_enumerationMutation(v36);
        }
        int v40 = *(void **)(*((void *)&v77 + 1) + 8 * v39);
        double v41 = (const char *)objc_msgSend((id)objc_msgSend(v40, "name"), "UTF8String");
        uint64_t v42 = [v40 _entitysReferenceID];
        if ([v40 _propertyType] != 2 && objc_msgSend(v40, "_propertyType") != 6)
        {
          uint64_t v47 = [v40 _propertyType];
          uint64_t v45 = "@";
          if (v47 != 7) {
            uint64_t v45 = 0LL;
          }
          uint64_t v46 = 8LL * (v47 == 7);
          uint64_t v44 = 3;
          goto LABEL_78;
        }

        uint64_t v43 = [v40 attributeType];
        uint64_t v44 = 3;
        if (v43 <= 499)
        {
          uint64_t v45 = "q";
          if (v43 == 300)
          {
            uint64_t v46 = 8LL;
          }

          else
          {
            uint64_t v45 = 0LL;
            uint64_t v46 = 0LL;
          }

          if (v43 == 200)
          {
            uint64_t v45 = "i";
            uint64_t v44 = 2;
          }

          else
          {
            uint64_t v44 = 3;
          }

          if (v43 == 200) {
            uint64_t v46 = 4LL;
          }
          if (v43 == 100)
          {
            uint64_t v45 = "s";
            uint64_t v44 = 1;
            uint64_t v46 = 2LL;
          }

          goto LABEL_78;
        }

        if (v43 > 799)
        {
          if (v43 == 800)
          {
            uint64_t v44 = 0;
            uint64_t v45 = "c";
            uint64_t v46 = 1LL;
            goto LABEL_78;
          }

          if (v43 != 900)
          {
            uint64_t v45 = 0LL;
            uint64_t v46 = 0LL;
            goto LABEL_78;
          }
        }

        else if (v43 != 500)
        {
          uint64_t v45 = "f";
          if (v43 == 600)
          {
            uint64_t v44 = 2;
          }

          else
          {
            uint64_t v45 = 0LL;
            uint64_t v44 = 3;
          }

          uint64_t v46 = 4LL;
          if (v43 != 600) {
            uint64_t v46 = 0LL;
          }
          goto LABEL_78;
        }

        uint64_t v45 = "d";
        uint64_t v46 = 8LL;
LABEL_78:
        if (v45) {
          int v48 = v45;
        }
        else {
          int v48 = "@";
        }
        if (v45) {
          uint64_t v49 = v44;
        }
        else {
          uint64_t v49 = 3;
        }
        if (v45) {
          BOOL v50 = v46;
        }
        else {
          BOOL v50 = 8LL;
        }
        *(_BYTE *)(*((void *)IndexedIvars + 7) + v42) = *v48;
        if (!class_addIvar(v26, v41, v50, v49, v48)) {
          goto LABEL_111;
        }
        if (v37 == ++v39)
        {
          int v51 = [v36 countByEnumeratingWithState:&v77 objects:v88 count:16];
          int v37 = v51;
          if (!v51) {
            goto LABEL_92;
          }
          goto LABEL_46;
        }
      }
    }
  }

  objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"Entity name must not be nil." userInfo:0]);
LABEL_111:
  objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58] reason:@"class_addIvar failed" userInfo:0]);
LABEL_112:
  __break(1u);
  return result;
}

LABEL_182:
            uint64_t v9 = v171;
            if ((v175 & 1) == 0)
            {
              uint64_t v123 = (unsigned int *)v185;
              [v185 knownKeyValuesPointer];
              -[NSPersistentStoreCache registerRow:forObjectID:options:](v164, v123, v178, 0);
              unint64_t v7 = v173;
              BOOL v22 = v182;
              unsigned int v11 = v172;
              uint64_t v3 = v177;
LABEL_186:
              uint64_t v27 = v183;
              switch(v11)
              {
                case 0u:
                case 3u:
                  id v125 = -[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( v22,  v178,  v166);
                  uint64_t v36 = v125;
                  if ((v175 & 1) != 0) {
                    goto LABEL_203;
                  }
                  uint64_t v27 = v183;
                  if (!v125) {
                    goto LABEL_191;
                  }
                  int v126 = *((_DWORD *)v125 + 4);
                  if ((v126 & 0x200) != 0)
                  {
                    if (v123)
                    {
                      uint64_t v132 = v123 + 3;
                      do
                        signed int v133 = __ldaxr(v132);
                      while (__stlxr(v133, v132));
                      if (v133 <= 0)
                      {
                        do
                          unsigned int v134 = __ldxr(v132);
                        while (__stxr(v134 + 1, v132));
                      }
                    }
                  }

                  else
                  {
                    *((_DWORD *)v125 + 4) = v126 | 0x200;
LABEL_191:
                    if (v123)
                    {
                      uint64_t v127 = v123 + 3;
                      do
                        unsigned int v128 = __ldxr(v127);
                      while (__stxr(v128 + 1, v127));
                    }
                  }

                  break;
                case 1u:
                  uint64_t v123 = (unsigned int *)v178;
                  _PFfastOidRetain(0, (unint64_t)v178);
                  goto LABEL_202;
                case 2u:
                  uint64_t v36 = v123;
                  goto LABEL_204;
                default:
                  uint64_t v36 = 0LL;
                  goto LABEL_204;
              }

              goto LABEL_204;
            }

            unsigned int v11 = v172;
            unint64_t v7 = v173;
            BOOL v22 = v182;
            uint64_t v3 = v177;
            uint64_t v123 = (unsigned int *)v185;
            if (v172 != 2)
            {
              [v185 knownKeyValuesPointer];
              uint64_t v124 = v189;
              *(void *)&v181[8 * v28] = v124;

              goto LABEL_186;
            }

            goto LABEL_202;
          }
        }

        else
        {
          char v33 = v180;
          unint64_t v34 = v180[v28];
          unint64_t v35 = _PFSetPrimaryKey(v34, *(void *)(v12 + 24));
          uint64_t v36 = (void *)v34;
          if (v34 == v35)
          {
            if ((v13 & 2) == 0) {
              goto LABEL_58;
            }
          }

          else
          {
            int v37 = (void *)v35;

            v33[v28] = v37;
            if ((v13 & 2) == 0)
            {
              *(void *)(*(void *)(*(void *)&v181[8 * v28] + 40LL) + 16LL) = v37;
              uint64_t v36 = v37;
LABEL_58:
              v178 = v36;
              uint64_t v42 = *(void **)&v181[8 * v28];
              uint64_t v38 = v187;
              goto LABEL_59;
            }

            uint64_t v36 = v37;
          }
        }

        if (v11 - 1 >= 2)
        {
          if (!v11 || v11 == 3)
          {
            char v129 = v36;
            uint64_t v123 = (unsigned int *)-[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( v22,  v36,  v166);

LABEL_202:
            uint64_t v36 = v123;
            goto LABEL_203;
          }

          uint64_t v36 = 0LL;
        }

              uint64_t v108 = strsep(&v264, ",");
              if (!v108) {
                goto LABEL_193;
              }
            }
          }

          v253 = 0;
          LODWORD(v257) = 0;
          uint64_t v109 = 1;
LABEL_193:
          double v138 = v109 & 1;
          unsigned int v20 = v259;
          uint64_t v55 = v253;
        }

        else
        {
          if (v98 == (objc_class *)objc_opt_class())
          {
            LODWORD(v257) = 0;
            uint64_t v55 = 0;
            double v138 = 1;
          }

          else
          {
            uint64_t v55 = 0;
            unsigned int v137 = v100[2];
            double v138 = 1;
            unsigned int v54 = v19 >= v137;
            uint64_t v139 = v19 - v137;
            LODWORD(v257) = 0;
            if (v54)
            {
              uint64_t v140 = v100[3];
              unsigned int v20 = v259;
              if (v139 < v140)
              {
                uint64_t v141 = v13 + 2;
                uint64_t v142 = (char *)calloc(1uLL, v13 + 2);
                *uint64_t v142 = 95;
                unsigned int v143 = (const char *)v255;
                strlcat(v142, (const char *)v255, v141);
                if (!class_getInstanceVariable(v98, v143) && !class_getInstanceVariable(v98, v142))
                {
                  uint64_t v144 = [v8 name];
                  v145 = sel_getName(v254);
                  v146 = class_getName(v98);
                  v250 = v145;
                  v251 = v146;
                  v249 = v144;
                  _NSCoreDataLog( 2LL,  (uint64_t)@"dynamic accessors failed to find @property implementation for '%s' for entity '%@' while resolving selector '%s' on class '%s'.  Did you remember to declare it @dynamic or @synthesized in the @implementation ?",  v147,  v148,  v149,  v150,  v151,  v152,  (uint64_t)v255);
                }

                free(v142);
                LODWORD(v257) = 0;
                uint64_t v55 = 0;
                double v138 = 1;
              }

              goto LABEL_218;
            }
          }

          unsigned int v20 = v259;
        }

                        *(_WORD *)&variableColumn->super._flags &= ~1u;
                        goto LABEL_183;
                      }

                      if ((objc_msgSend( (id)objc_msgSend(v3, "objectForKey:", @"supportedKVCAggregates"),  "containsObject:",  v102) & 1) != 0 || objc_msgSend(v102, "isEqual:", @"@total"))
                      {
                        if (-[NSSQLProperty propertyType](self->_targetColumn, "propertyType") == 1)
                        {
                          else {
                            uint64_t v107 = (const __CFString *)objc_msgSend( (id)objc_msgSend(v102, "substringFromIndex:", 1),  "uppercaseString");
                          }
                          variableColumn = objc_alloc_init(&OBJC_CLASS___NSSQLColumn);
                          uint64_t v105 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:&stru_189EAC2E8];
                          [v105 appendString:v107];
                          objc_msgSend(v105, "appendString:", @"(");
                          if (!-[NSSQLIntermediate isUpdateColumnsScoped](self, "isUpdateColumnsScoped"))
                          {
                            [v105 appendString:self->_targetAlias];
                            [v105 appendString:@"."];
                          }

                          objc_msgSend( v105,  "appendString:",  -[NSSQLColumn columnName](self->_targetColumn, "columnName"));
                          size_t v106 = @" ");
                          goto LABEL_181;
                        }

                        uint64_t v108 = (void *)MEMORY[0x189603F70];
                        uint64_t v109 = *MEMORY[0x189603A60];
                        id v110 = [NSString stringWithFormat:@"Aggregate functions need to work on attributes: %@", self->super._expression, v141];
                      }

                      else
                      {
                        uint64_t v108 = (void *)MEMORY[0x189603F70];
                        uint64_t v109 = *MEMORY[0x189603A60];
                        id v110 = [NSString stringWithFormat:@"Unsupported KVC function in trailing keypath %@, %@", self->super._expression, self->_trailingKeypath];
                      }

                      objc_msgSend( v3,  "setObject:forKey:",  objc_msgSend(v108, "exceptionWithName:reason:userInfo:", v109, v110, 0),  @"NSUnderlyingException");
                      goto LABEL_189;
                    }

                    variableColumn = objc_alloc_init(&OBJC_CLASS___NSSQLColumn);
                    uint64_t v105 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:&stru_189EAC2E8];
                    if (!-[NSSQLIntermediate isUpdateColumnsScoped](self, "isUpdateColumnsScoped"))
                    {
                      [v105 appendString:self->_targetAlias];
                      [v105 appendString:@"."];
                    }

                    size_t v106 = -[NSSQLColumn columnName](self->_targetColumn, "columnName");
LABEL_181:
                    [v105 appendString:v106];
                    -[NSSQLColumn _setColumnName:]((uint64_t)variableColumn, v105);

                    if (!variableColumn) {
                      goto LABEL_183;
                    }
                    goto LABEL_182;
                  }

                  uint64_t v135 = *(void **)(v87 + 32);
LABEL_217:
                  char v136 = v135;
                  self->_variableAlias = v136;
                  self->_targetAlias = v136;
                  if (v88)
                  {
                    unsigned int v137 = [*(id *)(v88 + 16) destinationEntity];
                    if (v137)
                    {
                      Class v93 = *(void **)(v137 + 128);
                      goto LABEL_220;
                    }

                    goto LABEL_244;
                  }
                }

                else
                {
                  uint64_t v135 = 0LL;
                  uint64_t v89 = 0LL;
                  if ((v76 & 1) == 0) {
                    goto LABEL_217;
                  }
LABEL_134:
                  uint64_t v90 = v89;
                  self->_variableAlias = v90;
                  self->_targetAlias = v90;
                  if (v88)
                  {
                    uint64_t v91 = [*(id *)(v88 + 16) destinationEntity];
                    int v92 = [v147 lastObject];
                    if (v91)
                    {
                      Class v93 = (void *)[*(id *)(v91 + 40) objectForKey:v92];
LABEL_220:
                      -[NSSQLSubqueryExpressionIntermediate _setVariableColumn:]((uint64_t)self, v93);
                      goto LABEL_221;
                    }

LABEL_203:
        uint64_t v27 = v183;
LABEL_204:
        *((void *)v7 + v2_Block_object_dispose(va, 8) = v36;
        uint64_t v130 = *(unsigned int *)(v12 + 4);
        if ((v130 & 0x80000000) == 0)
        {
          uint64_t v131 = *(void *)(*v27 + 8 * v130);
          if (v131)
          {
            uint64_t v12 = v131 + *(void *)(v12 + 16);
            ++v28;
            uint64_t v29 = v187;
            if (v28 != v179) {
              continue;
            }
          }
        }

        break;
      }
    }

    uint64_t v26 = v163;
    if ((v13 & 2) == 0) {
      goto LABEL_217;
    }
LABEL_227:
    unsigned int v143 = v162;
    unsigned int v137 = v161;
    uint64_t v139 = v181;
    goto LABEL_228;
  }

  BOOL v21 = (_DWORD)v25 == +[NSSQLRow newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:]( &OBJC_CLASS___NSSQLRow,  "newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:",  v181,  v25,  *(void *)(v5 + 40),  v180,  *(double *)(v165 + 8));
  unsigned int v23 = v24;
  BOOL v22 = v182;
  if (v21) {
    goto LABEL_40;
  }
  PF_FREE_OBJECT_ARRAY(v7);
  unint64_t v7 = 0LL;
  uint64_t v26 = 0LL;
  BOOL v150 = 0;
LABEL_217:
  uint64_t v135 = v155;
  char v136 = !v174;
  if (!v155) {
    char v136 = 1;
  }
  unsigned int v137 = v161;
  if ((v136 & 1) != 0)
  {
    uint64_t v139 = v181;
    if (v11 != 2 && v150)
    {
      uint64_t v140 = (int)v26;
      uint64_t v141 = (void **)v181;
      do
      {
        uint64_t v142 = *v141++;

        --v140;
      }

      while (v140);
    }
  }

  else
  {
    double v138 = objc_alloc(&OBJC_CLASS____PFArray);
    uint64_t v139 = v181;
    *uint64_t v135 = -[_PFArray initWithObjects:count:andFlags:andContext:]( v138,  "initWithObjects:count:andFlags:andContext:",  v181,  v26,  26LL,  v182);
  }

  unsigned int v143 = v162;
LABEL_228:
  if (v137 >= 0x201) {
    NSZoneFree(0LL, v139);
  }
  if (v143 >= 0x201) {
    NSZoneFree(0LL, v180);
  }
  if (v11 > 3) {
    uint64_t v144 = 10LL;
  }
  else {
    uint64_t v144 = dword_1868D6260[v11];
  }
  v145 = objc_alloc(&OBJC_CLASS____PFArray);
  return (uint64_t)-[_PFArray initWithObjects:count:andFlags:andContext:]( v145,  "initWithObjects:count:andFlags:andContext:",  v7,  v26,  v144,  v182);
}

                        ++v97;
                        if (v82 == ++v96) {
                          goto LABEL_209;
                        }
                        continue;
                      }
                    }

_PFArray *_prepareResultsFromResultSet_0(uint64_t a1, uint64_t *a2, void *a3)
{
  double v138 = a2;
  uint64_t v175 = *MEMORY[0x1895F89C0];
  if (a3) {
    uint64_t v5 = a3[17];
  }
  else {
    uint64_t v5 = 0LL;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 4);
  uint64_t v149 = *(void *)(v5 + 56);
  if (v6 <= 0x40000000) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = 0;
  }
  uint64_t v8 = PF_ALLOCATE_OBJECT_ARRAY((int)v7);
  if (v8) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = 0LL;
  }
  unint64_t v167 = *(unsigned int *)(v5 + 72);
  uint64_t v10 = (v167 >> 2) & 7;
  unsigned int v172 = a3;
  uint64_t v150 = a1;
  if (a3)
  {
    uint64_t v11 = a3[4];
    uint64_t v12 = *(uint64_t **)(a1 + 64);
    BOOL v174 = (void *)(a1 + 64);
    uint64_t v13 = *v12;
    if ((_DWORD)v10 == 3) {
      uint64_t v151 = a3[16];
    }
    else {
      uint64_t v151 = 0LL;
    }
    uint64_t v14 = [*(id *)(v5 + 8) _disablePersistentStoreResultCaching];
    int v160 = v14;
    if (v11)
    {
      int v161 = *(_BYTE *)(v11 + 43) & 1;
      goto LABEL_15;
    }
  }

  else
  {
    uint64_t v131 = *(uint64_t **)(a1 + 64);
    BOOL v174 = (void *)(a1 + 64);
    uint64_t v13 = *v131;
    uint64_t v14 = [*(id *)(v5 + 8) _disablePersistentStoreResultCaching];
    int v160 = v14;
    uint64_t v151 = 0LL;
    uint64_t v11 = 0LL;
  }

  int v161 = 0;
LABEL_15:
  int v165 = *(_DWORD *)(v5 + 72);
  MEMORY[0x1895F8858](v14);
  unsigned int v140 = v17;
  if (v17 > 0x200)
  {
    uint64_t v18 = NSAllocateScannedUncollectable();
    uint64_t v166 = (_BYTE *)v18;
  }

  else
  {
    uint64_t v166 = &v136[-v16];
    bzero(&v136[-v16], 8LL * v15);
  }

  MEMORY[0x1895F8858](v18);
  BOOL v21 = (id *)&v136[-v20];
  unsigned int v141 = v22;
  if (v22 > 0x200) {
    BOOL v21 = (id *)NSAllocateScannedUncollectable();
  }
  else {
    bzero(&v136[-v20], 8LL * v19);
  }
  uint64_t v163 = v21;
  if (v166) {
    BOOL v23 = v21 == 0LL;
  }
  else {
    BOOL v23 = 1;
  }
  if (v23)
  {
    PF_FREE_OBJECT_ARRAY(v8);
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
  }

  BOOL v24 = v172 == 0LL;
  uint64_t v148 = sel_setForeignEntityKeySlot_entityKey_;
  uint64_t v147 = +[NSSQLRow instanceMethodForSelector:](&OBJC_CLASS___NSSQLRow, "instanceMethodForSelector:");
  char v155 = sel_setForeignKeySlot_int64_;
  BOOL v154 = (void (*)(unsigned int *, char *, void, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  v146 = sel_setForeignOrderKeySlot_orderKey_;
  uint64_t v145 = +[NSSQLRow instanceMethodForSelector:](&OBJC_CLASS___NSSQLRow, "instanceMethodForSelector:");
  uint64_t v153 = sel_setOptLock_;
  unsigned int v152 = (void (*)(unsigned int *, char *, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  if (v24)
  {
    id v142 = (id)[MEMORY[0x1896078A8] defaultManager];
    id v170 = 0LL;
    BOOL v137 = 0;
  }

  else
  {
    id v170 = (objc_class *)[(id)v172[1] objectIDFactoryForSQLEntity:*(void *)(v5 + 40)];
    id v142 = (id)[MEMORY[0x1896078A8] defaultManager];
    BOOL v137 = *((_BYTE *)v172 + 201) != 0;
  }

  uint64_t v158 = v10;
  uint64_t v159 = v11;
  if ((v165 & 1) == 0)
  {
    BOOL v25 = (v167 & 2) == 0;
    else {
      uint64_t v26 = 0LL;
    }
    if ((_DWORD)v26) {
      BOOL v27 = v25;
    }
    else {
      BOOL v27 = 0;
    }
    if (v27)
    {
      if ((_DWORD)v26 != +[NSSQLRow newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:]( &OBJC_CLASS___NSSQLRow,  "newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:",  v163,  v26,  *(void *)(v5 + 40),  v166,  *(double *)(v150 + 8)))
      {
LABEL_38:
        PF_FREE_OBJECT_ARRAY(v8);
        int v28 = 0;
        uint64_t v9 = 0LL;
        uint64_t v8 = 0LL;
        goto LABEL_220;
      }
    }

    else if (!(_DWORD)v26)
    {
      goto LABEL_38;
    }
  }

  if ((int)v9 >= 1)
  {
    uint64_t v173 = 0LL;
    uint64_t v29 = 0LL;
    uint64_t v139 = 0LL;
    id v144 = 0LL;
    uint64_t v143 = 0LL;
    uint64_t v162 = v9;
    uint64_t v156 = v9;
    uint64_t v157 = v8;
    while (1)
    {
      while ((*(_DWORD *)v13 & 0x80000000) != 0)
      {
        uint64_t v30 = *(unsigned int *)(v13 + 4);
        if ((v30 & 0x80000000) != 0) {
          uint64_t v13 = 0LL;
        }
        else {
          uint64_t v13 = *(void *)(*v174 + 8 * v30) + *(void *)(v13 + 16);
        }
      }

      if (v172) {
        uint64_t v31 = v172[14];
      }
      else {
        uint64_t v31 = 0LL;
      }
      int v32 = (void *)_sqlEntityForEntityID(v31, *(unsigned int *)(v13 + 8));
      char v33 = v170;
      if (v32 != v29) {
        char v33 = 0LL;
      }
      id v170 = v33;
      uint64_t v171 = v32;
      if (v172 && v32 != v29) {
        id v170 = (objc_class *)[(id)v172[1] objectIDFactoryForSQLEntity:v171];
      }
      if ((v165 & 1) != 0)
      {
        uint64_t v39 = (unsigned int *)[[v170 alloc] initWithPK64:*(void *)(v13 + 24)];
        uint64_t v36 = v39;
        if ((v167 & 2) != 0) {
          goto LABEL_185;
        }
        uint64_t v164 = v39;
        int v40 = v171;
        double v41 = +[NSSQLRow allocForSQLEntity:]((uint64_t)&OBJC_CLASS___NSSQLRow, v171);
        uint64_t v42 = [v41 initWithSQLEntity:v40 ownedObjectID:v164 andTimestamp:*(double *)(v150 + 8)];
        v163[v173] = (id)v42;
      }

      else
      {
        unint64_t v34 = *(void *)&v166[8 * v173];
        unint64_t v35 = _PFSetPrimaryKey(v34, *(void *)(v13 + 24));
        uint64_t v36 = (unsigned int *)v35;
        if (v34 == v35)
        {
          uint64_t v36 = (unsigned int *)v34;
          if ((v167 & 2) != 0)
          {
LABEL_185:
            if ((v10 - 1) >= 2)
            {
              if ((_DWORD)v10 && (_DWORD)v10 != 3)
              {
LABEL_203:
                uint64_t v36 = 0LL;
              }

              else
              {
                uint64_t v109 = v36;
                id v110 = (unsigned int *)-[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( (void **)v11,  v36,  v151);
                uint64_t v111 = v109;
                uint64_t v112 = v110;

                uint64_t v36 = v112;
              }
            }

            goto LABEL_210;
          }
        }

        else
        {
          uint64_t v37 = v173;
          *(void *)&v166[8 * v173] = v35;
          if ((v167 & 2) != 0) {
            goto LABEL_185;
          }
          uint64_t v38 = (unsigned int *)v35;
          objc_msgSend(v163[v37], "setObjectID:");
          uint64_t v36 = v38;
        }

        uint64_t v164 = v36;
        uint64_t v42 = (uint64_t)v163[v173];
      }

      v169 = (unsigned int *)v42;
      uint64_t v43 = *(char **)(v42 + 40);
      unint64_t plan_for_entity = _sql_fetch_plan_for_entity((unint64_t *)v171);
      uint64_t v45 = *(unsigned int *)(plan_for_entity + 4);
      if ((_DWORD)v45)
      {
        uint64_t v46 = (char *)(v13 + 32);
        v168 = v43 + 28;
        uint64_t v47 = (id *)(plan_for_entity + 24);
        while (1)
        {
          int v48 = *((unsigned __int8 *)v47 - 4);
          else {
            uint64_t v49 = qword_1868D6998[(char)(v48 - 2)];
          }
          uint64_t v46 = (char *)((unint64_t)&v46[v49] & ~v49);
          if ((*(_BYTE *)(v47 - 1) & 1) != 0)
          {
            int v51 = *v46++;
            BOOL v50 = v51 != 0;
          }

          else
          {
            BOOL v50 = 0;
          }

          uint64_t v52 = (unsigned int *)(v47 - 2);
          uint64_t v53 = ~v49;
          switch(*((_BYTE *)v47 - 4))
          {
            case 1:
              uint64_t v65 = (char *)((unint64_t)&v46[v49] & v53);
              if (v50) {
                int v60 = v46;
              }
              else {
                int v60 = v65 + 4;
              }
              int v66 = *((unsigned __int8 *)v47 - 3);
              if (v66 == 10)
              {
                uint64_t v90 = *v52;
                if (v50)
                {
                  uint64_t v91 = v146;
                  int v92 = &v176;
LABEL_131:
                  ((void (*)(unsigned int *, char *, uint64_t, void))*(v92 - 32))(v169, v91, v90, 0LL);
LABEL_144:
                  uint64_t v46 = v60;
                  goto LABEL_177;
                }

                unsigned int v95 = v146;
                double v96 = &v176;
LABEL_143:
                ((void (*)(unsigned int *, char *, uint64_t, void))*(v96 - 32))( v169,  v95,  v90,  *(unsigned int *)v65);
                goto LABEL_144;
              }

              if (v66 == 4)
              {
                uint64_t v90 = *v52;
                if (v50)
                {
                  uint64_t v91 = v148;
                  int v92 = &v177;
                  goto LABEL_131;
                }

                unsigned int v95 = v148;
                double v96 = &v177;
                goto LABEL_143;
              }

              if (v66 != 1) {
                goto LABEL_109;
              }
              id v67 = *v47;
              if (v50)
              {
                if (!objc_msgSend((id)objc_msgSend(v67, "propertyDescription"), "superCompositeAttribute")) {
                  goto LABEL_104;
                }
                goto LABEL_103;
              }

              if (objc_msgSend((id)objc_msgSend(v67, "propertyDescription"), "superCompositeAttribute"))
              {
                setMultiColumnValueDictionary_0( v43,  v47 - 2,  [MEMORY[0x189607968] numberWithInt:*(unsigned int *)v65]);
                uint64_t v46 = v65 + 4;
              }

              else
              {
                uint64_t v102 = *v52;
                Class Class = object_getClass(v43);
                int v104 = *(char *)(*((void *)object_getIndexedIvars(Class) + 7) + v102);
                if (v104 == 99)
                {
                  snapshot_set_int8(v43, *v52, *v65);
                  uint64_t v46 = v65 + 4;
                }

                else
                {
                  if (v104 == 115) {
                    snapshot_set_int16(v43, *v52, *(_WORD *)v65);
                  }
                  else {
                    snapshot_set_int32(v43, *v52, *(_DWORD *)v65);
                  }
                  uint64_t v46 = v65 + 4;
                }
              }

LABEL_177:
              v47 += 3;
              if (!--v45) {
                goto LABEL_189;
              }
              break;
            case 2:
            case 3:
              uint64_t v59 = (void *)((unint64_t)&v46[v49] & v53);
              if (v50) {
                int v60 = v46;
              }
              else {
                int v60 = (char *)(v59 + 1);
              }
              int v61 = *((unsigned __int8 *)v47 - 3);
              switch(v61)
              {
                case 6:
                  if (v50) {
                    uint64_t v77 = 0LL;
                  }
                  else {
                    uint64_t v77 = *v59;
                  }
                  v152(v169, v153, v77);
                  uint64_t v46 = v60;
                  break;
                case 3:
                  if (v50) {
                    uint64_t v76 = 0LL;
                  }
                  else {
                    uint64_t v76 = *v59;
                  }
                  v154(v169, v155, *v52, v76);
                  uint64_t v46 = v60;
                  break;
                case 1:
                  id v62 = *v47;
                  if (v50)
                  {
                    if (!objc_msgSend((id)objc_msgSend(v62, "propertyDescription"), "superCompositeAttribute")) {
                      goto LABEL_104;
                    }
                    goto LABEL_103;
                  }

                  uint64_t v93 = objc_msgSend((id)objc_msgSend(v62, "propertyDescription"), "superCompositeAttribute");
                  uint64_t v94 = *v59;
                  if (v93) {
                    setMultiColumnValueDictionary_0( v43,  v47 - 2,  [MEMORY[0x189607968] numberWithLongLong:v94]);
                  }
                  else {
                    snapshot_set_int64(v43, *v52, v94);
                  }
                  uint64_t v46 = (char *)(v59 + 1);
                  break;
                default:
LABEL_109:
                  uint64_t v46 = v60;
                  break;
              }

              goto LABEL_177;
            case 4:
            case 5:
            case 6:
            case 9:
            case 0xC:
              if (v50) {
                goto LABEL_91;
              }
              unsigned int v54 = (const char *)((unint64_t)&v46[v49] & v53);
              uint64_t v55 = (__CFString *)CFStringCreateWithCString(0LL, v54 + 4, 0x8000100u);
              uint64_t v56 = *(int *)v54;
              int v57 = *((unsigned __int8 *)v47 - 4);
              if (v57 == 12)
              {
                unsigned int v68 = (__CFString *)(id)[MEMORY[0x189604030] URLWithString:v55];
                CFRelease(v55);
                uint64_t v55 = v68;
              }

              else if (v57 == 4)
              {
                uint64_t v58 = [objc_alloc(MEMORY[0x189607858]) initWithString:v55];
                CFRelease(v55);
                uint64_t v55 = (__CFString *)v58;
              }

              uint64_t v46 = (char *)&v54[v56 + 4];
              if (!objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute")) {
                goto LABEL_176;
              }
              goto LABEL_107;
            case 7:
            case 8:
              if (v50) {
                goto LABEL_91;
              }
              int v64 = (double *)((unint64_t)&v46[v49] & v53);
              uint64_t v46 = (char *)(v64 + 1);
              if (objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute"))
              {
                setMultiColumnValueDictionary_0( v43,  v47 - 2,  [MEMORY[0x189607968] numberWithDouble:*v64]);
              }

              else
              {
                uint64_t v84 = *((unsigned int *)v47 - 4);
                if (*((_BYTE *)v47 - 4) == 7)
                {
                  Class v85 = object_getClass(v43);
                  IndexedIvars = object_getIndexedIvars(v85);
                  unsigned int v87 = *v52;
                  double v88 = *v64;
                  if (*(_BYTE *)(IndexedIvars[7] + v84) == 102)
                  {
                    float v89 = v88;
                    snapshot_set_float(v43, v87, v89);
                  }

                  else
                  {
                    snapshot_set_double(v43, v87, v88);
                  }
                }

                else
                {
                  snapshot_set_double(v43, *((_DWORD *)v47 - 4), *v64);
                }
              }

              goto LABEL_177;
            case 0xD:
            case 0xE:
              goto LABEL_177;
            case 0x10:
              uint64_t v63 = (void *)[*v47 propertyDescription];
              if (v161 && ([v63 _isFileBackedFuture] & 1) == 0) {
                goto LABEL_90;
              }
              if (!v50)
              {
                uint64_t v78 = (int *)((unint64_t)&v46[v49] & v53);
                int v80 = v78 + 1;
                int v79 = *((unsigned __int8 *)v78 + 4);
                if (v79 == 3)
                {
                  if (v172 && !v143) {
                    uint64_t v143 = v172[13];
                  }
                  uint64_t v97 = [MEMORY[0x189603F48] dataWithBytes:((unint64_t)&v46[v49] & v53) + 4 length:*v78];
                  uint64_t v98 = objc_alloc(&OBJC_CLASS____NSDataFileBackedFuture);
                  uint64_t v83 = -[_NSDataFileBackedFuture initWithStoreMetadata:directory:]( v98,  "initWithStoreMetadata:directory:",  v97,  [MEMORY[0x189604030] fileURLWithPath:v143 isDirectory:1]);
LABEL_174:
                  uint64_t v55 = (__CFString *)v83;
                }

                else
                {
                  if (v79 == 1)
                  {
                    uint64_t v81 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                    if (v172) {
                      uint64_t v82 = *((unsigned int *)v172 + 46);
                    }
                    else {
                      uint64_t v82 = 0LL;
                    }
                    uint64_t v83 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v81,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  ((unint64_t)&v46[v49] & v53) + 4,  *v78,  0LL,  0LL,  v82);
                    goto LABEL_174;
                  }

                  size_t v99 = strnlen((const char *)v78 + 5, *v78 - 1LL);
                  uint64_t v100 = [v142 stringWithFileSystemRepresentation:(char *)v78 + 5 length:v99];
                  uint64_t v101 = v139;
                  if (v139)
                  {
                    if (!v172) {
                      goto LABEL_169;
                    }
LABEL_167:
                    if (!v144) {
                      id v144 = (id)v172[12];
                    }
                  }

                  else
                  {
                    if (v172)
                    {
                      uint64_t v101 = (void *)v172[11];
                      goto LABEL_167;
                    }

                    uint64_t v101 = 0LL;
                  }

LABEL_169:
                  uint64_t v139 = v101;
                  uint64_t v105 = [v101 stringByAppendingPathComponent:v100];
                  uint64_t v106 = [v144 stringByAppendingPathComponent:v100];
                  if (!v137 || [v142 fileExistsAtPath:v105])
                  {
                    uint64_t v107 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                    if (v172) {
                      uint64_t v108 = *((unsigned int *)v172 + 46);
                    }
                    else {
                      uint64_t v108 = 0LL;
                    }
                    uint64_t v83 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v107,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  v80,  *v78,  v105,  v106,  v108);
                    goto LABEL_174;
                  }

                  uint64_t v55 = 0LL;
                }

                uint64_t v46 = (char *)v80 + *v78;
                if (objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute"))
                {
LABEL_107:
                  setMultiColumnValueDictionary_0(v43, v47 - 2, (uint64_t)v55);
                }

                else
                {
LABEL_176:
                  snapshot_set_object(v43, *v52, (uint64_t)v55);
                }

                goto LABEL_177;
              }

              if (!objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute")) {
                goto LABEL_104;
              }
LABEL_103:
              setMultiColumnValueNullFlag(v43, (_DWORD *)v47 - 4);
              goto LABEL_177;
            default:
LABEL_90:
              if (v50)
              {
LABEL_91:
                if (objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute")) {
                  goto LABEL_103;
                }
LABEL_104:
                v168[(unint64_t)*v52 >> 3] |= 1 << (*v52 & 7);
              }

              else
              {
                int v69 = (const UInt8 *)((unint64_t)&v46[v49] & v53);
                CFAllocatorRef v70 = (int *)(v69 + 4);
                CFDataRef v71 = CFDataCreate(0LL, v69 + 4, *(int *)v69);
                CFDataRef v72 = v71;
                uint64_t v73 = *(int *)v69;
                int v74 = *((unsigned __int8 *)v47 - 4);
                if (v74 == 11)
                {
                  if (-[__CFData length](v71, "length") == 16)
                  {
                    id v75 = (id)objc_msgSend( objc_alloc(MEMORY[0x189607AB8]),  "initWithUUIDBytes:",  -[__CFData bytes](v72, "bytes"));
                    CFRelease(v72);
                  }

                  else
                  {

                    id v75 = 0LL;
                  }
                }

                else if (v74 == 15)
                {
                  id v75 = +[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)v71,  (void *)[*v47 propertyDescription]);
                  CFRelease(v72);
                }

                else
                {
                  id v75 = v71;
                }

                if (objc_msgSend((id)objc_msgSend(*v47, "propertyDescription"), "superCompositeAttribute")) {
                  setMultiColumnValueDictionary_0(v43, v47 - 2, (uint64_t)v75);
                }
                else {
                  snapshot_set_object(v43, *v52, (uint64_t)v75);
                }

                uint64_t v46 = (char *)v70 + v73;
              }

              goto LABEL_177;
          }
        }
      }

LABEL_189:
      if ((v160 & 1) == 0) {
        break;
      }
      uint64_t v8 = v157;
      uint64_t v10 = v158;
      uint64_t v9 = v156;
      uint64_t v11 = v159;
      if ((_DWORD)v158 != 2)
      {
        [v169 knownKeyValuesPointer];
        uint64_t v113 = v43;
        v163[v173] = v113;

        goto LABEL_193;
      }

          uint64_t v31 = 0LL;
          v164[v30] = v72;
          goto LABEL_190;
      }
    }
  }

LABEL_202:
      uint64_t v36 = v169;
LABEL_210:
      uint64_t v123 = v173;
      *((void *)v8 + v173) = v36;
      uint64_t v124 = *(unsigned int *)(v13 + 4);
      if ((v124 & 0x80000000) == 0)
      {
        uint64_t v125 = *(void *)(*v174 + 8 * v124);
        uint64_t v13 = v125 + *(void *)(v13 + 16);
        uint64_t v126 = v123 + 1;
        uint64_t v173 = v126;
        BOOL v127 = !v125 || v126 == v162;
        uint64_t v29 = v171;
        if (!v127) {
          continue;
        }
      }

      int v28 = 1;
      goto LABEL_220;
    }

    uint64_t v8 = v157;
    uint64_t v10 = v158;
    uint64_t v9 = v156;
    uint64_t v11 = v159;
    [v169 knownKeyValuesPointer];
    -[NSPersistentStoreCache registerRow:forObjectID:options:](v149, v169, v164, 0);
LABEL_193:
    switch((int)v10)
    {
      case 0:
      case 3:
        v114 = (unsigned int *)-[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( (void **)v11,  v164,  v151);
        uint64_t v36 = v114;
        uint64_t v115 = v169;
        if ((v160 & 1) != 0) {
          goto LABEL_210;
        }
        if (!v114) {
          goto LABEL_198;
        }
        unsigned int v116 = v114[4];
        if ((v116 & 0x200) != 0)
        {
          if (v169)
          {
            char v120 = v169 + 3;
            do
              signed int v121 = __ldaxr(v120);
            while (__stlxr(v121, v120));
            if (v121 <= 0)
            {
              do
                unsigned int v122 = __ldxr(v120);
              while (__stxr(v122 + 1, v120));
            }
          }
        }

        else
        {
          v114[4] = v116 | 0x200;
LABEL_198:
          if (v115)
          {
            int v117 = v115 + 3;
            do
              unsigned int v118 = __ldxr(v117);
            while (__stxr(v118 + 1, v117));
          }
        }

        break;
      case 1:
        char v119 = v164;
        _PFfastOidRetain(0, (unint64_t)v164);
        uint64_t v36 = v119;
        goto LABEL_210;
      case 2:
        goto LABEL_202;
      default:
        goto LABEL_203;
    }

    goto LABEL_210;
  }

  int v28 = 0;
LABEL_220:
  unsigned int v128 = v166;
  if ((v167 & 2) == 0)
  {
    if (v138 && (_DWORD)v10 == 3)
    {
      uint64_t v11 = v159;
      char v129 = objc_alloc(&OBJC_CLASS____PFArray);
      uint64_t v130 = -[_PFArray initWithObjects:count:andFlags:andContext:]( v129,  "initWithObjects:count:andFlags:andContext:",  v163,  v9,  26LL,  v11);
      *double v138 = v130;
    }

    else if ((v167 & 2) != 0 || (_DWORD)v10 == 2 || !v28)
    {
      uint64_t v11 = v159;
    }

    else
    {
      uint64_t v132 = (int)v9;
      signed int v133 = v163;
      uint64_t v11 = v159;
      do
      {

        --v132;
      }

      while (v132);
    }
  }

  if (v141 >= 0x201) {
    NSZoneFree(0LL, v163);
  }
  if (v140 >= 0x201) {
    NSZoneFree(0LL, v128);
  }
  else {
    uint64_t v134 = dword_1868D6260[v10];
  }
  return -[_PFArray initWithObjects:count:andFlags:andContext:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:andContext:",  v8,  v9,  v134,  v11);
}

              if (!v56) {
                goto LABEL_452;
              }
              BOOL v154 = strncmp("will", v10, 4uLL);
              if (v154)
              {
                char v155 = strncmp("did", v10, 3uLL);
                uint64_t v156 = v256;
                if (v155) {
                  goto LABEL_274;
                }
                if (!strncmp("Change", v10 + 3, 6uLL))
                {
                  v256 = v156;
                  uint64_t v157 = 1;
                }

                else
                {
                  if (strncmp("Access", v10 + 3, 6uLL)) {
                    goto LABEL_274;
                  }
                  v256 = v156;
                  uint64_t v157 = 0;
                }

                uint64_t v176 = 9LL;
              }

              else
              {
                uint64_t v159 = strncmp("Change", v10 + 4, 6uLL);
                int v160 = v256;
                if (v159)
                {
                  if (strncmp("Access", v10 + 4, 6uLL)) {
                    goto LABEL_274;
                  }
                  v256 = v160;
                  uint64_t v157 = 0;
                }

                else
                {
                  uint64_t v157 = 1;
                }

                uint64_t v176 = 10LL;
              }

              if (v272)
              {
                if (v258) {
                  CFRelease(v258);
                }
              }

              else
              {
                v271 = v270;
              }

              int v187 = &v10[v176];
              unsigned int v188 = (const char *)v255;
              strlcpy((char *)v255, v187, v14);
              unsigned __int8 v189 = CFStringCreateWithCStringNoCopy(v12, v188, 0x600u, v16);
              uint64_t v190 = v257;
              v258 = v189;
              char v191 = objc_msgSend(v257, "indexForKey:");
              if (v191 != 0x7FFFFFFFFFFFFFFFLL) {
                goto LABEL_339;
              }
              if (v272)
              {
                if (v258) {
                  CFRelease(v258);
                }
              }

              else
              {
                v271 = v270;
              }

              v203 = (char *)v255;
              *v203 = __tolower(*(char *)v255);
              v258 = CFStringCreateWithCStringNoCopy(v12, v203, 0x600u, v16);
              char v191 = objc_msgSend(v190, "indexForKey:");
              int v19 = 0x7FFFFFFFFFFFFFFFLL;
              if (v191 != 0x7FFFFFFFFFFFFFFFLL)
              {
LABEL_339:
                v204 = v191;
                v205 = v259;
                if (v272)
                {
                  if (v258) {
                    CFRelease(v258);
                  }
                }

                else
                {
                  v271 = v270;
                }

                if (v154)
                {
                  if (!v157)
                  {
                    v207 = (id (*)(id, SEL, ...))pf_empty_method_imp;
LABEL_364:
                    class_addMethod(v205, v254, v207, "v@:");
                    LOBYTE(v6) = 1;
                    return v6;
                  }

                  v264 = (char *)MEMORY[0x1895F87A8];
                  v265 = 3221225472LL;
                  v266 = __generateAccessor_block_invoke;
                  v267 = &__block_descriptor_48_e8__16__0_8l;
                  v206 = _sharedIMPL_dcvfk_core;
                }

                else
                {
                  v264 = (char *)MEMORY[0x1895F87A8];
                  v265 = 3221225472LL;
                  v266 = __generateAccessor_block_invoke;
                  v267 = &__block_descriptor_48_e8__16__0_8l;
                  if (v157) {
                    v206 = _sharedIMPL_wcvfk_core;
                  }
                  else {
                    v206 = _PF_Handler_WillAccess_Property;
                  }
                }

                v268 = v206;
                v269 = v204;
                v207 = imp_implementationWithBlock(&v264);
                goto LABEL_364;
              }

void sub_1866A1AD8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866A19B0LL);
  }

  _Unwind_Resume(a1);
}

void sub_1866A1AF4(_Unwind_Exception *a1)
{
}

void sub_1866A1B18(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1866A1B24LL);
}

void *PF_ALLOCATE_OBJECT_ARRAY(uint64_t a1)
{
  uint64_t v2 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v2 = malloc_default_zone();
  }
  return malloc_zone_malloc(v2, 8 * a1);
}

uint64_t _PFModelMapSlotForEntity(uint64_t a1, void *a2)
{
  uint64_t v4 = objc_msgSend((id)objc_msgSend(a2, "managedObjectModel"), "_modelsReferenceIDOffset");
  if (a2)
  {
    uint64_t result = a2[20];
    if (a1) {
      goto LABEL_4;
    }
  }

  else
  {
    uint64_t result = 0LL;
    if (a1) {
      goto LABEL_4;
    }
  }

  if (v4)
  {
    uint64_t v10 = [NSString stringWithUTF8String:"Model map is unexpectedly nil"];
    _NSCoreDataLog(17LL, v10, v11, v12, v13, v14, v15, v16, v26);
    unsigned int v17 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_186681000, v17, OS_LOG_TYPE_FAULT, "CoreData: Model map is unexpectedly nil", buf, 2u);
    }

    uint64_t v18 = (void *)MEMORY[0x189603F70];
    uint64_t v19 = *MEMORY[0x189603A58];
    uint64_t v20 = @"Model map is nil";
    goto LABEL_23;
  }

LABEL_4:
  if (v4 > 16049)
  {
    switch(v4)
    {
      case 16050LL:
        uint64_t v9 = 0LL;
        unsigned int v6 = *(void **)(a1 + 64);
LABEL_15:
        uint64_t v8 = v9 + 1;
        result += v6[v9];
        goto LABEL_16;
      case 17000LL:
        uint64_t v7 = 0LL;
        unsigned int v6 = *(void **)(a1 + 64);
        goto LABEL_14;
      case 18000LL:
        unsigned int v6 = *(void **)(a1 + 64);
        result += *v6;
        uint64_t v7 = 1LL;
LABEL_14:
        uint64_t v9 = v7 + 1;
        result += v6[v7];
        goto LABEL_15;
    }

    while (1)
    {
LABEL_24:
      BOOL v21 = (void *)MEMORY[0x189603F70];
      uint64_t v22 = *MEMORY[0x189603A58];
      BOOL v23 = (void *)NSString;
      uint64_t v24 = v4;
      BOOL v25 = (objc_class *)objc_opt_class();
      uint64_t v20 = (const __CFString *)[v23 stringWithFormat:@"Managed object model with offset %lu is not known to %@", v24, NSStringFromClass(v25)];
      uint64_t v18 = v21;
      uint64_t v19 = v22;
LABEL_23:
      objc_exception_throw((id)[v18 exceptionWithName:v19 reason:v20 userInfo:0]);
    }
  }

  if (!v4) {
    return result;
  }
  if (v4 != 16000) {
    goto LABEL_24;
  }
  uint64_t v8 = 0LL;
  unsigned int v6 = *(void **)(a1 + 64);
LABEL_16:
  result += v6[v8];
  return result;
}

  if (parent_buffer) {
    metadata = parent_buffer->_metadata;
  }
  else {
    metadata = 0LL;
  }
  uint64_t v10 = -[NSKnownKeysDictionary mapping](metadata, "mapping");
  if (-[NSKnownKeysMappingStrategy length](v10, "length") <= a3) {
    goto LABEL_29;
  }
  uint64_t v11 = self + 1;
  uint64_t v12 = (&self[1].super.super.isa)[a3];
  if (!v12) {
    goto LABEL_29;
  }
  uint64_t v13 = 0LL;
  if (a3)
  {
    uint64_t v14 = self + 1;
    uint64_t v15 = a3;
    do
    {
      isa = v14->super.super.isa;
      uint64_t v14 = (_PFResultObject *)((char *)v14 + 8);
      v13 += (uint64_t)isa;
      --v15;
    }

    while (v15);
  }

  uint64_t v109 = -[NSKnownKeysMappingStrategy length](v10, "length");
  unsigned int v17 = -[NSKnownKeysDictionary valueAtIndex:](metadata, "valueAtIndex:", a3);
  if (a3 < 6 || self->_sql_entity_id != 16001) {
    goto LABEL_22;
  }
  if (!self[1]._primary_key)
  {
LABEL_29:
    objc_autoreleasePoolPop(v5);
    return 0LL;
  }

  uint64_t v18 = vaddvq_s64(vaddq_s64(*(int64x2_t *)&self[1]._cd_rc, *(int64x2_t *)&self[1].super.super.isa));
  uint64_t v19 = *(void *)(((unint64_t)&(&v11->super.super.isa)[-[NSKnownKeysMappingStrategy length](v10, "length")]
                   + v18
                   + 7) & 0xFFFFFFFFFFFFFFF8LL);
  uint64_t v20 = self->_parent_buffer;
  uint64_t v107 = v12;
  uint64_t v108 = v5;
  if (v20 && (weakRequestStore = v20->_weakRequestStore) != 0LL) {
    WeakRetained = objc_loadWeakRetained(&weakRequestStore->_object);
  }
  else {
    WeakRetained = 0LL;
  }
  BOOL v23 = objc_msgSend((id)objc_msgSend(WeakRetained, "model"), "entityForID:", v19);
  uint64_t v24 = +[_PFPersistentHistoryModel _retainedTombstonesForEntity:]( (uint64_t)&OBJC_CLASS____PFPersistentHistoryModel,  (void *)v23);
  BOOL v25 = objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v17, "name"),  "stringByReplacingOccurrencesOfString:withString:",  @"TOMBSTONE",  &stru_189EAC2E8),  "intValue");
  if (v25 < (int)[v24 count])
  {
    uint64_t v26 = [v24 objectAtIndexedSubscript:v25];
    if (v23) {
      BOOL v27 = (void *)[*(id *)(v23 + 40) objectForKey:v26];
    }
    else {
      BOOL v27 = 0LL;
    }
    unsigned int v17 = (id)[v27 propertyDescription];
  }

  uint64_t v12 = v107;
  uint64_t v5 = v108;
LABEL_22:
  unint64_t v34 = (unsigned int *)(((unint64_t)&(&v11->super.super.isa)[v109] + v13 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  switch([v17 _propertyType])
  {
    case 2LL:
    case 6LL:
      double v41 = [v17 attributeType];
      goto LABEL_31;
    case 4LL:
      goto LABEL_64;
    case 5LL:
      double v41 = [v17 expressionResultType];
      if (v41)
      {
LABEL_31:
        if (v41 <= 799)
        {
          if (v41 > 399)
          {
            if (v41 <= 599)
            {
              if (v41 != 400)
              {
                if (v41 != 500) {
                  goto LABEL_45;
                }
                goto LABEL_84;
              }

              else {
                int v92 = -[_PFResultObject taggedStringFromPtr:withLength:]((CFStringRef)self, (char *)v34);
              }
              uint64_t v94 = v92;
              unsigned int v95 = (objc_class *)MEMORY[0x189607858];
              goto LABEL_118;
            }

            if (v41 == 600)
            {
LABEL_84:
              uint64_t v46 = (CFStringRef)[MEMORY[0x189607968] numberWithDouble:*(double *)v34];
              goto LABEL_105;
            }

            if (v41 == 700)
            {
              else {
                uint64_t v46 = -[_PFResultObject taggedStringFromPtr:withLength:]((CFStringRef)self, (char *)v34);
              }
              goto LABEL_105;
            }

            goto LABEL_45;
          }

          if (v41 != 100 && v41 != 200)
          {
            if (v41 != 300) {
              goto LABEL_45;
            }
            uint64_t v46 = (CFStringRef)[MEMORY[0x189607968] numberWithLongLong:*(void *)v34];
LABEL_105:
            uint64_t v45 = (__CFString *)v46;
            goto LABEL_106;
          }

  uint64_t v8 = 1;
LABEL_21:
  uint64_t v20 = v57;
  if (a3 && v57) {
    *a3 = v57;
  }
  [v43 drain];
  BOOL v21 = 0LL;
  uint64_t v22 = v57;
  BOOL v23 = v44;
  if (v8) {
    return v44;
  }
  else {
    return 0LL;
  }
}

  if (!key) {
    goto LABEL_15;
  }
LABEL_5:
  uint64_t v5 = (id *)_PFEntityForManagedObject(self);
  if (v5)
  {
    unsigned int v6 = [v5[13] indexForKey:key];
    if (v6 != 0x7FFFFFFFFFFFFFFFLL)
    {
      cd_extraFlags = self->_cd_extraFlags;
      if ((_DWORD)cd_extraFlags) {
        uint64_t v8 = (char *)self + cd_extraFlags;
      }
      else {
        uint64_t v8 = 0LL;
      }
    }
  }

  uint64_t v39 = 0u;
  int v40 = 0u;
  uint64_t v37 = 0u;
  uint64_t v38 = 0u;
  unsigned int v6 = -[NSArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v37,  v53,  16LL);
  if (v6)
  {
    uint64_t v7 = *(void *)v38;
LABEL_6:
    uint64_t v8 = 0LL;
    while (1)
    {
      if (*(void *)v38 != v7) {
        objc_enumerationMutation(obj);
      }
      if (!self)
      {
        uint64_t v22 = 0;
        goto LABEL_46;
      }

      uint64_t v9 = *(void **)(*((void *)&v37 + 1) + 8 * v8);
      uint64_t v10 = objc_msgSend((id)objc_msgSend(v9, "objectForKey:", @"newVersion"), "unsignedIntValue");
      uint64_t v11 = [v9 objectForKey:@"object"];
      uint64_t v12 = [(id)v11 managedObjectContext];
      uint64_t v13 = (void *)v12;
      if (v11) {
        uint64_t v14 = v12 == 0;
      }
      else {
        uint64_t v14 = 0;
      }
      if (v14)
      {
        uint64_t v13 = *(void **)(v11 + 32);
        if (v13)
        {
          uint64_t v15 = (void *)[(id)v11 objectID];
          uint64_t v16 = [v13 objectRegisteredForID:v15];
          if (v16 == v11)
          {
            *(_DWORD *)(v11 + 16) &= ~0x80u;
          }

          else if (!v16)
          {
            -[NSManagedObjectContext _registerObject:withID:]((uint64_t)v13, v11, v15);
          }
        }
      }

      type = self->_type;
      if ((_DWORD)v10)
      {
        switch(type)
        {
          case 1uLL:
            -[NSMergePolicy _mergeChangesStoreUpdatesTrumpForObject:withRecord:]( self,  "_mergeChangesStoreUpdatesTrumpForObject:withRecord:",  v11,  v9);
            objc_msgSend((id)v11, "_setVersionReference__:", v10);
            break;
          case 2uLL:
            if ((_BYTE)z9dsptsiQ80etb9782fsrs98bfdle88)
            {
              -[NSMergePolicy _mergeChangesObjectUpdatesTrumpForObject:withRecord:]( self,  "_mergeChangesObjectUpdatesTrumpForObject:withRecord:",  v11,  v9);
              objc_msgSend((id)v11, "_setVersionReference__:", v10);
            }

            else
            {
              [v13 refreshObject:v11 mergeChanges:1];
            }

            break;
          case 3uLL:
            if (([(id)v11 hasChanges] & 1) == 0) {
              _PFFastMOCObjectWillChange((uint64_t)v13, (_DWORD *)v11);
            }
            objc_msgSend((id)v11, "_setVersionReference__:", v10);
            break;
          case 4uLL:
            [v13 refreshObject:v11 mergeChanges:0];
            uint64_t v19 = (void *)[(id)v11 objectID];
            uint64_t v20 = (void *)[v19 persistentStore];
            if (@"NSXPCStore" == (__CFString *)[v20 type])
            {
              BOOL v21 = (void *)[v20 _persistentStoreCoordinator];
              uint64_t v46 = MEMORY[0x1895F87A8];
              uint64_t v47 = 3221225472LL;
              int v48 = (uint64_t)__33__NSMergePolicy_resolveConflict___block_invoke;
              uint64_t v49 = (void (*)(uint64_t, uint64_t))&unk_189EA7A38;
              BOOL v50 = (void (*)(uint64_t))v13;
              int v51 = (uint64_t)v20;
              uint64_t v52 = v19;
              [v21 performBlockAndWait:&v46];
            }

            break;
          default:
            break;
        }
      }

      else
      {
        if (type - 1 < 2) {
          goto LABEL_31;
        }
        if (type == 3)
        {
          if (([(id)v11 isDeleted] & 1) == 0 && (objc_msgSend((id)v11, "isInserted") & 1) == 0) {
            [v13 _forceInsertionForObject:v11];
          }
          goto LABEL_43;
        }

        if (type == 4) {
LABEL_31:
        }
          [v13 deleteObject:v11];
      }

  v29[0] = MEMORY[0x1895F87A8];
  v29[1] = 3221225472LL;
  v29[2] = __136__NSPersistentStoreCoordinator__NSInternalMethods___newOrderedRelationshipInformationForRelationship_forObjectWithID_withContext_error___block_invoke;
  v29[3] = &unk_189EA8EA0;
  v29[4] = self;
  v29[5] = a5;
  v29[6] = a3;
  v29[7] = a4;
  v29[8] = &v37;
  v29[9] = &v31;
  -[NSPersistentStoreCoordinator _routeLightweightBlock:toStore:]((unint64_t)self, (uint64_t)v29, v11);
  uint64_t v14 = (id)v32[5];
  if (a6)
  {
    uint64_t v15 = (void *)v32[5];
    if (v15) {
      *a6 = v15;
    }
  }

  uint64_t v16 = (void *)v38[5];
LABEL_8:
  _Block_object_dispose(&v31, 8);
  _Block_object_dispose(&v37, 8);
  return v16;
}

const void *_sqlEntityForEntityID(uint64_t a1, unint64_t a2)
{
  else {
    return 0LL;
  }
}

unint64_t _PFSetPrimaryKey(unint64_t a1, uint64_t a2)
{
  unint64_t v3 = a1;
  if ((a1 & 0x8000000000000000LL) == 0)
  {
    Class Class = object_getClass((id)a1);
    if ((*((_BYTE *)object_getIndexedIvars(Class) + 4) & 1) != 0)
    {
      if (HIWORD(a2))
      {
        id v11 = objc_alloc(_PFFallbackFactoryForOID((void *)v3));
        return [v11 initWithPK64:a2];
      }

      *(void *)(v3 + 8) |= a2 << 16;
    }

    else
    {
      *(void *)(v3 + 16) = a2;
    }

    return v3;
  }

  if (a2 <= 0x3FFFFFFFFFFLL)
  {
    if ((~a1 & 0xC000000000000007LL) != 0) {
      int v4 = *MEMORY[0x189616658];
    }
    else {
      int v4 = 7;
    }
    unint64_t v3 = (v4 ^ a1) & 0x1FFFF0 | (unint64_t)(a2 << 21) | 0x8000000000000005LL;
    unint64_t v5 = v3 ^ *MEMORY[0x189616658];
    if ((~v5 & 0xC000000000000007LL) != 0) {
      return v5 & 0xFFFFFFFFFFFFFFF8LL | *(unsigned __int8 *)(MEMORY[0x189616648] + (v5 & 7));
    }
    return v3;
  }

  int v7 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    int v7 = 7;
  }
  uint64_t v8 = (unint64_t *)(_PFTaggedPointersPool + 32 * (((unint64_t)(v7 ^ a1) >> 4) & 0x1FFFF));
  uint64_t v9 = (void *)atomic_load(v8);
  unint64_t v10 = atomic_load(v8 + 1);
  id v11 = (id)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v9, "objectIDFactoryForEntity:", v10), "_fallbackFactory"),  "alloc");
  return [v11 initWithPK64:a2];
}

void *_PFAllocateObject(Class cls, uint64_t a2)
{
  int v4 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    int v4 = malloc_default_zone();
  }
  size_t InstanceSize = class_getInstanceSize(cls);
  unsigned int v6 = malloc_zone_calloc(v4, 1uLL, ((InstanceSize + 7) & 0xFFFFFFFFFFFFFFF8LL) + a2);
  int v7 = v6;
  if (*MEMORY[0x1896049A0])
  {
    class_getName(cls);
    __CFSetLastAllocationEventName();
    if (!v7) {
      return v7;
    }
    goto LABEL_5;
  }

  if (v6) {
LABEL_5:
  }
    objc_constructInstance(cls, v7);
  return v7;
}

void sub_1866A2824(void *a1)
{
}

void sub_1866A2838(_Unwind_Exception *a1)
{
}

void *PF_CALLOC_SCANNED_BYTES(size_t size)
{
  uint64_t v2 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v2 = malloc_default_zone();
  }
  return malloc_zone_calloc(v2, 1uLL, size);
}

void _faultBatchAtIndex(uint64_t a1, unsigned int a2, int a3)
{
  v125[1] = *MEMORY[0x1895F89C0];
  unsigned int v3 = a2 / *(_DWORD *)(a1 + 48);
  uint64_t v4 = v3 >> 5;
  uint64_t v6 = a1;
  int v86 = 1 << ~(_BYTE)v3;
  uint64_t v7 = MEMORY[0x186E3E5D8]();
  int v8 = *(_DWORD *)(v6 + 48);
  uint64_t v9 = v8 * v3;
  unsigned int v10 = v9 + v8;
  unsigned int v11 = *(_DWORD *)(v6 + 12);
  if (v10 < v11) {
    unsigned int v11 = v10;
  }
  unsigned int v99 = v11;
  uint64_t v12 = [*(id *)(v6 + 16) _objectsPointer];
  if (a3)
  {
    uint64_t v13 = *(unsigned __int8 *)(v6 + 64);
    uint64_t v14 = *(void *)(v6 + 56);
    unsigned int v15 = *(_DWORD *)(v14 + 4 * v13);
    *(_DWORD *)(v14 + 4 * v13) = v3;
    BOOL v16 = v15 == -1 || v15 == v3;
    int v17 = !v16;
    int v85 = v17;
    if (!v16) {
      _releaseStaleBatch(v6, v15);
    }
    *(_BYTE *)(v6 + 64) = ((int)v13 + 1) % ((*(_DWORD *)(v6 + 64) >> 9) & 0x7FFu);
  }

  else
  {
    int v85 = 0;
  }

  uint64_t v18 = *(void **)(v6 + 40);
  uint64_t v19 = objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v18, "entity"), "managedObjectModel"),  "_modelsReferenceIDOffset");
  uint64_t v92 = v19;
  uint64_t v20 = [v18 resultType];
  BOOL v21 = v20 == 2 && v19 != 16000;
  if (v19 == 16000 && v20 != 2)
  {
    [v18 setResultType:2];
    BOOL v21 = 0;
  }

  uint64_t v94 = v99 - v9;
  uint64_t v91 = v18;
  BOOL v93 = v21;
  uint64_t v89 = v3 >> 5;
  uint64_t v87 = v12;
  if (([v18 includesPropertyValues] & 1) != 0
    || objc_msgSend((id)objc_msgSend(v18, "relationshipKeyPathsForPrefetching"), "count")
    || objc_msgSend((id)objc_msgSend(v18, "propertiesToFetch"), "count"))
  {
    BOOL v23 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603F18]),  "initWithObjects:count:",  objc_msgSend(*(id *)(v6 + 16), "_objectsPointer") + 8 * v9,  v94);
    uint64_t v124 = @"batch";
    v125[0] = [MEMORY[0x189607878] expressionForConstantValue:v23];
    objc_msgSend( v18,  "setSubstitutionVariables:",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", v125, &v124, 1));
    unint64_t v24 = [v23 count];

    id v114 = 0LL;
    uint64_t v26 = v9;
    if (v19 == 16000)
    {
      unint64_t v27 = 0x18C4A5000uLL;
      uint64_t v25 = [*(id *)(v6 + 32) _allowAncillaryEntities];
      if ((v25 & 1) != 0)
      {
        int v28 = 0;
      }

      else
      {
        int v28 = 1;
        uint64_t v25 = [*(id *)(v6 + 32) _setAllowAncillaryEntities:1];
      }
    }

    else
    {
      int v28 = 0;
      unint64_t v27 = 0x18C4A5000LL;
    }

    uint64_t v29 = (void *)MEMORY[0x186E3E5D8](v25);
    uint64_t v30 = *(void **)(v6 + *(int *)(v27 + 772));
    uint64_t v18 = v91;
    uint64_t v31 = (void *)[v30 executeFetchRequest:v91 error:&v114];
    unsigned int v122 = @"batch";
    uint64_t v123 = [MEMORY[0x189607878] expressionForConstantValue:NSArray_EmptyArray];
    objc_msgSend( v91,  "setSubstitutionVariables:",  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v123, &v122, 1));
    id v32 = v31;
    id v33 = v114;
    objc_autoreleasePoolPop(v29);
    id v34 = v31;
    id v35 = v114;
    if (v28) {
      [*(id *)(v6 + 32) _setAllowAncillaryEntities:0];
    }
    if (!v31)
    {
      id v36 = v114;
      [v114 userInfo];
      _NSCoreDataLog( 1LL,  (uint64_t)@"batched fetch array received an error %@ with userInfo %@",  v37,  v38,  v39,  v40,  v41,  v42,  (uint64_t)v36);
      uint64_t v31 = 0LL;
    }

    uint64_t v9 = v26;
    uint64_t v12 = v87;
  }

  else
  {
    unint64_t v24 = 0LL;
    uint64_t v31 = 0LL;
    id v114 = 0LL;
  }

  uint64_t v43 = v92;
  if ([v31 count] > v24)
  {
    [v31 count];
    _NSCoreDataLog( 1LL,  (uint64_t)@" batched fetch request asked to fetch %d objects but received %d objects as %@",  v44,  v45,  v46,  v47,  v48,  v49,  v24);
  }

  context = (void *)v7;
  obuint64_t j = v31;
  BOOL v50 = _PFStackAllocatorCreate(v121, 1024LL);
  memset(&keyCallBacks, 0, 24);
  *(_OWORD *)&keyCallBacks.copyDescription = *(_OWORD *)(MEMORY[0x189605240] + 24LL);
  keyCallBacks.hash = *(CFDictionaryHashCallBack *)(MEMORY[0x189605240] + 40LL);
  int v51 = v92 == 16000 || v21;
  uint64_t v97 = @"self";
  if (v51 == 1)
  {
    uint64_t v52 = @"self";
    if (!objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v18, "propertiesToFetch"), "valueForKey:", @"name"),  "containsObject:",  @"self")) {
      uint64_t v52 = @"objectID";
    }
    uint64_t v97 = v52;
  }

  uint64_t v53 = (const __CFDictionary *)[obj count];
  if (v53)
  {
    unsigned int v54 = CFDictionaryCreateMutable(v50, [obj count], &keyCallBacks, 0);
    if (v51)
    {
      __int128 v111 = 0uLL;
      __int128 v112 = 0uLL;
      __int128 v109 = 0uLL;
      __int128 v110 = 0uLL;
      uint64_t v55 = [obj countByEnumeratingWithState:&v109 objects:v120 count:16];
      if (v55)
      {
        uint64_t v56 = v55;
        uint64_t v57 = *(void *)v110;
        uint64_t v58 = context;
        do
        {
          for (uint64_t i = 0LL; i != v56; ++i)
          {
            if (*(void *)v110 != v57) {
              objc_enumerationMutation(obj);
            }
            CFDictionaryAddValue( v54,  (const void *)[*(id *)(*((void *)&v109 + 1) + 8 * i) objectForKey:v97],  *(const void **)(*((void *)&v109 + 1) + 8 * i));
          }

          uint64_t v56 = [obj countByEnumeratingWithState:&v109 objects:v120 count:16];
        }

        while (v56);
LABEL_63:
        uint64_t v18 = v91;
        BOOL v21 = v93;
LABEL_65:
        uint64_t v53 = v54;
        uint64_t v4 = v89;
        goto LABEL_66;
      }
    }

    else
    {
      __int128 v107 = 0uLL;
      __int128 v108 = 0uLL;
      __int128 v105 = 0uLL;
      __int128 v106 = 0uLL;
      uint64_t v60 = [obj countByEnumeratingWithState:&v105 objects:v119 count:16];
      if (v60)
      {
        uint64_t v61 = v60;
        uint64_t v62 = *(void *)v106;
        uint64_t v58 = context;
        do
        {
          for (uint64_t j = 0LL; j != v61; ++j)
          {
            if (*(void *)v106 != v62) {
              objc_enumerationMutation(obj);
            }
            CFDictionaryAddValue( v54,  (const void *)[*(id *)(*((void *)&v105 + 1) + 8 * j) objectID],  *(const void **)(*((void *)&v105 + 1) + 8 * j));
          }

          uint64_t v61 = [obj countByEnumeratingWithState:&v105 objects:v119 count:16];
        }

        while (v61);
        goto LABEL_63;
      }
    }

    uint64_t v58 = context;
    goto LABEL_65;
  }

  uint64_t v58 = context;
LABEL_66:
  if (v99 > v9)
  {
    unint64_t v64 = 0LL;
    theDict = v53;
    while (1)
    {
      unint64_t v96 = v64;
      uint64_t v65 = *(void **)(v12 + 8 * v9);
      if (v21)
      {
        int v66 = *(void **)(v12 + 8 * v9);
        if (!v53 || (Value = CFDictionaryGetValue(theDict, v65)) == 0LL)
        {
          if ([obj count] <= v96)
          {
            v117[0] = v97;
            v117[1] = @"isDeleted";
            v118[0] = v66;
            v118[1] = MEMORY[0x189604A88];
            Value = (_DWORD *)[MEMORY[0x189603F68] dictionaryWithObjects:v118 forKeys:v117 count:2];
          }

          else
          {
            Value = (id)objc_msgSend(obj, "objectAtIndexedSubscript:");
          }

          if (!Value) {
            goto LABEL_98;
          }
        }

        goto LABEL_97;
      }

      if (v43 == 16000) {
        break;
      }
      int v66 = v65;
      Value[4] |= 0x4000u;
LABEL_97:
      *(void *)(v12 + 8 * v9) = Value;
LABEL_98:

      ++v9;
      uint64_t v53 = theDict;
      unint64_t v64 = v96 + 1;
      if ((_DWORD)v94 == (_DWORD)v96 + 1) {
        goto LABEL_107;
      }
    }

    if (!v53 || (unsigned int v68 = (void *)CFDictionaryGetValue(v53, *(const void **)(v12 + 8 * v9)), (v69 = v68) == 0LL))
    {
      unsigned int v68 = (void *)[*(id *)(v6 + 32) objectWithID:v65];
      int v69 = v68;
      if (v68)
      {
        uint64_t v90 = v65;
        uint64_t v100 = (void *)objc_msgSend( MEMORY[0x189603FC8],  "dictionaryWithCapacity:",  objc_msgSend((id)objc_msgSend(v18, "propertiesToFetch"), "count"));
        unsigned int v68 = (void *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v69, "entity"), "name"),  "isEqualToString:",  @"TRANSACTION");
        if ((_DWORD)v68)
        {
          v116[0] = @"AUTHORTS";
          v116[1] = @"BUNDLEIDTS";
          v116[2] = @"CONTEXTNAMETS";
          v116[3] = @"PROCESSIDTS";
          CFAllocatorRef v70 = (void *)[MEMORY[0x189603F18] arrayWithObjects:v116 count:4];
          __int128 v101 = 0u;
          __int128 v102 = 0u;
          __int128 v103 = 0u;
          __int128 v104 = 0u;
          CFDataRef v71 = (void *)[v18 propertiesToFetch];
          unsigned int v68 = (void *)[v71 countByEnumeratingWithState:&v101 objects:v115 count:16];
          if (v68)
          {
            CFDataRef v72 = v68;
            uint64_t v83 = v9;
            uint64_t v84 = v6;
            uint64_t v73 = *(void *)v102;
            while (1)
            {
              int v74 = 0LL;
              do
              {
                if (*(void *)v102 != v73) {
                  objc_enumerationMutation(v71);
                }
                id v75 = *(void **)(*((void *)&v101 + 1) + 8LL * (void)v74);
                uint64_t v76 = (void *)MEMORY[0x186E3E5D8]();
                int v77 = objc_msgSend(v70, "containsObject:", objc_msgSend(v75, "name"));
                uint64_t v78 = (void *)objc_msgSend(v69, "valueForKey:", objc_msgSend(v75, "name"));
                uint64_t v79 = (uint64_t)v78;
                if (!v77)
                {
                  if (!v78) {
                    goto LABEL_88;
                  }
LABEL_87:
                  objc_msgSend(v100, "setValue:forKey:", v79, objc_msgSend(v75, "name"));
                  goto LABEL_88;
                }

                uint64_t v79 = [v78 valueForKey:@"NAME"];
                if (v79) {
                  goto LABEL_87;
                }
LABEL_88:
                objc_autoreleasePoolPop(v76);
                int v74 = (char *)v74 + 1;
              }

              while (v72 != v74);
              unsigned int v68 = (void *)[v71 countByEnumeratingWithState:&v101 objects:v115 count:16];
              CFDataRef v72 = v68;
              if (!v68)
              {
                int v69 = v100;
                uint64_t v9 = v83;
                uint64_t v6 = v84;
                uint64_t v58 = context;
                uint64_t v4 = v89;
                uint64_t v12 = v87;
                goto LABEL_101;
              }
            }
          }

          int v69 = v100;
LABEL_101:
          uint64_t v18 = v91;
          uint64_t v43 = v92;
        }

        uint64_t v65 = v90;
      }
    }

    int v66 = v65;
    ancillaryModelObjectBlock_block_invoke((uint64_t)v68, v18, *(void **)(v6 + 32), v69, v65);
    BOOL v21 = v93;
    if (v80)
    {
      uint64_t v81 = v80;
      *(void *)(v12 + 8 * v9) = v80;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        if ([(id)v6 transaction]) {
          objc_msgSend(v81, "_setTransaction:", objc_msgSend((id)v6, "transaction"));
        }
      }
    }

    goto LABEL_98;
  }

void sub_1866A4424(void *a1)
{
}

void sub_1866A4438(_Unwind_Exception *a1)
{
}

LABEL_33:
      [v8 addObject:v17];
      if (v7 == ++v16)
      {
        unsigned int v15 = 0;
        goto LABEL_37;
      }
    }
  }

  if (v7)
  {
    for (uint64_t i = 0LL; i != v7; ++i)
    {
      unsigned int v11 = -[NSArray objectAtIndex:](self->super._fetchColumns, "objectAtIndex:", i);
      if ([v11 _propertyType] == 5)
      {
        uint64_t v12 = (void *)[v11 expression];
        uint64_t v13 = [v12 expressionType];
        if (v13 == 3
          || v13 == 4
          && (sel_valueForKey_ == (char *)[v12 selector]
           || sel_valueForKeyPath_ == (char *)[v12 selector]))
        {
          uint64_t v14 = [v12 _mapKVCOperatorsToFunctionsInContext:v3];
          if ([v3 objectForKey:@"NSUnderlyingException"]) {
            goto LABEL_161;
          }
          if (v14)
          {
            unsigned int v11 = (id)[v11 copy];
            [v11 setExpression:v14];
          }

          uint64_t v7 = v103;
        }
      }

      [v8 addObject:v11];
    }

    unsigned int v15 = 0;
    uint64_t v100 = 0;
  }

  else
  {
    uint64_t v100 = 0;
    unsigned int v15 = 1;
  }

          LOBYTE(v6) = 1;
        }
      }
    }
  }

  return v6;
}

      if (!a4 || a4 != a1 && (a4[2] & 0x800) != 0) {
        goto LABEL_47;
      }
      if (!a2)
      {
        _PFFastMOCObjectWillChange(a1[4], a4);
        goto LABEL_47;
      }

      id v33 = [a2 isToMany];
      id v34 = [a2 name];
      id v35 = [a2 _entitysReferenceID];
      id v36 = [a2 entity];
      uint64_t v37 = (unint64_t *)[a4 entity];
      uint64_t v38 = v37;
      if (!(_DWORD)v33)
      {
        int v51 = _kvcPropertysPublicSetters(v38);
        _PF_Handler_Public_SetProperty((unsigned int *)a4, v35, a1, v34, *(void **)(v51 + 8 * v35));
        goto LABEL_47;
      }

      uint64_t v60 = a1;
      uint64_t v39 = (unint64_t *)_PFEntityForManagedObject(a4);
      uint64_t v40 = *(void *)(_kvcPropertysPrimitiveGetters(v39) + 8 * v35);
      uint64_t v41 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v39, "propertiesByName"), "valueAtIndex:", v35), "isOrdered");
      [a4 willAccessValueForKey:v34];
      _PF_Handler_Primitive_GetProperty((id **)a4, v35, v34, v40, v42, v43, v44, v45);
      uint64_t v47 = v46;
      [a4 didAccessValueForKey:v34];
      if (([v47 containsObject:a1] & 1) == 0)
      {
        if (v41)
        {
          uint64_t v48 = [v47 count];
          uint64_t v49 = *(void *)(_kvcPropertysPublicRelationshipMutators(v39) + 8 * v35);
          if (!v49)
          {
            unsigned int v54 = (void *)[objc_alloc(MEMORY[0x1896078D0]) initWithIndex:v48];
            [a4 willChange:2 valuesAtIndexes:v54 forKey:v34];
            [v47 addObject:a1];
            [a4 didChange:2 valuesAtIndexes:v54 forKey:v34];

            goto LABEL_47;
          }

          BOOL v50 = *(objc_method **)(v49 + 8);
          if (v50)
          {
            method_invoke(a4, v50, a1, v48);
            goto LABEL_47;
          }

          uint64_t v55 = (void *)[objc_alloc(MEMORY[0x1896078D0]) initWithIndex:v48];
          uint64_t v57 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:&v60 count:1];
          method_invoke(a4, *(Method *)(v49 + 24), v57, v55);
        }

        else
        {
          uint64_t v52 = *(void *)(_kvcPropertysPublicRelationshipMutators(v39) + 8 * v35);
          if (v52)
          {
            uint64_t v53 = *(objc_method **)(v52 + 8);
            if (v53)
            {
              method_invoke(a4, v53, a1);
              goto LABEL_47;
            }

            uint64_t v55 = (void *)[objc_alloc(MEMORY[0x189604010]) initWithObjects:&v60 count:1];
            method_invoke(a4, *(Method *)(v52 + 24), v55);
          }

          else
          {
            uint64_t v55 = (void *)[objc_alloc(MEMORY[0x189604010]) initWithObjects:&v60 count:1];
            [a4 willChangeValueForKey:v34 withSetMutation:1 usingObjects:v55];
            [v47 addObject:v60];
            [a4 didChangeValueForKey:v34 withSetMutation:1 usingObjects:v55];
          }
        }
      }

  id v32 = 0LL;
  if ((objc_msgSend(a1, "_nonPredicateValidateValue:forKey:inObject:error:", &v33, objc_msgSend(a1, "name"), 0, &v32) & 1) == 0)
  {
    uint64_t v2 = (char *)[v32 code];
    unint64_t v27 = (void *)[v32 localizedDescription];
    -[NSSQLiteConnection _batchInsertThrowWithErrorCode:andMessage:forKey:andValue:additionalDetail:]( (int)v2,  v27,  a1,  v33,  [v32 userInfo]);
    goto LABEL_55;
  }

  int v8 = (void *)[a1 _rawValidationPredicates];
  uint64_t v9 = (void *)[a1 _rawValidationWarnings];
  uint64_t result = [v8 count];
  if (!result) {
    return result;
  }
  unsigned int v11 = (char *)result;
  uint64_t v2 = 0LL;
  while (1)
  {
    uint64_t v12 = (void *)[v8 objectAtIndex:v2];
    uint64_t result = [v12 evaluateWithObject:v33];
    if ((result & 1) != 0) {
      goto LABEL_41;
    }
    uint64_t v13 = (void *)[v9 objectAtIndex:v2];
    uint64_t v14 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  objc_msgSend(v8, "objectAtIndex:", v2),  @"NSValidationErrorPredicate",  0);
    if (!v13)
    {
      unsigned int v15 = v33;
      BOOL v16 = 1550;
LABEL_49:
      uint64_t v18 = 0LL;
      goto LABEL_50;
    }

    if ([v13 isNSNumber])
    {
      BOOL v16 = [v13 intValue];
      unsigned int v15 = v33;
      goto LABEL_49;
    }

    objc_opt_class();
    uint64_t result = objc_opt_isKindOfClass();
    if ((result & 1) == 0) {
      goto LABEL_51;
    }
LABEL_41:
    if (v11 == ++v2) {
      return result;
    }
  }

  int v17 = objc_msgSend( (id)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(a1, "entity"), "managedObjectModel"),  "_localizationPolicy"),  "localizedModelStringForKey:",  v13);
  if (v17) {
    uint64_t v18 = (void *)v17;
  }
  else {
    uint64_t v18 = v13;
  }
  unsigned int v15 = v33;
  BOOL v16 = 1550;
LABEL_50:
  -[NSSQLiteConnection _batchInsertThrowWithErrorCode:andMessage:forKey:andValue:additionalDetail:]( v16,  v18,  a1,  v15,  v14);
LABEL_51:
  uint64_t v19 = [v13 intValue];
  uint64_t v20 = (void *)objc_msgSend( NSString,  "stringWithFormat:",  @"Illegal validation warning: property = %@; predicate/warning index = %lu; warning = %@.",
                  [a1 name],
                  v2,
                  v13);
  BOOL v21 = v33;
  uint64_t v22 = (void *)MEMORY[0x189603F68];
  BOOL v23 = [a1 name];
  unint64_t v24 = [MEMORY[0x189607968] numberWithUnsignedLong:v2];
  -[NSSQLiteConnection _batchInsertThrowWithErrorCode:andMessage:forKey:andValue:additionalDetail:]( v19,  v20,  a1,  v21,  objc_msgSend( v22,  "dictionaryWithObjectsAndKeys:",  v23,  @"NSValidationErrorKey",  v24,  @"index",  v13,  @"warning",  v33,  @"NSValidationErrorValue",  0));
LABEL_52:
  uint64_t v25 = [a1 _propertyType];
  uint64_t v26 = (void *)NSString;
  if (v25 == 6)
  {
    uint64_t v7 = (void *)objc_msgSend( NSString,  "stringWithFormat:",  @"Cannot set value for derived attribute: property = %@; entity = %@; value = %@",
                   [a1 name],
                   objc_msgSend((id)objc_msgSend(a1, "entity"), "name"),
                   v2,
                   v31);
    goto LABEL_58;
  }

  int v28 = (objc_class *)objc_opt_class();
  uint64_t v29 = (void *)[v26 stringWithFormat:@"Property (%@) is not supported with NSBatchInsertRequest", NSStringFromClass(v28)];
  -[NSSQLiteConnection _batchInsertThrowWithErrorCode:andMessage:forKey:andValue:additionalDetail:]( 3328,  v29,  a1,  (uint64_t)v2,  0LL);
LABEL_57:
  uint64_t v7 = (void *)objc_msgSend( NSString,  "stringWithFormat:",  @"Unacceptable type of value for attribute: property = %@; desired type = %@; given type = %@; value = %@.",
                 [a1 name],
                 [a1 attributeValueClassName],
                 objc_opt_class(),
                 v2);
LABEL_58:
  uint64_t v30 = -[NSSQLiteConnection _batchInsertThrowWithErrorCode:andMessage:forKey:andValue:additionalDetail:]( 1550,  v7,  a1,  (uint64_t)v2,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  objc_msgSend(a1, "name"),  @"key",  v2,  @"value",  0));
  return -[NSSQLiteConnection insertManagedObjectBlock:forEntity:includeOnConflict:](v30);
}

LABEL_34:
    goto LABEL_35;
  }

  uint64_t v13 = (void *)MEMORY[0x186E3E5D8]();
  else {
    uint64_t v14 = __ckLoggingOverride;
  }
  unsigned int v15 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Unable to schedule work because the mirroring delegate was deallocated."];
  _NSCoreDataLog( v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  (uint64_t)"-[NSCloudKitMirroringDelegate checkAndExecuteNextRequest]_block_invoke");
  objc_autoreleasePoolPop(v13);
LABEL_35:
}

      uint64_t v22 = (FILE *)*MEMORY[0x1895F89D0];
      BOOL v23 = (const char *)[(id)objc_msgSend( NSString stringWithFormat:@"Unable to create a copy of the store at url: %@\n%@", a3, v46), "UTF8String"];
      goto LABEL_34;
    }

    int v17 = 0LL;
    uint64_t v46 = v47;
LABEL_22:
    if (v17)
    {
      unint64_t v24 = -[NSCloudKitMirroringDelegateOptions initWithContainerIdentifier:]( objc_alloc(&OBJC_CLASS___NSCloudKitMirroringDelegateOptions),  "initWithContainerIdentifier:",  @"cdutil-stub-container");
      uint64_t v25 = v24;
      if (v24) {
        v24->_skipCloudKitSetup = 1;
      }
      uint64_t v26 = -[NSCloudKitMirroringDelegate initWithOptions:]( objc_alloc(&OBJC_CLASS___NSCloudKitMirroringDelegate),  "initWithOptions:",  v24);

      unint64_t v27 = -[NSPersistentStoreDescription initWithURL:]( objc_alloc(&OBJC_CLASS___NSPersistentStoreDescription),  "initWithURL:",  v17);
      -[NSPersistentStoreDescription setType:](v27, "setType:", @"SQLite");
      -[NSPersistentStoreDescription setConfiguration:](v27, "setConfiguration:", a4);
      -[NSPersistentStoreDescription setShouldMigrateStoreAutomatically:]( v27,  "setShouldMigrateStoreAutomatically:",  1LL);
      -[NSPersistentStoreDescription setShouldInferMappingModelAutomatically:]( v27,  "setShouldInferMappingModelAutomatically:",  1LL);
      -[NSPersistentStoreDescription setMirroringDelegate:](v27, "setMirroringDelegate:", v26);
      -[NSPersistentStoreDescription setOption:forKey:]( v27,  "setOption:forKey:",  MEMORY[0x189604A88],  @"NSPersistentHistoryTrackingKey");
      -[NSPersistentStoreDescription setOption:forKey:]( v27,  "setOption:forKey:",  MEMORY[0x189604A88],  @"NSCloudKitMirroringDelegateReadOnlyOptionKey");
      int v28 = dispatch_semaphore_create(0LL);
      uint64_t v29 = (void *)[MEMORY[0x189607958] defaultCenter];
      v45[0] = MEMORY[0x1895F87A8];
      v45[1] = 3221225472LL;
      v45[2] = __98__NSCloudKitMirroringDelegate___CLI__printMetadataForStoreAtURL_withConfiguration_operateOnACopy___block_invoke;
      v45[3] = &unk_189EA9708;
      v45[4] = v28;
      uint64_t v30 = [v29 addObserverForName:@"NSPersistentCloudKitContainerEventChangedNotification" object:v26 queue:0 usingBlock:v45];
      *(void *)buf = 0LL;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x2020000000LL;
      LOBYTE(v54) = 0;
      v44[0] = MEMORY[0x1895F87A8];
      v44[1] = 3221225472LL;
      v44[2] = __98__NSCloudKitMirroringDelegate___CLI__printMetadataForStoreAtURL_withConfiguration_operateOnACopy___block_invoke_12;
      v44[3] = &unk_189EAB550;
      v44[5] = v28;
      v44[6] = buf;
      v44[4] = v17;
      -[NSPersistentStoreCoordinator addPersistentStoreWithDescription:completionHandler:]( v42,  "addPersistentStoreWithDescription:completionHandler:",  v27,  v44);
      uint64_t v31 = dispatch_time(0LL, 10000000000LL);
      if (dispatch_semaphore_wait(v28, v31))
      {
        fputs( (const char *)objc_msgSend( (id)objc_msgSend( NSString,  "stringWithFormat:",  @"Timed out waiting for the mirroring delegate to finish setting up. This is a bug. Please re-run and attach a sample of cdutil if you can."),  "UTF8String"),  (FILE *)*MEMORY[0x1895F89D0]);
        id v32 = 0;
      }

      else
      {
        id v32 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
      }

      objc_msgSend((id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"), "removeObserver:", v30);
      dispatch_release(v28);
      if (v32)
      {
        id v33 = -[NSManagedObjectContext initWithConcurrencyType:]( objc_alloc(&OBJC_CLASS___NSManagedObjectContext),  "initWithConcurrencyType:",  1LL);
        -[NSManagedObjectContext setPersistentStoreCoordinator:](v33, "setPersistentStoreCoordinator:", v42);
        -[NSManagedObjectContext _setAllowAncillaryEntities:](v33, "_setAllowAncillaryEntities:", 1LL);
        v43[0] = MEMORY[0x1895F87A8];
        v43[1] = 3221225472LL;
        v43[2] = __98__NSCloudKitMirroringDelegate___CLI__printMetadataForStoreAtURL_withConfiguration_operateOnACopy___block_invoke_2;
        v43[3] = &unk_189EA7758;
        v43[4] = v33;
        -[NSManagedObjectContext performBlockAndWait:](v33, "performBlockAndWait:", v43);
      }

      _Block_object_dispose(buf, 8);
      goto LABEL_35;
    }

    goto LABEL_33;
  }

  uint64_t v22 = (FILE *)*MEMORY[0x1895F89E0];
  BOOL v23 = (const char *)[(id)objc_msgSend( NSString stringWithFormat:@"This store has never been used with CloudKit (use cdutil dumpmetadata [storePath] to show store metadata): %@", a3), "UTF8String"];
LABEL_34:
  fputs(v23, v22);
LABEL_35:
}

LABEL_38:
  uint64_t v20 = [v3 objectForKey:@"keypathExpressionDestinationRelationship"];
  BOOL v21 = [v3 objectForKey:@"entity"];
  uint64_t v22 = objc_alloc_init(&OBJC_CLASS___NSSQLEntity);
  -[NSSQLEntity copyValuesForReadOnlyFetch:](v22, "copyValuesForReadOnlyFetch:", v21);
  [v3 setObject:v22 forKey:@"fabricatedSQLEntityForReadOnlyFetch"];
  unint64_t v96 = (uint64_t)v22;

  uint64_t v94 = v20;
  if (v21) {
    unsigned int v99 = *(void **)(v21 + 40);
  }
  else {
    unsigned int v99 = 0LL;
  }
  uint64_t v97 = (void *)v21;
  __int128 v101 = objc_alloc_init(MEMORY[0x189603FA8]);
  BOOL v23 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:@"SELECT "];
  unint64_t v5 = v23;
  if (!*(&self->super._isCount + 1) && self->super._useDistinct) {
    [v23 appendString:@"DISTINCT "];
  }
  if ((v15 & 1) != 0)
  {
LABEL_44:
    unint64_t v24 = v3;
    uint64_t v25 = objc_alloc_init(MEMORY[0x189603FA8]);
    __int128 v106 = 0u;
    __int128 v107 = 0u;
    __int128 v104 = 0u;
    __int128 v105 = 0u;
    uint64_t v26 = [v8 countByEnumeratingWithState:&v104 objects:v127 count:16];
    if (v26)
    {
      unint64_t v27 = *(void *)v105;
      do
      {
        for (uint64_t j = 0LL; j != v26; ++j)
        {
          if (*(void *)v105 != v27) {
            objc_enumerationMutation(v8);
          }
          objc_msgSend(v25, "addObject:", objc_msgSend(*(id *)(*((void *)&v104 + 1) + 8 * j), "name"));
        }

        uint64_t v26 = [v8 countByEnumeratingWithState:&v104 objects:v127 count:16];
      }

      while (v26);
    }

    uint64_t v29 = -[NSSQLEntity addPropertiesForReadOnlyFetch:keys:context:](v96, v101, (uint64_t)v25, v24);

    if ((v29 & 1) == 0)
    {

      return 0LL;
    }

    [v5 appendString:@" FROM "];
    objc_msgSend(v5, "appendString:", -[NSSQLEntity tableName](self->super._entity, "tableName"));
    [v5 appendString:@" "];
    [v5 appendString:self->super._entityAlias];
    [v5 appendString:@" "];
    [v24 removeObjectForKey:@"keypathExpressionDestinationRelationship"];
    if (v94) {
      [v24 setObject:v94 forKey:@"keypathExpressionDestinationRelationship"];
    }
    return v5;
  }

  uint64_t v30 = 0LL;
  __int128 v102 = v3;
  while (1)
  {
    [v3 removeObjectForKey:@"keypathExpressionDestinationRelationship"];
    if (v30) {
      objc_msgSend(v5, "appendString:", @", ");
    }
    uint64_t v31 = (NSPropertyDescription *)[v8 objectAtIndex:v30];
    id v32 = -[NSArray objectAtIndex:](self->super._fetchColumns, "objectAtIndex:", v30);
    id v33 = -[NSPropertyDescription _propertyType](v31, "_propertyType");
    if (-[NSPropertyDescription _isAttribute](v31, "_isAttribute"))
    {
      if ((v100 & 1) == 0
        && (-[NSSQLFetchIntermediate groupByClauseContainsKeypath:](v98, -[NSPropertyDescription name](v31, "name")) & 1) == 0)
      {
        if (v5) {

        }
LABEL_168:
        uint64_t v81 = (void *)MEMORY[0x189603F70];
        unint64_t v82 = [NSString stringWithFormat:@"SELECT clauses in queries with GROUP BY components can only contain properties named in the GROUP BY or aggregate functions (%@ is not in the GROUP BY)", v31];
        objc_msgSend( v102,  "setObject:forKey:",  objc_msgSend(v81, "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], v82, 0),  @"NSUnderlyingException");
        return 0LL;
      }

      v119[0] = MEMORY[0x1895F87A8];
      v119[1] = 3221225472LL;
      char v120 = __62__NSSQLReadOnlySelectIntermediate_generateSQLStringInContext___block_invoke;
      signed int v121 = &unk_189EAA698;
      unsigned int v122 = v99;
      uint64_t v123 = v31;
      uint64_t v124 = v5;
      uint64_t v125 = self;
      uint64_t v126 = v101;
      uint64_t v113 = 0LL;
      id v114 = &v113;
      uint64_t v115 = 0x3052000000LL;
      unsigned int v116 = __Block_byref_object_copy__31;
      int v117 = __Block_byref_object_dispose__31;
      v112[0] = MEMORY[0x1895F87A8];
      v112[1] = 3221225472LL;
      v112[2] = __62__NSSQLReadOnlySelectIntermediate_generateSQLStringInContext___block_invoke_39;
      v112[3] = &unk_189EAA6C0;
      v112[6] = &v113;
      v112[4] = v5;
      v112[5] = v119;
      unsigned int v118 = v112;
      if (-[NSPropertyDescription attributeType](v31, "attributeType") == 2100)
      {
        (*(void (**)(void))(v114[5] + 16))();
        objc_msgSend(v5, "replaceCharactersInRange:withString:", objc_msgSend(v5, "length") - 2, 1, &stru_189EAC2E8);
      }

      else
      {
        if (v31 && -[NSPropertyDescription superCompositeAttribute](v31, "superCompositeAttribute")) {
          uint64_t v40 = -[NSPropertyDescription _qualifiedName](v31, "_qualifiedName");
        }
        else {
          uint64_t v40 = -[NSPropertyDescription name](v31, "name");
        }
        v120((uint64_t)v119, v40);
      }

      _Block_object_dispose(&v113, 8);
      goto LABEL_141;
    }

    if (v33 != 5)
    {
      if (v33 != 4)
      {

        uint64_t v79 = (void *)MEMORY[0x189603F70];
        int v80 = [NSString stringWithFormat:@"Unsupported value passed to valuesToFetch: (%@) not supported", v31];
        objc_msgSend( v102,  "setObject:forKey:",  objc_msgSend(v79, "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], v80, 0),  @"NSUnderlyingException");

        return 0LL;
      }

      if ((v100 & 1) == 0
        && (-[NSSQLFetchIntermediate groupByClauseContainsKeypath:](v98, -[NSPropertyDescription name](v31, "name")) & 1) == 0)
      {
        if (v5) {

        }
        goto LABEL_168;
      }

      id v34 = objc_msgSend(v99, "objectForKey:", -[NSPropertyDescription name](v31, "name"));
      id v35 = objc_alloc_init(&OBJC_CLASS___NSSQLToOne);
      id v36 = v35;
      if (v35) {
        v35->super.super._propertyDescription = v31;
      }
      -[NSSQLToOne copyValuesForReadOnlyFetch:](v35, "copyValuesForReadOnlyFetch:", v34);
      uint64_t v37 = -[NSSQLRelationship destinationEntity](v36, "destinationEntity");
      if (v37)
      {
        uint64_t v38 = *(void **)(v37 + 152);
        if (v38)
        {
          if ([v38 count])
          {
            [v5 appendString:self->super._columnAlias];
            [v5 appendString:@"."];
            if (v36) {
              foreignEntityKey = v36->_foreignEntityKey;
            }
            else {
              foreignEntityKey = 0LL;
            }
            objc_msgSend(v5, "appendString:", -[NSSQLColumn columnName](foreignEntityKey, "columnName"));
            objc_msgSend(v5, "appendString:", @", ");
          }
        }
      }

      goto LABEL_140;
    }

    uint64_t v41 = (void *)-[NSPropertyDescription expression](v31, "expression");
    uint64_t v42 = [v41 expressionType];
    if (!v42) {
      break;
    }
    if (v42 == 1)
    {
      uint64_t v43 = -[NSSQLToOne initForReadOnlyFetchWithEntity:propertyDescription:]( objc_alloc(&OBJC_CLASS___NSSQLToOne),  "initForReadOnlyFetchWithEntity:propertyDescription:",  v97,  v31);
      id v36 = v43;
      if (v43)
      {
        v43->super.super._propertyDescription = v31;
        if (![v102 objectForKey:@"nestedWhereSelect"])
        {
          uint64_t v44 = v36->_foreignEntityKey;
          goto LABEL_82;
        }
      }

      else if (![v102 objectForKey:@"nestedWhereSelect"])
      {
        uint64_t v44 = 0LL;
LABEL_82:
        if (v97 && (v97[20] || (unsigned int v68 = (void *)v97[19]) != 0 && [v68 count]))
        {
          [v5 appendString:self->super._columnAlias];
          [v5 appendString:@"."];
          objc_msgSend(v5, "appendString:", -[NSSQLColumn columnName](v44, "columnName"));
        }

        else
        {
          if (v44) {
            columnValue = v44->_columnValue;
          }
          else {
            columnValue = 0LL;
          }
          objc_msgSend(v5, "appendFormat:", @"%u", -[NSNumber unsignedIntValue](columnValue, "unsignedIntValue"));
        }

        objc_msgSend(v5, "appendString:", @", ");
      }

    objc_msgSend( (id)v4,  "setCoreSpotlightDisplayNameExpression:",  -[NSEntityDescription coreSpotlightDisplayNameExpression](self, "coreSpotlightDisplayNameExpression"));
  }

  return (id)v4;
}

        uint64_t result = [v40 removeAllObjects];
        uint64_t v7 = v41 + 1;
        if (v41 + 1 == v39) {
          return result;
        }
      }

      unsigned int v15 = (void *)[a1 mutableOrderedSetValueForKey:v14];
      BOOL v16 = (void *)[a2 mutableOrderedSetValueForKey:*(void *)(v8 + 8 * v7)];
      uint64_t v40 = v16;
      if ([v16 count]) {
        int v17 = (void *)objc_msgSend( v16,  "objectsAtIndexes:",  objc_msgSend( MEMORY[0x1896078D0],  "indexSetWithIndexesInRange:",  0,  objc_msgSend(v16, "count")));
      }
      else {
        int v17 = (void *)[MEMORY[0x189603F18] array];
      }
      int v28 = v17;
      BOOL v50 = 0u;
      int v51 = 0u;
      uint64_t v48 = 0u;
      uint64_t v49 = 0u;
      uint64_t v29 = [v17 countByEnumeratingWithState:&v48 objects:v53 count:16];
      if (!v29) {
        goto LABEL_38;
      }
      uint64_t v30 = v29;
      uint64_t v31 = *(void *)v49;
      do
      {
        for (uint64_t j = 0LL; j != v30; ++j)
        {
          if (*(void *)v49 != v31) {
            objc_enumerationMutation(v28);
          }
          id v33 = *(void **)(*((void *)&v48 + 1) + 8 * j);
          [v15 addObject:v33];
          if (!v10) {
            goto LABEL_40;
          }
          if (v12)
          {
            if (v42) {
              id v34 = (void *)[v33 mutableOrderedSetValueForKey:v11];
            }
            else {
              id v34 = (void *)[v33 mutableSetValueForKey:v11];
            }
            id v35 = v34;
            [v34 removeObject:a2];
            [v35 addObject:a1];
          }

          else
          {
            [v33 setValue:a1 forKey:v11];
          }
        }

        uint64_t v30 = [v28 countByEnumeratingWithState:&v48 objects:v53 count:16];
      }

      while (v30);
      goto LABEL_37;
    }
  }

  else
  {
    uint64_t result = [0 keys];
    __break(1u);
  }

  return result;
}

    +[_PFRoutines _logFileAccessDebugInformation:]((uint64_t)&OBJC_CLASS____PFRoutines, v13);
    return 0;
  }

  return v32;
}

          ++v6;
        }

        while (v6 != v4);
        uint64_t result = -[__objc2_class countByEnumeratingWithState:objects:count:]( a2,  "countByEnumeratingWithState:objects:count:",  &v45,  v55,  16LL);
        uint64_t v4 = result;
        if (result) {
          continue;
        }
        break;
      }
    }
  }

  return result;
}

        [v5 addObject:v9];
      }
    }

    ++*(_DWORD *)(a1 + 88);
    _execute(a1);
    unsigned int v3 = v65;
  }

  else
  {
    unint64_t v5 = 0LL;
  }

  objc_autoreleasePoolPop(v3);
  return v5;
}

          ++v20;
        }

        while (v18 != v20);
        uint64_t v30 = [v17 countByEnumeratingWithState:&v48 objects:v56 count:16];
        uint64_t v18 = v30;
        if (!v30)
        {
LABEL_42:
          [(id)a1 execute];
          uint64_t v7 = v37;
          if (!*(void *)(a1 + 80))
          {
            uint64_t v31 = -[NSSQLiteConnection statementCacheForEntity:](a1, v37);
            -[NSSQLiteStatementCache cacheInsertStatement:](v31, 0LL);
          }

          -[NSSQLiteConnection _clearBindVariablesForInsertedRow](a1);
          -[NSSQLiteConnection resetSQLStatement](a1);
          objc_autoreleasePoolPop(context);
          if (++v42 == v39)
          {
            id v32 = [a2 countByEnumeratingWithState:&v52 objects:v57 count:16];
            int v8 = v32;
            if (!v32)
            {
LABEL_48:

              id v34 = 0LL;
              return;
            }

            goto LABEL_6;
          }

          goto LABEL_7;
        }
      }
    }

    id v33 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  134030LL,  (uint64_t)@"unable to generate primary keys",  0LL);
    objc_exception_throw(v33);
    __break(1u);
  }

    id v33 = (NSString *)(id)objc_msgSend( (id)objc_msgSend(v3, "objectForKey:", @"aliasGenerator"),  "generateTableAlias");
    self->_selectEntityAlias = v33;
    self->_variableAlias = v33;
    self->_governingEntityForVariable = self->_selectFromEntity;
    id v34 = [v28 propertyType];
    -[NSSQLStatementIntermediate setGoverningAlias:]( self->_fetchIntermediate,  "setGoverningAlias:",  self->_selectEntityAlias);
    switch(v34)
    {
      case 7:
        uint64_t v148 = 1;
        id v35 = (NSSQLEntity *)[v28 destinationEntity];
        self->_selectFromEntity = v35;
        self->_governingEntityForVariable = v35;
        id v36 = (void *)[v25 mutableCopy];
        [v36 appendString:@"."];
        objc_msgSend(v36, "appendString:", objc_msgSend((id)objc_msgSend(v28, "foreignKey"), "columnName"));
        [v36 appendString:@" = "];
        [v36 appendString:self->_selectEntityAlias];
        [v36 appendString:@"."];
        selectFromEntity = self->_selectFromEntity;
        if (selectFromEntity) {
          primaryKey = selectFromEntity->_primaryKey;
        }
        else {
          primaryKey = 0LL;
        }
        objc_msgSend(v36, "appendString:", -[NSSQLColumn columnName](primaryKey, "columnName"));
        -[NSSQLStatementIntermediate setCorrelationToken:]((uint64_t)self->_fetchIntermediate, v36);

        break;
      case 9:
        uint64_t v148 = 0;
        int v69 = (NSSQLEntity *)[v28 destinationEntity];
        self->_selectFromEntity = v69;
        self->_governingEntityForVariable = v69;
        if (v28) {
          uint64_t v44 = (__CFString *)v28[7];
        }
        else {
          uint64_t v44 = 0LL;
        }
        CFAllocatorRef v70 = (void *)[v25 mutableCopy];
        [v70 appendString:@"."];
        if (v22) {
          CFDataRef v71 = v22->_primaryKey;
        }
        else {
          CFDataRef v71 = 0LL;
        }
        objc_msgSend(v70, "appendString:", -[NSSQLColumn columnName](v71, "columnName"));
        [v70 appendString:@" = "];
        [v70 appendString:self->_selectEntityAlias];
        [v70 appendString:@"."];
        [v70 appendString:-[NSSQLManyToMany inverseColumnName](v44)];
        -[NSSQLStatementIntermediate setCorrelationToken:]((uint64_t)self->_fetchIntermediate, v70);

        if (self->_onlyTrailIsCount && self->_subqueryHasTruePredicate)
        {
          CFDataRef v72 = (NSMutableString *)objc_msgSend((id)objc_msgSend(v28, "correlationTableName"), "mutableCopy");
          self->_selectFromCorrelationTarget = v72;
          -[NSMutableString appendString:](v72, "appendString:", @" ");
          -[NSMutableString appendString:]( self->_selectFromCorrelationTarget,  "appendString:",  self->_selectEntityAlias);
          goto LABEL_52;
        }

        int v77 = (NSMutableString *)objc_msgSend((id)objc_msgSend(v28, "correlationTableName"), "mutableCopy");
        self->_selectFromCorrelationTarget = v77;
        -[NSMutableString appendString:](v77, "appendString:", @" ");
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", self->_selectEntityAlias);
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", @" JOIN ");
        -[NSMutableString appendString:]( self->_selectFromCorrelationTarget,  "appendString:",  objc_msgSend((id)objc_msgSend(v28, "destinationEntity"), "tableName"));
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", @" ");
        uint64_t v78 = (NSString *)(id)objc_msgSend( (id)objc_msgSend(v3, "objectForKey:", @"aliasGenerator"),  "generateTableAlias");
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", v78);
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", @" ON ");
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", self->_selectEntityAlias);
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", @".");
        -[NSMutableString appendString:]( self->_selectFromCorrelationTarget,  "appendString:",  -[__CFString columnName](v44, "columnName"));
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", @" = ");
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", v78);
        -[NSMutableString appendString:](self->_selectFromCorrelationTarget, "appendString:", @".");
        selectFromCorrelationTarget = self->_selectFromCorrelationTarget;
        int v80 = (void *)[v28 destinationEntity];
        if (v80) {
          int v80 = (void *)v80[16];
        }
        -[NSMutableString appendString:](selectFromCorrelationTarget, "appendString:", [v80 columnName]);

        self->_selectEntityAlias = v78;
        self->_variableAlias = self->_selectEntityAlias;
        break;
      case 8:
        uint64_t v148 = 0;
        uint64_t v40 = (NSSQLEntity *)[v28 destinationEntity];
        self->_selectFromEntity = v40;
        self->_governingEntityForVariable = v40;
        if (v28) {
          uint64_t v41 = (void *)v28[7];
        }
        else {
          uint64_t v41 = 0LL;
        }
        uint64_t v42 = (void *)[v25 mutableCopy];
        [v42 appendString:@"."];
        if (v22) {
          uint64_t v43 = v22->_primaryKey;
        }
        else {
          uint64_t v43 = 0LL;
        }
        objc_msgSend(v42, "appendString:", -[NSSQLColumn columnName](v43, "columnName"));
        [v42 appendString:@" = "];
        [v42 appendString:self->_selectEntityAlias];
        [v42 appendString:@"."];
        objc_msgSend(v42, "appendString:", objc_msgSend((id)objc_msgSend(v41, "foreignKey"), "columnName"));
        -[NSSQLStatementIntermediate setCorrelationToken:]((uint64_t)self->_fetchIntermediate, v42);

        uint64_t v39 = [v28 destinationEntity];
        if (v39) {
          goto LABEL_51;
        }
        goto LABEL_226;
      default:
        [v3 setObject:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", @"Can't have a non-relationship collection element in a subquery%@", self->super._expression), 0), @"NSUnderlyingException" forKey];
        goto LABEL_139;
    }

    uint64_t v39 = [v28 destinationEntity];
    if (v39)
    {
LABEL_51:
      uint64_t v44 = *(__CFString **)(v39 + 128);
LABEL_52:
      -[NSSQLSubqueryExpressionIntermediate _setVariableColumn:]((uint64_t)self, v44);
      -[NSSQLStatementIntermediate setGoverningEntity:]( self->_fetchIntermediate,  "setGoverningEntity:",  self->_selectFromEntity);
      uint64_t v45 = self->_trailingKeypath;
      if (v45) {
        uint64_t v46 = -[NSString componentsSeparatedByString:]( -[NSExpression keyPath](v45, "keyPath"),  "componentsSeparatedByString:",  @".");
      }
      else {
        uint64_t v46 = 0LL;
      }
      if (objc_msgSend( -[NSArray objectAtIndex:](v46, "objectAtIndex:", 0),  "isEqualToString:",  &stru_189EAC2E8)) {
        uint64_t v46 = -[NSArray subarrayWithRange:](v46, "subarrayWithRange:", 1LL, -[NSArray count](v46, "count") - 1);
      }
      if (!self->_hasTrailingFunction) {
        goto LABEL_62;
      }
      if (-[NSArray count](v46, "count") >= 2)
      {
        [v147 count];
LABEL_66:
        uint64_t v48 = (id)[v147 mutableCopy];
        uint64_t v149 = 0u;
        uint64_t v150 = 0u;
        uint64_t v151 = 0u;
        unsigned int v152 = 0u;
        uint64_t v49 = -[NSArray countByEnumeratingWithState:objects:count:]( v46,  "countByEnumeratingWithState:objects:count:",  &v149,  v153,  16LL);
        if (v49)
        {
          BOOL v50 = v49;
          int v51 = *(void *)v150;
          do
          {
            for (uint64_t i = 0LL; i != v50; ++i)
            {
              if (*(void *)v150 != v51) {
                objc_enumerationMutation(v46);
              }
              uint64_t v53 = *(void **)(*((void *)&v149 + 1) + 8 * i);
              if (([v53 hasPrefix:@"@"] & 1) == 0) {
                [v48 addObject:v53];
              }
            }

            BOOL v50 = -[NSArray countByEnumeratingWithState:objects:count:]( v46,  "countByEnumeratingWithState:objects:count:",  &v149,  v153,  16LL);
          }

          while (v50);
        }

        unsigned int v54 = [v147 count];
        uint64_t v55 = v54 - 1;
        uint64_t v56 = [v48 count];
        uint64_t v57 = v56;
        uint64_t v145 = v56 - 1;
        v146 = v54;
        if (!v56)
        {
          uint64_t v59 = 0;
          unint64_t v64 = 0LL;
          goto LABEL_114;
        }

        uint64_t v143 = v3;
        uint64_t v58 = 0;
        uint64_t v59 = 0;
        uint64_t v60 = 0LL;
        uint64_t v61 = self->_selectFromEntity;
        id v142 = v56 == v54;
        while (1)
        {
          uint64_t v62 = [v48 objectAtIndex:v60];
          if (!v61) {
            break;
          }
          uint64_t v63 = (NSSQLColumn *)-[NSMutableDictionary objectForKey:](v61->_properties, "objectForKey:", v62);
          if (!v63) {
            break;
          }
          unint64_t v64 = v63;
          uint64_t v65 = -[NSSQLProperty propertyType](v63, "propertyType");
          if ((v65 - 7) > 2)
          {
            if (v145 != v60)
            {
              uint64_t v73 = (void *)MEMORY[0x189603F70];
              int v74 = *MEMORY[0x189603A60];
              id v75 = [NSString stringWithFormat:@"Bad collection keypath in subquery %@ (attribute in non-terminal position)", self->super._expression, v141];
              goto LABEL_112;
            }

            v59 |= v57 == v146;
            uint64_t v58 = 1;
          }

          else
          {
            if (!(((v65 & 0xFE) != 8) | v148 & 1))
            {
              uint64_t v73 = (void *)MEMORY[0x189603F70];
              int v74 = *MEMORY[0x189603A60];
              id v75 = [NSString stringWithFormat:@"Only allowed one toMany/manyToMany relationship in subquery expression collection (%@)", self->super._expression, v141];
              goto LABEL_112;
            }

            v148 &= (v65 & 0xFE) != 8;
            uint64_t v61 = (NSSQLEntity *)-[NSSQLColumn destinationEntity](v64, "destinationEntity");
          }

          if (v55 == v60)
          {
            if ((v59 & 1) != 0)
            {
              self->_governingEntityForVariable = v61;
              int v66 = self;
              id v67 = (NSSQLPrimaryKey *)v64;
            }

            else
            {
              unsigned int v68 = (NSSQLEntity *)-[NSSQLColumn destinationEntity](v64, "destinationEntity");
              self->_governingEntityForVariable = v68;
              if (v68) {
                id v67 = v68->_primaryKey;
              }
              else {
                id v67 = 0LL;
              }
              int v66 = self;
            }

            -[NSSQLSubqueryExpressionIntermediate _setVariableColumn:]((uint64_t)v66, v67);
          }

          if (v57 == ++v60)
          {
            if ((v58 & 1) != 0)
            {
              self->_targetColumn = v64;
              unsigned int v3 = v143;
              if (v57 > 1)
              {

                self->_variableAlias = 0LL;
                uint64_t v76 = 1;
                goto LABEL_120;
              }

              uint64_t v83 = 1;
LABEL_117:

              self->_variableAlias = 0LL;
              if (!v57 || (v83 & 1) != 0) {
                goto LABEL_137;
              }
              uint64_t v76 = 0;
LABEL_120:
              if (-[NSSQLIntermediate isUpdateColumnsScoped](self, "isUpdateColumnsScoped"))
              {
                [v3 setObject:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", @"Unsupported subquery with multiple joins in update columns %@", v144), 0), @"NSUnderlyingException" forKey];
                goto LABEL_139;
              }

              uint64_t v84 = [v3 objectForKey:@"subqueryCollectionContext"];
              [v3 setObject:self forKey:@"subqueryCollectionContext"];
              int v85 = +[NSSQLJoinIntermediate createJoinIntermediatesForKeypath:startEntity:startAlias:forScope:inStatementIntermediate:inContext:]( (uint64_t)&OBJC_CLASS___NSSQLJoinIntermediate,  v48,  (uint64_t)self->_selectFromEntity,  self->_selectEntityAlias,  self,  (uint64_t)self->_fetchIntermediate,  v3);
              if (v84) {
                [v3 setObject:v84 forKey:@"subqueryCollectionContext"];
              }
              else {
                [v3 removeObjectForKey:@"subqueryCollectionContext"];
              }
              if ([v3 objectForKey:@"NSUnderlyingException"])
              {

                goto LABEL_139;
              }

              if (!v85)
              {
LABEL_137:
                int v85 = 0LL;
                self->_variableAlias = self->_selectEntityAlias;
                selectEntityAlias = (objc_class *)self->_selectEntityAlias;
                unsigned int v95 = &OBJC_IVAR___NSSQLSubqueryExpressionIntermediate__targetAlias;
                goto LABEL_138;
              }

              if (v142)
              {
                int v86 = v147;
                if ((v59 & 1) != 0) {
                  int v86 = (void *)objc_msgSend(v147, "subarrayWithRange:", 0, v55);
                }
                uint64_t v87 = -[NSSQLFetchIntermediate finalJoinForKeypathWithComponents:]( (uint64_t)self->_fetchIntermediate,  v86);
                double v88 = v87;
                if (v87)
                {
                  if ((v76 & 1) != 0)
                  {
                    uint64_t v89 = *(void **)(v87 + 32);
                    goto LABEL_134;
                  }

                  uint64_t v126 = *(void *)(v87 + 16);
                  if (v126 && *(_BYTE *)(v126 + 24) == 9)
                  {
                    if (-[NSSQLSubqueryExpressionIntermediate canDoDirectJoinGivenPredicate:]( self,  (uint64_t)-[NSExpression predicate](self->super._expression, "predicate")))
                    {
                      *(_BYTE *)(v88 + 56) = 1;
                      BOOL v127 = (NSString *)*(id *)(v88 + 40);
                      self->_variableAlias = v127;
                      self->_targetAlias = v127;
                      unsigned int v128 = objc_alloc_init(&OBJC_CLASS___NSSQLColumn);
                      char v129 = (__CFString *)-[NSSQLManyToMany inverseColumnName]((const __CFString *)v126);
                      -[NSSQLColumn _setColumnName:]((uint64_t)v128, v129);
                      if (v128) {
                        *(_WORD *)&v128->super._flags |= 1u;
                      }
                      -[NSSQLSubqueryExpressionIntermediate _setVariableColumn:]((uint64_t)self, v128);

LABEL_221:
                      unsigned int v95 = &OBJC_IVAR___NSSQLSubqueryExpressionIntermediate__targetColumn;
                      selectEntityAlias = (objc_class *)self->_variableColumn;
                    }

                    else
                    {
                      double v138 = (NSString *)*(id *)(v88 + 32);
                      self->_variableAlias = v138;
                      self->_targetAlias = v138;
                      uint64_t v139 = [*(id *)(v88 + 16) destinationEntity];
                      if (v139) {
                        unsigned int v140 = *(void **)(v139 + 128);
                      }
                      else {
                        unsigned int v140 = 0LL;
                      }
                      -[NSSQLSubqueryExpressionIntermediate _setVariableColumn:]((uint64_t)self, v140);
                      unsigned int v95 = &OBJC_IVAR___NSSQLSubqueryExpressionIntermediate__targetColumn;
                      selectEntityAlias = (objc_class *)self->_variableColumn;
                    }

    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
    {
      signed int v121 = 0u;
      unsigned int v122 = 0u;
      char v119 = 0u;
      char v120 = 0u;
      uint64_t v53 = [obj countByEnumeratingWithState:&v119 objects:v137 count:16];
      if (v53)
      {
        unsigned int v54 = *(void *)v120;
        do
        {
          uint64_t v55 = 0LL;
          do
          {
            if (*(void *)v120 != v54) {
              objc_enumerationMutation(obj);
            }
            uint64_t v56 = *(void **)(*((void *)&v119 + 1) + 8 * v55);
            uint64_t v57 = (void *)objc_msgSend((id)objc_msgSend(v56, "recordID"), "zoneID");
            uint64_t v58 = *(void *)(*(void *)(a1 + 56) + 8LL);
            if (v58) {
              uint64_t v59 = *(void **)(v58 + 16);
            }
            else {
              uint64_t v59 = 0LL;
            }
            uint64_t v60 = +[NSCKRecordZoneMetadata zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:error:]( (uint64_t)NSCKRecordZoneMetadata,  v57,  [v59 databaseScope],  *(void *)(a1 + 40),  *(void **)(a1 + 48),  *(void *)(*(void *)(a1 + 80) + 8) + 40);
            if (v60)
            {
              uint64_t v61 = *(void *)(*(void *)(a1 + 56) + 8LL);
              if (v61
                && (uint64_t v62 = *(void *)(v61 + 16)) != 0
                && (uint64_t v63 = *(void *)(v62 + 136)) != 0
                && (unint64_t v64 = -[PFCloudKitArchivingUtilities encodeRecord:error:]( v63,  (uint64_t)v56,  (void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL))) != 0LL)
              {
                -[NSManagedObject setEncodedShareData:](v60, "setEncodedShareData:", v64);
                -[NSManagedObject setNeedsShareUpdate:](v60, "setNeedsShareUpdate:", 0LL);
              }

              else
              {
                *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
                int v66 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
                unint64_t v64 = 0LL;
              }
            }

            else
            {
              *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
              uint64_t v65 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
            }

            ++v55;
          }

          while (v53 != v55);
          id v67 = [obj countByEnumeratingWithState:&v119 objects:v137 count:16];
          uint64_t v53 = v67;
        }

        while (v67);
      }
    }

    unsigned int v68 = *(void *)(a1 + 72);
    if (*(_BYTE *)(*(void *)(v68 + 8) + 24LL))
    {
      v118[0] = MEMORY[0x1895F87A8];
      v118[1] = 3221225472LL;
      void v118[2] = __142__PFCloudKitExportContext_modifyRecordsOperationFinishedForStore_withSavedRecords_deletedRecordIDs_operationError_managedObjectContext_error___block_invoke_2;
      v118[3] = &unk_189EAB8E8;
      int v69 = *(void **)(a1 + 48);
      v118[4] = *(void *)(a1 + 56);
      CFAllocatorRef v70 = +[NSCKMirroredRelationship updateMirroredRelationshipsMatchingRecords:forStore:withManagedObjectContext:usingBlock:error:]( (uint64_t)&OBJC_CLASS___NSCKMirroredRelationship,  v105,  *(void *)(a1 + 40),  v69,  (uint64_t)v118,  (void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL));
      unsigned int v68 = *(void *)(a1 + 72);
      if (!v70)
      {
        *(_BYTE *)(*(void *)(v68 + 8) + 24LL) = 0;
        CFDataRef v71 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
        unsigned int v68 = *(void *)(a1 + 72);
      }
    }

    if (*(_BYTE *)(*(void *)(v68 + 8) + 24LL))
    {
      if ((+[NSCKMirroredRelationship purgeMirroredRelationshipsWithRecordIDs:fromStore:withManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMirroredRelationship,  *(void **)(a1 + 64),  *(void *)(a1 + 40),  *(void **)(a1 + 48),  (void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL)) & 1) == 0)
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
        CFDataRef v72 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
      }

      unsigned int v68 = *(void *)(a1 + 72);
      if (*(_BYTE *)(*(void *)(v68 + 8) + 24LL))
      {
        uint64_t v73 = +[NSCKRecordMetadata purgeRecordMetadataWithRecordIDs:inStore:withManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKRecordMetadata,  *(void **)(a1 + 64),  *(void *)(a1 + 40),  *(void **)(a1 + 48),  (id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL));
        unsigned int v68 = *(void *)(a1 + 72);
        if ((v73 & 1) == 0)
        {
          *(_BYTE *)(*(void *)(v68 + 8) + 24LL) = 0;
          int v74 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
          unsigned int v68 = *(void *)(a1 + 72);
        }
      }
    }

    if (*(_BYTE *)(*(void *)(v68 + 8) + 24LL))
    {
      id v75 = objc_alloc_init(MEMORY[0x189603FC8]);
      unsigned int v116 = 0u;
      int v117 = 0u;
      id v114 = 0u;
      uint64_t v115 = 0u;
      uint64_t v76 = *(void **)(a1 + 64);
      int v77 = [v76 countByEnumeratingWithState:&v114 objects:v136 count:16];
      if (v77)
      {
        uint64_t v78 = *(void *)v115;
        do
        {
          for (uint64_t j = 0LL; j != v77; ++j)
          {
            if (*(void *)v115 != v78) {
              objc_enumerationMutation(v76);
            }
            int v80 = *(void **)(*((void *)&v114 + 1) + 8 * j);
            uint64_t v81 = (id)objc_msgSend(v75, "objectForKey:", objc_msgSend(v80, "zoneID"));
            if (!v81)
            {
              uint64_t v81 = objc_alloc_init(MEMORY[0x189603FE0]);
              objc_msgSend(v75, "setObject:forKey:", v81, objc_msgSend(v80, "zoneID"));
            }

            objc_msgSend(v81, "addObject:", objc_msgSend(v80, "recordName"));

            unint64_t v82 = (void *)[v80 recordName];
          }

          int v77 = [v76 countByEnumeratingWithState:&v114 objects:v136 count:16];
        }

        while (v77);
      }

      __int128 v112 = 0u;
      uint64_t v113 = 0u;
      __int128 v110 = 0u;
      __int128 v111 = 0u;
      uint64_t v83 = [v75 countByEnumeratingWithState:&v110 objects:v135 count:16];
      if (v83)
      {
        uint64_t v100 = *(void *)v111;
        while (2)
        {
          unsigned int v99 = v83;
          for (uint64_t k = 0LL; k != v99; ++k)
          {
            if (*(void *)v111 != v100) {
              objc_enumerationMutation(v75);
            }
            int v85 = *(void **)(*((void *)&v110 + 1) + 8 * k);
            int v86 = (id)[v75 objectForKey:v85];
            uint64_t v87 = -[NSBatchUpdateRequest initWithEntityName:]( objc_alloc(&OBJC_CLASS___NSBatchUpdateRequest),  "initWithEntityName:",  +[NSCKRecordZoneMoveReceipt entityPath](&OBJC_CLASS___NSCKRecordZoneMoveReceipt, "entityPath"));
            -[NSBatchUpdateRequest setPredicate:]( v87,  "setPredicate:",  [MEMORY[0x1896079C8] predicateWithFormat:@"zoneName = %@ AND ownerName = %@ AND recordName in %@", objc_msgSend(v85, "zoneName"), objc_msgSend(v85, "ownerName"), v86]);
            uint64_t v134 = *(void *)(a1 + 40);
            -[NSPersistentStoreRequest setAffectedStores:]( v87,  "setAffectedStores:",  [MEMORY[0x189603F18] arrayWithObjects:&v134 count:1]);
            uint64_t v132 = @"needsCloudDelete";
            signed int v133 = [MEMORY[0x189607878] expressionForConstantValue:MEMORY[0x189604A80]];
            -[NSBatchUpdateRequest setPropertiesToUpdate:]( v87,  "setPropertiesToUpdate:",  [MEMORY[0x189603F68] dictionaryWithObjects:&v133 forKeys:&v132 count:1]);
            -[NSBatchUpdateRequest setResultType:](v87, "setResultType:", 0LL);
            if ((objc_msgSend( (id)objc_msgSend( (id)objc_msgSend( *(id *)(a1 + 48),  "executeRequest:error:",  v87,  *(void *)(*(void *)(a1 + 80) + 8) + 40),  "result"),  "BOOLValue") & 1) == 0)
            {
              *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
              double v88 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
              goto LABEL_90;
            }
          }

          uint64_t v83 = [v75 countByEnumeratingWithState:&v110 objects:v135 count:16];
          if (v83) {
            continue;
          }
          break;
        }
      }

      int v86 = 0LL;
      uint64_t v87 = 0LL;
LABEL_90:
      __int128 v108 = 0u;
      __int128 v109 = 0u;
      __int128 v106 = 0u;
      __int128 v107 = 0u;
      uint64_t v89 = [v101 countByEnumeratingWithState:&v106 objects:v131 count:16];
      if (v89)
      {
        uint64_t v90 = *(void *)v107;
        do
        {
          uint64_t v91 = 0LL;
          do
          {
            if (*(void *)v107 != v90) {
              objc_enumerationMutation(v101);
            }
            uint64_t v92 = (void *)[*(id *)(*((void *)&v106 + 1) + 8 * v91) zoneID];
            BOOL v93 = *(void *)(*(void *)(a1 + 56) + 8LL);
            if (v93) {
              uint64_t v94 = *(void **)(v93 + 16);
            }
            else {
              uint64_t v94 = 0LL;
            }
            unsigned int v95 = +[NSCKRecordZoneMetadata zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:error:]( (uint64_t)NSCKRecordZoneMetadata,  v92,  [v94 databaseScope],  *(void *)(a1 + 40),  *(void **)(a1 + 48),  *(void *)(*(void *)(a1 + 80) + 8) + 40);
            if (!v95)
            {
              *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
              uint64_t v97 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
              goto LABEL_104;
            }

            -[NSManagedObject setNeedsShareDelete:](v95, "setNeedsShareDelete:", 0LL);
            ++v91;
          }

          while (v89 != v91);
          unint64_t v96 = [v101 countByEnumeratingWithState:&v106 objects:v131 count:16];
          uint64_t v89 = v96;
        }

        while (v96);
      }

LABEL_140:
      [v5 appendString:self->super._columnAlias];
      [v5 appendString:@"."];
      objc_msgSend(v5, "appendString:", -[NSSQLToOne columnName](v36, "columnName"));
      [v101 addObject:v36];

      goto LABEL_141;
    }

    if ((unint64_t)(v42 - 3) > 1)
    {
      if (v42 == 20)
      {
        uint64_t v58 = -[NSSQLExpressionIntermediate initWithExpression:allowToMany:inScope:]( objc_alloc(&OBJC_CLASS___NSSQLTernaryExpressionIntermediate),  "initWithExpression:allowToMany:inScope:",  v41,  0LL,  self);
        uint64_t v59 = -[NSSQLTernaryExpressionIntermediate generateSQLStringInContext:]( v58,  "generateSQLStringInContext:",  v102);

        if (!v59)
        {

          if (![v102 objectForKey:@"NSUnderlyingException"])
          {
            uint64_t v89 = (void *)MEMORY[0x189603F70];
            uint64_t v90 = [NSString stringWithFormat:@"Can't generate SQL for ternary expression: %@", v41];
            objc_msgSend( v102,  "setObject:forKey:",  objc_msgSend(v89, "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], v90, 0),  @"NSUnderlyingException");
          }

          return 0LL;
        }

        [v5 appendString:v59];

        uint64_t v60 = -[NSSQLAttribute initForReadOnlyFetchWithExpression:]( objc_alloc(&OBJC_CLASS___NSSQLAttribute),  "initForReadOnlyFetchWithExpression:",  v31);
        uint64_t v57 = v60;
        if (v60) {
          v60[1] = v32;
        }
      }

      else
      {
        if (v42 != 50
          || ([v41 isCountOnlyRequest] & 1) == 0
          && objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v41, "requestExpression"),  "expressionValueWithObject:context:",  0,  0),  "resultType") != 4)
        {

          int v85 = (void *)MEMORY[0x189603F70];
          int v86 = [NSString stringWithFormat:@"Currently unsupported (%@), try again later", v31];
          objc_msgSend( v102,  "setObject:forKey:",  objc_msgSend(v85, "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], v86, 0),  @"NSUnderlyingException");

          return 0LL;
        }

        uint64_t v55 = (void *)-[NSSQLIntermediate _generateSQLForFetchExpression:allowToMany:inContext:](self, v41, 1LL, v102);
        if (!v55)
        {

          if (![v102 objectForKey:@"NSUnderlyingException"])
          {
            uint64_t v91 = (void *)MEMORY[0x189603F70];
            uint64_t v92 = [NSString stringWithFormat:@"Can't generate select target token for fetch request expression: %@", v41];
            objc_msgSend( v102,  "setObject:forKey:",  objc_msgSend(v91, "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], v92, 0),  @"NSUnderlyingException");
          }

          return 0LL;
        }

        [v5 appendString:v55];

        uint64_t v56 = -[NSSQLAttribute initForReadOnlyFetchWithExpression:]( objc_alloc(&OBJC_CLASS___NSSQLAttribute),  "initForReadOnlyFetchWithExpression:",  v31);
        uint64_t v57 = v56;
        if (v56) {
          v56[1] = v32;
        }
      }

      goto LABEL_133;
    }

    if (sel_inverseOrderKey_ == (char *)[v41 selector])
    {
      objc_msgSend( v5,  "appendString:",  objc_msgSend((id)objc_msgSend((id)objc_msgSend(v41, "arguments"), "objectAtIndex:", 0), "constantValue"));
      id v67 = -[NSSQLAttribute initForReadOnlyFetchWithExpression:]( objc_alloc(&OBJC_CLASS___NSSQLAttribute),  "initForReadOnlyFetchWithExpression:",  v31);
      uint64_t v57 = v67;
      if (v67) {
        v67[1] = v32;
      }
LABEL_133:
      [v101 addObject:v57];

      goto LABEL_141;
    }

    if (([(id)objc_opt_class() isSimpleKeypath:v41] & 1) != 0
      || -[NSSQLIntermediate isVariableBasedKeypathScopedBySubquery:]((uint64_t)self, v41))
    {
      BOOL v50 = -[NSSQLExpressionIntermediate initWithExpression:allowToMany:inScope:]( objc_alloc(&OBJC_CLASS___NSSQLKeypathExpressionIntermediate),  "initWithExpression:allowToMany:inScope:",  v41,  0LL,  self);
    }

    else if (-[NSSQLIntermediate _functionExpressionIsSubqueryFollowedByKeypath:]((BOOL)self, v41))
    {
      BOOL v50 = -[NSSQLSubqueryExpressionIntermediate initWithExpression:trailingKeypath:inScope:]( [NSSQLSubqueryExpressionIntermediate alloc],  "initWithExpression:trailingKeypath:inScope:",  [v41 operand],  objc_msgSend((id)objc_msgSend(v41, "arguments"), "objectAtIndex:", 0),  self);
    }

    else
    {
      BOOL v50 = -[NSSQLExpressionIntermediate initWithExpression:allowToMany:inScope:]( objc_alloc(&OBJC_CLASS___NSSQLFunctionExpressionIntermediate),  "initWithExpression:allowToMany:inScope:",  v41,  0LL,  self);
    }

    int v51 = v50;
    uint64_t v52 = -[NSSQLKeypathExpressionIntermediate generateSQLStringInContext:](v50, "generateSQLStringInContext:", v102);
    if (!v52)
    {

      if (![v102 objectForKey:@"NSUnderlyingException"])
      {
        uint64_t v87 = (void *)MEMORY[0x189603F70];
        double v88 = [NSString stringWithFormat:@"Can't generate select target token for expression: %@", v41];
        objc_msgSend( v102,  "setObject:forKey:",  objc_msgSend(v87, "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], v88, 0),  @"NSUnderlyingException");
      }

      return 0LL;
    }

    [v5 appendString:v52];

    uint64_t v53 = [v102 objectForKey:@"keypathExpressionDestinationRelationship"];
    if (v53 && -[NSPropertyDescription expressionResultType](v31, "expressionResultType") == 2000)
    {
      unsigned int v54 = objc_alloc_init(&OBJC_CLASS___NSSQLToOne);
      -[NSSQLToOne copyValuesForReadOnlyFetch:](v54, "copyValuesForReadOnlyFetch:", v53);
      if (v54) {
        v54->super.super._propertyDescription = v32;
      }
      [v101 addObject:v54];
    }

    else
    {
      uint64_t v61 = -[NSSQLAttribute initForReadOnlyFetchWithExpression:]( objc_alloc(&OBJC_CLASS___NSSQLAttribute),  "initForReadOnlyFetchWithExpression:",  v31);
      BOOL v93 = v61;
      if (v61) {
        v61[1] = v32;
      }
      objc_msgSend(v101, "addObject:");
      __int128 v110 = 0u;
      __int128 v111 = 0u;
      __int128 v108 = 0u;
      __int128 v109 = 0u;
      obuint64_t j = (id)objc_msgSend( (id)objc_msgSend(v102, "objectForKeyedSubscript:", @"storeRequest"),  "sortDescriptors");
      uint64_t v62 = [obj countByEnumeratingWithState:&v108 objects:v128 count:16];
      if (v62)
      {
        uint64_t v63 = *(void *)v109;
        while (2)
        {
          for (uint64_t k = 0LL; k != v62; ++k)
          {
            if (*(void *)v109 != v63) {
              objc_enumerationMutation(obj);
            }
            uint64_t v65 = *(void **)(*((void *)&v108 + 1) + 8 * k);
            int v66 = -[NSPropertyDescription name](v31, "name");
            if (-[NSString isEqualToString:](v66, "isEqualToString:", [v65 key]))
            {
              if (v97) {
                CFDataRef v71 = (void *)v97[5];
              }
              else {
                CFDataRef v71 = 0LL;
              }
              if ([v71 objectForKeyedSubscript:v66])
              {
                _NSCoreDataLog( 2LL,  (uint64_t)@"Sort descriptor key %@ may refer to a modelled property or an expression; the modelled property will be used.",
                  v72,
                  v73,
                  v74,
                  v75,
                  v76,
                  v77,
                  (uint64_t)v66);
              }

              else
              {
                uint64_t v78 = (void *)-[NSSQLAliasGenerator generateVariableAlias]([v102 objectForKey:@"aliasGenerator"]);
                -[NSMutableDictionary setObject:forKey:](self->_variableToAliasMappings, "setObject:forKey:", v78, v31);
                -[NSSQLColumn _setColumnName:]((uint64_t)v93, v78);
              }

              goto LABEL_153;
            }
          }

          uint64_t v62 = [obj countByEnumeratingWithState:&v108 objects:v128 count:16];
          if (v62) {
            continue;
          }
          break;
        }
      }

LABEL_153:
    }

        int v51 = v347;
        uint64_t v52 = v344;
        uint64_t v59 = v345;
        uint64_t v147 = (void *)[v60 name];
        uint64_t v148 = (objc_class *)objc_opt_class();
        if (([v147 isEqualToString:NSStringFromClass(v148)] & 1) != 0
          || (uint64_t v149 = (void *)[v60 name],
              uint64_t v150 = (objc_class *)objc_opt_class(),
              ([v149 isEqualToString:NSStringFromClass(v150)] & 1) != 0)
          || (uint64_t v151 = (void *)[v60 name],
              unsigned int v152 = (objc_class *)objc_opt_class(),
              [v151 isEqualToString:NSStringFromClass(v152)]))
        {
          uint64_t v153 = -[NSSQLiteAdapter newDropTableStatementForTableNamed:]( (NSSQLiteStatement *)[v347 adapter],  objc_msgSend(v60, "tableName"));
          BOOL v154 = *(void *)(v50 + 24);
          if (v154)
          {
            [*(id *)(v154 + 8) addObject:v153];
            *(_BYTE *)(v154 + 32) = 1;
          }

          id v67 = *(void *)(v50 + 24);
          if (v67) {
            goto LABEL_159;
          }
        }

        else
        {
          uint64_t v156 = (void *)[v60 name];
          uint64_t v157 = (objc_class *)objc_opt_class();
          if ([v156 isEqualToString:NSStringFromClass(v157)])
          {
            v382 = 0u;
            v383 = 0u;
            v380 = 0u;
            v381 = 0u;
            uint64_t v158 = [&unk_189F0B3E8 countByEnumeratingWithState:&v380 objects:v422 count:16];
            if (v158)
            {
              uint64_t v159 = *(void *)v381;
              do
              {
                int v160 = 0LL;
                do
                {
                  if (*(void *)v381 != v159) {
                    objc_enumerationMutation(&unk_189F0B3E8);
                  }
                  if (v60) {
                    int v161 = (_BYTE *)[v60[5] objectForKey:*(void *)(*((void *)&v380 + 1) + 8 * v160)];
                  }
                  else {
                    int v161 = 0LL;
                  }
                  if (objc_msgSend(v351, "containsString:", objc_msgSend(v161, "columnName")))
                  {
                    uint64_t v162 = (void *)MEMORY[0x186E3E5D8]();
                    else {
                      uint64_t v163 = __ckLoggingOverride;
                    }
                    uint64_t v164 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping migration for '%@' because it already has a column named '%@'"];
                    [v60 tableName];
                    [v161 columnName];
                    _NSCoreDataLog( v163,  v164,  v165,  v166,  v167,  v168,  v169,  v170,  (uint64_t)"-[PFCloudKitMetadataModelMigrator calculateMigrationStepsWithConnection:error:]");
                    objc_autoreleasePoolPop(v162);
                  }

                  else
                  {
                    -[PFCloudKitMetadataModelMigrator addMigrationStatementForAddingAttribute:toContext:inStore:]( v161,  *(void *)(v50 + 24),  *(void **)(v50 + 8));
                  }

                  ++v160;
                }

                while (v158 != v160);
                uint64_t v171 = [&unk_189F0B3E8 countByEnumeratingWithState:&v380 objects:v422 count:16];
                uint64_t v158 = v171;
              }

              while (v171);
            }

            [*(id *)(v50 + 24) addConstrainedEntityToPreflight:v60];
            unsigned int v172 = [v347 adapter];
            if (v172) {
              uint64_t v173 = -[NSSQLiteAdapter newCreateIndexStatementsForEntity:defaultIndicesOnly:](v172, (uint64_t)v60, 0);
            }
            else {
              uint64_t v173 = 0LL;
            }
            v378 = 0u;
            v379 = 0u;
            v376 = 0u;
            v377 = 0u;
            BOOL v174 = [v173 countByEnumeratingWithState:&v376 objects:v421 count:16];
            if (v174)
            {
              uint64_t v175 = *(void *)v377;
              do
              {
                for (m = 0LL; m != v174; ++m)
                {
                  if (*(void *)v377 != v175) {
                    objc_enumerationMutation(v173);
                  }
                  uint64_t v177 = *(void *)(v50 + 24);
                  if (v177)
                  {
                    [*(id *)(v177 + 8) addObject:*(void *)(*((void *)&v376 + 1) + 8 * m)];
                    *(_BYTE *)(v177 + 32) = 1;
                  }
                }

                BOOL v174 = [v173 countByEnumeratingWithState:&v376 objects:v421 count:16];
              }

              while (v174);
            }

            int v51 = v347;
          }

          v178 = (void *)[v60 name];
          uint64_t v179 = (objc_class *)objc_opt_class();
          if (([v178 isEqualToString:NSStringFromClass(v179)] & 1) != 0
            || (int v180 = (void *)[v60 name],
                v181 = (objc_class *)objc_opt_class(),
                [v180 isEqualToString:NSStringFromClass(v181)]))
          {
            if ([v351 containsString:@"ZHASCHANGES"])
            {
              int v182 = (void *)[v60 name];
              int v183 = (objc_class *)objc_opt_class();
              v350 = [v182 isEqualToString:NSStringFromClass(v183)];
              __int128 v184 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189607940]),  "initWithFormat:",  @"CREATE TEMPORARY TABLE %@_tmp("),  objc_msgSend(v60, "tableName");
              v343 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189607940]),  "initWithFormat:",  @"INSERT INTO %@_tmp ("),  objc_msgSend(v60, "tableName");
              v341 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:@"SELECT"];
              v342 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189607940]),  "initWithFormat:",  @"INSERT INTO %@ ("),  objc_msgSend(v60, "tableName");
              id v185 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:@"SELECT"];
              int v186 = v60;
              while (v186)
              {
                int v187 = v186;
                int v186 = (id *)v186[21];
                if (v186 == v187)
                {
                  unsigned int v188 = v187[9];
                  goto LABEL_200;
                }
              }

              unsigned int v188 = 0LL;
LABEL_200:
              unsigned __int8 v189 = [v188 count];
              uint64_t v190 = v189;
              if (v189)
              {
                char v191 = 0LL;
                uint64_t v192 = v189 - 1;
                do
                {
                  v193 = v60;
                  while (v193)
                  {
                    v194 = v193;
                    v193 = (id *)v193[21];
                    if (v193 == v194)
                    {
                      v195 = v194[9];
                      goto LABEL_206;
                    }
                  }

                  v195 = 0LL;
LABEL_206:
                  v196 = (void *)[v195 objectAtIndexedSubscript:v191];
                  if (objc_msgSend(v351, "containsString:", objc_msgSend(v196, "columnName")))
                  {
                    [v184 appendFormat:@" %@", objc_msgSend(v196, "columnName")];
                    [v343 appendFormat:@" %@", objc_msgSend(v196, "columnName")];
                    [v342 appendFormat:@" %@", objc_msgSend(v196, "columnName")];
                    [v185 appendFormat:@" %@", objc_msgSend(v196, "columnName")];
                    [v341 appendFormat:@" %@", objc_msgSend(v196, "columnName")];
                    if (v191 < v192)
                    {
                      [v184 appendString:@","];
                      [v343 appendString:@","];
                      [v342 appendString:@","];
                      [v185 appendString:@","];
                      [v341 appendString:@","];
                    }
                  }

                  ++v191;
                }

                while (v191 != v190);
              }

              [v184 appendString:@""]);
              [v342 appendString:@""]);
              [v343 appendString:@""]);
              [v341 appendFormat:@" FROM %@", objc_msgSend(v60, "tableName")];
              [v185 appendFormat:@" FROM %@_tmp", objc_msgSend(v60, "tableName")];
              v197 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  v60,  v184);
              v198 = *(void *)(v50 + 24);
              if (v198)
              {
                [*(id *)(v198 + 8) addObject:v197];
                *(_BYTE *)(v198 + 32) = 1;
              }

              v199 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
              v200 = -[NSSQLiteStatement initWithEntity:sqlString:]( v199,  "initWithEntity:sqlString:",  v60,  [NSString stringWithFormat:@"%@ %@", v343, v341]);
              v201 = *(void *)(v50 + 24);
              if (v201)
              {
                [*(id *)(v201 + 8) addObject:v200];
                *(_BYTE *)(v201 + 32) = 1;
              }

              v202 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
              v203 = -[NSSQLiteStatement initWithEntity:sqlString:]( v202,  "initWithEntity:sqlString:",  v60,  [NSString stringWithFormat:@"DROP TABLE %@", objc_msgSend(v60, "tableName")]);
              v204 = *(void *)(v50 + 24);
              if (v204)
              {
                [*(id *)(v204 + 8) addObject:v203];
                *(_BYTE *)(v204 + 32) = 1;
              }

              v205 = -[NSSQLiteAdapter newCreateTableStatementForEntity:]( (const __CFString *)[v51 adapter],  v60);
              v351 = -[NSSQLiteStatement sqlString](v205, "sqlString");
              v206 = *(void *)(v50 + 24);
              if (v206)
              {
                [*(id *)(v206 + 8) addObject:v205];
                *(_BYTE *)(v206 + 32) = 1;
              }

              v207 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
              v208 = -[NSSQLiteStatement initWithEntity:sqlString:]( v207,  "initWithEntity:sqlString:",  v60,  [NSString stringWithFormat:@"%@ %@", v342, v185]);
              v209 = *(void *)(v50 + 24);
              if (v209)
              {
                [*(id *)(v209 + 8) addObject:v208];
                *(_BYTE *)(v209 + 32) = 1;
              }

              v210 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
              v211 = -[NSSQLiteStatement initWithEntity:sqlString:]( v210,  "initWithEntity:sqlString:",  v60,  [NSString stringWithFormat:@"DROP TABLE %@_tmp", objc_msgSend(v60, "tableName")]);
              v212 = *(void *)(v50 + 24);
              if (v212)
              {
                [*(id *)(v212 + 8) addObject:v211];
                *(_BYTE *)(v212 + 32) = 1;
                v213 = *(void **)(v50 + 24);
              }

              else
              {
                v213 = 0LL;
              }

              [v213 addConstrainedEntityToPreflight:v60];
              v214 = v184;
              v215 = [v51 adapter];
              if (v215) {
                v216 = -[NSSQLiteAdapter newCreateIndexStatementsForEntity:defaultIndicesOnly:](v215, (uint64_t)v60, 0);
              }
              else {
                v216 = 0LL;
              }
              v217 = v185;
              v374 = 0u;
              v375 = 0u;
              v372 = 0u;
              v373 = 0u;
              v218 = [v216 countByEnumeratingWithState:&v372 objects:v420 count:16];
              if (v218)
              {
                v219 = *(void *)v373;
                do
                {
                  for (n = 0LL; n != v218; ++n)
                  {
                    if (*(void *)v373 != v219) {
                      objc_enumerationMutation(v216);
                    }
                    v221 = *(void *)(v50 + 24);
                    if (v221)
                    {
                      [*(id *)(v221 + 8) addObject:*(void *)(*((void *)&v372 + 1) + 8 * n)];
                      *(_BYTE *)(v221 + 32) = 1;
                    }
                  }

                  v218 = [v216 countByEnumeratingWithState:&v372 objects:v420 count:16];
                }

                while (v218);
              }
            }

            else
            {
              v350 = 0;
            }

            v370 = 0u;
            v371 = 0u;
            v368 = 0u;
            v369 = 0u;
            v222 = [&unk_189F0B400 countByEnumeratingWithState:&v368 objects:v419 count:16];
            if (v222)
            {
              v223 = *(void *)v369;
              do
              {
                v224 = 0LL;
                do
                {
                  if (*(void *)v369 != v223) {
                    objc_enumerationMutation(&unk_189F0B400);
                  }
                  if (v60) {
                    v225 = (_BYTE *)[v60[5] objectForKey:*(void *)(*((void *)&v368 + 1) + 8 * v224)];
                  }
                  else {
                    v225 = 0LL;
                  }
                  if (objc_msgSend(v351, "containsString:", objc_msgSend(v225, "columnName")))
                  {
                    v226 = (void *)MEMORY[0x186E3E5D8]();
                    else {
                      v227 = __ckLoggingOverride;
                    }
                    v228 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping migration for '%@' because it already has a column named '%@'"];
                    [v60 tableName];
                    [v225 columnName];
                    _NSCoreDataLog( v227,  v228,  v229,  v230,  v231,  v232,  v233,  v234,  (uint64_t)"-[PFCloudKitMetadataModelMigrator calculateMigrationStepsWithConnection:error:]");
                    objc_autoreleasePoolPop(v226);
                  }

                  else
                  {
                    -[PFCloudKitMetadataModelMigrator addMigrationStatementForAddingAttribute:toContext:inStore:]( v225,  *(void *)(v50 + 24),  *(void **)(v50 + 8));
                  }

                  ++v224;
                }

                while (v222 != v224);
                v235 = [&unk_189F0B400 countByEnumeratingWithState:&v368 objects:v419 count:16];
                v222 = v235;
              }

              while (v235);
            }

            v236 = (void *)[v60 name];
            v237 = (objc_class *)objc_opt_class();
            if ([v236 isEqualToString:NSStringFromClass(v237)])
            {
              v366 = 0u;
              v367 = 0u;
              v364 = 0u;
              v365 = 0u;
              v238 = [&unk_189F0B418 countByEnumeratingWithState:&v364 objects:v418 count:16];
              if (v238)
              {
                v239 = *(void *)v365;
                do
                {
                  v240 = 0LL;
                  do
                  {
                    if (*(void *)v365 != v239) {
                      objc_enumerationMutation(&unk_189F0B418);
                    }
                    if (v60) {
                      v241 = (_BYTE *)[v60[5] objectForKey:*(void *)(*((void *)&v364 + 1) + 8 * v240)];
                    }
                    else {
                      v241 = 0LL;
                    }
                    if (objc_msgSend(v351, "containsString:", objc_msgSend(v241, "columnName")))
                    {
                      v242 = (void *)MEMORY[0x186E3E5D8]();
                      else {
                        v243 = __ckLoggingOverride;
                      }
                      v244 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping migration for '%@' because it already has a column named '%@'"];
                      [v60 tableName];
                      [v241 columnName];
                      _NSCoreDataLog( v243,  v244,  v245,  v246,  v247,  v248,  v249,  v250,  (uint64_t)"-[PFCloudKitMetadataModelMigrator calculateMigrationStepsWithConnection:error:]");
                      objc_autoreleasePoolPop(v242);
                    }

                    else
                    {
                      -[PFCloudKitMetadataModelMigrator addMigrationStatementForAddingAttribute:toContext:inStore:]( v241,  *(void *)(v50 + 24),  *(void **)(v50 + 8));
                      v350 = 1;
                    }

                    ++v240;
                  }

                  while (v238 != v240);
                  v251 = [&unk_189F0B418 countByEnumeratingWithState:&v364 objects:v418 count:16];
                  v238 = v251;
                }

                while (v251);
              }

              v362 = 0u;
              v363 = 0u;
              v360 = 0u;
              v361 = 0u;
              v252 = [&unk_189F0B430 countByEnumeratingWithState:&v360 objects:v417 count:16];
              if (v252)
              {
                v253 = *(void *)v361;
                do
                {
                  v254 = 0LL;
                  do
                  {
                    if (*(void *)v361 != v253) {
                      objc_enumerationMutation(&unk_189F0B430);
                    }
                    if (v60) {
                      v255 = (_BYTE *)[v60[5] objectForKey:*(void *)(*((void *)&v360 + 1) + 8 * v254)];
                    }
                    else {
                      v255 = 0LL;
                    }
                    if (objc_msgSend(v351, "containsString:", objc_msgSend(v255, "columnName")))
                    {
                      v256 = (void *)MEMORY[0x186E3E5D8]();
                      else {
                        v257 = __ckLoggingOverride;
                      }
                      v258 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping migration for '%@' because it already has a column named '%@'"];
                      [v60 tableName];
                      [v255 columnName];
                      _NSCoreDataLog( v257,  v258,  v259,  v260,  v261,  v262,  v263,  v264,  (uint64_t)"-[PFCloudKitMetadataModelMigrator calculateMigrationStepsWithConnection:error:]");
                      objc_autoreleasePoolPop(v256);
                    }

                    else
                    {
                      -[PFCloudKitMetadataModelMigrator addMigrationStatementForAddingAttribute:toContext:inStore:]( v255,  *(void *)(v50 + 24),  *(void **)(v50 + 8));
                    }

                    ++v254;
                  }

                  while (v252 != v254);
                  v265 = [&unk_189F0B430 countByEnumeratingWithState:&v360 objects:v417 count:16];
                  v252 = v265;
                }

                while (v265);
              }
            }

            if ((v350 & 1) != 0)
            {
              v266 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
              v267 = (void *)NSString;
              v268 = [v60 tableName];
              if (v60) {
                v269 = (void *)[v60[5] objectForKey:@"hasRecordZoneNum"];
              }
              else {
                v269 = 0LL;
              }
              v270 = -[NSSQLiteStatement initWithEntity:sqlString:]( v266,  "initWithEntity:sqlString:",  v60,  [v267 stringWithFormat:@"UPDATE %@ SET %@=0", v268, objc_msgSend(v269, "columnName")]);
              v271 = *(void *)(v50 + 24);
              if (v271)
              {
                [*(id *)(v271 + 8) addObject:v270];
                *(_BYTE *)(v271 + 32) = 1;
              }
            }
          }

          v272 = (void *)[v60 name];
          v273 = (objc_class *)objc_opt_class();
          if ([v272 isEqualToString:NSStringFromClass(v273)])
          {
            v358 = 0u;
            v359 = 0u;
            v356 = 0u;
            v357 = 0u;
            v274 = [&unk_189F0B448 countByEnumeratingWithState:&v356 objects:v416 count:16];
            if (v274)
            {
              v275 = *(void *)v357;
              do
              {
                v276 = 0LL;
                do
                {
                  if (*(void *)v357 != v275) {
                    objc_enumerationMutation(&unk_189F0B448);
                  }
                  if (v60) {
                    v277 = (_BYTE *)[v60[5] objectForKey:*(void *)(*((void *)&v356 + 1) + 8 * v276)];
                  }
                  else {
                    v277 = 0LL;
                  }
                  if (objc_msgSend(v351, "containsString:", objc_msgSend(v277, "columnName")))
                  {
                    v278 = (void *)MEMORY[0x186E3E5D8]();
                    else {
                      v279 = __ckLoggingOverride;
                    }
                    v280 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping migration for '%@' because it already has a column named '%@'"];
                    [v60 tableName];
                    [v277 columnName];
                    _NSCoreDataLog( v279,  v280,  v281,  v282,  v283,  v284,  v285,  v286,  (uint64_t)"-[PFCloudKitMetadataModelMigrator calculateMigrationStepsWithConnection:error:]");
                    objc_autoreleasePoolPop(v278);
                  }

                  else
                  {
                    -[PFCloudKitMetadataModelMigrator addMigrationStatementForAddingAttribute:toContext:inStore:]( v277,  *(void *)(v50 + 24),  *(void **)(v50 + 8));
                  }

                  ++v276;
                }

                while (v274 != v276);
                v287 = [&unk_189F0B448 countByEnumeratingWithState:&v356 objects:v416 count:16];
                v274 = v287;
              }

              while (v287);
            }
          }

          v288 = (void *)[v60 name];
          v289 = (objc_class *)objc_opt_class();
          if ([v288 isEqualToString:NSStringFromClass(v289)])
          {
            v354 = 0u;
            v355 = 0u;
            v352 = 0u;
            v353 = 0u;
            v290 = [&unk_189F0B460 countByEnumeratingWithState:&v352 objects:v415 count:16];
            if (v290)
            {
              v291 = *(void *)v353;
              do
              {
                v292 = 0LL;
                do
                {
                  if (*(void *)v353 != v291) {
                    objc_enumerationMutation(&unk_189F0B460);
                  }
                  if (v60) {
                    v293 = (_BYTE *)[v60[5] objectForKey:*(void *)(*((void *)&v352 + 1) + 8 * v292)];
                  }
                  else {
                    v293 = 0LL;
                  }
                  if (objc_msgSend(v351, "containsString:", objc_msgSend(v293, "columnName")))
                  {
                    v294 = (void *)MEMORY[0x186E3E5D8]();
                    else {
                      v295 = __ckLoggingOverride;
                    }
                    v296 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping migration for '%@' because it already has a column named '%@'"];
                    [v60 tableName];
                    [v293 columnName];
                    _NSCoreDataLog( v295,  v296,  v297,  v298,  v299,  v300,  v301,  v302,  (uint64_t)"-[PFCloudKitMetadataModelMigrator calculateMigrationStepsWithConnection:error:]");
                    objc_autoreleasePoolPop(v294);
                  }

                  else
                  {
                    -[PFCloudKitMetadataModelMigrator addMigrationStatementForAddingAttribute:toContext:inStore:]( v293,  *(void *)(v50 + 24),  *(void **)(v50 + 8));
                  }

                  ++v292;
                }

                while (v290 != v292);
                v303 = [&unk_189F0B460 countByEnumeratingWithState:&v352 objects:v415 count:16];
                v290 = v303;
              }

              while (v303);
            }
          }

          v304 = *(void *)(v50 + 24);
          if (v304) {
            v305 = *(void **)(v304 + 80);
          }
          else {
            v305 = 0LL;
          }
          int v51 = v347;
          uint64_t v52 = v344;
          uint64_t v59 = v345;
          if ([v305 integerValue] <= 976)
          {
            v306 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
            v307 = -[NSSQLiteStatement initWithEntity:sqlString:]( v306,  "initWithEntity:sqlString:",  v60,  [NSString stringWithFormat:@"UPDATE %@ SET Z_OPT = 1 WHERE Z_OPT IS NULL OR Z_OPT <= 0", objc_msgSend(v60, "tableName")]);
            v308 = *(void *)(v50 + 24);
            if (v308)
            {
              [*(id *)(v308 + 8) addObject:v307];
              *(_BYTE *)(v308 + 32) = 1;
            }
          }

          v309 = *(void *)(v50 + 24);
          if (v309) {
            v310 = *(void **)(v309 + 80);
          }
          else {
            v310 = 0LL;
          }
          if ([v310 integerValue] <= 1031)
          {
            v311 = *(void *)(v50 + 24);
            if (v311)
            {
              char v155 = (_BYTE *)(v311 + 38);
              goto LABEL_160;
            }
          }
        }

void sub_1866A6518( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, char a46)
{
}

void sub_1866A7334(void *a1)
{
}

void sub_1866A734C(_Unwind_Exception *a1)
{
}

unint64_t sortByFunctionComparison(void *a1, void *a2, uint64_t a3)
{
  unint64_t v5 = *(uint64_t (**)(void, uint64_t))a3;
  uint64_t v4 = *(void *)(a3 + 8);
  int v6 = (*(uint64_t (**)(void, uint64_t))a3)(*a1, v4);
  int v7 = v5(*a2, v4);
  return (v6 > v7) - (unint64_t)(v6 < v7);
}

size_t customCount(const __CFArray *a1)
{
  ValueAtIndex = (const char *)CFArrayGetValueAtIndex(a1, 0LL);
  return strlen(ValueAtIndex);
}

void makeBranchRow( CFArrayRef *a1, CFArrayRef *a2, uint64_t a3, const __CFDictionary *a4, int a5, signed int a6, uint64_t a7, int a8)
{
  __int16 Count = CFArrayGetCount(*a1);
  unsigned int v91 = a8 + 1;
  __int16 v16 = Count;
  ValueAtIndex = (const char *)CFArrayGetValueAtIndex(*a2, 0LL);
  uint64_t v89 = a3;
  unint64_t v90 = a3 - 1;
  uint64_t v18 = a2[a3 - 1];
  CFIndex v19 = CFArrayGetCount(v18);
  uint64_t v20 = (const char *)CFArrayGetValueAtIndex(v18, v19 - 1);
  BOOL v21 = v20;
  key = v20;
  if (a5)
  {
    unsigned int v22 = ValueAtIndex[a6];
    else {
      unsigned int v23 = v20[a6];
    }
    if (a5 == 1)
    {
      int v92 = 0;
      int v24 = 8;
      goto LABEL_16;
    }

    uint64_t v26 = [NSString stringWithUTF8String:"Illegal branch data: operation"];
    _NSCoreDataLog(17LL, v26, v27, v28, v29, v30, v31, v32, v87);
    id v33 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_186681000, v33, OS_LOG_TYPE_FAULT, "CoreData: Illegal branch data: operation", buf, 2u);
    }

    if (byte_18C4ABDC6) {
      goto LABEL_54;
    }
    int v24 = 0;
  }

  else
  {
    unsigned int v22 = strlen(ValueAtIndex);
    unsigned int v25 = strlen(v21);
    int v24 = 0;
    if (v25 <= 1) {
      unsigned int v23 = 1;
    }
    else {
      unsigned int v23 = v25;
    }
  }

  int v92 = 1;
LABEL_16:
  if (a6 >= 0x80000)
  {
    uint64_t v34 = [NSString stringWithUTF8String:"Illegal branch data: parameter"];
    _NSCoreDataLog(17LL, v34, v35, v36, v37, v38, v39, v40, v87);
    uint64_t v41 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_186681000, v41, OS_LOG_TYPE_FAULT, "CoreData: Illegal branch data: parameter", buf, 2u);
    }

    if (byte_18C4ABDC6) {
      goto LABEL_54;
    }
    a6 = 0;
  }

  if (a7 >= 0xFFFFFFFE)
  {
    uint64_t v42 = [NSString stringWithUTF8String:"Illegal branch data: offset"];
    _NSCoreDataLog(17LL, v42, v43, v44, v45, v46, v47, v48, v87);
    uint64_t v49 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_186681000, v49, OS_LOG_TYPE_FAULT, "CoreData: Illegal branch data: offset", buf, 2u);
    }

    if (byte_18C4ABDC6) {
      goto LABEL_54;
    }
    a7 = 0LL;
  }

  if (v22 < 0xFFFE) {
    goto LABEL_31;
  }
  uint64_t v50 = [NSString stringWithUTF8String:"Illegal branch data: lower"];
  _NSCoreDataLog(17LL, v50, v51, v52, v53, v54, v55, v56, v87);
  uint64_t v57 = (os_log_s *)__pflogFaultLog;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_186681000, v57, OS_LOG_TYPE_FAULT, "CoreData: Illegal branch data: lower", buf, 2u);
  }

  if (byte_18C4ABDC6)
  {
LABEL_54:
    __break(1u);
LABEL_55:
    objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"Recursion count exceeded" userInfo:0]);
    -[NSSQLLimitIntermediate generateSQLStringInContext:](v84, v85, v86);
    return;
  }

  unsigned int v22 = 0;
LABEL_31:
  if (v23 < 0xFFFF) {
    goto LABEL_36;
  }
  uint64_t v58 = [NSString stringWithUTF8String:"Illegal branch data: upper"];
  _NSCoreDataLog(17LL, v58, v59, v60, v61, v62, v63, v64, v87);
  uint64_t v65 = (os_log_s *)__pflogFaultLog;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_186681000, v65, OS_LOG_TYPE_FAULT, "CoreData: Illegal branch data: upper", buf, 2u);
  }

  if (byte_18C4ABDC6) {
    goto LABEL_54;
  }
  unsigned int v23 = 1;
LABEL_36:
  int v66 = PF_CALLOC_SCANNED_BYTES(2 * ((v23 + ~v22) & ~((int)(v23 + ~v22) >> 31)) + 16);
  *(void *)int v66 = v24 | (a6 << 13) | 1u | (unint64_t)(a7 << 32);
  uint64_t v67 = v22 + 1;
  v66[4] = v22 + 1;
  v66[6] = v23 - 1;
  CFArrayAppendValue(*a1, v66);
  CFIndex v68 = CFArrayGetCount(*a2);
  if (v68 == 1)
  {
    __int16 v69 = v16 + 1;
    v66[5] = (unsigned __int16)CFDictionaryGetValue(a4, ValueAtIndex);
  }

  else
  {
    *(void *)buf = 0LL;
    calculateNextBranchOperation(*a2, v68, (const void ***)buf, &v96, &v97, (const __CFAllocator *)&v95, &v94);
    v66[5] = ~v16;
    CFAllocatorRef v70 = *(const void ***)buf;
    int v71 = v96;
    makeBranchRow(a1, *(void *)buf, v96, a4, v97, v95, v94, v91);
    __int16 v69 = CFArrayGetCount(*a1);
    freeArrayOfCFObjects(v70, v71);
  }

  if (v89 == 1)
  {
    v66[7] = v66[5];
  }

  else
  {
    CFIndex v72 = CFArrayGetCount(a2[v90]);
    if (v72 == 1)
    {
      v66[7] = (unsigned __int16)CFDictionaryGetValue(a4, key);
    }

    else
    {
      *(void *)buf = 0LL;
      calculateNextBranchOperation(a2[v90], v72, (const void ***)buf, &v96, &v97, (const __CFAllocator *)&v95, &v94);
      v66[7] = -v69;
      uint64_t v73 = *(const void ***)buf;
      int v74 = v96;
      makeBranchRow(a1, *(void *)buf, v96, a4, v97, v95, v94, v91);
      __int16 v69 = CFArrayGetCount(*a1);
      freeArrayOfCFObjects(v73, v74);
    }

    if (v90 >= 2)
    {
      uint64_t v75 = a6;
      uint64_t v76 = v89 - 2;
      int v77 = a2 + 1;
      do
      {
        unsigned int v78 = CFArrayGetCount(*v77);
        uint64_t v79 = (const char *)CFArrayGetValueAtIndex(*v77, 0LL);
        int v80 = v79;
        if (v92) {
          size_t v81 = strlen(v79);
        }
        else {
          size_t v81 = v79[v75];
        }
        if (v78 == 1LL)
        {
          v66[v81 - v67 + 8] = (unsigned __int16)CFDictionaryGetValue(a4, v80);
        }

        else
        {
          *(void *)buf = 0LL;
          calculateNextBranchOperation(*v77, v78, (const void ***)buf, &v96, &v97, (const __CFAllocator *)&v95, &v94);
          v66[v81 - v67 + 8] = -v69;
          unint64_t v82 = *(const void ***)buf;
          int v83 = v96;
          makeBranchRow(a1, *(void *)buf, v96, a4, v97, v95, v94, v91);
          __int16 v69 = CFArrayGetCount(*a1);
          freeArrayOfCFObjects(v82, v83);
        }

        ++v77;
        --v76;
      }

      while (v76);
    }
  }

void sub_1866A89C0()
{
}

unint64_t _sql_read_only_fetch_plan_for_entity(unint64_t *a1)
{
  int v1 = a1;
  if (!atomic_load(a1 + 28))
  {
    unsigned int v3 = (void *)[a1 foreignKeyColumns];
    uint64_t v4 = (void *)[v1 foreignEntityKeyColumns];
    unint64_t v5 = (void *)[v1 foreignOrderKeyColumns];
    uint64_t v29 = v1;
    int v6 = (void *)[v1 attributeColumns];
    int v7 = [v3 count];
    int v8 = [v4 count];
    int v9 = [v5 count];
    int v10 = v8 + v7 + v9 + [v6 count];
    unsigned int v11 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      unsigned int v11 = malloc_default_zone();
    }
    uint64_t v12 = malloc_zone_malloc(v11, (24 * v10 + 8));
    v12[1] = v10;
    id v13 = objc_alloc_init(MEMORY[0x189603FA8]);
    [v13 addObjectsFromArray:v3];
    [v13 addObjectsFromArray:v4];
    [v13 addObjectsFromArray:v5];
    [v13 addObjectsFromArray:v6];
    [v13 sortUsingFunction:_compareSQLColumnsByFetchIndex context:0];
    uint64_t v31 = v13;
    uint64_t v30 = [v13 count];
    uint64_t v28 = (CFTypeRef *)v12;
    if (v30)
    {
      uint64_t v14 = 0LL;
      unsigned int v15 = (char *)(v12 + 2);
      int v16 = 32;
      while (1)
      {
        int v17 = (unsigned __int16 *)[v31 objectAtIndex:v14];
        int v18 = [v17 slot];
        if (v17) {
          int v19 = v17[13];
        }
        else {
          int v19 = 0;
        }
        char v20 = [v17 sqlType];
        char v21 = [v17 propertyType];
        unsigned int v22 = (void *)[v17 propertyDescription];
        if (v22)
        {
          int v23 = [v22 isOptional];
          if (!v23) {
            goto LABEL_13;
          }
        }

        else
        {
          int v23 = 1;
        }

        v16 += 4;
LABEL_13:
        int v24 = -[NSSQLColumn roughSizeEstimate]((uint64_t)v17);
        if (v17) {
          CFRetain(v17);
        }
        v16 += v24;
        *(_DWORD *)unsigned int v15 = v18;
        *((_DWORD *)v15 + 1) = v19;
        *((_DWORD *)v15 + 2) = v23;
        v15[12] = v20;
        v15[13] = v21;
        *((_WORD *)v15 + 7) = v32;
        *((void *)v15 + 2) = v17;
        v15 += 24;
        if (v30 == ++v14) {
          goto LABEL_19;
        }
      }
    }

    int v16 = 32;
LABEL_19:

    int v1 = v29;
    *(_DWORD *)uint64_t v28 = v16;
    unsigned int v25 = v29 + 28;
    while (!__ldaxr(v25))
    {
    }

    __clrex();
    _deallocateFetchEntityPlan(v28);
  }

  return atomic_load(v1 + 28);
}

uint64_t _compareSQLColumnsByFetchIndex(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    unsigned int v2 = *(unsigned __int16 *)(a1 + 26);
    if (a2)
    {
LABEL_3:
      unsigned int v3 = *(unsigned __int16 *)(a2 + 26);
      goto LABEL_4;
    }
  }

  else
  {
    unsigned int v2 = 0;
    if (a2) {
      goto LABEL_3;
    }
  }

  unsigned int v3 = 0;
LABEL_4:
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return -1LL;
  }
}

uint64_t _prepareDictionaryResults(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v174 = *MEMORY[0x1895F89C0];
  uint64_t v155 = a2;
  if (a2) {
    uint64_t v3 = *(void *)(a2 + 136);
  }
  else {
    uint64_t v3 = 0LL;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 4);
  v146 = PF_ALLOCATE_OBJECT_ARRAY(*(unsigned int *)(a1 + 4));
  if (!v146) {
    return NSArray_EmptyArray;
  }
  uint64_t v5 = **(void **)(v2 + 64);
  int v6 = *(unint64_t **)(v3 + 40);
  if (v155)
  {
    uint64_t v134 = *(void *)(v155 + 112);
    if (v6)
    {
LABEL_7:
      unint64_t v139 = v6[30];
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v134 = 0LL;
    if (v6) {
      goto LABEL_7;
    }
  }

  unint64_t v139 = 0LL;
LABEL_8:
  BOOL v154 = *(uint64_t (**)(uint64_t, char *, void))(v3 + 64);
  unint64_t plan_for_entity = _sql_read_only_fetch_plan_for_entity(v6);
  if (!v155)
  {
    unsigned int v11 = (void *)[MEMORY[0x1896078A8] defaultManager];
    id v135 = v11;
    BOOL v133 = 0;
    uint64_t v138 = 0LL;
    uint64_t v12 = 0LL;
    int v9 = 0LL;
LABEL_227:
    int v149 = 0;
    goto LABEL_15;
  }

  uint64_t v138 = *(void *)(v155 + 128);
  uint64_t v7 = *(void *)(v155 + 32);
  uint64_t v8 = *(void *)(v155 + 136);
  if (v8) {
    int v9 = *(void **)(v8 + 8);
  }
  else {
    int v9 = 0LL;
  }
  unsigned int v11 = (void *)[MEMORY[0x1896078A8] defaultManager];
  id v135 = v11;
  BOOL v133 = *(_BYTE *)(v155 + 201) != 0;
  uint64_t v12 = (void **)v7;
  if (!v7) {
    goto LABEL_227;
  }
  int v149 = *(_BYTE *)(v7 + 43) & 1;
LABEL_15:
  BOOL v129 = (*(_DWORD *)(v3 + 72) & 0x1C) == 20;
  unsigned int v141 = v12;
  if (v129)
  {
    uint64_t v145 = (void *)[MEMORY[0x189603FA8] array];
    id v156 = (id)[MEMORY[0x189603FE0] set];
    uint64_t v159 = (void *)[MEMORY[0x189603FA8] array];
    uint64_t v13 = *(unsigned int *)(plan_for_entity + 4);
    if ((_DWORD)v13)
    {
      uint64_t v14 = (id *)(plan_for_entity + 24);
      do
      {
        uint64_t v15 = [*v14 propertyDescription];
        if (v15)
        {
          int v16 = (void *)v15;
          [v145 addObject:v15];
          if (([v16 _entitysReferenceID] & 0x8000000000000000) == 0) {
            objc_msgSend(v156, "addObject:", objc_msgSend(v16, "name"));
          }
        }

        v14 += 3;
        --v13;
      }

      while (v13);
    }

    __int128 v171 = 0u;
    __int128 v172 = 0u;
    __int128 v170 = 0u;
    __int128 v169 = 0u;
    int v17 = (void *)[v9 propertiesToFetch];
    unsigned int v11 = (void *)[v17 countByEnumeratingWithState:&v169 objects:v173 count:16];
    if (v11)
    {
      int v18 = v11;
      uint64_t v19 = *(void *)v170;
      do
      {
        char v20 = 0LL;
        do
        {
          if (*(void *)v170 != v19) {
            objc_enumerationMutation(v17);
          }
          char v21 = *(void **)(*((void *)&v169 + 1) + 8LL * (void)v20);
          if ([v21 isTransient])
          {
            [v159 addObject:v21];
            if (([v21 _entitysReferenceID] & 0x8000000000000000) == 0) {
              objc_msgSend(v156, "addObject:", objc_msgSend(v21, "name"));
            }
          }

          char v20 = (char *)v20 + 1;
        }

        while (v18 != v20);
        unsigned int v11 = (void *)[v17 countByEnumeratingWithState:&v169 objects:v173 count:16];
        int v18 = v11;
      }

      while (v11);
    }
  }

  else
  {
    uint64_t v159 = 0LL;
    uint64_t v145 = 0LL;
    id v156 = 0LL;
  }

  if ((int)v4 >= 1)
  {
    uint64_t v22 = 0LL;
    uint64_t v152 = 0LL;
    id v142 = 0LL;
    id v140 = 0LL;
    char v136 = 0LL;
    uint64_t v137 = 0LL;
    uint64_t v153 = sel_entityForID_;
    uint64_t v158 = @"TOMBSTONE";
    uint64_t v144 = v4;
    uint64_t v147 = v2;
    uint64_t v143 = v3;
    int v161 = v6;
    while (1)
    {
      while ((*(_DWORD *)v5 & 0x80000000) != 0)
      {
        uint64_t v23 = *(unsigned int *)(v5 + 4);
        if ((v23 & 0x80000000) != 0) {
          uint64_t v5 = 0LL;
        }
        else {
          uint64_t v5 = *(void *)(*(void *)(v2 + 64) + 8 * v23) + *(void *)(v5 + 16);
        }
      }

      uint64_t v150 = v132;
      uint64_t v24 = *(unsigned int *)(plan_for_entity + 4);
      MEMORY[0x1895F8858](v11);
      uint64_t v27 = (void **)&v132[-v26];
      uint64_t v163 = v24;
      bzero(&v132[-v26], 8LL * v25);
      uint64_t v164 = v27;
      if ((_DWORD)v24)
      {
        uint64_t v148 = v22;
        uint64_t v151 = v5;
        goto LABEL_43;
      }

      unsigned int v30 = 0;
LABEL_203:
      if ((*(_DWORD *)(v3 + 72) & 0x1C) == 0x10)
      {
        unsigned int v116 = objc_alloc(&OBJC_CLASS___NSKnownKeysDictionary);
        int v117 = -[NSKnownKeysDictionary initWithSearchStrategy:](v116, "initWithSearchStrategy:", v139);
        unsigned int v11 = (void *)-[NSKnownKeysDictionary setValues:](v117, "setValues:", v164);
      }

      else
      {
        uint64_t v118 = v4;
        uint64_t v119 = v3;
        char v120 = v164;
        signed int v121 = v141;
        int v122 = v138;
        int v117 = (NSKnownKeysDictionary *)-[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( v141,  *v164,  v138);
        uint64_t v123 = (uint64_t)v120;
        uint64_t v3 = v119;
        uint64_t v4 = v118;
        uint64_t v2 = v147;
        _PFFaultHandlerFulfillPartialFault(v122, (unsigned int *)v117, (uint64_t)v121, v123, v145, (uint64_t)v156, v159);
      }

      v146[v22] = v117;
      if (v30)
      {
        uint64_t v124 = v30;
        uint64_t v125 = v164;
        do
        {
          uint64_t v126 = *v125++;

          --v124;
        }

        while (v124);
      }

      uint64_t v127 = *(unsigned int *)(v5 + 4);
      if ((v127 & 0x80000000) == 0)
      {
        uint64_t v128 = *(void *)(*(void *)(v2 + 64) + 8 * v127);
        uint64_t v5 = v128 + *(void *)(v5 + 16);
        BOOL v129 = !v128 || ++v22 == v4;
        if (!v129) {
          continue;
        }
      }

      goto LABEL_219;
    }

    uint64_t v148 = v22;
    uint64_t v151 = v5;
    uint64_t v164 = (void **)NSAllocateScannedUncollectable();
LABEL_43:
    uint64_t v28 = 0LL;
    unint64_t v29 = 0LL;
    unsigned int v30 = 0;
    uint64_t v31 = 0LL;
    int v32 = 0;
    uint64_t v157 = 0LL;
    uint64_t v162 = 0LL;
    uint64_t v33 = v151 + 32;
    while (1)
    {
      uint64_t v34 = v31;
      uint64_t v35 = plan_for_entity + v28;
      int v36 = *(unsigned __int8 *)(plan_for_entity + v28 + 20);
      else {
        uint64_t v37 = qword_1868D6998[(char)(v36 - 2)];
      }
      uint64_t v38 = (unsigned __int8 *)((v37 + v33) & ~v37);
      if ((*(_BYTE *)(v35 + 16) & 1) != 0)
      {
        int v40 = *v38;
        uint64_t v167 = (uint64_t)(v38 + 1);
        BOOL v39 = v40 != 0;
      }

      else
      {
        uint64_t v167 = (v37 + v33) & ~v37;
        BOOL v39 = 0;
      }

      uint64_t v41 = 0LL;
      int v166 = v32;
      if (((v29 > 6) & v32) == 1 && !v39)
      {
        unint64_t v160 = v29;
        unsigned int v42 = v30;
        uint64_t v43 = v31;
        uint64_t v44 = v162;
        if (!v162)
        {
          if (v155) {
            uint64_t v45 = *(void **)(v155 + 8);
          }
          else {
            uint64_t v45 = 0LL;
          }
          uint64_t v46 = [v45 model];
          uint64_t v44 = (id *)v154(v46, v153, (int)v157);
        }

        uint64_t v41 = v44;
        id v47 = +[_PFPersistentHistoryModel _retainedTombstonesForEntity:]( (uint64_t)&OBJC_CLASS____PFPersistentHistoryModel,  v44);
        uint64_t v48 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(plan_for_entity + v28 + 24), "propertyDescription"), "name");
        int v49 = objc_msgSend( (id)objc_msgSend(v48, "stringByReplacingOccurrencesOfString:withString:", v158, &stru_189EAC2E8),  "intValue");
        int v50 = [v47 count];
        uint64_t v162 = v41;
        if (v49 >= v50)
        {
          uint64_t v41 = 0LL;
        }

        else
        {
          uint64_t v51 = [v47 objectAtIndexedSubscript:v49];
          if (v41) {
            uint64_t v41 = (id *)[v41[5] objectForKey:v51];
          }
          int v36 = 17;
        }

        uint64_t v34 = v43;
        unsigned int v30 = v42;
        unint64_t v29 = v160;
      }

      uint64_t v52 = ~v37;
      uint64_t v31 = 0LL;
      switch(v36)
      {
        case 1:
          LODWORD(valuePtr) = 0;
          uint64_t v65 = (int *)v167;
          int v66 = (CFAbsoluteTime *)((v37 + v167) & v52);
          if (v39) {
            p_CFAbsoluteTime valuePtr = &valuePtr;
          }
          else {
            p_CFAbsoluteTime valuePtr = (CFAbsoluteTime *)((v37 + v167) & v52);
          }
          if (!v39) {
            uint64_t v65 = (int *)v66 + 1;
          }
          uint64_t v167 = (uint64_t)v65;
          int v68 = *(unsigned __int8 *)(plan_for_entity + v28 + 21);
          switch(v68)
          {
            case 10:
              goto LABEL_142;
            case 4:
              if (v39) {
                CFNumberRef v70 = 0LL;
              }
              else {
                CFNumberRef v70 = (CFNumberRef)v154(v134, v153, *(int *)v66);
              }
              uint64_t v34 = 1LL;
              break;
            case 1:
              if (byte_18C4ABDBE) {
                BOOL v69 = v39;
              }
              else {
                BOOL v69 = 0;
              }
              if (v69)
              {
                CFNumberRef v70 = 0LL;
              }

              else
              {
                if (byte_18C4ABDBE) {
                  p_CFAbsoluteTime valuePtr = v66;
                }
LABEL_142:
                CFNumberRef v70 = CFNumberCreate(0LL, kCFNumberIntType, p_valuePtr);
              }

              uint64_t v34 = 0LL;
              break;
            default:
              goto LABEL_155;
          }

          v164[v30] = v70;
          goto LABEL_155;
        case 2:
        case 3:
          CFAbsoluteTime valuePtr = 0.0;
          uint64_t v57 = (void *)v167;
          uint64_t v58 = (CFAbsoluteTime *)((v37 + v167) & v52);
          if (!v39) {
            uint64_t v57 = v58 + 1;
          }
          uint64_t v167 = (uint64_t)v57;
          int v59 = *(unsigned __int8 *)(plan_for_entity + v28 + 21);
          if (v59 != 3)
          {
            if (v59 != 1) {
              goto LABEL_155;
            }
            if (byte_18C4ABDBE) {
              BOOL v60 = v39;
            }
            else {
              BOOL v60 = 0;
            }
            if (v60)
            {
LABEL_129:
              CFNumberRef v63 = 0LL;
            }

            else
            {
              uint64_t v61 = &valuePtr;
              if (!v39) {
                uint64_t v61 = v58;
              }
              if (byte_18C4ABDBE) {
                uint64_t v62 = v58;
              }
              else {
                uint64_t v62 = v61;
              }
              CFNumberRef v63 = CFNumberCreate(0LL, kCFNumberLongLongType, v62);
            }

            uint64_t v74 = v152;
            goto LABEL_131;
          }

          if ((v34 & 1) != 0)
          {
            uint64_t v74 = (uint64_t)v164[--v30];
            if (v39) {
              goto LABEL_129;
            }
          }

          else
          {
            uint64_t v74 = objc_msgSend( (id)objc_msgSend(*(id *)(plan_for_entity + v28 + 24), "toOneRelationship"),  "destinationEntity");
            if (v39) {
              goto LABEL_129;
            }
          }

          if (!*(void *)v58) {
            goto LABEL_129;
          }
          double v88 = v142;
          if (v74 != v152) {
            double v88 = 0LL;
          }
          if (v155 && v74 != v152) {
            double v88 = (objc_class *)[*(id *)(v155 + 8) objectIDFactoryForSQLEntity:v74];
          }
          id v142 = v88;
          CFNumberRef v63 = (CFNumberRef)[[v88 alloc] initWithPK64:*(void *)v58];
LABEL_131:
          uint64_t v34 = 0LL;
          v164[v30] = v63;
          uint64_t v152 = v74;
LABEL_155:
          uint64_t v31 = v34;
          goto LABEL_190;
        case 4:
        case 5:
        case 6:
        case 9:
        case 12:
          if (v39)
          {
            CFStringRef v53 = 0LL;
            goto LABEL_107;
          }

          uint64_t v54 = (const char *)((v37 + v167) & v52);
          CFStringRef v53 = CFStringCreateWithCString(0LL, v54 + 4, 0x8000100u);
          int v55 = *(unsigned __int8 *)(v35 + 20);
          uint64_t v167 = (uint64_t)&v54[*(int *)v54 + 4];
          if (v55 == 12)
          {
            uint64_t v56 = (const __CFString *)(id)[MEMORY[0x189604030] URLWithString:v53];
          }

          else
          {
            if (v55 != 4) {
              goto LABEL_107;
            }
            uint64_t v56 = (const __CFString *)[objc_alloc(MEMORY[0x189607858]) initWithString:v53];
          }

          uint64_t v73 = v56;
          CFRelease(v53);
          CFStringRef v53 = v73;
LABEL_107:
          uint64_t v31 = 0LL;
          v164[v30] = (void *)v53;
          goto LABEL_190;
        case 7:
        case 8:
          if (v39) {
            goto LABEL_102;
          }
          uint64_t v64 = (CFAbsoluteTime *)((v37 + v167) & v52);
          CFAbsoluteTime valuePtr = *v64;
          BOOL v129 = *(_BYTE *)(v35 + 20) == 7;
          uint64_t v167 = (uint64_t)(v64 + 1);
          if (v129) {
            CFNumberRef v78 = CFNumberCreate(0LL, kCFNumberDoubleType, &valuePtr);
          }
          else {
            CFNumberRef v78 = CFDateCreate(0LL, *v64);
          }
          goto LABEL_167;
        case 13:
        case 14:
          goto LABEL_190;
        case 16:
          int v71 = (void *)[*(id *)(plan_for_entity + v28 + 24) propertyDescription];
          if (v39)
          {
LABEL_102:
            CFNumberRef v78 = 0LL;
            goto LABEL_167;
          }

          uint64_t v79 = (const char *)((v37 + v167) & v52);
          size_t v81 = (int *)(v79 + 4);
          int v80 = *((unsigned __int8 *)v79 + 4);
          if (v80 != 3)
          {
            if (v80 == 1)
            {
              unint64_t v82 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
              if (v155) {
                uint64_t v83 = *(unsigned int *)(v155 + 184);
              }
              else {
                uint64_t v83 = 0LL;
              }
              uint64_t v84 = *(int *)v79;
              SEL v85 = (int *)(v79 + 4);
              uint64_t v86 = 0LL;
              uint64_t v87 = 0LL;
LABEL_165:
              CFNumberRef v78 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v82,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  v85,  v84,  v86,  v87,  v83);
              goto LABEL_166;
            }

            size_t v96 = strnlen(v79 + 5, *(int *)v79 - 1LL);
            uint64_t v97 = [v135 stringWithFileSystemRepresentation:v79 + 5 length:v96];
            uint64_t v98 = v136;
            if (v140)
            {
              if (!v155 || v136) {
                goto LABEL_160;
              }
LABEL_159:
              uint64_t v98 = *(void **)(v155 + 96);
            }

            else if (v155)
            {
              id v140 = *(id *)(v155 + 88);
              if (!v136) {
                goto LABEL_159;
              }
            }

            else
            {
              id v140 = 0LL;
            }

LABEL_160:
            uint64_t v99 = [v140 stringByAppendingPathComponent:v97];
            uint64_t v100 = [v98 stringByAppendingPathComponent:v97];
            char v136 = v98;
            if (!v133 || [v135 fileExistsAtPath:v99])
            {
              unint64_t v82 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
              if (v155) {
                uint64_t v83 = *(unsigned int *)(v155 + 184);
              }
              else {
                uint64_t v83 = 0LL;
              }
              uint64_t v84 = *(int *)v79;
              SEL v85 = (int *)(v79 + 4);
              uint64_t v86 = v99;
              uint64_t v87 = v100;
              goto LABEL_165;
            }

            CFNumberRef v78 = 0LL;
            goto LABEL_166;
          }

          uint64_t v93 = v137;
          if (v155 && !v137) {
            uint64_t v93 = *(void *)(v155 + 104);
          }
          uint64_t v94 = [MEMORY[0x189603F48] dataWithBytes:v81 length:*(int *)v79];
          unsigned int v95 = objc_alloc(&OBJC_CLASS____NSDataFileBackedFuture);
          uint64_t v137 = v93;
          CFNumberRef v78 = -[_NSDataFileBackedFuture initWithStoreMetadata:directory:]( v95,  "initWithStoreMetadata:directory:",  v94,  [MEMORY[0x189604030] fileURLWithPath:v93 isDirectory:1]);
LABEL_166:
          uint64_t v167 = (uint64_t)v81 + *(int *)v79;
LABEL_167:
          uint64_t v31 = 0LL;
          v164[v30] = v78;
LABEL_190:
          if (v161 && v28 == 72 && *((_DWORD *)v161 + 46) == 16001)
          {
            BOOL v114 = [v164[v30] intValue] == 2;
            int v32 = v114 | v166;
            uint64_t v115 = v163;
            uint64_t v33 = v167;
          }

          else
          {
            int v32 = v166;
            uint64_t v115 = v163;
            uint64_t v33 = v167;
            if (v28 == 120 && (v166 & 1) != 0)
            {
              uint64_t v157 = [v164[v30] intValue];
              int v32 = 1;
            }
          }

          ++v30;
          ++v29;
          v28 += 24LL;
          if (v115 == v29)
          {
            uint64_t v4 = v144;
            uint64_t v2 = v147;
            uint64_t v3 = v143;
            uint64_t v5 = v151;
            uint64_t v22 = v148;
            goto LABEL_203;
          }

          break;
        default:
LABEL_103:
          if (v39) {
            goto LABEL_104;
          }
          uint64_t v75 = (const UInt8 *)((v37 + v167) & v52);
          CFDataRef v72 = CFDataCreate(0LL, v75 + 4, *(int *)v75);
          uint64_t v167 = (uint64_t)&v75[*(int *)v75 + 4];
          if (v36 == 17 && [v41 sqlType] != 10)
          {
            [*(id *)(plan_for_entity + v28 + 24) propertyDescription];
            CFStringRef v89 = 0LL;
            int v90 = [v41 sqlType];
            switch(v90)
            {
              case 1:
                uint64_t v111 = -[__CFData bytes](v72, "bytes");
                __int128 v102 = (void *)[objc_alloc(NSString) initWithUTF8String:v111];
                uint64_t v103 = objc_msgSend( objc_alloc(MEMORY[0x189607968]),  "initWithInteger:",  objc_msgSend(v102, "integerValue"));
                goto LABEL_180;
              case 2:
              case 3:
                uint64_t v101 = -[__CFData bytes](v72, "bytes");
                __int128 v102 = (void *)[objc_alloc(NSString) initWithUTF8String:v101];
                uint64_t v103 = objc_msgSend( objc_alloc(MEMORY[0x189607968]),  "initWithLongLong:",  objc_msgSend(v102, "longLongValue"));
LABEL_180:
                CFStringRef v89 = (CFStringRef)v103;

                goto LABEL_188;
              case 4:
              case 5:
              case 6:
              case 9:
              case 12:
                if (CFDataGetLength(v72))
                {
                  BytePtr = (const char *)CFDataGetBytePtr(v72);
                  CFStringRef v89 = CFStringCreateWithCString(0LL, BytePtr, 0x8000100u);
                }

                else
                {
                  CFStringRef v89 = &stru_189EAC2E8;
                }

                if (v90 == 12)
                {
                  __int128 v109 = (objc_class *)MEMORY[0x189604030];
                }

                else
                {
                  if (v90 != 4) {
                    goto LABEL_188;
                  }
                  __int128 v109 = (objc_class *)MEMORY[0x189607858];
                }

                uint64_t v110 = [[v109 alloc] initWithString:v89];
                CFRelease(v89);
                CFStringRef v89 = (CFStringRef)v110;
LABEL_188:
                CFRelease(v72);
                CFDataRef v72 = (CFDataRef)v89;
                break;
              case 7:
              case 8:
                uint64_t v104 = -[__CFData bytes](v72, "bytes");
                __int128 v105 = (void *)[objc_alloc(NSString) initWithUTF8String:v104];
                if (v90 == 7)
                {
                  uint64_t v106 = objc_msgSend((id)objc_msgSend(v41, "propertyDescription"), "attributeType");
                  id v107 = objc_alloc(MEMORY[0x189607968]);
                  if (v106 == 600)
                  {
                    [v105 floatValue];
                    uint64_t v108 = objc_msgSend(v107, "initWithFloat:");
                  }

                  else
                  {
                    [v105 doubleValue];
                    uint64_t v108 = objc_msgSend(v107, "initWithDouble:");
                  }
                }

                else
                {
                  id v113 = objc_alloc(MEMORY[0x189603F50]);
                  [v105 doubleValue];
                  uint64_t v108 = objc_msgSend(v113, "initWithTimeIntervalSinceReferenceDate:");
                }

                CFStringRef v89 = (CFStringRef)v108;

                goto LABEL_188;
              case 11:
                if (-[__CFData length](v72, "length") == 16)
                {
                  __int128 v112 = (const __CFString *)objc_msgSend( objc_alloc(MEMORY[0x189607AB8]),  "initWithUUIDBytes:",  -[__CFData bytes](v72, "bytes"));
LABEL_184:
                  CFStringRef v89 = v112;
                }

                else
                {
                  CFStringRef v89 = 0LL;
                }

                goto LABEL_188;
              case 15:
                __int128 v112 = (const __CFString *)+[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)v72,  (void *)[v41 propertyDescription]);
                goto LABEL_184;
              default:
                goto LABEL_188;
            }
          }

          else
          {
            int v76 = *(unsigned __int8 *)(v35 + 20);
            if (v76 != 11)
            {
              if (v76 != 15) {
                goto LABEL_189;
              }
              int v77 = (const __CFData *)+[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)v72,  (void *)[*(id *)(plan_for_entity + v28 + 24) propertyDescription]);
              goto LABEL_139;
            }

            if (-[__CFData length](v72, "length") == 16)
            {
              int v77 = (const __CFData *)objc_msgSend( objc_alloc(MEMORY[0x189607AB8]),  "initWithUUIDBytes:",  -[__CFData bytes](v72, "bytes"));
LABEL_139:
              int v92 = v77;
              CFRelease(v72);
              CFDataRef v72 = v92;
              goto LABEL_189;
            }

LABEL_104:
            CFDataRef v72 = 0LL;
          }

            contexta = (char *)[v84 count];
            v216 = 0u;
            v217 = 0u;
            v214 = 0u;
            v215 = 0u;
            uint64_t v86 = [v204 countByEnumeratingWithState:&v214 objects:v244 count:16];
            if (v86)
            {
              uint64_t v87 = *(void *)v215;
              do
              {
                for (uint64_t k = 0LL; k != v86; ++k)
                {
                  if (*(void *)v215 != v87) {
                    objc_enumerationMutation(v204);
                  }
                  CFStringRef v89 = *(void *)(*((void *)&v214 + 1) + 8 * k);
                  if (v89)
                  {
                    int v90 = *(unsigned __int8 *)(v89 + 24);
                    if (v90 == 7 || v90 == 1) {
                      objc_msgSend(v84, "addObject:");
                    }
                  }
                }

                uint64_t v86 = [v204 countByEnumeratingWithState:&v214 objects:v244 count:16];
              }

              while (v86);
            }

            v202 = -[NSSQLiteConnection executeMulticolumnUniquenessCheckSQLStatement:returningColumns:](v161, v79, v84);

            v198 = (id)[v202 count];
            if ([v202 count])
            {
              v212 = 0u;
              v213 = 0u;
              v210 = 0u;
              v211 = 0u;
              v178 = (id)[v174 countByEnumeratingWithState:&v210 objects:v243 count:16];
              if (v178)
              {
                uint64_t v176 = *(void *)v211;
                do
                {
                  for (m = 0LL; m != v178; m = (char *)m + 1)
                  {
                    if (*(void *)v211 != v176) {
                      objc_enumerationMutation(v174);
                    }
                    if (v198)
                    {
                      int v92 = 0LL;
                      uint64_t v93 = *(void **)(*((void *)&v210 + 1) + 8LL * (void)m);
                      while (1)
                      {
                        v200 = (id)MEMORY[0x186E3E5D8]();
                        uint64_t v94 = [v202 objectAtIndex:v92];
                        if (v82) {
                          break;
                        }
LABEL_209:
                        uint64_t v118 = objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v202, "objectAtIndex:", v92), "objectAtIndex:", 0),  "unsignedIntegerValue");
                        uint64_t v119 = v196;
                        if (v194) {
                          uint64_t v119 = _sqlEntityForEntityID( v189,  objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v202, "objectAtIndex:", v92),  "objectAtIndex:",  1),  "unsignedIntegerValue"));
                        }
                        if (v205) {
                          char v120 = -[NSSQLCore newObjectIDForEntity:pk:]( v205->super._sqlCore,  "newObjectIDForEntity:pk:",  v119,  v118);
                        }
                        else {
                          char v120 = 0LL;
                        }
                        signed int v121 = (void *)[v93 objectID];
                        if (([v121 isEqual:v120] & 1) == 0)
                        {
                          int v122 = -[NSSQLStoreRequestContext createNestedObjectFaultContextForObjectWithID:]( v205,  (uint64_t)v120);
                          p_isa = (id *)&v122->super.super.isa;
                          if (v122) {
                            v122->_forConflictAnalysis = 1;
                          }
                          if (v205) {
                            connection = v205->super._connection;
                          }
                          else {
                            connection = 0LL;
                          }
                          -[NSSQLStoreRequestContext setConnection:]((uint64_t)v122, connection);
                          -[NSSQLStoreRequestContext setQueryGenerationToken:](p_isa, 0LL);
                          uint64_t v125 = _executeObjectFaultRequest((uint64_t)p_isa);
                          -[NSSQLStoreRequestContext setConnection:]((uint64_t)p_isa, 0LL);

                          if ([v93 isInserted])
                          {
                            uint64_t v126 = 0LL;
                          }

                          else
                          {
                            uint64_t v127 = -[NSSQLStoreRequestContext createNestedObjectFaultContextForObjectWithID:]( v205,  (uint64_t)v121);
                            uint64_t v128 = (id *)&v127->super.super.isa;
                            if (v127) {
                              v127->_forConflictAnalysis = 1;
                            }
                            if (v205) {
                              BOOL v129 = v205->super._connection;
                            }
                            else {
                              BOOL v129 = 0LL;
                            }
                            -[NSSQLStoreRequestContext setConnection:]((uint64_t)v127, v129);
                            -[NSSQLStoreRequestContext setQueryGenerationToken:](v128, 0LL);
                            uint64_t v126 = _executeObjectFaultRequest((uint64_t)v128);
                            -[NSSQLStoreRequestContext setConnection:]((uint64_t)v128, 0LL);
                          }

                          uint64_t v130 = (void *)[v183 objectWithID:v120];
                          uint64_t v131 = _newObjectGraphStyleForSQLRow(v125, v130);
                          if ([v93 isInserted]) {
                            uint64_t v132 = 0LL;
                          }
                          else {
                            uint64_t v132 = _newObjectGraphStyleForSQLRow(v126, v93);
                          }
                          BOOL v133 = objc_alloc(&OBJC_CLASS___NSConstraintConflict);
                          *(void *)&v233 = v93;
                          uint64_t v134 = [MEMORY[0x189603F18] arrayWithObjects:&v233 count:1];
                          id v135 = (uint64_t)v132;
                          if (!v132) {
                            id v135 = [MEMORY[0x189603FE8] null];
                          }
                          *(void *)&v229 = v135;
                          char v136 = -[NSConstraintConflict initWithConstraint:databaseObject:databaseSnapshot:conflictingObjects:conflictingSnapshots:]( v133,  "initWithConstraint:databaseObject:databaseSnapshot:conflictingObjects:conflictingSnapshots:",  v187,  v130,  v131,  v134,  [MEMORY[0x189603F18] arrayWithObjects:&v229 count:1]);
                          [v185 addObject:v136];
                        }

LABEL_232:
                        objc_autoreleasePoolPop(v200);
                        if ((id)++v92 == v198) {
                          goto LABEL_237;
                        }
                      }

                      unsigned int v95 = (void *)v94;
                      size_t v96 = 0LL;
                      uint64_t v97 = contexta;
                      while (2)
                      {
                        uint64_t v98 = (_BYTE *)[v204 objectAtIndex:v96];
                        uint64_t v99 = (uint64_t)v98;
                        if (v98)
                        {
                          if (v98[24] == 7) {
                            uint64_t v98 = (_BYTE *)[v98 propertyDescription];
                          }
                        }

                        else
                        {
                          uint64_t v98 = 0LL;
                        }

                        uint64_t v100 = (void *)objc_msgSend(v93, "valueForKey:", objc_msgSend(v98, "name"));
                        if (!v99) {
                          goto LABEL_193;
                        }
                        uint64_t v101 = *(unsigned __int8 *)(v99 + 24);
                        if (v101 == 7)
                        {
                          uint64_t v111 = (void *)[v95 objectAtIndex:v97];
                          __int128 v112 = [(id)v99 destinationEntity];
                          if (*(void *)(v99 + 72))
                          {
                            id v113 = (void *)[v95 objectAtIndex:++v97];
                            if (v205) {
                              BOOL v114 = v205->super._sqlCore;
                            }
                            else {
                              BOOL v114 = 0LL;
                            }
                            __int128 v112 = -[NSSQLModel entityForID:]( -[NSSQLCore model](v114, "model"),  "entityForID:",  [v113 longValue]);
                          }

                          uint64_t v115 = v112;
                          unsigned int v116 = [v111 longLongValue];
                          if (v205) {
                            int v117 = -[NSSQLCore newObjectIDForEntity:pk:]( v205->super._sqlCore,  "newObjectIDForEntity:pk:",  v115,  v116);
                          }
                          else {
                            int v117 = 0LL;
                          }
                          __int128 v102 = v117;
                          uint64_t v100 = (void *)[v100 objectID];
                        }

                        else
                        {
                          if (v101 == 1)
                          {
                            __int128 v102 = (id)[v95 objectAtIndex:v97];
                            goto LABEL_203;
                          }

LABEL_219:
  if ((*(_DWORD *)(v3 + 72) & 0x1C) == 0x14) {
    uint64_t v130 = 46LL;
  }
  else {
    uint64_t v130 = 10LL;
  }
  uint64_t v131 = objc_alloc(&OBJC_CLASS____PFArray);
  return (uint64_t)-[_PFArray initWithObjects:count:andFlags:andContext:]( v131,  "initWithObjects:count:andFlags:andContext:",  v146,  v4,  v130,  v141);
}

const void *_PFCMT_GetValue(void *a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  if (([a2 isTemporaryID] & 1) == 0)
  {
    unsigned int v5 = _PFModelMapSlotForEntity(a1[7], (void *)[a2 entity]);
    if ((v5 & 0x80000000) != 0)
    {
      uint64_t v7 = a1[3];
      if (!v7) {
        return 0LL;
      }
      uint64_t v4 = *(const __CFDictionary **)(v7 + 8LL * (v5 & 0x7FFFFFFF));
      if (!v4) {
        return 0LL;
      }
    }

    else
    {
      uint64_t v6 = a1[4];
      if (!v6) {
        return 0LL;
      }
      uint64_t v4 = *(const __CFDictionary **)(v6 + 8LL * v5);
      if (!v4) {
        return 0LL;
      }
    }

    return CFDictionaryGetValue(v4, a2);
  }

  uint64_t v4 = (const __CFDictionary *)a1[2];
  if (v4) {
    return CFDictionaryGetValue(v4, a2);
  }
  return 0LL;
}

unint64_t _PFObjectIDFastHash64(unint64_t a1)
{
  unint64_t v1 = a1;
  if ((a1 & 0x8000000000000000LL) == 0)
  {
    Class Class = object_getClass((id)a1);
    IndexedIvars = object_getIndexedIvars(Class);
    if ((IndexedIvars[4] & 2) != 0)
    {
      Class v5 = object_getClass((id)v1);
      if ((*((_BYTE *)object_getIndexedIvars(v5) + 4) & 1) != 0) {
        uint64_t v4 = *(void *)(v1 + 8) >> 16;
      }
      else {
        uint64_t v4 = *(void *)(v1 + 16);
      }
    }

    else
    {
      uint64_t v4 = [*(id *)(v1 + 16) hash];
    }

    return *((unsigned int *)IndexedIvars + 8) ^ (unint64_t)(v4 << 6);
  }

  return v1;
}

unint64_t *_PFFastEntityClass(unint64_t *result)
{
  v41[3] = *MEMORY[0x1895F89C0];
  if (result)
  {
    unint64_t v1 = result;
    uint64_t v2 = result + 7;
    if (atomic_load(result + 7)) {
      return (unint64_t *)atomic_load(v2);
    }
    Class v4 = (Class)objc_opt_class();
    Class v5 = (NSString *)[v1 managedObjectClassName];
    Class v6 = NSClassFromString(v5);
    if (!v6)
    {
      if (([@"NSManagedObject" isEqualToString:v5] & 1) == 0) {
        PFUseToolchainBehaviors();
      }
LABEL_12:
      if ((-[objc_class _isGeneratedClass](v4, "_isGeneratedClass") & 1) != 0)
      {
        int v10 = 0LL;
      }

      else
      {
        int v10 = (objc_class *)-[objc_class classForEntity:](v4, "classForEntity:", v1);
        Class v4 = v10;
      }

      while (!__ldaxr(v2))
      {
      }

      __clrex();
      unint64_t v12 = atomic_load(v2);
      if (v10 != (objc_class *)v12) {
        -[objc_class _entityDeallocated](v10, "_entityDeallocated");
      }
      return (unint64_t *)atomic_load(v2);
    }

    uint64_t v7 = v6;
    if (v6 == v4 || (-[objc_class isSubclassOfClass:](v6, "isSubclassOfClass:", v4) & 1) != 0)
    {
      if (!(_BYTE)z9dsptsiQ80etb9782fsrs98bfdle88)
      {
LABEL_9:
        Class v4 = v7;
        goto LABEL_12;
      }

      uint64_t v8 = -[objc_class instanceMethodForSelector:](v7, "instanceMethodForSelector:", sel_isEqual_);
      if (v8 == +[NSManagedObject instanceMethodForSelector:]( &OBJC_CLASS___NSManagedObject,  "instanceMethodForSelector:",  sel_isEqual_))
      {
        uint64_t v9 = -[objc_class instanceMethodForSelector:](v7, "instanceMethodForSelector:", sel_hash);
        if (v9 == +[NSManagedObject instanceMethodForSelector:]( &OBJC_CLASS___NSManagedObject,  "instanceMethodForSelector:",  sel_hash)) {
          goto LABEL_9;
        }
        uint64_t v33 = (void *)MEMORY[0x189603F70];
        uint64_t v34 = *MEMORY[0x189603A58];
        uint64_t v35 = [NSString stringWithFormat:@"Class '%s' for entity '%@' has an illegal override of NSManagedObject -hash", class_getName(v7), objc_msgSend(v1, "name")];
      }

      else
      {
        uint64_t v33 = (void *)MEMORY[0x189603F70];
        uint64_t v34 = *MEMORY[0x189603A58];
        uint64_t v35 = [NSString stringWithFormat:@"Class '%s' for entity '%@' has an illegal override of NSManagedObject -isEqual:", class_getName(v7), objc_msgSend(v1, "name")];
      }

      uint64_t v29 = v35;
      unsigned int v30 = v33;
      uint64_t v31 = v34;
      uint64_t v32 = 0LL;
    }

    else
    {
      uint64_t v13 = [v1 name];
      if (v13) {
        uint64_t v14 = (const __CFString *)v13;
      }
      else {
        uint64_t v14 = @"<nil entity>";
      }
      ImageName = class_getImageName(v7);
      if (ImageName) {
        int v16 = ImageName;
      }
      else {
        int v16 = "<unknown library>";
      }
      Name = class_getName(v7);
      if (Name) {
        int v18 = Name;
      }
      else {
        int v18 = "<unknown class>";
      }
      uint64_t v19 = class_getName(v7);
      BOOL v39 = v16;
      _NSCoreDataLog( 1LL,  (uint64_t)@"Class '%s' for entity '%@' is not a subclass of NSManagedObject.  It was loaded from '%s'",  v20,  v21,  v22,  v23,  v24,  v25,  (uint64_t)v19);
      v41[0] = v14;
      v40[0] = @"entityName";
      v40[1] = @"className";
      v41[1] = [NSString stringWithUTF8String:v18];
      v40[2] = @"sourceLibrary";
      v41[2] = [NSString stringWithUTF8String:v16];
      uint64_t v26 = [MEMORY[0x189603F68] dictionaryWithObjects:v41 forKeys:v40 count:3];
      uint64_t v27 = (void *)MEMORY[0x189603F70];
      uint64_t v28 = *MEMORY[0x189603A58];
      uint64_t v29 = [NSString stringWithFormat:@"%@ is not a subclass of NSManagedObject.", objc_msgSend(v1, "managedObjectClassName"), v14, v39];
      unsigned int v30 = v27;
      uint64_t v31 = v28;
      uint64_t v32 = v26;
    }

    objc_exception_throw((id)[v30 exceptionWithName:v31 reason:v29 userInfo:v32]);
    return (unint64_t *)+[NSManagedObject allocWithEntity:](v36, v37, v38);
  }

  return result;
}

uint64_t __generateReturnPointerMethod_block_invoke(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t __generateReturnPointerMethod_block_invoke_0(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

unint64_t _PFfastOidRetain(int a1, unint64_t a2)
{
  if ((a2 & 0x8000000000000000LL) == 0)
  {
    Class Class = object_getClass((id)a2);
    if ((*((_BYTE *)object_getIndexedIvars(Class) + 4) & 1) != 0)
    {
      uint64_t v7 = (unint64_t *)(a2 + 8);
LABEL_7:
      while (1)
      {
        unint64_t v8 = *v7;
        if ((*v7 & 0x8000) != 0) {
          break;
        }
        while (1)
        {
          unint64_t v9 = __ldaxr(v7);
          if (v9 != v8) {
            break;
          }
          if (!__stlxr(v8 + 1, v7)) {
            return a2;
          }
        }

        __clrex();
      }

      os_unfair_lock_lock_with_options();
      do
      {
        unint64_t v10 = __ldxr(v7);
        if (v10 != v8)
        {
          __clrex();
          os_unfair_lock_unlock((os_unfair_lock_t)&_extraRetainsLock);
          goto LABEL_7;
        }
      }

      while (__stxr(v8 | 0x8000, v7));
      NSIncrementExtraRefCount((id)a2);
      os_unfair_lock_unlock((os_unfair_lock_t)&_extraRetainsLock);
    }

    else
    {
      Class v4 = (unsigned int *)(a2 + 8);
      do
        unsigned int v5 = __ldxr(v4);
      while (__stxr(v5 + 1, v4));
    }
  }

  return a2;
}

LABEL_15:
  v18.receiver = v4;
  v18.super_class = (Class)&OBJC_CLASS___NSManagedObject;
  Class v4 = -[NSManagedObject init](&v18, sel_init);
  if (v4)
  {
    v4->_cd_objectID = (NSManagedObjectID *)_PFFastTemporaryIDCreation(v5);
    v4->_cd_stateFlags |= 0x8400u;
    if (context) {
      -[NSManagedObjectContext insertObject:](context, "insertObject:", v4);
    }
    else {
      _PFFaultHandlerFulfillFault(0LL, (uint64_t)v4, 0LL, 0LL, 1);
    }
  }

  return v4;
}

  unint64_t v8 = 0LL;
LABEL_16:
}

  v31.receiver = self;
  v31.super_class = (Class)&OBJC_CLASS___PFCloudKitCKQueryBackedImportWorkItem;
  if (!-[PFCloudKitImportRecordsWorkItem commitMetadataChangesWithContext:forStore:error:]( &v31,  sel_commitMetadataChangesWithContext_forStore_error_,  a3,  a4,  &v36))
  {
LABEL_17:
    if (v36)
    {
      if (a5)
      {
        LOBYTE(v21) = 0;
        *a5 = v36;
        return v21;
      }
    }

    else
    {
      uint64_t v22 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitCKQueryBackedImportWorkItem.m");
      uint64_t v29 = (os_log_s *)__pflogFaultLog;
      uint64_t v21 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
      if (!v21) {
        return v21;
      }
      *(_DWORD *)buf = 136315394;
      id v38 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitCKQueryBackedImportWorkItem.m";
      BOOL v39 = 1024;
      int v40 = 355;
      _os_log_fault_impl( &dword_186681000,  v29,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    }

    LOBYTE(v21) = 0;
    return v21;
  }

  LOBYTE(v21) = 1;
  return v21;
}

      unint64_t v12 = (id)_NSGetUsingKeyValueGetter();
LABEL_16:
      uint64_t v13 = v12;
      if (v5) {
        CFRelease(v5);
      }
      if (v13) {
        return [v13 isFault];
      }
      else {
        return 0;
      }
    }
  }

  else if ((self->_cd_stateFlags & 0x8000) == 0)
  {
    object_getClass(self);
    _NSKeyValuePrimitiveGetterForClassAndKey();
    goto LABEL_15;
  }

  if (v5) {
    CFRelease(v5);
  }
  return 1;
}

      unint64_t v8 = 0LL;
      unint64_t v9 = 0;
      unint64_t v10 = self;
      do
      {
        unsigned int v11 = v10 == (NSManagedObjectContext *)v3;
        if (v10 == (NSManagedObjectContext *)v3) {
          unint64_t v9 = 1;
        }
        if (v10 == v8) {
          unsigned int v11 = 1;
        }
        if (v11) {
          break;
        }
        if (!v8) {
          unint64_t v8 = v10;
        }
        unint64_t v10 = (NSManagedObjectContext *)atomic_load((unint64_t *)&v10->_queueOwner);
      }

      while (v10);
      if (v9) {
        uint64_t v3 = v11;
      }
      else {
        uint64_t v3 = 0LL;
      }
    }

  int v17 = v10;
  int v18 = [v10 count];
  uint64_t v19 = [v7 count];
  uint64_t v20 = 0LL;
  if (v18 && !v19)
  {
    if (v18 == 1) {
      uint64_t v21 = (NSManagedObjectModel *)[v10 objectAtIndex:0];
    }
    else {
      uint64_t v21 = +[NSManagedObjectModel modelByMergingModels:]( &OBJC_CLASS___NSManagedObjectModel,  "modelByMergingModels:",  v10);
    }
    uint64_t v20 = v21;
  }

  [v6 drain];
  return v20;
}

    objc_autoreleasePoolPop(v8);
    objc_sync_exit(self);
    return;
  }

  if ((*(_BYTE *)&managedObjectModelFlags & 1) == 0)
  {
    uint64_t v15 = *(_DWORD *)&managedObjectModelFlags & 0xFFFFFFFE | !v5;
    if (a4) {
      v15 |= 4u;
    }
    self->_managedObjectModelFlags = (__managedObjectModelFlags)v15;
    -[NSManagedObjectModel _traverseTombstonesAndMark:]((uint64_t)self, 1LL);
    -[NSManagedObjectModel _createCachesAndOptimizeState](self, "_createCachesAndOptimizeState");
    goto LABEL_15;
  }

  objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58] reason:@"Models cannot become mutable after being marked immutable." userInfo:0]);
  __break(1u);
}

    if (a6)
    {
      int v16 = 0LL;
      *a6 = v20;
      goto LABEL_8;
    }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

    *(void *)(a1 + 304) = 0LL;
    *(_DWORD *)(a1 + 312) &= ~2u;
    *(void *)(a1 + 72) = 0LL;
    *(void *)(a1 + 80) = 0LL;

    *(void *)(a1 + 24) = 0LL;
    *(void *)(a1 + 32) = 0LL;
    +[NSPersistentStoreCoordinator _endPowerAssertionWithAssert:andApp:]( (uint64_t)&OBJC_CLASS___NSPersistentStoreCoordinator,  v36,  v3);
  }
}

      ++v9;
    }

    while (v6 != v9);
    uint64_t v14 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
    Class v6 = v14;
  }

  while (v14);
  return v7;
}

    LOBYTE(v9) = 0;
    return (char)v9;
  }

  source = self->_source;
  if (source) {
    unint64_t v8 = _insertion_fault_handler;
  }
  else {
    unint64_t v8 = 0LL;
  }
  unint64_t v9 = (void *)-[NSFaultHandler retainedOrderedFaultInformationForAggregateFaultForObject:andRelationship:withContext:error:]( v8,  source,  -[_NSFaultingMutableOrderedSet relationship](self, "relationship"),  (uint64_t)-[NSManagedObject managedObjectContext](self->_source, "managedObjectContext"),  a4);
  if (!v9) {
    return (char)v9;
  }
  unint64_t v10 = v9;
  if ([v9 count] != 2)
  {

    if (a4)
    {
      uint64_t v22 = (void *)MEMORY[0x189607870];
      uint64_t v23 = *MEMORY[0x189607460];
      id v47 = @"message";
      v48[0] = [NSString stringWithFormat:@"failed to retrieve ordering information from fault for object %@ and relationship %@", -[NSManagedObject objectID](self->_source, "objectID"), -[NSPropertyDescription name]( -[_NSFaultingMutableOrderedSet relationship](self, "relationship"), "name")];
      uint64_t v19 = [MEMORY[0x189603F68] dictionaryWithObjects:v48 forKeys:&v47 count:1];
      uint64_t v20 = v22;
      uint64_t v21 = v23;
      goto LABEL_14;
    }

    goto LABEL_15;
  }

  unsigned int v11 = (id)objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 0), "mutableCopy");
  unint64_t v12 = (id)objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 1), "mutableCopy");
  uint64_t v13 = [v11 count];
  if (v13)
  {
    uint64_t v14 = v13;
    uint64_t v46 = 48LL;
    flags = (char)self->_flags;
    uint64_t v44 = v10;
    if ((flags & 1) != 0)
    {
      int v16 = 0LL;
    }

    else
    {
      int v16 = self->_realSet;
      -[_NSFaultingMutableOrderedSet turnIntoFault](self, "turnIntoFault");
    }

    uint64_t v25 = -[NSManagedObject managedObjectContext](self->_source, "managedObjectContext");
    v43[1] = v43;
    MEMORY[0x1895F8858](v25);
    uint64_t v27 = (char *)v43 - v26;
    if (v14 > 0x200) {
      uint64_t v27 = (char *)NSAllocateScannedUncollectable();
    }
    else {
      bzero((char *)v43 - v26, 8 * v14);
    }
    objc_msgSend(v11, "getObjects:range:", v27, 0, v14);
    for (uint64_t i = 0LL; i != v14; ++i)
      *(void *)&v27[8 * i] = -[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( v25,  *(void **)&v27[8 * i],  0LL);
    uint64_t v29 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:v27 count:v14];
    -[_NSFaultingMutableOrderedSet willReadWithContents:](self, "willReadWithContents:", v29);

    for (uint64_t j = 0LL; j != v14; ++j)
    if (v14 >= 0x201) {
      NSZoneFree(0LL, v27);
    }
    if (v16) {

    }
    uint64_t v31 = (objc_class *)[objc_alloc(MEMORY[0x189603FC8]) initWithCapacity:v14];
    (&self->super.super.super.isa)[v46 / 8] = v31;
    uint64_t v32 = [a3 count];
    uint64_t v33 = (void *)[objc_alloc(MEMORY[0x189603FD0]) initWithArray:v11 copyItems:0];
    uint64_t v45 = -[NSManagedObject mutableOrderedSetValueForKey:]( self->_source,  "mutableOrderedSetValueForKey:",  -[NSPropertyDescription name](-[_NSFaultingMutableOrderedSet relationship](self, "relationship"), "name"));
    if (v32)
    {
      uint64_t v34 = 0LL;
      do
      {
        uint64_t v35 = [a3 objectAtIndex:v34];
        id v36 = v34 + 1;
        SEL v37 = [a3 objectAtIndex:v34 + 1];
        id v38 = [v33 indexOfObject:v35];
        if (v38 != 0x7FFFFFFFFFFFFFFFLL)
        {
          BOOL v39 = v38;
          if ((objc_msgSend((id)objc_msgSend(v12, "objectAtIndex:", v38), "isEqual:", v37) & 1) == 0)
          {
            [v12 removeObjectAtIndex:v39];
            [v33 removeObjectAtIndex:v39];
            int v40 = objc_msgSend( v12,  "indexOfObject:inSortedRange:options:usingComparator:",  v37,  0,  objc_msgSend(v12, "count"),  1024,  &__block_literal_global_23);
            uint64_t v41 = [MEMORY[0x1896078D0] indexSetWithIndex:v39];
            [v45 moveObjectsAtIndexes:v41 toIndex:v40];
            [v12 insertObject:v37 atIndex:v40];
            [v33 insertObject:v35 atIndex:v40];
            -[objc_class setObject:forKey:]((&self->super.super.super.isa)[v46 / 8], "setObject:forKey:", v37, v35);
          }
        }

        uint64_t v34 = v36 + 1;
      }

      while (v36 + 1 < v32);
    }

    LOBYTE(v9) = 1;
  }

  else
  {

    LOBYTE(v9) = 1;
  }

  return (char)v9;
}

  unsigned int v11 = [NSString stringWithUTF8String:"Failed to get a reset sync reason for error even though we're posting a notification for it: %@"];
  _NSCoreDataLog(17LL, v11, v12, v13, v14, v15, v16, v17, (uint64_t)a3);
  int v18 = (os_log_s *)__pflogFaultLog;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 138412290;
    uint64_t v22 = a3;
    _os_log_fault_impl( &dword_186681000,  v18,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to get a reset sync reason for error even though we're posting a notification for it: %@",  buf,  0xCu);
  }

        unint64_t v12 = 0LL;
        goto LABEL_16;
      }
    }

    uint64_t v15 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSSQLAttributeExtensionFactory.m");
    uint64_t v22 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSSQLAttributeExtensionFactory.m";
      uint64_t v25 = 1024;
      uint64_t v26 = 48;
      _os_log_fault_impl( &dword_186681000,  v22,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    }

    goto LABEL_15;
  }

  return v2;
}

void _PFCMT_SetValue(uint64_t a1, void *a2, const void *a3)
{
  if (a2)
  {
    if ([a2 isTemporaryID])
    {
      uint64_t v7 = (__CFDictionary **)(a1 + 16);
      Class v6 = *(__CFDictionary **)(a1 + 16);
      if (v6)
      {
LABEL_31:
        CFDictionarySetValue(v6, a2, a3);
        return;
      }

      memset(&keyCallBacks, 0, 24);
      *(_OWORD *)&keyCallBacks.copyDescription = *(_OWORD *)(MEMORY[0x189605240] + 24LL);
      keyCallBacks.hash = *(CFDictionaryHashCallBack *)(MEMORY[0x189605240] + 40LL);
      memset(&v20, 0, sizeof(v20));
      v20.copyDescription = *(CFDictionaryCopyDescriptionCallBack *)(MEMORY[0x189605250] + 24LL);
      int v8 = *(_DWORD *)(a1 + 48) & 3;
      if (v8 != 1)
      {
        *(_OWORD *)&v20.retain = *(_OWORD *)(MEMORY[0x189605250] + 8LL);
        if (v8 == 3) {
          *(_OWORD *)&keyCallBacks.retain = *(_OWORD *)(MEMORY[0x189605240] + 8LL);
        }
      }

      unint64_t *v7 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, &keyCallBacks, &v20);
      _CFDictionarySetCapacity();
    }

    else
    {
      int v9 = _PFModelMapSlotForEntity(*(void *)(a1 + 56), (void *)[a2 entity]);
      LODWORD(v10) = v9;
      if (v9 < 0)
      {
        uint64_t v10 = v9 & 0x7FFFFFFF;
        int v16 = *(void **)(a1 + 24);
        if (!v16)
        {
          int v17 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
          if (!_PF_Private_Malloc_Zone) {
            int v17 = malloc_default_zone();
          }
          int v16 = malloc_zone_calloc(v17, 1uLL, 8LL * *(void *)(a1 + 8));
          *(void *)(a1 + 24) = v16;
        }

        Class v6 = (__CFDictionary *)v16[v10];
        if (v6) {
          goto LABEL_31;
        }
        int v18 = 0LL;
        memset(&keyCallBacks, 0, 24);
        *(_OWORD *)&keyCallBacks.copyDescription = *(_OWORD *)(MEMORY[0x189605240] + 24LL);
        keyCallBacks.hash = *(CFDictionaryHashCallBack *)(MEMORY[0x189605240] + 40LL);
        memset(&v20, 0, sizeof(v20));
        v20.copyDescription = *(CFDictionaryCopyDescriptionCallBack *)(MEMORY[0x189605250] + 24LL);
        int v19 = *(_DWORD *)(a1 + 48) & 3;
        if (v19 != 1)
        {
          *(_OWORD *)&v20.retain = *(_OWORD *)(MEMORY[0x189605250] + 8LL);
          if (v19 == 3) {
            *(_OWORD *)&keyCallBacks.retain = *(_OWORD *)(MEMORY[0x189605240] + 8LL);
          }
          int v18 = &v20;
        }

        *(void *)(*(void *)(a1 + 24) + 8 * v10) = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  &keyCallBacks,  v18);
        _CFDictionarySetCapacity();
        uint64_t v15 = *(void *)(a1 + 24);
      }

      else
      {
        unsigned int v11 = *(void **)(a1 + 32);
        if (!v11)
        {
          unint64_t v12 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
          if (!_PF_Private_Malloc_Zone) {
            unint64_t v12 = malloc_default_zone();
          }
          unsigned int v11 = malloc_zone_calloc(v12, 1uLL, 8LL * *(void *)(a1 + 8));
          *(void *)(a1 + 32) = v11;
        }

        Class v6 = (__CFDictionary *)v11[v10];
        if (v6) {
          goto LABEL_31;
        }
        uint64_t v13 = 0LL;
        uint64_t v10 = v10;
        memset(&keyCallBacks, 0, 24);
        keyCallBacks.copyDescription = *(CFDictionaryCopyDescriptionCallBack *)(MEMORY[0x189605240] + 24LL);
        keyCallBacks.equal = (CFDictionaryEqualCallBack)_PFObjectIDFastEquals64;
        keyCallBacks.hash = (CFDictionaryHashCallBack)_PFObjectIDFastHash64;
        memset(&v20, 0, sizeof(v20));
        v20.copyDescription = *(CFDictionaryCopyDescriptionCallBack *)(MEMORY[0x189605250] + 24LL);
        int v14 = *(_DWORD *)(a1 + 48) & 3;
        if (v14 != 1)
        {
          *(_OWORD *)&v20.retain = *(_OWORD *)(MEMORY[0x189605250] + 8LL);
          if (v14 == 3) {
            *(_OWORD *)&keyCallBacks.retain = *(_OWORD *)(MEMORY[0x189605240] + 8LL);
          }
          uint64_t v13 = &v20;
        }

        *(void *)(*(void *)(a1 + 32) + 8LL * v10) = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  &keyCallBacks,  v13);
        _CFDictionarySetCapacity();
        uint64_t v15 = *(void *)(a1 + 32);
      }

      uint64_t v7 = (__CFDictionary **)(v15 + 8 * v10);
    }

    Class v6 = *v7;
    goto LABEL_31;
  }

void _PFFaultHandlerFulfillPartialFault( int a1, unsigned int *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, void *a7)
{
  uint64_t v108 = *MEMORY[0x1895F89C0];
  unsigned int v7 = a2[4];
  if ((v7 & 0x38000) == 0x8000)
  {
    a2[4] = v7 & 0xFFFC7FFF | 0x18000;
    unint64_t v12 = (void *)*((void *)a2 + 5);
    uint64_t v13 = (unint64_t **)_PFEntityForManagedObject(a2);
    int v14 = v13;
    if (v13) {
      uint64_t v15 = v13[14];
    }
    else {
      uint64_t v15 = 0LL;
    }
    uint64_t v97 = _kvcPropertysPrimitiveSetters((uint64_t)v13);
    int v16 = (void *)*((void *)a2 + 6);
    if (v16 && *v16)
    {
      uint64_t v17 = 0LL;
      char v18 = 1;
      if (a6)
      {
        unsigned int v19 = a2[4];
        if ((v19 & 0x2000) == 0)
        {
          if (a3) {
            ++*(_WORD *)(a3 + 46);
          }
          a2[4] = v19 | 0x1000;
          [a2 _willChangeValuesForKeys:a6];
          char v18 = 0;
          uint64_t v17 = a6;
        }
      }
    }

    else
    {
      uint64_t v17 = 0LL;
      char v18 = 1;
    }

    char v90 = v18;
    uint64_t v89 = v17;
    uint64_t v91 = a3;
    CFDictionaryValueCallBacks v20 = (objc_class *)_PFCDSnapshotClassForEntity((unint64_t)v14);
    uint64_t v21 = (void *)*((void *)a2 + 3);
    if (v21) {

    }
    uint64_t v22 = -[_CDSnapshot initWithObjectID:](objc_alloc(v20), v12);
    snapshot_initialize_all_null(v22);
    *((void *)a2 + 3) = v22;
    uint64_t v23 = a2[5];
    if ((_DWORD)v23) {
      uint64_t v24 = (char *)a2 + v23;
    }
    else {
      uint64_t v24 = 0LL;
    }
    unsigned int v95 = &v24[-(((unint64_t)a2[4] >> 22) & 0x3FC)];
    unint64_t v25 = *v15;
    unint64_t v26 = v15[1] + *v15;
    if (*v15 < v26)
    {
      int v27 = v26 - 1;
      int v28 = (int)v25 >> 3;
      int v29 = v27 >> 3;
      unsigned int v30 = 0xFFu >> (8 - (v25 & 7));
      if (v27 >> 3 == (int)v25 >> 3)
      {
        int v31 = (510 << (v27 & 7)) | v30;
      }

      else
      {
        v95[v28] &= v30;
        if (v28 + 1 < v29) {
          bzero(&v95[v28 + 1], (v29 - v28 - 2) + 1LL);
        }
        int v31 = 510 << (v27 & 7);
        int v28 = v27 >> 3;
      }

      v95[v28] &= v31;
    }

    unint64_t v33 = v15[12];
    unint64_t v32 = v15[13];
    if (v33 < v32 + v33)
    {
      do
      {
        _PF_CopyOnWrite_Snapshot(a2);
        if (*(void *)(v97 + 8 * v33))
        {
          _NSSetUsingKeyValueSetter();
        }

        else
        {
          snapshot_set_value_as_object(*((char **)a2 + 3), v33, (void *)_CD_ScalarNull, v34, v35, v36, v37, v38);
        }

        ++v33;
        --v32;
      }

      while (v32);
    }

    size_t v96 = (char **)a2;
    __int128 v104 = 0u;
    __int128 v105 = 0u;
    __int128 v102 = 0u;
    __int128 v103 = 0u;
    uint64_t v39 = [a5 countByEnumeratingWithState:&v102 objects:v107 count:16];
    if (v39)
    {
      uint64_t v40 = v39;
      uint64_t v41 = *(void *)v103;
      uint64_t v42 = 1LL;
      uint64_t v92 = a4;
      do
      {
        for (uint64_t i = 0LL; i != v40; ++i)
        {
          if (*(void *)v103 != v41) {
            objc_enumerationMutation(a5);
          }
          uint64_t v44 = *(void **)(*((void *)&v102 + 1) + 8 * i);
          uint64_t v45 = [v44 _entitysReferenceID];
          if (v45 < 0)
          {
            ++v42;
          }

          else
          {
            uint64_t v46 = v45;
            uint64_t v47 = [v44 entity];
            if (v14 != (unint64_t **)v47) {
              uint64_t v46 = objc_msgSend( v14,  "_offsetRelationshipIndex:fromSuperEntity:andIsToMany:",  v46,  v47,  objc_msgSend(v44, "_isToManyRelationship"));
            }
            if (a4) {
              uint64_t v48 = *(void **)(a4 + 8 * v42++);
            }
            else {
              uint64_t v48 = 0LL;
            }
            unint64_t v49 = v15[6];
            BOOL v51 = v46 >= v49;
            unint64_t v50 = v46 - v49;
            BOOL v51 = !v51 || v50 >= v15[7];
            if (v51)
            {
              unint64_t v52 = v15[12];
              BOOL v51 = v46 >= v52;
              unint64_t v53 = v46 - v52;
              if (v51 && v53 < v15[13])
              {
                uint64_t v55 = *(void *)(v97 + 8 * v46);
                _PF_CopyOnWrite_Snapshot(v96);
                if (v55)
                {
                  _NSSetUsingKeyValueSetter();
                }

                else
                {
                  id v63 = v48;
                  snapshot_set_value_as_object(v96[3], v46, v63, v64, v65, v66, v67, v68);
                }

                a4 = v92;
                if (!v48) {
                  v95[v46 >> 3] |= 1 << (v46 & 7);
                }
              }
            }

            else
            {
              uint64_t v56 = *(void *)(v97 + 8 * v46);
              _PF_CopyOnWrite_Snapshot(v96);
              if (v56)
              {
                _NSSetUsingKeyValueSetter();
              }

              else
              {
                id v57 = v48;
                snapshot_set_value_as_object(v96[3], v46, v57, v58, v59, v60, v61, v62);
              }

              v95[v46 >> 3] |= 1 << (v46 & 7);
              a4 = v92;
            }
          }
        }

        uint64_t v40 = [a5 countByEnumeratingWithState:&v102 objects:v107 count:16];
      }

      while (v40);
    }

    __int128 v100 = 0u;
    __int128 v101 = 0u;
    __int128 v98 = 0u;
    __int128 v99 = 0u;
    uint64_t v69 = [a7 countByEnumeratingWithState:&v98 objects:v106 count:16];
    if (v69)
    {
      uint64_t v70 = v69;
      uint64_t v71 = *(void *)v99;
      do
      {
        for (uint64_t j = 0LL; j != v70; ++j)
        {
          if (*(void *)v99 != v71) {
            objc_enumerationMutation(a7);
          }
          uint64_t v73 = *(void **)(*((void *)&v98 + 1) + 8 * j);
          uint64_t v74 = [v73 _entitysReferenceID];
          if ((v74 & 0x8000000000000000LL) == 0)
          {
            uint64_t v75 = v74;
            uint64_t v76 = [v73 entity];
            if (v14 != (unint64_t **)v76) {
              uint64_t v75 = objc_msgSend( v14,  "_offsetRelationshipIndex:fromSuperEntity:andIsToMany:",  v75,  v76,  objc_msgSend(v73, "_isToManyRelationship"));
            }
            unint64_t v77 = v15[10];
            BOOL v51 = v75 >= v77;
            unint64_t v78 = v75 - v77;
            if (v51 && v78 < v15[11])
            {
              if ([v73 _propertyType] == 7) {
                uint64_t v80 = [v73 _buildDefaultValue];
              }
              else {
                uint64_t v80 = [v73 defaultValue];
              }
              size_t v81 = (void *)v80;
              uint64_t v82 = *(void *)(v97 + 8 * v75);
              _PF_CopyOnWrite_Snapshot(v96);
              if (v82)
              {
                _NSSetUsingKeyValueSetter();
              }

              else
              {
                id v83 = v81;
                snapshot_set_value_as_object(v96[3], v75, v83, v84, v85, v86, v87, v88);
              }

              v95[v75 >> 3] |= 1 << (v75 & 7);
            }
          }
        }

        uint64_t v70 = [a7 countByEnumeratingWithState:&v98 objects:v106 count:16];
      }

      while (v70);
    }

    *((_DWORD *)v96 + 4) = (_DWORD)v96[2] & 0xFFFC7FFF | 0x28000;
    if ((v90 & 1) == 0)
    {
      [v96 _didChangeValuesForKeys:v89];
      *((_DWORD *)v96 + 4) &= ~0x1000u;
      if (v91) {
        --*(_WORD *)(v91 + 46);
      }
    }
  }

id _PFEntityForManagedObject(id result)
{
  if (result)
  {
    unint64_t v1 = result;
    uint64_t v2 = (void *)*((void *)result + 5);
    if (!v2 || (uint64_t result = (id)[v2 entity]) == 0)
    {
      Class Class = object_getClass(v1);
      return _PFEntityForClass(Class);
    }
  }

  return result;
}

uint64_t _kvcPropertysPrimitiveSetters(uint64_t a1)
{
  if (**(void **)(a1 + 152)) {
    return **(void **)(a1 + 152);
  }
  else {
    return _resolveForSelectorAndType( (unint64_t *)a1,  sel__createValuePrimitiveSetterWithContainerClassID_key_,  (objc_class *)_MergedGlobals_68,  0);
  }
}

unint64_t _PFCDSnapshotClassForEntity(unint64_t result)
{
  if (result)
  {
    unint64_t v1 = (unint64_t *)(result + 16);
    if (!atomic_load((unint64_t *)(result + 16)))
    {
      uint64_t v3 = +[_CDSnapshot classForEntity:](&OBJC_CLASS____CDSnapshot, "classForEntity:", result);
      while (!__ldaxr(v1))
      {
      }

      __clrex();
      unint64_t v5 = atomic_load(v1);
      if (v3 != (objc_class *)v5) {
        -[objc_class _entityDeallocated](v3, "_entityDeallocated");
      }
    }

    return atomic_load(v1);
  }

  return result;
}

_DWORD *snapshot_initialize_all_null(_BYTE *a1)
{
  Class Class = object_getClass(a1);
  uint64_t result = object_getIndexedIvars(Class);
  int v4 = result[16];
  unsigned int v5 = v4 - 1;
  if (v4 >= 1)
  {
    Class v6 = a1 + 28;
    if (v4 >= 9)
    {
      unsigned int v7 = v5 >> 3;
      *Class v6 = -1;
      if (v5 >= 0x10)
      {
        if (v7 <= 2) {
          int v8 = 2;
        }
        else {
          int v8 = v5 >> 3;
        }
        uint64_t result = memset(a1 + 29, 255, (v8 - 1));
      }

      LOBYTE(v5) = v5 & 7;
      v6 += v7;
    }

    *v6 |= 0xFFu >> (v5 ^ 7);
  }

  return result;
}

void _PF_CopyOnWrite_Snapshot(id a1)
{
  uint64_t v2 = (_BYTE *)*((void *)a1 + 3);
  if (v2)
  {
    if ((v2[24] & 1) != 0)
    {
      id v13 = v2;
      *((void *)a1 + 3) = [v2 mutableCopy];
    }
  }

  else
  {
    id v3 = _PFEntityForManagedObject(a1);
    int v4 = (objc_class *)_PFCDSnapshotClassForEntity((unint64_t)v3);
    if (v4)
    {
      unsigned int v11 = -[_CDSnapshot initWithObjectID:](objc_alloc(v4), *((void **)a1 + 5));
      snapshot_initialize_all_null(v11);
      *((_DWORD *)v11 + 3) = *((_DWORD *)a1 + 3);
      *((void *)a1 + 3) = v11;
    }

    else
    {
      _NSCoreDataLog(1LL, (uint64_t)@"Snapshot class was nil", v5, v6, v7, v8, v9, v10, v12);
      __break(1u);
    }
  }

void snapshot_set_value_as_object( char *a1, unsigned int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    Class Class = object_getClass(a1);
    IndexedIvars = object_getIndexedIvars(Class);
    uint64_t v12 = &a1[(unint64_t)a2 >> 3];
    int v13 = 1 << (a2 & 7);
    char v14 = v12[28];
    char v15 = v14 & ~(_BYTE)v13;
    char v16 = v14 | v13;
    uint64_t v17 = a3;
    if (a3) {
      char v16 = v15;
    }
    v12[28] = v16;
    uint64_t v18 = *((unsigned int *)IndexedIvars + a2 + 19);
    int v19 = *(char *)(IndexedIvars[7] + a2);
    switch(*(_BYTE *)(IndexedIvars[7] + a2))
    {
      case 'c':
        char v20 = [a3 charValue];
        uint64_t v17 = a3;
        a1[v18] = v20;
        if (a3) {
          goto LABEL_29;
        }
        return;
      case 'd':
        if (a3)
        {
          else {
            [a3 timeIntervalSinceReferenceDate];
          }
          uint64_t v17 = a3;
        }

        else
        {
          uint64_t v23 = 0LL;
        }

        *(void *)&a1[v18] = v23;
        if (v17) {
          goto LABEL_29;
        }
        return;
      case 'e':
      case 'g':
      case 'h':
        goto LABEL_11;
      case 'f':
        if (a3)
        {
          [a3 floatValue];
          uint64_t v17 = a3;
        }

        else
        {
          int v24 = 0;
        }

        *(_DWORD *)&a1[v18] = v24;
        if (!v17) {
          return;
        }
        goto LABEL_29;
      case 'i':
        int v25 = [a3 intValue];
        uint64_t v17 = a3;
        *(_DWORD *)&a1[v18] = v25;
        if (!a3) {
          return;
        }
        goto LABEL_29;
      default:
        if (v19 == 113)
        {
          uint64_t v26 = [a3 longLongValue];
          uint64_t v17 = a3;
          *(void *)&a1[v18] = v26;
          if (!a3) {
            return;
          }
        }

        else if (v19 == 115)
        {
          __int16 v21 = [a3 shortValue];
          uint64_t v17 = a3;
          *(_WORD *)&a1[v18] = v21;
          if (!a3) {
            return;
          }
        }

        else
        {
LABEL_11:
          uint64_t v22 = *(void **)&a1[v18];
          *(void *)&a1[v18] = a3;
          uint64_t v17 = v22;
          if (!v22) {
            return;
          }
        }

void _deallocateFetchEntityPlan(CFTypeRef *ptr)
{
  if (ptr)
  {
    uint64_t v2 = *((unsigned int *)ptr + 1);
    if ((_DWORD)v2)
    {
      id v3 = ptr + 3;
      do
      {
        if (*v3) {
          CFRelease(*v3);
        }
        v3 += 3;
        --v2;
      }

      while (v2);
    }

    int v4 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      int v4 = malloc_default_zone();
    }
    malloc_zone_free(v4, ptr);
  }

void _PFDeallocateObject(id obj)
{
  if (*MEMORY[0x1896077C8])
  {
    _PFPerformDebugZombie(obj);
  }

  else
  {
    if (obj) {
      objc_destructInstance(obj);
    }
    uint64_t v2 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v2 = malloc_default_zone();
    }
    malloc_zone_free(v2, obj);
  }

CFAllocatorRef _PFStackAllocatorCreate(unint64_t *a1, uint64_t a2)
{
  unint64_t v3 = ((unint64_t)a1 + 47) & 0xFFFFFFFFFFFFFFF0LL;
  *a1 = v3;
  a1[1] = v3;
  a1[2] = (unint64_t)a1 + a2;
  a1[3] = 0LL;
  context.version = 0LL;
  context.info = a1;
  memset(&context.retain, 0, 24);
  context.allocate = (CFAllocatorAllocateCallBack)stack_allocate;
  context.reallocate = (CFAllocatorReallocateCallBack)stack_reallocate;
  context.deallocate = (CFAllocatorDeallocateCallBack)stack_deallocate;
  context.preferredSize = (CFAllocatorPreferredSizeCallBack)preferredSize;
  CFAllocatorRef result = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x189604DD8], &context);
  unint64_t v5 = (a1[1] + 15) & 0xFFFFFFFFFFFFFFF0LL;
  *a1 = v5;
  a1[1] = v5;
  return result;
}

void *stack_allocate(size_t size, uint64_t a2, void *a3)
{
  if (size - 1 > 0x7FFFFE
    || (result = (void *)a3[1], size_t v6 = ((unint64_t)result + size + 15) & 0xFFFFFFFFFFFFFFF0LL, v6 >= a3[2]))
  {
    uint64_t v7 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v7 = malloc_default_zone();
    }
    CFAllocatorRef result = malloc_zone_malloc(v7, size);
    if (result) {
      ++a3[3];
    }
  }

  else
  {
    a3[1] = v6;
  }

  return result;
}

uint64_t __generateAccessor_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void))(a1 + 32))(a2, 0LL, *(void *)(a1 + 40));
}

void _sharedIMPL_pvfk_core( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
}

uint64_t _pvfk_header( unsigned int *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!_PF_Threading_Debugging_level)
  {
    if (a1) {
      goto LABEL_3;
    }
LABEL_6:
    unsigned int v10 = MEMORY[0x10];
    goto LABEL_7;
  }

  _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_primitiveValueForKey_);
  if (!a1) {
    goto LABEL_6;
  }
LABEL_3:
  unsigned int v10 = a1[4];
  if ((v10 & 0x4000) != 0)
  {
    uint64_t v11 = a1;
    unsigned int v10 = a1[4] & 0xFFFFBFFF;
    a1[4] = v10;
  }

LABEL_7:
  uint64_t v12 = a1[5];
  if ((_DWORD)v12) {
    uint64_t v13 = (char *)a1 + v12;
  }
  else {
    uint64_t v13 = 0LL;
  }
  if (*((void *)a1 + 3)) {
    return 1LL;
  }
  uint64_t result = 0LL;
  unsigned int v15 = a1[4];
  if ((v15 & 0x38000) != 0x10000 && (v15 & 0x80) == 0)
  {
    _NSCoreDataLog( 1LL,  (uint64_t)@"NULL _cd_rawData but the object is not being turned into a fault",  a3,  a4,  a5,  a6,  a7,  a8,  v16);
    return 0LL;
  }

  return result;
}

  v29[0] = MEMORY[0x1895F87A8];
  v29[1] = 3221225472LL;
  v29[2] = __110__NSPersistentStoreCoordinator__NSInternalMethods__newValueForRelationship_forObjectWithID_withContext_error___block_invoke;
  v29[3] = &unk_189EA8EA0;
  v29[4] = self;
  v29[5] = a5;
  v29[6] = a3;
  v29[7] = a4;
  v29[8] = &v37;
  v29[9] = &v31;
  -[NSPersistentStoreCoordinator _routeLightweightBlock:toStore:]((unint64_t)self, (uint64_t)v29, v11);
  uint64_t v14 = (id)v32[5];
  if (a6)
  {
    unsigned int v15 = (void *)v32[5];
    if (v15) {
      *a6 = v15;
    }
  }

  uint64_t v16 = (void *)v38[5];
LABEL_11:
  _Block_object_dispose(&v31, 8);
  _Block_object_dispose(&v37, 8);
  return v16;
}

  v27[0] = MEMORY[0x1895F87A8];
  v27[1] = 3221225472LL;
  v27[2] = __95__NSPersistentStoreCoordinator__NSInternalMethods__newValuesForObjectWithID_withContext_error___block_invoke;
  v27[3] = &unk_189EA8E78;
  v27[4] = self;
  v27[5] = a4;
  v27[6] = a3;
  v27[7] = &v35;
  v27[8] = &v29;
  -[NSPersistentStoreCoordinator _routeLightweightBlock:toStore:]((unint64_t)self, (uint64_t)v27, v9);
  uint64_t v12 = (id)v30[5];
  if (a5)
  {
    uint64_t v13 = (void *)v30[5];
    if (v13) {
      *a5 = v13;
    }
  }

  uint64_t v14 = (void *)v36[5];
LABEL_11:
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v35, 8);
  return v14;
}

  int v25 = v38;
  objc_autoreleasePoolPop(v10);
  if (v38)
  {
    uint64_t v26 = v38;
    if (v26)
    {
      if (a5) {
        *a5 = v26;
      }
    }

    else
    {
      uint64_t v27 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSCKRecordMetadata.m");
      uint64_t v34 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        uint64_t v40 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSCKRecordMetadata.m";
        uint64_t v41 = 1024;
        LODWORD(v42) = 295;
        _os_log_fault_impl( &dword_186681000,  v34,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }
  }

  return v14;
}

    uint64_t v12 = v13;
    goto LABEL_8;
  }

  uint64_t v11 = v10;
  uint64_t v12 = open(v10, 0);
  if (v12 < 0)
  {
    uint64_t v11 = (const char *)[a2 _externalReferenceLocation];
    uint64_t v13 = open(v11, 0);
    if (v13 < 0)
    {
      uint64_t v14 = __error();
      unsigned int v15 = (void *)MEMORY[0x189603F70];
      uint64_t v16 = *MEMORY[0x189603A60];
      uint64_t v17 = objc_msgSend( NSString,  "stringWithFormat:",  @"Unable to open file with path: %s (%d)",  v11,  *v14);
      uint64_t v35 = @"com.apple.coredata.ubiquity.eat";
      uint64_t v36 = MEMORY[0x189604A88];
      uint64_t v18 = (void *)MEMORY[0x189603F68];
      int v19 = &v36;
      char v20 = &v35;
LABEL_14:
      int v25 = [v18 dictionaryWithObjects:v19 forKeys:v20 count:1];
      uint64_t v26 = v15;
      uint64_t v27 = v16;
      goto LABEL_15;
    }

    goto LABEL_7;
  }

  uint64_t v13 = *((unsigned int *)a1 + 5);
  if ((_DWORD)v13) {
    uint64_t v14 = (char *)a1 + v13;
  }
  else {
    uint64_t v14 = 0LL;
  }
  unsigned int v15 = a1[3];
  if (v15)
  {
    if (a4) {
      _NSGetUsingKeyValueGetter();
    }
    else {
      snapshot_get_value_as_object(v15, a2, a3, a4, a5, a6, a7, a8);
    }
  }

  else
  {
    uint64_t v16 = *((_DWORD *)a1 + 4);
    if ((v16 & 0x38000) != 0x10000 && (v16 & 0x80) == 0) {
      _NSCoreDataLog( 1LL,  (uint64_t)@"NULL _cd_rawData but the object is not being turned into a fault",  a3,  a4,  a5,  a6,  a7,  a8,  v17);
    }
  }

  size_t v6 = *((unsigned int *)v4 + 5);
  if ((_DWORD)v6) {
    uint64_t v7 = (char *)v4 + v6;
  }
  else {
    uint64_t v7 = 0LL;
  }
  return result;
}

  if ((*(_BYTE *)(a1 + 43) & 0x20) != 0)
  {
    uint64_t v9 = [a2 objectForKey:@"transactionAuthor"];
    if (v9)
    {
      unsigned int v10 = v9;
      uint64_t v11 = v4;
LABEL_12:
      [v11 setObject:v10 forKey:@"transactionAuthor"];
      goto LABEL_13;
    }

    uint64_t v12 = [(id)a1 transactionAuthor];
    if (v12)
    {
      uint64_t v13 = v12;
      [v4 setObject:v12 forKey:@"transactionAuthor"];
      uint64_t v11 = a2;
      unsigned int v10 = v13;
      goto LABEL_12;
    }
  }

  if ([v7 count])
  {
    [v7 sortUsingSelector:sel_compare_];
    uint64_t v12 = objc_alloc(MEMORY[0x189607940]);
    uint64_t v13 = (objc_class *)objc_opt_class();
    uint64_t v14 = (void *)[v12 initWithFormat:@"Invalid '%@'. The following validation failures occured:", NSStringFromClass(v13)];
    [v14 appendFormat:@"\n%@", objc_msgSend(v7, "componentsJoinedByString:", @"\n")];
    unsigned int v15 = *MEMORY[0x189607460];
    uint64_t v34 = *MEMORY[0x1896075F0];
    v35[0] = v14;
    int v29 = (void *)objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v15,  134070,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", v35, &v34, 1));
  }

  else if (v8)
  {

    self->_entityNameToAttributesToFetch = (NSDictionary *)[v8 copy];
    self->_editable = 0;
    LOBYTE(v16) = 1;
    return v16;
  }

LABEL_10:
  if (!v29)
  {
    uint64_t v17 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringFetchRecordsRequest.m");
    int v24 = (os_log_s *)__pflogFaultLog;
    uint64_t v16 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!v16) {
      return v16;
    }
    *(_DWORD *)buf = 136315394;
    int v31 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringFetchRecordsRequest.m";
    unint64_t v32 = 1024;
    unint64_t v33 = 195;
    _os_log_fault_impl( &dword_186681000,  v24,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
LABEL_15:
    LOBYTE(v16) = 0;
    return v16;
  }

  if (!a4) {
    goto LABEL_15;
  }
  LOBYTE(v16) = 0;
  *a4 = v29;
  return v16;
}

      if (a2 && v8 != -1) {
        notify_set_state(v8, [a2 unsignedLongLongValue]);
      }
      if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1) {
        _NSCoreDataLog( 9LL,  (uint64_t)@"Remote Change Notification - Posting for %@",  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)v5);
      }
      notify_post(v7);
    }

  uint64_t v9 = -[NSSQLToOne foreignKey](v3, "foreignKey");
  objc_msgSend(*(id *)(a1 + 40), "setObject:forKey:", v9, objc_msgSend(v9, "name"));
  if (!v7) {
    _PF_Leopard_CFDictionarySetValue(*(void **)(a1 + 248), (__CFString *)[v9 name], v9);
  }
  if (v8)
  {
    -[NSSQLEntity _addColumnToFetch:]((void *)a1, v9);
  }

  else
  {
    unsigned int v10 = *(void **)(a1 + 96);
    if (!v10)
    {
      unsigned int v10 = (void *)objc_opt_new();
      *(void *)(a1 + 96) = v10;
    }

    [v10 addObject:v9];
  }

  if (v3)
  {
    foreignEntityKey = v3->_foreignEntityKey;
    if (foreignEntityKey)
    {
      objc_msgSend( *(id *)(a1 + 40),  "setObject:forKey:",  foreignEntityKey,  -[NSSQLForeignEntityKey name](v3->_foreignEntityKey, "name"));
      if (!v7) {
        _PF_Leopard_CFDictionarySetValue( *(void **)(a1 + 248),  (__CFString *)-[NSSQLForeignEntityKey name](foreignEntityKey, "name"),  foreignEntityKey);
      }
      if (v8)
      {
        -[NSSQLEntity _addColumnToFetch:]((void *)a1, foreignEntityKey);
      }

      else
      {
        uint64_t v12 = *(void **)(a1 + 88);
        if (!v12)
        {
          uint64_t v12 = (void *)objc_opt_new();
          *(void *)(a1 + 8_Block_object_dispose(va, 8) = v12;
        }

        [v12 addObject:foreignEntityKey];
      }
    }
  }

  objc_msgSend(*(id *)(a1 + 40), "setObject:forKey:", v3, -[NSSQLRelationship name](v3, "name"));
  if (v7)
  {
    if (!v8) {
      goto LABEL_25;
    }
LABEL_28:
    -[NSSQLRelationship _setInverseRelationship:](v3, a2);

    if (!v3) {
      goto LABEL_37;
    }
LABEL_29:
    foreignOrderKey = v3->_foreignOrderKey;
    if (foreignOrderKey)
    {
      objc_msgSend( *(id *)(a1 + 40),  "setObject:forKey:",  foreignOrderKey,  -[NSSQLForeignOrderKey name](v3->_foreignOrderKey, "name"));
      uint64_t v14 = *(void **)(a1 + 248);
      if (v14) {
        _PF_Leopard_CFDictionarySetValue( v14,  (__CFString *)-[NSSQLForeignOrderKey name](foreignOrderKey, "name"),  foreignOrderKey);
      }
      if (v8)
      {
        -[NSSQLEntity _addColumnToFetch:]((void *)a1, foreignOrderKey);
      }

      else
      {
        unsigned int v15 = *(void **)(a1 + 104);
        if (!v15)
        {
          unsigned int v15 = (void *)objc_opt_new();
          *(void *)(a1 + 104) = v15;
        }

        [v15 addObject:foreignOrderKey];
      }
    }

    goto LABEL_37;
  }

  _PF_Leopard_CFDictionarySetValue(*(void **)(a1 + 248), (__CFString *)-[NSSQLRelationship name](v3, "name"), v3);
  if (v8) {
    goto LABEL_28;
  }
LABEL_25:
  if (v3) {
    goto LABEL_29;
  }
LABEL_37:
  uint64_t v16 = *(void **)(a1 + 152);
  uint64_t v22 = 0u;
  uint64_t v23 = 0u;
  int v24 = 0u;
  int v25 = 0u;
  uint64_t v17 = [v16 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (v17)
  {
    uint64_t v18 = v17;
    int v19 = *(void *)v23;
    do
    {
      for (uint64_t i = 0LL; i != v18; ++i)
      {
        if (*(void *)v23 != v19) {
          objc_enumerationMutation(v16);
        }
        -[NSSQLEntity _addVirtualToOneForToMany:withInheritedProperty:]( *(void *)(*((void *)&v22 + 1) + 8 * i),  a2,  v3);
      }

      uint64_t v18 = [v16 countByEnumeratingWithState:&v22 objects:v26 count:16];
    }

    while (v18);
  }

  return v3;
}

  uint64_t v11 = [v7 entity];
  uint64_t v12 = _sqlCoreLookupSQLEntityForEntityDescription(*(void **)(a1 + 8), (void *)v11);
  uint64_t v13 = (void *)v12;
  if (a3 && !v12)
  {
    uint64_t v14 = (void *)MEMORY[0x189607870];
    v125[0] = @"Reason";
    v125[1] = @"Model Configuration";
    v126[0] = [NSString stringWithFormat:@"NSBatchDeleteRequest could not locate an Entity for entity name '%@'", objc_msgSend((id)v11, "name")];
    unsigned int v15 = [*(id *)(a1 + 8) configurationName];
    uint64_t v16 = @"Default";
    if (v15) {
      uint64_t v16 = (const __CFString *)v15;
    }
    v126[1] = v16;
    uint64_t v17 = [MEMORY[0x189603F68] dictionaryWithObjects:v126 forKeys:v125 count:2];
    *a3 = [v14 errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:v17];
  }

  uint64_t v18 = (_BYTE *)-[NSSQLiteAdapter newSelectStatementWithFetchRequest:ignoreInheritance:](a1, v7, 0LL);
  int v19 = v18;
  if (!v18) {
    goto LABEL_22;
  }
  if (v18[40])
  {

    return [MEMORY[0x189603FA8] array];
  }

  __int16 v21 = (void *)[v18 sqlString];
  uint64_t v23 = objc_msgSend(v21, "rangeOfString:", @"t0.Z_ENT, ");
  if (v23 != 0x7FFFFFFFFFFFFFFFLL) {
    __int16 v21 = (void *)objc_msgSend(v21, "stringByReplacingCharactersInRange:withString:", v23, v22, &stru_189EAC2E8);
  }
  int v25 = objc_msgSend(v21, "rangeOfString:", @"0, ");
  if (v25 != 0x7FFFFFFFFFFFFFFFLL) {
    __int16 v21 = (void *)objc_msgSend(v21, "stringByReplacingCharactersInRange:withString:", v25, v24, &stru_189EAC2E8);
  }
  if (v21) {
    uint64_t v26 = [NSString stringWithFormat:@"DELETE FROM %@ WHERE Z_PK IN (%@)", objc_msgSend(v13, "tableName", v25), v21];
  }
  else {
LABEL_22:
  }
    uint64_t v26 = [NSString stringWithFormat:@"DELETE FROM %@", objc_msgSend(v13, "tableName")];
  uint64_t v27 = (NSString *)v26;
  uint64_t v91 = -[NSSQLiteStatement initWithEntity:](objc_alloc(&OBJC_CLASS___NSSQLiteStatement), "initWithEntity:", v13);
  if (v91)
  {
    sqlString = v91->_sqlString;
    if (sqlString != v27)
    {

      v91->_sqlString = (NSString *)-[NSString copy](v27, "copy");
    }

    if (v9 == 2) {
      v91->_trackChangedRow__int16 Count = 1;
    }
  }

  if (v19)
  {
    -[NSSQLiteStatement setBindIntarrays:]((uint64_t)v91, (void *)[v19 bindIntarrays]);
    -[NSSQLiteAdapter _useModel:]((uint64_t)v91, (void *)[v19 bindVariables]);
  }

  if (v11)
  {
    if ((*(_BYTE *)(v11 + 120) & 4) != 0)
    {
      int v29 = *(const void **)(v11 + 72);
    }

    else
    {
      do
      {
        int v29 = (const void *)v11;
        uint64_t v11 = [(id)v11 superentity];
      }

      while (v11);
    }
  }

  else
  {
    int v29 = 0LL;
  }

  os_unfair_lock_lock_with_options();
  Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), v29);
  int v31 = Value;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  unint64_t v32 = Value;
  if (v32)
  {
    char v20 = (void *)[MEMORY[0x189603FA8] array];
    objc_msgSend(v20, "addObject:", objc_msgSend(v32, "firstObject"));
    [v20 addObject:v91];
    objc_msgSend(v20, "addObject:", objc_msgSend(v32, "lastObject"));
  }

  else
  {
    unint64_t v33 = objc_alloc_init(MEMORY[0x189603FA8]);
    uint64_t v34 = objc_alloc_init(MEMORY[0x189603FA8]);
    uint64_t v35 = *(void *)(a1 + 16);
    if (v35) {
      uint64_t v36 = *(void **)(v35 + 32);
    }
    else {
      uint64_t v36 = 0LL;
    }
    uint64_t v37 = [v36 count];
    uint64_t v38 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    cf = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], v37, MEMORY[0x189605240], MEMORY[0x189605250]);
    uint64_t v39 = *(void *)(a1 + 16);
    if (v39) {
      uint64_t v40 = *(void **)(v39 + 32);
    }
    else {
      uint64_t v40 = 0LL;
    }
    uint64_t v41 = [v40 count];
    CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v38, v41, MEMORY[0x189605240], MEMORY[0x189605250]);
    uint64_t v42 = *(void *)(a1 + 8);
    if (v42 && (*(_BYTE *)(v42 + 201) & 4) != 0)
    {
      uint64_t v44 = *(void *)(a1 + 16);
      if (v44) {
        uint64_t v45 = *(void **)(v44 + 32);
      }
      else {
        uint64_t v45 = 0LL;
      }
      uint64_t v46 = [v45 count];
      uint64_t v43 = CFDictionaryCreateMutable(v38, v46, MEMORY[0x189605240], MEMORY[0x189605250]);
    }

    else
    {
      uint64_t v43 = 0LL;
    }

    uint64_t v87 = v43;
    uint64_t v88 = -[NSSQLiteAdapter generateTriggerForEntity:alreadyCreated:correlations:batchHistory:fragments:error:]( a1,  (uint64_t)v29,  cf,  Mutable,  v43,  0LL,  a3);
    if (v88)
    {
      if (!a2 || !*(_BYTE *)(a2 + 83))
      {
        uint64_t v47 = objc_alloc_init(MEMORY[0x189603FA8]);
        if (-[__CFDictionary count](cf, "count"))
        {
          if (a2) {
            objc_setProperty_nonatomic((id)a2, v48, @"ZQ_BATCH_DELETE_MARSHALLING", 88LL);
          }
          unint64_t v49 = objc_alloc_init(MEMORY[0x189603FA8]);
          unint64_t v50 = objc_alloc_init(MEMORY[0x189603FA8]);
          v116[0] = MEMORY[0x1895F87A8];
          v116[1] = 3221225472LL;
          v116[2] = __82__NSSQLiteAdapter__generateExternalDataRefStatementsForEntities_inRequestContext___block_invoke;
          v116[3] = &unk_189EAA118;
          void v116[4] = a1;
          v116[5] = @"ZQ_BATCH_DELETE_MARSHALLING";
          v116[6] = v49;
          v116[7] = v50;
          -[__CFDictionary enumerateKeysAndObjectsUsingBlock:](cf, "enumerateKeysAndObjectsUsingBlock:", v116);
          if ([v49 count])
          {
            BOOL v51 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  0LL,  @"CREATE TEMP TABLE ZQ_BATCH_DELETE_MARSHALLING(refToDelete)");
            [v49 insertObject:v51 atIndex:0];

            [v47 addObject:v49];
            [v47 addObject:v50];
            unint64_t v52 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  0LL,  @"SELECT refToDelete FROM ZQ_BATCH_DELETE_MARSHALLING");
            v128[0] = v52;
            objc_msgSend(v47, "addObject:", objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v128, 1));

            unint64_t v53 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  0LL,  @"DROP TABLE ZQ_BATCH_DELETE_MARSHALLING");
            uint64_t v127 = v53;
            objc_msgSend(v47, "addObject:", objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v127, 1));
          }
        }

        if (a2) {
          objc_setProperty_nonatomic((id)a2, v48, v47, 128LL);
        }
      }

      BOOL v114 = 0u;
      uint64_t v115 = 0u;
      __int128 v112 = 0u;
      id v113 = 0u;
      uint64_t v54 = (void *)-[__CFDictionary allValues](cf, "allValues");
      uint64_t v55 = [v54 countByEnumeratingWithState:&v112 objects:v124 count:16];
      if (v55)
      {
        uint64_t v56 = *(void *)v113;
        do
        {
          for (uint64_t i = 0LL; i != v55; ++i)
          {
            if (*(void *)v113 != v56) {
              objc_enumerationMutation(v54);
            }
            uint64_t v58 = *(void **)(*((void *)&v112 + 1) + 8 * i);
          }

          uint64_t v55 = [v54 countByEnumeratingWithState:&v112 objects:v124 count:16];
        }

        while (v55);
      }

      uint64_t v110 = 0u;
      uint64_t v111 = 0u;
      uint64_t v108 = 0u;
      __int128 v109 = 0u;
      uint64_t v59 = (void *)-[__CFDictionary allValues](Mutable, "allValues");
      uint64_t v60 = [v59 countByEnumeratingWithState:&v108 objects:v123 count:16];
      if (v60)
      {
        uint64_t v61 = *(void *)v109;
        do
        {
          for (uint64_t j = 0LL; j != v60; ++j)
          {
            if (*(void *)v109 != v61) {
              objc_enumerationMutation(v59);
            }
            id v63 = *(void **)(*((void *)&v108 + 1) + 8 * j);
          }

          uint64_t v60 = [v59 countByEnumeratingWithState:&v108 objects:v123 count:16];
        }

        while (v60);
      }

      uint64_t v106 = 0u;
      id v107 = 0u;
      __int128 v104 = 0u;
      __int128 v105 = 0u;
      uint64_t v64 = (void *)-[__CFDictionary allValues](v87, "allValues");
      uint64_t v65 = [v64 countByEnumeratingWithState:&v104 objects:v122 count:16];
      if (v65)
      {
        uint64_t v66 = *(void *)v105;
        do
        {
          for (uint64_t k = 0LL; k != v65; ++k)
          {
            if (*(void *)v105 != v66) {
              objc_enumerationMutation(v64);
            }
            uint64_t v68 = *(void **)(*((void *)&v104 + 1) + 8 * k);
          }

          uint64_t v65 = [v64 countByEnumeratingWithState:&v104 objects:v122 count:16];
        }

        while (v65);
      }

      [0 addObject:v91];
      __int128 v102 = 0u;
      __int128 v103 = 0u;
      __int128 v100 = 0u;
      __int128 v101 = 0u;
      uint64_t v69 = (void *)-[__CFDictionary allValues](cf, "allValues");
      uint64_t v70 = [v69 countByEnumeratingWithState:&v100 objects:v121 count:16];
      if (v70)
      {
        uint64_t v71 = *(void *)v101;
        do
        {
          for (m = 0LL; m != v70; ++m)
          {
            if (*(void *)v101 != v71) {
              objc_enumerationMutation(v69);
            }
            uint64_t v73 = *(void **)(*((void *)&v100 + 1) + 8 * m);
          }

          uint64_t v70 = [v69 countByEnumeratingWithState:&v100 objects:v121 count:16];
        }

        while (v70);
      }

      __int128 v98 = 0u;
      __int128 v99 = 0u;
      size_t v96 = 0u;
      uint64_t v97 = 0u;
      uint64_t v74 = (void *)-[__CFDictionary allValues](Mutable, "allValues");
      uint64_t v75 = [v74 countByEnumeratingWithState:&v96 objects:v120 count:16];
      if (v75)
      {
        uint64_t v76 = *(void *)v97;
        do
        {
          for (n = 0LL; n != v75; ++n)
          {
            if (*(void *)v97 != v76) {
              objc_enumerationMutation(v74);
            }
            unint64_t v78 = *(void **)(*((void *)&v96 + 1) + 8 * n);
          }

          uint64_t v75 = [v74 countByEnumeratingWithState:&v96 objects:v120 count:16];
        }

        while (v75);
      }

      uint64_t v94 = 0u;
      unsigned int v95 = 0u;
      uint64_t v92 = 0u;
      uint64_t v93 = 0u;
      uint64_t v79 = (void *)-[__CFDictionary allValues](v87, "allValues");
      uint64_t v80 = [v79 countByEnumeratingWithState:&v92 objects:v119 count:16];
      if (v80)
      {
        size_t v81 = *(void *)v93;
        do
        {
          for (iuint64_t i = 0LL; ii != v80; ++ii)
          {
            if (*(void *)v93 != v81) {
              objc_enumerationMutation(v79);
            }
            id v83 = *(void **)(*((void *)&v92 + 1) + 8 * ii);
          }

          uint64_t v80 = [v79 countByEnumeratingWithState:&v92 objects:v119 count:16];
        }

        while (v80);
      }
    }

    if (cf) {
      CFRelease(cf);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v87) {
      CFRelease(v87);
    }
    uint64_t v84 = (void *)[MEMORY[0x189603FA8] array];
    char v20 = v84;
    if (v88)
    {
      [v84 addObject:v33];
      uint64_t v118 = v91;
      objc_msgSend(v20, "addObject:", objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v118, 1));
      [v20 addObject:v34];
      v117[0] = v33;
      v117[1] = v34;
      uint64_t v85 = (const void *)[MEMORY[0x189603F18] arrayWithObjects:v117 count:2];
      os_unfair_lock_lock_with_options();
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v85, v29);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
    }
  }

  return (uint64_t)v20;
}

  if (!v28)
  {
    int v19 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitExportContext.m");
    uint64_t v26 = (os_log_s *)__pflogFaultLog;
    LODWORD(v1_Block_object_dispose(va, 8) = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!(_DWORD)v18) {
      return v18;
    }
    *(_DWORD *)buf = 136315394;
    unsigned int v30 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitExportContext.m";
    int v31 = 1024;
    unint64_t v32 = 1092;
    _os_log_fault_impl( &dword_186681000,  v26,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
LABEL_12:
    LOBYTE(v1_Block_object_dispose(va, 8) = 0;
    return v18;
  }

  if (!a6) {
    goto LABEL_12;
  }
  LOBYTE(v1_Block_object_dispose(va, 8) = 0;
  *a6 = v28;
  return v18;
}

id *_PF_FulfillDeferredFault(id **a1, unint64_t a2)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl( [a1 managedObjectContext],  sel_fulfillFault_withContext_forIndex_);
  }
  if (((_DWORD)a1[2] & 0x30000) == 0x10000 || ((_DWORD)a1[2] & 0x80) != 0) {
    return 0LL;
  }
  unint64_t v5 = a1[4];
  size_t v6 = a1[5];
  uint64_t v7 = (unint64_t *)_PFEntityForManagedObject(a1);
  unsigned int v8 = (void *)v7[14];
  unint64_t v9 = v8[2];
  BOOL v11 = a2 >= v9;
  unint64_t v10 = a2 - v9;
  BOOL v11 = !v11 || v10 >= v8[3];
  BOOL v12 = !v11;
  unint64_t v14 = *((unsigned int *)a1 + 4);
  uint64_t v13 = *((unsigned int *)a1 + 5);
  unsigned int v15 = (_DWORD)v13 ? (char *)a1 + v13 : 0LL;
  uint64_t v16 = &v15[-((v14 >> 22) & 0x3FC)];
  unint64_t v17 = a2 >> 3;
  if ((v14 & 0x38000) == 0x8000 || v12)
  {
    [(id)_insertion_fault_handler fulfillFault:a1 withContext:v5 forIndex:a2];
  }

  unint64_t v18 = v8[12];
  unint64_t v19 = v8[13];
  uint64_t v20 = _kvcPropertysPrimitiveSetters((uint64_t)v7);
  BOOL v11 = a2 >= v18;
  unint64_t v21 = a2 - v18;
  uint64_t v22 = *(void *)(v20 + 8 * a2);
  if (!v11 || v21 >= v19)
  {
    uint64_t v71 = *(void *)(v20 + 8 * a2);
    unint64_t v24 = v8[28];
    BOOL v11 = a2 >= v24;
    unint64_t v25 = a2 - v24;
    int v27 = v11 && v25 < v8[29];
    unint64_t v28 = v8[18];
    BOOL v11 = a2 >= v28;
    unint64_t v29 = a2 - v28;
    int v31 = v11 && v29 < v8[19];
    unint64_t v32 = v8[26];
    BOOL v11 = a2 >= v32;
    unint64_t v33 = a2 - v32;
    int v35 = v11 && v33 < v8[27];
    if (((v27 | v31) & 1) == 0 && !v35)
    {
      if (*(void *)(_kvcPropertysPrimitiveGetters(v7) + 8 * a2)) {
        uint64_t v42 = _NSGetUsingKeyValueGetter();
      }
      else {
        snapshot_get_value_as_object(a1[3], a2, v36, v37, v38, v39, v40, v41);
      }
      unint64_t v5 = (id *)v42;
      goto LABEL_68;
    }

    BOOL v51 = ((_DWORD)a1[2] & 0x12) == 0;
    int v52 = [v6 isTemporaryID];
    BOOL v53 = v5 != 0LL;
    uint64_t v54 = *(void *)(v7[12] + 24 + 8 * a2);
    uint64_t v55 = (v53 | ~v52) & v51 | v27;
    uint64_t v56 = (objc_class *)objc_opt_class();
    unint64_t v5 = (id *)objc_msgSend(_PFAllocateObject(v56, 0), "initWithSource:forRelationship:asFault:", a1, v54, v55);
    _PF_CopyOnWrite_Snapshot(a1);
    if (v71) {
      goto LABEL_57;
    }
    goto LABEL_58;
  }

  if (!v5)
  {
LABEL_68:
    v16[v17] |= 1 << (a2 & 7);
    return v5;
  }

  uint64_t v49 = *(void *)(_kvcPropertysPrimitiveGetters(v7) + 8 * a2);
  if (v49) {
    uint64_t v50 = _NSGetUsingKeyValueGetter();
  }
  else {
    snapshot_get_value_as_object(a1[3], a2, v43, v44, v45, v46, v47, v48);
  }
  uint64_t v62 = (void *)v50;
  if (v50 != _CD_ScalarNull)
  {
    if (v50) {
      goto LABEL_56;
    }
    goto LABEL_67;
  }

  [(id)_insertion_fault_handler fulfillFault:a1 withContext:v5 forIndex:a2];
  uint64_t result = a1[3];
  if (result)
  {
    if (v49) {
      uint64_t v70 = _NSGetUsingKeyValueGetter();
    }
    else {
      snapshot_get_value_as_object(result, a2, v63, v64, v65, v66, v67, v68);
    }
    uint64_t v62 = (void *)v70;
    if (v70)
    {
LABEL_56:
      unint64_t v5 = (id *)-[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( (void **)v5,  v62,  0LL);
      _PF_CopyOnWrite_Snapshot(a1);
      if (v22)
      {
LABEL_57:
        _NSSetUsingKeyValueSetter();

        goto LABEL_68;
      }

LABEL_67:
    unint64_t v5 = 0LL;
    goto LABEL_68;
  }

  __break(1u);
  return result;
}

    uint64_t v22 = v16;
    goto LABEL_68;
  }

  return result;
}

  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL)) {
    return;
  }
  uint64_t v115 = *(void *)(a1 + 32);
  if (v115)
  {
    unsigned int v116 = *(void *)(v115 + 40);
    if (v116)
    {
      if (([*(id *)(v116 + 64) shouldDefer] & 1) != 0 || *(_BYTE *)(v116 + 40))
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
        int v117 = objc_alloc(MEMORY[0x189607870]);
        uint64_t v175 = *MEMORY[0x1896075F0];
        uint64_t v176 = @"The request was aborted because it was deferred by the system.";
        uint64_t v118 = [MEMORY[0x189603F68] dictionaryWithObjects:&v176 forKeys:&v175 count:1];
        uint64_t v119 = (id *)[v117 initWithDomain:*MEMORY[0x189607460] code:134419 userInfo:v118];
LABEL_75:
        *(void *)(*(void *)(v1[8] + 8LL) + 40LL) = v119;
        return;
      }
    }
  }

  if (!+[_PFRoutines _isInMemoryStore:]((uint64_t)&OBJC_CLASS____PFRoutines, *(unsigned __int8 **)(a1 + 40)))
  {
    *(void *)buf = 0LL;
    if ((objc_msgSend( *(id *)(a1 + 48),  "setQueryGenerationFromToken:error:",  +[NSQueryGenerationToken currentQueryGenerationToken]( NSQueryGenerationToken,  "currentQueryGenerationToken"),  buf) & 1) == 0)
    {
      uint64_t v123 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v124 = __ckLoggingOverride;
      unint64_t v1 = (void *)a1;
      uint64_t v125 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Unable to set query generation on moc: %@"];
      _NSCoreDataLog( v124 != 0,  v125,  v126,  v127,  v128,  v129,  v130,  v131,  (uint64_t)"-[PFCloudKitExporter exportIfNecessary]_block_invoke_2");
      objc_autoreleasePoolPop(v123);
    }
  }

  int v180 = 0LL;
  if (![*(id *)(v1[4] + 56) checkForObjectsNeedingExportInStore:v1[5] andReturnCount:&v180 withManagedObjectContext:v1[6] error:&v173])
  {
    *(_BYTE *)(*(void *)(v1[7] + 8LL) + 24LL) = 0;
    uint64_t v119 = v173;
    goto LABEL_75;
  }

  uint64_t v132 = (void *)MEMORY[0x186E3E5D8]();
  BOOL v133 = __ckLoggingOverride;
  uint64_t v134 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Found %lu objects needing export."];
  if (v133 >= 0x10) {
    unsigned int v141 = 16LL;
  }
  else {
    unsigned int v141 = v133;
  }
  _NSCoreDataLog( v141,  v134,  v135,  v136,  v137,  v138,  v139,  v140,  (uint64_t)"-[PFCloudKitExporter exportIfNecessary]_block_invoke_2");
  objc_autoreleasePoolPop(v132);
  if (v180)
  {
    id v142 = -[PFCloudKitExportContext newOperationBySerializingDirtyObjectsInStore:inManagedObjectContext:error:]( *(void **)(*(void *)(a1 + 32) + 56LL),  *(void *)(a1 + 40),  *(void **)(a1 + 48),  &v173);
    if (v142)
    {
      WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 48LL));
      uint64_t v144 = *(void *)(a1 + 32);
      uint64_t v177 = v142;
      objc_msgSend( WeakRetained,  "exporter:willScheduleOperations:",  v144,  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v177, 1));

      uint64_t v145 = *(void *)(a1 + 32);
      if (v145)
      {
        objc_initWeak(location, *(id *)(a1 + 32));
        if ([*(id *)(v145 + 40) options]) {
          -[NSCloudKitMirroringRequestOptions applyToOperation:]([*(id *)(v145 + 40) options], v142);
        }
        [v142 setSavePolicy:1];
        v146 = *(void *)(v145 + 24);
        if (!v146 || (uint64_t v147 = *(void *)(v146 + 16)) == 0 || !*(_BYTE *)(v147 + 18)) {
          [v142 setSavePolicy:0];
        }
        uint64_t v148 = [v142 operationID];
        *(void *)buf = MEMORY[0x1895F87A8];
        *(void *)&uint8_t buf[8] = 3221225472LL;
        *(void *)&uint8_t buf[16] = __39__PFCloudKitExporter_executeOperation___block_invoke;
        int v183 = &unk_189EAA7B8;
        objc_copyWeak(v185, location);
        __int128 v184 = v148;
        [v142 setModifyRecordsCompletionBlock:buf];
        int v149 = *(void *)(v145 + 24);
        if (v149) {
          uint64_t v150 = *(void **)(v149 + 8);
        }
        else {
          uint64_t v150 = 0LL;
        }
        [v150 addOperation:v142];
        objc_destroyWeak(v185);
        objc_destroyWeak(location);
      }
    }

    else
    {
      uint64_t v162 = v173;
      if (v173)
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
        *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL) = v162;
      }

      else
      {
        uint64_t v163 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResult);
        uint64_t v164 = *(void *)(a1 + 32);
        int v165 = *(void *)(v164 + 64);
        if (v165) {
          int v166 = *(void *)(v165 + 48);
        }
        else {
          int v166 = 0LL;
        }
        uint64_t v167 = -[NSCloudKitMirroringResult initWithRequest:storeIdentifier:success:madeChanges:error:]( v163,  "initWithRequest:storeIdentifier:success:madeChanges:error:",  *(void *)(v164 + 40),  v166,  1LL,  0LL,  0LL);
        -[PFCloudKitExporter finishExportWithResult:](*(void **)(a1 + 32), (uint64_t)v167);
      }
    }
  }

  else
  {
    *(void *)buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2020000000LL;
    LOBYTE(v183) = 0;
    uint64_t v155 = *(void **)(*(void *)(a1 + 32) + 8LL);
    v172[0] = MEMORY[0x1895F87A8];
    v172[1] = 3221225472LL;
    v172[2] = __39__PFCloudKitExporter_exportIfNecessary__block_invoke_3;
    v172[3] = &unk_189EAA768;
    v172[4] = buf;
    [v155 enumerateKeysAndObjectsUsingBlock:v172];
    id v156 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResult);
    uint64_t v157 = *(void *)(a1 + 32);
    uint64_t v158 = *(void *)(v157 + 64);
    if (v158) {
      uint64_t v159 = *(void *)(v158 + 48);
    }
    else {
      uint64_t v159 = 0LL;
    }
    unint64_t v160 = -[NSCloudKitMirroringResult initWithRequest:storeIdentifier:success:madeChanges:error:]( v156,  "initWithRequest:storeIdentifier:success:madeChanges:error:",  *(void *)(v157 + 40),  v159,  1LL,  *(unsigned __int8 *)(*(void *)&buf[8] + 24LL),  0LL);
    -[PFCloudKitExporter finishExportWithResult:](*(void **)(a1 + 32), (uint64_t)v160);

    _Block_object_dispose(buf, 8);
  }

        ++idx;
LABEL_68:
        objc_autoreleasePoolPop(v18);
        if (v66 == ++v17) {
          goto LABEL_75;
        }
      }

      unint64_t v32 = (void *)_newConflictRecordForObject(v20, v22, 0LL, 0);
      -[NSPersistentStoreCache forgetRowForObjectID:](v64, v21);
      if ((int)-[NSSQLStoreRequestContext debugLogLevel]((uint64_t)v70) < 2)
      {
        if ((int)-[NSSQLStoreRequestContext debugLogLevel]((uint64_t)v70) >= 1) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Optimistic locking failure for %@.  Row was deleted.",  v45,  v46,  v47,  v48,  v49,  v50,  (uint64_t)v21);
        }
      }

      else
      {
        _NSCoreDataLog( 4LL,  (uint64_t)@"Optimistic locking failure for %@.  Row was deleted.  Original row = %@ New Row = <deleted>",  v39,  v40,  v41,  v42,  v43,  v44,  (uint64_t)v21);
      }

      int v31 = 0LL;
LABEL_65:
      if (v32)
      {
        [v62 addObject:v32];

        if (!v31) {
          goto LABEL_68;
        }
      }

      goto LABEL_67;
    }
  }

void snapshot_get_value_as_object( id *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    Class Class = object_getClass(a1);
    IndexedIvars = object_getIndexedIvars(Class);
    if (((*((unsigned __int8 *)a1 + ((unint64_t)a2 >> 3) + 28) >> (a2 & 7)) & 1) == 0)
    {
      uint64_t v13 = *((unsigned int *)IndexedIvars + a2 + 19);
      int v14 = *(char *)(IndexedIvars[7] + a2);
      switch(*(_BYTE *)(IndexedIvars[7] + a2))
      {
        case 'c':
          [MEMORY[0x189607968] numberWithChar:*((char *)a1 + v13)];
          break;
        case 'd':
          double v15 = *(double *)((char *)a1 + v13);
          uint64_t v16 = *(void **)(*(void *)([a1[2] entity] + 96) + 24 + 8 * a2);
          if (([v16 _isRelationship] & 1) != 0 || objc_msgSend(v16, "attributeType") != 900) {
            [MEMORY[0x189607968] numberWithDouble:v15];
          }
          else {
            [MEMORY[0x189603F50] dateWithTimeIntervalSinceReferenceDate:v15];
          }
          break;
        case 'e':
        case 'g':
        case 'h':
          return;
        case 'f':
          LODWORD(v12) = *(_DWORD *)((char *)a1 + v13);
          [MEMORY[0x189607968] numberWithFloat:v12];
          break;
        case 'i':
          [MEMORY[0x189607968] numberWithInt:*(unsigned int *)((char *)a1 + v13)];
          break;
        default:
          if (v14 == 113)
          {
            [MEMORY[0x189607968] numberWithLongLong:*(id *)((char *)a1 + v13)];
          }

          else if (v14 == 115)
          {
            [MEMORY[0x189607968] numberWithShort:*(__int16 *)((char *)a1 + v13)];
          }

          break;
      }
    }
  }

  else
  {
    _NSCoreDataLog( 1LL,  (uint64_t)@"warning snapshot_get_value_as_object called on NULL",  a3,  a4,  a5,  a6,  a7,  a8,  v17);
    __break(1u);
  }

void sub_1866AD8F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_1866ADADC()
{
}

void sub_1866ADAE8()
{
}

void sub_1866ADAF4()
{
  if (v0) {
    JUMPOUT(0x1866ADAFCLL);
  }
  JUMPOUT(0x1866ADB00LL);
}

void sub_1866ADF14(_Unwind_Exception *a1)
{
}

void sub_1866ADF30()
{
}

void _executeNewValuesForRelationshipFaultRequest(uint64_t a1)
{
  v113[6] = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v111 = *(void **)(a1 + 96);
    uint64_t v2 = *(void **)(a1 + 88);
    unint64_t v3 = *(void **)(a1 + 32);
  }

  else
  {
    uint64_t v2 = 0LL;
    uint64_t v111 = 0LL;
    unint64_t v3 = 0LL;
  }

  uint64_t v4 = [v2 name];
  if (([v2 isToMany] & 1) == 0)
  {
    double v12 = -[NSSQLStoreRequestContext createNestedObjectFaultContextForObjectWithID:]( (NSSQLObjectFaultRequestContext *)a1,  (uint64_t)v111);
    uint64_t v13 = v12;
    if (a1) {
      int v14 = *(void **)(a1 + 24);
    }
    else {
      int v14 = 0LL;
    }
    -[NSSQLStoreRequestContext setConnection:]((uint64_t)v12, v14);
    id v16 = _executeNewRowValuesForObjectFaultRequest(v13);
    if (v16)
    {
LABEL_25:
      -[NSSQLStoreRequestContext setConnection:]((uint64_t)v13, 0LL);

      id v22 = (id)[v16 valueForKey:v4];
      if (v22) {
        objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v22, 0);
      }
      return;
    }

    if (v13)
    {
      error = v13->super._error;
      if (!a1)
      {
LABEL_24:
        id v16 = 0LL;
        goto LABEL_25;
      }
    }

    else
    {
      error = 0LL;
      if (!a1) {
        goto LABEL_24;
      }
    }

    objc_setProperty_nonatomic((id)a1, v15, error, 40LL);
    goto LABEL_24;
  }

  [v3 stalenessInterval];
  double v6 = v5;
  double Current = CFAbsoluteTimeGetCurrent();
  double v8 = Current - v6;
  if (v6 <= 0.0) {
    double v8 = *(double *)&NSSQLDistantPastTimeInterval;
  }
  if (v6 == 0.0) {
    double v9 = *(double *)&NSSQLDistantFutureTimeInterval;
  }
  else {
    double v9 = v8;
  }
  unint64_t v10 = (void *)-[NSPersistentStoreCache toManyInformationForSourceObjectID:forProperty:afterTimestamp:]( objc_msgSend((id)a1, "rowCache", v8),  v111,  v2,  v9);
  if (v10)
  {
    id v11 = v10;
    return;
  }

  int v108 = [v2 isOrdered];
  id v109 = objc_alloc_init(MEMORY[0x1896077E8]);
  if (a1)
  {
    uint64_t v17 = *(void **)(a1 + 96);
    if (([v17 isTemporaryID] & 1) == 0)
    {
      unint64_t v18 = (id *)-[NSSQLCore entityForObjectID:](*(void *)(a1 + 8), v17);
      if (v18)
      {
        unint64_t v19 = *(void **)(a1 + 88);
        goto LABEL_19;
      }
    }

LABEL_91:
    uint64_t v60 = 0LL;
LABEL_79:
    -[NSSQLStoreRequestContext setConnection:](v30, v60);
    if (v30) {
      uint64_t v61 = *(void *)(v30 + 136);
    }
    else {
      uint64_t v61 = 0LL;
    }
    unsigned int v62 = *(_DWORD *)(v61 + 72) & 0xFFFFFFE3;
    if (v28)
    {
      int v63 = v62 | 0x10;
      *(_DWORD *)(v61 + 72) = v63;
      if (v25) {
        uint64_t v64 = *(void *)(v25 + 48);
      }
      else {
        uint64_t v64 = 0LL;
      }
      *(void *)(v61 + 40) = v64;
      unsigned int v65 = v63 & 0xFFFFFFF2;
    }

    else
    {
      unsigned int v65 = v62 | 4;
    }

    *(_DWORD *)(v61 + 72) = v65;
    uint64_t v56 = _newFetchedRowsForRequest(v30);
    -[NSSQLStoreRequestContext setConnection:](v30, 0LL);

    uint64_t v30 = 0LL;
    ++v55;
  }

  if (((v105 | !v28) & 1) == 0)
  {
    uint64_t v66 = -[_PFArray count](v56, "count");
    CFIndex v67 = v66;
    if (v66)
    {
      uint64_t v68 = (const void **)PF_ALLOCATE_OBJECT_ARRAY(v66);
      v114.location = 0LL;
      v114.length = v67;
      CFArrayGetValues((CFArrayRef)v56, v114, v68);
      CFMergeSortArray();
      uint64_t v69 = -[_PFArray initWithObjects:count:andFlags:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:",  v68,  v67,  11LL);

      uint64_t v56 = v69;
    }
  }

  if (v106)
  {
    if (PFInstrumentsGetLog_logtoken != -1) {
      dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
    }
    if (v106 != -1LL)
    {
      uint64_t v70 = (os_log_s *)PFInstrumentsGetLog_coreDataInstrumentsLog;
      if (os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl( &dword_186681000,  v70,  OS_SIGNPOST_INTERVAL_END,  v106,  "RelationshipFault",  "",  buf,  2u);
      }
    }
  }

    objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"NSPersistentHistoryTrackingEntitiesToInclude must be an NSArray of NSString" userInfo:0]);
    goto LABEL_95;
  }

  unint64_t v33 = 0LL;
  BOOL v28 = 0LL;
LABEL_36:
  uint64_t v34 = *(void *)(a1 + 104);
  if (v34) {
    uint64_t v35 = *(void **)(v34 + 24);
  }
  else {
    uint64_t v35 = 0LL;
  }
  uint64_t v36 = (void *)[v35 allKeys];
  id v37 = objc_alloc_init(MEMORY[0x189603FA8]);
  uint64_t v38 = objc_alloc_init(MEMORY[0x189603FA8]);
  if ([v28 count])
  {
    unint64_t v73 = 0u;
    uint64_t v74 = 0u;
    uint64_t v71 = 0u;
    unint64_t v72 = 0u;
    uint64_t v39 = [v36 countByEnumeratingWithState:&v71 objects:v86 count:16];
    if (v39)
    {
      uint64_t v40 = *(void *)v72;
      do
      {
        for (uint64_t k = 0LL; k != v39; ++k)
        {
          if (*(void *)v72 != v40) {
            objc_enumerationMutation(v36);
          }
          int v42 = *(void *)(*((void *)&v71 + 1) + 8 * k);
          else {
            uint64_t v43 = v38;
          }
          [v43 addObject:v42];
        }

        uint64_t v39 = [v36 countByEnumeratingWithState:&v71 objects:v86 count:16];
      }

      while (v39);
    }
  }

  else if ([v33 count])
  {
    uint64_t v69 = 0u;
    uint64_t v70 = 0u;
    CFIndex v67 = 0u;
    uint64_t v68 = 0u;
    BOOL v44 = [v36 countByEnumeratingWithState:&v67 objects:v85 count:16];
    if (v44)
    {
      uint64_t v45 = *(void *)v68;
      do
      {
        for (m = 0LL; m != v44; ++m)
        {
          if (*(void *)v68 != v45) {
            objc_enumerationMutation(v36);
          }
          uint64_t v47 = *(void *)(*((void *)&v67 + 1) + 8 * m);
          else {
            uint64_t v48 = v37;
          }
          [v48 addObject:v47];
        }

        BOOL v44 = [v36 countByEnumeratingWithState:&v67 objects:v85 count:16];
      }

      while (v44);
    }
  }

  else
  {
    [v37 addObjectsFromArray:v36];
  }

  if ([v64 count]) {
    objc_msgSend(v38, "addObjectsFromArray:", objc_msgSend(v64, "allObjects"));
  }
  v83[0] = @"NSPersistentHistoryTrackingEntitiesToInclude";
  v84[0] = [MEMORY[0x189604010] setWithArray:v37];
  v83[1] = @"NSPersistentHistoryTrackingEntitiesToExclude";
  v84[1] = [MEMORY[0x189604010] setWithArray:v38];
  *(void *)(a1 + 240) = (id)[MEMORY[0x189603F68] dictionaryWithObjects:v84 forKeys:v83 count:2];
  [(id)a1 setAncillaryModels:v66];
  [(id)a1 setAncillarySQLModels:v65];
}

          objc_autoreleasePoolPop(v89);
        }

        if (*(uint32_t *)((char *)&v92[v216]._os_unfair_lock_opaque
                         + _NSSQLRowInstanceSize
                         + ((2 * v92[4]._os_unfair_lock_opaque) & 0x1FFF8)) == (_DWORD)v94)
          goto LABEL_91;
        goto LABEL_90;
      }

LABEL_105:
  if (!-[_PFArray count](v56, "count"))
  {
    if (v108) {
      uint64_t v80 = &NSOrderedSet_EmptyOrderedSet;
    }
    else {
      uint64_t v80 = &NSSet_EmptySet;
    }
    uint64_t v71 = (void *)*v80;
    goto LABEL_114;
  }

  uint64_t v71 = v56;
  if (!v108)
  {
LABEL_114:
    size_t v81 = 0LL;
    id v82 = v71;
    goto LABEL_123;
  }

  unint64_t v72 = -[_PFArray count](v56, "count");
  uint64_t v110 = (NSFetchRequest *)v103;
  unint64_t v73 = MEMORY[0x1895F8858](v72);
  uint64_t v76 = (char *)v103 - v75;
  size_t v77 = 8 * v74;
  if (v73 >= 0x201)
  {
    uint64_t v76 = (char *)NSAllocateScannedUncollectable();
    uint64_t v79 = (char *)NSAllocateScannedUncollectable();
LABEL_116:
    uint64_t v83 = 0LL;
    do
    {
      id v84 = -[_PFArray objectAtIndex:](v56, "objectAtIndex:", v83);
      *(void *)&v76[8 * v83] = [v84 valueAtIndex:0];
      uint64_t v85 = [v84 valueAtIndex:1];
      if (v85) {
        uint64_t v86 = (void *)v85;
      }
      else {
        uint64_t v86 = &unk_189F04668;
      }
      *(void *)&v79[8 * v83++] = v86;
    }

    while (v72 != v83);
    goto LABEL_121;
  }

  bzero((char *)v103 - v75, 8 * v74);
  MEMORY[0x1895F8858](v78);
  uint64_t v79 = (char *)v103 - ((v77 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  bzero(v79, v77);
  if (v72) {
    goto LABEL_116;
  }
LABEL_121:
  size_t v81 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:v79 count:v72];
  id v82 = (id)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:v76 count:v72];
  if (v72 >= 0x201)
  {
    NSZoneFree(0LL, v76);
    NSZoneFree(0LL, v79);
  }

  unsigned int v116 = (v69 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  int v117 = v116 + 8;
  if (v116 + 8 <= a4)
  {
    uint64_t v118 = bswap64(*(void *)(a2 + v116));
    id v142 = v116 + 8;
    unsigned int v116 = (v116 + 15) & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v119 = v116 + 8;
    uint64_t v69 = v117;
  }

  else
  {
    uint64_t v118 = 0LL;
    uint64_t v119 = v116 + 8;
  }

  *(void *)(v20 + 72) = v118;
  if (v119 <= a4)
  {
    char v120 = bswap64(*(void *)(a2 + v116));
    id v142 = v119;
    uint64_t v69 = v119;
  }

  else
  {
    char v120 = 0LL;
  }

  *(void *)(v20 + 80) = v120;
  signed int v121 = (v69 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  int v122 = v121 + 4;
  if (v121 + 4 <= a4)
  {
    uint64_t v123 = *(_DWORD *)(a2 + v121);
    id v142 = v122;
    uint64_t v69 = v122;
    if (v123)
    {
      *(void *)(v20 + 96) = _newReadPFEncodedArrayFromData((uint64_t)a1, a2, &v142, a4, v18, 0LL);
      uint64_t v69 = v142;
    }
  }

  uint64_t v124 = (v69 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v125 = v124 + 4;
  if (v124 + 4 <= a4)
  {
    uint64_t v126 = bswap32(*(_DWORD *)(a2 + v124));
    id v142 = v124 + 4;
    uint64_t v124 = (v124 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v125 = v124 + 4;
  }

  else
  {
    uint64_t v126 = 0;
  }

  *(_DWORD *)(v20 + 104) = v126;
  *(_DWORD *)(v20 + 104) &= ~0x100u;
  if (v125 <= a4)
  {
    uint64_t v127 = *(_DWORD *)(a2 + v124);
    id v142 = v125;
    if (v127 == -20254786)
    {
      *id v22 = v125;
      return 1LL;
    }
  }

LABEL_123:
  if ((int)-[NSSQLStoreRequestContext debugLogLevel](a1) < 2)
  {
    if ((int)-[NSSQLStoreRequestContext debugLogLevel](a1) >= 1)
    {
      uint64_t v94 = [v2 name];
      -[_PFArray count](v56, "count");
      _NSCoreDataLog( 4LL,  (uint64_t)@"to-many relationship fault %@ for objectID %@ fulfilled from database.  Got %d rows",  v95,  v96,  v97,  v98,  v99,  v100,  v94);
    }
  }

  else
  {
    uint64_t v87 = [v2 name];
    -[_PFArray count](v56, "count");
    _NSCoreDataLog( 4LL,  (uint64_t)@"to-many relationship fault %@ for objectID %@ fulfilled from database.  Got %d rows with values: %@",  v88,  v89,  v90,  v91,  v92,  v93,  v87);
  }

  uint64_t v101 = [(id)a1 rowCache];
  if (v101) {
    -[NSPersistentStoreCache registerToMany:withOrderKeys:forSourceObjectID:forProperty:options:andTimestamp:]( v101,  v82,  v81,  v111,  v2,  Current);
  }
  [v109 drain];
  id v102 = 0LL;
  objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v82, v81, 0);
}

void sub_1866AF29C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866AF270LL);
  }

  JUMPOUT(0x1866AF1B8LL);
}

LABEL_17:
    _os_log_fault_impl(&dword_186681000, v23, OS_LOG_TYPE_FAULT, v22, buf, v24);
    return 0LL;
  }

  return result;
}

  double v6 = *a1;
  uint64_t v7 = v6 >= 0xC;
  double v8 = v6 - 12;
  if (!v7) {
    double v8 = -1;
  }
  return (v8 + 1);
}

  double v6 = *a1;
  uint64_t v7 = v6 >= 2;
  double v8 = v6 - 2;
  if (!v7) {
    double v8 = -1;
  }
  return (v8 + 1);
}

        ++v9;
      }

      while (v7 != v9);
      uint64_t result = [a2 countByEnumeratingWithState:&v21 objects:v25 count:16];
      uint64_t v7 = result;
    }

    while (result);
  }

  return result;
}

    double v6 = (void *)MEMORY[0x189607968];
    oldVersion = self->_newVersion;
    return (id)[v6 numberWithUnsignedInteger:oldVersion];
  }

  return self->_snapshot3;
}

  uint64_t v23 = [MEMORY[0x189607A40] isMainThread];
  if (([a3 shouldInvokeCompletionHandlerConcurrently] | v23 ^ a4))
  {
    unint64_t v24 = v53;
    uint64_t v25 = a2;
    if ((a4 & 1) != 0) {
      global_queue = (dispatch_queue_global_t)MEMORY[0x1895F8AE0];
    }
    else {
      global_queue = dispatch_get_global_queue(0LL, 0LL);
    }
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __114__NSPersistentStoreCoordinator__doAddPersistentStoreWithDescription_privateCopy_completeOnMainThread_withHandler___block_invoke;
    block[3] = &unk_189EA8C68;
    block[4] = a2;
    block[5] = v53;
    block[6] = a5;
    dispatch_async(global_queue, block);
  }

  else
  {
    (*(void (**)(uint64_t, void *, id))(a5 + 16))(a5, a2, v53);
  }

  [v10 drain];
  return 0LL;
}

    id v16 = 0LL;
    goto LABEL_8;
  }

  unint64_t v19 = [a5 _setQueryGenerationFromToken:v18 error:&v30];

  if ((v19 & 1) == 0)
  {
    uint64_t v20 = v30;
    if (!v30) {
      goto LABEL_12;
    }
    goto LABEL_15;
  }

      double v15 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitHistoryAnalyzer.m");
      id v22 = (os_log_s *)__pflogFaultLog;
      uint64_t v13 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
      if (!v13) {
        return v13;
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v35 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitHistoryAnalyzer.m";
      uint64_t v36 = 1024;
      id v37 = 101;
      _os_log_fault_impl( &dword_186681000,  v22,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      goto LABEL_19;
    }
  }

  lastProcessedToken = self->_lastProcessedToken;
  if (lastProcessedToken == (NSPersistentHistoryToken *)[a3 token])
  {
    if ([a3 token])
    {
      uint64_t v23 = [NSString stringWithUTF8String:"Transaction appears to have been processed twice: %@"];
      _NSCoreDataLog(17LL, v23, v24, v25, v26, v27, v28, v29, (uint64_t)a3);
      uint64_t v30 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 138412290;
        uint64_t v35 = (const char *)a3;
        _os_log_fault_impl( &dword_186681000,  v30,  OS_LOG_TYPE_FAULT,  "CoreData: Transaction appears to have been processed twice: %@",  buf,  0xCu);
      }
    }
  }

  else
  {

    self->_lastProcessedToken = (NSPersistentHistoryToken *)(id)[a3 token];
  }

  LOBYTE(v13) = 1;
  return v13;
}

  id v11 = 0LL;
  if (v4)
  {
LABEL_9:
    sqlString = v4->_sqlString;
    if (sqlString != v11)
    {

      v4->_sqlString = (NSString *)-[NSString copy](v11, "copy");
    }
  }

  double v9 = *(void *)(v3 + 56);
  if (v9 == v3)
  {
    else {
      unint64_t v10 = 0LL;
    }
  }

  else if (v9)
  {
    unint64_t v10 = *(__CFString **)(v9 + 80);
  }

  else
  {
    unint64_t v10 = 0LL;
  }

  id v11 = -[NSSQLManyToMany inverseOrderColumnName](a2);
  if ((v10 != 0LL) == (v11 == 0LL)) {
    return 0LL;
  }
  if (!v10) {
    return 1LL;
  }
  uint64_t result = -[__CFString isEqualToString:](v10, "isEqualToString:", v11);
  if ((_DWORD)result) {
    return 1LL;
  }
  return result;
}

          unint64_t v21 = CFNumberCreate(0LL, v17, &valuePtr);
LABEL_18:
          uint64_t result = v21;
          break;
      }
    }
  }

  return result;
}

  int v14 = *(_DWORD *)(a1 + 8);
LABEL_18:
  id v16 = *(const __CFString **)(a1 + 16);
  uint64_t v17 = ~(unint64_t)v16;
  if (v16 == a2 || v17 == (void)a2)
  {
    unint64_t v19 = (const __CFString *)((char *)v16 - 1);
    if (v14 >= 1)
    {
      uint64_t v20 = *(const __CFString ***)(a1 + 40);
      unint64_t v21 = v14;
      id v22 = *(const __CFString **)(a1 + 16);
LABEL_25:
      uint64_t v23 = -(uint64_t)v22;
      id v22 = v19;
      unint64_t v24 = v14;
      uint64_t v25 = *(const __CFString ***)(a1 + 40);
      do
      {
        if (v22 == *v25 || v23 == (void)*v25)
        {
          unint64_t v19 = (const __CFString *)((char *)v22 - 1);
          goto LABEL_25;
        }

        ++v25;
        --v24;
      }

      while (v24);
      do
      {
        uint64_t v27 = v22;
        if (v16 == *v20 || (uint64_t v27 = (const __CFString *)v23, (const __CFString *)v17 == *v20)) {
          *uint64_t v20 = v27;
        }
        ++v20;
        --v21;
      }

      while (v21);
      unint64_t v19 = v22;
    }

    *(void *)(a1 + 16) = v19;
  }

  BOOL v28 = v38;
  if ((v38 & 0x80000000) != 0 || (int)v38 >= v14)
  {
    id v29 = [NSString stringWithUTF8String:"illegal OOB dictionary calculation"];
    _NSCoreDataLog(17LL, v29, v30, v31, v32, v33, v34, v35, v37);
    uint64_t v36 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      LOWORD(v37) = 0;
      _os_log_fault_impl( &dword_186681000,  v36,  OS_LOG_TYPE_FAULT,  "CoreData: illegal OOB dictionary calculation",  (uint8_t *)&v37,  2u);
    }
  }

  else
  {
    *(void *)(*(void *)(a1 + 40) + 8LL * v3_Block_object_dispose(va, 8) = a2;
    *(void *)(*(void *)(a1 + 48) + 8 * v2_Block_object_dispose(va, 8) = a3;
  }

  ++*(_DWORD *)a1;
}

    objc_exception_throw((id)[v11 exceptionWithName:v12 reason:v13 userInfo:0]);
    if (v15 == 1)
    {
      objc_begin_catch(v14);

      objc_exception_rethrow();
      __break(1u);
      JUMPOUT(0x18689B5F8LL);
    }

    _Unwind_Resume(v14);
  }

  -[NSFetchIndexElementDescription _validateCollationType:forProperty:](self, collationType, property);
  v16.receiver = self;
  v16.super_class = (Class)&OBJC_CLASS___NSFetchIndexElementDescription;
  double v8 = -[NSFetchIndexElementDescription init](&v16, sel_init);
  if (v8)
  {
    if (-[NSPropertyDescription _propertyType](property, "_propertyType") == 5 || !v8->_indexDescription)
    {
      v8->_property = property;
      double v9 = *(_DWORD *)&v8->_indexElementDescriptionFlags | 2;
    }

    else
    {
      v8->_property = property;
      double v9 = *(_DWORD *)&v8->_indexElementDescriptionFlags & 0xFFFFFFFD;
    }

    v8->_indexElementDescriptionFlags = (__indexElementDescriptionFlags)v9;
    v8->_propertyName = -[NSPropertyDescription name](property, "name");
    v8->_collationType = collationType;
    *(_DWORD *)&v8->_indexElementDescriptionFlags |= 1u;
  }

  return v8;
}

          v4->_property = 0LL;
          double v12 = *(_DWORD *)&v4->_indexElementDescriptionFlags & 0xFFFFFFFD;
LABEL_23:
          v4->_indexElementDescriptionFlags = (__indexElementDescriptionFlags)v12;
          v4->_collationType = [a3 decodeIntegerForKey:@"NSFetchIndexElementType"];
          v4->_indexElementDescriptionFlags = (__indexElementDescriptionFlags)(*(_DWORD *)&v4->_indexElementDescriptionFlags & 0xFFFFFFFE | [a3 decodeBoolForKey:@"NSAscending"]);
          goto LABEL_24;
        }

        objc_msgSend( a3,  "failWithError:",  objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  4866,  &unk_189F03FB8));

LABEL_20:
        uint64_t v4 = 0LL;
LABEL_24:
        v16((uint64_t)&v14);
        return v4;
      }

      if (v5) {
        double v8 = (void *)v5[3];
      }
      else {
        double v8 = 0LL;
      }
      [v8 addObject:v7];
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();
      if ((isKindOfClass & 1) != 0) {
        unint64_t v10 = &unk_189F03F90;
      }
      else {
        unint64_t v10 = &unk_189F03F68;
      }
      if (v5 != 0LL && (isKindOfClass & 1) != 0)
      {
        if (v5[1] || v5[2]) {
          goto LABEL_13;
        }
        unint64_t v10 = &unk_189F03F90;
      }
    }

    objc_msgSend( a3,  "failWithError:",  objc_msgSend(MEMORY[0x189607870], "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], 4866, v10));

    goto LABEL_20;
  }

  return v4;
}

    LOBYTE(v_Block_object_dispose(va, 8) = 1;
  }

  return v8;
}

void sub_1866AFEC4(_Unwind_Exception *a1)
{
}

void _PFCMT_RemoveValue(void *a1, void *a2)
{
  if (a2)
  {
    if ([a2 isTemporaryID])
    {
      uint64_t v4 = (__CFDictionary *)a1[2];
      if (!v4) {
        return;
      }
LABEL_10:
      CFDictionaryRemoveValue(v4, a2);
      return;
    }

    unsigned int v5 = _PFModelMapSlotForEntity(a1[7], (void *)[a2 entity]);
    if ((v5 & 0x80000000) == 0)
    {
      uint64_t v6 = a1[4];
      if (v6)
      {
        uint64_t v4 = *(__CFDictionary **)(v6 + 8LL * v5);
        if (v4) {
          goto LABEL_10;
        }
      }
    }

    uint64_t v7 = a1[3];
    if (v7)
    {
      uint64_t v4 = *(__CFDictionary **)(v7 + 8LL * (v5 & 0x7FFFFFFF));
      if (v4) {
        goto LABEL_10;
      }
    }
  }

void _pvfk_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _PFFaultHandlerLookupRow(id a1, uint64_t a2, id *a3, int a4, uint64_t a5)
{
  uint64_t v109 = *MEMORY[0x1895F89C0];
  unsigned int v9 = *((_DWORD *)a1 + 4);
  if (((v9 >> 15) & 3 | 4) != 5 && (v9 & 0x80) == 0) {
    return;
  }
  unint64_t v10 = (void *)*((void *)a1 + 5);
  values = v10;
  id v11 = _PFEntityForManagedObject(a1);
  if (!v11)
  {
    objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"An NSManagedObject must have a valid NSEntityDescription." userInfo:0]);
    objc_exception_rethrow();
    goto LABEL_111;
  }

  double v12 = v11;
  int v13 = *((_DWORD *)a1 + 4);
  int v14 = [v10 isTemporaryID];
  char v15 = v14;
  int v97 = a4;
  if (v14)
  {
    if (!a2 || (unsigned __int8 v16 = atomic_load((unsigned __int8 *)(a2 + 48)), (v16 & 1) == 0))
    {
      uint64_t v17 = 0LL;
      int v18 = 0;
      int v19 = 0;
      id v99 = 0LL;
      goto LABEL_32;
    }
  }

  id v99 = 0LL;
  if ((v13 & 0x12) != 0)
  {
    uint64_t v17 = 0LL;
    int v18 = 0;
    int v19 = 0;
    goto LABEL_32;
  }

  uint64_t v20 = -[NSManagedObjectContext lockObjectStore](a2);
  if (a2)
  {
    unint64_t v21 = (void *)MEMORY[0x186E3E5D8](v20);
    id v22 = (void *)[*(id *)(a2 + 32) newValuesForObjectWithID:values withContext:a2 error:&v99];
    id v23 = v99;
    objc_autoreleasePoolPop(v21);
    if (v22)
    {
      if (*((_BYTE *)a1 + 17) & 2) != 0 || ([values isTemporaryID])
      {
        int v18 = 0;
        int v19 = 0;
      }

      else
      {
        uint64_t v26 = _PFStackAllocatorCreate((unint64_t *)buf, 1024LL);
        CFArrayRef v27 = CFArrayCreate(v26, (const void **)&values, 1LL, 0LL);
        objc_msgSend( *(id *)(a2 + 32),  "managedObjectContextDidRegisterObjectsWithIDs:generation:",  v27,  objc_msgSend((id)a2, "_queryGenerationToken"));
        if (v108 && v27) {
          CFRelease(v27);
        }
        int v18 = 0;
        int v19 = 0;
        *((_DWORD *)a1 + 4) |= 0x200u;
      }

      goto LABEL_29;
    }
  }

  if (v99 && [v99 code] != 133000)
  {
    if (objc_msgSend((id)objc_msgSend((id)a2, "persistentStoreCoordinator"), "delegate"))
    {
      [(id)a2 _setFaultingError:v99];
      uint64_t v24 = [(id)a2 persistentStoreCoordinator];
      uint64_t v25 = -[NSPersistentStoreCoordinator _handleFaultingError:fromContext:](v24, (uint64_t)v99, a2);
      if (v25 != 1)
      {
        if (v25 != 2)
        {
          objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58] reason:@"NSPersistentStoreCoordinatorDelegate returned an illegal NSPersistentStoreCoordinatorDelegateErrorAction" userInfo:0]);
          goto LABEL_111;
        }

        goto LABEL_98;
      }
    }

    else
    {
      uint64_t v74 = getprogname();
      if (v74 && (!strncmp("avatarsd", v74, 8uLL) || !strncmp("CalendarAgent", v74, 0xDuLL))) {
        [(id)a2 _setFaultingError:v99];
      }
    }

    int v18 = 0;
    id v22 = 0LL;
    int v28 = 1;
    int v19 = 1;
    goto LABEL_30;
  }

  if ((v15 & 1) == 0 && (*((_BYTE *)a1 + 16) & 0x24) == 0)
  {
    if (a2)
    {
      if ((*(_BYTE *)(a2 + 41) & 0x10) != 0) {
        goto LABEL_98;
      }
      int v72 = a4;
      if (!a4) {
        goto LABEL_99;
      }
      uint64_t v73 = [(id)a2 _delegate];
    }

    else
    {
      int v72 = a4;
      if ((a4 & 1) == 0) {
        goto LABEL_99;
      }
      uint64_t v73 = [*((id *)a1 + 4) _delegate];
    }

    uint64_t v75 = (void *)v73;
    if (a5 == 0x7FFFFFFFFFFFFFFFLL) {
      uint64_t v76 = 0LL;
    }
    else {
      uint64_t v76 = *(void *)(v12[12] + 24LL + 8 * a5);
    }
    if (v73 && (objc_opt_respondsToSelector() & 1) != 0)
    {
      unint64_t v77 = [v75 context:a2 shouldHandleInaccessibleFault:a1 forObjectID:values andTrigger:v76];
      if (v77 > 1)
      {
        if (v77 != 2)
        {
          if (v77 != 3)
          {
            objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58] reason:@"An NSManagedObjectContext delegate returned an illegal result" userInfo:0]);
            goto LABEL_111;
          }

          int v28 = 1;
          _NSCoreDataLog( 1LL,  (uint64_t)@"An NSManagedObjectContext delegate overrode fault handling behavior to silently substitute nil/0 for all property values for the object with ID '%@'.  This is very unwise.",  v78,  v79,  v80,  v81,  v82,  v83,  (uint64_t)values);
          int v18 = 0;
          int v19 = 0;
          id v22 = 0LL;
          goto LABEL_30;
        }

        goto LABEL_98;
      }

LABEL_99:
      *((_DWORD *)a1 + 4) = *((_DWORD *)a1 + 4) & 0xFFFC7FFF | 0x8000;
      uint64_t v96 = @"NSAffectedObjectsErrorKey";
      id v84 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObject:", a1));
      if (v72)
      {
        uint64_t v93 = (const __CFString *)values;
        if (!values) {
          uint64_t v93 = @"<UNKNOWN objectID>";
        }
        uint64_t v94 = [NSString stringWithFormat:@"CoreData could not fulfill a fault for '%@'", v93];
        id v95 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189607678],  133000LL,  v94,  v84);
        objc_exception_throw(v95);
        goto LABEL_111;
      }

      if (a3)
      {
        if (v99)
        {

          id v99 = 0LL;
        }

        id v85 = objc_alloc(MEMORY[0x189607870]);
        int v28 = 0;
        int v18 = 0;
        int v19 = 0;
        id v22 = 0LL;
        id v99 = (id)[v85 initWithDomain:*MEMORY[0x189607460] code:133000 userInfo:v84];
      }

      else
      {
        int v28 = 0;
        int v18 = 0;
        int v19 = 0;
        id v22 = 0LL;
      }

      goto LABEL_30;
    }

    if (([(id)a2 shouldHandleInaccessibleFault:a1 forObjectID:values triggeredByProperty:v76] & 1) == 0) {
      goto LABEL_99;
    }
LABEL_98:
    int v19 = 0;
    id v22 = 0LL;
    int v28 = 1;
    int v18 = 1;
    goto LABEL_30;
  }

  int v18 = 0;
  int v19 = 0;
  id v22 = 0LL;
LABEL_29:
  int v28 = 1;
LABEL_30:
  -[NSManagedObjectContext unlockObjectStore](a2);
  if (!v28)
  {
    int v31 = 0;
    LOBYTE(v34) = 1;
    goto LABEL_56;
  }

  uint64_t v17 = v22;
LABEL_32:
  uint64_t v29 = [v17 knownKeyValuesPointer];
  if (v17) {
    BOOL v30 = v29 == 0;
  }
  else {
    BOOL v30 = 0;
  }
  if (v30)
  {
    uint64_t v29 = -[NSManagedObjectContext lockObjectStore](a2);
    int v31 = 1;
  }

  else
  {
    int v31 = 0;
  }

  if (v19) {
    int v32 = 1;
  }
  else {
    int v32 = v18;
  }
  if (v32 == 1)
  {
    int v33 = *((_DWORD *)a1 + 4);
    BOOL v34 = (v33 & 0x2000) == 0;
    if ((v33 & 0x2000) == 0)
    {
      v33 |= 0x2000u;
      *((_DWORD *)a1 + 4) = v33;
    }

    if ((v33 & 0x38000) == 0x28000) {
      -[NSFaultHandler turnObject:intoFaultWithContext:](_insertion_fault_handler, (uint64_t)a1, a2);
    }
  }

  else
  {
    BOOL v34 = 0;
  }

  _PFFaultHandlerFulfillFault(v29, (uint64_t)a1, a2, v17, v32 ^ 1);
  if (v32)
  {
    if (![a1 managedObjectContext]) {
      -[NSManagedObjectContext _forceRegisterLostFault:](a2, a1);
    }
    if (v18) {
      [(id)a2 deleteObject:a1];
    }
    if (v34)
    {
      LOBYTE(v34) = 0;
      *((_DWORD *)a1 + 4) &= ~0x2000u;
    }
  }

  else
  {
    LOBYTE(v34) = 0;
    int v19 = 0;
  }

  id v22 = v17;
LABEL_56:
  BOOL v35 = v31 != 0;
  if (v22) {

  }
  if (v35) {
    -[NSManagedObjectContext unlockObjectStore](a2);
  }
  id v36 = v99;
  if (v19 != 0 || v34)
  {
    id v37 = v99;
    if (!v99)
    {
      if (!a3) {
        return;
      }
      uint64_t v38 = [NSString stringWithUTF8String:"faulting failed to record an error for an serious condition"];
      _NSCoreDataLog(17LL, v38, v39, v40, v41, v42, v43, v44, (uint64_t)v96);
      uint64_t v45 = __pflogFaultLog;
      if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
        return;
      }
      *(_WORD *)buf = 0;
      uint64_t v46 = "CoreData: faulting failed to record an error for an serious condition";
      uint64_t v47 = (os_log_s *)v45;
      uint32_t v48 = 2;
LABEL_73:
      _os_log_fault_impl(&dword_186681000, v47, OS_LOG_TYPE_FAULT, v46, buf, v48);
      return;
    }

    if (a3)
    {
      *a3 = v99;
      return;
    }

    if (v97)
    {
      [v99 userInfo];
      _NSCoreDataLog( 1LL,  (uint64_t)@"Unhandled error occurred during faulting: %@ (%@)",  v49,  v50,  v51,  v52,  v53,  v54,  (uint64_t)v37);
      if ((objc_msgSend((id)objc_msgSend(v99, "domain"), "isEqual:", @"NSSQLiteErrorDomain") & 1) != 0
        || [v99 code] == 134071)
      {
        uint64_t v55 = [NSString stringWithUTF8String:"Unhandled error (%@, %ld) occurred during faulting and was ignored: %@"];
        uint64_t v56 = [v99 domain];
        [v99 code];
        _NSCoreDataLog(17LL, v55, v57, v58, v59, v60, v61, v62, v56);
        uint64_t v63 = __pflogFaultLog;
        if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
          return;
        }
        uint64_t v64 = [v99 domain];
        uint64_t v65 = [v99 code];
        *(_DWORD *)buf = 138412802;
        uint64_t v104 = v64;
        __int16 v105 = 2048;
        uint64_t v106 = v65;
        __int16 v107 = 2112;
        id v108 = v99;
        uint64_t v46 = "CoreData: Unhandled error (%@, %ld) occurred during faulting and was ignored: %@";
        uint64_t v47 = (os_log_s *)v63;
        uint32_t v48 = 32;
        goto LABEL_73;
      }

      uint64_t v86 = (void *)NSString;
      uint64_t v87 = [v99 domain];
      uint64_t v88 = [v99 code];
      uint64_t v89 = [v86 stringWithFormat:@"Unhandled error (%@, %ld) occurred during faulting and was thrown: %@", v87, v88, v99];
      uint64_t v90 = [v99 code];
      uint64_t v101 = *MEMORY[0x189607798];
      id v102 = v99;
      uint64_t v91 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:&v102 forKeys:&v101 count:1];
      id v92 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  v90,  v89,  v91);
      -[_NSCoreDataException _setDomain:]((uint64_t)v92, (void *)[v99 domain]);
      objc_exception_throw(v92);
LABEL_111:
      __break(1u);
      return;
    }

    if ([v99 code] != 133000) {
      _NSCoreDataLog( 1LL,  (uint64_t)@"Client ill advisedly ignored an I/O or unknown error from faulting: %@",  v66,  v67,  v68,  v69,  v70,  v71,  (uint64_t)v99);
    }
  }

void sub_1866B11FC(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866B1210LL);
  }

  JUMPOUT(0x1866B1238LL);
}

void sub_1866B1220()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x1866B1228LL);
  }
  JUMPOUT(0x1866B1238LL);
}

id sub_1866B1230(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1866B1234LL);
  }
  objc_terminate();
  return -[NSPersistentStoreCoordinator newValuesForObjectWithID:withContext:error:](v2, v3, v4, v5, v6);
}

void sub_1866B1518( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_1866B16AC(_Unwind_Exception *a1)
{
}

LABEL_30:
    int v13 = 0LL;
    goto LABEL_28;
  }

  uint64_t v24 = exception;
  objc_exception_throw(exception);
  __break(1u);
  return result;
}

    uint64_t v40 = calloc(__count, 4uLL);
    uint64_t v58 = 0u;
    uint64_t v59 = 0u;
    uint64_t v60 = 0u;
    uint64_t v61 = 0u;
    uint64_t v41 = [a3 countByEnumeratingWithState:&v58 objects:v72 count:16];
    if (v41)
    {
      uint64_t v42 = v41;
      uint64_t v43 = *(void *)v59;
      do
      {
        for (uint64_t j = 0LL; j != v42; ++j)
        {
          if (*(void *)v59 != v43) {
            objc_enumerationMutation(a3);
          }
          uint64_t v45 = objc_msgSend((id)objc_msgSend(*(id *)(*((void *)&v58 + 1) + 8 * j), "entity"), "name");
          uint64_t v46 = (void *)[v31 objectForKey:v45];
          uint64_t v47 = [v33 indexForKey:v45];
          ++v40[v47];
          objc_msgSend(v32, "addObject:", objc_msgSend(v46, "objectAtIndex:"));
        }

        uint64_t v42 = [a3 countByEnumeratingWithState:&v58 objects:v72 count:16];
      }

      while (v42);
    }

    free(v40);
    uint64_t v20 = v55;
  }

  else
  {
    int v32 = 0LL;
    if (a4) {
      *a4 = v67;
    }
  }

  return v32;
}

                      ++v14;
                    }

                    while ([v12 count] > v14);
                  }
                }

                uint64_t v2 = v63;
                unsigned int v9 = v64;
                double v8 = v65;
                if (!v13)
                {
                  uint64_t v45 = (void *)MEMORY[0x189603F70];
                  uint64_t v46 = *MEMORY[0x189603A60];
                  uint64_t v47 = [NSString stringWithFormat:@"Can't find property named %@", v62];
                  uint64_t v93 = @"Property name";
                  uint64_t v94 = v62;
                  uint32_t v48 = (void *)MEMORY[0x189603F68];
                  uint64_t v49 = &v94;
                  uint64_t v50 = &v93;
LABEL_75:
                  uint64_t v41 = [v48 dictionaryWithObjects:v49 forKeys:v50 count:1];
                  uint64_t v43 = v45;
                  uint64_t v44 = v46;
                  for (uint64_t k = (const __CFString *)v47; ; uint64_t k = (const __CFString *)v53)
                  {
LABEL_76:
                    objc_exception_throw((id)[v43 exceptionWithName:v44 reason:k userInfo:v41]);
LABEL_77:
                    uint64_t v51 = (void *)MEMORY[0x189603F70];
                    uint64_t v52 = *MEMORY[0x189603A60];
                    uint64_t v53 = [NSString stringWithFormat:@"Uniqueness constraints must be defined at the highest level possible. All properties in constraint %@ are defined on parent entity.", v67, v54, v55];
                    id v84 = @"Problem constraint";
                    id v85 = v66;
                    uint64_t v41 = [MEMORY[0x189603F68] dictionaryWithObjects:&v85 forKeys:&v84 count:1];
                    uint64_t v43 = v51;
                    uint64_t v44 = v52;
                  }
                }
              }

              else
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) == 0)
                {
                  if (!objc_msgSend( (id)objc_msgSend(v2, "propertiesByName"),  "objectForKey:",  -[__CFString name](v11, "name")))
                  {
                    id v23 = -[__CFString name](v11, "name");
                    uint64_t v54 = v11;
                    uint64_t v55 = [v2 name];
                    _NSCoreDataLog( 1LL,  (uint64_t)@"Can't find property description '%@' %@ while setting unique constraints on entity '%@'",  v24,  v25,  v26,  v27,  v28,  v29,  v23);
                  }

            LOBYTE(v6) = 1;
          }
        }
      }
    }
  }

  return v6;
}

        int v97 = v10;
        id v23 = (void *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v10, "arguments"), "objectAtIndex:", 0),  "constantValue"),  "componentsSeparatedByString:",  @".");
        if ([v23 count] != 1)
        {
          uint64_t v93 = v6;
          uint64_t v94 = a3;
          BOOL v35 = (void *)objc_msgSend((id)objc_msgSend(a3, "objectForKey:", @"entity"), "entityDescription");
          uint64_t v91 = [v23 count];
          id v36 = v91 - 1;
          uint64_t v90 = objc_msgSend((id)objc_msgSend(v23, "lastObject"), "hasPrefix:", @"@");
          id v37 = 0LL;
          uint64_t v38 = 0;
          while (1)
          {
            uint64_t v39 = (void *)[v23 objectAtIndex:v37];
            if (!v35) {
              break;
            }
            uint64_t v40 = (void *)objc_msgSend((id)objc_msgSend(v35, "propertiesByName"), "objectForKey:", v39);
            if (!v40) {
              break;
            }
            uint64_t v41 = v40;
            if ([v40 _isAttribute])
            {
              if (v36 == v37) {
                goto LABEL_64;
              }
              uint64_t v43 = v90;
              if (v91 - 2 != v37) {
                uint64_t v43 = 0;
              }
              if ((v43 & 1) != 0) {
                goto LABEL_64;
              }
              uint64_t v87 = @"Can't generate SQL for keypath %@ : invalid attribute name location";
LABEL_106:
              a3 = v94;
              id v5 = v95;
LABEL_107:
              [a3 setObject:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", v87, objc_msgSend(v23, "componentsJoinedByString:", @".")), 0), @"NSUnderlyingException" forKey];
              unint64_t v10 = v97;
              goto LABEL_108;
            }

            if ([v41 _isRelationship])
            {
              BOOL v35 = (void *)[v41 destinationEntity];
              uint64_t v42 = [v41 isToMany];
              if ((v42 & v38 & 1) != 0)
              {
                uint64_t v87 = @"Can't generate SQL for keypath %@ : multiple to many keypath components";
                goto LABEL_106;
              }

              v38 |= v42;
            }

            if (++v37 > v36) {
              goto LABEL_64;
            }
          }

          if (![v39 hasPrefix:@"@"])
          {
            a3 = v94;
            id v5 = v95;
            uint64_t v87 = @"Can't generate SQL for keypath %@ : invalid keypath";
            goto LABEL_107;
          }

          if (v36 != v37)
          {
            uint64_t v87 = @"Can't generate SQL for keypath %@ : invalid location of keypath aggregate function";
            goto LABEL_106;
          }

    id v22 = 0LL;
    id v23 = v58;
    if (!v58)
    {
      uint64_t v6 = v55;
LABEL_73:
      uint64_t v24 = v65;
      goto LABEL_74;
    }

    uint64_t v24 = v65;
    if (v65)
    {
      uint64_t v25 = -[NSManagedObjectModel entitiesByName](v58, "entitiesByName");
      uint64_t v26 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FC8]), "initWithCapacity:", objc_msgSend(v65, "count"));
      CFArrayRef v27 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FE0]), "initWithCapacity:", objc_msgSend(v65, "count"));
      uint64_t v80 = 0u;
      uint64_t v81 = 0u;
      uint64_t v82 = 0u;
      uint64_t v83 = 0u;
      int v28 = [v65 countByEnumeratingWithState:&v80 objects:v95 count:16];
      if (v28)
      {
        uint64_t v29 = v28;
        BOOL v30 = *(void *)v81;
        uint64_t v60 = *(void *)v81;
        uint64_t v62 = v25;
        do
        {
          int v31 = 0LL;
          uint64_t v64 = v29;
          do
          {
            if (*(void *)v81 != v30) {
              objc_enumerationMutation(v24);
            }
            int v32 = *(void *)(*((void *)&v80 + 1) + 8 * v31);
            int v33 = (void *)MEMORY[0x186E3E5D8]();
            for (uint64_t k = -[NSDictionary objectForKey:](v25, "objectForKey:", v32); ; uint64_t k = (id)[v35 superentity])
            {
              BOOL v35 = k;
              objc_msgSend(v27, "addObject:", objc_msgSend(k, "name"));
              if (![v35 superentity]) {
                break;
              }
            }

            if (!objc_msgSend(v26, "valueForKey:", objc_msgSend(v35, "name")))
            {
              id v36 = (void *)[v35 copy];
              id v37 = objc_alloc_init(MEMORY[0x189603FA8]);
              contexta = v36;
              +[NSManagedObjectModel _deepCollectEntitiesInArray:entity:]( (uint64_t)&OBJC_CLASS___NSManagedObjectModel,  v37,  v36);
              uint64_t v78 = 0u;
              uint64_t v79 = 0u;
              uint64_t v76 = 0u;
              unint64_t v77 = 0u;
              uint64_t v38 = [v37 countByEnumeratingWithState:&v76 objects:v94 count:16];
              if (v38)
              {
                uint64_t v39 = v38;
                uint64_t v40 = *(void *)v77;
                do
                {
                  for (m = 0LL; m != v39; ++m)
                  {
                    if (*(void *)v77 != v40) {
                      objc_enumerationMutation(v37);
                    }
                    objc_msgSend( v26,  "setObject:forKey:",  *(void *)(*((void *)&v76 + 1) + 8 * m),  objc_msgSend(*(id *)(*((void *)&v76 + 1) + 8 * m), "name"));
                  }

                  uint64_t v39 = [v37 countByEnumeratingWithState:&v76 objects:v94 count:16];
                }

                while (v39);
              }

              uint64_t v29 = v64;
              uint64_t v24 = v65;
              BOOL v30 = v60;
              uint64_t v25 = v62;
            }

            objc_autoreleasePoolPop(v33);
            ++v31;
          }

          while (v31 != v29);
          uint64_t v29 = [v24 countByEnumeratingWithState:&v80 objects:v95 count:16];
        }

        while (v29);
      }

      uint64_t v74 = 0u;
      uint64_t v75 = 0u;
      int v72 = 0u;
      uint64_t v73 = 0u;
      uint64_t v42 = (void *)[v26 allValues];
      uint64_t v43 = [v42 countByEnumeratingWithState:&v72 objects:v93 count:16];
      if (v43)
      {
        uint64_t v44 = v43;
        uint64_t v45 = *(void *)v73;
        do
        {
          for (n = 0LL; n != v44; ++n)
          {
            if (*(void *)v73 != v45) {
              objc_enumerationMutation(v42);
            }
            uint64_t v47 = *(void **)(*((void *)&v72 + 1) + 8 * n);
            if ((objc_msgSend(v27, "containsObject:", objc_msgSend(v47, "name")) & 1) == 0)
            {
              -[NSEntityDescription _removeSubentity:]((id *)[v47 superentity], v47);
              objc_msgSend(v26, "removeObjectForKey:", objc_msgSend(v47, "name"));
            }
          }

          uint64_t v44 = [v42 countByEnumeratingWithState:&v72 objects:v93 count:16];
        }

        while (v44);
      }

      id v22 = -[NSManagedObjectModel _initWithEntities:]( [NSManagedObjectModel alloc],  "_initWithEntities:",  [v26 allValues]);
      objc_msgSend(v22, "setVersionIdentifiers:", -[NSManagedObjectModel versionIdentifiers](v58, "versionIdentifiers"));
      uint32_t v48 = -[NSManagedObjectModel fetchRequestTemplatesByName](v58, "fetchRequestTemplatesByName");
      uint64_t v68 = 0u;
      uint64_t v69 = 0u;
      uint64_t v70 = 0u;
      uint64_t v71 = 0u;
      uint64_t v49 = -[NSDictionary countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v68,  v92,  16LL);
      if (v49)
      {
        uint64_t v50 = v49;
        uint64_t v51 = *(void *)v69;
        do
        {
          for (iuint64_t i = 0LL; ii != v50; ++ii)
          {
            if (*(void *)v69 != v51) {
              objc_enumerationMutation(v48);
            }
            uint64_t v53 = *(void *)(*((void *)&v68 + 1) + 8 * ii);
            uint64_t v54 = -[NSDictionary objectForKey:](v48, "objectForKey:", v53);
            if (objc_msgSend(v26, "objectForKey:", objc_msgSend((id)objc_msgSend(v54, "entity"), "name"))) {
              [v22 setFetchRequestTemplate:v54 forName:v53];
            }
          }

          uint64_t v50 = -[NSDictionary countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v68,  v92,  16LL);
        }

        while (v50);
      }

      uint64_t v6 = v55;
      id v23 = v58;
      goto LABEL_73;
    }

    uint64_t v6 = v55;
  }

  else
  {
    id v23 = 0LL;
    uint64_t v24 = 0LL;
    id v22 = 0LL;
  }

    objc_msgSend( a3,  "failWithError:",  objc_msgSend(MEMORY[0x189607870], "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], 4866, v9));

    id v4 = 0LL;
    goto LABEL_31;
  }

  return v4;
}

  LOBYTE(v32) = 1;
  return v32;
}

void sub_1866B1968(_Unwind_Exception *a1)
{
}

id _executeNewRowValuesForObjectFaultRequest(void *a1)
{
  unint64_t v1 = a1;
  if (a1)
  {
    uint64_t v2 = (const void *)a1[11];
    a1 = (void *)a1[4];
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  [a1 stalenessInterval];
  double v4 = v3;
  if (v3 <= 0.0) {
    double v5 = *(double *)&NSSQLDistantPastTimeInterval;
  }
  else {
    double v5 = CFAbsoluteTimeGetCurrent() - v3;
  }
  if (v4 == 0.0) {
    double v6 = *(double *)&NSSQLDistantFutureTimeInterval;
  }
  else {
    double v6 = v5;
  }
  id v20 = -[NSPersistentStoreCache rowForObjectID:afterTimestamp:]( (os_unfair_lock_s *)objc_msgSend(v1, "rowCache", v5),  v2,  v6);
  if (!v20) {
    id v20 = _executeObjectFaultRequest((uint64_t)v1);
  }
  if ((int)-[NSSQLStoreRequestContext debugLogLevel]((uint64_t)v1) < 3)
  {
    if ((int)-[NSSQLStoreRequestContext debugLogLevel]((uint64_t)v1) >= 1) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"fault fulfilled from database for : %@",  v13,  v14,  v15,  v16,  v17,  v18,  (uint64_t)v2);
    }
  }

  else
  {
    _NSCoreDataLog( 4LL,  (uint64_t)@"fault fulfilled from database for : %@ with row values: %@",  v7,  v8,  v9,  v10,  v11,  v12,  (uint64_t)v2);
  }

  return v20;
}

NSSQLFetchRequestContext *_executeObjectFaultRequest(uint64_t a1)
{
  void v58[2] = *MEMORY[0x1895F89C0];
  uint64_t v2 = (void *)MEMORY[0x186E3E5D8]();
  if (!a1 || (double v3 = *(void **)(a1 + 88)) == 0LL)
  {
    uint64_t v5 = [NSString stringWithUTF8String:"_executeObjectFaultRequest passed a nil objectID"];
    _NSCoreDataLog(17LL, v5, v6, v7, v8, v9, v10, v11, v52);
    uint64_t v12 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl( &dword_186681000,  v12,  OS_LOG_TYPE_FAULT,  "CoreData: _executeObjectFaultRequest passed a nil objectID",  buf,  2u);
    }

    goto LABEL_17;
  }

  if ([*(id *)(a1 + 88) isTemporaryID]) {
    goto LABEL_17;
  }
  if (PFInstrumentsRecordingEnabled())
  {
    v53[0] = MEMORY[0x1895F87A8];
    v53[1] = 3221225472LL;
    v53[2] = ___executeObjectFaultRequest_block_invoke;
    v53[3] = &unk_189EA8DB8;
    v53[4] = v3;
    os_signpost_id_t v4 = ___executeObjectFaultRequest_block_invoke((uint64_t)v53);
  }

  else
  {
    os_signpost_id_t v4 = 0LL;
  }

  Request = -[NSSQLObjectFaultRequestContext createFetchRequestContext]((NSSQLFetchRequestContext *)a1);
  -[NSSQLStoreRequestContext setConnection:]((uint64_t)Request, *(void **)(a1 + 24));
  uint64_t v14 = (const void *)-[NSSQLCore entityForObjectID:](*(void *)(a1 + 8), v3);
  if (!v14)
  {
LABEL_17:
    objc_autoreleasePoolPop(v2);
    return 0LL;
  }

  uint64_t v15 = -[NSSQLiteConnection statementCacheForEntity:](*(void *)(a1 + 24), v14);
  uint64_t v16 = v15;
  if (v15)
  {
    p_isa = &v15->_faultingStatementCache->super.isa;
    uint64_t v18 = [v3 _referenceData64];
    if (p_isa)
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(p_isa, "bindVariables"), "objectAtIndex:", 0), "setInt64:", v18);
      -[NSSQLFetchRequestContext setFetchStatement:](Request, "setFetchStatement:", p_isa);
      if (Request) {
        goto LABEL_13;
      }
LABEL_37:
      uint32_t v48 = p_isa;
      __break(1u);
      goto LABEL_38;
    }
  }

  else
  {
    uint64_t v18 = [v3 _referenceData64];
  }

  uint64_t v46 = -[NSSQLFetchRequestContext fetchStatement](Request, "fetchStatement");
  p_isa = (void *)v46;
  if (v46) {
    [*(id *)(v46 + 16) removeAllObjects];
  }
  uint64_t v47 = -[NSSQLBindVariable initWithInt64:sqlType:]( objc_alloc(&OBJC_CLASS___NSSQLBindVariable),  "initWithInt64:sqlType:",  v18,  2LL);
  -[NSSQLiteStatement addBindVariable:]((uint64_t)p_isa, v47);

  -[NSSQLiteStatementCache cacheFaultingStatement:](v16, p_isa);
  if (!Request) {
    goto LABEL_37;
  }
LABEL_13:
  Request->_isUsingCachedStatement = 1;
  int v19 = p_isa;
  int v20 = 0;
  unint64_t v21 = 0LL;
  Request->_fetchPlan->flags = ($C6D29F7D67899FE11DE7F8953A7C3E5F)(*(_DWORD *)&Request->_fetchPlan->flags & 0xFFFFFFE3 | 8);
  while (!v21 && v20 != 1)
  {
    unint64_t v21 = _newFetchedRowsForRequest((uint64_t)Request);
    -[NSSQLStoreRequestContext setConnection:]((uint64_t)Request, 0LL);

    Request = 0LL;
    ++v20;
  }

  uint64_t v23 = -[_PFArray count](v21, "count");
  Request = (NSSQLFetchRequestContext *)-[_PFArray lastObject](v21, "lastObject");
  uint64_t v24 = Request;

  if (Request) {
    -[NSSQLFetchRequestContext knownKeyValuesPointer](Request, "knownKeyValuesPointer");
  }
  if (!v23)
  {

    uint64_t v41 = (void *)MEMORY[0x189607870];
    uint64_t v55 = @"objectID";
    uint64_t v56 = v3;
    uint64_t v42 = [MEMORY[0x189603F68] dictionaryWithObjects:&v56 forKeys:&v55 count:1];
    uint64_t v43 = (void *)[v41 errorWithDomain:*MEMORY[0x189607460] code:133000 userInfo:v42];
    objc_setProperty_nonatomic((id)a1, v44, v43, 40LL);
    goto LABEL_25;
  }

  if (v23 != 1)
  {
LABEL_38:
    if (!v4) {
      goto LABEL_43;
    }
    if (PFInstrumentsGetLog_logtoken != -1) {
      goto LABEL_44;
    }
    while (1)
    {
      if (v4 != -1LL)
      {
        uint64_t v49 = (os_log_s *)PFInstrumentsGetLog_coreDataInstrumentsLog;
        if (os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_186681000, v49, OS_SIGNPOST_INTERVAL_END, v4, "Fault", "", buf, 2u);
        }
      }

LABEL_43:
      _NSCoreDataLog( 1LL,  (uint64_t)@"Asked to fault objectID %@ but database returned multiple rows",  v25,  v26,  v27,  v28,  v29,  v30,  (uint64_t)v3);
      uint64_t v50 = [NSString stringWithFormat:@"failed to resolve fault to exactly one object for %@", v3];
      id v51 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  134071LL,  v50,  0LL);
      objc_exception_throw(v51);
      __break(1u);
LABEL_44:
      dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
    }
  }

  if ((objc_msgSend((id)-[NSSQLFetchRequestContext objectID](Request, "objectID"), "isEqual:", v3) & 1) == 0)
  {
    -[NSSQLFetchRequestContext objectID](Request, "objectID");
    _NSCoreDataLog( 1LL,  (uint64_t)@"Asked to fault objectID %@ but database returned row with different objectID %@",  v31,  v32,  v33,  v34,  v35,  v36,  (uint64_t)v3);
    id v37 = (void *)MEMORY[0x189607870];
    v57[0] = @"objectID";
    v57[1] = @"message";
    v58[0] = v3;
    v58[1] = [NSString stringWithFormat:@"Database appears corrupt.  Asked to fault objectID %@ but database returned row with different objectID %@", v3, -[NSSQLFetchRequestContext objectID](Request, "objectID")];
    uint64_t v38 = [MEMORY[0x189603F68] dictionaryWithObjects:v58 forKeys:v57 count:2];
    uint64_t v39 = (void *)[v37 errorWithDomain:*MEMORY[0x189607460] code:134071 userInfo:v38];
    objc_setProperty_nonatomic((id)a1, v40, v39, 40LL);

LABEL_25:
    Request = 0LL;
  }

  if (v4)
  {
    if (PFInstrumentsGetLog_logtoken != -1) {
      dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
    }
    if (v4 != -1LL)
    {
      uint64_t v45 = (os_log_s *)PFInstrumentsGetLog_coreDataInstrumentsLog;
      if (os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_186681000, v45, OS_SIGNPOST_INTERVAL_END, v4, "Fault", "", buf, 2u);
      }
    }
  }

  objc_autoreleasePoolPop(v2);
  return Request;
}

              if (-[__CFString _propertyType](v13, "_propertyType") == 4)
              {
                if (-[__CFString isToMany](v13, "isToMany"))
                {
                  uint64_t v39 = (void *)MEMORY[0x189603F70];
                  SEL v40 = *MEMORY[0x189603A60];
                  uint64_t v89 = @"Property name";
                  uint64_t v90 = -[__CFString name](v13, "name");
                  uint64_t v41 = [MEMORY[0x189603F68] dictionaryWithObjects:&v90 forKeys:&v89 count:1];
                  uint64_t k = @"Cannot create unique constraints for to-many relationships.";
LABEL_74:
                  uint64_t v43 = v39;
                  SEL v44 = v40;
                  goto LABEL_76;
                }
              }

              else if (-[__CFString _propertyType](v13, "_propertyType") != 2)
              {
                uint64_t v39 = (void *)MEMORY[0x189603F70];
                SEL v40 = *MEMORY[0x189603A60];
                uint64_t v87 = @"Property name";
                uint64_t v88 = -[__CFString name](v13, "name");
                uint64_t v41 = [MEMORY[0x189603F68] dictionaryWithObjects:&v88 forKeys:&v87 count:1];
                uint64_t k = @"Property type is not valid for unique constraints.";
                goto LABEL_74;
              }

              if (-[__CFString _propertyType](v13, "_propertyType") == 2
                && v13
                && -[__CFString superCompositeAttribute](v13, "superCompositeAttribute"))
              {
                uint64_t v30 = -[__CFString _qualifiedName](v13, "_qualifiedName");
              }

              else
              {
                uint64_t v30 = -[__CFString name](v13, "name");
              }

              [v67 addObject:v30];
              ++v10;
            }

            while (v10 != v8);
            uint64_t v31 = [v66 countByEnumeratingWithState:&v76 objects:v96 count:16];
            uint64_t v8 = v31;
          }

          while (v31);
LABEL_56:
          uint64_t v32 = (void *)v2[10];
          uint64_t i = v61;
          if (v32)
          {
            uint64_t v33 = (void *)[v32 propertiesByName];
            uint64_t v68 = 0u;
            uint64_t v69 = 0u;
            uint64_t v70 = 0u;
            uint64_t v71 = 0u;
            uint64_t v34 = [v67 countByEnumeratingWithState:&v68 objects:v86 count:16];
            if (v34)
            {
              uint64_t v35 = v34;
              uint64_t v36 = 0LL;
              id v37 = *(void *)v69;
              do
              {
                for (m = 0LL; m != v35; ++m)
                {
                  if (*(void *)v69 != v37) {
                    objc_enumerationMutation(v67);
                  }
                  if ([v33 valueForKey:*(void *)(*((void *)&v68 + 1) + 8 * m)]) {
                    ++v36;
                  }
                }

                uint64_t v35 = [v67 countByEnumeratingWithState:&v68 objects:v86 count:16];
              }

              while (v35);
            }

            else
            {
              uint64_t v36 = 0LL;
            }

            if (v36 == [v67 count]) {
              goto LABEL_77;
            }
          }
        }

        uint64_t v60 = [obj countByEnumeratingWithState:&v80 objects:v97 count:16];
        if (!v60)
        {
LABEL_71:

          *(void *)(v56 + 24) = v58;
          return;
        }
      }
    }
  }

      [(id)v11 awakeFromSnapshotEvents:64];
      if (v6 == ++v8)
      {
        uint64_t v6 = -[NSArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v37,  v53,  16LL);
        if (v6) {
          goto LABEL_6;
        }
        break;
      }
    }
  }

  id v22 = 1;
LABEL_46:
  if (v33) {
    [v33 drain];
  }
LABEL_50:
  if (error && !v22)
  {
    id v22 = 0;
    NSError *error = (NSError *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:133020 userInfo:0];
  }

  return v22;
}

    uint64_t v12 = 0LL;
    goto LABEL_16;
  }

  uint64_t v39 = *(_DWORD *)(a1 + 28);
  if (*v10 >= v39)
  {
    if ((*(_BYTE *)(a1 + 40) & 8) != 0)
    {
      uint64_t v42 = v39 + 0x4000;
      uint64_t v43 = (vm_map_t *)MEMORY[0x1895FBBE0];
      if (vm_allocate(*MEMORY[0x1895FBBE0], (vm_address_t *)address, 4LL * v42, 754974721)) {
        _NSCoreDataLog( 2LL,  (uint64_t)@"*** vm_allocate(size=%lld) failed (error code=%d)\n",  v44,  v45,  v46,  v47,  v48,  v49,  v42);
      }
      vm_copy(*v43, *(void *)(a1 + 56), 4LL * *(unsigned int *)(a1 + 28), *(vm_address_t *)address);
      MEMORY[0x186E3F154](*v43, *(void *)(a1 + 56), 4LL * *(unsigned int *)(a1 + 28));
      uint64_t v50 = *(void *)address;
      *(void *)(a1 + 56) = *(void *)address;
      *(_DWORD *)(v50 + 4 * v42 - 4) = 0;
      *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = v42;
      uint64_t v18 = *(char **)(a1 + 72);
    }

    else
    {
      SEL v40 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        SEL v40 = malloc_default_zone();
      }
      uint64_t v41 = malloc_zone_realloc(v40, *(void **)(a1 + 56), 4LL * (v39 + 512));
      *(void *)(a1 + 56) = v41;
      v41[v39 + 511] = 0;
      *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = v39 + 512;
    }
  }

  uint64_t result = memcpy(v18, a2, a3);
  *(void *)(a1 + 72) += a3;
  uint64_t v52 = *(_DWORD **)(a1 + 64);
  *(_DWORD *)(*(void *)(a1 + 56) + 4LL * (*v52)++) = a3;
  ++*(_DWORD *)a1;
  if (v5 >= v7 && (*(_BYTE *)(a1 + 40) & 8) == 0)
  {
    v52[1] = a3 + 8;
    uint64_t v53 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v53 + 1;
    uint64_t v54 = *(void *)(a1 + 16);
    uint64_t v55 = *(_DWORD *)(a1 + 24);
    if (v53 + 1 >= v55)
    {
      uint64_t v56 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        uint64_t v56 = malloc_default_zone();
      }
      uint64_t v57 = malloc_zone_realloc(v56, *(void **)(a1 + 48), 8LL * (v55 + 512));
      *(void *)(a1 + 4_Block_object_dispose(va, 8) = v57;
      v57[v55 + 511] = 0LL;
      *(_DWORD *)(a1 + 24) = v55 + 512;
    }

    uint64_t v58 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if ((*(_BYTE *)(a1 + 40) & 4) != 0)
    {
      if (!_PF_Private_Malloc_Zone) {
        uint64_t v58 = malloc_default_zone();
      }
      uint64_t result = malloc_zone_calloc(v58, 1uLL, v54);
    }

    else
    {
      if (!_PF_Private_Malloc_Zone) {
        uint64_t v58 = malloc_default_zone();
      }
      uint64_t result = malloc_zone_malloc(v58, v54);
    }

    *(void *)(a1 + 64) = result;
    *(void *)(*(void *)(a1 + 48) + 8LL * v53) = result;
    uint64_t v59 = *(void **)(a1 + 64);
    *(void *)(a1 + 72) = v59;
    if (v59)
    {
      *uint64_t v59 = 0LL;
      *(void *)(a1 + 72) = v59 + 1;
      *(_DWORD *)(a1 + 36) = v53;
      return result;
    }

    uint64_t v68 = [NSString stringWithUTF8String:"PF_MALLOC failed to allocate buffer to %ld bytes"];
    _NSCoreDataLog(17LL, v68, v69, v70, v71, v72, v73, v74, v54);
    uint64_t v67 = (os_log_s *)__pflogFaultLog;
    if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
      goto LABEL_72;
    }
    *(_DWORD *)address = 134217984;
    *(void *)&address[4] = v54;
    goto LABEL_71;
  }

  return result;
}

        [v28 appendString:@" WHERE "];
        [v28 appendString:v48];
        [v28 appendString:@" == "];
        [v28 appendFormat:@"%@", v54];
        [v28 appendString:@" AND "];
        [v28 appendString:v47];
        [v28 appendString:@" == "];
        [v28 appendString:v46];
        uint64_t v36 = -[NSSQLiteAdapter newStatementWithSQLString:]((NSSQLiteStatement *)v52[4], (uint64_t)v28);
        if (+[NSMappingModel migrationDebugLevel](&OBJC_CLASS___NSMappingModel, "migrationDebugLevel") > 0) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Executing shift tombstone column statement: %@",  v37,  v38,  v39,  v40,  v41,  v42,  (uint64_t)v36);
        }
        -[NSSQLiteConnection prepareAndExecuteSQLStatement:]((uint64_t)v52[6], v36);

        uint64_t v26 = v56 + 1;
        uint64_t v25 = v45;
      }

      while (v56 + 1 != v50);
      uint64_t v50 = [obj countByEnumeratingWithState:&v57 objects:v65 count:16];
      if (!v50) {
        return 1LL;
      }
    }
  }

  return result;
}

void sub_1866B2340(_Unwind_Exception *a1)
{
}

unint64_t _sql_fetch_plan_for_entity(unint64_t *a1)
{
  unint64_t v1 = a1;
  v37[5] = *MEMORY[0x1895F89C0];
  if (!atomic_load(a1 + 28))
  {
    double v3 = (void *)[a1 foreignKeyColumns];
    os_signpost_id_t v4 = (void *)[v1 foreignEntityKeyColumns];
    uint64_t v5 = (void *)[v1 foreignOrderKeyColumns];
    uint64_t v6 = (void *)[v1 attributeColumns];
    uint64_t v32 = v1;
    uint64_t v7 = [MEMORY[0x189603F18] arrayWithObject:v1[18]];
    int v8 = [v3 count];
    int v9 = [v4 count];
    int v10 = [v5 count];
    int v11 = v9 + v8 + v10 + [v6 count];
    int v12 = v11 + 1;
    size_t v13 = (24 * v11 + 32);
    uint64_t v14 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v14 = malloc_default_zone();
    }
    uint64_t v15 = malloc_zone_malloc(v14, v13);
    uint64_t v16 = 0LL;
    v15[1] = v12;
    ptr = (CFTypeRef *)v15;
    uint64_t v17 = (char *)(v15 + 2);
    v37[0] = v7;
    v37[1] = v3;
    v37[2] = v4;
    v37[3] = v5;
    int v18 = 32;
    v37[4] = v6;
    do
    {
      uint64_t v33 = v16;
      uint64_t v35 = (void *)v37[v16];
      uint64_t v34 = objc_msgSend(v35, "count", ptr);
      if (v34)
      {
        for (uint64_t i = 0LL; i != v34; ++i)
        {
          int v20 = (unsigned __int16 *)[v35 objectAtIndex:i];
          int v21 = [v20 slot];
          if (v20) {
            int v22 = v20[13];
          }
          else {
            int v22 = 0;
          }
          char v23 = [v20 sqlType];
          int v24 = [v20 propertyType];
          char v25 = v24;
          if (v24 == 1)
          {
            int v26 = objc_msgSend((id)objc_msgSend(v20, "propertyDescription"), "isOptional");
            if (v26) {
              v18 += 4;
            }
          }

          else
          {
            int v26 = 0;
          }

          int v27 = -[NSSQLColumn roughSizeEstimate]((uint64_t)v20);
          if (v20) {
            CFRetain(v20);
          }
          v18 += v27;
          *(_DWORD *)uint64_t v17 = v21;
          *((_DWORD *)v17 + 1) = v22;
          *((_DWORD *)v17 + 2) = v26;
          v17[12] = v23;
          v17[13] = v25;
          *((_WORD *)v17 + 7) = v36;
          *((void *)v17 + 2) = v20;
          v17 += 24;
        }
      }

      uint64_t v16 = v33 + 1;
    }

    while (v33 != 4);
    *(_DWORD *)ptr = v18;
    unint64_t v1 = v32;
    uint64_t v28 = v32 + 28;
    while (!__ldaxr(v28))
    {
    }

    __clrex();
    _deallocateFetchEntityPlan(ptr);
  }

  return atomic_load(v1 + 28);
}

uint64_t _PFAllocateObjects(objc_class *a1, void **a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = 0LL;
  if (a2 && a3)
  {
    uint64_t v6 = a2;
    size_t v8 = ((class_getInstanceSize(a1) + 7) & 0xFFFFFFFFFFFFFFF8LL) + a4;
    int v9 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      int v9 = malloc_default_zone();
    }
    LODWORD(v4) = 0;
    unsigned int v10 = a3;
    int v11 = v6;
    do
    {
      unsigned int v12 = malloc_zone_batch_malloc(v9, v8, v11, v10);
      uint64_t v4 = v12 + v4;
      if (v10 == v12)
      {
        unsigned int v10 = 0;
      }

      else
      {
        unsigned int v13 = v12;
        uint64_t v14 = malloc_zone_malloc(v9, v8);
        if (!v14) {
          break;
        }
        uint64_t v15 = &v11[v13];
        *uint64_t v15 = v14;
        int v11 = v15 + 1;
        uint64_t v4 = (v4 + 1);
        v10 += ~v13;
      }
    }

    while (v4 < a3);
    int v16 = a3 - v4;
    if (a3 > v4)
    {
      uint64_t v17 = &v6[v4];
      do
      {
        int v18 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
        if (!_PF_Private_Malloc_Zone) {
          int v18 = malloc_default_zone();
        }
        int v19 = malloc_zone_malloc(v18, v8);
        if (v19)
        {
          *uint64_t v17 = v19;
          uint64_t v4 = (v4 + 1);
        }

        ++v17;
        --v16;
      }

      while (v16);
    }

    if (v4 >= a3)
    {
      uint64_t v23 = v4;
      do
      {
        bzero(*v6, v8);
        int v24 = *v6++;
        objc_constructInstance(a1, v24);
        --v23;
      }

      while (v23);
    }

    else if ((_DWORD)v4)
    {
      uint64_t v20 = v4;
      do
      {
        int v21 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
        if (!_PF_Private_Malloc_Zone) {
          int v21 = malloc_default_zone();
        }
        int v22 = *v6++;
        malloc_zone_free(v21, v22);
        --v20;
      }

      while (v20);
      return 0LL;
    }
  }

  return v4;
}

void snapshot_set_transient_default_values(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 16) entity];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 112);
    uint64_t v4 = *(void *)(v3 + 88);
    if (!v4) {
      return;
    }
    unint64_t v5 = *(void *)(v3 + 80);
    unint64_t v6 = v5 + v4;
    uint64_t v7 = *(void *)(v2 + 96);
  }

  else
  {
    if (!MEMORY[0x58]) {
      return;
    }
    uint64_t v7 = 0LL;
    unint64_t v5 = MEMORY[0x50];
    unint64_t v6 = MEMORY[0x50] + MEMORY[0x58];
  }

  if (v5 < v6)
  {
    uint64_t v8 = v7 + 24;
    uint64_t v9 = a1 + 28;
    int v10 = v6 - 1;
    int v11 = (int)v5 >> 3;
    int v12 = 255 << (v5 & 7);
    if ((int)v5 >> 3 == ((int)v6 - 1) >> 3)
    {
      unsigned int v13 = (0xFFu >> (~(_BYTE)v10 & 7)) & v12;
    }

    else
    {
      *(_BYTE *)(v9 + v11) |= v12;
      if (v11 + 1 < v10 >> 3) {
        memset((void *)(v11 + a1 + 29), 255, ((v10 >> 3) - v11 - 2) + 1LL);
      }
      unsigned int v13 = 0xFFu >> (~(_BYTE)v10 & 7);
      int v11 = v10 >> 3;
    }

    *(_BYTE *)(v9 + v11) |= v13;
    do
    {
      uint64_t v14 = *(void **)(v8 + 8 * v5);
      if ([v14 _propertyType] == 7) {
        uint64_t v15 = (void *)[v14 _buildDefaultValue];
      }
      else {
        uint64_t v15 = (void *)[v14 defaultValue];
      }
      if (v15)
      {
        id v16 = v15;
        snapshot_set_value_as_object((char *)a1, v5, v16, v17, v18, v19, v20, v21);
      }

      ++v5;
    }

    while (v6 != v5);
  }

void snapshot_set_object(char *a1, unsigned int a2, uint64_t a3)
{
  Class Class = object_getClass(a1);
  IndexedIvars = (unsigned int *)object_getIndexedIvars(Class);
  a1[((unint64_t)a2 >> 3) + 28] &= ~(1 << (a2 & 7));
  uint64_t v8 = IndexedIvars[a2 + 19];
  uint64_t v9 = *(void **)&a1[v8];
  *(void *)&a1[v8] = a3;
  if (v9) {
}
  }

unsigned int *snapshot_set_int8(void *a1, unsigned int a2, char a3)
{
  Class Class = object_getClass(a1);
  uint64_t result = (unsigned int *)object_getIndexedIvars(Class);
  *((_BYTE *)a1 + ((unint64_t)a2 >> 3) + 28) &= ~(1 << (a2 & 7));
  *((_BYTE *)a1 + result[a2 + 19]) = a3;
  return result;
}

unsigned int *snapshot_set_int64(char *a1, unsigned int a2, uint64_t a3)
{
  Class Class = object_getClass(a1);
  uint64_t result = (unsigned int *)object_getIndexedIvars(Class);
  a1[((unint64_t)a2 >> 3) + 28] &= ~(1 << (a2 & 7));
  *(void *)&a1[result[a2 + 19]] = a3;
  return result;
}

unsigned int *snapshot_set_double(char *a1, unsigned int a2, double a3)
{
  Class Class = object_getClass(a1);
  uint64_t result = (unsigned int *)object_getIndexedIvars(Class);
  a1[((unint64_t)a2 >> 3) + 28] &= ~(1 << (a2 & 7));
  *(double *)&a1[result[a2 + 19]] = a3;
  return result;
}

uint64_t _PFfastRowRetain(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  uint64_t v3 = (unsigned int *)(a2 + 8);
  do
    unsigned int v4 = __ldxr(v3);
  while (__stxr(v4 + 1, v3));
  return result;
}

void _PFFaultHandlerFulfillFault(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, int a5)
{
  int v5 = (*(_DWORD *)(a2 + 16) >> 15) & 7;
  if (((*(_DWORD *)(a2 + 16) >> 15) & 3 | 4) != 5) {
    return;
  }
  int v150 = a5;
  uint64_t v152 = &v144;
  CFAllocatorContext context = (void *)MEMORY[0x186E3E5D8]();
  uint64_t v9 = *(_DWORD *)(a2 + 16) & 0xFFFC7FFF | 0x18000LL;
  *(_DWORD *)(a2 + 16) = v9;
  if ((v9 & 0x100) == 0) {
    [(id)a2 willFireFault];
  }
  int v10 = *(void **)(a2 + 40);
  int v11 = _PFEntityForManagedObject((id)a2);
  if ((v9 & 0x12) != 0)
  {
    int v12 = 1;
  }

  else if ([v10 isTemporaryID])
  {
    if (a3) {
      BOOL v13 = a4 == 0LL;
    }
    else {
      BOOL v13 = 1;
    }
    int v12 = v13;
  }

  else
  {
    int v12 = 0;
  }

  v146 = v10;
  id v156 = a4;
  if (v11)
  {
    int v161 = (void *)v11[14];
    uint64_t v14 = v11[12];
    uint64_t v15 = v11[13] + 40LL;
  }

  else
  {
    int v161 = 0LL;
    uint64_t v14 = 0LL;
    uint64_t v15 = 40LL;
  }

  uint64_t v144 = *(void *)v15;
  uint64_t v16 = _kvcPropertysPrimitiveSetters((uint64_t)v11);
  uint64_t v17 = *(void **)(a2 + 48);
  if (!v17 || !*v17 || (*(_BYTE *)(a2 + 17) & 0x20) != 0)
  {
    uint64_t v20 = (uint64_t)v11;
LABEL_26:
    int HasCustomPrimitiveProperties = _PF_HasCustomPrimitiveProperties(v20);
    uint64_t v18 = 0LL;
    goto LABEL_27;
  }

  if (!v11)
  {
    uint64_t v20 = 0LL;
    goto LABEL_26;
  }

  uint64_t v18 = *(void *)(v11[19] + 48LL);
  int HasCustomPrimitiveProperties = _PF_HasCustomPrimitiveProperties((uint64_t)v11);
  if (!v18)
  {
LABEL_27:
    int v19 = 1;
    goto LABEL_28;
  }

  if (a3) {
    ++*(_WORD *)(a3 + 46);
  }
  *(_DWORD *)(a2 + 16) |= 0x1000u;
  [(id)a2 _willChangeValuesForKeys:v18];
  int v19 = 0;
LABEL_28:
  uint64_t v153 = a3;
  uint64_t v149 = v9;
  uint64_t v145 = v18;
  int v147 = v5;
  int v148 = v19;
  if ((v12 & 1) != 0)
  {
    uint64_t v159 = 0LL;
LABEL_35:
    int v24 = *(char **)(a2 + 24);
    uint64_t v33 = v24;
    _PF_CopyOnWrite_Snapshot((id)a2);
    if (v5 == 5)
    {
      id v154 = v24;
    }

    else
    {

      id v154 = 0LL;
      int v24 = 0LL;
    }

    int HasCustomPrimitiveProperties = 1;
    int v32 = 1;
    goto LABEL_39;
  }

  uint64_t v21 = v14;
  id v22 = v156;
  uint64_t v23 = (_DWORD *)[v156 _snapshot];
  if (!v23)
  {
    uint64_t v159 = [v22 knownKeyValuesPointer];
    *(_DWORD *)(a2 + 12) = [v22 _versionNumber];
    uint64_t v14 = v21;
    goto LABEL_35;
  }

  id v154 = v23;
  *(_DWORD *)(a2 + 12) = v23[3];
  int v24 = *(char **)(a2 + 24);
  char v25 = v24;
  uint64_t v14 = v21;
  if (v24 == v154)
  {
    if (v5 != 5)
    {

      id v154 = 0LL;
    }

    int v32 = 0;
    uint64_t v159 = 0LL;
    int v24 = 0LL;
  }

  else
  {
    *(void *)(a2 + 24) = v154;
    if (v5 == 5)
    {
      int v32 = 0;
      uint64_t v159 = 0LL;
      id v154 = v24;
    }

    else
    {

      id v154 = 0LL;
      int v32 = 0;
      uint64_t v159 = 0LL;
    }
  }

uint64_t _PF_HasCustomPrimitiveProperties(uint64_t a1)
{
  unsigned int v1 = (*(_DWORD *)(a1 + 120) >> 9) & 3;
  if (v1 <= 1)
  {
    uint64_t v3 = objc_msgSend((id)objc_msgSend((id)a1, "properties"), "count");
    unsigned int v4 = *(void **)(*(void *)(a1 + 152) + 8LL);
    if (v4)
    {
      if (!v3) {
        goto LABEL_9;
      }
    }

    else
    {
      unsigned int v4 = (void *)_resolveForSelectorAndType( (unint64_t *)a1,  sel__createValuePrimitiveGetterWithContainerClassID_key_,  (objc_class *)qword_18C4AB980,  1);
      if (!v3)
      {
LABEL_9:
        unint64_t v6 = **(void ***)(a1 + 152);
        if (v6)
        {
          if (v3) {
            goto LABEL_11;
          }
          goto LABEL_13;
        }

        unint64_t v6 = (void *)_resolveForSelectorAndType( (unint64_t *)a1,  sel__createValuePrimitiveSetterWithContainerClassID_key_,  (objc_class *)_MergedGlobals_68,  0);
        if (!v3)
        {
LABEL_13:
          unsigned int v7 = *(_DWORD *)(a1 + 120) & 0xFFFFF9FF | 0x400;
LABEL_15:
          *(_DWORD *)(a1 + 120) = v7;
          unsigned int v1 = (v7 >> 9) & 3;
          return v1 & 1;
        }

LABEL_14:
        unsigned int v7 = *(_DWORD *)(a1 + 120) | 0x600;
        goto LABEL_15;
      }
    }

    uint64_t v5 = v3;
    while (!*v4)
    {
      ++v4;
      if (!--v5) {
        goto LABEL_9;
      }
    }

    goto LABEL_14;
  }

  return v1 & 1;
}

        ++v7;
      }

      while (v5 != v7);
      BOOL v13 = [a2 countByEnumeratingWithState:&v15 objects:v19 count:16];
      uint64_t v5 = v13;
      if (!v13) {
        return v3;
      }
    }
  }

  return (id)[MEMORY[0x189603FE8] null];
}

  objc_autoreleasePoolPop(v8);
}

  __dmb(0xBu);
}

      _NSCoreDataLog( 1LL,  (uint64_t)@"NSFetchedResultsController: cannot access fetched objects before -performFetch:",  v9,  v10,  v11,  v12,  v13,  v14,  v36);
      if (byte_18C4ABDBB)
      {
        uint64_t v18 = (void *)MEMORY[0x189603F70];
        int v19 = *MEMORY[0x189603A60];
        uint64_t v17 = @"cannot access fetched objects before -performFetch:";
        goto LABEL_22;
      }

      return 0LL;
    }
  }

  else if (v5 >= [0 count])
  {
    goto LABEL_14;
  }

  uint64_t v20 = (void *)-[NSMutableOrderedSet objectAtIndex:](self->_sections, "objectAtIndex:", v5);
  if (v6 >= [v20 numberOfObjects])
  {
    _NSCoreDataLog( 1LL,  (uint64_t)@"NSFetchedResultsController: no object at index %lu in section at index %lu",  v21,  v22,  v23,  v24,  v25,  v26,  v6);
    if (byte_18C4ABDBB)
    {
      uint64_t v31 = (void *)MEMORY[0x189603F70];
      int v32 = *MEMORY[0x189603A60];
      uint64_t v17 = (const __CFString *)objc_msgSend( NSString,  "stringWithFormat:",  @"no object at index %lu in section at index %lu",  v6,  v5);
      uint64_t v18 = v31;
      int v19 = v32;
      goto LABEL_22;
    }

    return 0LL;
  }

  if (v20) {
    uint64_t v27 = v20[4];
  }
  else {
    uint64_t v27 = 0LL;
  }
  uint64_t v28 = v27 + v6;
  if (v27 + v6 >= [self->_fetchedObjects count]) {
    uint64_t v29 = 0LL;
  }
  else {
    uint64_t v29 = (void *)[self->_fetchedObjects objectAtIndex:v28];
  }
  return v29;
}

    v4->_inverseRelationship = (NSRelationshipDescription *)[a3 decodeObjectOfClass:objc_opt_class() forKey:@"NSInverseRelationship"];
    int v11 = (void *)[a3 decodeObjectOfClass:objc_opt_class() forKey:@"_NSInverseRelationshipName"];
    if (v4->_inverseRelationship)
    {
      if (v5) {
        int v12 = (void *)v5[3];
      }
      else {
        int v12 = 0LL;
      }
      objc_msgSend(v12, "addObject:");
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        if (v5 && (v5[1] || v5[2]) || v4->_inverseRelationship == v4) {
          goto LABEL_31;
        }
        uint64_t v9 = &unk_189F03D10;
      }

      else
      {
        uint64_t v9 = &unk_189F03CE8;
      }
    }

    else
    {
      BOOL v13 = v11;
      if (!v11 || ([v11 isNSString] & 1) != 0)
      {
        v4->_lazyInverseRelationshipName = (NSString *)[v13 copy];
LABEL_31:
        v16((uint64_t)v15);
        return v4;
      }

      uint64_t v9 = &unk_189F03CC0;
    }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    PFBundleVersion = (void *)+[_PFRoutines _getPFBundleVersionNumber]();
    int v19 = +[PFCloudKitMetadataModel newMetadataModelForFrameworkVersion:]( (uint64_t)&OBJC_CLASS___PFCloudKitMetadataModel,  PFBundleVersion);
    uint64_t v20 = objc_alloc_init(MEMORY[0x189603FE0]);
    uint64_t v21 = (objc_class *)objc_opt_class();
    [v20 addObject:NSStringFromClass(v21)];
    id v22 = (objc_class *)objc_opt_class();
    [v20 addObject:NSStringFromClass(v22)];
    uint64_t v23 = (objc_class *)objc_opt_class();
    [v20 addObject:NSStringFromClass(v23)];
    int v24 = (objc_class *)objc_opt_class();
    [v20 addObject:NSStringFromClass(v24)];
    uint64_t v78 = 0u;
    uint64_t v79 = 0u;
    int v76 = 0u;
    uint64_t v77 = 0u;
    int v66 = v19;
    char v25 = -[NSManagedObjectModel countByEnumeratingWithState:objects:count:]( v19,  "countByEnumeratingWithState:objects:count:",  &v76,  v92,  16LL);
    if (v25)
    {
      uint64_t v26 = v25;
      uint64_t v27 = *(void *)v77;
      while (2)
      {
        for (uint64_t j = 0LL; j != v26; ++j)
        {
          if (*(void *)v77 != v27) {
            objc_enumerationMutation(v66);
          }
          uint64_t v29 = *(void **)(*((void *)&v76 + 1) + 8 * j);
          if ((objc_msgSend(v20, "containsObject:", objc_msgSend(v29, "name")) & 1) == 0)
          {
            uint64_t v30 = -[NSBatchDeleteRequest initWithFetchRequest:]( objc_alloc(&OBJC_CLASS___NSBatchDeleteRequest),  "initWithFetchRequest:",  +[NSFetchRequest fetchRequestWithEntityName:]( &OBJC_CLASS___NSFetchRequest,  "fetchRequestWithEntityName:",  _PFModelMapPathForEntity(v29)));
            -[NSBatchDeleteRequest setResultType:](v30, "setResultType:", 1LL);
            uint64_t v91 = *(void *)(a1 + 32);
            -[NSPersistentStoreRequest setAffectedStores:]( v30,  "setAffectedStores:",  [MEMORY[0x189603F18] arrayWithObjects:&v91 count:1]);
            uint64_t v31 = (void *)[*(id *)(a1 + 40) executeRequest:v30 error:&v84];

            if (![v31 result])
            {
              *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0;
              int v42 = (void *)MEMORY[0x186E3E5D8]();
              int v43 = __ckLoggingOverride != 0;
              unsigned int v44 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to purge cloudkit metadata entity (%@): %@"];
              [v29 name];
              _NSCoreDataLog( v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  (uint64_t)"-[PFCloudKitMetadataPurger purgeMetadataAfterAccountChangeFromStore:inMonitor:inDatabaseWithSco pe:error:]_block_invoke");
              objc_autoreleasePoolPop(v42);
              goto LABEL_31;
            }

            CFAllocatorContext context = (void *)MEMORY[0x186E3E5D8]();
            else {
              int v32 = __ckLoggingOverride;
            }
            uint64_t v33 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Removed cloud metadata after account change %@"];
            [*(id *)(a1 + 40) transactionAuthor];
            [v29 name];
            _NSCoreDataLog( v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  (uint64_t)"-[PFCloudKitMetadataPurger purgeMetadataAfterAccountChangeFromStore:inMonitor:inDatabaseWithScope :error:]_block_invoke");
            objc_autoreleasePoolPop(context);
            int v40 = (void *)[v31 result];
            if ([v40 count])
            {
              uint64_t v89 = @"deleted";
              uint64_t v90 = v40;
              int v41 = [MEMORY[0x189603F68] dictionaryWithObjects:&v90 forKeys:&v89 count:1];
              uint64_t v88 = *(void *)(a1 + 40);
              +[NSManagedObjectContext mergeChangesFromRemoteContextSave:intoContexts:]( NSManagedObjectContext,  "mergeChangesFromRemoteContextSave:intoContexts:",  v41,  [MEMORY[0x189603F18] arrayWithObjects:&v88 count:1]);
            }
          }
        }

        uint64_t v26 = -[NSManagedObjectModel countByEnumeratingWithState:objects:count:]( v66,  "countByEnumeratingWithState:objects:count:",  &v76,  v92,  16LL);
        if (v26) {
          continue;
        }
        break;
      }
    }

  if (![a4 objectForKey:@"NSUnderlyingException"]) {
    [a4 setObject:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", *MEMORY[0x189603A60], objc_msgSend(NSString, "stringWithFormat:", @"Unable to resolve variable expression: %@", a3), 0), @"NSUnderlyingException" forKey];
  }
  return 0LL;
}

    uint64_t v14 = -[NSCKRecordMetadata createRecordID](v8);
    uint64_t v15 = objc_alloc(getCloudKitCKRecordClass());
    unsigned int v119 = (void *)objc_msgSend( v15,  "initWithRecordType:recordID:",  +[PFCloudKitSerializer recordTypeForEntity:]( (uint64_t)PFCloudKitSerializer,  (uint64_t)v114),  v14);
    int v117 = (id)v14;
LABEL_15:
    uint64_t v16 = [v114 name];
    objc_opt_self();
    uint64_t v17 = [@"CD_" stringByAppendingString:@"entityName"];
    uint64_t v18 = [*(id *)(a1 + 24) useDeviceToDeviceEncryption];
    int v19 = v119;
    if (v18) {
      int v19 = (void *)[v119 encryptedValues];
    }
    [v19 setObject:v16 forKey:v17];
    if (objc_msgSend((id)objc_msgSend(v8, "moveReceipts"), "count") || a3)
    {
      if ((a3 & 1) != 0)
      {
        uint64_t v20 = (void *)[@"Some sample move receipt data." dataUsingEncoding:4];
        objc_opt_self();
        uint64_t v21 = [@"CD_" stringByAppendingString:@"moveReceipt"];
        id v22 = [*(id *)(a1 + 24) useDeviceToDeviceEncryption];
        uint64_t v23 = v119;
        if (v22) {
          uint64_t v23 = (void *)[v119 encryptedValues];
        }
        [v23 setObject:v20 forKey:v21];
        int v24 = +[PFCloudKitSerializer generateCKAssetFileURLForObjectInStore:]( (uint64_t)PFCloudKitSerializer,  (void *)objc_msgSend((id)objc_msgSend(a2, "objectID"), "persistentStore"));
        if ([v20 writeToURL:v24 options:0 error:v137 + 5])
        {
          [*(id *)(a1 + 40) addObject:v24];
          char v25 = (id)[objc_alloc((Class)getCloudKitCKAssetClass[0]()) initWithFileURL:v24];
          objc_opt_self();
          uint64_t v26 = (void *)[@"CD_" stringByAppendingString:@"moveReceipt"];
          objc_opt_self();
          objc_msgSend(v119, "setObject:forKey:", v25, objc_msgSend(v26, "stringByAppendingString:", @"_ckAsset"));
        }

        else
        {
          uint64_t v33 = (void *)MEMORY[0x186E3E5D8]();
          unint64_t v34 = __ckLoggingOverride != 0;
          uint64_t v35 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to write CKAsset data for '%@' on '%@' backing record '%@'.\n%@"];
          [a2 objectID];
          [v119 recordID];
          _NSCoreDataLog( v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  (uint64_t)"-[PFCloudKitSerializer newCKRecordsFromObject:fullyMaterializeRecords:includeRelationships:error:]");
          objc_autoreleasePoolPop(v33);
          *((_BYTE *)v143 + 24) = 0;
          int v42 = (id)v137[5];
        }
      }

      else
      {
        uint64_t v27 = (void *)[v8 createEncodedMoveReceiptData:v137 + 5];
        if (v27)
        {
          uint64_t v28 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 24), "ckAssetThresholdBytes"), "unsignedIntegerValue");
          objc_opt_self();
          uint64_t v29 = (void *)[@"CD_" stringByAppendingString:@"moveReceipt"];
          objc_opt_self();
          uint64_t v30 = [v29 stringByAppendingString:@"_ckAsset"];
          if (v28 && [v27 length] > v28
            || (uint64_t v31 = [v27 length], (unint64_t)(objc_msgSend(v119, "size") + v31) >= 0xAAE61))
          {
            int v32 = +[PFCloudKitSerializer generateCKAssetFileURLForObjectInStore:]( (uint64_t)PFCloudKitSerializer,  (void *)objc_msgSend((id)objc_msgSend(a2, "objectID"), "persistentStore"));
            if ([v27 writeToURL:v32 options:0 error:v137 + 5])
            {
              [*(id *)(a1 + 40) addObject:v32];
              objc_msgSend( v119,  "setObject:forKey:",  (id)objc_msgSend( objc_alloc((Class)getCloudKitCKAssetClass[0]()),  "initWithFileURL:",  v32),  v30);
            }

            else
            {
              uint64_t v47 = (void *)MEMORY[0x186E3E5D8]();
              uint32_t v48 = __ckLoggingOverride != 0;
              uint64_t v49 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to write CKAsset data for '%@' on '%@' backing record '%@'.\n%@"];
              [a2 objectID];
              [v119 recordID];
              _NSCoreDataLog( v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  (uint64_t)"-[PFCloudKitSerializer newCKRecordsFromObject:fullyMaterializeRecords:includeRelationships:error:]");
              objc_autoreleasePoolPop(v47);
              *((_BYTE *)v143 + 24) = 0;
              uint64_t v56 = (id)v137[5];
            }
          }

          else
          {
            objc_opt_self();
            unsigned int v44 = [@"CD_" stringByAppendingString:@"moveReceipt"];
            uint64_t v45 = [*(id *)(a1 + 24) useDeviceToDeviceEncryption];
            uint64_t v46 = v119;
            if (v45) {
              uint64_t v46 = (void *)[v119 encryptedValues];
            }
            [v46 setObject:v27 forKey:v44];
          }
        }

        else
        {
          *((_BYTE *)v143 + 24) = 0;
          int v43 = (id)v137[5];
        }
      }
    }

    uint64_t v57 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithArray:",  objc_msgSend((id)objc_msgSend(v114, "attributesByName"), "allValues"));
    objc_msgSend( v57,  "filterUsingPredicate:",  objc_msgSend(MEMORY[0x1896079C8], "predicateWithBlock:", &__block_literal_global_22));
    unint64_t v121 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FC8]), "initWithCapacity:", objc_msgSend(v57, "count"));
    obuint64_t j = v57;
    uint64_t v134 = 0u;
    char v135 = 0u;
    unint64_t v132 = 0u;
    unint64_t v133 = 0u;
    int v12 = (id)[v57 countByEnumeratingWithState:&v132 objects:v151 count:16];
    unint64_t v58 = v12;
    if (v12)
    {
      unint64_t v59 = *(void *)v133;
      do
      {
        uint64_t v60 = 0LL;
        do
        {
          if (*(void *)v133 != v59) {
            objc_enumerationMutation(obj);
          }
          uint64_t v61 = *(void **)(*((void *)&v132 + 1) + 8LL * (void)v60);
          uint64_t v62 = (void *)MEMORY[0x186E3E5D8]();
          uint64_t v63 = [v61 name];
          char v64 = (__CFString *)[a2 valueForKey:v63];
          if ([v61 attributeType] == 1800 || objc_msgSend(v61, "attributeType") == 2100)
          {
            if (v64)
            {
              int v65 = (const __CFString *) +[_PFRoutines retainedEncodeObjectValue:forTransformableAttribute:]( (uint64_t)&OBJC_CLASS____PFRoutines,  (uint64_t)v64,  v61);
            }

            else
            {
              if (!a3) {
                goto LABEL_57;
              }
              int v65 = +[PFCloudKitSchemaGenerator representativeValueFor:]( (uint64_t)&OBJC_CLASS___PFCloudKitSchemaGenerator,  v61);
            }
          }

          else if ([v61 attributeType] == 1100)
          {
            int v65 = (const __CFString *)-[__CFString UUIDString](v64, "UUIDString");
          }

          else
          {
            if ([v61 attributeType] != 1200) {
              goto LABEL_55;
            }
            int v65 = (const __CFString *)-[__CFString absoluteString](v64, "absoluteString");
          }

          char v64 = (__CFString *)v65;
LABEL_55:
          if (v64) {
            [v121 setObject:v64 forKey:v63];
          }
LABEL_57:
          objc_autoreleasePoolPop(v62);
          uint64_t v60 = (char *)v60 + 1;
        }

        while (v58 != v60);
        int v12 = (id)[obj countByEnumeratingWithState:&v132 objects:v151 count:16];
        unint64_t v58 = v12;
      }

      while (v12);
    }

  id v22 = (void *)[a2 operationMemoryThresholdBytes];
  if (!v22) {
    return 1LL;
  }
  uint64_t v23 = v22;
  if ([v22 isNSNumber])
  {
    int v24 = [&unk_189F04548 longLongValue];
    if ([v23 longLongValue] < v24)
    {
      char v25 = (void *)MEMORY[0x189607870];
      uint64_t v26 = *MEMORY[0x189607460];
      uint64_t v111 = *MEMORY[0x1896075F0];
      uint64_t v112 = [NSString stringWithFormat:@"The value for 'NSCloudKitMirroringDelegateOptions.operationMemoryThresholdBytes' must be at least %@ bytes. The following value is invalid: %@", &unk_189F04548, v23, v103, v104];
      uint64_t v27 = [MEMORY[0x189603F68] dictionaryWithObjects:&v112 forKeys:&v111 count:1];
      uint64_t v28 = v25;
      uint64_t v29 = v26;
      goto LABEL_47;
    }

    uint64_t v92 = [v23 longLongValue];
    if (v92 > objc_msgSend((id)objc_msgSend(a2, "ckAssetThresholdBytes"), "longLongValue")) {
      return 1LL;
    }
    uint64_t v93 = [NSString stringWithFormat:@"The value for 'NSCloudKitMirroringDelegateOptions.operationMemoryThresholdBytes', %@, must be larger than the value of 'NSCloudKitMirroringDelegateOptions.ckAssetThresholdBytes', %@.", v23, objc_msgSend(a2, "ckAssetThresholdBytes"), a2, v104];
    id v94 = (void *)MEMORY[0x189607870];
    uint64_t v95 = *MEMORY[0x189607460];
    uint64_t v113 = *MEMORY[0x1896075F0];
    v114[0] = v93;
    uint64_t v27 = [MEMORY[0x189603F68] dictionaryWithObjects:v114 forKeys:&v113 count:1];
    uint64_t v28 = v94;
    uint64_t v29 = v95;
  }

  else
  {
    uint64_t v81 = (void *)MEMORY[0x189607870];
    uint64_t v82 = *MEMORY[0x189607460];
    int v109 = *MEMORY[0x1896075F0];
    uint64_t v83 = (void *)NSString;
    int v84 = (objc_class *)objc_opt_class();
    id v110 = (const __CFString *)[v83 stringWithFormat:@"The value for 'NSCloudKitMirroringDelegateOptions.operationMemoryThresholdBytes' must be an instance of '%@'. The following value is invalid: %@", NSStringFromClass(v84), v23, v103, v104];
    uint64_t v27 = [MEMORY[0x189603F68] dictionaryWithObjects:&v110 forKeys:&v109 count:1];
    uint64_t v28 = v81;
    uint64_t v29 = v82;
  }

      objc_autoreleasePoolPop(v17);
      ++v15;
    }

    while (v14 != v15);
  }

  uint64_t v60 = (void *)[v132 attributeColumns];
  uint64_t v61 = [v60 count];
  uint64_t v62 = 0x20000LL;
  if (!_PF_INTERNAL_DATA_SIZE_THRESHOLD) {
    uint64_t v62 = 0LL;
  }
  int v136 = v62;
  if (v61)
  {
    uint64_t v63 = v61;
    char v64 = 0LL;
    int v65 = (id *)v141[5];
    do
    {
      int v66 = (void *)MEMORY[0x186E3E5D8]();
      int v67 = (_WORD *)[v60 objectAtIndex:v64];
      unsigned int v68 = (void *)[v67 propertyDescription];
      if (v68 && [v68 superCompositeAttribute]) {
        int v69 = -[NSPropertyDescription _rootName]((__CFString *)[v67 propertyDescription]);
      }
      else {
        int v69 = (__CFString *)[v67 name];
      }
      uint64_t v70 = (uint64_t)v69;
      int v71 = [v143 fastIndexForKnownKey:v69];
      if (v71 == 0x7FFFFFFFFFFFFFFFLL) {
        int v76 = [v8 primitiveValueForKey:v70];
      }
      else {
        _PF_Handler_Primitive_GetProperty((id **)v8, v71, v70, *(void *)(v140 + 8 * v71), v72, v73, v74, v75);
      }
      uint64_t v77 = (void *)v76;
      if (objc_msgSend((id)objc_msgSend(v67, "attributeDescription"), "attributeType") == 1000)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0) {
          *a5 = 0;
        }
      }

      uint64_t v78 = [v67 slot];
      uint64_t v85 = v78;
      if (v67 && (v67[16] & 8) != 0)
      {
        snapshot_get_value_as_object(v65, v78, v79, v80, v81, v82, v83, v84);
        [v8 setPrimitiveValue:v88 forKey:v70];
      }

      else if (v77)
      {
        Class Class = object_getClass(v65);
        int v87 = *(char *)(*((void *)object_getIndexedIvars(Class) + 7) + v85);
        switch(v87)
        {
          case 'c':
            snapshot_set_int8(v65, v85, [v77 charValue]);
            break;
          case 'd':
            else {
              [v77 timeIntervalSinceReferenceDate];
            }
            snapshot_set_double((char *)v65, v85, v95);
            break;
          case 'e':
          case 'g':
          case 'h':
            goto LABEL_88;
          case 'f':
            [v77 floatValue];
            snapshot_set_float((char *)v65, v85, v96);
            break;
          case 'i':
            snapshot_set_int32((char *)v65, v85, [v77 intValue]);
            break;
          default:
            if (v87 != 113)
            {
              if (v87 == 115)
              {
                snapshot_set_int16((char *)v65, v85, [v77 shortValue]);
                break;
              }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL))
  {
    unint64_t v36 = v3;
    uint64_t v37 = v2;
    uint64_t v14 = objc_alloc_init(&OBJC_CLASS___PFCloudKitMetadataCache);
    uint64_t v15 = -[PFCloudKitSerializer initWithMirroringOptions:metadataCache:recordNamePrefix:]( objc_alloc(&OBJC_CLASS___PFCloudKitSerializer),  "initWithMirroringOptions:metadataCache:recordNamePrefix:",  *(void *)(*(void *)(a1 + 48) + 8LL),  v14,  @"CD_FAKE_");
    uint64_t v16 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 64), "insertedObjects"), "allObjects");
    if ([*(id *)(a1 + 64) obtainPermanentIDsForObjects:v16 error:*(void *)(*(void *)(a1 + 80) + 8) + 40])
    {
      int v40 = 0u;
      int v41 = 0u;
      uint64_t v38 = 0u;
      uint64_t v39 = 0u;
      uint64_t v17 = [v16 countByEnumeratingWithState:&v38 objects:v48 count:16];
      if (v17)
      {
        uint64_t v18 = v17;
        int v19 = *(void *)v39;
        do
        {
          for (uint64_t j = 0LL; j != v18; ++j)
          {
            if (*(void *)v39 != v19) {
              objc_enumerationMutation(v16);
            }
            uint64_t v21 = *(void **)(*((void *)&v38 + 1) + 8 * j);
            id v22 = (void *)MEMORY[0x186E3E5D8]();
            if (v15
              && (uint64_t v23 = -[PFCloudKitSerializer newCKRecordsFromObject:fullyMaterializeRecords:includeRelationships:error:]( (uint64_t)v15,  v21,  1,  1,  (void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL))) != 0LL)
            {
              int v24 = v23;
              [*(id *)(a1 + 72) addObjectsFromArray:v23];
            }

            else
            {
              char v25 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
              int v24 = 0LL;
            }

            objc_autoreleasePoolPop(v22);
          }

          uint64_t v18 = [v16 countByEnumeratingWithState:&v38 objects:v48 count:16];
        }

        while (v18);
      }
    }

    else
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL) = 0;
      uint64_t v26 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
      uint64_t v27 = [NSString stringWithUTF8String:"Failed to acquire permanent objectIDs during schema generation: %@"];
      _NSCoreDataLog( 17LL,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL));
      unint64_t v34 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        uint64_t v35 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
        *(_DWORD *)buf = 138412290;
        uint64_t v47 = v35;
        _os_log_fault_impl( &dword_186681000,  v34,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to acquire permanent objectIDs during schema generation: %@",  buf,  0xCu);
      }
    }

    uint64_t v3 = v36;
    uint64_t v2 = v37;
  }
}

void sub_1866B4CA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void _PFfastRowRelease(int a1, id *obj)
{
  uint64_t v2 = (unsigned int *)(obj + 1);
  do
    int v3 = __ldxr(v2);
  while (__stxr(v3 - 1, v2));
  if (v3 <= 0)
  {
    do
      unsigned int v4 = __ldxr(v2);
    while (__stxr(v4 + 0x20000000, v2));
    _NSQLRow_dealloc_standard(obj);
  }

void _NSQLRow_dealloc_standard(id *obj)
{
  if (((_BYTE)obj[2] & 2) == 0)
  {

    obj[5] = 0LL;
  }

  uint64_t v2 = obj[3];
  if (v2)
  {
    obj[3] = 0LL;
    if ((void *)*v2 != v2)
    {
      uint64_t v3 = 0LL;
      do
      {
        unsigned int v4 = &v2[v3];

        v3 += 3LL;
      }

      while ((void *)v4[3] != v2);
      if (v3) {
        PF_FREE_OBJECT_ARRAY(v2);
      }
    }
  }

  if (((_BYTE)obj[2] & 2) == 0) {
    _PFDeallocateObject(obj);
  }
}

void _PFfastOidRelease(int a1, unint64_t a2)
{
  if ((a2 & 0x8000000000000000LL) == 0)
  {
    Class Class = object_getClass((id)a2);
    if ((*((_BYTE *)object_getIndexedIvars(Class) + 4) & 1) == 0)
    {
      unsigned int v4 = (unsigned int *)(a2 + 8);
      do
        int v5 = __ldxr(v4);
      while (__stxr(v5 - 1, v4));
      if (v5 > 0) {
        return;
      }
LABEL_23:
      Class v11 = object_getClass((id)a2);
      [(id)a2 dealloc];
      _PFfastFactoryRelease1(v11);
      return;
    }

    unint64_t v6 = (unint64_t *)(a2 + 8);
    while (2)
    {
      while (1)
      {
        unint64_t v7 = *v6;
        if ((*v6 & 0x8000) != 0) {
          break;
        }
        while (1)
        {
          unint64_t v8 = __ldaxr(v6);
          if (v8 != v7) {
            break;
          }
          if (!__stlxr(v7 - 1, v6)) {
            goto LABEL_22;
          }
        }

        __clrex();
      }

      os_unfair_lock_lock_with_options();
      do
      {
        unint64_t v9 = __ldxr(v6);
        if (v9 != v7) {
          goto LABEL_20;
        }
      }

      while (__stxr(v7, v6));
      if (NSDecrementExtraRefCountWasZero((id)a2))
      {
        while (1)
        {
          unint64_t v10 = __ldxr(v6);
          if (v10 != v7) {
            break;
          }
          if (!__stxr(v7 ^ 0xFFFF, v6)) {
            goto LABEL_21;
          }
        }

LABEL_21:
    os_unfair_lock_unlock((os_unfair_lock_t)&_extraRetainsLock);
LABEL_22:
    if (!(_WORD)v7) {
      goto LABEL_23;
    }
  }

      uint64_t v17 = v152[0];
      [v130 drain];
      uint64_t v18 = v152[0];
      int v19 = 0LL;
      if ((v16 & 1) != 0)
      {
        uint64_t v20 = v129;
      }

      else
      {
        uint64_t v20 = v129;
        if (!v124)
        {
          uint64_t v21 = objc_alloc(MEMORY[0x189603FA8]);
          char v124 = (id)objc_msgSend(v21, "initWithCapacity:", objc_msgSend(v120, "count"));
        }

        int v19 = v152[0];
        if (v152[0])
        {
          id v22 = (void *)[v152[0] domain];
          if ([v22 isEqual:v121] && objc_msgSend(v152[0], "code") == 1560)
          {
            uint64_t v23 = (void *)[v152[0] userInfo];
            int v24 = [v23 objectForKey:v118];
            int v19 = (id)[v124 addObjectsFromArray:v24];
          }

          else
          {
            int v19 = (id)[v124 addObject:v152[0]];
          }
        }

        if ((v122 & 1) == 0) {
          goto LABEL_113;
        }
        unint64_t v123 = 0;
      }

      uint64_t v14 = v20 + 1;
      if (v14 == v128)
      {
        if ((v123 & 1) != 0)
        {
          if ((v117 & 1) == 0) {
            goto LABEL_112;
          }
          unint64_t v104 = 0LL;
          Class v11 = *v12;
          *v12 |= 8u;
          do
          {
            __int16 v105 = (void *)MEMORY[0x186E3E5D8](v19);
            [(id)v127[v104] willSave];
            objc_autoreleasePoolPop(v105);
            ++v104;
          }

          while (v128 != v104);
          BOOL v13 = *v12;
          goto LABEL_111;
        }

        LOBYTE(v6) = 1;
      }
    }
  }

  return v6;
}

  if (!self) {
    goto LABEL_131;
  }
  if ((+[NSMigrationManager _performSanityCheckForMapping:fromSourceModel:toDestinationModel:]( (uint64_t)&OBJC_CLASS___NSMigrationManager,  mappings,  -[NSMigrationManager sourceModel](self, "sourceModel"),  -[NSMigrationManager destinationModel](self, "destinationModel")) & 1) == 0)
  {
    uint64_t v90 = (void *)MEMORY[0x189603F70];
    uint64_t v91 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  -[NSMigrationManager sourceModel](self, "sourceModel"),  @"sourceModel",  -[NSMigrationManager destinationModel](self, "destinationModel"),  @"destinationModel",  mappings,  @"mappingModel",  0);
    objc_exception_throw((id)[v90 exceptionWithName:*MEMORY[0x189603A60] reason:@"Mismatch between mapping and source/destination models" userInfo:v91]);
    __break(1u);
    return result;
  }

  self->_mappingModel = mappings;
  self->_migrationContext = -[NSMigrationContext initWithMigrationManager:]( objc_alloc(&OBJC_CLASS___NSMigrationContext),  "initWithMigrationManager:",  self);
  uint64_t v115 = 0LL;
  char v25 = -[NSPersistentStoreCoordinator initWithManagedObjectModel:]( objc_alloc(&OBJC_CLASS___NSPersistentStoreCoordinator),  "initWithManagedObjectModel:",  -[NSMigrationManager sourceModel](self, "sourceModel"));
  uint64_t v26 = -[NSManagedObjectContext initWithConcurrencyType:]( objc_alloc(&OBJC_CLASS___NSManagedObjectContext),  "initWithConcurrencyType:",  3LL);
  self->_sourceManagedObjectContext = v26;
  -[NSManagedObjectContext setPersistentStoreCoordinator:](v26, "setPersistentStoreCoordinator:", v25);
  -[NSManagedObjectContext setUndoManager:](self->_sourceManagedObjectContext, "setUndoManager:", 0LL);

  if (!sOptions)
  {
    uint64_t v28 = objc_alloc(MEMORY[0x189603F68]);
    uint64_t v27 = (NSDictionary *)objc_msgSend( v28,  "initWithObjectsAndKeys:",  objc_msgSend(MEMORY[0x189607968], "numberWithBool:", 1),  @"NSReadOnlyPersistentStoreOption",  0);
    goto LABEL_27;
  }

  if (-[NSDictionary objectForKey:](sOptions, "objectForKey:", @"NSReadOnlyPersistentStoreOption"))
  {
    uint64_t v27 = sOptions;
LABEL_27:
    uint64_t v29 = v27;
    goto LABEL_29;
  }

  uint64_t v29 = (NSDictionary *)-[NSDictionary mutableCopy](sOptions, "mutableCopy");
  -[NSDictionary setObject:forKey:]( v29,  "setObject:forKey:",  [MEMORY[0x189607968] numberWithBool:1],  @"NSReadOnlyPersistentStoreOption");
LABEL_29:
  uint64_t v98 = -[NSPersistentStoreCoordinator addPersistentStoreWithType:configuration:URL:options:error:]( v25,  "addPersistentStoreWithType:configuration:URL:options:error:",  sStoreType,  0LL,  sourceURL,  v29,  &v115);

  if (!v98)
  {
    if (error)
    {
      uint64_t v35 = (void *)MEMORY[0x189607870];
      unint64_t v36 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Can't add source store",  @"reason",  v115,  *MEMORY[0x189607798],  0);
LABEL_129:
      NSError *error = (NSError *)[v35 errorWithDomain:*MEMORY[0x189607460] code:134110 userInfo:v36];
    }

  v39[5] = 0LL;
  BOOL v13 = (void *)v45[5];
  if (v29[5])
  {

    v45[5] = 0LL;
    objc_exception_throw((id)v29[5]);
    __break(1u);
  }

  uint64_t v14 = v13;
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v44, 8);
  return v14;
}

  if (!a1[10])
  {
    uint64_t v18 = a2 ? (void *)[(id)a2 propertyDescription] : 0;
    if ([v18 isOrdered])
    {
      int v19 = objc_alloc(NSString);
      if (v5) {
        uint64_t v20 = *(unsigned int *)(v5 + 184);
      }
      else {
        uint64_t v20 = 0LL;
      }
      uint64_t v21 = (void *)[v19 initWithFormat:@"%@_%d%@", @"Z_FOK", v20, objc_msgSend((id)objc_msgSend((id)a2, "name"), "uppercaseString")];
      if (v5) {
        id v22 = *(void *)(v5 + 176);
      }
      else {
        id v22 = 0LL;
      }
      int v32 = v21;
      uint64_t v23 = -[NSSQLStoreMappingGenerator uniqueNameWithBase:](v22, v21);
      int v24 = (void *)a1[10];
      if (v24 != (void *)v23)
      {
        char v25 = (void *)v23;

        a1[10] = [v25 copy];
      }
    }
  }

      LOBYTE(v24) = 0;
      return v24;
    }

          ;
        }

        int v5 = [v3 countByEnumeratingWithState:&v23 objects:v29 count:16];
      }

      while (v5);
      uint64_t v2 = v18;
      if ((v6 & 1) != 0) {
        -[NSCloudKitMirroringDelegate scheduleExportAndStartAfterDate:](*(void *)(a1 + 48), 0LL);
      }
    }
  }
}

NSManagedObjectID_optional __swiftcall NSPersistentStoreCoordinator.managedObjectID(for:)(Swift::String a1)
{
  Swift::String v6 = a1;
  id v2 = v1;
  swift_bridgeObjectRetain();
  uint64_t v3 = (objc_class *)specialized String.withUTF8<A>(_:)(&v6._countAndFlagsBits, v2);

  swift_bridgeObjectRelease();
  int v5 = v3;
  result.value.super.isa = v5;
  result.is_nil = v4;
  return result;
}

id NSPersistentStoreCoordinator.addPersistentStore(type:configuration:at:options:)( void *a1, uint64_t a2, void *a3, uint64_t a4, Class isa)
{
  v17[1] = *(id *)MEMORY[0x1895F89C0];
  unint64_t v10 = (void *)MEMORY[0x186E3D7D4](*a1, a1[1]);
  if (a3) {
    a3 = (void *)MEMORY[0x186E3D7D4](a2, a3);
  }
  URL._bridgeToObjectiveC()(v9);
  int v12 = v11;
  if (isa) {
    isa = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  v17[0] = 0LL;
  id v13 = objc_msgSend(v5, sel_addPersistentStoreWithType_configuration_URL_options_error_, v10, a3, v12, isa, v17);

  if (v13)
  {
    id v14 = v17[0];
  }

  else
  {
    id v15 = v17[0];
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }

  return v13;
}

void static NSPersistentStoreCoordinator.registerStoreClass(_:type:)(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (a1) {
    uint64_t ObjCClassFromMetadata = swift_getObjCClassFromMetadata();
  }
  else {
    uint64_t ObjCClassFromMetadata = 0LL;
  }
  int v5 = (void *)swift_getObjCClassFromMetadata();
  id v6 = (id)MEMORY[0x186E3D7D4](v2, v3);
  objc_msgSend(v5, sel_registerStoreClass_forStoreType_, ObjCClassFromMetadata, v6);
}

id static NSPersistentStoreCoordinator.metadataForPersistentStore(type:at:options:)( void *a1, uint64_t a2, Class isa)
{
  v13[1] = *(id *)MEMORY[0x1895F89C0];
  Swift::Bool v4 = (void *)MEMORY[0x186E3D7D4](*a1, a1[1]);
  URL._bridgeToObjectiveC()(v5);
  unint64_t v7 = v6;
  if (isa) {
    isa = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  v13[0] = 0LL;
  id v8 =  objc_msgSend( (id)swift_getObjCClassFromMetadata(),  sel_metadataForPersistentStoreOfType_URL_options_error_,  v4,  v7,  isa,  v13);

  id v9 = v13[0];
  if (v8)
  {
    id v10 = (id)static Dictionary._unconditionallyBridgeFromObjectiveC(_:)();
    id v11 = v9;
  }

  else
  {
    id v10 = v13[0];
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }

  return v10;
}

id static NSPersistentStoreCoordinator.setMetadata(_:type:at:options:)( uint64_t a1, uint64_t *a2, uint64_t a3, Class isa)
{
  v15[1] = *(id *)MEMORY[0x1895F89C0];
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (a1) {
    v7.super.isa = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  else {
    v7.super.isa = 0LL;
  }
  id v8 = (void *)MEMORY[0x186E3D7D4](v5, v6);
  URL._bridgeToObjectiveC()(v9);
  id v11 = v10;
  if (isa) {
    isa = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  v15[0] = 0LL;
  unsigned int v12 = objc_msgSend( (id)swift_getObjCClassFromMetadata(),  sel_setMetadata_forPersistentStoreOfType_URL_options_error_,  v7.super.isa,  v8,  v11,  isa,  v15);

  if (v12) {
    return v15[0];
  }
  id v14 = v15[0];
  _convertNSErrorToError(_:)();

  return (id)swift_willThrow();
}

id NSPersistentStoreCoordinator.migratePersistentStore(_:to:options:type:)( uint64_t a1, uint64_t a2, Class isa, uint64_t *a4)
{
  uint64_t v5 = v4;
  uint64_t v18 = (NSURL *)*MEMORY[0x1895F89C0];
  uint64_t v8 = *a4;
  uint64_t v9 = a4[1];
  URL._bridgeToObjectiveC()(v18);
  id v11 = v10;
  if (isa) {
    isa = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  unsigned int v12 = (void *)MEMORY[0x186E3D7D4](v8, v9);
  id v17 = 0LL;
  id v13 = objc_msgSend(v5, sel_migratePersistentStore_toURL_options_withType_error_, a1, v11, isa, v12, &v17);

  if (v13)
  {
    id v14 = v17;
  }

  else
  {
    id v15 = v17;
    _convertNSErrorToError(_:)();

    swift_willThrow();
  }

  return v13;
}

id NSPersistentStoreCoordinator.destroyPersistentStore(at:type:options:)(uint64_t a1, uint64_t *a2, Class isa)
{
  Swift::Bool v4 = v3;
  id v15 = (NSURL *)*MEMORY[0x1895F89C0];
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  URL._bridgeToObjectiveC()(v15);
  uint64_t v9 = v8;
  id v10 = (void *)MEMORY[0x186E3D7D4](v6, v7);
  if (isa) {
    isa = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  id v14 = 0LL;
  unsigned int v11 = objc_msgSend(v4, sel_destroyPersistentStoreAtURL_withType_options_error_, v9, v10, isa, &v14);

  if (v11) {
    return v14;
  }
  id v13 = v14;
  _convertNSErrorToError(_:)();

  return (id)swift_willThrow();
}

id NSPersistentStoreCoordinator.replacePersistentStore(at:destinationOptions:withPersistentStoreFrom:sourceOptions:type:)( uint64_t a1, Class isa, uint64_t a3, Class a4, uint64_t *a5)
{
  uint64_t v6 = v5;
  uint64_t v21 = (NSURL *)*MEMORY[0x1895F89C0];
  uint64_t v9 = *a5;
  uint64_t v10 = a5[1];
  URL._bridgeToObjectiveC()(v21);
  id v13 = v12;
  if (isa) {
    isa = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  URL._bridgeToObjectiveC()(v11);
  id v15 = v14;
  if (a4) {
    a4 = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  uint64_t v16 = (void *)MEMORY[0x186E3D7D4](v9, v10);
  id v20 = 0LL;
  unsigned int v17 = objc_msgSend( v6,  sel_replacePersistentStoreAtURL_destinationOptions_withPersistentStoreFromURL_sourceOptions_storeType_error_,  v13,  isa,  v15,  a4,  v16,  &v20);

  if (v17) {
    return v20;
  }
  id v19 = v20;
  _convertNSErrorToError(_:)();

  return (id)swift_willThrow();
}

uint64_t thunk for @callee_guaranteed () -> (@out A, @error @owned Error)(uint64_t (*a1)(void))
{
  return a1();
}

uint64_t closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_performAndWait<A>(fn:execute:rescue:)( uint64_t a1, void (*a2)(uint64_t), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = type metadata accessor for Optional();
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = MEMORY[0x1895F8858](v8);
  unsigned int v12 = (char *)&v14 - v11;
  a2(v10);
  (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(a5 - 8) + 56LL))(v12, 0LL, 1LL, a5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v9 + 40))(a1, v12, v8);
}

uint64_t closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_perform<A>(_:rescue:)( void (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = a3;
  uint64_t v27 = a1;
  uint64_t v5 = type metadata accessor for Optional();
  uint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = MEMORY[0x1895F8858](v5);
  uint64_t v9 = (char *)&v25 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = MEMORY[0x1895F8858](v7);
  unsigned int v12 = (void (*)(uint64_t))((char *)&v25 - v11);
  uint64_t v13 = MEMORY[0x1895F8858](v10);
  id v15 = (char *)&v25 - v14;
  MEMORY[0x1895F8858](v13);
  unsigned int v17 = (char *)&v25 - v16;
  uint64_t v18 = *(void *)(a4 - 8);
  char v25 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v18 + 56);
  uint64_t v19 = v25((char *)&v25 - v16, 1LL, 1LL, a4);
  v27(v19);
  uint64_t v27 = v12;
  id v20 = *(void (**)(char *, uint64_t))(v6 + 8);
  v20(v17, v5);
  uint64_t v21 = v25;
  v25(v15, 0LL, 1LL, a4);
  id v22 = *(void (**)(char *, char *, uint64_t))(v6 + 32);
  v22(v17, v15, v5);
  (*(void (**)(char *, char *, uint64_t))(v6 + 16))(v9, v17, v5);
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v18 + 48))(v9, 1LL, a4);
  if ((_DWORD)result == 1)
  {
    __break(1u);
  }

  else
  {
    int v24 = (char *)v27;
    (*(void (**)(void (*)(uint64_t), char *, uint64_t))(v18 + 32))(v27, v9, a4);
    v21(v24, 0LL, 1LL, a4);
    v22(*(char **)(*(void *)(v26 + 64) + 40LL), v24, v5);
    swift_continuation_throwingResume();
    return ((uint64_t (*)(char *, uint64_t))v20)(v17, v5);
  }

  return result;
}

uint64_t thunk for @escaping @callee_guaranteed () -> ()(uint64_t a1)
{
  unsigned int v1 = *(void (**)(uint64_t))(a1 + 32);
  uint64_t v2 = swift_retain();
  v1(v2);
  return swift_release();
}

{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

void NSPersistentStoreCoordinator.performAndWait<A>(_:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v22 = a4;
  uint64_t v25 = type metadata accessor for Optional();
  uint64_t v8 = *(void *)(v25 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v25);
  int v24 = (char *)&v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  unsigned int v12 = (char *)&v21 - v11;
  uint64_t v23 = *(void *)(a3 - 8);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 56))((char *)&v21 - v11, 1LL, 1LL, a3);
  uint64_t v33 = 0LL;
  uint64_t v13 = (void *)swift_allocObject();
  id v13[2] = a3;
  v13[3] = a1;
  v13[4] = a2;
  uint64_t v27 = a3;
  uint64_t v28 = v12;
  uint64_t v29 = partial apply for thunk for @callee_guaranteed () -> (@out A, @error @owned Error);
  uint64_t v30 = v13;
  uint64_t v31 = &v33;
  uint64_t v14 = swift_allocObject();
  *(void *)(v14 + 16) = partial apply for closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_performAndWait<A>(fn:execute:rescue:);
  *(void *)(v14 + 24) = &v26;
  aBlock[4] = partial apply for thunk for @callee_guaranteed () -> ();
  aBlock[5] = v14;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 1107296256LL;
  aBlock[2] = thunk for @escaping @callee_guaranteed () -> ();
  aBlock[3] = &block_descriptor;
  id v15 = _Block_copy(aBlock);
  id v16 = v4;
  swift_retain();
  swift_release();
  objc_msgSend(v16, sel_performBlockAndWait_, v15);
  _Block_release(v15);
  LOBYTE(v15) = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if ((v15 & 1) != 0)
  {
    __break(1u);
    goto LABEL_9;
  }

  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if ((isEscapingClosureAtFileLocation & 1) != 0)
  {
LABEL_9:
    __break(1u);
LABEL_10:

    __break(1u);
    return;
  }

  if (v33)
  {
    swift_willThrow();
    (*(void (**)(char *, uint64_t))(v8 + 8))(v12, v25);

    return;
  }

  uint64_t v19 = v24;
  uint64_t v18 = v25;
  (*(void (**)(char *, char *, uint64_t))(v8 + 16))(v24, v12, v25);
  uint64_t v20 = v23;
  (*(void (**)(char *, uint64_t))(v8 + 8))(v12, v18);
  (*(void (**)(uint64_t, char *, uint64_t))(v20 + 32))(v22, v19, a3);
}

uint64_t thunk for @callee_guaranteed () -> ()(uint64_t (*a1)(void))
{
  return a1();
}

uint64_t NSPersistentStoreCoordinator.perform<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[19] = a4;
  v5[20] = v4;
  v5[17] = a2;
  v5[18] = a3;
  v5[16] = a1;
  uint64_t v6 = type metadata accessor for Optional();
  v5[21] = v6;
  v5[22] = *(void *)(v6 - 8);
  v5[23] = swift_task_alloc();
  v5[24] = swift_task_alloc();
  v5[25] = swift_task_alloc();
  v5[26] = swift_task_alloc();
  return swift_task_switch();
}

uint64_t NSPersistentStoreCoordinator.perform<A>(_:)()
{
  uint64_t v1 = v0[26];
  uint64_t v2 = *(void *)(v0[19] - 8LL);
  v0[27] = v2;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v2 + 56))(v1, 1LL, 1LL);
  return swift_task_switch();
}

{
  void *v0;
  void *v1;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v1 = v0;
  uint64_t v2 = v0[24];
  uint64_t v3 = (void *)v0[20];
  uint64_t v4 = v1[18];
  uint64_t v5 = v1[19];
  uint64_t v6 = v1[17];
  v1[7] = v2;
  v1[2] = v1;
  v1[3] = NSPersistentStoreCoordinator.perform<A>(_:);
  uint64_t v7 = swift_continuation_init();
  uint64_t v8 = (void *)swift_allocObject();
  v8[2] = v5;
  v8[3] = v6;
  v1[10] = MEMORY[0x1895F87A8];
  v1 += 10;
  v8[4] = v4;
  v8[5] = v7;
  v1[4] = partial apply for closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_perform<A>(_:rescue:);
  v1[5] = v8;
  v1[1] = 1107296256LL;
  v1[2] = thunk for @escaping @callee_guaranteed () -> ();
  v1[3] = &block_descriptor_9;
  uint64_t v9 = _Block_copy(v1);
  swift_retain();
  swift_release();
  objc_msgSend(v3, sel_performBlock_, v9);
  _Block_release(v9);
  return swift_continuation_await();
}

{
  uint64_t v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t v1 = *(void **)v0;
  uint64_t v2 = *(void *)(*(void *)v0 + 48LL);
  *(void *)(*(void *)v0 + 224LL) = v2;
  if (v2)
  {
    swift_willThrow();
  }

  else
  {
    uint64_t v4 = v1[24];
    uint64_t v3 = v1[25];
    uint64_t v5 = v1[21];
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(v1[22] + 32LL);
    v1[29] = v6;
    v6(v3, v4, v5);
  }

  return swift_task_switch();
}

{
  uint64_t v0;
  void (*v1)(uint64_t, uint64_t, uint64_t);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v1 = *(void (**)(uint64_t, uint64_t, uint64_t))(v0 + 232);
  uint64_t v2 = *(void *)(v0 + 208);
  uint64_t v3 = *(void *)(v0 + 216);
  uint64_t v4 = *(void *)(v0 + 200);
  uint64_t v6 = *(void *)(v0 + 176);
  uint64_t v5 = *(void *)(v0 + 184);
  uint64_t v7 = *(void *)(v0 + 168);
  uint64_t v8 = *(void *)(v0 + 152);
  uint64_t v9 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
  v9(v2, v7);
  v1(v2, v4, v7);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16))(v5, v2, v7);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 48))(v5, 1LL, v8);
  if ((_DWORD)result == 1)
  {
    __break(1u);
  }

  else
  {
    uint64_t v11 = *(void *)(v0 + 216);
    unsigned int v12 = *(void *)(v0 + 184);
    uint64_t v13 = *(void *)(v0 + 152);
    uint64_t v14 = *(void *)(v0 + 128);
    v9(*(void *)(v0 + 208), *(void *)(v0 + 168));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v11 + 32))(v14, v12, v13);
    swift_task_dealloc();
    swift_task_dealloc();
    swift_task_dealloc();
    swift_task_dealloc();
    return (*(uint64_t (**)(void))(v0 + 8))();
  }

  return result;
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v1 = *(void *)(v0 + 208);
  uint64_t v2 = *(void *)(v0 + 168);
  uint64_t v3 = *(void *)(v0 + 176);
  swift_willThrow();
  (*(void (**)(uint64_t, uint64_t))(v3 + 8))(v1, v2);
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  return (*(uint64_t (**)(void))(v0 + 8))();
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance NSManagedObjectContextConcurrencyType()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance NSAttributeType()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance NSManagedObjectContextConcurrencyType()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance NSAttributeType( void *a1, void *a2)
{
  return *a1 == *a2;
}

void *protocol witness for RawRepresentable.init(rawValue:) in conformance NSAttributeType@<X0>( void *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = *result;
  *(_BYTE *)(a2 + _Block_object_dispose(va, 8) = 0;
  return result;
}

void protocol witness for RawRepresentable.rawValue.getter in conformance NSAttributeType(void *a1@<X8>)
{
  *a1 = *v1;
}

uint64_t static String._copying(_:)()
{
  unint64_t v0 = String.subscript.getter();
  uint64_t v4 = static String._copying(_:)(v0, v1, v2, v3);
  swift_bridgeObjectRelease();
  return v4;
}

uint64_t static String._copying(_:)( unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if ((a4 & 0x1000000000000000LL) != 0)
  {
    unint64_t v9 = specialized Collection.count.getter(a1, a2, a3, a4);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)(v9, 0LL);
      unint64_t v12 = specialized Sequence._copySequenceContents(initializing:)( (unint64_t)v14,  (uint64_t)(v11 + 4),  v10,  a1,  a2,  a3,  a4);
      swift_bridgeObjectRetain();
      swift_bridgeObjectRelease();
      if (v12 != v10)
      {
        __break(1u);
        goto LABEL_9;
      }
    }

    else
    {
      uint64_t v11 = (void *)MEMORY[0x18961AFE8];
    }

    uint64_t v13 = MEMORY[0x186E3D7EC](v11 + 4, v11[2]);
    swift_release();
    return v13;
  }

  else
  {
    if ((a4 & 0x2000000000000000LL) == 0)
    {
      if ((a3 & 0x1000000000000000LL) != 0) {
LABEL_12:
      }
        JUMPOUT(0x186E3D7ECLL);
LABEL_9:
      _StringObject.sharedUTF8.getter();
      goto LABEL_12;
    }

    v14[0] = a3;
    v14[1] = a4 & 0xFFFFFFFFFFFFFFLL;
    return MEMORY[0x186E3D7EC]((char *)v14 + (a1 >> 16), (a2 >> 16) - (a1 >> 16));
  }

unint64_t specialized Collection.count.getter( unint64_t result, unint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = (a3 >> 59) & 1;
  if ((a4 & 0x1000000000000000LL) == 0) {
    LOBYTE(v_Block_object_dispose(va, 8) = 1;
  }
  uint64_t v9 = 4LL << v8;
  if ((result & 0xC) == 4LL << v8)
  {
    uint64_t result = _StringGuts._slowEnsureMatchingEncoding(_:)(result, a3, a4);
    unint64_t v7 = result;
  }

  if ((a2 & 0xC) == v9)
  {
    uint64_t result = _StringGuts._slowEnsureMatchingEncoding(_:)(a2, a3, a4);
    a2 = result;
    if ((a4 & 0x1000000000000000LL) == 0) {
      return (a2 >> 16) - (v7 >> 16);
    }
  }

  else if ((a4 & 0x1000000000000000LL) == 0)
  {
    return (a2 >> 16) - (v7 >> 16);
  }

  unint64_t v10 = HIBYTE(a4) & 0xF;
  if ((a4 & 0x2000000000000000LL) == 0) {
    unint64_t v10 = a3 & 0xFFFFFFFFFFFFLL;
  }
  if (v10 < v7 >> 16)
  {
    __break(1u);
  }

  else if (v10 >= a2 >> 16)
  {
    return String.UTF8View._foreignDistance(from:to:)();
  }

  __break(1u);
  return result;
}

void *specialized _ContiguousArrayBuffer.init(_uninitializedCount:minimumCapacity:)( uint64_t a1, uint64_t a2)
{
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return (void *)MEMORY[0x18961AFE8];
  }
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<UInt8>);
  uint64_t v4 = (void *)swift_allocObject();
  size_t v5 = _swift_stdlib_malloc_size(v4);
  v4[2] = a1;
  v4[3] = 2 * v5 - 64;
  return v4;
}

unint64_t specialized Sequence._copySequenceContents(initializing:)( unint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7)
{
  uint64_t v9 = (void *)result;
  if (!a2) {
    goto LABEL_5;
  }
  if (!a3)
  {
    unint64_t v12 = a4;
    uint64_t v11 = 0LL;
    goto LABEL_33;
  }

  if (a3 < 0) {
    goto LABEL_36;
  }
  unint64_t v10 = a5 >> 14;
  unint64_t v27 = a4 >> 14;
  if (a4 >> 14 == a5 >> 14)
  {
LABEL_5:
    uint64_t v11 = 0LL;
    unint64_t v12 = a4;
LABEL_33:
    void *v9 = a4;
    v9[1] = a5;
    v9[2] = a6;
    v9[3] = a7;
    v9[4] = v12;
    return v11;
  }

  uint64_t v11 = 0LL;
  uint64_t v14 = (a6 >> 59) & 1;
  if ((a7 & 0x1000000000000000LL) == 0) {
    LOBYTE(v14) = 1;
  }
  uint64_t v15 = 4LL << v14;
  uint64_t v21 = (a7 & 0xFFFFFFFFFFFFFFFLL) + 32;
  uint64_t v22 = a7 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v16 = HIBYTE(a7) & 0xF;
  if ((a7 & 0x2000000000000000LL) == 0) {
    uint64_t v16 = a6 & 0xFFFFFFFFFFFFLL;
  }
  unint64_t v23 = v16;
  uint64_t v26 = a3 - 1;
  unint64_t v12 = a4;
  while (1)
  {
    unint64_t v17 = v12 & 0xC;
    uint64_t result = v12;
    if (v17 == v15) {
      uint64_t result = _StringGuts._slowEnsureMatchingEncoding(_:)(v12, a6, a7);
    }
    if (result >> 14 < v27 || result >> 14 >= v10) {
      break;
    }
    if ((a7 & 0x1000000000000000LL) != 0)
    {
      uint64_t result = String.UTF8View._foreignSubscript(position:)();
      char v19 = result;
      if (v17 != v15) {
        goto LABEL_23;
      }
    }

    else
    {
      unint64_t v18 = result >> 16;
      if ((a7 & 0x2000000000000000LL) != 0)
      {
        v28[0] = a6;
        v28[1] = v22;
        char v19 = *((_BYTE *)v28 + v18);
        if (v17 != v15) {
          goto LABEL_23;
        }
      }

      else
      {
        uint64_t result = v21;
        if ((a6 & 0x1000000000000000LL) == 0) {
          uint64_t result = _StringObject.sharedUTF8.getter();
        }
        char v19 = *(_BYTE *)(result + v18);
        if (v17 != v15)
        {
LABEL_23:
          if ((a7 & 0x1000000000000000LL) == 0) {
            goto LABEL_24;
          }
          goto LABEL_27;
        }
      }
    }

    uint64_t result = _StringGuts._slowEnsureMatchingEncoding(_:)(v12, a6, a7);
    unint64_t v12 = result;
    if ((a7 & 0x1000000000000000LL) == 0)
    {
LABEL_24:
      unint64_t v12 = (v12 & 0xFFFFFFFFFFFF0000LL) + 65540;
      goto LABEL_29;
    }

uint64_t _StringGuts._slowEnsureMatchingEncoding(_:)(unint64_t a1, uint64_t a2, uint64_t a3)
{
  char v3 = a1;
  uint64_t v4 = (unsigned __int16)a1 >> 14;
  if ((a3 & 0x1000000000000000LL) == 0 || (a2 & 0x800000000000000LL) != 0)
  {
    uint64_t v10 = String.UTF16View.index(_:offsetBy:)();
    uint64_t v11 = v10 + (v4 << 16);
    unint64_t v12 = v10 & 0xFFFFFFFFFFFFFFFCLL | v3 & 3;
    unint64_t v13 = v11 & 0xFFFFFFFFFFFF0000LL;
    if (!v4) {
      unint64_t v13 = v12;
    }
    return v13 | 4;
  }

  else
  {
    uint64_t v5 = MEMORY[0x186E3D810](15LL, a1 >> 16);
    uint64_t v6 = v5 + (v4 << 16);
    unint64_t v7 = v5 & 0xFFFFFFFFFFFFFFFCLL | v3 & 3;
    unint64_t v8 = v6 & 0xFFFFFFFFFFFF0000LL;
    if (!v4) {
      unint64_t v8 = v7;
    }
    return v8 | 8;
  }

id specialized String.withUTF8<A>(_:)(uint64_t *a1, id a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  if ((v4 & 0x1000000000000000LL) == 0)
  {
    if ((v4 & 0x2000000000000000LL) == 0) {
      goto LABEL_3;
    }
LABEL_7:
    v13[0] = v3;
    v13[1] = v4 & 0xFFFFFFFFFFFFFFLL;
    id v7 = objc_msgSend(a2, sel_managedObjectIDFromUTF8String_length_, v13, HIBYTE(v4) & 0xF);
    return v7;
  }

  uint64_t v3 = static String._copying(_:)();
  uint64_t v10 = v9;
  swift_bridgeObjectRelease();
  *a1 = v3;
  a1[1] = v10;
  unint64_t v4 = v10;
  if ((v10 & 0x2000000000000000LL) != 0) {
    goto LABEL_7;
  }
LABEL_3:
  if ((v3 & 0x1000000000000000LL) != 0)
  {
    id v5 = (id)((v4 & 0xFFFFFFFFFFFFFFFLL) + 32);
    uint64_t v6 = v3 & 0xFFFFFFFFFFFFLL;
LABEL_5:
    id v7 = objc_msgSend(a2, sel_managedObjectIDFromUTF8String_length_, v5, v6);
    return v7;
  }

  id result = (id)_StringObject.sharedUTF8.getter();
  if (result)
  {
    id v5 = result;
    uint64_t v6 = v12;
    goto LABEL_5;
  }

  __break(1u);
  return result;
}

uint64_t sub_1866B6B18()
{
  return swift_deallocObject();
}

uint64_t partial apply for thunk for @callee_guaranteed () -> (@out A, @error @owned Error)()
{
  return (*(uint64_t (**)(void))(v0 + 24))();
}

uint64_t partial apply for closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_performAndWait<A>(fn:execute:rescue:)()
{
  return closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_performAndWait<A>(fn:execute:rescue:)( *(void *)(v0 + 24),  *(void (**)(uint64_t))(v0 + 32),  *(void *)(v0 + 40),  *(void *)(v0 + 48),  *(void *)(v0 + 16));
}

uint64_t sub_1866B6B58()
{
  return swift_deallocObject();
}

uint64_t partial apply for thunk for @callee_guaranteed () -> ()()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t block_copy_helper(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper()
{
  return swift_release();
}

uint64_t sub_1866B6BA0()
{
  return swift_deallocObject();
}

uint64_t partial apply for closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_perform<A>(_:rescue:)()
{
  return closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_perform<A>(_:rescue:)( *(void (**)(uint64_t))(v0 + 24),  *(void *)(v0 + 32),  *(void *)(v0 + 40),  *(void *)(v0 + 16));
}

void type metadata accessor for NSAttributeType(uint64_t a1)
{
}

void type metadata accessor for NSManagedObjectContextConcurrencyType(uint64_t a1)
{
}

void type metadata accessor for NSAttributeType(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v4) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }

uint64_t base witness table accessor for Equatable in NSManagedObjectContextConcurrencyType()
{
  return lazy protocol witness table accessor for type NSManagedObjectContextConcurrencyType and conformance NSManagedObjectContextConcurrencyType( &lazy protocol witness table cache variable for type NSManagedObjectContextConcurrencyType and conformance NSManagedObjectContextConcurrencyType,  (uint64_t (*)(uint64_t))type metadata accessor for NSManagedObjectContextConcurrencyType,  (uint64_t)&protocol conformance descriptor for NSManagedObjectContextConcurrencyType);
}

uint64_t base witness table accessor for Equatable in NSAttributeType()
{
  return lazy protocol witness table accessor for type NSManagedObjectContextConcurrencyType and conformance NSManagedObjectContextConcurrencyType( &lazy protocol witness table cache variable for type NSAttributeType and conformance NSAttributeType,  (uint64_t (*)(uint64_t))type metadata accessor for NSAttributeType,  (uint64_t)&protocol conformance descriptor for NSAttributeType);
}

uint64_t lazy protocol witness table accessor for type NSManagedObjectContextConcurrencyType and conformance NSManagedObjectContextConcurrencyType( unint64_t *a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v6 = a2(255LL);
    uint64_t result = MEMORY[0x186E3F040](a3, v6);
    atomic_store(result, a1);
  }

  return result;
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = MEMORY[0x186E3F034]((char *)a1 + (int)result, -(result >> 32), 0LL, 0LL);
    *a1 = result;
  }

  return result;
}

id NSMigrationManager.migrateStore(from:type:options:mapping:to:type:options:)( uint64_t a1, uint64_t *a2, Class isa, uint64_t a4, uint64_t a5, uint64_t *a6, Class a7)
{
  uint64_t v26 = (NSURL *)*MEMORY[0x1895F89C0];
  uint64_t v10 = *a2;
  uint64_t v9 = a2[1];
  uint64_t v11 = *a6;
  uint64_t v12 = a6[1];
  URL._bridgeToObjectiveC()(v26);
  uint64_t v14 = v13;
  uint64_t v16 = (void *)MEMORY[0x186E3D7D4](v10, v9);
  if (isa) {
    isa = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  URL._bridgeToObjectiveC()(v15);
  unint64_t v18 = v17;
  char v19 = (void *)MEMORY[0x186E3D7D4](v11, v12);
  if (a7) {
    a7 = Dictionary._bridgeToObjectiveC()().super.isa;
  }
  id v25 = 0LL;
  unsigned int v20 = objc_msgSend( v23,  sel_migrateStoreFromURL_type_options_withMappingModel_toDestinationURL_destinationType_destinationOptions_error_,  v14,  v16,  isa,  a4,  v18,  v19,  a7,  &v25);

  if (v20) {
    return v25;
  }
  id v22 = v25;
  _convertNSErrorToError(_:)();

  return (id)swift_willThrow();
}

id NSExpressionDescription.resultType.getter@<X0>(void *a1@<X8>)
{
  id result = objc_msgSend(v1, sel_expressionResultType);
  *a1 = result;
  return result;
}

id NSExpressionDescription.resultType.setter(void *a1)
{
  return objc_msgSend(v1, sel_setExpressionResultType_, *a1);
}

id (*NSExpressionDescription.resultType.modify(void *a1))(uint64_t a1)
{
  a1[1] = v1;
  *a1 = objc_msgSend(v1, sel_expressionResultType);
  return NSExpressionDescription.resultType.modify;
}

id NSExpressionDescription.resultType.modify(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 8), sel_setExpressionResultType_, *(void *)a1);
}

id sub_1866B6F74@<X0>(id *a1@<X0>, void *a2@<X8>)
{
  id result = objc_msgSend(*a1, sel_expressionResultType);
  *a2 = result;
  return result;
}

id sub_1866B6FA4(void *a1, id *a2)
{
  return objc_msgSend(*a2, sel_setExpressionResultType_, *a1);
}

NSLightweightMigrationStage __swiftcall NSLightweightMigrationStage.init(_:)(Swift::OpaquePointer a1)
{
  id v1 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  Class isa = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  uint64_t v3 = (objc_class *)objc_msgSend(v1, sel_initWithVersionChecksums_, isa);

  id v7 = v3;
  result._subsequentStage = v6;
  result._versionChecksums = v5;
  result.super._label = v4;
  result.super.super.Class isa = v7;
  return result;
}

NSStagedMigrationManager __swiftcall NSStagedMigrationManager.init(_:)(Swift::OpaquePointer a1)
{
  id v1 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  type metadata accessor for NSMigrationStage();
  Class isa = Array._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease();
  uint64_t v3 = (objc_class *)objc_msgSend(v1, sel_initWithMigrationStages_, isa);

  uint64_t v6 = v3;
  result._container = v5;
  result._stages = v4;
  result.super.Class isa = v6;
  return result;
}

unint64_t type metadata accessor for NSMigrationStage()
{
  unint64_t result = lazy cache variable for type metadata for NSMigrationStage;
  if (!lazy cache variable for type metadata for NSMigrationStage)
  {
    objc_opt_self();
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&lazy cache variable for type metadata for NSMigrationStage);
  }

  return result;
}

id NSManagedObjectContext.fetch<A>(_:)(uint64_t a1)
{
  v10[1] = *(id *)MEMORY[0x1895F89C0];
  v10[0] = 0LL;
  id v2 = objc_msgSend(v1, sel_executeRequest_error_, a1, v10);
  id v3 = v10[0];
  if (!v2)
  {
    id v9 = v10[0];
    _convertNSErrorToError(_:)();

    swift_willThrow();
    return v9;
  }

  uint64_t v4 = v2;
  objc_opt_self();
  id v5 = (void *)swift_dynamicCastObjCClassUnconditional();
  id v6 = v3;
  id result = objc_msgSend(v5, sel_finalResult);
  if (result)
  {
    unint64_t v8 = result;
    id v9 = (id)static Array._unconditionallyBridgeFromObjectiveC(_:)();

    return v9;
  }

  __break(1u);
  return result;
}

char *NSManagedObjectContext.fetch(_:)(uint64_t a1)
{
  v11[1] = *(id *)MEMORY[0x1895F89C0];
  v11[0] = 0LL;
  id v2 = objc_msgSend(v1, sel_executeRequest_error_, a1, v11);
  id v3 = (char *)v11[0];
  if (!v2)
  {
    id v10 = v11[0];
    _convertNSErrorToError(_:)();

    swift_willThrow();
    return v3;
  }

  uint64_t v4 = v2;
  objc_opt_self();
  id v5 = (void *)swift_dynamicCastObjCClassUnconditional();
  id v6 = v3;
  id result = (char *)objc_msgSend(v5, sel_finalResult);
  if (result)
  {
    unint64_t v8 = result;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for NSFetchRequestResult);
    unint64_t v9 = static Array._unconditionallyBridgeFromObjectiveC(_:)();

    id v3 = specialized _arrayForceCast<A, B>(_:)(v9);
    swift_bridgeObjectRelease();
    return v3;
  }

  __break(1u);
  return result;
}

char *specialized _arrayForceCast<A, B>(_:)(unint64_t a1)
{
  if (a1 >> 62)
  {
    swift_bridgeObjectRetain();
    uint64_t v2 = _CocoaArrayWrapper.endIndex.getter();
    swift_bridgeObjectRelease();
  }

  else
  {
    uint64_t v2 = *(void *)((a1 & 0xFFFFFFFFFFFFF8LL) + 0x10);
  }

  uint64_t v3 = MEMORY[0x18961AFE8];
  if (!v2) {
    return (char *)v3;
  }
  uint64_t v12 = MEMORY[0x18961AFE8];
  id result = specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  v2 & ~(v2 >> 63),  0);
  if ((v2 & 0x8000000000000000LL) == 0)
  {
    if ((a1 & 0xC000000000000001LL) != 0)
    {
      uint64_t v5 = 0LL;
      uint64_t v3 = v12;
      do
      {
        MEMORY[0x186E3D87C](v5, a1);
        __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for NSFetchRequestResult);
        swift_dynamicCast();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v3 + 16) + 1LL,  1);
          uint64_t v3 = v12;
        }

        unint64_t v7 = *(void *)(v3 + 16);
        unint64_t v6 = *(void *)(v3 + 24);
        if (v7 >= v6 >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (char *)(v6 > 1),  v7 + 1,  1);
          uint64_t v3 = v12;
        }

        ++v5;
        *(void *)(v3 + 16) = v7 + 1;
        outlined init with take of Any(v11, (_OWORD *)(v3 + 32 * v7 + 32));
      }

      while (v2 != v5);
    }

    else
    {
      unint64_t v8 = a1 + 32;
      uint64_t v3 = v12;
      do
      {
        swift_unknownObjectRetain();
        __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for NSFetchRequestResult);
        swift_dynamicCast();
        if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( 0LL,  *(void *)(v3 + 16) + 1LL,  1);
          uint64_t v3 = v12;
        }

        unint64_t v10 = *(void *)(v3 + 16);
        unint64_t v9 = *(void *)(v3 + 24);
        if (v10 >= v9 >> 1)
        {
          specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( (char *)(v9 > 1),  v10 + 1,  1);
          uint64_t v3 = v12;
        }

        *(void *)(v3 + 16) = v10 + 1;
        outlined init with take of Any(v11, (_OWORD *)(v3 + 32 * v10 + 32));
        v8 += 8LL;
        --v2;
      }

      while (v2);
    }

    return (char *)v3;
  }

  __break(1u);
  return result;
}

id NSManagedObjectContext.count<A>(for:)(uint64_t a1)
{
  v4[1] = *(id *)MEMORY[0x1895F89C0];
  v4[0] = 0LL;
  id v2 = objc_msgSend(v1, sel_countForFetchRequest_error_, a1, v4);
  if (v4[0])
  {
    v4[0];
    swift_willThrow();
  }

  return v2;
}

uint64_t one-time initialization function for willSaveObjectsNotification()
{
  uint64_t result = MEMORY[0x186E3D7D4](0xD00000000000002CLL, 0x80000001868D6B90LL);
  static NSManagedObjectContext.willSaveObjectsNotification = result;
  return result;
}

id static NSManagedObjectContext.willSaveObjectsNotification.getter()
{
  return static NSManagedObjectContext.willSaveObjectsNotification.getter( one-time initialization token for willSaveObjectsNotification,  (id *)&static NSManagedObjectContext.willSaveObjectsNotification);
}

uint64_t one-time initialization function for didSaveObjectsNotification()
{
  uint64_t result = MEMORY[0x186E3D7D4](0xD00000000000002BLL, 0x80000001868D6B60LL);
  static NSManagedObjectContext.didSaveObjectsNotification = result;
  return result;
}

id static NSManagedObjectContext.didSaveObjectsNotification.getter()
{
  return static NSManagedObjectContext.willSaveObjectsNotification.getter( &one-time initialization token for didSaveObjectsNotification,  (id *)&static NSManagedObjectContext.didSaveObjectsNotification);
}

uint64_t one-time initialization function for didChangeObjectsNotification()
{
  uint64_t result = MEMORY[0x186E3D7D4](0xD00000000000002DLL, 0x80000001868D6B30LL);
  static NSManagedObjectContext.didChangeObjectsNotification = result;
  return result;
}

id static NSManagedObjectContext.didChangeObjectsNotification.getter()
{
  return static NSManagedObjectContext.willSaveObjectsNotification.getter( &one-time initialization token for didChangeObjectsNotification,  (id *)&static NSManagedObjectContext.didChangeObjectsNotification);
}

uint64_t one-time initialization function for didSaveObjectIDsNotification()
{
  uint64_t result = MEMORY[0x186E3D7D4](0xD000000000000032LL, 0x80000001868D6AF0LL);
  static NSManagedObjectContext.didSaveObjectIDsNotification = result;
  return result;
}

id static NSManagedObjectContext.didSaveObjectIDsNotification.getter()
{
  return static NSManagedObjectContext.willSaveObjectsNotification.getter( &one-time initialization token for didSaveObjectIDsNotification,  (id *)&static NSManagedObjectContext.didSaveObjectIDsNotification);
}

uint64_t one-time initialization function for didMergeChangesObjectIDsNotification()
{
  uint64_t result = MEMORY[0x186E3D7D4](0xD00000000000003ALL, 0x80000001868D6AB0LL);
  static NSManagedObjectContext.didMergeChangesObjectIDsNotification = result;
  return result;
}

id static NSManagedObjectContext.didMergeChangesObjectIDsNotification.getter()
{
  return static NSManagedObjectContext.willSaveObjectsNotification.getter( &one-time initialization token for didMergeChangesObjectIDsNotification,  (id *)&static NSManagedObjectContext.didMergeChangesObjectIDsNotification);
}

id static NSManagedObjectContext.willSaveObjectsNotification.getter(void *a1, id *a2)
{
  if (*a1 != -1LL) {
    swift_once();
  }
  return *a2;
}

uint64_t NSManagedObjectContext.NotificationKey.init(rawValue:)@<X0>( Swift::String string@<0:X0, 8:X1>, char *a2@<X8>)
{
  object = string._object;
  v3._countAndFlagsBits = string._countAndFlagsBits;
  v3._object = object;
  unint64_t v5 = _findStringSwitchCase(cases:string:)( (Swift::OpaquePointer)&outlined read-only object #0 of NSManagedObjectContext.NotificationKey.init(rawValue:),  v3);
  uint64_t result = swift_bridgeObjectRelease();
  char v7 = 12;
  if (v5 < 0xC) {
    char v7 = v5;
  }
  *a2 = v7;
  return result;
}

uint64_t NSManagedObjectContext.NotificationKey.rawValue.getter()
{
  return ((uint64_t (*)(unint64_t, unint64_t))((char *)sub_1866B7868 + 4 * byte_1868D5670[*v0]))( 0xD000000000000012LL,  0x80000001868D69B0LL);
}

uint64_t sub_1866B7868()
{
  return 0x6164696C61766E69LL;
}

uint64_t sub_1866B78F8@<X0>(uint64_t a1@<X8>)
{
  return a1 + 1;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance NSManagedObjectContext.NotificationKey()
{
  return specialized == infix<A>(_:_:)();
}

uint64_t specialized == infix<A>(_:_:)()
{
  uint64_t v0 = NSManagedObjectContext.NotificationKey.rawValue.getter();
  uint64_t v2 = v1;
  if (v0 == NSManagedObjectContext.NotificationKey.rawValue.getter() && v2 == v3) {
    char v5 = 1;
  }
  else {
    char v5 = _stringCompareWithSmolCheck(_:_:expecting:)();
  }
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v5 & 1;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance NSManagedObjectContext.NotificationKey()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance NSManagedObjectContext.NotificationKey()
{
  return swift_bridgeObjectRelease();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance NSManagedObjectContext.NotificationKey()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for RawRepresentable.init(rawValue:) in conformance NSManagedObjectContext.NotificationKey@<X0>( Swift::String *a1@<X0>, char *a2@<X8>)
{
  return NSManagedObjectContext.NotificationKey.init(rawValue:)(*a1, a2);
}

uint64_t protocol witness for RawRepresentable.rawValue.getter in conformance NSManagedObjectContext.NotificationKey@<X0>( uint64_t *a1@<X8>)
{
  uint64_t result = NSManagedObjectContext.NotificationKey.rawValue.getter();
  *a1 = result;
  a1[1] = v3;
  return result;
}

uint64_t NSManagedObjectContext.ConcurrencyType.init(rawValue:)@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  return result;
}

void static NSManagedObjectContext.ConcurrencyType.privateQueue.getter(void *a1@<X8>)
{
  *a1 = 1LL;
}

void static NSManagedObjectContext.ConcurrencyType.mainQueue.getter(void *a1@<X8>)
{
  *a1 = 2LL;
}

uint64_t NSManagedObjectContext.ConcurrencyType.rawValue.getter()
{
  return *(void *)v0;
}

uint64_t NSManagedObjectContext.ConcurrencyType.rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*NSManagedObjectContext.ConcurrencyType.rawValue.modify())()
{
  return NSManagedObjectContext.ConcurrencyType.rawValue.modify;
}

BOOL static NSManagedObjectContext.ScheduledTaskType.== infix(_:_:)( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

void NSManagedObjectContext.ScheduledTaskType.hash(into:)()
{
}

Swift::Int NSManagedObjectContext.ScheduledTaskType.hashValue.getter()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

BOOL protocol witness for static Equatable.== infix(_:_:) in conformance NSManagedObjectContext.ScheduledTaskType( unsigned __int8 *a1, unsigned __int8 *a2)
{
  return ((*a1 ^ *a2) & 1) == 0;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance NSManagedObjectContext.ScheduledTaskType()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

void protocol witness for Hashable.hash(into:) in conformance NSManagedObjectContext.ScheduledTaskType()
{
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance NSManagedObjectContext.ScheduledTaskType()
{
  Swift::UInt v1 = *v0;
  Hasher.init(_seed:)();
  Hasher._combine(_:)(v1);
  return Hasher._finalize()();
}

id NSManagedObjectContext.init(_:)(void *a1)
{
  return objc_msgSend(objc_allocWithZone((Class)swift_getObjCClassFromMetadata()), sel_initWithConcurrencyType_, *a1);
}

void NSManagedObjectContext.performAndWait<A>(_:)( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v22 = a4;
  uint64_t v25 = type metadata accessor for Optional();
  uint64_t v8 = *(void *)(v25 - 8);
  uint64_t v9 = MEMORY[0x1895F8858](v25);
  int v24 = (char *)&v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  MEMORY[0x1895F8858](v9);
  uint64_t v12 = (char *)&v21 - v11;
  uint64_t v23 = *(void *)(a3 - 8);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(v23 + 56))((char *)&v21 - v11, 1LL, 1LL, a3);
  uint64_t v33 = 0LL;
  unint64_t v13 = (void *)swift_allocObject();
  void v13[2] = a3;
  v13[3] = a1;
  v13[4] = a2;
  uint64_t v27 = a3;
  uint64_t v28 = v12;
  uint64_t v29 = _sxs5Error_pIgrzo_xsAA_pIegrzo_lTRTA_0;
  uint64_t v30 = v13;
  uint64_t v31 = &v33;
  uint64_t v14 = swift_allocObject();
  *(void *)(v14 + 16) = partial apply for closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_performAndWait<A>(fn:execute:rescue:);
  *(void *)(v14 + 24) = &v26;
  aBlock[4] = _sIg_Ieg_TRTA_0;
  aBlock[5] = v14;
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 1107296256LL;
  aBlock[2] = thunk for @escaping @callee_guaranteed () -> ();
  aBlock[3] = &block_descriptor_0;
  uint64_t v15 = _Block_copy(aBlock);
  id v16 = v4;
  swift_retain();
  swift_release();
  objc_msgSend(v16, sel_performBlockAndWait_, v15);
  _Block_release(v15);
  LOBYTE(v15) = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if ((v15 & 1) != 0)
  {
    __break(1u);
    goto LABEL_9;
  }

  char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
  swift_release();
  if ((isEscapingClosureAtFileLocation & 1) != 0)
  {
LABEL_9:
    __break(1u);
LABEL_10:

    __break(1u);
    return;
  }

  if (v33)
  {
    swift_willThrow();
    (*(void (**)(char *, uint64_t))(v8 + 8))(v12, v25);

    return;
  }

  char v19 = v24;
  uint64_t v18 = v25;
  (*(void (**)(char *, char *, uint64_t))(v8 + 16))(v24, v12, v25);
  uint64_t v20 = v23;
  (*(void (**)(char *, uint64_t))(v8 + 8))(v12, v18);
  (*(void (**)(uint64_t, char *, uint64_t))(v20 + 32))(v22, v19, a3);
}

uint64_t sub_1866B7FA8()
{
  return swift_deallocObject();
}

uint64_t _sxs5Error_pIgrzo_xsAA_pIegrzo_lTRTA_0()
{
  return thunk for @callee_guaranteed () -> (@out A, @error @owned Error)(*(uint64_t (**)(void))(v0 + 24));
}

uint64_t sub_1866B7FD4()
{
  return swift_deallocObject();
}

uint64_t _sIg_Ieg_TRTA_0()
{
  return thunk for @callee_guaranteed () -> ()(*(uint64_t (**)(void))(v0 + 16));
}

uint64_t block_copy_helper_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper_0()
{
  return swift_release();
}

uint64_t NSManagedObjectContext.perform<A>(schedule:_:)( uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(v6 + 24_Block_object_dispose(va, 8) = a5;
  *(void *)(v6 + 256) = v5;
  *(void *)(v6 + 232) = a3;
  *(void *)(v6 + 240) = a4;
  *(void *)(v6 + 224) = a1;
  uint64_t v8 = type metadata accessor for Optional();
  *(void *)(v6 + 264) = v8;
  *(void *)(v6 + 272) = *(void *)(v8 - 8);
  *(void *)(v6 + 280) = swift_task_alloc();
  *(void *)(v6 + 28_Block_object_dispose(va, 8) = swift_task_alloc();
  *(void *)(v6 + 296) = swift_task_alloc();
  *(void *)(v6 + 304) = swift_task_alloc();
  *(void *)(v6 + 312) = swift_task_alloc();
  *(void *)(v6 + 320) = swift_task_alloc();
  *(_BYTE *)(v6 + 36_Block_object_dispose(va, 8) = *a2;
  return swift_task_switch();
}

uint64_t NSManagedObjectContext.perform<A>(schedule:_:)()
{
  if (*((_BYTE *)v0 + 368) == 1)
  {
    Swift::UInt v1 = 0LL;
    uint64_t v2 = 0LL;
    uint64_t v3 = v0[31];
    uint64_t v4 = *(void *)(v3 - 8);
    uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v4 + 56);
LABEL_8:
    v0[42] = v1;
    v0[43] = v2;
    v0[41] = v4;
    v5(v0[38], 1LL, 1LL, v3);
    return swift_task_switch();
  }

  id v33 = (id)v0[32];
  uint64_t v6 = v0[30];
  uint64_t v7 = v0[31];
  uint64_t v8 = v0[29];
  uint64_t v9 = swift_allocBox();
  uint64_t v31 = v10;
  uint64_t v32 = *(void *)(v7 - 8);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v32 + 56);
  v5(v10, 1LL, 1LL, v7);
  uint64_t v11 = swift_allocObject();
  *(void *)(v11 + 16) = 0LL;
  uint64_t v12 = (id *)(v11 + 16);
  uint64_t v2 = (void *)swift_allocObject();
  v2[2] = v7;
  v2[3] = v8;
  v2[4] = v6;
  v2[5] = v9;
  v2[6] = v11;
  uint64_t v13 = swift_allocObject();
  v0[16] = MEMORY[0x1895F87A8];
  *(void *)(v13 + 16) = partial apply for closure #1 in NSManagedObjectContext.perform<A>(schedule:_:);
  *(void *)(v13 + 24) = v2;
  v0[20] = thunk for @callee_guaranteed () -> ()partial apply;
  v0[21] = v13;
  v0[17] = 1107296256LL;
  v0[18] = thunk for @escaping @callee_guaranteed () -> ();
  v0[19] = &block_descriptor_23;
  uint64_t v14 = _Block_copy(v0 + 16);
  swift_retain();
  swift_retain();
  swift_retain();
  swift_retain();
  swift_retain();
  swift_release();
  unsigned int v15 = objc_msgSend(v33, sel__performImmediate_, v14);
  _Block_release(v14);
  LOBYTE(v14) = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if ((v14 & 1) != 0)
  {
    __break(1u);
  }

  else
  {
    if (!v15)
    {
      swift_release();
      swift_release();
      swift_release();
      uint64_t v3 = v0[31];
      Swift::UInt v1 = partial apply for closure #1 in NSManagedObjectContext.perform<A>(schedule:_:);
      uint64_t v4 = v32;
      goto LABEL_8;
    }

    uint64_t v17 = v0[40];
    uint64_t v19 = v0[33];
    uint64_t v18 = v0[34];
    swift_beginAccess();
    uint64_t v20 = *(void (**)(uint64_t, uint64_t, uint64_t))(v18 + 16);
    v20(v17, v31, v19);
    swift_beginAccess();
    uint64_t v21 = v0[40];
    if (*v12)
    {
      uint64_t v22 = v0[33];
      uint64_t v23 = v0[34];
      id v24 = *v12;
      swift_willThrow();
      (*(void (**)(uint64_t, uint64_t))(v23 + 8))(v21, v22);
      swift_release_n();
      swift_release();
      swift_release();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      uint64_t v25 = (uint64_t (*)(void))v0[1];
      return v25();
    }

    uint64_t v26 = v0[39];
    uint64_t v27 = v0[31];
    v20(v26, v0[40], v0[33]);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v32 + 48))(v26, 1LL, v27);
    if ((_DWORD)result != 1)
    {
      uint64_t v28 = v0[40];
      uint64_t v30 = v0[33];
      uint64_t v29 = v0[34];
      (*(void (**)(void, void, void))(v32 + 32))(v0[28], v0[39], v0[31]);
      (*(void (**)(uint64_t, uint64_t))(v29 + 8))(v28, v30);
      swift_release_n();
      swift_release();
      swift_release();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      swift_task_dealloc();
      uint64_t v25 = (uint64_t (*)(void))v0[1];
      return v25();
    }
  }

  __break(1u);
  return result;
}

{
  void *v0;
  void *v1;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  Swift::UInt v1 = v0;
  uint64_t v2 = v0[36];
  uint64_t v3 = (void *)v0[32];
  uint64_t v4 = v1[30];
  uint64_t v5 = v1[31];
  uint64_t v6 = v1[29];
  v1[7] = v2;
  v1[2] = v1;
  v1[3] = NSManagedObjectContext.perform<A>(schedule:_:);
  uint64_t v7 = swift_continuation_init();
  uint64_t v8 = (void *)swift_allocObject();
  v8[2] = v5;
  v8[3] = v6;
  v1[10] = MEMORY[0x1895F87A8];
  v1 += 10;
  v8[4] = v4;
  v8[5] = v7;
  v1[4] = partial apply for closure #1 in closure #1 in NSPersistentStoreCoordinator._rethrowsHelper_perform<A>(_:rescue:);
  v1[5] = v8;
  v1[1] = 1107296256LL;
  v1[2] = thunk for @escaping @callee_guaranteed () -> ();
  v1[3] = &block_descriptor_9_0;
  uint64_t v9 = _Block_copy(v1);
  swift_retain();
  swift_release();
  objc_msgSend(v3, sel_performBlock_, v9);
  _Block_release(v9);
  return swift_continuation_await();
}

{
  uint64_t v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t, uint64_t);
  Swift::UInt v1 = *(void **)v0;
  uint64_t v2 = *(void *)(*(void *)v0 + 48LL);
  *(void *)(*(void *)v0 + 352LL) = v2;
  if (v2)
  {
    swift_willThrow();
  }

  else
  {
    uint64_t v4 = v1[36];
    uint64_t v3 = v1[37];
    uint64_t v5 = v1[33];
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(v1[34] + 32LL);
    v1[45] = v6;
    v6(v3, v4, v5);
  }

  return swift_task_switch();
}

{
  uint64_t v0;
  void (*v1)(uint64_t, uint64_t, uint64_t);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  Swift::UInt v1 = *(void (**)(uint64_t, uint64_t, uint64_t))(v0 + 360);
  uint64_t v2 = *(void *)(v0 + 328);
  uint64_t v3 = *(void *)(v0 + 296);
  uint64_t v4 = *(void *)(v0 + 304);
  uint64_t v6 = *(void *)(v0 + 272);
  uint64_t v5 = *(void *)(v0 + 280);
  uint64_t v7 = *(void *)(v0 + 264);
  uint64_t v8 = *(void *)(v0 + 248);
  uint64_t v9 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
  v9(v4, v7);
  v1(v4, v3, v7);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16))(v5, v4, v7);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v2 + 48))(v5, 1LL, v8);
  if ((_DWORD)result == 1)
  {
    __break(1u);
  }

  else
  {
    uint64_t v11 = *(void *)(v0 + 336);
    uint64_t v12 = *(void *)(v0 + 328);
    uint64_t v13 = *(void *)(v0 + 280);
    uint64_t v14 = *(void *)(v0 + 248);
    unsigned int v15 = *(void *)(v0 + 224);
    v9(*(void *)(v0 + 304), *(void *)(v0 + 264));
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 32))(v15, v13, v14);
    outlined consume of (@escaping @callee_guaranteed () -> ())?(v11);
    swift_task_dealloc();
    swift_task_dealloc();
    swift_task_dealloc();
    swift_task_dealloc();
    swift_task_dealloc();
    swift_task_dealloc();
    return (*(uint64_t (**)(void))(v0 + 8))();
  }

  return result;
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  Swift::UInt v1 = *(void *)(v0 + 336);
  uint64_t v2 = *(void *)(v0 + 304);
  uint64_t v3 = *(void *)(v0 + 264);
  uint64_t v4 = *(void *)(v0 + 272);
  swift_willThrow();
  (*(void (**)(uint64_t, uint64_t))(v4 + 8))(v2, v3);
  outlined consume of (@escaping @callee_guaranteed () -> ())?(v1);
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t sub_1866B8808()
{
  return swift_deallocObject();
}

uint64_t outlined consume of (@escaping @callee_guaranteed () -> ())?(uint64_t result)
{
  if (result) {
    return swift_release();
  }
  return result;
}

uint64_t sub_1866B883C()
{
  return swift_deallocObject();
}

uint64_t closure #1 in NSManagedObjectContext.perform<A>(schedule:_:)( void (*a1)(uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = type metadata accessor for Optional();
  uint64_t v9 = *(void *)(v8 - 8);
  MEMORY[0x1895F8858](v8);
  uint64_t v11 = &v16[-v10];
  uint64_t v12 = swift_projectBox();
  uint64_t v13 = (void *)swift_allocObject();
  void v13[2] = a5;
  v13[3] = a1;
  v13[4] = a2;
  uint64_t v14 = swift_retain();
  a1(v14);
  (*(void (**)(_BYTE *, void, uint64_t, uint64_t))(*(void *)(a5 - 8) + 56LL))(v11, 0LL, 1LL, a5);
  swift_beginAccess();
  (*(void (**)(uint64_t, _BYTE *, uint64_t))(v9 + 40))(v12, v11, v8);
  LOBYTE(a2) = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if ((a2 & 1) != 0) {
    __break(1u);
  }
  return result;
}

uint64_t sub_1866B89CC()
{
  return swift_deallocObject();
}

uint64_t partial apply for closure #1 in NSManagedObjectContext.perform<A>(schedule:_:)()
{
  return closure #1 in NSManagedObjectContext.perform<A>(schedule:_:)( *(void (**)(uint64_t))(v0 + 24),  *(void *)(v0 + 32),  *(void *)(v0 + 40),  *(void *)(v0 + 48),  *(void *)(v0 + 16));
}

uint64_t sub_1866B8A10()
{
  return swift_deallocObject();
}

unint64_t lazy protocol witness table accessor for type NSManagedObjectContext.NotificationKey and conformance NSManagedObjectContext.NotificationKey()
{
  unint64_t result = lazy protocol witness table cache variable for type NSManagedObjectContext.NotificationKey and conformance NSManagedObjectContext.NotificationKey;
  if (!lazy protocol witness table cache variable for type NSManagedObjectContext.NotificationKey and conformance NSManagedObjectContext.NotificationKey)
  {
    unint64_t result = MEMORY[0x186E3F040]( &protocol conformance descriptor for NSManagedObjectContext.NotificationKey,  &type metadata for NSManagedObjectContext.NotificationKey);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type NSManagedObjectContext.NotificationKey and conformance NSManagedObjectContext.NotificationKey);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type NSManagedObjectContext.ConcurrencyType and conformance NSManagedObjectContext.ConcurrencyType()
{
  unint64_t result = lazy protocol witness table cache variable for type NSManagedObjectContext.ConcurrencyType and conformance NSManagedObjectContext.ConcurrencyType;
  if (!lazy protocol witness table cache variable for type NSManagedObjectContext.ConcurrencyType and conformance NSManagedObjectContext.ConcurrencyType)
  {
    unint64_t result = MEMORY[0x186E3F040]( &protocol conformance descriptor for NSManagedObjectContext.ConcurrencyType,  &type metadata for NSManagedObjectContext.ConcurrencyType);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type NSManagedObjectContext.ConcurrencyType and conformance NSManagedObjectContext.ConcurrencyType);
  }

  return result;
}

unint64_t lazy protocol witness table accessor for type NSManagedObjectContext.ScheduledTaskType and conformance NSManagedObjectContext.ScheduledTaskType()
{
  unint64_t result = lazy protocol witness table cache variable for type NSManagedObjectContext.ScheduledTaskType and conformance NSManagedObjectContext.ScheduledTaskType;
  if (!lazy protocol witness table cache variable for type NSManagedObjectContext.ScheduledTaskType and conformance NSManagedObjectContext.ScheduledTaskType)
  {
    unint64_t result = MEMORY[0x186E3F040]( &protocol conformance descriptor for NSManagedObjectContext.ScheduledTaskType,  &type metadata for NSManagedObjectContext.ScheduledTaskType);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type NSManagedObjectContext.ScheduledTaskType and conformance NSManagedObjectContext.ScheduledTaskType);
  }

  return result;
}

_BYTE *__swift_memcpy1_1(_BYTE *result, _BYTE *a2)
{
  *unint64_t result = *a2;
  return result;
}

uint64_t getEnumTagSinglePayload for NSManagedObjectContext.NotificationKey( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xF5) {
    goto LABEL_17;
  }
  if (a2 + 11 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 11) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 11;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 11;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 11;
    }
  }

uint64_t storeEnumTagSinglePayload for NSManagedObjectContext.NotificationKey( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 11 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 11) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xF5) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xF4) {
    return ((uint64_t (*)(void))((char *)&loc_1866B8BE4 + 4 * byte_1868D5681[v4]))();
  }
  *a1 = a2 + 11;
  return ((uint64_t (*)(void))((char *)sub_1866B8C18 + 4 * byte_1868D567C[v4]))();
}

uint64_t sub_1866B8C18(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1866B8C20(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x1866B8C28LL);
  }
  return result;
}

uint64_t sub_1866B8C34(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x1866B8C3CLL);
  }
  *(_BYTE *)unint64_t result = a2 + 11;
  return result;
}

uint64_t sub_1866B8C40(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1866B8C48(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

uint64_t getEnumTag for NSManagedObjectContext.NotificationKey(unsigned __int8 *a1)
{
  return *a1;
}

_BYTE *destructiveInjectEnumTag for NSManagedObjectContext.NotificationKey(_BYTE *result, char a2)
{
  *unint64_t result = a2;
  return result;
}

ValueMetadata *type metadata accessor for NSManagedObjectContext.NotificationKey()
{
  return &type metadata for NSManagedObjectContext.NotificationKey;
}

ValueMetadata *type metadata accessor for NSManagedObjectContext.ConcurrencyType()
{
  return &type metadata for NSManagedObjectContext.ConcurrencyType;
}

uint64_t getEnumTagSinglePayload for NSManagedObjectContext.ScheduledTaskType( unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }

    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }

uint64_t storeEnumTagSinglePayload for NSManagedObjectContext.ScheduledTaskType( _BYTE *a1, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 0LL;
  }
  if (a2 <= 0xFE) {
    return ((uint64_t (*)(void))((char *)&loc_1866B8D60 + 4 * byte_1868D568B[v4]))();
  }
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_1866B8D94 + 4 * byte_1868D5686[v4]))();
}

uint64_t sub_1866B8D94(uint64_t result)
{
  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_1866B8D9C(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2) {
    JUMPOUT(0x1866B8DA4LL);
  }
  return result;
}

uint64_t sub_1866B8DB0(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2) {
    JUMPOUT(0x1866B8DB8LL);
  }
  *(_BYTE *)unint64_t result = a2 + 1;
  return result;
}

uint64_t sub_1866B8DBC(uint64_t result)
{
  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_1866B8DC4(uint64_t result)
{
  *(_WORD *)(result + 1) = v1;
  return result;
}

_BYTE *destructiveInjectEnumTag for NSManagedObjectContext.ScheduledTaskType(_BYTE *result, char a2)
{
  *unint64_t result = a2 & 1;
  return result;
}

ValueMetadata *type metadata accessor for NSManagedObjectContext.ScheduledTaskType()
{
  return &type metadata for NSManagedObjectContext.ScheduledTaskType;
}

uint64_t sub_1866B8DEC()
{
  return swift_deallocObject();
}

char *specialized ContiguousArray._createNewBuffer(bufferIsUnique:minimumCapacity:growForAppend:)( char *a1, int64_t a2, char a3)
{
  unint64_t result = specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( a1,  a2,  a3,  *v3);
  *int v3 = result;
  return result;
}

_OWORD *outlined init with take of Any(_OWORD *a1, _OWORD *a2)
{
  __int128 v2 = a1[1];
  *a2 = *a1;
  a2[1] = v2;
  return a2;
}

char *specialized _ContiguousArrayBuffer._consumeAndCreateNew(bufferIsUnique:minimumCapacity:growForAppend:)( char *result, int64_t a2, char a3, char *a4)
{
  char v5 = (char)result;
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        return result;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for _ContiguousArrayStorage<Any>);
    uint64_t v10 = (char *)swift_allocObject();
    int64_t v11 = _swift_stdlib_malloc_size(v10);
    uint64_t v12 = v11 - 32;
    if (v11 < 32) {
      uint64_t v12 = v11 - 1;
    }
    *((void *)v10 + 2) = v8;
    *((void *)v10 + 3) = 2 * (v12 >> 5);
  }

  else
  {
    uint64_t v10 = (char *)MEMORY[0x18961AFE8];
  }

  uint64_t v13 = v10 + 32;
  uint64_t v14 = a4 + 32;
  if ((v5 & 1) != 0)
  {
    if (v10 != a4 || v13 >= &v14[32 * v8]) {
      memmove(v13, v14, 32 * v8);
    }
    *((void *)a4 + 2) = 0LL;
  }

  else
  {
    swift_arrayInitWithCopy();
  }

  swift_release();
  return v10;
}

uint64_t static CocoaError.Code.coreData.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.managedObjectValidationError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationMultipleErrorsError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationMissingMandatoryPropertyError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationRelationshipLacksMinimumCountError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationRelationshipExceedsMaximumCountError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationRelationshipDeniedDeleteError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationNumberTooLargeError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationNumberTooSmallError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationDateTooLateError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationDateTooSoonError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationInvalidDateError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationStringTooLongError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationStringTooShortError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.validationStringPatternMatchingError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.managedObjectContextLockingError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreCoordinatorLockingError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.managedObjectReferentialIntegrityError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.managedObjectExternalRelationshipError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.managedObjectMergeError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.managedObjectConstraintMergeError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreInvalidTypeError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreTypeMismatchError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreIncompatibleSchemaError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreSaveError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreIncompleteSaveError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreSaveConflictsError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreOperationError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreOpenError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreTimeoutError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreUnsupportedRequestTypeError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.persistentStoreIncompatibleVersionHashError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.migrationError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.migrationCancelledError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.migrationMissingSourceModelError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.migrationMissingMappingModelError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.migrationManagerSourceStoreError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.migrationManagerDestinationStoreError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.entityMigrationPolicyError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.sqliteError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.inferredMappingModelError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t static CocoaError.Code.externalRecordImportError.getter()
{
  return CocoaError.Code.init(rawValue:)();
}

uint64_t CocoaError.validationObject.getter@<X0>(_OWORD *a1@<X8>)
{
  return CocoaError.validationObject.getter(a1);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  char v6;
  type metadata accessor for CocoaError();
  lazy protocol witness table accessor for type CocoaError and conformance CocoaError();
  __int128 v2 = _BridgedStoredNSError.userInfo.getter();
  int v3 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  if (*(void *)(v2 + 16) && (char v5 = specialized __RawDictionaryStorage.find<A>(_:)(v3, v4), (v6 & 1) != 0))
  {
    outlined init with copy of Any(*(void *)(v2 + 56) + 32 * v5, (uint64_t)a1);
  }

  else
  {
    *a1 = 0u;
    a1[1] = 0u;
  }

  swift_bridgeObjectRelease();
  return swift_bridgeObjectRelease();
}

unint64_t lazy protocol witness table accessor for type CocoaError and conformance CocoaError()
{
  unint64_t result = lazy protocol witness table cache variable for type CocoaError and conformance CocoaError;
  if (!lazy protocol witness table cache variable for type CocoaError and conformance CocoaError)
  {
    uint64_t v1 = type metadata accessor for CocoaError();
    unint64_t result = MEMORY[0x186E3F040](MEMORY[0x189605F68], v1);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type CocoaError and conformance CocoaError);
  }

  return result;
}

uint64_t CocoaError.validationKey.getter()
{
  uint64_t v0 = _BridgedStoredNSError.userInfo.getter();
  uint64_t v1 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  if (!*(void *)(v0 + 16) || (unint64_t v3 = specialized __RawDictionaryStorage.find<A>(_:)(v1, v2), (v4 & 1) == 0))
  {
    __int128 v7 = 0u;
    __int128 v8 = 0u;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    goto LABEL_9;
  }

  outlined init with copy of Any(*(void *)(v0 + 56) + 32 * v3, (uint64_t)&v7);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (!*((void *)&v8 + 1))
  {
LABEL_9:
    outlined destroy of Any?((uint64_t)&v7);
    return 0LL;
  }

  else {
    return 0LL;
  }
}

uint64_t CocoaError.validationPredicate.getter()
{
  uint64_t v0 = _BridgedStoredNSError.userInfo.getter();
  uint64_t v1 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  if (!*(void *)(v0 + 16) || (unint64_t v3 = specialized __RawDictionaryStorage.find<A>(_:)(v1, v2), (v4 & 1) == 0))
  {
    __int128 v7 = 0u;
    __int128 v8 = 0u;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    goto LABEL_8;
  }

  outlined init with copy of Any(*(void *)(v0 + 56) + 32 * v3, (uint64_t)&v7);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (!*((void *)&v8 + 1))
  {
LABEL_8:
    outlined destroy of Any?((uint64_t)&v7);
    return 0LL;
  }

  type metadata accessor for NSPredicate();
  else {
    return 0LL;
  }
}

uint64_t CocoaError.validationValue.getter@<X0>(_OWORD *a1@<X8>)
{
  return CocoaError.validationObject.getter(a1);
}

uint64_t CocoaError.affectedStores.getter()
{
  return CocoaError.affectedStores.getter( (uint64_t)&NSAffectedStoresErrorKey,  &demangling cache variable for type metadata for [Swift.AnyObject]);
}

uint64_t CocoaError.affectedObjects.getter()
{
  return CocoaError.affectedStores.getter( (uint64_t)&NSAffectedObjectsErrorKey,  &demangling cache variable for type metadata for [Swift.AnyObject]);
}

uint64_t CocoaError.persistentStoreSaveConflicts.getter()
{
  return CocoaError.affectedStores.getter( (uint64_t)&NSPersistentStoreSaveConflictsErrorKey,  &demangling cache variable for type metadata for [NSMergeConflict]);
}

uint64_t CocoaError.affectedStores.getter(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = _BridgedStoredNSError.userInfo.getter();
  uint64_t v4 = static String._unconditionallyBridgeFromObjectiveC(_:)();
  if (!*(void *)(v3 + 16) || (unint64_t v6 = specialized __RawDictionaryStorage.find<A>(_:)(v4, v5), (v7 & 1) == 0))
  {
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    goto LABEL_8;
  }

  outlined init with copy of Any(*(void *)(v3 + 56) + 32 * v6, (uint64_t)&v10);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (!*((void *)&v11 + 1))
  {
LABEL_8:
    outlined destroy of Any?((uint64_t)&v10);
    return 0LL;
  }

  __swift_instantiateConcreteTypeFromMangledName(a2);
  else {
    return 0LL;
  }
}

void static CocoaError.ManagedObjectValidationError.getter()
{
}

void static CocoaError.ValidationMultipleErrorsError.getter()
{
}

void static CocoaError.ValidationMissingMandatoryPropertyError.getter()
{
}

void static CocoaError.ValidationRelationshipLacksMinimumCountError.getter()
{
}

void static CocoaError.ValidationRelationshipExceedsMaximumCountError.getter()
{
}

void static CocoaError.ValidationRelationshipDeniedDeleteError.getter()
{
}

void static CocoaError.ValidationNumberTooLargeError.getter()
{
}

void static CocoaError.ValidationNumberTooSmallError.getter()
{
}

void static CocoaError.ValidationDateTooLateError.getter()
{
}

void static CocoaError.ValidationDateTooSoonError.getter()
{
}

void static CocoaError.ValidationInvalidDateError.getter()
{
}

void static CocoaError.ValidationStringTooLongError.getter()
{
}

void static CocoaError.ValidationStringTooShortError.getter()
{
}

void static CocoaError.ValidationStringPatternMatchingError.getter()
{
}

void static CocoaError.ManagedObjectContextLockingError.getter()
{
}

void static CocoaError.PersistentStoreCoordinatorLockingError.getter()
{
}

void static CocoaError.ManagedObjectReferentialIntegrityError.getter()
{
}

void static CocoaError.ManagedObjectExternalRelationshipError.getter()
{
}

void static CocoaError.ManagedObjectMergeError.getter()
{
}

void static CocoaError.ManagedObjectConstraintMergeError.getter()
{
}

void static CocoaError.PersistentStoreInvalidTypeError.getter()
{
}

void static CocoaError.PersistentStoreTypeMismatchError.getter()
{
}

void static CocoaError.PersistentStoreIncompatibleSchemaError.getter()
{
}

void static CocoaError.PersistentStoreSaveError.getter()
{
}

void static CocoaError.PersistentStoreIncompleteSaveError.getter()
{
}

void static CocoaError.PersistentStoreSaveConflictsError.getter()
{
}

void static CocoaError.CoreDataError.getter()
{
}

void static CocoaError.PersistentStoreOperationError.getter()
{
}

void static CocoaError.PersistentStoreOpenError.getter()
{
}

void static CocoaError.PersistentStoreTimeoutError.getter()
{
}

void static CocoaError.PersistentStoreUnsupportedRequestTypeError.getter()
{
}

void static CocoaError.PersistentStoreIncompatibleVersionHashError.getter()
{
}

void static CocoaError.MigrationError.getter()
{
}

void static CocoaError.MigrationCancelledError.getter()
{
}

void static CocoaError.MigrationMissingSourceModelError.getter()
{
}

void static CocoaError.MigrationMissingMappingModelError.getter()
{
}

void static CocoaError.MigrationManagerSourceStoreError.getter()
{
}

void static CocoaError.MigrationManagerDestinationStoreError.getter()
{
}

void static CocoaError.EntityMigrationPolicyError.getter()
{
}

void static CocoaError.SQLiteError.getter()
{
}

void static CocoaError.InferredMappingModelError.getter()
{
}

void static CocoaError.ExternalRecordImportError.getter()
{
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:)(uint64_t a1, uint64_t a2)
{
  Swift::Int v4 = Hasher._finalize()();
  return specialized __RawDictionaryStorage.find<A>(_:hashValue:)(a1, a2, v4);
}

uint64_t outlined init with copy of Any(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

uint64_t outlined destroy of Any?(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any?);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(a1, v2);
  return a1;
}

unint64_t type metadata accessor for NSPredicate()
{
  unint64_t result = lazy cache variable for type metadata for NSPredicate;
  if (!lazy cache variable for type metadata for NSPredicate)
  {
    objc_opt_self();
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&lazy cache variable for type metadata for NSPredicate);
  }

  return result;
}

unint64_t specialized __RawDictionaryStorage.find<A>(_:hashValue:)( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3 + 64;
  uint64_t v5 = -1LL << *(_BYTE *)(v3 + 32);
  unint64_t v6 = a3 & ~v5;
  if (((*(void *)(v3 + 64 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) != 0)
  {
    uint64_t v9 = *(void *)(v3 + 48);
    __int128 v10 = (void *)(v9 + 16 * v6);
    BOOL v11 = *v10 == a1 && v10[1] == a2;
    if (!v11 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0)
    {
      uint64_t v12 = ~v5;
      do
      {
        unint64_t v6 = (v6 + 1) & v12;
        if (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v6) & 1) == 0) {
          break;
        }
        uint64_t v13 = (void *)(v9 + 16 * v6);
        BOOL v14 = *v13 == a1 && v13[1] == a2;
      }

      while (!v14 && (_stringCompareWithSmolCheck(_:_:expecting:)() & 1) == 0);
    }
  }

  return v6;
}

id _PFExampleClass.__deallocating_deinit()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for _PFExampleClass();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t type metadata accessor for _PFExampleClass()
{
  return objc_opt_self();
}

uint64_t NSPersistentStore.StoreType.rawValue.getter()
{
  uint64_t v1 = *v0;
  swift_bridgeObjectRetain();
  return v1;
}

uint64_t NSPersistentStore.StoreType.rawValue.setter(uint64_t a1, uint64_t a2)
{
  uint64_t result = swift_bridgeObjectRelease();
  void *v2 = a1;
  v2[1] = a2;
  return result;
}

uint64_t (*NSPersistentStore.StoreType.rawValue.modify())()
{
  return NSManagedObjectContext.ConcurrencyType.rawValue.modify;
}

uint64_t NSPersistentStore.StoreType.init(rawValue:)@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = result;
  a3[1] = a2;
  return result;
}

Swift::Int protocol witness for Hashable.hashValue.getter in conformance NSPersistentStore.StoreType()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance NSPersistentStore.StoreType()
{
  return swift_bridgeObjectRelease();
}

Swift::Int protocol witness for Hashable._rawHashValue(seed:) in conformance NSPersistentStore.StoreType()
{
  return Hasher._finalize()();
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance NSPersistentStore.StoreType( void *a1, void *a2)
{
  if (*a1 == *a2 && a1[1] == a2[1]) {
    return 1LL;
  }
  else {
    return _stringCompareWithSmolCheck(_:_:expecting:)();
  }
}

void *protocol witness for RawRepresentable.init(rawValue:) in conformance NSPersistentStore.StoreType@<X0>( void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result[1];
  *a2 = *result;
  a2[1] = v2;
  return result;
}

uint64_t protocol witness for RawRepresentable.rawValue.getter in conformance NSPersistentStore.StoreType@<X0>( void *a1@<X8>)
{
  uint64_t v2 = v1[1];
  *a1 = *v1;
  a1[1] = v2;
  return swift_bridgeObjectRetain();
}

uint64_t one-time initialization function for sqlite()
{
  uint64_t result = static String._unconditionallyBridgeFromObjectiveC(_:)();
  static NSPersistentStore.StoreType.sqlite = result;
  unk_18C693770 = v1;
  return result;
}

uint64_t static NSPersistentStore.StoreType.sqlite.getter@<X0>(void *a1@<X8>)
{
  return static NSPersistentStore.StoreType.sqlite.getter( &one-time initialization token for sqlite,  &static NSPersistentStore.StoreType.sqlite,  &qword_18C693770,  a1);
}

uint64_t one-time initialization function for binary()
{
  uint64_t result = static String._unconditionallyBridgeFromObjectiveC(_:)();
  static NSPersistentStore.StoreType.binary = result;
  unk_18C693780 = v1;
  return result;
}

uint64_t static NSPersistentStore.StoreType.binary.getter@<X0>(void *a1@<X8>)
{
  return static NSPersistentStore.StoreType.sqlite.getter( &one-time initialization token for binary,  &static NSPersistentStore.StoreType.binary,  &qword_18C693780,  a1);
}

uint64_t one-time initialization function for inMemory()
{
  uint64_t result = static String._unconditionallyBridgeFromObjectiveC(_:)();
  static NSPersistentStore.StoreType.inMemory = result;
  unk_18C693790 = v1;
  return result;
}

uint64_t static NSPersistentStore.StoreType.inMemory.getter@<X0>(void *a1@<X8>)
{
  return static NSPersistentStore.StoreType.sqlite.getter( &one-time initialization token for inMemory,  &static NSPersistentStore.StoreType.inMemory,  &qword_18C693790,  a1);
}

uint64_t one-time initialization function for xpc()
{
  uint64_t result = static String._unconditionallyBridgeFromObjectiveC(_:)();
  static NSPersistentStore.StoreType.xpc = result;
  unk_18C6937A0 = v1;
  return result;
}

uint64_t static NSPersistentStore.StoreType.xpc.getter@<X0>(void *a1@<X8>)
{
  return static NSPersistentStore.StoreType.sqlite.getter( &one-time initialization token for xpc,  &static NSPersistentStore.StoreType.xpc,  &qword_18C6937A0,  a1);
}

uint64_t static NSPersistentStore.StoreType.sqlite.getter@<X0>( void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  if (*a1 != -1LL) {
    swift_once();
  }
  uint64_t v7 = *a3;
  *a4 = *a2;
  a4[1] = v7;
  return swift_bridgeObjectRetain();
}

unint64_t lazy protocol witness table accessor for type NSPersistentStore.StoreType and conformance NSPersistentStore.StoreType()
{
  unint64_t result = lazy protocol witness table cache variable for type NSPersistentStore.StoreType and conformance NSPersistentStore.StoreType;
  if (!lazy protocol witness table cache variable for type NSPersistentStore.StoreType and conformance NSPersistentStore.StoreType)
  {
    unint64_t result = MEMORY[0x186E3F040]( &protocol conformance descriptor for NSPersistentStore.StoreType,  &type metadata for NSPersistentStore.StoreType);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type NSPersistentStore.StoreType and conformance NSPersistentStore.StoreType);
  }

  return result;
}

void *initializeBufferWithCopyOfBuffer for NSPersistentStore.StoreType(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t destroy for NSPersistentStore.StoreType()
{
  return swift_bridgeObjectRelease();
}

void *assignWithCopy for NSPersistentStore.StoreType(void *a1, void *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();
  return a1;
}

__n128 __swift_memcpy16_8(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

void *assignWithTake for NSPersistentStore.StoreType(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t getEnumTagSinglePayload for NSPersistentStore.StoreType(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (a2 < 0 && *(_BYTE *)(a1 + 16)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t storeEnumTagSinglePayload for NSPersistentStore.StoreType(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)__n128 result = a2 ^ 0x80000000;
    *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
    if (a3 < 0) {
      *(_BYTE *)(result + 16) = 1;
    }
  }

  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + _Block_object_dispose(va, 8) = (a2 - 1);
      return result;
    }

    *(_BYTE *)(result + 16) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }

  return result;
}

ValueMetadata *type metadata accessor for NSPersistentStore.StoreType()
{
  return &type metadata for NSPersistentStore.StoreType;
}

id static NSManagedObject.fetchRequest()()
{
  uint64_t ObjCClassFromMetadata = (void *)swift_getObjCClassFromMetadata();
  id v1 = objc_msgSend(ObjCClassFromMetadata, sel_entity);
  if (v1)
  {
    unint64_t v2 = v1;
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for NSFetchRequest);
    uint64_t v3 = (objc_class *)swift_getObjCClassFromMetadata();
    id v4 = v2;
    id v5 = objc_msgSend(objc_allocWithZone(v3), sel_init);
    objc_msgSend(v5, sel_setEntity_, v4);

    return v5;
  }

  else
  {
    id v7 = objc_msgSend(ObjCClassFromMetadata, sel_entityName);
    uint64_t v8 = static String._unconditionallyBridgeFromObjectiveC(_:)();
    uint64_t v10 = v9;

    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for NSFetchRequest);
    return NSFetchRequest.__allocating_init(entityName:)(v8, v10);
  }

id NSFetchRequest.__allocating_init(entityName:)(uint64_t a1, uint64_t a2)
{
  id v4 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  id v5 = (void *)MEMORY[0x186E3D7D4](a1, a2);
  swift_bridgeObjectRelease();
  id v6 = objc_msgSend(v4, sel_initWithEntityName_, v5);

  return v6;
}

id @objc static NSManagedObject.fetchRequest()(id a1, SEL a2)
{
  return static NSManagedObject.fetchRequest()();
}

id NSManagedObject.objectWillChange.getter()
{
  if (objc_msgSend(v0, sel_bindableObjectPublisher))
  {
    _bridgeAnyObjectToAny(_:)();
    swift_unknownObjectRelease();
    outlined destroy of Any?((uint64_t)v4);
  }

  else
  {
    memset(v4, 0, sizeof(v4));
    outlined destroy of Any?((uint64_t)v4);
    type metadata accessor for ObservableObjectPublisher();
    swift_allocObject();
    objc_msgSend(v0, sel_setBindableObjectPublisher_, ObservableObjectPublisher.init()());
    swift_release();
  }

  id result = objc_msgSend(v0, sel_bindableObjectPublisher);
  if (result)
  {
    _bridgeAnyObjectToAny(_:)();
    swift_unknownObjectRelease();
    outlined init with take of Any(&v3, v4);
    type metadata accessor for ObservableObjectPublisher();
    swift_dynamicCast();
    return (id)v2;
  }

  else
  {
    __break(1u);
  }

  return result;
}

id protocol witness for ObservableObject.objectWillChange.getter in conformance NSManagedObject@<X0>( void *a1@<X8>)
{
  id result = NSManagedObject.objectWillChange.getter();
  *a1 = result;
  return result;
}

double NSManagedObject.subscript.getter@<D0>(_OWORD *a1@<X8>)
{
  __int128 v3 = (void *)MEMORY[0x186E3D7D4]();
  id v4 = objc_msgSend(v1, sel_valueForKey_, v3);

  if (v4)
  {
    _bridgeAnyObjectToAny(_:)();
    swift_unknownObjectRelease();
  }

  else
  {
    double result = 0.0;
    *a1 = 0u;
    a1[1] = 0u;
  }

  return result;
}

double key path getter for NSManagedObject.subscript(_:) : NSManagedObject@<D0>( void **a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  id v4 = *a1;
  id v5 = (void *)MEMORY[0x186E3D7D4](*a2, a2[1]);
  id v6 = objc_msgSend(v4, sel_valueForKey_, v5);

  if (v6)
  {
    _bridgeAnyObjectToAny(_:)();
    swift_unknownObjectRelease();
  }

  else
  {
    double result = 0.0;
    *a3 = 0u;
    a3[1] = 0u;
  }

  return result;
}

uint64_t key path setter for NSManagedObject.subscript(_:) : NSManagedObject( uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = a3[1];
  outlined init with copy of Any?(a1, (uint64_t)v6);
  swift_bridgeObjectRetain();
  return NSManagedObject.subscript.setter((uint64_t)v6, v4, v3);
}

uint64_t NSManagedObject.subscript.setter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = v16;
  if (v16)
  {
    uint64_t v8 = __swift_project_boxed_opaque_existential_0(v15, v16);
    uint64_t v9 = *(void *)(v7 - 8);
    MEMORY[0x1895F8858](v8);
    BOOL v11 = (char *)v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    (*(void (**)(char *))(v9 + 16))(v11);
    uint64_t v12 = _bridgeAnythingToObjectiveC<A>(_:)();
    (*(void (**)(char *, uint64_t))(v9 + 8))(v11, v7);
    __swift_destroy_boxed_opaque_existential_0((uint64_t)v15);
  }

  else
  {
    uint64_t v12 = 0LL;
  }

  uint64_t v13 = (void *)MEMORY[0x186E3D7D4](a2, a3);
  swift_bridgeObjectRelease();
  objc_msgSend(v3, sel_setValue_forKey_, v12, v13);
  swift_unknownObjectRelease();

  return outlined destroy of Any?(a1);
}

uint64_t outlined init with copy of Any?(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any?);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

void *__swift_project_boxed_opaque_existential_0(void *result, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) & 0x20000) != 0) {
    return (void *)(*result
  }
                    + ((*(_DWORD *)(*(void *)(a2 - 8) + 80LL) + 16LL) & ~(unint64_t)*(_DWORD *)(*(void *)(a2 - 8) + 80LL)));
  return result;
}

uint64_t __swift_destroy_boxed_opaque_existential_0(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 24) - 8LL);
  if ((*(_BYTE *)(v1 + 82) & 2) != 0) {
    return swift_release();
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

void (*NSManagedObject.subscript.modify( void *a1, uint64_t a2, uint64_t a3))(uint64_t *a1, char a2)
{
  uint64_t v4 = v3;
  uint64_t v8 = (char *)malloc(0x58uLL);
  *a1 = v8;
  uint64_t v9 = v8 + 32;
  *((void *)v8 + 9) = a3;
  *((void *)v8 + 10) = v4;
  *((void *)v8 + _Block_object_dispose(va, 8) = a2;
  uint64_t v10 = (void *)MEMORY[0x186E3D7D4](a2, a3);
  id v11 = objc_msgSend(v4, sel_valueForKey_, v10);

  if (v11)
  {
    _bridgeAnyObjectToAny(_:)();
    swift_unknownObjectRelease();
  }

  else
  {
    _OWORD *v9 = 0u;
    *((_OWORD *)v8 + 3) = 0u;
  }

  outlined init with take of Any?((uint64_t)v9, (uint64_t)v8);
  return NSManagedObject.subscript.modify;
}

void NSManagedObject.subscript.modify(uint64_t *a1, char a2)
{
  uint64_t v2 = (void *)*a1;
  if ((a2 & 1) != 0)
  {
    uint64_t v3 = v2[9];
    uint64_t v4 = v2[8];
    outlined init with copy of Any?(*a1, (uint64_t)(v2 + 4));
    swift_bridgeObjectRetain();
    NSManagedObject.subscript.setter((uint64_t)(v2 + 4), v4, v3);
    outlined destroy of Any?((uint64_t)v2);
  }

  else
  {
    uint64_t v5 = v2[9];
    uint64_t v6 = v2[8];
    swift_bridgeObjectRetain();
    NSManagedObject.subscript.setter((uint64_t)v2, v6, v5);
  }

  free(v2);
}

uint64_t outlined init with take of Any?(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any?);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32LL))(a2, a1, v4);
  return a2;
}

uint64_t associated type witness table accessor for ObservableObject.ObjectWillChangePublisher : Publisher in NSManagedObject()
{
  return MEMORY[0x189602300];
}

uint64_t sub_1866BB570()
{
  return 0LL;
}

void __swiftcall NSCustomMigrationStage.init(migratingFrom:to:)( NSCustomMigrationStage *__return_ptr retstr, NSManagedObjectModelReference *migratingFrom, NSManagedObjectModelReference *to)
{
}

uint64_t (*NSCustomMigrationStage.willMigrateHandler.getter())(uint64_t a1, uint64_t a2)
{
  double result = (uint64_t (*)(uint64_t, uint64_t))objc_msgSend(v0, sel_willMigrateHandler);
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = v2;
    uint64_t v4 = swift_allocObject();
    *(void *)(v4 + 16) = partial apply for thunk for @escaping @callee_unowned @convention(block) (@unowned NSStagedMigrationManager, @unowned NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool);
    *(void *)(v4 + 24) = v3;
    return partial apply for closure #1 in NSCustomMigrationStage.willMigrateHandler.getter;
  }

  return result;
}

void *key path getter for NSCustomMigrationStage.willMigrateHandler : NSCustomMigrationStage@<X0>( id *a1@<X0>, void *a2@<X8>)
{
  double result = objc_msgSend(*a1, sel_willMigrateHandler);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = swift_allocObject();
    *(void *)(v5 + 16) = v4;
    uint64_t v6 = swift_allocObject();
    *(void *)(v6 + 16) = thunk for @escaping @callee_unowned @convention(block) (@unowned NSStagedMigrationManager, @unowned NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool)partial apply;
    *(void *)(v6 + 24) = v5;
    double result = (void *)swift_allocObject();
    result[2] = partial apply for closure #1 in NSCustomMigrationStage.willMigrateHandler.getter;
    result[3] = v6;
    uint64_t v7 = thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage) -> (@error @owned Error)partial apply;
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  *a2 = v7;
  a2[1] = result;
  return result;
}

id key path setter for NSCustomMigrationStage.willMigrateHandler : NSCustomMigrationStage(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  if (*a1)
  {
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = v1;
    *(void *)(v3 + 24) = v2;
    uint64_t v4 = partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed NSStagedMigrationManager, @in_guaranteed NSCustomMigrationStage) -> (@out (), @error @owned Error);
  }

  else
  {
    uint64_t v4 = 0LL;
    uint64_t v3 = 0LL;
  }

  _sxq_q0_s5Error_pRi_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lySo24NSStagedMigrationManagerCSo08NSCustomC5StageCytIsegnnrzo_SgWOy(v1);
  return NSCustomMigrationStage.willMigrateHandler.setter((uint64_t)v4, v3);
}

id NSCustomMigrationStage.willMigrateHandler.setter(uint64_t a1, uint64_t a2)
{
  return NSCustomMigrationStage.willMigrateHandler.setter( a1,  a2,  (uint64_t)&unk_189EA6D40,  (uint64_t)closure #1 in NSCustomMigrationStage.willMigrateHandler.setterpartial apply,  (uint64_t)&block_descriptor_1,  (SEL *)&selRef_setWillMigrateHandler_);
}

uint64_t sub_1866BB7BC()
{
  return swift_deallocObject();
}

uint64_t partial apply for thunk for @escaping @callee_unowned @convention(block) (@unowned NSStagedMigrationManager, @unowned NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool)()
{
  return (*(uint64_t (**)(void))(*(void *)(v0 + 16) + 16LL))();
}

uint64_t partial apply for closure #1 in NSCustomMigrationStage.willMigrateHandler.getter( uint64_t a1, uint64_t a2)
{
  return partial apply for closure #1 in NSCustomMigrationStage.willMigrateHandler.getter(a1, a2);
}

{
  uint64_t v2;
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16))(a1, a2, 0LL);
}

uint64_t thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool)( uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v7 = *(uint64_t (**)(id, id, uint64_t))(a1 + 32);
  swift_retain();
  id v8 = a2;
  id v9 = a3;
  LOBYTE(a4) = v7(v8, v9, a4);
  swift_release();

  return a4 & 1;
}

uint64_t block_copy_helper_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_destroy_helper_1()
{
  return swift_release();
}

void (*NSCustomMigrationStage.willMigrateHandler.modify(void *a1))(uint64_t a1, char a2)
{
  uint64_t v2 = v1;
  uint64_t v4 = malloc(0x48uLL);
  *a1 = v4;
  v4[8] = v2;
  uint64_t v5 = objc_msgSend(v2, sel_willMigrateHandler);
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = swift_allocObject();
    *(void *)(v7 + 16) = v6;
    uint64_t v5 = (void *)swift_allocObject();
    v5[2] = thunk for @escaping @callee_unowned @convention(block) (@unowned NSStagedMigrationManager, @unowned NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool)partial apply;
    v5[3] = v7;
    id v8 = partial apply for closure #1 in NSCustomMigrationStage.willMigrateHandler.getter;
  }

  else
  {
    id v8 = 0LL;
  }

  v4[6] = v8;
  v4[7] = v5;
  return NSCustomMigrationStage.willMigrateHandler.modify;
}

void NSCustomMigrationStage.willMigrateHandler.modify(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 48LL);
  uint64_t v4 = *(void **)(*(void *)a1 + 64LL);
  if ((a2 & 1) != 0)
  {
    if (v3)
    {
      uint64_t v5 = v2[7];
      uint64_t v6 = swift_allocObject();
      *(void *)(v6 + 16) = v3;
      *(void *)(v6 + 24) = v5;
      v2[4] = closure #1 in NSCustomMigrationStage.willMigrateHandler.setterpartial apply;
      v2[5] = v6;
      void *v2 = MEMORY[0x1895F87A8];
      v2[1] = 1107296256LL;
      v2[2] = thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool);
      v2[3] = &block_descriptor_13;
      uint64_t v7 = _Block_copy(v2);
      swift_retain_n();
      swift_release();
      objc_msgSend(v4, sel_setWillMigrateHandler_, v7);
      _Block_release(v7);
      outlined consume of (@escaping @callee_guaranteed () -> ())?(v3);
    }

    else
    {
      objc_msgSend(*(id *)(*(void *)a1 + 64), sel_setWillMigrateHandler_, 0);
    }

    uint64_t v11 = v2[6];
  }

  else
  {
    if (!v3)
    {
      objc_msgSend(*(id *)(*(void *)a1 + 64), sel_setWillMigrateHandler_, 0);
      goto LABEL_10;
    }

    uint64_t v8 = v2[7];
    uint64_t v9 = swift_allocObject();
    *(void *)(v9 + 16) = v3;
    *(void *)(v9 + 24) = v8;
    v2[4] = closure #1 in NSCustomMigrationStage.willMigrateHandler.setterpartial apply;
    v2[5] = v9;
    void *v2 = MEMORY[0x1895F87A8];
    v2[1] = 1107296256LL;
    v2[2] = thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool);
    v2[3] = &block_descriptor_20;
    uint64_t v10 = _Block_copy(v2);
    swift_retain();
    swift_release();
    objc_msgSend(v4, sel_setWillMigrateHandler_, v10);
    _Block_release(v10);
    uint64_t v11 = v3;
  }

  outlined consume of (@escaping @callee_guaranteed () -> ())?(v11);
LABEL_10:
  free(v2);
}

uint64_t sub_1866BBB28()
{
  return swift_deallocObject();
}

uint64_t (*NSCustomMigrationStage.didMigrateHandler.getter())(uint64_t a1, uint64_t a2)
{
  double result = (uint64_t (*)(uint64_t, uint64_t))objc_msgSend(v0, sel_didMigrateHandler);
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = v2;
    uint64_t v4 = swift_allocObject();
    *(void *)(v4 + 16) = thunk for @escaping @callee_unowned @convention(block) (@unowned NSStagedMigrationManager, @unowned NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool)partial apply;
    *(void *)(v4 + 24) = v3;
    return partial apply for closure #1 in NSCustomMigrationStage.willMigrateHandler.getter;
  }

  return result;
}

void *key path getter for NSCustomMigrationStage.didMigrateHandler : NSCustomMigrationStage@<X0>( id *a1@<X0>, void *a2@<X8>)
{
  double result = objc_msgSend(*a1, sel_didMigrateHandler);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = swift_allocObject();
    *(void *)(v5 + 16) = v4;
    uint64_t v6 = swift_allocObject();
    *(void *)(v6 + 16) = thunk for @escaping @callee_unowned @convention(block) (@unowned NSStagedMigrationManager, @unowned NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool)partial apply;
    *(void *)(v6 + 24) = v5;
    double result = (void *)swift_allocObject();
    result[2] = partial apply for closure #1 in NSCustomMigrationStage.willMigrateHandler.getter;
    result[3] = v6;
    uint64_t v7 = partial apply for thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage) -> (@error @owned Error);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  *a2 = v7;
  a2[1] = result;
  return result;
}

id key path setter for NSCustomMigrationStage.didMigrateHandler : NSCustomMigrationStage(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  if (*a1)
  {
    uint64_t v3 = swift_allocObject();
    *(void *)(v3 + 16) = v1;
    *(void *)(v3 + 24) = v2;
    uint64_t v4 = partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed NSStagedMigrationManager, @in_guaranteed NSCustomMigrationStage) -> (@out (), @error @owned Error);
  }

  else
  {
    uint64_t v4 = 0LL;
    uint64_t v3 = 0LL;
  }

  _sxq_q0_s5Error_pRi_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lySo24NSStagedMigrationManagerCSo08NSCustomC5StageCytIsegnnrzo_SgWOy(v1);
  return NSCustomMigrationStage.didMigrateHandler.setter((uint64_t)v4, v3);
}

id NSCustomMigrationStage.didMigrateHandler.setter(uint64_t a1, uint64_t a2)
{
  return NSCustomMigrationStage.willMigrateHandler.setter( a1,  a2,  (uint64_t)&unk_189EA6ED0,  (uint64_t)partial apply for closure #1 in NSCustomMigrationStage.didMigrateHandler.setter,  (uint64_t)&block_descriptor_41,  (SEL *)&selRef_setDidMigrateHandler_);
}

id NSCustomMigrationStage.willMigrateHandler.setter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, SEL *a6)
{
  uint64_t v8 = v6;
  if (!a1) {
    return objc_msgSend(v6, *a6, 0);
  }
  uint64_t v13 = swift_allocObject();
  *(void *)(v13 + 16) = a1;
  *(void *)(v13 + 24) = a2;
  v16[4] = a4;
  v16[5] = v13;
  v16[0] = MEMORY[0x1895F87A8];
  v16[1] = 1107296256LL;
  v16[2] = thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool);
  v16[3] = a5;
  BOOL v14 = _Block_copy(v16);
  swift_retain();
  swift_release();
  objc_msgSend(v8, *a6, v14);
  _Block_release(v14);
  return (id)outlined consume of (@escaping @callee_guaranteed () -> ())?(a1);
}

uint64_t closure #1 in NSCustomMigrationStage.willMigrateHandler.setter( uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(void))
{
  return 1LL;
}

uint64_t partial apply for closure #1 in NSCustomMigrationStage.didMigrateHandler.setter( uint64_t a1, uint64_t a2, uint64_t a3)
{
  return closure #1 in NSCustomMigrationStage.willMigrateHandler.setter(a1, a2, a3, *(void (**)(void))(v3 + 16)) & 1;
}

void (*NSCustomMigrationStage.didMigrateHandler.modify(void *a1))(uint64_t a1, char a2)
{
  uint64_t v2 = v1;
  uint64_t v4 = malloc(0x48uLL);
  *a1 = v4;
  v4[8] = v2;
  uint64_t v5 = objc_msgSend(v2, sel_didMigrateHandler);
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = swift_allocObject();
    *(void *)(v7 + 16) = v6;
    uint64_t v5 = (void *)swift_allocObject();
    v5[2] = thunk for @escaping @callee_unowned @convention(block) (@unowned NSStagedMigrationManager, @unowned NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool)partial apply;
    v5[3] = v7;
    uint64_t v8 = partial apply for closure #1 in NSCustomMigrationStage.willMigrateHandler.getter;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  v4[6] = v8;
  v4[7] = v5;
  return NSCustomMigrationStage.didMigrateHandler.modify;
}

void NSCustomMigrationStage.didMigrateHandler.modify(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 48LL);
  uint64_t v4 = *(void **)(*(void *)a1 + 64LL);
  if ((a2 & 1) != 0)
  {
    if (v3)
    {
      uint64_t v5 = v2[7];
      uint64_t v6 = swift_allocObject();
      *(void *)(v6 + 16) = v3;
      *(void *)(v6 + 24) = v5;
      v2[4] = closure #1 in NSCustomMigrationStage.willMigrateHandler.setterpartial apply;
      v2[5] = v6;
      void *v2 = MEMORY[0x1895F87A8];
      v2[1] = 1107296256LL;
      v2[2] = thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool);
      v2[3] = &block_descriptor_48;
      uint64_t v7 = _Block_copy(v2);
      swift_retain_n();
      swift_release();
      objc_msgSend(v4, sel_setDidMigrateHandler_, v7);
      _Block_release(v7);
      outlined consume of (@escaping @callee_guaranteed () -> ())?(v3);
    }

    else
    {
      objc_msgSend(*(id *)(*(void *)a1 + 64), sel_setDidMigrateHandler_, 0);
    }

    uint64_t v11 = v2[6];
  }

  else
  {
    if (!v3)
    {
      objc_msgSend(*(id *)(*(void *)a1 + 64), sel_setDidMigrateHandler_, 0);
      goto LABEL_10;
    }

    uint64_t v8 = v2[7];
    uint64_t v9 = swift_allocObject();
    *(void *)(v9 + 16) = v3;
    *(void *)(v9 + 24) = v8;
    v2[4] = closure #1 in NSCustomMigrationStage.willMigrateHandler.setterpartial apply;
    v2[5] = v9;
    void *v2 = MEMORY[0x1895F87A8];
    v2[1] = 1107296256LL;
    v2[2] = thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage, @unowned AutoreleasingUnsafeMutablePointer<NSError?>?) -> (@unowned Bool);
    v2[3] = &block_descriptor_55;
    uint64_t v10 = _Block_copy(v2);
    swift_retain();
    swift_release();
    objc_msgSend(v4, sel_setDidMigrateHandler_, v10);
    _Block_release(v10);
    uint64_t v11 = v3;
  }

  outlined consume of (@escaping @callee_guaranteed () -> ())?(v11);
LABEL_10:
  free(v2);
}

uint64_t _sxq_q0_s5Error_pRi_zRi0_zRi__Ri0__Ri_0_Ri0_0_r1_lySo24NSStagedMigrationManagerCSo08NSCustomC5StageCytIsegnnrzo_SgWOy( uint64_t result)
{
  if (result) {
    return swift_retain();
  }
  return result;
}

uint64_t partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed NSStagedMigrationManager, @in_guaranteed NSCustomMigrationStage) -> (@out (), @error @owned Error)( uint64_t a1, uint64_t a2)
{
  return partial apply for thunk for @escaping @callee_guaranteed (@in_guaranteed NSStagedMigrationManager, @in_guaranteed NSCustomMigrationStage) -> (@out (), @error @owned Error)( a1,  a2);
}

{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *, uint64_t *);
  uint64_t v5;
  uint64_t v6;
  uint64_t v5 = a2;
  uint64_t v3 = *(uint64_t (**)(uint64_t *, uint64_t *))(v2 + 16);
  uint64_t v6 = a1;
  return v3(&v6, &v5);
}

uint64_t partial apply for thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage) -> (@error @owned Error)( void *a1, void *a2)
{
  return (*(uint64_t (**)(void, void))(v2 + 16))(*a1, *a2);
}

unint64_t type metadata accessor for NSError()
{
  unint64_t result = lazy cache variable for type metadata for NSError;
  if (!lazy cache variable for type metadata for NSError)
  {
    objc_opt_self();
    unint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, (unint64_t *)&lazy cache variable for type metadata for NSError);
  }

  return result;
}

uint64_t thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage) -> (@error @owned Error)partial apply( void *a1, void *a2)
{
  return partial apply for thunk for @escaping @callee_guaranteed (@guaranteed NSStagedMigrationManager, @guaranteed NSCustomMigrationStage) -> (@error @owned Error)( a1,  a2);
}

void static NSPersistentContainer.defaultDirectoryURL.getter()
{
  id v0 = objc_msgSend((id)swift_getObjCClassFromMetadata(), sel_defaultDirectoryURL);
  static URL._unconditionallyBridgeFromObjectiveC(_:)();
}

uint64_t NSPersistentContainer.performBackgroundTask<A>(_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[5] = a4;
  v5[6] = v4;
  v5[3] = a2;
  v5[4] = a3;
  v5[2] = a1;
  uint64_t v6 = type metadata accessor for Optional();
  v5[7] = v6;
  v5[8] = *(void *)(v6 - 8);
  v5[9] = swift_task_alloc();
  v5[10] = swift_task_alloc();
  v5[11] = swift_task_alloc();
  return swift_task_switch();
}

uint64_t NSPersistentContainer.performBackgroundTask<A>(_:)()
{
  uint64_t v1 = *(void *)(v0 + 88);
  uint64_t v2 = *(void *)(v0 + 40);
  uint64_t v3 = *(void **)(v0 + 48);
  uint64_t v5 = *(void *)(v0 + 24);
  uint64_t v4 = *(void *)(v0 + 32);
  uint64_t v6 = *(void *)(v2 - 8);
  *(void *)(v0 + 96) = v6;
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 56);
  *(void *)(v0 + 104) = v7;
  v7(v1, 1LL, 1LL, v2);
  id v8 = objc_msgSend(v3, sel_newBackgroundContext);
  *(void *)(v0 + 112) = v8;
  uint64_t v9 = (void *)swift_allocObject();
  *(void *)(v0 + 120) = v9;
  v9[2] = v2;
  v9[3] = v5;
  v9[4] = v4;
  v9[5] = v8;
  *(_BYTE *)(v0 + 144) = 0;
  swift_retain();
  v8;
  uint64_t v10 = (void *)swift_task_alloc();
  *(void *)(v0 + 12_Block_object_dispose(va, 8) = v10;
  void *v10 = v0;
  v10[1] = NSPersistentContainer.performBackgroundTask<A>(_:);
  return NSManagedObjectContext.perform<A>(schedule:_:)( *(void *)(v0 + 80),  (_BYTE *)(v0 + 144),  (uint64_t)partial apply for closure #1 in NSPersistentContainer._rethrowsHelper_performTask<A>(execute:rescue:),  (uint64_t)v9,  *(void *)(v0 + 40));
}

{
  uint64_t v0;
  uint64_t v1;
  *(void *)(*(void *)v1 + 136LL) = v0;
  swift_task_dealloc();
  return swift_task_switch();
}

{
  uint64_t v0;
  void (*v1)(uint64_t, void, uint64_t, uint64_t);
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t result;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v2 = *(void *)(v0 + 96);
  uint64_t v1 = *(void (**)(uint64_t, void, uint64_t, uint64_t))(v0 + 104);
  uint64_t v3 = *(void *)(v0 + 80);
  uint64_t v4 = *(void *)(v0 + 88);
  uint64_t v6 = *(void *)(v0 + 64);
  uint64_t v5 = *(void *)(v0 + 72);
  uint64_t v7 = *(void *)(v0 + 56);
  id v8 = *(void *)(v0 + 40);
  uint64_t v9 = *(void (**)(uint64_t, uint64_t))(v6 + 8);
  v9(v4, v7);
  v1(v3, 0LL, 1LL, v8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 32))(v4, v3, v7);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 16))(v5, v4, v7);
  unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v2 + 48))(v5, 1LL, v8);
  if ((_DWORD)result == 1)
  {
    __break(1u);
  }

  else
  {
    uint64_t v11 = *(void **)(v0 + 112);
    uint64_t v12 = *(void *)(v0 + 96);
    uint64_t v13 = *(void *)(v0 + 72);
    BOOL v14 = *(void *)(v0 + 40);
    unsigned int v15 = *(void *)(v0 + 16);
    v9(*(void *)(v0 + 88), *(void *)(v0 + 56));

    swift_release();
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v12 + 32))(v15, v13, v14);
    swift_task_dealloc();
    swift_task_dealloc();
    swift_task_dealloc();
    return (*(uint64_t (**)(void))(v0 + 8))();
  }

  return result;
}

{
  uint64_t v0;
  void *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  id v6;
  uint64_t v1 = *(void **)(v0 + 136);
  uint64_t v2 = *(void **)(v0 + 112);
  uint64_t v3 = *(void *)(v0 + 88);
  uint64_t v4 = *(void *)(v0 + 64);
  uint64_t v5 = *(void *)(v0 + 56);
  uint64_t v6 = v1;
  swift_willThrow();
  swift_release();

  (*(void (**)(uint64_t, uint64_t))(v4 + 8))(v3, v5);
  swift_task_dealloc();
  swift_task_dealloc();
  swift_task_dealloc();
  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t sub_1866BC704()
{
  return swift_deallocObject();
}

id partial apply for closure #1 in NSPersistentContainer._rethrowsHelper_performTask<A>(execute:rescue:)()
{
  uint64_t v2 = *(void **)(v0 + 40);
  id result = (id)(*(uint64_t (**)(void *))(v0 + 24))(v2);
  if (!v1) {
    return objc_msgSend(v2, sel_reset);
  }
  return result;
}

uint64_t NSAttributeDescription.AttributeType.init(rawValue:)@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  *a2 = result;
  return result;
}

uint64_t NSAttributeDescription.AttributeType.rawValue.getter()
{
  return *(void *)v0;
}

uint64_t NSAttributeDescription.AttributeType.rawValue.setter(uint64_t result)
{
  *uint64_t v1 = result;
  return result;
}

uint64_t (*NSAttributeDescription.AttributeType.rawValue.modify())()
{
  return NSManagedObjectContext.ConcurrencyType.rawValue.modify;
}

id NSAttributeDescription.type.getter@<X0>(void *a1@<X8>)
{
  id result = objc_msgSend(v1, sel_attributeType);
  *a1 = result;
  return result;
}

id NSAttributeDescription.type.setter(void *a1)
{
  return objc_msgSend(v1, sel_setAttributeType_, *a1);
}

id (*NSAttributeDescription.type.modify(void *a1))(uint64_t a1)
{
  a1[1] = v1;
  *a1 = objc_msgSend(v1, sel_attributeType);
  return NSAttributeDescription.type.modify;
}

id NSAttributeDescription.type.modify(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 8), sel_setAttributeType_, *(void *)a1);
}

void static NSAttributeDescription.AttributeType.undefined.getter(void *a1@<X8>)
{
  *a1 = 0LL;
}

void static NSAttributeDescription.AttributeType.integer16.getter(void *a1@<X8>)
{
  *a1 = 100LL;
}

void static NSAttributeDescription.AttributeType.integer32.getter(void *a1@<X8>)
{
  *a1 = 200LL;
}

void static NSAttributeDescription.AttributeType.integer64.getter(void *a1@<X8>)
{
  *a1 = 300LL;
}

void static NSAttributeDescription.AttributeType.decimal.getter(void *a1@<X8>)
{
  *a1 = 400LL;
}

void static NSAttributeDescription.AttributeType.double.getter(void *a1@<X8>)
{
  *a1 = 500LL;
}

void static NSAttributeDescription.AttributeType.float.getter(void *a1@<X8>)
{
  *a1 = 600LL;
}

void static NSAttributeDescription.AttributeType.string.getter(void *a1@<X8>)
{
  *a1 = 700LL;
}

void static NSAttributeDescription.AttributeType.BOOLean.getter(void *a1@<X8>)
{
  *a1 = 800LL;
}

void static NSAttributeDescription.AttributeType.date.getter(void *a1@<X8>)
{
  *a1 = 900LL;
}

void static NSAttributeDescription.AttributeType.binaryData.getter(void *a1@<X8>)
{
  *a1 = 1000LL;
}

void static NSAttributeDescription.AttributeType.uuid.getter(void *a1@<X8>)
{
  *a1 = 1100LL;
}

void static NSAttributeDescription.AttributeType.uri.getter(void *a1@<X8>)
{
  *a1 = 1200LL;
}

void static NSAttributeDescription.AttributeType.transformable.getter(void *a1@<X8>)
{
  *a1 = 1800LL;
}

void static NSAttributeDescription.AttributeType.objectID.getter(void *a1@<X8>)
{
  *a1 = 2000LL;
}

void static NSAttributeDescription.AttributeType.composite.getter(void *a1@<X8>)
{
  *a1 = 2100LL;
}

unint64_t lazy protocol witness table accessor for type NSAttributeDescription.AttributeType and conformance NSAttributeDescription.AttributeType()
{
  unint64_t result = lazy protocol witness table cache variable for type NSAttributeDescription.AttributeType and conformance NSAttributeDescription.AttributeType;
  if (!lazy protocol witness table cache variable for type NSAttributeDescription.AttributeType and conformance NSAttributeDescription.AttributeType)
  {
    unint64_t result = MEMORY[0x186E3F040]( &protocol conformance descriptor for NSAttributeDescription.AttributeType,  &type metadata for NSAttributeDescription.AttributeType);
    atomic_store( result,  (unint64_t *)&lazy protocol witness table cache variable for type NSAttributeDescription.AttributeType and conformance NSAttributeDescription.AttributeType);
  }

  return result;
}

id sub_1866BC93C@<X0>(id *a1@<X0>, void *a2@<X8>)
{
  id result = objc_msgSend(*a1, sel_attributeType);
  *a2 = result;
  return result;
}

id sub_1866BC96C(void *a1, id *a2)
{
  return objc_msgSend(*a2, sel_setAttributeType_, *a1);
}

ValueMetadata *type metadata accessor for NSAttributeDescription.AttributeType()
{
  return &type metadata for NSAttributeDescription.AttributeType;
}

void sub_1866BD3D8(_Unwind_Exception *a1)
{
}

void sub_1866BD3F4()
{
}

void sub_1866BDA68()
{
}

void sub_1866BDB10(_Unwind_Exception *a1)
{
}

void sub_1866BDB2C()
{
}

void sub_1866BE0F8(_Unwind_Exception *a1)
{
}

void sub_1866BE114()
{
}

void sub_1866BE268(_Unwind_Exception *a1)
{
}

void sub_1866BE284()
{
}

void sub_1866BEA14(_Unwind_Exception *a1)
{
}

void sub_1866BEA30()
{
}

void sub_1866BECE4(_Unwind_Exception *a1)
{
}

void sub_1866BEFE4(_Unwind_Exception *a1)
{
}

void sub_1866BF000()
{
}

void sub_1866BF110(_Unwind_Exception *a1)
{
}

void sub_1866BF12C()
{
}

void sub_1866BF644(_Unwind_Exception *a1)
{
}

void sub_1866BF660()
{
}

void sub_1866BF9B0(_Unwind_Exception *a1)
{
}

void sub_1866BF9CC()
{
}

void sub_1866BFBD0(_Unwind_Exception *a1)
{
}

void sub_1866BFBEC()
{
}

id _swizzleManifestTypeDataXPC(void *a1, void *a2)
{
  CFStringRef v4 = 0LL;
  int v5 = [a2 sqlType];
  switch(v5)
  {
    case 1:
      uint64_t v19 = [a1 bytes];
      id v8 = (void *)[objc_alloc(NSString) initWithUTF8String:v19];
      uint64_t v9 = objc_msgSend(objc_alloc(MEMORY[0x189607968]), "initWithInteger:", objc_msgSend(v8, "integerValue"));
      goto LABEL_18;
    case 2:
    case 3:
      uint64_t v7 = [a1 bytes];
      id v8 = (void *)[objc_alloc(NSString) initWithUTF8String:v7];
      uint64_t v9 = objc_msgSend(objc_alloc(MEMORY[0x189607968]), "initWithLongLong:", objc_msgSend(v8, "longLongValue"));
LABEL_18:
      uint64_t v16 = v9;

      goto LABEL_19;
    case 4:
    case 5:
    case 6:
    case 9:
    case 12:
      if (CFDataGetLength((CFDataRef)a1))
      {
        BytePtr = (const char *)CFDataGetBytePtr((CFDataRef)a1);
        CFStringRef v4 = CFStringCreateWithCString(0LL, BytePtr, 0x8000100u);
      }

      else
      {
        CFStringRef v4 = &stru_189EAC2E8;
      }

      if (v5 == 12)
      {
        unsigned int v15 = (objc_class *)MEMORY[0x189604030];
      }

      else
      {
        if (v5 != 4) {
          goto LABEL_24;
        }
        unsigned int v15 = (objc_class *)MEMORY[0x189607858];
      }

      uint64_t v16 = [[v15 alloc] initWithString:v4];
      CFRelease(v4);
LABEL_19:
      id result = (id)v16;
      break;
    case 7:
    case 8:
      uint64_t v10 = [a1 bytes];
      uint64_t v11 = (void *)[objc_alloc(NSString) initWithUTF8String:v10];
      if (v5 == 7)
      {
        uint64_t v12 = objc_msgSend((id)objc_msgSend(a2, "propertyDescription"), "attributeType");
        id v13 = objc_alloc(MEMORY[0x189607968]);
        if (v12 == 600)
        {
          [v11 floatValue];
          uint64_t v14 = objc_msgSend(v13, "initWithFloat:");
        }

        else
        {
          [v11 doubleValue];
          uint64_t v14 = objc_msgSend(v13, "initWithDouble:");
        }
      }

      else
      {
        id v18 = objc_alloc(MEMORY[0x189603F50]);
        [v11 doubleValue];
        uint64_t v14 = objc_msgSend(v18, "initWithTimeIntervalSinceReferenceDate:");
      }

      CFStringRef v4 = (CFStringRef)v14;

      goto LABEL_24;
    case 11:
      if ([a1 length] == 16)
      {
        id result = (id)objc_msgSend(objc_alloc(MEMORY[0x189607AB8]), "initWithUUIDBytes:", objc_msgSend(a1, "bytes"));
      }

      else
      {
        CFStringRef v4 = 0LL;
LABEL_24:
        id result = (id)v4;
      }

      break;
    case 15:
      return +[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)a1,  (void *)[a2 propertyDescription]);
    default:
      goto LABEL_24;
  }

  return result;
}

LABEL_335:
    PF_FREE_OBJECT_ARRAY(v239);
    goto LABEL_336;
  }

LABEL_113:
  if (v107 < 1) {
    goto LABEL_344;
  }
  int v108 = 0LL;
  v276 = 0LL;
  v277 = 0LL;
  v289 = 0LL;
  v338 = 0LL;
  v278 = 0LL;
  v319 = @"TOMBSTONE";
  v290 = v321;
  v291 = v47;
  v292 = v76;
  while (1)
  {
    v305 = &v276;
    MEMORY[0x1895F8858](v93);
    v300 = v111;
    if (v111 > 0x200)
    {
      uint64_t v93 = NSAllocateScannedUncollectable();
      v332 = (char *)v93;
    }

    else
    {
      v332 = (char *)&v276 - v110;
      bzero((char *)&v276 - v110, 8LL * v109);
    }

    uint64_t v112 = v54;
    while ((*(_DWORD *)v112 & 0x80000000) != 0)
    {
      uint64_t v113 = *(unsigned int *)(v112 + 4);
      if ((v113 & 0x80000000) != 0) {
        uint64_t v112 = 0LL;
      }
      else {
        uint64_t v112 = *(void *)(*(void *)(v15 + 96) + 8 * v113) + *(void *)(v112 + 16);
      }
    }

    uint64_t v114 = v87 - v112;
    if (v114 <= 31)
    {
      uint64_t v89 = v337;
      uint64_t v90 = v322;
      uint64_t v91 = v308;
      if (!a8) {
        goto LABEL_393;
      }
      v262 = (void *)MEMORY[0x189607870];
      v263 = *MEMORY[0x189607460];
      v264 = (void *)MEMORY[0x189603F68];
      v265 = objc_msgSend( NSString,  "stringWithFormat:",  @"CoreData: XPC: Suspect response from server (not enough room for row %d)",  v108);
      goto LABEL_385;
    }

    v314 = v112;
    if ((v333 & 1) == 0)
    {
      int v117 = (void *)_sqlEntityForEntityID(v47, *(unsigned int *)(v112 + 8));
      if (v117 != v289)
      {
        v293 = (objc_class *)[v324 objectIDFactoryForSQLEntity:v117];
        v289 = v117;
      }

      if (v301)
      {
        int v118 = v117;
        v336 = v88;
        unsigned int v119 = v108;
        int v120 = v317;
        unint64_t v121 = v317[v119];
        uint64_t v93 = _PFSetPrimaryKey(v121, *(void *)(v314 + 24));
        if (v121 == v93)
        {
          int v108 = v119;
          if ((v306 & 2) != 0)
          {
            int v116 = (NSKnownKeysDictionary *)v121;
            goto LABEL_139;
          }
        }

        else
        {
          uint64_t v122 = v93;
          v120[v119] = v93;
          int v108 = v119;
          if ((v306 & 2) != 0)
          {
            int v116 = (NSKnownKeysDictionary *)v93;
LABEL_139:
            uint64_t v112 = v314;
LABEL_140:
            int v125 = 0LL;
            uint64_t v126 = v338;
            switch((int)v311)
            {
              case 0:
              case 3:
              case 5:
                int v125 = (NSKnownKeysDictionary *)-[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( v304,  v116,  v296);

                goto LABEL_318;
              case 1:
                int v125 = v116;
                break;
              default:
                goto LABEL_319;
            }

            goto LABEL_319;
          }

          [*(id *)&v315[8 * v119] setObjectID:v93];
          unint64_t v121 = v122;
        }

        char v124 = *(void **)&v315[8 * v108];
        uint64_t v115 = (NSKnownKeysDictionary *)v121;
        int v117 = v118;
      }

      else
      {
        unint64_t v123 = objc_alloc(v293);
        uint64_t v93 = [v123 initWithPK64:*(void *)(v314 + 24)];
        uint64_t v115 = (NSKnownKeysDictionary *)v93;
        if ((v306 & 2) != 0)
        {
          int v116 = (NSKnownKeysDictionary *)v93;
          v336 = v88;
          goto LABEL_139;
        }

        char v124 = (void *)objc_msgSend( +[NSSQLRow allocForSQLEntity:]((uint64_t)NSSQLRow, v117),  "initWithSQLEntity:ownedObjectID:andTimestamp:",  v117,  v93,  *(double *)(v15 + 40));
        *(void *)&v315[8 * v108] = v124;
      }

      v299 = v124;
      v312 = (char *)v124[5];
      uint64_t v88 = (int *)_sql_fetch_plan_for_entity((unint64_t *)v117);
      uint64_t v112 = v314;
      goto LABEL_146;
    }

    uint64_t v115 = 0LL;
    if ((v306 & 2) != 0)
    {
      int v116 = 0LL;
      v336 = v88;
      goto LABEL_140;
    }

    v338 = 0LL;
    int v117 = v295;
    v299 = 0LL;
    v312 = 0LL;
LABEL_146:
    v279 = v115;
    if (v114 < *v88)
    {
      uint64_t v89 = v337;
      uint64_t v90 = v322;
      uint64_t v91 = v308;
      if (!a8) {
        goto LABEL_393;
      }
      v262 = (void *)MEMORY[0x189607870];
      v263 = *MEMORY[0x189607460];
      v264 = (void *)MEMORY[0x189603F68];
      v265 = objc_msgSend( NSString,  "stringWithFormat:",  @"CoreData: XPC: Suspect response from server (remaining space for %d smaller than estimated size)",  v108);
LABEL_385:
      v270 = v265;
      v271 = v264;
      goto LABEL_386;
    }

    v288 = v108;
    char v127 = v88[1];
    v336 = v88;
    uint64_t v126 = v338;
    if ((_DWORD)v127) {
      break;
    }
LABEL_311:
    if (v333)
    {
      v233 = objc_alloc(&OBJC_CLASS___NSKnownKeysDictionary);
      int v125 = -[NSKnownKeysDictionary initWithSearchStrategy:](v233, "initWithSearchStrategy:", propertyMapping);
      uint64_t v93 = -[NSKnownKeysDictionary _setValues:retain:](v125, "_setValues:retain:", v332, 0LL);
      uint64_t v112 = v314;
      int v108 = v288;
    }

    else
    {
      v234 = v299;
      [v299 knownKeyValuesPointer];
      int v108 = v288;
      *(void *)&v307[8 * v288] = v234;
      v235 = v312;
      uint64_t v93 = v312;
      *(void *)&v315[8 * v108] = v93;
      if ((a4 & 1) != 0)
      {
        uint64_t v93 = v235;
LABEL_317:
        int v125 = (NSKnownKeysDictionary *)v93;
LABEL_318:
        uint64_t v112 = v314;
      }

      else
      {
        int v125 = 0LL;
        uint64_t v112 = v314;
        switch((int)v311)
        {
          case 0:
          case 3:
          case 5:
            uint64_t v93 = (uint64_t)-[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]( v304,  v279,  v296);
            goto LABEL_317;
          case 1:
            int v125 = v279;
            uint64_t v93 = _PFfastOidRetain(0, (unint64_t)v279);
            goto LABEL_318;
          case 2:
          case 4:
            break;
          default:
            goto LABEL_318;
        }
      }
    }

    if (a3) {
      uint64_t v97 = [NSString stringWithFormat:@"%@.%@", a3, objc_msgSend(v8, "name")];
    }
    else {
      uint64_t v97 = [v8 name];
    }
    uint64_t v98 = v97;
    if (![v8 isOptional] || (objc_msgSend(a2, "isOptional") & 1) != 0)
    {
      if ([a2 attributeType] == 1000
        && [a2 storesBinaryDataExternally]
        && ([v8 storesBinaryDataExternally] & 1) == 0)
      {
        unint64_t v104 = [MEMORY[0x189607878] expressionForKeyPath:v98];
        __int16 v105 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObject:v104];
        uint64_t v99 = objc_msgSend( MEMORY[0x189607878],  "expressionForFunction:selectorName:arguments:",  objc_msgSend(MEMORY[0x189607878], "expressionForEvaluatedObject"),  @"_prependExternalBlobToken:",  v105);

        goto LABEL_125;
      }

      if ([a2 attributeType] != 1000
        || ![v8 storesBinaryDataExternally]
        || [a2 storesBinaryDataExternally])
      {
        uint64_t v99 = [MEMORY[0x189607878] expressionForKeyPath:v98];
LABEL_125:
        uint64_t v100 = (void *)MEMORY[0x189607878];
        uint64_t v101 = [MEMORY[0x189607878] expressionForVariable:@"source"];
        uint64_t v39 = objc_msgSend( v100,  "expressionForFunction:selectorName:arguments:",  v101,  @"valueForKey:",  objc_msgSend( MEMORY[0x189603F18],  "arrayWithObject:",  objc_msgSend(MEMORY[0x189607878], "expressionForConstantValue:", v98)));
        id v143 = -[NSPropertyTransform initWithPropertyName:valueExpression:]( objc_alloc(&OBJC_CLASS___NSPropertyTransform),  "initWithPropertyName:valueExpression:",  v140,  v99);
        uint64_t v31 = v140;
        uint64_t v38 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:&v143 count:1];

        unint64_t v102 = 0;
        goto LABEL_142;
      }

      unsigned int v68 = objc_alloc(MEMORY[0x189607870]);
      int v69 = *MEMORY[0x189607460];
      uint64_t v122 = (void *)MEMORY[0x189603F68];
      unint64_t v123 = [*(id *)(v19 + 24) destinationEntityName];
      unint64_t v133 = @"Reason";
      uint64_t v134 = 0LL;
LABEL_158:
      char v124 = @"Unable to use inferred mapping to move external reference into store.";
      goto LABEL_149;
    }

    if ([a2 defaultValue])
    {
      unint64_t v103 = 0;
    }

    else
    {
      if ((int)[(id)objc_opt_class() migrationDebugLevel] >= 2)
      {
        uint64_t v106 = [*(id *)(v19 + 24) sourceEntityName];
        [*(id *)(v19 + 24) destinationEntityName];
        _NSCoreDataLog( 2LL,  (uint64_t)@"(migration) attribute mapping for (%@->%@ to %@->%@) requires data validation during store migration, mapping a previously optional attribute to a mandatory attribute without a default value.\n",  v107,  v108,  v109,  v110,  v111,  v112,  v106);
      }

      unint64_t v103 = 1;
    }

    if ([a2 attributeType] == 1000
      && [a2 storesBinaryDataExternally]
      && ([v8 storesBinaryDataExternally] & 1) == 0)
    {
      char v141 = v103;
      uint64_t v131 = [MEMORY[0x189607878] expressionForKeyPath:v98];
      unint64_t v132 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObject:v131];
      int v138 = objc_msgSend( MEMORY[0x189607878],  "expressionForFunction:selectorName:arguments:",  objc_msgSend(MEMORY[0x189607878], "expressionForEvaluatedObject"),  @"_prependExternalBlobToken:",  v132);
    }

    else
    {
      if ([a2 attributeType] == 1000
        && [v8 storesBinaryDataExternally]
        && ![a2 storesBinaryDataExternally])
      {
        unsigned int v68 = objc_alloc(MEMORY[0x189607870]);
        int v69 = *MEMORY[0x189607460];
        uint64_t v122 = (void *)MEMORY[0x189603F68];
        unint64_t v123 = [*(id *)(v19 + 24) destinationEntityName];
        unint64_t v133 = 0LL;
        goto LABEL_158;
      }

      char v141 = v103;
      int v138 = [MEMORY[0x189607878] expressionForKeyPath:v98];
    }

    uint64_t v113 = (void *)MEMORY[0x189607878];
    char v135 = [MEMORY[0x189607878] expressionForVariable:@"entityPolicy"];
    uint64_t v114 = (void *)MEMORY[0x189603F18];
    uint64_t v115 = [MEMORY[0x189607878] expressionForConstantValue:v31];
    int v116 = [MEMORY[0x189607878] expressionForVariable:@"source"];
    uint64_t v39 = objc_msgSend( v113,  "expressionForFunction:selectorName:arguments:",  v135,  @"_nonNilValueOrDefaultValueForAttribute:source:destination:",  objc_msgSend( v114,  "arrayWithObjects:",  v115,  v116,  objc_msgSend(MEMORY[0x189607878], "expressionForVariable:", @"destination"),  0));
    int v117 = -[NSPropertyTransform initWithPropertyName:valueExpression:]( objc_alloc(&OBJC_CLASS___NSPropertyTransform),  "initWithPropertyName:valueExpression:",  v31,  v138);
    int v118 = objc_alloc(&OBJC_CLASS___NSPropertyTransform);
    unsigned int v119 = -[NSPropertyTransform initWithPropertyName:valueExpression:]( v118,  "initWithPropertyName:valueExpression:",  v31,  objc_msgSend(MEMORY[0x189607878], "expressionForConstantValue:", objc_msgSend(a2, "defaultValue")));
    unint64_t v121 = v119;
    if (v119)
    {
      objc_setProperty_nonatomic(v119, v120, v117, 24LL);
      v121->_replaceMissingValueOnly = 1;
    }

    uint64_t v38 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v117, v121, 0);

    unint64_t v102 = v141;
LABEL_142:
    unint64_t v36 = v102 != 0;
    if (!v38)
    {
LABEL_143:
      unsigned int v68 = objc_alloc(MEMORY[0x189607870]);
      int v69 = *MEMORY[0x189607460];
      uint64_t v70 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  v31,  @"property",  objc_msgSend(*(id *)(v19 + 24), "destinationEntityName"),  @"entity",  @"Unable to infer mapping for attribute",  @"reason",  0);
      goto LABEL_150;
    }

    goto LABEL_49;
  }

  if (([a2 isOptional] & 1) != 0 || objc_msgSend(a2, "defaultValue"))
  {
    unint64_t v36 = 0;
  }

  else
  {
    if ((int)[(id)objc_opt_class() migrationDebugLevel] >= 2)
    {
      uint64_t v83 = [*(id *)(v19 + 24) destinationEntityName];
      _NSCoreDataLog( 2LL,  (uint64_t)@"(migration) attribute mapping for (%@->%@) requires data validation during store migration, mapping a new, mandatory attribute without a default value.\n",  v84,  v85,  v86,  v87,  v88,  v89,  v83);
    }

    unint64_t v36 = 1;
  }

  uint64_t v37 = objc_alloc(&OBJC_CLASS___NSPropertyTransform);
  id v143 = -[NSPropertyTransform initWithPropertyName:valueExpression:]( v37,  "initWithPropertyName:valueExpression:",  v31,  objc_msgSend(MEMORY[0x189607878], "expressionForConstantValue:", objc_msgSend(a2, "defaultValue")));
  uint64_t v38 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:&v143 count:1];

  uint64_t v39 = 0LL;
  if (!v38) {
    goto LABEL_143;
  }
LABEL_49:
  int v40 = objc_alloc_init(&OBJC_CLASS___NSPropertyMapping);
  -[NSPropertyMapping setName:](v40, "setName:", v31);
  -[NSPropertyMapping setValueExpression:](v40, "setValueExpression:", v39);
  -[NSPropertyMapping _setPropertyTransforms:](v40, v38);

  if (v36)
  {
    int v41 = objc_alloc(MEMORY[0x189603F68]);
    int v42 = [MEMORY[0x189607968] numberWithBool:1];
    int v43 = (void *)objc_msgSend(v41, "initWithObjectsAndKeys:", v42, _NSInferredMappingCouldFailValidation, 0);
    -[NSPropertyMapping setUserInfo:](v40, "setUserInfo:", v43);
    v144[0] = NSPropertyTransformMandatoryPropertyValidation;
    -[NSPropertyMapping _setTransformValidations:]( v40,  (void *)[MEMORY[0x189603F18] arrayWithObjects:v144 count:1]);
    unsigned int v44 = (void *)[*(id *)(v19 + 24) userInfo];
    if (v44)
    {
      uint64_t v45 = v44;
      if ((objc_msgSend((id)objc_msgSend(v44, "objectForKey:", _NSInferredMappingCouldFailValidation), "BOOLValue") & 1) == 0)
      {
        uint64_t v46 = (void *)[v45 mutableCopy];
        uint64_t v47 = [MEMORY[0x189607968] numberWithBool:1];
        [v46 setObject:v47 forKey:_NSInferredMappingCouldFailValidation];
        [*(id *)(v19 + 24) setUserInfo:v46];
      }
    }

    else
    {
      [*(id *)(v19 + 24) setUserInfo:v43];
    }
  }

  if (!v40) {
    goto LABEL_152;
  }
  uint64_t v90 = (id *)(a1 + 72);
LABEL_96:
  [*v90 addObject:v40];

  if (v8) {
    objc_msgSend(*(id *)(a1 + 88), "removeObject:", objc_msgSend(v8, "name"));
  }
}

        if ([v124 count] == 1)
        {
          if (v119)
          {
            uint64_t v107 = [v124 objectAtIndex:0];
            uint64_t v106 = 0LL;
            *unsigned int v119 = v107;
            goto LABEL_121;
          }
        }

        else
        {
          int v108 = v119 != 0LL;
          int v109 = [v124 count];
          id v110 = !v108;
          if (v109 < 2) {
            id v110 = 1;
          }
          if ((v110 & 1) == 0)
          {
            uint64_t v111 = objc_alloc(MEMORY[0x189603F68]);
            uint64_t v112 = (void *)objc_msgSend(v111, "initWithObjectsAndKeys:", v124, v118, 0);
            uint64_t v113 = [MEMORY[0x189607870] errorWithDomain:v121 code:1560 userInfo:v112];
            *unsigned int v119 = v113;
          }
        }

        uint64_t v106 = 0LL;
LABEL_121:
        uint64_t v114 = v128 < 0x201;

        if (!v114) {
          NSZoneFree(0LL, v127);
        }
        return v106;
      }
    }
  }

  if ((v117 & 1) != 0)
  {
    char v124 = 0LL;
    uint64_t v12 = v139 + 10;
    uint64_t v11 = v139[10];
    id v13 = v11 | 8;
    v139[10] = v11 | 8;
LABEL_111:
    id *v12 = v13 & 0xFFFFFFF7 | (8 * ((v11 >> 3) & 1));
LABEL_112:
    uint64_t v106 = 1LL;
    goto LABEL_121;
  }

  return 1LL;
}

LABEL_319:
    *((void *)v322 + v10_Block_object_dispose(va, 8) = v125;
    v236 = *(unsigned int *)(v112 + 4);
    if ((v236 & 0x80000000) != 0 || (v237 = *(void *)(*(void *)(v15 + 96) + 8 * v236)) == 0)
    {
      int v76 = v292;
LABEL_344:
      v243 = v76;
      else {
        v244 = dword_1868D5B70[v311];
      }
      v245 = v337;
      v247 = v321;
      v246 = v322;
      v248 = objc_alloc(&OBJC_CLASS____PFArray);
      id v24 = -[_PFArray initWithObjects:count:andFlags:andContext:]( v248,  "initWithObjects:count:andFlags:andContext:",  v246,  v247,  v244,  v304);
      if (((v243 | v294) & 1) != 0)
      {
        v249 = 0;
        v250 = v315;
        v251 = v320;
LABEL_355:
        if (((v243 | v249) & 1) == 0 && (int)v247 >= 1)
        {
          v257 = (int)v247;
          v258 = (void **)v307;
          do
          {
            v259 = *v258++;

            --v257;
          }

          while (v257);
        }
      }

      else
      {
        v337 = v245;
        v252 = v313;
        v249 = v313 != 0LL;
        v251 = v320;
        if (v313)
        {
          v253 = objc_alloc(&OBJC_CLASS____PFArray);
          *v252 = -[_PFArray initWithObjects:count:andFlags:andContext:]( v253,  "initWithObjects:count:andFlags:andContext:",  v307,  v247,  26LL,  v304);
        }

        v250 = v315;
        v245 = v337;
        if ((int)v247 >= 1)
        {
          v254 = (int)v247;
          v255 = (void **)v315;
          do
          {
            v256 = *v255++;

            --v254;
          }

          while (v254);
          v245 = v337;
          goto LABEL_355;
        }
      }

      if (v308 >= 0x201)
      {
        NSZoneFree(0LL, v250);
        NSZoneFree(0LL, v307);
      }

      if (v310 >= 0x201) {
        NSZoneFree(0LL, v317);
      }
      if (v251) {

      }
      return (id)v24;
    }

    v338 = v126;
    v238 = *(void *)(v112 + 16);
    int v76 = v292;
    if (v300 >= 0x201) {
      NSZoneFree(0LL, v332);
    }
    uint64_t v54 = v237 + v238;
    ++v108;
    uint64_t v47 = v291;
    int v87 = v323;
    uint64_t v88 = v336;
    if (v108 == v290) {
      goto LABEL_344;
    }
  }

  uint64_t v128 = 0LL;
  BOOL v129 = 0LL;
  v329 = v117;
  v330 = 0LL;
  v318 = 0LL;
  uint64_t v130 = 0;
  uint64_t v131 = 0LL;
  v340 = (__CFString *)(v112 + 32);
  v328 = v332 != 0LL;
  v298 = v312 + 28;
  v327 = 24 * v127;
  while (2)
  {
    v338 = v126;
    v339 = v128;
    unint64_t v132 = v131;
    unint64_t v133 = (CFDataRef)((char *)v88 + v128);
    uint64_t v134 = *((unsigned __int8 *)v88 + v128 + 20);
    else {
      char v135 = qword_1868D5B38[(char)(v134 - 2)];
    }
    v340 = (__CFString *)(((unint64_t)v340 + v135) & ~v135);
    if ((*((_BYTE *)v133 + 16) & 1) != 0)
    {
      isa_low = LOBYTE(v340->isa);
      v340 = (__CFString *)((char *)v340 + 1);
      int v136 = isa_low != 0;
    }

    else
    {
      int v136 = 0;
    }

    int v138 = 0LL;
    v334 = v129;
    v335 = v130;
    if (((v129 > 6) & v130) == 1 && !v136)
    {
      v325 = v136;
      v331 = v133;
      v326 = v131;
      int v138 = v330;
      if (!v330)
      {
        int v139 = [v324 model];
        int v138 = v303(v139, v302, (int)v318);
      }

      unsigned int v140 = +[_PFPersistentHistoryModel _retainedTombstonesForEntity:]( (uint64_t)&OBJC_CLASS____PFPersistentHistoryModel,  (void *)v138);
      char v141 = (void *)objc_msgSend((id)objc_msgSend(*(id *)((char *)v88 + v339 + 24), "propertyDescription"), "name");
      id v142 = objc_msgSend( (id)objc_msgSend(v141, "stringByReplacingOccurrencesOfString:withString:", v319, &stru_189EAC2E8),  "intValue");
      id v143 = [v140 count];
      v330 = v138;
      if (v142 >= v143)
      {
        int v138 = 0LL;
      }

      else
      {
        uint64_t v144 = [v140 objectAtIndexedSubscript:v142];
        if (v138) {
          int v138 = [*(id *)(v138 + 40) objectForKey:v144];
        }
        uint64_t v134 = 17;
      }

      unint64_t v132 = v326;
      unint64_t v133 = v331;
      int v136 = v325;
    }

    uint64_t v145 = ~v135;
    uint64_t v131 = 0LL;
    switch(v134)
    {
      case 1:
        LODWORD(v341) = 0;
        uint64_t v167 = v340;
        v168 = (__int16 *)(((unint64_t)v340 + v135) & v145);
        if (!v136) {
          uint64_t v167 = (__CFString *)(v168 + 2);
        }
        v340 = v167;
        __int128 v169 = (__int16 *)&v341;
        if (!v136) {
          __int128 v169 = v168;
        }
        __int128 v170 = *((unsigned __int8 *)v336 + v339 + 21);
        switch(v170)
        {
          case 10:
            if ((v333 & 1) == 0) {
              v280(v299, v281, *((unsigned int *)v133 + 2), *(unsigned int *)v169);
            }
            break;
          case 4:
            if ((v333 & 1) != 0)
            {
              v202 = v338;
              if (v136)
              {
                *(void *)&v332[8 * (int)v338] = 0LL;
              }

              else
              {
                v229 = v303(v291, v302, *(int *)v168);
                *(void *)&v332[8 * v202] = v229;
              }

              unint64_t v132 = 1LL;
            }

            else
            {
              v282(v299, v283, *((unsigned int *)v133 + 2), *(unsigned int *)v169);
            }

            break;
          case 1:
            __int128 v171 = v136;
            __int128 v172 = v312;
            if ((v333 & 1) != 0)
            {
              if (!byte_18C4ABDBE) {
                __int128 v171 = 0;
              }
              uint64_t v173 = v338;
              if (v171)
              {
                uint64_t v174 = 0LL;
              }

              else
              {
                if (byte_18C4ABDBE) {
                  v228 = v168;
                }
                else {
                  v228 = v169;
                }
                uint64_t v174 = CFNumberCreate(0LL, kCFNumberIntType, v228);
              }

              unint64_t v132 = 0LL;
              *(void *)&v332[8 * v173] = v174;
            }

            else
            {
              v214 = *((unsigned int *)v133 + 2);
              if (v171)
              {
                v200 = 1 << (v214 & 7);
                v201 = v214 >> 3;
                goto LABEL_263;
              }

              v230 = v133;
              Class Class = object_getClass(v312);
              v232 = *(char *)(*((void *)object_getIndexedIvars(Class) + 7) + v214);
              if (v232 == 115)
              {
                snapshot_set_int16(v172, *((_DWORD *)v230 + 2), *v168);
              }

              else if (v232 == 99)
              {
                snapshot_set_int8(v172, *((_DWORD *)v230 + 2), *(_BYTE *)v168);
              }

              else
              {
                snapshot_set_int32(v172, *((_DWORD *)v230 + 2), *(_DWORD *)v168);
              }
            }

            break;
          default:
            goto LABEL_283;
        }

        goto LABEL_283;
      case 2:
      case 3:
        id v156 = v340;
        uint64_t v157 = (uint64_t *)(((unint64_t)v340 + v135) & v145);
        if (!v136) {
          id v156 = (__CFString *)(v157 + 1);
        }
        v340 = v156;
        v341 = 0LL;
        int v158 = &v341;
        if (!v136) {
          int v158 = v157;
        }
        uint64_t v159 = *((unsigned __int8 *)v336 + v339 + 21);
        switch(v159)
        {
          case 6:
            if ((v333 & 1) == 0) {
              v284(v299, v285, *v158);
            }
            break;
          case 3:
            if ((v333 & 1) == 0)
            {
              v286(v299, v287, *((unsigned int *)v133 + 2), *v158);
              goto LABEL_283;
            }

            if ((v132 & 1) != 0)
            {
              unsigned int v188 = *(void *)&v332[8 * (int)v338 - 8];
              v338 = (int)v338 - 1LL;
            }

            else
            {
              unsigned int v188 = objc_msgSend( (id)objc_msgSend(*(id *)((char *)v336 + v339 + 24), "toOneRelationship"),  "destinationEntity");
            }

            if (v136 || !*v157)
            {
              int v161 = 0LL;
            }

            else
            {
              if (v188 != v276)
              {
                v215 = (objc_class *)[v324 objectIDFactoryForSQLEntity:v188];
                v276 = v188;
                v277 = v215;
              }

              int v161 = (CFNumberRef)[[v277 alloc] initWithPK64:*v157];
            }

            v213 = v332;
            unint64_t v132 = 0LL;
            goto LABEL_274;
          case 1:
            if ((v333 & 1) != 0)
            {
              if (byte_18C4ABDBE) {
                uint64_t v160 = v136;
              }
              else {
                uint64_t v160 = 0;
              }
              if (v160)
              {
                int v161 = 0LL;
              }

              else
              {
                if (byte_18C4ABDBE) {
                  v212 = v157;
                }
                else {
                  v212 = v158;
                }
                int v161 = CFNumberCreate(0LL, kCFNumberLongLongType, v212);
              }

              unint64_t v132 = 0LL;
              v213 = v332;
LABEL_274:
              *(void *)&v213[8 * (int)v338] = v161;
              goto LABEL_283;
            }

            v199 = *((unsigned int *)v133 + 2);
            if (v136)
            {
              v200 = 1 << (v199 & 7);
              v201 = v199 >> 3;
LABEL_263:
              v298[v201] |= v200;
            }

            else
            {
              snapshot_set_int64(v312, v199, *v157);
            }

            break;
          default:
            goto LABEL_283;
        }

        goto LABEL_283;
      case 4:
      case 5:
      case 6:
      case 9:
      case 12:
        if ((v333 & 1) != 0)
        {
          if (v136)
          {
            v146 = 0LL;
            int v147 = v338;
LABEL_229:
            uint64_t v131 = 0LL;
            *(void *)&v332[8 * v147] = v146;
            goto LABEL_284;
          }

          uint64_t v163 = (const char *)(((unint64_t)v340 + v135) & v145);
          if ((uint64_t)(v323 - (void)(v163 + 4)) >= *(int *)v163)
          {
            uint64_t v164 = v133;
            v146 = CFStringCreateWithCString(0LL, v163 + 4, 0x8000100u);
            v340 = (__CFString *)&v163[*(int *)v163 + 4];
            int v165 = *((unsigned __int8 *)v164 + 20);
            if (v165 == 12)
            {
              int v166 = (const __CFString *)(id)[MEMORY[0x189604030] URLWithString:v146];
              int v147 = v338;
            }

            else
            {
              int v147 = v338;
              if (v165 != 4) {
                goto LABEL_229;
              }
              int v166 = (const __CFString *)[objc_alloc(MEMORY[0x189607858]) initWithString:v146];
            }

            CFRelease(v146);
            v146 = v166;
            goto LABEL_229;
          }

          uint64_t v89 = v337;
          uint64_t v90 = v322;
          uint64_t v91 = v308;
          if (!a8) {
            goto LABEL_393;
          }
          v266 = (void *)MEMORY[0x189607870];
          v267 = *MEMORY[0x189607460];
          v268 = (void *)MEMORY[0x189603F68];
          v269 = [NSString stringWithFormat:@"CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (2))", *(void *)((char *)v336 + v339 + 24)];
LABEL_391:
          v272 = [v268 dictionaryWithObject:v269 forKey:@"Reason"];
          v273 = v266;
          v274 = v267;
          goto LABEL_392;
        }

        if (v136) {
          goto LABEL_218;
        }
        int v148 = (const char *)(((unint64_t)v340 + v135) & v145);
        uint64_t v149 = (int *)(v148 + 4);
        if ((uint64_t)(v323 - (void)(v148 + 4)) < *(int *)v148)
        {
          uint64_t v89 = v337;
          uint64_t v90 = v322;
          uint64_t v91 = v308;
          if (!a8) {
            goto LABEL_393;
          }
          v266 = (void *)MEMORY[0x189607870];
          v267 = *MEMORY[0x189607460];
          v268 = (void *)MEMORY[0x189603F68];
          v269 = [NSString stringWithFormat:@"CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (1))", *(void *)((char *)v336 + v339 + 24)];
          goto LABEL_391;
        }

        int v150 = v133;
        uint64_t v151 = (__CFString *)CFStringCreateWithCString(0LL, v148 + 4, 0x8000100u);
        uint64_t v152 = *(int *)v148;
        uint64_t v153 = *((unsigned __int8 *)v150 + 20);
        if (v153 == 12)
        {
          v340 = (__CFString *)(id)[MEMORY[0x189604030] URLWithString:v151];
          id v154 = v312;
          goto LABEL_280;
        }

        id v154 = v312;
        if (v153 != 4) {
          goto LABEL_281;
        }
        int v155 = (__CFString *)[objc_alloc(MEMORY[0x189607858]) initWithString:v151];
        goto LABEL_279;
      case 7:
      case 8:
        if ((v333 & 1) != 0)
        {
          if (v136)
          {
            uint64_t v162 = 0LL;
          }

          else
          {
            unsigned __int8 v189 = (CFAbsoluteTime *)(((unint64_t)v340 + v135) & v145);
            v340 = (__CFString *)(v189 + 1);
            if (*((_BYTE *)v133 + 20) == 7) {
              uint64_t v162 = CFNumberCreate(0LL, kCFNumberDoubleType, v189);
            }
            else {
              uint64_t v162 = CFDateCreate(0LL, *v189);
            }
          }

          uint64_t v131 = 0LL;
          *(void *)&v332[8 * (int)v338] = v162;
          goto LABEL_284;
        }

        if (v136) {
          goto LABEL_218;
        }
        uint64_t v179 = (double *)(((unint64_t)v340 + v135) & v145);
        v340 = (__CFString *)(v179 + 1);
        int v180 = *((unsigned int *)v133 + 2);
        v181 = v312;
        if (*((_BYTE *)v133 + 20) == 7)
        {
          int v182 = v133;
          int v183 = object_getClass(v312);
          IndexedIvars = object_getIndexedIvars(v183);
          id v185 = *((_DWORD *)v182 + 2);
          int v186 = *v179;
          if (*(_BYTE *)(IndexedIvars[7] + v180) == 102)
          {
            int v187 = v186;
            snapshot_set_float(v181, v185, v187);
            goto LABEL_283;
          }

          v211 = v181;
        }

        else
        {
          int v186 = *v179;
          v211 = v312;
          id v185 = *((_DWORD *)v133 + 2);
        }

        snapshot_set_double(v211, v185, v186);
        goto LABEL_283;
      case 13:
      case 14:
        goto LABEL_284;
      case 16:
        uint64_t v175 = *(void **)((char *)v336 + v339 + 24);
        v331 = v133;
        uint64_t v176 = objc_msgSend((id)objc_msgSend(v175, "propertyDescription"), "_isFileBackedFuture");
        unint64_t v133 = v331;
        if (!v176) {
          goto LABEL_210;
        }
        if (v136)
        {
          if ((v333 & 1) != 0)
          {
            uint64_t v131 = 0LL;
            *(void *)&v332[8 * (int)v338] = 0LL;
            goto LABEL_284;
          }

LABEL_218:
          v298[(unint64_t)*((unsigned int *)v133 + 2) >> 3] |= 1 << (*((_DWORD *)v133 + 2) & 7);
          goto LABEL_283;
        }

        v203 = (int *)(((unint64_t)v340 + v135) & v145);
        v204 = v203 + 1;
        if ((uint64_t)(v323 - (void)(v203 + 1)) >= *v203)
        {
          v205 = objc_msgSend(MEMORY[0x189603F48], "dataWithBytes:length:", v203 + 1);
          v206 = *v203;
          v207 = v278;
          if (!v278) {
            v207 = [v324 fileBackedFuturesDirectory];
          }
          v340 = (__CFString *)((char *)v204 + v206);
          v208 = objc_alloc(&OBJC_CLASS____NSDataFileBackedFuture);
          v278 = v207;
          v209 = -[_NSDataFileBackedFuture initWithStoreMetadata:directory:]( v208,  "initWithStoreMetadata:directory:",  v205,  [MEMORY[0x189604030] fileURLWithPath:v207 isDirectory:1]);
          v210 = v209;
          if ((v333 & 1) != 0)
          {
            uint64_t v131 = 0LL;
            *(void *)&v332[8 * (int)v338] = v209;
            goto LABEL_284;
          }

          v218 = *((_DWORD *)v331 + 2);
          v219 = v312;
LABEL_282:
          snapshot_set_object(v219, v218, v210);
LABEL_283:
          uint64_t v131 = v132;
LABEL_284:
          v220 = v339;
          if (v329 && v339 == 72 && v329[46] == 16001)
          {
            v221 = v338;
            v222 = v131;
            v223 = [*(id *)&v332[8 * (int)v338] intValue];
            uint64_t v131 = v222;
            uint64_t v130 = (v223 == 2) | v335;
            uint64_t v88 = v336;
          }

          else
          {
            uint64_t v130 = v335;
            uint64_t v88 = v336;
            v221 = v338;
            if (v339 == 120 && (v335 & 1) != 0)
            {
              v224 = a4;
              v225 = v131;
              v226 = [*(id *)&v332[8 * (int)v338] intValue];
              uint64_t v131 = v225;
              a4 = v224;
              uint64_t v88 = v336;
              v318 = v226;
              uint64_t v130 = 1;
            }
          }

          uint64_t v126 = (v221 + v328);
          BOOL v129 = v334 + 1;
          uint64_t v128 = v220 + 24;
          if (v327 == v128) {
            goto LABEL_311;
          }
          continue;
        }

        uint64_t v89 = v337;
        uint64_t v90 = v322;
        uint64_t v91 = v308;
        if (a8)
        {
          v262 = (void *)MEMORY[0x189607870];
          v263 = *MEMORY[0x189607460];
          v275 = (void *)MEMORY[0x189603F68];
          v270 = [NSString stringWithFormat:@"CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (3))", *(void *)((char *)v336 + v339 + 24)];
          v271 = v275;
LABEL_386:
          v272 = objc_msgSend(v271, "dictionaryWithObject:forKey:", v270, @"Reason", v276);
          v273 = v262;
          v274 = v263;
LABEL_392:
          *a8 = objc_msgSend(v273, "errorWithDomain:code:userInfo:", v274, 134060, v272, v276);
        }

        if (objc_msgSend(v99, "isReadOnly", v252))
        {
          v251 = (const char *)[v8 name];
          LODWORD(v59) = 1;
          _NSCoreDataLog( 1LL,  (uint64_t)@"Property '%s' is marked readonly on entity '%@'.  Cannot generate a setter method for it.",  v161,  v162,  v163,  v164,  v165,  v166,  (uint64_t)v255);
          uint64_t v57 = 0LL;
          unint64_t v58 = 0LL;
          uint64_t v62 = 0LL;
          uint64_t v61 = 0;
          uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
        }

        else if (v138)
        {
          if ((byte_18C4AB9B9 & 1) == 0) {
            -[objc_class _initializeAccessorStubs](v20, "_initializeAccessorStubs");
          }
          uint64_t v57 = 0LL;
          unint64_t v58 = 0LL;
          uint64_t v61 = 0;
          uint64_t v62 = qword_18C4AB9F8;
          LODWORD(v59) = 1;
        }

        else
        {
          uint64_t v57 = 0LL;
          uint64_t v62 = 0LL;
          uint64_t v61 = 0;
          LODWORD(v59) = 1;
          unint64_t v58 = _sharedIMPL_copying_setvfk_core;
        }

        goto LABEL_277;
      }

      uint64_t v19 = v18;
      v256 = &v252;
      uint64_t v20 = v259;
      if ((byte_18C4AB9B9 & 1) == 0) {
        -[objc_class _initializeAccessorStubs](v259, "_initializeAccessorStubs");
      }
      uint64_t v21 = (objc_class *)objc_opt_class();
      uint64_t v22 = *(void **)(v8[12] + 24LL + 8 * v19);
      uint64_t v23 = v8[14];
      id v24 = class_getProperty(v21, v10);
      if (v24)
      {
        uint64_t v25 = property_getAttributes(v24);
        uint64_t v26 = strlen(v25);
        v255 = &v252;
        MEMORY[0x1895F8858](v26);
        uint64_t v28 = (char *)&v252 - v27;
        strlcpy((char *)&v252 - v27, v25, v29);
        v264 = v28;
        uint64_t v30 = strsep(&v264, ",");
        if (v30)
        {
          uint64_t v31 = v30;
          LODWORD(v257) = 0;
          v253 = 0;
          v252 = @"Property '%s' is a scalar type on class '%s' that does not match its Entity's property's scalar type.  Dynamically generated accessors do not support implicit type coercion.  Cannot generate a getter method for it.";
          while (1)
          {
            if (*v31 == 84)
            {
              id v33 = v31[1];
              uint64_t v32 = v31 + 1;
              if (v33 != 64 && (isTypeEncodingObject(v32) & 1) == 0)
              {
                unint64_t v34 = *(void *)(v23 + 16);
                uint64_t v54 = v19 >= v34;
                uint64_t v35 = v19 - v34;
                if (!v54 || v35 >= *(void *)(v23 + 24))
                {
                  v252 = @"Property '%s' is a scalar type on class '%s'.  Cannot generate a getter method for it.";
LABEL_106:
                  uint64_t v20 = v259;
                  uint64_t v78 = (objc_class *)objc_opt_class();
                  v251 = class_getName(v78);
                  _NSCoreDataLog(1LL, (uint64_t)v252, v79, v80, v81, v82, v83, v84, (uint64_t)v10);
                  uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
                  uint64_t v57 = 0LL;
                  unint64_t v58 = 0LL;
                  uint64_t v62 = 0LL;
                  uint64_t v61 = 0;
                  LODWORD(v59) = 0;
                  goto LABEL_247;
                }

                unint64_t v36 = objc_msgSend(v22, "attributeType", v252);
                if (v36 <= 499)
                {
                  switch(v36)
                  {
                    case 100LL:
                      int v42 = *(unsigned __int8 *)v32;
                      LODWORD(v257) = 115;
                      if ((v42 | 0x20) != 0x73) {
                        goto LABEL_106;
                      }
                      break;
                    case 200LL:
                      int v43 = *(unsigned __int8 *)v32;
                      LODWORD(v257) = 105;
                      unsigned int v44 = v43 - 73;
                      if (v44 > 0x28) {
                        goto LABEL_106;
                      }
                      if (((1LL << v44) & 0x900000009LL) == 0)
                      {
                        if (((1LL << v44) & 0x10000000100LL) == 0) {
                          goto LABEL_106;
                        }
                        uint64_t v45 = (objc_class *)objc_opt_class();
                        v251 = class_getName(v45);
                        _NSCoreDataLog( 2LL,  (uint64_t)@"Property '%s' is a 64 bit scalar type on class '%s' that does not match its entity's property's 32 bit scalar type.  Implicit coercion to 32 bits in the database is not recommended.",  v46,  v47,  v48,  v49,  v50,  v51,  (uint64_t)v10);
                        LODWORD(v257) = 113;
                        v253 = 105;
                      }

                      break;
                    case 300LL:
                      uint64_t v38 = *(unsigned __int8 *)v32;
                      LODWORD(v257) = 113;
                      if ((v38 | 0x20) != 0x71) {
                        goto LABEL_106;
                      }
                      break;
                    default:
                      goto LABEL_106;
                  }
                }

                else if (v36 > 799)
                {
                  if (v36 == 900)
                  {
LABEL_41:
                    int v41 = *(unsigned __int8 *)v32;
                    LODWORD(v257) = 100;
                    if (v41 != 100) {
                      goto LABEL_106;
                    }
                    goto LABEL_49;
                  }

                  if (v36 != 800) {
                    goto LABEL_106;
                  }
                  uint64_t v39 = *(unsigned __int8 *)v32;
                  LODWORD(v257) = 66;
                  int v40 = v39 - 66;
                  if (v40 > 0x21 || ((1LL << v40) & 0x200000003LL) == 0) {
                    goto LABEL_106;
                  }
                }

                else
                {
                  if (v36 == 500) {
                    goto LABEL_41;
                  }
                  if (v36 != 600) {
                    goto LABEL_106;
                  }
                  uint64_t v37 = *(unsigned __int8 *)v32;
                  LODWORD(v257) = 102;
                  if (v37 != 102) {
                    goto LABEL_106;
                  }
                }
              }
            }

LABEL_393:
        uint64_t v55 = v320;
LABEL_394:
        if (v91 >= 0x201)
        {
          NSZoneFree(0LL, v315);
          NSZoneFree(0LL, v307);
        }

        if (v310 >= 0x201) {
          NSZoneFree(0LL, v317);
        }
        PF_FREE_OBJECT_ARRAY(v90);

        if (v55) {
        return 0LL;
        }
      default:
LABEL_210:
        if ((v333 & 1) == 0)
        {
          if (v136) {
            goto LABEL_218;
          }
          v195 = (const UInt8 *)(((unint64_t)v340 + v135) & v145);
          uint64_t v149 = (int *)(v195 + 4);
          v196 = *(int *)v195;
          if ((uint64_t)(v323 - (void)(v195 + 4)) < v196)
          {
            uint64_t v89 = v337;
            uint64_t v90 = v322;
            uint64_t v91 = v308;
            if (!a8) {
              goto LABEL_393;
            }
            v266 = (void *)MEMORY[0x189607870];
            v267 = *MEMORY[0x189607460];
            v268 = (void *)MEMORY[0x189603F68];
            v269 = [NSString stringWithFormat:@"CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (3))", *(void *)((char *)v336 + v339 + 24)];
            goto LABEL_391;
          }

          int v150 = v133;
          v197 = CFDataCreate(0LL, v195 + 4, v196);
          uint64_t v151 = (__CFString *)v197;
          uint64_t v152 = *(int *)v195;
          v198 = *((unsigned __int8 *)v150 + 20);
          if (v198 == 11)
          {
            v216 = -[__CFData length](v197, "length");
            id v154 = v312;
            if (v216 == 16)
            {
              v340 = (__CFString *)objc_alloc(MEMORY[0x189607AB8]);
              v217 = -[__CFString bytes](v151, "bytes");
              int v155 = -[__CFString initWithUUIDBytes:](v340, "initWithUUIDBytes:", v217);
              goto LABEL_279;
            }
          }

          else
          {
            id v154 = v312;
            if (v198 == 15)
            {
              int v155 = (__CFString *)+[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)v197,  (void *)[*(id *)((char *)v336 + v339 + 24) propertyDescription]);
LABEL_279:
              v340 = v155;
LABEL_280:
              CFRelease(v151);
              uint64_t v151 = v340;
            }
          }

LABEL_281:
          v340 = (__CFString *)((char *)v149 + v152);
          v218 = *((_DWORD *)v150 + 2);
          v219 = v154;
          v210 = (uint64_t)v151;
          goto LABEL_282;
        }

        if (v136)
        {
          uint64_t v177 = 0LL;
          v178 = v338;
          goto LABEL_298;
        }

        uint64_t v190 = (const UInt8 *)(((unint64_t)v340 + v135) & v145);
        char v191 = *(int *)v190;
        if ((uint64_t)(v323 - (void)(v190 + 4)) < v191)
        {
          uint64_t v89 = v337;
          uint64_t v90 = v322;
          uint64_t v91 = v308;
          if (!a8) {
            goto LABEL_393;
          }
          v266 = (void *)MEMORY[0x189607870];
          v267 = *MEMORY[0x189607460];
          v268 = (void *)MEMORY[0x189603F68];
          v269 = [NSString stringWithFormat:@"CoreData: XPC: Suspect response from server (remaining space for %@ insufficient (4))", *(void *)((char *)v336 + v339 + 24)];
          goto LABEL_391;
        }

        uint64_t v192 = v133;
        v331 = CFDataCreate(0LL, v190 + 4, v191);
        v340 = (__CFString *)&v190[*(int *)v190 + 4];
        if (v134 == 17 && [(id)v138 sqlType] != 10)
        {
          [*(id *)((char *)v336 + v339 + 24) propertyDescription];
          uint64_t v177 = v331;
          v227 = (const __CFData *)_swizzleManifestTypeDataXPC(v331, (void *)v138);
          v178 = v338;
        }

        else
        {
          v193 = *((unsigned __int8 *)v192 + 20);
          v178 = v338;
          if (v193 == 11)
          {
            uint64_t v177 = v331;
            if (-[__CFData length](v331, "length") != 16) {
              goto LABEL_298;
            }
            v194 = (const __CFData *)objc_msgSend( objc_alloc(MEMORY[0x189607AB8]),  "initWithUUIDBytes:",  -[__CFData bytes](v177, "bytes"));
          }

          else
          {
            uint64_t v177 = v331;
            if (v193 != 15) {
              goto LABEL_298;
            }
            v194 = (const __CFData *)+[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)v331,  (void *)[*(id *)((char *)v336 + v339 + 24) propertyDescription]);
          }

          v227 = v194;
        }

        CFRelease(v177);
        uint64_t v177 = v227;
LABEL_298:
        uint64_t v131 = 0LL;
        *(void *)&v332[8 * v178] = v177;
        goto LABEL_284;
    }
  }

void sub_1866C2FD0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x1866C2FACLL);
}

void sub_1866C2FDC(_Unwind_Exception *a1)
{
}

void sub_1866C3CF4(void *a1)
{
}

void sub_1866C3D08(_Unwind_Exception *a1)
{
}

void sub_1866C41B8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + *(int *)(v3 + 556)));
    objc_exception_rethrow();
    __break(1u);
    JUMPOUT(0x1866C41DCLL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1866C42B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_1866C448C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1866C4664(_Unwind_Exception *a1)
{
}

void sub_1866C48CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_56:
  if (+[NSXPCStore debugDefault](&OBJC_CLASS___NSXPCStore, "debugDefault"))
  {
    if (v35)
    {
      uint64_t v57 = -[_PFBatchFaultingArray count](v35, "count");
      _NSCoreDataLog(8LL, (uint64_t)@"Fetch retrieved %lu results from server", v58, v59, v60, v61, v62, v63, v57);
    }

    else
    {
      _NSCoreDataLog(8LL, (uint64_t)@"Fetch retrieved null, error %@", v51, v52, v53, v54, v55, v56, (uint64_t)v109);
    }
  }

  char v64 = v109;
  [v103 drain];
  int v65 = v109;
  int v66 = 0LL;

  if (v104)
  {
    if (v109) {
      __CFString *v104 = v109;
    }
  }

  int v67 = v35;
}

      if (v44 == ++v46)
      {
        unsigned int v44 = [a3 countByEnumeratingWithState:&v61 objects:v73 count:16];
        if (!v44) {
          goto LABEL_58;
        }
        goto LABEL_48;
      }
    }

    uint32_t v48 = +[NSPersistentHistoryResult _transactionFromResult:withChanges:]( (uint64_t)&OBJC_CLASS___NSPersistentHistoryResult,  v47,  0LL);
LABEL_55:
    uint64_t v49 = v48;
    [v32 addObject:v48];

    goto LABEL_56;
  }

  uint64_t v51 = v8;
  uint64_t v56 = (id)[MEMORY[0x189603FE0] set];
  uint64_t v54 = (void *)[MEMORY[0x189603FE0] set];
  uint64_t v53 = (void *)[MEMORY[0x189603FE0] set];
  int v69 = 0u;
  uint64_t v70 = 0u;
  int v71 = 0u;
  int v72 = 0u;
  uint64_t v9 = [a3 countByEnumeratingWithState:&v69 objects:v77 count:16];
  if (!v9) {
    goto LABEL_20;
  }
  uint64_t v10 = v9;
  unint64_t v59 = *(void *)v70;
  do
  {
    for (uint64_t j = 0LL; j != v10; ++j)
    {
      if (*(void *)v70 != v59) {
        objc_enumerationMutation(a3);
      }
      uint64_t v12 = *(void **)(*((void *)&v69 + 1) + 8 * j);
      id v13 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v14 = (void *)objc_msgSend( a5,  "newObjectIDForEntity:pk:",  objc_msgSend( (id)objc_msgSend(a5, "model"),  "entityForID:",  (int)objc_msgSend((id)objc_msgSend(v12, "objectForKey:", @"ENTITY"), "intValue")),  (int)objc_msgSend((id)objc_msgSend(v12, "objectForKey:", @"ENTITYPK"), "intValue"));
      unsigned int v15 = objc_msgSend((id)objc_msgSend(v12, "objectForKey:", @"CHANGETYPE"), "unsignedIntegerValue");
      switch(v15)
      {
        case 2LL:
          uint64_t v22 = v53;
          goto LABEL_16;
        case 1LL:
          uint64_t v22 = v54;
          goto LABEL_16;
        case 0LL:
          uint64_t v22 = v56;
LABEL_16:
          [v22 addObject:v14];
          goto LABEL_18;
      }

      _NSCoreDataLog(1LL, (uint64_t)@"error: unexpected type of change : %lu", v16, v17, v18, v19, v20, v21, v15);
LABEL_18:

      objc_autoreleasePoolPop(v13);
    }

    uint64_t v10 = [a3 countByEnumeratingWithState:&v69 objects:v77 count:16];
  }

  while (v10);
LABEL_20:
  [v56 minusSet:v53];
  [v54 minusSet:v53];
  [v54 minusSet:v56];
  uint64_t v23 = (void *)[v56 copy];
  id v24 = (void *)[v54 copy];
  uint64_t v25 = (void *)[v53 copy];
  v75[0] = @"inserted_objectIDs";
  v75[1] = @"updated_objectIDs";
  v76[0] = v23;
  v76[1] = v24;
  v75[2] = @"deleted_objectIDs";
  v76[2] = v25;
  a3 = (id)[MEMORY[0x189603F68] dictionaryWithObjects:v76 forKeys:v75 count:3];

  id v8 = v51;
LABEL_23:
  uint64_t v27 = -[NSPersistentHistoryResult initWithResultType:andResult:]( [NSPersistentHistoryResult alloc],  "initWithResultType:andResult:",  [a4 resultType],  a3);
  objc_autoreleasePoolPop(v8);
  return v27;
}

        uint64_t v45 = (void *)MEMORY[0x189607870];
        uint64_t v46 = *MEMORY[0x189607460];
        uint64_t v47 = (void *)MEMORY[0x189603F68];
        uint32_t v48 = (void *)NSString;
        goto LABEL_57;
      }

      uint64_t v51 = (void *)MEMORY[0x189607870];
      uint64_t v52 = *MEMORY[0x189607460];
      uint64_t v53 = (void *)MEMORY[0x189603F68];
      uint64_t v54 = objc_msgSend( NSString,  "stringWithFormat:",  @"No permissions to create file; code = %d",
              1LL);
    }

    uint64_t v55 = [v53 dictionaryWithObject:v54 forKey:@"reason"];
    uint64_t v56 = v51;
    uint64_t v57 = v52;
    unint64_t v58 = 513LL;
LABEL_59:
    *a6 = (id)[v56 errorWithDomain:v57 code:v58 userInfo:v55];
    goto LABEL_60;
  }

  if (!v17)
  {
    if (!v15)
    {
      uint64_t v32 = 1;
      if (access(v13, 2))
      {
        *a5 = 1;
        +[_PFRoutines _logFileAccessDebugInformation:]((uint64_t)&OBJC_CLASS____PFRoutines, v13);
      }

      return v32;
    }

    return 1;
  }

  uint64_t v32 = 1;
  if (access(v13, 2))
  {
    id v33 = *__error();
    *a5 = 1;
    if (a6)
    {
      unint64_t v34 = (void *)MEMORY[0x189607870];
      uint64_t v35 = *MEMORY[0x189607460];
      uint64_t v28 = [MEMORY[0x189603F68] dictionaryWithObject:objc_msgSend(NSString, "stringWithFormat:", @"No write permissions to file: %d", v33), @"reason" forKey];
      uint64_t v29 = v34;
      uint64_t v30 = v35;
      uint64_t v31 = 513LL;
      goto LABEL_37;
    }

  if ((v50 & 1) == 0)
  {
    if (v90[0])
    {
      *(id *)(v73 + 40) = v90[0];
    }

    else
    {
      char v64 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v64,  v65,  v66,  v67,  v68,  v69,  v70,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitExporter.m");
      int v71 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        uint64_t v92 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitExporter.m";
        uint64_t v93 = 1024;
        id v94 = 871;
        _os_log_fault_impl( &dword_186681000,  v71,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }

    goto LABEL_31;
  }

  id result = [*(id *)(a1 + 72) save:*(void *)(*(void *)(a1 + 88) + 8) + 40];
  if ((result & 1) == 0)
  {
    uint64_t v27 = (void *)MEMORY[0x186E3E5D8]();
    uint64_t v56 = __ckLoggingOverride;
    uint64_t v57 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to save record name updates: %@"];
    _NSCoreDataLog( v56 != 0,  v57,  v58,  v59,  v60,  v61,  v62,  v63,  (uint64_t)"-[PFCloudKitExporter exportOperationFinished:withSavedRecords:deletedRecordIDs:operationError:]_block_invoke_2");
    goto LABEL_30;
  }

  return result;
}

      uint32_t v48 = [v45 unsignedIntValue];
      if (v45 && v48)
      {
        if (v38) {
          uint64_t v49 = v38 < v48;
        }
        else {
          uint64_t v49 = 1;
        }
        id v50 = v49;
        uint64_t v51 = (v39 & 1) == 0;
        if ((v39 & 1) != 0) {
          uint64_t v39 = v50;
        }
        else {
          uint64_t v39 = 0;
        }
        if (!v51) {
          uint64_t v38 = v48;
        }
        *(_DWORD *)(*(void *)(a1 + 32) + 4 * v37) = v48;
      }

      else
      {
        v39 &= v45 == 0LL;
        ++v94;
        if (v38) {
          ++v38;
        }
        else {
          uint64_t v38 = 0LL;
        }
      }

      int v40 = v95;
    }
  }

  id v94 = 0;
  uint64_t v39 = 1;
  int v40 = v95;
LABEL_76:
  if (v91) {
    CFRelease(v91);
  }
  uint64_t v52 = *(void **)(a1 + 48);
  uint64_t v53 = v90;
  if (v52)
  {

    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  }

  if (v94 == (_DWORD)v10) {
    uint64_t v54 = 1;
  }
  else {
    uint64_t v54 = v39;
  }
  if ((v54 & 1) == 0)
  {
    uint64_t v55 = 0LL;
    uint64_t v56 = 0LL;
    uint64_t v57 = ~v94 + v10;
    unint64_t v58 = 2;
    unint64_t v59 = 1;
    while (1)
    {
      uint64_t v60 = v59;
      uint64_t v61 = ((uint64_t (*)(void, size_t, uint64_t, uint64_t))preserveOrderKeyFuncs[v55])( *(void *)(a1 + 32),  v10,  v56,  1LL);
      if (v61 == v57) {
        break;
      }
      unint64_t v59 = 0;
      uint64_t v62 = v61 <= (int)v56;
      else {
        uint64_t v56 = v61;
      }
      if (!v62) {
        unint64_t v58 = v55;
      }
      uint64_t v55 = 1LL;
      if ((v60 & 1) == 0) {
        goto LABEL_94;
      }
    }

    unint64_t v58 = v55;
LABEL_94:
    if (v58 <= 1) {
      uint64_t v63 = v58;
    }
    else {
      uint64_t v63 = 0;
    }
    ((void (*)(void, size_t, uint64_t, void))preserveOrderKeyFuncs[v63])( *(void *)(a1 + 32),  v10,  v56,  0LL);
    uint64_t v53 = v90;
    int v40 = v95;
  }

  char v64 = v92;
  if (!(_DWORD)v10)
  {
LABEL_129:
    int v73 = v87;
    if (v64 && (_DWORD)v10) {
      goto LABEL_160;
    }
    return;
  }

  int v65 = 0LL;
  int v66 = 0LL;
  int v67 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    unsigned int v68 = *(void *)(a1 + 32);
    int v69 = *(unsigned int *)(v68 + 4 * v65);
    if (v67 == 0x7FFFFFFFFFFFFFFFLL)
    {
      if ((_DWORD)v69) {
        int v67 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        int v67 = v65;
      }
    }

    else
    {
      if (!(_DWORD)v69) {
        goto LABEL_126;
      }
      if (v67)
      {
        int v66 = *(unsigned int *)(v68 + 4 * (v67 - 1));
        uint64_t v70 = (uint64_t)(v69 - v66) / (v65 - (v67 - 1));
        int v71 = v70 + v66;
        if (!v70) {
          goto LABEL_117;
        }
      }

      else
      {
        if (v65 >= v69 >> 10) {
          uint64_t v70 = v69 / ((int)v65 + 1);
        }
        else {
          uint64_t v70 = 1024LL;
        }
        int v71 = v69 - v70 * v65;
        if (!v70)
        {
LABEL_117:
          *(_DWORD *)(v68 + 4 * v65) = 0;
          goto LABEL_126;
        }
      }

      if (v67 && v70 == 1 && v69 - v66 == v65 - v67 + 1) {
        goto LABEL_117;
      }
      if (v67 < v65)
      {
        do
        {
          if (v71 <= 1) {
            int v72 = 1LL;
          }
          else {
            int v72 = v71;
          }
          *(_DWORD *)(*(void *)(a1 + 32) + 4 * v67) = v72;
          if (v64) {
            v53[v67] = 1;
          }
          int v71 = v72 + v70;
          ++v67;
        }

        while (v65 != v67);
      }

      int v67 = 0x7FFFFFFFFFFFFFFFLL;
    }

        if (++v15 == v16) {
          return;
        }
      }

      if ((void *)v51 == v27 || ![v27 count])
      {
        uint64_t v28 = objc_alloc_init(MEMORY[0x189603FE0]);
        if ((void *)v51 != v26 && [v26 count])
        {
          uint64_t v30 = [v26 count];
          uint64_t v31 = MEMORY[0x1895F8858](v30);
          unint64_t v34 = (char *)&v47 - v33;
          if (v31 > 0x200) {
            unint64_t v34 = (char *)NSAllocateScannedUncollectable();
          }
          else {
            bzero((char *)&v47 - v33, 8 * v32);
          }
          [v26 getObjects:v34];
          unint64_t v36 = (void *)[objc_alloc(MEMORY[0x189603FE0]) initWithObjects:v34 count:v30];
          if (v30 >= 0x201) {
            NSZoneFree(0LL, v34);
          }
          goto LABEL_39;
        }

        uint64_t v35 = (objc_class *)MEMORY[0x189603FE0];
      }

      else
      {
        if ((void *)v51 != v26 && [v26 count])
        {
          uint64_t v28 = +[_PFRoutines newMutableSetFromCollection:byIntersectingWithCollection:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v26,  v27);
          uint64_t v29 = +[_PFRoutines newMutableSetFromCollection:byRemovingItems:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v26,  v27);
LABEL_35:
          unint64_t v36 = v29;
LABEL_39:
          uint64_t v37 = objc_alloc_init(MEMORY[0x189603FA8]);
          unint64_t v59 = 0u;
          uint64_t v60 = 0u;
          uint64_t v61 = 0u;
          uint64_t v62 = 0u;
          uint64_t v38 = [v28 countByEnumeratingWithState:&v59 objects:v64 count:16];
          if (v38)
          {
            uint64_t v39 = v38;
            int v40 = *(void *)v60;
            do
            {
              for (uint64_t i = 0LL; i != v39; ++i)
              {
                if (*(void *)v60 != v40) {
                  objc_enumerationMutation(v28);
                }
                objc_msgSend(v37, "addObject:", objc_msgSend(*(id *)(*((void *)&v59 + 1) + 8 * i), "objectID"));
              }

              uint64_t v39 = [v28 countByEnumeratingWithState:&v59 objects:v64 count:16];
            }

            while (v39);
          }

          uint64_t v57 = 0u;
          unint64_t v58 = 0u;
          uint64_t v55 = 0u;
          uint64_t v56 = 0u;
          int v42 = [v36 countByEnumeratingWithState:&v55 objects:v63 count:16];
          if (v42)
          {
            int v43 = v42;
            unsigned int v44 = *(void *)v56;
            do
            {
              for (uint64_t j = 0LL; j != v43; ++j)
              {
                if (*(void *)v56 != v44) {
                  objc_enumerationMutation(v36);
                }
                objc_msgSend(v37, "addObject:", objc_msgSend(*(id *)(*((void *)&v55 + 1) + 8 * j), "objectID"));
              }

              int v43 = [v36 countByEnumeratingWithState:&v55 objects:v63 count:16];
            }

            while (v43);
          }

          if ([v37 count])
          {
            uint64_t v46 = -[NSSQLSavePlan _correlationTableUpdateTrackerForRelationship:](v50, v24);
            -[NSSQLCorrelationTableUpdateTracker trackInserts:deletes:reorders:forObjectWithID:]( (uint64_t)v46,  0LL,  v37,  0LL,  v49);
          }

          int v5 = v47;
          uint64_t v2 = v48;
          uint64_t v17 = &OBJC_IVAR____NSPersistentHistoryToken__storeTokens;
          goto LABEL_56;
        }

        uint64_t v28 = objc_alloc_init(MEMORY[0x189603FE0]);
        uint64_t v35 = (objc_class *)MEMORY[0x189603FE0];
      }

      uint64_t v29 = objc_alloc_init(v35);
      goto LABEL_35;
    }
  }

void sub_1866C596C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866C5928LL);
  }

  JUMPOUT(0x1866C58ECLL);
}

LABEL_133:
            uint64_t v46 = 0LL;
LABEL_136:
            uint64_t v14 = v46;
            goto LABEL_137;
          }

          int v148 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
          _NSCoreDataLog( 17LL,  v148,  v149,  v150,  v151,  v152,  v153,  v154,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m");
          unint64_t v121 = (os_log_s *)__pflogFaultLog;
          if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
            goto LABEL_133;
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m";
          v221 = 1024;
          v222 = 1468;
        }

        else
        {
          uint64_t v113 = (void *)v223;
          if ((void)v223) {
            goto LABEL_101;
          }
          uint64_t v114 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
          _NSCoreDataLog( 17LL,  v114,  v115,  v116,  v117,  v118,  v119,  v120,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m");
          unint64_t v121 = (os_log_s *)__pflogFaultLog;
          if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
            goto LABEL_133;
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m";
          v221 = 1024;
          v222 = 1473;
        }

        _os_log_fault_impl( &dword_186681000,  v121,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
        goto LABEL_133;
      case 6LL:
        if (!self) {
          goto LABEL_139;
        }
        *(void *)&v223 = 0LL;
        [a3 _resolveEntityWithContext:a4];
        int v73 = (void *)[a3 encodeForXPC];
        if (!v73)
        {
          uint64_t v91 = (void *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:&unk_189F022F8];
          if (v91) {
            goto LABEL_95;
          }
          uint64_t v106 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
          _NSCoreDataLog( 17LL,  v106,  v107,  v108,  v109,  v110,  v111,  v112,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m");
          uint64_t v99 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315394;
            *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m";
            v221 = 1024;
            v222 = 1486;
            goto LABEL_125;
          }

          goto LABEL_139;
        }

        int v74 = objc_alloc_init(&OBJC_CLASS___NSCoreDataXPCMessage);
        int v76 = v74;
        if (v74)
        {
          v74->_messageCode = 15LL;
          objc_setProperty_nonatomic(v74, v75, v73, 24LL);
        }

        uint64_t v77 = -[NSXPCStore sendMessage:fromContext:interrupts:error:]((uint64_t *)self, v76, a4, &v230, &v223);
        if (v77)
        {
          uint64_t v78 = (void *)MEMORY[0x189604010];
          uint64_t v79 = objc_opt_class();
          uint64_t v80 = objc_opt_class();
          uint64_t v81 = objc_opt_class();
          uint64_t v82 = objc_msgSend(v78, "setWithObjects:", v79, v80, v81, objc_opt_class(), 0);
          uint64_t v83 = +[_NSXPCStoreUtilities decodeSecureArchivedData:usingDelegate:classes:]( (uint64_t)&OBJC_CLASS____NSXPCStoreUtilities,  (uint64_t)v77,  (uint64_t)self,  v82);
          if (v83)
          {
            uint64_t v46 = -[NSBatchUpdateResult initWithResultType:andObject:]( [NSBatchUpdateResult alloc],  "initWithResultType:andObject:",  [a3 resultType],  v83);
            goto LABEL_136;
          }

          uint64_t v126 = (void *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:&unk_189F02320];
          *(void *)&v223 = v126;
          if (v126)
          {
LABEL_121:
            if (a5)
            {
              uint64_t v46 = 0LL;
              *a5 = v126;
              goto LABEL_136;
            }

            goto LABEL_135;
          }

          int v155 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
          _NSCoreDataLog( 17LL,  v155,  v156,  v157,  v158,  v159,  v160,  v161,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m");
          uint64_t v134 = (os_log_s *)__pflogFaultLog;
          if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
LABEL_135:
            uint64_t v46 = 0LL;
            goto LABEL_136;
          }

          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m";
          v221 = 1024;
          v222 = 1505;
        }

        else
        {
          uint64_t v126 = (void *)v223;
          if ((void)v223) {
            goto LABEL_121;
          }
          char v127 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
          _NSCoreDataLog( 17LL,  v127,  v128,  v129,  v130,  v131,  v132,  v133,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m");
          uint64_t v134 = (os_log_s *)__pflogFaultLog;
          if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
            goto LABEL_135;
          }
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m";
          v221 = 1024;
          v222 = 1510;
        }

        _os_log_fault_impl( &dword_186681000,  v134,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
        goto LABEL_135;
      case 7LL:
        if (!self) {
          goto LABEL_139;
        }
        objc_msgSend((id)objc_msgSend(a3, "fetchRequest"), "_resolveEntityWithContext:", a4);
        unint64_t v34 = (void *)[a3 encodeForXPC];
        uint64_t v35 = objc_alloc_init(&OBJC_CLASS___NSCoreDataXPCMessage);
        uint64_t v37 = v35;
        if (v35)
        {
          v35->_messageCode = 12LL;
          objc_setProperty_nonatomic(v35, v36, v34, 24LL);
        }

        *(void *)buf = 0LL;
        uint64_t v38 = -[NSXPCStore sendMessage:fromContext:interrupts:error:]((uint64_t *)self, v37, a4, &v223, buf);

        if (v38)
        {
          uint64_t v39 = (void *)MEMORY[0x189604010];
          int v40 = objc_opt_class();
          int v41 = objc_opt_class();
          int v42 = objc_opt_class();
          int v43 = objc_msgSend(v39, "setWithObjects:", v40, v41, v42, objc_opt_class(), 0);
          unsigned int v44 = +[_NSXPCStoreUtilities decodeSecureArchivedData:usingDelegate:classes:]( (uint64_t)&OBJC_CLASS____NSXPCStoreUtilities,  (uint64_t)v38,  (uint64_t)self,  v43);
          uint64_t v45 = v44;
          if (a5 && !v44) {
            *a5 = (id)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:&unk_189F02348];
          }
          uint64_t v46 = -[NSBatchDeleteResult initWithResultType:andObject:]( [NSBatchDeleteResult alloc],  "initWithResultType:andObject:",  [a3 resultType],  v45);
        }

        else
        {
          uint64_t v46 = 0LL;
          if (a5) {
            *a5 = *(id *)buf;
          }
        }

        goto LABEL_136;
      case 8LL:
        goto LABEL_15;
      case 10LL:
        if (!a5) {
          goto LABEL_139;
        }
        id v33 = (id)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134091 userInfo:&unk_189F023C0];
        goto LABEL_39;
      default:
        if (!a5) {
          goto LABEL_139;
        }
        uint64_t v31 = (void *)MEMORY[0x189607870];
        uint64_t v32 = [MEMORY[0x189603F68] dictionaryWithObject:@"Invalid request type" forKey:@"Reason"];
        id v33 = (id)[v31 errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:v32];
LABEL_39:
        id v13 = 0LL;
        *a5 = v33;
        goto LABEL_140;
    }
  }

  do
    uint64_t v12 = __ldxr((unsigned int *)p_outstandingRequests);
  while (__stxr(v12 - 1, (unsigned int *)p_outstandingRequests));
  if (v9 != 8)
  {
    if (v9 == 1) {
      return (id)NSArray_EmptyArray;
    }
    goto LABEL_11;
  }

  if ([a3 isDelete])
  {
LABEL_11:
    id v13 = 0LL;
    if (a5) {
      *a5 = (id)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134098 userInfo:0];
    }
    return v13;
  }

  unsigned int v15 = objc_alloc(&OBJC_CLASS___NSPersistentHistoryResult);
  uint64_t v16 = [a3 resultType];
  -[NSPersistentHistoryResult initWithResultType:andResult:]( v15,  "initWithResultType:andResult:",  v16,  MEMORY[0x189604A58]);
LABEL_15:
  if (!self) {
    goto LABEL_139;
  }
  v217 = 0LL;
  if (!-[NSDictionary valueForKey:]( -[NSPersistentStore options](self, "options"),  "valueForKey:",  @"NSPersistentHistoryTrackingKey"))
  {
    int v84 = -[NSPersistentStore identifier](self, "identifier");
    -[NSPersistentStore URL](self, "URL");
    _NSCoreDataLog( 1LL,  (uint64_t)@"History Change Request failed as no history tracking option detected on store %@ at %@",  v85,  v86,  v87,  v88,  v89,  v90,  (uint64_t)v84);
    uint64_t v91 = (void *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134091 userInfo:&unk_189F02370];
    v217 = v91;
    if (v91) {
      goto LABEL_95;
    }
    uint64_t v92 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v92,  v93,  v94,  v95,  v96,  v97,  v98,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m");
    uint64_t v99 = (os_log_s *)__pflogFaultLog;
    if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
LABEL_139:
      id v13 = 0LL;
      goto LABEL_140;
    }

    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m";
    v221 = 1024;
    v222 = 1557;
    goto LABEL_125;
  }

  if ([a3 token]
    && !objc_msgSend( (id)objc_msgSend((id)objc_msgSend(a3, "token"), "storeTokens"),  "objectForKey:",  -[NSPersistentStore identifier](self, "identifier")))
  {
    uint64_t v122 = (void *)MEMORY[0x189607870];
    v230 = @"Reason";
    unint64_t v123 = (void *)NSString;
    char v124 = [a3 token];
    v227 = -[NSPersistentStore identifier](self, "identifier");
    *(void *)&v223 = [v123 stringWithFormat:@"Unable to find stores referenced in History Token (%@) - %@", v124, objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v227, 1)];
    int v125 = [MEMORY[0x189603F68] dictionaryWithObjects:&v223 forKeys:&v230 count:1];
    uint64_t v91 = (void *)[v122 errorWithDomain:*MEMORY[0x189607460] code:134501 userInfo:v125];
    v217 = v91;
    if (v91)
    {
LABEL_95:
      if (a5)
      {
        id v13 = 0LL;
        *a5 = v91;
        goto LABEL_140;
      }

      goto LABEL_139;
    }

    char v141 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v141,  v142,  v143,  v144,  v145,  v146,  v147,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m");
    uint64_t v99 = (os_log_s *)__pflogFaultLog;
    if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
      goto LABEL_139;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/XPCStore/NSXPCStore.m";
    v221 = 1024;
    v222 = 1564;
LABEL_125:
    _os_log_fault_impl( &dword_186681000,  v99,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    goto LABEL_139;
  }

  if ([a3 isDelete])
  {
    uint64_t v17 = (void *)[a3 encodeForXPC];
    id v18 = objc_alloc_init(&OBJC_CLASS___NSCoreDataXPCMessage);
    uint64_t v20 = v18;
    if (v18)
    {
      v18->_messageCode = 13LL;
      objc_setProperty_nonatomic(v18, v19, v17, 24LL);
    }

    uint64_t v21 = -[NSXPCStore sendMessage:fromContext:interrupts:error:]((uint64_t *)self, v20, a4, buf, &v217);
    if (v21)
    {
      v214 = (void *)MEMORY[0x189604010];
      v212 = objc_opt_class();
      v211 = objc_opt_class();
      v210 = objc_opt_class();
      v209 = objc_opt_class();
      uint64_t v22 = objc_opt_class();
      uint64_t v23 = objc_opt_class();
      id v24 = objc_opt_class();
      uint64_t v25 = objc_opt_class();
      uint64_t v26 = objc_opt_class();
      uint64_t v27 = objc_msgSend( v214,  "setWithObjects:",  v212,  v211,  v210,  v209,  v22,  v23,  v24,  v25,  v26,  objc_opt_class(),  0);
      uint64_t v28 = +[_NSXPCStoreUtilities decodeSecureArchivedData:usingDelegate:classes:]( (uint64_t)&OBJC_CLASS____NSXPCStoreUtilities,  (uint64_t)v21,  (uint64_t)self,  v27);
      uint64_t v29 = v28;
      if (a5 && !v28) {
        *a5 = (id)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:&unk_189F02398];
      }
      uint64_t v30 = -[NSPersistentHistoryResult initWithResultType:andResult:]( [NSPersistentHistoryResult alloc],  "initWithResultType:andResult:",  [a3 resultType],  v29);
    }

    else
    {
      uint64_t v30 = 0LL;
      if (a5) {
        *a5 = v217;
      }
    }

    uint64_t v14 = v30;
LABEL_137:
    id v13 = v14;
    goto LABEL_140;
  }

  v216 = (NSManagedObjectContext *)a4;
  if (!a4)
  {
    v216 = -[NSManagedObjectContext initWithConcurrencyType:]( objc_alloc(&OBJC_CLASS___NSManagedObjectContext),  "initWithConcurrencyType:",  1LL);
    -[NSManagedObjectContext setPersistentStoreCoordinator:]( v216,  "setPersistentStoreCoordinator:",  -[NSPersistentStore persistentStoreCoordinator](self, "persistentStoreCoordinator"));
  }

  -[NSManagedObjectContext _setAllowAncillaryEntities:](v216, "_setAllowAncillaryEntities:", 1LL);
  if ([a3 token])
  {
    uint64_t v100 = -[NSPersistentHistoryChangeRequest fetchRequestDescribingTokenCheckForStore:]((NSFetchRequest *)a3, self);
    if (v100)
    {
      -[NSXPCStore executeFetchRequest:withContext:error:]((uint64_t *)self, (uint64_t)v100, v216, &v217);
      unint64_t v102 = v101;
      if ([v101 count] && (objc_msgSend((id)objc_msgSend(v102, "firstObject"), "BOOLValue") & 1) == 0)
      {
        unint64_t v103 = (__CFString *)[NSString stringWithFormat:@"Persistent History Token is expired for store at %@", -[NSURL path](-[NSPersistentStore URL](self, "URL"), "path")];
        unint64_t v104 = (void *)MEMORY[0x189607870];
        v230 = v103;
        v227 = (NSString *)@"message";
        v228 = @"NSStoreUUID";
        v231 = -[NSPersistentStore identifier](self, "identifier");
        v229 = *MEMORY[0x1896074F8];
        v232 = -[NSURL path](-[NSPersistentStore URL](self, "URL"), "path");
        __int16 v105 = [MEMORY[0x189603F68] dictionaryWithObjects:&v230 forKeys:&v227 count:3];
        v217 = (void *)[v104 errorWithDomain:*MEMORY[0x189607460] code:134301 userInfo:v105];
      }

      if (v217)
      {
        if (a5) {
          *a5 = v217;
        }
        if (a4)
        {
LABEL_84:
          -[NSManagedObjectContext _setAllowAncillaryEntities:](v216, "_setAllowAncillaryEntities:", 0LL);
          goto LABEL_139;
        }

          if ([a3 objectForKey:@"NSUnderlyingException"]) {
            goto LABEL_137;
          }
          int v69 = (void *)MEMORY[0x189603F70];
          int v84 = v10;
          int v71 = *MEMORY[0x189603A60];
          int v72 = [NSString stringWithFormat:@"Can't generate new column value from expression %@", v84];
LABEL_135:
          int v67 = [v69 exceptionWithName:v71 reason:v72 userInfo:0];
          unsigned int v68 = a3;
LABEL_136:
          [v68 setObject:v67 forKey:@"NSUnderlyingException"];
          goto LABEL_137;
        }

        if (v25 != v28)
        {
          uint64_t v79 = (void *)MEMORY[0x189603F70];
          uint64_t v80 = *MEMORY[0x189603A60];
          uint64_t v81 = [NSString stringWithFormat:@"Attempting to insert a relationship value into an attribute or vice versa is not supported %@/%@", objc_msgSend(v14, "name"), objc_msgSend(v27, "name")];
          goto LABEL_128;
        }

        if (objc_msgSend((id)objc_msgSend(v14, "propertyDescription"), "_propertyType") != 4)
        {
          uint64_t v17 = (NSSQLConstantValueIntermediate *)[objc_alloc(MEMORY[0x189607940]) initWithFormat:@"%@ = %@", objc_msgSend(v14, "columnName"), objc_msgSend(v27, "columnName")];
LABEL_68:
          uint64_t v10 = v97;
LABEL_85:
          self = v98;
          if (!v17) {
            goto LABEL_129;
          }
          goto LABEL_96;
        }

        if (v14[9])
        {
          if (!v27 || !v27[9]) {
            goto LABEL_124;
          }
        }

        else if (v27 && v27[9])
        {
LABEL_124:
          uint64_t v79 = (void *)MEMORY[0x189603F70];
          uint64_t v80 = *MEMORY[0x189603A60];
          uint64_t v81 = [NSString stringWithFormat:@"Can't generate new column values for destination - incompatible entity foreign key state: %@", v14, v89];
          goto LABEL_128;
        }

        if ((objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v14, "destinationEntity"), "entityDescription"),  "_subentitiesIncludes:",  objc_msgSend((id)objc_msgSend(v27, "destinationEntity"), "entityDescription")) & 1) == 0) {
          goto LABEL_124;
        }
        uint64_t v17 = (NSSQLConstantValueIntermediate *)[objc_alloc(MEMORY[0x189607940]) initWithFormat:@"%@ = %@", objc_msgSend(v14, "columnName"), objc_msgSend(v27, "columnName")];
        uint64_t v51 = objc_msgSend((id)objc_msgSend(v14, "destinationEntity"), "entityDescription");
        uint64_t v52 = v51;
        if (v51)
        {
          uint64_t v10 = v97;
          if (![*(id *)(v51 + 144) count])
          {
            if ((*(_BYTE *)(v52 + 120) & 4) != 0)
            {
              uint64_t v54 = *(void **)(v52 + 72);
            }

            else
            {
              uint64_t v53 = (void *)v52;
              do
              {
                uint64_t v54 = v53;
                uint64_t v53 = (void *)[v53 superentity];
              }

              while (v53);
            }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)
    && [*(id *)(*(void *)(a1 + 32) + 16) hasChanges]
    && ([*(id *)(*(void *)(a1 + 32) + 16) save:*(void *)(*(void *)(a1 + 48) + 8) + 40] & 1) == 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
    uint64_t v114 = *(id *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  }

  [*(id *)(*(void *)(a1 + 32) + 16) reset];
  objc_autoreleasePoolPop(v96);
  int v87 = *(void *)(a1 + 40);
  if (!*(_BYTE *)(*(void *)(v87 + 8) + 24LL)) {
    goto LABEL_168;
  }
LABEL_138:
  uint64_t v115 = *(void *)(a1 + 32);
  int v116 = *(void *)(v115 + 24);
  if (v116)
  {
    if (*(_BYTE *)(v116 + 40))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = -[PFCloudKitMetadataModelMigrator checkForOrphanedMirroredRelationshipsInStore:inManagedObjectContext:error:]( v115,  *(void **)(v115 + 8),  *(void **)(v115 + 16),  &v172);
      if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
      {
        *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) = v172;
        int v87 = *(void *)(a1 + 40);
        if (!*(_BYTE *)(*(void *)(v87 + 8) + 24LL)) {
          goto LABEL_168;
        }
      }
    }
  }

  if (v148)
  {
    if (!-[PFCloudKitMetadataModelMigrator checkForCorruptedRecordMetadataInStore:inManagedObjectContext:error:]( *(void *)(a1 + 32),  *(void *)(*(void *)(a1 + 32) + 8LL),  *(void **)(*(void *)(a1 + 32) + 16LL),  &v172))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
      int v117 = v172;
LABEL_147:
      int v120 = !v148;
      unint64_t v121 = a1;
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) = v117;
      goto LABEL_152;
    }

LABEL_208:
    unsigned int v188 = (uint64_t)v177;
    goto LABEL_211;
  }

  if (([a3 resultType] == 1 || objc_msgSend(a3, "resultType") == 4)
    && objc_msgSend((id)objc_msgSend(a3, "entityNameToFetch"), "isEqualToString:", @"TRANSACTION"))
  {
    v178 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(v177, "count"));
    v225 = 0u;
    v226 = 0u;
    v223 = 0u;
    v224 = 0u;
    uint64_t v179 = [v177 countByEnumeratingWithState:&v223 objects:buf count:16];
    if (v179)
    {
      int v180 = *(void *)v224;
      do
      {
        for (uint64_t k = 0LL; k != v179; ++k)
        {
          if (*(void *)v224 != v180) {
            objc_enumerationMutation(v177);
          }
          objc_msgSend( v178,  "addObject:",  objc_msgSend(*(id *)(*((void *)&v223 + 1) + 8 * k), "objectForKey:", @"self"));
        }

        uint64_t v179 = [v177 countByEnumeratingWithState:&v223 objects:buf count:16];
      }

      while (v179);
    }

    if ([v178 count])
    {
      int v182 = -[NSPersistentHistoryChangeRequest initWithTransactionIDs:]( objc_alloc(&OBJC_CLASS___NSPersistentHistoryChangeRequest),  "initWithTransactionIDs:",  v178);
      int v183 = -[NSPersistentHistoryChangeRequest fetchRequestDescribingChangeRequestForStore:](v182, self);
      -[NSFetchRequest setResultType:](v183, "setResultType:", 2LL);
      -[NSXPCStore executeFetchRequest:withContext:error:]((uint64_t *)self, (uint64_t)v183, v216, &v217);
      id v185 = v184;
      int v186 = v217;

      if (v185) {
        int v187 = v186 == 0LL;
      }
      else {
        int v187 = 0;
      }
      if (v187) {
        unsigned int v188 = v185;
      }
      else {
        unsigned int v188 = 0LL;
      }

      goto LABEL_211;
    }

    goto LABEL_195;
  }

  if ([a3 resultType] != 3 && objc_msgSend(a3, "resultType") != 5
    || !objc_msgSend((id)objc_msgSend(a3, "entityNameToFetch"), "isEqualToString:", @"CHANGE"))
  {
    goto LABEL_208;
  }

  unsigned __int8 v189 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(v177, "count"));
  v225 = 0u;
  v226 = 0u;
  v223 = 0u;
  v224 = 0u;
  uint64_t v190 = [v177 countByEnumeratingWithState:&v223 objects:buf count:16];
  if (v190)
  {
    char v191 = *(void *)v224;
    do
    {
      for (m = 0LL; m != v190; ++m)
      {
        if (*(void *)v224 != v191) {
          objc_enumerationMutation(v177);
        }
        objc_msgSend( v189,  "addObject:",  objc_msgSend(*(id *)(*((void *)&v223 + 1) + 8 * m), "objectForKey:", @"TRANSACTIONID"));
      }

      uint64_t v190 = [v177 countByEnumeratingWithState:&v223 objects:buf count:16];
    }

    while (v190);
  }

  if ([v189 count])
  {
    v193 = -[NSPersistentHistoryChangeRequest initWithTransactionIDs:]( objc_alloc(&OBJC_CLASS___NSPersistentHistoryChangeRequest),  "initWithTransactionIDs:",  v189);
    -[NSPersistentHistoryChangeRequest setResultType:](v193, "setResultType:", 3LL);
    v194 = -[NSPersistentHistoryChangeRequest fetchRequestDescribingChangeRequestForStore:](v193, self);
    -[NSFetchRequest setResultType:](v194, "setResultType:", 2LL);
    -[NSXPCStore executeFetchRequest:withContext:error:]((uint64_t *)self, (uint64_t)v194, v216, &v217);
    unsigned int v188 = 0LL;
    if (!v217)
    {
      v196 = v195;
      if (v195)
      {
        if ([a3 resultType] == 5)
        {
          v218 = v196;
          v219 = v177;
          unsigned int v188 = [MEMORY[0x189603F18] arrayWithObjects:&v218 count:2];
        }

        else
        {
          unsigned int v188 = v196;
        }
      }
    }

LABEL_210:
    goto LABEL_211;
  }

LABEL_195:
  unsigned int v188 = MEMORY[0x189604A58];
LABEL_211:
  id v13 = +[NSPersistentHistoryResult _processResult:forRequest:withProvider:]( &OBJC_CLASS___NSPersistentHistoryResult,  "_processResult:forRequest:withProvider:",  v188,  a3,  self);
  if (a4) {
    -[NSManagedObjectContext _setAllowAncillaryEntities:](v216, "_setAllowAncillaryEntities:", 0LL);
  }
  else {

  }
  do
  {
LABEL_140:
    uint64_t v162 = __ldxr((unsigned int *)p_outstandingRequests);
    uint64_t v163 = v162 - 1;
  }

  while (__stxr(v163, (unsigned int *)p_outstandingRequests));
  if (!v163) {
    dispatch_semaphore_signal((dispatch_semaphore_t)self->_requestTerminationSem);
  }
  return v13;
}

        -[NSSQLiteConnection endFetchAndRecycleStatement:](v252, 0);
        int v137 = v284;

        int v138 = 0LL;
        int v139 = v284;
        if ((v131 & 1) == 0)
        {
          if (v284)
          {
            *(void *)&v299 = v284;
          }

          else
          {
            unsigned int v140 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
            _NSCoreDataLog( 17LL,  v140,  v141,  v142,  v143,  v144,  v145,  v146,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLCore.m");
            int v147 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              v286.f_bsize = 136315394;
              *(void *)&v286.f_iosize = "/Library/Caches/com.apple.xbs/Sources/Persistence/sqlcore/NSSQLCore.m";
              WORD2(v286.f_blocks) = 1024;
              *(_DWORD *)((char *)&v286.f_blocks + 6) = 5568;
              _os_log_fault_impl( &dword_186681000,  v147,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  (uint8_t *)&v286,  0x12u);
            }
          }

          int v148 = v299;
          [(id)v299 userInfo];
          _NSCoreDataLog( 1LL,  (uint64_t)@"Repairing RTree triggers failed with error = %@ and userInfo = %@",  v149,  v150,  v151,  v152,  v153,  v154,  v148);
        }

        -[NSSQLCore _rebuildDerivedAttributeTriggerSchemaUsingConnection:recomputeValues:error:](v255, v252);
        goto LABEL_202;
      }

      goto LABEL_171;
    }
  }

void sub_1866C7B68(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866C7AC0LL);
  }

  JUMPOUT(0x1866C7A48LL);
}

void sub_1866C7B90(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1866C7A44LL);
  }
  JUMPOUT(0x1866C7A04LL);
}

LABEL_46:
    int v40 = 0LL;
    goto LABEL_69;
  }

  if (!v78) {
    goto LABEL_46;
  }
  int v40 = 0LL;
  *uint64_t v78 = (id)objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  133000,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObject:", a3),  @"NSAffectedObjectsErrorKey",  0));
LABEL_69:

  return v40;
}

  if (v43 >= 0x201) {
    NSZoneFree(0LL, v9);
  }
  return v33;
}

      uint64_t v3 = (NSEntityDescription *)v40;
      if (objc_msgSend(v41, "count", v34))
      {
        uint64_t v20 = -[NSFetchIndexDescription initWithName:elements:]( objc_alloc(&OBJC_CLASS___NSFetchIndexDescription),  "initWithName:elements:",  v7,  v41);
        [v42 addObject:v20];
      }

      int v5 = v39 + 1;
    }

    while (v39 + 1 != v38);
    uint64_t v38 = -[NSArray countByEnumeratingWithState:objects:count:]( compoundIndexes,  "countByEnumeratingWithState:objects:count:",  &v59,  v73,  16LL);
  }

  while (v38);
LABEL_50:
  if (objc_msgSend(v42, "count", v34))
  {
    uint64_t v49 = 0u;
    id v50 = 0u;
    uint64_t v47 = 0u;
    uint32_t v48 = 0u;
    uint64_t v21 = *(void **)(v35 + 40);
    uint64_t v22 = [v21 countByEnumeratingWithState:&v47 objects:v64 count:16];
    if (v22)
    {
      uint64_t v23 = *(void *)v48;
      do
      {
        for (uint64_t j = 0LL; j != v22; ++j)
        {
          if (*(void *)v48 != v23) {
            objc_enumerationMutation(v21);
          }
          [*(id *)(*((void *)&v47 + 1) + 8 * j) _setEntity:0];
        }

        uint64_t v22 = [v21 countByEnumeratingWithState:&v47 objects:v64 count:16];
      }

      while (v22);
    }

    uint64_t v45 = 0u;
    uint64_t v46 = 0u;
    int v43 = 0u;
    unsigned int v44 = 0u;
    uint64_t v25 = [v42 countByEnumeratingWithState:&v43 objects:v63 count:16];
    if (v25)
    {
      uint64_t v26 = *(void *)v44;
      do
      {
        for (uint64_t k = 0LL; k != v25; ++k)
        {
          if (*(void *)v44 != v26) {
            objc_enumerationMutation(v42);
          }
          [*(id *)(*((void *)&v43 + 1) + 8 * k) _setEntity:v3];
        }

        uint64_t v25 = [v42 countByEnumeratingWithState:&v43 objects:v63 count:16];
      }

      while (v25);
    }

    *(void *)(v35 + 40) = v42;
  }

  else
  {

    *(void *)(v35 + 40) = 0LL;
  }

                    ++v22;
                    unsigned int v15 = v164;
                    uint64_t v12 = v165;
                    uint64_t v20 = v163;
                  }

                  while (v22 != v21);
                  uint64_t v21 = -[NSArray countByEnumeratingWithState:objects:count:]( v163,  "countByEnumeratingWithState:objects:count:",  &v185,  v199,  16LL);
                  uint64_t v14 = v162;
                  if (v21) {
                    continue;
                  }
                  break;
                }
              }

              uint64_t v28 = 0;
              uint64_t v29 = v168->_entityDescriptionFlags;
            }

            else
            {
              uint64_t v29 = v168->_entityDescriptionFlags;
              if ((*(_BYTE *)&v29 & 0x20) != 0) {
LABEL_53:
              }
                uint64_t v28 = 32;
              else {
                uint64_t v28 = 0;
              }
            }

            entityDescriptionFlags = *(_DWORD *)&v29 & 0xFFFFFFDF | v28;
            v168->_entityDescriptionFlags = (__entityDescriptionFlags)entityDescriptionFlags;
          }

          if (HIBYTE(dword_18C4ABDC0)) {
            uint64_t v30 = v28 == 0;
          }
          else {
            uint64_t v30 = 1;
          }
          if (!v30)
          {
            if (![v17 _isSpotlightIndexedAndTransient])
            {
              uint64_t v153 = (void *)MEMORY[0x189603F70];
              v194 = @"attribute";
              v195 = [v17 name];
              id v154 = [MEMORY[0x189603F68] dictionaryWithObjects:&v195 forKeys:&v194 count:1];
              objc_exception_throw((id)[v153 exceptionWithName:*MEMORY[0x189603A58] reason:@"Transient attributes cannot be indexed in Spotlight" userInfo:v154]);
              goto LABEL_208;
            }

            entityDescriptionFlags = v168->_entityDescriptionFlags;
          }

          if ((entityDescriptionFlags & 0x40) == 0)
          {
            else {
              uint64_t v31 = 0;
            }
            v168->_entityDescriptionFlags = (__entityDescriptionFlags)(*(_DWORD *)&v168->_entityDescriptionFlags & 0xFFFFFFBF | v31);
          }

          uint64_t v32 = [v17 _propertyType];
          if (v32 == 6)
          {
            if (objc_msgSend((id)objc_msgSend(v17, "derivationExpression"), "expressionType") == 3) {
              -[NSArray setObject:forKey:]( v167,  "setObject:forKey:",  v17,  objc_msgSend((id)objc_msgSend(v17, "derivationExpression"), "keyPath"));
            }
          }

          else if (v32 == 2)
          {
            if ([v17 storesBinaryDataExternally]
              && ([v17 isFileBackedFuture] & 1) == 0)
            {
              *(_DWORD *)&v168->_entityDescriptionFlags |= 0x100u;
            }

            if (([v17 isFileBackedFuture] & 1) != 0
              || objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v17, "userInfo"),  "valueForKey:",  @"NSIsFileBackedFuture"),  "BOOLValue"))
            {
              *(_DWORD *)&v168->_entityDescriptionFlags |= 0x8100u;
            }
          }

          objc_autoreleasePoolPop(v18);
          if ((NSArray *)++v16 == v14)
          {
            uint64_t v14 = (NSArray *)[v12 countByEnumeratingWithState:&v173 objects:v196 count:16];
            if (!v14) {
              break;
            }
            goto LABEL_25;
          }
        }
      }

      if (-[NSArray count](v161, "count"))
      {
        __int128 v171 = 0u;
        __int128 v172 = 0u;
        __int128 v169 = 0u;
        __int128 v170 = 0u;
        id v33 = -[NSArray countByEnumeratingWithState:objects:count:]( v161,  "countByEnumeratingWithState:objects:count:",  &v169,  v193,  16LL);
        if (v33)
        {
          unint64_t v34 = *(void *)v170;
LABEL_83:
          uint64_t v35 = 0LL;
          while (1)
          {
            if (*(void *)v170 != v34) {
              objc_enumerationMutation(v161);
            }
            unint64_t v36 = *(void **)(*((void *)&v169 + 1) + 8 * v35);
            if (!-[NSArray valueForKey:](v167, "valueForKey:", [v36 name])) {
              break;
            }
            if (v33 == ++v35)
            {
              id v33 = -[NSArray countByEnumeratingWithState:objects:count:]( v161,  "countByEnumeratingWithState:objects:count:",  &v169,  v193,  16LL);
              if (!v33) {
                goto LABEL_89;
              }
              goto LABEL_83;
            }
          }

          uint64_t v151 = (void *)MEMORY[0x189603F70];
          uint64_t v152 = [NSString stringWithFormat:@"Mergeable attribute %@ requires a paired derived attribute with a derivation expression in the form %@", objc_msgSend(v36, "name"), objc_msgSend(v36, "name")];
          objc_exception_throw((id)[v151 exceptionWithName:*MEMORY[0x189603A58] reason:v152 userInfo:0]);
          goto LABEL_208;
        }
      }

                  LOBYTE(v6) = 1;
                }
              }
            }
          }
        }
      }
    }
  }

  return v6;
}

              if (!v40)
              {
                id v18 = v178;
                unsigned int v140 = [NSString stringWithFormat:@"Row (pk = %ld) for entity '%@' is missing mandatory text data for property '%@'", 0, objc_msgSend( (id)objc_msgSend((id)_sqlEntityForEntityID(v170, v178), "entityDescription"), "name"), objc_msgSend((id)objc_msgSend(*(id *)&v189[6 * v23 + 6], "propertyDescription"), "name")];
                _NSCoreDataLog(1LL, (uint64_t)@"%@\n", v141, v142, v143, v144, v145, v146, v140);
                int v139 = v177;
                int v138 = v185;
                goto LABEL_162;
              }
            }

            objc_opt_self();
            LOBYTE(v42) = *v40;
            if (*v40)
            {
              int v43 = 0;
              unsigned int v44 = 0LL;
              do
              {
                if ((v42 & 0x80u) != 0) {
                  int v43 = 1;
                }
                uint64_t v45 = v44 + 1;
                int v42 = v40[++v44];
              }

              while (v42);
            }

            else
            {
              int v43 = 0;
              uint64_t v45 = 0LL;
            }

            uint64_t v46 = off_189EA56D8;
            if (v43) {
              uint64_t v46 = &off_189EA56E0;
            }
            uint64_t v47 = -[__objc2_class bufferOffset](*v46, "bufferOffset");
            uint32_t v48 = v47 + (((v45 << 32) + 0x100000000LL) >> 32);
            if (v190 - (v22 - (char *)v188) < v48)
            {
              uint64_t v49 = (objc_class *)objc_opt_class();
              id v50 = class_getInstanceSize(v49);
              v190 += (int)(((v50 + 7) & 0xFFFFFFF8) + v48);
              uint64_t v51 = (char *)bufferResultSetRealloc(v188, (unint64_t *)&v190);
              uint64_t v22 = &v51[v22 - (char *)v188];
              int v187 = &v51[v187 - (char *)v188];
              unsigned int v188 = v51;
            }

            if (v43 || (int)v45 > 7)
            {
              if (v43) {
                uint64_t v53 = -1LL;
              }
              else {
                uint64_t v53 = 0LL;
              }
              *(void *)uint64_t v22 = v53;
              *((_DWORD *)v22 + 4) = v45;
              uint64_t v54 = &v22[v47];
              memcpy(v54, v40, (int)v45);
              uint64_t v55 = &v54[(int)v45];
              goto LABEL_74;
            }

            if ((*(_BYTE *)(a2 + 40) & 2) != 0)
            {
              memcpy(v22, v40, (int)v45);
              uint64_t v55 = &v22[(int)v45];
LABEL_74:
              CFStringRef v55 = 0;
              uint64_t v52 = v55 + 1;
              uint64_t v26 = v187;
              goto LABEL_116;
            }

            *(void *)buf = 0LL;
            __memmove_chk();
            uint64_t v26 = v187;
            if ((*(void *)buf & 0x8080808080808080LL) != 0)
            {
              uint64_t v52 = v22;
            }

            else
            {
              uint64_t v97 = (8LL * (int)v45) | (*(void *)buf << 7) | 0x8000000000000002LL;
              uint64_t v98 = *MEMORY[0x189616658] ^ v97;
              if ((~v98 & 0xC000000000000007LL) == 0
                || (uint64_t v52 = v22,
                    (uint64_t v97 = v98 & 0xFFFFFFFFFFFFFFF8LL | *(unsigned __int8 *)(MEMORY[0x189616648] + (v98 & 7))) != 0))
              {
                *(void *)uint64_t v22 = v97;
                uint64_t v52 = v22 + 8;
              }
            }

        uint64_t v3 = v43 + 1;
      }

      while (v43 + 1 != v40);
      unint64_t v34 = [obj countByEnumeratingWithState:&v46 objects:v58 count:16];
      int v40 = v34;
    }

    while (v34);
  }

  return v42;
}

LABEL_71:
        objc_autoreleasePoolPop(v50);
        uint64_t v47 = (char *)v47 + 1;
      }

      while (v109 != v47);
      int v66 = (void *)[v110 countByEnumeratingWithState:&v118 objects:v136 count:16];
      int v109 = v66;
      if (!v66) {
        goto LABEL_110;
      }
    }
  }

  if (!objc_msgSend((id)objc_msgSend(v112, "inverseRelationship"), "isToMany"))
  {
    char v124 = 0u;
    int v125 = 0u;
    uint64_t v122 = 0u;
    unint64_t v123 = 0u;
    id v110 = (void *)[v29 countByEnumeratingWithState:&v122 objects:v137 count:16];
    if (v110)
    {
      int v67 = 0LL;
      unsigned int v68 = 0LL;
      int v109 = *(id *)v123;
      do
      {
        for (uint64_t j = 0LL; j != v110; uint64_t j = (char *)j + 1)
        {
          uint64_t v70 = v68;
          if (*(id *)v123 != v109) {
            objc_enumerationMutation(v105);
          }
          int v71 = *(void **)(*((void *)&v122 + 1) + 8LL * (void)j);
          int v72 = (void *)MEMORY[0x186E3E5D8]();
          unsigned int v68 = (NSManagedObject *)-[os_unfair_lock_s valueForPropertyDescription:]( -[NSXPCStore _cachedRowForObjectWithID:generation:]( v28,  (const void *)[v71 objectID],  v111),  "valueForPropertyDescription:",  objc_msgSend(v112, "inverseRelationship"));
          if ([v112 inverseRelationship] && !-[NSManagedObject isEqual:](v70, "isEqual:", v68))
          {
            if (v67)
            {
              int v73 = v67;
              int v108 = v68;
              unint64_t v104 = (void *)-[os_unfair_lock_s valueForPropertyDescription:]( -[NSXPCStore _cachedRowForObjectWithID:generation:]( v28,  (const void *)objc_msgSend((id)objc_msgSend(v67, "lastObject"), "objectID"),  v111),  "valueForPropertyDescription:",  objc_msgSend(v112, "inverseRelationship"));
              int v74 = -[NSManagedObjectContext objectWithID:](a4, "objectWithID:");
              unsigned int v75 = -[_NSFaultingMutableSet initWithSource:destinations:forRelationship:inContext:]( objc_alloc(&OBJC_CLASS____NSFaultingMutableSet),  "initWithSource:destinations:forRelationship:inContext:",  v74,  v73,  v112,  a4);
              if ([v112 isOrdered])
              {
                int v76 = [v73 valueForKey:@"objectID"];
              }

              else
              {
                uint64_t v77 = v73;
                uint64_t v78 = (void *)MEMORY[0x189604010];
                uint64_t v79 = [v77 valueForKey:@"objectID"];
                uint64_t v80 = v78;
                int v73 = v77;
                int v76 = [v80 setWithArray:v79];
              }

              uint64_t v81 = (void *)v76;
              uint64_t v28 = (os_unfair_lock_s *)v113;
              uint64_t v82 = -[NSGenerationalRowCache rowCacheForGeneration:]((uint64_t)v113[1]._oidFactories, v111);
              -[NSPersistentStoreCache registerToMany:withOrderKeys:forSourceObjectID:forProperty:options:andTimestamp:]( (uint64_t)v82,  v81,  0LL,  v104,  v112,  v18);
              _PFFaultHandlerPreconnectRelationship((int)defaultFaultHandler, v74, v112, v75);
              [v107 minusSet:v75];

              unsigned int v68 = v108;
            }

            int v67 = objc_alloc_init(MEMORY[0x189603FA8]);
          }

          [v67 addObject:v71];
          objc_autoreleasePoolPop(v72);
        }

        id v110 = (void *)[v105 countByEnumeratingWithState:&v122 objects:v137 count:16];
      }

      while (v110);
      if (!v67 || ![v67 count]) {
        goto LABEL_109;
      }
      uint64_t v83 = v111;
      int v84 = (void *)-[os_unfair_lock_s valueForPropertyDescription:]( -[NSXPCStore _cachedRowForObjectWithID:generation:]( v28,  (const void *)objc_msgSend((id)objc_msgSend(v67, "lastObject"), "objectID"),  v111),  "valueForPropertyDescription:",  objc_msgSend(v112, "inverseRelationship"));
      uint64_t v85 = -[NSManagedObjectContext objectWithID:](a4, "objectWithID:", v84);
      id v86 = -[_NSFaultingMutableSet initWithSource:destinations:forRelationship:inContext:]( objc_alloc(&OBJC_CLASS____NSFaultingMutableSet),  "initWithSource:destinations:forRelationship:inContext:",  v85,  v67,  v112,  a4);
      if ([v112 isOrdered])
      {
        int v87 = (void *)[v67 valueForKey:@"objectID"];
      }

      else
      {
        uint64_t v83 = v111;
        int v87 = (void *)objc_msgSend( MEMORY[0x189604010],  "setWithArray:",  objc_msgSend(v67, "valueForKey:", @"objectID"));
      }

      -[NSXPCStore cacheContents:ofRelationship:onObjectWithID:withTimestamp:generation:]( (uint64_t)v28,  v87,  v112,  v84,  v83,  v18);
      _PFFaultHandlerPreconnectRelationship((int)defaultFaultHandler, v85, v112, v86);
      [v107 minusSet:v86];
    }

    int v67 = 0LL;
LABEL_109:

    goto LABEL_110;
  }

  id v33 = [v109 count];
  if (v33 >= 2)
  {
    unint64_t v34 = 0LL;
    unint64_t v104 = (void *)(v33 >> 1);
    do
    {
      id v110 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v35 = (void *)[v109 objectAtIndex:2 * (void)v34];
      int v108 = -[NSManagedObjectContext objectWithID:](a4, "objectWithID:", v35);
      unint64_t v36 = (void *)[v109 objectAtIndex:(2 * (void)v34) | 1];
      uint64_t v37 = objc_alloc_init(MEMORY[0x189603FA8]);
      uint64_t v126 = 0u;
      char v127 = 0u;
      uint64_t v128 = 0u;
      BOOL v129 = 0u;
      uint64_t v38 = [v36 countByEnumeratingWithState:&v126 objects:v138 count:16];
      if (v38)
      {
        uint64_t v39 = v38;
        int v40 = *(void *)v127;
        do
        {
          int v41 = 0LL;
          do
          {
            if (*(void *)v127 != v40) {
              objc_enumerationMutation(v36);
            }
            if (a4) {
              int v42 = _PFRetainedObjectIDCore((uint64_t)a4, *(void **)(*((void *)&v126 + 1) + 8 * v41), 0LL, 1);
            }
            else {
              int v42 = 0LL;
            }
            [v37 addObject:v42];

            ++v41;
          }

          while (v39 != v41);
          int v43 = [v36 countByEnumeratingWithState:&v126 objects:v138 count:16];
          uint64_t v39 = v43;
        }

        while (v43);
      }

      if (([v112 isOrdered] & 1) == 0) {
        unint64_t v36 = (void *)[MEMORY[0x189604010] setWithArray:v36];
      }
      unsigned int v44 = -[NSGenerationalRowCache rowCacheForGeneration:]((uint64_t)v113[1]._oidFactories, v111);
      -[NSPersistentStoreCache registerToMany:withOrderKeys:forSourceObjectID:forProperty:options:andTimestamp:]( (uint64_t)v44,  v36,  0LL,  v35,  v112,  v18);
      uint64_t v45 = -[_NSFaultingMutableSet initWithSource:destinations:forRelationship:inContext:]( objc_alloc(&OBJC_CLASS____NSFaultingMutableSet),  "initWithSource:destinations:forRelationship:inContext:",  v108,  v37,  v112,  a4);
      _PFFaultHandlerPreconnectRelationship((int)defaultFaultHandler, (unsigned int *)v108, v112, v45);
      [v107 minusSet:v45];

      objc_autoreleasePoolPop(v110);
      unint64_t v34 = (char *)v34 + 1;
    }

    while (v34 != v104);
  }

    *(_WORD *)(a5 + 72) |= 0x4000u;
    if ((v53 & 0x40) == 0) {
      goto LABEL_64;
    }
    goto LABEL_63;
  }

  if (!*(_DWORD *)(a2 + v27))
  {
LABEL_54:
    uint64_t v16 = v28;
    goto LABEL_55;
  }

  uint64_t v29 = *(unsigned __int16 *)(a5 + 80);
  if (v29 <= 0x1F3)
  {
    if (*(unsigned __int16 *)(a5 + 80) > 0x12Bu)
    {
      if (v29 != 300)
      {
        if (v29 == 400)
        {
          int v40 = (v27 + 7) & 0xFFFFFFFFFFFFFFFCLL;
          if (v40 + 4 <= a4)
          {
            int v41 = bswap32(*(_DWORD *)(a2 + v40));
            uint64_t v28 = v40 + 4;
          }

          else
          {
            int v41 = 0LL;
          }

          id v50 = (CFNumberRef)[objc_alloc(MEMORY[0x189607858]) initWithString:*(void *)(a6 + 8 * v41)];
          goto LABEL_53;
        }

        goto LABEL_44;
      }

      uint64_t v45 = (v27 + 11) & 0xFFFFFFFFFFFFFFF8LL;
      uint64_t v46 = v45 + 8;
      if (v45 + 8 <= a4)
      {
        uint64_t v47 = bswap64(*(void *)(a2 + v45));
        uint64_t v28 = v46;
      }

      else
      {
        uint64_t v47 = 0LL;
      }

      CFAbsoluteTime valuePtr = v47;
      int v42 = kCFNumberLongLongType;
LABEL_52:
      id v50 = CFNumberCreate(0LL, v42, &valuePtr);
LABEL_53:
      *(void *)(a5 + 112) = v50;
      goto LABEL_54;
    }

    if (v29 != 100 && v29 != 200) {
      goto LABEL_44;
    }
LABEL_28:
    id v33 = (v27 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v34 = v33 + 4;
    if (v33 + 4 <= a4)
    {
      uint64_t v35 = bswap32(*(_DWORD *)(a2 + v33));
      uint64_t v28 = v34;
    }

    else
    {
      uint64_t v35 = 0;
    }

    LODWORD(valuePtr) = v35;
    int v42 = kCFNumberIntType;
    goto LABEL_52;
  }

  if (*(unsigned __int16 *)(a5 + 80) <= 0x2BBu)
  {
    if (v29 != 500)
    {
      if (v29 == 600)
      {
        unint64_t v36 = (v27 + 7) & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v37 = bswap32(*(_DWORD *)(a2 + v36));
        uint64_t v38 = objc_alloc(MEMORY[0x189607968]);
        LODWORD(v39) = v37;
        *(void *)(a5 + 112) = [v38 initWithFloat:v39];
        uint64_t v16 = v36 + 4;
        goto LABEL_55;
      }

      goto LABEL_44;
    }

    int v43 = (v27 + 11) & 0xFFFFFFFFFFFFFFF8LL;
    unsigned int v44 = [objc_alloc(MEMORY[0x189607968]) initWithDouble:COERCE_DOUBLE(bswap64(*(void *)(a2 + v43)))];
LABEL_41:
    *(void *)(a5 + 112) = v44;
    uint64_t v16 = v43 + 8;
    goto LABEL_55;
  }

  switch(v29)
  {
    case 0x384u:
      int v43 = (v27 + 11) & 0xFFFFFFFFFFFFFFF8LL;
      unsigned int v44 = [objc_alloc(MEMORY[0x189603F50]) initWithTimeIntervalSinceReferenceDate:COERCE_DOUBLE(bswap64(*(void *)(a2 + v43)))];
      goto LABEL_41;
    case 0x320u:
      goto LABEL_28;
    case 0x2BCu:
      uint64_t v30 = (v27 + 7) & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v31 = v30 + 4;
      if (v30 + 4 <= a4)
      {
        uint64_t v32 = bswap32(*(_DWORD *)(a2 + v30));
        uint64_t v28 = v31;
      }

      else
      {
        uint64_t v32 = 0LL;
      }

      id v50 = (CFNumberRef)*(id *)(a8 + 8 * v32);
      goto LABEL_53;
  }

  if (v11)
  {
    if (a2)
    {
      id result = 0LL;
      *a2 = v11;
      return result;
    }
  }

  else
  {
    uint64_t v81 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v81,  v82,  v83,  v84,  v85,  v86,  v87,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
    uint64_t v88 = (os_log_s *)__pflogFaultLog;
    id result = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result) {
      return result;
    }
    *(_DWORD *)v259 = 136315394;
    *(void *)&v259[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m";
    *(_WORD *)&v259[12] = 1024;
    *(_DWORD *)&v259[14] = 104;
    _os_log_fault_impl( &dword_186681000,  v88,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v259,  0x12u);
  }

  return 0LL;
}

void sub_1866C9F70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1866CBBA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2 != 1) {
    _Unwind_Resume(exception_object);
  }
  id v13 = objc_begin_catch(exception_object);
  if (v12) {
    objc_setProperty_nonatomic(v12, v14, v13, 48LL);
  }
  objc_end_catch();
}

uint64_t _PFLogGetErrorLog()
{
  if (qword_18C4AB808 != -1) {
    dispatch_once(&qword_18C4AB808, &__block_literal_global);
  }
  return __pflogFaultLog;
}

void _NSCoreDataLog( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v11 = "unknown";
  uint64_t v12 = (void *)MEMORY[0x186E3E5D8]();
  unint64_t v13 = a1 - 1;
  switch(a1)
  {
    case 1LL:
    case 2LL:
    case 17LL:
      if (qword_18C4AB808 == -1) {
        goto LABEL_7;
      }
      uint64_t v26 = &qword_18C4AB808;
      uint64_t v27 = &__block_literal_global;
      break;
    case 3LL:
      if (qword_18C4AB840 != -1) {
        dispatch_once(&qword_18C4AB840, &__block_literal_global_5);
      }
      uint64_t v11 = "warning";
      goto LABEL_21;
    case 4LL:
    case 5LL:
      if (qword_18C4AB848 == -1) {
        goto LABEL_7;
      }
      uint64_t v26 = &qword_18C4AB848;
      uint64_t v27 = &__block_literal_global_7;
      break;
    case 6LL:
    case 7LL:
      if (qword_18C4AB850 == -1) {
        goto LABEL_7;
      }
      uint64_t v26 = &qword_18C4AB850;
      uint64_t v27 = &__block_literal_global_9;
      break;
    case 8LL:
      if (qword_18C4AB858 != -1) {
        dispatch_once(&qword_18C4AB858, &__block_literal_global_11);
      }
      uint64_t v11 = "XPC";
      goto LABEL_21;
    case 9LL:
      if (qword_18C4AB868 != -1) {
        dispatch_once(&qword_18C4AB868, &__block_literal_global_15);
      }
      uint64_t v11 = "debug";
      goto LABEL_21;
    case 16LL:
      if (qword_18C4AB860 != -1) {
        dispatch_once(&qword_18C4AB860, &__block_literal_global_13);
      }
      uint64_t v11 = "CloudKit";
      goto LABEL_21;
    default:
      goto LABEL_21;
  }

  dispatch_once(v26, v27);
LABEL_7:
  if (v13 <= 0x10) {
    uint64_t v11 = off_189EA73D0[v13];
  }
LABEL_21:
  if (_pflogging_enable_oslog >= 1)
  {
    if (_pflogging_catastrophic_mode) {
      uint64_t v14 = 1LL;
    }
    else {
      uint64_t v14 = a1;
    }
    switch(v14)
    {
      case 1LL:
      case 17LL:
        goto LABEL_40;
      case 2LL:
        if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_ERROR)) {
          goto LABEL_31;
        }
        goto LABEL_40;
      case 3LL:
        unsigned int v15 = (os_log_s *)qword_18C4AB810;
        goto LABEL_38;
      case 4LL:
      case 5LL:
        unsigned int v15 = (os_log_s *)qword_18C4AB818;
        goto LABEL_38;
      case 6LL:
      case 7LL:
        unsigned int v15 = (os_log_s *)qword_18C4AB820;
        goto LABEL_35;
      case 8LL:
        unsigned int v15 = (os_log_s *)qword_18C4AB828;
        goto LABEL_38;
      case 9LL:
        unsigned int v15 = (os_log_s *)qword_18C4AB838;
LABEL_35:
        os_log_type_t v18 = OS_LOG_TYPE_INFO;
        goto LABEL_39;
      case 16LL:
        unsigned int v15 = (os_log_s *)qword_18C4AB830;
        goto LABEL_38;
      default:
        unsigned int v15 = (os_log_s *)MEMORY[0x1895F8DA0];
LABEL_38:
        os_log_type_t v18 = OS_LOG_TYPE_DEFAULT;
LABEL_39:
        if (!os_log_type_enabled(v15, v18))
        {
LABEL_31:
          uint64_t v17 = 0LL;
          goto LABEL_70;
        }

os_log_t ___pflogInitialize_block_invoke()
{
  os_log_t result = os_log_create("com.apple.coredata", "warning");
  qword_18C4AB810 = (uint64_t)result;
  return result;
}

os_log_t ___pflogInitialize_block_invoke_2()
{
  os_log_t result = os_log_create("com.apple.coredata", "annotation");
  qword_18C4AB818 = (uint64_t)result;
  return result;
}

os_log_t ___pflogInitialize_block_invoke_3()
{
  os_log_t result = os_log_create("com.apple.coredata", "sql");
  qword_18C4AB820 = (uint64_t)result;
  return result;
}

os_log_t ___pflogInitialize_block_invoke_4()
{
  os_log_t result = os_log_create("com.apple.coredata", "XPC");
  qword_18C4AB828 = (uint64_t)result;
  return result;
}

os_log_t ___pflogInitialize_block_invoke_5()
{
  os_log_t result = os_log_create("com.apple.coredata", "CloudKit");
  qword_18C4AB830 = (uint64_t)result;
  return result;
}

os_log_t ___pflogInitialize_block_invoke_6()
{
  os_log_t result = os_log_create("com.apple.coredata", "debug");
  qword_18C4AB838 = (uint64_t)result;
  return result;
}

LABEL_31:
                    LOBYTE(v6) = 1;
                    return v6;
                  }
                }
              }
            }
          }
        }

        goto LABEL_30;
      }
    }
  }

  return v6;
}

        _NSCoreDataLog(1LL, (uint64_t)@"Failed to create NSXPCConnection", v17, v18, v19, v20, v21, v22, v75);
        return 0LL;
      }
    }

    LOBYTE(v7) = 1;
    return v7;
  }

  uint64_t v7 = [self->_lock tryLock];
  if (v7)
  {
    -[NSManagedObjectContext lock](self, "lock");
    [self->_lock unlock];
    goto LABEL_31;
  }

  return v7;
}

    if (v17) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }

  if (!-[NSPersistentStoreCoordinator _persistentStoreForIdentifier:]( (uint64_t)v10,  [v6 _storeIdentifier]))
  {
    uint64_t v19 = (void *)MEMORY[0x189603F70];
    uint64_t v20 = *MEMORY[0x189603A60];
    uint64_t v21 = [NSString stringWithFormat:@"Object %@ persistent store is not reachable from this NSManagedObjectContext's coordinator", v6];
    uint64_t v22 = @"objectID";
    v23[0] = v6;
    uint64_t v17 = (id)objc_msgSend( v19,  "exceptionWithName:reason:userInfo:",  v20,  v21,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", v23, &v22, 1));
    uint64_t v16 = 134098LL;
    if ((a4 & 1) == 0) {
      goto LABEL_18;
    }
    goto LABEL_31;
  }

  os_log_type_t v18 = -[NSPersistentStoreCoordinator managedObjectIDForURIRepresentation:error:](v10, v15, 0LL);
  if (v18)
  {
    uint64_t v17 = -[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:]((void **)a1, v18, 0LL);
    if (v17) {
      return v17;
    }
  }

  if ((a4 & 1) != 0)
  {
LABEL_32:
    uint64_t v17 = (id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58] reason:@"Invalid state for objectID or NSManagedObjectContext" userInfo:0];
LABEL_33:
    objc_exception_throw(v17);
  }

  uint64_t v17 = 0LL;
  if (a3)
  {
    uint64_t v16 = 133000LL;
    goto LABEL_27;
  }

  return v17;
}

      ++v15;
    }

    while (v13 != v15);
    uint64_t v22 = [v11 countByEnumeratingWithState:&v23 objects:v31 count:16];
    unint64_t v13 = v22;
  }

  while (v22);
  return v2;
}

  if (v36[3] && v13) {
    CFRelease(v13);
  }
  return v8;
}

  uint64_t v38 = v6 & 1;
  uint64_t v3 = v55;
LABEL_32:
  if (*((_BYTE *)v76 + 24))
  {
    v58[0] = MEMORY[0x1895F87A8];
    v58[1] = 3221225472LL;
    void v58[2] = __53__PFCloudKitImporter_processWorkItemsWithCompletion___block_invoke_59;
    void v58[3] = &unk_189EA7B00;
    v58[4] = v1[5];
    v58[5] = v2;
    v58[6] = v3;
    v58[7] = &v75;
    v58[8] = &v69;
    v58[9] = &v63;
    -[NSManagedObjectContext performBlockAndWait:](v3, "performBlockAndWait:", v58);

    uint64_t v3 = 0LL;
  }

  if (!v64[5])
  {
    int v41 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResult);
    int v42 = v1[4];
    if (v42) {
      int v43 = *(void *)(v42 + 48);
    }
    else {
      int v43 = 0LL;
    }
    unsigned int v44 = -[NSCloudKitMirroringResult initWithRequest:storeIdentifier:success:madeChanges:error:]( v41,  "initWithRequest:storeIdentifier:success:madeChanges:error:",  *(void *)(v1[5] + 16),  v43,  *((unsigned __int8 *)v76 + 24),  v38,  v70[5]);
    v64[5] = v44;
  }

  uint64_t v45 = objc_alloc(&OBJC_CLASS___PFCloudKitImportedRecordBytesMetric);
  uint64_t v46 = v1[5];
  if (v46 && (uint64_t v47 = *(void *)(v46 + 8)) != 0) {
    uint32_t v48 = *(void **)(v47 + 24);
  }
  else {
    uint32_t v48 = 0LL;
  }
  uint64_t v49 = -[PFCloudKitSizeMetric initWithContainerIdentifier:]( v45,  "initWithContainerIdentifier:",  [v48 containerIdentifier]);
  -[PFCloudKitSizeMetric addByteSize:]((uint64_t)v49, *(void *)(v1[5] + 48));
  id v50 = v1[5];
  if (v50 && (uint64_t v51 = *(void *)(v50 + 8)) != 0 && (v52 = *(void *)(v51 + 24)) != 0) {
    uint64_t v53 = *(void *)(v52 + 72);
  }
  else {
    uint64_t v53 = 0LL;
  }
  -[PFCloudKitMetricsClient logMetric:](v53, v49);

  uint64_t v54 = v1[6];
  if (v54) {
    (*(void (**)(uint64_t, uint64_t))(v54 + 16))(v54, v64[5]);
  }

  v64[5] = 0LL;
  v70[5] = 0LL;
  _Block_object_dispose(&v63, 8);
  _Block_object_dispose(&v69, 8);
  _Block_object_dispose(&v75, 8);
LABEL_48:
}

      objc_autoreleasePoolPop(v10);
    }

    uint64_t v60 = (void *)[v9 objectAtIndex:0];
    uint64_t v11 = [v60 unsignedLongValue];
    uint64_t v12 = (void *)[v9 objectAtIndex:1];
    unint64_t v13 = (void *)[v9 objectAtIndex:2];
    uint64_t v61 = [v9 objectAtIndex:3];
    if (v11 >> 7 < 0x7D)
    {
      os_log_type_t v18 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 16), "model"), "entityForID:", v11);
    }

    else
    {
      int v65 = 0u;
      int v66 = 0u;
      uint64_t v63 = 0u;
      char v64 = 0u;
      uint64_t v14 = (void *)[*(id *)(a1 + 16) ancillarySQLModels];
      unsigned int v15 = [v14 countByEnumeratingWithState:&v63 objects:v76 count:16];
      if (v15)
      {
        uint64_t v16 = *(void *)v64;
LABEL_9:
        uint64_t v17 = 0LL;
        while (1)
        {
          if (*(void *)v64 != v16) {
            objc_enumerationMutation(v14);
          }
          os_log_type_t v18 = objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(*(id *)(a1 + 16), "ancillarySQLModels"),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v63 + 1) + 8 * v17)),  "entityForID:",  v11);
          if (v18) {
            break;
          }
          if (v15 == ++v17)
          {
            unsigned int v15 = [v14 countByEnumeratingWithState:&v63 objects:v76 count:16];
            os_log_type_t v18 = 0LL;
            if (v15) {
              goto LABEL_9;
            }
            break;
          }
        }
      }

      else
      {
        os_log_type_t v18 = 0LL;
      }
    }

    uint64_t v27 = (void *)objc_msgSend( *(id *)(a1 + 16),  "newObjectIDForEntity:pk:",  v18,  objc_msgSend(v12, "unsignedLongLongValue"));
    if (v27)
    {
      uint64_t v28 = [v13 longLongValue];
      uint64_t v29 = v59;
      if (v28)
      {
        if ([v13 longLongValue] == 1)
        {
          if (v61)
          {
            v75[0] = v27;
            v75[1] = v61;
            objc_msgSend(v56, "addObject:", objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v75, 2));
LABEL_30:

            goto LABEL_31;
          }

          int v42 = [NSString stringWithUTF8String:"History Update for %@ without any updated columns."];
          _NSCoreDataLog(17LL, v42, v43, v44, v45, v46, v47, v48, (uint64_t)v27);
          uint64_t v49 = __pflogFaultLog;
          if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
            goto LABEL_30;
          }
          *(_DWORD *)buf = 138412290;
          unsigned int v68 = v27;
          uint64_t v38 = (os_log_s *)v49;
          uint64_t v39 = "CoreData: History Update for %@ without any updated columns.";
          int v40 = 12;
LABEL_27:
          _os_log_fault_impl(&dword_186681000, v38, OS_LOG_TYPE_FAULT, v39, buf, v40);
          goto LABEL_30;
        }

        int v41 = [v13 longLongValue];
        uint64_t v29 = v57;
        if (v41 != 2) {
          goto LABEL_30;
        }
      }

      [v29 addObject:v27];
      goto LABEL_30;
    }

    __int16 v30 = [NSString stringWithUTF8String:"Unable to construct objectID for History Change: %@-%@-%@-%@"];
    _NSCoreDataLog(17LL, v30, v31, v32, v33, v34, v35, v36, (uint64_t)v60);
    uint64_t v37 = __pflogFaultLog;
    if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
      goto LABEL_30;
    }
    *(_DWORD *)buf = 138413058;
    unsigned int v68 = v60;
    int v69 = 2112;
    uint64_t v70 = v12;
    int v71 = 2112;
    int v72 = v13;
    int v73 = 2112;
    int v74 = v61;
    uint64_t v38 = (os_log_s *)v37;
    uint64_t v39 = "CoreData: Unable to construct objectID for History Change: %@-%@-%@-%@";
    int v40 = 42;
    goto LABEL_27;
  }

  return MEMORY[0x189604A60];
}

    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
    {
      uint64_t v51 = +[NSCKDatabaseMetadata databaseMetadataForScope:forStore:inContext:error:]( (uint64_t)&OBJC_CLASS___NSCKDatabaseMetadata,  *(void *)(a1 + 64),  *(void *)(a1 + 32),  *(void **)(a1 + 40),  (uint64_t)&v84);
      if (v51)
      {
        uint64_t v52 = v51;
        -[NSManagedObject setCurrentChangeToken:](v51, "setCurrentChangeToken:", 0LL);
        -[NSManagedObject setHasSubscription:](v52, "setHasSubscription:", 0LL);
        int v74 = 0u;
        unsigned int v75 = 0u;
        int v72 = 0u;
        int v73 = 0u;
        uint64_t v53 = (void *)-[NSManagedObject recordZones](v52, "recordZones");
        uint64_t v54 = [v53 countByEnumeratingWithState:&v72 objects:v87 count:16];
        if (v54)
        {
          uint64_t v55 = v54;
          uint64_t v56 = *(void *)v73;
          do
          {
            for (uint64_t k = 0LL; k != v55; ++k)
            {
              if (*(void *)v73 != v56) {
                objc_enumerationMutation(v53);
              }
              unint64_t v58 = *(void **)(*((void *)&v72 + 1) + 8 * k);
              [v58 setCurrentChangeToken:0];
              [v58 setHasRecordZone:0];
              [v58 setHasSubscription:0];
              [v58 setSupportsFetchChanges:0];
              [v58 setSupportsAtomicChanges:0];
              [v58 setSupportsRecordSharing:0];
            }

            uint64_t v55 = [v53 countByEnumeratingWithState:&v72 objects:v87 count:16];
          }

          while (v55);
        }
      }

      else if (v84)
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0;
      }
    }
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    v86[0] = @"NSCloudKitMirroringDelegateLastHistoryTokenKey";
    v86[1] = @"NSCloudKitMirroringDelegateCheckedCKIdentityDefaultsKey";
    v86[2] = @"NSCloudKitMirroringDelegateCKIdentityRecordNameDefaultsKey";
    unint64_t v59 = +[NSCKMetadataEntry entriesForKeys:fromStore:inManagedObjectContext:error:]( (uint64_t)NSCKMetadataEntry,  [MEMORY[0x189603F18] arrayWithObjects:v86 count:3],  *(void *)(a1 + 32),  *(void **)(a1 + 40),  (uint64_t)&v84);
    if (v59)
    {
      uint64_t v70 = 0u;
      int v71 = 0u;
      unsigned int v68 = 0u;
      int v69 = 0u;
      uint64_t v60 = (void *)[v59 allValues];
      uint64_t v61 = [v60 countByEnumeratingWithState:&v68 objects:v85 count:16];
      if (v61)
      {
        uint64_t v62 = v61;
        uint64_t v63 = *(void *)v69;
        do
        {
          for (m = 0LL; m != v62; ++m)
          {
            if (*(void *)v69 != v63) {
              objc_enumerationMutation(v60);
            }
            [*(id *)(a1 + 40) deleteObject:*(void *)(*((void *)&v68 + 1) + 8 * m)];
          }

          uint64_t v62 = [v60 countByEnumeratingWithState:&v68 objects:v85 count:16];
        }

        while (v62);
      }
    }

    else
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0;
    }
  }

  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)
    || (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [*(id *)(a1 + 40) save:&v84]) == 0)
  {
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL) = v84;
  }
}

      objc_autoreleasePoolPop(context);
      if (!v12) {
        goto LABEL_36;
      }
      ++v10;
    }

    while (v9 != v10);
    uint64_t v38 = [obj countByEnumeratingWithState:&v90 objects:v101 count:16];
    uint64_t v9 = v38;
  }

  while (v38);
LABEL_36:
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 24LL)) {
    *int v76 = 1;
  }
  uint64_t v39 = *(void *)(*(void *)(a1 + 40) + 48LL);
  int v40 = [*(id *)(a1 + 32) objectID];
  if (v39) {
    int v41 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(v39 + 40), "objectForKey:", v40), "objectForKey:", v77);
  }
  else {
    int v41 = 0LL;
  }
  int v42 = (void *)[v41 mutableCopy];
  [v42 minusSet:v81];
  uint64_t v88 = 0u;
  uint64_t v89 = 0u;
  id v86 = 0u;
  int v87 = 0u;
  int v43 = [v42 countByEnumeratingWithState:&v86 objects:v94 count:16];
  if (v43)
  {
    unsigned int v44 = *(void *)v87;
    uint64_t v45 = MEMORY[0x189604A88];
    uint64_t v46 = MEMORY[0x189604A80];
    do
    {
      uint64_t v47 = 0LL;
      do
      {
        if (*(void *)v87 != v44) {
          objc_enumerationMutation(v42);
        }
        uint32_t v48 = *(void *)(*((void *)&v86 + 1) + 8 * v47);
        uint64_t v49 = *(void *)(*(void *)(a1 + 40) + 48LL);
        id v50 = [*(id *)(a1 + 56) zoneID];
        if (v49)
        {
          uint64_t v51 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(v49 + 32), "objectForKey:", v50), "objectForKey:", v48);
          if (v51)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0) {
              goto LABEL_50;
            }
          }
        }

        else
        {
          uint64_t v51 = 0LL;
        }

        uint64_t v52 = [NSString stringWithUTF8String:"Failed to look up cached mirrored relationship for mtmKey: %@"];
        _NSCoreDataLog(17LL, v52, v53, v54, v55, v56, v57, v58, v48);
        unint64_t v59 = (os_log_s *)__pflogFaultLog;
        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 138412290;
          uint64_t v96 = v48;
          _os_log_fault_impl( &dword_186681000,  v59,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to look up cached mirrored relationship for mtmKey: %@",  buf,  0xCu);
        }

LABEL_34:
  unint64_t v13 = (void *)objc_msgSend( (id)objc_msgSend(a3, "userInfo"),  "objectForKey:",  @"NSCloudKitMirroringDelegateIgnoredPropertyKey");
  if (v13)
  {
    uint64_t v14 = v13;
    if ([v13 isNSNumber] & 1) != 0 || (objc_msgSend(v14, "isNSString"))
    {
      unsigned int v15 = *(void **)(a1 + 64);
      uint64_t v16 = [NSString stringWithFormat:@"%@: %@ - attribute is not optional", objc_msgSend(*(id *)(a1 + 48), "name"), a2, v34, v35, v36];
    }

    else
    {
      unsigned int v15 = *(void **)(a1 + 64);
      uint64_t v17 = (void *)NSString;
      os_log_type_t v18 = [*(id *)(a1 + 48) name];
      uint64_t v19 = [a3 name];
      uint64_t v20 = (objc_class *)objc_opt_class();
      uint64_t v21 = NSStringFromClass(v20);
      uint64_t v22 = (objc_class *)objc_opt_class();
      uint64_t v23 = NSStringFromClass(v22);
      uint64_t v16 = [v17 stringWithFormat:@"%@: %@ - Value must be an instance of '%@' or '%@' that evalutes to YES or NO using '%@'", v18, v19, v21, v23, NSStringFromSelector(sel_BOOLValue)];
    }

    [v15 addObject:v16];
  }

        objc_sync_exit(self);
        int v43 = v15;
        objc_autoreleasePoolPop(v13);
        goto LABEL_35;
      }
    }

    else
    {
      objc_sync_enter(self);
      uint64_t v14 = 0LL;
    }

    os_log_type_t v18 = 1;
    goto LABEL_17;
  }

  unsigned int v15 = 0LL;
LABEL_35:
  if (!-[NSXPCStoreServerPerConnectionCache coordinator](v15, "coordinator"))
  {
    uint64_t v49 = [NSString stringWithFormat:@"Unable to create stack"];
    +[_NSXPCStoreUtilities logMessage:forComponent:]( (uint64_t)&OBJC_CLASS____NSXPCStoreUtilities,  v49,  (uint64_t)self,  v50,  v51,  v52,  v53,  v54,  v62);

LABEL_40:
    uint32_t v48 = 0;
    goto LABEL_41;
  }

  unsigned int v44 = objc_alloc(&OBJC_CLASS___NSXPCStoreConnectionInfo);
  entitlementNames = self->_entitlementNames;
  int v66 = v63;
  int v67 = v64;
  uint64_t v46 = -[NSXPCStoreConnectionInfo initForToken:entitlementNames:cache:]( v44,  "initForToken:entitlementNames:cache:",  &v66,  entitlementNames,  v15);

  if (!v46)
  {
    uint64_t v55 = [NSString stringWithFormat:@"Unable to create connection context"];
    +[_NSXPCStoreUtilities logMessage:forComponent:]( (uint64_t)&OBJC_CLASS____NSXPCStoreUtilities,  v55,  (uint64_t)self,  v56,  v57,  v58,  v59,  v60,  v62);
    goto LABEL_40;
  }

  [a4 setDelegate:self];
  [a4 setExportedObject:self];
  objc_msgSend(a4, "setExportedInterface:", objc_msgSend(MEMORY[0x189607B48], "interfaceWithProtocol:", &unk_18C698588));
  uint64_t v47 = objc_alloc_init(MEMORY[0x189603FC8]);
  [v47 setValue:v46 forKey:@"NSConnectionInfo"];

  [a4 setUserInfo:v47];
  [a4 resume];
  uint32_t v48 = 1;
LABEL_41:
  objc_autoreleasePoolPop(v6);
  return v48;
}

  uint64_t v21 = v5->super._store;
  if (!v21 || (WeakRetained = objc_loadWeakRetained(&v21->_object)) == 0LL)
  {
    WeakRetained = 0LL;
    *(_WORD *)&v5->super._flags |= 8u;
  }

  return v5;
}

  os_log_type_t v25 = -[NSMutableOrderedSet _shouldProcessKVOChange](self->_mutableOrderedSet, "_shouldProcessKVOChange");
  if (v25) {
    -[NSMutableOrderedSet _setProcessingIdempotentKVO:](self->_mutableOrderedSet, "_setProcessingIdempotentKVO:", 1LL);
  }
  if (length == 0x7FFFFFFFFFFFFFFFLL) {
    length = -[NSMutableOrderedSet count](self->_mutableOrderedSet, "count");
  }
  v30.receiver = self;
  v30.super_class = (Class)&OBJC_CLASS____NSNotifyingWrapperMutableOrderedSet;
  -[_NSNotifyingWrapperMutableOrderedSet sortRange:options:usingComparator:]( &v30,  sel_sortRange_options_usingComparator_,  location,  length,  v27,  v28);
  if (v25) {
    -[NSMutableOrderedSet _setProcessingIdempotentKVO:](self->_mutableOrderedSet, "_setProcessingIdempotentKVO:", 0LL);
  }
}

  os_log_type_t v18 = (void *)MEMORY[0x186E3E5D8]();
  uint64_t v19 = __ckLoggingOverride != 0;
LABEL_35:
  uint64_t v28 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Not reviving the mirroring delegate (%@:%ld) after notification for subscription: %@\n%@"];
  uint64_t v29 = *(void *)(a1 + 32);
  if (v29) {
    __int16 v30 = *(void **)(v29 + 80);
  }
  else {
    __int16 v30 = 0LL;
  }
  [v30 domain];
  uint64_t v31 = *(void *)(a1 + 32);
  if (v31) {
    uint64_t v32 = *(void **)(v31 + 80);
  }
  else {
    uint64_t v32 = 0LL;
  }
  [v32 code];
  _NSCoreDataLog( v19,  v28,  v33,  v34,  v35,  v36,  v37,  v38,  (uint64_t)"-[NSCloudKitMirroringDelegate _respondToPushNotification:forSubscription:]_block_invoke");
  objc_autoreleasePoolPop(v18);
}

  return v29;
}

LABEL_42:
  id v24 = (void *)objc_msgSend( (id)objc_msgSend(a3, "userInfo"),  "objectForKey:",  @"NSPersistentCloudKitContainerEncryptedAttributeKey");
  if (v24)
  {
    os_log_type_t v25 = v24;
    if (([v24 isNSNumber] & 1) == 0 && (objc_msgSend(v25, "isNSString") & 1) == 0)
    {
      uint64_t v26 = *(void **)(a1 + 72);
      uint64_t v27 = (void *)NSString;
      uint64_t v28 = [*(id *)(a1 + 48) name];
      uint64_t v29 = [a3 name];
      __int16 v30 = (objc_class *)objc_opt_class();
      uint64_t v31 = NSStringFromClass(v30);
      uint64_t v32 = (objc_class *)objc_opt_class();
      id v33 = NSStringFromClass(v32);
      [v26 addObject:objc_msgSend( v27, "stringWithFormat:", @"%@: %@ - Value for %@ must be an instance of '%@' or '%@' that evalutes to YES or NO using '%@'", v28, v29, @"NSPersistentCloudKitContainerEncryptedAttributeKey", v31, v33, NSStringFromSelector(sel_BOOLValue))];
    }

    if ([a3 allowsCloudEncryption]) {
      [*(id *)(a1 + 72) addObject:objc_msgSend( NSString, "stringWithFormat:", @"%@:%@ - Encryption value should be set via -[NSAttributeDescription allowsCloudEncryption], please remove usage of 'NSPersistentCloudKitContainerEncryptedAttributeKey'", objc_msgSend(*(id *)(a1 + 48), "name"), objc_msgSend(a3, "name"))];
    }
    if ([*(id *)(*(void *)(a1 + 32) + 32) useDeviceToDeviceEncryption]) {
      [*(id *)(a1 + 72) addObject:objc_msgSend( NSString, "stringWithFormat:", @"%@:%@ - Partial encryption cannot be used with device-to-device encryption", objc_msgSend(*(id *)(a1 + 48), "name"), objc_msgSend(a3, "name"))];
    }
  }

  if ([*(id *)(*(void *)(a1 + 32) + 32) useDeviceToDeviceEncryption]
    && [a3 allowsCloudEncryption])
  {
    [*(id *)(a1 + 72) addObject:objc_msgSend( NSString, "stringWithFormat:", @"%@:%@ - Device-to-Device encryption cannot be used with partial encryption", objc_msgSend(*(id *)(a1 + 48), "name"), objc_msgSend(a3, "name"))];
  }

  if (([a3 isOptional] & 1) == 0 && !objc_msgSend(a3, "defaultValue")) {
    [*(id *)(a1 + 88) addObject:objc_msgSend( NSString, "stringWithFormat:", @"%@: %@", objc_msgSend(*(id *)(a1 + 48), "name"), objc_msgSend(a3, "name"))];
  }
  os_log_t result = [a3 usesMergeableStorage];
  if ((_DWORD)result)
  {
    if (!*(_BYTE *)(*(void *)(a1 + 32) + 40LL)) {
      return [*(id *)(a1 + 96) addObject:objc_msgSend( NSString, "stringWithFormat:", @"Attributes that use mergeable storage (%@: %@) are unsupported in CloudKit. Please file a radar to Core Data to request support.", objc_msgSend(*(id *)(a1 + 48), "name"), objc_msgSend(a3, "name"))];
    }
  }

  return result;
}

  if (-[NSAttributeDescription attributeType](self, "attributeType") == NSURIAttributeType)
  {
    uint64_t v22 = [*a3 absoluteString];
    uint64_t v23 = 1560LL;
    if (!v15) {
      uint64_t v23 = 1690LL;
    }
    if (!v22) {
      unsigned int v15 = v23;
    }
  }

  LOBYTE(v10) = v15 == 0;
  if (a6 && v15)
  {
    if (a5) {
      uint64_t v10 = -[NSManagedObject _generateErrorWithCode:andMessage:forKey:andValue:additionalDetail:]( (uint64_t)a5,  v15,  0LL,  (uint64_t)-[NSPropertyDescription name](self, "name"),  (uint64_t)*a3,  0LL);
    }
    else {
      uint64_t v10 = [MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:v15 userInfo:0];
    }
    id v24 = (void *)v10;
    LOBYTE(v10) = 0;
    *a6 = v24;
  }

  return v10;
}

                  unint64_t v13 = v11;
                  goto LABEL_43;
                }

                if (v11)
                {
                  if (-[__CFString superCompositeAttribute](v11, "superCompositeAttribute"))
                  {
                    uint64_t v22 = -[NSPropertyDescription _rootName](v11);
                    if (!-[NSEntityDescription _attributeNamed:]((uint64_t)v2, (uint64_t)v22))
                    {
                      uint64_t v45 = (void *)MEMORY[0x189603F70];
                      uint64_t v46 = *MEMORY[0x189603A60];
                      uint64_t v47 = [NSString stringWithFormat:@"Can't find property named %@", v11];
                      uint64_t v91 = @"Property name";
                      uint64_t v92 = v11;
                      uint32_t v48 = (void *)MEMORY[0x189603F68];
                      uint64_t v49 = &v92;
                      id v50 = &v91;
                      goto LABEL_75;
                    }
                  }

                  goto LABEL_42;
                }

                unint64_t v13 = 0LL;
              }

      *(_WORD *)(v3 + 24) &= ~0x400u;
      -[NSPersistentStoreCoordinator _removePersistentStore:]( v3,  (unint64_t *)objc_msgSend((id)v3, "persistentStoreForURL:", objc_msgSend(a2, "storeURL")));
      uint64_t v37 = objc_msgSend( (id)v3,  "addPersistentStoreWithType:configuration:URL:options:error:",  objc_msgSend(a2, "storeType"),  v6,  objc_msgSend(a2, "storeURL"),  objc_msgSend(a2, "options"),  &v59);
      uint64_t v19 = v59;
      if (v37 && !v59)
      {
        [a2 setMigratedStore:v37];
        uint64_t v3 = 1LL;
LABEL_56:

        return v3;
      }

          unint64_t v58 = (void *)MEMORY[0x186E3E5D8]();
          else {
            unint64_t v59 = __ckLoggingOverride;
          }
          uint64_t v60 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Already have scheduled activity for client: %@\n%@\n%@"];
          uint64_t v88 = v18;
          uint64_t v89 = v19;
          _NSCoreDataLog( v59,  v60,  v61,  v62,  v63,  v64,  v65,  v66,  (uint64_t)"-[CDDCloudKitServer _handleScheduleMessage:]_block_invoke");
          objc_autoreleasePoolPop(v58);
          uint64_t v37 = 0LL;
          goto LABEL_46;
        }

        int v43 = objc_alloc(MEMORY[0x189607870]);
        unint64_t v102 = *MEMORY[0x1896075F0];
        unsigned int v44 = (void *)NSString;
        if (-[NSManagedObject containerIdentifier](v90, "containerIdentifier")) {
          uint64_t v45 = -[NSManagedObject containerIdentifier](v90, "containerIdentifier");
        }
        else {
          uint64_t v45 = [MEMORY[0x189603FE8] null];
        }
        unint64_t v103 = [v44 stringWithFormat:@"Failed to get a container for '%@", v45, v87];
        id v86 = [MEMORY[0x189603F68] dictionaryWithObjects:&v103 forKeys:&v102 count:1];
        uint64_t v39 = (id)[v43 initWithDomain:*MEMORY[0x189607460] code:134060 userInfo:v86];
      }

      else
      {
        int v40 = objc_alloc(MEMORY[0x189607870]);
        uint64_t v100 = *MEMORY[0x1896075F0];
        int v41 = *(void *)(v92 + 40);
        if (v41) {
          int v41 = *(void *)(v41 + 24);
        }
        uint64_t v101 = [NSString stringWithFormat:@"No client is registered for: %@", v41];
        int v42 = [MEMORY[0x189603F68] dictionaryWithObjects:&v101 forKeys:&v100 count:1];
        uint64_t v39 = (id)[v40 initWithDomain:*MEMORY[0x189607460] code:134060 userInfo:v42];
      }
    }

    else
    {
      uint64_t v39 = v99;
    }

    *(void *)(*(void *)(*(void *)(v92 + 56) + 8LL) + 40LL) = v39;
LABEL_57:
    int v5 = v91;
    goto LABEL_58;
  }

  uint64_t v38 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
LABEL_58:
}

  *(void *)(*(void *)&buf[8] + 40LL) = 0LL;
  *(void *)(v228 + 40) = 0LL;
  uint64_t v51 = *(unsigned __int8 *)(*(void *)&v239[8] + 24LL);
  _Block_object_dispose(buf, 8);
  _Block_object_dispose(&v227, 8);
  _Block_object_dispose(v239, 8);
  if (!v51) {
    goto LABEL_71;
  }
  *(void *)v278 = 0LL;
  *(void *)&v278[8] = v278;
  *(void *)&v278[16] = 0x2020000000LL;
  v279 = 0;
  -[PFCloudKitSetupAssistant beginActivityForPhase:](v4, 3LL);
  v227 = 0LL;
  v228 = (uint64_t)&v227;
  v229 = 0x3052000000LL;
  v230 = __Block_byref_object_copy__25;
  v231 = __Block_byref_object_dispose__25;
  v232 = 0LL;
  *(void *)buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x3052000000LL;
  v275 = __Block_byref_object_copy__25;
  v276 = __Block_byref_object_dispose__25;
  v277 = 0LL;
  uint64_t v52 = *(void **)(v4 + 56);
  if (v52) {
    uint64_t v52 = (void *)v52[6];
  }
  uint64_t v53 = *(dispatch_semaphore_s **)(v4 + 48);
  uint64_t v54 = v52;
  uint64_t v55 = *(void **)(v4 + 16);
  *(void *)v259 = MEMORY[0x1895F87A8];
  *(void *)&v259[8] = 3221225472LL;
  *(void *)&v259[16] = __47__PFCloudKitSetupAssistant__checkUserIdentity___block_invoke;
  v260 = &unk_189EA9F80;
  v263 = (uint64_t *)v278;
  v264 = (uint8_t *)&v227;
  v265 = (uint64_t)buf;
  v261 = v54;
  v262 = (uint64_t *)v53;
  [v55 fetchUserRecordIDWithCompletionHandler:v259];
  dispatch_semaphore_wait(v53, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v56 = (void (*)(uint64_t))*(id *)(v4 + 56);
  if (*(_BYTE *)(*(void *)&v278[8] + 24LL))
  {
    *(void *)(v4 + 80) = *(id *)(v228 + 40);
    *(void *)v246 = MEMORY[0x1895F87A8];
    v247 = 3221225472LL;
    v248 = (uint64_t)__47__PFCloudKitSetupAssistant__checkUserIdentity___block_invoke_2;
    v249 = (void (*)(uint64_t, uint64_t))&unk_189EA9FF8;
    v250 = v56;
    v251 = (uint64_t *)v4;
    v252 = &v227;
    v253 = v278;
    v254 = (uint64_t)buf;
    -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v56, (uint64_t)v246);
    uint64_t v57 = *(void **)(*(void *)&buf[8] + 40LL);
    if (!v57)
    {
      id v8 = 0LL;
      goto LABEL_55;
    }

    goto LABEL_53;
  }

  unint64_t v58 = (void *)[*(id *)(*(void *)&buf[8] + 40) domain];
  if (![v58 isEqualToString:getCloudKitCKErrorDomain()]
    || [*(id *)(*(void *)&buf[8] + 40) code] != 9)
  {
    unint64_t v59 = (void *)MEMORY[0x186E3E5D8]();
    uint64_t v60 = __ckLoggingOverride;
    uint64_t v61 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Identity fetch failed with unknown error: %@"];
    _NSCoreDataLog( v60 != 0,  v61,  v62,  v63,  v64,  v65,  v66,  v67,  (uint64_t)"-[PFCloudKitSetupAssistant _checkUserIdentity:]");
    objc_autoreleasePoolPop(v59);
    uint64_t v57 = *(void **)(*(void *)&buf[8] + 40LL);
    if (!v57)
    {
      uint64_t v113 = [NSString stringWithUTF8String:"Identity fetch failed but did not set an error."];
      _NSCoreDataLog(17LL, v113, v114, v115, v116, v117, v118, v119, v225);
      int v120 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v246 = 0;
        _os_log_fault_impl( &dword_186681000,  v120,  OS_LOG_TYPE_FAULT,  "CoreData: Identity fetch failed but did not set an error.",  v246,  2u);
      }

      unint64_t v121 = (void *)MEMORY[0x189607870];
      uint64_t v122 = *(void *)(*(void *)&buf[8] + 40LL);
      if (v122)
      {
        *(void *)v272 = *MEMORY[0x189607798];
        *(void *)v246 = v122;
        unint64_t v123 = [MEMORY[0x189603F68] dictionaryWithObjects:v246 forKeys:v272 count:1];
      }

      else
      {
        unint64_t v123 = 0LL;
      }

      unsigned int v68 = (__CFString *)[v121 errorWithDomain:*MEMORY[0x189607460] code:134400 userInfo:v123];
      goto LABEL_54;
    }

        if ([a2 objectForKey:@"NSUnderlyingException"]) {
          return 0LL;
        }
        uint64_t v16 = (void *)MEMORY[0x189603F70];
        uint64_t v17 = *MEMORY[0x189603A60];
        os_log_type_t v18 = [NSString stringWithFormat:@"Unsupported expression %@", *(void *)(a1 + 16)];
        goto LABEL_10;
      }

      if (objc_msgSend(@"distinct:", "isEqual:", objc_msgSend(v20, "function")))
      {
        uint64_t v31 = -[NSSQLExpressionIntermediate initWithExpression:allowToMany:inScope:]( objc_alloc(&OBJC_CLASS___NSSQLFunctionExpressionIntermediate),  "initWithExpression:allowToMany:inScope:",  v20,  1LL,  a1);
        uint64_t v29 = -[NSSQLFunctionExpressionIntermediate generateSQLStringInContext:](v31, "generateSQLStringInContext:", a2);

        if (!v29)
        {
          if ([a2 objectForKey:@"NSUnderlyingException"]) {
            return 0LL;
          }
          uint64_t v16 = (void *)MEMORY[0x189603F70];
          uint64_t v17 = *MEMORY[0x189603A60];
          os_log_type_t v18 = [NSString stringWithFormat:@"Unable to generate SQL for expression: %@", *(void *)(a1 + 16)];
          goto LABEL_10;
        }

        __int16 v30 = CFSTR("COUNT (");
LABEL_41:
        unsigned int v15 = (id)-[__CFString mutableCopy](v30, "mutableCopy");
        [v15 appendString:v29];

        [v15 appendString:@""]);
        return (uint64_t)v15;
      }
    }

    else if (v21 == 13)
    {
      os_log_type_t v25 = (void *)[(id)objc_opt_class() _newKeyPathExpressionForString:@".@count"];
      uint64_t v26 = -[NSSQLSubqueryExpressionIntermediate initWithExpression:trailingKeypath:inScope:]( objc_alloc(&OBJC_CLASS___NSSQLSubqueryExpressionIntermediate),  "initWithExpression:trailingKeypath:inScope:",  v20,  v25,  *(void *)(a1 + 8));

      unsigned int v15 = -[NSSQLSubqueryExpressionIntermediate generateSQLStringInContext:](v26, "generateSQLStringInContext:", a2);
      if (v15) {
        return (uint64_t)v15;
      }
      goto LABEL_42;
    }

    CFStringRef v4 = (void *)MEMORY[0x189603F70];
    int v5 = *MEMORY[0x189603A60];
    uint64_t v6 = [NSString stringWithFormat:@"Unsupported function expression : %@", *(void *)(a1 + 16)];
    id v8 = [MEMORY[0x189603F68] dictionaryWithObject:*(void *)(a1 + 16) forKey:@"Bad value"];
LABEL_5:
    uint64_t v9 = v8;
    uint64_t v10 = v4;
    uint64_t v11 = v5;
    uint64_t v12 = (const __CFString *)v6;
LABEL_13:
    objc_msgSend( a2,  "setObject:forKey:",  objc_msgSend(v10, "exceptionWithName:reason:userInfo:", v11, v12, v9),  @"NSUnderlyingException");
    return 0LL;
  }

  return -[NSSQLFunctionExpressionIntermediate _generateCorrelatedSubqueryStringWithSymbol:forExpression:inContext:]( (void *)a1,  (uint64_t)@"count",  v20,  a2);
}

  if ((v26 & 1) == 0)
  {

    if (v27)
    {
      uint64_t v63 = *MEMORY[0x189607798];
      char v64 = v27;
      int v42 = [MEMORY[0x189603F68] dictionaryWithObjects:&v64 forKeys:&v63 count:1];
      goto LABEL_65;
    }

  id v33 = v8;
  uint64_t v35 = v63;
  unint64_t v34 = v64;
  while (v33)
  {
    unint64_t v36 = v33;
    id v33 = (_DWORD *)*((void *)v33 + 21);
    if (v33 == v36)
    {
      uint64_t v37 = (void *)*((void *)v36 + 9);
      goto LABEL_46;
    }
  }

  uint64_t v37 = 0LL;
LABEL_46:
  uint64_t v38 = [v37 count];
  if (v38 == [v6 count])
  {
    uint64_t v39 = [v6 count];
    if (v39 != [v7 count])
    {
      int v40 = (void *)MEMORY[0x189603F70];
      int v41 = [MEMORY[0x189603F68] dictionaryWithObject:v8 forKey:@"entity"];
      int v42 = *MEMORY[0x189603A58];
      int v43 = @"Mismatched columns and values in migration insert statement";
      goto LABEL_50;
    }

    goto LABEL_52;
  }

  int v40 = (void *)MEMORY[0x189603F70];
  int v41 = [MEMORY[0x189603F68] dictionaryWithObject:v8 forKey:@"entity"];
  int v42 = *MEMORY[0x189603A58];
  int v43 = @"Wrong number of columns in migration insert statement";
LABEL_50:
  uint64_t v32 = (void *)[v40 exceptionWithName:v42 reason:v43 userInfo:v41];
  if (v32)
  {
LABEL_51:
    unsigned int v44 = 0LL;
  }

  else
  {
LABEL_52:
    uint64_t v62 = [v6 componentsJoinedByString:@","];
    int v66 = -[_NSSQLTableMigrationDescription _sourceRootTableNameInMigrationContext:](v63, v64);
    uint64_t v45 = 0x189607000uLL;
    if (v9 && (*(void *)(v9 + 160) || (uint64_t v56 = *(void **)(v9 + 152)) != 0 && [v56 count]))
    {
      uint64_t v46 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:@" WHERE "];
      [v46 appendString:v66];
      [v46 appendString:@"."];
      [v46 appendString:@"Z_ENT"];
      [v46 appendString:@" = "];
      uint64_t v47 = objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v8, "entityDescription"), "userInfo"),  "objectForKey:",  @"NSEntityRenamingShouldRebaseKey");
      if (!v47) {
        goto LABEL_70;
      }
      uint64_t v70 = 0u;
      int v71 = 0u;
      unsigned int v68 = 0u;
      int v69 = 0u;
      uint32_t v48 = *(void **)(v9 + 152);
      uint64_t v49 = [v48 countByEnumeratingWithState:&v68 objects:v76 count:16];
      if (!v49) {
        goto LABEL_70;
      }
      id v50 = 0LL;
      uint64_t v51 = *(void *)v69;
      do
      {
        for (uint64_t i = 0LL; i != v49; ++i)
        {
          if (*(void *)v69 != v51) {
            objc_enumerationMutation(v48);
          }
          if (!(_DWORD)v50)
          {
            uint64_t v53 = *(unsigned int **)(*((void *)&v68 + 1) + 8 * i);
            uint64_t v54 = objc_msgSend((id)objc_msgSend(v53, "name"), "isEqualToString:", v47);
            if (v53) {
              uint64_t v55 = v54;
            }
            else {
              uint64_t v55 = 0;
            }
            if (v55 == 1) {
              id v50 = v53[46];
            }
            else {
              id v50 = 0LL;
            }
          }
        }

        uint64_t v49 = [v48 countByEnumeratingWithState:&v68 objects:v76 count:16];
      }

      while (v49);
      uint64_t v45 = 0x189607000LL;
      if (!(_DWORD)v50) {
LABEL_70:
      }
        id v50 = *(unsigned int *)(v9 + 184);
      objc_msgSend(v46, "appendFormat:", @"%d", v50);
      uint64_t v35 = v63;
      unint64_t v34 = v64;
    }

    else
    {
      uint64_t v46 = 0LL;
    }

    uint64_t v57 = [v7 componentsJoinedByString:@","];
    unint64_t v58 = v66;
    unint64_t v59 = (void *)[objc_alloc(*(Class *)(v45 + 2368)) initWithString:@"INSERT INTO "];
    objc_msgSend(v59, "appendString:", objc_msgSend(*(id *)(v35 + 8), "tableName"));
    objc_msgSend(v59, "appendString:", @" (");
    [v59 appendString:v62];
    [v59 appendString:@" SELECT "]);
    [v59 appendString:v57];
    [v59 appendString:@" FROM "];
    [v59 appendString:v58];
    if (v46)
    {
      [v59 appendString:v46];
    }

    if (v34) {
      uint64_t v60 = *(NSSQLiteStatement **)(v34 + 32);
    }
    else {
      uint64_t v60 = 0LL;
    }
    unsigned int v44 = -[NSSQLiteAdapter newStatementWithSQLString:](v60, (uint64_t)v59);
    -[NSSQLiteAdapter _useModel:]((uint64_t)v44, v67);

    uint64_t v32 = 0LL;
  }

  if (v32)
  {

    objc_exception_throw(v32);
    __break(1u);
  }

  return v44;
}
          }

          if ((v30 & 1) == 0) {
            objc_msgSend(v28, "appendString:", @" , ");
          }
          [v28 appendString:v32];
          id v33 = v28;
          unint64_t v34 = @" = NULL";
LABEL_41:
          [v33 appendString:v34];
          __int16 v30 = 0;
          goto LABEL_42;
        }

void sub_1866D12B0(_Unwind_Exception *a1)
{
}

void sub_1866D17BC(_Unwind_Exception *a1)
{
}

void sub_1866D1BC8( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
  if (a2 == 1)
  {
    id v28 = objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1866D1B08LL);
  }

  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 120), 8);
  _Unwind_Resume(exc_buf);
}

void sub_1866D1C24()
{
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

LABEL_412:
      if (self)
      {
        self->_messageCode = v681;
        objc_setProperty_nonatomic(self, v680, v39, 24LL);
      }

      if (v742) {
        v742 = (char *) +[_NSXPCStoreUtilities newSecureArchivedDataWithRootObject:]( (uint64_t)&OBJC_CLASS____NSXPCStoreUtilities,  (uint64_t)v742);
      }
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog(8LL, (uint64_t)@"Sending reply %p, %p", v682, v683, v684, v685, v686, v687, (uint64_t)self);
      }
      v688 = v742;
      [(id)a1[6] reset];

      [v733 drain];
      v689 = objc_alloc_init(MEMORY[0x1896077E8]);
      (*(void (**)(void))(a1[11] + 16))();
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog(8LL, (uint64_t)@"Sent reply", v690, v691, v692, v693, v694, v695, v724);
      }

      [v689 drain];
      v742 = 0LL;
      return;
    case 0xCLL:
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog(8LL, (uint64_t)@"Batch delete", v71, v72, v73, v74, v75, v76, v724);
      }
      uint64_t v77 = a1[5];
      if (v77) {
        uint64_t v78 = *(void *)(v77 + 24);
      }
      else {
        uint64_t v78 = 0LL;
      }
      uint64_t v79 = v734[8];
      if (!v79) {
        goto LABEL_324;
      }
      uint64_t v80 = v734[7];
      v781 = 0LL;
      uint64_t v81 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v82 = +[NSBatchDeleteRequest decodeFromXPCArchive:withContext:withPolicy:]( &OBJC_CLASS___NSBatchDeleteRequest,  "decodeFromXPCArchive:withContext:withPolicy:",  v78,  v80,  *(void *)(v79 + 64));
      if (v82)
      {
        uint64_t v88 = (id)[*(id *)(v79 + 64) processRequest:v82 fromClientWithContext:v80 error:&v781];
        if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
          _NSCoreDataLog(8LL, (uint64_t)@"Which had result %@", v89, v90, v91, v92, v93, v94, (uint64_t)v88);
        }
        if (v88) {
          uint64_t v88 = +[_NSXPCStoreUtilities newSecureArchivedDataWithRootObject:]( (uint64_t)_NSXPCStoreUtilities,  [v88 result]);
        }
      }

      else
      {
        _NSCoreDataLog(8LL, (uint64_t)@"Nil batch delete request", 0LL, v83, v84, v85, v86, v87, v724);
        uint64_t v88 = 0LL;
      }

      v593 = v781;
      objc_autoreleasePoolPop(v81);
      if (v781) {
        v742 = (char *)v781;
      }
      goto LABEL_332;
    case 0xDLL:
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog(8LL, (uint64_t)@"Persistent history", v261, v262, v263, v264, v265, v266, v724);
      }
      v267 = a1[5];
      if (v267) {
        v268 = *(void *)(v267 + 24);
      }
      else {
        v268 = 0LL;
      }
      v269 = v734[8];
      if (!v269) {
        goto LABEL_324;
      }
      v270 = v734[7];
      v781 = 0LL;
      v271 = (void *)MEMORY[0x186E3E5D8]();
      v272 = +[NSPersistentHistoryChangeRequest decodeFromXPCArchive:withContext:withPolicy:]( &OBJC_CLASS___NSPersistentHistoryChangeRequest,  "decodeFromXPCArchive:withContext:withPolicy:",  v268,  v270,  *(void *)(v269 + 64));
      if (v272)
      {
        uint64_t v88 = (id)[*(id *)(v269 + 64) processRequest:v272 fromClientWithContext:v270 error:&v781];
        if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
          _NSCoreDataLog(8LL, (uint64_t)@"Which had result %@", v278, v279, v280, v281, v282, v283, (uint64_t)v88);
        }
        if (v88) {
          uint64_t v88 = +[_NSXPCStoreUtilities newSecureArchivedDataWithRootObject:]( (uint64_t)_NSXPCStoreUtilities,  [v88 result]);
        }
      }

      else
      {
        _NSCoreDataLog(8LL, (uint64_t)@"Nil persistent history request", 0LL, v273, v274, v275, v276, v277, v724);
        uint64_t v88 = 0LL;
      }

      v595 = v781;
      objc_autoreleasePoolPop(v271);
      if (v781) {
        v742 = (char *)v781;
      }
LABEL_332:
      v594 = v781;
      v332 = v88;
      goto LABEL_403;
    case 0xELL:
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog(8LL, (uint64_t)@"Persistent history token", v95, v96, v97, v98, v99, v100, v724);
      }
      uint64_t v101 = a1[5];
      if (v101) {
        unint64_t v102 = *(void *)(v101 + 24);
      }
      else {
        unint64_t v102 = 0LL;
      }
      if (!a1[8]) {
        goto LABEL_445;
      }
      unint64_t v103 = (void *)a1[7];
      unint64_t v104 = (void *)MEMORY[0x186E3E5D8]();
      __int16 v105 = (void *)[v103 persistentStoreCoordinator];
      uint64_t v106 = (void *)MEMORY[0x189604010];
      uint64_t v107 = objc_opt_class();
      v724 = objc_opt_class();
      v726 = 0LL;
      int v108 = (void *)+[_NSXPCStoreUtilities decodeSecureArchivedData:usingDelegate:classes:]( (uint64_t)_NSXPCStoreUtilities,  v102,  (uint64_t)v103,  [v106 setWithObjects:v107]);
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog( 8LL,  (uint64_t)@"Server received history token payload - %@",  v109,  v110,  v111,  v112,  v113,  v114,  (uint64_t)v108);
      }
      if (![v108 count]) {
        goto LABEL_276;
      }
      uint64_t v115 = (void *)objc_msgSend(MEMORY[0x189603FA8], "arrayWithCapacity:", objc_msgSend(v108, "count"));
      v779 = 0u;
      v780 = 0u;
      v777 = 0u;
      v778 = 0u;
      int v116 = (void *)[v105 persistentStores];
      int v117 = [v116 countByEnumeratingWithState:&v777 objects:&v781 count:16];
      if (v117)
      {
        int v118 = *(void *)v778;
        do
        {
          for (kuint64_t k = 0LL; kk != v117; ++kk)
          {
            if (*(void *)v778 != v118) {
              objc_enumerationMutation(v116);
            }
            int v120 = *(void **)(*((void *)&v777 + 1) + 8 * kk);
          }

          int v117 = [v116 countByEnumeratingWithState:&v777 objects:&v781 count:16];
        }

        while (v117);
      }

      if ([v115 count]) {
        unint64_t v121 = (void *)[v105 currentPersistentHistoryTokenFromStores:v115];
      }
      else {
LABEL_276:
      }
        unint64_t v121 = 0LL;
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog( 8LL,  (uint64_t)@"Server sending back historyToken %@",  v488,  v489,  v490,  v491,  v492,  v493,  (uint64_t)v121);
      }
      v494 = +[_NSXPCStoreUtilities newSecureArchivedDataWithRootObject:]( (uint64_t)_NSXPCStoreUtilities,  [v121 storeTokens]);
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog( 8LL,  (uint64_t)@"Server historyToken archived to %@",  v495,  v496,  v497,  v498,  v499,  v500,  (uint64_t)v494);
      }
      objc_autoreleasePoolPop(v104);
      v501 = 0LL;
      v332 = v494;
      goto LABEL_403;
    case 0xFLL:
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog(8LL, (uint64_t)@"Batch update", v47, v48, v49, v50, v51, v52, v724);
      }
      uint64_t v53 = a1[5];
      if (v53) {
        uint64_t v54 = *(void *)(v53 + 24);
      }
      else {
        uint64_t v54 = 0LL;
      }
      uint64_t v55 = v734[8];
      if (!v55) {
        goto LABEL_445;
      }
      uint64_t v56 = v734[7];
      v781 = 0LL;
      uint64_t v57 = (void *)MEMORY[0x186E3E5D8]();
      unint64_t v58 = +[NSBatchUpdateRequest decodeFromXPCArchive:withContext:withPolicy:]( &OBJC_CLASS___NSBatchUpdateRequest,  "decodeFromXPCArchive:withContext:withPolicy:",  v54,  v56,  *(void *)(v55 + 64));
      if (v58)
      {
        char v64 = (id)[*(id *)(v55 + 64) processRequest:v58 fromClientWithContext:v56 error:&v781];
        if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
          _NSCoreDataLog(8LL, (uint64_t)@"Which had result %@", v65, v66, v67, v68, v69, v70, (uint64_t)v64);
        }
        if (v64) {
          char v64 = +[_NSXPCStoreUtilities newSecureArchivedDataWithRootObject:]( (uint64_t)_NSXPCStoreUtilities,  [v64 result]);
        }
      }

      else
      {
        _NSCoreDataLog(8LL, (uint64_t)@"Nil batch update request", 0LL, v59, v60, v61, v62, v63, v724);
        v588 = (void *)MEMORY[0x189607870];
        v776[0] = *(id *)MEMORY[0x1896075F0];
        *(void *)&v777 = @"Unable to decode request, ensure policy allows for updated class values";
        v589 = [MEMORY[0x189603F68] dictionaryWithObjects:&v777 forKeys:v776 count:1];
        v590 = (__CFString *)[v588 errorWithDomain:*MEMORY[0x189607460] code:134070 userInfo:v589];
        char v64 = 0LL;
        v781 = v590;
      }

      v591 = v781;
      objc_autoreleasePoolPop(v57);
      if (v781) {
        v742 = (char *)v781;
      }
      goto LABEL_328;
    case 0x10LL:
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog(8LL, (uint64_t)@"Batch insert", v365, v366, v367, v368, v369, v370, v724);
      }
      v371 = a1[5];
      if (v371) {
        v372 = *(void *)(v371 + 24);
      }
      else {
        v372 = 0LL;
      }
      v373 = v734[8];
      if (!v373) {
        goto LABEL_445;
      }
      v374 = v734[7];
      v781 = 0LL;
      v375 = (void *)MEMORY[0x186E3E5D8]();
      v376 = +[NSBatchInsertRequest decodeFromXPCArchive:withContext:withPolicy:]( &OBJC_CLASS___NSBatchInsertRequest,  "decodeFromXPCArchive:withContext:withPolicy:",  v372,  v374,  *(void *)(v373 + 64));
      if (v376)
      {
        char v64 = (id)[*(id *)(v373 + 64) processRequest:v376 fromClientWithContext:v374 error:&v781];
        if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
          _NSCoreDataLog(8LL, (uint64_t)@"Which had result %@", v382, v383, v384, v385, v386, v387, (uint64_t)v64);
        }
        if (v64) {
          char v64 = +[_NSXPCStoreUtilities newSecureArchivedDataWithRootObject:]( (uint64_t)_NSXPCStoreUtilities,  [v64 result]);
        }
      }

      else
      {
        _NSCoreDataLog(8LL, (uint64_t)@"Nil batch insert request", 0LL, v377, v378, v379, v380, v381, v724);
        v596 = (void *)MEMORY[0x189607870];
        v776[0] = *(id *)MEMORY[0x1896075F0];
        *(void *)&v777 = @"Unable to decode request, ensure policy allows for inserted class values";
        v597 = [MEMORY[0x189603F68] dictionaryWithObjects:&v777 forKeys:v776 count:1];
        v598 = (__CFString *)[v596 errorWithDomain:*MEMORY[0x189607460] code:134070 userInfo:v597];
        char v64 = 0LL;
        v781 = v598;
      }

      v599 = v781;
      objc_autoreleasePoolPop(v375);
      if (v781) {
        v742 = (char *)v781;
      }
LABEL_328:
      v592 = v781;
      v332 = v64;
      goto LABEL_403;
    case 0x11LL:
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog( 8LL,  (uint64_t)@"Query generation active connections",  v388,  v389,  v390,  v391,  v392,  v393,  v724);
      }
      if (!a1[8])
      {
LABEL_324:
        uint64_t v39 = 0LL;
        goto LABEL_404;
      }

      v394 = (void *)a1[7];
      v340 = (void *)MEMORY[0x186E3E5D8]();
      v395 = (void *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v394, "persistentStoreCoordinator"), "persistentStores"),  "lastObject");
      if (v395)
      {
        v402 = (void *)objc_msgSend(MEMORY[0x189607968], "numberWithBool:", objc_msgSend(v395, "_hasActiveGenerations"));
      }

      else
      {
        _NSCoreDataLog(8LL, (uint64_t)@"no store", v396, v397, v398, v399, v400, v401, v724);
        v402 = &unk_189F04170;
      }

      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        _NSCoreDataLog( 8LL,  (uint64_t)@"Got active connections %@",  v600,  v601,  v602,  v603,  v604,  v605,  (uint64_t)v402);
      }
      v358 = +[_NSXPCStoreUtilities newSecureArchivedDataWithRootObject:]( (uint64_t)&OBJC_CLASS____NSXPCStoreUtilities,  (uint64_t)v402);
      if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault")) {
        goto LABEL_400;
      }
      goto LABEL_401;
    default:
      goto LABEL_28;
  }

void sub_1866D4A0C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    if (a2 != 4)
    {
      objc_begin_catch(a1);
      JUMPOUT(0x1866D4340LL);
    }

    id v2 = objc_begin_catch(a1);
    objc_exception_rethrow();
    JUMPOUT(0x1866D4940LL);
  }

  _Unwind_Resume(a1);
}

void sub_1866D525C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866D522CLL);
  }

  JUMPOUT(0x1866D4F90LL);
}

LABEL_2:
  if (self->_count <= a3)
  {
    [MEMORY[0x189603F70] raise:*MEMORY[0x189603B40], @"%@: index (%lu) beyond bounds (%lu)", _NSMethodExceptionProem(), a3, self->_count format];
    return 0LL;
  }

  if (!resultSet->var5)
  {
    uint64_t v12 = 0LL;
LABEL_19:
    uint64_t v14 = (unsigned int *)resultSet->var9[v12];
    goto LABEL_20;
  }

  uint64_t v12 = 0LL;
  unint64_t v13 = 0LL;
  while (1)
  {
    uint64_t v14 = (unsigned int *)resultSet->var9[v12];
    unsigned int v15 = *v14;
    v13 += v15;
LABEL_9:
  }

  if (v15 < (int)a3 - (int)v13)
  {
    _NSCoreDataLog(1LL, (uint64_t)@"Index beyond buffer: %ld, %ld, %ld, %ld", a3, v3, v4, v5, v6, v7, v12);
    resultSet = self->_resultSet;
    goto LABEL_9;
  }

  uint64_t v23 = a3 - v13;
  if (a3 == v13)
  {
LABEL_20:
    uint64_t v20 = 8LL;
    goto LABEL_21;
  }

  id v24 = v14[1];
  uint64_t v20 = 8LL;
  do
  {
    v20 += *(unsigned int *)((char *)v14 + v24);
    v24 += 4LL;
    --v23;
  }

  while (v23);
LABEL_21:
  uint64_t v19 = (char *)v14 + v20;
  if (!*(void *)((char *)v14 + v20))
  {
    uint64_t v21 = (objc_class *)objc_opt_class();
    object_setClass(v19, v21);
  }

  [v19 _setParentBuffer:self];
  return v19;
}

  if ([v11 count]
    && (int v66 = 0u,
        int v67 = 0u,
        char v64 = 0u,
        int v65 = 0u,
        (unint64_t v13 = [v11 countByEnumeratingWithState:&v64 objects:v77 count:16]) != 0))
  {
    uint64_t v14 = v13;
    unsigned int v15 = *(void *)v65;
    unint64_t v58 = a5;
    unint64_t v59 = v12;
    do
    {
      uint64_t v16 = 0LL;
      do
      {
        if (*(void *)v65 != v15) {
          objc_enumerationMutation(v11);
        }
        uint64_t v17 = *(void **)(*((void *)&v64 + 1) + 8 * v16);
        if (!self->_onlyCompareSharedZones
          || objc_msgSend( v63,  "containsObject:",  objc_msgSend(*(id *)(*((void *)&v64 + 1) + 8 * v16), "zoneID"))
          && objc_msgSend(v60, "containsObject:", objc_msgSend(v17, "zoneID")))
        {
          os_log_type_t v18 = -[PFCloudKitStoreComparer getObjectMatchingRecordID:fromStore:withManagedObjectContext:]( self,  "getObjectMatchingRecordID:fromStore:withManagedObjectContext:",  v17,  a3,  -[PFCloudKitStoreComparisonCache storeMoc](self->_cache, "storeMoc"));
          uint64_t v19 = (id)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v18, "entity"), "relationshipsByName"),  "allValues");
          if (!v18)
          {
            uint64_t v39 = (void *)MEMORY[0x189607870];
            int v40 = *MEMORY[0x189607460];
            int v69 = *MEMORY[0x1896075F0];
            uint64_t v70 = [NSString stringWithFormat:@"Failed to retrieve object with recordID '%@' from store %@", v17, a3];
            unsigned int v68 = (void *)objc_msgSend( v39,  "errorWithDomain:code:userInfo:",  v40,  134060,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v70, &v69, 1));
            a5 = v58;
            goto LABEL_37;
          }

          uint64_t v20 = -[PFCloudKitStoreComparer getObjectMatchingRecordID:fromStore:withManagedObjectContext:]( self,  "getObjectMatchingRecordID:fromStore:withManagedObjectContext:",  v17,  v61,  -[PFCloudKitStoreComparisonCache otherStoreMoc](self->_cache, "otherStoreMoc"));
          if (!v20)
          {
            int v41 = (void *)MEMORY[0x189607870];
            int v42 = *MEMORY[0x189607460];
            int v71 = *MEMORY[0x1896075F0];
            int v72 = [NSString stringWithFormat:@"Failed to retrieve object with recordID '%@' from store %@", v17, v61];
            unsigned int v68 = (void *)objc_msgSend( v41,  "errorWithDomain:code:userInfo:",  v42,  134060,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v72, &v71, 1));
LABEL_35:

            a5 = v58;
            goto LABEL_36;
          }

          uint64_t v21 = [v18 entity];
          if (v21) {
            uint64_t v22 = *(void *)(v21 + 160);
          }
          else {
            uint64_t v22 = 0LL;
          }
          uint64_t v23 = [v20 entity];
          if (v23) {
            id v24 = *(void *)(v23 + 160);
          }
          else {
            id v24 = 0LL;
          }
          if (v22 != v24)
          {
            os_log_type_t v25 = [NSString stringWithUTF8String:"Objects appear to be from different entities:\nStore: %@\nOther Store: %@"];
            _NSCoreDataLog(17LL, v25, v26, v27, v28, v29, v30, v31, (uint64_t)v18);
            uint64_t v32 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412546;
              int v74 = (const char *)v18;
              unsigned int v75 = 2112;
              int v76 = v20;
              _os_log_fault_impl( &dword_186681000,  v32,  OS_LOG_TYPE_FAULT,  "CoreData: Objects appear to be from different entities:\nStore: %@\nOther Store: %@",  buf,  0x16u);
            }
          }

          if (!-[PFCloudKitStoreComparer compareAttributesOnObject:toObject:error:]( self,  "compareAttributesOnObject:toObject:error:",  v18,  v20,  &v68)) {
            goto LABEL_35;
          }
          id v33 = -[PFCloudKitStoreComparer compareRelationshipsOfRecordID:withStoreObject:andOtherObject:error:]( self,  "compareRelationshipsOfRecordID:withStoreObject:andOtherObject:error:",  v17,  v18,  v20,  &v68);

          uint64_t v11 = v62;
          if (!v33)
          {
            uint64_t v35 = 0;
            a5 = v58;
            goto LABEL_38;
          }
        }

        ++v16;
      }

      while (v14 != v16);
      unint64_t v34 = [v11 countByEnumeratingWithState:&v64 objects:v77 count:16];
      uint64_t v14 = v34;
      uint64_t v35 = 1;
      a5 = v58;
      uint64_t v12 = v59;
    }

    while (v34);
  }

  else
  {
    uint64_t v35 = 1;
  }

LABEL_55:
          uint64_t v46 = (CFStringRef)[MEMORY[0x189607968] numberWithInt:*v34];
          goto LABEL_105;
        }

        if (v41 <= 1099)
        {
          if (v41 == 800) {
            goto LABEL_55;
          }
          if (v41 == 900)
          {
            uint64_t v93 = (__CFString *)CFDateCreate(0LL, *(CFAbsoluteTime *)v34);
            goto LABEL_122;
          }

          if (v41 != 1000) {
            goto LABEL_45;
          }
        }

        else
        {
          if (v41 <= 1799)
          {
            if (v41 != 1100)
            {
              if (v41 == 1200)
              {
                else {
                  unsigned int v44 = -[_PFResultObject taggedStringFromPtr:withLength:]((CFStringRef)self, (char *)v34);
                }
                id v94 = v44;
                uint64_t v95 = (objc_class *)MEMORY[0x189604030];
LABEL_118:
                uint64_t v93 = (__CFString *)[[v95 alloc] initWithString:v94];
                goto LABEL_122;
              }

      uint64_t v35 = -[NSManagedObjectContext _retainedObjectWithID:optionalHandler:withInlineStorage:](v38, v32, 0LL);
LABEL_58:
      [v42 setValue:v35 forKey:*(void *)(v15 + 8 * v26)];
      [v41 setValue:v35 atIndex:v26];

      id v28 = v39;
LABEL_59:
      ++v26;
      if (!--v27) {
        goto LABEL_60;
      }
    }

  unint64_t v58 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
  _NSCoreDataLog( 17LL,  v58,  v59,  v60,  v61,  v62,  v63,  v64,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentStoreCoordinator.m");
  int v65 = (os_log_s *)__pflogFaultLog;
  uint64_t v10 = v142;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int v166 = 136315394;
    uint64_t v167 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentStoreCoordinator.m";
    v168 = 1024;
    __int128 v169 = 6580;
    _os_log_fault_impl( &dword_186681000,  v65,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v166,  0x12u);
  }

                  [v25 addObject:v20];
                  unint64_t v13 = v49;
                }

                goto LABEL_57;
              }

              uint64_t v20 = v18;
              if (v18)
              {
                v18->_changeType = 2LL;
                objc_setProperty_nonatomic(v18, v19, newValue, 24LL);
              }

              id v24 = (void *)objc_msgSend( *(id *)(v12 + 104),  "objectAtIndex:",  objc_msgSend(newValue, "indexAtPosition:", 0));
              if (v20) {
                objc_setProperty_nonatomic(v20, v23, v24, 40LL);
              }
              os_log_type_t v25 = a4;
              if ((*(_BYTE *)(v12 + 72) & 8) != 0)
              {
                uint64_t v26 = -[_NSDefaultSectionInfo sectionNumber]((uint64_t)v24);
                if (v24) {
                  v24[6] = v26;
                }
                objc_msgSend(a6, "setObject:forKey:", v24, objc_msgSend(v24, "name"));
                os_log_type_t v25 = a4;
              }

              goto LABEL_55;
            }
          }

  unsigned int v44 = [a3 valueForKey:@"NSPersistentStoreFileProtectionKey"];
  uint64_t v99 = (__CFString *)v20;
  if (v44)
  {
    uint64_t v45 = v44;
    if ([(id)*MEMORY[0x189607538] isEqualToString:v44])
    {
      uint64_t v46 = v7;
      v22 |= 0x400000u;
    }

    else if ([(id)*MEMORY[0x189607518] isEqualToString:v45])
    {
      uint64_t v46 = v7;
      v22 |= 0x300000u;
    }

    else
    {
      uint64_t v46 = v7;
      if ([(id)*MEMORY[0x189607510] isEqualToString:v45])
      {
        v22 |= 0x200000u;
      }

      else if ([(id)*MEMORY[0x189607508] isEqualToString:v45])
      {
        v22 |= 0x100000u;
      }

      else if ([(id)*MEMORY[0x189607528] isEqualToString:v45])
      {
        v22 |= 0x700000u;
      }

      else
      {
        _NSCoreDataLog( 1LL,  (uint64_t)@"Unrecognized value '%@' passed into options for NSPersistentStoreFileProtectionKey",  v47,  v48,  v49,  v50,  v51,  v52,  v45);
      }
    }
  }

  else
  {
    uint64_t v46 = v7;
  }

  unint64_t v104 = 0LL;
  if (objc_msgSend((id)objc_msgSend(v103, "query"), "length"))
  {
    objc_opt_self();
    id v8 = (const char *)objc_msgSend((id)objc_msgSend(v103, "absoluteString"), "fileSystemRepresentation");
  }

  uint64_t v53 = -6;
  do
  {
    uint64_t v54 = +[NSSQLCore databaseKeyFromOptionsDictionary:]((uint64_t)&OBJC_CLASS___NSSQLCore, a3);
    uint64_t v55 = +[NSSQLiteConnection openAtPath:withKey:handle:flags:module:checkpointOnClose:]( (uint64_t)&OBJC_CLASS___NSSQLiteConnection,  v8,  v54,  &v104,  v22,  1);
    if (v55 != 14) {
      break;
    }
    if (v104)
    {
      sqlite3_close_v2(v104);
      unint64_t v104 = 0LL;
    }

    usleep(0x4E20u);
  }

  while (!__CFADD__(v53++, 1));
  uint64_t v57 = (void *)[a3 objectForKey:@"NSPersistentStoreForceDestroyOption"];
  if (v57) {
    unint64_t v58 = [v57 BOOLValue];
  }
  else {
    unint64_t v58 = 1;
  }
  unint64_t v59 = v15 | v58;
  uint64_t v60 = v104;
  uint64_t v61 = v46;
  if (!v55)
  {
    sqlite3_busy_timeout(v104, 120000);
    int v108 = 0LL;
    uint64_t v62 = sqlite3_file_control(v60, 0LL, 7, &v108);
    if (!v108 || v62)
    {
LABEL_105:
      if (v99 && (-[__CFString isEqualToString:](v99, "isEqualToString:", @":auto:") & 1) == 0) {
        sqlite3_exec( v60,  (const char *)[(id)objc_msgSend( NSString stringWithFormat:@"pragma lock_proxy_file='%@'", v99), "UTF8String"],  0,  0,  0);
      }
      if (v59) {
        v105 |= 0x80u;
      }
      unsigned int v68 = -6;
      while (1)
      {
        int v69 = sqlite3_file_control(v60, 0LL, 101, &v105);
        if ((v69 & 0x7F) != 5)
        {
          uint64_t v55 = v69;
          if ((v69 & 0x7F) != 6) {
            goto LABEL_115;
          }
          usleep(0x4E20u);
        }

        uint64_t v55 = 5;
LABEL_115:
        if (v68)
        {
          ++v68;
          if (v55 == 5) {
            continue;
          }
        }

        goto LABEL_117;
      }
    }

    if (*(void *)v108)
    {
      uint64_t v63 = (*(uint64_t (**)(void))(*(void *)v108 + 16LL))();
      if (!v63)
      {
        int v66 = v111 == 2 && v112 == 2;
LABEL_103:
        if (v66 == 1) {
          v105 |= 1u;
        }
        goto LABEL_105;
      }
    }

    else
    {
      uint64_t v63 = 1;
    }

    uint64_t v107 = 0;
    int v67 = sqlite3_file_control(v60, 0LL, 4, &v107);
    if (v107)
    {
      int v66 = -1;
    }

    else if (v63 == 522)
    {
      int v66 = 0;
    }

    else if (v67)
    {
      int v66 = v67;
    }

    else
    {
      int v66 = -1;
    }

    goto LABEL_103;
  }

LABEL_56:
      uint64_t v1 = v149;
      goto LABEL_57;
    }

    uint64_t v52 = [v30 longLongValue];
    [*(id *)(v149 + 104) allKeys];
    _NSCoreDataLog( 1LL,  (uint64_t)@"Error: Persistent History (%lld) has to be truncated due to the following entities being removed: %@",  v53,  v54,  v55,  v56,  v57,  v58,  v52);
    uint64_t v145 = (NSSQLiteStatement *)[objc_alloc(NSString) initWithFormat:@"DELETE FROM %@ WHERE Z_PK <= %lld", objc_msgSend(v146, "tableName"), objc_msgSend(v30, "longLongValue")];
    id v143 = -[NSSQLiteAdapter newStatementWithSQLString:](*(NSSQLiteStatement **)(v149 + 32), (uint64_t)v145);
    unint64_t v59 = objc_alloc(NSString);
    uint64_t v60 = [v4 tableName];
    [v30 longLongValue];
    uint64_t v144 = (void *)[v59 initWithFormat:@"DELETE FROM %@ WHERE %@ <= %lld"];
    id v142 = -[NSSQLiteAdapter newStatementWithSQLString:](*(NSSQLiteStatement **)(v149 + 32), (uint64_t)v144);
    _NSCoreDataLog( 2LL,  (uint64_t)@"Warning: Dropping Indexes for Persistent History",  v61,  v62,  v63,  v64,  v65,  v66,  v60);
    int v67 = *(NSSQLiteStatement **)(v149 + 32);
    if (v67)
    {
      unsigned int v68 = -[NSSQLiteAdapter newDropIndexStatementsForEntity:defaultIndicesOnly:](v67, (uint64_t)v146, 0);
      int v69 = *(NSSQLiteStatement **)(v149 + 32);
      if (v69)
      {
        uint64_t v70 = -[NSSQLiteAdapter newDropIndexStatementsForEntity:defaultIndicesOnly:](v69, (uint64_t)v4, 0);
LABEL_42:
        uint64_t v152 = 0u;
        uint64_t v153 = 0u;
        int v150 = 0u;
        uint64_t v151 = 0u;
        int v71 = (void *)[v68 arrayByAddingObjectsFromArray:v70];
        uint64_t v78 = [v71 countByEnumeratingWithState:&v150 objects:v158 count:16];
        if (v78)
        {
          uint64_t v79 = *(void *)v151;
          do
          {
            for (uint64_t i = 0LL; i != v78; ++i)
            {
              if (*(void *)v151 != v79) {
                objc_enumerationMutation(v71);
              }
              uint64_t v81 = *(void **)(*((void *)&v150 + 1) + 8 * i);
              if (v148 >= 1) {
                _NSCoreDataLog( 4LL,  (uint64_t)@"Executing drop index from history statement: %@",  v72,  v73,  v74,  v75,  v76,  v77,  *(void *)(*((void *)&v150 + 1) + 8 * i));
              }
              -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(v149 + 48), v81);
            }

            uint64_t v78 = [v71 countByEnumeratingWithState:&v150 objects:v158 count:16];
          }

          while (v78);
        }

        uint64_t v82 = [v30 longLongValue];
        _NSCoreDataLog( 2LL,  (uint64_t)@"Warning: Dropping Transactions prior to %lld for Persistent History",  v83,  v84,  v85,  v86,  v87,  v88,  v82);
        if (v148 <= 0)
        {
          -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(v149 + 48), v143);
          int v108 = [v30 longLongValue];
          _NSCoreDataLog( 2LL,  (uint64_t)@"Warning: Dropping Changes prior to TransactionID %lld for Persistent History",  v109,  v110,  v111,  v112,  v113,  v114,  v108);
        }

        else
        {
          _NSCoreDataLog( 4LL,  (uint64_t)@"Executing mass delete of transactions from history statement: %@",  v89,  v90,  v91,  v92,  v93,  v94,  (uint64_t)v143);
          -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(v149 + 48), v143);
          uint64_t v95 = [v30 longLongValue];
          _NSCoreDataLog( 2LL,  (uint64_t)@"Warning: Dropping Changes prior to TransactionID %lld for Persistent History",  v96,  v97,  v98,  v99,  v100,  v101,  v95);
          _NSCoreDataLog( 4LL,  (uint64_t)@"Executing mass delete of changes from history statement: %@",  v102,  v103,  v104,  v105,  v106,  v107,  (uint64_t)v142);
        }

        -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(v149 + 48), v142);

        goto LABEL_55;
      }
    }

    else
    {
      unsigned int v68 = 0LL;
    }

    uint64_t v70 = 0LL;
    goto LABEL_42;
  }

  int v42 = (void *)MEMORY[0x186E3E5D8]();
  int v43 = __ckLoggingOverride != 0;
  unsigned int v44 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to write CKAsset data for '%@' on '%@' backing record '%@'.\n%@"];
  [*(id *)(a1 + 64) objectID];
  [*(id *)(a1 + 56) recordID];
  _NSCoreDataLog( v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  (uint64_t)"-[PFCloudKitSerializer newCKRecordsFromObject:fullyMaterializeRecords:includeRelationships:error:]_block_invoke_3");
  objc_autoreleasePoolPop(v42);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
  *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL) = v55;
LABEL_56:
  uint64_t v51 = *(void *)(a1 + 48);
  uint64_t v52 = -[PFCloudKitSerializer shouldEncryptValueForAttribute:](v51, *(void **)(a1 + 32));
  if (v51)
  {
    uint64_t v53 = v52;
    uint64_t v54 = *(void **)(a1 + 56);
    if (v53) {
      uint64_t v54 = (void *)[v54 encryptedValues];
    }
    [v54 setObject:v12 forKey:v3];
  }

    uint64_t v32 = 0LL;
    goto LABEL_34;
  }

LABEL_45:
              _NSCoreDataLog( 1LL,  (uint64_t)@"Unsupported type for buffer allocated dictionary: %@",  v35,  v36,  v37,  v38,  v39,  v40,  v41);
LABEL_46:
              uint64_t v45 = 0LL;
              goto LABEL_123;
            }

            goto LABEL_74;
          }

          if (v41 != 1800)
          {
            if (v41 != 2000) {
              goto LABEL_45;
            }
            goto LABEL_64;
          }
        }

                  if (!v14) {
                    return;
                  }
                  goto LABEL_46;
                }

                const char *v16 = 10LL;
                CFRelease(v25);
LABEL_43:
                uint64_t v17 = 10LL;
                goto LABEL_44;
              }
            }
          }

          else
          {
            const char *v16 = 10LL;
            CFRelease(v21);
          }
        }

        else
        {
          const char *v16 = 10LL;
        }

        const char *v16 = 10LL;
        goto LABEL_43;
      }

LABEL_74:
        uint64_t v54 = -[_PFResultObject dataFromPtr:]((uint64_t)self, v34);
        uint64_t v55 = v54;
        if (v41 != 1800)
        {
          if (v41 == 1100)
          {
            if ([v54 length] != 16) {
              goto LABEL_46;
            }
            uint64_t v93 = (__CFString *)objc_msgSend( objc_alloc(MEMORY[0x189607AB8]),  "initWithUUIDBytes:",  objc_msgSend(v55, "bytes"));
            goto LABEL_122;
          }

          if (([v17 _isFileBackedFuture] & 1) == 0
            && (![v17 _storeBinaryDataExternally] || (*(_BYTE *)&resultSet->var7 & 2) != 0))
          {
            uint64_t v93 = v55;
            goto LABEL_122;
          }

          uint64_t v56 = self->_parent_buffer;
          if (v56 && (uint64_t v57 = v56->_weakRequestStore) != 0LL) {
            unint64_t v58 = objc_loadWeakRetained(&v57->_object);
          }
          else {
            unint64_t v58 = 0LL;
          }
          if (*(_BYTE *)[v55 bytes] == 1)
          {
            unint64_t v59 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
            uint64_t v60 = [v55 bytes];
            uint64_t v61 = [v55 length];
            if (v58) {
              uint64_t v62 = (*((_DWORD *)v58 + 50) >> 2) & 7;
            }
            else {
              uint64_t v62 = 0LL;
            }
            uint64_t v63 = v59;
            char v64 = v60;
            int v65 = 0LL;
            int v66 = 0LL;
LABEL_134:
            uint64_t v97 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v63,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  v64,  v61,  v65,  v66,  v62);
            goto LABEL_135;
          }

          if (*(_BYTE *)[v55 bytes] == 3)
          {
            uint64_t v96 = objc_alloc(&OBJC_CLASS____NSDataFileBackedFuture);
            uint64_t v97 = -[_NSDataFileBackedFuture initWithStoreMetadata:directory:]( v96,  "initWithStoreMetadata:directory:",  v55,  objc_msgSend( MEMORY[0x189604030],  "fileURLWithPath:isDirectory:",  objc_msgSend(v58, "fileBackedFuturesDirectory"),  1));
            goto LABEL_135;
          }

          uint64_t v98 = (const char *)([v55 bytes] + 1);
          uint64_t v99 = objc_msgSend( (id)objc_msgSend(MEMORY[0x1896078A8], "defaultManager"),  "stringWithFileSystemRepresentation:length:",  v98,  strnlen(v98, objc_msgSend(v55, "length") - 1));
          uint64_t v100 = objc_msgSend( (id)objc_msgSend(v58, "externalDataReferencesDirectory"),  "stringByAppendingPathComponent:",  v99);
          if (v58)
          {
            unint64_t v102 = (void *)atomic_load((unint64_t *)v58 + 22);
            unint64_t v103 = [v102 stringByAppendingPathComponent:v99];
            if (objc_msgSend( (id)objc_msgSend(v58, "options"),  "objectForKey:",  @"NSPersistentStoreUbiquitousContentNameKey")
              && !objc_msgSend( (id)objc_msgSend(MEMORY[0x1896078A8], "defaultManager"),  "fileExistsAtPath:",  v100))
            {
              if (objc_msgSend( (id)objc_msgSend(v58, "options"),  "objectForKey:",  @"NSPersistentStoreUbiquitousContentNameKey")
                && !objc_msgSend( (id)objc_msgSend(MEMORY[0x1896078A8], "defaultManager"),  "fileExistsAtPath:",  v100))
              {
                uint64_t v45 = 0LL;
                goto LABEL_136;
              }

              uint64_t v97 = v55;
LABEL_135:
              uint64_t v45 = (__CFString *)v97;
LABEL_136:

              goto LABEL_123;
            }
          }

          else
          {
            unint64_t v103 = [0 stringByAppendingPathComponent:v99];
          }

          unint64_t v104 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
          __int16 v105 = [v55 bytes];
          uint64_t v61 = [v55 length];
          if (v58) {
            uint64_t v62 = (*((_DWORD *)v58 + 50) >> 2) & 7;
          }
          else {
            uint64_t v62 = 0LL;
          }
          uint64_t v63 = v104;
          char v64 = v105;
          int v65 = v100;
          int v66 = v103;
          goto LABEL_134;
        }

        uint64_t v93 = (__CFString *)+[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)&OBJC_CLASS____PFRoutines,  (uint64_t)v54,  v17);
LABEL_122:
        uint64_t v45 = v93;
        goto LABEL_123;
      }

      [v17 expression];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
LABEL_44:
        int v41 = 0LL;
        goto LABEL_45;
      }

  [v6 drain];
  return v22;
}

      uint64_t v49 = 0;
      int v182 = (id)[MEMORY[0x189607870] errorWithDomain:v151 code:133020 userInfo:v48];
      goto LABEL_75;
    }

    uint64_t v49 = 0;
LABEL_75:

    if ((v49 & 1) == 0) {
      break;
    }
LABEL_76:
    if (++v162 == v153)
    {
      os_log_type_t v18 = -[NSArray countByEnumeratingWithState:objects:count:]( list,  "countByEnumeratingWithState:objects:count:",  &v169,  v197,  16LL);
      int v155 = 1;
      if (!v18) {
        goto LABEL_247;
      }
      goto LABEL_24;
    }
  }

  char v141 = v182;
LABEL_245:
  int v155 = 0;
LABEL_247:
  [v150 drain];
  id v143 = 0LL;
  if ((v155 & 1) != 0) {
    return 1;
  }
  uint64_t v144 = v182;
  error = v149;
  if (v182)
  {
    *uint64_t v149 = (NSError *)v182;
    uint64_t v145 = v144;
    return 0;
  }

    int v41 = objc_msgSend( (id)objc_msgSend(a6, "objectForKey:", @"NSPersistentStoreTrackIndexUseOptionKey"),  "BOOLValue");
    if (v41) {
      int v42 = 0x10000;
    }
    else {
      int v42 = 0;
    }
    val->_sqlCoreFlags = (_sqlCoreFlags)(*(_DWORD *)&val->_sqlCoreFlags & 0xFFFEFFFF | v42);
    if (v93) {
      int v43 = v41;
    }
    else {
      int v43 = 0;
    }
    if (v43 == 1)
    {
      +[_PFRoutines _getPFBundleVersionNumber]();
      unsigned int v44 = +[NSSQLiteIndexTrackingModel newModelForFrameworkVersion:]();
      -[_PFModelMap addManagedObjectModel:](v93[12], v44);
      uint64_t v45 = -[NSSQLModel initWithManagedObjectModel:]( objc_alloc(&OBJC_CLASS___NSSQLModel),  "initWithManagedObjectModel:",  v44);
      objc_msgSend(v90, "addObjectsFromArray:", objc_msgSend((id)objc_msgSend(v44, "entitiesByName"), "allKeys"));
      [v92 setObject:v44 forKey:@"NSPersistentStoreTrackIndexUseOptionKey"];
      [v91 setObject:v45 forKey:@"NSPersistentStoreTrackIndexUseOptionKey"];
    }

    else if (!v93)
    {
      goto LABEL_86;
    }

    if (objc_msgSend( (id)objc_msgSend(a6, "objectForKey:", @"NSPersistentStoreMirroringOptionsKey"),  "objectForKey:",  @"NSPersistentStoreMirroringDelegateOptionKey")
      || objc_msgSend( (id)objc_msgSend(a6, "objectForKey:", @"NSCloudKitMirroringDelegateReadOnlyOptionKey"),  "BOOLValue"))
    {
      PFBundleVersion = (void *)+[_PFRoutines _getPFBundleVersionNumber]();
      uint64_t v47 = +[PFCloudKitMetadataModel newMetadataModelForFrameworkVersion:]( (uint64_t)&OBJC_CLASS___PFCloudKitMetadataModel,  PFBundleVersion);
      -[_PFModelMap addManagedObjectModel:](v93[12], v47);
      objc_msgSend( v90,  "addObjectsFromArray:",  -[NSDictionary allKeys](-[NSManagedObjectModel entitiesByName](v47, "entitiesByName"), "allKeys"));
      [v92 setObject:v47 forKey:@"NSPersistentStoreMirroringDelegateOptionKey"];
      uint32_t v48 = -[NSSQLModel initWithManagedObjectModel:]( objc_alloc(&OBJC_CLASS___NSSQLModel),  "initWithManagedObjectModel:",  v47);
      [v91 setObject:v48 forKey:@"NSPersistentStoreMirroringDelegateOptionKey"];
    }

    v78[5] = 0LL;
    _Block_object_dispose(&v77, 8);
    _Block_object_dispose(&v83, 8);
    goto LABEL_75;
  }

  __int16 v30 = (void *)MEMORY[0x189607870];
  unint64_t v103 = *MEMORY[0x1896075F0];
  unint64_t v104 = [NSString stringWithFormat:@"Request '%@' was cancelled because the store was removed from the coordinator.", objc_msgSend(*(id *)(a1[5] + 16), "requestIdentifier")];
  uint64_t v31 = [MEMORY[0x189603F68] dictionaryWithObjects:&v104 forKeys:&v103 count:1];
  uint64_t v32 = [v30 errorWithDomain:*MEMORY[0x189607460] code:134407 userInfo:v31];
  id v33 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResult);
  unint64_t v34 = a1[4];
  if (v34) {
    uint64_t v35 = *(void *)(v34 + 48);
  }
  else {
    uint64_t v35 = 0LL;
  }
  unint64_t v36 = -[NSCloudKitMirroringResult initWithRequest:storeIdentifier:success:madeChanges:error:]( v33,  "initWithRequest:storeIdentifier:success:madeChanges:error:",  *(void *)(a1[5] + 16LL),  v35,  0LL,  0LL,  v32);
  (*(void (**)(void))(a1[7] + 16LL))();

LABEL_75:
}

LABEL_64:
      uint64_t v47 = *(void *)v34;
      uint32_t v48 = *((void *)v34 + 1);
      if (v47) {
        uint64_t v49 = v48 == 0;
      }
      else {
        uint64_t v49 = 1;
      }
      if (v49) {
        goto LABEL_102;
      }
      id v50 = self->_parent_buffer;
      if (v50 && (uint64_t v51 = v50->_weakRequestStore) != 0LL) {
        uint64_t v52 = objc_loadWeakRetained(&v51->_object);
      }
      else {
        uint64_t v52 = 0LL;
      }
      if (v47 < 16000)
      {
        uint64_t v53 = objc_msgSend((id)objc_msgSend(v52, "model"), "entityForID:", v47);
        if (v53)
        {
LABEL_104:
          uint64_t v90 = (objc_class *)[v52 objectIDFactoryForSQLEntity:v53];

          uint64_t v46 = (CFStringRef)(id)[[v90 alloc] initWithPK64:v48];
          goto LABEL_105;
        }

        goto LABEL_101;
      }

      int v67 = (void *)[v52 ancillarySQLModels];
      id v110 = 0u;
      uint64_t v111 = 0u;
      uint64_t v112 = 0u;
      uint64_t v113 = 0u;
      unsigned int v68 = [v67 countByEnumeratingWithState:&v110 objects:v116 count:16];
      if (v68)
      {
        int v69 = v68;
        uint64_t v70 = *(void *)v111;
        do
        {
          int v71 = 0LL;
          do
          {
            if (*(void *)v111 != v70) {
              objc_enumerationMutation(v67);
            }
            int v72 = (unsigned int *)[v67 objectForKey:*(void *)(*((void *)&v110 + 1) + 8 * v71)];
            if (v72)
            {
              if (v47 <= v72[15]) {
                goto LABEL_95;
              }
              int v73 = v72[16];
            }

            else
            {
              int v73 = 0LL;
            }

            if (v47 <= v73)
            {
              int v74 = [v72 entityForID:v47];
              if (v74)
              {
                uint64_t v53 = v74;
                goto LABEL_104;
              }
            }

        parentObjectStore = 0LL;
        goto LABEL_39;
      }
    }

    else if (-[NSManagedObject hasChanges](object, "hasChanges"))
    {
      goto LABEL_37;
    }

    uint64_t v27 = 0;
LABEL_52:
    if (-[NSKnownKeysDictionary count](refreshed, "count")) {
      -[NSManagedObject _updateFromRefreshSnapshot:includingTransients:](object, refreshed, 0);
    }

    if (-[NSKnownKeysDictionary count](v5, "count")) {
      -[NSManagedObject _updateFromSnapshot:]((uint64_t)object, v5);
    }
    uint64_t v31 = object->_cd_stateFlags;
    if (v27)
    {
      object->_cd_stateFlags = v31 | 0x1000;
      -[NSManagedObject awakeFromFetch](object, "awakeFromFetch");
      uint64_t v31 = object->_cd_stateFlags & 0xFFFFEFFF;
    }

    object->_cd_stateFlags = v31 & 0xFFFFDFFF;
    if ((v7 & 1) == 0) {
      -[NSManagedObject _didChangeValuesForKeys:](object, "_didChangeValuesForKeys:", v4);
    }
    goto LABEL_60;
  }

        if (v30 >= 0x201) {
          NSZoneFree(0LL, v34);
        }
        id v28 = (void *)v56;
      }

      goto LABEL_69;
    }
  }

  else
  {
    id v28 = (void *)v56;
  }

  uint64_t v29 = v51;
LABEL_69:
  if (v29 >= 0x201) {
    NSZoneFree(0LL, v55);
  }
  objc_autoreleasePoolPop(v28);
  return (uint64_t)v26;
}

          unsigned int v44 = (void *)[(id)objc_opt_class() _newKeyPathExpressionForString:objc_msgSend( NSString, "stringWithFormat:", @".%@", objc_msgSend(v23, "lastObject"))];
          uint64_t v45 = objc_msgSend( (id)objc_msgSend(v23, "subarrayWithRange:", 0, objc_msgSend(v23, "count") - 1),  "componentsJoinedByString:",  @".");
          uint64_t v46 = -[NSSQLIntermediate governingAlias](v98->super._scope, "governingAlias");
          a3 = v94;
          if (!v46) {
            uint64_t v46 = -[NSSQLAliasGenerator generateVariableAlias]([v94 objectForKey:@"aliasGenerator"]);
          }
          uint64_t v47 = (void *)MEMORY[0x189607878];
          uint32_t v48 = [MEMORY[0x189607878] expressionForKeyPath:v45];
          uint64_t v49 = -[NSSQLSubqueryExpressionIntermediate initWithExpression:trailingKeypath:inScope:]( [NSSQLSubqueryExpressionIntermediate alloc],  "initWithExpression:trailingKeypath:inScope:",  objc_msgSend( v47,  "expressionForSubquery:usingIteratorVariable:predicate:",  v48,  v46,  objc_msgSend(MEMORY[0x1896079C8], "predicateWithValue:", 1)),  v44,  v98);

          id v50 = -[NSSQLSubqueryExpressionIntermediate generateSQLStringInContext:]( v49,  "generateSQLStringInContext:",  v94);
          uint64_t v6 = v93;
          if (v50)
          {
            uint64_t v17 = (NSSQLConstantValueIntermediate *)objc_msgSend((id)objc_msgSend(v14, "columnName"), "mutableCopy");
            -[NSSQLConstantValueIntermediate appendString:](v17, "appendString:", @" = ");
            -[NSSQLConstantValueIntermediate appendString:](v17, "appendString:", v50);

            int v5 = v95;
            goto LABEL_68;
          }

          int v5 = v95;
          uint64_t v10 = v97;
          if (![v94 objectForKey:@"NSUnderlyingException"])
          {
            int v87 = @"Can't generate SQL for keypath %@ : unexpected problem";
            goto LABEL_107;
          }

    uint64_t v45 = 0x189607000LL;
LABEL_65:

    if ((v55 | 2) == 2)
    {
      if (!v54) {
        break;
      }
      goto LABEL_69;
    }

    if ((v117 & 1) == 0) {
      break;
    }
LABEL_69:
    uint64_t v115 = 0LL;
    if (!-[NSManagedObjectContext save:](self->_destinationManagedObjectContext, "save:", &v115))
    {
      uint64_t v113 = (id)objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v92,  134110,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Failed to save new store after first pass of migration.",  @"reason",  v115,  *MEMORY[0x189607798],  0));
      goto LABEL_136;
    }

    [v102 drain];
    if (++v46 == v43)
    {
      int v43 = -[NSArray countByEnumeratingWithState:objects:count:]( v42,  "countByEnumeratingWithState:objects:count:",  &v109,  v127,  16LL);
      if (!v43)
      {
LABEL_72:
        uint64_t v107 = 0u;
        int v108 = 0u;
        __int16 v105 = 0u;
        uint64_t v106 = 0u;
        uint64_t v56 = -[NSArray countByEnumeratingWithState:objects:count:]( v42,  "countByEnumeratingWithState:objects:count:",  &v105,  &v123,  16LL);
        if (!v56) {
          goto LABEL_105;
        }
        uint64_t v96 = *(void *)v106;
        uint64_t v93 = *MEMORY[0x189607460];
        do
        {
          uint64_t v57 = 0LL;
          uint64_t v95 = v56;
          do
          {
            if (*(void *)v106 != v96) {
              objc_enumerationMutation(v42);
            }
            unint64_t v58 = *(NSEntityMigrationPolicy **)(*((void *)&v105 + 1) + 8 * v57);
            unint64_t v102 = objc_alloc_init(MEMORY[0x1896077E8]);
            uint64_t v99 = v57;
            unint64_t v121 = 0LL;
            unint64_t v59 = -[NSEntityMapping _migrationPolicy](v58);
            -[NSMigrationContext setCurrentEntityMapping:]((uint64_t)v103->_migrationContext, v58);
            uint64_t v60 = -[NSMigrationContext destinationInstancesForEntityMapping:sourceInstance:]( (id *)&v103->_migrationContext->super.isa,  v58,  0LL);
            unsigned int v119 = 0u;
            int v120 = 0u;
            int v117 = 0u;
            int v118 = 0u;
            uint64_t v61 = [v60 countByEnumeratingWithState:&v117 objects:v128 count:16];
            if (v61)
            {
              uint64_t v62 = *(void *)v118;
              while (2)
              {
                for (uint64_t j = 0LL; j != v61; ++j)
                {
                  if (*(void *)v118 != v62) {
                    objc_enumerationMutation(v60);
                  }
                  char v64 = *(void *)(*((void *)&v117 + 1) + 8 * j);
                  int v65 = objc_alloc_init(MEMORY[0x1896077E8]);
                  if (!-[NSEntityMigrationPolicy createRelationshipsForDestinationInstance:entityMapping:manager:error:]( v59,  "createRelationshipsForDestinationInstance:entityMapping:manager:error:",  v64,  v58,  v103,  &v121))
                  {
                    int v42 = v100;
                    int v69 = v121;
                    int v67 = 0;
                    goto LABEL_93;
                  }

                  if ((*(_BYTE *)&v103->_migrationManagerFlags & 1) != 0)
                  {
                    int v42 = v100;
                    unint64_t v121 = v103->_migrationCancellationError;
                    uint64_t v122 = 0;
                    unsigned int v68 = 1;
                    goto LABEL_91;
                  }

                  [v65 drain];
                }

                uint64_t v61 = [v60 countByEnumeratingWithState:&v117 objects:v128 count:16];
                if (v61) {
                  continue;
                }
                break;
              }
            }

            int v42 = v100;
            int v66 = -[NSEntityMigrationPolicy endRelationshipCreationForEntityMapping:manager:error:]( v59,  "endRelationshipCreationForEntityMapping:manager:error:",  v58,  v103,  &v121);
            int v67 = v66;
            if ((*(_BYTE *)&v103->_migrationManagerFlags & 1) != 0)
            {
              int v65 = 0LL;
              unint64_t v121 = v103->_migrationCancellationError;
LABEL_93:
              uint64_t v122 = 0;
              unsigned int v68 = 1;
            }

            else if ((v66 & 1) != 0)
            {
              int v65 = 0LL;
              unsigned int v68 = 0;
LABEL_91:
              int v67 = 1;
            }

            else
            {
              int v72 = v121;
              int v65 = 0LL;
              unsigned int v68 = 0;
              int v67 = 0;
            }

            if (v65) {
              [v65 drain];
            }
            uint64_t v113 = v121;
            uint64_t v70 = v121;
            int v71 = 0LL;
            if ((v68 | 2) == 2)
            {
              if (!v67) {
                goto LABEL_134;
              }
            }

            else if ((v122 & 1) == 0)
            {
              goto LABEL_134;
            }

            uint64_t v115 = 0LL;
            if (!-[NSManagedObjectContext save:](v103->_destinationManagedObjectContext, "save:", &v115))
            {
              uint64_t v113 = (id)objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v93,  134110,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Failed to save new store after second pass of migration.",  @"reason",  v115,  *MEMORY[0x189607798],  0));
              goto LABEL_136;
            }

            [v102 drain];
            ++v57;
          }

          while (v99 + 1 != v95);
          uint64_t v56 = -[NSArray countByEnumeratingWithState:objects:count:]( v42,  "countByEnumeratingWithState:objects:count:",  &v105,  &v123,  16LL);
        }

        while (v56);
LABEL_105:
        -[NSManagedObjectModel _restoreValidation]( -[NSMigrationManager sourceModel](v103, "sourceModel"),  "_restoreValidation");
        -[NSManagedObjectModel _restoreValidation]( -[NSMigrationManager destinationModel](v103, "destinationModel"),  "_restoreValidation");
        if ((-[NSMigrationManager _validateAllObjectsAfterMigration:](v103, (uint64_t *)&v113) & 1) == 0)
        {
LABEL_148:
          uint64_t v89 = v113;
          -[NSMigrationManager _doCleanupOnFailure:]((id *)&v103->super.isa);
          uint64_t v82 = 0;
          int v116 = 0;
          goto LABEL_139;
        }

        unsigned int v119 = 0u;
        int v120 = 0u;
        int v117 = 0u;
        int v118 = 0u;
        int v73 = -[NSArray countByEnumeratingWithState:objects:count:]( v42,  "countByEnumeratingWithState:objects:count:",  &v117,  v128,  16LL);
        if (!v73)
        {
          uint64_t v82 = 1;
          goto LABEL_139;
        }

        int v74 = *(void *)v118;
        while (2)
        {
          unsigned int v75 = 0LL;
LABEL_109:
          if (*(void *)v118 != v74) {
            objc_enumerationMutation(v42);
          }
          int v76 = *(NSEntityMigrationPolicy **)(*((void *)&v117 + 1) + 8 * v75);
          uint64_t v77 = 1;
          uint64_t v78 = -[NSEntityMapping _migrationPolicy](v76);
          -[NSMigrationContext setCurrentEntityMapping:]((uint64_t)v103->_migrationContext, v76);
          if (-[NSEntityMigrationPolicy performCustomValidationForEntityMapping:manager:error:]( v78,  "performCustomValidationForEntityMapping:manager:error:",  v76,  v103,  &v113))
          {
            if ((*(_BYTE *)&v103->_migrationManagerFlags & 1) == 0)
            {
              uint64_t v79 = -[NSEntityMigrationPolicy endEntityMapping:manager:error:]( v78,  "endEntityMapping:manager:error:",  v76);
              if ((*(_BYTE *)&v103->_migrationManagerFlags & 1) != 0)
              {
                uint64_t v113 = v103->_migrationCancellationError;
                LOBYTE(v121) = 0;
                uint64_t v80 = 1;
              }

              else
              {
                uint64_t v80 = 0;
              }

              uint64_t v81 = v78;
              uint64_t v77 = v79;
LABEL_120:

              if ((v80 | 2) == 2)
              {
                int v42 = v100;
                if ((v77 & 1) == 0) {
                  goto LABEL_148;
                }
              }

              else
              {
                int v42 = v100;
              }

              if (v73 == ++v75)
              {
                int v73 = -[NSArray countByEnumeratingWithState:objects:count:]( v42,  "countByEnumeratingWithState:objects:count:",  &v117,  v128,  16LL);
                uint64_t v82 = 1;
                if (!v73) {
                  goto LABEL_139;
                }
                continue;
              }

              goto LABEL_109;
            }

            uint64_t v113 = v103->_migrationCancellationError;
          }

          else
          {
            uint64_t v77 = 0;
          }

          break;
        }

        LOBYTE(v121) = 0;
        uint64_t v80 = 1;
        uint64_t v81 = v78;
        goto LABEL_120;
      }

      goto LABEL_42;
    }
  }

              if (!v46 || v48)
              {
                uint64_t v54 = !v49;
                if (!v46) {
                  uint64_t v54 = 1;
                }
                if ((v54 & 1) == 0
                  && (objc_msgSend((id)objc_msgSend(v46, "columnName"), "isEqual:", objc_msgSend(v48, "columnName")) & 1) == 0)
                {
                  id v50 = *(void **)(v9 + 128);
                  v64[0] = v46;
                  v64[1] = v48;
                  uint64_t v51 = (void *)MEMORY[0x189603F18];
                  uint64_t v52 = (void **)v64;
                  uint64_t v53 = 2LL;
                  goto LABEL_73;
                }
              }

              else
              {
                if (!v56) {
                  return 1LL;
                }
                id v50 = *(void **)(v9 + 176);
                int v65 = v46;
                uint64_t v51 = (void *)MEMORY[0x189603F18];
                uint64_t v52 = &v65;
                uint64_t v53 = 1LL;
LABEL_73:
                objc_msgSend(v50, "addObject:", objc_msgSend(v51, "arrayWithObjects:count:", v52, v53));
              }

              if ((v47 & 1) == 0) {
                goto LABEL_75;
              }
              goto LABEL_78;
            }

            uint64_t v49 = 0;
            uint32_t v48 = 0LL;
          }

          uint64_t v47 = 1;
          goto LABEL_64;
        }

LABEL_95:
            ++v71;
          }

          while (v69 != v71);
          unsigned int v75 = [v67 countByEnumeratingWithState:&v110 objects:v116 count:16];
          int v69 = v75;
        }

        while (v75);
      }

      int v76 = [NSString stringWithUTF8String:"Unknown ancillary entityID - %lld"];
      _NSCoreDataLog(17LL, v76, v77, v78, v79, v80, v81, v82, v47);
      uint64_t v83 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134217984;
        uint64_t v115 = v47;
        _os_log_fault_impl( &dword_186681000,  v83,  OS_LOG_TYPE_FAULT,  "CoreData: Unknown ancillary entityID - %lld",  buf,  0xCu);
      }

void sub_1866D7CF0(_Unwind_Exception *a1)
{
}

void sub_1866D7E18(_Unwind_Exception *a1)
{
}

void sub_1866D7F2C(_Unwind_Exception *a1)
{
}

void sub_1866D85C4()
{
}

void sub_1866D85D0()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x1866D85D8LL);
  }
  JUMPOUT(0x1866D85DCLL);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

void sub_1866D873C(_Unwind_Exception *a1)
{
}

void sub_1866D8758()
{
}

LABEL_92:
                          uint64_t v122 = (void *)MEMORY[0x189603F18];
                          unint64_t v123 = [v26 name];
                          uint64_t v97 = objc_msgSend(v122, "arrayWithObjects:", v165, v123, NSArray_EmptyArray, 0);
                          goto LABEL_93;
                        }

                        uint64_t v85 = 0LL;
                        while (2)
                        {
                          id v86 = (void *)MEMORY[0x186E3E5D8]();
                          int v87 = [v27 objectAtIndex:v85];
                          uint64_t v88 = v25;
                          uint64_t v89 = v23;
                          v182[0] = 0LL;
                          uint64_t v90 = (void *)[v163 objectRegisteredForID:v87];
                          if (v90)
                          {
                            uint64_t v91 = [(id)v160 slot];
                            if ((v155 & 1) != 0) {
                              uint64_t v92 = 0LL;
                            }
                            else {
                              uint64_t v92 = *(void *)(v30 + 192);
                            }
                            uint64_t v93 = (void *)[v90 entity];
                            id v94 = v92 + v91;
                            uint64_t v26 = v152;
                            if (v93 != v152)
                            {
                              id v94 = [v93 _offsetRelationshipIndex:v94 fromSuperEntity:v152 andIsToMany:0];
                              uint64_t v26 = v152;
                            }

                            if ((_PF_InternalToOneRelationshipForeignKeyCache((unsigned int *)v90, v94, v182) & 1) == 0
                              || !v182[0])
                            {
LABEL_72:
                              objc_autoreleasePoolPop(v86);
                              ++v85;
                              uint64_t v23 = v89;
                              os_log_type_t v25 = v88;
                              if (v149 == v85) {
                                goto LABEL_76;
                              }
                              continue;
                            }
                          }

                          else
                          {
                            v182[0] = objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v163, "existingObjectWithID:error:", v87, 0),  "primitiveValueForKey:",  v165),  "objectID");
                            if (!v182[0]) {
                              goto LABEL_72;
                            }
                          }

                          break;
                        }

                        objc_msgSend((id)v206[5], "addObject:");
                        goto LABEL_72;
                      }
                    }

                    else
                    {
                      __int16 v30 = 0LL;
                      int v150 = 0LL;
                      int v148 = 0LL;
                    }

                    uint64_t v160 = 0LL;
                    int v155 = 1;
                    goto LABEL_29;
                  }

          uint64_t v112 = v54;
          CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, 0LL);
          int v69 = v115;
          uint64_t v70 = (v115 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          int v71 = v70 + 4;
          if (v70 + 4 <= v6)
          {
            int v72 = *(_DWORD *)(v11 + v70);
            uint64_t v115 = v71;
            int v69 = v71;
            if (v72)
            {
              int v73 = bswap32(v72);
              while (1)
              {
                int v74 = (v115 + 3) & 0xFFFFFFFFFFFFFFFCLL;
                unsigned int v75 = v74 + 4;
                if (v74 + 4 > v6) {
                  goto LABEL_111;
                }
                int v76 = *(_DWORD *)(v11 + v74);
                uint64_t v115 = v75;
                if (!v76) {
                  goto LABEL_111;
                }
                CFArrayAppendValue(Mutable, (const void *)bswap32(v76));
                if (!--v73)
                {
                  int v69 = v115;
                  break;
                }
              }
            }
          }

          uint64_t v77 = (v69 + 7) & 0xFFFFFFFFFFFFFFF8LL;
          uint64_t v78 = v77 + 8;
          if (v77 + 8 > v6 || (uint64_t v79 = *(void *)(v11 + v77), v115 = v78, !v79))
          {
LABEL_111:
            uint64_t v89 = 0;
            uint64_t v90 = 0LL;
            uint64_t v85 = 0LL;
            uint64_t v82 = 0LL;
            goto LABEL_112;
          }

          uint64_t v80 = bswap64(v79);
          id v110 = [MEMORY[0x189607968] numberWithLongLong:v80];
          __int16 Count = CFArrayGetCount(Mutable);
          uint64_t v82 = CFArrayCreateMutable(0LL, 0LL, 0LL);
          uint64_t v111 = v80;
          uint64_t v83 = v80 >= 0x1000000 || Count >= 0xFF;
          int v84 = !v83;
          int v109 = v84;
          if (!v83) {
            goto LABEL_108;
          }
          uint64_t v91 = (v115 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v92 = v91 + 4;
          if (v91 + 4 <= v6)
          {
            uint64_t v93 = bswap32(*(_DWORD *)(v11 + v91));
            uint64_t v115 = v92;
          }

          else
          {
            uint64_t v93 = 0;
          }

          unint64_t v103 = v93;
          if (Count >= 0xFF)
          {
            if (v93)
            {
              do
              {
                __int16 v105 = (v115 + 1) & 0xFFFFFFFFFFFFFFFELL;
                uint64_t v106 = v105 + 2;
                if (v105 + 2 <= v6)
                {
                  uint64_t v107 = bswap32(*(unsigned __int16 *)(v11 + v105)) >> 16;
                  uint64_t v115 = v106;
                }

                else
                {
                  uint64_t v107 = 0;
                }

                if (v107 >= Count) {
                  goto LABEL_158;
                }
                CFArrayAppendValue(v82, (const void *)v107);
              }

              while (--v103);
            }
          }

          else if (v93)
          {
            while (1)
            {
              if (v115 + 1 <= v6) {
                unint64_t v104 = *(unsigned __int8 *)(v11 + v115++);
              }
              else {
                unint64_t v104 = 0;
              }
              if (v104 >= Count) {
                break;
              }
              CFArrayAppendValue(v82, (const void *)v104);
              if (!--v103) {
                goto LABEL_108;
              }
            }

          unint64_t v58 = v53;
          [a2 addObject:v53];
        }

    goto LABEL_93;
  }

  uint64_t v6 = (void *)MEMORY[0x186E3E5D8]();
  else {
    uint64_t v7 = __ckLoggingOverride;
  }
  id v8 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Asked to set up but already successfully initialized: %@"];
  _NSCoreDataLog( v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)"-[NSCloudKitMirroringDelegate _performSetupRequest:]_block_invoke");
  objc_autoreleasePoolPop(v6);
  *(void *)buf = 0LL;
  unsigned int v15 = *(void *)(a1 + 32);
  if (v15 && (uint64_t v16 = *(void *)(v15 + 8)) != 0) {
    uint64_t v17 = *(void **)(v16 + 88);
  }
  else {
    uint64_t v17 = 0LL;
  }
  os_log_type_t v18 = -[PFCloudKitStoreMonitorProvider createMonitorForObservedStore:inTransactionWithLabel:]( v17,  (uint64_t)WeakRetained);
  uint64_t v19 = (NSPersistentCloudKitContainerEvent *)+[NSCKEvent beginEventForRequest:withMonitor:error:]( (uint64_t)&OBJC_CLASS___NSCKEvent,  *(void *)(a1 + 40),  (uint64_t)v18,  buf);
  if (v19)
  {
    [v142 eventUpdated:v19];
  }

  else
  {
    uint64_t v60 = (void *)MEMORY[0x186E3E5D8]();
    uint64_t v61 = __ckLoggingOverride != 0;
    uint64_t v62 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Failed to create setup event: %@"];
    _NSCoreDataLog( v61,  v62,  v63,  v64,  v65,  v66,  v67,  v68,  (uint64_t)"-[NSCloudKitMirroringDelegate _performSetupRequest:]_block_invoke");
    objc_autoreleasePoolPop(v60);
  }

LABEL_93:
  int v116 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResult);
  int v117 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v117 + 89)) {
    int v118 = 0LL;
  }
  else {
    int v118 = *(void *)(v117 + 80);
  }
  unsigned int v119 = -[NSCloudKitMirroringResult initWithRequest:storeIdentifier:success:madeChanges:error:]( v116,  "initWithRequest:storeIdentifier:success:madeChanges:error:",  *(void *)(a1 + 40),  *(void *)(v117 + 168),  *(unsigned __int8 *)(v117 + 89) != 0,  0LL,  v118);
  -[NSCloudKitMirroringDelegate _finishedRequest:withResult:](*(void *)(a1 + 32), *(void **)(a1 + 40), v119);
  if (v19)
  {
    *(void *)buf = 0LL;
    int v120 = *(void *)(a1 + 32);
    if (v120 && (unint64_t v121 = *(void *)(v120 + 8)) != 0) {
      uint64_t v122 = *(void **)(v121 + 88);
    }
    else {
      uint64_t v122 = 0LL;
    }
    unint64_t v123 = -[PFCloudKitStoreMonitorProvider createMonitorForObservedStore:inTransactionWithLabel:]( v122,  (uint64_t)WeakRetained);
    char v124 = (void *)+[NSCKEvent finishEventForResult:withMonitor:error:]( (uint64_t)&OBJC_CLASS___NSCKEvent,  (uint64_t)v119,  (uint64_t)v123,  buf);
    if (v124)
    {
      [v142 eventUpdated:v124];
    }

    else
    {
      int v125 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v126 = __ckLoggingOverride != 0;
      char v127 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to finish setup event: %@"];
      _NSCoreDataLog( v126,  v127,  v128,  v129,  v130,  v131,  v132,  v133,  (uint64_t)"-[NSCloudKitMirroringDelegate _performSetupRequest:]_block_invoke");
      objc_autoreleasePoolPop(v125);
    }
  }
}

      if ([v214 count])
      {
        uint64_t v96 = objc_alloc_init(&OBJC_CLASS___NSFetchRequest);
        -[NSFetchRequest setEntity:]( v96,  "setEntity:",  objc_msgSend((id)objc_msgSend(v225, "destinationEntity"), "entityDescription"));
        -[NSFetchRequest setPredicate:]( v96,  "setPredicate:",  [MEMORY[0x1896079C8] predicateWithFormat:@"self IN %@", v214]);
        uint64_t v97 = objc_alloc(&OBJC_CLASS___NSSQLFetchRequestContext);
        uint64_t v98 = *(void *)(a1 + 8);
        if (v98)
        {
          uint64_t v99 = *(void *)(v98 + 32);
          uint64_t v100 = *(void *)(v98 + 8);
        }

        else
        {
          uint64_t v99 = 0LL;
          uint64_t v100 = 0LL;
        }

        uint64_t v101 = -[NSSQLFetchRequestContext initWithRequest:context:sqlCore:]( v97,  "initWithRequest:context:sqlCore:",  v96,  v99,  v100);
        -[NSSQLStoreRequestContext setQueryGenerationToken:]((id *)v101, 0LL);
        *(_DWORD *)(*(void *)(v101 + 136) + 72LL) = *(_DWORD *)(*(void *)(v101 + 136) + 72LL) & 0xFFFFFFE3 | 8;
        unint64_t v102 = *(void *)(a1 + 8);
        if (v102) {
          unint64_t v103 = *(void *)(v102 + 8);
        }
        else {
          unint64_t v103 = 0LL;
        }
        -[NSSQLCore dispatchRequest:withRetries:](v103, (void *)v101, 0LL);
        unint64_t v104 = (id)[(id)v101 result];

        v242 = 0u;
        v243 = 0u;
        v240 = 0u;
        v241 = 0u;
        __int16 v105 = [v104 countByEnumeratingWithState:&v240 objects:v253 count:16];
        if (v105)
        {
          uint64_t v106 = *(void *)v241;
          do
          {
            for (n = 0LL; n != v105; ++n)
            {
              if (*(void *)v241 != v106) {
                objc_enumerationMutation(v104);
              }
              int v108 = *(void **)(*((void *)&v240 + 1) + 8 * n);
              int v109 = *(void *)(a1 + 8);
              id v110 = [v108 objectID];
              if (v109) {
                [*(id *)(v109 + 136) setObject:v108 forKey:v110];
              }
            }

            __int16 v105 = [v104 countByEnumeratingWithState:&v240 objects:v253 count:16];
          }

          while (v105);
        }

        uint64_t v111 = 0LL;
      }

      else
      {
        uint64_t v111 = v214;
      }

      v238 = 0u;
      v239 = 0u;
      v236 = 0u;
      v237 = 0u;
      int v116 = [v87 countByEnumeratingWithState:&v236 objects:v252 count:16];
      if (v116)
      {
        int v117 = *(void *)v237;
        do
        {
          for (iuint64_t i = 0LL; ii != v116; ++ii)
          {
            if (*(void *)v237 != v117) {
              objc_enumerationMutation(v87);
            }
            unsigned int v119 = *(const void **)(*((void *)&v236 + 1) + 8 * ii);
            int v120 = (void *)[v87 objectForKey:v119];
            unint64_t v121 = -[NSSQLSaveChangesRequestContext originalRowForObjectID:](*(void *)(a1 + 8), v119);
            Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v119);
            if (Value) {
              unint64_t v123 = 1;
            }
            else {
              unint64_t v123 = v121 == 0LL;
            }
            if (!v123)
            {
              Value = (void *)-[os_unfair_lock_s copy](v121, "copy");
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v119, Value);
            }

            if (Value)
            {
              char v124 = [v120 intValue];
              [Value setForeignOrderKeySlot:v231 orderKey:v124];
              [v234 addObject:v119];
              [v234 addObject:v120];
            }
          }

          int v116 = [v87 countByEnumeratingWithState:&v236 objects:v252 count:16];
        }

        while (v116);
      }
    }

    else
    {
      int v87 = 0LL;
    }

    if (v234)
    {
      if ([v234 count]) {
        int v125 = (uint64_t)v234;
      }
      else {
        int v125 = 0LL;
      }
      if ([v215 count]) {
        uint64_t v126 = (uint64_t)v215;
      }
      else {
        uint64_t v126 = 0LL;
      }
      char v127 = (const void *)[v224 objectID];
      -[NSSQLSavePlan _registerChangedFOKs:deletions:forSourceObject:andRelationship:](a1, v125, v126, v127, v223);
    }

    else
    {
      v234 = 0LL;
    }

    goto LABEL_215;
  }

  v232 = a4;
  v215 = (id)+[_PFRoutines newSetOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v222);
  if ((*(_BYTE *)(a1 + 148) & 1) != 0) {
    v226 = objc_alloc_init(MEMORY[0x189603FA8]);
  }
  else {
    v226 = 0LL;
  }
  int v42 = (void *)+[_PFRoutines newArrayOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v233);
  int v43 = [v222 count];
  unsigned int v44 = v217;
  uint64_t v45 = [v217 count];
  v234 = v42;
  if (v43 == v45)
  {
    uint64_t v46 = [v44 count];
    if (v46)
    {
      uint64_t v47 = v46;
      uint32_t v48 = [a3 count];
      if (+[_PFRoutines _objectsInOrderedCollection:formSubstringInOrderedCollection:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v44,  a3))
      {
        uint64_t v49 = objc_msgSend(a3, "indexOfObject:", objc_msgSend(v44, "objectAtIndex:", 0));
        if (v49)
        {
          id v50 = v49 + v47;
          uint64_t v51 = v48 - (v49 + v47);
          uint64_t v52 = a12;
          if (v51)
          {
            uint64_t v53 = (id)objc_msgSend(objc_alloc(MEMORY[0x189603FD0]), "initWithArray:range:copyItems:", a3, 0, v49, 0);
            MEMORY[0x1895F8858](v53);
            v205 = (char *)&v212 - v204;
            objc_msgSend(a3, "getObjects:range:", (char *)&v212 - v204, v50, v51);
            id v86 = v232;
            [v53 addObjects:v205 count:v51];
            goto LABEL_163;
          }

          uint64_t v53 = (id)objc_msgSend(objc_alloc(MEMORY[0x189603FD0]), "initWithArray:range:copyItems:", a3, 0, v49, 0);
LABEL_162:
          id v86 = v232;
LABEL_163:
          [v53 addObjectsFromArray:v234];
          v225 = 0LL;
          goto LABEL_164;
        }

        uint64_t v115 = (id)objc_msgSend( objc_alloc(MEMORY[0x189603FD0]),  "initWithArray:range:copyItems:",  a3,  v47,  v48 - v47,  0);
      }

      else
      {
        uint64_t v115 = +[_PFRoutines newOrderedSetFromCollection:byRemovingItems:]((uint64_t)&OBJC_CLASS____PFRoutines, a3, v215);
      }
    }

    else
    {
      uint64_t v115 = (id)[objc_alloc(MEMORY[0x189603FD0]) initWithArray:a3];
    }

    uint64_t v53 = v115;
    uint64_t v52 = a12;
    goto LABEL_162;
  }

  uint64_t v85 = +[_PFRoutines newOrderedSetFromCollection:byRemovingItems:]((uint64_t)&OBJC_CLASS____PFRoutines, v44, v215);
  if (!+[_PFRoutines _objectsInOrderedCollection:formSubstringInOrderedCollection:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v85,  v42))
  {

    uint64_t v112 = (void *)+[_PFRoutines newSetOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, a7);
    v216 = [a3 mutableCopy];
    uint64_t v113 = +[_PFRoutines newOrderedSetFromCollection:byRemovingItems:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v44,  (void *)v216);
    uint64_t v114 = +[_PFRoutines newOrderedSetFromCollection:byRemovingItems:]((uint64_t)&OBJC_CLASS____PFRoutines, v113, v112);

    if (v226) {
      v225 = +[_PFRoutines newMutableArrayFromCollection:byRemovingItems:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v215,  v114);
    }
    else {
      v225 = 0LL;
    }
    uint64_t v128 = v217;
    BOOL v129 = [v217 count];
    uint64_t v52 = a12;
    if (v129 == [v114 count])
    {
      uint64_t v130 = 0LL;
    }

    else
    {
      uint64_t v131 = (void *)[v128 mutableCopy];
      uint64_t v130 = +[_PFRoutines newOrderedSetFromCollection:byRemovingItems:]((uint64_t)&OBJC_CLASS____PFRoutines, v131, v114);
    }

    unint64_t v132 = [v128 count];
    unint64_t v133 = [v114 count];
    v214 = v114;
    if (v132 == v133)
    {
      uint64_t v134 = +[_PFRoutines newOrderedSetFromCollection:byRemovingItems:]((uint64_t)&OBJC_CLASS____PFRoutines, v234, v128);
      char v135 = +[_PFRoutines newOrderedSetFromCollection:byAddingItems:]((uint64_t)&OBJC_CLASS____PFRoutines, v134, a3);
    }

    else
    {
      uint64_t v134 = v130;
      if (!+[_PFRoutines _objectsInOrderedCollection:formSubstringInOrderedCollection:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v130,  a3))
      {

        int v136 = (void *)v216;
        int v137 = +[_PFRoutines newOrderedSetFromCollection:byRemovingItems:]( (uint64_t)&OBJC_CLASS____PFRoutines,  (void *)v216,  v217);
        [v137 minusSet:v215];
        uint64_t v53 = +[_PFRoutines newOrderedSetFromCollection:byRemovingItems:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v234,  v114);
        int v138 = (void *)+[_PFRoutines newArrayOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v222);
        [v136 removeObjectsInArray:v138];

        v213 = v137;
        if ([v137 count])
        {
          v212 = a12;
          int v139 = v136;
          v231 = (_NSFaultingMutableOrderedSet *)[v136 count];
          if (v231)
          {
            unsigned int v140 = 0;
            char v141 = 0LL;
            id v142 = 0LL;
            for (juint64_t j = 0LL; jj != v231; juint64_t j = (_NSFaultingMutableOrderedSet *)((char *)jj + 1))
            {
              uint64_t v144 = [v139 objectAtIndex:jj];
              if ([v53 containsObject:v144])
              {
                if ((unint64_t)v142 | v141)
                {
                  v146 = objc_msgSend( v139,  "objectsAtIndexes:",  objc_msgSend(MEMORY[0x1896078D0], "indexSetWithIndexesInRange:", v142, v141));
                  int v147 = [v53 indexOfObject:v144];
                  objc_msgSend( v53,  "insertObjects:atIndexes:",  v146,  objc_msgSend(MEMORY[0x1896078D0], "indexSetWithIndexesInRange:", v147, v141));
                  id v142 = 0LL;
                  char v141 = 0LL;
                  unsigned int v140 = 0;
                }

                else
                {
                  id v142 = 0LL;
                  char v141 = 0LL;
                }
              }

              else
              {
                uint64_t v145 = (v140 & 1) == 0;
                if ((v140 & 1) == 0) {
                  id v142 = jj;
                }
                unsigned int v140 = 1;
                if (v145) {
                  char v141 = 1LL;
                }
                else {
                  ++v141;
                }
              }
            }
          }

          else
          {
            id v142 = 0LL;
            char v141 = 0LL;
          }

          if ((unint64_t)v142 | v141)
          {
            v206 = objc_msgSend( v139,  "objectsAtIndexes:",  objc_msgSend(MEMORY[0x1896078D0], "indexSetWithIndexesInRange:", v142, v141));
            v207 = [v53 count];
            objc_msgSend( v53,  "insertObjects:atIndexes:",  v206,  objc_msgSend(MEMORY[0x1896078D0], "indexSetWithIndexesInRange:", v207, v141));
          }

          uint64_t v52 = v212;
          uint64_t v134 = v213;
        }

        else
        {
          uint64_t v134 = v213;
        }

        goto LABEL_145;
      }

      char v135 = +[_PFRoutines _replaceBaseline:inOrderedSet:withOrderedSet:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v130,  a3,  v234);
    }

    uint64_t v53 = v135;
LABEL_145:
    id v86 = v232;

    goto LABEL_164;
  }

  uint64_t v53 = +[_PFRoutines _replaceBaseline:inOrderedSet:withOrderedSet:]((uint64_t)&OBJC_CLASS____PFRoutines, v85, v42, a3);

  v225 = 0LL;
  uint64_t v52 = a12;
  id v86 = v232;
LABEL_164:
  int v148 = [v223 name];
  v232 = (id)[v221 objectForKey:v148];
  if ([v232 isToMany])
  {
    if (v232 && (uint64_t v149 = *((void *)v232 + 7)) != 0) {
      int v150 = *(void **)(v149 + 80);
    }
    else {
      int v150 = 0LL;
    }
    LODWORD(v216) = [v150 slot];
  }

  else
  {
    LODWORD(v216) = 0;
  }

  uint64_t v151 = [v53 isNSArray];
  uint64_t v152 = objc_alloc(MEMORY[0x189603FA8]);
  uint64_t v153 = (uint64_t)v53;
  if ((v151 & 1) == 0) {
    uint64_t v153 = objc_msgSend(v53, "array", v53);
  }
  v235 = (id)[v152 initWithArray:v153];
  v231 = -[_NSFaultingMutableOrderedSet initWithOrderedSet:]( objc_alloc(&OBJC_CLASS____NSFaultingMutableOrderedSet),  "initWithOrderedSet:",  v53);

  if (-[_NSFaultingMutableOrderedSet count](v231, "count"))
  {
    id v154 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      id v154 = malloc_default_zone();
    }
    int v155 = malloc_zone_calloc(v154, -[_NSFaultingMutableOrderedSet count](v231, "count"), 1uLL);
    *v227 = v155;
    id v156 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      id v156 = malloc_default_zone();
    }
    *uint64_t v52 = malloc_zone_calloc(v156, -[_NSFaultingMutableOrderedSet count](v231, "count"), 8uLL);
    -[_NSFaultingMutableOrderedSet _populateOrderKeysUsingSnapshot:orderKeys:newIndexes:reorderedIndexes:]( (uint64_t)v231,  a3,  v86,  (void **)v52,  v227);
    -[_NSFaultingMutableOrderedSet _updateOrderKeysFromOrderOfObjectIDs:]((id *)v233, v231);
  }

  v233 = (char *)[v235 count];
  if (v233)
  {
    uint64_t v157 = 0LL;
    v227 = (void **)v216;
    do
    {
      int v158 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v159 = (const void *)[v235 objectAtIndex:v157];
      uint64_t v160 = -[NSSQLSaveChangesRequestContext originalRowForObjectID:](*(void *)(a1 + 8), v159);
      if (!v160)
      {
        int v161 = -[NSSQLStoreRequestContext createNestedObjectFaultContextForObjectWithID:]( *(NSSQLObjectFaultRequestContext **)(a1 + 8),  (uint64_t)v159);
        -[NSSQLStoreRequestContext setQueryGenerationToken:]((id *)&v161->super.super.isa, 0LL);
        uint64_t v162 = *(void *)(a1 + 8);
        if (v162) {
          uint64_t v163 = *(void *)(v162 + 8);
        }
        else {
          uint64_t v163 = 0LL;
        }
        -[NSSQLCore dispatchRequest:withRetries:](v163, v161, 0LL);
        uint64_t v160 = (os_unfair_lock_s *)-[NSSQLStoreRequestContext result](v161, "result");
        if (v160)
        {
          uint64_t v164 = *(void *)(a1 + 8);
          if (v164) {
            [*(id *)(v164 + 136) setObject:v160 forKey:v159];
          }
        }

        int v165 = v160;
      }

      if ([v232 isToMany])
      {
        int v166 = -[_NSFaultingMutableOrderedSet _orderKeyForObject:]((uint64_t)v231, (uint64_t)v159);
        uint64_t v167 = v166;
        v168 = v160
             ? *(uint32_t *)((char *)&v160[(void)v227]._os_unfair_lock_opaque
                           + _NSSQLRowInstanceSize
                           + ((2 * v160[4]._os_unfair_lock_opaque) & 0x1FFF8))
             : 0;
        if (v168 != (_DWORD)v166)
        {
          __int128 v169 = (void *)objc_msgSend((id)objc_msgSend(v224, "managedObjectContext"), "objectRegisteredForID:", v159);
          if (([v169 isDeleted] & 1) == 0)
          {
            if ([v169 isFault])
            {
              __int128 v170 = -[NSSQLStoreRequestContext createNestedObjectFaultContextForObjectWithID:]( *(NSSQLObjectFaultRequestContext **)(a1 + 8),  [v169 objectID]);
              -[NSSQLStoreRequestContext setQueryGenerationToken:]((id *)&v170->super.super.isa, 0LL);
              __int128 v171 = *(void *)(a1 + 8);
              if (v171) {
                __int128 v172 = *(void *)(v171 + 8);
              }
              else {
                __int128 v172 = 0LL;
              }
              -[NSSQLCore dispatchRequest:withRetries:](v172, v170, 0LL);
              uint64_t v160 = (os_unfair_lock_s *)-[NSSQLStoreRequestContext result](v170, "result");

              uint64_t v173 = v160;
            }

            uint64_t v174 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v159);
            if (!v174 && v160)
            {
              uint64_t v174 = (void *)-[os_unfair_lock_s copy](v160, "copy");
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v159, v174);
            }

            if (v174)
            {
              [v174 setForeignOrderKeySlot:v216 orderKey:v167];
              [v226 addObject:v159];
              uint64_t v175 = [MEMORY[0x189607968] numberWithUnsignedInt:v167];
              [v226 addObject:v175];
            }
          }
        }
      }

      objc_autoreleasePoolPop(v158);
      ++v157;
    }

    while (v233 != v157);
  }

  uint64_t v176 = v226;
  if (v226)
  {
    if ([v226 count]) {
      uint64_t v177 = (uint64_t)v226;
    }
    else {
      uint64_t v177 = 0LL;
    }
    if ([v225 count]) {
      v178 = (uint64_t)v225;
    }
    else {
      v178 = 0LL;
    }
    uint64_t v179 = (const void *)[v224 objectID];
    -[NSSQLSavePlan _registerChangedFOKs:deletions:forSourceObject:andRelationship:](a1, v177, v178, v179, v223);
    uint64_t v176 = v226;
  }

LABEL_215:
  uint64_t v26 = v228;
LABEL_216:
  if (!v220 || !v230) {
    goto LABEL_252;
  }
  int v180 = [v223 name];
  v181 = (void *)[v221 objectForKey:v180];
  int v182 = [v181 isToMany];
  int v183 = v182 ^ 1;
  if (!v181) {
    int v183 = 1;
  }
  if ((v183 & 1) == 0 && (int v182 = v181[7]) != 0 && *(_BYTE *)(v182 + 88))
  {
    int v182 = objc_msgSend((id)objc_msgSend((id)v182, "foreignKey"), "slot");
    __int128 v184 = v182;
    LODWORD(v234) = 1;
  }

  else
  {
    LODWORD(v234) = 0;
    __int128 v184 = 0LL;
  }

  v231 = (_NSFaultingMutableOrderedSet *)&v212;
  MEMORY[0x1895F8858](v182);
  int v187 = (char *)&v212 - v185;
  if (v186 > 0x200) {
    int v187 = (char *)NSAllocateScannedUncollectable();
  }
  else {
    bzero((char *)&v212 - v185, 8 * v186);
  }
  unsigned int v188 = [v222 getObjects:v187];
  unsigned __int8 v189 = 0LL;
  v233 = a9;
  LODWORD(v232) = v184;
  do
  {
    uint64_t v190 = (void *)MEMORY[0x186E3E5D8](v188);
    char v191 = (const void *)[*(id *)&v187[8 * v189] objectID];
    uint64_t v192 = v191;
    if ((v229 & 1) == 0) {
      *(void *)&v228[8 * v189] = v191;
    }
    if ((_DWORD)v234)
    {
      v193 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v191);
      if (v193) {
        goto LABEL_242;
      }
      if (-[NSSQLSaveChangesRequestContext originalRowForObjectID:](*(void *)(a1 + 8), v192))
      {
        v193 = 0LL;
        goto LABEL_242;
      }

      v194 = -[NSSQLStoreRequestContext createNestedObjectFaultContextForObjectWithID:]( *(NSSQLObjectFaultRequestContext **)(a1 + 8),  (uint64_t)v192);
      -[NSSQLStoreRequestContext setQueryGenerationToken:]((id *)&v194->super.super.isa, 0LL);
      v195 = *(void *)(a1 + 8);
      if (v195) {
        v196 = *(void *)(v195 + 8);
      }
      else {
        v196 = 0LL;
      }
      -[NSSQLCore dispatchRequest:withRetries:](v196, v194, 0LL);
      v197 = -[NSSQLStoreRequestContext result](v194, "result");
      if (v197)
      {
        v198 = *(void *)(a1 + 8);
        if (v198) {
          [*(id *)(v198 + 136) setObject:v197 forKey:v192];
        }
      }

      v199 = v197;
      __int128 v184 = v232;
      if (v197)
      {
        v193 = (void *)[v197 copy];
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v192, v193);

LABEL_242:
        v200 = (char *)-[NSSQLRow foreignKeyForSlot:]((uint64_t)v193, v184);
        if (v200 == v233) {
          [v193 setForeignKeySlot:v184 int64:0];
        }
      }
    }

    objc_autoreleasePoolPop(v190);
    ++v189;
  }

  while (v230 != v189);
  if ((v229 & 1) == 0)
  {
    v201 = objc_alloc(MEMORY[0x189604010]);
    v202 = (void *)[v201 initWithObjects:v228 count:v230];
    [v235 minusSet:v202];
  }

  if (v230 >= 0x201) {
    NSZoneFree(0LL, v187);
  }
  uint64_t v26 = v228;
LABEL_252:
  if (v218 >= 0x201) {
    NSZoneFree(0LL, v26);
  }
  [v219 drain];
  return v235;
}

LABEL_96:
                  objc_autoreleasePoolPop(v25);
                  ++v23;
                }

                while (v23 != v157);
                char v124 = [v159 countByEnumeratingWithState:&v166 objects:v229 count:16];
                uint64_t v157 = v124;
              }

              while (v124);
            }
          }

                  if (![v243 count]) {
                    goto LABEL_359;
                  }
                  v216 = [(id)v253 manyToOnePrefetchRequestForRelationshipNamed:v219 onEntity:v237];
                  *(void *)&v318 = @"objects";
                  v317[0] = [MEMORY[0x189607878] expressionForConstantValue:v243];
                  unint64_t v34 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:v317 forKeys:&v318 count:1];

LABEL_131:
                  v227 = -1;
                  v221 = -1;
LABEL_132:
                  if (v216)
                  {
                    uint64_t v82 = (void *)objc_msgSend((id)v253, "createChildContextForNestedFetchRequest:");
                    int v84 = v82;
                    if (v82) {
                      objc_setProperty_nonatomic(v82, v83, v34, 216LL);
                    }
                    -[NSSQLStoreRequestContext setConnection:]((uint64_t)v84, *(void **)(v253 + 24));
                    *(_DWORD *)(v84[17] + 72LL) = *(_DWORD *)(v84[17] + 72LL) & 0xFFFFFFE3 | 8;
                    v252 = (id)_newFetchedRowsForRequest(v84);
                    -[NSSQLStoreRequestContext setConnection:]((uint64_t)v84, 0LL);

                    if ((int)-[NSSQLStoreRequestContext debugLogLevel](v253) < 3)
                    {
                      if ((int)-[NSSQLStoreRequestContext debugLogLevel](v253) >= 1)
                      {
                        [v252 count];
                        _NSCoreDataLog( 4LL,  (uint64_t)@"Prefetching with key '%@'.  Got %lu rows.",  v91,  v92,  v93,  v94,  v95,  v96,  v219);
                      }
                    }

                    else
                    {
                      [v252 count];
                      _NSCoreDataLog( 4LL,  (uint64_t)@"Prefetching with request %@.  Got %lu rows with values: %@",  v85,  v86,  v87,  v88,  v89,  v90,  v216);
                    }
                  }

                  else
                  {
                    v252 = 0LL;
                  }

                  if (v256[24] == 7)
                  {
                    v240 = (id)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  objc_msgSend(v247, "count"));
                    v235 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  objc_msgSend(v247, "count"));
                    contexta = objc_alloc_init(MEMORY[0x189603FC8]);
                    v244 = objc_alloc_init(MEMORY[0x189603FC8]);
                    v303 = 0u;
                    v304 = 0u;
                    v301 = 0u;
                    v302 = 0u;
                    uint64_t v97 = [v252 countByEnumeratingWithState:&v301 objects:v314 count:16];
                    if (v97)
                    {
                      uint64_t v98 = *(void *)v302;
                      do
                      {
                        for (uint64_t k = 0LL; k != v97; ++k)
                        {
                          if (*(void *)v302 != v98) {
                            objc_enumerationMutation(v252);
                          }
                          uint64_t v100 = *(void **)(*((void *)&v301 + 1) + 8 * k);
                          uint64_t v101 = [v100 objectID];
                          if (v101) {
                            [contexta setObject:v100 forKey:v101];
                          }
                          unint64_t v102 = *((void *)v256 + 7);
                          if (v102)
                          {
                            if (*(_BYTE *)(v102 + 24) == 7)
                            {
                              unint64_t v103 = (void *)objc_msgSend(v100, "newObjectIDForToOne:");
                              if (v103)
                              {
                                [v244 setObject:v100 forKey:v103];
                              }
                            }
                          }
                        }

                        uint64_t v97 = [v252 countByEnumeratingWithState:&v301 objects:v314 count:16];
                      }

                      while (v97);
                    }

                    v299 = 0u;
                    v300 = 0u;
                    v297 = 0u;
                    v298 = 0u;
                    unint64_t v104 = [v247 countByEnumeratingWithState:&v297 objects:v313 count:16];
                    if (v104)
                    {
                      __int16 v105 = *(void *)v298;
                      do
                      {
                        uint64_t v106 = 0LL;
                        do
                        {
                          if (*(void *)v298 != v105) {
                            objc_enumerationMutation(v247);
                          }
                          uint64_t v107 = *(void **)(*((void *)&v297 + 1) + 8 * v106);
                          int v108 = (void *)MEMORY[0x186E3E5D8]();
                          int v109 = (os_unfair_lock_s *)[(id)v253 rowCache];
                          id v110 = -[NSPersistentStoreCache rowForObjectID:afterTimestamp:]( v109,  v107,  *(double *)&NSSQLDistantPastTimeInterval);
                          if (v110)
                          {
                            uint64_t v111 = -[os_unfair_lock_s newObjectIDForToOne:](v110, "newObjectIDForToOne:", v256);
                            uint64_t v113 = (void *)v111;
                            if (v22)
                            {
                              uint64_t v114 = (unsigned int *)_PFRetainedObjectIDCore((uint64_t)v22, v107, 0LL, 1);
                              if (v113)
                              {
                                uint64_t v115 = _PFRetainedObjectIDCore((uint64_t)v22, v113, 0LL, 1);
LABEL_163:
                                if (v264)
                                {
                                  if ([v115 isFault])
                                  {
                                    uint64_t v112 = (void *)[contexta objectForKey:v113];
                                    if (v112)
                                    {
                                      _PFFaultHandlerFulfillFault((uint64_t)v259, (uint64_t)v115, (uint64_t)v22, v112, 0);
                                      [v235 addObject:v115];
                                    }
                                  }
                                }

                                if (v115)
                                {
                                  int v116 = v115[4];
                                  if ((v116 & 0x200) == 0)
                                  {
                                    v115[4] = v116 | 0x200;
                                    goto LABEL_170;
                                  }
                                }

                                else
                                {
LABEL_170:
                                  objc_msgSend(v240, "addObject:", v113, v112);
                                }

                                _PFFaultHandlerPreconnectRelationship((int)v259, v114, v261, v115);

LABEL_204:
                                goto LABEL_205;
                              }
                            }

                            else
                            {
                              uint64_t v114 = 0LL;
                              uint64_t v115 = 0LL;
                              if (v111) {
                                goto LABEL_163;
                              }
                            }

                            _PFFaultHandlerPreconnectRelationship((int)v259, v114, v261, 0LL);
                            goto LABEL_204;
                          }

                          if ((*(_DWORD *)(*(void *)(v253 + 136) + 72LL) & 0x1C) != 0x14) {
                            goto LABEL_205;
                          }
                          int v117 = *((void *)v256 + 7);
                          if (v117 && *(_BYTE *)(v117 + 24) == 7)
                          {
                            int v118 = (void *)[v244 objectForKey:v107];
                            unsigned int v119 = v118;
                            if (!v118) {
                              goto LABEL_205;
                            }
                            int v120 = (id)[v118 objectID];
                            if (v22)
                            {
                              unint64_t v121 = (unsigned int *)_PFRetainedObjectIDCore((uint64_t)v22, v107, 0LL, 1);
                              uint64_t v122 = _PFRetainedObjectIDCore((uint64_t)v22, v120, 0LL, 1);
                            }

                            else
                            {
                              unint64_t v121 = 0LL;
                              uint64_t v122 = 0LL;
                            }

                            if ([v122 isFault])
                            {
                              _PFFaultHandlerFulfillFault((uint64_t)v259, (uint64_t)v122, (uint64_t)v22, v119, 0);
                              [v235 addObject:v122];
                            }

                            if (v122)
                            {
                              unint64_t v123 = v122[4];
                              if ((v123 & 0x200) == 0)
                              {
                                v122[4] = v123 | 0x200;
                                goto LABEL_183;
                              }
                            }

                            else
                            {
LABEL_183:
                              [v240 addObject:v120];
                            }

                            _PFFaultHandlerPreconnectRelationship((int)v259, v121, v261, v122);

                            goto LABEL_205;
                          }

                          char v124 = (unsigned int *)[v22 objectRegisteredForID:v107];
                          if (v124)
                          {
                            int v125 = [v256 slot];
                            uint64_t v126 = (char *)v233[24];
                            char v127 = (void *)[v107 entity];
                            uint64_t v128 = (unint64_t)&v126[v125];
                            if (v127 != v237) {
                              uint64_t v128 = objc_msgSend( v127,  "_offsetRelationshipIndex:fromSuperEntity:andIsToMany:",  &v126[v125]);
                            }
                            v312[0] = 0LL;
                            BOOL v129 = _PF_InternalToOneRelationshipForeignKeyCache(v124, v128, v312);
                            if (v312[0])
                            {
                              if (v22) {
                                uint64_t v131 = _PFRetainedObjectIDCore((uint64_t)v22, v312[0], 0LL, 1);
                              }
                              else {
                                uint64_t v131 = 0LL;
                              }
                              if (v264)
                              {
                                if ([v131 isFault])
                                {
                                  uint64_t v130 = (void *)[contexta objectForKey:v312[0]];
                                  if (v130)
                                  {
                                    _PFFaultHandlerFulfillFault((uint64_t)v259, (uint64_t)v131, (uint64_t)v22, v130, 0);
                                    [v235 addObject:v131];
                                  }
                                }
                              }

                              if (v131)
                              {
                                unint64_t v132 = v131[4];
                                if ((v132 & 0x200) == 0)
                                {
                                  v131[4] = v132 | 0x200;
                                  goto LABEL_198;
                                }
                              }

                              else
                              {
LABEL_198:
                                objc_msgSend(v240, "addObject:", v312[0], v130);
                              }

                              _PFFaultHandlerPreconnectRelationship((int)v259, v124, v261, v131);

                              goto LABEL_205;
                            }

                            if (v129) {
                              _PFFaultHandlerPreconnectRelationship((int)v259, v124, v261, 0LL);
                            }
                          }

void sub_1866D9BD8()
{
}

void sub_1866D9C00()
{
}

void sub_1866DA268()
{
}

void sub_1866DA274(void *a1)
{
}

void sub_1866DA284()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x1866DA28CLL);
  }
  JUMPOUT(0x1866DA290LL);
}

void sub_1866DA90C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x1866DA65CLL);
  }

  _Unwind_Resume(exception_object);
}

#error "1866DAE58: call analysis failed (funcsize=77)"
void *__141__NSXPCStoreServerRequestHandlingPolicy__prefetchRelationshipKey_sourceEntityDescription_sourceObjectIDs_prefetchRelationshipKeys_inContext___block_invoke_71( uint64_t a1)
{
  return -[NSSQLCore _uncacheRows:](*(void **)(a1 + 32), *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
}

LABEL_109:
              uint64_t v90 = 1;
              goto LABEL_114;
            }

            if (a5) {
              unsigned int v140 = (id)[MEMORY[0x189607870] errorWithDomain:v121 code:134030 userInfo:0];
            }
            uint64_t v89 = [MEMORY[0x189607968] numberWithBool:0];
            uint64_t v90 = 0;
            int v125 = (void *)v89;
          }

          else
          {
            if (a5) {
              unsigned int v140 = (id)[MEMORY[0x189607870] errorWithDomain:v121 code:134092 userInfo:0];
            }
            uint64_t v89 = [MEMORY[0x189607968] numberWithBool:0];
            uint64_t v90 = 0;
          }

          uint64_t v128 = (void *)v89;
LABEL_114:
          objc_autoreleasePoolPop(v85);
          if (!v90)
          {
            uint64_t v56 = 0LL;
            uint64_t v57 = v125;
            goto LABEL_157;
          }
        }

        uint64_t v82 = [v131 countByEnumeratingWithState:&v132 objects:v141 count:16];
        if (!v82)
        {
LABEL_117:
          uint64_t v57 = v125;
          if ([v129 count])
          {
            if (a5) {
              unsigned int v140 = (id)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:v129];
            }
            uint64_t v95 = [MEMORY[0x189607968] numberWithBool:0];
LABEL_156:
            uint64_t v56 = 0LL;
            uint64_t v128 = (void *)v95;
            uint64_t v57 = (void *)v95;
          }

          else
          {
            if (+[NSXPCStoreServer debugDefault](&OBJC_CLASS___NSXPCStoreServer, "debugDefault"))
            {
              _NSCoreDataLog(8LL, (uint64_t)@"Saving.", v107, v108, v109, v110, v111, v112, v118);
              NSLog((NSString *)@"\tInserted = %@", [v119 insertedObjects]);
              NSLog((NSString *)@"\tUpdated = %@", [v119 updatedObjects]);
              NSLog((NSString *)@"\tDeleted = %@", [v119 deletedObjects]);
            }

            if ([v119 save:&v140])
            {
              uint64_t v95 = [MEMORY[0x189607968] numberWithBool:1];
              goto LABEL_156;
            }

            uint64_t v56 = 0LL;
            uint64_t v128 = v125;
          }

  *(void *)(*(void *)&v239[8] + 40LL) = 0LL;
  id v142 = *((unsigned __int8 *)v269 + 24);
  _Block_object_dispose(v237, 8);
  _Block_object_dispose(v239, 8);
  _Block_object_dispose(&v268, 8);
  if (!v142) {
    goto LABEL_71;
  }
  *(void *)v239 = 0LL;
  *(void *)&v239[8] = v239;
  *(void *)&v239[16] = 0x2020000000LL;
  LOBYTE(v240) = 1;
  *(void *)v278 = 0LL;
  *(void *)&v278[8] = v278;
  *(void *)&v278[16] = 0x2020000000LL;
  v279 = 0;
  *(void *)buf = 0LL;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x3052000000LL;
  v275 = __Block_byref_object_copy__25;
  v276 = __Block_byref_object_dispose__25;
  v277 = 0LL;
  *(void *)v272 = 0LL;
  *(void *)&v272[8] = v272;
  *(void *)&v272[16] = 0x2020000000LL;
  LOBYTE(v273) = 0;
  v268 = 0LL;
  v269 = &v268;
  v270 = 0x2020000000LL;
  v271 = 0;
  id v143 = [*(id *)(v4 + 8) databaseScope];
  if (v143 == 1)
  {
    uint64_t v144 = 1;
    goto LABEL_167;
  }

  -[PFCloudKitSetupAssistant beginActivityForPhase:](v4, 5LL);
  v146 = *(id *)(v4 + 56);
  int v147 = v146;
  if (v143 == 3)
  {
    *(void *)v259 = MEMORY[0x1895F87A8];
    *(void *)&v259[8] = 3221225472LL;
    *(void *)&v259[16] = __66__PFCloudKitSetupAssistant__setupDatabaseSubscriptionIfNecessary___block_invoke_3;
    v260 = &unk_189EA9F30;
    v265 = 3LL;
    v261 = v146;
    v262 = (uint64_t *)v272;
    v263 = (uint64_t *)v239;
    v264 = buf;
    -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v146, (uint64_t)v259);
  }

  else if (v143 == 2)
  {
    int v148 = +[PFCloudKitSerializer defaultRecordZoneIDForDatabaseScope:]( &OBJC_CLASS___PFCloudKitSerializer,  "defaultRecordZoneIDForDatabaseScope:",  2LL);
    *(void *)v259 = MEMORY[0x1895F87A8];
    *(void *)&v259[8] = 3221225472LL;
    *(void *)&v259[16] = __66__PFCloudKitSetupAssistant__setupDatabaseSubscriptionIfNecessary___block_invoke;
    v260 = &unk_189EA9F08;
    v261 = v147;
    v262 = (uint64_t *)v148;
    v267 = 2LL;
    v263 = &v268;
    v264 = v272;
    v265 = (uint64_t)v239;
    v266 = (uint64_t)buf;
    -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v147, (uint64_t)v259);
  }

  if (*(_BYTE *)(*(void *)&v239[8] + 24LL))
  {
    uint64_t v159 = [*(id *)(v4 + 8) databaseScope];
    switch(v159)
    {
      case 1LL:
        uint64_t v160 = PFPublicDatabaseSubscriptionID;
        break;
      case 2LL:
        uint64_t v160 = PFPrivateDatabaseSubscriptionID;
        break;
      case 3LL:
        uint64_t v160 = PFSharedDatabaseSubscriptionID;
        break;
      default:
        *(_BYTE *)(*(void *)&v239[8] + 24LL) = 0;
        __int128 v169 = objc_alloc(MEMORY[0x189607870]);
        v258 = *MEMORY[0x1896075F0];
        *(void *)v243 = [NSString stringWithFormat:@"CloudKit integration does not support the '%@' database scope.", softLinkCKDatabaseScopeString(objc_msgSend(*(id *)(v4 + 8), "databaseScope"))];
        __int128 v170 = [MEMORY[0x189603F68] dictionaryWithObjects:v243 forKeys:&v258 count:1];
        __int128 v171 = [v169 initWithDomain:*MEMORY[0x189607460] code:134400 userInfo:v170];
        v168 = 0LL;
        *(void *)(*(void *)&buf[8] + 40LL) = v171;
LABEL_142:
        if (*(_BYTE *)(*(void *)&v239[8] + 24LL))
        {
          *(void *)(v4 + 32) = [objc_alloc(getCloudKitCKDatabaseSubscriptionClass()) initWithSubscriptionID:v168];
          __int128 v172 = objc_alloc_init(getCloudKitCKNotificationInfoClass());
          [v172 setShouldSendContentAvailable:1];
          [*(id *)(v4 + 32) setNotificationInfo:v172];

          if (*(_BYTE *)(*(void *)&v272[8] + 24LL))
          {
            *(_BYTE *)(*(void *)&v239[8] + 24LL) = 1;
          }

          else
          {
            *(_BYTE *)(*(void *)&v239[8] + 24LL) = 0;
            uint64_t v173 = (void (*)(uint64_t))*(id *)(v4 + 32);
            uint64_t v174 = *(dispatch_semaphore_s **)(v4 + 48);
            if (*((_BYTE *)v269 + 24))
            {
              v257 = @"com.apple.coredata.cloudkit.zone.subscription";
              uint64_t v175 = [MEMORY[0x189603F18] arrayWithObjects:&v257 count:1];
            }

            else
            {
              uint64_t v175 = 0LL;
            }

            char v191 = objc_alloc((Class)getCloudKitCKModifySubscriptionsOperationClass[0]());
            v256 = v173;
            uint64_t v192 = (void *)objc_msgSend( v191,  "initWithSubscriptionsToSave:subscriptionIDsToDelete:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v256, 1),  v175);
            -[NSCloudKitMirroringRequestOptions applyToOperation:]([*(id *)(v4 + 72) options], v192);
            *(void *)v246 = MEMORY[0x1895F87A8];
            v247 = 3221225472LL;
            v248 = (uint64_t)__66__PFCloudKitSetupAssistant__setupDatabaseSubscriptionIfNecessary___block_invoke_5;
            v249 = (void (*)(uint64_t, uint64_t))&unk_189EA9F58;
            v252 = (uint64_t *)v239;
            v253 = buf;
            v254 = (uint64_t)v278;
            v250 = v173;
            v251 = (uint64_t *)v174;
            [v192 setModifySubscriptionsCompletionBlock:v246];
            [*(id *)(v4 + 24) addOperation:v192];
            dispatch_semaphore_wait(v174, 0xFFFFFFFFFFFFFFFFLL);
            v193 = (void (*)(uint64_t))*(id *)(v4 + 56);
            v227 = MEMORY[0x1895F87A8];
            v228 = 3221225472LL;
            v229 = (uint64_t)__66__PFCloudKitSetupAssistant__setupDatabaseSubscriptionIfNecessary___block_invoke_102;
            v230 = (void (*)(uint64_t, uint64_t))&unk_189EA9F30;
            v231 = v193;
            v232 = v239;
            v233 = v278;
            v234 = (uint64_t *)buf;
            v235 = (_BYTE *)v143;
            -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v193, (uint64_t)&v227);
          }
        }

        goto LABEL_163;
    }

    v168 = *v160;
    goto LABEL_142;
  }

            *(double *)uint64_t v22 = v65;
            uint64_t v52 = v22 + 8;
            goto LABEL_116;
          case 16:
            if (!v174) {
              goto LABEL_91;
            }
            if (objc_msgSend( (id)objc_msgSend(*(id *)&v189[6 * v23 + 6], "propertyDescription"),  "_isFileBackedFuture")) {
              goto LABEL_91;
            }
            int v74 = &v189[6 * v23];
            int v76 = v74[3];
            unsigned int v75 = v74 + 3;
            uint64_t v77 = (const char *)sqlite3_column_blob(*(sqlite3_stmt **)(v185 + 80), v76);
            uint64_t v78 = sqlite3_column_bytes(*(sqlite3_stmt **)(v185 + 80), *v75);
            uint64_t v79 = (v78 - 1);
            if (v78 < 1) {
              goto LABEL_91;
            }
            uint64_t v167 = v75;
            v168 = v78;
            uint64_t v80 = (void *)[MEMORY[0x1896078A8] defaultManager];
            uint64_t v81 = *(unsigned __int8 *)v77;
            if (v81 == 1)
            {
              uint64_t v128 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
              BOOL v129 = *(void *)(v185 + 16);
              if (v129) {
                uint64_t v130 = (*(_DWORD *)(v129 + 200) >> 2) & 7;
              }
              else {
                uint64_t v130 = 0LL;
              }
              uint64_t v91 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v128,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  v77,  v168,  0LL,  0LL,  v130);
            }

            else
            {
              if (v81 == 3) {
                goto LABEL_183;
              }
              int v165 = v77;
              int v166 = objc_msgSend(v80, "stringWithFileSystemRepresentation:length:", v77 + 1, strnlen(v77 + 1, v79));
              uint64_t v82 = (void *)[*(id *)(v185 + 16) externalDataReferencesDirectory];
              uint64_t v83 = *(void *)(v185 + 16);
              if (v83)
              {
                uint64_t v85 = (void *)atomic_load((unint64_t *)(v83 + 176));
              }

              else
              {
                uint64_t v85 = 0LL;
              }

              id v86 = [v82 stringByAppendingPathComponent:v166];
              int v87 = [v85 stringByAppendingPathComponent:v166];
              uint64_t v88 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
              uint64_t v89 = *(void *)(v185 + 16);
              if (v89) {
                uint64_t v90 = (*(_DWORD *)(v89 + 200) >> 2) & 7;
              }
              else {
                uint64_t v90 = 0LL;
              }
              uint64_t v91 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v88,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  v165,  v168,  v86,  v87,  v90);
            }

            uint64_t v131 = v91;
            unint64_t v132 = -[_PFExternalReferenceData length](v91, "length");
            unint64_t v133 = v132;
            uint64_t v26 = v187;
            if ((v189[6 * v23 + 4] & 1) == 0) {
              goto LABEL_149;
            }
            if (v132)
            {
              *(_DWORD *)uint64_t v22 = 0;
            }

            else
            {
              uint64_t v134 = sqlite3_column_type(*(sqlite3_stmt **)(v185 + 80), *v167);
              *(_DWORD *)uint64_t v22 = v134 == 5;
              if (v134 == 5)
              {

                goto LABEL_118;
              }
            }

LABEL_157:
          uint64_t v113 = v57;
          uint64_t v114 = v140;
          [v120 drain];
          uint64_t v115 = v57;
          int v116 = v140;
          if (a5 && v140) {
            *a5 = v140;
          }
          int v117 = v116;
          return v128;
        }
      }

    case 5LL:
      if (!self) {
        return 0LL;
      }
      v142[0] = 0LL;
      uint64_t v20 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v21 = (void *)[a4 managedObjectContext];
      [a3 _resolveEntityWithContext:v21];
      uint64_t v22 = [a3 entity];
      if (v22)
      {
        if ((*(_BYTE *)(v22 + 120) & 4) != 0)
        {
          uint64_t v23 = *(void *)(v22 + 72);
        }

        else
        {
          do
          {
            uint64_t v23 = v22;
            uint64_t v22 = [(id)v22 superentity];
          }

          while (v22);
        }
      }

      else
      {
        uint64_t v23 = 0LL;
      }

      unint64_t v58 = -[NSXPCStoreServerRequestHandlingPolicy restrictingWritePredicateForEntity:fromClientWithContext:]( self,  "restrictingWritePredicateForEntity:fromClientWithContext:",  v23,  a4);
      if (v58)
      {
        if ((id)[MEMORY[0x1896079C8] predicateWithValue:0] != v58)
        {
          unint64_t v59 = (void *)[v21 executeRequest:a3 error:v142];
          uint64_t v60 = v142[0];
          goto LABEL_135;
        }

        if (a5)
        {
          int v65 = (void *)MEMORY[0x189607870];
          int v66 = *MEMORY[0x189607460];
          int v67 = 134030LL;
          goto LABEL_127;
        }
      }

      else if (a5)
      {
        int v65 = (void *)MEMORY[0x189607870];
        int v66 = *MEMORY[0x189607460];
        int v67 = 134092LL;
LABEL_127:
        uint64_t v60 = (id)[v65 errorWithDomain:v66 code:v67 userInfo:0];
        unint64_t v59 = 0LL;
        v142[0] = v60;
        goto LABEL_135;
      }

      uint64_t v60 = 0LL;
      unint64_t v59 = 0LL;
LABEL_135:
      uint64_t v99 = v60;
      uint64_t v100 = v59;
      objc_autoreleasePoolPop(v20);
      uint64_t v101 = v142[0];
      if (a5 && v142[0]) {
        *a5 = v142[0];
      }
      goto LABEL_148;
    case 6LL:
      if (!self) {
        return 0LL;
      }
      v142[0] = 0LL;
      uint64_t v47 = (void *)MEMORY[0x186E3E5D8]();
      uint32_t v48 = (void *)[a4 managedObjectContext];
      [a3 _resolveEntityWithContext:v48];
      uint64_t v49 = [a3 entity];
      if (v49)
      {
        if ((*(_BYTE *)(v49 + 120) & 4) != 0)
        {
          id v50 = *(void *)(v49 + 72);
        }

        else
        {
          do
          {
            id v50 = v49;
            uint64_t v49 = [(id)v49 superentity];
          }

          while (v49);
        }
      }

      else
      {
        id v50 = 0LL;
      }

      uint64_t v61 = -[NSXPCStoreServerRequestHandlingPolicy restrictingWritePredicateForEntity:fromClientWithContext:]( self,  "restrictingWritePredicateForEntity:fromClientWithContext:",  v50,  a4);
      if (v61)
      {
        if ((id)[MEMORY[0x1896079C8] predicateWithValue:0] != v61)
        {
          unint64_t v59 = (void *)[v48 executeRequest:a3 error:v142];
          uint64_t v62 = v142[0];
          goto LABEL_140;
        }

        if (a5)
        {
          int v74 = (void *)MEMORY[0x189607870];
          unsigned int v75 = *MEMORY[0x189607460];
          int v76 = 134030LL;
          goto LABEL_130;
        }
      }

      else if (a5)
      {
        int v74 = (void *)MEMORY[0x189607870];
        unsigned int v75 = *MEMORY[0x189607460];
        int v76 = 134092LL;
LABEL_130:
        uint64_t v62 = (id)[v74 errorWithDomain:v75 code:v76 userInfo:0];
        unint64_t v59 = 0LL;
        v142[0] = v62;
        goto LABEL_140;
      }

      uint64_t v62 = 0LL;
      unint64_t v59 = 0LL;
LABEL_140:
      unint64_t v102 = v62;
      unint64_t v103 = v59;
      objc_autoreleasePoolPop(v47);
      uint64_t v101 = v142[0];
      if (a5 && v142[0]) {
        *a5 = v142[0];
      }
      goto LABEL_148;
    case 7LL:
      if (!self) {
        return 0LL;
      }
      v142[0] = 0LL;
      uint64_t v51 = (void *)MEMORY[0x186E3E5D8]();
      uint64_t v52 = (void *)[a3 fetchRequest];
      uint64_t v53 = (void *)[a4 managedObjectContext];
      [v52 _resolveEntityWithContext:v53];
      uint64_t v54 = [v52 entity];
      if (v54)
      {
        if ((*(_BYTE *)(v54 + 120) & 4) != 0)
        {
          uint64_t v55 = *(void *)(v54 + 72);
        }

        else
        {
          do
          {
            uint64_t v55 = v54;
            uint64_t v54 = [(id)v54 superentity];
          }

          while (v54);
        }
      }

      else
      {
        uint64_t v55 = 0LL;
      }

      uint64_t v63 = -[NSXPCStoreServerRequestHandlingPolicy restrictingWritePredicateForEntity:fromClientWithContext:]( self,  "restrictingWritePredicateForEntity:fromClientWithContext:",  v55,  a4);
      if (v63)
      {
        if ((id)[MEMORY[0x1896079C8] predicateWithValue:0] != v63)
        {
          unint64_t v59 = (void *)[v53 executeRequest:a3 error:v142];
          char v64 = v142[0];
          goto LABEL_145;
        }

        if (a5)
        {
          uint64_t v77 = (void *)MEMORY[0x189607870];
          uint64_t v78 = *MEMORY[0x189607460];
          uint64_t v79 = 134030LL;
          goto LABEL_133;
        }
      }

      else if (a5)
      {
        uint64_t v77 = (void *)MEMORY[0x189607870];
        uint64_t v78 = *MEMORY[0x189607460];
        uint64_t v79 = 134092LL;
LABEL_133:
        char v64 = (id)[v77 errorWithDomain:v78 code:v79 userInfo:0];
        unint64_t v59 = 0LL;
        v142[0] = v64;
        goto LABEL_145;
      }

      char v64 = 0LL;
      unint64_t v59 = 0LL;
LABEL_145:
      unint64_t v104 = v64;
      __int16 v105 = v59;
      objc_autoreleasePoolPop(v51);
      uint64_t v101 = v142[0];
      if (a5 && v142[0]) {
        *a5 = v142[0];
      }
LABEL_148:
      uint64_t v106 = v101;
      return v59;
    case 8LL:
      if (!self) {
        return 0LL;
      }
      v142[0] = 0LL;
      id v24 = (void *)MEMORY[0x186E3E5D8]();
      os_log_type_t v25 = (void *)objc_msgSend((id)objc_msgSend(a4, "managedObjectContext"), "executeRequest:error:", a3, v142);
      uint64_t v26 = v25;
      uint64_t v27 = v142[0];
      objc_autoreleasePoolPop(v24);
      id v28 = v142[0];
      if (a5 && v142[0]) {
        *a5 = v142[0];
      }
      uint64_t v29 = v28;
      return v25;
    default:
      if (!a5) {
        return 0LL;
      }
      __int16 v30 = [a3 description];
      if (v30) {
        uint64_t v31 = (const __CFString *)v30;
      }
      else {
        uint64_t v31 = @"Request description was nil.";
      }
      uint64_t v128 = 0LL;
      *a5 = (id)objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  0,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObject:forKey:", v31, @"Request"));
      return v128;
  }

void sub_1866DBE50( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1866DB560LL);
  }

  _Unwind_Resume(exc_buf);
}

LABEL_13:
        unsigned int v15 = [a1 restrictingWritePredicateForEntity:v14 fromClientWithContext:a3];
        if (!v15)
        {
          id v24 = (void *)[MEMORY[0x189607870] errorWithDomain:v35 code:134092 userInfo:0];
LABEL_28:
          os_log_type_t v25 = 0;
          uint64_t v23 = 0LL;
          id v50 = v24;
          goto LABEL_31;
        }

        if ([MEMORY[0x1896079C8] predicateWithValue:0] == v15)
        {
          id v24 = (void *)[MEMORY[0x189607870] errorWithDomain:v35 code:134030 userInfo:0];
          goto LABEL_28;
        }

        uint64_t v16 = [v8 unsignedIntegerValue];
        for (uint64_t i = objc_alloc_init(MEMORY[0x189603FA8]); v16; --v16)
        {
          os_log_type_t v18 = -[NSManagedObject initWithEntity:insertIntoManagedObjectContext:]( objc_alloc(&OBJC_CLASS___NSManagedObject),  "initWithEntity:insertIntoManagedObjectContext:",  v13,  v10);
          [i addObject:v18];
        }

        if ([v10 obtainPermanentIDsForObjects:i error:&v50])
        {
          uint64_t v19 = objc_alloc_init(MEMORY[0x189603FA8]);
          uint32_t v48 = 0u;
          uint64_t v49 = 0u;
          uint64_t v46 = 0u;
          uint64_t v47 = 0u;
          uint64_t v20 = [i countByEnumeratingWithState:&v46 objects:v52 count:16];
          if (v20)
          {
            uint64_t v21 = *(void *)v47;
            do
            {
              for (uint64_t j = 0LL; j != v20; ++j)
              {
                if (*(void *)v47 != v21) {
                  objc_enumerationMutation(i);
                }
                objc_msgSend(v19, "addObject:", objc_msgSend(*(id *)(*((void *)&v46 + 1) + 8 * j), "objectID"));
              }

              uint64_t v20 = [i countByEnumeratingWithState:&v46 objects:v52 count:16];
            }

            while (v20);
          }

          uint64_t v23 = v19;
        }

        else
        {
          uint64_t v23 = 0LL;
        }

        os_log_type_t v25 = 1;
LABEL_31:
        uint64_t v26 = v50;
        [v9 drain];
        if (v50) {
          int v5 = v50;
        }
        uint64_t v27 = v50;
        if ((v25 & 1) == 0 || (id v28 = v23) == 0LL)
        {
          uint64_t v39 = 0LL;
          goto LABEL_43;
        }

        [v39 setValue:v28 forKey:v7];
        ++v6;
      }

      while (v6 != v38);
      uint64_t v29 = [obj countByEnumeratingWithState:&v42 objects:v51 count:16];
      uint64_t v38 = v29;
      if (!v29) {
        goto LABEL_43;
      }
    }
  }

  int v5 = 0LL;
LABEL_43:
  __int16 v30 = v5;
  objc_autoreleasePoolPop(context);
  uint64_t v31 = v5;
  if (a4 && v5) {
    *a4 = v5;
  }
  return v39;
}
}

    __break(1u);
    return;
  }

  if (*MEMORY[0x189616650] && Class == a1 && !_PFTaggedPointersPool)
  {
    CFStringRef v4 = (size_t *)MEMORY[0x1895FD590];
    int v5 = ((*MEMORY[0x1895FD578] + 0x400000LL) & ~*MEMORY[0x1895FD578]) + *MEMORY[0x1895FD590];
    _PFTaggedPointersPool = (uint64_t)mmap(0LL, v5, 3, 4098, 771751936, 0LL);
    mprotect((void *)(v5 + _PFTaggedPointersPool - *v4), *v4, 0);
    unk_18C4AB950 = a1;
    _objc_registerTaggedPointerClass();
    qword_18C4AB958 = (uint64_t)objc_alloc_init(MEMORY[0x189603FE0]);
    dword_18C4AB94C = 0;
    if (_PFTaggedPointersPool)
    {
      __dmb(0xBu);
      return;
    }

    uint64_t v16 = [NSString stringWithUTF8String:"Failure to initialize tagged pointers (pool is NULL after initialization attempt): %@:%p:%@:%p - %p\n %s\n %s"];
    NSStringFromClass((Class)a1);
    class_getImageName((Class)a1);
    class_getImageName((Class)a1);
    _NSCoreDataLog(17LL, v16, v17, v18, v19, v20, v21, v22, (uint64_t)a1);
    uint64_t v23 = __pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138413826;
      os_log_type_t v25 = a1;
      uint64_t v26 = 2048;
      uint64_t v27 = a1;
      id v28 = 2112;
      uint64_t v29 = NSStringFromClass((Class)a1);
      __int16 v30 = 2048;
      uint64_t v31 = a1;
      uint64_t v32 = 2048;
      id v33 = _PFTaggedPointersPool;
      unint64_t v34 = 2080;
      ImageName = class_getImageName((Class)a1);
      unint64_t v36 = 2080;
      uint64_t v37 = class_getImageName((Class)a1);
      uint64_t v14 = "CoreData: Failure to initialize tagged pointers (pool is NULL after initialization attempt): %@:%p:%@:%p - %p\n%s\n%s";
      unsigned int v15 = (os_log_s *)v23;
      goto LABEL_12;
    }

    goto LABEL_13;
  }

    uint64_t v19 = 0;
    goto LABEL_14;
  }

  *(int8x8_t *)&unsigned int v15 = SetHostHeaderWithBigHeader((uint64_t)v26, [v9 bytes]);
  if (v27 != 1)
  {
    if (a3)
    {
      uint64_t v20 = objc_alloc(MEMORY[0x189603F68]);
      uint64_t v21 = (void *)objc_msgSend(v20, "initWithObjectsAndKeys:", a2, *MEMORY[0x1896074F8], 0);
      os_log_type_t v25 = (id)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134000 userInfo:v21];
    }

    goto LABEL_13;
  }

  objc_msgSend(v8, "seekToFileOffset:", v28, v15);
  uint64_t v16 = [v8 readDataOfLength:v29];
  uint64_t v17 = (void *)[objc_alloc(MEMORY[0x189603FB8]) initWithCapacity:512];
  os_log_type_t v18 = (void *)[objc_alloc(MEMORY[0x1896078F8]) initForWritingWithMutableData:v17];
  [v18 encodeObject:a1[2] forKey:@"metadata"];
  [v18 finishEncoding];

  uint64_t v19 = [a1 _writeMetadataData:v17 andMapDataData:v16 toFile:a2 error:&v25];
LABEL_14:
  uint64_t v14 = v19 != 0;
  uint64_t v22 = v25;
  [v8 closeFile];
  [v6 drain];
  uint64_t v23 = v25;
  if (a3 && v25) {
    *a3 = v25;
  }
  return v14;
}

  if ((v9 & 0x1000) != 0) {
    goto LABEL_25;
  }
LABEL_14:
  if ((v9 & 0x80) != 0)
  {
    uint64_t v21 = [(id)a1 objectID];
    _NSCoreDataLog( 1LL,  (uint64_t)@"Mutating a managed object %@ (%p) after it has been removed from its context.",  v22,  v23,  v24,  v25,  v26,  v27,  v21);
  }

  id v28 = *(void *)(a1 + 32);
  if (v28 && (v12 & ((*(void *)&v9 & 0x400000LL) != 0)) == 0)
  {
    uint64_t v29 = v17 ? v19 : 0;
  }

  *(_DWORD *)(a1 + 16) |= 0x800u;
LABEL_25:
  if ((v9 & 0x2000) == 0)
  {
    __int16 v30 = *(void **)(a1 + 48);
    if (v30) {
      LOBYTE(v30) = *v30 != 0LL;
    }
    if ((v30 & 1) != 0
      || (a5 & 1) != 0
      || (v31 = v11[4], uint64_t v14 = a4 >= v31, v32 = a4 - v31, v14) && v32 < v11[5])
    {
      off_18C4AB998(a1, sel_willChangeValueForKey_, a3);
    }
  }

  uint64_t v14 = (void *)[a2 objectForKey:@"newQueryGeneration"];
  if (v14
    || (uint64_t v14 = (void *)[(id)a1 _queryGenerationToken], v15 = objc_msgSend(v14, "_isEnabled"), v14) && v15)
  {
    [v4 setObject:v14 forKey:@"newQueryGeneration"];
  }

  uint64_t v16 = objc_alloc_init(MEMORY[0x189603FE0]);
  uint64_t v17 = *(void **)(*(void *)(a1 + 168) + 136LL);
  uint64_t v63 = v4;
  if ([v17 count])
  {
    os_log_type_t v18 = (id)objc_msgSend((id)objc_msgSend(a2, "objectForKey:", @"inserted"), "mutableCopy");
    if (!v18) {
      os_log_type_t v18 = objc_alloc_init(MEMORY[0x189603FE0]);
    }
    int v74 = 0u;
    unsigned int v75 = 0u;
    int v72 = 0u;
    int v73 = 0u;
    uint64_t v19 = [v17 countByEnumeratingWithState:&v72 objects:v78 count:16];
    if (v19)
    {
      uint64_t v20 = v19;
      uint64_t v21 = *(void *)v73;
      do
      {
        for (uint64_t i = 0LL; i != v20; ++i)
        {
          if (*(void *)v73 != v21) {
            objc_enumerationMutation(v17);
          }
          uint64_t v23 = objc_msgSend( (id)a1,  "objectWithID:",  objc_msgSend(*(id *)(*((void *)&v72 + 1) + 8 * i), "firstObject"));
          if (v23)
          {
            id v24 = v23;
            [v18 addObject:v23];
            [v16 addObject:v24];
          }
        }

        uint64_t v20 = [v17 countByEnumeratingWithState:&v72 objects:v78 count:16];
      }

      while (v20);
    }

    [a2 setObject:v18 forKey:@"inserted"];

    *(void *)(*(void *)(a1 + 168) + 136LL) = 0LL;
    CFStringRef v4 = v63;
  }

  os_log_type_t v25 = *(void **)(*(void *)(a1 + 168) + 144LL);
  if ([v25 count])
  {
    uint64_t v26 = (id)objc_msgSend((id)objc_msgSend(a2, "objectForKey:", @"updated"), "mutableCopy");
    if (!v26) {
      uint64_t v26 = objc_alloc_init(MEMORY[0x189603FE0]);
    }
    uint64_t v70 = 0u;
    int v71 = 0u;
    unsigned int v68 = 0u;
    int v69 = 0u;
    uint64_t v27 = [v25 countByEnumeratingWithState:&v68 objects:v77 count:16];
    if (v27)
    {
      id v28 = v27;
      uint64_t v29 = *(void *)v69;
      do
      {
        for (uint64_t j = 0LL; j != v28; ++j)
        {
          if (*(void *)v69 != v29) {
            objc_enumerationMutation(v25);
          }
          uint64_t v31 = objc_msgSend( (id)a1,  "objectWithID:",  objc_msgSend(*(id *)(*((void *)&v68 + 1) + 8 * j), "firstObject"));
          if (v31)
          {
            uint64_t v32 = v31;
            [v26 addObject:v31];
            [v16 addObject:v32];
          }
        }

        id v28 = [v25 countByEnumeratingWithState:&v68 objects:v77 count:16];
      }

      while (v28);
    }

    *(void *)(*(void *)(a1 + 168) + 144LL) = 0LL;
    CFStringRef v4 = v63;
  }

  else
  {
    uint64_t v26 = 0LL;
  }

  id v33 = *(void **)(*(void *)(a1 + 168) + 112LL);
  if ([v33 count])
  {
    if (!v26)
    {
      uint64_t v26 = (id)objc_msgSend((id)objc_msgSend(a2, "objectForKey:", @"updated"), "mutableCopy");
      if (!v26) {
        uint64_t v26 = objc_alloc_init(MEMORY[0x189603FE0]);
      }
    }

    int v66 = 0u;
    int v67 = 0u;
    char v64 = 0u;
    int v65 = 0u;
    unint64_t v34 = [v33 countByEnumeratingWithState:&v64 objects:v76 count:16];
    if (v34)
    {
      uint64_t v35 = v34;
      unint64_t v36 = *(void *)v65;
      do
      {
        for (uint64_t k = 0LL; k != v35; ++k)
        {
          if (*(void *)v65 != v36) {
            objc_enumerationMutation(v33);
          }
          uint64_t v38 = [(id)a1 objectWithID:*(void *)(*((void *)&v64 + 1) + 8 * k)];
          if (v38)
          {
            uint64_t v39 = v38;
            [v26 addObject:v38];
            [v16 addObject:v39];
          }
        }

        uint64_t v35 = [v33 countByEnumeratingWithState:&v64 objects:v76 count:16];
      }

      while (v35);
    }

    *(void *)(*(void *)(a1 + 168) + 112LL) = 0LL;
    CFStringRef v4 = v63;
  }

  if (v26) {
    [a2 setObject:v26 forKey:@"updated"];
  }

  if ([v16 count]) {
    [a2 setObject:v16 forKey:@"_NSTriggerModifiedObjectsKey"];
  }

  if (!objc_msgSend((id)objc_msgSend(a2, "objectForKey:", @"inserted"), "count")) {
    [a2 removeObjectForKey:@"inserted"];
  }
  if (!objc_msgSend((id)objc_msgSend(a2, "objectForKey:", @"deleted"), "count")) {
    [a2 removeObjectForKey:@"deleted"];
  }
  if (!objc_msgSend((id)objc_msgSend(a2, "objectForKey:", @"updated"), "count")) {
    [a2 removeObjectForKey:@"updated"];
  }
  for (m = 0LL; m != 5; ++m)
  {
    int v41 = (void *)[a2 objectForKey:off_189EA84D0[m]];
    if ([v41 count])
    {
      int v42 = (void *)+[_PFRoutines newSetOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v41);
      [v4 setObject:v42 forKey:off_189EA84F8[m]];
    }
  }

  int v43 = (void *)[a2 objectForKey:@"refreshed"];
  if ([v43 count]) {
    unsigned int v44 = (id)+[_PFRoutines newSetOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v43);
  }
  else {
    unsigned int v44 = (id)NSSet_EmptySet;
  }
  uint64_t v45 = v44;
  uint64_t v46 = (void *)[a2 objectForKey:@"refreshed_objectIDs"];
  if (![v45 count] && !objc_msgSend(v46, "count"))
  {
    [a2 removeObjectForKey:@"refreshed"];
    [a2 removeObjectForKey:@"refreshed_objectIDs"];
    [v4 removeObjectForKey:@"refreshed"];
    [v4 removeObjectForKey:@"refreshed_objectIDs"];
    goto LABEL_94;
  }

  uint64_t v47 = +[_PFRoutines newSetFromCollection:byAddingItems:]((uint64_t)&OBJC_CLASS____PFRoutines, v45, v46);

  [v4 setObject:v47 forKey:@"refreshed_objectIDs"];
  uint32_t v48 = [v47 count];
  uint64_t v49 = v48;
  if (v48 <= 1) {
    id v50 = 1LL;
  }
  else {
    id v50 = v48;
  }
  if (v48 >= 0x201) {
    uint64_t v51 = 1LL;
  }
  else {
    uint64_t v51 = v50;
  }
  uint64_t v52 = (char *)&v62 - ((8 * v51 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v45 = v47;
  if (v48 >= 0x201)
  {
    uint64_t v52 = (char *)NSAllocateScannedUncollectable();
    [v47 getObjects:v52];
LABEL_87:
    uint64_t v54 = 0LL;
    uint64_t v53 = 0LL;
    do
    {
      uint64_t v55 = [(id)a1 objectRegisteredForID:*(void *)&v52[8 * v54]];
      if (v55) {
        *(void *)&v52[8 * v53++] = v55;
      }
      ++v54;
    }

    while (v49 != v54);
    goto LABEL_91;
  }

  bzero((char *)&v62 - ((8 * v51 + 15) & 0xFFFFFFFFFFFFFFF0LL), 8 * v50);
  [v47 getObjects:v52];
  if (v49) {
    goto LABEL_87;
  }
  uint64_t v53 = 0LL;
LABEL_91:
  uint64_t v56 = (void *)[objc_alloc(MEMORY[0x189604010]) initWithObjects:v52 count:v53];
  if (v49 >= 0x201) {
    NSZoneFree(0LL, v52);
  }
  [a2 setObject:v56 forKey:@"refreshed"];

LABEL_94:
  uint64_t v57 = (id)[v4 copy];

  unint64_t v58 = (void *)[MEMORY[0x189607958] defaultCenter];
  unint64_t v59 = v58;
  uint64_t v60 = atomic_load((unsigned __int8 *)(a1 + 48));
  if ((v60 & 1) == 0)
  {
    [v58 postNotificationName:@"_NSManagedObjectContextDidSaveObjectIDsPrivateNotification" object:*(void *)(a1 + 32) userInfo:v57];
    [v59 postNotificationName:@"NSManagedObjectContextDidSaveObjectIDsNotification" object:*(void *)(a1 + 32) userInfo:v57];
  }

  [v59 postNotificationName:@"_NSManagedObjectContextDidSaveObjectIDsPrivateNotification" object:a1 userInfo:v57];
  os_log_t result = [v59 postNotificationName:@"NSManagedObjectContextDidSaveObjectIDsNotification" object:a1 userInfo:v57];
  if ((*(_BYTE *)(a1 + 43) & 0x10) != 0) {
    return [v59 postNotificationName:@"NSManagingContextDidSaveChangesNotification" object:a1 userInfo:a2];
  }
  return result;
}

    LOBYTE(v6) = 1;
  }

  return v6;
}

  [v4 drain];
  unint64_t v13 = 0LL;

  if (v10) {
    return 0LL;
  }
  else {
    return v9;
  }
}

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) && [v2 count])
  {
    uint64_t v11 = +[NSCKRecordZoneMoveReceipt _fetchReceiptsMatchingSubPredicates:inManagedObjectContext:persistentStore:error:]( (uint64_t)&OBJC_CLASS___NSCKRecordZoneMoveReceipt,  (uint64_t)v2,  *(void **)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
    if (v11)
    {
      [*(id *)(a1 + 56) addObjectsFromArray:v11];
    }

    else
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
      uint64_t v12 = *(id *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
    }
  }

    objc_autoreleasePoolPop(v4);
  }

  sqlite3_result_int(a1, 0);
LABEL_14:
  if (v8) {
    CFRelease(v8);
  }
}

  uint64_t v2 = &OBJC_IVAR____NSPersistentHistoryToken__storeTokens;
  if (!a1[9])
  {
    uint64_t v10 = objc_alloc(NSString);
    uint64_t v11 = @"Z";
    if (v5)
    {
      uint64_t v12 = *(unsigned int *)(v5 + 184);
LABEL_16:
      unint64_t v13 = (void *)[v10 initWithFormat:@"%@_%d%@", v11, v12, objc_msgSend((id)objc_msgSend((id)a2, "name"), "uppercaseString")];
      if (v5) {
        uint64_t v14 = *(void *)(v5 + 176);
      }
      else {
        uint64_t v14 = 0LL;
      }
      unsigned int v15 = -[NSSQLStoreMappingGenerator uniqueNameWithBase:](v14, v13);
      uint64_t v16 = *(void **)((char *)a1 + v2[69]);
      if (v16 != (void *)v15)
      {
        uint64_t v17 = (void *)v15;

        *(void *)((char *)a1 + v2[69]) = [v17 copy];
      }

      goto LABEL_21;
    }

      if (++v10 == v8)
      {
        id v8 = [v6 countByEnumeratingWithState:&v37 objects:v41 count:16];
        if (v8) {
          goto LABEL_4;
        }
        goto LABEL_20;
      }
    }

    do
    {
      unint64_t v13 = __ldaxr(IndexedIvars);
      if (v13 != -1)
      {
        __clrex();
        goto LABEL_13;
      }
    }

    while (__stlxr(0, IndexedIvars));
    if (v11)
    {
LABEL_17:
      uint64_t v14 = (unsigned int *)object_getIndexedIvars(v11);
      do
        unsigned int v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
      goto LABEL_33;
    }
  }

  if (!a3) {
    return 0;
  }
  id v24 = 0;
  *a3 = v15;
  return v24;
}

  uint64_t v16 = *((unsigned __int8 *)v48 + 24);
  _Block_object_dispose(&v47, 8);
  if (v16)
  {
    uint64_t v17 = a3;
    if (!v5) {
      goto LABEL_22;
    }
    objc_opt_self();
    os_log_type_t v18 = (const __CFString *)MEMORY[0x189604A88];
    uint64_t v17 = (id)objc_msgSend( MEMORY[0x189604030],  "fileURLWithPath:",  -[NSString stringByAppendingPathComponent:]( -[NSString stringByAppendingPathComponent:]( -[NSString stringByAppendingPathComponent:]( NSTemporaryDirectory(),  "stringByAppendingPathComponent:",  @"cdutil"),  "stringByAppendingPathComponent:",  objc_msgSend((id)objc_msgSend(MEMORY[0x189607AB8], "UUID"), "UUIDString")),  "stringByAppendingPathComponent:",  objc_msgSend(a3, "lastPathComponent")));
    uint64_t v47 = 0LL;
    if (+[NSCloudKitMirroringDelegate checkAndCreateDirectoryAtURL:wipeIfExists:error:]( NSCloudKitMirroringDelegate,  "checkAndCreateDirectoryAtURL:wipeIfExists:error:",  [v17 URLByDeletingLastPathComponent],  1,  &v47))
    {
      unint64_t v58 = @"NSReadOnlyPersistentStoreOption";
      v59[0] = v18;
      uint64_t v19 = [MEMORY[0x189603F68] dictionaryWithObjects:v59 forKeys:&v58 count:1];
      uint64_t v56 = @"NSReadOnlyPersistentStoreOption";
      uint64_t v57 = v18;
      if (-[NSPersistentStoreCoordinator replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:storeType:error:]( v42,  "replacePersistentStoreAtURL:destinationOptions:withPersistentStoreFromURL:sourceOptions:storeType:error:",  v17,  v19,  a3,  [MEMORY[0x189603F68] dictionaryWithObjects:&v57 forKeys:&v56 count:1],  @"SQLite",  &v47))
      {
        goto LABEL_22;
      }

      uint64_t v20 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v21 = (void *)[NSString stringWithFormat:@"Failed to move store to a temporary location: %@\n%@", v17, v47];
    }

    else
    {
      uint64_t v20 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v21 = (void *)[NSString stringWithFormat:@"Failed to create a temporary directory for working on the store.\n%@", v47];
    }

    fputs((const char *)[v21 UTF8String], v20);
    if (!v47)
    {
      unint64_t v34 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringDelegate+CLI.m");
      int v41 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringDelegate+CLI.m";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 303;
        _os_log_fault_impl( &dword_186681000,  v41,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }

  if (-[NSArray count]( -[NSPersistentStoreRequest affectedStores]( -[NSSQLPersistentHistoryChangeRequestContext request](self, "request"),  "affectedStores"),  "count"))
  {
    objc_msgSend( v3,  "setAffectedStores:",  -[NSPersistentStoreRequest affectedStores]( -[NSSQLPersistentHistoryChangeRequestContext request](self, "request"),  "affectedStores"));
  }

  id v8 = -[NSSQLFetchRequestContext initWithRequest:context:sqlCore:]( objc_alloc(&OBJC_CLASS___NSSQLFetchRequestContext),  "initWithRequest:context:sqlCore:",  v3,  self->super._context,  self->super._sqlCore);
  uint64_t v9 = v8;
  if (v8) {
    id v8 = (NSSQLFetchRequestContext *)v8->super._context;
  }
  -[NSSQLFetchRequestContext _setAllowAncillaryEntities:](v8, "_setAllowAncillaryEntities:", 1LL);
  return v9;
}

void sub_1866DC398(_Unwind_Exception *a1)
{
}

void sub_1866DC3B0(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1866DC3BCLL);
}

void sub_1866DCDF8(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v3 = objc_begin_catch(exception_object);
    v2[2] = 0LL;

    objc_exception_throw(v3);
    __break(1u);
    JUMPOUT(0x1866DCE38LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1866DCFB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1866DD31C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

#error "1866DD658: call analysis failed (funcsize=79)"
void -[NSXPCStoreConnection sendMessageWithContext:](void *a1, uint64_t a2)
{
  id v3;
  SEL v4;
  SEL v5;
  id newValue;
  if (a1)
  {
    newValue = 0LL;
    if (a2)
    {
      id v3 = -[NSXPCStoreConnection sendMessage:store:error:](a1, *(void *)(a2 + 16), *(void **)(a2 + 8), &newValue);
      objc_setProperty_nonatomic((id)a2, v4, v3, 24LL);
      objc_setProperty_nonatomic((id)a2, v5, newValue, 32LL);
    }

    else
    {
      -[NSXPCStoreConnection sendMessage:store:error:](a1, 0LL, 0LL, &newValue);
    }
  }

void sub_1866EB0A4(_Unwind_Exception *a1)
{
}

void sub_1866EB7FC(_Unwind_Exception *a1)
{
}

unint64_t sub_1866EB818(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1866EB81CLL);
  }
  objc_terminate();
  return +[PFCloudKitMetadataModel ancillaryEntityCount](v2, v3);
}

#error "1866ED6CC: call analysis failed (funcsize=46)"
void *-[NSCKRecordMetadata createObjectIDForLinkedRow](void *result)
{
  if (result) {
    return (void *)+[NSCKRecordMetadata createObjectIDForEntityID:primaryKey:inSQLCore:]( (uint64_t)NSCKRecordMetadata,  (void *)[result entityId],  (void *)objc_msgSend(result, "entityPK"),  (void *)objc_msgSend((id)objc_msgSend(result, "objectID"), "persistentStore"));
  }
  return result;
}

void sub_1866EDF8C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866EDF64LL);
  }

  JUMPOUT(0x1866EDF44LL);
}

LABEL_50:
  return v7;
}

  if ([a2 count]) {
    [v13 setObject:a2 forKey:@"inserted"];
  }
  if ([v55 count]) {
    [v13 setObject:v55 forKey:@"deleted"];
  }
  uint64_t v29 = v56;
  if ([a4 count]) {
    [v13 setObject:a4 forKey:@"updated"];
  }
  if (![a5 count]) {
    goto LABEL_74;
  }
  [v13 setObject:a5 forKey:@"refreshed_objectIDs"];
  __int16 v30 = [a5 count];
  uint64_t v31 = v30;
  if (v30 <= 1) {
    uint64_t v32 = 1LL;
  }
  else {
    uint64_t v32 = v30;
  }
  if (v30 >= 0x201) {
    id v33 = 1LL;
  }
  else {
    id v33 = v32;
  }
  unint64_t v34 = &v52[-((8 * v33 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  if (v30 >= 0x201)
  {
    unint64_t v34 = (_BYTE *)NSAllocateScannedUncollectable();
    [a5 getObjects:v34];
LABEL_67:
    unint64_t v36 = 0LL;
    uint64_t v35 = 0LL;
    do
    {
      uint64_t v37 = [v29 objectRegisteredForID:*(void *)&v34[8 * v36]];
      if (v37) {
        *(void *)&v34[8 * v35++] = v37;
      }
      ++v36;
    }

    while (v31 != v36);
    goto LABEL_71;
  }

  bzero(&v52[-((8 * v33 + 15) & 0xFFFFFFFFFFFFFFF0LL)], 8 * v32);
  [a5 getObjects:v34];
  if (v31) {
    goto LABEL_67;
  }
  uint64_t v35 = 0LL;
LABEL_71:
  uint64_t v38 = (void *)[objc_alloc(MEMORY[0x189604010]) initWithObjects:v34 count:v35];
  if (v31 >= 0x201) {
    NSZoneFree(0LL, v34);
  }
  unint64_t v13 = v57;
  [v57 setObject:v38 forKey:@"refreshed"];

LABEL_74:
  if ([v13 count])
  {
    if (byte_18C4ABDBE) {
      objc_msgSend( v13,  "setObject:forKey:",  +[_PFWeakReference weakReferenceWithObject:]((uint64_t)_PFWeakReference, (uint64_t)v29),  @"managedObjectContext");
    }
    if (v53) {
      [v13 setObject:NSSet_EmptySet forKey:@"NSObjectsChangedByMergeChangesKey"];
    }
    -[NSManagedObjectContext _postObjectsDidChangeNotificationWithUserInfo:]((uint64_t)v29, v13);
  }

  if (*(void *)(v29[21] + 104LL))
  {
    uint64_t v39 = (void *)[v13 mutableCopy];
    if (byte_18C4ABDBE) {
      objc_msgSend( v39,  "setObject:forKey:",  +[_PFWeakReference weakReferenceWithObject:]((uint64_t)_PFWeakReference, (uint64_t)v29),  @"managedObjectContext");
    }
    [v39 removeObjectForKey:@"NSObjectsChangedByMergeChangesKey"];
    [v39 addEntriesFromDictionary:*(void *)(v29[21] + 104)];
    if ([v39 count])
    {
      int v40 = objc_alloc_init(MEMORY[0x189603FC8]);
      if (byte_18C4ABDBE) {
        objc_msgSend( v40,  "setObject:forKey:",  +[_PFWeakReference weakReferenceWithObject:]((uint64_t)_PFWeakReference, (uint64_t)v29),  @"managedObjectContext");
      }
      int v41 = (NSQueryGenerationToken *)[v39 objectForKey:@"newQueryGeneration"];
      if (v41
        || (uint64_t v51 = (NSQueryGenerationToken *)[v29 _queryGenerationToken]) != 0
        && (int v41 = v51,
            v51 != +[NSQueryGenerationToken unpinnedQueryGenerationToken]( &OBJC_CLASS___NSQueryGenerationToken,  "unpinnedQueryGenerationToken"))
        && v41 != +[NSQueryGenerationToken currentQueryGenerationToken]( &OBJC_CLASS___NSQueryGenerationToken,  "currentQueryGenerationToken"))
      {
        [v40 setObject:v41 forKey:@"newQueryGeneration"];
      }

      for (m = 0LL; m != 5; ++m)
      {
        int v43 = (void *)[v39 objectForKey:off_189EA8520[m]];
        if ([v43 count]) {
          unsigned int v44 = (id)+[_PFRoutines newSetOfObjectIDsFromCollection:]((uint64_t)&OBJC_CLASS____PFRoutines, v43);
        }
        else {
          unsigned int v44 = (id)NSSet_EmptySet;
        }
        uint64_t v45 = v44;
        uint64_t v46 = off_189EA8548[m];
        uint64_t v47 = (void *)[v39 objectForKey:v46];
        if ([v45 count] || objc_msgSend(v47, "count"))
        {
          uint32_t v48 = +[_PFRoutines newSetFromCollection:byAddingItems:]((uint64_t)&OBJC_CLASS____PFRoutines, v45, v47);

          [v40 setObject:v48 forKey:v46];
          uint64_t v45 = v48;
        }

        else
        {
          [v40 removeObjectForKey:v46];
        }
      }

      uint64_t v49 = (id)[v40 copy];

      id v50 = (void *)[MEMORY[0x189607958] defaultCenter];
      uint64_t v29 = v56;
      [v50 postNotificationName:@"_NSManagedObjectContextDidMergeChangesObjectIDsPrivateNotification" object:v56 userInfo:v49];
      [v50 postNotificationName:@"NSManagedObjectContextDidMergeChangesObjectIDsNotification" object:v29 userInfo:v49];
      unint64_t v13 = v57;
    }

    *(void *)(v29[21] + 104LL) = 0LL;
  }
}

      *(void *)(a11 + 40) = v71;
      int v150 = 0u;
      uint64_t v151 = 0u;
      uint64_t v152 = 0u;
      uint64_t v153 = 0u;
      uint64_t v77 = [v71 countByEnumeratingWithState:&v150 objects:v156 count:16];
      if (v77)
      {
        uint64_t v78 = v77;
        uint64_t v79 = *(void *)v151;
        do
        {
          for (uint64_t i = 0LL; i != v78; ++i)
          {
            if (*(void *)v151 != v79) {
              objc_enumerationMutation(v71);
            }
            [*(id *)(*((void *)&v150 + 1) + 8 * i) allowEvaluation];
          }

          uint64_t v78 = [v71 countByEnumeratingWithState:&v150 objects:v156 count:16];
        }

        while (v78);
      }

      uint64_t v81 = _newReadPFEncodedArrayFromData(v149, v19, &v155, v30, v145, a16);
      if (!v81)
      {
        if (v20)
        {
          uint64_t v26 = (void *)MEMORY[0x189607870];
          uint64_t v27 = *MEMORY[0x189607460];
          id v28 = (void *)MEMORY[0x189603F68];
          uint64_t v29 = @"Can't read property into shell: Can't read validation warnings";
          goto LABEL_32;
        }

        return 0LL;
      }

      uint64_t v82 = (void *)v81;
      if (v144)
      {
        for (uint64_t j = 0LL; v144 != j; ++j)
        {
          int v84 = (void *)[v82 objectAtIndex:j];
          if (([v84 isNSString] & 1) == 0)
          {
            id v154 = 0LL;
            uint64_t v85 = (void *)MEMORY[0x189604010];
            id v86 = objc_opt_class();
            int v87 = objc_msgSend(v85, "setWithObjects:", v86, objc_opt_class(), 0);
            uint64_t v88 = +[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v87,  (uint64_t)v84,  (uint64_t)&v154);
            if (!v88)
            {
              unsigned int v140 = [(id)a11 name];
              _NSCoreDataLog( 1LL,  (uint64_t)@"Unable to decode validation warning for property %@ : %@",  v130,  v131,  v132,  v133,  v134,  v135,  v140);
              goto LABEL_116;
            }

            [v82 _replaceObject:v88 atIndex:j];
            uint64_t v35 = v143;
          }
        }
      }

      *(void *)(a11 + 4_Block_object_dispose((const void *)(v17 - 112), 8) = v82;
      char v64 = v155;
      unsigned int v68 = v149;
      uint64_t v37 = v141;
    }
  }

  uint64_t v89 = (v64 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v90 = v89 + 4;
  if (v89 + 4 <= v30)
  {
    uint64_t v91 = *(_DWORD *)(v19 + v89);
    int v155 = v90;
    char v64 = v90;
    if (v91)
    {
      id v142 = v37;
      uint64_t v92 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        uint64_t v92 = malloc_default_zone();
      }
      uint64_t v93 = 1;
      id v94 = malloc_zone_calloc(v92, 1uLL, 0x28uLL);
      uint64_t v95 = (v155 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      char v64 = v95 + 4;
      if (v95 + 4 <= v30)
      {
        uint64_t v97 = *(_DWORD *)(v19 + v95);
        int v155 = v95 + 4;
        uint64_t v93 = v97 == 0;
        uint64_t v95 = (v95 + 7) & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v96 = v95 + 4;
      }

      else
      {
        uint64_t v96 = v95 + 4;
        char v64 = v155;
      }

      if (v96 <= v30)
      {
        uint64_t v98 = bswap32(*(_DWORD *)(v19 + v95));
        int v155 = v96;
        char v64 = v96;
      }

      else
      {
        uint64_t v98 = 0LL;
      }

      if (v93)
      {
        uint64_t v99 = 0LL;
      }

      else
      {
        uint64_t v99 = [*(id *)(v145 + 8 * v98) mutableCopy];
        char v64 = v155;
      }

      *id v94 = v99;
      uint64_t v100 = (v64 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      uint64_t v101 = v100 + 8;
      if (v100 + 8 <= v30)
      {
        unint64_t v102 = bswap64(*(void *)(v19 + v100));
        int v155 = v100 + 8;
        uint64_t v100 = (v100 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v103 = v100 + 8;
        char v64 = v101;
      }

      else
      {
        unint64_t v102 = 0LL;
        unint64_t v103 = v100 + 8;
      }

      v94[1] = v102;
      if (v103 <= v30)
      {
        unint64_t v104 = bswap64(*(void *)(v19 + v100));
        int v155 = v103;
        char v64 = v103;
      }

      else
      {
        unint64_t v104 = 0LL;
      }

      v94[2] = v104;
      atomic_store((unint64_t)v94, (unint64_t *)(a11 + 56));
      *(_WORD *)(a11 + 72) &= ~0x80u;
      uint64_t v37 = v142;
    }
  }

  __int16 v105 = (v64 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v106 = v105 + 4;
  if (v105 + 4 <= v30)
  {
    uint64_t v107 = *(_DWORD *)(v19 + v105);
    int v155 = v106;
    char v64 = v106;
    if (v107)
    {
      int v108 = *(void *)(a16 + 8LL * bswap32(v107));
      id v154 = 0LL;
      int v109 = +[_PFRoutines plistClassesForSecureCoding]();
      id v110 = (void *)+[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v109,  v108,  (uint64_t)&v154);
      if (!v110)
      {
        int v138 = [(id)a11 name];
        _NSCoreDataLog( 1LL,  (uint64_t)@"Unable to decode userInfo for property %@ : %@",  v115,  v116,  v117,  v118,  v119,  v120,  v138);
LABEL_116:
        if (v20) {
          *uint64_t v20 = v154;
        }
        return 0LL;
      }

      *(void *)(a11 + 64) = v110;
      char v64 = v155;
    }
  }

  uint64_t v111 = (v64 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v112 = v111 + 4;
  if (v111 + 4 <= v30)
  {
    uint64_t v113 = bswap32(*(_DWORD *)(v19 + v111));
    int v155 = v112;
    char v64 = v112;
  }

  else
  {
    uint64_t v113 = 0;
  }

  *(_WORD *)(a11 + 76) = v113;
  if (v37)
  {
    uint64_t v114 = _readRelationshipIntoShellFromBytes(v68, v19, &v155, v30, (void *)a11, v148);
LABEL_96:
    *os_log_type_t v18 = v155;
    if ((v114 & 1) == 0) {
      return 0LL;
    }
  }

  else
  {
    switch(v35)
    {
      case 0u:
        uint64_t v114 = _readAttributeIntoShellFromBytes(v68, v19, &v155, v30, a11, a14, a16, v145, v20);
        goto LABEL_96;
      case 1u:
        char v127 = (v64 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v128 = v127 + 4;
        if (v127 + 4 <= v30)
        {
          BOOL v129 = bswap32(*(_DWORD *)(v19 + v127));
          char v64 = v128;
        }

        else
        {
          BOOL v129 = 0LL;
        }

        *(void *)(a11 + 96) = *(id *)(v147 + 8 * v129);
        break;
      case 3u:
        uint64_t v114 = _readExpressionDescriptionIntoShellFromBytes(v68, v19, &v155, v30, (void *)a11, a14, a16, v145, v20);
        goto LABEL_96;
      case 4u:
        uint64_t v114 = _readDerivedAttributeIntoShellFromBytes(v68, v19, &v155, v30, a11, a14, a16, v145, v20);
        goto LABEL_96;
      case 5u:
        uint64_t v114 = _readCompositeAttributeIntoShellFromBytes(v68, v19, &v155, v30, a11, a14, a16, v145, v20);
        goto LABEL_96;
      default:
        a11 = 0LL;
        break;
    }

    *os_log_type_t v18 = v64;
  }

  return a11;
}

        [v51 setNeedsDelete:v45];
        [v51 setIsUploaded:v46];
        [v51 setIsPending:v46];
        ++v47;
      }

      while (v43 != v47);
      uint64_t v60 = [v42 countByEnumeratingWithState:&v86 objects:v94 count:16];
      int v43 = v60;
    }

    while (v60);
  }

  uint64_t v61 = v81;
LABEL_67:
}

void sub_1866EE72C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866EE6A4LL);
  }

  JUMPOUT(0x1866EE648LL);
}

void sub_1866EE73C()
{
}

uint64_t sub_1866EE754(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1866EE644LL);
  }
  objc_terminate();
  return +[NSCKRecordMetadata metadataForRecord:inManagedObjectContext:fromStore:error:]();
}

void sub_1866EF0C8( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, uint64_t a17)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1866EEF74LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1866EF8C0(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1866EF7E0LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1866EFE48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

void sub_1866EFE98(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1866EFEB4LL);
  }
  JUMPOUT(0x1866EFE88LL);
}

void sub_1866EFEAC(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1866EFEB4LL);
  }
  JUMPOUT(0x1866EFE88LL);
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void sub_1866F0390( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1866F0288LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1866F0884(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866F085CLL);
  }

  JUMPOUT(0x1866F0844LL);
}

LABEL_106:
            ++v67;
          }

          while (v65 != v67);
          id v110 = [obja countByEnumeratingWithState:&v270 objects:v297 count:16];
          int v65 = v110;
        }

        while (v110);
      }

LABEL_124:
  char v124 = +[NSCKMirroredRelationship fetchMirroredRelationshipsMatchingRelatingRecords:andRelatingRecordIDs:fromStore:inManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMirroredRelationship,  *(void **)(a1 + 8),  MEMORY[0x189604A58],  (uint64_t)v234,  v239,  &v287);
  int v125 = v124;
  if (!v124)
  {
    uint64_t v122 = v287;
    if (v287)
    {
      unint64_t v123 = a4;
      if (a4)
      {
        v231 = 0LL;
        objb = 0LL;
        v223 = 0;
LABEL_160:
        *unint64_t v123 = v122;
        goto LABEL_207;
      }
    }

    else
    {
      unsigned __int8 v189 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v189,  v190,  v191,  v192,  v193,  v194,  v195,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitImportZoneContext.m");
      v196 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        v289 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitImportZoneContext.m";
        v290 = 1024;
        v291 = 444;
        _os_log_fault_impl( &dword_186681000,  v196,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }

    v231 = 0LL;
    objb = 0LL;
    v223 = 0;
    goto LABEL_207;
  }

  v267 = 0u;
  v268 = 0u;
  v265 = 0u;
  v266 = 0u;
  uint64_t v126 = [v124 countByEnumeratingWithState:&v265 objects:v296 count:16];
  if (v126)
  {
    char v127 = *(void *)v266;
    do
    {
      for (uint64_t k = 0LL; k != v126; ++k)
      {
        if (*(void *)v266 != v127) {
          objc_enumerationMutation(v125);
        }
        BOOL v129 = *(void **)(*((void *)&v265 + 1) + 8 * k);
        uint64_t v130 = (void *)MEMORY[0x186E3E5D8]();
        uint64_t v131 = -[NSCKMirroredRelationship createRecordIDForRecord](v129);
        unint64_t v132 = -[NSCKMirroredRelationship createRecordIDForRelatedRecord](v129);
        unint64_t v133 = (id)objc_msgSend(v246, "objectForKey:", objc_msgSend(v129, "cdEntityName"));
        if (!v133)
        {
          unint64_t v133 = objc_alloc_init(MEMORY[0x189603FA8]);
          objc_msgSend(v246, "setObject:forKey:", v133, objc_msgSend(v129, "cdEntityName"));
        }

        [v133 addObject:v131];

        uint64_t v134 = (id)objc_msgSend(v246, "objectForKey:", objc_msgSend(v129, "relatedEntityName"));
        if (!v134)
        {
          uint64_t v134 = objc_alloc_init(MEMORY[0x189603FA8]);
          objc_msgSend(v246, "setObject:forKey:", v134, objc_msgSend(v129, "relatedEntityName"));
        }

        [v134 addObject:v132];

        objc_autoreleasePoolPop(v130);
      }

      uint64_t v126 = [v125 countByEnumeratingWithState:&v265 objects:v296 count:16];
    }

    while (v126);
  }

  objb = objc_alloc_init(MEMORY[0x189603FC8]);
  v263 = 0u;
  v264 = 0u;
  v261 = 0u;
  v262 = 0u;
  v231 = (id)objc_msgSend(objc_alloc(MEMORY[0x189603FE0]), "initWithArray:", objc_msgSend(v246, "allKeys"));
  char v135 = [v231 countByEnumeratingWithState:&v261 objects:v295 count:16];
  if (v135)
  {
    int v136 = *(void *)v262;
    p_cache = &OBJC_CLASS___NSSQLUpdateIntermediate.cache;
    int v138 = (void *)MEMORY[0x189604A58];
LABEL_138:
    int v139 = 0LL;
    v237 = v135;
    while (1)
    {
      if (*(void *)v262 != v136) {
        objc_enumerationMutation(v231);
      }
      unsigned int v140 = (void *)[v246 objectForKey:*(void *)(*((void *)&v261 + 1) + 8 * v139)];
      char v141 = (void *)+[NSCKRecordMetadata createMapOfMetadataMatchingRecords:andRecordIDs:inStore:withManagedObjectContext:error:]( (uint64_t)(p_cache + 473),  v138,  v140,  v234,  v239,  &v287);
      if (v141)
      {
        v259 = 0u;
        v260 = 0u;
        v257 = 0u;
        v258 = 0u;
        id v142 = [v140 countByEnumeratingWithState:&v257 objects:v294 count:16];
        if (v142)
        {
          id v143 = v136;
          uint64_t v144 = p_cache;
          uint64_t v145 = *(void *)v258;
          do
          {
            for (m = 0LL; m != v142; ++m)
            {
              if (*(void *)v258 != v145) {
                objc_enumerationMutation(v140);
              }
              int v147 = *(void *)(*((void *)&v257 + 1) + 8 * m);
              int v148 = (void *)[v141 objectForKey:v147];
              if (v148)
              {
                uint64_t v149 = -[NSCKRecordMetadata createObjectIDForLinkedRow](v148);
                -[PFCloudKitImportZoneContext addObjectID:toCache:andRecordID:](a1, v149, objb, v147);
              }
            }

            id v142 = [v140 countByEnumeratingWithState:&v257 objects:v294 count:16];
          }

          while (v142);
          p_cache = v144;
          int v136 = v143;
          char v135 = v237;
          int v138 = (void *)MEMORY[0x189604A58];
        }
      }

      else
      {
        v223 = 0;
        int v150 = v287;
      }

      if ((v223 & 1) == 0) {
        break;
      }
      if (++v139 == v135)
      {
        char v135 = [v231 countByEnumeratingWithState:&v261 objects:v295 count:16];
        if (v135) {
          goto LABEL_138;
        }
        goto LABEL_162;
      }
    }
  }

  else if ((v223 & 1) != 0)
  {
LABEL_162:
    uint64_t v151 = (id)+[NSCKImportOperation fetchUnfinishedImportOperationsInStore:withManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKImportOperation,  (uint64_t)v234,  v239,  (uint64_t)&v287);
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = v151;
    if (v151)
    {
      v255 = 0u;
      v256 = 0u;
      v253 = 0u;
      v254 = 0u;
      v222 = v151;
      uint64_t v152 = [v151 countByEnumeratingWithState:&v253 objects:v293 count:16];
      if (v152)
      {
        v225 = *(void *)v254;
        do
        {
          uint64_t v153 = 0LL;
          v227 = (char *)v152;
          do
          {
            if (*(void *)v254 != v225) {
              objc_enumerationMutation(v222);
            }
            contexta = v153;
            id v154 = *(void **)(*((void *)&v253 + 1) + 8LL * (void)v153);
            v249 = 0u;
            v250 = 0u;
            v251 = 0u;
            v252 = 0u;
            int v155 = (void *)[v154 pendingRelationships];
            id v156 = [v155 countByEnumeratingWithState:&v249 objects:v292 count:16];
            if (v156)
            {
              v235 = v155;
              v238 = *(void *)v250;
              do
              {
                for (n = 0LL; n != v156; ++n)
                {
                  if (*(void *)v250 != v238) {
                    objc_enumerationMutation(v235);
                  }
                  int v158 = *(void **)(*((void *)&v249 + 1) + 8 * n);
                  uint64_t v159 = objc_msgSend( (id)objc_msgSend(v244, "entitiesByName"),  "objectForKey:",  objc_msgSend(v158, "cdEntityName"));
                  uint64_t v160 = objc_msgSend( (id)objc_msgSend(v244, "entitiesByName"),  "objectForKey:",  objc_msgSend(v158, "relatedEntityName"));
                  if (v159) {
                    int v161 = v160 == 0;
                  }
                  else {
                    int v161 = 1;
                  }
                  if (v161)
                  {
                    uint64_t v162 = (void *)MEMORY[0x186E3E5D8](v160);
                    uint64_t v163 = __ckLoggingOverride;
                    uint64_t v164 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Deleting pending relationship because it's entities are no longer in the model: %@"];
                    if (v163 >= 0x10) {
                      __int128 v171 = 16LL;
                    }
                    else {
                      __int128 v171 = v163;
                    }
                    _NSCoreDataLog( v171,  v164,  v165,  v166,  v167,  v168,  v169,  v170,  (uint64_t)"-[PFCloudKitImportZoneContext initializeCachesWithManagedObjectContext:andObservedStore:error:]");
                    objc_autoreleasePoolPop(v162);
                    [v239 deleteObject:v158];
                  }

                  else
                  {
                    __int128 v172 = +[PFCloudKitSerializer recordTypeForEntity:]( (uint64_t)&OBJC_CLASS___PFCloudKitSerializer,  v159);
                    uint64_t v173 = (void *)objc_msgSend( objc_alloc(getCloudKitCKRecordZoneIDClass()),  "initWithZoneName:ownerName:",  objc_msgSend(v158, "recordZoneName"),  objc_msgSend(v158, "recordZoneOwnerName"));
                    uint64_t v174 = (void *)objc_msgSend( objc_alloc(getCloudKitCKRecordIDClass()),  "initWithRecordName:zoneID:",  objc_msgSend(v158, "recordName"),  v173);
                    uint64_t v175 = (void *)objc_msgSend( objc_alloc(getCloudKitCKRecordZoneIDClass()),  "initWithZoneName:ownerName:",  objc_msgSend(v158, "relatedRecordZoneName"),  objc_msgSend(v158, "relatedRecordZoneOwnerName"));
                    uint64_t v176 = (void *)objc_msgSend( objc_alloc(getCloudKitCKRecordIDClass()),  "initWithRecordName:zoneID:",  objc_msgSend(v158, "relatedRecordName"),  v175);
                    uint64_t v177 = [v173 isEqual:v175];
                    if ((v177 & 1) == 0)
                    {
                      v178 = [NSString stringWithUTF8String:"Import is attempting to link objects across zones: %@"];
                      _NSCoreDataLog(17LL, v178, v179, v180, v181, v182, v183, v184, (uint64_t)v158);
                      id v185 = (os_log_s *)__pflogFaultLog;
                      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 138412290;
                        v289 = (const char *)v158;
                        _os_log_fault_impl( &dword_186681000,  v185,  OS_LOG_TYPE_FAULT,  "CoreData: Import is attempting to link objects across zones: %@",  buf,  0xCu);
                      }
                    }

                    -[PFCloudKitImportZoneContext addUnresolvedRecordID:forRecordType:toCache:]( (uint64_t)v174,  v172,  *(void **)(a1 + 72));
                    int v186 = +[PFCloudKitSerializer recordTypeForEntity:]( (uint64_t)PFCloudKitSerializer,  objc_msgSend( (id)objc_msgSend(v244, "entitiesByName"),  "objectForKey:",  objc_msgSend(v158, "relatedEntityName")));
                    -[PFCloudKitImportZoneContext addUnresolvedRecordID:forRecordType:toCache:]( (uint64_t)v176,  v186,  *(void **)(a1 + 72));
                    if ((objc_msgSend((id)objc_msgSend(v233, "objectForKey:", v172), "containsObject:", v174) & 1) != 0
                      || objc_msgSend( (id)objc_msgSend(v233, "objectForKey:", v186),  "containsObject:",  v176))
                    {
                      [v239 deleteObject:v158];
                    }
                  }
                }

                id v156 = [v235 countByEnumeratingWithState:&v249 objects:v292 count:16];
              }

              while (v156);
            }

            uint64_t v153 = contexta + 1;
          }

          while (contexta + 1 != v227);
          uint64_t v152 = [v222 countByEnumeratingWithState:&v253 objects:v293 count:16];
        }

        while (v152);
      }

      *(void *)(a1 + 64) = objb;
      *(void *)(a1 + 32) = [v220 copy];
      *(void *)(a1 + 4_Block_object_dispose(va, 8) = [v243 copy];
      *(void *)(a1 + 56) = [v218 copy];
      *(void *)(a1 + 40) = v219;
      *(void *)(a1 + 112) = [v232 copy];
      int v187 = objc_alloc_init(MEMORY[0x189603FE0]);
      unsigned int v188 = *(void **)(a1 + 16);
      v248[0] = MEMORY[0x1895F87A8];
      v248[1] = 3221225472LL;
      v248[2] = __95__PFCloudKitImportZoneContext_initializeCachesWithManagedObjectContext_andObservedStore_error___block_invoke_46;
      v248[3] = &unk_189EA7910;
      v248[4] = a1;
      v248[5] = v187;
      [v188 enumerateKeysAndObjectsUsingBlock:v248];
      *(void *)(a1 + 24) = [v187 copy];

      goto LABEL_207;
    }

    v205 = v287;
    v223 = 0;
  }

  if (v287)
  {
    if (a4) {
      *a4 = v287;
    }
  }

  else
  {
    v206 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v206,  v207,  v208,  v209,  v210,  v211,  v212,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitImportZoneContext.m");
    v213 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315394;
      v289 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitImportZoneContext.m";
      v290 = 1024;
      v291 = 439;
      _os_log_fault_impl( &dword_186681000,  v213,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    }
  }

  v214 = v287;
LABEL_207:
  v215 = v223 & 1;

  return v215;
}

                    v21 += 3;
                    if (!--v19) {
                      goto LABEL_148;
                    }
                    break;
                  default:
                    if (v24)
                    {
LABEL_68:
                      if (!objc_msgSend((id)objc_msgSend(*v21, "propertyDescription"), "superCompositeAttribute")) {
                        goto LABEL_66;
                      }
LABEL_69:
                      setMultiColumnValueNullFlag((char *)v16, (_DWORD *)v21 - 4);
                      goto LABEL_124;
                    }

                    unint64_t v59 = (const UInt8 *)((unint64_t)&v20[v23] & v27);
                    uint64_t v60 = (int *)(v59 + 4);
                    uint64_t v61 = CFDataCreate(0LL, v59 + 4, *(int *)v59);
                    uint64_t v62 = v61;
                    uint64_t v63 = *(int *)v59;
                    char v64 = *((unsigned __int8 *)v21 - 4);
                    if (v64 != 11)
                    {
                      if (v64 != 15) {
                        goto LABEL_122;
                      }
                      int v65 = (const __CFData *)+[_PFRoutines retainedDecodeValue:forTransformableAttribute:]( (uint64_t)_PFRoutines,  (uint64_t)v61,  (void *)[*v21 propertyDescription]);
                      goto LABEL_108;
                    }

                    if (-[__CFData length](v61, "length") == 16)
                    {
                      int v65 = (const __CFData *)objc_msgSend( objc_alloc(MEMORY[0x189607AB8]),  "initWithUUIDBytes:",  -[__CFData bytes](v62, "bytes"));
LABEL_108:
                      uint64_t v82 = v65;
                      CFRelease(v62);
                      uint64_t v62 = v82;
                      goto LABEL_122;
                    }

                    uint64_t v62 = 0LL;
LABEL_122:
                    uint64_t v20 = (unsigned __int8 *)v60 + v63;
                    if (objc_msgSend((id)objc_msgSend(*v21, "propertyDescription"), "superCompositeAttribute"))
                    {
                      setMultiColumnValueDictionary((char *)v16, v21 - 2, v62);

                      goto LABEL_124;
                    }

                    uint64_t v54 = *v26;
                    uint64_t v55 = (char *)v16;
                    uint64_t v56 = (uint64_t)v62;
                    goto LABEL_76;
                }
              }
            }

void sub_1866F7748()
{
}

uint64_t sub_1866F7760(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1866F766CLL);
  }
  objc_terminate();
  return __95__PFCloudKitImportZoneContext_initializeCachesWithManagedObjectContext_andObservedStore_error___block_invoke();
}

void sub_1866F8280( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

void sub_1866F85A8(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1866F8558LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1866F9360()
{
}

void sub_1866F936C()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x1866F9374LL);
  }
  JUMPOUT(0x1866F9378LL);
}

void sub_1866F95BC(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866F958CLL);
  }

  JUMPOUT(0x1866F9560LL);
}

void sub_1866F98C0(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866F9890LL);
  }

  JUMPOUT(0x1866F9870LL);
}

void sub_1866F9EA0(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866F9E6CLL);
  }

  JUMPOUT(0x1866F9E44LL);
}

void sub_1866FA500(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1866FA4D0LL);
  }

  JUMPOUT(0x1866FA4B0LL);
}

void sub_1866FA6C4()
{
}

void sub_1866FA6D0()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x1866FA6D8LL);
  }
  JUMPOUT(0x1866FA6DCLL);
}

Method _PFKeyValueMethodForPattern(objc_class *a1, char *__s, const char *a3)
{
  v12[1] = *MEMORY[0x1895F89C0];
  strlen(__s);
  size_t v6 = strlen(a3);
  MEMORY[0x1895F8858](v6);
  id v8 = (char *)v12 - v7;
  snprintf((char *)v12 - v7, v9, __s, a3, a3);
  if ((-[objc_class _classShouldAlwaysRegisterSelectorNamed:](a1, "_classShouldAlwaysRegisterSelectorNamed:", v8) & 1) != 0
    || !BYTE2(dword_18C4ABDC0))
  {
    uint64_t v10 = sel_registerName(v8);
  }

  else
  {
    uint64_t v10 = (const char *)sel_lookUpByName();
  }

  return class_getInstanceMethod(a1, v10);
}

LABEL_78:
        SEL v3 = obj;
      }

      else
      {
        unint64_t v58 = objc_alloc(MEMORY[0x189607870]);
        unint64_t v59 = [MEMORY[0x189603F68] dictionaryWithObject:@"Each destination entity must have a unique renaming identifier" forKey:@"reason"];
        uint64_t v60 = [v58 initWithDomain:*MEMORY[0x189607460] code:134190 userInfo:v59];
        v85->_entityMappings = (NSMutableArray *)v60;
        if (a2) {
          *a2 = v60;
        }

        id v2 = 0LL;
        SEL v3 = v9;
      }
    }

    else
    {
      uint64_t v55 = objc_alloc(MEMORY[0x189607870]);
      uint64_t v56 = [MEMORY[0x189603F68] dictionaryWithObject:@"Each source entity must have a unique renaming identifier" forKey:@"reason"];
      uint64_t v57 = [v55 initWithDomain:*MEMORY[0x189607460] code:134190 userInfo:v56];
      v85->_entityMappings = (NSMutableArray *)v57;
      id v2 = 0LL;
      if (a2) {
        *a2 = v57;
      }
    }
  }

  return v2;
}

          uint64_t v51 = (v38 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v52 = v51 + 4;
          if (v51 + 4 > v6
            || (uint64_t v53 = *(_DWORD *)(v11 + v51), v115 = v52, !v53)
            || !BYTE3(z9dsptsiQ80etb9782fsrs98bfdle88))
          {
LABEL_79:

            return 1LL;
          }

          uint64_t v113 = objc_alloc_init(MEMORY[0x1896077E8]);
          uint64_t v54 = (void *)[MEMORY[0x189603FA8] array];
          uint64_t v55 = (v115 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v56 = v55 + 4;
          if (v55 + 4 <= v6)
          {
            uint64_t v57 = *(_DWORD *)(v11 + v55);
            uint64_t v115 = v56;
            if (v57)
            {
              unint64_t v58 = bswap32(v57);
              do
              {
                unint64_t v59 = _newReadStringFromBytes(v11, &v115, v6);
                if (!v59) {
                  goto LABEL_120;
                }
                uint64_t v60 = v59;
                [v54 addObject:v59];
              }

              while (--v58);
            }
          }

          uint64_t v61 = (void *)[MEMORY[0x189603FA8] array];
          uint64_t v62 = (v115 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v63 = v62 + 4;
          if (v62 + 4 <= v6)
          {
            char v64 = *(_DWORD *)(v11 + v62);
            uint64_t v115 = v63;
            if (v64)
            {
              int v65 = bswap32(v64);
              while (1)
              {
                int v66 = _newReadStringFromBytes(v11, &v115, v6);
                if (!v66) {
                  break;
                }
                int v67 = v66;
                [v61 addObject:v66];

                if (!--v65) {
                  goto LABEL_92;
                }
              }

      LOBYTE(v11) = 1;
      return v11;
    }

    if (!-[NSRelationshipDescription isOrdered](self, "isOrdered") && ([*a3 isNSSet] & 1) == 0
      || (uint64_t v88 = v14, -[NSRelationshipDescription isOrdered](self, "isOrdered"))
      && ([*a3 isNSOrderedSet] & 1) == 0)
    {
      int v74 = (void *)MEMORY[0x189603F70];
      unsigned int v75 = *MEMORY[0x189603A58];
      int v76 = objc_msgSend( NSString,  "stringWithFormat:",  @"Illegal container for relationship: value = %@; relationship = %@.",
              *a3,
              a4);
      objc_exception_throw((id)objc_msgSend( v74,  "exceptionWithName:reason:userInfo:",  v75,  v76,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObject:forKey:", *a3, a4)));
      LOBYTE(v11) = _readRelationshipIntoShellFromBytes(v77, v78, v79, v80, v81, v82);
      return v11;
    }

    uint64_t v89 = -[NSPropertyDescription isOptional](self, "isOptional");
    if (!self)
    {
LABEL_46:
      uint64_t v38 = v93;
      if (v93)
      {
        uint64_t v39 = *a3;
        int v40 = a5;
        int v41 = 1550;
LABEL_48:
        int v42 = a4;
        int v43 = 0LL;
LABEL_49:
        unsigned int v44 = -[NSManagedObject _generateErrorWithCode:andMessage:forKey:andValue:additionalDetail:]( (uint64_t)v40,  v41,  0LL,  (uint64_t)v42,  (uint64_t)v39,  v43);
        LOBYTE(v11) = 0;
        *uint64_t v38 = v44;
        return v11;
      }

      goto LABEL_89;
    }

    uint64_t v22 = *a3;
    uint64_t v23 = -[NSRelationshipDescription destinationEntity](self, "destinationEntity");
    if (([v22 isFault] & 1) == 0)
    {
      if ([v22 count])
      {
        uint64_t v98 = 0u;
        uint64_t v99 = 0u;
        uint64_t v97 = 0u;
        uint64_t v96 = 0u;
        id v24 = [v22 countByEnumeratingWithState:&v96 objects:v100 count:16];
        if (v24)
        {
          os_log_type_t v25 = v24;
          uint64_t v26 = *(char **)v97;
          id v94 = *(char **)v97;
LABEL_26:
          uint64_t v27 = 0LL;
          while (1)
          {
            if (!v23) {
              goto LABEL_46;
            }
            id v28 = *(void **)(*((void *)&v96 + 1) + 8 * v27);
            if (!v28
              || !-[NSEntityDescription _subentitiesIncludes:]( v23,  "_subentitiesIncludes:",  _PFEntityForManagedObject(v28)))
            {
              goto LABEL_46;
            }

            ++v27;
            uint64_t v26 = v94;
            if (v25 == v27)
            {
              os_log_type_t v25 = [v22 countByEnumeratingWithState:&v96 objects:v100 count:16];
              uint64_t v26 = v94;
              if (v25) {
                goto LABEL_26;
              }
              break;
            }
          }
        }
      }
    }

    uint64_t v29 = v89;
    LOBYTE(v11) = 1;
    if ((v89 & v13) != 1 && v12 | v13 ^ 1)
    {
      if ((_BYTE)z9dsptsiQ80etb9782fsrs98bfdle88)
      {
        __int16 v30 = *a3;
        uint64_t v31 = [*a3 count];
        if (v31)
        {
          uint64_t v32 = v31;
          uint64_t v90 = -[NSRelationshipDescription deleteRule]( -[NSRelationshipDescription inverseRelationship](self, "inverseRelationship"),  "deleteRule");
          int v87 = -[NSRelationshipDescription isOrdered](self, "isOrdered");
          uint64_t v85 = (uint64_t)&v85;
          id v33 = v32 >= 0x201 ? 1LL : v32;
          unint64_t v34 = (8 * v33 + 15) & 0xFFFFFFFFFFFFFFF0LL;
          uint64_t v35 = (char *)&v85 - v34;
          if (v32 > 0x200) {
            uint64_t v35 = (char *)NSAllocateScannedUncollectable();
          }
          else {
            bzero((char *)&v85 - v34, 8 * v32);
          }
          id v94 = v35;
          objc_msgSend(v30, "getObjects:", v35, v85);
          uint64_t v45 = 0LL;
          uint64_t v46 = 0LL;
          uint64_t v47 = 1;
          id v86 = @"NSAffectedObjectsErrorKey";
          uint32_t v48 = v93;
          uint64_t v92 = v32;
          do
          {
            uint64_t v49 = *(_BYTE **)&v94[8 * v46];
            if (v49 && (v49[16] & 0x24) != 0)
            {
              [a5 objectID];
              [v49 objectID];
              _NSCoreDataLog( 4LL,  (uint64_t)@"repairing missing delete propagation for to-many relationship %@ on object %p (%@) with bad fault %p (%@)",  v50,  v51,  v52,  v53,  v54,  v55,  (uint64_t)a4);
              if (v90 == NSCascadeDeleteRule)
              {
                if (![a5 managedObjectContext]) {
                  -[NSManagedObjectContext _forceRegisterLostFault:]([a5 managedObjectContext], a5);
                }
                objc_msgSend((id)objc_msgSend(a5, "managedObjectContext"), "deleteObject:", a5);
              }

              uint64_t v32 = v92;
              if (!v45)
              {
                if (v87) {
                  uint64_t v56 = [a5 mutableOrderedSetValueForKey:a4];
                }
                else {
                  uint64_t v56 = [a5 mutableSetValueForKey:a4];
                }
                uint64_t v45 = (void *)v56;
              }

              [v45 removeObject:v49];
            }

            else
            {
              if (v91 && ![v49 managedObjectContext]) {
                [v88 insertObject:v49];
              }
              isValidRelationshipDestination = -[NSManagedObject _isValidRelationshipDestination__]((uint64_t)v49);
              v47 &= isValidRelationshipDestination;
              if (v48 && (isValidRelationshipDestination & 1) == 0)
              {
                unint64_t v58 = *a3;
                unint64_t v59 = (void *)MEMORY[0x189603F68];
                uint64_t v60 = [MEMORY[0x189603F18] arrayWithObject:v49];
                uint64_t v61 = [MEMORY[0x189603FE8] null];
                uint64_t v62 = [MEMORY[0x189607968] numberWithBool:1];
                int v84 = v61;
                uint32_t v48 = v93;
                uint64_t v63 = objc_msgSend( v59,  "dictionaryWithObjectsAndKeys:",  v60,  v86,  v84,  @"Dangling reference to an invalid object.",  v62,  @"NSValidationErrorShouldAttemptRecoveryKey",  0);
                char v64 = (uint64_t)v58;
                uint64_t v32 = v92;
                uint64_t v47 = 0;
                *uint32_t v48 = -[NSManagedObject _generateErrorWithCode:andMessage:forKey:andValue:additionalDetail:]( (uint64_t)a5,  1550,  0LL,  (uint64_t)a4,  v64,  v63);
              }
            }

            ++v46;
          }

          while (v32 != v46);
          if (v32 >= 0x201) {
            NSZoneFree(0LL, v94);
          }
          uint64_t v29 = v89;
          if ((v47 & 1) == 0) {
            goto LABEL_89;
          }
        }
      }

      int v65 = -[NSRelationshipDescription minCount](self, "minCount");
      int v66 = -[NSRelationshipDescription maxCount](self, "maxCount");
      int v67 = [*a3 count];
      if (v67) {
        unsigned int v68 = 0;
      }
      else {
        unsigned int v68 = v29;
      }
      if (v68) {
        goto LABEL_78;
      }
      int v69 = v67;
      if (v65 && v67 < v65)
      {
        uint64_t v38 = v93;
        if (v93)
        {
          uint64_t v39 = *a3;
          int v40 = a5;
          int v41 = 1580;
          goto LABEL_48;
        }

                uint64_t v7 = v57;
                if (*(_BYTE *)(v13 + 88)) {
                  return 1LL;
                }
                goto LABEL_79;
              }

void sub_1866FD23C(_Unwind_Exception *a1)
{
}

void __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

void sub_1867015F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id location, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void sub_186701B7C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const __CFString *a10, uint64_t a11, uint64_t a12, const __CFString *a13)
{
  if (a2 == 1)
  {
    id v14 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v13 + 64) + 8LL) + 24LL) = 0;
    id v15 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v16 = *MEMORY[0x1896075F0];
    a10 = @"NSUnderlyingException";
    a11 = v16;
    a12 = (uint64_t)v14;
    a13 = @"Import failed because creating the zone query hit an unhandled exception.";
    uint64_t v17 = [MEMORY[0x189603F68] dictionaryWithObjects:&a12 forKeys:&a10 count:2];
    *(void *)(*(void *)(*(void *)(v13 + 72) + 8) + 40) = [v15 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v17];
    objc_end_catch();
    JUMPOUT(0x186701B3CLL);
  }

  _Unwind_Resume(exception_object);
}

void sub_186702194( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const __CFString *a10, uint64_t a11, uint64_t a12, const __CFString *a13)
{
  if (a2 == 1)
  {
    id v14 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v13 + 64) + 8LL) + 24LL) = 0;
    id v15 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v16 = *MEMORY[0x1896075F0];
    a10 = @"NSUnderlyingException";
    a11 = v16;
    a12 = (uint64_t)v14;
    a13 = @"Import failed because applying the zone query metadata changes hit an unhandled exception.";
    uint64_t v17 = [MEMORY[0x189603F68] dictionaryWithObjects:&a12 forKeys:&a10 count:2];
    *(void *)(*(void *)(*(void *)(v13 + 56) + 8) + 40) = [v15 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v17];
    objc_end_catch();
    JUMPOUT(0x18670214CLL);
  }

  _Unwind_Resume(exception_object);
}

void __LoadCoreAnalytics_block_invoke()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  _MergedGlobals_64 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/CoreAnalytics.framework/CoreAnalytics", 2);
  if (!_MergedGlobals_64 && os_log_type_enabled(MEMORY[0x1895F8DA0], OS_LOG_TYPE_FAULT))
  {
    int v0 = 136315138;
    uint64_t v1 = dlerror();
    _os_log_fault_impl( &dword_186681000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_FAULT,  "### Failed to Soft Link: /System/Library/PrivateFrameworks/CoreAnalytics.framework/CoreAnalytics\n%s",  (uint8_t *)&v0,  0xCu);
  }

uint64_t (*initAnalyticsSendEvent())()
{
  if (qword_18C4AB8B8 != -1) {
    dispatch_once(&qword_18C4AB8B8, &__block_literal_global_3);
  }
  os_log_t result = (uint64_t (*)())dlsym((void *)_MergedGlobals_64, "AnalyticsSendEvent");
  softLinkAnalyticsSendEvent = result;
  return result;
}

void _PFInvokeMutationMethodForEachMemberOfSet(void *a1, objc_method *a2, void *a3)
{
  v12[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = [a3 count];
  if (v6)
  {
    unint64_t v7 = v6;
    unint64_t v8 = MEMORY[0x1895F8858](v6);
    uint64_t v10 = (char *)v12 - v9;
    if (v8 > 0x200) {
      uint64_t v10 = (char *)NSAllocateScannedUncollectable();
    }
    else {
      bzero((char *)v12 - v9, 8 * v8);
    }
    [a3 getObjects:v10];
    for (uint64_t i = 0LL; i != v7; ++i)
      method_invoke(a1, a2, *(void *)&v10[8 * i]);
    if (v7 >= 0x201) {
      NSZoneFree(0LL, v10);
    }
  }

void ancillaryModelObjectBlock_block_invoke(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  v60[1] = *MEMORY[0x1895F89C0];
  if (objc_msgSend(@"TRANSACTION", "isEqualToString:", objc_msgSend(a2, "entityName")))
  {
    uint64_t v9 = -[_NSPersistentHistoryTransaction initWithDictionary:andObjectID:]( objc_alloc(&OBJC_CLASS____NSPersistentHistoryTransaction),  "initWithDictionary:andObjectID:",  a4,  a5);
    if (objc_msgSend((id)objc_msgSend(a2, "relationshipKeyPathsForPrefetching"), "count") && v9)
    {
      uint64_t v10 = objc_alloc(&OBJC_CLASS___NSPersistentHistoryChangeRequest);
      v60[0] = objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedLongLong:", objc_msgSend(a5, "_referenceData64"));
      uint64_t v11 = -[NSPersistentHistoryChangeRequest initWithTransactionIDs:]( v10,  "initWithTransactionIDs:",  [MEMORY[0x189603F18] arrayWithObjects:v60 count:1]);
      -[NSPersistentHistoryChangeRequest setFetchBatchSize:](v11, "setFetchBatchSize:", [a2 fetchLimit]);
      if (objc_msgSend((id)objc_msgSend(a2, "affectedStores"), "count")) {
        -[NSPersistentStoreRequest setAffectedStores:](v11, "setAffectedStores:", [a2 affectedStores]);
      }
      id v12 = objc_alloc_init(MEMORY[0x1896077E8]);
      id v55 = 0LL;
      uint64_t v19 = (void *)objc_msgSend((id)objc_msgSend(a3, "executeRequest:error:", v11, &v55), "result");
      if (v19)
      {
        if (v55)
        {
          uint64_t v20 = [NSString stringWithUTF8String:"Batched persistent history request returned a result AND an error %@"];
          _NSCoreDataLog(17LL, v20, v21, v22, v23, v24, v25, v26, (uint64_t)v55);
          uint64_t v27 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138412290;
            id v59 = v55;
            _os_log_fault_impl( &dword_186681000,  v27,  OS_LOG_TYPE_FAULT,  "CoreData: Batched persistent history request returned a result AND an error %@",  buf,  0xCu);
          }
        }

        if ([v19 count])
        {
          [v19 _setTransaction:v9];
          -[_NSPersistentHistoryTransaction _setChanges:](v9, v19);
        }

        [v12 drain];
        id v28 = 0LL;
      }

      else
      {
        _NSCoreDataLog( 1LL,  (uint64_t)@"Batched history request: %@ encountered an error",  v13,  v14,  v15,  v16,  v17,  v18,  (uint64_t)v11);
        _NSCoreDataLog(1LL, (uint64_t)@" \t error: %@", v38, v39, v40, v41, v42, v43, (uint64_t)v55);
        uint64_t v44 = [NSString stringWithUTF8String:"Batched history request encountered error %@"];
        _NSCoreDataLog(17LL, v44, v45, v46, v47, v48, v49, v50, (uint64_t)v55);
        uint64_t v51 = (os_log_s *)__pflogFaultLog;
        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 138412290;
          id v59 = v55;
          _os_log_fault_impl( &dword_186681000,  v51,  OS_LOG_TYPE_FAULT,  "CoreData: Batched history request encountered error %@",  buf,  0xCu);
        }

        uint64_t v52 = [v55 code];
        uint64_t v56 = *MEMORY[0x189607798];
        id v57 = v55;
        uint64_t v53 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:&v57 forKeys:&v56 count:1];
        id v54 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  v52,  (uint64_t)@"Batched persistent history request encountered an error",  v53);
        -[_NSCoreDataException _setDomain:]((uint64_t)v54, (void *)[v55 domain]);
        objc_exception_throw(v54);
        __break(1u);
      }
    }
  }

  else if (objc_msgSend(@"CHANGE", "isEqualToString:", objc_msgSend(a2, "entityName")))
  {
    int v29 = [a4 isNSDictionary];
    __int16 v30 = objc_alloc(&OBJC_CLASS____NSPersistentHistoryChange);
    if (v29) {
      -[_NSPersistentHistoryChange initWithDictionary:andChangeObjectID:]( v30,  "initWithDictionary:andChangeObjectID:",  a4,  a5);
    }
    else {
      -[_NSPersistentHistoryChange initWithManagedObject:](v30, "initWithManagedObject:", a4);
    }
  }

  else
  {
    uint64_t v31 = [a2 entityName];
    _NSCoreDataLog( 9LL,  (uint64_t)@"Error attempted to convert unknown Ancillary Entity: %@",  v32,  v33,  v34,  v35,  v36,  v37,  v31);
  }

void sub_18670595C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186705918LL);
  }

  JUMPOUT(0x186705970LL);
}

void _releaseStaleBatch(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = a2 >> 5;
  int v3 = 1 << ~(_BYTE)a2;
  if ((*(_DWORD *)(*(void *)(a1 + 24) + 4LL * v2) & v3) != 0)
  {
    int v5 = *(_DWORD *)(a1 + 48);
    unsigned int v6 = v5 * a2;
    unsigned int v7 = v5 * a2 + v5;
    if (v7 >= *(_DWORD *)(a1 + 12)) {
      unsigned int v8 = *(_DWORD *)(a1 + 12);
    }
    else {
      unsigned int v8 = v7;
    }
    uint64_t v9 = [*(id *)(a1 + 16) _objectsPointer];
    int v10 = v8 - v6;
    if (v8 > v6)
    {
      uint64_t v11 = (void **)(v9 + 8LL * v6);
      do
      {
        id v12 = *v11;
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          uint64_t v13 = (void *)[v12 objectID];
        }

        else
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
            uint64_t v13 = (void *)[v12 _backingObjectID];
          }
          else {
            uint64_t v13 = (void *)[v12 objectForKey:@"objectID"];
          }
        }

        uint64_t v14 = v13;
        id v15 = v13;
        *v11++ = v14;

        --v10;
      }

      while (v10);
    }

    *(_DWORD *)(*(void *)(a1 + 24) + 4 * v2) &= ~v3;
  }

void sub_18670682C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1867069A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

void minion_duties2(uint64_t a1)
{
  id v2 = objc_alloc_init(MEMORY[0x1896077E8]);
  (*(void (**)(uint64_t))(a1 + 16))(a1);
  [v2 drain];
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  *(_DWORD *)(a1 + 144) = 1;
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 96));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
  CFRelease((CFTypeRef)a1);
}

void _PFPerformDebugZombie(void *a1)
{
  if (a1)
  {
    Class Class = object_getClass(a1);
    if (Class)
    {
      name = 0LL;
      int v3 = class_getName(Class);
      asprintf(&name, "_NSZombie_%s", v3);
      CFStringRef v4 = objc_lookUpClass(name);
      if (!v4)
      {
        int v5 = objc_lookUpClass("_NSZombie_");
        CFStringRef v4 = objc_duplicateClass(v5, name, 0LL);
        if (!v4) {
          CFStringRef v4 = objc_lookUpClass(name);
        }
      }

      if (name) {
        free(name);
      }
      objc_destructInstance(a1);
      object_setClass(a1, v4);
    }

    if (*MEMORY[0x189607488])
    {
      unsigned int v6 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        unsigned int v6 = malloc_default_zone();
      }
      malloc_zone_free(v6, a1);
    }
  }

void _PFDeallocateObjects(void **to_be_freed, unsigned int num)
{
  int v3 = to_be_freed;
  if (*MEMORY[0x1896077C8])
  {
    if (num)
    {
      uint64_t v7 = num;
      do
      {
        if (*v3) {
          _PFPerformDebugZombie(*v3);
        }
        ++v3;
        --v7;
      }

      while (v7);
    }
  }

  else
  {
    if (num)
    {
      uint64_t v4 = num;
      int v5 = to_be_freed;
      do
      {
        if (*v5) {
          objc_destructInstance(*v5);
        }
        ++v5;
        --v4;
      }

      while (v4);
    }

    unsigned int v6 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      unsigned int v6 = malloc_default_zone();
    }
    malloc_zone_batch_free(v6, v3, num);
  }

void *stack_reallocate(void *ptr, size_t size, uint64_t a3, void *a4)
{
  uint64_t v7 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v7 = malloc_default_zone();
  }
  return malloc_zone_realloc(v7, ptr, size);
}

void stack_deallocate(void *ptr, void *a2)
{
  if (*a2 > (unint64_t)ptr || a2[2] <= (unint64_t)ptr)
  {
    --a2[3];
    int v3 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      int v3 = malloc_default_zone();
    }
    malloc_zone_free(v3, ptr);
  }

LABEL_25:
    _NSCoreDataLog(1LL, (uint64_t)@"  MNT_UNKNOWNPERMISSIONS", v129, v130, v131, v132, v133, v134, v196);
    f_flags = v198.f_flags;
    if ((v198.f_flags & 0x800000) == 0)
    {
LABEL_18:
      if ((f_flags & 0x2000000) == 0)
      {
LABEL_20:
        _NSCoreDataLog( 1LL,  (uint64_t)@"  Total data blocks: \t\t%lu",  v129,  v130,  v131,  v132,  v133,  v134,  v198.f_blocks);
        _NSCoreDataLog( 1LL,  (uint64_t)@"  Free data blocks: \t\t%lu",  v136,  v137,  v138,  v139,  v140,  v141,  v198.f_bfree);
        _NSCoreDataLog( 1LL,  (uint64_t)@"  Free blocks for nonsuperuser:\t%lu",  v142,  v143,  v144,  v145,  v146,  v147,  v198.f_bavail);
        _NSCoreDataLog( 1LL,  (uint64_t)@"  Total i-nodes: \t\t\t%lu",  v148,  v149,  v150,  v151,  v152,  v153,  v198.f_files);
        _NSCoreDataLog( 1LL,  (uint64_t)@"  File system ID: \t\t%#x, %#x",  v154,  v155,  v156,  v157,  v158,  v159,  v198.f_fsid.val[0]);
        _NSCoreDataLog( 1LL,  (uint64_t)@"  Free i-nodes: \t\t\t%llu",  v160,  v161,  v162,  v163,  v164,  v165,  v198.f_ffree);
        _NSCoreDataLog(1LL, (uint64_t)@"  Owner UID: \t\t\t%u", v166, v167, v168, v169, v170, v171, v198.f_owner);
        _NSCoreDataLog( 1LL,  (uint64_t)@"  Filesystem type name: \t\t%s",  v172,  v173,  v174,  v175,  v176,  v177,  (uint64_t)v198.f_fstypename);
        _NSCoreDataLog( 1LL,  (uint64_t)@"  Mount on name: \t\t\t%s",  v178,  v179,  v180,  v181,  v182,  v183,  (uint64_t)v198.f_mntonname);
        _NSCoreDataLog( 1LL,  (uint64_t)@"  Mount from name: \t\t%s",  v184,  v185,  v186,  v187,  v188,  v189,  (uint64_t)v198.f_mntfromname);
        return;
      }

    uint64_t v4 = (objc_class *)objc_opt_class();
    return NSStringFromClass(v4);
  }

  if (a2 <= 1799)
  {
    if (a2 != 1100 && a2 != 1200) {
      return (NSString *)NSKeyValueCoding_NullValue;
    }
    goto LABEL_25;
  }

  if (a2 == 1800) {
    return result;
  }
  if (a2 == 2100) {
    goto LABEL_25;
  }
  return (NSString *)NSKeyValueCoding_NullValue;
}

                      ++v11;
                    }

                    while ([v9 count] > v11);
                  }
                }

                if (!v10)
                {
                  uint64_t v22 = (void *)MEMORY[0x189603F70];
                  uint64_t v23 = *MEMORY[0x189603A60];
                  uint64_t v24 = [NSString stringWithFormat:@"Can't find property named %@", v31];
                  uint64_t v50 = @"Property name";
                  uint64_t v51 = v31;
                  objc_exception_throw((id)objc_msgSend( v22,  "exceptionWithName:reason:userInfo:",  v23,  v24,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjects:forKeys:count:",  &v51,  &v50,  1)));
                }

                uint64_t v19 = -[NSFetchIndexElementDescription initWithProperty:collationType:]( objc_alloc(&OBJC_CLASS___NSFetchIndexElementDescription),  "initWithProperty:collationType:",  v10,  0LL);
                [v34 appendFormat:@"_%@", objc_msgSend(v10, "name")];
                [v35 addObject:v19];
              }

              uint64_t v36 = [v30 countByEnumeratingWithState:&v45 objects:v53 count:16];
            }

            while (v36);
          }

          uint64_t v20 = -[NSFetchIndexDescription initWithName:elements:]( objc_alloc(&OBJC_CLASS___NSFetchIndexDescription),  "initWithName:elements:",  v34,  v35);
          -[NSFetchIndexDescription _setIsUnique:]((uint64_t)v20, 1);

          [v27 addObject:v20];
          int v5 = v29 + 1;
        }

        while (v29 + 1 != v28);
        id v28 = [obj countByEnumeratingWithState:&v37 objects:v49 count:16];
      }

      while (v28);
    }
  }

  return v27;
}

  int v10 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL)
    && *(void *)(a1 + 96)
    && !*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL))
  {
    uint64_t v11 = (void *)MEMORY[0x189607870];
    id v12 = (void *)MEMORY[0x189603F68];
    uint64_t v13 = objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:", *(void *)(a1 + 48), *(void *)(a1 + 64), 0);
    uint64_t v14 = objc_msgSend(v12, "dictionaryWithObjectsAndKeys:", v13, *MEMORY[0x189607760], 0);
    *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) = (id)[v11 errorWithDomain:*MEMORY[0x189607460] code:134000 userInfo:v14];
  }

LABEL_26:
  if (!*((_BYTE *)v64 + 24))
  {
    uint64_t v38 = (NSError *)(id)v58[5];
    if (v38)
    {
      if (error) {
        NSError *error = v38;
      }
    }

    else
    {
      uint64_t v39 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentCloudKitContainer.m");
      uint64_t v46 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        unsigned int v68 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSPersistentCloudKitContainer.m";
        int v69 = 1024;
        uint64_t v70 = 307;
        _os_log_fault_impl( &dword_186681000,  v46,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }
  }

  dispatch_release(group);
  v58[5] = 0LL;
  uint64_t v36 = *((_BYTE *)v64 + 24);
  _Block_object_dispose(&v57, 8);
  _Block_object_dispose(&v63, 8);
  return v36;
}

      goto LABEL_27;
    }
  }

  return result;
}

  *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = [a3 containsObject:@"com.apple.coredata.cloudkit.zone.subscription"];
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

      uint64_t v21 = (void *)v13[1].length;
      length = (void *)*((void *)v3 + 7);
      if (length) {
        LODWORD(length) = objc_msgSend((id)objc_msgSend(length, "propertyDescription"), "isOrdered");
      }
LABEL_35:
      if (((v16 | length) & 1) == 0)
      {
        if ((objc_msgSend( (id)objc_msgSend(v3, "correlationTableName"),  "isEqualToString:",  -[__CFString correlationTableName](v13, "correlationTableName")) & 1) == 0)
        {
          uint64_t v24 = -[NSSQLiteAdapter newRenameTableStatementFrom:to:]( v103,  [v3 correlationTableName],  -[__CFString correlationTableName](v13, "correlationTableName"));
          [a2 addObject:v24];
        }

        uint64_t v25 = objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v3, "propertyDescription"), "renamingIdentifier"),  "isEqualToString:",  objc_msgSend((id)-[__CFString propertyDescription](v13, "propertyDescription"), "renamingIdentifier"));
        uint64_t v26 = (void *)[MEMORY[0x189603FA8] arrayWithCapacity:4];
        v142[0] = -[__CFString columnName](v13, "columnName");
        if ((v25 & 1) != 0) {
          uint64_t v27 = (const __CFString *)[v3 columnName];
        }
        else {
          uint64_t v27 = -[NSSQLManyToMany inverseColumnName]((const __CFString *)v3);
        }
        v142[1] = v27;
        objc_msgSend(v26, "addObject:", objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v142, 2));
        v141[0] = -[NSSQLManyToMany inverseColumnName](v13);
        if ((v25 & 1) != 0) {
          id v28 = -[NSSQLManyToMany inverseColumnName]((const __CFString *)v3);
        }
        else {
          id v28 = (const __CFString *)[v3 columnName];
        }
        v141[1] = v28;
        objc_msgSend(v26, "addObject:", objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v141, 2));
        if (v13[2].data)
        {
          if (*((void *)v3 + 10))
          {
            v140[0] = v13[2].data;
            if ((v25 & 1) != 0)
            {
              int v29 = (__CFString *)*((void *)v3 + 10);
              if (!v29) {
                int v29 = (__CFString *)[v3 columnName];
              }
            }

            else
            {
              int v29 = -[NSSQLManyToMany inverseOrderColumnName]((__CFString *)v3);
              if (!v29) {
                int v29 = (__CFString *)-[NSSQLManyToMany inverseColumnName]((const __CFString *)v3);
              }
            }

            v140[1] = v29;
            __int16 v30 = v140;
          }

          else
          {
            v139[0] = v13[2].data;
            v139[1] = &stru_189EAC2E8;
            __int16 v30 = v139;
          }

          objc_msgSend(v26, "addObject:", objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v30, 2));
        }

        uint64_t v31 = -[NSSQLManyToMany inverseOrderColumnName](v13);
        if (v31)
        {
          uint64_t v32 = v31;
          if (-[NSSQLManyToMany inverseOrderColumnName]((__CFString *)v3))
          {
            v138[0] = v32;
            if ((v25 & 1) != 0)
            {
              uint64_t v33 = -[NSSQLManyToMany inverseOrderColumnName]((__CFString *)v3);
              if (!v33) {
                uint64_t v33 = (__CFString *)-[NSSQLManyToMany inverseColumnName]((const __CFString *)v3);
              }
            }

            else
            {
              uint64_t v33 = (__CFString *)*((void *)v3 + 10);
              if (!v33) {
                uint64_t v33 = (__CFString *)[v3 columnName];
              }
            }

            v138[1] = v33;
            uint64_t v34 = v138;
          }

          else
          {
            v137[0] = v32;
            v137[1] = &stru_189EAC2E8;
            uint64_t v34 = v137;
          }

          objc_msgSend(v26, "addObject:", objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v34, 2));
        }

        uint64_t v35 = (void *)[v26 sortedArrayUsingComparator:&__block_literal_global_47];
        int v108 = 0u;
        int v109 = 0u;
        id v110 = 0u;
        uint64_t v111 = 0u;
        uint64_t v36 = [v35 countByEnumeratingWithState:&v108 objects:v136 count:16];
        if (v36)
        {
          uint64_t v37 = v36;
          uint64_t v38 = *(void *)v109;
          do
          {
            for (iuint64_t i = 0LL; ii != v37; ++ii)
            {
              if (*(void *)v109 != v38) {
                objc_enumerationMutation(v35);
              }
              uint64_t v40 = *(void **)(*((void *)&v108 + 1) + 8 * ii);
              if ((objc_msgSend( (id)objc_msgSend(v40, "lastObject"),  "isEqualToString:",  objc_msgSend(v40, "firstObject")) & 1) == 0)
              {
                uint64_t v41 = objc_msgSend((id)objc_msgSend(v40, "lastObject"), "length");
                uint64_t v42 = objc_alloc(NSString);
                uint64_t v43 = -[__CFString correlationTableName](v13, "correlationTableName");
                if (v41) {
                  uint64_t v44 = [v42 initWithFormat:@"ALTER TABLE %@ RENAME COLUMN %@ TO %@", v43, objc_msgSend(v40, "lastObject"), objc_msgSend(v40, "firstObject")];
                }
                else {
                  uint64_t v44 = [v42 initWithFormat:@"ALTER TABLE %@ ADD COLUMN %@ %@", v43, objc_msgSend(v40, "firstObject"), @"INTEGER"];
                }
                uint64_t v45 = (void *)v44;
                uint64_t v46 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  0LL,  v44);

                [a2 addObject:v46];
              }
            }

            uint64_t v37 = [v35 countByEnumeratingWithState:&v108 objects:v136 count:16];
          }

          while (v37);
        }

        unsigned int v6 = v99;
        [*(id *)(v99 + 136) addObject:v13];
        unsigned int v8 = v98;
        uint64_t v9 = v100;
        int v10 = &OBJC_IVAR____NSPersistentHistoryToken__storeTokens;
        goto LABEL_78;
      }

void sub_18670D4C8(_Unwind_Exception *a1)
{
}

void sub_18670D4E4()
{
}

void sub_186710324( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
}

void sub_186710664(_Unwind_Exception *a1)
{
}

void sub_186711064(_Unwind_Exception *a1)
{
}

void sub_18671122C(_Unwind_Exception *a1)
{
}

void sub_186711340(_Unwind_Exception *a1)
{
}

uint64_t _PFCeateStubFileAtPath(char *a1, int a2)
{
  if (!a2) {
    return open(a1, 2562, 420LL);
  }
  uint64_t result = open_dprotected_np(a1, 2562, a2, 0, 420LL);
  if ((_DWORD)result != -1) {
    return result;
  }
  if (*__error() != 45) {
    return 0xFFFFFFFFLL;
  }
  else {
    return open(a1, 2562, 420LL);
  }
}

uint64_t _comparePropertiesByName(void *a1, void *a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "name"), "compare:", objc_msgSend(a2, "name"));
}

uint64_t _compareEntitiesByName(void *a1, void *a2)
{
  return objc_msgSend((id)objc_msgSend(a1, "name"), "compare:", objc_msgSend(a2, "name"));
}

void _writeStringIntoData(void *a1, void *a2, void *a3)
{
  uint64_t v10 = 0LL;
  int v6 = [a2 length];
  uint64_t v7 = 2 * [a1 length];
  unsigned int v9 = bswap32(v7);
  [a2 appendBytes:&v9 length:4];
  [a2 appendBytes:&v10 length:4];
  if ((_DWORD)v7)
  {
    unsigned int v8 = a3;
    [a1 getCharacters:v8];
    [a2 appendBytes:v8 length:v7];
    if (v8 != a3) {
      free(v8);
    }
  }

id _newReadStringFromBytes(uint64_t a1, void *a2, unint64_t a3)
{
  unint64_t v3 = (*a2 + 3LL) & 0xFFFFFFFFFFFFFFFCLL;
  if (v3 + 4 > a3) {
    return 0LL;
  }
  unsigned int v4 = *(_DWORD *)(a1 + v3);
  uint64_t v5 = bswap32(v4);
  unint64_t v6 = v3 + 8;
  if (v6 + v5 > a3) {
    return 0LL;
  }
  *a2 = v6 + v5;
  if (v4) {
    return (id)[objc_alloc(NSString) initWithCharactersNoCopy:a1 + v6 length:v5 >> 1 freeWhenDone:0];
  }
  else {
    return objc_alloc_init(NSString);
  }
}

void _writePFEncodedStringShapeIntoData(void *a1, void *a2, _BYTE *a3)
{
  uint64_t v10 = 0LL;
  int v6 = [a1 length];
  unsigned int v7 = [a2 length];
  [a1 appendBytes:&v10 length:8];
  [a1 appendBytes:&v10 length:4];
  unsigned int v9 = bswap32(v7);
  [a1 appendBytes:&v9 length:4];
  [a1 appendBytes:&v10 length:8];
  if (v7)
  {
    unsigned int v8 = a3;
    if (v7 >= 0x401) {
      unsigned int v8 = malloc(v7 + 1);
    }
    objc_msgSend(a2, "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:", v8, 0, v7, 0);
    v8[v7] = 0;
    [a1 appendBytes:v8 length:v7 + 1];
    if (v8 != a3) {
      free(v8);
    }
  }

  else
  {
    [a1 appendBytes:&v10 length:1];
  }

uint64_t _readPFEncodedStringFromData(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  unsigned int v8 = (objc_class *)_readPFEncodedStringFromData_myStringClass;
  if (!_readPFEncodedStringFromData_myStringClass)
  {
    unsigned int v8 = (objc_class *)objc_opt_class();
    _readPFEncodedStringFromData_myStringClass Class = (uint64_t)v8;
  }

  unint64_t v9 = (*a3 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = v9 + 24;
  if (v9 + 24 > a4) {
    return 0LL;
  }
  uint64_t v12 = a2 + v9;
  object_setClass((id)v12, v8);
  *(void *)(v12 + 16) = a1;
  unsigned int v13 = bswap32(*(_DWORD *)(v12 + 12));
  *(_DWORD *)(v12 + 12) = v13;
  unint64_t v14 = v10 + v13 + 1;
  *a3 = v14;
  if (v14 <= a4) {
    return v12;
  }
  else {
    return 0LL;
  }
}

uint64_t _writeDataIntoData(void *a1, void *a2)
{
  uint64_t v8 = 0LL;
  int v4 = [a2 length];
  unsigned int v5 = [a1 length];
  unsigned int v7 = bswap32(v5);
  [a2 appendBytes:&v7 length:4];
  uint64_t result = [a2 appendBytes:&v8 length:4];
  if (v5) {
    return [a2 appendData:a1];
  }
  return result;
}

id _newReadDataFromBytes(uint64_t a1, void *a2, unint64_t a3)
{
  unint64_t v3 = (*a2 + 3LL) & 0xFFFFFFFFFFFFFFFCLL;
  if (v3 + 4 > a3) {
    return 0LL;
  }
  unsigned int v4 = *(_DWORD *)(a1 + v3);
  uint64_t v5 = bswap32(v4);
  unint64_t v6 = v3 + 8;
  if (v6 + v5 > a3) {
    return 0LL;
  }
  *a2 = v6 + v5;
  if (v4) {
    return (id)[objc_alloc(MEMORY[0x189603F48]) initWithBytesNoCopy:a1 + v6 length:v5 freeWhenDone:0];
  }
  else {
    return objc_alloc_init(MEMORY[0x189603F48]);
  }
}

uint64_t _writePFEncodedDataShapeIntoData(void *a1, void *a2)
{
  uint64_t v8 = 0LL;
  int v4 = [a1 length];
  [a1 appendBytes:&v8 length:8];
  [a1 appendBytes:&v8 length:8];
  unsigned int v5 = [a2 length];
  unsigned int v7 = bswap32(v5);
  [a1 appendBytes:&v7 length:4];
  [a1 appendBytes:&v8 length:4];
  return objc_msgSend(a1, "appendBytes:length:", objc_msgSend(a2, "bytes"), v5);
}

unsigned int *_readPFEncodedDataFromData(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  uint64_t v8 = (objc_class *)_readPFEncodedDataFromData_myDataClass;
  if (!_readPFEncodedDataFromData_myDataClass)
  {
    uint64_t v8 = NSClassFromString((NSString *)@"_PFEncodedData");
    _readPFEncodedDataFromData_myDataClass Class = (uint64_t)v8;
  }

  unint64_t v9 = (*a3 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v10 = v9 + 24;
  if (v9 + 24 > a4) {
    return 0LL;
  }
  uint64_t v12 = (unsigned int *)(a2 + v9);
  *(void *)uint64_t v12 = 0LL;
  object_setClass(v12, v8);
  *((void *)v12 + 1) = a1;
  uint64_t v13 = bswap32(v12[4]);
  v12[4] = v13;
  unint64_t v14 = v10 + v13;
  *a3 = v14;
  if (v14 <= a4) {
    return v12;
  }
  else {
    return 0LL;
  }
}

uint64_t _writePFEncodedArrayShapeIntoData(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v23 = 0LL;
  int v8 = [a1 length];
  [a1 appendBytes:&v23 length:8];
  [a1 appendBytes:&v23 length:8];
  [a1 appendBytes:&v23 length:4];
  unsigned int v22 = bswap32([a2 count]);
  [a1 appendBytes:&v22 length:4];
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  uint64_t result = [a2 countByEnumeratingWithState:&v18 objects:v24 count:16];
  if (result)
  {
    unint64_t v10 = result;
    uint64_t v11 = 0LL;
    uint64_t v12 = *(void *)v19;
    for (uint64_t i = *(void *)v19; ; uint64_t i = *(void *)v19)
    {
      if (i != v12) {
        objc_enumerationMutation(a2);
      }
      unint64_t v14 = *(void **)(*((void *)&v18 + 1) + 8 * v11);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        break;
      }
      unint64_t v15 = objc_msgSend(a3, "indexForKey:", objc_msgSend(v14, "name"));
      unint64_t v17 = 0LL;
      if (a4) {
        goto LABEL_15;
      }
LABEL_17:
      unint64_t v17 = bswap64(v15);
      [a1 appendBytes:&v17 length:8];
      if (++v11 >= v10)
      {
        uint64_t result = [a2 countByEnumeratingWithState:&v18 objects:v24 count:16];
        if (!result) {
          return result;
        }
        unint64_t v10 = result;
        uint64_t v11 = 0LL;
      }
    }

    if (!a4)
    {
      unint64_t v15 = objc_msgSend((id)objc_msgSend(a3, "objectForKey:", v14), "unsignedIntegerValue");
      goto LABEL_17;
    }

    if ([v14 isNSNumber])
    {
      unint64_t v15 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", v14), "unsignedIntegerValue");
      unint64_t v17 = 0x100000000000000LL;
      uint64_t v16 = &v17;
    }

    else
    {
      unint64_t v15 = objc_msgSend((id)objc_msgSend(a3, "objectForKey:", v14), "unsignedIntegerValue");
      unint64_t v17 = 0LL;
LABEL_15:
      uint64_t v16 = (unint64_t *)&v23;
    }

    [a1 appendBytes:v16 length:8];
    goto LABEL_17;
  }

  return result;
}

uint64_t _newReadPFEncodedArrayFromData( uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = (objc_class *)_newReadPFEncodedArrayFromData_myArrayClass;
  if (!_newReadPFEncodedArrayFromData_myArrayClass)
  {
    uint64_t v11 = (objc_class *)objc_opt_class();
    _newReadPFEncodedArrayFromData_myArrayClass Class = (uint64_t)v11;
  }

  unint64_t v12 = (*a3 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v13 = v12 + 24;
  if (v12 + 24 > a4) {
    return 0LL;
  }
  uint64_t v15 = a2 + v12;
  *(void *)(a2 + v12) = 0LL;
  object_setClass((id)(a2 + v12), v11);
  *(_DWORD *)(v15 + 16) = 0;
  unint64_t v16 = v12 + 20;
  *(_DWORD *)(v15 + 20) = bswap32(*(_DWORD *)(a2 + v16));
  if (*(int *)(a2 + v16) >= 1)
  {
    uint64_t v17 = 0LL;
    uint64_t v18 = a2 + v13;
    if (a6) {
      a5 = a6;
    }
    do
    {
      if (a6) {
        v13 += 8LL;
      }
      *(void *)(v18 + 8 * v17++) = *(id *)(a5 + 8 * bswap64(*(void *)(a2 + v13)));
      v13 += 8LL;
    }

    while (v17 < *(int *)(a2 + v16));
  }

  *a3 = v13;
  if (v13 <= a4) {
    return v15;
  }
  else {
    return 0LL;
  }
}

uint64_t _writeNSPropertyProxyIntoData(void *a1, void *a2, void *a3)
{
  uint64_t v9 = 0LL;
  unsigned int v5 = objc_msgSend( (id)objc_msgSend(a3, "objectForKey:", objc_msgSend(a2, "_underlyingProperty")),  "unsignedIntegerValue");
  int v6 = [a1 length];
  unsigned int v8 = bswap32(v5);
  [a1 appendBytes:&v8 length:4];
  unsigned int v8 = bswap32([a2 _entitysReferenceID]);
  [a1 appendBytes:&v8 length:4];
  [a1 appendBytes:&v9 length:8];
  [a1 appendBytes:&v9 length:8];
  [a1 appendBytes:&v9 length:8];
  return [a1 appendBytes:&v9 length:4];
}

void *_newReadPropertyProxyFromBytes( void *a1, uint64_t a2, unint64_t *a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v12 = (objc_class *)_newReadPropertyProxyFromBytes_myProxyClass;
  if (!_newReadPropertyProxyFromBytes_myProxyClass)
  {
    unint64_t v12 = (objc_class *)objc_opt_class();
    _newReadPropertyProxyFromBytes_myProxyClass Class = (uint64_t)v12;
  }

  unint64_t v13 = (*a3 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v14 = v13 + 36;
  if (v13 + 36 > a4) {
    return 0LL;
  }
  uint64_t v15 = (void *)(a2 + v13);
  uint64_t v16 = *(void *)(a6 + 8LL * bswap32(*(_DWORD *)(a2 + v13)));
  unsigned int v17 = *(_DWORD *)(a2 + (v13 | 4));
  *uint64_t v15 = 0LL;
  object_setClass(v15, v12);
  v15[1] = a1;
  id v15[2] = v16;
  void v15[3] = a5;
  *((_DWORD *)v15 + _Block_object_dispose(va, 8) = bswap32(v17);
  *a3 = v14;
  return v15;
}

uint64_t _writeKKDRow2IntoData(void *a1, uint64_t a2)
{
  v14[1] = *MEMORY[0x1895F89C0];
  int v4 = [a1 length];
  if ((int)(((v4 + 7) & 0xFFFFFFF8) - v4) >= 1)
  {
    v14[0] = 0LL;
    objc_msgSend(a1, "appendBytes:length:", v14);
  }

  _writeInt32IntoData(a1, *(_DWORD *)a2);
  _writeInt32IntoData(a1, *(unsigned __int16 *)(a2 + 4));
  unsigned int v5 = *(unsigned __int16 *)(a2 + 8);
  _writeInt16IntoData(a1, v5);
  _writeInt16IntoData(a1, *(unsigned __int16 *)(a2 + 10));
  unsigned int v6 = *(unsigned __int16 *)(a2 + 12);
  _writeInt16IntoData(a1, v6);
  uint64_t result = _writeInt16IntoData(a1, *(unsigned __int16 *)(a2 + 14));
  if (((v6 - v5) & 0x80000000) == 0)
  {
    MEMORY[0x1895F8858](result);
    if ((_DWORD)v8)
    {
      unint64_t v10 = (unsigned __int16 *)(a2 + 16);
      uint64_t v11 = (_WORD *)((char *)v14 - v9);
      uint64_t v12 = v8;
      do
      {
        unsigned int v13 = *v10++;
        *v11++ = bswap32(v13) >> 16;
        --v12;
      }

      while (v12);
    }

    return objc_msgSend(a1, "appendBytes:length:");
  }

  return result;
}

uint64_t _writeInt32IntoData(void *a1, unsigned int a2)
{
  int v4 = [a1 length];
  if ((int)(((v4 + 3) & 0xFFFFFFFC) - v4) >= 1)
  {
    uint64_t v7 = 0LL;
    objc_msgSend(a1, "appendBytes:length:", &v7);
  }

  unsigned int v6 = bswap32(a2);
  return [a1 appendBytes:&v6 length:4];
}

uint64_t _writeInt16IntoData(void *a1, unsigned int a2)
{
  int v4 = [a1 length];
  if ((int)(((v4 + 1) & 0xFFFFFFFE) - v4) >= 1)
  {
    uint64_t v7 = 0LL;
    objc_msgSend(a1, "appendBytes:length:", &v7);
  }

  __int16 v6 = __rev16(a2);
  return [a1 appendBytes:&v6 length:2];
}

uint64_t _writeKKDMappingStrategyIntoData(void *a1, void *a2, void *a3)
{
  uint64_t v16 = 0LL;
  int v6 = [a1 length];
  LODWORD(v7) = [a2 length];
  uint64_t v8 = (uint64_t *)[a2 keys];
  [a1 appendBytes:&v16 length:8];
  [a1 appendBytes:&v16 length:8];
  [a1 appendBytes:&v16 length:8];
  [a1 appendBytes:&v16 length:8];
  [a1 appendBytes:&v16 length:8];
  uint64_t v9 = (uint64_t *)a2[2];
  if (*v9)
  {
    unsigned int v10 = 1;
    while (v9[v10++])
      ;
  }

  else
  {
    unsigned int v10 = 1;
  }

  _writeInt32IntoData(a1, v7);
  for (uint64_t result = _writeInt32IntoData(a1, v10); v10; --v10)
    uint64_t result = [a1 appendBytes:&v16 length:8];
  uint64_t v13 = *v9;
  if (*v9)
  {
    unsigned int v14 = 1;
    do
    {
      uint64_t result = _writeKKDRow2IntoData(a1, v13);
      uint64_t v13 = v9[v14++];
    }

    while (v13);
  }

  uint64_t v7 = v7;
  if ((_DWORD)v7)
  {
    do
    {
      uint64_t v15 = *v8++;
      uint64_t result = _writeInt64IntoData(a1, objc_msgSend((id)objc_msgSend(a3, "objectForKey:", v15), "unsignedIntegerValue"));
      --v7;
    }

    while (v7);
  }

  return result;
}

uint64_t _writeInt64IntoData(void *a1, unint64_t a2)
{
  int v4 = [a1 length];
  if ((int)(((v4 + 7) & 0xFFFFFFF8) - v4) >= 1)
  {
    unint64_t v6 = 0LL;
    objc_msgSend(a1, "appendBytes:length:", &v6);
  }

  unint64_t v6 = bswap64(a2);
  return [a1 appendBytes:&v6 length:8];
}

uint64_t _newReadKKDMappingStrategyFromByes( uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4, uint64_t a5)
{
  unint64_t v5 = (*a3 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  if ((v5 | 4) > a4) {
    return 0LL;
  }
  unsigned int v10 = (objc_class *)_newReadKKDMappingStrategyFromByes_myKnownKeysMappingStrategy;
  if (!_newReadKKDMappingStrategyFromByes_myKnownKeysMappingStrategy)
  {
    unsigned int v10 = NSClassFromString((NSString *)@"NSKnownKeysMappingStrategy2");
    _newReadKKDMappingStrategyFromByes_myKnownKeysMappingStrategy = (uint64_t)v10;
  }

  *(void *)(a2 + v5) = 0LL;
  object_setClass((id)(a2 + v5), v10);
  unint64_t v15 = v5 + 8;
  if (v5 + 8 > a4) {
    unint64_t v15 = v5;
  }
  if (v15 + 8 <= a4) {
    v15 += 8LL;
  }
  if (v15 + 8 <= a4) {
    v15 += 8LL;
  }
  if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8 <= a4) {
    unint64_t v15 = ((v15 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8;
  }
  if (((v15 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8 <= a4) {
    unint64_t v16 = ((v15 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8;
  }
  else {
    unint64_t v16 = v15;
  }
  unint64_t v17 = (v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v18 = v17 + 4;
  if (v17 + 4 <= a4)
  {
    uint64_t v19 = bswap32(*(_DWORD *)(a2 + v17));
    unint64_t v17 = (v17 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v20 = v17 + 4;
  }

  else
  {
    uint64_t v19 = 0LL;
    unint64_t v20 = v17 + 4;
    unint64_t v18 = v16;
  }

  if (v20 <= a4)
  {
    LODWORD(v17) = *(_DWORD *)(a2 + v17);
    __int128 v21 = (void **)(a2 + v20);
    if ((_DWORD)v17)
    {
      unint64_t v17 = bswap32(v17);
      unint64_t v23 = v17;
      while (1)
      {
        unint64_t v24 = (v20 + 7) & 0xFFFFFFFFFFFFFFF8LL;
        if (v24 + 8 <= a4)
        {
          unint64_t v20 = v24 + 8;
          if (*(void *)(a2 + v24)) {
            break;
          }
        }

        if (!--v23)
        {
          uint64_t v22 = (v17 - 1);
          if ((_DWORD)v17 != 1) {
            goto LABEL_28;
          }
          uint64_t v22 = 0LL;
          LODWORD(v17) = 1;
LABEL_60:
          if (a2 && (_DWORD)v17) {
            v21[v22] = 0LL;
          }
          unint64_t v48 = (v20 + 7) & 0xFFFFFFFFFFFFFFF8LL;
          uint64_t v49 = a2 + v48;
          if (v19)
          {
            uint64_t v50 = (void *)(a2 + v48);
            uint64_t v51 = v19;
            do
            {
              unint64_t v52 = (v20 + 7) & 0xFFFFFFFFFFFFFFF8LL;
              unint64_t v53 = v52 + 8;
              if (v52 + 8 <= a4)
              {
                unint64_t v54 = bswap64(*(void *)(a2 + v52));
                unint64_t v20 = v53;
              }

              else
              {
                unint64_t v54 = 0LL;
              }

              *v50++ = *(void *)(a5 + 8 * v54);
              --v51;
            }

            while (v51);
            *a3 = v20;
LABEL_74:
            id v57 = *v21;
            if (*v21)
            {
              unint64_t v58 = v21 + 1;
              while ((*v57 & 7LL) == 1)
              {
                id v59 = (void *)*v58++;
                id v57 = v59;
                if (!v59) {
                  return objc_msgSend((id)(a2 + v5), "_setupForKeys:count:table:inData:", v49);
                }
              }

              int v67 = descriptionForBranchRow((uint64_t)v57, 0xFFFFFFFFLL);
              _NSCoreDataLog( 1LL,  (uint64_t)@"Corrupted branch row in optimized model detected:\n\t%@",  v60,  v61,  v62,  v63,  v64,  v65,  (uint64_t)v67);
              return 0LL;
            }
          }

          else
          {
            *a3 = v20;
            if (a2) {
              goto LABEL_74;
            }
          }

          return objc_msgSend((id)(a2 + v5), "_setupForKeys:count:table:inData:", v49);
        }
      }

      id v55 = @"Corrupted archive (unexpected data in pointer space).";
      goto LABEL_71;
    }

    uint64_t v22 = 0xFFFFFFFFLL;
LABEL_28:
    unint64_t v18 = v20;
  }

  else
  {
    LODWORD(v17) = 0;
    __int128 v21 = (void **)(a2 + v18);
    uint64_t v22 = 0xFFFFFFFFLL;
  }

  uint64_t v25 = 0LL;
  unint64_t v20 = v18;
  while (1)
  {
    unint64_t v26 = (v20 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    if (v26 + 16 > a4) {
      break;
    }
    uint64_t v27 = a2 + v26;
    if ((v26 | 4) <= a4)
    {
      unsigned int v28 = bswap32(*(_DWORD *)v27);
      v26 |= 4uLL;
    }

    else
    {
      unsigned int v28 = 0;
    }

    unint64_t v29 = v28 & 0xFFFFE000 | ((unint64_t)*(unsigned int *)(v27 + 4) << 32) | v28 & 0x1FF8 | (unint64_t)(v28 & 7);
    *(void *)uint64_t v27 = v29;
    unint64_t v30 = (v26 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v31 = v30 + 4;
    if (v30 + 4 <= a4)
    {
      unint64_t v32 = (unint64_t)bswap32(*(_DWORD *)(a2 + v30)) << 32;
      unint64_t v26 = v31;
    }

    else
    {
      unint64_t v32 = 0LL;
    }

    *(void *)uint64_t v27 = v32 | v29;
    unint64_t v33 = (v26 + 1) & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v34 = v33 + 2;
    if (v33 + 2 <= a4)
    {
      unsigned int v35 = bswap32(*(unsigned __int16 *)(a2 + v33)) >> 16;
      unint64_t v33 = (v33 + 3) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v36 = v33 + 2;
      unint64_t v26 = v34;
    }

    else
    {
      unsigned int v35 = 0;
      unint64_t v36 = v33 + 2;
    }

    *(_WORD *)(v27 + _Block_object_dispose(va, 8) = v35;
    if (v36 <= a4)
    {
      unsigned int v37 = bswap32(*(unsigned __int16 *)(a2 + v33)) >> 16;
      unint64_t v33 = (v36 + 1) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v38 = v33 + 2;
      unint64_t v26 = v36;
    }

    else
    {
      LOWORD(v37) = 0;
      unint64_t v38 = v36;
    }

    *(_WORD *)(v27 + 10) = v37;
    if (v38 <= a4)
    {
      unsigned int v39 = bswap32(*(unsigned __int16 *)(a2 + v33)) >> 16;
      unint64_t v33 = (v38 + 1) & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v40 = v33 + 2;
      unint64_t v26 = v38;
    }

    else
    {
      unsigned int v39 = 0;
      unint64_t v40 = v38;
    }

    *(_WORD *)(v27 + 12) = v39;
    if (v40 <= a4)
    {
      unsigned int v41 = bswap32(*(unsigned __int16 *)(a2 + v33)) >> 16;
      unint64_t v26 = v40;
    }

    else
    {
      LOWORD(v41) = 0;
    }

    *(_WORD *)(v27 + 14) = v41;
    BOOL v42 = __OFSUB__(v39, v35);
    int v43 = v39 - v35;
    int v44 = v43 < 0 != v42 ? -1 : v43;
    uint64_t v45 = (v44 + 1);
    uint64_t v46 = (2 * v45);
    if (v20 + v46 > a4) {
      break;
    }
    if (v43 < 0)
    {
      unint64_t v20 = v26;
    }

    else
    {
      if ((_DWORD)v45)
      {
        uint64_t v47 = (_WORD *)(v27 + 16);
        do
        {
          *uint64_t v47 = bswap32((unsigned __int16)*v47) >> 16;
          ++v47;
          --v45;
        }

        while (v45);
      }

      unint64_t v20 = v26 + v46;
    }

    v21[v25++] = (void *)v27;
    if (v25 == v22) {
      goto LABEL_60;
    }
  }

  id v55 = @"Corrupted archive (failed to read row).";
LABEL_71:
  _NSCoreDataLog(1LL, (uint64_t)v55, v11, v19, (uint64_t)v21, v12, v13, v14, v66);
  return 0LL;
}

BOOL _compareUnknownStrings(void *a1, __CFString *a2)
{
  int64_t v4 = [a1 length];
  if (v4 != -[__CFString length](a2, "length")) {
    return 0;
  }
  unint64_t v5 = (char *)[a1 UTF8String];
  Class Class = object_getClass(a1);
  if (Class == object_getClass(a2))
  {
    CStringPtr = (const char *)-[__CFString UTF8String](a2, "UTF8String");
    return memcmp(v5, CStringPtr, v4) == 0;
  }

  if (a2)
  {
    CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
    CStringPtr = CFStringGetCStringPtr(a2, SystemEncoding);
    if (CStringPtr) {
      return memcmp(v5, CStringPtr, v4) == 0;
    }
  }

  CFStringRef theString = a2;
  uint64_t v29 = 0LL;
  int64_t v30 = v4;
  CharactersPtr = CFStringGetCharactersPtr(a2);
  unsigned int v10 = 0LL;
  uint64_t v27 = CharactersPtr;
  if (!CharactersPtr) {
    unsigned int v10 = CFStringGetCStringPtr(a2, 0x600u);
  }
  int64_t v31 = 0LL;
  int64_t v32 = 0LL;
  unsigned int v28 = v10;
  if (v4 < 1)
  {
    return 1;
  }

  else
  {
    uint64_t v11 = 0LL;
    int64_t v12 = 0LL;
    BOOL v13 = 0;
    int64_t v14 = 0LL;
    uint64_t v15 = 64LL;
    do
    {
      else {
        uint64_t v16 = v14;
      }
      int64_t v17 = v30;
      if (v30 <= v14)
      {
        UniChar v18 = 0;
      }

      else if (v27)
      {
        UniChar v18 = v27[v14 + v29];
      }

      else if (v28)
      {
        UniChar v18 = v28[v29 + v14];
      }

      else
      {
        if (v32 <= v14 || v12 > v14)
        {
          uint64_t v20 = v16 + v11;
          uint64_t v21 = v15 - v16;
          int64_t v22 = v14 - v16;
          int64_t v23 = v22 + 64;
          if (v22 + 64 >= v30) {
            int64_t v23 = v30;
          }
          int64_t v31 = v22;
          int64_t v32 = v23;
          if (v30 >= v21) {
            int64_t v17 = v21;
          }
          v33.length = v17 + v20;
          v33.location = v22 + v29;
          CFStringGetCharacters(theString, v33, buffer);
          int64_t v12 = v31;
        }

        UniChar v18 = buffer[v14 - v12];
      }

      BOOL v13 = ++v14 >= v4;
      --v11;
      ++v15;
    }

    while (v4 != v14);
  }

  return v13;
}

void _PFResultsObjectCFDeallocator_deallocate(uint64_t a1)
{
}

LABEL_44:
  int64_t v32 = -[NSPropertyDescription _extraIVars](v4, "_extraIVars");
  [a3 decodeDoubleForKey:@"NSMaxValueName"];
  *(void *)(v32 + 16) = v33;
  if (v24) {
    goto LABEL_37;
  }
LABEL_47:
  if (!-[NSPropertyDescription _isFileBackedFuture](v4, "_isFileBackedFuture")
    && objc_msgSend( -[NSDictionary valueForKey:]( -[NSPropertyDescription userInfo](v4, "userInfo"),  "valueForKey:",  @"NSIsFileBackedFuture"),  "BOOLValue"))
  {
    *(_WORD *)&v4->super._propertyDescriptionFlags |= 0x4800u;
  }

  return v4;
}

  unint64_t v48 = (v27 + 7) & 0xFFFFFFFFFFFFFFFCLL;
  if (v48 + 4 <= a4)
  {
    uint64_t v49 = bswap32(*(_DWORD *)(a2 + v48));
    unsigned int v28 = v48 + 4;
  }

  else
  {
    uint64_t v49 = 0LL;
  }

  CFAbsoluteTime valuePtr = 0LL;
  id v55 = +[_PFRoutines attributeClassesForSecureCoding]();
  uint64_t v56 = (void *)+[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v55,  *(void *)(a7 + 8 * v49),  (uint64_t)&valuePtr);
  if (v56)
  {
    uint64_t v50 = v56;
    goto LABEL_53;
  }

  id v57 = [(id)a5 name];
  _NSCoreDataLog(1LL, (uint64_t)@"Error decoding default value for %@ : %@", v58, v59, v60, v61, v62, v63, v57);
  if (a9) {
    *a9 = valuePtr;
  }
  return 0LL;
}

        return;
      }

      uint64_t v45 = objc_alloc_init(MEMORY[0x1896077E8]);
      if (byte_18C4ABDBE)
      {
        int64_t v17 = (void *)[*(id *)(a1 + 40) objectForKey:@"_NSBinaryStoreInsecureDecodingCompatibilityOption"];
        if (v17) {
          UniChar v18 = [v17 BOOLValue] ^ 1;
        }
        else {
          UniChar v18 = 1;
        }
      }

      else
      {
        UniChar v18 = 0;
      }

      uint64_t v46 = 0LL;
      *(int8x8_t *)&uint64_t v19 = SetHostHeaderWithBigHeader((uint64_t)v49, [v7 bytes]);
      if (v50 != 1)
      {
        if (a3)
        {
          uint64_t v25 = objc_alloc(MEMORY[0x189603F68]);
          unint64_t v26 = (void *)objc_msgSend(v25, "initWithObjectsAndKeys:", a2, *MEMORY[0x1896074F8], 0);
          uint64_t v27 = objc_alloc(MEMORY[0x189607870]);
          unsigned int v28 = (void *)[v27 initWithDomain:*MEMORY[0x189607460] code:134000 userInfo:v26];
        }

        else
        {
          unsigned int v28 = 0LL;
        }

          unsigned int v10 = 0;
        }

        uint64_t v8 = [v6 countByEnumeratingWithState:&v55 objects:v72 count:16];
        unsigned int v10 = 0;
        if (v8) {
          continue;
        }
        break;
      }

    unsigned int v39 = (void *)MEMORY[0x189607870];
    v66[0] = @"NSDetailedErrors";
    v66[1] = @"NSValidationErrorShouldAttemptRecoveryKey";
    v67[0] = v34;
    v67[1] = MEMORY[0x189604A88];
    unint64_t v40 = [MEMORY[0x189603F68] dictionaryWithObjects:v67 forKeys:v66 count:2];
    int64_t v14 = 0;
    uint64_t v65 = (NSError *)[v39 errorWithDomain:v53 code:1560 userInfo:v40];
LABEL_34:
    ++v11;
  }

  while (v11 != v12);
  if (error != 0LL && !v14)
  {
    int64_t v14 = 0;
    NSError *error = v65;
  }

  return v14;
}

              _NSCoreDataLog( 1LL,  (uint64_t)@" Failed to load NSManagedObjectModel with URL '%@'",  v33,  v34,  v35,  v36,  v37,  v38,  (uint64_t)a3);
              unint64_t v24 = 0LL;
              goto LABEL_45;
            }
          }
        }

  uint64_t v25 = 0LL;
LABEL_48:
  +[NSPersistentStoreCoordinator _endPowerAssertionWithAssert:andApp:]( (uint64_t)&OBJC_CLASS___NSPersistentStoreCoordinator,  v42,  v37);
  CFRange v33 = v43;
  [v36 drain];
  unint64_t v34 = v43;
  if (!v24) {
    return 0LL;
  }
  if (error && !v25)
  {
    unsigned int v35 = (NSError *)v43;
    if (!v43) {
      unsigned int v35 = (NSError *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134000 userInfo:0];
    }
    NSError *error = v35;
  }

  return (NSDictionary *)v25;
}

  return v18;
}

                unsigned int v10 = v36;
                [v36 setObject:v20 forKey:v13];

                uint64_t v8 = v34;
                uint64_t v7 = v35;
                goto LABEL_71;
              }

              uint64_t v19 = [NSString stringWithFormat:@"<relationship fault: %p '%@'>", v15, objc_msgSend((id)-[__CFString relationship](v15, "relationship"), "name")];
              goto LABEL_68;
            }

            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              UniChar v18 = v10;
              int64_t v17 = v15;
              break;
            }

            if (v15 != (__CFString *)_CD_ScalarNull)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0) {
                uint64_t v19 = [NSString stringWithFormat:@"foreign key: %@", v15, v29];
              }
              else {
                uint64_t v19 = -[__CFString objectID](v15, "objectID");
              }
LABEL_68:
              int64_t v17 = (const __CFString *)v19;
              goto LABEL_69;
            }

            UniChar v18 = v10;
            int64_t v17 = @"<deferred relationship fault>";
            break;
          default:
            UniChar v18 = v10;
            int64_t v17 = @"(...not nil..)";
            break;
        }
      }

      else
      {
        UniChar v18 = v10;
        int64_t v17 = @"nil";
      }

      [v18 setObject:v17 forKey:v13];
LABEL_71:
      if (++v11 == v8)
      {
        int64_t v4 = v32;
        unint64_t v3 = v33;
        cd_objectID = v30;
        unint64_t v5 = v31;
        return (id)objc_msgSend( v3,  "stringWithFormat:",  @"%@ (entity: %@; id: %@ ; data: %@)",
                     v4,
                     v5,
                     cd_objectID,
                     v10);
      }
    }
  }

  return (id)objc_msgSend( v3,  "stringWithFormat:",  @"%@ (entity: %@; id: %@ ; data: %@)",
               v4,
               v5,
               cd_objectID,
               v10);
}

LABEL_28:
    if (v3)
    {
      int64_t v17 = [MEMORY[0x189607968] numberWithDouble:*(double *)&v7->var1];
      [v6 addObject:objc_msgSend(MEMORY[0x1896079C8], "predicateWithFormat:", @"self >= %@", v17)];
    }

    if (!v5) {
      goto LABEL_33;
    }
    UniChar v18 = [MEMORY[0x189607968] numberWithDouble:*(double *)&v7->var2];
    BOOL v13 = [MEMORY[0x1896079C8] predicateWithFormat:@"self =< %@", v18];
    goto LABEL_32;
  }

  if (v8 != NSDecimalAttributeType)
  {
    if (v8 == NSStringAttributeType)
    {
      if (v3)
      {
        uint64_t v15 = [MEMORY[0x189607968] numberWithLongLong:v7->var1];
        [v6 addObject:objc_msgSend(MEMORY[0x1896079C8], "predicateWithFormat:", @"length >= %@", v15)];
      }

      if (!v5) {
        goto LABEL_33;
      }
      uint64_t v16 = [MEMORY[0x189607968] numberWithLongLong:v7->var2];
      BOOL v13 = [MEMORY[0x1896079C8] predicateWithFormat:@"length =< %@", v16];
      goto LABEL_32;
    }

    if (v8 == NSDateAttributeType)
    {
      if (v3)
      {
        uint64_t v11 = [MEMORY[0x189607968] numberWithDouble:*(double *)&v7->var1];
        [v6 addObject:objc_msgSend(MEMORY[0x1896079C8], "predicateWithFormat:", @"timeIntervalSinceReferenceDate >= %@", v11)];
      }

      if (!v5) {
        goto LABEL_33;
      }
      int64_t v12 = [MEMORY[0x189607968] numberWithDouble:*(double *)&v7->var2];
      BOOL v13 = [MEMORY[0x1896079C8] predicateWithFormat:@"timeIntervalSinceReferenceDate =< %@", v12];
      goto LABEL_32;
    }

    goto LABEL_28;
  }

  if (v3)
  {
    int64_t v14 = [MEMORY[0x189607858] numberWithDouble:*(double *)&v7->var1];
    [v6 addObject:objc_msgSend(MEMORY[0x1896079C8], "predicateWithFormat:", @"SELF >= %@", v14)];
  }

  if (!v5) {
    goto LABEL_33;
  }
  unsigned int v10 = [MEMORY[0x189607858] numberWithDouble:*(double *)&v7->var2];
LABEL_23:
  BOOL v13 = [MEMORY[0x1896079C8] predicateWithFormat:@"SELF =< %@", v10];
LABEL_32:
  [v6 addObject:v13];
LABEL_33:
  if (-[NSAttributeDescription attributeType](self, "attributeType") == NSURIAttributeType) {
    objc_msgSend(v6, "addObject:", objc_msgSend(MEMORY[0x1896079C8], "predicateWithBlock:", &__block_literal_global_5));
  }
  return v6;
}

        if (!v16) {
          goto LABEL_44;
        }
        goto LABEL_29;
      }

      unint64_t v48 = @" Failed to load model as no file exists at path '%@'";
    }

    else
    {
      uint64_t v25 =  -[NSManagedObjectModelBundle initWithPath:]( objc_alloc(&OBJC_CLASS___NSManagedObjectModelBundle),  "initWithPath:",  v16);
      if (v25)
      {
        int64_t v32 = v25;
        int64_t v22 = objc_msgSend(-[NSManagedObjectModelBundle optimizedVersionURL](v25, "optimizedVersionURL"), "path");
        uint64_t v16 = (void *)objc_msgSend(-[NSManagedObjectModelBundle currentVersionURL](v32, "currentVersionURL"), "path");
        int64_t v23 = 0;
        goto LABEL_16;
      }

      unint64_t v48 = @" Failed to load model bundle at path '%@'";
    }

    _NSCoreDataLog(1LL, (uint64_t)v48, v26, v27, v28, v29, v30, v31, (uint64_t)v16);

    int64_t v22 = 0LL;
    goto LABEL_28;
  }

  _NSCoreDataLog( 1LL,  (uint64_t)@" Cannot load NSManagedObjectModel.  nil is an illegal URL parameter",  v8,  v9,  v10,  v11,  v12,  v13,  v73);
  if (!byte_18C4ABDBA)
  {

    return 0LL;
  }

  objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"CoreData: Cannot load NSManagedObjectModel.  nil is an illegal URL parameter" userInfo:0]);
  objc_exception_rethrow();
  __break(1u);
  return result;
}

    objc_msgSend( a3,  "failWithError:",  objc_msgSend(MEMORY[0x189607870], "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], 4866, v22));

LABEL_29:
    int64_t v4 = 0LL;
    goto LABEL_30;
  }

  return v4;
}

  if (a4 && !v8)
  {
LABEL_30:
    uint64_t v8 = 0LL;
    *a4 = objc_msgSend(MEMORY[0x189607870], "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], v10, 0, v34);
  }

  -[NSManagedObject setOperation:](v9, "setOperation:", a3);
  [a5 assignObject:v9 toPersistentStore:a4];
  return v9;
}

LABEL_16:
        if (-[__CFString isEqual:](v7, "isEqual:", v8)
          && !objc_msgSend((id)objc_msgSend(a2, "rightExpression"), "expressionType"))
        {
          uint64_t v9 = [a2 predicateOperatorType];
          if (v9 == 3) {
            return -1LL;
          }
          else {
            return v9 == 1;
          }
        }

        return 0LL;
      }

      if (v5 == 500 || v5 == 600) {
        goto LABEL_14;
      }
    }

    else
    {
      if (*(unsigned __int16 *)(v4 + 80) <= 0x12Bu)
      {
        if (v5 != 100 && v5 != 200) {
          return result;
        }
        goto LABEL_14;
      }

      if (v5 == 300 || v5 == 400)
      {
LABEL_14:
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          return 0LL;
        }
        unint64_t v6 = [a2 leftExpression];
        uint64_t v7 = (__CFString *)[MEMORY[0x189607878] expressionForEvaluatedObject];
        uint64_t v8 = v6;
        goto LABEL_16;
      }
    }
  }

  return result;
}

        if (-[NSFetchRequest resultType](self->_fetchRequest, "resultType") == 2)
        {
          if (BYTE4(z9dsptsiQ80etb9782fsrs98bfdle88))
          {
            int64_t v12 = (void *)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60], objc_msgSend( NSString, "stringWithFormat:", @"%@ does not support both change tracking and fetch request's with NSDictionaryResultType", objc_opt_class()), 0 reason userInfo];
            objc_exception_throw(v12);
LABEL_19:

            return;
          }
        }

        else
        {
          objc_msgSend( (id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"),  "addObserver:selector:name:object:",  self,  sel__managedObjectContextDidChange_,  @"_NSObjectsChangedInManagingContextPrivateNotification",  -[NSFetchedResultsController managedObjectContext](self, "managedObjectContext"));
          objc_msgSend( (id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"),  "addObserver:selector:name:object:",  self,  sel__managedObjectContextDidChangeObjectIDs_,  @"_NSManagedObjectContextDidMergeChangesObjectIDsPrivateNotification",  -[NSFetchedResultsController managedObjectContext](self, "managedObjectContext"));
          objc_msgSend( (id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"),  "addObserver:selector:name:object:",  self,  sel__managedObjectContextDidMutateObjectIDs_,  @"_NSManagedObjectContextPrivateDidMutateObjectIDsNotification",  -[NSFetchedResultsController managedObjectContext](self, "managedObjectContext"));
          uint64_t v27 = -[NSFetchedResultsController managedObjectContext](self, "managedObjectContext");
          if (v27) {
            atomic_store(1u, (unsigned __int8 *)&v27->_generatedMutatedIDsNotification);
          }
        }

        goto LABEL_44;
      }

      managedObjectContext = self->_managedObjectContext;
      if (managedObjectContext) {
        atomic_store(1u, (unsigned __int8 *)&managedObjectContext->_generatedMutatedIDsNotification);
      }
      uint64_t v11 = 64;
    }

    *(_DWORD *)&self->_flags |= v11;
    goto LABEL_16;
  }

  return v4;
}

  int64_t v22 = v41;
LABEL_22:
  if (v17 | v21)
  {
    uint64_t v29 = objc_alloc(MEMORY[0x189607940]);
    int64_t v30 = &stru_189EAC2E8;
    if (v17) {
      int64_t v31 = (const __CFString *)v17;
    }
    else {
      int64_t v31 = &stru_189EAC2E8;
    }
    if (v21) {
      int64_t v30 = (const __CFString *)v21;
    }
    int64_t v32 = (NSString *)[v29 initWithFormat:@"CREATE TEMPORARY TRIGGER IF NOT EXISTS ZQ_%@_TRIGGER AFTER DELETE ON %@ FOR EACH ROW BEGIN %@%@ END", v22, v22, v31, v30, 0];
  }

  else
  {
    int64_t v32 = 0LL;
  }

  unint64_t v34 = -[NSSQLiteStatement initWithEntity:](objc_alloc(&OBJC_CLASS___NSSQLiteStatement), "initWithEntity:", v8);
  unsigned int v35 = v34;
  if (v34)
  {
    sqlString = v34->_sqlString;
    if (sqlString != v32)
    {

      v35->_sqlString = (NSString *)-[NSString copy](v32, "copy");
    }
  }

  unsigned int v37 = (NSString *)[objc_alloc(NSString) initWithFormat:@"DROP TRIGGER IF EXISTS ZQ_%@_TRIGGER", v22, 0];
  unint64_t v38 = -[NSSQLiteStatement initWithEntity:](objc_alloc(&OBJC_CLASS___NSSQLiteStatement), "initWithEntity:", v8);
  unsigned int v39 = v38;
  if (v38)
  {
    unint64_t v40 = v38->_sqlString;
    if (v40 != v37)
    {

      v39->_sqlString = (NSString *)-[NSString copy](v37, "copy");
    }
  }

  v43[0] = v35;
  v43[1] = v39;
  CFDictionarySetValue(a3, v6, (const void *)[MEMORY[0x189603F18] arrayWithObjects:v43 count:2]);

  return 1LL;
}

      UniChar v18 = @"forceVacuum";
      if (a2) {
        UniChar v18 = @"forceWalCheckpoint";
      }
      _NSCoreDataLog(4LL, (uint64_t)@"PostSaveMaintenance: %@ override", v8, v9, v10, v11, v12, v13, (uint64_t)v18);
      if (*(void *)(a1 + 296) == 0x7FFFFFFFFFFFFFFFLL)
      {
LABEL_46:
        _NSCoreDataLog( 4LL,  (uint64_t)@"PostSaveMaintenance: wal_checkpoint(TRUNCATE) ",  v8,  v9,  v10,  v11,  v12,  v13,  v33);
        if (-[NSSQLiteConnection _walCheckpoint](a1) - 5 <= 1)
        {
          if (*(void *)(a1 + 8)) {
            -[NSSQLiteConnection scheduleWALCheckpointAfter:retry:](a1, 1LL, 0.1);
          }
        }

        return;
      }

      uint64_t v16 = (uint64_t *)(a1 + 296);
      *(void *)(a1 + 296) = 0LL;
      int64_t v14 = 1;
      goto LABEL_20;
    }
  }

  uint64_t v21 = ppStmt;
  if (ppStmt)
  {
    int64_t v22 = sqlite3_step(ppStmt);
    if (v22 != 100)
    {
      LOBYTE(v23) = v22;
      unint64_t v24 = 0;
      uint64_t v25 = 1;
      while (v23 - 5 <= 1)
      {
        if (v24 >= 0xB) {
          unint64_t v26 = v24 + 1101;
        }
        else {
          unint64_t v26 = v25;
        }
        usleep(v26);
        int64_t v23 = sqlite3_step(ppStmt);
        v25 += 3;
        ++v24;
        if (v23 == 100) {
          goto LABEL_24;
        }
      }

      unsigned int v37 = *MEMORY[0x189603A58];
      unint64_t v34 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithInt:"),  @"NSSQLiteErrorDomain");
      unint64_t v36 = @"Fetching maximum primary key for entity failed";
      unsigned int v35 = v37;
      goto LABEL_29;
    }

    int v44 = (void *)[MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:134412 userInfo:0];
    if (v44)
    {
      if (a5)
      {
        LOBYTE(v24) = 0;
        *a5 = v44;
        return v24;
      }

  return v12;
}

    unint64_t v24 = (void *)MEMORY[0x189607870];
    uint64_t v25 = *MEMORY[0x189607460];
    unint64_t v26 = 134413LL;
    goto LABEL_17;
  }

  if (!v15) {
    goto LABEL_16;
  }
LABEL_15:
  unint64_t v24 = (void *)MEMORY[0x189607870];
  uint64_t v25 = *MEMORY[0x189607460];
  unint64_t v26 = 134412LL;
LABEL_17:
  int64_t v22 = [v24 errorWithDomain:v25 code:v26 userInfo:0];
  int64_t v23 = 0;
LABEL_18:

  if ((v23 & 1) != 0) {
    return 1LL;
  }
  if (v22)
  {
    if (a5)
    {
      uint64_t result = 0LL;
      *a5 = v22;
      return result;
    }
  }

  else
  {
    uint64_t v27 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSCKMirroredRelationship.m");
    unint64_t v34 = (os_log_s *)__pflogFaultLog;
    uint64_t result = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    unint64_t v36 = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSCKMirroredRelationship.m";
    unsigned int v37 = 1024;
    unint64_t v38 = 114;
    _os_log_fault_impl( &dword_186681000,  v34,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
  }

  return 0LL;
}

      LOBYTE(v_Block_object_dispose(va, 8) = 0;
      return v8;
    }

LABEL_35:
      if (v16 == ++v20)
      {
        int64_t v32 = [v14 count];
        if (v32 == [v19 count])
        {
        }

        else
        {
          -[NSPropertyDescription _replaceValidationPredicates:andWarnings:]( self,  "_replaceValidationPredicates:andWarnings:",  v18,  v19);
        }

        return;
      }
    }
  }

    CFRange v33 = v15;
    [v10 closeFile];
    [v8 drain];
    unint64_t v34 = v15;
    if (a4)
    {
      if (v15) {
        *a4 = v15;
      }
    }

    return;
  }

  [v8 drain];
  if (a4)
  {
    uint64_t v16 = objc_alloc(MEMORY[0x189603F68]);
    int64_t v17 = (void *)objc_msgSend(v16, "initWithObjectsAndKeys:", a2, *MEMORY[0x1896074F8], 0);
    *a4 = [MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:260 userInfo:v17];
  }

    uint64_t v80 = 0LL;
    id v86 = 0LL;
LABEL_36:
    memset(v100, 0, 24);
    *(_OWORD *)&v100[0].copyDescription = *(_OWORD *)(MEMORY[0x189605240] + 24LL);
    v100[0].hash = *(CFDictionaryHashCallBack *)(MEMORY[0x189605240] + 40LL);
    memset(&v96, 0, 24);
    *(_OWORD *)&v96.copyDescription = *(_OWORD *)(MEMORY[0x189605250] + 24LL);
    uint64_t v51 = (const __CFAllocator *)*MEMORY[0x189604DB0];
    uint64_t v79 = v29;
    unint64_t v52 = CFDictionaryCreate(v51, (const void **)v29, (const void **)v87, v35, v100, &v96);
    uint64_t v92 = 0u;
    uint64_t v93 = 0u;
    id v94 = 0u;
    uint64_t v95 = 0u;
    unint64_t v53 = -[NSManagedObjectContext registeredObjects](self, "registeredObjects");
    unint64_t v54 = -[NSSet countByEnumeratingWithState:objects:count:]( v53,  "countByEnumeratingWithState:objects:count:",  &v92,  v99,  16LL);
    if (v54)
    {
      id v55 = v54;
      uint64_t v56 = *(void *)v93;
      do
      {
        for (uint64_t i = 0LL; i != v55; ++i)
        {
          if (*(void *)v93 != v56) {
            objc_enumerationMutation(v53);
          }
          unint64_t v58 = *(id ***)(*((void *)&v92 + 1) + 8 * i);
          if (v58) {
            id v59 = _insertion_fault_handler;
          }
          else {
            id v59 = 0;
          }
          _PFFaultHandlerFixRelationshipsPostMigration(v59, v58, (uint64_t)self, v52);
        }

        id v55 = -[NSSet countByEnumeratingWithState:objects:count:]( v53,  "countByEnumeratingWithState:objects:count:",  &v92,  v99,  16LL);
      }

      while (v55);
    }

    CFRelease(v52);

    if (v25 >= 0x402)
    {
      NSZoneFree(0LL, v79);
      NSZoneFree(0LL, v87);
      NSZoneFree(0LL, v85);
      NSZoneFree(0LL, v84);
    }

    unint64_t v5 = v82;
  }

  __int16 Count = _PFCMT_GetCount(&self->_infoByGID->super.isa);
  uint64_t v61 = [v5 objectForKey:@"removed"];
  if (v61)
  {
    uint64_t v62 = (void *)v61;
    uint64_t v63 = objc_alloc_init(MEMORY[0x189603FA8]);
    uint64_t v64 = [v62 count];
    if (v64)
    {
      uint64_t v65 = v64;
      for (uint64_t j = 0LL; j != v65; ++j)
      {
        int v67 = -[NSManagedObjectContext _retainedObjectsFromRemovedStore:]( self,  "_retainedObjectsFromRemovedStore:",  [v62 objectAtIndex:j]);
        [v63 addObjectsFromArray:v67];
      }
    }

    unsigned int v68 = [v63 count];
    if (v68)
    {
      int v69 = v68;
      if (v68 == Count) {
        uint64_t v70 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  NSArray_EmptyArray,  @"invalidatedAll",  +[_PFWeakReference weakReferenceWithObject:]( (uint64_t)_PFWeakReference,  (uint64_t)self),  @"managedObjectContext",  0);
      }
      else {
        uint64_t v70 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  objc_msgSend(MEMORY[0x189604010], "setWithArray:", v63),  @"invalidated",  +[_PFWeakReference weakReferenceWithObject:]( (uint64_t)_PFWeakReference,  (uint64_t)self),  @"managedObjectContext",  0);
      }
      -[NSManagedObjectContext _postObjectsDidChangeNotificationWithUserInfo:]((uint64_t)self, v70);
      for (uint64_t k = 0LL; k != v69; ++k)
      {
        int v72 = [v63 objectAtIndex:k];
        if (v72) {
          int v73 = _insertion_fault_handler;
        }
        else {
          int v73 = 0LL;
        }
        -[NSFaultHandler turnObject:intoFaultWithContext:](v73, v72, (uint64_t)self);
        if (self) {
          -[NSManagedObjectContext _forgetObject:propagateToObjectStore:removeFromRegistry:]( self,  "_forgetObject:propagateToObjectStore:removeFromRegistry:",  v72,  0LL,  1LL);
        }
      }
    }
  }

  if (v7)
  {
    uint64_t v90 = 0u;
    uint64_t v91 = 0u;
    uint64_t v88 = 0u;
    uint64_t v89 = 0u;
    int v74 = [v7 countByEnumeratingWithState:&v88 objects:v98 count:16];
    if (v74)
    {
      unsigned int v75 = v74;
      int v76 = *(void *)v89;
      do
      {
        for (m = 0LL; m != v75; ++m)
        {
          if (*(void *)v89 != v76) {
            objc_enumerationMutation(v7);
          }
          objc_msgSend( (id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"),  "postNotification:",  *(void *)(*((void *)&v88 + 1) + 8 * m));
        }

        unsigned int v75 = [v7 countByEnumeratingWithState:&v88 objects:v98 count:16];
      }

      while (v75);
    }
  }

  [v83 drain];
  -[NSManagedObjectContext _processReferenceQueue:]((uint64_t)self, 0);
}

    uint64_t v27 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSSQLAttributeTrigger.m");
    unint64_t v34 = (os_log_s *)__pflogFaultLog;
    uint64_t result = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSSQLAttributeTrigger.m";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 676;
    _os_log_fault_impl( &dword_186681000,  v34,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    return 0LL;
  }

  return result;
}

    if ((v7 & 0x20) == 0)
    {
      int64_t v22 = (void *)MEMORY[0x189604010];
      int64_t v23 = objc_opt_class();
      unint64_t v24 = objc_opt_class();
      uint64_t v25 = objc_opt_class();
      v4->_validationWarnings = (NSArray *)(id)objc_msgSend( a3,  "decodeObjectOfClasses:forKey:",  objc_msgSend( v22,  "setWithObjects:",  v23,  v24,  v25,  objc_opt_class(),  0),  @"NSValidationWarnings");
    }

    if ((v7 & 0x40) == 0) {
      v4->_userInfo = (NSMutableDictionary *)(id)[a3 decodeObjectOfClasses:+[_PFRoutines plistClassesForSecureCoding]() forKey:@"NSUserInfo"];
    }
    if ((v7 & 0x80) == 0)
    {
      unint64_t v26 = (void *)MEMORY[0x189604010];
      uint64_t v27 = objc_opt_class();
      unsigned int v28 = (NSString *)(id)objc_msgSend( a3,  "decodeObjectOfClasses:forKey:",  objc_msgSend(v26, "setWithObjects:", v27, objc_opt_class(), 0),  @"NSVersionHashModifier");
      v4->_versionHashModifier = v28;
      if (v28)
      {
        if (!-[NSString isNSString](v28, "isNSString"))
        {
          CFRange v33 = &unk_189F03B30;
          goto LABEL_60;
        }
      }
    }

    *(_WORD *)&v4->_propertyDescriptionFlags &= ~0x10u;
    uint64_t v29 = (NSString *)(id)[a3 decodeObjectOfClass:objc_opt_class() forKey:@"NSPropertyName"];
    v4->_name = v29;
    if (v29 && !-[NSString isNSString](v29, "isNSString"))
    {
      CFRange v33 = &unk_189F03B58;
      goto LABEL_60;
    }

    int64_t v30 = [a3 decodeObjectOfClass:objc_opt_class() forKey:@"NSEntity"];
    v4->_entity = (NSEntityDescription *)v30;
    if (v30)
    {
      if (v37) {
        int64_t v31 = (void *)v37[3];
      }
      else {
        int64_t v31 = 0LL;
      }
      [v31 addObject:v30];
      objc_opt_class();
      char isKindOfClass = objc_opt_isKindOfClass();
      if ((isKindOfClass & 1) != 0) {
        CFRange v33 = &unk_189F03BA8;
      }
      else {
        CFRange v33 = &unk_189F03B80;
      }
      if (v37 == 0LL || (isKindOfClass & 1) == 0) {
        goto LABEL_60;
      }
      if (!v37[1] && !v37[2])
      {
        CFRange v33 = &unk_189F03BA8;
        goto LABEL_60;
      }
    }

    unint64_t v34 = (void *)MEMORY[0x189604010];
    unsigned int v35 = objc_opt_class();
    -[NSPropertyDescription setRenamingIdentifier:]( v4,  "setRenamingIdentifier:",  objc_msgSend( a3,  "decodeObjectOfClasses:forKey:",  objc_msgSend(v34, "setWithObjects:", v35, objc_opt_class(), 0),  @"NSRenamingIdentifier"));
    if (!-[NSPropertyDescription renamingIdentifier](v4, "renamingIdentifier")
      || (-[NSString isNSString](-[NSPropertyDescription renamingIdentifier](v4, "renamingIdentifier"), "isNSString") & 1) != 0)
    {
      -[NSPropertyDescription _setNamespace:]((unint64_t *)v4, 0LL);
      -[NSPropertyDescription setSuperCompositeAttribute:](v4, "setSuperCompositeAttribute:", 0LL);
      v4->_entitysReferenceIDForProperty = -1;
LABEL_62:
      v43((uint64_t)v42);
      return v4;
    }

    CFRange v33 = &unk_189F03BD0;
LABEL_60:
    objc_msgSend( a3,  "failWithError:",  objc_msgSend(MEMORY[0x189607870], "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], 4866, v33));

LABEL_61:
    int64_t v4 = 0LL;
    goto LABEL_62;
  }

  return v4;
}

              ++v18;
            }

            while (v18 != v103);
            int64_t v31 = [v13 countByEnumeratingWithState:&v106 objects:v131 count:16];
            unint64_t v3 = v101;
            unint64_t v6 = v98;
            int64_t v4 = v99;
            uint64_t v7 = 0x189603000LL;
            uint64_t v8 = (void *)MEMORY[0x189604A58];
            uint64_t v9 = v97;
            unsigned int v10 = &OBJC_IVAR____NSPersistentHistoryToken__storeTokens;
            unint64_t v103 = v31;
            if (v31) {
              continue;
            }
            break;
          }
        }
      }

      else
      {
        int64_t v32 = -[NSSQLEntity derivedAttributesExtension](v3);
        -[NSSQLEntity_DerivedAttributesExtension addDerivationKeypath:forAttribute:]((uint64_t)v32, v8, v12);
      }

      uint64_t v11 = v105 + 1;
    }

    while (v105 + 1 != v6);
    unint64_t v6 = [v4 countByEnumeratingWithState:&v111 objects:v144 count:16];
    uint64_t result = 1LL;
    if (v6) {
      continue;
    }
    return result;
  }

  if (a5) {
    *a5 = v31;
  }
  return v32;
}

    uint64_t v64 = [MEMORY[0x189607A20] sortDescriptorWithKey:@"name" ascending:1];
    uint64_t v25 = (void *)objc_msgSend( v8,  "sortedArrayUsingDescriptors:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v64, 1));
    uint64_t v63 = [MEMORY[0x189607A20] sortDescriptorWithKey:@"name" ascending:1];
    unint64_t v26 = (void *)objc_msgSend( v36,  "sortedArrayUsingDescriptors:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v63, 1));
    uint64_t v45 = 0u;
    uint64_t v46 = 0u;
    uint64_t v47 = 0u;
    unint64_t v48 = 0u;
    uint64_t v27 = [v25 countByEnumeratingWithState:&v45 objects:v62 count:16];
    if (v27)
    {
      unsigned int v28 = v27;
      uint64_t v29 = *(void *)v46;
      do
      {
        for (m = 0LL; m != v28; ++m)
        {
          if (*(void *)v46 != v29) {
            objc_enumerationMutation(v25);
          }
          objc_msgSend( *(id *)(*(void *)(v35 + 32) + 160),  "addObject:",  -[NSSQLEntity indexForIndexDescription:](*(id **)(v35 + 40), *(id **)(*((void *)&v45 + 1) + 8 * m)));
        }

        unsigned int v28 = [v25 countByEnumeratingWithState:&v45 objects:v62 count:16];
      }

      while (v28);
    }

    int v43 = 0u;
    int v44 = 0u;
    unsigned int v41 = 0u;
    BOOL v42 = 0u;
    int64_t v31 = [v26 countByEnumeratingWithState:&v41 objects:v61 count:16];
    if (v31)
    {
      int64_t v32 = v31;
      CFRange v33 = *(void *)v42;
      do
      {
        for (n = 0LL; n != v32; ++n)
        {
          if (*(void *)v42 != v33) {
            objc_enumerationMutation(v26);
          }
          objc_msgSend( *(id *)(*(void *)(v35 + 32) + 168),  "addObject:",  -[NSSQLEntity indexForIndexDescription:](*(id **)(v35 + 48), *(id **)(*((void *)&v41 + 1) + 8 * n)));
        }

        int64_t v32 = [v26 countByEnumeratingWithState:&v41 objects:v61 count:16];
      }

      while (v32);
    }
  }

      ++v13;
      --v5;
    }

    while (v5);
  }

  free(v21);
  free(v9);
}

  uint64_t v46 = 0LL;
  unint64_t v34 = 0LL;
LABEL_49:
}

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL))
  {
    if ([*(id *)(a1 + 56) hasChanges])
    {
      *(void *)buf = 0LL;
      if (([*(id *)(a1 + 56) save:buf] & 1) == 0)
      {
        uint64_t v63 = (void *)MEMORY[0x186E3E5D8]();
        uint64_t v64 = __ckLoggingOverride != 0;
        uint64_t v65 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to save metadata changes from serialization of records: %@\n%@"];
        _NSCoreDataLog( v64,  v65,  v66,  v67,  v68,  v69,  v70,  v71,  (uint64_t)"-[NSCloudKitMirroringDelegate _performSerializationRequest:]_block_invoke");
        objc_autoreleasePoolPop(v63);
      }
    }
  }
}

  if (*(_BYTE *)(*(void *)(v1[5] + 8LL) + 24LL))
  {
    unint64_t v52 = 0u;
    unint64_t v53 = 0u;
    uint64_t v50 = 0u;
    uint64_t v51 = 0u;
    int64_t v30 = v1[4];
    int64_t v31 = v30 ? *(void **)(v30 + 24) : 0LL;
    uint64_t result = [v31 countByEnumeratingWithState:&v50 objects:v62 count:16];
    if (result)
    {
      int64_t v32 = result;
      CFRange v33 = *(void *)v51;
      uint64_t v49 = v31;
      do
      {
        unint64_t v34 = 0LL;
        do
        {
          if (*(void *)v51 != v33) {
            objc_enumerationMutation(v49);
          }
          unsigned int v35 = *(void **)(*((void *)&v50 + 1) + 8 * v34);
          unint64_t v36 = v1[4];
          if (v36) {
            unsigned int v37 = *(void **)(v36 + 24);
          }
          else {
            unsigned int v37 = 0LL;
          }
          unint64_t v38 = (id)[v37 objectForKey:*(void *)(*((void *)&v50 + 1) + 8 * v34)];
          unsigned int v39 = +[NSEntityDescription insertNewObjectForEntityForName:inManagedObjectContext:]( &OBJC_CLASS___NSEntityDescription,  "insertNewObjectForEntityForName:inManagedObjectContext:",  +[NSCKHistoryAnalyzerState entityPath](&OBJC_CLASS___NSCKHistoryAnalyzerState, "entityPath"),  *(void *)(v1[4] + 56LL));
          -[NSManagedObject setValue:forKey:]( v39,  "setValue:forKey:",  [v38 originalTransactionNumber],  @"originalTransactionNumber");
          -[NSManagedObject setOriginalChangeTypeNum:]( v39,  "setOriginalChangeTypeNum:",  objc_msgSend(MEMORY[0x189607968], "numberWithInteger:", objc_msgSend(v38, "originalChangeType")));
          -[NSManagedObject setValue:forKey:]( v39,  "setValue:forKey:",  [v38 finalTransactionNumber],  @"finalTransactionNumber");
          -[NSManagedObject setValue:forKey:]( v39,  "setValue:forKey:",  [v38 finalChangeAuthor],  @"finalChangeAuthor");
          -[NSManagedObject setFinalChangeTypeNum:]( v39,  "setFinalChangeTypeNum:",  objc_msgSend(MEMORY[0x189607968], "numberWithInteger:", objc_msgSend(v38, "finalChangeType")));
          unint64_t v40 = _sqlEntityForEntityDescription( [*(id *)(v1[4] + 88) model],  (void *)objc_msgSend(v35, "entity"));
          if (v40) {
            unsigned int v41 = *(unsigned int *)(v40 + 184);
          }
          else {
            unsigned int v41 = 0LL;
          }
          -[NSManagedObject setEntityId:]( v39,  "setEntityId:",  [MEMORY[0x189607968] numberWithUnsignedInt:v41]);
          -[NSManagedObject setEntityPK:]( v39,  "setEntityPK:",  objc_msgSend(MEMORY[0x189607968], "numberWithLongLong:", objc_msgSend(v35, "_referenceData64")));
          [*(id *)(v1[4] + 56) assignObject:v39 toPersistentStore:*(void *)(v1[4] + 88)];

          ++v34;
        }

        while (v32 != v34);
        uint64_t result = [v49 countByEnumeratingWithState:&v50 objects:v62 count:16];
        int64_t v32 = result;
      }

      while (result);
    }
  }

  BOOL v42 = v1[5];
  if (*(_BYTE *)(*(void *)(v42 + 8) + 24LL))
  {
    int v43 = v1[4];
    if (v43)
    {
      int v44 = *(void *)(v43 + 48);
      if (v44)
      {
        uint64_t result = +[NSCKMetadataEntry updateOrInsertMetadataEntryWithKey:transformedValue:forStore:intoManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMetadataEntry,  (uint64_t)@"NSCloudKitMirroringDelegateLastHistoryTokenKey",  v44,  *(void *)(v43 + 88),  *(void **)(v43 + 56),  (void *)(*(void *)(v1[6] + 8LL) + 40LL));
        BOOL v42 = v1[5];
        if (!result)
        {
          *(_BYTE *)(*(void *)(v42 + 8) + 24LL) = 0;
          uint64_t result = (uint64_t)*(id *)(*(void *)(v1[6] + 8LL) + 40LL);
          BOOL v42 = v1[5];
        }
      }
    }
  }

  if (*(_BYTE *)(*(void *)(v42 + 8) + 24LL))
  {
    uint64_t result = [*(id *)(v1[4] + 56) save:*(void *)(v1[6] + 8) + 40];
    if ((result & 1) == 0) {
      return (uint64_t)*(id *)(*(void *)(v1[6] + 8LL) + 40LL);
    }
  }

  return result;
}

uint64_t _readAttributeIntoShellFromBytes( uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t *a9)
{
  unint64_t v16 = *a3;
  unint64_t v17 = (*a3 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (v17 + 4 <= a4)
  {
    unint64_t v16 = v17 + 4;
    unsigned int v18 = *(_DWORD *)(a2 + v17);
    if (v18)
    {
      unsigned int v19 = bswap32(v18);
      uint64_t v20 = *(void **)(a8 + 8LL * v19);
      if (v20)
      {
        if ([*(id *)(a8 + 8 * v19) isEqualToString:@"NSSecureUnarchiveFromDataTransformerName"]) {
          id v21 = (id)[(id)*MEMORY[0x1896076E8] copy];
        }
        else {
          id v21 = v20;
        }
      }

      else
      {
        id v21 = 0LL;
      }

      *(void *)(a5 + 96) = v21;
    }
  }

  unint64_t v22 = (v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v23 = v22 + 4;
  if (v22 + 4 <= a4)
  {
    __int16 v24 = bswap32(*(_DWORD *)(a2 + v22));
    unint64_t v22 = (v22 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v25 = v22 + 4;
    unint64_t v16 = v23;
  }

  else
  {
    __int16 v24 = 0;
    unint64_t v25 = v22 + 4;
  }

  *(_WORD *)(a5 + 80) = v24;
  if (v25 <= a4)
  {
    unsigned int v26 = *(_DWORD *)(a2 + v22);
    if (v26) {
      *(void *)(a5 + 104) = *(id *)(a6 + 8LL * bswap32(v26));
    }
    unint64_t v16 = v25;
  }

  unint64_t v27 = (v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v28 = v27 + 4;
  if (v27 + 4 > a4)
  {
LABEL_55:
    unint64_t v51 = (v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v52 = v51 + 4;
    if (v51 + 4 > a4)
    {
LABEL_65:
      *a3 = v16;
      return 1LL;
    }

    char v53 = bswap32(*(_DWORD *)(a2 + v51));
    if ((v53 & 1) != 0)
    {
      *(_WORD *)(a5 + 72) |= 0x200u;
      if ((v53 & 2) == 0)
      {
LABEL_58:
        if ((v53 & 4) == 0) {
          goto LABEL_59;
        }
        goto LABEL_68;
      }
    }

    else if ((v53 & 2) == 0)
    {
      goto LABEL_58;
    }

    *(_WORD *)(a5 + 72) |= 0x400u;
    if ((v53 & 4) == 0)
    {
LABEL_59:
      if ((v53 & 8) == 0) {
        goto LABEL_60;
      }
      goto LABEL_69;
    }

LABEL_68:
    *(_WORD *)(a5 + 72) |= 0x800u;
    if ((v53 & 8) == 0)
    {
LABEL_60:
      if ((v53 & 0x10) == 0) {
        goto LABEL_61;
      }
      goto LABEL_70;
    }

LABEL_69:
    *(_WORD *)(a5 + 72) |= 0x2000u;
    if ((v53 & 0x10) == 0)
    {
LABEL_61:
      if ((v53 & 0x20) == 0) {
        goto LABEL_62;
      }
      goto LABEL_71;
    }

            unsigned int v18 = v10;
            break;
          case 3LL:
            goto LABEL_20;
          case 4LL:
            if ([v12 isToMany])
            {
LABEL_20:
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
                || !-[__CFString isFault](v15, "isFault"))
              {
                uint64_t v20 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  -[__CFString count](v15, "count"));
                id v38 = 0u;
                double v39 = 0u;
                unint64_t v40 = 0u;
                uint64_t v41 = 0u;
                id v21 = -[__CFString countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v38,  v42,  16LL);
                if (v21)
                {
                  unint64_t v22 = v21;
                  unint64_t v23 = 0LL;
                  __int16 v24 = *(void *)v39;
                  do
                  {
                    unint64_t v25 = 0LL;
                    if (v23 <= 0xA) {
                      unsigned int v26 = 10 - v23;
                    }
                    else {
                      unsigned int v26 = 0LL;
                    }
                    do
                    {
                      if (*(void *)v39 != v24) {
                        objc_enumerationMutation(v15);
                      }
                      if (v26 == v25)
                      {
                        [v20 addObject:objc_msgSend( NSString, "stringWithFormat:", @"(...and %ld more...)", -[__CFString count](v15, "count") - 10)];
                        goto LABEL_44;
                      }

                      objc_msgSend( v20,  "addObject:",  objc_msgSend(*(id *)(*((void *)&v38 + 1) + 8 * v25++), "objectID"));
                    }

                    while (v22 != v25);
                    unint64_t v22 = -[__CFString countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v38,  v42,  16LL);
                    v23 += v25;
                  }

                  while (v22);
                }
                }
              }

              else
              {
                CFNumberType v42 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
                if (v42)
                {
                  if (objc_msgSend((id)objc_msgSend(v42, "domain"), "isEqualToString:", v148)
                    && [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) code] == 133000)
                  {
                    [v19 setNeedsCloudDelete:1];
                    -[PFCloudKitOperationBatch addDeletedRecordID:forRecordOfType:](*(void *)(a1 + 56), v20, v156);
                    *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL) = 0LL;
                  }

                  else
                  {
                    *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
                    unint64_t v43 = *(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
                  }
                }
              }
            }
          }

          else
          {
            unint64_t v22 = (void *)MEMORY[0x186E3E5D8](v21);
            unint64_t v23 = __ckLoggingOverride;
            __int16 v24 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Ignoring dirty metadata for record in immutable zone: %@"];
            unint64_t v31 = v23 >= 3 ? 3LL : v23;
            _NSCoreDataLog( v31,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  (uint64_t)"-[PFCloudKitExportContext newOperationBySerializingDirtyObjectsInStore:inManagedObjectContext:err or:]_block_invoke");
            objc_autoreleasePoolPop(v22);
            [v19 setNeedsUpload:0];
            [v19 setNeedsCloudDelete:0];
          }

          if ([*(id *)(a1 + 48) hasChanges])
          {
            unint64_t v51 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "insertedObjects"), "count");
            unint64_t v52 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "updatedObjects"), "count");
            if ((unint64_t)(v52
                                  + v51
                                  + objc_msgSend((id)objc_msgSend(*(id *)(a1 + 48), "deletedObjects"), "count")) >= 0xC9
              && ([*(id *)(a1 + 48) save:*(void *)(*(void *)(a1 + 72) + 8) + 40] & 1) == 0)
            {
              *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
              char v53 = *(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
            }
          }

          [*(id *)(a1 + 48) refreshAllObjects];
          if (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL)) {
            unint64_t v54 = -[PFCloudKitExportContext currentBatchExceedsThresholds:]( *(void *)(a1 + 40),  *(void *)(a1 + 56))
          }
                ? 5
                : 0;
          else {
            unint64_t v54 = 5;
          }
          objc_autoreleasePoolPop(context);
          if (v54) {
            break;
          }
          if (++v155 == v152)
          {
            uint64_t v55 = [v6 countByEnumeratingWithState:&v184 objects:v203 count:16];
            uint64_t v152 = v55;
            if (v55) {
              goto LABEL_21;
            }
            break;
          }
        }
      }

      if (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL))
      {
        if ((-[PFCloudKitExportContext currentBatchExceedsThresholds:](*(void *)(a1 + 40), *(void *)(a1 + 56)) & 1) == 0)
        {
          uint64_t v56 = (void *)+[NSCKMirroredRelationship fetchMirroredRelationshipsMatchingPredicate:fromStore:inManagedObjectContext:error:]( (uint64_t)NSCKMirroredRelationship,  [MEMORY[0x1896079C8] predicateWithFormat:@"isUploaded = NO"],  *(void *)(a1 + 32),  *(void **)(a1 + 48),  *(void *)(*(void *)(a1 + 72) + 8) + 40);
          if (v56)
          {
            uint64_t v157 = (void *)objc_msgSend( (id)objc_msgSend(*(id *)(a1 + 48), "persistentStoreCoordinator"),  "managedObjectModel");
            uint64_t v174 = 0u;
            uint64_t v175 = 0u;
            __int128 v172 = 0u;
            uint64_t v173 = 0u;
            uint64_t v57 = [v56 countByEnumeratingWithState:&v172 objects:v200 count:16];
            if (v57)
            {
              uint64_t v58 = *(void *)v173;
LABEL_89:
              uint64_t v59 = 0LL;
              while (1)
              {
                if (*(void *)v173 != v58) {
                  objc_enumerationMutation(v56);
                }
                uint64_t v60 = *(void **)(*((void *)&v172 + 1) + 8 * v59);
                if ((-[PFCloudKitExportContext currentBatchExceedsThresholds:]( *(void *)(a1 + 40),  *(void *)(a1 + 56)) & 1) != 0) {
                  break;
                }
                uint64_t v61 = -[NSCKMirroredRelationship createRecordID](v60);
                uint64_t v62 = [v61 zoneID];
                if (v158
                  && (uint64_t v62 = -[NSMutableSet containsObject:](v158->_mutableZoneIDs, "containsObject:", v62),
                      (v62 & 1) != 0))
                {
                  uint64_t v63 = *(void *)(a1 + 56);
                  if (v63) {
                    uint64_t v64 = *(void **)(v63 + 32);
                  }
                  else {
                    uint64_t v64 = 0LL;
                  }
                  if (([v64 containsObject:v61] & 1) == 0)
                  {
                    uint64_t v65 = *(void *)(a1 + 56);
                    uint64_t v66 = v65 ? *(void **)(v65 + 8) : 0LL;
                    if (([v66 containsObject:v61] & 1) == 0)
                    {
                      if ([v60 needsDelete])
                      {
                        -[PFCloudKitOperationBatch addDeletedRecordID:forRecordOfType:]( *(void *)(a1 + 56),  v61,  (uint64_t)@"CDMR");
                      }

                      else
                      {
                        int v76 = -[NSCKMirroredRelationship createRecordIDForRecord](v60);
                        uint64_t v77 = -[NSCKMirroredRelationship createRecordIDForRelatedRecord](v60);
                        uint64_t v78 = (void *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v157, "entitiesByName"),  "objectForKeyedSubscript:",  objc_msgSend(v60, "cdEntityName")),  "relationshipsByName"),  "objectForKeyedSubscript:",  objc_msgSend(v60, "relationshipName"));
                        uint64_t v79 = -[PFMirroredManyToManyRelationshipV2 initWithRecordID:forRecordWithID:relatedToRecordWithID:byRelationship:withInverse:andType:]( [PFMirroredManyToManyRelationshipV2 alloc],  "initWithRecordID:forRecordWithID:relatedToRecordWithID:byRelationship:withInverse:andType:",  v61,  v76,  v77,  v78,  [v78 inverseRelationship],  0);
                        uint64_t v80 = (void *)[objc_alloc(getCloudKitCKRecordClass()) initWithRecordType:@"CDMR" recordID:v61];
                        uint64_t v81 = *(void *)(*(void *)(a1 + 40) + 8LL);
                        if (v81) {
                          uint64_t v82 = *(void **)(v81 + 16);
                        }
                        else {
                          uint64_t v82 = 0LL;
                        }
                        uint64_t v83 = [v82 useDeviceToDeviceEncryption];
                        int v84 = (uint64_t)v80;
                        if (v83) {
                          int v84 = objc_msgSend(v80, "encryptedValueStore", v80);
                        }
                        -[PFMirroredManyToManyRelationshipV2 populateRecordValues:](v79, "populateRecordValues:", v84);
                        -[PFCloudKitOperationBatch addRecord:](*(void *)(a1 + 56), v80);
                      }
                    }
                  }
                }

                else
                {
                  int v67 = (void *)MEMORY[0x186E3E5D8](v62);
                  unsigned int v68 = __ckLoggingOverride;
                  int v69 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Ignoring update to dirty mirrored relationship because the zone is not mutable: %@"];
                  _NSCoreDataLog( v68 != 0,  v69,  v70,  v71,  v72,  v73,  v74,  v75,  (uint64_t)"-[PFCloudKitExportContext newOperationBySerializingDirtyObjectsInStore:inManagedObjectConte xt:error:]_block_invoke");
                  objc_autoreleasePoolPop(v67);
                  [v60 setIsUploaded:MEMORY[0x189604A88]];
                }

                if (v57 == ++v59)
                {
                  uint64_t v85 = [v56 countByEnumeratingWithState:&v172 objects:v200 count:16];
                  uint64_t v57 = v85;
                  if (v85) {
                    goto LABEL_89;
                  }
                  break;
                }
              }
            }
          }

          else
          {
            *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
            char v135 = *(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
          }
        }

        int v136 = *(void *)(a1 + 56);
        if (v136) {
          int v137 = *(void **)(v136 + 8);
        }
        else {
          int v137 = 0LL;
        }
        int v138 = +[NSCKMirroredRelationship markRelationshipsForDeletedRecordIDs:inStore:withManagedObjectContext:error:]( (uint64_t)NSCKMirroredRelationship,  (void *)[v137 allObjects],  *(void *)(a1 + 32),  *(void **)(a1 + 48),  (void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40));
        int v139 = v138;
        if (v138)
        {
          __int128 v170 = 0u;
          __int128 v171 = 0u;
          v168 = 0u;
          __int128 v169 = 0u;
          unsigned int v140 = [v138 countByEnumeratingWithState:&v168 objects:v199 count:16];
          if (v140)
          {
            char v141 = *(void *)v169;
LABEL_177:
            id v142 = 0LL;
            while (1)
            {
              if (*(void *)v169 != v141) {
                objc_enumerationMutation(v139);
              }
              id v143 = *(void **)(*((void *)&v168 + 1) + 8 * v142);
              if ((-[PFCloudKitExportContext currentBatchExceedsThresholds:]( *(void *)(a1 + 40),  *(void *)(a1 + 56)) & 1) != 0) {
                break;
              }
              uint64_t v144 = *(void *)(a1 + 56);
              if (v144) {
                uint64_t v145 = *(void **)(v144 + 8);
              }
              else {
                uint64_t v145 = 0LL;
              }
              if (([v145 containsObject:v143] & 1) == 0) {
                -[PFCloudKitOperationBatch addDeletedRecordID:forRecordOfType:]( *(void *)(a1 + 56),  v143,  (uint64_t)@"CDMR");
              }
              if (v140 == ++v142)
              {
                v146 = [v139 countByEnumeratingWithState:&v168 objects:v199 count:16];
                unsigned int v140 = v146;
                if (v146) {
                  goto LABEL_177;
                }
                break;
              }
            }
          }
        }

        else
        {
          *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
          int v147 = *(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
        }
      }
    }

    else
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
      id v86 = *(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
    }
  }

  else
  {
    int v158 = 0LL;
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL)
    && (-[PFCloudKitExportContext currentBatchExceedsThresholds:](*(void *)(a1 + 40), *(void *)(a1 + 56)) & 1) == 0)
  {
    int v87 = +[NSFetchRequest fetchRequestWithEntityName:]( &OBJC_CLASS___NSFetchRequest,  "fetchRequestWithEntityName:",  +[NSCKRecordZoneMetadata entityPath](&OBJC_CLASS___NSCKRecordZoneMetadata, "entityPath"));
    -[NSFetchRequest setPredicate:]( v87,  "setPredicate:",  [MEMORY[0x1896079C8] predicateWithFormat:@"needsShareUpdate = YES OR needsShareDelete = YES"]);
    -[NSFetchRequest setPropertiesToFetch:](v87, "setPropertiesToFetch:", &unk_189F0B340);
    uint64_t v88 = (void *)[*(id *)(a1 + 48) executeFetchRequest:v87 error:*(void *)(*(void *)(a1 + 72) + 8) + 40];
    uint64_t v89 = v88;
    if (v88)
    {
      int v166 = 0u;
      uint64_t v167 = 0u;
      uint64_t v164 = 0u;
      int v165 = 0u;
      uint64_t v90 = [v88 countByEnumeratingWithState:&v164 objects:v198 count:16];
      if (v90)
      {
        uint64_t v91 = *(void *)v165;
        do
        {
          uint64_t v92 = 0LL;
          do
          {
            if (*(void *)v165 != v91) {
              objc_enumerationMutation(v89);
            }
            uint64_t v93 = *(void **)(*((void *)&v164 + 1) + 8 * v92);
            id v94 = (char *)-[NSCKRecordZoneMetadata createRecordZoneID](v93);
            if (![v93 encodedShareData])
            {
              uint64_t v95 = [NSString stringWithUTF8String:"Zone metadata is missing it's encoded share data but is marked for a mutation: %@ - %@"];
              _NSCoreDataLog(17LL, v95, v96, v97, v98, v99, v100, v101, (uint64_t)v94);
              unint64_t v102 = (os_log_s *)__pflogFaultLog;
              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 138412546;
                v195 = v94;
                v196 = 2112;
                v197 = v93;
                _os_log_fault_impl( &dword_186681000,  v102,  OS_LOG_TYPE_FAULT,  "CoreData: Zone metadata is missing it's encoded share data but is marked for a mutation: %@ - %@",  buf,  0x16u);
              }
            }

            unint64_t v103 = *(void *)(*(void *)(a1 + 40) + 8LL);
            if (v103 && (unint64_t v104 = *(void *)(v103 + 16)) != 0) {
              __int16 v105 = *(void *)(v104 + 136);
            }
            else {
              __int16 v105 = 0LL;
            }
            uint64_t v106 = -[PFCloudKitArchivingUtilities shareFromEncodedData:inZoneWithID:error:]( v105,  (void *)[v93 encodedShareData],  v94,  (void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40));
            if (!v106)
            {
              *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
              int v117 = *(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);

              goto LABEL_149;
            }

            if ([v93 needsShareUpdate])
            {
              -[PFCloudKitOperationBatch addRecord:](*(void *)(a1 + 56), v106);
              if ((-[PFCloudKitExportContext currentBatchExceedsThresholds:]( *(void *)(a1 + 40),  *(void *)(a1 + 56)) & 1) != 0) {
                goto LABEL_148;
              }
            }

            else if ([v93 needsShareDelete])
            {
              -[PFCloudKitOperationBatch addDeletedRecordID:forRecordOfType:]( *(void *)(a1 + 56),  (void *)[v106 recordID],  objc_msgSend(v106, "recordType"));
              if (-[PFCloudKitExportContext currentBatchExceedsThresholds:]( *(void *)(a1 + 40),  *(void *)(a1 + 56)))
              {
LABEL_148:

                goto LABEL_149;
              }
            }

            else
            {
              uint64_t v107 = [NSString stringWithUTF8String:"Fetched dirty zone that didn't need a share update or delete: %@"];
              _NSCoreDataLog(17LL, v107, v108, v109, v110, v111, v112, v113, (uint64_t)v93);
              uint64_t v114 = (os_log_s *)__pflogFaultLog;
              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 138412290;
                v195 = (char *)v93;
                _os_log_fault_impl( &dword_186681000,  v114,  OS_LOG_TYPE_FAULT,  "CoreData: Fetched dirty zone that didn't need a share update or delete: %@",  buf,  0xCu);
              }
            }

            ++v92;
          }

          while (v90 != v92);
          uint64_t v115 = [v89 countByEnumeratingWithState:&v164 objects:v198 count:16];
          uint64_t v90 = v115;
        }

        while (v115);
      }
    }

    else
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
      int v116 = *(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
    }
  }

LABEL_63:
      *(_WORD *)(a5 + 72) |= 0x8000u;
      goto LABEL_64;
    }

  if (v39 - 1 >= v12) {
    return v12;
  }
  else {
    return v39;
  }
}

    CFNumberType v42 = 0LL;
LABEL_65:
    double v39 = (void *)MEMORY[0x189603F70];
    unint64_t v40 = *MEMORY[0x189603A60];
    uint64_t v41 = @"Duplicate version checksums across stages detected.";
    goto LABEL_66;
  }

  v53.receiver = v50;
  v53.super_class = (Class)&OBJC_CLASS___NSStagedMigrationManager;
  unint64_t v28 = -[NSStagedMigrationManager init](&v53, sel_init);
  if (v28)
  {
    unsigned int v29 = v49;
    v28->_stages = v29;
    uint64_t v65 = 0u;
    uint64_t v66 = 0u;
    int v67 = 0u;
    unsigned int v68 = 0u;
    unint64_t v30 = -[NSArray countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v65,  v69,  16LL);
    if (v30)
    {
      unint64_t v31 = v30;
      uint64_t v32 = 0;
      unint64_t v33 = 0LL;
      unint64_t v34 = 0LL;
      unsigned int v35 = *(void *)v66;
      do
      {
        for (uint64_t j = 0LL; j != v31; ++j)
        {
          if (*(void *)v66 != v35) {
            objc_enumerationMutation(v29);
          }
          unsigned int v37 = *(void *)(*((void *)&v65 + 1) + 8 * j);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            if ((v32 & 1) == 0) {
              unint64_t v33 = -[NSArray indexOfObject:](v28->_stages, "indexOfObject:", v37);
            }
            ++v34;
            uint64_t v32 = 1;
          }

          else
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              if (v33 >= v34 + v33)
              {
                uint64_t v32 = 0;
                unint64_t v33 = 0LL;
                unint64_t v34 = 0LL;
              }

              else
              {
                do
                {
                  objc_msgSend( -[NSArray objectAtIndex:](v28->_stages, "objectAtIndex:", v33++),  "setSubsequentStage:",  v37);
                  --v34;
                }

                while (v34);
                uint64_t v32 = 0;
                unint64_t v33 = 0LL;
              }
            }
          }
        }

        unint64_t v31 = -[NSArray countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v65,  v69,  16LL);
      }

      while (v31);
    }
  }

  return v28;
}

LABEL_36:
        defaultValue = self->_defaultValue;
        unint64_t v22 = a7;
        goto LABEL_37;
      }

      if (type != 100 && type != 200) {
        goto LABEL_36;
      }
LABEL_18:
      unint64_t v25 = [self->_defaultValue integerValue];
LABEL_38:
      __int16 v24 = v25;
      unint64_t v23 = a3;
      goto LABEL_39;
    }

    if (self->_type <= 0x2BBu)
    {
      if (type != 500)
      {
        if (type != 600) {
          goto LABEL_36;
        }
        unsigned int v26 = [a3 length];
        unint64_t v27 = (v26 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        if (v27 != v26)
        {
          id v38 = 0LL;
          [a3 appendBytes:&v38 length:v27 - v26];
        }

        [self->_defaultValue floatValue];
        LODWORD(v3_Block_object_dispose(va, 8) = bswap32(v28);
        unsigned int v29 = a3;
        unint64_t v30 = 4LL;
LABEL_35:
        [v29 appendBytes:&v38 length:v30];
        goto LABEL_40;
      }

      unint64_t v34 = [a3 length];
      unsigned int v35 = (v34 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      if (v35 != v34)
      {
        id v38 = 0LL;
        [a3 appendBytes:&v38 length:v35 - v34];
      }

      [self->_defaultValue doubleValue];
    }

    else
    {
      if (type != 900)
      {
        if (type != 800)
        {
          if (type == 700)
          {
            defaultValue = self->_defaultValue;
            unint64_t v22 = a6;
LABEL_37:
            unint64_t v25 = objc_msgSend((id)objc_msgSend(v22, "objectForKey:", defaultValue), "unsignedIntegerValue");
            goto LABEL_38;
          }

          goto LABEL_36;
        }

        goto LABEL_18;
      }

      unint64_t v31 = [a3 length];
      uint64_t v32 = (v31 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      if (v32 != v31)
      {
        id v38 = 0LL;
        [a3 appendBytes:&v38 length:v32 - v31];
      }

      [self->_defaultValue timeIntervalSinceReferenceDate];
    }

    id v38 = bswap64(v33);
    unsigned int v29 = a3;
    unint64_t v30 = 8LL;
    goto LABEL_35;
  }

  unint64_t v23 = a3;
  __int16 v24 = 0;
LABEL_39:
  _writeInt32IntoData(v23, v24);
LABEL_40:
  unint64_t v36 = -[NSPropertyDescription _hasMaxValueInExtraIvars](self, "_hasMaxValueInExtraIvars");
  if (-[NSPropertyDescription _hasMinValueInExtraIvars](self, "_hasMinValueInExtraIvars")) {
    v36 |= 2u;
  }
  if (-[NSPropertyDescription _storeBinaryDataExternally](self, "_storeBinaryDataExternally")) {
    v36 |= 4u;
  }
  if (-[NSPropertyDescription _isTriggerBacked](self, "_isTriggerBacked")) {
    v36 |= 8u;
  }
  if (-[NSAttributeDescription preservesValueInHistoryOnDeletion](self, "preservesValueInHistoryOnDeletion")) {
    v36 |= 0x10u;
  }
  if (-[NSPropertyDescription _isFileBackedFuture](self, "_isFileBackedFuture"))
  {
    v36 |= 0x20u;
  }

  else if (objc_msgSend( -[NSDictionary valueForKey:]( -[NSPropertyDescription userInfo](self, "userInfo"),  "valueForKey:",  @"NSIsFileBackedFuture"),  "BOOLValue"))
  {
    v36 |= 0x24u;
  }

  if (-[NSPropertyDescription _allowsCloudEncryption](self, "_allowsCloudEncryption")) {
    unsigned int v37 = v36 | 0x40;
  }
  else {
    unsigned int v37 = v36;
  }
  _writeInt32IntoData(a3, v37);
  id v38 = bswap32([a3 length] - v16);
  objc_msgSend(a3, "replaceBytesInRange:withBytes:", v17 - 4, 4, &v38);
}

      unint64_t v22 = -[_NSSQLTableMigrationDescription _tempNameForTableName:](v6, [v3 correlationTableName]);
      unint64_t v23 = -[NSSQLiteAdapter newRenameTableStatementFrom:to:]( v103,  [v3 correlationTableName],  (uint64_t)v22);
      [a2 addObject:v23];

LABEL_78:
      uint64_t v11 = v101;
      int64_t v12 = obj;
LABEL_79:
      int64_t v12 = (char *)v12 + 1;
      if (v12 == (id)v9)
      {
        uint64_t result = [v8 countByEnumeratingWithState:&v112 objects:v143 count:16];
        uint64_t v9 = result;
        if (!result) {
          return result;
        }
        goto LABEL_7;
      }
    }
  }

  return result;
}

void *_PFfastFactoryRelease1(void *a1)
{
  uint64_t result = object_getIndexedIvars(a1);
  id v2 = result;
  do
    int v3 = __ldxr((unsigned int *)result);
  while (__stxr(v3 - 1, (unsigned int *)result));
  if (v3 <= 0)
  {
    int64_t v4 = (const void *)result[5];
    if (v4)
    {
      CFRelease(v4);
      v2[5] = 0LL;
    }

    v2[6] = 0LL;
    v2[2] = 0LL;
    uint64_t result = (void *)v2[3];
    if (result)
    {
      uint64_t result = (void *)_PFfastFactoryRelease1();
      v2[3] = 0LL;
    }

    if (v2[1]) {
      v2[1] = 0LL;
    }
    __dmb(0xBu);
  }

  return result;
}

uint64_t _PFObjectIDFastEquals64(unint64_t a1, unint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  uint64_t result = 0LL;
  if ((a1 & 0x8000000000000000LL) == 0 && (a2 & 0x8000000000000000LL) == 0)
  {
    Class Class = object_getClass((id)a1);
    if (Class == (Class)objc_opt_class())
    {
      Class v6 = object_getClass((id)a1);
      if ((*((_BYTE *)object_getIndexedIvars(v6) + 4) & 2) != 0)
      {
        Class v7 = object_getClass((id)a1);
        if ((*((_BYTE *)object_getIndexedIvars(v7) + 4) & 1) != 0) {
          uint64_t v8 = *(void *)(a1 + 8) >> 16;
        }
        else {
          uint64_t v8 = *(void *)(a1 + 16);
        }
        Class v9 = object_getClass((id)a2);
        if ((*((_BYTE *)object_getIndexedIvars(v9) + 4) & 1) != 0) {
          uint64_t v10 = *(void *)(a2 + 8) >> 16;
        }
        else {
          uint64_t v10 = *(void *)(a2 + 16);
        }
        return v8 == v10;
      }

      else
      {
        return [*(id *)(a1 + 16) isEqual:*(void *)(a2 + 16)];
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

objc_class *_PFFallbackFactoryForOID(void *a1)
{
  Class Class = object_getClass(a1);
  int v3 = (unint64_t *)((char *)object_getIndexedIvars(Class) + 24);
  int64_t v4 = (objc_class *)*v3;
  if (!*v3)
  {
    unint64_t v5 = (void *)[a1 persistentStore];
    Class v6 = (void *)[a1 entity];
    int64_t v4 = +[_NSCoreManagedObjectID classWithStore:andEntity:]( &OBJC_CLASS___NSScalarObjectID64,  "classWithStore:andEntity:",  v5,  v6);
    if (!-[objc_class _storeInfo1](v4, "_storeInfo1"))
    {
      uint64_t v7 = 0LL;
      if (v5 && v6) {
        uint64_t v7 = _sqlCoreLookupSQLEntityForEntityDescription(v5, v6);
      }
      -[objc_class _setStoreInfo1:](v4, "_setStoreInfo1:", v7);
    }

    while (!__ldaxr(v3))
    {
    }

    __clrex();
    unint64_t v9 = *v3;

    return (objc_class *)v9;
  }

  return v4;
}

void sub_18671D30C()
{
}

int8x8_t SetHostHeaderWithBigHeader(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(int8x8_t *)(a1 + _Block_object_dispose(va, 8) = vrev32_s8(*(int8x8_t *)(a2 + 8));
  *(int8x16_t *)(a1 + 16) = vrev64q_s8(*(int8x16_t *)(a2 + 16));
  *(int8x16_t *)(a1 + 32) = vrev64q_s8(*(int8x16_t *)(a2 + 32));
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = bswap64(*(void *)(a2 + 48));
  int8x8_t result = vrev32_s8(*(int8x8_t *)(a2 + 56));
  *(int8x8_t *)(a1 + 56) = result;
  return result;
}

void sub_18671E0C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a2)
  {
    if (a2 == 2)
    {
      id v17 = objc_begin_catch(exception_object);
      if (v15)
      {
        if (!a15)
        {
          unsigned int v18 = (void *)[objc_alloc(MEMORY[0x189603F68]) initWithObjectsAndKeys:v16];
          [MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:259 userInfo:v18];
        }
      }

      id v19 = v17;
      objc_end_catch();
    }

    else
    {
      objc_begin_catch(exception_object);
    }

    JUMPOUT(0x18671DEA8LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_18671E668(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18671E63CLL);
  }

  _Unwind_Resume(a1);
}

void sub_18671E678(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    JUMPOUT(0x18671E680LL);
  }
  _Unwind_Resume(a1);
}

void sub_18671E688(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18671E690LL);
  }
  objc_terminate();
  -[NSBinaryObjectStoreFile readMetadataFromFile:securely:error:](v2, v3, v4, v5);
}

void sub_18671EDDC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18671ED98LL);
  }

  _Unwind_Resume(a1);
}

void sub_18671EDEC(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    JUMPOUT(0x18671EDF4LL);
  }
  _Unwind_Resume(a1);
}

BOOL sub_18671EDFC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18671EE04LL);
  }
  objc_terminate();
  return -[NSBinaryObjectStoreFile _writeMetadataData:andMapDataData:toFile:error:](v2, v3, v4, v5, v6, v7);
}

void sub_18671F198(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18671F16CLL);
  }

  JUMPOUT(0x18671F138LL);
}

void sub_18671FCA4()
{
}

void sub_1867200E8(_Unwind_Exception *a1)
{
}

void sub_18672013C(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x18671FF68LL);
  }

  JUMPOUT(0x18672012CLL);
}

void sub_186720EA0(_Unwind_Exception *a1)
{
}

void sub_186720EBC()
{
}

uint64_t _kvcPropertysPrimitiveGetters(unint64_t *a1)
{
  if (*(void *)(a1[19] + 8)) {
    return *(void *)(a1[19] + 8);
  }
  else {
    return _resolveForSelectorAndType( a1,  sel__createValuePrimitiveGetterWithContainerClassID_key_,  (objc_class *)qword_18C4AB980,  1);
  }
}

uint64_t _kvcPropertysPublicSetters(unint64_t *a1)
{
  if (*(void *)(a1[19] + 16)) {
    return *(void *)(a1[19] + 16);
  }
  else {
    return _resolveForSelectorAndType( a1,  sel__createValueSetterWithContainerClassID_key_,  (objc_class *)_MergedGlobals_68,  2);
  }
}

uint64_t _kvcPropertysPublicGetters(unint64_t *a1)
{
  if (*(void *)(a1[19] + 24)) {
    return *(void *)(a1[19] + 24);
  }
  else {
    return _resolveForSelectorAndType( a1,  sel__createValueGetterWithContainerClassID_key_,  (objc_class *)qword_18C4AB980,  3);
  }
}

uint64_t _resolveValidationMethods(unint64_t *a1)
{
  v19[1] = *MEMORY[0x1895F89C0];
  uint64_t v2 = (void *)a1[13];
  SEL v3 = (id *)[v2 keys];
  uint64_t v4 = [v2 length];
  id v5 = (Method *)PF_CALLOC_OBJECT_ARRAY(v4);
  v19[0] = a1;
  id v6 = _PFFastEntityClass(a1);
  Class Superclass = class_getSuperclass((Class)v6);
  if (v4)
  {
    uint64_t v8 = Superclass;
    unint64_t v9 = v5;
    do
    {
      uint64_t v10 = (const __CFString *)*v3;
      uint64_t v11 = objc_msgSend(*v3, "length", v19[0]);
      MEMORY[0x1895F8858](v11);
      BOOL v13 = (char *)v19 - v12;
      CFStringGetCString(v10, (char *)v19 - v12, v14, 0x8000100u);
      if (v11) {
        *BOOL v13 = __toupper(*v13);
      }
      *v9++ = _PFKeyValueMethodForPattern(v8, "validate%s:error:", v13);
      ++v3;
      --v4;
    }

    while (v4);
  }

  uint64_t v15 = v19[0];
  uint64_t v16 = (unint64_t *)(*(void *)(v19[0] + 152LL) + 32LL);
  while (!__ldaxr(v16))
  {
  }

  __clrex();
  PF_FREE_OBJECT_ARRAY(v5);
  return *(void *)(*(void *)(v15 + 152) + 32LL);
}

uint64_t _kvcPropertysPublicRelationshipMutators(unint64_t *a1)
{
  uint64_t result = *(void *)(a1[19] + 40);
  if (!result)
  {
    SEL v3 = (void *)a1[13];
    uint64_t v4 = [v3 keys];
    uint64_t v5 = [v3 length];
    id v6 = (void **)PF_CALLOC_OBJECT_ARRAY(v5);
    uint64_t v7 = _PFFastEntityClass(a1);
    Class Superclass = class_getSuperclass((Class)v7);
    unint64_t v9 = (void *)a1[14];
    uint64_t v10 = objc_opt_class();
    if (v5 && Superclass != (Class)v10)
    {
      unint64_t v11 = 0LL;
      while (1)
      {
        unint64_t v12 = v9[14];
        if (v12 <= v11 && v11 - v12 < v9[15]) {
          break;
        }
        unint64_t v14 = v9[22];
        if (v14 <= v11 && v11 - v14 < v9[23]) {
          break;
        }
        unint64_t v16 = v9[16];
        BOOL v17 = v16 > v11 || v11 - v16 >= v9[17];
        if (!v17 || (unint64_t v18 = v9[24], v18 <= v11) && v11 - v18 < v9[25])
        {
          id v19 = &OBJC_CLASS____NSFaultingMutableOrderedSetMutationMethods;
          goto LABEL_24;
        }

void sub_186722B7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39, uint64_t a40, void (*a41)(char *))
{
}

void sub_186724250(_Unwind_Exception *a1)
{
}

void sub_1867260A0()
{
}

void sub_186726464(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x186726414LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_186726B00()
{
}

void sub_186728234( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
}

void sub_186728418(_Unwind_Exception *a1)
{
}

LABEL_52:
                        unsigned int v29 = v168->_entityDescriptionFlags;
                        uint64_t v15 = v164;
                        unint64_t v12 = v165;
                        unint64_t v14 = v162;
                        goto LABEL_53;
                      }
                    }

                    else if ([v23 isIndexedBySpotlight])
                    {
                      goto LABEL_52;
                    }

            unsigned int v119 = 0u;
            int v120 = 0u;
            int v117 = 0u;
            int v118 = 0u;
            unint64_t v47 = [v115 countByEnumeratingWithState:&v117 objects:v133 count:16];
            if (!v47) {
              return CFBitVectorCreate(0LL, v15, v109);
            }
            unint64_t v48 = v47;
            uint64_t v113 = (id)((v116 >> 4) & 1);
            uint64_t v49 = *(void *)v118;
            while (2)
            {
              CFNumberRef v50 = 0LL;
LABEL_55:
              if (*(void *)v118 != v49) {
                objc_enumerationMutation(v115);
              }
              unint64_t v51 = *(_WORD **)(*((void *)&v117 + 1) + 8 * v50);
              if (!v51 || (v51[16] & 0x18) == 0)
              {
                unint64_t v52 = [v51 isConstrained];
                if ((v116 & 8) != 0) {
                  char v53 = v52 ^ 1;
                }
                else {
                  char v53 = 1;
                }
                unint64_t v54 = v52;
                if ((v116 & 0x10) == 0) {
                  LOBYTE(v53) = 1;
                }
                if (((v52 ^ 1) & (v116 >> 2) & 1) != 0 || (v53 & 1) == 0)
                {
                  uint64_t v55 = [v51 slot];
                  if (a2) {
                    uint64_t v56 = 0;
                  }
                  else {
                    uint64_t v56 = v54;
                  }
                  if ((v56 & 1) != 0)
                  {
                    v15[(unint64_t)v27 >> 3] |= 1 << (~(_BYTE)v27 & 7);
                    goto LABEL_78;
                  }

                  uint64_t v57 = v55;
                  if (a2) {
                    uint64_t v58 = *(unsigned __int8 **)(a2 + 40);
                  }
                  else {
                    uint64_t v58 = 0LL;
                  }
                  uint64_t v59 = (unsigned __int8 *)*((void *)v114 + 5);
                  uint64_t v60 = 1 << (v55 & 7);
                  if (((v60 & v59[((unint64_t)v55 >> 3) + 28]) != 0) != ((v60 & v58[((unint64_t)v55 >> 3) + 28]) != 0))
                  {
LABEL_76:
                    v15[(unint64_t)v27 >> 3] |= 1 << (~(_BYTE)v27 & 7);
                  }

                  else if ((v60 & v59[((unint64_t)v55 >> 3) + 28]) == 0)
                  {
                    uint64_t v111 = v55;
                    uint64_t v112 = v58;
                    Class Class = object_getClass(v59);
                    uint64_t v62 = *(char *)(*((void *)object_getIndexedIvars(Class) + 7) + v57);
                    switch(v62)
                    {
                      case 'c':
                        uint64_t v63 = object_getClass(v59);
                        IndexedIvars = (unsigned int *)object_getIndexedIvars(v63);
                        uint64_t v65 = v111;
                        uint64_t v66 = v112;
                        int v67 = v59[IndexedIvars[v111 + 19]];
                        unsigned int v68 = object_getClass(v112);
                        int v69 = v66[*((unsigned int *)object_getIndexedIvars(v68) + v65 + 19)];
                        goto LABEL_95;
                      case 'd':
                        uint64_t v83 = object_getClass(v59);
                        int v84 = (unsigned int *)object_getIndexedIvars(v83);
                        id v86 = v111;
                        uint64_t v85 = (char *)v112;
                        int v87 = *(double *)&v59[v84[v111 + 19]];
                        uint64_t v88 = object_getClass(v112);
                        break;
                      case 'e':
                      case 'g':
                      case 'h':
                        goto LABEL_86;
                      case 'f':
                        uint64_t v89 = object_getClass(v59);
                        uint64_t v90 = (unsigned int *)object_getIndexedIvars(v89);
                        uint64_t v92 = v111;
                        uint64_t v91 = (char *)v112;
                        uint64_t v93 = *(float *)&v59[v90[v111 + 19]];
                        id v94 = object_getClass(v112);
                        break;
                      case 'i':
                        uint64_t v95 = object_getClass(v59);
                        uint64_t v96 = (unsigned int *)object_getIndexedIvars(v95);
                        uint64_t v97 = v111;
                        uint64_t v98 = (char *)v112;
                        int v67 = *(_DWORD *)&v59[v96[v111 + 19]];
                        uint64_t v99 = object_getClass(v112);
                        int v69 = *(_DWORD *)&v98[*((unsigned int *)object_getIndexedIvars(v99) + v97 + 19)];
                        goto LABEL_95;
                      default:
                        if (v62 == 113)
                        {
                          uint64_t v100 = object_getClass(v59);
                          uint64_t v101 = (unsigned int *)object_getIndexedIvars(v100);
                          unint64_t v102 = v111;
                          unint64_t v103 = (char *)v112;
                          unint64_t v104 = *(void *)&v59[v101[v111 + 19]];
                          __int16 v105 = object_getClass(v112);
                        }

                        else if (v62 == 115)
                        {
                          uint64_t v70 = object_getClass(v59);
                          int v71 = (unsigned int *)object_getIndexedIvars(v70);
                          int v72 = v111;
                          int v73 = (char *)v112;
                          int v67 = *(unsigned __int16 *)&v59[v71[v111 + 19]];
                          int v74 = object_getClass(v112);
                          int v69 = *(unsigned __int16 *)&v73[*((unsigned int *)object_getIndexedIvars(v74) + v72 + 19)];
LABEL_95:
                          if (v67 != v69) {
                            goto LABEL_76;
                          }
                        }

                        else
                        {
LABEL_86:
                          unsigned int v75 = object_getClass(v59);
                          int v76 = (unsigned int *)object_getIndexedIvars(v75);
                          uint64_t v77 = v111;
                          int v108 = *(void **)&v59[v76[v111 + 19]];
                          uint64_t v78 = (char *)v112;
                          uint64_t v79 = object_getClass(v112);
                          uint64_t v80 = *(void **)&v78[*((unsigned int *)object_getIndexedIvars(v79) + v77 + 19)];
                          if ([v51 sqlType] == 16)
                          {
                            uint64_t v81 = v108;
                            if (v108 == v80) {
                              break;
                            }
                            uint64_t v82 = v81;
                          }

                          else
                          {
                            uint64_t v82 = v108;
                            if (v108 == v80) {
                              break;
                            }
                          }

                          if (([v82 isEqual:v80] & 1) == 0) {
                            goto LABEL_76;
                          }
                        }

                        break;
                    }
                  }
                }
              }

              ++v27;
LABEL_78:
              if (v48 == ++v50)
              {
                uint64_t v106 = [v115 countByEnumeratingWithState:&v117 objects:v133 count:16];
                unint64_t v48 = v106;
                if (!v106) {
                  return CFBitVectorCreate(0LL, v15, v109);
                }
                continue;
              }

              goto LABEL_55;
            }
          }

LABEL_89:
      -[NSArray drain](v159, "drain");
      uint64_t v157 = objc_alloc_init(MEMORY[0x1896077E8]);
      unsigned int v37 = v168->_superentity;
      if (v37)
      {
        propertyRanges = v37->_propertyRanges;
        double v39 = objc_msgSend((id)-[NSMutableDictionary mapping](v37->_properties, "mapping"), "keys");
        if (propertyRanges[15].length) {
          unint64_t v40 = objc_msgSend(MEMORY[0x189603FA8], "arrayWithObjects:count:", v39 + 8 * propertyRanges[15].location);
        }
        else {
          unint64_t v40 = [MEMORY[0x189603FA8] array];
        }
        uint64_t v41 = (NSArray *)v40;
        if (propertyRanges[16].length) {
          int v158 = (id)objc_msgSend(MEMORY[0x189603FA8], "arrayWithObjects:count:", v39 + 8 * propertyRanges[16].location);
        }
        else {
          int v158 = (id)[MEMORY[0x189603FA8] array];
        }
        if (propertyRanges[5].length) {
          char v53 = objc_msgSend(MEMORY[0x189603FA8], "arrayWithObjects:count:", v39 + 8 * propertyRanges[5].location);
        }
        else {
          char v53 = [MEMORY[0x189603FA8] array];
        }
        CFNumberType v42 = (NSArray *)v53;
        if (propertyRanges[6].length) {
          int v166 = (NSArray *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithObjects:count:",  v39 + 8 * propertyRanges[6].location);
        }
        else {
          int v166 = (NSArray *)[MEMORY[0x189603FA8] array];
        }
        if (propertyRanges[10].length) {
          uint64_t v164 = (NSArray *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithObjects:count:",  v39 + 8 * propertyRanges[10].location);
        }
        else {
          uint64_t v164 = (NSArray *)[MEMORY[0x189603FA8] array];
        }
        if (propertyRanges[7].length) {
          uint64_t v163 = (NSArray *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithObjects:count:",  v39 + 8 * propertyRanges[7].location);
        }
        else {
          uint64_t v163 = (NSArray *)[MEMORY[0x189603FA8] array];
        }
        if (propertyRanges[8].length) {
          uint64_t v162 = (NSArray *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithObjects:count:",  v39 + 8 * propertyRanges[8].location);
        }
        else {
          uint64_t v162 = (NSArray *)[MEMORY[0x189603FA8] array];
        }
        if (propertyRanges[11].length) {
          int v161 = (NSArray *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithObjects:count:",  v39 + 8 * propertyRanges[11].location);
        }
        else {
          int v161 = (NSArray *)[MEMORY[0x189603FA8] array];
        }
        if (propertyRanges[12].length) {
          uint64_t v159 = (NSArray *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithObjects:count:",  v39 + 8 * propertyRanges[12].location);
        }
        else {
          uint64_t v159 = (NSArray *)[MEMORY[0x189603FA8] array];
        }
        if (propertyRanges[14].length) {
          unint64_t v54 = objc_msgSend(MEMORY[0x189603FA8], "arrayWithObjects:count:", v39 + 8 * propertyRanges[14].location);
        }
        else {
          unint64_t v54 = [MEMORY[0x189603FA8] array];
        }
        unint64_t v43 = (NSArray *)v54;
        if (propertyRanges[17].length) {
          uint64_t v167 = (NSArray *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithObjects:count:",  v39 + 8 * propertyRanges[17].location);
        }
        else {
          uint64_t v167 = (NSArray *)[MEMORY[0x189603FA8] array];
        }
        uint64_t v55 = objc_msgSend(v12, "count", v157);
        if (v55)
        {
          uint64_t v56 = 0LL;
          while (1)
          {
            uint64_t v57 = (void *)[v165 objectAtIndex:v56];
            uint64_t v58 = [v57 name];
            uint64_t v59 = v168->_superentity;
            if (!v59) {
              break;
            }
            if ((*(_BYTE *)&v59->_entityDescriptionFlags & 4) != 0)
            {
              if ([v59->_propertyMapping indexForKey:v58] == 0x7FFFFFFFFFFFFFFFLL) {
                break;
              }
            }

            else if (!-[NSDictionary objectForKey:]( -[NSEntityDescription propertiesByName](v59, "propertiesByName"),  "objectForKey:",  v58))
            {
              break;
            }

        LOBYTE(v11) = 0;
        return v11;
      }

      LOBYTE(v11) = 1;
      if (v66 && v69 > v66)
      {
        id v38 = v93;
        if (v93)
        {
          double v39 = *a3;
          unint64_t v40 = a5;
          uint64_t v41 = 1590;
          goto LABEL_48;
        }

        goto LABEL_89;
      }
    }
  }

  return v11;
}

  int v73 = *(void **)(a1 + 40);
  if (v73)
  {
    int v74 = *(void *)(a1 + 32);
    if ([*(id *)(a1 + 40) _persistentStoreCoordinator])
    {
      if (([v73 isReadOnly] & 1) == 0)
      {
        -[NSSQLiteConnection connect](v74);
        if (!v74 || (-[NSSQLiteConnection _hasTableWithName:isTemp:](v74, (uint64_t)@"Z_MODELCACHE", 0) & 1) == 0) {
          -[NSSQLiteConnection saveCachedModel:]( v74,  objc_msgSend((id)objc_msgSend(v73, "model"), "managedObjectModel"));
        }
      }
    }

    unsigned int v75 = *(void *)(a1 + 40);
    if (v75)
    {
      int v76 = *(void *)(a1 + 32);
      os_unfair_lock_lock_with_options();
      uint64_t v77 = (void *)[*(id *)(v75 + 160) objectForKey:0x189EBA2C8];
      os_unfair_lock_unlock((os_unfair_lock_t)(v75 + 152));
      uint64_t v78 = [v77 unsignedIntegerValue];
      uint64_t v79 = [(id)v75 _persistentStoreCoordinator];
      uint64_t v80 = (void *)v79;
      if (v79 && v78 >= 0x2BD && v78 <= 0x2EA)
      {
        if (([(id)v75 isReadOnly] & 1) == 0)
        {
          -[NSSQLiteConnection connect](v76);
          *(void *)&v286.f_bsize = 0LL;
          if ((-[NSSQLCore _rebuildTriggerSchemaUsingConnection:recomputeValues:error:](v75, v76, (id *)&v286) & 1) == 0)
          {
            uint64_t v81 = *(void *)&v286.f_bsize;
            [*(id *)&v286.f_bsize userInfo];
            _NSCoreDataLog( 1LL,  (uint64_t)@"Repairing old triggers failed with error = %@ and userInfo = %@",  v82,  v83,  v84,  v85,  v86,  v87,  v81);
          }

          goto LABEL_202;
        }
      }

      else if (!v79)
      {
LABEL_171:
        if (([(id)v75 isReadOnly]
           || v78 < 0x3BE
           || v78 > 0x44B
           || !-[NSManagedObjectModel _hasEntityWithDerivedAttribute]([v80 managedObjectModel]))
          && (([(id)v75 isReadOnly] & 1) != 0
           || v78 > 0x4BC
           || !-[NSManagedObjectModel _hasEntityWithDerivedAttribute]([v80 managedObjectModel])))
        {
LABEL_203:
          int v155 = *(void *)(a1 + 40);
          if (!v155) {
            goto LABEL_245;
          }
          id v156 = *(id **)(a1 + 32);
          os_unfair_lock_lock_with_options();
          uint64_t v157 = (void *)[*(id *)(v155 + 160) objectForKey:0x189EBA2C8];
          os_unfair_lock_unlock((os_unfair_lock_t)(v155 + 152));
          int v158 = [(id)v155 _persistentStoreCoordinator];
          uint64_t v159 = [v157 unsignedIntegerValue];
          uint64_t v160 = (void *)[*(id *)(v155 + 232) objectForKey:@"NSPersistentHistoryTrackingKey"];
          int v161 = [(id)v155 isReadOnly];
          if (!v158 || (v161 & 1) != 0) {
            goto LABEL_242;
          }
          uint64_t v162 = *(_DWORD *)(v155 + 200);
          hasPersistentHistory = -[NSSQLiteConnection _hasPersistentHistoryTables]((uint64_t)v156);
          uint64_t v164 = hasPersistentHistory;
          if ((v162 & 0x400) == 0)
          {
            if (hasPersistentHistory && -[NSSQLiteConnection hasHistoryRows]((BOOL)v156))
            {
              int v165 = [NSString stringWithUTF8String:"Store opened without NSPersistentHistoryTrackingKey but previously had been opened with NSPersist entHistoryTrackingKey - Forcing into Read Only mode store at '%@'"];
              int v166 = [(id)v155 URL];
              _NSCoreDataLog(17LL, v165, v167, v168, v169, v170, v171, v172, v166);
              uint64_t v173 = (os_log_s *)__pflogFaultLog;
              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
              {
                v234 = [(id)v155 URL];
                v286.f_bsize = 138412290;
                *(void *)&v286.f_iosize = v234;
                _os_log_fault_impl( &dword_186681000,  v173,  OS_LOG_TYPE_FAULT,  "CoreData: Store opened without NSPersistentHistoryTrackingKey but previously had been opened with NSPe rsistentHistoryTrackingKey - Forcing into Read Only mode store at '%@'",  (uint8_t *)&v286,  0xCu);
              }

              [(id)v155 setReadOnly:1];
            }

            goto LABEL_242;
          }

          if (v159 - 801 <= 0x16 && -[NSSQLiteConnection _hasOldHistoryTrackingTables]((uint64_t)v156))
          {
            -[NSSQLiteConnection connect]((uint64_t)v156);
            -[NSSQLiteConnection _dropOldHistoryTrackingTables]((uint64_t)v156);
          }

          if (v164)
          {
            if (v159 < 0x334)
            {
LABEL_217:
              -[NSSQLiteConnection connect]((uint64_t)v156);
              -[NSSQLiteConnection dropHistoryTrackingTables](v156);
              LOBYTE(v164) = 0;
              LOBYTE(v174) = 1;
              goto LABEL_231;
            }

            if (v159 <= 0x34C)
            {
              if (objc_msgSend( (id)objc_msgSend((id)objc_msgSend(MEMORY[0x1896079D8], "processInfo"), "processName"),  "isEqualToString:",  @"coreduetd")) {
                goto LABEL_217;
              }
              if (v159 <= 0x345)
              {
                uint64_t v175 = -[NSSQLiteConnection numberOfTombstones]((uint64_t)v156);
                if (v175 < +[_PFPersistentHistoryModel _maxCountOfTombstonesInModel:]( (uint64_t)&OBJC_CLASS____PFPersistentHistoryModel,  *(void **)(v155 + 104)))
                {
                  -[NSSQLiteConnection connect]((uint64_t)v156);
                  uint64_t v176 = -[NSSQLiteConnection numberOfTombstones]((uint64_t)v156);
                  uint64_t v177 = +[_PFPersistentHistoryModel _maxCountOfTombstonesInModel:]( (uint64_t)&OBJC_CLASS____PFPersistentHistoryModel,  *(void **)(v155 + 104));
                  -[NSSQLiteConnection addTombstoneColumnsForRange:](v156, v176, v177);
                }
              }
            }

            if (v159 == 914 || v159 == 863)
            {
              -[NSSQLiteConnection connect]((uint64_t)v156);
              -[NSSQLiteConnection hasAncillaryEntitiesInHistory](v156);
              id v185 = v178;
              if (v178)
              {
                _NSCoreDataLog( 1LL,  (uint64_t)@"found Ancillary Entities in Persistent History - %@",  v179,  v180,  v181,  v182,  v183,  v184,  v178);
                -[NSSQLiteConnection dropHistoryBeforeTransactionID:](v156, v185);
              }
            }
          }

          uint64_t v174 = v164 ^ 1;
          if (v159 >= 0x35E && v159 - 900 > 0xC)
          {
            if (!v174)
            {
LABEL_242:
              int v187 = *(void *)(a1 + 40);
              if (v187)
              {
                unsigned int v188 = *(void *)(a1 + 32);
                os_unfair_lock_lock_with_options();
                unsigned __int8 v189 = objc_msgSend( (id)objc_msgSend(*(id *)(v187 + 160), "objectForKey:", 0x189EBA2C8),  "unsignedIntegerValue");
                uint64_t v190 = (void *)[*(id *)(v187 + 160) objectForKey:0x189EB9D88];
                os_unfair_lock_unlock((os_unfair_lock_t)(v187 + 152));
                char v191 = getprogname();
                if (v191)
                {
                  if (!strncmp("homed", v191, 5uLL))
                  {
                    if ([(id)v187 _persistentStoreCoordinator])
                    {
                      if (v189 >= 0x4BA)
                      {
                        v211 = [(id)v187 isReadOnly];
                        if (v188)
                        {
                          if ((v211 & 1) == 0
                            && -[NSSQLiteConnection _hasTableWithName:isTemp:]( v188,  (uint64_t)@"Z_47ACTIONMEDIAPLAYBACKS_",  0)
                            && -[NSSQLiteConnection _hasTableWithName:isTemp:]( v188,  (uint64_t)@"Z_48ACTIONMEDIAPLAYBACKS_",  0))
                          {
                            if (([v190 isEqualToString:@"7G8C8LDyGsq8nWlygb+W8X+/Cib0xLur8J7eDoPpDg+r21Lp9FSS3Lxq6BtPoouvaSJ1rZ7uYvGBCtGwtaU/IA=="] & 1) != 0 || (objc_msgSend( v190,  "isEqualToString:",  @"NdSMhI64y0fcuGTkPpTBUTgUCmv1yHtrblyXGtAcfUtTWLUB/DyCki93Ps2ZydhpvOlS/5cUaUueM7chxR4pWg==") & 1) != 0 || objc_msgSend( v190,  "isEqualToString:",  @"GrkWfiJ5F085geZxp8His1GEvGdt1zwn0jZ+8FYWsccb6+KEIWdCVcNcaa7RAU+X37QwU+10nMCuBCnuT0/zQg=="))
                            {
                              _NSCoreDataLog( 1LL,  (uint64_t)@"Executing schema repair operations for HomeKitModel-882 Z_48ACTIONMEDIAPLAYBACKS_ table",  v212,  v213,  v214,  v215,  v216,  v217,  (uint64_t)v243);
                              v218 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:]( v188,  @"DROP TABLE Z_48ACTIONMEDIAPLAYBACKS_");
                              if (v218) {
                                CFRelease(v218);
                              }
                            }

                            else
                            {
                              v235 = [NSString stringWithUTF8String:"Unknown schema hash presents conflicting ACTIONMEDIAPLAYBACKS_ tables: %@"];
                              _NSCoreDataLog(17LL, v235, v236, v237, v238, v239, v240, v241, (uint64_t)v190);
                              v242 = (os_log_s *)__pflogFaultLog;
                              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                              {
                                v286.f_bsize = 138412290;
                                *(void *)&v286.f_iosize = v190;
                                _os_log_fault_impl( &dword_186681000,  v242,  OS_LOG_TYPE_FAULT,  "CoreData: Unknown schema hash presents conflicting ACTIONMEDIAPLAYBACKS_ tables: %@",  (uint8_t *)&v286,  0xCu);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

              goto LABEL_245;
            }

      int v76 = (void *)MEMORY[0x186E3E5D8]();
      else {
        uint64_t v77 = __ckLoggingOverride;
      }
      uint64_t v78 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Recovered from error: %@:%ld"];
      [a2 domain];
      [a2 code];
      _NSCoreDataLog( v77,  v78,  v79,  v80,  v81,  v82,  v83,  v84,  (uint64_t)"-[NSCloudKitMirroringDelegate _recoverFromError:withZoneIDs:forStore:inMonitor:]");
      uint64_t v85 = 1LL;
      goto LABEL_150;
    }

    if ([a2 code] == 112 || objc_msgSend(a2, "code") == 21 || objc_msgSend(a2, "code") == 26)
    {
      -[NSCloudKitMirroringDelegate _postResetSyncNotificationWithName:forError:]( (void *)v9,  (uint64_t)@"NSCloudKitMirroringDelegateWillResetSyncNotificationName",  a2);
      if (![a3 count])
      {
        uint64_t v41 = *(void *)(v9 + 8);
        if (v41)
        {
          CFNumberType v42 = *(void *)(v41 + 96);
          unint64_t v43 = [*(id *)(v9 + 56) databaseScope];
          if (v42
            && -[PFCloudKitMetadataPurger purgeMetadataFromStore:inMonitor:withOptions:forRecordZones:inDatabaseWithScope:andTransactionAuthor:error:]( v42,  a4,  a5,  294LL,  (uint64_t)a3,  v43,  0LL,  &v202))
          {
            if ([a2 code] != 112)
            {
              uint64_t v44 = (void *)[a2 userInfo];
              if (!objc_msgSend( (id)objc_msgSend( v44,  "objectForKey:",  getCloudKitCKErrorUserDidResetEncryptedDataKey()),  "BOOLValue")) {
                goto LABEL_86;
              }
            }

            if (-[NSCloudKitMirroringDelegate _markZonesNeedingRecoveryFromManateeIdentityLoss:databaseScope:inStore:error:]( v9,  (uint64_t)a3,  [*(id *)(v9 + 56) databaseScope],  a4,  &v202)) {
              goto LABEL_86;
            }
          }
        }

        else
        {
          [*(id *)(v9 + 56) databaseScope];
        }

        goto LABEL_148;
      }

      v196 = a5;
      v197 = v9;
      unint64_t v11 = objc_alloc_init(MEMORY[0x189603FA8]);
      unint64_t v12 = objc_alloc_init(MEMORY[0x189603FA8]);
      v198 = 0u;
      v199 = 0u;
      v200 = 0u;
      v201 = 0u;
      BOOL v13 = [a3 countByEnumeratingWithState:&v198 objects:v207 count:16];
      if (v13)
      {
        unint64_t v14 = v13;
        uint64_t v15 = *(void *)v199;
        do
        {
          for (uint64_t i = 0LL; i != v14; ++i)
          {
            if (*(void *)v199 != v15) {
              objc_enumerationMutation(a3);
            }
            BOOL v17 = *(void **)(*((void *)&v198 + 1) + 8 * i);
            unint64_t v18 = (void *)[v17 ownerName];
            else {
              id v19 = v12;
            }
            [v19 addObject:v17];
          }

          unint64_t v14 = [a3 countByEnumeratingWithState:&v198 objects:v207 count:16];
        }

        while (v14);
      }

      unint64_t v9 = v197;
      if ([v11 count])
      {
        uint64_t v20 = *(void *)(v197 + 8);
        if (!v20)
        {
LABEL_146:
          [*(id *)(v197 + 56) databaseScope];
LABEL_147:

LABEL_148:
          -[NSCloudKitMirroringDelegate _postResetSyncNotificationWithName:forError:]( (void *)v9,  (uint64_t)@"NSCloudKitMirroringDelegateDidResetSyncNotificationName",  a2);
          goto LABEL_149;
        }

        id v21 = *(void *)(v20 + 96);
        unint64_t v22 = [*(id *)(v197 + 56) databaseScope];
        if (!v21
          || !-[PFCloudKitMetadataPurger purgeMetadataFromStore:inMonitor:withOptions:forRecordZones:inDatabaseWithScope:andTransactionAuthor:error:]( v21,  a4,  v196,  298LL,  (uint64_t)v11,  v22,  0LL,  &v202))
        {
          goto LABEL_147;
        }

        if ([a2 code] == 112
          || (unint64_t v23 = (void *)[a2 userInfo],
              objc_msgSend( (id)objc_msgSend(v23, "objectForKey:", getCloudKitCKErrorUserDidResetEncryptedDataKey()),  "BOOLValue")))
        {
          if (!-[NSCloudKitMirroringDelegate _markZonesNeedingRecoveryFromManateeIdentityLoss:databaseScope:inStore:error:]( v197,  (uint64_t)v11,  [*(id *)(v197 + 56) databaseScope],  a4,  &v202)) {
            goto LABEL_147;
          }
        }
      }

      if (![v12 count])
      {

LABEL_86:
        -[NSCloudKitMirroringDelegate resetAfterError:andKeepContainer:](v9, a2);
LABEL_87:
        -[NSCloudKitMirroringDelegate _setUpCloudKitIntegration:](v9, 0LL);
LABEL_88:
        -[NSCloudKitMirroringDelegate _postResetSyncNotificationWithName:forError:]( (void *)v9,  (uint64_t)@"NSCloudKitMirroringDelegateDidResetSyncNotificationName",  a2);
        goto LABEL_89;
      }

      if ([a2 code] == 26
        || [a2 code] == 112
        || (__int16 v24 = (void *)[a2 userInfo],
            objc_msgSend( (id)objc_msgSend(v24, "objectForKey:", getCloudKitCKErrorUserDidResetEncryptedDataKey()),  "BOOLValue")))
      {
        if ([a2 code] == 112)
        {
          unint64_t v25 = -[NSCloudKitMirroringDelegate _markZonesNeedingRecoveryFromManateeIdentityLoss:databaseScope:inStore:error:]( v197,  (uint64_t)v12,  [*(id *)(v197 + 56) databaseScope],  a4,  &v202);
          goto LABEL_85;
        }

        uint64_t v56 = *(void *)(v197 + 8);
        if (v56)
        {
          uint64_t v57 = *(void *)(v56 + 96);
          uint64_t v58 = [*(id *)(v197 + 56) databaseScope];
          if (v57)
          {
            uint64_t v59 = v58;
            uint64_t v60 = v57;
            uint64_t v61 = a4;
            uint64_t v62 = v196;
            uint64_t v63 = 9LL;
LABEL_84:
            unint64_t v25 = -[PFCloudKitMetadataPurger purgeMetadataFromStore:inMonitor:withOptions:forRecordZones:inDatabaseWithScope:andTransactionAuthor:error:]( v60,  v61,  v62,  v63,  (uint64_t)v12,  v59,  0LL,  &v202);
LABEL_85:
            unsigned int v75 = v25;

            if ((v75 & 1) != 0) {
              goto LABEL_86;
            }
            goto LABEL_148;
          }

          goto LABEL_147;
        }
      }

      else
      {
        int v72 = *(void *)(v197 + 8);
        if (v72)
        {
          int v73 = *(void *)(v72 + 96);
          int v74 = [*(id *)(v197 + 56) databaseScope];
          if (v73)
          {
            uint64_t v59 = v74;
            uint64_t v60 = v73;
            uint64_t v61 = a4;
            uint64_t v62 = v196;
            uint64_t v63 = 298LL;
            goto LABEL_84;
          }

          goto LABEL_147;
        }
      }

      goto LABEL_146;
    }

    if ([a2 code] == 28)
    {
      -[NSCloudKitMirroringDelegate _postResetSyncNotificationWithName:forError:]( (void *)v9,  (uint64_t)@"NSCloudKitMirroringDelegateWillResetSyncNotificationName",  a2);
      unint64_t v47 = *(void *)(v9 + 8);
      if (v47)
      {
        unint64_t v48 = *(void *)(v47 + 96);
        unsigned int v29 = [*(id *)(v9 + 56) databaseScope];
        if (v48)
        {
          unsigned int v29 = -[PFCloudKitMetadataPurger purgeMetadataFromStore:inMonitor:withOptions:forRecordZones:inDatabaseWithScope:andTransactionAuthor:error:]( v48,  a4,  a5,  9LL,  (uint64_t)a3,  v29,  0LL,  &v202);
          if ((_DWORD)v29) {
            goto LABEL_86;
          }
        }

    unint64_t v48 = (void *)MEMORY[0x186E3E5D8]();
    uint64_t v49 = __ckLoggingOverride != 0;
    CFNumberRef v50 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@: Found unknown error as part of a partial failure: %@"];
    _NSCoreDataLog( v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  (uint64_t)"-[NSCloudKitMirroringDelegate _recoverFromPartialError:forStore:inMonitor:]_block_invoke");
    objc_autoreleasePoolPop(v48);
    uint64_t v57 = -[PFCloudKitUnhandledPartialErrorMetric initWithContainerIdentifier:error:]( [PFCloudKitUnhandledPartialErrorMetric alloc],  "initWithContainerIdentifier:error:",  [*(id *)(*(void *)(a1 + 80) + 8) containerIdentifier],  a3);
    uint64_t v58 = *(void *)(*(void *)(a1 + 80) + 8LL);
    if (v58) {
      uint64_t v59 = *(void *)(v58 + 72);
    }
    else {
      uint64_t v59 = 0LL;
    }
    -[PFCloudKitMetricsClient logMetric:](v59, v57);

    goto LABEL_92;
  }

  unint64_t v25 = [NSString stringWithUTF8String:"%@: Found unknown itemID (%@) as part of a partial failure: %@"];
  _NSCoreDataLog(17LL, v25, v26, v27, v28, v29, v30, v31, *(void *)(a1 + 80));
  uint64_t v32 = (os_log_s *)__pflogFaultLog;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    unint64_t v33 = *(void **)(a1 + 80);
    *(_DWORD *)buf = 138412802;
    uint64_t v61 = v33;
    uint64_t v62 = 2112;
    uint64_t v63 = a2;
    uint64_t v64 = 2112;
    uint64_t v65 = a3;
    _os_log_fault_impl( &dword_186681000,  v32,  OS_LOG_TYPE_FAULT,  "CoreData: %@: Found unknown itemID (%@) as part of a partial failure: %@",  buf,  0x20u);
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL)) {
    *(void *)(*(void *)(a1 + 48) + 128LL) = 0LL;
  }
LABEL_49:
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
  {
    int v136 = 0u;
    int v137 = 0u;
    uint64_t v134 = 0u;
    char v135 = 0u;
    obuint64_t j = *(id *)(*(void *)(a1 + 48) + 120LL);
    uint64_t v65 = [obj countByEnumeratingWithState:&v134 objects:v146 count:16];
    if (v65)
    {
      uint64_t v66 = *(void *)v135;
LABEL_52:
      int v67 = 0LL;
      while (1)
      {
        if (*(void *)v135 != v66) {
          objc_enumerationMutation(obj);
        }
        unsigned int v68 = *(void **)(*((void *)&v134 + 1) + 8 * v67);
        int v69 = (void *)MEMORY[0x186E3E5D8]();
        uint64_t v70 = *(void *)(a1 + 48);
        if (v70 && (int v71 = *(void *)(v70 + 8)) != 0) {
          int v72 = *(void **)(v71 + 24);
        }
        else {
          int v72 = 0LL;
        }
        int v73 = +[NSCKRecordZoneMetadata zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:error:]( (uint64_t)NSCKRecordZoneMetadata,  v68,  [v72 databaseScope],  *(void *)(a1 + 32),  *(void **)(a1 + 40),  *(void *)(*(void *)(a1 + 56) + 8) + 40);
        if (v73)
        {
          int v74 = [*(id *)(*(void *)(a1 + 48) + 120) objectForKey:v68];
          unsigned int v75 = (void *)MEMORY[0x186E3E5D8]();
          int v76 = __ckLoggingOverride;
          uint64_t v77 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Importing updated share: %@"];
          int v84 = v76 >= 0x10 ? 16LL : v76;
          _NSCoreDataLog( v84,  v77,  v78,  v79,  v80,  v81,  v82,  v83,  (uint64_t)"-[PFCloudKitImportRecordsWorkItem applyAccumulatedChangesToStore:inManagedObjectContext:withStoreMo nitor:madeChanges:error:]_block_invoke");
          objc_autoreleasePoolPop(v75);
          uint64_t v85 = *(void *)(a1 + 48);
          if (v85
            && (id v86 = *(void *)(v85 + 8)) != 0
            && (int v87 = *(void *)(v86 + 24)) != 0
            && (uint64_t v88 = *(void *)(v87 + 136)) != 0
            && (uint64_t v89 = -[PFCloudKitArchivingUtilities encodeRecord:error:]( v88,  v74,  (void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL))) != 0LL)
          {
            -[NSManagedObject setEncodedShareData:](v73, "setEncodedShareData:", v89);
            -[NSManagedObject setNeedsShareUpdate:](v73, "setNeedsShareUpdate:", 0LL);
          }

          else
          {
            *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
            uint64_t v91 = (void *)MEMORY[0x186E3E5D8](*(id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL));
            uint64_t v92 = __ckLoggingOverride;
            uint64_t v93 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Failed to encode an updated share: %@\n%@\n%@\n%@"];
            _NSCoreDataLog( v92 != 0,  v93,  v94,  v95,  v96,  v97,  v98,  v99,  (uint64_t)"-[PFCloudKitImportRecordsWorkItem applyAccumulatedChangesToStore:inManagedObjectContext:withStore Monitor:madeChanges:error:]_block_invoke");
            objc_autoreleasePoolPop(v91);
            uint64_t v89 = 0LL;
          }
        }

        else
        {
          *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
          uint64_t v90 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
        }

        uint64_t v100 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL);
        objc_autoreleasePoolPop(v69);
        if (!v100) {
          break;
        }
        if (v65 == ++v67)
        {
          uint64_t v101 = [obj countByEnumeratingWithState:&v134 objects:v146 count:16];
          uint64_t v65 = v101;
          if (v101) {
            goto LABEL_52;
          }
          break;
        }
      }
    }

    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL)
      && ([*(id *)(a1 + 40) save:*(void *)(*(void *)(a1 + 56) + 8) + 40] & 1) == 0)
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
      unint64_t v102 = *(id *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
    }
  }

  -[PFCloudKitImportRecordsWorkItem removeDownloadedAssetFiles](*(void *)(a1 + 48));
}

LABEL_165:
            if (v55 == ++v56) {
              goto LABEL_166;
            }
          }

          uint64_t v60 = [v57 _propertyType] - 2;
          uint64_t v61 = v43;
          switch(v60)
          {
            case 0LL:
            case 4LL:
            case 5LL:
              else {
                uint64_t v61 = v41;
              }
              break;
            case 1LL:
              break;
            case 2LL:
              if ([v57 isToMany])
              {
                if ([v57 isTransient])
                {
                  uint64_t v62 = [v57 isOrdered] == 0;
                  uint64_t v63 = v161;
                  uint64_t v64 = v159;
                }

                else
                {
                  uint64_t v62 = [v57 isOrdered] == 0;
                  uint64_t v64 = v162;
                  uint64_t v63 = v163;
                }

                if (v62) {
                  uint64_t v61 = v63;
                }
                else {
                  uint64_t v61 = v64;
                }
              }

              else if ([v57 isTransient])
              {
                uint64_t v61 = v164;
              }

              else
              {
                uint64_t v61 = v166;
              }

              break;
            default:
              uint64_t v61 = v167;
              break;
          }

          -[NSArray addObject:](v61, "addObject:", v58);
          goto LABEL_165;
        }
      }

      else
      {
        uint64_t v41 = (NSArray *)[MEMORY[0x189603FA8] array];
        int v158 = (id)[MEMORY[0x189603FA8] array];
        CFNumberType v42 = (NSArray *)[MEMORY[0x189603FA8] array];
        int v166 = (NSArray *)[MEMORY[0x189603FA8] array];
        uint64_t v164 = (NSArray *)[MEMORY[0x189603FA8] array];
        uint64_t v162 = (NSArray *)[MEMORY[0x189603FA8] array];
        uint64_t v163 = (NSArray *)[MEMORY[0x189603FA8] array];
        uint64_t v159 = (NSArray *)[MEMORY[0x189603FA8] array];
        int v161 = (NSArray *)[MEMORY[0x189603FA8] array];
        unint64_t v43 = (NSArray *)[MEMORY[0x189603FA8] array];
        uint64_t v167 = (NSArray *)[MEMORY[0x189603FA8] array];
        uint64_t v44 = [v12 count];
        if (v44)
        {
          for (uint64_t k = 0LL; k != v44; ++k)
          {
            unint64_t v46 = (void *)objc_msgSend(v165, "objectAtIndex:", k, v157);
            unint64_t v47 = [v46 name];
            unint64_t v48 = [v46 _propertyType] - 2;
            uint64_t v49 = v43;
            switch(v48)
            {
              case 0LL:
              case 4LL:
              case 5LL:
                else {
                  uint64_t v49 = v41;
                }
                break;
              case 1LL:
                break;
              case 2LL:
                if ([v46 isToMany])
                {
                  if ([v46 isTransient])
                  {
                    CFNumberRef v50 = [v46 isOrdered] == 0;
                    unint64_t v51 = v161;
                    unint64_t v52 = v159;
                  }

                  else
                  {
                    CFNumberRef v50 = [v46 isOrdered] == 0;
                    unint64_t v52 = v162;
                    unint64_t v51 = v163;
                  }

                  if (v50) {
                    uint64_t v49 = v51;
                  }
                  else {
                    uint64_t v49 = v52;
                  }
                }

                else if ([v46 isTransient])
                {
                  uint64_t v49 = v164;
                }

                else
                {
                  uint64_t v49 = v166;
                }

                break;
              default:
                uint64_t v49 = v167;
                break;
            }

            -[NSArray addObject:](v49, "addObject:", v47);
          }
        }
      }

  if ([v143 count])
  {
    uint64_t v88 = (void *)[v125 objectForKey:@"updated"];
    if (v88) {
      objc_msgSend(v88, "addObjectsFromArray:", objc_msgSend(v143, "allObjects"));
    }
    else {
      [v125 setValue:v143 forKey:@"updated"];
    }
  }

LABEL_170:
  if (![v130 count]) {
    goto LABEL_193;
  }
  uint64_t v89 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FE0]), "initWithCapacity:", objc_msgSend(v130, "count"));
  uint64_t v152 = 0u;
  uint64_t v153 = 0u;
  int v150 = 0u;
  uint64_t v151 = 0u;
  uint64_t v90 = [v130 countByEnumeratingWithState:&v150 objects:v190 count:16];
  if (!v90) {
    goto LABEL_190;
  }
  uint64_t v91 = *(void *)v151;
  while (2)
  {
    uint64_t v92 = 0LL;
    while (2)
    {
      if (*(void *)v151 != v91) {
        objc_enumerationMutation(v130);
      }
      uint64_t v93 = *(void *)(*((void *)&v150 + 1) + 8 * v92);
      id v94 = *(void *)(a1 + 16);
      if (v94) {
        uint64_t v95 = (void *)[*(id *)(v94 + 240) objectForKey:@"NSPersistentHistoryTrackingEntitiesToExclude"];
      }
      else {
        uint64_t v95 = 0LL;
      }
      if (![v95 count]) {
        goto LABEL_187;
      }
      uint64_t v96 = *(void *)(a1 + 16);
      if (v96)
      {
        uint64_t v97 = (void *)[*(id *)(v96 + 240) objectForKey:@"NSPersistentHistoryTrackingEntitiesToExclude"];
        if (v93) {
          goto LABEL_181;
        }
LABEL_185:
        uint64_t v98 = 0LL;
      }

      else
      {
        uint64_t v97 = 0LL;
        if (!v93) {
          goto LABEL_185;
        }
LABEL_181:
        if ((*(_BYTE *)(v93 + 16) & 1) != 0) {
          goto LABEL_185;
        }
        uint64_t v98 = (void *)[*(id *)(*(void *)(v93 + 40) + 16) _storeInfo1];
      }

      if ((objc_msgSend(v97, "containsObject:", objc_msgSend(v98, "name")) & 1) == 0) {
LABEL_187:
      }
        [v89 addObject:v93];
      if (v90 != ++v92) {
        continue;
      }
      break;
    }

    uint64_t v90 = [v130 countByEnumeratingWithState:&v150 objects:v190 count:16];
    if (v90) {
      continue;
    }
    break;
  }

LABEL_166:
      uint64_t v65 = (_NSRange *)PF_CALLOC_SCANNED_BYTES(0x120uLL);
      uint64_t v66 = v168;
      v168->_propertyRanges = v65;
      int v67 = (void *)objc_msgSend( MEMORY[0x189603FA8],  "arrayWithCapacity:",  -[NSMutableDictionary count](v66->_properties, "count"));
      unsigned int v68 = -[NSArray count](v41, "count");
      [v67 addObjectsFromArray:v41];
      int v69 = v168->_propertyRanges;
      v69[15].location = 0LL;
      v69[15].length = v68;
      uint64_t v70 = [v158 count];
      [v67 addObjectsFromArray:v158];
      int v71 = v168->_propertyRanges;
      v71[16].location = v68;
      v71[16].length = v70;
      int v72 = [v67 count];
      v71[3].location = 0LL;
      v71[3].length = v72;
      int v73 = -[NSArray count](v42, "count");
      [v67 addObjectsFromArray:v42];
      int v74 = v70 + v68;
      unsigned int v75 = v168->_propertyRanges;
      v75[5].location = v74;
      v75[5].length = v73;
      int v76 = [v67 count];
      v75[1].location = 0LL;
      v75[1].length = v76;
      uint64_t v77 = -[NSArray count](v166, "count");
      [v67 addObjectsFromArray:v166];
      uint64_t v78 = v73 + v74;
      uint64_t v79 = v168->_propertyRanges;
      v79[6].location = v78;
      v79[6].length = v77;
      uint64_t v80 = -[NSArray count](v163, "count");
      [v67 addObjectsFromArray:v163];
      uint64_t v81 = v77 + v78;
      uint64_t v82 = v168->_propertyRanges;
      v82[7].location = v81;
      v82[7].length = v80;
      uint64_t v83 = -[NSArray count](v162, "count");
      [v67 addObjectsFromArray:v162];
      int v84 = v80 + v81;
      uint64_t v85 = v168->_propertyRanges;
      v85[8].location = v84;
      v85[8].length = v83;
      id v86 = v85[7].length + v83;
      v85[9].location = v85[7].location;
      v85[9].length = v86;
      int v87 = v85[6].length + v86;
      v85[4].location = v85[6].location;
      v85[4].length = v87;
      uint64_t v88 = -[NSArray count](v164, "count");
      [v67 addObjectsFromArray:v164];
      uint64_t v89 = v83 + v84;
      uint64_t v90 = v168->_propertyRanges;
      v90[10].location = v89;
      v90[10].length = v88;
      uint64_t v91 = -[NSArray count](v161, "count");
      [v67 addObjectsFromArray:v161];
      uint64_t v92 = v88 + v89;
      uint64_t v93 = v168->_propertyRanges;
      v93[11].location = v92;
      v93[11].length = v91;
      id v94 = -[NSArray count](v159, "count");
      [v67 addObjectsFromArray:v159];
      uint64_t v95 = v91 + v92;
      uint64_t v96 = v168;
      uint64_t v97 = v168->_propertyRanges;
      v97[12].location = v95;
      v97[12].length = v94;
      uint64_t v98 = v97[11].length + v94;
      v97[13].location = v97[11].location;
      v97[13].length = v98;
      location = v97[6].location;
      uint64_t v100 = [v67 count] - v96->_propertyRanges[1].length;
      v97[2].location = location;
      v97[2].length = v100;
      uint64_t v101 = -[NSArray count](v43, "count");
      [v67 addObjectsFromArray:v43];
      unint64_t v102 = v94 + v95;
      unint64_t v103 = v167;
      unint64_t v104 = v168->_propertyRanges;
      v104[14].location = v102;
      v104[14].length = v101;
      __int16 v105 = -[NSArray count](v103, "count");
      [v67 addObjectsFromArray:v167];
      uint64_t v106 = v168->_propertyRanges;
      v106[17].location = v102 + 2 * v101;
      v106[17].length = v105;
      uint64_t v107 = [v67 count];
      int v108 = v168->_propertyRanges;
      v108->location = 0LL;
      v108->length = v107;
      int v109 = MEMORY[0x1895F8858](v107);
      uint64_t v112 = (char *)&v157 - v111;
      uint64_t v113 = 8 * v110;
      if (v109 >= 0x201)
      {
        uint64_t v112 = (char *)NSAllocateScannedUncollectable();
        uint64_t v115 = (char *)NSAllocateScannedUncollectable();
      }

      else
      {
        bzero((char *)&v157 - v111, 8 * v110);
        MEMORY[0x1895F8858](v114);
        uint64_t v115 = (char *)&v157 - ((v113 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        bzero(v115, v113);
      }

      objc_msgSend(v67, "getObjects:range:", v115, 0, v107, v157);
      if (v107)
      {
        for (m = 0LL; m != v107; ++m)
        {
          int v117 = (void *)-[NSMutableDictionary objectForKey:]( v168->_properties,  "objectForKey:",  *(void *)&v115[8 * m]);
          *(void *)&v112[8 * m] = v117;
          [v117 _setEntitysReferenceID:m];
        }
      }

      int v118 = -[NSKnownKeysDictionary initWithObjects:forKeys:count:]( objc_alloc(&OBJC_CLASS___NSKnownKeysDictionary),  "initWithObjects:forKeys:count:",  v112,  v115,  v107);
      if (v107 >= 0x201)
      {
        NSZoneFree(0LL, v112);
        NSZoneFree(0LL, v115);
      }

      [v157 drain];

      v168->_properties = &v118->super;
      unsigned int v119 = -[NSKnownKeysDictionary mapping](v118, "mapping");
      v168->_propertyMapping = (id)v119;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      int v120 = (void *)objc_msgSend( (id)-[NSMutableDictionary allValues](v168->_subentities, "allValues"),  "sortedArrayUsingFunction:context:",  _compareEntitiesByName,  0);
      unint64_t v121 = [v120 count];
      uint64_t v122 = MEMORY[0x1895F8858](v121);
      int v125 = (char *)&v157 - v124;
      uint64_t v126 = 8 * v123;
      if (v122 >= 0x201)
      {
        int v125 = (char *)NSAllocateScannedUncollectable();
        uint64_t v128 = (char *)NSAllocateScannedUncollectable();
      }

      else
      {
        bzero((char *)&v157 - v124, 8 * v123);
        MEMORY[0x1895F8858](v127);
        uint64_t v128 = (char *)&v157 - ((v126 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        bzero(v128, v126);
      }

      objc_msgSend(v120, "getObjects:range:", v125, 0, v121);
      if (v121)
      {
        BOOL v129 = (id *)v125;
        uint64_t v130 = v128;
        uint64_t v131 = v121;
        do
        {
          *(void *)uint64_t v130 = [*v129 name];
          v130 += 8;
          ++v129;
          --v131;
        }

        while (v131);
      }

      unint64_t v132 = -[NSKnownKeysDictionary initWithObjects:forKeys:count:]( objc_alloc(&OBJC_CLASS___NSKnownKeysDictionary),  "initWithObjects:forKeys:count:",  v125,  v128,  v121);
      if (v121 >= 0x201)
      {
        NSZoneFree(0LL, v125);
        NSZoneFree(0LL, v128);
      }

      v168->_subentities = &v132->super;
    }

    unint64_t v133 = v168;
    if (!v168->_flattenedSubentities)
    {
      uint64_t v134 = -[NSEntityDescription _collectSubentities](v168);
      unint64_t v133 = v168;
      v168->_flattenedSubentities = v134;
    }

    propertyMapping = v133->_propertyMapping;
    int v136 = [propertyMapping keys];
    int v137 = [propertyMapping length];
    int v138 = (id **)PF_CALLOC_SCANNED_BYTES(0x50uLL);
    int v139 = v168;
    v168->_kvcPropertyAccessors = v138;
    *((void *)v139->_kvcPropertyAccessors + 6) = [objc_alloc(MEMORY[0x189604010]) initWithObjects:v136 count:v137];
    *((void *)v139->_kvcPropertyAccessors + 7) = -[NSEntityDescription _newMappingForPropertiesOfRange:]( v139,  "_newMappingForPropertiesOfRange:",  1LL);
    *((void *)v139->_kvcPropertyAccessors + _Block_object_dispose(va, 8) = -[NSEntityDescription _newMappingForPropertiesOfRange:]( v139,  "_newMappingForPropertiesOfRange:",  2LL);
    *((void *)v139->_kvcPropertyAccessors + 9) = PF_CALLOC_SCANNED_BYTES(v137);
    -[NSEntityDescription _commonCachesAndOptimizedState](v139);
    *(_DWORD *)&v139->_entityDescriptionFlags |= 4u;
    unsigned __int8 v189 = 0u;
    uint64_t v190 = 0u;
    char v191 = 0u;
    uint64_t v192 = 0u;
    properties = v139->_properties;
    char v141 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( properties,  "countByEnumeratingWithState:objects:count:",  &v189,  v200,  16LL);
    if (v141)
    {
      id v142 = 0LL;
      id v143 = *(void *)v190;
      do
      {
        for (n = 0LL; n != v141; ++n)
        {
          if (*(void *)v190 != v143) {
            objc_enumerationMutation(properties);
          }
          uint64_t v145 = (void *)-[NSMutableDictionary objectForKey:]( v168->_properties,  "objectForKey:",  *(void *)(*((void *)&v189 + 1) + 8 * n));
          if ([v145 _isAttribute] && objc_msgSend(v145, "_namespace"))
          {
            if (!v142) {
              id v142 = (void *)[MEMORY[0x189603FC8] dictionary];
            }
            -[NSEntityDescription _checkAttributeMembership:hashes:](v145, v142);
          }
        }

        char v141 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( properties,  "countByEnumeratingWithState:objects:count:",  &v189,  v200,  16LL);
      }

      while (v141);
    }

    [v160 drain];
    v146 = 0LL;
    if (v168)
    {
      if (!v168->_extraIvars) {
        -[NSEntityDescription _initializeExtraIVars]((uint64_t)v168);
      }
    }
  }

        unint64_t v31 = v116;
        goto LABEL_167;
      }

      int v139 = @"NSSQLiteErrorDomain";
      unsigned int v140 = [MEMORY[0x189607968] numberWithInt:v61];
      uint64_t v114 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:&v140 forKeys:&v139 count:1];
      uint64_t v115 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A48],  (int)v61,  (uint64_t)@"Persistent history request failed to adopt query generation",  v114);
      -[_NSCoreDataException _setDomain:]((uint64_t)v115, @"NSSQLiteErrorDomain");
      objc_exception_throw(v115);
LABEL_204:
      __break(1u);
      return;
    }

    if (a1) {
      int v76 = (void *)a1[4];
    }
    else {
      int v76 = 0LL;
    }
    if (objc_msgSend((id)objc_msgSend(v76, "_queryGenerationToken"), "_isEnabled"))
    {
      -[NSSQLiteConnection beginReadTransaction]((uint64_t)v118);
      if (a1) {
        uint64_t v77 = (void *)a1[4];
      }
      else {
        uint64_t v77 = 0LL;
      }
      uint64_t v78 = [v77 _queryGenerationToken];
      if (a1) {
        uint64_t v79 = (void *)a1[1];
      }
      else {
        uint64_t v79 = 0LL;
      }
      uint64_t v80 = -[_NSQueryGenerationToken _generationalComponentForStore:](v78, v79);
      if (v80) {
        uint64_t v81 = *((void *)v80 + 3);
      }
      else {
        uint64_t v81 = 0LL;
      }
      uint64_t v82 = -[NSSQLiteConnection adoptQueryGenerationWithIdentifier:]((uint64_t)v118, v81);
      if ((_DWORD)v82)
      {
        char v141 = @"NSSQLiteErrorDomain";
        id v142 = [MEMORY[0x189607968] numberWithInt:v82];
        uint64_t v112 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:&v142 forKeys:&v141 count:1];
        uint64_t v113 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A48],  (int)v82,  (uint64_t)@"Persistent history request failed to adopt query generation",  v112);
        -[_NSCoreDataException _setDomain:]((uint64_t)v113, @"NSSQLiteErrorDomain");
        objc_exception_throw(v113);
        goto LABEL_204;
      }

      int v116 = 1;
    }

    uint64_t v83 = [a1 createCountRequestContextForChanges];
    -[NSSQLStoreRequestContext setConnection:](v83, v118);
    _executeCountRequest(v83);
    unint64_t v31 = 0;
    if (v116)
    {
      -[NSSQLiteConnection endFetchAndRecycleStatement:]((uint64_t)v118, 0);
      -[NSSQLiteConnection commitTransaction]((uint64_t)v118);
    }

    -[NSSQLStoreRequestContext setConnection:](v83, 0LL);
    goto LABEL_167;
  }

  if (!objc_msgSend((id)objc_msgSend(v4, "fetchRequest"), "predicate")) {
    goto LABEL_50;
  }
  unint64_t v22 =  -[_NSPersistentHistoryTransactionPredicateParser initWithPredicate:]( [_NSPersistentHistoryTransactionPredicateParser alloc],  "initWithPredicate:",  objc_msgSend((id)objc_msgSend(v4, "fetchRequest"), "predicate"));
  *(void *)unint64_t v132 = 0LL;
  -[_NSPersistentHistoryTransactionPredicateParser parse:](v22, "parse:", v132);
  if (*(void *)v132)
  {
    id v21 = 0;
    if (a2) {
      *a2 = *(void *)v132;
    }
    goto LABEL_127;
  }

  uint64_t v32 = -[_NSPersistentHistoryTransactionPredicateParser storeTokens](v22, "storeTokens");
  unint64_t v33 = a1 ? (void *)a1[1] : 0LL;
  unint64_t v34 = objc_msgSend(v32, "objectForKey:", objc_msgSend(v33, "identifier"));
  if (!v34)
  {
LABEL_50:
    id v21 = 0;
    goto LABEL_51;
  }

  if (a1) {
    unsigned int v35 = (void *)a1[4];
  }
  else {
    unsigned int v35 = 0LL;
  }
  unint64_t v36 = objc_msgSend((id)objc_msgSend(v35, "_queryGenerationToken"), "_isEnabled");
  if (v36)
  {
    id v21 = 1;
    -[NSSQLiteConnection beginReadTransaction]((uint64_t)v118);
    if (a1) {
      unsigned int v37 = (void *)a1[4];
    }
    else {
      unsigned int v37 = 0LL;
    }
    id v38 = [v37 _queryGenerationToken];
    if (a1) {
      double v39 = (void *)a1[1];
    }
    else {
      double v39 = 0LL;
    }
    unint64_t v40 = -[_NSQueryGenerationToken _generationalComponentForStore:](v38, v39);
    if (v40) {
      uint64_t v41 = *((void *)v40 + 3);
    }
    else {
      uint64_t v41 = 0LL;
    }
    CFNumberType v42 = -[NSSQLiteConnection adoptQueryGenerationWithIdentifier:]((uint64_t)v118, v41);
    if ((_DWORD)v42)
    {
      unint64_t v43 = [NSString stringWithUTF8String:"Persistent history request failed to adopt a query generation with error %d"];
      _NSCoreDataLog(17LL, v43, v44, v45, v46, v47, v48, v49, v42);
      CFNumberRef v50 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 67109120;
        int v148 = v42;
        _os_log_fault_impl( &dword_186681000,  v50,  OS_LOG_TYPE_FAULT,  "CoreData: Persistent history request failed to adopt a query generation with error %d",  buf,  8u);
      }
    }
  }

  else
  {
    id v21 = 0;
  }

  -[NSSQLiteConnection hasHistoryTransactionWithNumber:](v118, v34);
  int v87 = v86;
  if ((v86 & 1) == 0)
  {
    if (a1) {
      uint64_t v88 = (void *)a1[1];
    }
    else {
      uint64_t v88 = 0LL;
    }
    uint64_t v89 = [NSString stringWithFormat:@"Persistent History Token is expired for store at %@", objc_msgSend(v88, "URL")];
    uint64_t v90 = (void *)MEMORY[0x189607870];
    v146[0] = v89;
    v145[0] = @"message";
    v145[1] = @"NSStoreUUID";
    if (a1) {
      uint64_t v91 = (void *)a1[1];
    }
    else {
      uint64_t v91 = 0LL;
    }
    v146[1] = [v91 identifier];
    v145[2] = *MEMORY[0x1896074F8];
    if (a1) {
      uint64_t v92 = (void *)a1[1];
    }
    else {
      uint64_t v92 = 0LL;
    }
    v146[2] = objc_msgSend((id)objc_msgSend(v92, "URL"), "path");
    uint64_t v93 = [MEMORY[0x189603F68] dictionaryWithObjects:v146 forKeys:v145 count:3];
    uint64_t v131 = [v90 errorWithDomain:*MEMORY[0x189607460] code:134301 userInfo:v93];
  }

  if (v36)
  {
    -[NSSQLiteConnection commitTransaction]((uint64_t)v118);
    id v21 = 0;
  }

  if ((v87 & 1) != 0) {
    goto LABEL_51;
  }
LABEL_127:
  unint64_t v31 = v21 != 0;
LABEL_167:
  -[NSSQLiteConnection endFetchAndRecycleStatement:]((uint64_t)v118, 0);
  if (v31) {
    -[NSSQLiteConnection rollbackTransaction]((uint64_t)v118);
  }
  if (a2)
  {
    if (v131) {
      *a2 = v131;
    }
  }

void sub_18672A060(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18672A030LL);
  }

  JUMPOUT(0x186729F8CLL);
}

uint64_t _readEntityIntoShellFromData( void *a1, uint64_t a2, void *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unint64_t *a9, uint64_t a10, void *a11, uint64_t a12, unint64_t **a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t **a17, uint64_t *a18)
{
  unint64_t v18 = a18;
  v257[1] = *MEMORY[0x1895F89C0];
  unint64_t v19 = (*a3 + 3LL) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v20 = v19 + 4;
  if (v19 + 4 > a4 || (uint64_t v21 = a2, *(_DWORD *)(a2 + v19) != -335614502))
  {
    if (!a18) {
      return 0LL;
    }
    unint64_t v31 = (void *)MEMORY[0x189607870];
    uint64_t v32 = *MEMORY[0x189607460];
    unint64_t v33 = (void *)MEMORY[0x189603F68];
    unint64_t v34 = @"Can't read entity into shell: Missing entity frontside delimiter";
    goto LABEL_7;
  }

  uint64_t v22 = a8;
  uint64_t v23 = a7;
  uint64_t v25 = a5;
  unsigned int v26 = a3;
  unint64_t v27 = a1;
  unint64_t v28 = (v19 + 7) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v29 = v28 + 4;
  if (v28 + 4 <= a4)
  {
    unsigned int v30 = bswap32(*(_DWORD *)(a2 + v28));
    unint64_t v20 = v29;
  }

  else
  {
    unsigned int v30 = 0;
  }

  unint64_t v37 = v20 + v30;
  if (v37 > a4)
  {
    if (!a18) {
      return 0LL;
    }
    unint64_t v31 = (void *)MEMORY[0x189607870];
    uint64_t v32 = *MEMORY[0x189607460];
    unint64_t v33 = (void *)MEMORY[0x189603F68];
    unint64_t v34 = @"Can't read entity: Not enough bytes left";
    goto LABEL_7;
  }

  id v38 = a13;
  unint64_t v39 = (v20 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v40 = v39 + 4;
  if (v39 + 4 <= v37)
  {
    unsigned int v41 = *(_DWORD *)(a2 + v39);
    if (v41)
    {
      CFNumberType v42 = a13[bswap32(v41)];
      uint64_t v255 = (uint64_t)a18;
      unint64_t v46 = v37;
      CFNumberRef v50 = v42;
      id v38 = a13;
      uint64_t v25 = a5;
      uint64_t v22 = a8;
      uint64_t v23 = a7;
      unint64_t v37 = v46;
      unsigned int v26 = a3;
      uint64_t v21 = a2;
      unint64_t v18 = a18;
      unint64_t v27 = a1;
      *(void *)(v25 + 24) = v50;
    }

    unint64_t v20 = v40;
  }

  unint64_t v51 = (v20 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v52 = v51 + 4;
  if (v51 + 4 > v37 || (unsigned int v53 = *(_DWORD *)(v21 + v51), v257[0] = v51 + 4, !v53))
  {
    if (!v18) {
      return 0LL;
    }
    unint64_t v31 = (void *)MEMORY[0x189607870];
    uint64_t v32 = *MEMORY[0x189607460];
    unint64_t v33 = (void *)MEMORY[0x189603F68];
    unint64_t v34 = @"Can't read entity: Missing version hash value";
    goto LABEL_7;
  }

  v252 = v38;
  v253 = v27;
  uint64_t v255 = a12;
  uint64_t v251 = a14;
  atomic_store((unint64_t)*(id *)(a14 + 8LL * bswap32(v53)), (unint64_t *)(v25 + 32));
  unint64_t v54 = (v51 + 7) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v55 = v54 + 4;
  if (v54 + 4 <= v37)
  {
    unsigned int v56 = *(_DWORD *)(v21 + v54);
    if (v56) {
      *(void *)(v25 + 4_Block_object_dispose(va, 8) = *(id *)(v255 + 8LL * bswap32(v56));
    }
    unint64_t v52 = v55;
  }

  uint64_t v254 = a6;
  unint64_t v57 = (v52 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v58 = v57 + 4;
  if (v57 + 4 > v37 || (unsigned int v59 = *(_DWORD *)(v21 + v57), v257[0] = v57 + 4, !v59))
  {
    if (!v18) {
      return 0LL;
    }
    unint64_t v31 = (void *)MEMORY[0x189607870];
    uint64_t v32 = *MEMORY[0x189607460];
    unint64_t v33 = (void *)MEMORY[0x189603F68];
    unint64_t v34 = @"Can't read entity: Missing entity name";
    goto LABEL_7;
  }

  uint64_t v250 = a15;
  *(void *)(v25 + 64) = *(id *)(v255 + 8LL * bswap32(v59));
  unint64_t v60 = v57 + 5;
  if (v57 + 5 <= v37)
  {
    int v62 = *(unsigned __int8 *)(v21 + v58);
    v257[0] = v57 + 5;
    uint64_t v61 = v254;
    if (v62)
    {
      unint64_t v63 = (v52 + 11) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v64 = v63 + 4;
      uint64_t v65 = v250;
      if (v63 + 4 <= v37)
      {
        unsigned int v66 = bswap32(*(_DWORD *)(v21 + v63));
        v257[0] = v64;
        unint64_t v60 = v64;
      }

      else
      {
        unsigned int v66 = 0;
      }

      *(void *)(v25 + 80) = *(void *)(v250 + 8LL * v66);
      unint64_t v58 = v60;
      goto LABEL_37;
    }

    unint64_t v58 = v60;
  }

  else
  {
    uint64_t v61 = v254;
  }

  uint64_t v65 = v250;
LABEL_37:
  unint64_t v67 = (v58 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v68 = v67 + 4;
  if (v67 + 4 <= v37)
  {
    unsigned int v69 = bswap32(*(_DWORD *)(v21 + v67));
    v257[0] = v68;
    unint64_t v58 = v68;
  }

  else
  {
    unsigned int v69 = 0;
  }

  *(void *)(v25 + 72) = *(void *)(v65 + 8LL * v69);
  unint64_t v70 = v58 + 1;
  if (v58 + 1 <= v37)
  {
    int v71 = *(unsigned __int8 *)(v21 + v58);
    v257[0] = v58 + 1;
    if (v71)
    {
      if ((v58 & 0xFFFFFFFFFFFFFFFCLL) + 8 <= v37)
      {
        unsigned int v72 = bswap32(*(_DWORD *)((v58 & 0xFFFFFFFFFFFFFFFCLL) + v21 + 4));
        v257[0] = (v58 & 0xFFFFFFFFFFFFFFFCLL) + 8;
        unint64_t v70 = v257[0];
      }

      else
      {
        unsigned int v72 = 0;
      }

      int v73 = *(void **)(v61 + 8LL * v72);
      *(void *)(v25 + 8_Block_object_dispose(va, 8) = v73;
      if ([v73 count])
      {
        if (!v18) {
          return 0LL;
        }
        unint64_t v31 = (void *)MEMORY[0x189607870];
        uint64_t v32 = *MEMORY[0x189607460];
        unint64_t v33 = (void *)MEMORY[0x189603F68];
        unint64_t v34 = @"Cant' read entity: Miswired subentities dictionary";
        goto LABEL_7;
      }

      unint64_t v74 = (v70 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      if (v74 + 4 <= v37)
      {
        unsigned int v75 = bswap32(*(_DWORD *)(v21 + v74));
        v257[0] = v74 + 4;
        unint64_t v70 = v74 + 4;
      }

      else
      {
        unsigned int v75 = 0;
      }

      if (objc_msgSend((id)objc_msgSend(*(id *)(v25 + 88), "mapping"), "length") != v75)
      {
        if (!v18) {
          return 0LL;
        }
        unint64_t v31 = (void *)MEMORY[0x189607870];
        uint64_t v32 = *MEMORY[0x189607460];
        unint64_t v33 = (void *)MEMORY[0x189603F68];
        unint64_t v34 = @"Cant' read entity: Mismatched subentity count";
        goto LABEL_7;
      }

      uint64_t v76 = v75;
      unint64_t v77 = (v70 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      unint64_t v78 = v21 + v77;
      if (v75)
      {
        uint64_t v79 = (void *)(v21 + v77);
        uint64_t v80 = v250;
        do
        {
          unint64_t v81 = (v70 + 7) & 0xFFFFFFFFFFFFFFF8LL;
          unint64_t v82 = v81 + 8;
          if (v81 + 8 <= v37)
          {
            unint64_t v83 = bswap64(*(void *)(v21 + v81));
            v257[0] = v82;
            unint64_t v70 = v82;
          }

          else
          {
            unint64_t v83 = 0LL;
          }

          *v79++ = *(void *)(v80 + 8 * v83);
          --v76;
        }

        while (v76);
      }

      [*(id *)(v25 + 88) _setValues:v78 retain:1];
    }

    unint64_t v58 = v70;
  }

  unint64_t v84 = (v58 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v85 = v84 + 4;
  if (v84 + 4 <= v37)
  {
    unsigned int v86 = bswap32(*(_DWORD *)(v21 + v84));
    v257[0] = v85;
    unint64_t v58 = v85;
  }

  else
  {
    unsigned int v86 = 0;
  }

  int v87 = *(void **)(v61 + 8LL * v86);
  *(void *)(v25 + 96) = v87;
  if ([v87 count])
  {
    if (!v18) {
      return 0LL;
    }
    unint64_t v31 = (void *)MEMORY[0x189607870];
    uint64_t v32 = *MEMORY[0x189607460];
    unint64_t v33 = (void *)MEMORY[0x189603F68];
    unint64_t v34 = @"Cant' read entity: Properties dictionary has content";
    goto LABEL_7;
  }

  uint64_t v88 = (void *)[*(id *)(v25 + 96) mapping];
  *(void *)(v25 + 104) = v88;
  uint64_t v89 = [v88 length];
  unint64_t v249 = (v58 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  if (v89)
  {
    uint64_t v90 = v89;
    uint64_t v91 = v89;
    do
    {
      unint64_t v92 = (v58 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      unint64_t v93 = v92 + 8;
      if (v92 + 8 <= v37)
      {
        uint64_t v94 = *(void *)(v21 + v92);
        v257[0] = v93;
        unint64_t v58 = v93;
        if (v94)
        {
          if (!v18) {
            return 0LL;
          }
          unint64_t v31 = (void *)MEMORY[0x189607870];
          uint64_t v32 = *MEMORY[0x189607460];
          unint64_t v33 = (void *)MEMORY[0x189603F68];
          unint64_t v34 = @"Cant' read entity: Properties buffer has content";
          goto LABEL_7;
        }
      }

      --v91;
    }

    while (v91);
    unint64_t v95 = v249;
    do
    {
      unint64_t v96 = (v257[0] + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v97 = v96 + 4;
      if (v96 + 4 <= v37)
      {
        int v98 = *(_DWORD *)(v21 + v96);
        v257[0] = v96 + 4;
        if (v98)
        {
          PropertyProxyFromBytes = _newReadPropertyProxyFromBytes(v253, v21, v257, v37, v25, v23);
          *(void *)(v21 + v95) = PropertyProxyFromBytes;
          if ([PropertyProxyFromBytes entity] != v25)
          {
            if (!v18) {
              return 0LL;
            }
            unint64_t v31 = (void *)MEMORY[0x189607870];
            uint64_t v32 = *MEMORY[0x189607460];
            unint64_t v33 = (void *)MEMORY[0x189603F68];
            unint64_t v34 = @"Cant' read entity: Property entity does not match entity being decoded (2)";
            goto LABEL_7;
          }

          goto LABEL_81;
        }

        unint64_t v96 = (v96 + 7) & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v97 = v96 + 4;
      }

      if (v97 <= v37)
      {
        unsigned int v100 = bswap32(*(_DWORD *)(v21 + v96));
        v257[0] = v97;
      }

      else
      {
        unsigned int v100 = 0;
      }

      uint64_t v101 = *(void **)(v23 + 8LL * v100);
      *(void *)(v21 + v95) = v101;
      if ([v101 entity] != v25)
      {
        if (!v18) {
          return 0LL;
        }
        unint64_t v31 = (void *)MEMORY[0x189607870];
        uint64_t v32 = *MEMORY[0x189607460];
        unint64_t v33 = (void *)MEMORY[0x189603F68];
        unint64_t v34 = @"Cant' read entity: Property entity does not match entity being decoded (1)";
        goto LABEL_7;
      }

LABEL_81:
      v95 += 8LL;
      --v90;
    }

    while (v90);
  }

  [*(id *)(v25 + 96) _setValues:v21 + v249 retain:0];
  unint64_t v102 = v257[0];
  if (a17 == (unint64_t **)1)
  {
    unint64_t v103 = (unint64_t *)malloc(0x120uLL);
    uint64_t v104 = 0LL;
    __int16 v105 = v103 + 1;
    do
    {
      switch((int)v104)
      {
        case 8:
          v103[16] = 0LL;
          v103[17] = 0LL;
          break;
        case 9:
          *((_OWORD *)v103 + 9) = *((_OWORD *)v103 + 7);
          break;
        case 12:
          v103[24] = 0LL;
          v103[25] = 0LL;
          break;
        case 13:
          *((_OWORD *)v103 + 13) = *((_OWORD *)v103 + 11);
          break;
        default:
          unint64_t v106 = (v102 + 7) & 0xFFFFFFFFFFFFFFF8LL;
          unint64_t v107 = v106 + 8;
          if (v106 + 8 <= v37)
          {
            unint64_t v108 = bswap64(*(void *)(v21 + v106));
            v257[0] = v106 + 8;
            unint64_t v106 = (v106 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            unint64_t v109 = v106 + 8;
            unint64_t v102 = v107;
          }

          else
          {
            unint64_t v108 = 0LL;
            unint64_t v109 = v106 + 8;
          }

          *(v105 - 1) = v108;
          if (v109 <= v37)
          {
            unint64_t v110 = bswap64(*(void *)(v21 + v106));
            v257[0] = v109;
            unint64_t v102 = v109;
          }

          else
          {
            unint64_t v110 = 0LL;
          }

          unint64_t *v105 = v110;
          break;
      }

      ++v104;
      v105 += 2;
    }

    while (v104 != 17);
  }

  else
  {
    uint64_t v111 = 0LL;
    unint64_t v103 = (unint64_t *)(v21 + ((v257[0] + 7) & 0xFFFFFFFFFFFFFFF8LL));
    do
    {
      unint64_t v112 = (v102 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      unint64_t v113 = v112 + 8;
      if (v112 + 8 <= v37)
      {
        unint64_t v114 = bswap64(*(void *)(v21 + v112));
        v257[0] = v112 + 8;
        unint64_t v112 = (v112 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v115 = v112 + 8;
        unint64_t v102 = v113;
      }

      else
      {
        unint64_t v114 = 0LL;
        unint64_t v115 = v112 + 8;
      }

      v103[v111] = v114;
      if (v115 <= v37)
      {
        unint64_t v116 = bswap64(*(void *)(v21 + v112));
        v257[0] = v115;
        unint64_t v102 = v115;
      }

      else
      {
        unint64_t v116 = 0LL;
      }

      v103[v111 + 1] = v116;
      v111 += 2LL;
    }

    while (v111 != 36);
  }

  int v117 = a11;
  int v118 = a9;
  *(void *)(v25 + 112) = v103;
  unint64_t v119 = (v102 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v120 = v119 + 4;
  if (v119 + 4 <= v37)
  {
    unsigned int v121 = bswap32(*(_DWORD *)(v21 + v119));
    v257[0] = v120;
    unint64_t v102 = v120;
  }

  else
  {
    unsigned int v121 = 0;
  }

  uint64_t v243 = a10;
  *(_DWORD *)(v25 + 120) = v121;
  int v122 = 8;
  do
  {
    if (((v102 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8 <= v37)
    {
      v257[0] = ((v102 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 8;
      unint64_t v102 = v257[0];
    }

    --v122;
  }

  while (v122);
  uint64_t v123 = v102 + v21 - 64;
  *(void *)(v25 + 12_Block_object_dispose(va, 8) = v123;
  unint64_t v124 = (v102 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v125 = v124 + 8;
  if (v124 + 8 <= v37)
  {
    unint64_t v126 = (unint64_t)*(unsigned int *)(v21 + v124 + 4) << 32;
    v257[0] = v125;
    unint64_t v102 = v125;
    if (v126)
    {
      char v127 = v252[bswap64(v126)];
      v252 = a17;
      unint64_t v103 = v127;
      int v118 = a9;
      int v117 = a11;
      uint64_t v123 = *(void *)(v25 + 128);
      *(void *)uint64_t v123 = v103;
      unint64_t v102 = v257[0];
    }
  }

  if ((unint64_t)a17 >= 0xB)
  {
    unint64_t v128 = (v102 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v129 = v128 + 8;
    if (v128 + 8 <= v37)
    {
      unint64_t v130 = (unint64_t)*(unsigned int *)(v21 + v128 + 4) << 32;
      v257[0] = v129;
      unint64_t v102 = v129;
      if (v130)
      {
        v238 = v118;
        v239 = v117;
        v252 = *(unint64_t ***)(v251 + 8 * bswap64(v130));
        uint64_t v256 = 0LL;
        unint64_t v249 = (unint64_t)&OBJC_CLASS____PFRoutines;
        uint64_t v131 = (void *)MEMORY[0x189604010];
        uint64_t v132 = objc_opt_class();
        uint64_t v133 = objc_msgSend(v131, "setWithObjects:", v132, objc_opt_class(), 0);
        uint64_t v134 = +[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v133,  (uint64_t)v252,  (uint64_t)&v256);
        if (!v134)
        {
          uint64_t v236 = [(id)v25 name];
          _NSCoreDataLog( 1LL,  (uint64_t)@"Can't decode coreSpotlightDisplayNameExpression for entity %",  v223,  v224,  v225,  v226,  v227,  v228,  v236);
          goto LABEL_211;
        }

        char v135 = (void *)v134;
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          uint64_t v237 = objc_opt_class();
          _NSCoreDataLog( 1LL,  (uint64_t)@"Can't decode coreSpotlightDisplayNameExpression - wrong class decoded - %@",  v229,  v230,  v231,  v232,  v233,  v234,  v237);
          goto LABEL_211;
        }

        unint64_t v103 = v135;
        uint64_t v123 = *(void *)(v25 + 128);
        *(void *)(v123 + 32) = v103;
        unint64_t v102 = v257[0];
        uint64_t v61 = v254;
        int v118 = v238;
        int v117 = v239;
      }
    }
  }

  unint64_t v136 = (v102 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v137 = v136 + 8;
  if (v136 + 8 > v37)
  {
    unint64_t v138 = 0LL;
    unint64_t v139 = 0LL;
    uint64_t v140 = 0LL;
    goto LABEL_179;
  }

  unint64_t v139 = (unint64_t)*(unsigned int *)(v21 + v136 + 4) << 32;
  v257[0] = v137;
  if (!v139)
  {
    unint64_t v138 = 0LL;
    uint64_t v140 = 0LL;
    unint64_t v102 = v137;
LABEL_179:
    *(void *)(v123 + 40) = v139;
    *(_DWORD *)(v123 + 4_Block_object_dispose(va, 8) = 0;
    *int v118 = v138;
    *int v117 = v140;
    unint64_t v176 = (v102 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v177 = v176 + 8;
    if (v176 + 8 <= v37)
    {
      unint64_t v178 = (unint64_t)*(unsigned int *)(v21 + v176 + 4) << 32;
      v257[0] = v177;
      unint64_t v102 = v177;
      if (v178)
      {
        v252 = &v238;
        unint64_t v179 = bswap64(v178);
        MEMORY[0x1895F8858](v103);
        v181 = (void **)((char *)&v238 - ((v180 + 15) & 0xFFFFFFFF0LL));
        uint64_t v182 = 0LL;
        uint64_t v183 = v255;
        uint64_t v184 = (uint64_t)v253;
        do
          v181[v182++] = (void *)_newReadPFEncodedArrayFromData(v184, v21, v257, v37, v183, 0LL);
        while (v179 != v182);
        uint64_t v185 = [objc_alloc(MEMORY[0x189603F18]) initWithObjects:v181 count:v179];
        do
        {
          int v186 = *v181++;

          --v179;
        }

        while (v179);
        *(void *)(*(void *)(v25 + 128) + 24LL) = v185;
        unint64_t v102 = v257[0];
        uint64_t v61 = v254;
      }
    }

    unint64_t v187 = (v102 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v188 = v187 + 4;
    if (v187 + 4 > v37) {
      goto LABEL_190;
    }
    unsigned int v189 = *(_DWORD *)(v21 + v187);
    v257[0] = v188;
    unint64_t v102 = v188;
    if (!v189) {
      goto LABEL_190;
    }
    uint64_t v190 = *(void *)(v251 + 8LL * bswap32(v189));
    uint64_t v256 = 0LL;
    uint64_t v191 = +[_PFRoutines plistClassesForSecureCoding]();
    uint64_t v192 = (void *)+[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v191,  v190,  (uint64_t)&v256);
    if (v192)
    {
      *(void *)(v25 + 136) = v192;
      unint64_t v102 = v257[0];
LABEL_190:
      unint64_t v193 = (v102 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v194 = v193 + 4;
      if (v193 + 4 <= v37)
      {
        int v195 = *(_DWORD *)(v21 + v193);
        v257[0] = v194;
        unint64_t v102 = v194;
        if (v195)
        {
          PFEncodedArrayFromData = (void *)_newReadPFEncodedArrayFromData((uint64_t)v253, v21, v257, v37, v250, 0LL);
          v197 = (const void **)[PFEncodedArrayFromData _values];
          *(void *)(v25 + 144) = CFSetCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  v197,  [PFEncodedArrayFromData count],  0);

          unint64_t v102 = v257[0];
        }
      }

      unint64_t v198 = (v102 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v199 = v198 + 4;
      if (v198 + 4 <= v37)
      {
        uint64_t v200 = bswap32(*(_DWORD *)(v21 + v198));
        v257[0] = v199;
      }

      else
      {
        uint64_t v200 = 0LL;
      }

      *(void *)(v25 + 160) = v200;
      v201 = *(void **)(v25 + 104);
      uint64_t v202 = objc_msgSend(v201, "keys", v238, v239);
      size_t v203 = [v201 length];
      *(void *)(v25 + 152) = PF_CALLOC_SCANNED_BYTES(0x50uLL);
      *(void *)(*(void *)(v25 + 152) + 48) = [objc_alloc(MEMORY[0x189604010]) initWithObjects:v202 count:v203];
      uint64_t v204 = [*(id *)(v25 + 96) values];
      uint64_t v205 = v204;
      unint64_t v206 = (v257[0] + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v207 = v206 + 4;
      if (v206 + 4 <= v37)
      {
        uint64_t v208 = bswap32(*(_DWORD *)(v21 + v206));
        v257[0] = v207;
      }

      else
      {
        uint64_t v208 = 0LL;
      }

      v209 = *(void **)(v61 + 8 * v208);
      [v209 setValues:v204 + 8 * *(void *)(*(void *)(v25 + 112) + 16)];
      *(void *)(*(void *)(v25 + 152) + 56LL) = v209;
      unint64_t v210 = (v257[0] + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v211 = v210 + 4;
      if (v210 + 4 <= v37)
      {
        uint64_t v212 = bswap32(*(_DWORD *)(v21 + v210));
        v257[0] = v211;
      }

      else
      {
        uint64_t v212 = 0LL;
      }

      v213 = *(void **)(v61 + 8 * v212);
      [v213 setValues:v205 + 8 * *(void *)(*(void *)(v25 + 112) + 32)];
      *(void *)(*(void *)(v25 + 152) + 64LL) = v213;
      *(void *)(*(void *)(v25 + 152) + 72LL) = PF_CALLOC_SCANNED_BYTES(v203);
      unint64_t v214 = (v257[0] + 3) & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v215 = v214 + 4;
      if (v214 + 4 <= v37)
      {
        int v216 = *(_DWORD *)(v21 + v214);
        v257[0] = v215;
        if (v216 == -335614502)
        {
          -[NSEntityDescription _commonCachesAndOptimizedState]((id)v25);
          void *v26 = v257[0];
          return 1LL;
        }
      }

      unint64_t v31 = (void *)MEMORY[0x189607870];
      uint64_t v32 = *MEMORY[0x189607460];
      unint64_t v33 = (void *)MEMORY[0x189603F68];
      unint64_t v34 = @"Can't read entity into shell: Missing entity back-end delimiter";
LABEL_7:
      uint64_t v35 = objc_msgSend( v31,  "errorWithDomain:code:userInfo:",  v32,  134060,  objc_msgSend(v33, "dictionaryWithObject:forKey:", v34, @"Root cause", v238, v239));
      uint64_t result = 0LL;
      *unint64_t v18 = v35;
      return result;
    }

    uint64_t v235 = [(id)v25 name];
    _NSCoreDataLog( 1LL,  (uint64_t)@"Unable to decode userInfo for entity '%@' : %@",  v217,  v218,  v219,  v220,  v221,  v222,  v235);
LABEL_211:
    if (v18) {
      *unint64_t v18 = v256;
    }
    return 0LL;
  }

  unint64_t v141 = bswap64(v139);
  if (*v118 < v141)
  {
    if (!v18) {
      return 0LL;
    }
    unint64_t v31 = (void *)MEMORY[0x189607870];
    uint64_t v32 = *MEMORY[0x189607460];
    unint64_t v33 = (void *)MEMORY[0x189603F68];
    unint64_t v34 = @"Cant' read entity: Mismatched number of fetch indexes";
    goto LABEL_7;
  }

  v238 = v118;
  v239 = v117;
  unint64_t v240 = *v117;
  unint64_t v244 = v141;
  id v245 = (id)[objc_alloc(MEMORY[0x189603FA8]) initWithCapacity:v141];
  unint64_t v249 = 0LL;
  uint64_t v242 = 0LL;
  while (1)
  {
    unint64_t v142 = (v257[0] + 7) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v143 = v142 + 8;
    if (v142 + 8 <= v37)
    {
      unint64_t v144 = *(void *)(v21 + v142);
      v257[0] = v142 + 8;
      uint64_t v247 = v144 ? *(void *)(v255 + 8 * bswap64(v144)) : 0LL;
    }

    else
    {
      uint64_t v247 = 0LL;
      unint64_t v143 = v257[0];
    }

    uint64_t v145 = *(void **)(v22 + 8 * v249);
    unint64_t v146 = (v143 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    if (v146 + 8 <= v37)
    {
      uint64_t v147 = *(void *)(v21 + v146);
      v257[0] = v146 + 8;
      if (v147)
      {
        unint64_t v148 = (v146 + 15) & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v149 = v148 + 8;
        if (v148 + 8 <= v37)
        {
          unint64_t v150 = bswap64(*(void *)(v21 + v148));
          v257[0] = v149;
        }

        else
        {
          unint64_t v150 = 0LL;
        }

        v252 = *(unint64_t ***)(v251 + 8 * v150);
        uint64_t v151 = (void *)MEMORY[0x189604010];
        uint64_t v152 = objc_opt_class();
        uint64_t v153 = objc_msgSend(v151, "setWithObjects:", v152, objc_opt_class(), 0);
        uint64_t v246 = +[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v153,  (uint64_t)v252,  0LL);
        unint64_t v143 = v257[0];
      }

      else
      {
        uint64_t v246 = 0LL;
        unint64_t v143 = v146 + 8;
      }
    }

    else
    {
      uint64_t v246 = 0LL;
    }

    unint64_t v154 = (v143 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    unint64_t v155 = v154 + 8;
    id v248 = v145;
    if (v154 + 8 <= v37)
    {
      unint64_t v156 = *(void *)(v21 + v154);
      v257[0] = v155;
      if (v156) {
        break;
      }
    }

    uint64_t v159 = (unint64_t **)objc_alloc_init(MEMORY[0x189603FA8]);
LABEL_177:
    uint64_t v175 = v159;
    objc_msgSend(v248, "initWithName:predicate:elements:entity:", v247, v246, v159, v25, v238, v239);

    [v245 addObject:v248];
    if (++v249 == v244)
    {
      uint64_t v123 = *(void *)(v25 + 128);
      unint64_t v138 = v244;
      unint64_t v139 = (unint64_t)v245;
      unint64_t v102 = v257[0];
      int v118 = v238;
      int v117 = v239;
      uint64_t v140 = v242;
      uint64_t v61 = v254;
      goto LABEL_179;
    }
  }

  uint64_t v157 = bswap64(v156);
  if (v240 >= v157)
  {
    int v158 = (unint64_t **)[objc_alloc(MEMORY[0x189603FA8]) initWithCapacity:v157];
    uint64_t v159 = v158;
    if (v157 >= 1)
    {
      v252 = v158;
      uint64_t v241 = v157 + v242;
      uint64_t v160 = (void **)(v243 + 8 * v242);
      do
      {
        unint64_t v161 = (v257[0] + 7) & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v162 = v161 + 8;
        if (v161 + 8 <= v37)
        {
          unint64_t v164 = *(void *)(v21 + v161);
          v257[0] = v161 + 8;
          if (v164) {
            uint64_t v163 = *(void **)(v255 + 8 * bswap64(v164));
          }
          else {
            uint64_t v163 = 0LL;
          }
        }

        else
        {
          uint64_t v163 = 0LL;
          unint64_t v162 = v257[0];
        }

        unint64_t v165 = (v162 + 7) & 0xFFFFFFFFFFFFFFF8LL;
        unint64_t v166 = v165 + 8;
        if (v165 + 8 <= v37)
        {
          uint64_t v167 = bswap64(*(void *)(v21 + v165));
          v257[0] = v165 + 8;
          unint64_t v165 = (v165 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          unint64_t v166 = v165 + 8;
        }

        else
        {
          uint64_t v167 = 0LL;
        }

        if (v166 <= v37)
        {
          unint64_t v168 = bswap64(*(void *)(v21 + v165));
          v257[0] = v166;
          unint64_t v165 = (v166 + 7) & 0xFFFFFFFFFFFFFFF8LL;
          unint64_t v166 = v165 + 8;
        }

        else
        {
          unint64_t v168 = 0LL;
        }

        if (v166 <= v37 && (uint64_t v169 = *(void *)(v21 + v165), v257[0] = v166, v169))
        {
          unint64_t v170 = (v166 + 7) & 0xFFFFFFFFFFFFFFF8LL;
          unint64_t v171 = v170 + 8;
          if (v170 + 8 <= v37)
          {
            unint64_t v172 = bswap64(*(void *)(v21 + v170));
            v257[0] = v171;
          }

          else
          {
            unint64_t v172 = 0LL;
          }

          uint64_t v173 = *(void **)(v23 + 8 * v172);
        }

        else
        {
          uint64_t v173 = 0LL;
        }

        uint64_t v174 = *v160++;
        -[NSFetchIndexElementDescription initWithPropertyName:property:collationType:ascending:]( v174,  v163,  v173,  v167,  v168 != 0);
        [v252 addObject:v174];

        --v157;
      }

      while (v157);
      uint64_t v242 = v241;
      uint64_t v159 = v252;
    }

    goto LABEL_177;
  }

  if (v18) {
    *unint64_t v18 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  *MEMORY[0x189607460],  134060,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  @"Cant' read entity: Mismatched number of fetch index elements",  @"Root cause"));
  }

  return 0LL;
}

            unint64_t v55 = v54 == (void *)v52;
            uint64_t v10 = v97;
            if (v55) {
              goto LABEL_85;
            }
          }
        }

        else
        {
          uint64_t v10 = v97;
          if (![0 count])
          {
            unint64_t v54 = 0LL;
            goto LABEL_81;
          }
        }

        unsigned int v56 = [v14[9] columnName];
        if (v27) {
          unint64_t v57 = (void *)v27[9];
        }
        else {
          unint64_t v57 = 0LL;
        }
        -[NSSQLConstantValueIntermediate appendFormat:]( v17,  "appendFormat:",  @", %@ = %@",  v56,  [v57 columnName]);
        uint64_t v5 = v95;
        goto LABEL_85;
      }

      unint64_t v29 = (void *)[v10 constantValue];
      if (v11 == 4)
      {
        objc_opt_class();
        unint64_t v97 = v10;
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          unsigned int v75 = [v29 objectID];
        }

        else
        {
          objc_opt_class();
          unsigned int v75 = (uint64_t)v29;
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            unsigned int v75 = 0LL;
          }
        }

        unsigned int v86 = *MEMORY[0x189603A60];
        if (!v75 && v29)
        {
          [a3 setObject:objc_msgSend( MEMORY[0x189603F70], "exceptionWithName:reason:userInfo:", v86, objc_msgSend( NSString, "stringWithFormat:", @"Invalid new constant value %@ for %@ (not a managed object)", v10, v9), 0), @"NSUnderlyingException" forKey];

          return 0LL;
        }

        unint64_t v83 = [MEMORY[0x189603F70] exceptionWithName:v86, objc_msgSend( NSString, "stringWithFormat:", @"Can't generate new column values for %@ - incompatible destination: %@", objc_msgSend(v14, "name"), v75), 0 reason userInfo];
        goto LABEL_132;
      }

      unsigned int v30 = v98;
      unint64_t v31 = v14;
      uint64_t v32 = (uint64_t)v29;
      self = v98;
LABEL_95:
      BOOL v17 = -[NSSQLUpdateColumnsIntermediate _generateSQLForAttributeUpdate:value:inContext:]( (uint64_t)v30,  v31,  v32,  a3);
      if (!v17) {
        goto LABEL_133;
      }
LABEL_96:
      ++v7;
      [v5 appendString:v17];

      ++v8;
    }

    while (v8 != v100);
    unint64_t v58 = -[NSDictionary countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v102,  v107,  16LL);
    uint64_t v7 = v92;
    unsigned int v100 = v58;
  }

  while (v58);
LABEL_103:
  objc_msgSend(v5, "appendString:", @", Z_OPT = (Z_OPT + 1) ");
  return v5;
}

            if ([v197 count])
            {
              CFNumberRef v50 = (void *)[v203 objectID];
              unint64_t v51 = objc_msgSend((id)objc_msgSend(v192, "objectAtIndex:", 0), "unsignedIntegerValue");
              unint64_t v52 = v184;
              if (v179) {
                unint64_t v52 = _sqlEntityForEntityID( v171,  objc_msgSend((id)objc_msgSend(v192, "objectAtIndex:", 1), "unsignedIntegerValue"));
              }
              if (v205)
              {
                unint64_t v193 = -[NSSQLCore newObjectIDForEntity:pk:](v205->super._sqlCore, "newObjectIDForEntity:pk:", v52, v51);
                unsigned int v53 = [v50 isEqual:v193];
              }

              else
              {
                unint64_t v193 = 0LL;
                unsigned int v53 = [v50 isEqual:0];
              }

              if ((v53 & 1) == 0)
              {
                uint64_t v182 = faultRowWithObjectID((uint64_t)v193, v205);
                if (v182)
                {
                  unint64_t v54 = (void *)[v164 objectWithID:v193];
                  if ([v203 isInserted])
                  {
                    unint64_t v55 = 0LL;
                  }

                  else
                  {
                    unsigned int v56 = faultRowWithObjectID((uint64_t)v50, v205);
                    unint64_t v57 = v56;
                    if (v56)
                    {
                      unint64_t v55 = _newObjectGraphStyleForSQLRow(v56, v203);
                    }

                    else
                    {
                      unint64_t v55 = 0LL;
                      v201 = 0LL;
                    }
                  }

                  if (v201)
                  {
                    unint64_t v58 = _newObjectGraphStyleForSQLRow(v182, v54);
                    uint64_t v208 = 0u;
                    v209 = 0u;
                    unint64_t v206 = 0u;
                    unint64_t v207 = 0u;
                    unsigned int v59 = [v197 countByEnumeratingWithState:&v206 objects:&v221 count:16];
                    if (v59)
                    {
                      unint64_t v60 = *(void *)v207;
                      do
                      {
                        for (uint64_t j = 0LL; j != v59; ++j)
                        {
                          if (*(void *)v207 != v60) {
                            objc_enumerationMutation(v197);
                          }
                          int v62 = *(void *)(*((void *)&v206 + 1) + 8 * j);
                          unint64_t v63 = objc_alloc(&OBJC_CLASS___NSConstraintConflict);
                          uint64_t v220 = v62;
                          unint64_t v64 = [MEMORY[0x189603F18] arrayWithObjects:&v220 count:1];
                          uint64_t v219 = v203;
                          uint64_t v65 = [MEMORY[0x189603F18] arrayWithObjects:&v219 count:1];
                          unsigned int v66 = (uint64_t)v55;
                          if (!v55) {
                            unsigned int v66 = [MEMORY[0x189603FE8] null];
                          }
                          uint64_t v218 = v66;
                          unint64_t v67 = -[NSConstraintConflict initWithConstraint:databaseObject:databaseSnapshot:conflictingObjects:conflictingSnapshots:]( v63,  "initWithConstraint:databaseObject:databaseSnapshot:conflictingObjects:conflictingSnapshots:",  v64,  v54,  v58,  v65,  [MEMORY[0x189603F18] arrayWithObjects:&v218 count:1]);
                          [v201 addObject:v67];
                        }

                        unsigned int v59 = [v197 countByEnumeratingWithState:&v206 objects:&v221 count:16];
                      }

                      while (v59);
                    }
                  }
                }

                else
                {
                  v201 = 0LL;
                }
              }
            }

            objc_autoreleasePoolPop(context);
            if (!v201) {
              goto LABEL_119;
            }
            uint64_t v23 = v188 + 1;
          }

          while (v188 + 1 != v186);
          unint64_t v68 = [v177 countByEnumeratingWithState:&v229 objects:&v225 count:16];
          int v186 = v68;
          if (!v68)
          {
LABEL_116:
            unint64_t v20 = v149;
            uint64_t v21 = v151 + 1;
            if (v151 + 1 == v156)
            {
              unint64_t v156 = [v168 countByEnumeratingWithState:&v233 objects:v243 count:16];
              unint64_t v20 = v149;
              if (!v156) {
                goto LABEL_120;
              }
              goto LABEL_39;
            }

            goto LABEL_40;
          }
        }
      }

      if (v201) {
        goto LABEL_116;
      }
LABEL_119:
      v201 = 0LL;
LABEL_120:
      [v162 drain];
LABEL_121:
      uint64_t v2 = (uint64_t)v205;
      if (!v201)
      {
        unint64_t v70 = 0LL;
        goto LABEL_132;
      }

      uint64_t v173 = (char *)v173 + 1;
      if (v173 == (id)v160)
      {
        unsigned int v69 = [obj countByEnumeratingWithState:&v210 objects:v245 count:16];
        uint64_t v160 = v69;
        uint64_t v2 = (uint64_t)v205;
        if (!v69) {
          goto LABEL_131;
        }
        goto LABEL_7;
      }
    }

    [v10 addObject:0];
    if (!v179) {
      goto LABEL_22;
    }
    unint64_t v12 = 0LL;
    goto LABEL_21;
  }

LABEL_49:
  if (self
    && ((extraIvars = self->_extraIvars) != 0LL && (var3 = extraIvars->var3) != 0LL
     || (var3 = (id)NSArray_EmptyArray) != 0LL)
    && [var3 count])
  {
    _writeInt64IntoData(a3, [var3 count]);
    unsigned int v66 = 0u;
    unint64_t v67 = 0u;
    unint64_t v64 = 0u;
    uint64_t v65 = 0u;
    CFNumberRef v50 = [var3 countByEnumeratingWithState:&v64 objects:v68 count:16];
    unint64_t v52 = v60;
    unint64_t v51 = v61;
    unsigned int v53 = v59;
    if (v50)
    {
      unint64_t v54 = v50;
      unint64_t v55 = *(void *)v65;
      do
      {
        for (uint64_t j = 0LL; j != v54; ++j)
        {
          if (*(void *)v65 != v55) {
            objc_enumerationMutation(var3);
          }
          _writePFEncodedArrayShapeIntoData(a3, *(void **)(*((void *)&v64 + 1) + 8 * j), a5, 0LL);
        }

        unint64_t v54 = [var3 countByEnumeratingWithState:&v64 objects:v68 count:16];
      }

      while (v54);
    }
  }

  else
  {
    _writeInt64IntoData(a3, 0LL);
    unint64_t v52 = v60;
    unint64_t v51 = v61;
    unsigned int v53 = v59;
  }

  if (self->_userInfo) {
    unint64_t v57 = objc_msgSend((id)objc_msgSend(v62, "objectForKey:"), "unsignedIntegerValue");
  }
  else {
    unint64_t v57 = 0;
  }
  _writeInt32IntoData(a3, v57);
  unint64_t v58 = [self->_flattenedSubentities count];
  _writeInt32IntoData(a3, v58);
  if (v58) {
    _writePFEncodedArrayShapeIntoData(a3, self->_flattenedSubentities, v53, 0LL);
  }
  _writeInt32IntoData(a3, self->_modelsReferenceIDForEntity);
  _writeInt32IntoData( a3,  objc_msgSend( (id)objc_msgSend( v51,  "objectForKey:",  -[NSDictionary mapping](-[NSEntityDescription attributesByName](self, "attributesByName"), "mapping")),  "unsignedIntegerValue"));
  _writeInt32IntoData( a3,  objc_msgSend( (id)objc_msgSend( v51,  "objectForKey:",  -[NSDictionary mapping](-[NSEntityDescription relationshipsByName](self, "relationshipsByName"), "mapping")),  "unsignedIntegerValue"));
  _writeInt32IntoData(a3, 0xDAEDFEEB);
  unint64_t v63 = bswap32([a3 length] - v52);
  objc_msgSend(a3, "replaceBytesInRange:withBytes:", v52, 4, &v63);
}

            unint64_t v31 = strsep(&v264, ",");
            if (!v31) {
              goto LABEL_62;
            }
          }
        }

        v253 = 0;
        LODWORD(v257) = 0;
LABEL_62:
        unint64_t v20 = v259;
        unint64_t v55 = v253;
      }

      else if (v21 == (objc_class *)objc_opt_class() {
             || ((unint64_t v52 = *(void *)(v23 + 16), v54 = v19 >= v52, v53 = v19 - v52, v54)
      }
               ? (unint64_t v54 = v53 >= *(void *)(v23 + 24))
               : (unint64_t v54 = 1),
                 v54))
      {
        LODWORD(v257) = 0;
        unint64_t v55 = 0;
      }

      else
      {
        unint64_t v64 = v13 + 2;
        uint64_t v65 = (char *)calloc(1uLL, v64);
        int *v65 = 95;
        strlcat(v65, v10, v64);
        if (!class_getInstanceVariable(v21, v10) && !class_getInstanceVariable(v21, v65))
        {
          unsigned int v66 = [v8 name];
          uint64_t v250 = sel_getName(v254);
          uint64_t v251 = class_getName(v21);
          unint64_t v20 = v259;
          unint64_t v249 = v66;
          _NSCoreDataLog( 2LL,  (uint64_t)@"dynamic accessors failed to find @property implementation for '%s' for entity '%@' while resolving selector '%s' on class '%s'.  Did you remember to declare it @dynamic or @synthesized in the @implementation ?",  v67,  v68,  v69,  v70,  v71,  v72,  (uint64_t)v10);
        }

        free(v65);
        LODWORD(v257) = 0;
        unint64_t v55 = 0;
      }

      if ((*(_BYTE *)(v7 + 96) & 1) != 0)
      {
        unint64_t v57 = 0LL;
        unint64_t v58 = 0LL;
        int v62 = 0LL;
        uint64_t v61 = 0;
        LODWORD(v59) = 0;
      }

      else
      {
        unint64_t v57 = 0LL;
        unint64_t v58 = 0LL;
        LODWORD(v59) = 0;
        unint64_t v60 = *(void *)(_kvcPropertysPrimitiveGetters(v8) + 8 * v19) == 0LL;
        uint64_t v61 = v60;
        if (v60) {
          int v62 = qword_18C4AB9F0;
        }
        else {
          int v62 = 0LL;
        }
      }

      goto LABEL_277;
    }

    LOBYTE(v6) = 0;
  }

  return v6;
}

      unint64_t v40 = v19;
      goto LABEL_50;
    }

    uint64_t v8 = objc_msgSend((id)objc_msgSend(a2, "metadata"), "objectForKey:", @"NSStoreModelVersionChecksumKey");
    if (!v8) {
      goto LABEL_61;
    }
    unint64_t v9 = v8;
    uint64_t v10 = [v7 _findCurrentMigrationStageFromModelChecksum:v8];
    if ((objc_msgSend( v7,  "_shouldAttemptStagedMigrationWithStoreModelVersionChecksum:coordinatorModelVersionChecksum:error:",  v9,  objc_msgSend((id)objc_msgSend((id)v3, "managedObjectModel"), "versionChecksum"),  &v59) & 1) == 0)
    {
      unint64_t v19 = v59;
      goto LABEL_49;
    }

    if (v10 == 0x7FFFFFFFFFFFFFFFLL)
    {
LABEL_61:
      if (objc_msgSend((id)objc_msgSend(a2, "storeType"), "isEqualToString:", @"SQLite"))
      {
        unint64_t v11 = +[NSPersistentStore cachedModelForPersistentStoreWithURL:options:error:]( NSPersistentStore,  "cachedModelForPersistentStoreWithURL:options:error:",  [a2 storeURL],  objc_msgSend(a2, "options"),  &v59);
        [v11 _setIsEditable:0];
        if (v11)
        {
          uint64_t v10 = objc_msgSend(v7, "_findCurrentMigrationStageFromModelChecksum:", objc_msgSend(v11, "versionChecksum"));
          if (v10 == 0x7FFFFFFFFFFFFFFFLL)
          {
            unint64_t v12 = objc_alloc(MEMORY[0x189607870]);
            BOOL v13 = *MEMORY[0x189607460];
            unint64_t v70 = *MEMORY[0x1896075E0];
            int v71 = @"Cannot use staged migration with an unknown model version.";
            unint64_t v14 = [MEMORY[0x189603F68] dictionaryWithObjects:&v71 forKeys:&v70 count:1];
            uint64_t v15 = 134504LL;
LABEL_14:
            unint64_t v16 = v12;
            BOOL v17 = v13;
LABEL_15:
            unsigned int v59 = (id)[v16 initWithDomain:v17 code:v15 userInfo:v14];
            goto LABEL_50;
          }

          goto LABEL_20;
        }

        unint64_t v19 = v59;
        if (v59) {
          goto LABEL_49;
        }
        unint64_t v20 = objc_alloc(MEMORY[0x189607870]);
        uint64_t v21 = *MEMORY[0x189607460];
        unint64_t v68 = *MEMORY[0x1896075E0];
        unsigned int v69 = @"The store must be opened one time without Staged Migration to update store metadata to be able to use Staged Migration.";
        uint64_t v22 = (void *)MEMORY[0x189603F68];
        uint64_t v23 = &v69;
        __int16 v24 = &v68;
      }

      else
      {
        unint64_t v20 = objc_alloc(MEMORY[0x189607870]);
        uint64_t v21 = *MEMORY[0x189607460];
        unsigned int v66 = *MEMORY[0x1896075E0];
        unint64_t v67 = @"The store must be opened one time without Staged Migration to update store metadata to be able to use Staged Migration.";
        uint64_t v22 = (void *)MEMORY[0x189603F68];
        uint64_t v23 = &v67;
        __int16 v24 = &v66;
      }

      unint64_t v14 = [v22 dictionaryWithObjects:v23 forKeys:v24 count:1];
      unint64_t v16 = v20;
      BOOL v17 = v21;
      uint64_t v15 = 134505LL;
      goto LABEL_15;
    }

  if (v30)
  {
    [v30 appendString:@".@"];
    CFNumberType v42 = v30;
  }

  else
  {
    CFNumberType v42 = (void *)[@".@" mutableCopy];
    unsigned int v30 = v42;
  }

  [v42 appendString:v56];
  unint64_t v43 = [a3 operand];
  uint64_t v44 = (void *)[(id)objc_opt_class() _newKeyPathExpressionForString:v57];

  unint64_t v45 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v44, 0);
  unint64_t v46 = [MEMORY[0x189607878] expressionForFunction:v43 selectorName:@"valueForKeyPath:" arguments:v45];

  unint64_t v47 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", @"aliasGenerator"), "generateSubqueryVariableAlias");
  unint64_t v48 = objc_msgSend( MEMORY[0x189607878],  "expressionForSubquery:usingIteratorVariable:predicate:",  v46,  v47,  objc_msgSend(MEMORY[0x1896079C8], "predicateWithValue:", 1));
  uint64_t v49 = (void *)[(id)objc_opt_class() _newKeyPathExpressionForString:v30];

  CFNumberRef v50 = -[NSSQLSubqueryExpressionIntermediate initWithExpression:trailingKeypath:inScope:]( objc_alloc(&OBJC_CLASS___NSSQLSubqueryExpressionIntermediate),  "initWithExpression:trailingKeypath:inScope:",  v48,  v49,  v54[1]);
  uint64_t v21 = -[NSSQLSubqueryExpressionIntermediate generateSQLStringInContext:](v50, "generateSQLStringInContext:", a4);

  if (!v21)
  {
    unint64_t v16 = (void *)MEMORY[0x189603F70];
    BOOL v17 = *MEMORY[0x189603A60];
    unint64_t v18 = [NSString stringWithFormat:@"Failed to generate SQL for function expression: %@", a3];
    goto LABEL_6;
  }

  return v21;
}

    CFNumberType v42 = [*(id *)(v2 + 56) isEqual:v23];
    unint64_t v43 = *(NSMappingModel **)(v2 + 56);
    if ((v42 & 1) == 0)
    {

      unint64_t v43 = v23;
      *(void *)(v2 + 56) = v43;
    }

    if (!v43) {
      goto LABEL_86;
    }
    uint64_t v44 = *(void **)(v2 + 32);
    unint64_t v45 = [*(id *)(v2 + 88) isEqual:v44];
    unint64_t v46 = *(id *)(v2 + 88);
    if ((v45 & 1) == 0)
    {

      unint64_t v46 = v44;
      *(void *)(v2 + 8_Block_object_dispose(va, 8) = v46;
    }

    if (!v46) {
      goto LABEL_86;
    }
    unint64_t v47 = (void *)[*(id *)(v2 + 48) valueForKey:@"NSStoreType"];
    unint64_t v48 = [*(id *)(v2 + 72) isEqual:v47];
    uint64_t v49 = *(id *)(v2 + 72);
    if ((v48 & 1) == 0)
    {

      uint64_t v49 = v47;
      *(void *)(v2 + 72) = v49;
    }

    if (!v49) {
      goto LABEL_86;
    }
    CFNumberRef v50 = *(void **)(v2 + 24);
    if (([*(id *)(v2 + 80) isEqual:v50] & 1) == 0)
    {

      *(void *)(v2 + 80) = v50;
    }

    unint64_t v51 = (void *)objc_msgSend( (id)v2,  "createMigrationManagerForSourceModel:destinationModel:error:",  *(void *)(v2 + 40),  objc_msgSend(*(id *)(v2 + 8), "managedObjectModel"),  a2);
    [v51 setDestinationConfigurationForCloudKitValidation:*(void *)(v2 + 136)];
    -[NSStoreMigrationPolicy setMigrationManager:](v2, v51);
    if (!*(void *)(v2 + 96)) {
      goto LABEL_86;
    }
    unint64_t v52 = [(id)objc_opt_class() _canMigrateWithMappingModel:*(void *)(v2 + 56)];
    if ((v52 & 1) != 0)
    {
      unsigned int v53 = *(void **)(v2 + 16);
      if (!v53) {
        goto LABEL_86;
      }
LABEL_68:
      if (([*(id *)(v2 + 64) isEqual:v53] & 1) == 0)
      {

        *(void *)(v2 + 64) = v53;
      }

      if ((v5 & 1) != 0) {
        objc_msgSend( (id)objc_msgSend( -[NSDictionary valueForKey:]( +[NSPersistentStoreCoordinator registeredStoreTypes]( NSPersistentStoreCoordinator,  "registeredStoreTypes"),  "valueForKey:",  *(void *)(v2 + 72)),  "pointerValue"),  "_figureOutWhereExternalReferencesEndedUpRelativeTo:",  v53);
      }
      unsigned int v56 = (id)[*(id *)(v2 + 88) mutableCopy];
      [v56 setObject:MEMORY[0x189604A88] forKey:@"NSPersistentStoreUnlinkDestroyOption"];
      [v56 setObject:MEMORY[0x189604A88] forKey:@"NSPersistentStoreForceDestroyOption"];
      if ((v52 & 1) == 0
        && objc_msgSend( (id)objc_msgSend(v53, "path"),  "hasSuffix:",  @".migrationdestination_41b5a6b5c6e848c462a8480cd24caef3"))
      {
        *(void *)buf = 0LL;
        if (([*(id *)(v2 + 8) _destroyPersistentStoreAtURL:v53 withType:*(void *)(v2 + 72) options:v56 error:buf] & 1) == 0) {
          _NSCoreDataLog( 1LL,  (uint64_t)@"(migration) Failed to remove orphaned, partially migrated store file %@: %@",  v57,  v58,  v59,  v60,  v61,  v62,  (uint64_t)v53);
        }
        objc_msgSend( *(id *)(v2 + 8),  "removePersistentStore:error:",  objc_msgSend(*(id *)(v2 + 8), "persistentStoreForURL:", v53),  0);
        objc_msgSend(v14, "removeItemAtPath:error:", objc_msgSend(v53, "path"), 0);
        objc_msgSend( v14,  "removeItemAtPath:error:",  objc_msgSend((id)objc_msgSend(v53, "path"), "stringByAppendingString:", @"-shm"),  0);
        objc_msgSend( v14,  "removeItemAtPath:error:",  objc_msgSend((id)objc_msgSend(v53, "path"), "stringByAppendingString:", @"-journal"),  0);
        objc_msgSend( v14,  "removeItemAtPath:error:",  objc_msgSend((id)objc_msgSend(v53, "path"), "stringByAppendingString:", @"-wal"),  0);
      }

      if (![(id)v2 migrateStoreAtURL:*(void *)(v2 + 16) withManager:*(void *)(v2 + 96) metadata:*(void *)(v2 + 48) options:*(void *)(v2 + 88) error:a2])
      {
        if (([*(id *)(v2 + 16) isEqual:v53] & 1) == 0
          && objc_msgSend( (id)objc_msgSend(v53, "path"),  "hasSuffix:",  @".migrationdestination_41b5a6b5c6e848c462a8480cd24caef3"))
        {
          if (+[NSMappingModel migrationDebugLevel](&OBJC_CLASS___NSMappingModel, "migrationDebugLevel") < 1)
          {
            [*(id *)(v2 + 8) _destroyPersistentStoreAtURL:v53 withType:*(void *)(v2 + 72) options:v56 error:0];
            objc_msgSend( *(id *)(v2 + 8),  "removePersistentStore:error:",  objc_msgSend(*(id *)(v2 + 8), "persistentStoreForURL:", v53),  0);
            objc_msgSend(v14, "removeItemAtPath:error:", objc_msgSend(v53, "path"), 0);
            objc_msgSend( v14,  "removeItemAtPath:error:",  objc_msgSend((id)objc_msgSend(v53, "path"), "stringByAppendingString:", @"-shm"),  0);
            objc_msgSend( v14,  "removeItemAtPath:error:",  objc_msgSend((id)objc_msgSend(v53, "path"), "stringByAppendingString:", @"-journal"),  0);
            objc_msgSend( v14,  "removeItemAtPath:error:",  objc_msgSend((id)objc_msgSend(v53, "path"), "stringByAppendingString:", @"-wal"),  0);
          }

          else
          {
            _NSCoreDataLog( 4LL,  (uint64_t)@"(migration) leaving incompletely migrated store on disk after automatic migration failure. (%@)",  v65,  v66,  v67,  v68,  v69,  v70,  (uint64_t)v53);
          }
        }

        goto LABEL_86;
      }

      -[NSStoreMigrationPolicy setMigrationManager:](v2, 0LL);
      unint64_t v63 = [(id)objc_opt_class() migrationStoreOptionsFromStoreOptions:*(void *)(v2 + 88)];
      unint64_t v64 = (id)objc_msgSend( (id)objc_msgSend( (id)objc_opt_class(),  "migrationStoreOptionsFromStoreOptions:",  *(void *)(v2 + 32)),  "mutableCopy");
      objc_msgSend( v64,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithBool:", 1),  @"NSPersistentStoreUnlinkDestroyOption");
      [v64 setObject:MEMORY[0x189604A88] forKey:@"NSPersistentStoreForceDestroyOption"];
      if ((v52 & 1) != 0
        || ([*(id *)(v2 + 8) _replacePersistentStoreAtURL:*(void *)(v2 + 16) destinationOptions:v63 withPersistentStoreFromURL:v53 sourceOptions:v64 storeType:*(void *)(v2 + 72) error:a2] & 1) != 0)
      {
        uint64_t v2 = [*(id *)(v2 + 8) addPersistentStoreWithType:*(void *)(v2 + 72) configuration:*(void *)(v2 + 80) URL:*(void *)(v2 + 16) options:*(void *)(v2 + 88) error:a2];
        goto LABEL_87;
      }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 24LL)
    && (unint64_t)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "insertedObjects"), "count") >= 0x1F4)
  {
    if ([*(id *)(a1 + 32) save:*(void *)(*(void *)(a1 + 96) + 8) + 40])
    {
      [*(id *)(a1 + 32) reset];
    }

    else
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 24LL) = 0;
      unint64_t v52 = *(id *)(*(void *)(*(void *)(a1 + 96) + 8LL) + 40LL);
    }
  }

      uint64_t v35 = [NSString stringWithUTF8String:"Unknown attribute type: %lu"];
      unint64_t v36 = [a5 attributeType];
      _NSCoreDataLog(17LL, v35, v37, v38, v39, v40, v41, v42, v36);
      unint64_t v43 = __pflogFaultLog;
      BOOL v13 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
      if (!v13) {
        return v13;
      }
      *(_DWORD *)buf = 134217984;
      unint64_t v64 = [a5 attributeType];
      uint64_t v32 = "CoreData: Unknown attribute type: %lu";
      unint64_t v33 = (os_log_s *)v43;
      unint64_t v34 = 12;
      goto LABEL_51;
    }

    goto LABEL_61;
  }

  if (v9 == 1800)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0) {
      goto LABEL_48;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
LABEL_54:
      unint64_t v12 = a3;
      unint64_t v11 = a4;
      goto LABEL_55;
    }

    getCloudKitCKRecordClass();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      uint64_t v44 = [a3 recordID];
      unint64_t v45 = (id)[a4 recordID];
      unint64_t v46 = (id)v44;
LABEL_62:
      LOBYTE(v13) = [v46 isEqual:v45];
      return v13;
    }

    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      unint64_t v47 = [NSString stringWithUTF8String:"Unknown value type '%@' for attribute: %@"];
      unint64_t v48 = objc_opt_class();
      _NSCoreDataLog(17LL, v47, v49, v50, v51, v52, v53, v54, v48);
      unint64_t v55 = __pflogFaultLog;
      BOOL v13 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
      if (!v13) {
        return v13;
      }
      *(_DWORD *)buf = 138412546;
      unint64_t v64 = objc_opt_class();
      uint64_t v65 = 2112;
      unsigned int v66 = a5;
      uint64_t v32 = "CoreData: Unknown value type '%@' for attribute: %@";
      unint64_t v33 = (os_log_s *)v55;
      unint64_t v34 = 22;
LABEL_51:
      _os_log_fault_impl(&dword_186681000, v33, OS_LOG_TYPE_FAULT, v32, buf, v34);
LABEL_52:
      LOBYTE(v13) = 0;
      return v13;
    }

uint64_t _resolveForSelectorAndType(unint64_t *a1, const char *a2, objc_class *a3, int a4)
{
  LODWORD(v4) = a4;
  uint64_t v48 = *MEMORY[0x1895F89C0];
  uint64_t v8 = (void *)a1[13];
  uint64_t v9 = [v8 keys];
  uint64_t v10 = [v8 length];
  unint64_t v11 = (void **)PF_CALLOC_OBJECT_ARRAY(v10);
  unint64_t v12 = _PFFastEntityClass(a1);
  Class Superclass = class_getSuperclass((Class)v12);
  unint64_t v46 = v10;
  if (v10)
  {
    unsigned int v45 = v4;
    unint64_t v14 = 0LL;
    uint64_t v44 = a1 + 19;
    while (1)
    {
      id v15 = objc_msgSend(Superclass, a2, Superclass, *(void *)(v9 + 8 * v14));
      Class Class = object_getClass(v15);
      BOOL v17 = Class != 0LL;
      if (Class != a3 && Class != 0LL)
      {
        do
        {
          Class Class = class_getSuperclass(Class);
          BOOL v17 = Class != 0LL;
        }

        while (Class != a3 && Class);
      }

      if (!v17) {
        break;
      }

LABEL_43:
      if (++v14 == v10)
      {
        unint64_t v36 = a1 + 19;
        uint64_t v4 = v45;
        unint64_t v37 = (unint64_t *)(*v44 + 8LL * v45);
        while (!__ldaxr(v37))
        {
        }

        __clrex();
        unsigned int v41 = v11;
        do
        {
          CFNumberType v42 = *v41++;

          --v10;
        }

        while (v10);
LABEL_56:
        PF_FREE_OBJECT_ARRAY(v11);
        return *(void *)(*v36 + 8 * v4);
      }
    }

    if (v14 > v46 && !PFUseToolchainBehaviors())
    {
      uint64_t v19 = [a1 name];
      class_getName(Superclass);
      _NSCoreDataLog( 2LL,  (uint64_t)@"Relationship properties should be @dynamic, not ivars (entity %@, class %s, property %@).  This will be an error in the future.",  v20,  v21,  v22,  v23,  v24,  v25,  v19);
    }

    unsigned int v26 = *(void **)(a1[12] + 24 + 8 * v14);
    if (([v26 _propertyType] & 0xFFFFFFFFFFFFFFFBLL) != 2 || objc_msgSend(v26, "attributeType") != 900)
    {
LABEL_42:
      v11[v14] = v15;
      goto LABEL_43;
    }

    if (v45 == 3)
    {
      if (!v15) {
        goto LABEL_42;
      }
      unint64_t v29 = (objc_class *)[v15 containerClassID];
      if ((objc_opt_isKindOfClass() & 1) == 0
        && (objc_opt_isKindOfClass() & 1) != 0
        && (unsigned int v30 = (const char *)[v15 selector]) != 0
        && (InstanceMethod = class_getInstanceMethod(v29, v30)) != 0LL)
      {
        method_getReturnType(InstanceMethod, dst, 0x20uLL);
        int v32 = dst[0];
      }

      else
      {
        int v32 = 0;
      }

      uint64_t v33 = *(void *)(*v44 + 72);
      char v34 = *(_BYTE *)(v33 + v14) | 0x10;
LABEL_41:
      *(_BYTE *)(v33 + v14) = v34;
      goto LABEL_42;
    }

    if (v45 != 2 || !v15) {
      goto LABEL_42;
    }
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      unint64_t v27 = (objc_ivar *)[v15 ivar];
      if (v27)
      {
        int v28 = *(unsigned __int8 *)ivar_getTypeEncoding(v27);
        goto LABEL_38;
      }
    }

    else if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      uint64_t v35 = (objc_method *)[v15 method];
      if (v35)
      {
        method_getArgumentType(v35, 2u, dst, 0x20uLL);
        int v28 = dst[0];
        goto LABEL_38;
      }
    }

    int v28 = 0;
LABEL_38:
    uint64_t v33 = *(void *)(*v44 + 72);
    char v34 = *(_BYTE *)(v33 + v14) | 1;
    goto LABEL_41;
  }

  unint64_t v36 = a1 + 19;
  uint64_t v4 = v4;
  unint64_t v39 = (unint64_t *)(a1[19] + 8LL * v4);
  do
  {
    if (__ldaxr(v39))
    {
      __clrex();
      goto LABEL_56;
    }
  }

  while (__stlxr((unint64_t)v11, v39));
  return *(void *)(*v36 + 8 * v4);
}

BOOL _readExpressionDescriptionIntoShellFromBytes( uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  unint64_t v11 = (*a3 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v12 = v11 + 4;
  if (v11 + 4 <= a4)
  {
    uint64_t v13 = bswap32(*(_DWORD *)(a2 + v11));
    unint64_t v11 = (v11 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v14 = v11 + 4;
  }

  else
  {
    uint64_t v13 = 0LL;
    unint64_t v14 = v11 + 4;
    unint64_t v12 = *a3;
  }

  a5[20] = v13;
  if (v14 <= a4)
  {
    uint64_t v15 = bswap32(*(_DWORD *)(a2 + v11));
    unint64_t v12 = v14;
  }

  else
  {
    uint64_t v15 = 0LL;
  }

  uint64_t v16 = *(void *)(a7 + 8 * v15);
  uint64_t v30 = 0LL;
  BOOL v17 = (void *)MEMORY[0x189604010];
  uint64_t v18 = objc_opt_class();
  uint64_t v19 = objc_msgSend(v17, "setWithObjects:", v18, objc_opt_class(), 0);
  uint64_t v20 = (void *)+[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v19,  v16,  (uint64_t)&v30);
  uint64_t v21 = v20;
  if (v20)
  {
    a5[19] = v20;
    *a3 = v12;
  }

  else
  {
    uint64_t v22 = [a5 name];
    _NSCoreDataLog( 1LL,  (uint64_t)@"Unable to decode expression for expression description %@ : %@",  v23,  v24,  v25,  v26,  v27,  v28,  v22);
    if (a9) {
      *a9 = v30;
    }
  }

  return v21 != 0LL;
}

void _PF_Handler_SetNilValueForKeyIndex(char **a1, uint64_t a2, uint64_t a3)
{
  id v5 = _PFEntityForManagedObject(a1);
  id v6 = *(void **)(_kvcPropertysPrimitiveSetters((uint64_t)v5) + 8 * a3);
  _PF_CopyOnWrite_Snapshot(a1);
  snapshot_set_value_as_object(a1[3], a3, 0LL, v7, v8, v9, v10, v11);
  if (v6)
  {
    if (isScalarTypeForKVCSetter(v6)) {
      _NSSetUsingKeyValueSetter();
    }
  }

BOOL isScalarTypeForKVCSetter(void *a1)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    uint64_t v2 = (objc_ivar *)[a1 ivar];
    if (v2)
    {
      int v3 = *(unsigned __int8 *)ivar_getTypeEncoding(v2);
      return v3 == 58 || (v3 - 65) < 0x35;
    }
  }

  else if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    uint64_t v4 = (objc_method *)[a1 method];
    if (v4)
    {
      method_getArgumentType(v4, 2u, dst, 0x20uLL);
      int v3 = dst[0];
      return v3 == 58 || (v3 - 65) < 0x35;
    }
  }

  int v3 = 0;
  return v3 == 58 || (v3 - 65) < 0x35;
}

void _PF_Handler_Primitive_Internal_SetProperty(char **a1, unsigned int a2, void *a3, uint64_t a4)
{
  if (a4)
  {
    _NSSetUsingKeyValueSetter();
  }

  else
  {
    id v8 = a3;
    snapshot_set_value_as_object(a1[3], a2, v8, v9, v10, v11, v12, v13);
  }

uint64_t _PF_InternalToOneRelationshipForeignKeyCache(unsigned int *a1, unint64_t a2, void *a3)
{
  if (a3) {
    *a3 = 0LL;
  }
  if ((a1[4] & 0x30000) == 0x10000 || (a1[4] & 0x80) != 0) {
    return 0LL;
  }
  uint64_t v7 = *((void *)a1 + 4);
  id v8 = (unint64_t *)_PFEntityForManagedObject(a1);
  unint64_t v9 = v8[14];
  uint64_t v10 = a1[5];
  uint64_t v11 = (_DWORD)v10 ? (char *)a1 + v10 : 0LL;
  unint64_t v13 = *(void *)(v9 + 96);
  unint64_t v12 = *(void *)(v9 + 104);
  BOOL v15 = a2 >= v13;
  unint64_t v14 = a2 - v13;
  BOOL v15 = !v15 || v14 >= v12;
  if (v15 || v7 == 0) {
    return 0LL;
  }
  unint64_t v17 = a1[4];
  if (*(void *)(_kvcPropertysPrimitiveGetters(v8) + 8 * a2)) {
    uint64_t v24 = (void *)_NSGetUsingKeyValueGetter();
  }
  else {
    snapshot_get_value_as_object(*((id **)a1 + 3), a2, v18, v19, v20, v21, v22, v23);
  }
  if (((v11[(a2 >> 3) - ((v17 >> 22) & 0x3FC)] >> (a2 & 7)) & 1) != 0)
  {
    if (a3)
    {
      uint64_t v24 = (void *)[v24 objectID];
LABEL_27:
      *a3 = v24;
    }
  }

  else if (a3)
  {
    goto LABEL_27;
  }

  return 1LL;
}

id *_PF_ObjectIDsForDeferredFault(id **a1, unint64_t a2)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl( [a1 managedObjectContext],  sel_fulfillFault_withContext_forIndex_);
  }
  if (((_DWORD)a1[2] & 0x30000) == 0x10000 || ((_DWORD)a1[2] & 0x80) != 0) {
    return 0LL;
  }
  uint64_t v5 = (uint64_t)a1[4];
  id v6 = (unint64_t *)_PFEntityForManagedObject(a1);
  uint64_t v7 = (void *)v6[14];
  unint64_t v8 = v7[2];
  BOOL v10 = a2 >= v8;
  unint64_t v9 = a2 - v8;
  BOOL v10 = !v10 || v9 >= v7[3];
  int v11 = !v10;
  if (((_DWORD)a1[2] & 0x38000) == 0x8000 || v11 != 0) {
    [(id)_insertion_fault_handler fulfillFault:a1 withContext:v5 forIndex:a2];
  }
  if ((v11 & 1) != 0) {
    return 0LL;
  }
  unint64_t v15 = v7[12];
  BOOL v10 = a2 >= v15;
  unint64_t v16 = a2 - v15;
  int v18 = v10 && v16 < v7[13];
  uint64_t v25 = *(void *)(_kvcPropertysPrimitiveGetters(v6) + 8 * a2);
  if (v25) {
    uint64_t v26 = (void *)_NSGetUsingKeyValueGetter();
  }
  else {
    snapshot_get_value_as_object(a1[3], a2, v19, v20, v21, v22, v23, v24);
  }
  uint64_t v27 = v26;
  if (v18)
  {
    if (!v5) {
      return 0LL;
    }
    if (v26 != (void *)_CD_ScalarNull)
    {
LABEL_59:
      if (v27)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0) {
          return (id *)[MEMORY[0x189603F18] arrayWithObject:v27];
        }
        uint64_t v27 = (void *)[v27 objectID];
        if (v27) {
          return (id *)[MEMORY[0x189603F18] arrayWithObject:v27];
        }
      }

      return 0LL;
    }

    [(id)_insertion_fault_handler fulfillFault:a1 withContext:v5 forIndex:a2];
    uint64_t result = a1[3];
    if (result)
    {
      if (v25) {
        uint64_t v34 = _NSGetUsingKeyValueGetter();
      }
      else {
        snapshot_get_value_as_object(result, a2, v28, v29, v30, v31, v32, v33);
      }
      uint64_t v27 = (void *)v34;
      goto LABEL_59;
    }

    __break(1u);
  }

  else
  {
    if (v26 && ([v26 isFault] & 1) == 0)
    {
      unint64_t v13 = (void *)[MEMORY[0x189603FA8] array];
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      uint64_t v40 = [v27 countByEnumeratingWithState:&v48 objects:v53 count:16];
      if (v40)
      {
        uint64_t v41 = v40;
        uint64_t v42 = *(void *)v49;
        do
        {
          for (uint64_t i = 0LL; i != v41; ++i)
          {
            if (*(void *)v49 != v42) {
              objc_enumerationMutation(v27);
            }
            objc_msgSend(v13, "addObject:", objc_msgSend(*(id *)(*((void *)&v48 + 1) + 8 * i), "objectID"));
          }

          uint64_t v41 = [v27 countByEnumeratingWithState:&v48 objects:v53 count:16];
        }

        while (v41);
      }

      return (id *)v13;
    }

    id v35 = -[NSFaultHandler retainedFulfillAggregateFaultForObject:andRelationship:withContext:]( _insertion_fault_handler,  a1,  *(void **)(v6[12] + 24 + 8 * a2),  v5);
    if (![v35 isNSArray])
    {
      unint64_t v13 = (void *)[MEMORY[0x189603FA8] array];
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      uint64_t v36 = [v35 countByEnumeratingWithState:&v44 objects:v52 count:16];
      if (v36)
      {
        uint64_t v37 = v36;
        uint64_t v38 = *(void *)v45;
        do
        {
          for (uint64_t j = 0LL; j != v37; ++j)
          {
            if (*(void *)v45 != v38) {
              objc_enumerationMutation(v35);
            }
            [v13 addObject:*(void *)(*((void *)&v44 + 1) + 8 * j)];
          }

          uint64_t v37 = [v35 countByEnumeratingWithState:&v44 objects:v52 count:16];
        }

        while (v37);
      }

      return (id *)v13;
    }

    return (id *)v35;
  }

  return result;
}

void _PFFaultHandlerFixRelationshipsPostMigration(int a1, id **a2, uint64_t a3, const __CFDictionary *a4)
{
  int v4 = (*((_DWORD *)a2 + 4) >> 15) & 7;
  if (v4 == 5 || v4 == 0)
  {
    unint64_t v8 = (unint64_t *)_PFEntityForManagedObject(a2);
    uint64_t v9 = (uint64_t)v8;
    if (v8) {
      unint64_t v37 = v8[14];
    }
    else {
      unint64_t v37 = 0LL;
    }
    uint64_t v10 = _kvcPropertysPrimitiveGetters(v8);
    uint64_t v38 = _kvcPropertysPrimitiveSetters(v9);
    uint64_t v17 = 0LL;
    uint64_t v18 = *((unsigned int *)a2 + 5);
    if ((_DWORD)v18) {
      uint64_t v19 = (char *)a2 + v18;
    }
    else {
      uint64_t v19 = 0LL;
    }
    uint64_t v20 = &v19[-(((unint64_t)*((unsigned int *)a2 + 4) >> 22) & 0x3FC)];
    char v21 = 1;
    do
    {
      char v22 = v21;
      uint64_t v23 = (unint64_t *)(v37
                               + 16LL
                               * *((int *)&__const__PFFaultHandlerFixRelationshipsPostMigration_rangeIndices + v17));
      unint64_t v25 = *v23;
      unint64_t v24 = v23[1];
      if (*v23 < v24 + *v23)
      {
        do
        {
          if (((v20[v25 >> 3] >> (v25 & 7)) & 1) == 0)
          {
            if (*(void *)(v10 + 8 * v25)) {
              uint64_t v26 = (const void *)_NSGetUsingKeyValueGetter();
            }
            else {
              snapshot_get_value_as_object(a2[3], v25, v11, v12, v13, v14, v15, v16);
            }
            if (v26) {
              BOOL v27 = v26 == (const void *)_CD_ScalarNull;
            }
            else {
              BOOL v27 = 1;
            }
            if (!v27)
            {
              Value = (void *)CFDictionaryGetValue(a4, v26);
              if (Value)
              {
                uint64_t v29 = Value;
                uint64_t v30 = *(void *)(v38 + 8 * v25);
                _PF_CopyOnWrite_Snapshot(a2);
                if (v30)
                {
                  _NSSetUsingKeyValueSetter();
                }

                else
                {
                  id v31 = v29;
                  snapshot_set_value_as_object((char *)a2[3], v25, v31, v32, v33, v34, v35, v36);
                }
              }
            }
          }

          ++v25;
          --v24;
        }

        while (v24);
      }

      char v21 = 0;
      uint64_t v17 = 1LL;
    }

    while ((v22 & 1) != 0);
  }

void _PFFaultHandlerPreconnectRelationship(int a1, unsigned int *a2, void *a3, void *a4)
{
  id v7 = _PFEntityForManagedObject(a2);
  uint64_t v8 = [a3 entity];
  unint64_t v9 = [a3 _entitysReferenceID];
  uint64_t v10 = [a3 isToMany];
  if (v7 != (id)v8) {
    unint64_t v9 = [v7 _offsetRelationshipIndex:v9 fromSuperEntity:v8 andIsToMany:v10];
  }
  uint64_t v11 = _kvcPropertysPrimitiveSetters((uint64_t)v7);
  uint64_t v12 = *(void *)(v11 + 8 * v9);
  unsigned int v13 = a2[4];
  if ((v13 & 0x38000) == 0x8000)
  {
    uint64_t v14 = (void *)*((void *)a2 + 6);
    if (v14)
    {
      uint64_t v15 = 0LL;
      if ((v13 & 0x2000) == 0 && *v14)
      {
        uint64_t v11 = objc_msgSend(objc_alloc(MEMORY[0x189604010]), "initWithObjects:", objc_msgSend(a3, "name"), 0);
        uint64_t v15 = (void *)v11;
      }
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    _PFFaultHandlerFulfillPartialFault( v11,  a2,  *((void *)a2 + 4),  0LL,  (void *)NSArray_EmptyArray,  (uint64_t)v15,  MEMORY[0x189604A58]);

    unsigned int v13 = a2[4];
  }

  uint64_t v16 = a2[5];
  if ((_DWORD)v16) {
    uint64_t v17 = (char *)a2 + v16;
  }
  else {
    uint64_t v17 = 0LL;
  }
  uint64_t v18 = &v17[-((v13 >> 22) & 0x3FC)];
  int v19 = v18[v9 >> 3];
  int v20 = 1 << (v9 & 7);
  if ((v20 & v19) == 0)
  {
    v18[v9 >> 3] = v19 | v20;
    if ((v10 & 1) != 0)
    {
      [a3 isOrdered];
    }

    else
    {
      if ((a2[4] & 0x80) != 0 || !*((void *)a2 + 4)) {
        return;
      }
      if (!a4)
      {
        uint64_t v28 = (char **)a2;
        unint64_t v29 = v9;
        uint64_t v30 = 0LL;
        goto LABEL_19;
      }
    }

    uint64_t v28 = (char **)a2;
    unint64_t v29 = v9;
    uint64_t v30 = a4;
LABEL_19:
    _PF_Handler_Primitive_SetProperty(v28, v29, v30, 0LL, v12);
    return;
  }

  else {
    snapshot_get_value_as_object(*((id **)a2 + 3), v9, v21, v22, v23, v24, v25, v26);
  }
  id v31 = v27;
  if ((_DWORD)v10)
  {
    if (v27)
    {
      return;
    }

    uint64_t v39 = [a3 name];
    [a2 objectID];
    _NSCoreDataLog( 1LL,  (uint64_t)@"During prefetching, materialized to-many relationship '%@' on object %@ was null",  v40,  v41,  v42,  v43,  v44,  v45,  v39);
LABEL_34:
    __break(1u);
    return;
  }

  if (v27)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      uint64_t v32 = [a3 name];
      [a2 objectID];
      _NSCoreDataLog( 1LL,  (uint64_t)@"During prefetching, materialized to-one relationship '%@' on object %@ was not a managed object but instead %@",  v33,  v34,  v35,  v36,  v37,  v38,  v32);
      goto LABEL_34;
    }
  }

void sub_186735280( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, void (*a24)(char *))
{
}

uint64_t _readFetchRequestIntoShellFromData( void *a1, uint64_t a2, unint64_t *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t *a14)
{
  unint64_t v14 = (*a3 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v15 = v14 + 4;
  if (v14 + 4 > a4) {
    goto LABEL_120;
  }
  int v17 = *(_DWORD *)(a2 + v14);
  unint64_t v142 = v14 + 4;
  if (v17 != -20254786) {
    goto LABEL_120;
  }
  uint64_t v18 = a8;
  uint64_t v20 = a5;
  uint64_t v22 = a3;
  unint64_t v23 = (v14 + 7) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v24 = v23 + 4;
  if (v23 + 4 <= a4)
  {
    unsigned int v25 = bswap32(*(_DWORD *)(a2 + v23));
    unint64_t v142 = v24;
    unint64_t v15 = v24;
  }

  else
  {
    unsigned int v25 = 0;
  }

  if (v15 + v25 > a4)
  {
    if (a14)
    {
      uint64_t v26 = (void *)MEMORY[0x189607870];
      uint64_t v27 = *MEMORY[0x189607460];
      uint64_t v28 = (void *)MEMORY[0x189603F68];
      unint64_t v29 = @"Can't read entity: Not enough bytes left";
      goto LABEL_122;
    }

    return 0LL;
  }

  unint64_t v30 = (v15 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v31 = v30 + 4;
  if (v30 + 4 <= a4)
  {
    unsigned int v32 = *(_DWORD *)(a2 + v30);
    unint64_t v142 = v30 + 4;
    if (!v32)
    {
      unint64_t v15 = v30 + 4;
      goto LABEL_39;
    }

    CFIndex v33 = bswap32(v32);
    values = (void **)(a2 + ((v30 + 11) & 0xFFFFFFFFFFFFFFF8LL));
    CFIndex v34 = v33;
    while (1)
    {
      unint64_t v35 = (v31 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      unint64_t v36 = v35 + 8;
      if (v35 + 8 <= a4)
      {
        uint64_t v37 = *(void *)(a2 + v35);
        unint64_t v142 = v36;
        unint64_t v31 = v36;
        if (v37) {
          break;
        }
      }

      if (!--v34)
      {
        uint64_t v39 = values;
        CFIndex v40 = v33;
        while (1)
        {
          unint64_t v41 = (v142 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v42 = v41 + 4;
          if (v41 + 4 <= a4)
          {
            unsigned int v44 = bswap32(*(_DWORD *)(a2 + v41));
            unint64_t v142 = v41 + 4;
            if (v44 == 2)
            {
              unint64_t v46 = (v41 + 7) & 0xFFFFFFFFFFFFFFFCLL;
              unint64_t v47 = v46 + 4;
              if (v46 + 4 <= a4)
              {
                unsigned int v48 = bswap32(*(_DWORD *)(a2 + v46));
                unint64_t v142 = v47;
              }

              else
              {
                unsigned int v48 = 0;
              }

              uint64_t v45 = *(void **)(a7 + 8LL * v48);
              goto LABEL_25;
            }

            if (v44 == 1)
            {
              unint64_t v49 = (v41 + 7) & 0xFFFFFFFFFFFFFFFCLL;
              unint64_t v50 = v49 + 4;
              if (v49 + 4 <= a4)
              {
                unsigned int v51 = bswap32(*(_DWORD *)(a2 + v49));
                unint64_t v142 = v50;
              }

              else
              {
                unsigned int v51 = 0;
              }

              uint64_t v45 = *(void **)(a8 + 8LL * v51);
              goto LABEL_25;
            }

            if (v44)
            {
              if (a14)
              {
                uint64_t v26 = (void *)MEMORY[0x189607870];
                uint64_t v27 = *MEMORY[0x189607460];
                uint64_t v28 = (void *)MEMORY[0x189603F68];
                unint64_t v29 = @"Invalid groupByProperty type in archive";
                goto LABEL_122;
              }

              goto LABEL_26;
            }

            unint64_t v41 = (v41 + 7) & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v42 = v41 + 4;
          }

          if (v42 <= a4)
          {
            unsigned int v43 = bswap32(*(_DWORD *)(a2 + v41));
            unint64_t v142 = v42;
          }

          else
          {
            unsigned int v43 = 0;
          }

          uint64_t v45 = _newReadPropertyProxyFromBytes(a1, a2, &v142, a4, *(void *)(a11 + 8LL * v43), a7);
LABEL_25:
          *uint64_t v39 = v45;
LABEL_26:
          ++v39;
          if (!--v40)
          {
            callBacks.version = 0LL;
            *(_OWORD *)&callBacks.retain = *(_OWORD *)(MEMORY[0x189605228] + 8LL);
            callBacks.copyDescription = *(CFArrayCopyDescriptionCallBack *)(MEMORY[0x189605228] + 24LL);
            callBacks.equal = 0LL;
            uint64_t v20 = a5;
            *(void *)(a5 + 16) = CFArrayCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)values,  v33,  &callBacks);
            unint64_t v15 = v142;
            uint64_t v18 = a8;
            goto LABEL_39;
          }
        }
      }
    }

LABEL_120:
  if (a14)
  {
    uint64_t v26 = (void *)MEMORY[0x189607870];
    uint64_t v27 = *MEMORY[0x189607460];
    uint64_t v28 = (void *)MEMORY[0x189603F68];
    unint64_t v29 = @"Can't read entity into shell: Missing entity frontside delimiter";
    goto LABEL_122;
  }

  return 0LL;
}

              [v113 drain];
              goto LABEL_27;
            }
          }

                      uint64_t v20 = (unsigned __int8 *)v37;
                    }

                    goto LABEL_124;
                  case 4:
                  case 5:
                  case 6:
                  case 9:
                  case 0xC:
                    if (v24) {
                      goto LABEL_68;
                    }
                    uint64_t v28 = (const char *)((unint64_t)&v20[v23] & v27);
                    unint64_t v29 = (int *)(v28 + 4);
                    unint64_t v30 = (__CFString *)CFStringCreateWithCString(0LL, v28 + 4, 0x8000100u);
                    unint64_t v31 = *(int *)v28;
                    unsigned int v32 = *((unsigned __int8 *)v21 - 4);
                    if (v32 == 12)
                    {
                      CFIndex v33 = (__CFString *)(id)[MEMORY[0x189604030] URLWithString:v30];
                    }

                    else
                    {
                      if (v32 != 4) {
                        goto LABEL_72;
                      }
                      CFIndex v33 = (__CFString *)[objc_alloc(MEMORY[0x189607858]) initWithString:v30];
                    }

                    unint64_t v53 = v33;
                    CFRelease(v30);
                    unint64_t v30 = v53;
LABEL_72:
                    uint64_t v20 = (unsigned __int8 *)v29 + v31;
                    goto LABEL_73;
                  case 7:
                  case 8:
                    if (v24) {
                      goto LABEL_68;
                    }
                    CFIndex v34 = (double *)((unint64_t)&v20[v23] & v27);
                    uint64_t v20 = (unsigned __int8 *)(v34 + 1);
                    if (objc_msgSend((id)objc_msgSend(*v21, "propertyDescription"), "superCompositeAttribute"))
                    {
                      setMultiColumnValueDictionary( (char *)v16,  v21 - 2,  (void *)[MEMORY[0x189607968] numberWithDouble:*v34]);
                      goto LABEL_124;
                    }

                    unint64_t v66 = *((unsigned int *)v21 - 4);
                    if (*((_BYTE *)v21 - 4) == 7)
                    {
                      unint64_t v67 = object_getClass(v16);
                      IndexedIvars = object_getIndexedIvars(v67);
                      unint64_t v69 = *v26;
                      unint64_t v70 = *v34;
                      if (*(_BYTE *)(IndexedIvars[7] + v66) == 102)
                      {
                        unint64_t v71 = v70;
                        snapshot_set_float((char *)v16, v69, v71);
                        goto LABEL_124;
                      }

                      unint64_t v76 = (char *)v16;
                    }

                    else
                    {
                      unint64_t v70 = *v34;
                      unint64_t v76 = (char *)v16;
                      unint64_t v69 = *((_DWORD *)v21 - 4);
                    }

                    snapshot_set_double(v76, v69, v70);
                    goto LABEL_124;
                  case 0xD:
                  case 0xE:
                    goto LABEL_124;
                  case 0x10:
                    if (v24) {
                      goto LABEL_68;
                    }
                    unint64_t v41 = (const char *)((unint64_t)&v20[v23] & v27);
                    unsigned int v43 = (int *)(v41 + 4);
                    unint64_t v42 = *((unsigned __int8 *)v41 + 4);
                    if (v42 == 3)
                    {
                      if (v118)
                      {
                        unint64_t v77 = v113;
                        if (!v113) {
                          unint64_t v77 = *(void *)(v118 + 104);
                        }
                      }

                      else
                      {
                        unint64_t v77 = v113;
                      }

                      unint64_t v90 = [MEMORY[0x189603F48] dataWithBytes:v43 length:*(int *)v41];
                      unsigned int v91 = objc_alloc(&OBJC_CLASS____NSDataFileBackedFuture);
                      uint64_t v113 = v77;
                      unint64_t v30 = -[_NSDataFileBackedFuture initWithStoreMetadata:directory:]( v91,  "initWithStoreMetadata:directory:",  v90,  [MEMORY[0x189604030] fileURLWithPath:v77 isDirectory:1]);
                      goto LABEL_141;
                    }

                    if (v42 == 1)
                    {
                      unsigned int v44 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                      if (v118) {
                        uint64_t v45 = *(unsigned int *)(v118 + 184);
                      }
                      else {
                        uint64_t v45 = 0LL;
                      }
                      unint64_t v46 = *(int *)v41;
                      unint64_t v47 = (int *)(v41 + 4);
                      unsigned int v48 = 0LL;
                      unint64_t v49 = 0LL;
LABEL_135:
                      unint64_t v30 = -[_PFExternalReferenceData initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:]( v44,  "initWithStoreBytes:length:externalLocation:safeguardLocation:protectionLevel:",  v47,  v46,  v48,  v49,  v45);
                      goto LABEL_141;
                    }

                    uint64_t v78 = objc_msgSend( v112,  "stringWithFileSystemRepresentation:length:",  v41 + 5,  strnlen(v41 + 5, *(int *)v41 - 1));
                    uint64_t v79 = v115;
                    if (v115)
                    {
                      CFIndex v80 = v118;
                      unint64_t v81 = v114;
                      if (!v118 || v114) {
                        goto LABEL_130;
                      }
LABEL_129:
                      unint64_t v81 = *(void **)(v80 + 96);
                      goto LABEL_130;
                    }

                    CFIndex v80 = v118;
                    unint64_t v81 = v114;
                    if (v118)
                    {
                      uint64_t v79 = *(void **)(v118 + 88);
                      if (v114) {
                        goto LABEL_130;
                      }
                      goto LABEL_129;
                    }

                    uint64_t v79 = 0LL;
LABEL_130:
                    unint64_t v115 = v79;
                    unsigned int v83 = [v79 stringByAppendingPathComponent:v78];
                    uint64_t v114 = v81;
                    unsigned int v84 = v81;
                    unint64_t v85 = v83;
                    unint64_t v86 = [v84 stringByAppendingPathComponent:v78];
                    if (!v106 || [v112 fileExistsAtPath:v85])
                    {
                      unsigned int v44 = objc_alloc(&OBJC_CLASS____PFExternalReferenceData);
                      if (v118) {
                        uint64_t v45 = *(unsigned int *)(v118 + 184);
                      }
                      else {
                        uint64_t v45 = 0LL;
                      }
                      unint64_t v46 = *(int *)v41;
                      unint64_t v47 = (int *)(v41 + 4);
                      unsigned int v48 = v85;
                      unint64_t v49 = v86;
                      goto LABEL_135;
                    }

                    unint64_t v30 = 0LL;
LABEL_141:
                    uint64_t v20 = (unsigned __int8 *)v43 + *(int *)v41;
LABEL_73:
                    if (objc_msgSend((id)objc_msgSend(*v21, "propertyDescription"), "superCompositeAttribute"))
                    {
                      setMultiColumnValueDictionary((char *)v16, v21 - 2, v30);
                    }

                    else
                    {
                      unsigned int v54 = *v26;
                      uint64_t v55 = (char *)v16;
                      unsigned int v56 = (uint64_t)v30;
LABEL_76:
                      snapshot_set_object(v55, v54, v56);
                    }

void sub_186737080( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
}

void sub_186737614( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

#error "186737B24: call analysis failed (funcsize=54)"
id __cdecl -[NSXPCStoreNotificationObserver initForObservationWithName:store:]( NSXPCStoreNotificationObserver *self,  SEL a2,  id a3,  id a4)
{
  NSXPCStoreNotificationObserver *v6;
  NSXPCStoreNotificationObserver *v7;
  const char *v8;
  const char *v9;
  dispatch_queue_s *queue;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void handler[5];
  id v20;
  id location;
  objc_super v22;
  v22.receiver = self;
  v22.super_class = (Class)&OBJC_CLASS___NSXPCStoreNotificationObserver;
  id v6 = -[NSXPCStoreNotificationObserver init](&v22, sel_init);
  id v7 = v6;
  if (v6)
  {
    v6->_token = -1;
    v6->_storeID = (NSString *)objc_msgSend((id)objc_msgSend(a4, "identifier"), "copy");
    objc_storeWeak((id *)&v7->_psc, (id)[a4 persistentStoreCoordinator]);
    uint64_t v8 = (const char *)[(id)objc_msgSend( NSString stringWithFormat:@"com.apple.CoreData.%@.%p", a3, v7), "UTF8String"];
    v7->_queue = (OS_dispatch_queue *)dispatch_queue_create(v8, MEMORY[0x1895F8AF8]);
    objc_initWeak(&location, v7);
    unint64_t v9 = (const char *)[a3 fileSystemRepresentation];
    queue = (dispatch_queue_s *)v7->_queue;
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = __67__NSXPCStoreNotificationObserver_initForObservationWithName_store___block_invoke;
    handler[3] = &unk_189EA7F68;
    handler[4] = v7;
    objc_copyWeak(&v20, &location);
    uint64_t v11 = notify_register_dispatch(v9, &v7->_token, queue, handler);
    if ((_DWORD)v11)
    {
      _NSCoreDataLog( 1LL,  (uint64_t)@" Failed to setup notification listener: %d",  v12,  v13,  v14,  v15,  v16,  v17,  v11);

      objc_destroyWeak(&v20);
      objc_destroyWeak(&location);
      return 0LL;
    }

    else
    {
      objc_destroyWeak(&v20);
      objc_destroyWeak(&location);
    }
  }

  return v7;
}

void sub_186737D24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_186737F60(void *a1)
{
}

void sub_186737F90()
{
  if (v0) {
    JUMPOUT(0x186737F98LL);
  }
  JUMPOUT(0x186737F9CLL);
}

void sub_186738078(_Unwind_Exception *a1)
{
}

void sub_1867385B0(void *a1)
{
}

CFStringRef descriptionForBranchRow(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return @"branch row pointer is NULL";
  }
  uint64_t v4 = (*(__int16 *)(a1 + 14) - *(__int16 *)(a1 + 10));
  if ((int)v4 < 1)
  {
    id v5 = 0LL;
  }

  else
  {
    id v5 = objc_alloc_init(MEMORY[0x189603FA8]);
    id v6 = (__int16 *)(a1 + 16);
    do
    {
      unsigned int v7 = *v6++;
      objc_msgSend(v5, "addObject:", objc_msgSend(MEMORY[0x189607968], "numberWithShort:", v7));
      --v4;
    }

    while (v4);
  }

  if ((a2 & 0x80000000) != 0) {
    unint64_t v9 = &stru_189EAC2E8;
  }
  else {
    unint64_t v9 = (const __CFString *)objc_msgSend(NSString, "stringWithFormat:", @"[%d]", a2);
  }
  uint64_t v10 = [NSString stringWithFormat:@"branch row pointer%@ = %p flags.size = %d flags.operation = %d flags.parameter = %d flags.offset = %d lowerBound = %d lowerSlot = %d upperBound = %d upperSlot = %d generalSlots pointer = %p with contents = %@", v9, a1, *(void *)a1 & 7, (*(void *)a1 >> 3) & 0x3FF, *(void *)a1 >> 13, HIDWORD(*(void *)a1), *(unsigned __int16 *)(a1 + 8), *(__int16 *)(a1 + 10), *(unsigned __int16 *)(a1 + 12), *(__int16 *)(a1 + 14), a1 + 16, v5];

  return (const __CFString *)v10;
}

void calculateNextBranchOperation( const __CFArray *a1, CFIndex a2, const void ***a3, _DWORD *a4, _DWORD *a5, const __CFAllocator *a6, _DWORD *a7)
{
  unint64_t v41 = a4;
  CFAllocatorRef v42 = a6;
  CFIndex v40 = a3;
  uint64_t v45 = *MEMORY[0x1895F89C0];
  *a7 = 0;
  *a5 = 1;
  CFIndex v9 = a2 - 1;
  else {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v11 = v10;
  }
  uint64_t v12 = 8 * v11;
  MEMORY[0x1895F8858](a1);
  unint64_t v15 = (const void **)((char *)&v40 - v14);
  size_t v16 = 8 * v13;
  if (v17 > 0x200) {
    unint64_t v15 = (const void **)NSAllocateScannedUncollectable();
  }
  else {
    bzero((char *)&v40 - v14, 8 * v13);
  }
  v46.location = 0LL;
  v46.length = a2;
  CFArrayGetValues(a1, v46, v15);
  int64_t v18 = strlen((const char *)*v15);
  MEMORY[0x1895F8858](v18);
  int v19 = (uint64_t *)((char *)&v40 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
  else {
    bzero(v19, v16);
  }
  if (v18 < 1)
  {
    uint64_t v20 = 0LL;
    goto LABEL_35;
  }

  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v22 = 1LL;
  while (1)
  {
    if (a2 < 1)
    {
      CFMergeSortArray();
LABEL_25:
      uint64_t v27 = 1LL;
      goto LABEL_26;
    }

    uint64_t v23 = 0LL;
    do
    {
      v19[v23] = *((char *)v15[v23] + v21);
      ++v23;
    }

    while (a2 != v23);
    CFMergeSortArray();
    if (a2 < 2) {
      goto LABEL_25;
    }
    uint64_t v24 = *v19;
    unsigned int v25 = v19 + 1;
    CFIndex v26 = v9;
    uint64_t v27 = 1LL;
    do
    {
      uint64_t v29 = *v25++;
      uint64_t v28 = v29;
      if (v29 != v24) {
        ++v27;
      }
      uint64_t v24 = v28;
      --v26;
    }

    while (v26);
LABEL_26:
    if (v27 == a2) {
      break;
    }
    BOOL v30 = v22 < v27;
    if (v22 <= v27) {
      uint64_t v22 = v27;
    }
    if (v30) {
      uint64_t v20 = v21;
    }
    if (++v21 == v18) {
      goto LABEL_35;
    }
  }

  uint64_t v20 = v21;
LABEL_35:
  *(_DWORD *)CFAllocatorRef v42 = v20;
  CFAllocatorRef v42 = (CFAllocatorRef)*MEMORY[0x189604DB0];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(v42, 0LL, 0LL, 0LL);
  if (a2 >= 1)
  {
    unsigned int v32 = v15;
    CFIndex v33 = a2;
    do
    {
      CFIndex v34 = *v32;
      unint64_t v35 = (const void *)*((unsigned __int8 *)*v32 + v20);
      Value = (void *)CFDictionaryGetValue(Mutable, v35);
      if (!Value)
      {
        Value = CFArrayCreateMutable(v42, 0LL, 0LL);
        CFDictionarySetValue(Mutable, v35, Value);
      }

      CFArrayAppendValue((CFMutableArrayRef)Value, v34);
      ++v32;
      --v33;
    }

    while (v33);
  }

  CFIndex Count = CFDictionaryGetCount(Mutable);
  int v38 = Count;
  uint64_t v39 = (const void **)PF_ALLOCATE_OBJECT_ARRAY(Count);
  CFDictionaryGetKeysAndValues(Mutable, 0LL, v39);
  CFRelease(Mutable);
  unsigned int v43 = customCharAt;
  uint64_t v44 = v20;
  CFMergeSortArray();
  *CFIndex v40 = v39;
  *unint64_t v41 = v38;
  if ((unint64_t)a2 >= 0x201)
  {
    NSZoneFree(0LL, v19);
    NSZoneFree(0LL, v15);
  }

void freeArrayOfCFObjects(const void **ptr, int a2)
{
  if (a2 >= 1)
  {
    uint64_t v3 = a2;
    uint64_t v4 = ptr;
    do
    {
      id v5 = *v4++;
      CFRelease(v5);
      --v3;
    }

    while (v3);
  }

  PF_FREE_OBJECT_ARRAY(ptr);
}

unint64_t sortAsLong(uint64_t a1, uint64_t a2)
{
  return (a1 > a2) - (unint64_t)(a1 < a2);
}

uint64_t customCharAt(const __CFArray *a1, uint64_t a2)
{
  return *((unsigned __int8 *)CFArrayGetValueAtIndex(a1, 0LL) + a2);
}

uint64_t _PF_Handler_Public_SetProperty( unsigned int *a1, unint64_t a2, void *a3, uint64_t a4, void *a5)
{
  if (!a5) {
    return [a1 _setGenericValue:a3 forKey:a4 withIndex:a2 flags:1];
  }
  uint64_t v10 = *(void *)(*((void *)_PFEntityForManagedObject(a1) + 19) + 72LL);
  if (v10 && a3 && (*(_BYTE *)(v10 + a2) & 1) != 0 && [a3 isNSDate])
  {
    uint64_t v11 = (void *)MEMORY[0x189607968];
    [a3 timeIntervalSinceReferenceDate];
    objc_msgSend(v11, "numberWithDouble:");
  }

  if (*a5 == _NSKeyValueIvarSetterClass)
  {
    [a1 willChangeValueForKey:a4];
    _NSSetUsingKeyValueSetter();
    uint64_t result = [a1 didChangeValueForKey:a4];
  }

  else
  {
    uint64_t result = _NSSetUsingKeyValueSetter();
  }

  uint64_t v13 = a1[5];
  if ((_DWORD)v13) {
    uint64_t v14 = (char *)a1 + v13;
  }
  else {
    uint64_t v14 = 0LL;
  }
  unint64_t v15 = &v14[-(((unint64_t)a1[4] >> 22) & 0x3FC)];
  v15[a2 >> 3] |= 1 << (a2 & 7);
  return result;
}

void *_PF_Handler_Public_GetProperty(id **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = *((unsigned int *)a1 + 5);
    if ((_DWORD)v6) {
      unsigned int v7 = (char *)a1 + v6;
    }
    else {
      unsigned int v7 = 0LL;
    }
    uint64_t v8 = (void *)_NSGetUsingKeyValueGetter();
    uint64_t v9 = *(void *)(*((void *)_PFEntityForManagedObject(a1) + 19) + 72LL);
    if (v9 && (*(_BYTE *)(v9 + a2) & 0x10) != 0 && v8 && [v8 isNSNumber])
    {
      uint64_t v10 = (void *)MEMORY[0x189603F50];
      [v8 doubleValue];
      uint64_t v8 = (void *)objc_msgSend(v10, "dateWithTimeIntervalSinceReferenceDate:");
    }
  }

  else
  {
    uint64_t v8 = (void *)[a1 _genericValueForKey:a3 withIndex:a2 flags:1];
    if (!a1) {
      return v8;
    }
  }

  if ((*((_BYTE *)a1 + 17) & 0x40) != 0)
  {
    uint64_t v12 = a1;
    *((_DWORD *)a1 + 4) &= ~0x4000u;
  }

  return v8;
}

void _PF_ManagedObject_WillChangeValueForKeyIndex( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, char a5)
{
  int v9 = *(_DWORD *)(a1 + 16);
  uint64_t v10 = _PFEntityForManagedObject((id)a1);
  if (!v10)
  {
    uint64_t v11 = 0LL;
    if ((v9 & 0x40) != 0) {
      goto LABEL_3;
    }
LABEL_36:
    [(id)a1 willAccessValueForKey:a3];
    if (a4 == 0x7FFFFFFFFFFFFFFFLL) {
      goto LABEL_4;
    }
    goto LABEL_6;
  }

  uint64_t v11 = (void *)v10[14];
  if ((v9 & 0x40) == 0) {
    goto LABEL_36;
  }
LABEL_3:
  if (a4 == 0x7FFFFFFFFFFFFFFFLL)
  {
LABEL_4:
    char v12 = 1;
    goto LABEL_12;
  }

  _PF_Handler_WillAccess_Property((id *)a1, (uint64_t)sel_willAccessValueForKey_, a4);
LABEL_6:
  char v12 = 0;
  unint64_t v13 = v11[10];
  BOOL v14 = a4 >= v13;
  unint64_t v15 = a4 - v13;
  if (!v14 || v15 >= v11[11])
  {
LABEL_12:
    int v20 = 0;
    uint64_t v17 = 0LL;
    int v19 = 0;
    if ((*(_BYTE *)(a1 + 17) & 0x80) == 0) {
      goto LABEL_13;
    }
    goto LABEL_48;
  }

  uint64_t v16 = -[objc_class _transientPropertiesChangesMask](object_getClass((id)a1), "_transientPropertiesChangesMask");
  uint64_t v17 = v16;
  unint64_t v18 = *(unsigned int *)(a1 + 16);
  int v19 = 1;
  if ((v18 & 0x8000) == 0)
  {
    char v12 = 0;
    if ((v9 & 0x1000) != 0) {
      goto LABEL_25;
    }
    goto LABEL_14;
  }

  uint64_t v33 = *(unsigned int *)(a1 + 20);
  if ((_DWORD)v33) {
    uint64_t v34 = a1 + v33;
  }
  else {
    uint64_t v34 = 0LL;
  }
  int v35 = *(unsigned __int8 *)(v34 - ((v18 >> 22) & 0x3FC) + (a4 >> 3));
  int v36 = 1 << (a4 & 7);
  char v12 = 0;
  if ((v36 & v35) == 0 || v16 == 0)
  {
    int v20 = 1;
    goto LABEL_48;
  }

  int v20 = 1;
  if ((v36 & *(_BYTE *)(v16 + (a4 >> 3))) == 0)
  {
LABEL_48:
    [(id)_insertion_fault_handler fulfillFault:a1 withContext:*(void *)(a1 + 32) forIndex:a4];
    int v19 = v20;
    if ((v9 & 0x1000) != 0) {
      goto LABEL_25;
    }
    goto LABEL_14;
  }

void *_PF_ManagedObject_DidChangeValueForKeyIndex( void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  id v5 = result;
  int v6 = *((_DWORD *)result + 4);
  if ((v6 & 0x2000) == 0)
  {
    uint64_t result = _PFEntityForManagedObject(result);
    uint64_t v9 = result[14];
    unint64_t v10 = *(void *)(v9 + 32);
    unint64_t v11 = *(void *)(v9 + 40);
    char v12 = (void *)v5[6];
    if (v12)
    {
      if (*v12) {
        goto LABEL_8;
      }
    }

    BOOL v14 = a4 >= v10;
    unint64_t v13 = a4 - v10;
    BOOL v14 = !v14 || v13 >= v11;
    if (!v14) {
LABEL_8:
    }
      uint64_t result = (void *)_NSObjectDidChangeVFKImp(v5, a2, a3);
  }

  if ((v6 & 0x1000) == 0) {
    *((_DWORD *)v5 + 4) &= ~0x800u;
  }
  if ((v6 & 0x40) == 0) {
    return (void *)[v5 didAccessValueForKey:a3];
  }
  return result;
}

void _PF_ManagedObject_WillChangeValueForKeywithSetMutation( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  int v12 = a1[4];
  if ((v12 & 0x40) != 0)
  {
    if (a6 != 0x7FFFFFFFFFFFFFFFLL) {
      _PF_Handler_WillAccess_Property((id *)a1, (uint64_t)sel_willAccessValueForKey_, a6);
    }
  }

  else
  {
    [a1 willAccessValueForKey:a3];
  }

  if ((*((_BYTE *)a1 + 17) & 0x80) != 0)
  {
    [(id)_insertion_fault_handler fulfillFault:a1 withContext:*((void *)a1 + 4) forIndex:a6];
    if ((v12 & 0x1000) != 0)
    {
LABEL_6:
      if ((v12 & 0x2000) != 0) {
        return;
      }
      goto LABEL_7;
    }
  }

  else if ((v12 & 0x1000) != 0)
  {
    goto LABEL_6;
  }

  if (a6 != 0x7FFFFFFFFFFFFFFFLL || (v12 & 0x400000) == 0) {
    _PFFastMOCObjectWillChange(*((void *)a1 + 4), a1);
  }
  a1[4] |= 0x800u;
  if ((v12 & 0x2000) == 0) {
LABEL_7:
  }
    off_18C4AB9A0(a1, a2, a3, a4, a5);
}

uint64_t _PF_ManagedObject_DidChangeValueForKeywithSetMutation(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (_DWORD *)result;
  int v5 = *(_DWORD *)(result + 16);
  if ((v5 & 0x2000) != 0)
  {
    if ((v5 & 0x1000) != 0) {
      goto LABEL_3;
    }
  }

  else
  {
    uint64_t result = _NSObjectDidChangeForKeywithSetMutationImp(result, a2, a3);
    if ((v5 & 0x1000) != 0)
    {
LABEL_3:
      if ((v5 & 0x40) != 0) {
        return result;
      }
      return [v4 didAccessValueForKey:a3];
    }
  }

  v4[4] &= ~0x800u;
  if ((v5 & 0x40) == 0) {
    return [v4 didAccessValueForKey:a3];
  }
  return result;
}

void sub_186740DFC(_Unwind_Exception *a1)
{
}

uint64_t _PFManagedObject_coerceValueForKeyWithDescription( uint64_t a1, void **a2, const __CFString *a3, void *a4)
{
  unsigned int v7 = a2;
  uint64_t v50 = *MEMORY[0x1895F89C0];
  uint64_t v9 = *a2;
  else {
    unint64_t v10 = v9;
  }
  uint64_t result = [a4 _propertyType];
  if (result != 4)
  {
    if (result != 2)
    {
      uint64_t v9 = v10;
      goto LABEL_88;
    }

    if (v10)
    {
      uint64_t v12 = [a4 attributeType];
      if (v12 > 699)
      {
        if (v12 > 899)
        {
          switch(v12)
          {
            case 900LL:
              uint64_t result = [v10 isNSDate];
              if ((result & 1) != 0) {
                return result;
              }
              break;
            case 1000LL:
              if ([a4 isFileBackedFuture])
              {
                objc_opt_class();
                uint64_t result = objc_opt_isKindOfClass();
                if ((result & 1) != 0) {
                  return result;
                }
              }

              else
              {
                uint64_t result = [v10 isNSData];
                if ((result & 1) != 0) {
                  return result;
                }
              }

              break;
            case 1800LL:
              if ([a4 usesMergeableStorage])
              {
                objc_opt_class();
                uint64_t result = objc_opt_respondsToSelector();
                if ((result & 1) != 0) {
                  return result;
                }
              }

              break;
          }

          goto LABEL_59;
        }

        if (v12 == 700)
        {
          uint64_t result = [v10 isNSString];
          if ((result & 1) != 0) {
            return result;
          }
          goto LABEL_59;
        }

        if (v12 != 800)
        {
LABEL_59:
          if (![a4 isFileBackedFuture])
          {
            if ([a4 usesMergeableStorage])
            {
              unsigned int v7 = (void **)MEMORY[0x189603F70];
              uint64_t v9 = (void *)*MEMORY[0x189603A60];
              uint64_t v28 = [NSString stringWithFormat:@"Using mergeable storage with the attribute %@ requires conformance to %@.", objc_msgSend(a4, "name"), NSStringFromProtocol((Protocol *)&unk_18C69CAA0)];
              goto LABEL_51;
            }

            uint64_t v33 = [a4 _attributeValueClass];
            if (!v33)
            {
              uint64_t result = [a4 isTransient];
              if ((result & 1) == 0)
              {
                uint64_t result = [a4 attributeType];
                if (result != 1800)
                {
                  unsigned int v7 = (void **)MEMORY[0x189603F70];
                  uint64_t v9 = (void *)*MEMORY[0x189603A58];
                  uint64_t v28 = objc_msgSend( NSString,  "stringWithFormat:",  @"Cannot set value for attribute with undefined type: property = %@; entity = %@; value = %@",
                          a3,
                          [a4 entity],
                          v10,
                          v46);
                  goto LABEL_51;
                }
              }

              goto LABEL_88;
            }

            uint64_t v34 = (void *)v33;
            uint64_t result = objc_opt_isKindOfClass();
            if ((result & 1) != 0) {
              goto LABEL_88;
            }
            uint64_t v4 = (unint64_t *)a3;
            if ([v10 isNSNumber])
            {
              a3 = (const __CFString *)0x189607000LL;
              if ([v34 isSubclassOfClass:objc_opt_class()])
              {
                uint64_t result = objc_msgSend(MEMORY[0x189607858], "decimalNumberWithString:", objc_msgSend(v10, "stringValue"));
                uint64_t v9 = (void *)result;
                goto LABEL_88;
              }
            }

            unsigned int v7 = (void **)MEMORY[0x189603F70];
            uint64_t v9 = (void *)*MEMORY[0x189603A60];
            uint64_t v45 = objc_msgSend( NSString,  "stringWithFormat:",  @"Unacceptable type of value for attribute: property = %@; desired type = %@; given type = %@; value = %@.",
                    v4,
                    [a4 attributeValueClassName],
                    objc_opt_class(),
                    v10);
            goto LABEL_110;
          }

          unsigned int v7 = (void **)MEMORY[0x189603F70];
          a4 = (void *)*MEMORY[0x189603A60];
          uint64_t v43 = objc_msgSend( NSString,  "stringWithFormat:",  @"Unacceptable type of value for attribute: property = %@; desired type = %@; given type = %@; value = %@.",
                  a3,
                  @"A class implementing the NSFileBackedFuture protocol",
                  objc_opt_class(),
                  v10);
LABEL_114:
          uint64_t v9 = (void *)v43;
          uint64_t v30 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  a3,  @"key",  v10,  @"value",  0);
          unint64_t v31 = v7;
          unint64_t v32 = a4;
          CFAllocatorRef v42 = v9;
          goto LABEL_86;
        }
      }

      else if (v12 <= 299)
      {
        if (v12 != 100 && v12 != 200) {
          goto LABEL_59;
        }
      }

      else if (v12 != 300 && v12 != 500 && v12 != 600)
      {
        goto LABEL_59;
      }

      uint64_t result = [v10 isNSNumber];
      if ((result & 1) != 0) {
        return result;
      }
      goto LABEL_59;
    }

void sub_186745590(_Unwind_Exception *a1)
{
}

void sub_18674727C()
{
}

Class sub_186747288(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18674728CLL);
  }
  objc_terminate();
  return override_instace_class(v2);
}

Class override_instace_class(void *a1)
{
  Class Class = object_getClass(a1);
  return class_getSuperclass(Class);
}

Class override_class_superclass(objc_class *a1)
{
  Class Superclass = class_getSuperclass(a1);
  return class_getSuperclass(Superclass);
}

id _PFEntityForClass(objc_class *a1)
{
  uint64_t v88 = *MEMORY[0x1895F89C0];
  uint64_t v2 = -[objc_class _PFMOClassFactoryData](a1, "_PFMOClassFactoryData");
  if (!v2 || (id v3 = *(id *)(v2 + 8)) == 0LL)
  {
    Name = class_getName(a1);
    if (!strncmp(Name, "NSManagedObject", 0xFuLL)) {
      return 0LL;
    }
    id AssociatedObject = objc_getAssociatedObject(a1, PFEntityDescriptionAssociationKey);
    if (![AssociatedObject count]) {
      goto LABEL_18;
    }
    __int128 v82 = 0u;
    __int128 v83 = 0u;
    __int128 v80 = 0u;
    __int128 v81 = 0u;
    uint64_t v12 = [AssociatedObject countByEnumeratingWithState:&v80 objects:v87 count:16];
    if (!v12) {
      goto LABEL_18;
    }
    uint64_t v13 = v12;
    id v3 = 0LL;
    uint64_t v14 = *(void *)v81;
    while (2)
    {
      for (uint64_t i = 0LL; i != v13; ++i)
      {
        if (*(void *)v81 != v14) {
          objc_enumerationMutation(AssociatedObject);
        }
        uint64_t v16 = *(void *)(*((void *)&v80 + 1) + 8 * i);
        if (v16)
        {
          id WeakRetained = objc_loadWeakRetained((id *)(v16 + 8));
          if (WeakRetained)
          {
            if (v3 && WeakRetained != v3)
            {

              os_unfair_lock_lock_with_options();
              CFStringRef v25 = CFStringCreateWithCString(0LL, Name, 0x8000100u);
              CFMutableArrayRef Mutable = (const __CFSet *)qword_18C4AB9E0;
              if (!qword_18C4AB9E0)
              {
                CFMutableArrayRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605258]);
                qword_18C4AB9E0 = (uint64_t)Mutable;
              }

              int v27 = CFSetContainsValue(Mutable, v25);
              if (v27)
              {
                CFRelease(v25);
                os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C4AB9C0);
              }

              else
              {
                CFSetAddValue((CFMutableSetRef)qword_18C4AB9E0, v25);
                CFRelease(v25);
                os_unfair_lock_unlock((os_unfair_lock_t)&unk_18C4AB9C0);
                _NSCoreDataLog( 2LL,  (uint64_t)@"Multiple NSEntityDescriptions claim the NSManagedObject subclass '%s' so +entity is unable to disambiguate.",  v28,  v29,  v30,  v31,  v32,  v33,  (uint64_t)Name);
              }

              __int128 v78 = 0u;
              __int128 v79 = 0u;
              __int128 v76 = 0u;
              __int128 v77 = 0u;
              uint64_t v34 = [AssociatedObject countByEnumeratingWithState:&v76 objects:v86 count:16];
              if (v34)
              {
                uint64_t v35 = v34;
                uint64_t v36 = *(void *)v77;
                do
                {
                  for (uint64_t j = 0LL; j != v35; ++j)
                  {
                    if (*(void *)v77 != v36) {
                      objc_enumerationMutation(AssociatedObject);
                    }
                    uint64_t v38 = *(void *)(*((void *)&v76 + 1) + 8 * j);
                    if (v38)
                    {
                      id v39 = objc_loadWeakRetained((id *)(v38 + 8));
                      if (v39)
                      {
                        uint64_t v40 = v39;
                        if (!v27)
                        {
                          uint64_t v41 = [v39 name];
                          [v40 managedObjectModel];
                          _NSCoreDataLog( 2LL,  (uint64_t)@" \t '%@' (%p) from NSManagedObjectModel (%p) claims '%s'.",  v42,  v43,  v44,  v45,  v46,  v47,  v41);
                        }
                      }
                    }
                  }

                  uint64_t v35 = [AssociatedObject countByEnumeratingWithState:&v76 objects:v86 count:16];
                }

                while (v35);
              }

              char v24 = 1;
              goto LABEL_37;
            }

            id v3 = WeakRetained;
          }
        }
      }

      uint64_t v13 = [AssociatedObject countByEnumeratingWithState:&v80 objects:v87 count:16];
      if (v13) {
        continue;
      }
      break;
    }

    if (!v3)
    {
LABEL_18:
      _NSCoreDataLog( 1LL,  (uint64_t)@"No NSEntityDescriptions in any model claim the NSManagedObject subclass '%s' so +entity is confused.  Have you loaded your NSManagedObjectModel yet ?",  v6,  v7,  v8,  v9,  v10,  v11,  (uint64_t)Name);
      char v24 = 0;
LABEL_37:
      unsigned int v48 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 712);
      if (v48)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          uint64_t v49 = objc_msgSend((id)objc_msgSend(v48, "persistentStoreCoordinator"), "managedObjectModel");
          if (v49)
          {
            unsigned int v56 = (void *)v49;
            uint64_t v57 = (void *)[NSString stringWithUTF8String:Name];
            __int128 v72 = 0u;
            __int128 v73 = 0u;
            __int128 v74 = 0u;
            __int128 v75 = 0u;
            uint64_t v58 = [v56 countByEnumeratingWithState:&v72 objects:v85 count:16];
            if (v58)
            {
              uint64_t v59 = v58;
              id v3 = 0LL;
              uint64_t v60 = *(void *)v73;
              while (2)
              {
                for (uint64_t k = 0LL; k != v59; ++k)
                {
                  if (*(void *)v73 != v60) {
                    objc_enumerationMutation(v56);
                  }
                  uint64_t v62 = *(void **)(*((void *)&v72 + 1) + 8 * k);
                  uint64_t v63 = [v62 managedObjectClassName];
                  if (v63 && [v57 isEqualToString:v63])
                  {
                    if (v3)
                    {
                      [v62 name];
                      [v3 name];
                      _NSCoreDataLog( 1LL,  (uint64_t)@"Multiple NSEntityDescriptions in NSManagedObjectModel (%p) claim the NSManagedObject subclass '%s' so +entity is unable to disambiguate.  Both entities '%@' (%p) and '%@' (%p)",  v65,  v66,  v67,  v68,  v69,  v70,  (uint64_t)v56);
                      goto LABEL_59;
                    }

                    id v3 = v62;
                  }
                }

                uint64_t v59 = [v56 countByEnumeratingWithState:&v72 objects:v85 count:16];
                if (v59) {
                  continue;
                }
                break;
              }

              if (v3) {
                char v64 = v24;
              }
              else {
                char v64 = 1;
              }
              if ((v64 & 1) == 0)
              {
                id v84 = +[_PFWeakReference weakReferenceWithObject:]((uint64_t)&OBJC_CLASS____PFWeakReference, (uint64_t)v3);
                objc_setAssociatedObject( a1,  PFEntityDescriptionAssociationKey,  (id)[MEMORY[0x189603F18] arrayWithObjects:&v84 count:1],  (void *)0x303);
                return v3;
              }

              if (v3) {
                return v3;
              }
            }
          }

          else
          {
            _NSCoreDataLog( 1LL,  (uint64_t)@"This NSManagedObjectContext (%p) does not have a coordinator and model assigned yet so +entity on '%s' is sad.",  v50,  v51,  v52,  v53,  v54,  v55,  (uint64_t)v48);
          }
        }
      }

LABEL_59:
      _NSCoreDataLog( 1LL,  (uint64_t)@"+[%s entity] Failed to find a unique match for an NSEntityDescription to a managed object subclass",  v18,  v19,  v20,  v21,  v22,  v23,  (uint64_t)Name);
      return 0LL;
    }
  }

  return v3;
}

          ++v34;
        }

        while (v32 != v34);
        id v39 = [v31 countByEnumeratingWithState:&v53 objects:v66 count:16];
        uint64_t v32 = v39;
      }

      while (v39);
    }

    uint64_t v40 = (void *)[v30 _uniquenessConstraintsAsFetchIndexes];
    uint64_t v51 = 0u;
    uint64_t v52 = 0u;
    uint64_t v49 = 0u;
    uint64_t v50 = 0u;
    uint64_t v41 = [v40 countByEnumeratingWithState:&v49 objects:v65 count:16];
    if (v41)
    {
      uint64_t v42 = *(void *)v50;
      do
      {
        for (uint64_t j = 0LL; j != v41; ++j)
        {
          if (*(void *)v50 != v42) {
            objc_enumerationMutation(v40);
          }
          uint64_t v44 = -[NSSQLiteAdapter generateDropBinaryIndexStatementsForIndex:onEntity:]( (uint64_t)a1,  *(void *)(*((void *)&v49 + 1) + 8 * j),  a2);
          if (v44) {
            [v48 addObjectsFromArray:v44];
          }
        }

        uint64_t v41 = [v40 countByEnumeratingWithState:&v49 objects:v65 count:16];
      }

      while (v41);
    }
  }

  return v48;
}

            uint64_t v17 = v129;
LABEL_60:
            if (v47)
            {
              uint64_t v51 = &unk_189F044D0;
              if (v39 == 2) {
                uint64_t v51 = &unk_189F044B8;
              }
              v145[0] = v51;
              v145[1] = v47;
              BOOL v15 = [MEMORY[0x189603F18] arrayWithObjects:v145 count:2];

              a5 = v126;
              a3 = theDict;
              if (!v15) {
                goto LABEL_137;
              }
              goto LABEL_88;
            }

    if (*((_BYTE *)v143 + 24))
    {
      uint64_t v66 = MEMORY[0x1895F87A8];
      v131[0] = MEMORY[0x1895F87A8];
      v131[1] = 3221225472LL;
      v131[2] = __98__PFCloudKitSerializer_newCKRecordsFromObject_fullyMaterializeRecords_includeRelationships_error___block_invoke_2;
      v131[3] = &unk_189EAABC8;
      v131[4] = v121;
      [obj sortUsingComparator:v131];
      uint64_t v129 = 0u;
      unint64_t v130 = 0u;
      int v127 = 0u;
      unint64_t v128 = 0u;
      uint64_t v12 = (id)[obj countByEnumeratingWithState:&v127 objects:v150 count:16];
      uint64_t v67 = v12;
      if (v12)
      {
        uint64_t v68 = *(void *)v128;
        do
        {
          uint64_t v69 = 0LL;
          do
          {
            if (*(void *)v128 != v68) {
              objc_enumerationMutation(obj);
            }
            uint64_t v70 = *(void **)(*((void *)&v127 + 1) + 8LL * (void)v69);
            if (+[PFCloudKitSerializer shouldTrackAttribute:]((uint64_t)&OBJC_CLASS___PFCloudKitSerializer, v70))
            {
              v125[0] = v66;
              v125[1] = 3221225472LL;
              v125[2] = __98__PFCloudKitSerializer_newCKRecordsFromObject_fullyMaterializeRecords_includeRelationships_error___block_invoke_3;
              void v125[3] = &unk_189EAABF0;
              v125[4] = v70;
              v125[5] = v121;
              unsigned int v126 = a3;
              v125[6] = a1;
              v125[7] = v119;
              v125[8] = a2;
              v125[9] = &v142;
              v125[10] = &v136;
              +[_PFRoutines wrapBlockInGuardedAutoreleasePool:]( &OBJC_CLASS____PFRoutines,  "wrapBlockInGuardedAutoreleasePool:",  v125);
            }

            uint64_t v69 = (char *)v69 + 1;
          }

          while (v67 != v69);
          uint64_t v12 = (id)[obj countByEnumeratingWithState:&v127 objects:v150 count:16];
          uint64_t v67 = v12;
        }

        while (v12);
      }

      if (a4)
      {
        v124[0] = v66;
        v124[1] = 3221225472LL;
        v124[2] = __98__PFCloudKitSerializer_newCKRecordsFromObject_fullyMaterializeRecords_includeRelationships_error___block_invoke_4;
        v124[3] = &unk_189EAAC18;
        v124[4] = a2;
        v124[5] = a1;
        v124[6] = v8;
        v124[7] = v117;
        v124[8] = v116;
        v124[9] = v113;
        v124[12] = &v136;
        v124[13] = &v142;
        v124[10] = v115;
        v124[11] = v119;
        uint64_t v12 = (id)objc_msgSend( (id)objc_msgSend(v114, "relationshipsByName"),  "enumerateKeysAndObjectsUsingBlock:",  v124);
      }
    }

    if (*((_BYTE *)v143 + 24))
    {
      if (v119)
      {
        unint64_t v71 = (void *)MEMORY[0x186E3E5D8](v12);
        else {
          __int128 v72 = __ckLoggingOverride;
        }
        __int128 v73 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Serializer has finished creating record: %@\nModified Fields: %@"];
        __int128 v74 = [*(id *)(a1 + 24) useDeviceToDeviceEncryption];
        __int128 v75 = v119;
        if (v74) {
          __int128 v75 = (void *)[v119 encryptedValueStore];
        }
        __int128 v77 = v121;
        __int128 v76 = obj;
        [v75 changedKeys];
        _NSCoreDataLog( v72,  v73,  v78,  v79,  v80,  v81,  v82,  v83,  (uint64_t)"-[PFCloudKitSerializer newCKRecordsFromObject:fullyMaterializeRecords:includeRelationships:error:]");
        objc_autoreleasePoolPop(v71);
        [v115 addObject:v119];
        goto LABEL_83;
      }

      unint64_t v93 = [NSString stringWithUTF8String:"Supposedly serialization succeeded but there's no record: %@"];
      _NSCoreDataLog(17LL, v93, v94, v95, v96, v97, v98, v99, v137[5]);
      unsigned int v91 = (os_log_s *)__pflogFaultLog;
      __int128 v77 = v121;
      __int128 v76 = obj;
      if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
LABEL_83:

        goto LABEL_84;
      }

      unint64_t v110 = (const char *)v137[5];
      *(_DWORD *)buf = 138412290;
      uint64_t v147 = v110;
      unint64_t v92 = "CoreData: Supposedly serialization succeeded but there's no record: %@";
    }

    else
    {
      __int128 v77 = v121;
      __int128 v76 = obj;
      if (v137[5]) {
        goto LABEL_83;
      }
      id v84 = [NSString stringWithUTF8String:"Object serialization failed but did not set an error: %@"];
      _NSCoreDataLog(17LL, v84, v85, v86, v87, v88, v89, v90, (uint64_t)a2);
      unsigned int v91 = (os_log_s *)__pflogFaultLog;
      __int128 v77 = v121;
      __int128 v76 = obj;
      if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 138412290;
      uint64_t v147 = (const char *)a2;
      unint64_t v92 = "CoreData: Object serialization failed but did not set an error: %@";
    }

    _os_log_fault_impl(&dword_186681000, v91, OS_LOG_TYPE_FAULT, v92, buf, 0xCu);
    goto LABEL_83;
  }

  *((_BYTE *)v143 + 24) = 0;
  uint64_t v13 = (id)v137[5];
LABEL_84:

  if (!*((_BYTE *)v143 + 24))
  {
    unsigned int v100 = (id)v137[5];
    if (v100)
    {
      if (a5) {
        *a5 = v100;
      }
    }

    else
    {
      uint64_t v101 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v101,  v102,  v103,  v104,  v105,  v106,  v107,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitSerializer.m");
      unsigned int v108 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        uint64_t v147 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitSerializer.m";
        unint64_t v148 = 1024;
        unint64_t v149 = 612;
        _os_log_fault_impl( &dword_186681000,  v108,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }

    unint64_t v115 = 0LL;
  }

  v137[5] = 0LL;
  _Block_object_dispose(&v136, 8);
  _Block_object_dispose(&v142, 8);
  return v115;
}

#error "186747C54: call analysis failed (funcsize=67)"
BOOL __cdecl +[NSManagedObject _isGeneratedClass](id a1, SEL a2)
{
  return 0;
}

void _PF_Handler_Primitive_SetProperty(char **a1, unint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_setValue_forKey_);
  }
  _PF_CopyOnWrite_Snapshot(a1);
  if (a5)
  {
    _NSSetUsingKeyValueSetter();
  }

  else
  {
    id v9 = a3;
    snapshot_set_value_as_object(a1[3], a2, v9, v10, v11, v12, v13, v14);
  }

  uint64_t v15 = *((unsigned int *)a1 + 5);
  if ((_DWORD)v15) {
    uint64_t v16 = (char *)a1 + v15;
  }
  else {
    uint64_t v16 = 0LL;
  }
  uint64_t v17 = &v16[-(((unint64_t)*((unsigned int *)a1 + 4) >> 22) & 0x3FC)];
  v17[a2 >> 3] |= 1 << (a2 & 7);
}

void _PF_Handler_Primitive_GetProperty( id **a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!_PF_Threading_Debugging_level)
  {
    if (a1) {
      goto LABEL_3;
    }
LABEL_6:
    unsigned int v11 = MEMORY[0x10];
    goto LABEL_7;
  }

  _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_valueForKey_);
  if (!a1) {
    goto LABEL_6;
  }
LABEL_3:
  unsigned int v11 = *((_DWORD *)a1 + 4);
  if ((v11 & 0x4000) != 0)
  {
    uint64_t v12 = a1;
    unsigned int v11 = (_DWORD)a1[2] & 0xFFFFBFFF;
    *((_DWORD *)a1 + 4) = v11;
  }

id *_PF_Handler_WillAccess_Property(id *result, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = result;
  if (!_PF_Threading_Debugging_level)
  {
    if (result) {
      goto LABEL_3;
    }
LABEL_6:
    unsigned int v5 = MEMORY[0x10];
    goto LABEL_7;
  }

  uint64_t result = (id *)_PFAssertSafeMultiThreadedAccess_impl( [result managedObjectContext],  sel_willAccessValueForKey_);
  if (!v4) {
    goto LABEL_6;
  }
LABEL_3:
  unsigned int v5 = *((_DWORD *)v4 + 4);
  if ((v5 & 0x4000) != 0)
  {
    uint64_t result = v4;
    unsigned int v5 = (_DWORD)v4[2] & 0xFFFFBFFF;
    *((_DWORD *)v4 + 4) = v5;
  }

uint64_t _sharedIMPL_vfk_core(id **a1, uint64_t a2, unint64_t a3)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_valueForKey_);
  }
  unsigned int v5 = *((_DWORD *)a1 + 4);
  uint64_t v6 = (unint64_t *)_PFEntityForManagedObject(a1);
  uint64_t v7 = *(void *)(*(void *)(*(void *)(v6[12] + 16) + 40LL) + 8 * a3);
  uint64_t v14 = *(void *)(_kvcPropertysPrimitiveGetters(v6) + 8 * a3);
  if ((v5 & 0x40) != 0)
  {
    unsigned int v15 = *((_DWORD *)a1 + 4);
    if ((v15 & 0x4000) != 0)
    {
      uint64_t v23 = a1;
      unsigned int v15 = (_DWORD)a1[2] & 0xFFFFBFFF;
      *((_DWORD *)a1 + 4) = v15;
    }
  }

  else
  {
    [a1 willAccessValueForKey:v7];
    unsigned int v15 = *((_DWORD *)a1 + 4);
  }

  uint64_t v16 = *((unsigned int *)a1 + 5);
  if ((_DWORD)v16) {
    uint64_t v17 = (char *)a1 + v16;
  }
  else {
    uint64_t v17 = 0LL;
  }
  uint64_t v18 = a1[3];
  if (v18)
  {
    if (v14) {
      uint64_t v19 = _NSGetUsingKeyValueGetter();
    }
    else {
      snapshot_get_value_as_object(v18, a3, v8, v9, v10, v11, v12, v13);
    }
    uint64_t v20 = v19;
    if ((v5 & 0x40) == 0) {
      [a1 didAccessValueForKey:v7];
    }
  }

  else
  {
    uint64_t v20 = 0LL;
    unsigned int v21 = *((_DWORD *)a1 + 4);
    if ((v21 & 0x38000) != 0x10000 && (v21 & 0x80) == 0)
    {
      _NSCoreDataLog( 1LL,  (uint64_t)@"NULL _cd_rawData but the object is not being turned into a fault",  v8,  v9,  v10,  v11,  v12,  v13,  v24);
      return 0LL;
    }
  }

  return v20;
}

void *_sharedIMPL_setvfk_core(char **a1, uint64_t a2, void *a3, unint64_t a4)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_setValue_forKey_);
  }
  uint64_t v20 = a3;
  uint64_t v7 = _PFEntityForManagedObject(a1);
  uint64_t v8 = *(void **)(v7[12] + 24LL + 8 * a4);
  uint64_t v9 = *(void *)(_kvcPropertysPrimitiveSetters((uint64_t)v7) + 8 * a4);
  uint64_t v10 = *(void *)(*(void *)(v7[12] + 16LL) + 40LL);
  uint64_t v11 = *(const __CFString **)(v10 + 8 * a4);
  int v12 = *((_DWORD *)a1 + 4);
  if ((v12 & 0x40000) != 0) {
    _PF_ManagedObject_WillChangeValueForKeyIndex((uint64_t)a1, (uint64_t)sel_willChangeValueForKey_, (uint64_t)v11, a4, 0);
  }
  else {
    [a1 willChangeValueForKey:*(void *)(v10 + 8 * a4)];
  }
  _PF_CopyOnWrite_Snapshot(a1);
  _PFManagedObject_coerceValueForKeyWithDescription((uint64_t)a1, &v20, v11, v8);
  if (v9)
  {
    _NSSetUsingKeyValueSetter();
    if ((v12 & 0x40000) != 0) {
      return _PF_ManagedObject_DidChangeValueForKeyIndex(a1, (uint64_t)sel_didChangeValueForKey_, (uint64_t)v11, a4);
    }
  }

  else
  {
    id v13 = v20;
    snapshot_set_value_as_object(a1[3], a4, v13, v14, v15, v16, v17, v18);
    if ((v12 & 0x40000) != 0) {
      return _PF_ManagedObject_DidChangeValueForKeyIndex(a1, (uint64_t)sel_didChangeValueForKey_, (uint64_t)v11, a4);
    }
  }

  return (void *)[a1 didChangeValueForKey:v11];
}

void _sharedIMPL_setPvfk_core(char **a1, uint64_t a2, void *a3, unint64_t a4)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_setPrimitiveValue_forKey_);
  }
  uint64_t v18 = a3;
  uint64_t v7 = *((void *)_PFEntityForManagedObject(a1) + 12);
  uint64_t v8 = *(void **)(v7 + 24 + 8 * a4);
  uint64_t v9 = *(const __CFString **)(*(void *)(*(void *)(v7 + 16) + 40LL) + 8 * a4);
  _PF_CopyOnWrite_Snapshot(a1);
  _PFManagedObject_coerceValueForKeyWithDescription((uint64_t)a1, &v18, v9, v8);
  uint64_t v10 = *((unsigned int *)a1 + 5);
  if ((_DWORD)v10) {
    uint64_t v11 = (char *)a1 + v10;
  }
  else {
    uint64_t v11 = 0LL;
  }
  v11[(a4 >> 3) - (((unint64_t)*((unsigned int *)a1 + 4) >> 22) & 0x3FC)] |= 1 << (a4 & 7);
  id v12 = v18;
  snapshot_set_value_as_object(a1[3], a4, v12, v13, v14, v15, v16, v17);
}

void _spvfk_0(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_1(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_2(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_3(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_4(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_5(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_6(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_7(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_8(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_9(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_10(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_11(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_12(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_13(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_14(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_15(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_16(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_17(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_18(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_19(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_20(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_21(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_22(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_23(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_24(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_25(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_26(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_27(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_28(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_29(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_30(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_31(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_32(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_33(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_34(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_35(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_36(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_37(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_38(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_39(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_40(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_41(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_42(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_43(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_44(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_45(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_46(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_47(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_48(char **a1, uint64_t a2, void *a3)
{
}

void _spvfk_49(char **a1, uint64_t a2, void *a3)
{
}

void _pvfk_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_5(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_9(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_10( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_11( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_12( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_13( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_14( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_15( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_16( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_17( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_18( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_19( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_20( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_21( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_22( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_23( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_24( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_25( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_26( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_27( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_28( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_29( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_30( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_31( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_32( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_33( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_34( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_35( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_36( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_37( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_38( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_39( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_40( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_41( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_42( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_43( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_44( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_45( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_46( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_47( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_48( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _pvfk_49( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void *_svfk_0(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0LL);
}

void *_svfk_1(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 1uLL);
}

void *_svfk_2(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 2uLL);
}

void *_svfk_3(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 3uLL);
}

void *_svfk_4(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 4uLL);
}

void *_svfk_5(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 5uLL);
}

void *_svfk_6(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 6uLL);
}

void *_svfk_7(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 7uLL);
}

void *_svfk_8(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 8uLL);
}

void *_svfk_9(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 9uLL);
}

void *_svfk_10(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0xAuLL);
}

void *_svfk_11(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0xBuLL);
}

void *_svfk_12(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0xCuLL);
}

void *_svfk_13(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0xDuLL);
}

void *_svfk_14(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0xEuLL);
}

void *_svfk_15(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0xFuLL);
}

void *_svfk_16(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x10uLL);
}

void *_svfk_17(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x11uLL);
}

void *_svfk_18(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x12uLL);
}

void *_svfk_19(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x13uLL);
}

void *_svfk_20(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x14uLL);
}

void *_svfk_21(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x15uLL);
}

void *_svfk_22(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x16uLL);
}

void *_svfk_23(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x17uLL);
}

void *_svfk_24(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x18uLL);
}

void *_svfk_25(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x19uLL);
}

void *_svfk_26(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x1AuLL);
}

void *_svfk_27(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x1BuLL);
}

void *_svfk_28(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x1CuLL);
}

void *_svfk_29(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x1DuLL);
}

void *_svfk_30(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x1EuLL);
}

void *_svfk_31(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x1FuLL);
}

void *_svfk_32(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x20uLL);
}

void *_svfk_33(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x21uLL);
}

void *_svfk_34(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x22uLL);
}

void *_svfk_35(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x23uLL);
}

void *_svfk_36(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x24uLL);
}

void *_svfk_37(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x25uLL);
}

void *_svfk_38(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x26uLL);
}

void *_svfk_39(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x27uLL);
}

void *_svfk_40(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x28uLL);
}

void *_svfk_41(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x29uLL);
}

void *_svfk_42(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x2AuLL);
}

void *_svfk_43(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x2BuLL);
}

void *_svfk_44(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x2CuLL);
}

void *_svfk_45(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x2DuLL);
}

void *_svfk_46(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x2EuLL);
}

void *_svfk_47(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x2FuLL);
}

void *_svfk_48(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x30uLL);
}

void *_svfk_49(char **a1, uint64_t a2, void *a3)
{
  return _sharedIMPL_setvfk_core(a1, a2, a3, 0x31uLL);
}

LABEL_274:
                    uint64_t v57 = 0LL;
                    uint64_t v55 = 0;
                    LODWORD(v257) = 0;
                    uint64_t v58 = 0LL;
                    uint64_t v62 = 0LL;
                    uint64_t v61 = 0;
                    LODWORD(v59) = 0;
LABEL_275:
                    uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_276:
                    uint64_t v20 = v259;
                    goto LABEL_277;
                  }

                  if (v272)
                  {
                    if (v258) {
                      CFRelease(v258);
                    }
                  }

                  else
                  {
                    v271 = v270;
                  }

                  id v245 = (const char *)v255;
                  strlcpy((char *)v255, v10 + 15, v14);
                  v245[v13 - 34] = 0;
                  v258 = CFStringCreateWithCStringNoCopy(v12, v245, 0x600u, v16);
                  uint64_t v246 = objc_msgSend(v257, "indexForKey:");
                  if (v246 != 0x7FFFFFFFFFFFFFFFLL) {
                    goto LABEL_453;
                  }
                  if (v272)
                  {
                    if (v258) {
                      CFRelease(v258);
                    }
                  }

                  else
                  {
                    v271 = v270;
                  }

                  uint64_t v247 = (char *)v255;
                  *uint64_t v247 = __tolower(*(char *)v255);
                  v258 = CFStringCreateWithCStringNoCopy(v12, v247, 0x600u, v16);
                  uint64_t v246 = objc_msgSend(v257, "indexForKey:");
                  if (v246 != 0x7FFFFFFFFFFFFFFFLL)
                  {
LABEL_453:
                    uint64_t v19 = v246;
                    uint64_t v55 = 0;
                    LODWORD(v257) = 0;
                    uint64_t v62 = 0LL;
                    uint64_t v61 = 0;
                    LODWORD(v59) = 1;
                    uint64_t v58 = _sharedIMPL_replaceObjectInOrderedSetAtIndex_core;
                    uint64_t v57 = "v@:Q@";
                    goto LABEL_276;
                  }

LABEL_452:
                  uint64_t v57 = 0LL;
                  uint64_t v55 = 0;
                  LODWORD(v257) = 0;
                  uint64_t v58 = 0LL;
                  uint64_t v62 = 0LL;
                  uint64_t v61 = 0;
                  LODWORD(v59) = 0;
                  uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
                  goto LABEL_276;
                }
              }

              if (!strncmp("validate", v10, 8uLL) && !strncmp(":error:", &v10[v13 - 7], 7uLL))
              {
                if (v272)
                {
                  if (v258) {
                    CFRelease(v258);
                  }
                }

                else
                {
                  v271 = v270;
                }

                uint64_t v220 = (const char *)v255;
                strlcpy((char *)v255, v10 + 8, v14);
                v220[v13 - 15] = 0;
                uint64_t v221 = CFStringCreateWithCStringNoCopy(v12, v220, 0x600u, v16);
                uint64_t v222 = v257;
                v258 = v221;
                if (objc_msgSend(v257, "indexForKey:") != 0x7FFFFFFFFFFFFFFFLL) {
                  goto LABEL_398;
                }
                if (v272)
                {
                  if (v258) {
                    CFRelease(v258);
                  }
                }

                else
                {
                  v271 = v270;
                }

                uint64_t v230 = (char *)v255;
                *uint64_t v230 = __tolower(*(char *)v255);
                v258 = CFStringCreateWithCStringNoCopy(v12, v230, 0x600u, v16);
                uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
                if (objc_msgSend(v222, "indexForKey:") != 0x7FFFFFFFFFFFFFFFLL)
                {
LABEL_398:
                  uint64_t v231 = v259;
                  if (v272)
                  {
                    if (v258) {
                      CFRelease(v258);
                    }
                  }

                  else
                  {
                    v271 = v270;
                  }

                  InstanceMethod = class_getInstanceMethod(v231, sel__defaultValidation_error_);
                  Implementation = method_getImplementation(InstanceMethod);
                  TypeEncoding = method_getTypeEncoding(InstanceMethod);
                  int v195 = v231;
                  v196 = v254;
                  unint64_t v194 = Implementation;
                  goto LABEL_293;
                }

                goto LABEL_397;
              }

LABEL_397:
              uint64_t v57 = 0LL;
              uint64_t v55 = 0;
              LODWORD(v257) = 0;
              uint64_t v58 = 0LL;
              uint64_t v62 = 0LL;
              uint64_t v61 = 0;
              LODWORD(v59) = 0;
              goto LABEL_276;
            }

            if (v13 < 0xE) {
              goto LABEL_228;
            }
            if (strncmp("Object:", &v10[v13 - 7], 7uLL))
            {
              if (v13 >= 0x19)
              {
                if (!strncmp("AtIndex:", &v10[v13 - 8], 8uLL))
                {
                  if (!strncmp("removeObjectFrom", v10, 0x10uLL))
                  {
                    if (v272)
                    {
                      if (v258) {
                        CFRelease(v258);
                      }
                    }

                    else
                    {
                      v271 = v270;
                    }

                    v238 = (const char *)v255;
                    strlcpy((char *)v255, v10 + 16, v14);
                    v238[v13 - 24] = 0;
                    v258 = CFStringCreateWithCStringNoCopy(v12, v238, 0x600u, v16);
                    v239 = objc_msgSend(v257, "indexForKey:");
                    if (v239 != 0x7FFFFFFFFFFFFFFFLL) {
                      goto LABEL_441;
                    }
                    if (v272)
                    {
                      if (v258) {
                        CFRelease(v258);
                      }
                    }

                    else
                    {
                      v271 = v270;
                    }

                    uint64_t v243 = (char *)v255;
                    *uint64_t v243 = __tolower(*(char *)v255);
                    v258 = CFStringCreateWithCStringNoCopy(v12, v243, 0x600u, v16);
                    v239 = objc_msgSend(v257, "indexForKey:");
                    if (v239 != 0x7FFFFFFFFFFFFFFFLL)
                    {
LABEL_441:
                      uint64_t v19 = v239;
                      uint64_t v55 = 0;
                      LODWORD(v257) = 0;
                      uint64_t v62 = 0LL;
                      uint64_t v61 = 0;
                      LODWORD(v59) = 1;
                      uint64_t v58 = _sharedIMPL_removeObjectFromOrderedSetAtIndex_core;
                      uint64_t v57 = "v@:Q";
                      goto LABEL_276;
                    }
                  }

                  goto LABEL_228;
                }

LABEL_268:
                if (!strncmp("AtIndexes:", &v10[v13 - 10], 0xAuLL))
                {
                  if (v272)
                  {
                    if (v258) {
                      CFRelease(v258);
                    }
                  }

                  else
                  {
                    v271 = v270;
                  }

                  uint64_t v228 = (const char *)v255;
                  strlcpy((char *)v255, v10 + 6, v14);
                  v228[v13 - 16] = 0;
                  v258 = CFStringCreateWithCStringNoCopy(v12, v228, 0x600u, v16);
                  uint64_t v229 = objc_msgSend(v257, "indexForKey:");
                  if (v229 != 0x7FFFFFFFFFFFFFFFLL) {
                    goto LABEL_412;
                  }
                  if (v272)
                  {
                    if (v258) {
                      CFRelease(v258);
                    }
                  }

                  else
                  {
                    v271 = v270;
                  }

                  uint64_t v235 = (char *)v255;
                  *uint64_t v235 = __tolower(*(char *)v255);
                  v258 = CFStringCreateWithCStringNoCopy(v12, v235, 0x600u, v16);
                  uint64_t v229 = objc_msgSend(v257, "indexForKey:");
                  if (v229 != 0x7FFFFFFFFFFFFFFFLL)
                  {
LABEL_412:
                    uint64_t v19 = v229;
                    uint64_t v57 = 0LL;
                    uint64_t v55 = 0;
                    LODWORD(v257) = 0;
                    uint64_t v62 = 0LL;
                    uint64_t v61 = 0;
                    LODWORD(v59) = 1;
                    uint64_t v58 = _sharedIMPL_removeOrderedSetAtIndexes_core;
                    goto LABEL_276;
                  }
                }

                goto LABEL_228;
              }

              if (v13 >= 0x11) {
                goto LABEL_268;
              }
LABEL_228:
              if (v272)
              {
                if (v258) {
                  CFRelease(v258);
                }
              }

              else
              {
                v271 = v270;
              }

              unint64_t v172 = (const char *)v255;
              strlcpy((char *)v255, v10 + 6, v14);
              v172[v13 - 7] = 0;
              uint64_t v173 = CFStringCreateWithCStringNoCopy(v12, v172, 0x600u, v16);
              uint64_t v174 = v257;
              v258 = v173;
              uint64_t v175 = objc_msgSend(v257, "indexForKey:");
              if (v175 == 0x7FFFFFFFFFFFFFFFLL)
              {
                if (v272)
                {
                  if (v258) {
                    CFRelease(v258);
                  }
                }

                else
                {
                  v271 = v270;
                }

                uint64_t v192 = (char *)v255;
                *uint64_t v192 = __tolower(*(char *)v255);
                v258 = CFStringCreateWithCStringNoCopy(v12, v192, 0x600u, v16);
                uint64_t v175 = objc_msgSend(v174, "indexForKey:");
                if (v175 == 0x7FFFFFFFFFFFFFFFLL) {
                  goto LABEL_274;
                }
              }

              uint64_t v19 = v175;
              uint64_t v20 = v259;
              unint64_t v168 = [*(id *)(v8[12] + 24 + 8 * v175) _isOrdered];
              uint64_t v57 = 0LL;
              uint64_t v55 = 0;
              LODWORD(v257) = 0;
              uint64_t v62 = 0LL;
              uint64_t v61 = 0;
              uint64_t v169 = _sharedIMPL_removeSet_core;
              unint64_t v170 = _sharedIMPL_removeOrderedSet_core;
LABEL_318:
              if (v168) {
                uint64_t v58 = v170;
              }
              else {
                uint64_t v58 = v169;
              }
LABEL_321:
              LODWORD(v59) = 1;
              goto LABEL_277;
            }

            if (v272)
            {
              if (v258) {
                CFRelease(v258);
              }
            }

            else
            {
              v271 = v270;
            }

            unint64_t v214 = (const char *)v255;
            strlcpy((char *)v255, v10 + 6, v14);
            v214[v13 - 13] = 0;
            v258 = CFStringCreateWithCStringNoCopy(v12, v214, 0x600u, v16);
            unint64_t v215 = objc_msgSend(v257, "indexForKey:");
            if (v215 == 0x7FFFFFFFFFFFFFFFLL)
            {
              if (v272)
              {
                if (v258) {
                  CFRelease(v258);
                }
              }

              else
              {
                v271 = v270;
              }

              uint64_t v227 = (char *)v255;
              *uint64_t v227 = __tolower(*(char *)v255);
              v258 = CFStringCreateWithCStringNoCopy(v12, v227, 0x600u, v16);
              uint64_t v19 = objc_msgSend(v257, "indexForKey:");
              if (v19 == 0x7FFFFFFFFFFFFFFFLL) {
                goto LABEL_228;
              }
            }

            else
            {
              uint64_t v19 = v215;
            }

            unint64_t v211 = [*(id *)(v8[12] + 24 + 8 * v19) _isOrdered];
            uint64_t v57 = 0LL;
            uint64_t v55 = 0;
            LODWORD(v257) = 0;
            uint64_t v62 = 0LL;
            uint64_t v61 = 0;
            uint64_t v212 = _sharedIMPL_removeObjectFromSet_core;
            v213 = _sharedIMPL_removeObjectFromOrderedSet_core;
LABEL_386:
            if (v211) {
              uint64_t v58 = v213;
            }
            else {
              uint64_t v58 = v212;
            }
            LODWORD(v59) = 1;
            goto LABEL_276;
          }

          if (v13 >= 0xB && !strncmp("Object:", &v10[v13 - 7], 7uLL))
          {
            if (v272)
            {
              if (v258) {
                CFRelease(v258);
              }
            }

            else
            {
              v271 = v270;
            }

            uint64_t v185 = (const char *)v255;
            strlcpy((char *)v255, v10 + 3, v14);
            v185[v13 - 10] = 0;
            v258 = CFStringCreateWithCStringNoCopy(v12, v185, 0x600u, v16);
            int v186 = objc_msgSend(v257, "indexForKey:");
            if (v186 != 0x7FFFFFFFFFFFFFFFLL)
            {
              uint64_t v19 = v186;
LABEL_361:
              unint64_t v211 = [*(id *)(v8[12] + 24 + 8 * v19) _isOrdered];
              uint64_t v57 = 0LL;
              uint64_t v55 = 0;
              LODWORD(v257) = 0;
              uint64_t v62 = 0LL;
              uint64_t v61 = 0;
              uint64_t v212 = _sharedIMPL_addObjectToSet_core;
              v213 = _sharedIMPL_addObjectToOrderedSet_core;
              goto LABEL_386;
            }

            if (v272)
            {
              if (v258) {
                CFRelease(v258);
              }
            }

            else
            {
              v271 = v270;
            }

            unint64_t v210 = (char *)v255;
            *unint64_t v210 = __tolower(*(char *)v255);
            v258 = CFStringCreateWithCStringNoCopy(v12, v210, 0x600u, v16);
            uint64_t v19 = objc_msgSend(v257, "indexForKey:");
            if (v19 != 0x7FFFFFFFFFFFFFFFLL) {
              goto LABEL_361;
            }
          }

          if (v272)
          {
            if (v258) {
              CFRelease(v258);
            }
          }

          else
          {
            v271 = v270;
          }

          unint64_t v93 = (const char *)v255;
          strlcpy((char *)v255, v10 + 3, v14);
          v93[v13 - 4] = 0;
          unsigned int v94 = CFStringCreateWithCStringNoCopy(v12, v93, 0x600u, v16);
          unint64_t v95 = v257;
          v258 = v94;
          unsigned int v96 = objc_msgSend(v257, "indexForKey:");
          if (v96 == 0x7FFFFFFFFFFFFFFFLL)
          {
            if (v272)
            {
              if (v258) {
                CFRelease(v258);
              }
            }

            else
            {
              v271 = v270;
            }

            uint64_t v167 = (char *)v255;
            *uint64_t v167 = __tolower(*(char *)v255);
            v258 = CFStringCreateWithCStringNoCopy(v12, v167, 0x600u, v16);
            unsigned int v96 = objc_msgSend(v95, "indexForKey:");
            if (v96 == 0x7FFFFFFFFFFFFFFFLL) {
              goto LABEL_274;
            }
          }

          uint64_t v19 = v96;
          uint64_t v20 = v259;
          unint64_t v168 = [*(id *)(v8[12] + 24 + 8 * v96) _isOrdered];
          uint64_t v57 = 0LL;
          uint64_t v55 = 0;
          LODWORD(v257) = 0;
          uint64_t v62 = 0LL;
          uint64_t v61 = 0;
          uint64_t v169 = _sharedIMPL_addSet_core;
          unint64_t v170 = _sharedIMPL_addOrderedSet_core;
          goto LABEL_318;
        }

        if (v272)
        {
          __int128 v73 = v256;
          if (v258) {
            CFRelease(v258);
          }
        }

        else
        {
          v271 = v270;
          __int128 v73 = v256;
        }

        __int128 v74 = (const char *)v255;
        strlcpy((char *)v255, v10 + 3, v14);
        v74[v13 - 4] = 0;
        __int128 v75 = CFStringCreateWithCStringNoCopy(v12, v74, 0x600u, v16);
        __int128 v76 = v257;
        v258 = v75;
        __int128 v77 = objc_msgSend(v257, "indexForKey:");
        if (v77 == 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v272)
          {
            if (v258) {
              CFRelease(v258);
            }
          }

          else
          {
            v271 = v270;
          }

          id v97 = (char *)v255;
          *id v97 = __tolower(*(char *)v255);
          v258 = CFStringCreateWithCStringNoCopy(v12, v97, 0x600u, v16);
          __int128 v77 = objc_msgSend(v76, "indexForKey:");
          if (v77 == 0x7FFFFFFFFFFFFFFFLL) {
            goto LABEL_274;
          }
        }

        uint64_t v19 = v77;
        unint64_t v98 = (objc_class *)objc_opt_class();
        unint64_t v99 = *(void **)(v8[12] + 24LL + 8 * v19);
        unsigned int v100 = (void *)v8[14];
        Property = class_getProperty(v98, (const char *)v255);
        uint64_t v256 = v73;
        if (Property)
        {
          Attributes = property_getAttributes(Property);
          uint64_t v103 = strlen(Attributes);
          v252 = (const __CFString *)&v252;
          MEMORY[0x1895F8858](v103);
          __int16 v105 = (char *)&v252 - v104;
          strlcpy((char *)&v252 - v104, Attributes, v106);
          v264 = v105;
          unint64_t v107 = strsep(&v264, ",");
          if (v107)
          {
            unsigned int v108 = v107;
            LODWORD(v257) = 0;
            v253 = 0;
            uint64_t v109 = 1;
            while (1)
            {
              unint64_t v110 = *v108;
              if (v110 == 67)
              {
                uint64_t v111 = v100[12];
                uint64_t v54 = v19 >= v111;
                uint64_t v112 = v19 - v111;
                uint64_t v113 = !v54 || v112 >= v100[13];
                if (!v113
                  || ((v114 = v100[20], uint64_t v54 = v19 >= v114, v115 = v19 - v114, v54)
                    ? (unint64_t v116 = v115 >= v100[21])
                    : (unint64_t v116 = 1),
                      !v116))
                {
                  uint64_t v20 = v259;
                  unint64_t v171 = (objc_class *)objc_opt_class();
                  uint64_t v251 = class_getName(v171);
                  uint64_t v250 = (const char *)v255;
                  uint64_t v184 = @"Property '%s' is marked copy on class '%s'.  Cannot generate a copying setter method for NSManagedObject's to-one relationship.";
                  goto LABEL_246;
                }

                uint64_t v109 = 0;
                goto LABEL_182;
              }

              if (v110 != 84)
              {
                if (v110 == 87)
                {
                  uint64_t v20 = v259;
                  unint64_t v177 = (objc_class *)objc_opt_class();
                  uint64_t v251 = class_getName(v177);
                  uint64_t v250 = (const char *)v255;
                  uint64_t v184 = @"Property '%s' is marked __weak on class '%s'.  Cannot generate a setter method for it.";
                  goto LABEL_246;
                }

                goto LABEL_182;
              }

              unint64_t v118 = v108[1];
              unint64_t v117 = v108 + 1;
              if (v118 == 64 || (isTypeEncodingObject(v117) & 1) != 0) {
                goto LABEL_182;
              }
              unint64_t v119 = v100[2];
              uint64_t v54 = v19 >= v119;
              unint64_t v120 = v19 - v119;
              if (!v54 || v120 >= v100[3])
              {
                uint64_t v20 = v259;
                int v216 = (objc_class *)objc_opt_class();
                uint64_t v217 = class_getName(v216);
                uint64_t v250 = v10;
                uint64_t v251 = v217;
                uint64_t v184 = @"Property '%s' is a scalar type on class '%s'.  Cannot generate a setter method for it.";
                goto LABEL_246;
              }

              unint64_t v121 = [v99 attributeType];
              if (v121 <= 499)
              {
                if (v121 == 100)
                {
                  int v127 = *(unsigned __int8 *)v117;
                  LODWORD(v257) = 115;
                  if ((v127 | 0x20) != 0x73) {
                    goto LABEL_372;
                  }
                }

                else if (v121 == 200)
                {
                  unint64_t v128 = *(unsigned __int8 *)v117;
                  LODWORD(v257) = 105;
                  uint64_t v129 = v128 - 73;
                  if (v129 > 0x28) {
                    goto LABEL_372;
                  }
                  if (((1LL << v129) & 0x900000009LL) == 0)
                  {
                    if (((1LL << v129) & 0x10000000100LL) == 0) {
                      goto LABEL_372;
                    }
                    unint64_t v130 = (objc_class *)objc_opt_class();
                    uint64_t v251 = class_getName(v130);
                    _NSCoreDataLog( 2LL,  (uint64_t)@"Property '%s' is a 64 bit scalar type on class '%s' that does not match its entity's property's 32 bit scalar type.  Implicit coercion to 32 bits in the database is not recommended.",  v131,  v132,  v133,  v134,  v135,  v136,  (uint64_t)v10);
                    LODWORD(v257) = 113;
                    v253 = 105;
                  }
                }

                else if (v121 != 300 || (int v123 = *(unsigned __int8 *)v117, LODWORD(v257) = 113, (v123 | 0x20) != 0x71))
                {
LABEL_372:
                  uint64_t v20 = v259;
                  uint64_t v218 = (objc_class *)objc_opt_class();
                  uint64_t v219 = class_getName(v218);
                  uint64_t v250 = v10;
                  uint64_t v251 = v219;
                  uint64_t v184 = @"Property '%s' is a scalar type on class '%s' that does not match its Entity's property's scalar type.  Dynamically generated accessors do not support implicit type coercion.  Cannot generate a setter method for it.";
LABEL_246:
                  _NSCoreDataLog(1LL, (uint64_t)v184, v178, v179, v180, v181, v182, v183, (uint64_t)v250);
                  uint64_t v57 = 0LL;
                  uint64_t v58 = 0LL;
                  uint64_t v62 = 0LL;
                  uint64_t v61 = 0;
                  LODWORD(v59) = 1;
                  uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_247:
                  uint64_t v55 = v253;
LABEL_277:
                  if (v272)
                  {
                    if (v258) {
                      CFRelease(v258);
                    }
                  }

                  else
                  {
                    v271 = v270;
                  }

                  if (v19 == 0x7FFFFFFFFFFFFFFFLL)
                  {
LABEL_282:
                    LOBYTE(v6) = 0;
                    return v6;
                  }

                  unint64_t v193 = "@@:";
                  if ((_DWORD)v59) {
                    unint64_t v193 = "v@:@";
                  }
                  if (!v57) {
                    uint64_t v57 = v193;
                  }
                  if (!strcmp(v57, "v@:Q") || !strcmp(v57, "v@:I") || strlen(v57) >= 5)
                  {
                    generateAccessorWithFunctionPtrSignature(v57, (uint64_t)v58, v19);
                    if (!v6) {
                      return v6;
                    }
                    unint64_t v194 = (id (*)(id, SEL, ...))v6;
LABEL_292:
                    int v195 = v20;
                    v196 = v254;
                    TypeEncoding = v57;
LABEL_293:
                    class_addMethod(v195, v196, v194, TypeEncoding);
                    LOBYTE(v6) = 1;
                    return v6;
                  }

                  if (!(_DWORD)v257)
                  {
                    if (v19 <= 0x31 && v62)
                    {
                      unint64_t v194 = *(id (**)(id, SEL, ...))(v62 + 8 * v19);
                    }

                    else
                    {
                      if (v58)
                      {
                        v264 = (char *)MEMORY[0x1895F87A8];
                        v265 = 3221225472LL;
                        v266 = __generateAccessor_block_invoke_2;
                        v267 = &__block_descriptor_48_e11__24__0_8_16l;
                        v268 = v58;
                        v269 = v19;
                        AccessorType = imp_implementationWithBlock(&v264);
                      }

                      else
                      {
                        AccessorType = generateAccessorType((int)v59, v19, v61);
                      }

                      unint64_t v194 = AccessorType;
                      if (!AccessorType) {
                        goto LABEL_282;
                      }
                    }

                    goto LABEL_292;
                  }

                  if ((_DWORD)v59)
                  {
                    qmemcpy(v263, "v@:", 3);
                    v263[3] = (_BYTE)v257;
                    v263[4] = 0;
                    if (v257 <= 0x70u)
                    {
                      unint64_t v198 = _sharedIMPL_setvfk_core_c;
                      switch((char)v257)
                      {
                        case 'c':
                          goto LABEL_353;
                        case 'd':
                          v262 = MEMORY[0x1895F87A8];
                          unint64_t v199 = (char *)&__block_descriptor_40_e11_v24__0_8d16l;
                          uint64_t v200 = (char *)__80__NSManagedObject__PFDynamicAccessorsAndPropertySupport__resolveInstanceMethod___block_invoke;
                          v201 = (char **)&v262;
                          break;
                        case 'e':
                        case 'g':
                        case 'h':
                          goto LABEL_282;
                        case 'f':
                          v261 = MEMORY[0x1895F87A8];
                          unint64_t v199 = (char *)&__block_descriptor_40_e11_v20__0_8f16l;
                          uint64_t v200 = (char *)__80__NSManagedObject__PFDynamicAccessorsAndPropertySupport__resolveInstanceMethod___block_invoke_2;
                          v201 = (char **)&v261;
                          break;
                        case 'i':
                          unint64_t v198 = _sharedIMPL_setvfk_core_i;
                          goto LABEL_353;
                        default:
                          goto LABEL_353;
                      }

                      v201[1] = (char *)3221225472LL;
                      v201[2] = v200;
                      v201[3] = v199;
                      v201[4] = (char *)v19;
                      goto LABEL_357;
                    }

                    if (v257 == 113)
                    {
                      if (v55)
                      {
                        if (v55 != 105) {
                          goto LABEL_282;
                        }
                        unint64_t v198 = _sharedIMPL_setvfk_core_i2q;
                      }

                      else
                      {
                        unint64_t v198 = _sharedIMPL_setvfk_core_q;
                      }
                    }

                    else
                    {
                      unint64_t v198 = _sharedIMPL_setvfk_core_s;
                    }

LABEL_353:
                    v264 = (char *)MEMORY[0x1895F87A8];
                    v265 = 3221225472LL;
                    uint64_t v208 = __generateAccessor_block_invoke_2;
                    v209 = &__block_descriptor_48_e11__24__0_8_16l;
                  }

                  else
                  {
                    v263[0] = (_BYTE)v257;
                    strcpy(&v263[1], "@:");
                    if (v257 <= 0x70u)
                    {
                      unint64_t v198 = _sharedIMPL_pvfk_core_c;
                      switch((char)v257)
                      {
                        case 'c':
                          goto LABEL_355;
                        case 'd':
                          v260[0] = MEMORY[0x1895F87A8];
                          v260[1] = 3221225472LL;
                          v260[2] = __80__NSManagedObject__PFDynamicAccessorsAndPropertySupport__resolveInstanceMethod___block_invoke_3;
                          v260[3] = &__block_descriptor_40_e8_d16__0_8l;
                          v260[4] = v19;
                          v201 = (char **)v260;
                          goto LABEL_357;
                        case 'e':
                        case 'g':
                        case 'h':
                          goto LABEL_282;
                        case 'f':
                          unint64_t v198 = _sharedIMPL_pvfk_core_f;
                          goto LABEL_355;
                        case 'i':
                          unint64_t v198 = _sharedIMPL_pvfk_core_i;
                          goto LABEL_355;
                        default:
                          goto LABEL_355;
                      }
                    }

                    if (v257 == 113)
                    {
                      if (v55)
                      {
                        if (v55 != 105) {
                          goto LABEL_282;
                        }
                        unint64_t v198 = _sharedIMPL_pvfk_core_i2q;
                      }

                      else
                      {
                        unint64_t v198 = _sharedIMPL_pvfk_core_q;
                      }
                    }

                    else
                    {
                      unint64_t v198 = _sharedIMPL_pvfk_core_s;
                    }

LABEL_355:
                    v264 = (char *)MEMORY[0x1895F87A8];
                    v265 = 3221225472LL;
                    uint64_t v208 = __generateAccessor_block_invoke;
                    v209 = &__block_descriptor_48_e8__16__0_8l;
                  }

                  v266 = v208;
                  v267 = v209;
                  v268 = v198;
                  v269 = v19;
                  v201 = &v264;
LABEL_357:
                  unint64_t v194 = imp_implementationWithBlock(v201);
                  if (!v194) {
                    goto LABEL_282;
                  }
                  TypeEncoding = v263;
                  int v195 = v20;
                  v196 = v254;
                  goto LABEL_293;
                }
              }

              else if (v121 > 799)
              {
                if (v121 == 900)
                {
LABEL_174:
                  unsigned int v126 = *(unsigned __int8 *)v117;
                  LODWORD(v257) = 100;
                  if (v126 != 100) {
                    goto LABEL_372;
                  }
                  goto LABEL_182;
                }

                if (v121 != 800) {
                  goto LABEL_372;
                }
                unint64_t v124 = *(unsigned __int8 *)v117;
                LODWORD(v257) = 66;
                unint64_t v125 = v124 - 66;
                if (v125 > 0x21 || ((1LL << v125) & 0x200000003LL) == 0) {
                  goto LABEL_372;
                }
              }

              else
              {
                if (v121 == 500) {
                  goto LABEL_174;
                }
                if (v121 != 600) {
                  goto LABEL_372;
                }
                unint64_t v122 = *(unsigned __int8 *)v117;
                LODWORD(v257) = 102;
                if (v122 != 102) {
                  goto LABEL_372;
                }
              }

uint64_t isTypeEncodingObject(const char *a1)
{
  int v1 = *(unsigned __int8 *)a1;
  if (v1 == 64) {
    return 1LL;
  }
  if (v1 != 94) {
    return 0LL;
  }
  int v2 = *((unsigned __int8 *)a1 + 1);
  if (v2 == 35) {
    return 1LL;
  }
  if (v2 != 123) {
    return 0LL;
  }
  uint64_t result = (uint64_t)strchr(a1, 61);
  if (result) {
    return *(unsigned __int8 *)(result + 1) == 35;
  }
  return result;
}

void _sharedIMPL_copying_setvfk_core(char **a1, uint64_t a2, void *a3, unint64_t a4)
{
  if (a3)
  {
    id v7 = (id)[a3 copy];
    _sharedIMPL_setvfk_core(a1, v6, v7, a4);
    if (v7) {
  }
    }

  else
  {
    _sharedIMPL_setvfk_core(a1, a2, 0LL, a4);
  }

void _sharedIMPL_addObjectToOrderedSet_core(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a3)
  {
    uint64_t v7 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
    _PF_Handler_WillAccess_Property((id *)a1, v8, a4);
    _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
    uint64_t v16 = v15;
    int v17 = [v15 containsObject:a3];
    char v18 = v17;
    id v19 = (id)objc_msgSend( objc_alloc(MEMORY[0x1896078D0]),  "initWithIndexesInRange:",  objc_msgSend(v16, "count"),  v17 ^ 1u);
    objc_msgSend(a1, "willChange:valuesAtIndexes:forKey:", 2);
    if ((v18 & 1) == 0) {
      [v16 addObject:a3];
    }
    [a1 didChange:2 valuesAtIndexes:v19 forKey:v7];
  }

void _sharedIMPL_addObjectToSet_core(_DWORD *a1, uint64_t a2, void *a3, unint64_t a4)
{
  values = a3;
  uint64_t v6 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
  int v7 = a1[4];
  CFSetRef v8 = CFSetCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)&values, 1LL, MEMORY[0x189605258]);
  if ((v7 & 0x200000) != 0) {
    _PF_ManagedObject_WillChangeValueForKeywithSetMutation( a1,  (uint64_t)sel_willChangeValueForKey_withSetMutation_usingObjects_,  v6,  1LL,  (uint64_t)v8,  a4);
  }
  else {
    [a1 willChangeValueForKey:v6 withSetMutation:1 usingObjects:v8];
  }
  _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
  [v15 addObject:values];
  if ((v7 & 0x200000) != 0)
  {
    _PF_ManagedObject_DidChangeValueForKeywithSetMutation( (uint64_t)a1,  (uint64_t)sel_didChangeValueForKey_withSetMutation_usingObjects_,  v6);
    if (!v8) {
      return;
    }
    goto LABEL_8;
  }

  [a1 didChangeValueForKey:v6 withSetMutation:1 usingObjects:v8];
  if (v8) {
LABEL_8:
  }
    CFRelease(v8);
}

void _sharedIMPL_addOrderedSet_core(void *a1, uint64_t a2, void *a3, unint64_t a4)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  uint64_t v7 = [a3 count];
  if (v7)
  {
    unint64_t v8 = v7;
    uint64_t v28 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
    _PF_Handler_WillAccess_Property((id *)a1, v9, a4);
    _sharedIMPL_pvfk_core((uint64_t)a1, v10, a4, v11, v12, v13, v14, v15);
    int v17 = v16;
    uint64_t v29 = &v28;
    MEMORY[0x1895F8858](v16);
    id v19 = (char *)&v28 - v18;
    if (v8 > 0x200) {
      id v19 = (char *)NSAllocateScannedUncollectable();
    }
    else {
      bzero((char *)&v28 - v18, 8 * v8);
    }
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v31 = 0u;
    __int128 v30 = 0u;
    uint64_t v20 = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v30, v34, 16, v28, v29);
    if (v20)
    {
      uint64_t v21 = v20;
      uint64_t v22 = 0LL;
      uint64_t v23 = *(void *)v31;
      do
      {
        for (uint64_t i = 0LL; i != v21; ++i)
        {
          if (*(void *)v31 != v23) {
            objc_enumerationMutation(a3);
          }
          uint64_t v25 = *(void *)(*((void *)&v30 + 1) + 8 * i);
          if (([v17 containsObject:v25] & 1) == 0) {
            *(void *)&v19[8 * v22++] = v25;
          }
        }

        uint64_t v21 = [a3 countByEnumeratingWithState:&v30 objects:v34 count:16];
      }

      while (v21);
    }

    else
    {
      uint64_t v22 = 0LL;
    }

    uint64_t v26 = (void *)objc_msgSend( objc_alloc(MEMORY[0x1896078D0]),  "initWithIndexesInRange:",  objc_msgSend(v17, "count"),  v22);
    uint64_t v27 = v28;
    [a1 willChange:2 valuesAtIndexes:v26 forKey:v28];
    [v17 addObjects:v19 count:v22];
    [a1 didChange:2 valuesAtIndexes:v26 forKey:v27];

    if (v8 >= 0x201) {
      NSZoneFree(0LL, v19);
    }
  }

uint64_t _sharedIMPL_addSet_core(_DWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
  int v8 = a1[4];
  if ((v8 & 0x200000) != 0) {
    _PF_ManagedObject_WillChangeValueForKeywithSetMutation( a1,  (uint64_t)sel_willChangeValueForKey_withSetMutation_usingObjects_,  v7,  1LL,  a3,  a4);
  }
  else {
    [a1 willChangeValueForKey:v7 withSetMutation:1 usingObjects:a3];
  }
  _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
  [v15 unionSet:a3];
  if ((v8 & 0x200000) != 0) {
    return _PF_ManagedObject_DidChangeValueForKeywithSetMutation( (uint64_t)a1,  (uint64_t)sel_didChangeValueForKey_withSetMutation_usingObjects_,  v7);
  }
  else {
    return [a1 didChangeValueForKey:v7 withSetMutation:1 usingObjects:a3];
  }
}

void _sharedIMPL_removeObjectFromOrderedSet_core(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a3)
  {
    uint64_t v7 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
    _PF_Handler_WillAccess_Property((id *)a1, v8, a4);
    _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
    uint64_t v16 = v15;
    id v18 = objc_alloc_init(MEMORY[0x189607938]);
    uint64_t v17 = [v16 indexOfObject:a3];
    if (v17 != 0x7FFFFFFFFFFFFFFFLL) {
      [v18 addIndex:v17];
    }
    [a1 willChange:3 valuesAtIndexes:v18 forKey:v7];
    [v16 removeObjectsAtIndexes:v18];
    [a1 didChange:3 valuesAtIndexes:v18 forKey:v7];
  }

void _sharedIMPL_removeObjectFromSet_core(_DWORD *a1, uint64_t a2, void *a3, unint64_t a4)
{
  values = a3;
  uint64_t v6 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
  int v7 = a1[4];
  CFSetRef v8 = CFSetCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const void **)&values, 1LL, MEMORY[0x189605258]);
  if ((v7 & 0x200000) != 0) {
    _PF_ManagedObject_WillChangeValueForKeywithSetMutation( a1,  (uint64_t)sel_willChangeValueForKey_withSetMutation_usingObjects_,  v6,  2LL,  (uint64_t)v8,  a4);
  }
  else {
    [a1 willChangeValueForKey:v6 withSetMutation:2 usingObjects:v8];
  }
  _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
  [v15 removeObject:values];
  if ((v7 & 0x200000) != 0)
  {
    _PF_ManagedObject_DidChangeValueForKeywithSetMutation( (uint64_t)a1,  (uint64_t)sel_didChangeValueForKey_withSetMutation_usingObjects_,  v6);
    if (!v8) {
      return;
    }
    goto LABEL_8;
  }

  [a1 didChangeValueForKey:v6 withSetMutation:2 usingObjects:v8];
  if (v8) {
LABEL_8:
  }
    CFRelease(v8);
}

void _sharedIMPL_removeObjectFromOrderedSetAtIndex_core( void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
  _PF_Handler_WillAccess_Property((id *)a1, v8, a4);
  _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
  uint64_t v16 = v15;
  id v17 = objc_alloc_init(MEMORY[0x189607938]);
  id v18 = v17;
  id v19 = v17;
  if (a3 != 0x7FFFFFFFFFFFFFFFLL)
  {
    [v17 addIndex:a3];
    id v18 = v19;
  }

  [a1 willChange:3 valuesAtIndexes:v18 forKey:v7];
  [v16 removeObjectsAtIndexes:v19];
  [a1 didChange:3 valuesAtIndexes:v19 forKey:v7];
}

uint64_t _sharedIMPL_removeOrderedSetAtIndexes_core(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
  _PF_Handler_WillAccess_Property((id *)a1, v8, a4);
  _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
  uint64_t v16 = v15;
  [a1 willChange:3 valuesAtIndexes:a3 forKey:v7];
  [v16 removeObjectsAtIndexes:a3];
  return [a1 didChange:3 valuesAtIndexes:a3 forKey:v7];
}

void _sharedIMPL_removeOrderedSet_core(void *a1, uint64_t a2, void *a3, unint64_t a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if ([a3 count])
  {
    uint64_t v7 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
    _PF_Handler_WillAccess_Property((id *)a1, v8, a4);
    _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
    uint64_t v16 = v15;
    id v17 = objc_alloc_init(MEMORY[0x189607938]);
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    uint64_t v18 = [a3 countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v18)
    {
      uint64_t v19 = v18;
      uint64_t v20 = *(void *)v24;
      do
      {
        uint64_t v21 = 0LL;
        do
        {
          if (*(void *)v24 != v20) {
            objc_enumerationMutation(a3);
          }
          uint64_t v22 = [v16 indexOfObject:*(void *)(*((void *)&v23 + 1) + 8 * v21)];
          if (v22 != 0x7FFFFFFFFFFFFFFFLL) {
            [v17 addIndex:v22];
          }
          ++v21;
        }

        while (v19 != v21);
        uint64_t v19 = [a3 countByEnumeratingWithState:&v23 objects:v27 count:16];
      }

      while (v19);
    }

    [a1 willChange:3 valuesAtIndexes:v17 forKey:v7];
    [v16 removeObjectsAtIndexes:v17];
    [a1 didChange:3 valuesAtIndexes:v17 forKey:v7];
  }

uint64_t _sharedIMPL_removeSet_core(_DWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a4) name];
  int v8 = a1[4];
  if ((v8 & 0x200000) != 0) {
    _PF_ManagedObject_WillChangeValueForKeywithSetMutation( a1,  (uint64_t)sel_willChangeValueForKey_withSetMutation_usingObjects_,  v7,  2LL,  a3,  a4);
  }
  else {
    [a1 willChangeValueForKey:v7 withSetMutation:2 usingObjects:a3];
  }
  _sharedIMPL_pvfk_core((uint64_t)a1, v9, a4, v10, v11, v12, v13, v14);
  [v15 minusSet:a3];
  if ((v8 & 0x200000) != 0) {
    return _PF_ManagedObject_DidChangeValueForKeywithSetMutation( (uint64_t)a1,  (uint64_t)sel_didChangeValueForKey_withSetMutation_usingObjects_,  v7);
  }
  else {
    return [a1 didChangeValueForKey:v7 withSetMutation:2 usingObjects:a3];
  }
}

void _sharedIMPL_insertObjectToOrderedSetAtIndex_core( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3)
  {
    uint64_t v9 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a5) name];
    _PF_Handler_WillAccess_Property((id *)a1, v10, a5);
    _sharedIMPL_pvfk_core((uint64_t)a1, v11, a5, v12, v13, v14, v15, v16);
    uint64_t v18 = v17;
    int v19 = [v17 containsObject:a3];
    char v20 = v19;
    id v21 = (id)objc_msgSend(objc_alloc(MEMORY[0x1896078D0]), "initWithIndexesInRange:", a4, v19 ^ 1u);
    objc_msgSend(a1, "willChange:valuesAtIndexes:forKey:", 2);
    if ((v20 & 1) == 0) {
      [v18 insertObject:a3 atIndex:a4];
    }
    [a1 didChange:2 valuesAtIndexes:v21 forKey:v9];
  }

void _sharedIMPL_insertOrderedSetAtIndexes_core( void *a1, uint64_t a2, void *a3, void *a4, unint64_t a5)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  uint64_t v9 = [a3 count];
  if (v9)
  {
    unint64_t v10 = v9;
    uint64_t v42 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a5) name];
    _PF_Handler_WillAccess_Property((id *)a1, v11, a5);
    _sharedIMPL_pvfk_core((uint64_t)a1, v12, a5, v13, v14, v15, v16, v17);
    int v19 = v18;
    id v20 = objc_alloc_init(MEMORY[0x189607938]);
    id v21 = v20;
    uint64_t v43 = &v41;
    if (v10 >= 0x201) {
      uint64_t v22 = 1LL;
    }
    else {
      uint64_t v22 = v10;
    }
    uint64_t v23 = 8 * v22;
    MEMORY[0x1895F8858](v20);
    __int128 v25 = (char *)&v41 - v24;
    if (v10 > 0x200) {
      __int128 v25 = (char *)NSAllocateScannedUncollectable();
    }
    else {
      bzero((char *)&v41 - v24, 8 * v10);
    }
    uint64_t v26 = [a4 lastIndex];
    v49[0] = 0LL;
    v49[1] = v26;
    uint64_t v27 = [a4 getIndexes:v25 maxCount:v10 inIndexRange:v49];
    MEMORY[0x1895F8858](v27);
    uint64_t v28 = (char *)&v41 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    if (v10 > 0x200) {
      uint64_t v28 = (char *)NSAllocateScannedUncollectable();
    }
    else {
      bzero((char *)&v41 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL), 8 * v10);
    }
    id v44 = a1;
    __int128 v48 = 0u;
    __int128 v47 = 0u;
    __int128 v46 = 0u;
    __int128 v45 = 0u;
    uint64_t v29 = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v45, v50, 16, v10);
    if (v29)
    {
      uint64_t v30 = v29;
      uint64_t v31 = 0LL;
      uint64_t v32 = *(void *)v46;
      do
      {
        for (uint64_t i = 0LL; i != v30; ++i)
        {
          if (*(void *)v46 != v32) {
            objc_enumerationMutation(a3);
          }
          uint64_t v34 = *(void *)(*((void *)&v45 + 1) + 8 * i);
          if (([v19 containsObject:v34] & 1) == 0)
          {
            *(void *)&v28[8 * v31] = v34;
            [v21 addIndex:*(void *)&v25[8 * v31++]];
          }
        }

        uint64_t v30 = [a3 countByEnumeratingWithState:&v45 objects:v50 count:16];
      }

      while (v30);
    }

    else
    {
      uint64_t v31 = 0LL;
    }

    if (v41 >= 0x201)
    {
      NSZoneFree(0LL, v25);
      uint64_t v38 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:v28 count:v31];
      id v39 = v44;
      uint64_t v40 = v42;
      [v44 willChange:2 valuesAtIndexes:v21 forKey:v42];
      [v19 insertObjects:v38 atIndexes:v21];
      [v39 didChange:2 valuesAtIndexes:v21 forKey:v40];

      NSZoneFree(0LL, v28);
    }

    else
    {
      uint64_t v35 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:v28 count:v31];
      id v36 = v44;
      uint64_t v37 = v42;
      [v44 willChange:2 valuesAtIndexes:v21 forKey:v42];
      [v19 insertObjects:v35 atIndexes:v21];
      [v36 didChange:2 valuesAtIndexes:v21 forKey:v37];
    }
  }

void _sharedIMPL_replaceObjectInOrderedSetAtIndex_core( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v22 = a4;
  if (a4)
  {
    uint64_t v9 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a5) name];
    _PF_Handler_WillAccess_Property((id *)a1, v10, a5);
    _sharedIMPL_pvfk_core((uint64_t)a1, v11, a5, v12, v13, v14, v15, v16);
    uint64_t v18 = v17;
    int v19 = [v17 containsObject:a4];
    char v20 = v19;
    id v21 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1896078D0]), "initWithIndexesInRange:", a3, v19 ^ 1u);
    [a1 willChange:4 valuesAtIndexes:v21 forKey:v9];
    if ((v20 & 1) == 0) {
      objc_msgSend(v18, "replaceObjectsInRange:withObjects:count:", a3, 1, &v22, 1);
    }
    [a1 didChange:4 valuesAtIndexes:v21 forKey:v9];
  }

void _sharedIMPL_replaceOrderedSetAtIndexes_core( void *a1, uint64_t a2, void *a3, void *a4, unint64_t a5)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  uint64_t v9 = [a3 count];
  if (v9)
  {
    unint64_t v10 = v9;
    uint64_t v42 = [*(id *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 24 + 8 * a5) name];
    _PF_Handler_WillAccess_Property((id *)a1, v11, a5);
    _sharedIMPL_pvfk_core((uint64_t)a1, v12, a5, v13, v14, v15, v16, v17);
    int v19 = v18;
    id v20 = objc_alloc_init(MEMORY[0x189607938]);
    id v21 = v20;
    uint64_t v43 = &v41;
    if (v10 >= 0x201) {
      uint64_t v22 = 1LL;
    }
    else {
      uint64_t v22 = v10;
    }
    uint64_t v23 = 8 * v22;
    MEMORY[0x1895F8858](v20);
    __int128 v25 = (char *)&v41 - v24;
    if (v10 > 0x200) {
      __int128 v25 = (char *)NSAllocateScannedUncollectable();
    }
    else {
      bzero((char *)&v41 - v24, 8 * v10);
    }
    uint64_t v26 = [a4 lastIndex];
    v49[0] = 0LL;
    v49[1] = v26;
    uint64_t v27 = [a4 getIndexes:v25 maxCount:v10 inIndexRange:v49];
    MEMORY[0x1895F8858](v27);
    uint64_t v28 = (char *)&v41 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    if (v10 > 0x200) {
      uint64_t v28 = (char *)NSAllocateScannedUncollectable();
    }
    else {
      bzero((char *)&v41 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL), 8 * v10);
    }
    id v44 = a1;
    __int128 v48 = 0u;
    __int128 v47 = 0u;
    __int128 v46 = 0u;
    __int128 v45 = 0u;
    uint64_t v29 = objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v45, v50, 16, v10);
    if (v29)
    {
      uint64_t v30 = v29;
      uint64_t v31 = 0LL;
      uint64_t v32 = *(void *)v46;
      do
      {
        for (uint64_t i = 0LL; i != v30; ++i)
        {
          if (*(void *)v46 != v32) {
            objc_enumerationMutation(a3);
          }
          uint64_t v34 = *(void *)(*((void *)&v45 + 1) + 8 * i);
          if (([v19 containsObject:v34] & 1) == 0)
          {
            *(void *)&v28[8 * v31] = v34;
            [v21 addIndex:*(void *)&v25[8 * v31++]];
          }
        }

        uint64_t v30 = [a3 countByEnumeratingWithState:&v45 objects:v50 count:16];
      }

      while (v30);
    }

    else
    {
      uint64_t v31 = 0LL;
    }

    if (v41 >= 0x201)
    {
      NSZoneFree(0LL, v25);
      uint64_t v38 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:v28 count:v31];
      id v39 = v44;
      uint64_t v40 = v42;
      [v44 willChange:4 valuesAtIndexes:v21 forKey:v42];
      [v19 replaceObjectsAtIndexes:v21 withObjects:v38];
      [v39 didChange:4 valuesAtIndexes:v21 forKey:v40];

      NSZoneFree(0LL, v28);
    }

    else
    {
      uint64_t v35 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:v28 count:v31];
      id v36 = v44;
      uint64_t v37 = v42;
      [v44 willChange:4 valuesAtIndexes:v21 forKey:v42];
      [v19 replaceObjectsAtIndexes:v21 withObjects:v35];
      [v36 didChange:4 valuesAtIndexes:v21 forKey:v37];
    }
  }

void _sharedIMPL_wcvfk_core(id a1, uint64_t a2, unint64_t a3)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_willChangeValueForKey_);
  }
  uint64_t v5 = *(void *)(*(void *)(*(void *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 16LL) + 40LL) + 8 * a3);
  _PF_ManagedObject_WillChangeValueForKeyIndex((uint64_t)a1, (uint64_t)sel_willChangeValueForKey_, v5, a3, 0);
}

void *_sharedIMPL_dcvfk_core(void *a1, uint64_t a2, unint64_t a3)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_didChangeValueForKey_);
  }
  uint64_t v5 = *(void *)(*(void *)(*(void *)(*((void *)_PFEntityForManagedObject(a1) + 12) + 16LL) + 40LL) + 8 * a3);
  return _PF_ManagedObject_DidChangeValueForKeyIndex(a1, (uint64_t)sel_didChangeValueForKey_, v5, a3);
}

void generateAccessorWithFunctionPtrSignature(const char *a1, uint64_t a2, uint64_t a3)
{
  if (!strcmp(a1, "v@:Q"))
  {
    uint64_t v21 = MEMORY[0x1895F87A8];
    uint64_t v12 = &__block_descriptor_48_e11__24__0_8Q16l;
    uint64_t v13 = __generateAccessorWithFunctionPtrSignature_block_invoke;
    p_blocuint64_t k = &v21;
    goto LABEL_15;
  }

  if (!strcmp(a1, "v@:I"))
  {
    uint64_t v20 = MEMORY[0x1895F87A8];
    uint64_t v12 = &__block_descriptor_48_e11__20__0_8I16l;
    uint64_t v13 = __generateAccessorWithFunctionPtrSignature_block_invoke_2;
    p_blocuint64_t k = &v20;
    goto LABEL_15;
  }

  if (!strcmp(a1, "v@:Q@"))
  {
    uint64_t v19 = MEMORY[0x1895F87A8];
    uint64_t v12 = &__block_descriptor_48_e14__32__0_8Q16_24l;
    uint64_t v13 = __generateAccessorWithFunctionPtrSignature_block_invoke_3;
    p_blocuint64_t k = &v19;
    goto LABEL_15;
  }

  if (!strcmp(a1, "v@:I@"))
  {
    uint64_t v18 = MEMORY[0x1895F87A8];
    uint64_t v12 = &__block_descriptor_48_e14__28__0_8I16_20l;
    uint64_t v13 = __generateAccessorWithFunctionPtrSignature_block_invoke_4;
    p_blocuint64_t k = &v18;
    goto LABEL_15;
  }

  if (!strcmp(a1, "v@:@Q"))
  {
    uint64_t v17 = MEMORY[0x1895F87A8];
    uint64_t v12 = &__block_descriptor_48_e14__32__0_8_16Q24l;
    uint64_t v13 = __generateAccessorWithFunctionPtrSignature_block_invoke_5;
    p_blocuint64_t k = &v17;
    goto LABEL_15;
  }

  if (!strcmp(a1, "v@:@I"))
  {
    blocuint64_t k = MEMORY[0x1895F87A8];
    uint64_t v12 = &__block_descriptor_48_e14__28__0_8_16I24l;
    uint64_t v13 = __generateAccessorWithFunctionPtrSignature_block_invoke_6;
    p_blocuint64_t k = &block;
    goto LABEL_15;
  }

  if (!strcmp(a1, "v@:@@"))
  {
    uint64_t v15 = MEMORY[0x1895F87A8];
    uint64_t v12 = &__block_descriptor_48_e14__32__0_8_16_24l;
    uint64_t v13 = __generateAccessorWithFunctionPtrSignature_block_invoke_7;
    p_blocuint64_t k = &v15;
LABEL_15:
    p_block[1] = 3221225472LL;
    p_block[2] = (uint64_t)v13;
    p_block[3] = (uint64_t)v12;
    p_block[4] = a2;
    p_block[5] = a3;
    imp_implementationWithBlock(p_block);
    return;
  }

  _NSCoreDataLog( 1LL,  (uint64_t)@"generateAccessorWithFunctionPtrSignature failed with unknown signature '%s'",  v6,  v7,  v8,  v9,  v10,  v11,  (uint64_t)a1);
  __break(1u);
}

IMP generateAccessorType(int a1, uint64_t a2, int a3)
{
  v9[0] = MEMORY[0x1895F87A8];
  if (a1)
  {
    id v3 = _sharedIMPL_setvfk_core;
    uint64_t v4 = _sharedIMPL_setPvfk_core;
    BOOL v5 = a3 == 0;
    uint64_t v6 = __generateAccessor_block_invoke_2;
    uint64_t v7 = &__block_descriptor_48_e11__24__0_8_16l;
  }

  else
  {
    id v3 = _sharedIMPL_vfk_core;
    uint64_t v4 = _sharedIMPL_pvfk_core;
    BOOL v5 = a3 == 0;
    uint64_t v6 = __generateAccessor_block_invoke;
    uint64_t v7 = &__block_descriptor_48_e8__16__0_8l;
  }

  v9[1] = 3221225472LL;
  v9[2] = v6;
  v9[3] = v7;
  if (!v5) {
    id v3 = v4;
  }
  v9[4] = v3;
  v9[5] = a2;
  return imp_implementationWithBlock(v9);
}

void *_sharedIMPL_setvfk_core_c(void *a1, uint64_t a2, char a3, unint64_t a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___sharedIMPL_setvfk_core_c_block_invoke;
  v5[3] = &unk_189EA81E0;
  v5[4] = a1;
  v5[5] = a4;
  char v6 = a3;
  return _sharedIMPL_setvfk_core_scalar(a1, a4, (uint64_t)v5);
}

void *_sharedIMPL_setvfk_core_s(void *a1, uint64_t a2, __int16 a3, unint64_t a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___sharedIMPL_setvfk_core_s_block_invoke;
  v5[3] = &unk_189EA8208;
  v5[4] = a1;
  v5[5] = a4;
  __int16 v6 = a3;
  return _sharedIMPL_setvfk_core_scalar(a1, a4, (uint64_t)v5);
}

void *_sharedIMPL_setvfk_core_i(void *a1, uint64_t a2, int a3, unint64_t a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___sharedIMPL_setvfk_core_i_block_invoke;
  v5[3] = &unk_189EA8230;
  v5[4] = a1;
  v5[5] = a4;
  int v6 = a3;
  return _sharedIMPL_setvfk_core_scalar(a1, a4, (uint64_t)v5);
}

void *_sharedIMPL_setvfk_core_q(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___sharedIMPL_setvfk_core_q_block_invoke;
  v5[3] = &unk_189EA8258;
  v5[4] = a1;
  v5[5] = a4;
  void v5[6] = a3;
  return _sharedIMPL_setvfk_core_scalar(a1, a4, (uint64_t)v5);
}

void *_sharedIMPL_setvfk_core_i2q(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = ___sharedIMPL_setvfk_core_i2q_block_invoke;
  v5[3] = &unk_189EA8258;
  v5[4] = a1;
  v5[5] = a4;
  void v5[6] = a3;
  return _sharedIMPL_setvfk_core_scalar(a1, a4, (uint64_t)v5);
}

uint64_t _sharedIMPL_pvfk_core_c( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  if (_pvfk_header((unsigned int *)a1, a3, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v10 = *(void **)(a1 + 24);
    Class Class = object_getClass(v10);
    return (char)*((_BYTE *)v10 + *((unsigned int *)object_getIndexedIvars(Class) + v8 + 19));
  }

  else
  {
    return 0;
  }

uint64_t _sharedIMPL_pvfk_core_s( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  if (_pvfk_header((unsigned int *)a1, a3, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v10 = *(char **)(a1 + 24);
    Class Class = object_getClass(v10);
    return *(__int16 *)&v10[*((unsigned int *)object_getIndexedIvars(Class) + v8 + 19)];
  }

  else
  {
    return 0;
  }

uint64_t _sharedIMPL_pvfk_core_i( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  uint64_t result = _pvfk_header((unsigned int *)a1, a3, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    uint64_t v11 = *(char **)(a1 + 24);
    Class Class = object_getClass(v11);
    return *(unsigned int *)&v11[*((unsigned int *)object_getIndexedIvars(Class) + v8 + 19)];
  }

  return result;
}

uint64_t _sharedIMPL_pvfk_core_q( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  uint64_t v10 = *(char **)(a1 + 24);
  Class Class = object_getClass(v10);
  return *(void *)&v10[*((unsigned int *)object_getIndexedIvars(Class) + v8 + 19)];
}

uint64_t _sharedIMPL_pvfk_core_i2q( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  uint64_t v10 = *(char **)(a1 + 24);
  Class Class = object_getClass(v10);
  return *(int *)&v10[*((unsigned int *)object_getIndexedIvars(Class) + v8 + 19)];
}

float _sharedIMPL_pvfk_core_f( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  uint64_t v10 = *(char **)(a1 + 24);
  Class Class = object_getClass(v10);
  return *(float *)&v10[*((unsigned int *)object_getIndexedIvars(Class) + v8 + 19)];
}

uint64_t __generateAccessor_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void))(a1 + 32))(a2, 0LL, a3, *(void *)(a1 + 40));
}

uint64_t __generateAccessorWithFunctionPtrSignature_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void))(a1 + 32))(a2, 0LL, a3, *(void *)(a1 + 40));
}

uint64_t __generateAccessorWithFunctionPtrSignature_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, void))(a1 + 32))(a2, 0LL, a3, *(void *)(a1 + 40));
}

uint64_t __generateAccessorWithFunctionPtrSignature_block_invoke_3( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, void))(a1 + 32))( a2,  0LL,  a3,  a4,  *(void *)(a1 + 40));
}

uint64_t __generateAccessorWithFunctionPtrSignature_block_invoke_4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, void))(a1 + 32))( a2,  0LL,  a3,  a4,  *(void *)(a1 + 40));
}

uint64_t __generateAccessorWithFunctionPtrSignature_block_invoke_5( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, void))(a1 + 32))( a2,  0LL,  a3,  a4,  *(void *)(a1 + 40));
}

uint64_t __generateAccessorWithFunctionPtrSignature_block_invoke_6( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, void))(a1 + 32))( a2,  0LL,  a3,  a4,  *(void *)(a1 + 40));
}

uint64_t __generateAccessorWithFunctionPtrSignature_block_invoke_7( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, void))(a1 + 32))( a2,  0LL,  a3,  a4,  *(void *)(a1 + 40));
}

void *_sharedIMPL_setvfk_core_scalar(void *a1, unint64_t a2, uint64_t a3)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl([a1 managedObjectContext], sel_setValue_forKey_);
  }
  int v6 = _PFEntityForManagedObject(a1);
  uint64_t v7 = *(void *)(_kvcPropertysPrimitiveSetters((uint64_t)v6) + 8 * a2);
  uint64_t v8 = *(void *)(*(void *)(v6[12] + 16LL) + 40LL);
  uint64_t v9 = *(void *)(v8 + 8 * a2);
  int v10 = *((_DWORD *)a1 + 4);
  if ((v10 & 0x40000) != 0) {
    _PF_ManagedObject_WillChangeValueForKeyIndex((uint64_t)a1, (uint64_t)sel_willChangeValueForKey_, v9, a2, 0);
  }
  else {
    [a1 willChangeValueForKey:*(void *)(v8 + 8 * a2)];
  }
  _PF_CopyOnWrite_Snapshot(a1);
  (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v7);
  if ((v10 & 0x40000) != 0) {
    return _PF_ManagedObject_DidChangeValueForKeyIndex(a1, (uint64_t)sel_didChangeValueForKey_, v9, a2);
  }
  else {
    return (void *)[a1 didChangeValueForKey:v9];
  }
}

unsigned int *___sharedIMPL_setvfk_core_c_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return snapshot_set_int8(*(void **)(*(void *)(a1 + 32) + 24LL), *(_DWORD *)(a1 + 40), *(_BYTE *)(a1 + 48));
  }
  [MEMORY[0x189607968] numberWithChar:*(char *)(a1 + 48)];
  return (unsigned int *)_NSSetUsingKeyValueSetter();
}

unsigned int *___sharedIMPL_setvfk_core_s_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return snapshot_set_int16(*(char **)(*(void *)(a1 + 32) + 24LL), *(_DWORD *)(a1 + 40), *(_WORD *)(a1 + 48));
  }
  [MEMORY[0x189607968] numberWithShort:*(__int16 *)(a1 + 48)];
  return (unsigned int *)_NSSetUsingKeyValueSetter();
}

unsigned int *___sharedIMPL_setvfk_core_i_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return snapshot_set_int32(*(char **)(*(void *)(a1 + 32) + 24LL), *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 48));
  }
  [MEMORY[0x189607968] numberWithInt:*(unsigned int *)(a1 + 48)];
  return (unsigned int *)_NSSetUsingKeyValueSetter();
}

unsigned int *___sharedIMPL_setvfk_core_q_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return snapshot_set_int64(*(char **)(*(void *)(a1 + 32) + 24LL), *(_DWORD *)(a1 + 40), *(void *)(a1 + 48));
  }
  [MEMORY[0x189607968] numberWithLongLong:*(void *)(a1 + 48)];
  return (unsigned int *)_NSSetUsingKeyValueSetter();
}

unsigned int *___sharedIMPL_setvfk_core_i2q_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return snapshot_set_int32(*(char **)(*(void *)(a1 + 32) + 24LL), *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 48));
  }
  [MEMORY[0x189607968] numberWithInt:*(unsigned int *)(a1 + 48)];
  return (unsigned int *)_NSSetUsingKeyValueSetter();
}

unsigned int *___sharedIMPL_setvfk_core_d_block_invoke(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return snapshot_set_double(*(char **)(*(void *)(a1 + 32) + 24LL), *(_DWORD *)(a1 + 40), *(double *)(a1 + 48));
  }
  [MEMORY[0x189607968] numberWithDouble:*(double *)(a1 + 48)];
  return (unsigned int *)_NSSetUsingKeyValueSetter();
}

unsigned int *___sharedIMPL_setvfk_core_f_block_invoke(uint64_t a1, uint64_t a2, double a3)
{
  if (!a2) {
    return snapshot_set_float(*(char **)(*(void *)(a1 + 32) + 24LL), *(_DWORD *)(a1 + 40), *(float *)(a1 + 48));
  }
  LODWORD(a3) = *(_DWORD *)(a1 + 48);
  [MEMORY[0x189607968] numberWithFloat:a3];
  return (unsigned int *)_NSSetUsingKeyValueSetter();
}

BOOL _PFIsSerializedWithMainQueue()
{
  return pthread_main_np() || dispatch_get_specific("com.apple.CoreData.NSManagedObjectContext.mainQueue") != 0LL;
}

BOOL PFUseToolchainBehaviors()
{
  return byte_18C4ABA01 != 0;
}

uint64_t _deallocateContextBackgroundThread(uint64_t a1)
{
  int v2 = *(void **)(a1 + 24);
  -[NSManagedObjectContext _dispose:]((uint64_t)v2);
  _PFDeallocateObject(v2);
  *(void *)(a1 + 24) = 0LL;
  return 0LL;
}

void sub_18674E89C(_Unwind_Exception *a1)
{
}

void sub_18674E8B8()
{
}

void sub_18674F0F4(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18674F0C8LL);
  }

  JUMPOUT(0x18674F08CLL);
}

void internal_PF_actor_clear_for_dealloc(uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v3 = *(void *)(StatusReg + 712);
  if (v3 == a1)
  {
    *(void *)(StatusReg + 712) = 0LL;
  }

  else if (v3)
  {
    uint64_t v4 = (unint64_t *)(v3 + 8);
    unint64_t v5 = atomic_load((unint64_t *)(v3 + 8));
    if (v5 == a1)
    {
      while (1)
      {
        unint64_t v6 = __ldaxr(v4);
        if (v6 != v5) {
          break;
        }
        if (!__stlxr(0LL, v4)) {
          goto LABEL_10;
        }
      }

      __clrex();
      uint64_t v7 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
      atomic_load((unint64_t *)(v3 + 8));
      _NSCoreDataLog(17LL, v7, v8, v9, v10, v11, v12, v13, v3);
      uint64_t v14 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        unint64_t v15 = atomic_load((unint64_t *)(v3 + 8));
        *(_DWORD *)buf = 134218752;
        uint64_t v30 = v3;
        __int16 v31 = 2048;
        uint64_t v32 = 0LL;
        __int16 v33 = 2048;
        unint64_t v34 = v5;
        __int16 v35 = 2048;
        unint64_t v36 = v15;
        _os_log_fault_impl( &dword_186681000,  v14,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
      }
    }
  }

LABEL_10:
  if (a1)
  {
    uint64_t v16 = (unint64_t *)(a1 + 8);
    unint64_t v17 = atomic_load((unint64_t *)(a1 + 8));
    do
    {
      unint64_t v18 = __ldaxr(v16);
      if (v18 != v17)
      {
        while (1)
        {
          __clrex();
          uint64_t v19 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
          atomic_load((unint64_t *)(a1 + 8));
          _NSCoreDataLog(17LL, v19, v20, v21, v22, v23, v24, v25, a1);
          uint64_t v26 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            unint64_t v28 = atomic_load((unint64_t *)(a1 + 8));
            *(_DWORD *)buf = 134218752;
            uint64_t v30 = a1;
            __int16 v31 = 2048;
            uint64_t v32 = 0LL;
            __int16 v33 = 2048;
            unint64_t v34 = v17;
            __int16 v35 = 2048;
            unint64_t v36 = v28;
            _os_log_fault_impl( &dword_186681000,  v26,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
          }

          unint64_t v17 = atomic_load(v16);
          while (1)
          {
            unint64_t v27 = __ldaxr(v16);
            if (v27 != v17) {
              break;
            }
            if (!__stlxr(0LL, v16)) {
              goto LABEL_14;
            }
          }
        }
      }
    }

    while (__stlxr(0LL, v16));
  }

  unint64_t v18 = (unint64_t *)(v2 + 8);
  uint64_t v19 = atomic_load((unint64_t *)(v2 + 8));
  do
  {
    uint64_t v20 = __ldaxr(v18);
    if (v20 != v19)
    {
      while (1)
      {
        __clrex();
        uint64_t v23 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
        atomic_load((unint64_t *)(v2 + 8));
        _NSCoreDataLog(17LL, v23, v24, v25, v26, v27, v28, v29, v2);
        uint64_t v30 = (os_log_s *)__pflogFaultLog;
        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
        {
          uint64_t v32 = atomic_load((unint64_t *)(v2 + 8));
          *(_DWORD *)buf = 134218752;
          __int16 v35 = v2;
          unint64_t v36 = 2048;
          uint64_t v37 = 0LL;
          uint64_t v38 = 2048;
          id v39 = v19;
          uint64_t v40 = 2048;
          unint64_t v41 = v32;
          _os_log_fault_impl( &dword_186681000,  v30,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
        }

        uint64_t v19 = atomic_load(v18);
        while (1)
        {
          __int16 v31 = __ldaxr(v18);
          if (v31 != v19) {
            break;
          }
          if (!__stlxr(0LL, v18)) {
            goto LABEL_13;
          }
        }
      }
    }
  }

  while (__stlxr(0LL, v18));
LABEL_13:
  __dmb(0xBu);
  *(void *)(v2 + 16) = 0LL;
  global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __39__NSPersistentStoreCoordinator_dealloc__block_invoke_2;
  block[3] = &unk_189EA86D8;
  uint64_t v22 = *(void *)(a1 + 32);
  block[4] = v3;
  block[5] = v22;
  dispatch_async(global_queue, block);
}

  if (!a4) {
    return 0;
  }
  uint64_t v13 = (void *)MEMORY[0x189607870];
  uint64_t v14 = [MEMORY[0x189603F68] dictionaryWithObject:a3 forKey:@"NSManagedObjectContext is nil for objects passed to obtainPermanentIDsForObjects"];
  unint64_t v15 = 0;
  *a4 = (id)[v13 errorWithDomain:*MEMORY[0x189607460] code:134060 userInfo:v14];
  return v15;
}

    objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58], objc_msgSend( NSString, "stringWithFormat:", @"Can't find entity for batch update (%@)", self->_entity), 0 reason userInfo]);
    unint64_t v15 = v14;
    objc_end_catch();
    _Unwind_Resume(v15);
  }

  v24[5] = 0LL;
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&v29, 8);
  return v10;
}

  return v2;
}

  v7->_fileBackedFuturesDirectory = (NSString *)(id)[a5 fileBackedFuturesDirectory];
  sqlCore = v7->super._sqlCore;
  if (sqlCore) {
    uint64_t v12 = -[NSSQLCore rowCacheForGeneration:](sqlCore, (void *)[0 _queryGenerationToken]);
  }
  else {
    uint64_t v12 = 0LL;
  }
  primaryRowCache = v12;
  v7->_primaryRowCache = primaryRowCache;
  uint64_t v14 = v7->super._sqlCore;
  if (v14)
  {
    unint64_t v15 = (NSSQLRowCache *)-[NSSQLCore rowCacheForGeneration:](v14, (void *)[a4 _queryGenerationToken]);
    primaryRowCache = v7->_primaryRowCache;
  }

  else
  {
    unint64_t v15 = 0LL;
  }

  if (v15 != primaryRowCache) {
    v7->_contextGenerationRowCache = v15;
  }
  return v7;
}

  uint64_t v8 = v41;
  if (a3)
  {
    if (v41)
    {
      *a3 = v41;
      uint64_t v8 = v41;
    }
  }

  return v8 == 0LL;
}

void sub_186750A6C(void *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    objc_begin_catch(a1);
    JUMPOUT(0x186750784LL);
  }

  JUMPOUT(0x1867509DCLL);
}

void sub_186750A8C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186750A98LL);
  }

  JUMPOUT(0x1867509DCLL);
}

void _PFFastMOCObjectWillChange(uint64_t a1, _DWORD *a2)
{
  if (_PF_Threading_Debugging_level) {
    _PFAssertSafeMultiThreadedAccess_impl(a1, sel_objectWillChange_);
  }
  int v4 = a2[4];
  if ((v4 & 7) == 0)
  {
    if ((v4 & 0x80) != 0)
    {
      uint64_t v20 = [a2 objectID];
      _NSCoreDataLog( 1LL,  (uint64_t)@"Mutating a managed object %@ (%p) after it has been removed from its context.",  v6,  v7,  v8,  v9,  v10,  v11,  v20);
    }

    else if (a1)
    {
      if ((v4 & 0x80) != 0) {
        uint64_t v5 = 0LL;
      }
      else {
        uint64_t v5 = *((void *)a2 + 4);
      }
      if (v5 == a1)
      {
        -[NSManagedObjectContext _establishEventSnapshotsForObject:](a1, a2);
        int v19 = *(_DWORD *)(a1 + 40);
        if ((v19 & 0x200) != 0 && (v19 & 0x100) == 0)
        {
          _PFFaultLogExcessivePrepareForPendingChangesAttempts();
          int v19 = *(_DWORD *)(a1 + 40);
        }

        *(_DWORD *)(a1 + 40) = v19 | 0x100;
        [*(id *)(a1 + 56) addObject:a2];
        a2[4] |= 1u;
        -[NSManagedObjectContext _registerClearStateWithUndoManager](a1);
        -[NSManagedObjectContext _enqueueEndOfEventNotification](a1);
        if ((*(_BYTE *)(a1 + 41) & 4) == 0)
        {
          [(id)a1 willChangeValueForKey:@"hasChanges"];
          *(_DWORD *)(a1 + 40) |= 0x400u;
          [(id)a1 didChangeValueForKey:@"hasChanges"];
        }
      }

      else
      {
        uint64_t v12 = [a2 objectID];
        _NSCoreDataLog( 1LL,  (uint64_t)@"Mutating a managed object %@ (%p) that has a different context %p than the receiver %p.",  v13,  v14,  v15,  v16,  v17,  v18,  v12);
      }
    }
  }

void sub_186751F48(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186751F14LL);
  }

  _Unwind_Resume(a1);
}

void sub_186751F70()
{
}

void sub_186751F88(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x186751E10LL);
  }

  _Unwind_Resume(a1);
}

void sub_186751F9C()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x186751FA4LL);
  }
  JUMPOUT(0x186751FA8LL);
}

void sub_186751FB0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  _Unwind_Resume(a1);
}

void sub_1867521DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint8_t buf)
{
}

void sub_186752FA8(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186752F78LL);
  }

  JUMPOUT(0x186752F08LL);
}

void sub_186752FC8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x186752F04LL);
  }
  objc_terminate();
  -[NSManagedObjectContext _prepareForPushChanges:](v2, v3);
}

void sub_186753274()
{
}

void sub_186753F2C(_Unwind_Exception *a1)
{
}

void sub_186753F40(_Unwind_Exception *a1)
{
}

void sub_186753F58(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_terminate();
    uint64_t v3 = v2;
    if (v4)
    {
      objc_begin_catch(v2);
      JUMPOUT(0x186753D90LL);
    }
  }

  else
  {
    uint64_t v3 = a1;
  }

  _Unwind_Resume(v3);
}

void __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
}

void _perform(unint64_t a1, uint64_t a2)
{
  context[4] = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v2 = *(dispatch_queue_s **)(a1 + 24);
    if (v2)
    {
      uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 712);
      context[0] = a2;
      context[1] = a1;
      context[2] = 0LL;
      context[3] = v3;
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)(a1 + 49));
      if ((v4 & 1) != 0)
      {
        if (_PFIsSerializedWithMainQueue())
        {
LABEL_25:
          internalBlockToNSManagedObjectContextPerform(context);
          return;
        }
      }

      else if (v3)
      {
        unint64_t v5 = 0LL;
        int v6 = 0;
        unint64_t v7 = v3;
        while (v7 != a1)
        {
          if (v7 == v5) {
            goto LABEL_15;
          }
          if (!v5) {
            unint64_t v5 = v7;
          }
          unint64_t v7 = atomic_load((unint64_t *)(v7 + 8));
          if (!v7) {
            goto LABEL_16;
          }
        }

        int v6 = 1;
LABEL_15:
        if (v6) {
          goto LABEL_25;
        }
LABEL_16:
        unint64_t v8 = 0LL;
        int v9 = 0;
        while (a1 != v3)
        {
          if (a1 == v8) {
            goto LABEL_24;
          }
          if (!v8) {
            unint64_t v8 = a1;
          }
          a1 = atomic_load((unint64_t *)(a1 + 8));
          if (!a1) {
            goto LABEL_26;
          }
        }

        int v9 = 1;
LABEL_24:
        if (v9) {
          goto LABEL_25;
        }
      }

void sub_1867553C4(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867553A8LL);
  }
  objc_terminate();
  -[NSManagedObjectContext _countForFetchRequest_:error:](v2, v3, v4);
}

void sub_186755D80(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186755D48LL);
  }

  _Unwind_Resume(a1);
}

void sub_186755DA0(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    JUMPOUT(0x186755DA8LL);
  }
  _Unwind_Resume(a1);
}

void sub_186755DB0(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x186755DBCLL);
}

void sub_186756420(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867563ECLL);
  }

  _Unwind_Resume(a1);
}

void sub_186756440(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    JUMPOUT(0x186756448LL);
  }
  _Unwind_Resume(a1);
}

void sub_186756450(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x18675645CLL);
}

void sub_1867566F8()
{
}

void sub_186756708()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x186756710LL);
  }
  JUMPOUT(0x186756714LL);
}

LABEL_119:
  uint64_t v61 = [*(id *)(v1 + 32) fetchLimit];
  if (v61)
  {
    uint64_t v62 = v61;
    if ([*(id *)(*(void *)(*(void *)(v1 + 56) + 8) + 40) count] > v61)
    {
      uint64_t v63 = (id)objc_msgSend( *(id *)(*(void *)(*(void *)(v1 + 56) + 8) + 40),  "subarrayWithRange:",  0,  v62);

      *(void *)(*(void *)(*(void *)(v1 + 56) + 8LL) + 40LL) = v63;
    }
  }

  char v64 = [*(id *)(*(void *)(*(void *)(v1 + 64) + 8) + 40) progress];
  if (v64)
  {
    uint64_t v65 = (void *)v64;
    uint64_t v66 = [*(id *)(*(void *)(*(void *)(v1 + 56) + 8) + 40) count];
    uint64_t v67 = [v65 completedUnitCount];
    [v65 setTotalUnitCount:v66];
    if (v67 != v66) {
      objc_msgSend( v65,  "setCompletedUnitCount:",  objc_msgSend(*(id *)(*(void *)(*(void *)(v1 + 56) + 8) + 40), "count"));
    }
  }

  -[NSAsynchronousFetchResult setFinalResult:]( *(void *)(*(void *)(*(void *)(v1 + 64) + 8LL) + 40LL),  *(id *)(*(void *)(*(void *)(v1 + 56) + 8LL) + 40LL));
  [*(id *)(*(void *)(*(void *)(v1 + 64) + 8) + 40) setOperationError:0];
  if ([*(id *)(v1 + 48) completionBlock])
  {
    uint64_t v68 = [*(id *)(v1 + 48) completionBlock];
    (*(void (**)(uint64_t, void))(v68 + 16))( v68,  *(void *)(*(void *)(*(void *)(v1 + 64) + 8LL) + 40LL));
  }

  return *(id *)(*(void *)(*(void *)(v1 + 64) + 8LL) + 40LL);
}

void sub_1867575E8(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867575C4LL);
  }

  JUMPOUT(0x186757590LL);
}

void sub_18675808C()
{
}

void sub_186758098()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x1867580A0LL);
  }
  JUMPOUT(0x1867580A4LL);
}

void sub_186758188()
{
}

void sub_186758194()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x18675819CLL);
  }
  JUMPOUT(0x1867581A0LL);
}

dispatch_queue_t createQueueForMOC(void *a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  __str[0] = 0;
  id v2 = (id)[*(id *)(a1[21] + 168) copy];
  if (v2)
  {
    uint64_t v3 = v2;
    snprintf(__str, 0x1FFuLL, "NSManagedObjectContext %p: ", a1);
    [v3 UTF8String];
    __strlcat_chk();
  }

  else
  {
    snprintf(__str, 0x1FFuLL, "NSManagedObjectContext %p", a1);
  }

  dispatch_queue_t v4 = dispatch_queue_create(__str, 0LL);
  dispatch_set_context(v4, a1);
  return v4;
}

void sub_186759BCC(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186759B9CLL);
  }

  JUMPOUT(0x186759B64LL);
}

void sub_18675A668( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18675A85C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18675AAFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_18675AF2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t _PF_actor_set_owner(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  int v6 = (unint64_t *)(a2 + 8);
  while (1)
  {
    unint64_t v7 = __ldaxr(v6);
    if (v7 != a1) {
      break;
    }
    if (!__stlxr(a3, v6)) {
      return 1LL;
    }
  }

  uint64_t v8 = 0LL;
  __clrex();
  uint64_t v9 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
  atomic_load((unint64_t *)(a2 + 8));
  _NSCoreDataLog(17LL, v9, v10, v11, v12, v13, v14, v15, a2);
  uint64_t v16 = (os_log_s *)__pflogFaultLog;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    unint64_t v18 = atomic_load((unint64_t *)(a2 + 8));
    *(_DWORD *)buf = 134218752;
    uint64_t v20 = a2;
    __int16 v21 = 2048;
    unint64_t v22 = a3;
    __int16 v23 = 2048;
    uint64_t v24 = a1;
    __int16 v25 = 2048;
    unint64_t v26 = v18;
    _os_log_fault_impl( &dword_186681000,  v16,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
  }

  return v8;
}

id _PFRetainedObjectIDCore(uint64_t a1, void *a2, void *a3, char a4)
{
  int v6 = a2;
  v23[1] = *MEMORY[0x1895F89C0];
  uint64_t v8 = (void *)[a2 persistentStore];
  uint64_t v9 = [v8 _persistentStoreCoordinator];
  uint64_t v10 = (void *)[(id)a1 persistentStoreCoordinator];
  if (v8) {
    int v11 = [v6 _isPersistentStoreAlive] ^ 1;
  }
  else {
    int v11 = 1;
  }
  if (*(void *)(*(void *)(a1 + 168) + 8LL))
  {
    if ([v6 isTemporaryID])
    {
      if (!_PFCMT_GetValue(*(void **)(a1 + 120), v6))
      {
        uint64_t v12 = [**(id **)(*(void *)(a1 + 168) + 8) objectForKey:v6];
        if (v12) {
          int v6 = (void *)v12;
        }
      }
    }
  }

  else {
    int v13 = 1;
  }
  uint64_t v15 = (const __CFURL *)[v6 URIRepresentation];
  if ([v6 isTemporaryID])
  {
    uint64_t v16 = 133000LL;
    id v17 = (id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"Temporary object ID refers to object in different NSPersistentStoreCoordinator" userInfo:0];
    if ((a4 & 1) == 0)
    {
LABEL_18:
      if (!a3) {
        return 0LL;
      }
      if (v17) {
        id v17 = (id)objc_msgSend( objc_alloc(MEMORY[0x189603F68]),  "initWithObjectsAndKeys:",  v17,  @"NSUnderlyingException",  0);
      }
LABEL_27:
      *a3 = [MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460] code:v16 userInfo:v17];

      return 0LL;
    }

void *sub_18675D288(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  objc_terminate();
  return -[NSManagedObjectContext _clearOriginalSnapshotAndInitializeRec:](v2);
}

void sub_18675D2A0(_Unwind_Exception *a1)
{
  if (v1) {
    JUMPOUT(0x18675D2A8LL);
  }
  _Unwind_Resume(a1);
}

void _PFFaultLogExcessivePrepareForPendingChangesAttempts()
{
  uint64_t v0 = [NSString stringWithUTF8String:"About to exceed _prepareForPushChanges limit. Set a breakpoint on _PFFaultLogExcessivePrepareForPendingChangesA ttempts to stop here in the debugger."];
  _NSCoreDataLog(17LL, v0, v1, v2, v3, v4, v5, v6, v8);
  unint64_t v7 = (os_log_s *)__pflogFaultLog;
  if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
  {
    LOWORD(v_Block_object_dispose(va, 8) = 0;
    _os_log_fault_impl( &dword_186681000,  v7,  OS_LOG_TYPE_FAULT,  "CoreData: About to exceed _prepareForPushChanges limit. Set a breakpoint on _PFFaultLogExcessivePrepareForPendingC hangesAttempts to stop here in the debugger.",  (uint8_t *)&v8,  2u);
  }

void sub_18676023C()
{
}

void sub_186760248()
{
  if (v0) {
    JUMPOUT(0x186760250LL);
  }
  JUMPOUT(0x186760254LL);
}

void sub_1867603FC(void *a1)
{
}

void sub_186760408(_Unwind_Exception *a1)
{
}

void sub_186761330( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18676202C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186762000LL);
  }

  JUMPOUT(0x186762040LL);
}

void _performRunLoopAction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return;
  }
  uint64_t v4 = (os_unfair_lock_s *)(a3 + 12);
  os_unfair_lock_lock_with_options();
  if ((*(_DWORD *)(a3 + 20) & 0x80000000) != 0)
  {
    os_unfair_lock_unlock(v4);
    return;
  }

  *(_DWORD *)(a3 + 20) = 0;
  os_unfair_lock_unlock(v4);
  os_unfair_lock_lock_with_options();
  v6 = *(void *)(a3 + 24) && (uint64_t v5 = *(const __CFArray **)(a3 + 32)) != 0LL && CFArrayGetCount(v5) > 0;
  os_unfair_lock_unlock(v4);
  uint64_t v7 = *(void *)(a3 + 24);
  if (!v7 || *(_DWORD *)(v7 + 16) || (int v8 = *(_DWORD *)(v7 + 40), (v8 & 8) != 0))
  {
    int v9 = 0;
LABEL_13:
    if ((v6 | v9) != 1) {
      return;
    }
    goto LABEL_14;
  }

  if ((v8 & 0x100) == 0)
  {
    int v9 = *(_DWORD *)(v7 + 40) & 1;
    goto LABEL_13;
  }

  int v9 = 1;
LABEL_14:
  id v10 = objc_alloc_init(MEMORY[0x1896077E8]);
  id WeakRetained = (id *)+[_PFWeakReference weakReferenceWithObject:]((uint64_t)&OBJC_CLASS____PFWeakReference, v7);
  if (WeakRetained) {
    id WeakRetained = (id *)objc_loadWeakRetained(WeakRetained + 1);
  }
  uint64_t v12 = WeakRetained;
  if (v12
    && (int v13 = v12, !*((_DWORD *)v12 + 4))
    && (v9 & ([v12 _isDeallocating] ^ 1) & 1) != 0
    && ((_PF_USE_IOS_PLATFORM & 1) != 0
     || !objc_msgSend((id)objc_msgSend(v13, "undoManager"), "groupsByEvent")))
  {
    [v13 processPendingChanges];
  }

  else
  {
    -[_PFManagedObjectReferenceQueue _processReferenceQueue:](a3, 0);
  }

  [v10 drain];
}

id _PFRetainedObjectForMappedChildObjectIDInParentContext(void *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  if (*(void *)(*(void *)(a2 + 168) + 8LL))
  {
    if ([a1 isTemporaryID])
    {
      uint64_t v4 = [**(id **)(*(void *)(a2 + 168) + 8) objectForKey:v3];
      if (v4) {
        uint64_t v3 = (void *)v4;
      }
    }
  }

  return _PFRetainedObjectIDCore(a2, v3, 0LL, 1);
}

void sub_186762FA0(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186762F74LL);
  }

  JUMPOUT(0x186762F3CLL);
}

void sub_186763140( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_186763D58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_186763F8C(_Unwind_Exception *a1)
{
}

void sub_186763FA8()
{
}

void sub_18676405C(_Unwind_Exception *a1)
{
}

void sub_186764468( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_186764758( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_186764D20(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186764CF0LL);
  }

  _Unwind_Resume(a1);
}

void sub_186764D34(_Unwind_Exception *a1)
{
  if (v1) {
    JUMPOUT(0x186764D3CLL);
  }
  _Unwind_Resume(a1);
}

void sub_186764D44(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x186764A7CLL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_186764D5C(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    JUMPOUT(0x186764D64LL);
  }
  _Unwind_Resume(a1);
}

void sub_186764D6C(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x186764D78LL);
}

void sub_186765088( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void internalBlockToNSManagedObjectContextPerform(uint64_t *a1)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *a1;
  unint64_t v2 = a1[1];
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  uint64_t v4 = *(void *)(StatusReg + 712);
  uint64_t v5 = a1[3];
  if (v5)
  {
    BOOL v6 = *(dispatch_queue_s **)(v5 + 16);
    if (v6) {
      BOOL v7 = _PF_Threading_Debugging_level < 2;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7) {
      dispatch_assert_queue_V2(v6);
    }
    if (v4 != v2)
    {
      int v8 = (unint64_t *)(v5 + 8);
      unint64_t v9 = atomic_load((unint64_t *)(v5 + 8));
      do
      {
        unint64_t v10 = __ldaxr(v8);
        if (v10 != v9)
        {
          unint64_t v14 = 0x189607000uLL;
          uint64_t v15 = "Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)";
          while (1)
          {
            __clrex();
            unint64_t v16 = v14;
            uint64_t v17 = v15;
            uint64_t v18 = objc_msgSend(*(id *)(v14 + 2600), "stringWithUTF8String:");
            atomic_load((unint64_t *)(v5 + 8));
            _NSCoreDataLog(17LL, v18, v19, v20, v21, v22, v23, v24, v5);
            __int16 v25 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              unint64_t v27 = atomic_load((unint64_t *)(v5 + 8));
              *(_DWORD *)buf = 134218752;
              uint64_t v50 = v5;
              __int16 v51 = 2048;
              unint64_t v52 = v2;
              __int16 v53 = 2048;
              unint64_t v54 = v9;
              __int16 v55 = 2048;
              unint64_t v56 = v27;
              _os_log_fault_impl( &dword_186681000,  v25,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
            }

            unint64_t v9 = atomic_load(v8);
            unint64_t v14 = v16;
            uint64_t v15 = v17;
            while (1)
            {
              unint64_t v26 = __ldaxr(v8);
              if (v26 != v9) {
                break;
              }
              if (!__stlxr(v2, v8)) {
                goto LABEL_13;
              }
            }
          }
        }
      }

      while (__stlxr(v2, v8));
      goto LABEL_13;
    }

    unint64_t v9 = 0LL;
LABEL_15:
    char v11 = 1;
    goto LABEL_16;
  }

  unint64_t v9 = 0LL;
  if (v4 == v2) {
    goto LABEL_15;
  }
LABEL_13:
  char v11 = 0;
  *(void *)(StatusReg + 712) = v2;
LABEL_16:
  (*(void (**)(uint64_t))(v1 + 16))(v1);
  if ((v11 & 1) == 0)
  {
    *(void *)(StatusReg + 712) = v4;
    if (v5)
    {
      uint64_t v12 = (unint64_t *)(v5 + 8);
      while (1)
      {
        unint64_t v13 = __ldaxr(v12);
        if (v13 != v2) {
          break;
        }
        if (!__stlxr(v9, v12)) {
          return;
        }
      }

      __clrex();
      uint64_t v28 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
      atomic_load((unint64_t *)(v5 + 8));
      _NSCoreDataLog(17LL, v28, v29, v30, v31, v32, v33, v34, v5);
      __int16 v35 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        unint64_t v48 = atomic_load((unint64_t *)(v5 + 8));
        *(_DWORD *)buf = 134218752;
        uint64_t v50 = v5;
        __int16 v51 = 2048;
        unint64_t v52 = v9;
        __int16 v53 = 2048;
        unint64_t v54 = v2;
        __int16 v55 = 2048;
        unint64_t v56 = v48;
        _os_log_fault_impl( &dword_186681000,  v35,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
      }

      unint64_t v36 = atomic_load(v12);
      do
      {
        unint64_t v37 = __ldaxr(v12);
        if (v37 != v36)
        {
          while (1)
          {
            __clrex();
            uint64_t v38 = [NSString stringWithUTF8String:"Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)"];
            atomic_load((unint64_t *)(v5 + 8));
            _NSCoreDataLog(17LL, v38, v39, v40, v41, v42, v43, v44, v5);
            __int128 v45 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              unint64_t v47 = atomic_load(v12);
              *(_DWORD *)buf = 134218752;
              uint64_t v50 = v5;
              __int16 v51 = 2048;
              unint64_t v52 = v9;
              __int16 v53 = 2048;
              unint64_t v54 = v36;
              __int16 v55 = 2048;
              unint64_t v56 = v47;
              _os_log_fault_impl( &dword_186681000,  v45,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to set actor (%p) new owner (%p).  Expected previous (%p) is now (%p)",  buf,  0x2Au);
            }

            unint64_t v36 = atomic_load(v12);
            while (1)
            {
              unint64_t v46 = __ldaxr(v12);
              if (v46 != v36) {
                break;
              }
              if (!__stlxr(v9, v12)) {
                return;
              }
            }
          }
        }
      }

      while (__stlxr(v9, v12));
    }
  }

void sub_186765644(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) != 0) {
    objc_end_catch();
  }
  _Unwind_Resume(exception_object);
}

void __internalBlockToDeallocNSManagedObjectContext_block_invoke(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 40);
  id v3 = objc_alloc_init(MEMORY[0x1896077E8]);
  -[NSManagedObjectContext _dealloc__]((uint64_t)v2);
  MEMORY[0x186E3F1B4]([v3 drain]);
  internal_PF_actor_clear_for_dealloc((uint64_t)v2);
  v2[3] = 0LL;
  *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 712) = 0LL;
  if (!*(_DWORD *)(a1 + 48)) {
    objc_destructInstance(v2);
  }
  dispatch_time_t v4 = dispatch_time(0LL, 3000000000LL);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __internalBlockToDeallocNSManagedObjectContext_block_invoke_2;
  block[3] = &unk_189EA8690;
  int v8 = *(_DWORD *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 40);
  block[4] = *(void *)(a1 + 32);
  block[5] = v6;
  dispatch_after(v4, global_queue, block);
}

void __internalBlockToDeallocNSManagedObjectContext_block_invoke_2(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    unint64_t v2 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      unint64_t v2 = malloc_default_zone();
    }
    malloc_zone_free(v2, *(void **)(a1 + 40));
  }

void sub_186765F40(_Unwind_Exception *a1)
{
}

void sub_18676A65C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,void (*a56)(char *))
{
}

void sub_18676BE3C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18676BE10LL);
  }

  _Unwind_Resume(a1);
}

void sub_18676BE4C(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    JUMPOUT(0x18676BE54LL);
  }
  _Unwind_Resume(a1);
}

BOOL sub_18676BE5C(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18676BE64LL);
  }
  objc_terminate();
  return +[NSManagedObjectModel versionHashes:compatibleWithStoreMetadata:](v2, v3, v4, v5);
}

LABEL_187:
                if (v174 == ++v176)
                {
                  uint64_t v174 = [v172 countByEnumeratingWithState:&v406 objects:v459 count:16];
                  if (!v174)
                  {
LABEL_191:
                    unint64_t v120 = (void *)v338;
                    unint64_t v122 = v339;
                    int v123 = v335;
                    unint64_t v124 = v341;
                    goto LABEL_192;
                  }

                  continue;
                }

                goto LABEL_179;
              }

              break;
            }

            unsigned int v189 = v328;
            if (!v328) {
              goto LABEL_211;
            }
            uint64_t v190 = (void *)MEMORY[0x189607870];
            uint64_t v191 = *MEMORY[0x189607460];
            uint64_t v192 = [MEMORY[0x189603F68] dictionaryWithObject:@"Invalid value in warnings array" forKey:@"Base error"];
LABEL_208:
            unint64_t v193 = 0LL;
            *unsigned int v189 = [v190 errorWithDomain:v191 code:134060 userInfo:v192];
            break;
          case 7LL:
            unsigned int v189 = v328;
            if (!v328) {
              goto LABEL_211;
            }
            uint64_t v190 = (void *)MEMORY[0x189607870];
            uint64_t v191 = *MEMORY[0x189607460];
            uint64_t v192 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Unsupported property; can't optimize composite attribute",
                     @"Base error",
                     v125,
                     @"Property",
                     0LL);
            goto LABEL_208;
          default:
            unsigned int v189 = v328;
            if (!v328) {
              goto LABEL_211;
            }
            uint64_t v190 = (void *)MEMORY[0x189607870];
            uint64_t v191 = *MEMORY[0x189607460];
            uint64_t v192 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Invalid property; can't optimize",
                     @"Base error",
                     v125,
                     @"Property",
                     0LL);
            goto LABEL_208;
        }

LABEL_212:
        unint64_t v194 = Mutable;
        int v195 = v344;
        v196 = v333;
        v197 = v334;
        unint64_t v198 = v336;
        if (!Mutable) {
          goto LABEL_214;
        }
LABEL_213:
        CFRelease(v194);
        goto LABEL_214;
      }

LABEL_194:
      uint64_t v180 = -[NSSQLModel entityNamed:](v327, "entityNamed:", v322);
      v402 = 0u;
      v403 = 0u;
      v404 = 0u;
      v405 = 0u;
      v181 = (void *)-[NSSQLEntity properties](v180);
      uint64_t v182 = [v181 countByEnumeratingWithState:&v402 objects:v458 count:16];
      if (v182)
      {
        uint64_t v183 = v182;
        uint64_t v184 = *(void *)v403;
        do
        {
          for (iuint64_t i = 0LL; ii != v183; ++ii)
          {
            if (*(void *)v403 != v184) {
              objc_enumerationMutation(v181);
            }
            int v186 = [*(id *)(*((void *)&v402 + 1) + 8 * ii) name];
            if (!-[__CFDictionary objectForKey:](v350, "objectForKey:", v186))
            {
              unint64_t v187 = objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedInteger:", -[__CFArray count](v29, "count"));
              -[__CFArray addObject:](v29, "addObject:", v186);
              unint64_t v188 = v187;
              __int16 v53 = v347;
              -[__CFDictionary setObject:forKey:](v350, "setObject:forKey:", v188, v186);
            }
          }

          uint64_t v183 = [v181 countByEnumeratingWithState:&v402 objects:v458 count:16];
        }

        while (v183);
      }

      unint64_t v52 = v320;
      unint64_t v54 = v321 + 1;
      uint64_t v50 = v318;
    }

    while (v321 + 1 != v319);
    __int16 v51 = [v318 countByEnumeratingWithState:&v426 objects:v464 count:16];
    unint64_t v52 = v320;
  }

  while (v51);
LABEL_244:
  v400 = 0u;
  v401 = 0u;
  v398 = 0u;
  v399 = 0u;
  v338 = -[__CFArray countByEnumeratingWithState:objects:count:]( v336,  "countByEnumeratingWithState:objects:count:",  &v398,  v457,  16LL);
  if (v338)
  {
    v335 = *(id *)v399;
    do
    {
      size_t v203 = 0LL;
      do
      {
        if (*(id *)v399 != v335) {
          objc_enumerationMutation(v336);
        }
        v339 = v203;
        v341 = *(char **)(*((void *)&v398 + 1) + 8 * v203);
        uint64_t v204 = [v341 predicate];
        uint64_t v205 = v347;
        if (v204)
        {
          unint64_t v206 = (const void *)v204;
          if (!-[__CFDictionary objectForKey:](v14, "objectForKey:", v204))
          {
            unint64_t v207 = (const void *)objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](v344, "count"));
            -[__CFArray addObject:]( v344,  "addObject:",  [MEMORY[0x1896078F8] archivedDataWithRootObject:v206 requiringSecureCoding:1 error:0]);
            CFDictionarySetValue(v14, v206, v207);
          }
        }

        uint64_t v208 = [v341 havingPredicate];
        if (v208)
        {
          v209 = (const void *)v208;
          if (!-[__CFDictionary objectForKey:](v14, "objectForKey:", v208))
          {
            unint64_t v210 = (const void *)objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](v344, "count"));
            -[__CFArray addObject:]( v344,  "addObject:",  [MEMORY[0x1896078F8] archivedDataWithRootObject:v209 requiringSecureCoding:1 error:0]);
            CFDictionarySetValue(v14, v209, v210);
          }
        }

        unint64_t v211 = (void *)[v341 propertiesToFetch];
        v394 = 0u;
        v395 = 0u;
        v396 = 0u;
        v397 = 0u;
        uint64_t v212 = [v211 countByEnumeratingWithState:&v394 objects:v456 count:16];
        if (v212)
        {
          v213 = v212;
          unint64_t v214 = *(void *)v395;
          do
          {
            for (juint64_t j = 0LL; jj != v213; ++jj)
            {
              if (*(void *)v395 != v214) {
                objc_enumerationMutation(v211);
              }
              int v216 = *(void **)(*((void *)&v394 + 1) + 8 * jj);
              if (object_getClass(v216) == v346)
              {
                if (!-[__CFDictionary objectForKey:](v205, "objectForKey:", v216))
                {
                  uint64_t v217 = (const void *)objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](Mutable, "count"));
                  uint64_t v205 = v347;
                  -[__CFArray addObject:](Mutable, "addObject:", v216);
                  CFDictionarySetValue(v347, v216, v217);
                }

                uint64_t v218 = [v216 name];
                if (!-[__CFDictionary objectForKey:](v350, "objectForKey:", v218))
                {
                  uint64_t v219 = objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](v345, "count"));
                  unint64_t v14 = (__CFDictionary *)v348;
                  -[__CFArray addObject:](v345, "addObject:", v218);
                  uint64_t v220 = v219;
                  uint64_t v205 = v347;
                  -[__CFDictionary setObject:forKey:](v350, "setObject:forKey:", v220, v218);
                }

                LODWORD(v349) = (_DWORD)v349 + 1;
                uint64_t v221 = [v216 expression];
                if (!-[__CFDictionary objectForKey:](v14, "objectForKey:", v221))
                {
                  uint64_t v222 = objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](v344, "count"));
                  unint64_t v14 = (__CFDictionary *)v348;
                  -[__CFArray addObject:]( v344,  "addObject:",  [MEMORY[0x1896078F8] archivedDataWithRootObject:v221 requiringSecureCoding:1 error:0]);
                  [(id)v348 setObject:v222 forKey:v221];
                }
              }
            }

            v213 = [v211 countByEnumeratingWithState:&v394 objects:v456 count:16];
          }

          while (v213);
        }

        uint64_t v223 = (void *)[v341 propertiesToGroupBy];
        v390 = 0u;
        v391 = 0u;
        v392 = 0u;
        v393 = 0u;
        uint64_t v224 = [v223 countByEnumeratingWithState:&v390 objects:v455 count:16];
        if (v224)
        {
          uint64_t v225 = v224;
          uint64_t v226 = *(void *)v391;
          do
          {
            for (kuint64_t k = 0LL; kk != v225; ++kk)
            {
              if (*(void *)v391 != v226) {
                objc_enumerationMutation(v223);
              }
              uint64_t v228 = *(void **)(*((void *)&v390 + 1) + 8 * kk);
              if (object_getClass(v228) == v346)
              {
                if (!-[__CFDictionary objectForKey:](v205, "objectForKey:", v228))
                {
                  uint64_t v229 = (const void *)objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](Mutable, "count"));
                  uint64_t v205 = v347;
                  -[__CFArray addObject:](Mutable, "addObject:", v228);
                  CFDictionarySetValue(v347, v228, v229);
                }

                uint64_t v230 = [v228 name];
                if (!-[__CFDictionary objectForKey:](v350, "objectForKey:", v230))
                {
                  uint64_t v231 = objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](v345, "count"));
                  unint64_t v14 = (__CFDictionary *)v348;
                  -[__CFArray addObject:](v345, "addObject:", v230);
                  uint64_t v232 = v231;
                  uint64_t v205 = v347;
                  -[__CFDictionary setObject:forKey:](v350, "setObject:forKey:", v232, v230);
                }

                LODWORD(v349) = (_DWORD)v349 + 1;
                uint64_t v233 = [v228 expression];
                if (!-[__CFDictionary objectForKey:](v14, "objectForKey:", v233))
                {
                  uint64_t v234 = objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](v344, "count"));
                  unint64_t v14 = (__CFDictionary *)v348;
                  -[__CFArray addObject:]( v344,  "addObject:",  [MEMORY[0x1896078F8] archivedDataWithRootObject:v233 requiringSecureCoding:1 error:0]);
                  [(id)v348 setObject:v234 forKey:v233];
                }
              }
            }

            uint64_t v225 = [v223 countByEnumeratingWithState:&v390 objects:v455 count:16];
          }

          while (v225);
        }

        uint64_t v235 = (void *)[v341 sortDescriptors];
        v386 = 0u;
        v387 = 0u;
        v388 = 0u;
        v389 = 0u;
        uint64_t v236 = [v235 countByEnumeratingWithState:&v386 objects:v454 count:16];
        uint64_t v29 = v345;
        if (v236)
        {
          uint64_t v237 = v236;
          v238 = *(void *)v387;
          do
          {
            for (mm = 0LL; mm != v237; ++mm)
            {
              if (*(void *)v387 != v238) {
                objc_enumerationMutation(v235);
              }
              unint64_t v240 = *(void *)(*((void *)&v386 + 1) + 8 * mm);
              if (!-[__CFDictionary objectForKey:](v14, "objectForKey:", v240))
              {
                uint64_t v241 = objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](v344, "count"));
                unint64_t v14 = (__CFDictionary *)v348;
                -[__CFArray addObject:]( v344,  "addObject:",  [MEMORY[0x1896078F8] archivedDataWithRootObject:v240 requiringSecureCoding:1 error:0]);
                [(id)v348 setObject:v241 forKey:v240];
              }
            }

            uint64_t v237 = [v235 countByEnumeratingWithState:&v386 objects:v454 count:16];
          }

          while (v237);
        }

        uint64_t v242 = (void *)[v341 relationshipKeyPathsForPrefetching];
        v382 = 0u;
        v383 = 0u;
        v384 = 0u;
        v385 = 0u;
        uint64_t v243 = [v242 countByEnumeratingWithState:&v382 objects:v453 count:16];
        if (v243)
        {
          unint64_t v244 = v243;
          id v245 = *(void *)v383;
          do
          {
            for (nn = 0LL; nn != v244; ++nn)
            {
              if (*(void *)v383 != v245) {
                objc_enumerationMutation(v242);
              }
              uint64_t v247 = *(void *)(*((void *)&v382 + 1) + 8 * nn);
              if (!-[__CFDictionary objectForKey:](v350, "objectForKey:", v247))
              {
                id v248 = objc_msgSend( MEMORY[0x189607968],  "numberWithUnsignedInteger:",  -[__CFArray count](v345, "count"));
                -[__CFArray addObject:](v345, "addObject:", v247);
                -[__CFDictionary setObject:forKey:](v350, "setObject:forKey:", v248, v247);
              }
            }

            unint64_t v244 = [v242 countByEnumeratingWithState:&v382 objects:v453 count:16];
          }

          while (v244);
        }

        size_t v203 = v339 + 1;
      }

      while (v339 + 1 != v338);
      v338 = -[__CFArray countByEnumeratingWithState:objects:count:]( v336,  "countByEnumeratingWithState:objects:count:",  &v398,  v457,  16LL);
    }

    while (v338);
  }

  v381 = 0LL;
  v380 = -559038737;
  unint64_t v193 = objc_alloc_init(MEMORY[0x189603FB8]);
  [v193 appendBytes:"momv2$srsraori55717101jhus-[6910aathnnhi86786714[-;uadmiraenv143" length:64];
  unint64_t v249 = [v193 length];
  uint64_t v250 = (v249 + 3) & 0xFFFFFFFC;
  if (v250 != v249) {
    [v193 appendBytes:&v381 length:v250 - v249];
  }
  v346 = (objc_class *)[v193 length];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v381 length:4];
  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  v341 = (char *)[v193 length];
  _writeInt32IntoData(v193, -[__CFArray count](v333, "count"));
  v378 = 0u;
  v379 = 0u;
  v376 = 0u;
  v377 = 0u;
  uint64_t v251 = -[__CFArray countByEnumeratingWithState:objects:count:]( v333,  "countByEnumeratingWithState:objects:count:",  &v376,  v451,  16LL);
  if (v251)
  {
    v252 = v251;
    v253 = *(void *)v377;
    do
    {
      for (i1 = 0LL; i1 != v252; ++i1)
      {
        if (*(void *)v377 != v253) {
          objc_enumerationMutation(v333);
        }
        _writeStringIntoData(*(void **)(*((void *)&v376 + 1) + 8 * i1), v193, v452);
      }

      v252 = -[__CFArray countByEnumeratingWithState:objects:count:]( v333,  "countByEnumeratingWithState:objects:count:",  &v376,  v451,  16LL);
    }

    while (v252);
  }

  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  v339 = [v193 length];
  _writeInt32IntoData(v193, -[__CFArray count](v29, "count"));
  v374 = 0u;
  v375 = 0u;
  v372 = 0u;
  v373 = 0u;
  uint64_t v255 = -[__CFArray countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v372,  v450,  16LL);
  if (v255)
  {
    uint64_t v256 = v255;
    v257 = *(void *)v373;
    do
    {
      for (i2 = 0LL; i2 != v256; ++i2)
      {
        if (*(void *)v373 != v257) {
          objc_enumerationMutation(v29);
        }
        _writePFEncodedStringShapeIntoData(v193, *(void **)(*((void *)&v372 + 1) + 8 * i2), v452);
      }

      uint64_t v256 = -[__CFArray countByEnumeratingWithState:objects:count:]( v29,  "countByEnumeratingWithState:objects:count:",  &v372,  v450,  16LL);
    }

    while (v256);
  }

  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  v338 = [v193 length];
  _writeInt32IntoData(v193, -[__CFArray count](v344, "count"));
  v370 = 0u;
  v371 = 0u;
  v368 = 0u;
  v369 = 0u;
  v259 = -[__CFArray countByEnumeratingWithState:objects:count:]( v344,  "countByEnumeratingWithState:objects:count:",  &v368,  v449,  16LL);
  if (v259)
  {
    v260 = v259;
    v261 = *(void *)v369;
    do
    {
      for (i3 = 0LL; i3 != v260; ++i3)
      {
        if (*(void *)v369 != v261) {
          objc_enumerationMutation(v344);
        }
        _writePFEncodedDataShapeIntoData(v193, *(void **)(*((void *)&v368 + 1) + 8 * i3));
      }

      v260 = -[__CFArray countByEnumeratingWithState:objects:count:]( v344,  "countByEnumeratingWithState:objects:count:",  &v368,  v449,  16LL);
    }

    while (v260);
  }

  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  v335 = (id)[v193 length];
  _writeInt32IntoData(v193, -[__CFArray count](v330, "count"));
  v366 = 0u;
  v367 = 0u;
  v364 = 0u;
  v365 = 0u;
  v263 = -[__CFArray countByEnumeratingWithState:objects:count:]( v330,  "countByEnumeratingWithState:objects:count:",  &v364,  v448,  16LL);
  if (v263)
  {
    v264 = v263;
    v265 = *(void *)v365;
    do
    {
      for (i4 = 0LL; i4 != v264; ++i4)
      {
        if (*(void *)v365 != v265) {
          objc_enumerationMutation(v330);
        }
        _writeKKDMappingStrategyIntoData(v193, *(void **)(*((void *)&v364 + 1) + 8 * i4), v350);
      }

      v264 = -[__CFArray countByEnumeratingWithState:objects:count:]( v330,  "countByEnumeratingWithState:objects:count:",  &v364,  v448,  16LL);
    }

    while (v264);
  }

  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  v329 = (id)[v193 length];
  _writeInt32IntoData(v193, v323);
  _writeInt32IntoData(v193, HIDWORD(v323));
  _writeInt32IntoData(v193, v324);
  _writeInt32IntoData(v193, v349);
  _writeInt32IntoData(v193, HIDWORD(v324));
  v362 = 0u;
  v363 = 0u;
  v360 = 0u;
  v361 = 0u;
  v267 = -[__CFArray countByEnumeratingWithState:objects:count:]( Mutable,  "countByEnumeratingWithState:objects:count:",  &v360,  v447,  16LL);
  if (v267)
  {
    v268 = v267;
    v269 = *(void *)v361;
    do
    {
      for (i5 = 0LL; i5 != v268; ++i5)
      {
        if (*(void *)v361 != v269) {
          objc_enumerationMutation(Mutable);
        }
        objc_msgSend( *(id *)(*((void *)&v360 + 1) + 8 * i5),  "_writeIntoData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:entitiesSlots:fetchRequests:",  v193,  v347,  v350,  v334,  v14,  objc_msgSend(*((id *)v340 + 4), "mapping"),  v337);
      }

      v268 = -[__CFArray countByEnumeratingWithState:objects:count:]( Mutable,  "countByEnumeratingWithState:objects:count:",  &v360,  v447,  16LL);
    }

    while (v268);
  }

  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  v322 = [v193 length];
  _writeInt32IntoData(v193, [*((id *)v340 + 4) count]);
  v271 = objc_msgSend((id)objc_msgSend(*((id *)v340 + 4), "mapping"), "length");
  if (v271)
  {
    v272 = v271;
    for (i6 = 0LL; i6 != v272; ++i6)
      objc_msgSend( (id)objc_msgSend(*((id *)v340 + 4), "valueAtIndex:", i6),  "_writeIntoData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:uniquedMappings:entities:",  v193,  v347,  v350,  v334,  v14,  v331,  *((void *)v340 + 4));
  }

  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  v325 = (objc_class *)[v193 length];
  _writeInt32IntoData(v193, -[__CFArray count](v336, "count"));
  v274 = -[__CFArray count](v336, "count");
  if (v274)
  {
    v275 = v274;
    for (i7 = 0LL; i7 != v275; ++i7)
      objc_msgSend( (id)-[__CFArray objectAtIndex:](v336, "objectAtIndex:", i7),  "_writeIntoData:propertiesDict:uniquedPropertyNames:uniquedStrings:uniquedData:uniquedMappings:entities:",  v193,  v347,  v350,  v334,  v14,  v331,  *((void *)v340 + 4));
  }

  [v193 appendBytes:&v380 length:4];
  [v193 appendBytes:&v380 length:4];
  v321 = [v193 length];
  _writeInt32IntoData(v193, *((_DWORD *)v340 + 16));
  v277 = (void *)*((void *)v340 + 4);
  if (v277) {
    v278 = [v277 count];
  }
  else {
    v278 = 0;
  }
  _writeInt32IntoData(v193, v278);
  if (v326 && -[NSKnownKeysDictionary count](v326, "count"))
  {
    _writeInt32IntoData(v193, [*((id *)v340 + 6) count]);
    v358 = 0u;
    v359 = 0u;
    v356 = 0u;
    v357 = 0u;
    v279 = (void *)[*((id *)v340 + 6) allValues];
    v280 = [v279 countByEnumeratingWithState:&v356 objects:v446 count:16];
    if (v280)
    {
      v281 = v280;
      v282 = *(void *)v357;
      do
      {
        for (i8 = 0LL; i8 != v281; ++i8)
        {
          if (*(void *)v357 != v282) {
            objc_enumerationMutation(v279);
          }
          v284 = objc_msgSend( (id)CFDictionaryGetValue(v337, *(const void **)(*((void *)&v356 + 1) + 8 * i8)),  "unsignedIntegerValue");
          _writeInt64IntoData(v193, v284);
        }

        v281 = [v279 countByEnumeratingWithState:&v356 objects:v446 count:16];
      }

      while (v281);
    }
  }

  else
  {
    _writeInt32IntoData(v193, 0);
  }

  v285 = (void *)*((void *)v340 + 5);
  if (v285)
  {
    _writeInt32IntoData(v193, [v285 count]);
    v286 = (void *)[*((id *)v340 + 4) mapping];
    v352 = 0u;
    v353 = 0u;
    v354 = 0u;
    v355 = 0u;
    *(void *)&v348 = *((void *)v340 + 5);
    v287 = [(id)v348 countByEnumeratingWithState:&v352 objects:v445 count:16];
    if (v287)
    {
      v288 = v287;
      v289 = *(void *)v353;
      do
      {
        for (i9 = 0LL; i9 != v288; ++i9)
        {
          if (*(void *)v353 != v289) {
            objc_enumerationMutation((id)v348);
          }
          v291 = *(void *)(*((void *)&v352 + 1) + 8 * i9);
          v292 = (void *)[*((id *)v340 + 5) objectForKey:v291];
          _writeInt32IntoData( v193,  objc_msgSend((id)-[__CFDictionary objectForKey:](v350, "objectForKey:", v291), "unsignedIntegerValue"));
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0) {
            v292 = (void *)[v292 allObjects];
          }
          _writePFEncodedArrayShapeIntoData(v193, v292, v286, 0LL);
        }

        v288 = [(id)v348 countByEnumeratingWithState:&v352 objects:v445 count:16];
      }

      while (v288);
    }
  }

  else
  {
    _writeInt32IntoData(v193, 0);
  }

  v293 = (id *)v340;
  _writePFEncodedArrayShapeIntoData(v193, (void *)[*((id *)v340 + 7) allObjects], v14, 0);
  if ([*((id *)v340 + 4) count])
  {
    v294 = 0LL;
    do
    {
      _writeInt64IntoData(v193, 0LL);
      ++v294;
    }

    while (v294 < [*((id *)v340 + 4) count]);
  }

  *(void *)&v348 = v327->_entitiesByName;
  v295 = [*((id *)v340 + 4) count];
  uint64_t v29 = v345;
  if (v295)
  {
    v296 = v295;
    for (i10 = 0LL; i10 != v296; ++i10)
    {
      v298 = objc_msgSend((id)objc_msgSend(v293[4], "valueAtIndex:", i10), "name");
      v299 = (void *)[(id)v348 objectForKey:v298];
      if (v299 && (v300 = (void *)v299[31]) != 0LL)
      {
        v301 = [(id)-[NSSQLEntity properties]((uint64_t)v299) count];
        v302 = MEMORY[0x1895F8858](v301);
        v305 = (char *)&v318 - v304;
        v306 = v302;
        if (v302 > 0x200) {
          v305 = (char *)NSAllocateScannedUncollectable();
        }
        else {
          bzero((char *)&v318 - v304, 8 * v303);
        }
        v307 = v300[1];
        if (v307 >= 1)
        {
          v308 = 0LL;
          v309 = (uint64_t *)v300[9];
          do
          {
            v311 = *v309++;
            v310 = v311;
            v312 = v300[8];
            if (v312 != v311 && v310 != ~v312) {
              *(void *)&v305[8 * v308++] = v310;
            }
            --v307;
          }

          while (v307);
        }

        v314 = (void *)[objc_alloc(MEMORY[0x189603F18]) initWithObjects:v305 count:v306];
        _writePFEncodedArrayShapeIntoData(v193, v314, v350, 0LL);

        if (v306 >= 0x201) {
          NSZoneFree(0LL, v305);
        }
        v293 = (id *)v340;
      }

      else if (v328)
      {
        v317 = [MEMORY[0x189607870] errorWithDomain:*MEMORY[0x189607460], 134060, objc_msgSend( MEMORY[0x189603F68], "dictionaryWithObject:forKey:", objc_msgSend( NSString, "stringWithFormat:", @"Can't find hashorder for entity '%@'", objc_msgSend(v299, "name")), @"Base Problem") code userInfo];
        *v328 = v317;

        goto LABEL_211;
      }
    }
  }

  [v193 appendBytes:&v381 length:8];
  v351 = bswap32(v321);
  v315 = (int)v346;
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", v346, 4, &v351);
  v351 = bswap32(v322);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 4), 4, &v351);
  v351 = bswap32([v293[4] count]);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 8), 4, &v351);
  v351 = bswap32(v329);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 12), 4, &v351);
  v351 = bswap32(-[__CFDictionary count](v347, "count"));
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 16), 4, &v351);
  v351 = bswap32(v323);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 20), 4, &v351);
  v351 = bswap32(HIDWORD(v323));
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 24), 4, &v351);
  v351 = bswap32(v324);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 28), 4, &v351);
  v351 = bswap32(v349);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 32), 4, &v351);
  v351 = bswap32(HIDWORD(v324));
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 36), 4, &v351);
  v351 = bswap32(v335);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 40), 4, &v351);
  v351 = bswap32(-[__CFArray count](v330, "count"));
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 44), 4, &v351);
  v351 = bswap32(v338);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 48), 4, &v351);
  int v195 = v344;
  v351 = bswap32(-[__CFArray count](v344, "count"));
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 52), 4, &v351);
  v351 = bswap32(v341);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 56), 4, &v351);
  v316 = v293;
  v197 = v334;
  v351 = bswap32(-[__CFDictionary count](v334, "count"));
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 60), 4, &v351);
  v351 = bswap32(v339);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 64), 4, &v351);
  v351 = bswap32(-[__CFDictionary count](v350, "count"));
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 68), 4, &v351);
  v351 = bswap32(v325);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 72), 4, &v351);
  unint64_t v198 = v336;
  v351 = bswap32(-[__CFArray count](v336, "count"));
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 76), 4, &v351);
  v351 = bswap32([v316[6] count]);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 80), 4, &v351);
  v351 = bswap32(v332);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 84), 4, &v351);
  v351 = bswap32(v342);
  objc_msgSend(v193, "replaceBytesInRange:withBytes:", (v315 + 88), 4, &v351);
  unint64_t v194 = Mutable;
  v196 = v333;
  if (Mutable) {
    goto LABEL_213;
  }
LABEL_214:
  if (v347) {
    CFRelease(v347);
  }
  if (v196) {
    CFRelease(v196);
  }
  if (v197) {
    CFRelease(v197);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v350) {
    CFRelease(v350);
  }
  unint64_t v199 = v330;
  uint64_t v200 = v331;
  v201 = v326;
  if (v195) {
    CFRelease(v195);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v199) {
    CFRelease(v199);
  }
  if (v200) {
    CFRelease(v200);
  }
  uint64_t v202 = v337;
  if (v201) {

  }
  if (v198) {
    CFRelease(v198);
  }
  if (v202) {
    CFRelease(v202);
  }
  if (v327) {

  }
  if (v193) {
    return v193;
  }
  else {
    return 0LL;
  }
}

void sub_18676F958()
{
}

void sub_18676F964()
{
  if (v0) {
    JUMPOUT(0x18676F96CLL);
  }
  JUMPOUT(0x18676F970LL);
}

LABEL_341:
                                                                  uint64_t v173 = v276;
                                                                }

                                                                _PFDeallocateObjects(v142, v173);
                                                                unint64_t v170 = v277;
                                                              }

                                                              _PFDeallocateObjects((void **)v256, v170);
                                                              uint64_t v167 = v278;
                                                            }

                                                            _PFDeallocateObjects((void **)v127, v167);
                                                            unint64_t v164 = v279;
                                                          }

                                                          _PFDeallocateObjects((void **)v259, v164);
                                                          unint64_t v161 = v280;
                                                        }

                                                        _PFDeallocateObjects((void **)v262, v161);
                                                        int v158 = v281;
                                                      }

                                                      _PFDeallocateObjects((void **)v263, v158);
                                                      unint64_t v155 = v282;
                                                    }

                                                    _PFDeallocateObjects((void **)v260, v155);
                                                    uint64_t v152 = v283;
                                                  }

                                                  _PFDeallocateObjects((void **)v261, v152);
                                                  _PFDeallocateObjects(v264, 0);
                                                  unint64_t v149 = v286;
                                                  uint64_t v147 = (void **)v92;
                                                }

                                                _PFDeallocateObjects(v147, v149);
                                                uint64_t v232 = v290;
                                                uint64_t v233 = (void **)v266;
                                                if (v292)
                                                {
                                                  do
                                                  {
                                                    uint64_t v234 = *v233++;

                                                    --v232;
                                                  }

                                                  while (v232);
                                                }

                                                if (v285)
                                                {
                                                  uint64_t v235 = v288;
                                                  uint64_t v236 = v265;
                                                  do
                                                  {
                                                    uint64_t v237 = *v236++;

                                                    --v235;
                                                  }

                                                  while (v235);
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

NSManagedObjectModel *_newReadModelFromBytes( uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4, NSMutableDictionary *a5, NSMutableDictionary *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v140 = *MEMORY[0x1895F89C0];
  unint64_t v135 = *a3;
  unint64_t v17 = v135;
  uint64_t v18 = objc_alloc_init(&OBJC_CLASS___NSManagedObjectModel);
  uint64_t v19 = v18;
  unint64_t v20 = (v135 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v21 = v20 + 4;
  uint64_t v22 = a2;
  if (v20 + 4 <= a4)
  {
    unsigned int v23 = bswap32(*(_DWORD *)(a2 + v20));
    unint64_t v135 = v21;
    unint64_t v17 = v21;
  }

  else
  {
    unsigned int v23 = 0;
  }

  v18->_managedObjectModelFlags = (__managedObjectModelFlags)(v23 & 0xFFFFFFFB);
  entities = v18->_entities;
  if (entities) {

  }
  v19->_entities = a5;
  uint64_t v25 = objc_msgSend((id)-[NSMutableDictionary mapping](a5, "mapping"), "length");
  unint64_t v32 = (v17 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v33 = v32 + 4;
  if (v32 + 4 <= a4)
  {
    unsigned int v34 = bswap32(*(_DWORD *)(a2 + v32));
    unint64_t v135 = v33;
    unint64_t v17 = v33;
  }

  else
  {
    unsigned int v34 = 0;
  }

  if (v25 != v34)
  {
    _NSCoreDataLog( 1LL,  (uint64_t)@"Mismatch: strategy has %lu length, archive has %u values",  v26,  v27,  v28,  v29,  v30,  v31,  v25);
    goto LABEL_75;
  }

  uint64_t v116 = v25;
  -[NSMutableDictionary _setValues:retain:](a5, "_setValues:retain:", a7, 0LL);
  unint64_t v41 = (v17 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v42 = v41 + 4;
  uint64_t v113 = a5;
  if (v41 + 4 <= a4)
  {
    unsigned int v44 = *(_DWORD *)(a2 + v41);
    unsigned int v43 = bswap32(v44);
    unint64_t v135 = v42;
    if (!a6)
    {
      if (!v44) {
        goto LABEL_27;
      }
      _NSCoreDataLog( 1LL,  (uint64_t)@"Mismatch: frt strategy has %d length, archive has %u values",  v35,  v36,  v37,  v38,  v39,  v40,  0LL);
      goto LABEL_75;
    }

    unint64_t v17 = v42;
LABEL_16:
    fetchRequestTemplates = v19->_fetchRequestTemplates;
    if (fetchRequestTemplates) {

    }
    v19->_fetchRequestTemplates = a6;
    unint64_t v46 = (void *)-[NSMutableDictionary mapping](a6, "mapping");
    if ([v46 length] == v43)
    {
      unint64_t v47 = v22 + ((v17 + 7) & 0xFFFFFFFFFFFFFFF8LL);
      if (v43)
      {
        uint64_t v48 = v43;
        uint64_t v49 = (void *)(v22 + ((v17 + 7) & 0xFFFFFFFFFFFFFFF8LL));
        do
        {
          unint64_t v50 = (v17 + 7) & 0xFFFFFFFFFFFFFFF8LL;
          unint64_t v51 = v50 + 8;
          if (v50 + 8 <= a4)
          {
            unint64_t v52 = bswap64(*(void *)(v22 + v50));
            unint64_t v135 = v51;
            unint64_t v17 = v51;
          }

          else
          {
            unint64_t v52 = 0LL;
          }

          *v49++ = *(void *)(a8 + 8 * v52);
          --v48;
        }

        while (v48);
      }

      -[NSMutableDictionary _setValues:retain:](a6, "_setValues:retain:", v47, 1LL);
      goto LABEL_26;
    }

    uint64_t v112 = [v46 length];
    _NSCoreDataLog( 1LL,  (uint64_t)@"Mismatch: frt strategy has %lu length, archive has %u values",  v55,  v56,  v57,  v58,  v59,  v60,  v112);
LABEL_75:

    return 0LL;
  }

  if (a6)
  {
    unsigned int v43 = 0;
    goto LABEL_16;
  }

void sub_186772844(_Unwind_Exception *a1)
{
}

void sub_186772860()
{
}

LABEL_51:
          ++v30;
        }

        while (v30 != v28);
        uint64_t v38 = -[__CFSet countByEnumeratingWithState:objects:count:]( Mutable,  "countByEnumeratingWithState:objects:count:",  &v71,  v77,  16LL);
        uint64_t v28 = v38;
        if (!v38)
        {
LABEL_55:
          uint64_t v69 = 0u;
          uint64_t v70 = 0u;
          uint64_t v67 = 0u;
          uint64_t v68 = 0u;
          uint64_t v39 = [v26 countByEnumeratingWithState:&v67 objects:v76 count:16];
          if (v39)
          {
            uint64_t v40 = *(void *)v68;
            do
            {
              for (uint64_t j = 0LL; j != v39; ++j)
              {
                if (*(void *)v68 != v40) {
                  objc_enumerationMutation(v26);
                }
                CFSetRemoveValue(Mutable, *(const void **)(*((void *)&v67 + 1) + 8 * j));
              }

              uint64_t v39 = [v26 countByEnumeratingWithState:&v67 objects:v76 count:16];
            }

            while (v39);
          }

          ++v27;
          goto LABEL_29;
        }
      }
    }

    CFRelease(Mutable);
    [v26 removeAllObjects];
    unint64_t v42 = -[NSKnownKeysDictionary count](v62, "count");
    if (v42)
    {
      for (uint64_t k = 0LL; k != v42; ++k)
      {
        unsigned int v44 = *(_DWORD **)(v19 + 8 * k);
        if (-[NSEntityDescription _hasUniqueProperties]((uint64_t)v44))
        {
          __int128 v45 = -[NSEntityDescription _checkSelfForNonCascadeNoInverses]((uint64_t)v44);
          if (v45)
          {
            if (v44)
            {
              unint64_t v46 = v44;
              do
              {
                unint64_t v47 = v46[30];
                if ((v47 & 0x2000) != 0) {
                  break;
                }
                v46[30] = v47 | 0x2000;
                unint64_t v46 = (_DWORD *)*((void *)v46 + 10);
              }

              while (v46);
            }

            uint64_t v48 = [v44 uniquenessConstraints];
            [v44 name];
            [v45 name];
            objc_msgSend((id)objc_msgSend(v45, "inverseRelationship"), "name");
            [v45 name];
            _NSCoreDataLog( 1LL,  (uint64_t)@"Cannot use uniqueness constraints { %@ } on entity '%@' due to relationship '%@' having a mandatory to-one inverse relationship '%@' and not using a cascade delete rule on '%@'",  v49,  v50,  v51,  v52,  v53,  v54,  v48);
          }
        }
      }
    }

    if (BYTE6(z9dsptsiQ80etb9782fsrs98bfdle88))
    {
      uint64_t v65 = 0u;
      uint64_t v66 = 0u;
      unsigned int v63 = 0u;
      char v64 = 0u;
      fetchRequestTemplates = self->_fetchRequestTemplates;
      uint64_t v56 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( fetchRequestTemplates,  "countByEnumeratingWithState:objects:count:",  &v63,  v75,  16LL);
      if (v56)
      {
        uint64_t v57 = *(void *)v64;
        do
        {
          for (uint64_t m = 0LL; m != v56; ++m)
          {
            if (*(void *)v64 != v57) {
              objc_enumerationMutation(fetchRequestTemplates);
            }
            uint64_t v59 = (void *)-[NSMutableDictionary objectForKey:]( self->_fetchRequestTemplates,  "objectForKey:",  *(void *)(*((void *)&v63 + 1) + 8 * m));
            [v59 allowEvaluation];
            [v59 _incrementInUseCounter];
          }

          uint64_t v56 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( fetchRequestTemplates,  "countByEnumeratingWithState:objects:count:",  &v63,  v75,  16LL);
        }

        while (v56);
      }
    }

    -[NSManagedObjectModel _finalizeIndexes](self);
    if (v42 >= 6 && (int)+[_PFTask getNumActiveProcessors]() >= 2) {

    }
    [v61 drain];
  }

  uint64_t v39 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FA8]), "initWithCapacity:", objc_msgSend(obj, "count"));
  uint64_t v40 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FA8]), "initWithCapacity:", objc_msgSend(obj, "count"));
  unint64_t v10 = (id)objc_msgSend(objc_alloc(MEMORY[0x189603FA8]), "initWithCapacity:", objc_msgSend(obj, "count"));
  uint64_t v96 = 0u;
  uint64_t v97 = 0u;
  uint64_t v98 = 0u;
  uint64_t v99 = 0u;
  unint64_t v41 = [obj countByEnumeratingWithState:&v96 objects:v100 count:16];
  if (v41)
  {
    unint64_t v42 = v41;
    unsigned int v43 = *(void *)v97;
    do
    {
      for (uint64_t k = 0LL; k != v42; ++k)
      {
        if (*(void *)v97 != v43) {
          objc_enumerationMutation(obj);
        }
        __int128 v45 = *(void **)(*((void *)&v96 + 1) + 8 * k);
        unint64_t v46 = (void *)[v45 objectID];
        [v39 addObject:v46];
        unint64_t v47 = -[NSTemporaryObjectID initWithEntity:]( [NSTemporaryObjectID alloc],  "initWithEntity:",  [v45 entity]);
        [v39 addObject:v45];
        [v40 addObject:v45];
        [v10 addObject:v47];

        -[NSManagedObjectContext _insertObjectWithGlobalID:globalID:]((uint64_t)v85, (uint64_t)v45, v46);
      }

      unint64_t v42 = [obj countByEnumeratingWithState:&v96 objects:v100 count:16];
    }

    while (v42);
  }

  if ([v40 count])
  {

    uint64_t v48 = [v40 count];
    uint64_t v49 = objc_msgSend(*(id *)(v82 + 40), "entitiesForConfiguration:", objc_msgSend(v81, "configurationName"));
    if (v48)
    {
      unint64_t v14 = (void *)v49;
      unint64_t v50 = 0LL;
      while (1)
      {
        unint64_t v51 = (void *)[v40 objectAtIndex:v50];
        unint64_t v52 = v51;
        if (_PF_Threading_Debugging_level) {
          _PFAssertSafeMultiThreadedAccess_impl( [v51 managedObjectContext],  sel__assignObject_toPersistentStore_forConfiguration_);
        }
        char v1 = [v52 objectID];
        if (![(id)v1 isTemporaryID])
        {
          unint64_t v71 = (void *)MEMORY[0x189603F70];
          __int128 v72 = *MEMORY[0x189603A60];
          uint64_t v73 = @"Can't reassign an object to a different store once it has been saved.";
          goto LABEL_100;
        }

        if (objc_msgSend(v14, "indexOfObjectIdenticalTo:", objc_msgSend((id)v1, "entity")) == 0x7FFFFFFFFFFFFFFFLL) {
          break;
        }
        [(id)v1 _setPersistentStore:v81];
        if (v48 == ++v50) {
          goto LABEL_66;
        }
      }

      unint64_t v71 = (void *)MEMORY[0x189603F70];
      __int128 v72 = *MEMORY[0x189603A60];
      uint64_t v73 = @"Can't assign an object to a store that does not contain the object's entity.";
LABEL_100:
      objc_exception_throw((id)[v71 exceptionWithName:v72 reason:v73 userInfo:0]);
      goto LABEL_101;
    }
  }

void sub_1867734D4(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18677349CLL);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1867734F0(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867734F8LL);
  }
  objc_terminate();
  return _computeVersionHashesOnBackgroundThread(v2);
}

uint64_t _computeVersionHashesOnBackgroundThread(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = (void *)MEMORY[0x186E3E5D8]();
  SEL v3 = *(void **)(a1 + 24);
  id v4 = (void *)[v3 entitiesByName];
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v11;
    do
    {
      for (uint64_t i = 0LL; i != v6; ++i)
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v4);
        }
        objc_msgSend((id)objc_msgSend(v4, "objectForKey:", *(void *)(*((void *)&v10 + 1) + 8 * i)), "versionHash");
      }

      uint64_t v6 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }

    while (v6);
  }

  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 24) = 0LL;
  objc_autoreleasePoolPop(v2);
  return 0LL;
}

void sub_186773BD4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
}

void sub_186773EE4(_Unwind_Exception *a1)
{
}

LABEL_108:
          if (![a3 objectForKey:@"NSUnderlyingException"])
          {
            uint64_t v59 = (void *)MEMORY[0x189603F70];
            uint64_t v60 = *MEMORY[0x189603A60];
            uint64_t v61 = [NSString stringWithFormat:@"Unable to generate sql for components %@", v23];
            unint64_t v62 = v60;
            __int128 v10 = v97;
            objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(v59, "exceptionWithName:reason:userInfo:", v62, v61, 0),  @"NSUnderlyingException");
          }

          goto LABEL_129;
        }

        uint64_t v24 = [v23 lastObject];
        uint64_t v25 = [v14 propertyType];
        uint64_t v26 = [v14 entity];
        if (v26) {
          uint64_t v27 = (void *)[*(id *)(v26 + 40) objectForKey:v24];
        }
        else {
          uint64_t v27 = 0LL;
        }
        uint64_t v28 = [v27 propertyType];
        if (v28 != 1 && v28 != 7)
        {
          uint64_t v79 = (void *)MEMORY[0x189603F70];
          uint64_t v80 = *MEMORY[0x189603A60];
          uint64_t v81 = [NSString stringWithFormat:@"Invalid keypath for update (not an attribute or a to one) %@", objc_msgSend(v14, "name"), v89];
LABEL_128:
          objc_msgSend( a3,  "setObject:forKey:",  objc_msgSend(v79, "exceptionWithName:reason:userInfo:", v80, v81, 0),  @"NSUnderlyingException");
          __int128 v10 = v97;
LABEL_129:
          if (![a3 objectForKey:@"NSUnderlyingException"])
          {
            __int128 v76 = (void *)MEMORY[0x189603F70];
            __int128 v82 = v10;
            __int128 v77 = *MEMORY[0x189603A60];
            __int128 v78 = [NSString stringWithFormat:@"Invalid keypath expression (%@) in propertiesToUpdate - joins unsupported here", v82, v89];
LABEL_131:
            uint64_t v83 = [v76 exceptionWithName:v77 reason:v78 userInfo:0];
LABEL_132:
            [a3 setObject:v83 forKey:@"NSUnderlyingException"];
            __int128 v10 = v97;
          }

          uint64_t v85 = CFArrayCreateMutable(0LL, 0LL, 0LL);
          uint64_t v86 = (v115 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v87 = v86 + 4;
          if (v86 + 4 <= v6)
          {
            uint64_t v88 = bswap32(*(_DWORD *)(v11 + v86));
            unint64_t v115 = v87;
          }

          else
          {
            uint64_t v88 = 0;
          }

          uint64_t v94 = v88;
          if (v111 >= 0xFFFFFFFFLL)
          {
            if (v88)
            {
              do
              {
                uint64_t v98 = (v115 + 7) & 0xFFFFFFFFFFFFFFF8LL;
                uint64_t v99 = v98 + 8;
                if (v98 + 8 > v6) {
                  goto LABEL_136;
                }
                uint64_t v100 = *(void *)(v11 + v98);
                unint64_t v115 = v99;
                if (!v100) {
                  goto LABEL_136;
                }
                CFArrayAppendValue(v85, (const void *)bswap64(v100));
              }

              while (--v94);
            }
          }

          else if (v88)
          {
            while (1)
            {
              uint64_t v95 = (v115 + 3) & 0xFFFFFFFFFFFFFFFCLL;
              uint64_t v96 = v95 + 4;
              if (v95 + 4 > v6) {
                break;
              }
              uint64_t v97 = *(_DWORD *)(v11 + v95);
              unint64_t v115 = v96;
              if (!v97) {
                break;
              }
              CFArrayAppendValue(v85, (const void *)bswap32(v97));
              if (!--v94) {
                goto LABEL_134;
              }
            }

            if ((*(_BYTE *)&val->_sqlCoreFlags & 2) == 0)
            {
              uint64_t v100 = 0u;
              uint64_t v101 = 0u;
              uint64_t v98 = 0u;
              uint64_t v99 = 0u;
              uint64_t v59 = v53 ? *(void **)(v53 + 32) : 0LL;
              uint64_t v60 = [v59 countByEnumeratingWithState:&v98 objects:v125 count:16];
              if (v60)
              {
                uint64_t v61 = *(void *)v99;
                while (2)
                {
                  for (uint64_t m = 0LL; m != v60; ++m)
                  {
                    if (*(void *)v99 != v61) {
                      objc_enumerationMutation(v59);
                    }
                    unsigned int v63 = *(void *)(*((void *)&v98 + 1) + 8 * m);
                    if (v63 && (*(_BYTE *)(v63 + 280) & 1) != 0)
                    {
                      *(_DWORD *)&val->_sqlCoreFlags |= 2u;
                      goto LABEL_122;
                    }
                  }

                  uint64_t v60 = [v59 countByEnumeratingWithState:&v98 objects:v125 count:16];
                  if (v60) {
                    continue;
                  }
                  break;
                }
              }
            }

  if (*(_BYTE *)(*(void *)(*(void *)v121 + 8LL) + 24LL)
    && v122
    && ([*(id *)(*(void *)(a1 + 32) + 56) processAnalyzedHistoryInStore:*(void *)(a1 + 40) inManagedObjectContext:*(void *)(a1 + 48) error:&v173] & 1) == 0)
  {
    goto LABEL_111;
  }

void sub_186776F40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

void __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
}

void sub_186777D40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
}

void sub_18677946C(_Unwind_Exception *a1)
{
}

void sub_18677A7C4(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exception_object);

    objc_exception_rethrow();
    __break(1u);
    JUMPOUT(0x18677A7E8LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_18677AF40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, void (*a24)(char *))
{
}

void sub_18677C874()
{
}

void sub_18677C880()
{
  if (v0) {
    JUMPOUT(0x18677C888LL);
  }
  JUMPOUT(0x18677C88CLL);
}

void sub_18677D3E4()
{
}

void sub_18677FB58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

LABEL_53:
  -[NSMergePolicy _mergeToManyRelationshipsForObject:ontoObject:](v2, v3);
  return [v44 deleteObject:v2];
}

    uint64_t v68 = v57;
LABEL_54:
    int v8 = v68;
    goto LABEL_55;
  }

  *(void *)v239 = 0LL;
  *(void *)&v239[8] = v239;
  *(void *)&v239[16] = 0x3052000000LL;
  unint64_t v240 = __Block_byref_object_copy__25;
  uint64_t v241 = __Block_byref_object_dispose__25;
  uint64_t v242 = 0LL;
  *(void *)uint64_t v246 = MEMORY[0x1895F87A8];
  uint64_t v247 = 3221225472LL;
  id v248 = (uint64_t)__47__PFCloudKitSetupAssistant__checkUserIdentity___block_invoke_116;
  unint64_t v249 = (void (*)(uint64_t, uint64_t))&unk_189EA9FF8;
  v252 = (uint64_t *)v278;
  v253 = v239;
  uint64_t v250 = v56;
  uint64_t v251 = (uint64_t *)v4;
  uint64_t v254 = (uint64_t)buf;
  -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v56, (uint64_t)v246);
  if (*(_BYTE *)(*(void *)&v278[8] + 24LL)) {
    int v8 = 0LL;
  }
  else {
    int v8 = (__CFString *)*(id *)(*(void *)&v239[8] + 40LL);
  }

  *(void *)(*(void *)&v239[8] + 40LL) = 0LL;
  _Block_object_dispose(v239, 8);
LABEL_55:
  -[PFCloudKitSetupAssistant endActivityForPhase:withError:](v4, 3LL, (uint64_t)v8);
  if (*(_BYTE *)(*(void *)&v278[8] + 24LL))
  {
LABEL_56:
    int v8 = v11;
    goto LABEL_58;
  }

  if (!v8)
  {
    unint64_t v105 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v105,  v106,  v107,  v108,  v109,  v110,  v111,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
    uint64_t v112 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v239 = 136315394;
      *(void *)&v239[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m";
      *(_WORD *)&v239[12] = 1024;
      *(_DWORD *)&v239[14] = 1631;
      _os_log_fault_impl( &dword_186681000,  v112,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v239,  0x12u);
    }

    goto LABEL_56;
  }

LABEL_54:
  objc_autoreleasePoolPop(v6);
  return v5;
}

    unsigned int v34 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringRequestManager.m");
    unint64_t v41 = (os_log_s *)__pflogFaultLog;
    uint64_t result = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/NSCloudKitMirroringRequestManager.m";
    unsigned int v43 = 1024;
    unsigned int v44 = 164;
    _os_log_fault_impl( &dword_186681000,  v41,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
    return 0LL;
  }

  return result;
}

          uint64_t v67 = v99 + 1;
        }

        while (v99 + 1 != v98);
        uint64_t v65 = [obj countByEnumeratingWithState:&v105 objects:v113 count:16];
        if (!v65) {
          goto LABEL_82;
        }
      }
    }

    uint64_t v66 = 0;
    id v4 = 0LL;
LABEL_82:
    uint64_t v5 = v66 & 1;
    char v1 = v100;
    SEL v3 = v94;
  }

  else
  {
    uint64_t v56 = [NSString stringWithUTF8String:"Failed to fetch database metadata during automatic import check: %@"];
    _NSCoreDataLog(17LL, v56, v57, v58, v59, v60, v61, v62, v109[0]);
    unsigned int v63 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v111 = v109[0];
      _os_log_fault_impl( &dword_186681000,  v63,  OS_LOG_TYPE_FAULT,  "CoreData: Failed to fetch database metadata during automatic import check: %@",  buf,  0xCu);
    }

    uint64_t v5 = 0;
    id v4 = 0LL;
  }

LABEL_54:
    if (!v32) {
      goto LABEL_57;
    }
    goto LABEL_55;
  }

          uint64_t v39 = (void *)v72;
          PF_Tiger_CFDictionaryGetKeysAndValues((uint64_t)v7, 0LL, (void *)v72);
          __int128 v11 = (void *)[MEMORY[0x189603F18] arrayWithObjects:v39 count:v6];
          PF_Tiger_CFDictionaryDestroy(v7);
          if (v6 >= 0x201) {
            NSZoneFree(0LL, v39);
          }
          goto LABEL_56;
        }

        goto LABEL_34;
      }

      uint64_t v26 = **(void **)(v1 + 248);
      if (v26 < 1)
      {
LABEL_34:
        __int128 v11 = (void *)NSArray_EmptyArray;
LABEL_56:
        __int128 v76 = 0u;
        __int128 v77 = 0u;
        uint64_t v74 = 0u;
        uint64_t v75 = 0u;
        uint64_t result = (void *)objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v74, v86, 16, v72, v73);
        if (!result) {
          return result;
        }
        uint64_t v40 = result;
        unint64_t v41 = *(void *)v75;
        while (1)
        {
          unint64_t v42 = 0LL;
          do
          {
            if (*(void *)v75 != v41) {
              objc_enumerationMutation(v11);
            }
            unsigned int v43 = *(void *)(*((void *)&v74 + 1) + 8LL * (void)v42);
            if (v43)
            {
              unsigned int v44 = *(unsigned __int8 *)(v43 + 24);
              if ((v44 - 7) <= 2)
              {
                if (*(void *)(v43 + 56))
                {
                  if (v44 == 7 && *(void *)(v43 + 80)) {
                    goto LABEL_72;
                  }
                }

                else
                {
                  __int128 v45 = (void *)objc_msgSend((id)objc_msgSend((id)v43, "propertyDescription"), "inverseRelationship");
                  if (v45)
                  {
                    if (*(_BYTE *)(v43 + 24) == 9) {
                      goto LABEL_76;
                    }
                    unint64_t v46 = [(id)v43 destinationEntity];
                    unint64_t v47 = [v45 name];
                    if (v46) {
                      uint64_t v48 = (void *)[*(id *)(v46 + 40) objectForKey:v47];
                    }
                    else {
                      uint64_t v48 = 0LL;
                    }
                    -[NSSQLRelationship _setInverseRelationship:]((void *)v43, v48);
                    if (*(_BYTE *)(v43 + 24) == 7)
                    {
LABEL_72:
                      -[NSSQLEntity _addForeignOrderKeyForToOne:entity:](v1, (id *)v43, (void *)v1);
                      goto LABEL_79;
                    }

                    if ([v48 entity] == v1) {
                      [v48 isToMany];
                    }
                  }

                  else
                  {
                    if ([(id)v43 isToMany])
                    {
                      uint64_t v49 = -[NSSQLEntity _addVirtualToOneForToMany:withInheritedProperty:]( [(id)v43 destinationEntity],  (void *)v43,  0);
                      -[NSSQLRelationship _setInverseRelationship:]((void *)v43, v49);
                      goto LABEL_79;
                    }

                    if (*(_BYTE *)(v43 + 24) == 9)
                    {
LABEL_76:
                      unint64_t v50 = [(id)v43 destinationEntity];
                      unint64_t v51 = [v45 name];
                      if (v50) {
                        unint64_t v52 = [*(id *)(v50 + 40) objectForKey:v51];
                      }
                      else {
                        unint64_t v52 = 0LL;
                      }
                      -[NSSQLManyToMany _setInverseManyToMany:]((void *)v43, v52);
                    }
                  }
                }
              }
            }

                objc_autoreleasePoolPop(v25);
                ++v23;
              }

              while (v23 != v20);
              unsigned int v44 = [v19 countByEnumeratingWithState:&v69 objects:v77 count:16];
              unint64_t v20 = v44;
            }

            while (v44);
          }

          [(id)a1 execute];
          if (!*(void *)(a1 + 80))
          {
            __int128 v45 = -[NSSQLiteConnection statementCacheForEntity:](a1, v57);
            -[NSSQLiteStatementCache cacheInsertStatement:](v45, 0LL);
          }

          -[NSSQLiteConnection _clearBindVariablesForInsertedRow](a1);
          -[NSSQLiteConnection resetSQLStatement](a1);
          objc_autoreleasePoolPop(context);
          ++v61;
        }

        while (v61 != v54);
        unint64_t v46 = [a2 countByEnumeratingWithState:&v73 objects:v78 count:16];
        unsigned int v54 = v46;
      }

      while (v46);
    }

    [v49 drain];
    uint64_t v48 = 0LL;
  }

  else
  {
    unint64_t v47 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  134030LL,  (uint64_t)@"unable to generate primary keys",  0LL);
    objc_exception_throw(v47);
    __break(1u);
  }

LABEL_60:
  if (v40) {
    -[NSMergePolicy mergeToManyRelationshipForSourceObject:withOldSnapshot:newSnapshot:andAncestor:andLegacyPath:]( v36,  "mergeToManyRelationshipForSourceObject:withOldSnapshot:newSnapshot:andAncestor:andLegacyPath:",  v42,  v9,  v10,  v40,  v28);
  }
  if ((_BYTE)z9dsptsiQ80etb9782fsrs98bfdle88)
  {
    if ([v42 isDeleted]) {
      -[NSManagedObjectContext _insertObjectWithGlobalID:globalID:]( [v42 managedObjectContext],  (uint64_t)v42,  (void *)objc_msgSend(v42, "objectID"));
    }
  }

void sub_1867811AC()
{
}

void sub_186781A64(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    objc_exception_rethrow();
    __break(1u);
    JUMPOUT(0x186781B04LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_18678218C(_Unwind_Exception *a1)
{
}

void sub_1867821A0(_Unwind_Exception *a1)
{
}

void sub_1867821B8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_terminate();
    SEL v3 = v2;
    if (v4)
    {
      objc_begin_catch(v2);
      JUMPOUT(0x186781C90LL);
    }
  }

  else
  {
    SEL v3 = a1;
  }

  _Unwind_Resume(v3);
}

LABEL_241:
        p_Class isa = 0LL;
        goto LABEL_164;
      }

      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0
        || ([v80 _referenceData], (objc_opt_respondsToSelector() & 1) == 0))
      {
        uint64_t v79 = [v71 firstObject];
        goto LABEL_163;
      }

      unint64_t v193 = 0u;
      unint64_t v194 = 0u;
      uint64_t v191 = 0u;
      uint64_t v192 = 0u;
      uint64_t v89 = [v71 countByEnumeratingWithState:&v191 objects:v207 count:16];
      if (!v89) {
        goto LABEL_241;
      }
      uint64_t v90 = 0LL;
      p_Class isa = 0LL;
      uint64_t v91 = *(void *)v192;
      do
      {
        for (muint64_t m = 0LL; mm != v89; ++mm)
        {
          if (*(void *)v192 != v91) {
            objc_enumerationMutation(v71);
          }
          uint64_t v93 = *(void **)(*((void *)&v191 + 1) + 8 * mm);
          uint64_t v94 = objc_msgSend((id)objc_msgSend(v93, "objectID"), "_referenceData");
          if (v90)
          {
            uint64_t v95 = (void *)v94;
            if ([v90 compare:v94] != -1)
            {
              uint64_t v90 = v95;
              p_Class isa = v93;
            }
          }

          else
          {
            uint64_t v90 = (void *)objc_msgSend((id)objc_msgSend(v93, "objectID"), "_referenceData");
          }
        }

        uint64_t v89 = [v71 countByEnumeratingWithState:&v191 objects:v207 count:16];
      }

      while (v89);
LABEL_164:

LABEL_165:
      type = v154->_type;
      if (type - 3 < 2)
      {
        size_t v203 = 0u;
        uint64_t v204 = 0u;
        uint64_t v205 = 0u;
        unint64_t v206 = 0u;
        uint64_t v136 = -[NSConstraintConflict conflictingObjects](v156, "conflictingObjects");
        unint64_t v137 = -[NSArray countByEnumeratingWithState:objects:count:]( v136,  "countByEnumeratingWithState:objects:count:",  &v203,  v207,  16LL);
        if (v137)
        {
          unint64_t v138 = *(void *)v204;
          do
          {
            for (nn = 0LL; nn != v137; ++nn)
            {
              if (*(void *)v204 != v138) {
                objc_enumerationMutation(v136);
              }
              uint64_t v140 = *(void **)(*((void *)&v203 + 1) + 8 * nn);
              if (v140 != p_isa) {
                objc_msgSend( (id)objc_msgSend(*(id *)(*((void *)&v203 + 1) + 8 * nn), "managedObjectContext"),  "deleteObject:",  v140);
              }
            }

            unint64_t v137 = -[NSArray countByEnumeratingWithState:objects:count:]( v136,  "countByEnumeratingWithState:objects:count:",  &v203,  v207,  16LL);
          }

          while (v137);
        }

    if (*(_BYTE *)(*(void *)(*(void *)(v376 + 96) + 8LL) + 24LL))
    {
      v265 = (void *)MEMORY[0x186E3E5D8]();
      v405 = 0u;
      v406 = 0u;
      v403 = 0u;
      v404 = 0u;
      if (v354) {
        v266 = *(void **)(v370 + 24);
      }
      else {
        v266 = 0LL;
      }
      v267 = [v266 countByEnumeratingWithState:&v403 objects:v425 count:16];
      if (v267)
      {
        v268 = *(void *)v404;
        do
        {
          for (uint64_t j = 0LL; j != v267; ++j)
          {
            if (*(void *)v404 != v268) {
              objc_enumerationMutation(v266);
            }
            objc_msgSend( *(id *)(v376 + 32),  "deleteObject:",  objc_msgSend(*(id *)(v376 + 32), "objectWithID:", *(void *)(*((void *)&v403 + 1) + 8 * j)));
          }

          v267 = [v266 countByEnumeratingWithState:&v403 objects:v425 count:16];
        }

        while (v267);
      }

      objc_autoreleasePoolPop(v265);
      v270 = v370 ? *(void **)(v370 + 24) : 0LL;
      v271 = +[NSCKRecordMetadata metadataForObjectIDs:inStore:withManagedObjectContext:error:]( (uint64_t)NSCKRecordMetadata,  [v270 allObjects],  *(void *)(v376 + 48),  *(void **)(v376 + 32),  (void *)(*(void *)(*(void *)(v376 + 88) + 8) + 40));
      v272 = v271;
      if (v271)
      {
        v401 = 0u;
        v402 = 0u;
        v399 = 0u;
        v400 = 0u;
        v273 = [v271 countByEnumeratingWithState:&v399 objects:v424 count:16];
        if (v273)
        {
          v274 = *(void *)v400;
          do
          {
            for (uint64_t k = 0LL; k != v273; ++k)
            {
              if (*(void *)v400 != v274) {
                objc_enumerationMutation(v272);
              }
              [*(id *)(v376 + 32) deleteObject:*(void *)(*((void *)&v399 + 1) + 8 * k)];
            }

            v273 = [v272 countByEnumeratingWithState:&v399 objects:v424 count:16];
          }

          while (v273);
        }
      }

      else
      {
        *(_BYTE *)(*(void *)(*(void *)(v376 + 96) + 8LL) + 24LL) = 0;
        v314 = *(id *)(*(void *)(*(void *)(v376 + 88) + 8LL) + 40LL);
      }

      if (*(_BYTE *)(*(void *)(*(void *)(v376 + 96) + 8LL) + 24LL))
      {
        v397 = 0u;
        v398 = 0u;
        v395 = 0u;
        v396 = 0u;
        v315 = v370 ? *(void **)(v370 + 112) : 0LL;
        v316 = [v315 countByEnumeratingWithState:&v395 objects:v423 count:16];
        if (v316)
        {
          v317 = *(void *)v396;
          while (2)
          {
            for (uint64_t m = 0LL; m != v316; ++m)
            {
              if (*(void *)v396 != v317) {
                objc_enumerationMutation(v315);
              }
              v319 = +[NSCKRecordZoneMetadata zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:error:]( (uint64_t)NSCKRecordZoneMetadata,  (void *)[*(id *)(*((void *)&v395 + 1) + 8 * m) zoneID],  objc_msgSend(*(id *)(*(void *)(v376 + 40) + 24), "databaseScope"),  *(void *)(v376 + 48),  *(void **)(v376 + 32),  *(void *)(*(void *)(v376 + 88) + 8) + 40);
              if (!v319)
              {
                *(_BYTE *)(*(void *)(*(void *)(v376 + 96) + 8LL) + 24LL) = 0;
                v320 = *(id *)(*(void *)(*(void *)(v376 + 88) + 8LL) + 40LL);
                goto LABEL_263;
              }

              -[NSManagedObject setEncodedShareData:](v319, "setEncodedShareData:", 0LL);
            }

            v316 = [v315 countByEnumeratingWithState:&v395 objects:v423 count:16];
            if (v316) {
              continue;
            }
            break;
          }
        }
      }
    }
  }

  else
  {
    v276 = *(id *)(*(void *)(*(void *)(v376 + 88) + 8LL) + 40LL);
    *(_BYTE *)(*(void *)(*(void *)(v376 + 96) + 8LL) + 24LL) = 0;
  }

LABEL_237:
        uint64_t v88 = 1;
        goto LABEL_239;
      }

      if (type - 1 <= 1)
      {
        uint64_t v97 = -[NSConstraintConflict conflictingObjects](v156, "conflictingObjects");
        unint64_t v206 = 0u;
        uint64_t v205 = 0u;
        uint64_t v204 = 0u;
        size_t v203 = 0u;
        uint64_t v98 = -[NSArray countByEnumeratingWithState:objects:count:]( v97,  "countByEnumeratingWithState:objects:count:",  &v203,  v207,  16LL);
        if (!v98) {
          goto LABEL_237;
        }
        uint64_t v160 = *(void *)v204;
        uint64_t v157 = v97;
        while (1)
        {
          uint64_t v99 = 0LL;
          int v158 = v98;
          do
          {
            if (*(void *)v204 != v160) {
              objc_enumerationMutation(v157);
            }
            uint64_t v100 = *(void **)(*((void *)&v203 + 1) + 8 * v99);
            if (v100 == p_isa) {
              goto LABEL_225;
            }
            if (p_isa && (uint64_t v101 = p_isa[6]) != 0)
            {
              uint64_t v102 = *(void **)(v101 + 8);
              if (!v100) {
                goto LABEL_180;
              }
            }

            else
            {
              uint64_t v102 = 0LL;
              if (!v100) {
                goto LABEL_180;
              }
            }

            unint64_t v103 = v100[6];
            if (!v103)
            {
LABEL_180:
              unint64_t v164 = 0LL;
              goto LABEL_181;
            }

            unint64_t v164 = *(void **)(v103 + 8);
LABEL_181:
            uint64_t v104 = [p_isa entity];
            unint64_t v105 = (void *)v104;
            if (v104)
            {
              unint64_t v106 = [*(id *)(v104 + 104) keys];
              uint64_t v107 = (void *)v105[14];
            }

            else
            {
              unint64_t v106 = [0 keys];
              uint64_t v107 = 0LL;
            }

            unint64_t v168 = (id)[MEMORY[0x189603FE8] null];
            uint64_t v163 = v105;
            unint64_t v166 = v100;
            unint64_t v108 = v107[6];
            uint64_t v109 = v107[7];
            if (v108 < v109 + v108)
            {
              unint64_t v110 = (void *)(v106 + 8 * v108);
              do
              {
                if (!v102
                  || ((uint64_t v111 = [v102 valueForKey:*v110], v168 != (id)v111)
                    ? (uint64_t v112 = v111)
                    : (uint64_t v112 = 0LL),
                      (uint64_t v113 = [p_isa valueForKey:*v110], v112 | v113)
                   && [(id)v112 isEqual:v113]))
                {
                  unint64_t v114 = [v164 valueForKey:*v110];
                  unint64_t v115 = v168 == (id)v114 ? 0LL : v114;
                  uint64_t v116 = [v166 valueForKey:*v110];
                  unint64_t v117 = v116;
                  if (v116 | v115)
                  {
                    if (([(id)v116 isEqual:v115] & 1) == 0) {
                      [p_isa setValue:v117 forKey:*v110];
                    }
                  }
                }

                ++v110;
                --v109;
              }

              while (v109);
            }

            unint64_t v161 = v99;
            uint64_t v118 = v107[12];
            unint64_t v119 = v107[13];
            if (v118 < v119 + v118)
            {
              unint64_t v120 = 8 * v118;
              do
              {
                unint64_t v121 = p_isa;
                uint64_t v122 = [p_isa valueForKey:*(void *)(v106 + v120)];
                if (!v102
                  || ((__int128 v123 = [v102 valueForKey:*(void *)(v106 + v120)], v168 != (id)v123)
                    ? (__int128 v124 = v123)
                    : (__int128 v124 = 0LL),
                      v124 | v122
                   && objc_msgSend((id)v124, "isEqual:", objc_msgSend((id)v122, "objectID"))))
                {
                  __int128 v125 = [v164 valueForKey:*(void *)(v106 + v120)];
                  __int128 v126 = v168 == (id)v125 ? 0LL : v125;
                  __int128 v127 = [v166 valueForKey:*(void *)(v106 + v120)];
                  __int128 v128 = (void *)v127;
                  if (v127 | v126)
                  {
                    if (([(id)v127 isEqual:v126] & 1) == 0)
                    {
                      __int128 v129 = *(void **)(v163[12] + 24LL + v120);
                      __int128 v130 = (void *)[v129 inverseRelationship];
                      __int128 v131 = [v130 name];
                      __int128 v132 = [v130 isToMany];
                      if (v122)
                      {
                        if (!v130)
                        {
                          uint64_t result = -[NSMergePolicy _cannotResolveConflictOnEntity:relationshipWithNoInverse:]( v163,  v129);
                          __break(1u);
                          return result;
                        }

                        if (v132)
                        {
                          __int128 v133 = [v130 isOrdered];
                          __int128 v134 = [v130 name];
                          if (v133)
                          {
                            objc_msgSend( (id)objc_msgSend((id)v122, "mutableOrderedSetValueForKey:", v134),  "removeObject:",  v121);
                            unint64_t v135 = (void *)objc_msgSend( v128,  "mutableOrderedSetValueForKey:",  objc_msgSend(v130, "name"));
                          }

                          else
                          {
                            objc_msgSend( (id)objc_msgSend((id)v122, "mutableSetValueForKey:", v134),  "removeObject:",  v121);
                            unint64_t v135 = (void *)objc_msgSend(v128, "mutableSetValueForKey:", objc_msgSend(v130, "name"));
                          }

                          [v135 addObject:v121];
                          [v135 removeObject:v166];
                        }

                        else
                        {
                          [v128 setValue:v121 forKey:v131];
                          [(id)v122 setValue:0 forKey:v131];
                        }

                        if ([v129 deleteRule] == 2) {
                          objc_msgSend((id)objc_msgSend(v121, "managedObjectContext"), "deleteObject:", v122);
                        }
                      }

                      [v166 setValue:0 forKey:*(void *)(v106 + v120)];
                      [v121 setValue:v128 forKey:*(void *)(v106 + v120)];
                    }
                  }
                }

                v120 += 8LL;
                --v119;
                p_Class isa = v121;
              }

              while (v119);
            }

            -[NSMergePolicy _mergeToManyUnionRelationshipsForObject:andObject:](p_isa, v166);
            uint64_t v98 = v158;
            uint64_t v99 = v161;
            objc_msgSend((id)objc_msgSend(v166, "managedObjectContext"), "deleteObject:", v166);
LABEL_225:
            ++v99;
          }

          while (v99 != v98);
          uint64_t v98 = -[NSArray countByEnumeratingWithState:objects:count:]( v157,  "countByEnumeratingWithState:objects:count:",  &v203,  v207,  16LL);
          if (!v98) {
            goto LABEL_237;
          }
        }
      }

      uint64_t v88 = 0;
LABEL_239:
      objc_msgSend((id)objc_msgSend(p_isa, "managedObjectContext"), "processPendingChanges");
      uint64_t v48 = &unk_189F03A18;
      if ((v88 & 1) != 0)
      {
        uint64_t v49 = 1;
        goto LABEL_75;
      }

                    ;
                  }

                  unint64_t v178 = (id)[v174 countByEnumeratingWithState:&v210 objects:v243 count:16];
                }

                while (v178);
              }
            }

LABEL_240:
            __int128 v76 = v172 + 1;
          }

          while ((id)(v172 + 1) != v169);
          unint64_t v137 = [v159 countByEnumeratingWithState:&v221 objects:v245 count:16];
          uint64_t v169 = (id)v137;
        }

        while (v137);
      }

      objc_autoreleasePoolPop(v150);
      ++v155;
    }

    while (v155 != v157);
    unint64_t v138 = [obj countByEnumeratingWithState:&v225 objects:v246 count:16];
    uint64_t v157 = v138;
  }

  while (v138);
LABEL_250:
  unint64_t v139 = v185;
  [v148 drain];
  if (!v205 || !v205->super._error)
  {
    uint64_t v140 = v167;
    if (v167 && (v141 = [v167 count], uint64_t v140 = v167, v141))
    {
      if (v139)
      {
        unint64_t v142 = [v139 count];
        uint64_t v140 = v167;
        if (v142)
        {
          unint64_t v143 = v167;
          unint64_t v71 = (id)[v167 mutableCopy];
          [v71 addObjectsFromArray:v139];
          unint64_t v144 = v71;
          goto LABEL_261;
        }
      }

      unint64_t v143 = v140;
      uint64_t v145 = v140;
    }

    else
    {
      unint64_t v143 = v140;
      uint64_t v145 = v139;
    }

    unint64_t v71 = v145;
LABEL_261:

    if (v146) {
    return v71;
    }
  }

LABEL_135:
  return 0LL;
}

LABEL_251:
  unint64_t v146 = (void *)MEMORY[0x189607870];
  int v195 = @"conflictList";
  v196 = list;
  uint64_t v147 = [MEMORY[0x189603F68] dictionaryWithObjects:&v196 forKeys:&v195 count:1];
  unint64_t v148 = (NSError *)[v146 errorWithDomain:*MEMORY[0x189607460] code:133021 userInfo:v147];
  uint64_t result = 0;
  NSError *error = v148;
  return result;
}

void sub_186783750(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186783644LL);
  }

  _Unwind_Resume(a1);
}

void sub_186783760(_Unwind_Exception *a1)
{
}

void sub_18678377C(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x186783780LL);
  }
  objc_terminate();
  __Block_byref_object_copy__14(v2, v3);
}

void __Block_byref_object_copy__14(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
}

void sub_186783EBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36)
{
}

LABEL_130:
    -[NSMigrationManager _doCleanupOnFailure:]((id *)&self->super.isa);
    goto LABEL_131;
  }

  uint64_t v30 = -[NSPersistentStoreCoordinator initWithManagedObjectModel:]( objc_alloc(&OBJC_CLASS___NSPersistentStoreCoordinator),  "initWithManagedObjectModel:",  -[NSMigrationManager destinationModel](self, "destinationModel"));
  uint64_t v31 = -[NSManagedObjectContext initWithConcurrencyType:]( objc_alloc(&OBJC_CLASS___NSManagedObjectContext),  "initWithConcurrencyType:",  3LL);
  self->_destinationManagedObjectContext = v31;
  -[NSManagedObjectContext setPersistentStoreCoordinator:](v31, "setPersistentStoreCoordinator:", v30);
  -[NSManagedObjectContext setUndoManager:](self->_destinationManagedObjectContext, "setUndoManager:", 0LL);

  if (dOptions)
  {
    unint64_t v32 = -[NSDictionary objectForKey:](dOptions, "objectForKey:", @"NSSQLitePragmasOption");
    unint64_t v33 = v32;
    if (v32)
    {
      if ([v32 objectForKey:@"journal_mode]"])
      {
        unsigned int v34 = dOptions;
      }

      else
      {
        unsigned int v34 = (NSDictionary *)-[NSDictionary mutableCopy](dOptions, "mutableCopy");
        unint64_t v41 = (void *)[v33 mutableCopy];
        objc_msgSend(v41, "setObject:forKey:", objc_msgSend(MEMORY[0x189603FE8], "null"), @"journal_mode");
        -[NSDictionary setObject:forKey:](v34, "setObject:forKey:", v41, @"NSSQLitePragmasOption");
      }
    }

    else
    {
      unsigned int v34 = (NSDictionary *)-[NSDictionary mutableCopy](dOptions, "mutableCopy");
      uint64_t v39 = objc_alloc(MEMORY[0x189603F68]);
      uint64_t v40 = (void *)objc_msgSend( v39,  "initWithObjectsAndKeys:",  objc_msgSend(MEMORY[0x189603FE8], "null"),  @"journal_mode",  0);
      -[NSDictionary setObject:forKey:](v34, "setObject:forKey:", v40, @"NSSQLitePragmasOption");
    }
  }

  else
  {
    uint64_t v37 = objc_alloc(MEMORY[0x189603F68]);
    uint64_t v38 = (void *)objc_msgSend( v37,  "initWithObjectsAndKeys:",  objc_msgSend(MEMORY[0x189603FE8], "null"),  @"journal_mode",  0);
    unsigned int v34 = (NSDictionary *)objc_msgSend( objc_alloc(MEMORY[0x189603F68]),  "initWithObjectsAndKeys:",  v38,  @"NSSQLitePragmasOption",  0);
  }

  uint64_t v94 = -[NSPersistentStoreCoordinator addPersistentStoreWithType:configuration:URL:options:error:]( v30,  "addPersistentStoreWithType:configuration:URL:options:error:",  dStoreType,  0LL,  dURL,  v34,  &v115);

  if (!v94)
  {
    if (error)
    {
      uint64_t v35 = (void *)MEMORY[0x189607870];
      uint64_t v36 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Can't add destination store",  @"reason",  v115,  *MEMORY[0x189607798],  0);
      goto LABEL_129;
    }

    goto LABEL_130;
  }

  v114[0] = MEMORY[0x1895F87A8];
  v114[1] = 3221225472LL;
  v114[2] = __148__NSMigrationManager_InternalMethods___migrateStoreFromURL_type_options_withMappingModel_toDestinationURL_destinationType_destinationOptions_error___block_invoke;
  v114[3] = &unk_189EA8980;
  v114[4] = v30;
  v114[5] = v98;
  v114[6] = v94;
  v114[7] = self;
  -[NSPersistentStoreCoordinator performBlockAndWait:](v30, "performBlockAndWait:", v114);
  unint64_t v42 = -[NSMappingModel entityMappings](mappings, "entityMappings");
  uint64_t v113 = 0LL;
  uint64_t v109 = 0u;
  unint64_t v110 = 0u;
  uint64_t v111 = 0u;
  uint64_t v112 = 0u;
  unsigned int v43 = -[NSArray countByEnumeratingWithState:objects:count:]( v42,  "countByEnumeratingWithState:objects:count:",  &v109,  v127,  16LL);
  uint64_t v100 = v42;
  if (!v43) {
    goto LABEL_72;
  }
  unsigned int v44 = *(void *)v110;
  unint64_t v92 = *MEMORY[0x189607460];
  __int128 v45 = 0x189607000uLL;
LABEL_42:
  unint64_t v46 = 0LL;
  while (1)
  {
    if (*(void *)v110 != v44) {
      objc_enumerationMutation(v42);
    }
    unint64_t v47 = *(NSEntityMigrationPolicy **)(*((void *)&v109 + 1) + 8 * v46);
    uint64_t v102 = objc_alloc_init(*(Class *)(v45 + 2024));
    uint64_t v48 = -[NSEntityMapping _migrationPolicy](v47);
    if (!-[NSEntityMigrationPolicy beginEntityMapping:manager:error:]( v48,  "beginEntityMapping:manager:error:",  v47,  self,  &v113))
    {
      unsigned int v54 = 0;
LABEL_60:
      LOBYTE(v117) = 0;
      uint64_t v55 = 1;
      goto LABEL_65;
    }

    if ((*(_BYTE *)&self->_migrationManagerFlags & 1) != 0)
    {
      unsigned int v54 = 1;
      uint64_t v113 = self->_migrationCancellationError;
      goto LABEL_60;
    }

    -[NSMigrationContext setCurrentEntityMapping:]((uint64_t)self->_migrationContext, v47);
    uint64_t v49 = (void *)[objc_alloc(MEMORY[0x189603FC8]) initWithCapacity:8];
    [v49 setValue:self forKey:@"manager"];
    [v49 setValue:v47 forKey:@"entityMapping"];
    [v49 setValue:v48 forKey:@"entityPolicy"];
    unint64_t v50 = (void *)objc_msgSend( (id)-[NSEntityMigrationPolicy sourceExpression](v47, "sourceExpression"),  "expressionValueWithObject:context:",  0,  v49);

    __int128 v125 = 0u;
    __int128 v126 = 0u;
    __int128 v123 = 0u;
    __int128 v124 = 0u;
    unint64_t v51 = [v50 countByEnumeratingWithState:&v123 objects:v128 count:16];
    if (v51)
    {
      unint64_t v52 = *(void *)v124;
      while (2)
      {
        for (uint64_t i = 0LL; i != v51; ++i)
        {
          if (*(void *)v124 != v52) {
            objc_enumerationMutation(v50);
          }
          if (!-[NSEntityMigrationPolicy createDestinationInstancesForSourceInstance:entityMapping:manager:error:]( v48,  "createDestinationInstancesForSourceInstance:entityMapping:manager:error:",  *(void *)(*((void *)&v123 + 1) + 8 * i),  v47,  self,  &v113))
          {
            unsigned int v54 = 0;
            LOBYTE(v117) = 0;
            uint64_t v55 = 1;
            unint64_t v42 = v100;
            goto LABEL_64;
          }

          if ((*(_BYTE *)&self->_migrationManagerFlags & 1) != 0)
          {
            unint64_t v42 = v100;
            uint64_t v113 = self->_migrationCancellationError;
            LOBYTE(v117) = 0;
            uint64_t v55 = 1;
            unsigned int v54 = 1;
            goto LABEL_64;
          }
        }

        unint64_t v51 = [v50 countByEnumeratingWithState:&v123 objects:v128 count:16];
        unint64_t v42 = v100;
        if (v51) {
          continue;
        }
        break;
      }
    }

    unsigned int v54 = -[NSEntityMigrationPolicy endInstanceCreationForEntityMapping:manager:error:]( v48,  "endInstanceCreationForEntityMapping:manager:error:",  v47,  self,  &v113);
    if ((*(_BYTE *)&self->_migrationManagerFlags & 1) != 0)
    {
      uint64_t v113 = self->_migrationCancellationError;
      LOBYTE(v117) = 0;
      uint64_t v55 = 1;
    }

    else
    {
      uint64_t v55 = 0;
    }

void sub_186786524(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867864E8LL);
  }

  JUMPOUT(0x186786450LL);
}

void sub_186787EB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
}

void sub_186788380(_Unwind_Exception *a1)
{
}

void __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

void sub_186788510( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

#error "186788824: call analysis failed (funcsize=45)"
void __cdecl -[NSSQLDefaultConnectionManager scheduleConnectionsBarrier:]( NSSQLDefaultConnectionManager *self,  SEL a2,  id a3)
{
  dispatch_queue_s *processingQueue;
  void *v4;
  void block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  void (*v10)(uint64_t);
  uint64_t v11;
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  int v8 = 0x3052000000LL;
  unint64_t v9 = __Block_byref_object_copy__15;
  __int128 v10 = __Block_byref_object_dispose__15;
  __int128 v11 = 0LL;
  processingQueue = (dispatch_queue_s *)self->_processingQueue;
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __60__NSSQLDefaultConnectionManager_scheduleConnectionsBarrier___block_invoke;
  block[3] = &unk_189EA8A50;
  block[4] = self;
  block[5] = a3;
  void block[6] = &v6;
  dispatch_barrier_sync(processingQueue, block);
  int v4 = (void *)v7[5];
  if (v4)
  {
    objc_exception_throw(v4);
    __break(1u);
  }

  else
  {
    _Block_object_dispose(&v6, 8);
  }

void sub_186788994( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

#error "186788CD0: call analysis failed (funcsize=45)"
uint64_t __60__NSSQLDefaultConnectionManager_scheduleConnectionsBarrier___block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void sub_186788E48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

#error "1867892B0: call analysis failed (funcsize=45)"
void __57__NSSQLDefaultConnectionManager_disconnectAllConnections__block_invoke_3(uint64_t a1)
{
  -[NSSQLiteConnection disconnect](*(void *)(a1 + 32));
}

void sub_1867895C0(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x186789494LL);
  }

  JUMPOUT(0x186789600LL);
}

uint64_t sub_1867895F8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867895FCLL);
  }
  objc_terminate();
  return __72__NSSQLDefaultConnectionManager_enumerateAvailableConnectionsWithBlock___block_invoke(v2);
}

objc_class *_PFFastStoreTemporaryIDClass(uint64_t a1)
{
  uint64_t v3 = (unint64_t *)(a1 + 64);
  uint64_t result = *(objc_class **)(a1 + 64);
  if (!result)
  {
    uint64_t result = +[NSTemporaryObjectID classForStore:](&OBJC_CLASS___NSTemporaryObjectID, "classForStore:", a1);
    while (!__ldaxr(v3))
    {
    }

    __clrex();
    unint64_t v5 = *v3;

    return (objc_class *)v5;
  }

  return result;
}

void sub_18678C0A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
}

void sub_18678C2D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void __Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
}

void _perform_0(unint64_t a1, uint64_t a2)
{
  unint64_t v2 = a1;
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v3 = *(dispatch_queue_s **)(a1 + 16);
  if (v3)
  {
    unint64_t v4 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 712);
    v15[0] = a2;
    v15[1] = v2;
    id v15[2] = 0LL;
    void v15[3] = v4;
    id v16 = 0LL;
    if (v4)
    {
      unint64_t v5 = 0LL;
      int v6 = 0;
      unint64_t v7 = v4;
      while (v7 != v2)
      {
        if (v7 == v5) {
          goto LABEL_11;
        }
        if (!v5) {
          unint64_t v5 = v7;
        }
        unint64_t v7 = atomic_load((unint64_t *)(v7 + 8));
        if (!v7) {
          goto LABEL_12;
        }
      }

      int v6 = 1;
LABEL_11:
      if (v6)
      {
LABEL_21:
        gutsOfBlockToNSPersistentStoreCoordinatorPerform(v15);
        goto LABEL_23;
      }

void sub_18678DDAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18678DF7C(_Unwind_Exception *a1)
{
}

void sub_18678DFF4(_Unwind_Exception *a1)
{
}

void sub_18678E304( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_18678E390(_Unwind_Exception *a1)
{
}

void sub_18678EA64(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18678EA30LL);
  }

  JUMPOUT(0x18678EA0CLL);
}

void sub_18678F070(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18678F040LL);
  }

  JUMPOUT(0x18678F008LL);
}

void sub_18678F230( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

#error "18678F784: call analysis failed (funcsize=31)"
uint64_t -[NSPersistentStoreCoordinator _hasHistoryTracking:](uint64_t result, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _BYTE v10[128];
  uint64_t v11;
  id v11 = *MEMORY[0x1895F89C0];
  if (result)
  {
    unint64_t v8 = 0u;
    int v9 = 0u;
    int v6 = 0u;
    unint64_t v7 = 0u;
    uint64_t result = [a2 countByEnumeratingWithState:&v6 objects:v10 count:16];
    if (result)
    {
      uint64_t v3 = result;
      unint64_t v4 = *(void *)v7;
      while (2)
      {
        unint64_t v5 = 0LL;
        do
        {
          if (*(void *)v7 != v4) {
            objc_enumerationMutation(a2);
          }
          if (objc_msgSend( (id)objc_msgSend(*(id *)(*((void *)&v6 + 1) + 8 * v5), "options"),  "objectForKey:",  @"NSPersistentHistoryTrackingKey"))
          {
            return 1LL;
          }

          ++v5;
        }

        while (v3 != v5);
        uint64_t result = [a2 countByEnumeratingWithState:&v6 objects:v10 count:16];
        uint64_t v3 = result;
        if (result) {
          continue;
        }
        break;
      }
    }
  }

  return result;
}

void sub_18678FE28(_Unwind_Exception *a1)
{
}

void sub_186790614(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867905E8LL);
  }

  JUMPOUT(0x1867905B8LL);
}

void sub_1867906C4(_Unwind_Exception *a1)
{
}

void sub_186790924(_Unwind_Exception *a1)
{
}

void sub_186790940()
{
}

void sub_186790D94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

LABEL_57:
  uint64_t v66 = *(id *)(*(void *)(*(void *)(v10 + 72) + 8LL) + 40LL);
}

          objc_autoreleasePoolPop(context);
          ++v14;
        }

        while (v14 != v52);
        uint64_t result = [v11 countByEnumeratingWithState:&v59 objects:v64 count:16];
        unint64_t v52 = result;
      }

      while (result);
    }
  }

  return result;
}

  unint64_t v115 = -[NSSQLiteConnection numberOfTombstones](*(void *)(v1 + 48));
  uint64_t v116 = +[_PFPersistentHistoryModel _maxCountOfTombstonesInModel:]( (uint64_t)&OBJC_CLASS____PFPersistentHistoryModel,  *(void **)(v1 + 16));
  __int128 v123 = v116;
  if (v115 >= v116)
  {
    if (!v115 || !v116) {
      goto LABEL_71;
    }
    if (v148 > 0) {
      goto LABEL_67;
    }
LABEL_70:
    if ((-[_NSSQLiteStoreMigrator shiftTombstones]((id *)v1) & 1) == 0) {
      goto LABEL_77;
    }
    goto LABEL_71;
  }

  if (v148 >= 1) {
    _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning adding new tombstone columns",  v117,  v118,  v119,  v120,  v121,  v122,  v138);
  }
  if (!-[NSSQLiteConnection addTombstoneColumnsForRange:](*(id **)(v1 + 48), v115, v123)) {
    goto LABEL_77;
  }
  if (v148 <= 0)
  {
    if (!v115) {
      goto LABEL_71;
    }
    goto LABEL_70;
  }

  _NSCoreDataLog(4LL, (uint64_t)@"Finished adding new tombstone columns", v117, v118, v119, v120, v121, v122, v138);
  if (!v115) {
    goto LABEL_71;
  }
LABEL_67:
  _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning remapping of shifted tombstone columns",  v117,  v118,  v119,  v120,  v121,  v122,  v138);
  _NSCoreDataLog( 4LL,  (uint64_t)@"Finished remapping of shifted tombstone columns",  v124,  v125,  v126,  v127,  v128,  v129,  v140);
LABEL_71:
  if (v115 > v123)
  {
    if (v148 < 1)
    {
      if (-[_NSSQLiteStoreMigrator clearTombstoneColumnsForRange:](v1, v115, v123)) {
        goto LABEL_76;
      }
    }

    else
    {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning clearing contents from removed tombstone columns",  v117,  v118,  v119,  v120,  v121,  v122,  v138);
      if (-[_NSSQLiteStoreMigrator clearTombstoneColumnsForRange:](v1, v115, v123))
      {
        _NSCoreDataLog( 4LL,  (uint64_t)@"Finished clearing contents from removed tombstone columns",  v130,  v131,  v132,  v133,  v134,  v135,  v141);
        goto LABEL_76;
      }
    }

    storeIdentifier = 0LL;
    goto LABEL_46;
  }

  if (a4)
  {
    uint64_t v25 = (void *)MEMORY[0x189607870];
    uint64_t v85 = *MEMORY[0x1896075F0];
    if (self) {
      uint64_t v26 = self->super.super._request;
    }
    else {
      uint64_t v26 = 0LL;
    }
    uint64_t v86 = [NSString stringWithFormat:@"Request '%@' was cancelled because the store was removed from the coordinator.", -[NSCloudKitMirroringRequest requestIdentifier](v26, "requestIdentifier")];
    uint64_t v27 = [MEMORY[0x189603F68] dictionaryWithObjects:&v86 forKeys:&v85 count:1];
    uint64_t v28 = [v25 errorWithDomain:*MEMORY[0x189607460] code:134407 userInfo:v27];
    uint64_t v29 = objc_alloc(&OBJC_CLASS___NSCloudKitMirroringResult);
    if (self)
    {
      uint64_t v30 = self->super.super._request;
      if (!v9) {
        goto LABEL_55;
      }
    }

    else
    {
      uint64_t v30 = 0LL;
      if (!v9) {
        goto LABEL_55;
      }
    }

    uint64_t v31 = v9->_monitor;
    if (v31)
    {
      unint64_t v32 = (uint64_t)v31->_storeIdentifier;
LABEL_34:
      unint64_t v33 = -[NSCloudKitMirroringResult initWithRequest:storeIdentifier:success:madeChanges:error:]( v29,  "initWithRequest:storeIdentifier:success:madeChanges:error:",  v30,  v32,  0LL,  0LL,  v28);
      (*((void (**)(id, NSCloudKitMirroringResult *))a4 + 2))(a4, v33);

      goto LABEL_35;
    }

void sub_1867922E4(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867925B0LL);
  }

  JUMPOUT(0x1867925C0LL);
}

void sub_1867922F4(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867925C0LL);
  }
  JUMPOUT(0x1867925B0LL);
}

void sub_1867925C8(_Unwind_Exception *a1)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_1867925E0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  _Unwind_Resume(a1);
}

void sub_186792F60(void *a1)
{
}

void sub_1867932B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1867933C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_3:
    [a2 willRemoveFromPersistentStoreCoordinator:a1];
    __dmb(0xBu);
    while (1)
    {
      os_unfair_lock_lock_with_options();
      unint64_t v4 = *(void **)(a1 + 48);
      unint64_t v5 = (void *)[v4 mutableCopy];
      [v5 removeObjectIdenticalTo:a2];
      int v6 = (id)[v5 copy];

      CFRetain(v6);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
      if (v6) {
        CFRelease(v6);
      }
    }

    *(void *)(a1 + 4_Block_object_dispose((const void *)(v9 - 48), 8) = v6;
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
    if (a2)
    {
      if (atomic_load(a2 + 1)) {
        atomic_store(0LL, a2 + 1);
      }
    }

    if (v4) {
      CFRelease(v4);
    }
  }

  return a1 != 0;
}

  id v84 = v3;
  uint64_t v85 = v5;
  uint64_t v80 = v1;
  int v6 = objc_alloc_init(&OBJC_CLASS___NSFetchRequest);
  unint64_t v103 = 0u;
  uint64_t v104 = 0u;
  uint64_t v101 = 0u;
  uint64_t v102 = 0u;
  __int128 v82 = v2;
  unint64_t v7 = *(void **)(v2 + 40);
  unint64_t v8 = [v7 countByEnumeratingWithState:&v101 objects:v100 count:16];
  uint64_t v81 = v4;
  if (v8)
  {
    uint64_t v9 = v8;
    id v10 = 0LL;
    id v11 = *(void *)v102;
    __int128 v12 = *MEMORY[0x189603A58];
    do
    {
      for (uint64_t i = 0LL; i != v9; ++i)
      {
        if (*(void *)v102 != v11) {
          objc_enumerationMutation(v7);
        }
        int v1 = *(void *)(*((void *)&v101 + 1) + 8 * i);
        if (![(id)v1 superentity])
        {
          uint64_t v94 = 0LL;
          -[NSFetchRequest setEntity:](v6, "setEntity:", v1);
          -[NSFetchRequest setAffectedStores:]( v6,  "setAffectedStores:",  [MEMORY[0x189603F18] arrayWithObject:v84]);
          if (!-[NSManagedObjectContext executeFetchRequest:error:](v5, "executeFetchRequest:error:", v6, &v94)) {
            id v10 = (id)[MEMORY[0x189603F70] exceptionWithName:v12, objc_msgSend( NSString, "stringWithFormat:", @"Fetch instances of entity %@ from store %@ failed, reason: %@", v1, v84, v94), 0 reason userInfo];
          }
        }
      }

      uint64_t v9 = [v7 countByEnumeratingWithState:&v101 objects:v100 count:16];
    }

    while (v9);

    unint64_t v14 = v5;
    if (v10) {
      goto LABEL_101;
    }
  }

  else
  {

    unint64_t v14 = v5;
  }

  uint64_t v15 = (void *)[v14 registeredObjects];
  id v16 = (id)objc_msgSend( objc_alloc(MEMORY[0x189603FE0]),  "initWithCapacity:",  objc_msgSend(v15, "count"));
  uint64_t v79 = objc_msgSend((id)objc_msgSend(v14, "deletedObjects"), "count");
  uint64_t v90 = 0u;
  uint64_t v91 = 0u;
  unint64_t v92 = 0u;
  uint64_t v93 = 0u;
  uint64_t v17 = [v15 countByEnumeratingWithState:&v90 objects:&v96 count:16];
  if (v17)
  {
    uint64_t v18 = v17;
    uint64_t v19 = *(void *)v91;
    do
    {
      for (uint64_t j = 0LL; j != v18; ++j)
      {
        if (*(void *)v91 != v19) {
          objc_enumerationMutation(v15);
        }
        unint64_t v21 = *(void **)(*((void *)&v90 + 1) + 8 * j);
        if ((void *)objc_msgSend((id)objc_msgSend(v21, "objectID"), "persistentStore") == v84)
        {
          [v16 addObject:v21];
          if (v21) {
            uint64_t v22 = _insertion_fault_handler;
          }
          else {
            uint64_t v22 = 0LL;
          }
          -[NSFaultHandler _fireFirstAndSecondLevelFaultsForObject:withContext:](v22, v21);
        }
      }

      uint64_t v18 = [v15 countByEnumeratingWithState:&v90 objects:&v96 count:16];
    }

    while (v18);
  }

  obuint64_t j = v16;
  unsigned int v23 = (void *)[v14 registeredObjects];
  uint64_t v24 = objc_msgSend((id)objc_msgSend(v14, "deletedObjects"), "count");
  uint64_t v86 = 0u;
  uint64_t v87 = 0u;
  uint64_t v88 = 0u;
  uint64_t v89 = 0u;
  uint64_t v25 = [v23 countByEnumeratingWithState:&v86 objects:v95 count:16];
  if (v25)
  {
    uint64_t v26 = v25;
    uint64_t v27 = 0;
    uint64_t v28 = *(void *)v87;
LABEL_30:
    uint64_t v29 = 0LL;
    while (1)
    {
      if (*(void *)v87 != v28) {
        objc_enumerationMutation(v23);
      }
      uint64_t v30 = *(_BYTE **)(*((void *)&v86 + 1) + 8 * v29);
      if ((void *)objc_msgSend((id)objc_msgSend(v30, "objectID"), "persistentStore") == v84)
      {
        ++v27;
        if (([obj containsObject:v30] & 1) == 0) {
          break;
        }
      }

      if (v26 == ++v29)
      {
        uint64_t v26 = [v23 countByEnumeratingWithState:&v86 objects:v95 count:16];
        if (v26) {
          goto LABEL_30;
        }
        goto LABEL_46;
      }
    }

    uint64_t v31 = (void *)[v30 objectID];
    if ((v30[16] & 0x12) == 0)
    {
      unint64_t v32 = v31;
      if (([v31 isTemporaryID] & 1) == 0)
      {
        uint64_t v94 = 0LL;
        unint64_t v33 = (void *)[v84 newValuesForObjectWithID:v32 withContext:v14 error:&v94];
        if (!v33)
        {
          uint64_t v55 = v94;
          __int128 v78 = *MEMORY[0x189607678];
          uint64_t v56 = [NSString stringWithFormat:@"CoreData could not fulfill a fault for '%@'", v32];
          uint64_t v57 = (void *)MEMORY[0x189603F68];
          uint64_t v58 = [MEMORY[0x189603F18] arrayWithObject:v30];
          if (v55) {
            uint64_t v59 = (void *)objc_msgSend( v57,  "dictionaryWithObjectsAndKeys:",  v58,  @"NSAffectedObjectsErrorKey",  v94,  *MEMORY[0x189607798],  0);
          }
          else {
            uint64_t v59 = (void *)objc_msgSend( v57,  "dictionaryWithObjectsAndKeys:",  v58,  @"NSAffectedObjectsErrorKey",  0,  v76,  v77);
          }
          int v1 = 133000LL;
          uint64_t v60 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  v78,  133000LL,  v56,  v59);
          uint64_t v61 = *MEMORY[0x189603A58];
          unint64_t v62 = [NSString stringWithFormat:@"Referential integrity problem found during migratePersistentStore:toURL:options:withType:error: %@", objc_msgSend(v60, "reason")];
          unsigned int v34 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  v60,  @"NSUnderlyingException",  0);
          uint64_t v36 = v61;
          uint64_t v37 = 133000LL;
          uint64_t v35 = (const __CFString *)v62;
LABEL_43:
          id v10 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  v36,  v37,  (uint64_t)v35,  v34);
          if (!v10) {
            goto LABEL_46;
          }
          goto LABEL_101;
        }
      }
    }

    int v1 = *MEMORY[0x189603A58];
    unsigned int v34 = (void *)objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjectsAndKeys:", v30, @"object", 0);
    uint64_t v35 = @"Save failed during during migratePersistentStore:toURL:options:withType:error:, object added to store during fetch.";
    uint64_t v36 = v1;
    uint64_t v37 = 134030LL;
    goto LABEL_43;
  }

  uint64_t v27 = 0;
LABEL_46:
  if ([obj count] == v27)
  {
    if (v24 == v79) {
      goto LABEL_51;
    }
    int v1 = *MEMORY[0x189603A58];
    uint64_t v38 = objc_msgSend( NSString,  "stringWithFormat:",  @"Save failed during migratePersistentStore:toURL:options:withType:error:, %d objects in store were removed during fetch.",  v24 - v79);
  }

  else
  {
    int v1 = *MEMORY[0x189603A58];
    uint64_t v38 = objc_msgSend( NSString,  "stringWithFormat:",  @"Save failed during migratePersistentStore:toURL:options:withType:error:, %d objects in store were removed during fetch.",  objc_msgSend(obj, "count") - v27);
  }

  id v10 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  v1,  134030LL,  v38,  0LL);
  if (v10)
  {
LABEL_101:

    objc_exception_throw(v10);
LABEL_102:
    unsigned int v54 = 0LL;
    goto LABEL_72;
  }

  unint64_t v7 = 0;
LABEL_11:

  return v7;
}

void sub_186793A6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_186793C38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_186794464(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186794424LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_186794488(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_1867944AC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    if ((v2 & 1) != 0) {
      JUMPOUT(0x1867944B8LL);
    }
    objc_begin_catch(a1);
    JUMPOUT(0x186794324LL);
  }

  _Unwind_Resume(a1);
}

void sub_1867944C0(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867944C8LL);
  }
  objc_terminate();
  sub_1867944DC(v2, v3);
}

void sub_1867944DC(_Unwind_Exception *exc_buf, int a2)
{
  if (!a2) {
    _Unwind_Resume(exc_buf);
  }
  objc_begin_catch(exc_buf);
  JUMPOUT(0x186794324LL);
}

void sub_1867944E8(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_sync_exit(v2);
    JUMPOUT(0x1867944FCLL);
  }

  JUMPOUT(0x1867944C8LL);
}

LABEL_66:
  -[NSPersistentStoreCoordinator _copyMetadataFromStore:toStore:migrationManager:](v82, v84, v81, 0LL);
  if (v84)
  {
    unint64_t v53 = (void *)[MEMORY[0x189607958] defaultCenter];
    *(void *)&uint64_t v101 = @"removed";
    v95[0] = v84;
    objc_msgSend( v53,  "postNotificationName:object:userInfo:",  @"_NSPersistentStoreCoordinatorPrivateWillRemoveStoreNotification",  v82,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", v95, &v101, 1));
  }

  -[NSPersistentStoreCoordinator _removePersistentStore:](v82, (unint64_t *)v84);
  *(void *)&uint64_t v90 = 0LL;
  -[NSManagedObjectContext save:](v85, "save:", &v90);
  char v1 = v80;
  if ((void)v90)
  {

    uint64_t v74 = v85;
    uint64_t v75 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  *MEMORY[0x189603A58],  134030,  (uint64_t)@"Save failed.",  (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  (void)v90,  @"NSCoreDataPrimaryError",  0));
    objc_exception_throw(v75);
  }

  -[NSManagedObjectContext reset](v85, "reset");

  if ((void)v90) {
    unsigned int v54 = 0LL;
  }
  else {
    unsigned int v54 = v39;
  }
LABEL_72:
  *(void *)(*(void *)(*(void *)(v1 + 56) + 8LL) + 40LL) = v54;
}

void sub_186795634( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_349:
          uint64_t v212 = 0LL;
LABEL_350:
          if (v192) {
            v192[18] = v196;
          }
          uint64_t v237 = (void *)[v333 lockedObjects];
          if ([v237 count])
          {
            v389 = 0u;
            v390 = 0u;
            v387 = 0u;
            v388 = 0u;
            v238 = [v237 countByEnumeratingWithState:&v387 objects:v424 count:16];
            if (v238)
            {
              v239 = *(void *)v388;
              while (2)
              {
                for (kuint64_t k = 0LL; kk != v238; ++kk)
                {
                  if (*(void *)v388 != v239) {
                    objc_enumerationMutation(v237);
                  }
                  uint64_t v241 = *(void **)(*((void *)&v387 + 1) + 8 * kk);
                  uint64_t v242 = (void *)MEMORY[0x186E3E5D8]();
                  if (objc_msgSend((id)objc_msgSend(v241, "objectID"), "isTemporaryID"))
                  {
                    v289 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObject:", v241),  @"NSAffectedObjectsErrorKey",  0);
                    v290 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A60],  134030LL,  (uint64_t)@"Cannot lock object that was never inserted.",  v289);
                    objc_exception_throw(v290);
                    goto LABEL_502;
                  }

                  uint64_t v243 = -[NSPersistentStoreCoordinator _conflictsWithRowCacheForObject:withContext:andStore:]( v191,  v241,  (void **)v192,  v338);
                  if (v243) {
                    [contextb addObject:v243];
                  }
                  objc_autoreleasePoolPop(v242);
                }

                v238 = [v237 countByEnumeratingWithState:&v387 objects:v424 count:16];
                if (v238) {
                  continue;
                }
                break;
              }
            }
          }

          if (v192) {
            v192[18] = v196;
          }
          if (v331) {
            [v192 _setQueryGenerationFromToken:v329 error:0];
          }
          [v325 drain];
          unint64_t v244 = 0LL;
          if (v212)
          {
            -[NSSaveChangesRequest setDeletedObjects:](v333, v212);
          }

LABEL_369:
          if (![contextb count])
          {
            id v245 = [v338 _prepareForExecuteRequest:*(void *)(v327 + 32) withContext:*(void *)(v327 + 56) error:&v370];
            if (v245) {
              uint64_t v246 = [v338 executeRequest:*(void *)(v327 + 32) withContext:*(void *)(v327 + 56) error:&v370];
            }
            else {
              uint64_t v246 = 0LL;
            }
            if (*(void *)(v327 + 96))
            {
              if (PFInstrumentsGetLog_logtoken != -1) {
                dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
              }
              uint64_t v247 = *(void *)(v327 + 96);
              if (v247 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
              {
                id v248 = (os_log_s *)PFInstrumentsGetLog_coreDataInstrumentsLog;
                if (os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl( &dword_186681000,  v248,  OS_SIGNPOST_INTERVAL_END,  v247,  "Save",  "",  buf,  2u);
                }
              }
            }

            if (!v246)
            {
              if (v370) {
                unint64_t v249 = v245;
              }
              else {
                unint64_t v249 = 0;
              }
              if (v249 == 1 && [v370 code] == 134050)
              {
                v319 = [v370 userInfo];
                objc_exception_throw( +[_NSCoreDataOptimisticLockingException exceptionWithName:reason:userInfo:]( &OBJC_CLASS____NSCoreDataOptimisticLockingException,  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A58],  @"optimistic locking failure",  v319));
                goto LABEL_502;
              }

              if (*(void *)(v327 + 104)) {
                *(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL) = v370;
              }
            }

            *(void *)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL) = v246;
            goto LABEL_414;
          }

          if (*(void *)(v327 + 96))
          {
            if (PFInstrumentsGetLog_logtoken != -1) {
              dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
            }
            v310 = *(void *)(v327 + 96);
            if (v310 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              v311 = (os_log_s *)PFInstrumentsGetLog_coreDataInstrumentsLog;
              if (os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog))
              {
                *(_WORD *)buf = 0;
                _os_signpost_emit_with_name_impl( &dword_186681000,  v311,  OS_SIGNPOST_INTERVAL_END,  v310,  "Save",  "",  buf,  2u);
              }
            }
          }

          v312 = [MEMORY[0x189603F68] dictionaryWithObject:contextb forKey:@"conflictList"];
          objc_exception_throw( +[_NSCoreDataOptimisticLockingException exceptionWithName:reason:userInfo:]( &OBJC_CLASS____NSCoreDataOptimisticLockingException,  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A58],  @"optimistic locking failure",  v312));
LABEL_502:
          __break(1u);
          return;
        }

        v313 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObject:", v338),  @"NSAffectedStoresErrorKey",  0);
        v314 = *MEMORY[0x189603A60];
        v315 = @"Cannot delete objects into a read only store.";
LABEL_499:
        v316 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  v314,  134030LL,  (uint64_t)v315,  v313);
        objc_exception_throw(v316);
        goto LABEL_502;
      }

      unsigned int v23 = *(void *)(v327 + 88);
LABEL_93:
      switch(v23)
      {
        case 1uLL:
          uint64_t v113 = (void *)[*(id *)(v327 + 32) sortDescriptors];
          unint64_t v114 = [v113 count]
          objc_msgSend((id)objc_msgSend(*(id *)(v327 + 32), "propertiesToGroupBy"), "count");
          *(void *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) = [MEMORY[0x189603FA8] arrayWithCapacity:v323];
          if (!v323)
          {
            uint64_t v221 = 0;
LABEL_392:
            if ((unint64_t)[*(id *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) count] >= 2
              && ((v221 ^ 1) & 1) == 0
              && v114)
            {
              [*(id *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) sortUsingDescriptors:v113];
            }

            goto LABEL_414;
          }

          uint64_t v220 = 0LL;
          uint64_t v221 = 0;
          while (1)
          {
            uint64_t v222 = (void *)objc_msgSend( (id)objc_msgSend(obj, "objectAtIndex:", v220),  "executeRequest:withContext:error:",  *(void *)(v327 + 32),  *(void *)(v327 + 56),  &v370);
            uint64_t v223 = v222;
            if (!v222) {
              break;
            }
            if ([v222 count])
            {
              uint64_t v224 = [*(id *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) count] != 0;
              [*(id *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) addObjectsFromArray:v223];
              v221 |= v224;
            }

            if (v323 == ++v220) {
              goto LABEL_392;
            }
          }

          *(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL) = v370;
          __int128 v45 = *(void *)(v327 + 64);
          goto LABEL_400;
        case 3uLL:
          *(void *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) = [MEMORY[0x189603FA8] arrayWithCapacity:v323];
          if (v323)
          {
            uint64_t v109 = 0LL;
            unint64_t v110 = 0LL;
            do
            {
              uint64_t v111 = (void *)objc_msgSend( (id)objc_msgSend(obj, "objectAtIndex:", v109),  "executeRequest:withContext:error:",  *(void *)(v327 + 32),  *(void *)(v327 + 56),  *(void *)(*(void *)(v327 + 80) + 8) + 40);
              uint64_t v112 = v111;
              if (v111 && [v111 count]) {
              ++v109;
              }
            }

            while (v323 != v109);
          }

          else
          {
            unint64_t v110 = 0LL;
          }

          uint64_t v250 = (NSPersistentHistoryResult *)objc_msgSend( MEMORY[0x189603F18],  "arrayWithObject:",  objc_msgSend(MEMORY[0x189607968], "numberWithUnsignedInt:", v110));
          break;
        case 2uLL:
          if (v323)
          {
            for (muint64_t m = 0LL; mm != v323; ++mm)
              objc_msgSend((id)objc_msgSend(obj, "objectAtIndex:", mm), "_preflightCrossCheck");
          }

          -[NSPersistentStoreCoordinator _doPreSaveAssignmentsForObjects:intoStores:]( *(void *)(v327 + 48),  (__objc2_class *)[*(id *)(v327 + 32) insertedObjects],  obj);
          v321 = (void *)[MEMORY[0x189603FA8] arrayWithCapacity:v323];
          v330 = (void *)[MEMORY[0x189603FA8] array];
          if (v323)
          {
            unint64_t v47 = 0LL;
            v320 = *MEMORY[0x189603A60];
            do
            {
              v322 = v47;
              uint64_t v48 = (unsigned __int8 *)objc_msgSend(obj, "objectAtIndex:");
              v332 = *(void *)(v327 + 48);
              if (v332)
              {
                uint64_t v49 = *(void **)(v327 + 56);
                v324 = *(void **)(v327 + 32);
                if (_PF_Threading_Debugging_level) {
                  _PFAssertSafeMultiThreadedAccess_impl( (uint64_t)v49,  sel__saveRequestForStore_withContext_originalRequest_andOptimisticLocking_);
                }
                unint64_t v50 = [v48 isReadOnly];
                [v49 stalenessInterval];
                unint64_t v52 = v51;
                if (v49) {
                  v49[18] = NSSQLDistantPastTimeInterval;
                }
                CFAllocatorContext context = (void **)v49;
                unint64_t v53 = (void *)[v324 insertedObjects];
                v402 = 0u;
                v401 = 0u;
                v399 = 0u;
                v400 = 0u;
                unsigned int v54 = [v53 countByEnumeratingWithState:&v399 objects:buf count:16];
                if (v54)
                {
                  v339 = 0LL;
                  uint64_t v55 = *(void *)v400;
                  do
                  {
                    for (nn = 0LL; nn != v54; ++nn)
                    {
                      if (*(void *)v400 != v55) {
                        objc_enumerationMutation(v53);
                      }
                      uint64_t v57 = *(void **)(*((void *)&v399 + 1) + 8 * nn);
                      if ((unsigned __int8 *)objc_msgSend((id)objc_msgSend(v57, "objectID"), "persistentStore") == v48)
                      {
                        if ((v50 & 1) != 0)
                        {

                          uint64_t v95 = (void *)MEMORY[0x189603F68];
                          uint64_t v96 = [MEMORY[0x189603F18] arrayWithObject:v48];
                          uint64_t v97 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  v320,  134030,  (uint64_t)@"Cannot insert objects into a read only store.",  (void *)objc_msgSend( v95,  "dictionaryWithObjectsAndKeys:",  v96,  @"NSAffectedStoresErrorKey",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObject:", v57),  @"NSAffectedObjectsErrorKey",  0));
                          objc_exception_throw(v97);
                          goto LABEL_502;
                        }

                        uint64_t v58 = v339;
                        if (!v339) {
                          uint64_t v58 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FE0]),  "initWithCapacity:",  objc_msgSend((id)objc_msgSend(v324, "insertedObjects"), "count"));
                        }
                        v339 = v58;
                        [v58 addObject:v57];
                      }
                    }

                    unsigned int v54 = [v53 countByEnumeratingWithState:&v399 objects:buf count:16];
                  }

                  while (v54);
                }

                else
                {
                  v339 = 0LL;
                }

                uint64_t v59 = (void *)[v324 updatedObjects];
                v397 = 0u;
                v398 = 0u;
                v395 = 0u;
                v396 = 0u;
                uint64_t v60 = [v59 countByEnumeratingWithState:&v395 objects:v426 count:16];
                if (v60)
                {
                  v328 = 0LL;
                  uint64_t v61 = *(void *)v396;
                  do
                  {
                    for (i1 = 0LL; i1 != v60; ++i1)
                    {
                      if (*(void *)v396 != v61) {
                        objc_enumerationMutation(v59);
                      }
                      unsigned int v63 = *(void **)(*((void *)&v395 + 1) + 8 * i1);
                      char v64 = (void *)MEMORY[0x186E3E5D8]();
                      if ((unsigned __int8 *)objc_msgSend((id)objc_msgSend(v63, "objectID"), "persistentStore") == v48)
                      {
                        if ((v50 & 1) != 0)
                        {

                          uint64_t v98 = (void *)MEMORY[0x189603F68];
                          uint64_t v99 = [MEMORY[0x189603F18] arrayWithObject:v48];
                          uint64_t v100 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  v320,  134030,  (uint64_t)@"Cannot update objects into a read only store.",  (void *)objc_msgSend( v98,  "dictionaryWithObjectsAndKeys:",  v99,  @"NSAffectedStoresErrorKey",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObject:", v63),  @"NSAffectedObjectsErrorKey",  0));
                          objc_exception_throw(v100);
                          goto LABEL_502;
                        }

                        uint64_t v65 = -[NSPersistentStoreCoordinator _conflictsWithRowCacheForObject:withContext:andStore:]( v332,  v63,  context,  v48);
                        if (v65)
                        {
                          [v330 addObject:v65];
                        }

                        else
                        {
                          uint64_t v66 = v328;
                          if (!v328) {
                            uint64_t v66 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FE0]),  "initWithCapacity:",  objc_msgSend((id)objc_msgSend(v324, "updatedObjects"), "count"));
                          }
                          v328 = v66;
                          [v66 addObject:v63];
                        }
                      }

                      objc_autoreleasePoolPop(v64);
                    }

                    uint64_t v60 = [v59 countByEnumeratingWithState:&v395 objects:v426 count:16];
                  }

                  while (v60);
                }

                else
                {
                  v328 = 0LL;
                }

                uint64_t v67 = (void *)[v324 deletedObjects];
                v393 = 0u;
                v394 = 0u;
                v391 = 0u;
                v392 = 0u;
                uint64_t v68 = 0LL;
                uint64_t v69 = [v67 countByEnumeratingWithState:&v391 objects:v425 count:16];
                if (v69)
                {
                  uint64_t v70 = *(void *)v392;
                  do
                  {
                    unint64_t v71 = 0LL;
                    do
                    {
                      if (*(void *)v392 != v70) {
                        objc_enumerationMutation(v67);
                      }
                      __int128 v72 = *(void **)(*((void *)&v391 + 1) + 8 * v71);
                      uint64_t v73 = (void *)MEMORY[0x186E3E5D8]();
                      if ((unsigned __int8 *)objc_msgSend((id)objc_msgSend(v72, "objectID"), "persistentStore") == v48)
                      {
                        if ((v50 & 1) != 0)
                        {

                          uint64_t v101 = (void *)MEMORY[0x189603F68];
                          uint64_t v102 = [MEMORY[0x189603F18] arrayWithObject:v48];
                          unint64_t v103 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  v320,  134030,  (uint64_t)@"Cannot delete objects into a read only store.",  (void *)objc_msgSend( v101,  "dictionaryWithObjectsAndKeys:",  v102,  @"NSAffectedStoresErrorKey",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObject:", v72),  @"NSAffectedObjectsErrorKey",  0));
                          objc_exception_throw(v103);
                          goto LABEL_502;
                        }

                        uint64_t v74 = (void *)-[NSPersistentStoreCoordinator _conflictsWithRowCacheForObject:withContext:andStore:]( v332,  v72,  context,  v48);
                        uint64_t v75 = v74;
                        if (v74)
                        {
                          if (objc_msgSend( (id)objc_msgSend(v74, "objectForKey:", @"newVersion"),  "intValue"))
                          {
                            [v330 addObject:v75];
                          }

                          else if (!v68)
                          {
                            uint64_t v68 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FE0]),  "initWithCapacity:",  objc_msgSend((id)objc_msgSend(v324, "deletedObjects"), "count"));
                          }
                        }

                        else
                        {
                          if (!v68) {
                            uint64_t v68 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FE0]),  "initWithCapacity:",  objc_msgSend((id)objc_msgSend(v324, "deletedObjects"), "count"));
                          }
                          [v68 addObject:v72];
                        }
                      }

                      objc_autoreleasePoolPop(v73);
                      ++v71;
                    }

                    while (v69 != v71);
                    __int128 v76 = [v67 countByEnumeratingWithState:&v391 objects:v425 count:16];
                    uint64_t v69 = v76;
                  }

                  while (v76);
                }

                if (context) {
                  context[18] = v52;
                }
                __int128 v77 = (void *)[v324 lockedObjects];
                v389 = 0u;
                v390 = 0u;
                v387 = 0u;
                v388 = 0u;
                __int128 v78 = [v77 countByEnumeratingWithState:&v387 objects:v424 count:16];
                if (v78)
                {
                  uint64_t v79 = 0LL;
                  uint64_t v80 = *(void *)v388;
                  do
                  {
                    for (i2 = 0LL; i2 != v78; ++i2)
                    {
                      if (*(void *)v388 != v80) {
                        objc_enumerationMutation(v77);
                      }
                      __int128 v82 = *(void **)(*((void *)&v387 + 1) + 8 * i2);
                      uint64_t v83 = (void *)MEMORY[0x186E3E5D8]();
                      if ((unsigned __int8 *)objc_msgSend((id)objc_msgSend(v82, "objectID"), "persistentStore") == v48)
                      {
                        id v84 = -[NSPersistentStoreCoordinator _conflictsWithRowCacheForObject:withContext:andStore:]( v332,  v82,  context,  v48);
                        if (v84)
                        {
                          [v330 addObject:v84];
                        }

                        else
                        {
                          if (!v79) {
                            uint64_t v79 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FE0]),  "initWithCapacity:",  objc_msgSend((id)objc_msgSend(v324, "lockedObjects"), "count"));
                          }
                          [v79 addObject:v82];
                        }
                      }

                      objc_autoreleasePoolPop(v83);
                    }

                    __int128 v78 = [v77 countByEnumeratingWithState:&v387 objects:v424 count:16];
                  }

                  while (v78);
                }

                else
                {
                  uint64_t v79 = 0LL;
                }

                if (context) {
                  context[18] = v52;
                }
                uint64_t v85 = [v330 count];
                uint64_t v86 = objc_alloc(&OBJC_CLASS___NSSaveChangesRequest);
                if (v85) {
                  uint64_t v87 = 0LL;
                }
                else {
                  uint64_t v87 = v339;
                }
                if (v85) {
                  uint64_t v88 = 0LL;
                }
                else {
                  uint64_t v88 = v328;
                }
                if (v85) {
                  uint64_t v89 = 0LL;
                }
                else {
                  uint64_t v89 = v68;
                }
                if (v85) {
                  uint64_t v90 = 0LL;
                }
                else {
                  uint64_t v90 = v79;
                }
                uint64_t v91 = -[NSSaveChangesRequest initWithInsertedObjects:updatedObjects:deletedObjects:lockedObjects:]( v86,  "initWithInsertedObjects:updatedObjects:deletedObjects:lockedObjects:",  v87,  v88,  v89,  v90);

                unint64_t v92 = v91;
              }

              else
              {
                unint64_t v92 = 0LL;
              }

              if (([v48 isReadOnly] & 1) == 0)
              {
                if (-[NSSaveChangesRequest hasChanges]((BOOL)v92)
                  || v48 && (uint64_t v93 = atomic_load(v48 + 60), (v93 & 1) != 0))
                {
                  uint64_t v94 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603F18]), "initWithObjects:", v48, 0);
                  -[NSPersistentStoreRequest setAffectedStores:](v92, "setAffectedStores:", v94);

                  [v321 addObject:v92];
                }
              }

              unint64_t v47 = v322 + 1;
            }

            while (v322 + 1 != v323);
          }

          if ([v330 count])
          {
            v305 = [MEMORY[0x189603F68] dictionaryWithObject:v330 forKey:@"conflictList"];
            if (*(void *)(v327 + 96))
            {
              if (PFInstrumentsGetLog_logtoken != -1) {
                dispatch_once(&PFInstrumentsGetLog_logtoken, &__block_literal_global_24);
              }
              v306 = *(void *)(v327 + 96);
              if (v306 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
              {
                v307 = (os_log_s *)PFInstrumentsGetLog_coreDataInstrumentsLog;
                if (os_signpost_enabled((os_log_t)PFInstrumentsGetLog_coreDataInstrumentsLog))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl( &dword_186681000,  v307,  OS_SIGNPOST_INTERVAL_END,  v306,  "Save",  "",  buf,  2u);
                }
              }
            }

            objc_exception_throw( +[_NSCoreDataOptimisticLockingException exceptionWithName:reason:userInfo:]( &OBJC_CLASS____NSCoreDataOptimisticLockingException,  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A58],  @"optimistic locking failure",  v305));
            goto LABEL_502;
          }

          uint64_t v145 = [v321 count];
          *(void *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) = [MEMORY[0x189603FA8] arrayWithCapacity:v145];
          if (!v145)
          {
LABEL_414:
            uint64_t v255 = *(void *)(v327 + 88);
            if (v255 <= 7 && ((1LL << v255) & 0xE4) != 0)
            {
              if (*(void *)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL))
              {
                v257 = *(void **)(v327 + 56);
                if (v257)
                {
                  if (v255 == 2
                    && objc_msgSend((id)objc_msgSend(v257, "_queryGenerationToken"), "_isEnabled"))
                  {
                    v360[0] = MEMORY[0x1895F87A8];
                    v360[1] = 3221225472LL;
                    v361 = __65__NSPersistentStoreCoordinator_executeRequest_withContext_error___block_invoke_429;
                    v362 = &unk_189EA7A38;
                    v258 = *(void **)(v327 + 56);
                    v363 = *(void *)(v327 + 48);
                    v364 = obj;
                    v365 = v258;
                    if ([v258 concurrencyType]) {
                      [*(id *)(v327 + 48) performBlockAndWait:v360];
                    }
                    else {
                      v361((uint64_t)v360);
                    }
                  }

                  else
                  {
                    v358 = 0u;
                    v359 = 0u;
                    v356 = 0u;
                    v357 = 0u;
                    v259 = [obj countByEnumeratingWithState:&v356 objects:v406 count:16];
                    if (v259)
                    {
                      v260 = *(void *)v357;
                      v261 = MEMORY[0x1895F87A8];
                      do
                      {
                        for (i3 = 0LL; i3 != v259; ++i3)
                        {
                          if (*(void *)v357 != v260) {
                            objc_enumerationMutation(obj);
                          }
                          v263 = *(void **)(*((void *)&v356 + 1) + 8 * i3);
                          if ([v263 supportsGenerationalQuerying]
                            && [v263 _hasActiveGenerations])
                          {
                            v351[0] = v261;
                            v351[1] = 3221225472LL;
                            v352 = __65__NSPersistentStoreCoordinator_executeRequest_withContext_error___block_invoke_2;
                            v353 = &unk_189EA7648;
                            v264 = *(void **)(v327 + 56);
                            v354 = *(void *)(v327 + 48);
                            v355 = v263;
                            if ([v264 concurrencyType]) {
                              [*(id *)(v327 + 48) performBlockAndWait:v351];
                            }
                            else {
                              v352((uint64_t)v351);
                            }
                          }
                        }

                        v259 = [obj countByEnumeratingWithState:&v356 objects:v406 count:16];
                      }

                      while (v259);
                    }
                  }

                  if (-[NSPersistentStoreCoordinator _hasHistoryTracking:](*(void *)(v327 + 48), obj))
                  {
                    v345[0] = MEMORY[0x1895F87A8];
                    v345[1] = 3221225472LL;
                    v346 = __65__NSPersistentStoreCoordinator_executeRequest_withContext_error___block_invoke_3;
                    v347 = &unk_189EA7A38;
                    v265 = *(void **)(v327 + 56);
                    v348 = *(void *)(v327 + 48);
                    v349 = obj;
                    v350 = v265;
                    if ([v265 concurrencyType]) {
                      [*(id *)(v327 + 48) performBlockAndWait:v345];
                    }
                    else {
                      v346((uint64_t)v345);
                    }
                  }
                }
              }
            }

            v266 = *(void **)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL);
            if (v266) {
              v267 = v266;
            }
            v268 = *(void **)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL);
            if (v268) {
              v269 = v268;
            }
            if (*(void *)(v327 + 88) == 2LL)
            {
              v270 = *(void *)(v327 + 32);
              if (v270) {
                v271 = *(void *)(v270 + 56) ? *(void **)(v270 + 56) : (void *)MEMORY[0x189604A58];
              }
              else {
                v271 = 0LL;
              }
              if ([v271 count])
              {
                v272 = (id)[v271 firstObject];
                if ((unint64_t)[v271 count] >= 2)
                {
                  contextc = (void *)MEMORY[0x186E3E5D8]();
                  v273 = objc_alloc_init(MEMORY[0x189603FC8]);
                  v343 = 0u;
                  v344 = 0u;
                  v341 = 0u;
                  v342 = 0u;
                  v274 = [v271 countByEnumeratingWithState:&v341 objects:v405 count:16];
                  if (v274)
                  {
                    v275 = *(void *)v342;
                    do
                    {
                      for (i4 = 0LL; i4 != v274; ++i4)
                      {
                        if (*(void *)v342 != v275) {
                          objc_enumerationMutation(v271);
                        }
                        v277 = *(void **)(*((void *)&v341 + 1) + 8 * i4);
                        v278 = (void *)MEMORY[0x186E3E5D8]();
                        v279 = (void *)objc_msgSend( (id)objc_msgSend(v277, "userInfo"),  "objectForKey:",  @"_NSManagedObjectContextObjectIDMutationMappingKey");
                        if ([v279 count]) {
                          [v273 addEntriesFromDictionary:v279];
                        }
                        objc_autoreleasePoolPop(v278);
                      }

                      v274 = [v271 countByEnumeratingWithState:&v341 objects:v405 count:16];
                    }

                    while (v274);
                  }

                  v280 = objc_alloc(MEMORY[0x189607950]);
                  v281 = [v272 name];
                  v282 = [v272 object];
                  v403 = @"_NSManagedObjectContextObjectIDMutationMappingKey";
                  v404 = v273;
                  v283 = objc_msgSend( v280,  "initWithName:object:userInfo:",  v281,  v282,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v404, &v403, 1));

                  objc_autoreleasePoolPop(contextc);
                  v272 = (id)v283;
                }

                v284 = (void *)MEMORY[0x186E3E5D8]();
                objc_msgSend((id)objc_msgSend(MEMORY[0x189607958], "defaultCenter"), "postNotification:", v272);
                if (v270)
                {

                  *(void *)(v270 + 56) = 0LL;
                }

                objc_autoreleasePoolPop(v284);
              }
            }

            return;
          }

          unint64_t v146 = 0LL;
          uint64_t v147 = 1LL;
          contexta = (void *)*MEMORY[0x189607460];
          v340 = *MEMORY[0x189607798];
          unint64_t v148 = (void *)MEMORY[0x189604A58];
          while (1)
          {
            unint64_t v149 = (id *)[v321 objectAtIndex:v146];
            unint64_t v150 = (void *)objc_msgSend((id)objc_msgSend(v149, "affectedStores"), "objectAtIndex:", 0);
            if ([v150 _prepareForExecuteRequest:v149 withContext:*(void *)(v327 + 56) error:*(void *)(*(void *)(v327 + 80) + 8) + 40]) {
              break;
            }
LABEL_276:
            ++v146;
            ++v147;
            if (v146 == v145) {
              goto LABEL_414;
            }
          }

          uint64_t v151 = [v150 executeRequest:v149 withContext:*(void *)(v327 + 56) error:*(void *)(*(void *)(v327 + 80) + 8) + 40];
          if (v151)
          {
            [*(id *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) addObject:v151];
            if (v149)
            {
              if (v149[7]) {
                uint64_t v152 = v149[7];
              }
              else {
                uint64_t v152 = v148;
              }
            }

            else
            {
              uint64_t v152 = 0LL;
            }

            if ([v152 count])
            {
              v368 = 0u;
              v369 = 0u;
              v366 = 0u;
              v367 = 0u;
              uint64_t v153 = [v152 countByEnumeratingWithState:&v366 objects:v415 count:16];
              if (v153)
              {
                unint64_t v154 = *(void *)v367;
                do
                {
                  for (i5 = 0LL; i5 != v153; ++i5)
                  {
                    if (*(void *)v367 != v154) {
                      objc_enumerationMutation(v152);
                    }
                    -[NSSaveChangesRequest _addChangedObjectIDsNotification:]( *(void *)(v327 + 32),  *(void *)(*((void *)&v366 + 1) + 8 * i5));
                  }

                  uint64_t v153 = [v152 countByEnumeratingWithState:&v366 objects:v415 count:16];
                }

                while (v153);
              }
            }

            if (!v149) {
              goto LABEL_276;
            }

            unint64_t v156 = v149 + 7;
            goto LABEL_275;
          }

          if (*(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL))
          {
LABEL_272:
            if (v145 != 1)
            {
              v296 = *(void *)(v327 + 80);
              if (v146
                || (v297 = objc_msgSend(*(id *)(*(void *)(v296 + 8) + 40), "code", v151),
                    v296 = *(void *)(v327 + 80),
                    v297 != 134050))
              {
                v300 = objc_msgSend(*(id *)(*(void *)(v296 + 8) + 40), "code", v151);
                v301 = [*(id *)(*(void *)(*(void *)(v327 + 80) + 8) + 40) localizedFailureReason];
                v416 = v340;
                v417 = *(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL);
                v302 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:&v417 forKeys:&v416 count:1];
                if (v301) {
                  v303 = (const __CFString *)v301;
                }
                else {
                  v303 = @"Save failed";
                }
                v304 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  v300,  (uint64_t)v303,  v302);
                -[_NSCoreDataException _setDomain:]( (uint64_t)v304,  (void *)[*(id *)(*(void *)(*(void *)(v327 + 80) + 8) + 40) domain]);
                *(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL) = 0LL;
                objc_exception_throw(v304);
              }

              else
              {
                v298 = [*(id *)(*(void *)(v296 + 8) + 40) userInfo];
                v299 = +[_NSCoreDataOptimisticLockingException exceptionWithName:reason:userInfo:]( &OBJC_CLASS____NSCoreDataOptimisticLockingException,  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A58],  @"optimistic locking failure",  v298);
                *(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL) = 0LL;
                objc_exception_throw(v299);
              }

              goto LABEL_502;
            }

            if (objc_msgSend(*(id *)(*(void *)(*(void *)(v327 + 80) + 8) + 40), "code", v151) == 134050)
            {
              v294 = [*(id *)(*(void *)(*(void *)(v327 + 80) + 8) + 40) userInfo];
              v295 = +[_NSCoreDataOptimisticLockingException exceptionWithName:reason:userInfo:]( &OBJC_CLASS____NSCoreDataOptimisticLockingException,  "exceptionWithName:reason:userInfo:",  *MEMORY[0x189603A58],  @"optimistic locking failure",  v294);
              *(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL) = 0LL;
              objc_exception_throw(v295);
              goto LABEL_502;
            }

            unint64_t v156 = (void *)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL);
LABEL_275:
            void *v156 = 0LL;
            goto LABEL_276;
          }

          if (objc_msgSend((id)objc_msgSend(v150, "type", 0), "isEqualToString:", @"SQLite"))
          {
            uint64_t v157 = [NSString stringWithUTF8String:"A sqlite store save failed but did not return an error: %@"];
            _NSCoreDataLog(17LL, v157, v158, v159, v160, v161, v162, v163, (uint64_t)v150);
            unint64_t v164 = __pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412290;
              v428 = v150;
              unint64_t v165 = (os_log_s *)v164;
              unint64_t v166 = "CoreData: A sqlite store save failed but did not return an error: %@";
LABEL_270:
              _os_log_fault_impl(&dword_186681000, v165, OS_LOG_TYPE_FAULT, v166, buf, 0xCu);
            }
          }

          else if (objc_msgSend((id)objc_msgSend(v150, "type"), "isEqualToString:", @"NSXPCStore"))
          {
            uint64_t v167 = [NSString stringWithUTF8String:"A xpc store save failed but did not return an error: %@"];
            _NSCoreDataLog(17LL, v167, v168, v169, v170, v171, v172, v173, (uint64_t)v150);
            uint64_t v174 = __pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412290;
              v428 = v150;
              unint64_t v165 = (os_log_s *)v174;
              unint64_t v166 = "CoreData: A xpc store save failed but did not return an error: %@";
              goto LABEL_270;
            }
          }

          else
          {
            if (!objc_msgSend((id)objc_msgSend(v150, "type"), "isEqualToString:", @"Binary"))
            {
              uint64_t v183 = [NSString stringWithUTF8String:"An in-memory store save failed but did not return an error: %@"];
              _NSCoreDataLog(17LL, v183, v184, v185, v186, v187, v188, v189, (uint64_t)v150);
              uint64_t v190 = __pflogFaultLog;
              if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT)) {
                goto LABEL_271;
              }
              *(_DWORD *)buf = 138412290;
              v428 = v150;
              unint64_t v165 = (os_log_s *)v190;
              unint64_t v166 = "CoreData: An in-memory store save failed but did not return an error: %@";
              goto LABEL_270;
            }

            uint64_t v175 = [NSString stringWithUTF8String:"A binary store save failed but did not return an error: %@"];
            _NSCoreDataLog(17LL, v175, v176, v177, v178, v179, v180, v181, (uint64_t)v150);
            uint64_t v182 = __pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412290;
              v428 = v150;
              unint64_t v165 = (os_log_s *)v182;
              unint64_t v166 = "CoreData: A binary store save failed but did not return an error: %@";
              goto LABEL_270;
            }
          }

LABEL_271:
          *(void *)(*(void *)(*(void *)(v327 + 80) + 8) + 40) = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  contexta,  134060,  objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  @"Unknown",  v340));
          goto LABEL_272;
        default:
          unint64_t v115 = *(id *)(v327 + 32);
          if (v23 == 8)
          {
            if ([*(id *)(v327 + 32) resultType] == 4)
            {
              _NSCoreDataLog( 1LL,  (uint64_t)@"NSPersistentHistoryResultTypeChangesOnly unsupported for multiple stores [%@]",  v116,  v117,  v118,  v119,  v120,  v121,  (uint64_t)obj);
              v413 = @"NSAffectedStoresErrorKey";
              v414 = obj;
              v317 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:&v414 forKeys:&v413 count:1];
              v318 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  134091LL,  (uint64_t)@"NSPersistentHistoryResultTypeChangesOnly unsupported for multiple stores",  v317);
              objc_exception_throw(v318);
              goto LABEL_502;
            }

            if ([v115 fetchBatchSize])
            {
              unint64_t v115 = (id)[v115 copy];
              [v115 setFetchBatchSize:0];
            }
          }

          *(void *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) = [MEMORY[0x189603FA8] arrayWithCapacity:v323];
          uint64_t v122 = objc_alloc_init(MEMORY[0x189603FA8]);
          __int128 v123 = objc_alloc_init(MEMORY[0x189603FA8]);
          if (v323)
          {
            __int128 v124 = 0LL;
            __int128 v125 = *MEMORY[0x189607460];
            do
            {
              __int128 v126 = objc_msgSend( (id)objc_msgSend(obj, "objectAtIndex:", v124),  "executeRequest:withContext:error:",  v115,  *(void *)(v327 + 56),  *(void *)(*(void *)(v327 + 80) + 8) + 40);
              if (v126)
              {
                [*(id *)(*(void *)(*(void *)(v327 + 64) + 8) + 40) addObject:v126];
              }

              else
              {
                __int128 v127 = *(void **)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL);
                if (v127)
                {
                  __int128 v128 = objc_msgSend(v127, "code", 0);
                  __int128 v129 = *(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL);
                  if (v128 != 134091)
                  {
                    [v123 addObject:v129];
                    break;
                  }

                  __int128 v130 = v122;
                }

                else
                {
                  __int128 v131 = (void *)MEMORY[0x189607870];
                  v412[0] = *(void *)(v327 + 32);
                  v411[0] = @"NSPersistentStoreRequest";
                  v411[1] = @"NSPersistentStore";
                  __int128 v132 = [obj objectAtIndex:v124];
                  v411[2] = @"reason";
                  v412[1] = v132;
                  v412[2] = @"Store returned nil but no error.";
                  __int128 v129 = objc_msgSend( v131,  "errorWithDomain:code:userInfo:",  v125,  134070,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", v412, v411, 3));
                  __int128 v130 = v123;
                }

                [v130 addObject:v129];
              }

              *(void *)(*(void *)(*(void *)(v327 + 80) + 8LL) + 40LL) = 0LL;
              ++v124;
            }

            while (v323 != v124);
          }

          if ([v122 count] == v323)
          {
            _NSCoreDataLog( 1LL,  (uint64_t)@"NSPersistentStoreRequest failed unsupported by all stores on this coordinator.  Request: '%@' and stores [%@]",  v133,  v134,  v135,  v136,  v137,  v138,  *(void *)(v327 + 32));
            unint64_t v139 = (void *)MEMORY[0x189607870];
            uint64_t v140 = *(void *)(v327 + 32);
            v409[0] = @"NSPersistentStoreRequest";
            v409[1] = @"NSPersistentStores";
            v410[0] = v140;
            v410[1] = obj;
            v409[2] = @"reason";
            v410[2] = @"Operation unsupported by all stores on this coordinator.";
            unint64_t v141 = [MEMORY[0x189603F68] dictionaryWithObjects:v410 forKeys:v409 count:3];
            objc_msgSend( v123,  "addObject:",  objc_msgSend(v139, "errorWithDomain:code:userInfo:", *MEMORY[0x189607460], 134091, v141));
          }

          if ([v123 count])
          {
            *(void *)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL) = 0LL;
            if (*(void *)(v327 + 104))
            {
              unint64_t v142 = (void *)MEMORY[0x189607870];
              unint64_t v143 = *(void *)(v327 + 32);
              v407[0] = @"NSPersistentStoreRequest";
              v407[1] = @"Underlying errors";
              v408[0] = v143;
              v408[1] = v123;
              v407[2] = @"reason";
              v408[2] = @"One or more stores returned an error.";
              unint64_t v144 = [MEMORY[0x189603F68] dictionaryWithObjects:v408 forKeys:v407 count:3];
              *(void *)(*(void *)(*(void *)(v327 + 80) + 8) + 40) = [v142 errorWithDomain:*MEMORY[0x189607460] code:134070 userInfo:v144];
            }

            goto LABEL_414;
          }

          if (*(void *)(v327 + 48))
          {
            uint64_t v251 = *(void **)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL);
            v252 = [*(id *)(v327 + 32) requestType];
            v253 = off_189EA5180;
            switch(v252)
            {
              case 5LL:
                goto LABEL_411;
              case 6LL:
                v253 = off_189EA5190;
                goto LABEL_411;
              case 7LL:
                v253 = off_189EA5170;
                goto LABEL_411;
              case 8LL:
                if (!v251) {
                  goto LABEL_466;
                }
                if ([v251 count] == 1) {
                  goto LABEL_405;
                }
                uint64_t v254 = -[NSPersistentHistoryResult initWithSubresults:]( objc_alloc(&OBJC_CLASS___NSPersistentHistoryResult),  "initWithSubresults:",  v251);
                goto LABEL_412;
              case 10LL:
                v253 = off_189EA55B8;
                goto LABEL_411;
              case 11LL:
                v253 = off_189EA5490;
                goto LABEL_411;
              default:
                if ([v251 count] == 1)
                {
LABEL_405:
                  uint64_t v250 = (NSPersistentHistoryResult *)[v251 lastObject];
                }

                else
                {
                  v253 = &off_189EA5628;
LABEL_411:
                  uint64_t v254 = (NSPersistentHistoryResult *)[objc_alloc(*v253) initWithSubresults:v251];
LABEL_412:
                  uint64_t v250 = v254;
                }

                break;
            }
          }

          else
          {
LABEL_466:
            uint64_t v250 = 0LL;
          }

          break;
      }

      *(void *)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL) = v250;
      goto LABEL_414;
    }
  }

  switch(*(void *)(v327 + 88))
  {
    case 1LL:
    case 3LL:
      unint64_t v108 = (NSPersistentHistoryResult *)(id)NSArray_EmptyArray;
      goto LABEL_343;
    case 2LL:
      uint64_t v235 = *(void *)(v327 + 32);
      if (!v235) {
        goto LABEL_347;
      }
      uint64_t v236 = *(void *)(v235 + 48);
      if ((_BYTE)v236)
      {
LABEL_36:
        -[NSPersistentStoreCoordinator _introspectLastErrorAndThrow](*(void **)(v327 + 48));
        goto LABEL_37;
      }

      *(void *)(v235 + 4_Block_object_dispose((const void *)(v9 - 48), 8) = v236 & 0xFFFFFF00 | 1LL;
LABEL_347:
      *(_BYTE *)(*(void *)(*(void *)(v327 + 72) + 8LL) + 24LL) = 1;
      break;
    case 5LL:
    case 6LL:
    case 7LL:
      goto LABEL_36;
    case 8LL:
      uint64_t v225 = objc_alloc(&OBJC_CLASS___NSPersistentHistoryResult);
      uint64_t v226 = [*(id *)(v327 + 32) resultType];
      unint64_t v108 = -[NSPersistentHistoryResult initWithResultType:andResult:]( v225,  "initWithResultType:andResult:",  v226,  NSArray_EmptyArray);
      goto LABEL_343;
    case 9LL:
      *(_DWORD *)buf = 0;
      uint64_t v227 = [*(id *)(v327 + 48) _exceptionNoStoreSaveFailureForError:*(void *)(*(void *)(v327 + 48) + 72) recommendedFrame:buf];
      uint64_t v228 = objc_alloc(MEMORY[0x189607870]);
      v420 = @"reason";
      v421 = v227;
      uint64_t v229 = [MEMORY[0x189603F68] dictionaryWithObjects:&v421 forKeys:&v420 count:1];
      *(void *)(*(void *)(*(void *)(v327 + 80) + 8) + 40) = [v228 initWithDomain:*MEMORY[0x189607460] code:134098 userInfo:v229];
      *(void *)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL) = 0LL;
      return;
    case 0xALL:
      uint64_t v234 = objc_alloc(&OBJC_CLASS___NSSQLiteIndexStatisticsResult);
      unint64_t v108 = -[NSSQLiteIndexStatisticsResult initWithResult:](v234, "initWithResult:", NSArray_EmptyArray);
      goto LABEL_343;
    case 0xBLL:
      uint64_t v233 = objc_alloc(&OBJC_CLASS___NSPersistentCloudKitContainerEventResult);
      unint64_t v108 = -[NSPersistentCloudKitContainerEventResult initWithResult:ofType:]( v233,  "initWithResult:ofType:",  NSArray_EmptyArray,  [*(id *)(v327 + 32) resultType]);
LABEL_343:
      *(void *)(*(void *)(*(void *)(v327 + 64) + 8LL) + 40LL) = v108;
      return;
    default:
      uint64_t v230 = *(void **)(v327 + 48);
      if (!v230) {
        goto LABEL_37;
      }
      uint64_t v231 = (void *)MEMORY[0x189603F70];
      uint64_t v232 = [v230 _exceptionNoStoreSaveFailureForError:v230[9] recommendedFrame:0];
      objc_exception_throw((id)[v231 exceptionWithName:*MEMORY[0x189603A58] reason:v232 userInfo:0]);
      goto LABEL_502;
  }

void sub_1867990D4(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186799068LL);
  }

  JUMPOUT(0x1867990F0LL);
}

void sub_18679A31C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

void sub_18679A598( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_18679B0DC(_Unwind_Exception *a1)
{
}

void sub_18679B10C(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x18679B014LL);
  }

  JUMPOUT(0x18679B104LL);
}

void sub_18679B3DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_18679B578(_Unwind_Exception *a1)
{
}

void sub_18679B78C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_18679B814(_Unwind_Exception *a1)
{
}

void sub_18679B830()
{
}

void sub_18679BF10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
}

void sub_18679C4C0(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x18679C344LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_18679D080(_Unwind_Exception *a1)
{
}

void sub_18679D0BC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18679D088LL);
  }
  objc_terminate();
  -[NSPersistentStoreCoordinator _copyMetadataFromStore:toStore:migrationManager:](v2, v3, v4, v5);
}

void sub_18679D4E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

void sub_18679D820(void *a1)
{
}

void sub_18679DA30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_18679DBE4(_Unwind_Exception *a1)
{
}

void sub_18679DC04()
{
}

void sub_18679DED8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_18679E078(_Unwind_Exception *a1)
{
}

void sub_18679E094()
{
}

void sub_18679E1DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_18679E444( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_18679E7B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_18679EB1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_18679EED0(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18679EEA0LL);
  }

  JUMPOUT(0x18679EE80LL);
}

void sub_1867A2F98()
{
}

void sub_1867A3668()
{
}

void sub_1867A3FA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
}

void sub_1867A47B8(_Unwind_Exception *exception_object)
{
}

void sub_1867A47FC(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1867A46E8LL);
  }

  JUMPOUT(0x1867A47DCLL);
}

void sub_1867A51A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47)
{
}

void __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
}

void sub_1867A56D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void sub_1867A602C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1867A6848( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_1867A746C(_Unwind_Exception *a1)
{
}

void sub_1867A749C(void *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x1867A7328LL);
  }

  JUMPOUT(0x1867A748CLL);
}

void sub_1867A79E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location, uint64_t a22, char a23)
{
}

void sub_1867A866C(_Unwind_Exception *a1)
{
}

void sub_1867A86A4(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1867A84FCLL);
  }

  JUMPOUT(0x1867A868CLL);
}

void sub_1867A8E4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
}

void sub_1867A938C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

void sub_1867A9A7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41)
{
}

void sub_1867A9E38(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    if (a2 == 2)
    {
      *(void *)(*(void *)(*(void *)(v2 + 56) + 8LL) + 40LL) = objc_begin_catch(exc_buf);
      objc_end_catch();
    }

    else
    {
      objc_begin_catch(exc_buf);
    }

    JUMPOUT(0x1867A9DDCLL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1867AA86C(_Unwind_Exception *a1)
{
}

void sub_1867AC020( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1867ACC5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, void (*a26)(char *))
{
}

void sub_1867AD1FC(_Unwind_Exception *a1)
{
}

uint64_t _readPropertyIntoShellFromBytes( uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t a17, unint64_t *a18)
{
  uint64_t v18 = a3;
  uint64_t v19 = a2;
  unint64_t v20 = a18;
  uint64_t v157 = *MEMORY[0x1895F89C0];
  unint64_t v21 = *a3;
  unint64_t v22 = (*a3 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v23 = v22 + 4;
  if (v22 + 4 <= a4)
  {
    unsigned int v24 = bswap32(*(_DWORD *)(a2 + v22));
    unint64_t v21 = v23;
  }

  else
  {
    unsigned int v24 = 0;
  }

  unint64_t v25 = v21 + v24;
  if (v25 > a4)
  {
    if (a18)
    {
      uint64_t v26 = (void *)MEMORY[0x189607870];
      uint64_t v27 = *MEMORY[0x189607460];
      uint64_t v28 = (void *)MEMORY[0x189603F68];
      uint64_t v29 = @"Can't read property into shell: Not enough bytes left";
LABEL_32:
      uint64_t v51 = objc_msgSend( v26,  "errorWithDomain:code:userInfo:",  v27,  134060,  objc_msgSend(v28, "dictionaryWithObject:forKey:", v29, @"Root cause"));
      a11 = 0LL;
      *unint64_t v20 = v51;
      return a11;
    }

    return 0LL;
  }

  unint64_t v30 = v25 - 4;
  unint64_t v31 = (v21 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v32 = v31 + 4;
  if (v31 + 4 > v30)
  {
LABEL_8:
    if (a18)
    {
      uint64_t v26 = (void *)MEMORY[0x189607870];
      uint64_t v27 = *MEMORY[0x189607460];
      uint64_t v28 = (void *)MEMORY[0x189603F68];
      uint64_t v29 = @"Can't read property into shell: Unknown type";
      goto LABEL_32;
    }

    return 0LL;
  }

  unsigned int v33 = *(_DWORD *)(a2 + v31);
  unsigned int v34 = bswap32(v33);
  unsigned int v35 = v34 - 2;
  int v37 = 1;
  switch(v34)
  {
    case 2u:
      int v37 = 0;
      a11 = a8;
      break;
    case 3u:
      int v37 = 0;
      a11 = a13;
      break;
    case 4u:
      break;
    case 5u:
      int v37 = 0;
      a11 = a12;
      break;
    case 6u:
      int v37 = 0;
      a11 = a9;
      break;
    case 7u:
      int v37 = 0;
      a11 = a10;
      break;
    default:
      goto LABEL_8;
  }

  unint64_t v38 = (v31 + 7) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v39 = v38 + 4;
  if (v38 + 4 <= v30)
  {
    unsigned int v41 = bswap32(*(_DWORD *)(a2 + v38));
    unint64_t v155 = v38 + 4;
    *(_DWORD *)(a11 + 72) = v41;
    if (a17 <= 4 && (v41 & 0x100) != 0) {
      return 0LL;
    }
    uint64_t v147 = a7;
    uint64_t v149 = a1;
    unint64_t v38 = (v38 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v40 = v38 + 4;
  }

  else
  {
    uint64_t v147 = a7;
    uint64_t v149 = a1;
    *(_DWORD *)(a11 + 72) = 0;
    unint64_t v40 = v38 + 4;
    unint64_t v39 = v32;
  }

  uint64_t v42 = a15;
  if (v40 <= v30)
  {
    unsigned int v43 = *(_DWORD *)(a2 + v38);
    if (v43)
    {
      unint64_t v44 = v30;
      uint64_t v46 = a5;
      id v47 = *(id *)(a15 + 8LL * bswap32(v43));
      uint64_t v42 = a15;
      a5 = v46;
      uint64_t v18 = a3;
      unint64_t v30 = v44;
      unint64_t v20 = a18;
      uint64_t v19 = a2;
      *(void *)(a11 + _Block_object_dispose((const void *)(v13 - 80), 8) = v47;
    }

    unint64_t v39 = v40;
  }

  unint64_t v48 = (v39 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v49 = v48 + 4;
  if (v48 + 4 <= v30)
  {
    unsigned int v50 = bswap32(*(_DWORD *)(v19 + v48));
    unint64_t v39 = v49;
  }

  else
  {
    unsigned int v50 = 0;
  }

  if (v33 != 83886080 && !v50)
  {
    if (v20)
    {
      uint64_t v26 = (void *)MEMORY[0x189607870];
      uint64_t v27 = *MEMORY[0x189607460];
      uint64_t v28 = (void *)MEMORY[0x189603F68];
      uint64_t v29 = @"Can't read property into shell: Missing version hash value";
      goto LABEL_32;
    }

    return 0LL;
  }

  uint64_t v145 = v42;
  uint64_t v148 = a5;
  *(void *)(a11 + 16) = *(id *)(a16 + 8LL * v50);
  unint64_t v58 = (v39 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v59 = v58 + 4;
  if (v58 + 4 <= v30)
  {
    unsigned int v62 = *(_DWORD *)(v19 + v58);
    uint64_t v61 = v148;
    if (v62 == -1) {
      goto LABEL_38;
    }
    unsigned int v60 = bswap32(v62);
  }

  else
  {
    unsigned int v60 = 0;
    unint64_t v59 = v39;
    uint64_t v61 = v148;
  }

  *(void *)(a11 + 24) = *(void *)(v61 + 8LL * v60);
LABEL_38:
  unint64_t v63 = (v59 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v64 = v63 + 4;
  if (v63 + 4 > v30)
  {
LABEL_72:
    _NSCoreDataLog( 1LL,  (uint64_t)@"Corrupted archive (missing property name).",  v52,  v53,  v54,  v55,  v56,  v57,  v137);
    a11 = 0LL;
    *uint64_t v18 = v59;
    return a11;
  }

  unsigned int v65 = *(_DWORD *)(v19 + v63);
  unint64_t v155 = v63 + 4;
  if (!v65)
  {
    unint64_t v59 = v63 + 4;
    goto LABEL_72;
  }

  *(void *)(a11 + 32) = *(id *)(a14 + 8LL * bswap32(v65));
  unint64_t v66 = (v63 + 7) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v67 = v66 + 4;
  uint64_t v68 = v149;
  if (v66 + 4 <= v30)
  {
    int v69 = *(_DWORD *)(v19 + v66);
    unint64_t v155 = v67;
    unint64_t v64 = v67;
    if (v69)
    {
      int v141 = v37;
      uint64_t v70 = (void *)_newReadPFEncodedArrayFromData(v149, v19, &v155, v30, a16, 0LL);
      if (!v70)
      {
        if (v20)
        {
          uint64_t v26 = (void *)MEMORY[0x189607870];
          uint64_t v27 = *MEMORY[0x189607460];
          uint64_t v28 = (void *)MEMORY[0x189603F68];
          uint64_t v29 = @"Can't read property into shell: Can't read validation predicates";
          goto LABEL_32;
        }

        return 0LL;
      }

      unint64_t v71 = v70;
      unsigned int v143 = v35;
      uint64_t v144 = [v70 count];
      if (v144)
      {
        uint64_t v72 = 0LL;
        while (1)
        {
          uint64_t v73 = [v71 objectAtIndex:v72];
          unint64_t v154 = 0LL;
          uint64_t v74 = [MEMORY[0x189604010] setWithObject:objc_opt_class()];
          uint64_t v75 = +[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)&OBJC_CLASS____PFRoutines,  v74,  v73,  (uint64_t)&v154);
          if (!v75) {
            break;
          }
          __int128 v76 = (void *)v75;
          if (!byte_18C4ABDC6)
          {
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0) {
              [v76 allowEvaluation];
            }
          }

          [v71 _replaceObject:v76 atIndex:v72++];
          if (v144 == v72) {
            goto LABEL_50;
          }
        }

        uint64_t v139 = [(id)a11 name];
        _NSCoreDataLog( 1LL,  (uint64_t)@"Unable to decode validation predicate for property %@ : %@",  v121,  v122,  v123,  v124,  v125,  v126,  v139);
        goto LABEL_116;
      }

void sub_1867AFCBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
}

void sub_1867B006C(_Unwind_Exception *a1)
{
}

void sub_1867B0088()
{
}

LABEL_158:
            unint64_t v89 = 0;
            unint64_t v90 = 0LL;
            uint64_t v85 = 0LL;
            goto LABEL_112;
          }

  if (v71 && v74) {
    *unint64_t v71 = v74;
  }
  return v9;
}

LABEL_136:
            unint64_t v89 = 0;
            unint64_t v90 = 0LL;
            goto LABEL_112;
          }

            uint64_t v15 = 0LL;
LABEL_137:
            uint64_t v74 = v124;
            goto LABEL_138;
          }

          uint64_t v29 = objc_msgSend(v24[5], "objectForKey:", objc_msgSend(v21, "name"));
          unint64_t v30 = [v21 destinationEntity];
          uint64_t v130 = (void *)_sqlCoreLookupSQLEntityForEntityDescription(*(void **)(a1 + 8), (void *)v30);
          if (!v130
            || ((unint64_t v31 = [v130 model],
                 unint64_t v32 = [*(id *)(v131 + 8) model],
                 unsigned int v33 = [(id)v30 managedObjectModel],
                 unsigned int v34 = [*(id *)(v131 + 8) configurationName],
                 !v33)
             || (objc_msgSend( (id)objc_msgSend(*(id *)(*(void *)(v33 + 24) + 24), "objectForKey:", v34),  "containsObject:",  objc_msgSend((id)v30, "name")) & 1) == 0)
            && v31 == v32)
          {
            BOOL v93 = v127;
            if (!v127) {
              goto LABEL_136;
            }
            uint64_t v94 = (void *)MEMORY[0x189607870];
            unint64_t v95 = *MEMORY[0x189607460];
            v148[0] = @"Reason";
            v149[0] = [NSString stringWithFormat:@"Entity named:%@ not found for relationship named:%@", objc_msgSend((id)v30, "name"), objc_msgSend(v21, "name")];
            v148[1] = @"MissingEntity";
            v149[1] = [NSString stringWithFormat:@"%@.%@", objc_msgSend((id)v30, "name"), v30];
            v148[2] = @"Relationship";
            v149[2] = [NSString stringWithFormat:@"Name: %@ Destination Entity:%@", objc_msgSend(v21, "name"), objc_msgSend((id)objc_msgSend(v21, "entity"), "name")];
            unint64_t v96 = (void *)MEMORY[0x189603F68];
            int v97 = v149;
            uint64_t v98 = (__int128 *)v148;
LABEL_134:
            uint64_t v99 = [v96 dictionaryWithObjects:v97 forKeys:v98 count:3];
            unint64_t v100 = v94;
            unint64_t v101 = v95;
LABEL_135:
            *BOOL v93 = [v100 errorWithDomain:v101 code:134060 userInfo:v99];
            goto LABEL_136;
          }

          unsigned int v35 = (void *)[v21 inverseRelationship];
          if (v29) {
            uint64_t v36 = *(void *)(v29 + 56);
          }
          else {
            uint64_t v36 = 0LL;
          }
          uint64_t v17 = v129;
          if (v35) {
            int v37 = [v35 isOptional] ^ 1;
          }
          else {
            int v37 = 0;
          }
          unint64_t v38 = [v21 deleteRule];
          unint64_t v39 = v38;
          if (v38 == 2)
          {
            if (v29 && *(_BYTE *)(v29 + 24) == 7)
            {
              unint64_t v40 = [objc_alloc(NSString) initWithFormat:@"DELETE FROM %@ WHERE Z_PK = OLD.%@", objc_msgSend(v130, "tableName"), objc_msgSend((id)v29, "columnName"), 0];
              goto LABEL_50;
            }

            if (v36 && *(_BYTE *)(v36 + 24) == 7)
            {
              uint64_t v42 = objc_alloc(NSString);
              unsigned int v43 = [v130 tableName];
              __int16 v113 = [(id)v36 columnName];
              unint64_t v112 = v43;
              unint64_t v44 = v42;
LABEL_49:
              unint64_t v40 = [v44 initWithFormat:@"DELETE FROM %@ WHERE %@ = OLD.Z_PK", v112, v113, 0];
LABEL_50:
              id v47 = (void *)v40;
              if (v30) {
                goto LABEL_51;
              }
LABEL_70:
              unsigned int v50 = 0LL;
LABEL_56:
              unint64_t v49 = v131;
            }

            else
            {
              if (v29 && *(_BYTE *)(v29 + 24) == 9)
              {
                if (!-[NSSQLiteAdapter generateCorrelationTableTriggerStatementsForRelationship:existing:correlationTableTriggers:error:]( v131,  v21,  a4,  v127)) {
                  goto LABEL_136;
                }
                __int128 v45 = objc_alloc(NSString);
                uint64_t v46 = [(id)v29 correlationTableName];
                __int16 v113 = [(id)v29 columnName];
                unint64_t v112 = v46;
                unint64_t v44 = v45;
                goto LABEL_49;
              }

              id v47 = 0LL;
              if (!v30) {
                goto LABEL_70;
              }
LABEL_51:
              if ((*(_BYTE *)(v30 + 120) & 4) != 0)
              {
                unsigned int v50 = *(const void **)(v30 + 72);
                goto LABEL_56;
              }

              unint64_t v48 = (void *)v30;
              unint64_t v49 = v131;
              do
              {
                unsigned int v50 = v48;
                unint64_t v48 = (void *)[v48 superentity];
              }

              while (v48);
            }

            if (!CFDictionaryContainsKey(theDict, v50)
              && (-[NSSQLiteAdapter generateTriggerForEntity:alreadyCreated:correlations:batchHistory:fragments:error:]( v49,  v30,  theDict,  a4,  v126,  0LL,  v127) & 1) == 0)
            {

              goto LABEL_136;
            }

            goto LABEL_153;
          }
        }

        uint64_t v83 = *(void *)(v50 + 24);
        if (v83) {
          id v84 = *(void **)(v83 + 72);
        }
        else {
          id v84 = 0LL;
        }
        uint64_t v85 = objc_msgSend(v84, "entityNamed:", objc_msgSend(v60, "name"));
        if ([v351 containsString:@"ZENTITYNAME"]) {
          -[PFCloudKitMetadataModelMigrator addMigrationStatementToContext:forRenamingAttributeNamed:withOldColumnName:toAttributeName:onOldSQLEntity:andCurrentSQLEntity:]( *(void *)(v50 + 24),  (uint64_t)@"entityName",  (uint64_t)@"ZENTITYNAME",  (uint64_t)@"cdEntityName",  v85,  v60);
        }
        if ([v351 containsString:@"ZISDELETED"]) {
          -[PFCloudKitMetadataModelMigrator addMigrationStatementToContext:forRenamingAttributeNamed:withOldColumnName:toAttributeName:onOldSQLEntity:andCurrentSQLEntity:]( *(void *)(v50 + 24),  (uint64_t)@"isDeleted",  (uint64_t)@"ZISDELETED",  (uint64_t)@"needsDelete",  v85,  v60);
        }
        uint64_t v86 = (void *)[v60 name];
        uint64_t v87 = (objc_class *)objc_opt_class();
        if (![v86 isEqualToString:NSStringFromClass(v87)])
        {
          int v97 = (void *)[v60 name];
          uint64_t v98 = (objc_class *)objc_opt_class();
          v391 = 0u;
          v392 = 0u;
          v389 = 0u;
          v390 = 0u;
          uint64_t v99 = [&unk_189F0B3B8 countByEnumeratingWithState:&v389 objects:&v425 count:16];
          if (!v99) {
            goto LABEL_153;
          }
          unint64_t v100 = *(void *)v390;
          while (2)
          {
            unint64_t v101 = 0LL;
LABEL_100:
            if (*(void *)v390 != v100) {
              objc_enumerationMutation(&unk_189F0B3B8);
            }
            unint64_t v102 = *(void **)(*((void *)&v389 + 1) + 8 * v101);
            if (v60) {
              unint64_t v103 = (_BYTE *)[v60[5] objectForKey:*(void *)(*((void *)&v389 + 1) + 8 * v101)];
            }
            else {
              unint64_t v103 = 0LL;
            }
            if (objc_msgSend(v351, "containsString:", objc_msgSend(v103, "columnName")))
            {
              unint64_t v104 = (void *)MEMORY[0x186E3E5D8]();
              else {
                unint64_t v105 = __ckLoggingOverride;
              }
              unint64_t v106 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"Skipping migration for '%@' because it already has a column named '%@'"];
              [v60 tableName];
              [v103 columnName];
              _NSCoreDataLog( v105,  v106,  v107,  v108,  v109,  v110,  v111,  v112,  (uint64_t)"-[PFCloudKitMetadataModelMigrator calculateMigrationStepsWithConnection:error:]");
              objc_autoreleasePoolPop(v104);
LABEL_114:
              if (v99 == ++v101)
              {
                uint64_t v121 = [&unk_189F0B3B8 countByEnumeratingWithState:&v389 objects:&v425 count:16];
                uint64_t v99 = v121;
                if (!v121) {
                  goto LABEL_153;
                }
                continue;
              }

              goto LABEL_100;
            }

            break;
          }

          -[PFCloudKitMetadataModelMigrator addMigrationStatementForAddingAttribute:toContext:inStore:]( v103,  *(void *)(v50 + 24),  *(void **)(v50 + 8));
          if (([v102 isEqualToString:@"recordZoneName"] & 1) != 0
            || [v102 isEqualToString:@"relatedRecordZoneName"])
          {
            __int16 v113 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
            char v114 = -[NSSQLiteStatement initWithEntity:sqlString:]( v113,  "initWithEntity:sqlString:",  v60,  [NSString stringWithFormat:@"UPDATE %@ SET %@ = '%@'", objc_msgSend(v60, "tableName"), objc_msgSend(v103, "columnName"), @"com.apple.coredata.cloudkit.zone"]);
            uint64_t v115 = *(void *)(v50 + 24);
            if (v115)
            {
              [*(id *)(v115 + 8) addObject:v114];
              *(_BYTE *)(v115 + 32) = 1;
            }
          }

          else
          {
            if (([v102 isEqualToString:@"recordZoneOwnerName"] & 1) == 0
              && ![v102 isEqualToString:@"relatedRecordZoneOwnerName"])
            {
              goto LABEL_114;
            }

            uint64_t v116 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
            uint64_t v117 = (void *)NSString;
            uint64_t v118 = [v60 tableName];
            uint64_t v119 = [v103 columnName];
            char v114 = -[NSSQLiteStatement initWithEntity:sqlString:]( v116,  "initWithEntity:sqlString:",  v60,  [v117 stringWithFormat:@"UPDATE %@ SET %@ = '%@'", v118, v119, getCloudKitCKCurrentUserDefaultName()]);
            uint64_t v120 = *(void *)(v50 + 24);
            if (v120)
            {
              [*(id *)(v120 + 8) addObject:v114];
              *(_BYTE *)(v120 + 32) = 1;
            }
          }

          goto LABEL_114;
        }

        if (v60) {
          uint64_t v88 = (void *)[v60[5] objectForKey:@"recordZone"];
        }
        else {
          uint64_t v88 = 0LL;
        }
        if ((objc_msgSend(v351, "containsString:", objc_msgSend(v88, "columnName")) & 1) == 0)
        {
          unint64_t v89 = (void *)[objc_alloc(NSString) initWithFormat:@"ALTER TABLE %@ ADD COLUMN %@ INTEGER", objc_msgSend(v60, "tableName"), objc_msgSend(v88, "columnName")];
          unint64_t v90 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  v60,  v89);
          int v91 = *(void *)(v50 + 24);
          if (v91)
          {
            [*(id *)(v91 + 8) addObject:v90];
            *(_BYTE *)(v91 + 32) = 1;
            unint64_t v92 = *(void *)(v50 + 24);
            if (v92) {
              *(_BYTE *)(v92 + 35) = 1;
            }
          }

          BOOL v93 = *(uint64_t **)(v50 + 16);
          uint64_t v94 = *(uint64_t **)(v50 + 24);
          unint64_t v95 = v402;
          *(void *)&buf = 0LL;
          *((void *)&buf + 1) = &buf;
          v438 = 0x2020000000LL;
          v439 = 1;
          *(void *)&v411 = 0LL;
          *((void *)&v411 + 1) = &v411;
          *(void *)&v412 = 0x3052000000LL;
          *((void *)&v412 + 1) = __Block_byref_object_copy__48;
          *(void *)&v413 = __Block_byref_object_dispose__48;
          *((void *)&v413 + 1) = 0LL;
          *(void *)v446 = MEMORY[0x1895F87A8];
          *(void *)&v446[8] = 3221225472LL;
          *(void *)&v446[16] = __149__PFCloudKitMetadataModelMigrator_addMigrationStatementsToDeleteDuplicateMirroredRelationshipsToContext_withManagedObjectContext_andSQLEntity_error___block_invoke;
          v447 = &unk_189EABBD0;
          v448 = v93;
          v449 = v60;
          v451 = &v411;
          v450 = v94;
          p_buf = &buf;
          [v93 performBlockAndWait:v446];
          if (!*(_BYTE *)(*((void *)&buf + 1) + 24LL))
          {
            unint64_t v96 = *(id *)(*((void *)&v411 + 1) + 40LL);
            if (v96)
            {
              v95[5] = (uint64_t)v96;
            }

            else
            {
              uint64_t v132 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
              _NSCoreDataLog( 17LL,  v132,  v133,  v134,  v135,  v136,  v137,  v138,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitMetadataModelMigrator.m");
              uint64_t v139 = (os_log_s *)__pflogFaultLog;
              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)v433 = 136315394;
                v434 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitMetadataModelMigrator.m";
                v435 = 1024;
                v436 = 1695;
                _os_log_fault_impl( &dword_186681000,  v139,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v433,  0x12u);
              }
            }
          }

          *(void *)(*((void *)&v411 + 1) + 40LL) = 0LL;
          uint64_t v140 = *(unsigned __int8 *)(*((void *)&buf + 1) + 24LL);
          _Block_object_dispose(&v411, 8);
          _Block_object_dispose(&buf, 8);
          if (!v140)
          {
            *((_BYTE *)v408 + 24) = 0;
            unint64_t v146 = (id)v402[5];
            goto LABEL_153;
          }

          int v141 = [v347 adapter];
          if (v141) {
            uint64_t v126 = -[NSSQLiteAdapter newCreateIndexStatementsForEntity:defaultIndicesOnly:](v141, (uint64_t)v60, 0);
          }
          else {
            uint64_t v126 = 0LL;
          }
          v395 = 0u;
          v396 = 0u;
          v393 = 0u;
          v394 = 0u;
          int v142 = [v126 countByEnumeratingWithState:&v393 objects:&v429 count:16];
          if (v142)
          {
            unsigned int v143 = *(void *)v394;
            do
            {
              for (uint64_t k = 0LL; k != v142; ++k)
              {
                if (*(void *)v394 != v143) {
                  objc_enumerationMutation(v126);
                }
                uint64_t v145 = *(void *)(v50 + 24);
                if (v145)
                {
                  [*(id *)(v145 + 8) addObject:*(void *)(*((void *)&v393 + 1) + 8 * k)];
                  *(_BYTE *)(v145 + 32) = 1;
                }
              }

              int v142 = [v126 countByEnumeratingWithState:&v393 objects:&v429 count:16];
            }

            while (v142);
          }

          goto LABEL_136;
        }

LABEL_112:
          if (Mutable) {
            CFRelease(Mutable);
          }
          if (v82) {
            CFRelease(v82);
          }
          if (v85) {
            CFRelease(v85);
          }

          [v113 drain];
          if (!v89) {
            goto LABEL_27;
          }
          goto LABEL_79;
        }

        if ([v15 isEqualToString:v14])
        {
          if (*(void *)(v1 + 24)) {
            goto LABEL_30;
          }
          goto LABEL_24;
        }
      }

void sub_1867B30E4(_Unwind_Exception *a1)
{
}

__darwin_time_t stat_path_for_modication_time(void *a1)
{
  if ((objc_msgSend(a1, "isFileURL", 0, 0, 0, 0, 0, 0) & 1) == 0)
  {
    v7.st_mtimespec.tv_sec = 0LL;
    v7.st_mtimespec.tv_nsec = 0LL;
LABEL_7:
    v6.st_mtimespec = 0uLL;
    goto LABEL_8;
  }

  uint64_t v2 = (void *)[a1 path];
  int v3 = (void *)[v2 stringByAppendingString:@"-wal"];
  LODWORD(v2) = stat((const char *)[v2 fileSystemRepresentation], &v7);
  int v4 = stat((const char *)[v3 fileSystemRepresentation], &v6);
  if ((_DWORD)v2)
  {
    v7.st_mtimespec.tv_sec = 0LL;
    v7.st_mtimespec.tv_nsec = 0LL;
  }

  if (v4) {
    goto LABEL_7;
  }
LABEL_8:
  if (v7.st_mtimespec.tv_sec <= v6.st_mtimespec.tv_sec) {
    return v6.st_mtimespec.tv_sec;
  }
  else {
    return v7.st_mtimespec.tv_sec;
  }
}

BOOL _objectIDEntityAffectsResults(uint64_t a1, void *a2)
{
  int v4 = (void *)[*(id *)(a1 + 8) entity];
  int v5 = *(_DWORD *)(a1 + 72);
  stat v6 = (void *)[*(id *)(a1 + 8) affectedStores];
  BOOL result = 0;
  if (!v6 || objc_msgSend(v6, "indexOfObjectIdenticalTo:", objc_msgSend(a2, "persistentStore")) != 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v7 = [a2 entity];
  }

  return result;
}

#error "1867B63B4: call analysis failed (funcsize=93)"
uint64_t __82__NSFetchedResultsController_PrivateMethods___core_managedObjectContextDidChange___block_invoke_2( uint64_t a1,  void *a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  BOOL v6;
  uint64_t v2 = a2[2];
  if ((unint64_t)(v2 - 3) >= 2)
  {
    stat v6 = v2 == 1;
    int v5 = a2 + 6;
    int v3 = (void *)(a1 + 32);
    if (!v6) {
      int v5 = a2 + 5;
    }
    return *v5 == *v3;
  }

  int v4 = *(void *)(a1 + 32);
  int v3 = (void *)(a1 + 32);
  if (a2[5] != v4)
  {
    int v5 = a2 + 6;
    return *v5 == *v3;
  }

  return 1LL;
}

void sub_1867B89AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
}

uint64_t _readRelationshipIntoShellFromBytes( uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4, void *a5, uint64_t a6)
{
  unint64_t v10 = (*a3 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v11 = v10 + 4;
  if (v10 + 4 <= a4)
  {
    uint64_t v12 = bswap32(*(_DWORD *)(a2 + v10));
    unint64_t v10 = (v10 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v13 = v10 + 4;
  }

  else
  {
    uint64_t v12 = 0LL;
    unint64_t v13 = v10 + 4;
    unint64_t v11 = *a3;
  }

  a5[12] = *(void *)(a6 + 8 * v12);
  if (v13 <= a4)
  {
    if (*(_DWORD *)(a2 + v10))
    {
      unint64_t v14 = (v10 + 7) & 0xFFFFFFFFFFFFFFFCLL;
      if (v14 + 4 <= a4)
      {
        uint64_t v15 = bswap32(*(_DWORD *)(a2 + v14));
        unint64_t v13 = v14 + 4;
      }

      else
      {
        uint64_t v15 = 0LL;
      }

      a5[14] = (id)[MEMORY[0x189607968] numberWithUnsignedInteger:v15];
    }

    unint64_t v11 = v13;
  }

  unint64_t v16 = (v11 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v17 = v16 + 4;
  if (v16 + 4 <= a4)
  {
    uint64_t v18 = bswap32(*(_DWORD *)(a2 + v16));
    unint64_t v16 = (v16 + 7) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v19 = v16 + 4;
    unint64_t v11 = v17;
  }

  else
  {
    uint64_t v18 = 0LL;
    unint64_t v19 = v16 + 4;
  }

  a5[16] = v18;
  if (v19 <= a4)
  {
    uint64_t v20 = bswap32(*(_DWORD *)(a2 + v16));
    unint64_t v16 = (v19 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    unint64_t v21 = v16 + 4;
    unint64_t v11 = v19;
  }

  else
  {
    uint64_t v20 = 0LL;
    unint64_t v21 = v19;
  }

  a5[17] = v20;
  if (v21 <= a4)
  {
    uint64_t v22 = bswap32(*(_DWORD *)(a2 + v16));
    unint64_t v11 = v21;
  }

  else
  {
    uint64_t v22 = 0LL;
  }

  a5[18] = v22;
  *a3 = v11;
  return 1LL;
}

void sub_1867BADA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_1867BB9A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void __Block_byref_object_copy__21(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__21(uint64_t a1)
{
}

void sub_1867BC6DC(_Unwind_Exception *a1)
{
}

void sub_1867BD2D4(_Unwind_Exception *a1)
{
}

void sub_1867BDA58(_Unwind_Exception *a1)
{
}

void sub_1867BF458(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867BF428LL);
  }

  JUMPOUT(0x1867BF3E4LL);
}

const void *_sqlCoreLookupSQLEntityForEntityID(void *a1, unint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  int v4 = _sqlEntityForEntityID([a1 model], a2);
  if (!v4)
  {
    id v5 = (id)[a1 ancillarySQLModels];
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    uint64_t v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)v13;
      while (2)
      {
        for (uint64_t i = 0LL; i != v7; ++i)
        {
          if (*(void *)v13 != v8) {
            objc_enumerationMutation(v5);
          }
          unint64_t v10 = _sqlEntityForEntityID([v5 objectForKey:*(void *)(*((void *)&v12 + 1) + 8 * i)], a2);
          if (v10)
          {
            int v4 = v10;
            goto LABEL_12;
          }
        }

        uint64_t v7 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v7) {
          continue;
        }
        break;
      }
    }

    int v4 = 0LL;
LABEL_12:
  }

  return v4;
}

LABEL_61:
    unint64_t v112 = 0u;
    __int16 v113 = 0u;
    unint64_t v110 = 0u;
    unint64_t v111 = 0u;
    unsigned int v35 = val->_model;
    if (v35) {
      uint64_t v36 = v35->_entities;
    }
    else {
      uint64_t v36 = 0LL;
    }
    int v37 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v36,  "countByEnumeratingWithState:objects:count:",  &v110,  v128,  16LL);
    if (v37)
    {
      unint64_t v38 = *(void *)v111;
      while (2)
      {
        for (uint64_t j = 0LL; j != v37; ++j)
        {
          if (*(void *)v111 != v38) {
            objc_enumerationMutation(v36);
          }
          unint64_t v40 = *(void *)(*((void *)&v110 + 1) + 8 * j);
          if (v40 && (*(_BYTE *)(v40 + 280) & 1) != 0)
          {
            *(_DWORD *)&val->_sqlCoreFlags |= 2u;
            goto LABEL_74;
          }
        }

        int v37 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v36,  "countByEnumeratingWithState:objects:count:",  &v110,  v128,  16LL);
        if (v37) {
          continue;
        }
        break;
      }
    }

    uint64_t v46 = a3;
    __int128 v45 = a4;
    goto LABEL_62;
  }

  if (v9 != 2100) {
    goto LABEL_49;
  }
  __int128 v14 = (void *)[a5 elements];
  unint64_t v58 = 0u;
  unint64_t v59 = 0u;
  unsigned int v60 = 0u;
  uint64_t v61 = 0u;
  __int128 v15 = [v14 countByEnumeratingWithState:&v58 objects:v62 count:16];
  if (v15)
  {
    unint64_t v16 = v15;
    uint64_t v17 = *(void *)v59;
    do
    {
      for (uint64_t i = 0LL; i != v16; ++i)
      {
        if (*(void *)v59 != v17) {
          objc_enumerationMutation(v14);
        }
        unint64_t v19 = *(void **)(*((void *)&v58 + 1) + 8 * i);
        uint64_t v20 = objc_msgSend(a3, "valueForKey:", objc_msgSend(v19, "name"));
        unint64_t v21 = objc_msgSend(a4, "valueForKey:", objc_msgSend(v19, "name"));
        if (v20) {
          uint64_t v22 = v21 == 0;
        }
        else {
          uint64_t v22 = 1;
        }
        if (v22)
        {
          if (v20 | v21) {
            goto LABEL_52;
          }
        }

        else if (!-[PFCloudKitStoreComparer isValue:equalToValue:forAttribute:]( self,  "isValue:equalToValue:forAttribute:",  v20,  v21,  v19))
        {
          goto LABEL_52;
        }
      }

      unint64_t v16 = [v14 countByEnumeratingWithState:&v58 objects:v62 count:16];
      LOBYTE(v13) = 1;
    }

    while (v16);
  }

  else
  {
    LOBYTE(v13) = 1;
  }

  return v13;
}

LABEL_86:
    -[NSSQLCore setAncillaryModels:](val, "setAncillaryModels:", v92);
    -[NSSQLCore setAncillarySQLModels:](val, "setAncillarySQLModels:", v91);
    if (v93) {
      -[NSSQLCore _setupHistoryModelForPSC:withExcludedEntityNames:]((uint64_t)val, (uint64_t)v93, v90);
    }
    if (-[NSDictionary count](val->_ancillaryModels, "count"))
    {
      *(_DWORD *)&val->_sqlCoreFlags |= 0x800u;
      uint64_t v108 = 0u;
      uint64_t v109 = 0u;
      unint64_t v106 = 0u;
      unsigned int v107 = 0u;
      unint64_t v49 = -[NSDictionary allValues](val->_ancillarySQLModels, "allValues");
      unsigned int v50 = -[NSArray countByEnumeratingWithState:objects:count:]( v49,  "countByEnumeratingWithState:objects:count:",  &v106,  v127,  16LL);
      if (v50)
      {
        uint64_t v51 = *(void *)v107;
        do
        {
          uint64_t v52 = 0LL;
          do
          {
            if (*(void *)v107 != v51) {
              objc_enumerationMutation(v49);
            }
            uint64_t v53 = *(void *)(*((void *)&v106 + 1) + 8 * v52);
            if ((*((_BYTE *)&val->_sqlCoreFlags + 1) & 0x20) == 0)
            {
              unint64_t v104 = 0u;
              unint64_t v105 = 0u;
              unint64_t v102 = 0u;
              unint64_t v103 = 0u;
              uint64_t v54 = v53 ? *(void **)(v53 + 32) : 0LL;
              uint64_t v55 = [v54 countByEnumeratingWithState:&v102 objects:v126 count:16];
              if (v55)
              {
                uint64_t v56 = *(void *)v103;
                while (2)
                {
                  for (uint64_t k = 0LL; k != v55; ++k)
                  {
                    if (*(void *)v103 != v56) {
                      objc_enumerationMutation(v54);
                    }
                    unint64_t v58 = *(void *)(*((void *)&v102 + 1) + 8 * k);
                    if (v58 && (*(_BYTE *)(v58 + 280) & 2) != 0)
                    {
                      *(_DWORD *)&val->_sqlCoreFlags |= 0x2000u;
                      goto LABEL_108;
                    }
                  }

                  uint64_t v55 = [v54 countByEnumeratingWithState:&v102 objects:v126 count:16];
                  if (v55) {
                    continue;
                  }
                  break;
                }
              }
            }

      uint64_t v2 = 0LL;
      goto LABEL_87;
    }

    uint64_t v53 = (void *)[(id)objc_opt_class() destinationURLForMigrationSourceURL:*(void *)(v2 + 16) createDocumentReplacementDirectory:0 error:a2];
    if (!v53) {
      goto LABEL_86;
    }
    if (!a2) {
      goto LABEL_86;
    }
    uint64_t v54 = (void *)MEMORY[0x189607870];
    uint64_t v55 = objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObjectsAndKeys:",  @"Migration source and destination URLs must be different",  @"reason",  *(void *)(v2 + 16),  @"sourceURL",  v53,  @"destinationURL",  0);
    uint64_t v27 = [v54 errorWithDomain:*MEMORY[0x189607460] code:134110 userInfo:v55];
LABEL_28:
    uint64_t v2 = 0LL;
    *a2 = v27;
LABEL_87:
    +[NSPersistentStoreCoordinator _endPowerAssertionWithAssert:andApp:]( (uint64_t)&OBJC_CLASS___NSPersistentStoreCoordinator,  v77,  v72);
  }

  return v2;
}

LABEL_122:
            ++v52;
          }

          while (v52 != v50);
          unint64_t v64 = -[NSArray countByEnumeratingWithState:objects:count:]( v49,  "countByEnumeratingWithState:objects:count:",  &v106,  v127,  16LL);
          unsigned int v50 = v64;
        }

        while (v64);
      }
    }

    objc_opt_self();
    val->_dbKey = (NSData *) +[NSSQLCore _databaseKeyFromValue:]( (uint64_t)NSSQLCore,  (void *)[a6 objectForKey:@"_NSSQLiteSEEKeychainItemOption"]);

    if (v93) {
      unsigned int v65 = -[NSGenerationalRowCache initWithStore:]( objc_alloc(&OBJC_CLASS___NSGenerationalRowCache),  "initWithStore:",  val);
    }
    else {
      unsigned int v65 = 0LL;
    }
    val->_generationalRowCache = v65;
    val->_adapter = -[NSSQLiteAdapter initWithSQLCore:]( objc_alloc(&OBJC_CLASS___NSSQLiteAdapter),  "initWithSQLCore:",  val);
    unint64_t v66 = (void *)[a6 valueForKey:@"NSXPCStoreDelegate"];
    val->_sqlCoreStateLock._os_unfair_lock_opaque = 0;
    val->_writerSerializationMutex = objc_alloc_init(&OBJC_CLASS____PFMutex);
    if (objc_msgSend( (id)objc_msgSend(a6, "valueForKey:", @"NSPersistentStoreOrderKeyUpdateNotification"),  "BOOLValue")) {
      *(_DWORD *)&val->_sqlCoreFlags |= 0x20u;
    }
    unint64_t v67 = [a6 valueForKey:@"NSPersistentStoreFileProtectionKey"];
    if (v67)
    {
      if ([(id)*MEMORY[0x189607538] isEqualToString:v67])
      {
        uint64_t v68 = val;
        int v69 = *(_DWORD *)&val->_sqlCoreFlags & 0xFFFFFFE3 | 0x10;
      }

      else if ([(id)*MEMORY[0x189607518] isEqualToString:v67])
      {
        uint64_t v68 = val;
        int v69 = *(_DWORD *)&val->_sqlCoreFlags & 0xFFFFFFE3 | 0xC;
      }

      else if ([(id)*MEMORY[0x189607510] isEqualToString:v67])
      {
        uint64_t v68 = val;
        int v69 = *(_DWORD *)&val->_sqlCoreFlags & 0xFFFFFFE3 | 8;
      }

      else if ([(id)*MEMORY[0x189607508] isEqualToString:v67])
      {
        uint64_t v68 = val;
        int v69 = *(_DWORD *)&val->_sqlCoreFlags & 0xFFFFFFE3 | 4;
      }

      else
      {
        if (![(id)*MEMORY[0x189607528] isEqualToString:v67])
        {
          _NSCoreDataLog( 1LL,  (uint64_t)@"Unrecognized value '%@' passed into options for NSPersistentStoreFileProtectionKey",  v70,  v71,  v72,  v73,  v74,  v75,  v67);
          goto LABEL_147;
        }

        uint64_t v68 = val;
        int v69 = *(_DWORD *)&val->_sqlCoreFlags | 0x1C;
      }
    }

    else
    {
      uint64_t v68 = val;
      int v69 = *(_DWORD *)&val->_sqlCoreFlags & 0xFFFFFFE3;
    }

    v68->_sqlCoreFlags = (_sqlCoreFlags)v69;
LABEL_147:
    if (v93)
    {
      __int128 v76 = getprogname();
      if (v76)
      {
        if (!strncmp("assetsd", v76, 7uLL)
          || !strncmp("homed", v76, 5uLL)
          || !strncmp("mapssyncd", v76, 9uLL)
          || !strncmp("financed", v76, 8uLL)
          || !strncmp("xctest", v76, 6uLL))
        {
          objc_initWeak(location, val);
          dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
          uint64_t v78 = dispatch_source_create(MEMORY[0x1895F8B50], 0LL, 0x30uLL, global_queue);
          val->_cache_event_source = (OS_dispatch_source *)v78;
          handler[0] = MEMORY[0x1895F87A8];
          handler[1] = 3221225472LL;
          handler[2] = __78__NSSQLCore_initWithPersistentStoreCoordinator_configurationName_URL_options___block_invoke;
          handler[3] = &unk_189EA8330;
          objc_copyWeak(&v97, location);
          dispatch_source_set_event_handler(v78, handler);
          dispatch_resume((dispatch_object_t)val->_cache_event_source);
          *(_DWORD *)&val->_sqlCoreFlags &= ~0x20000u;
          objc_destroyWeak(&v97);
          objc_destroyWeak(location);
        }
      }
    }

    return val;
  }

  objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:@"Got a nil sqlmodel" userInfo:0]);
LABEL_168:
  __break(1u);
  return result;
}

void sub_1867C2F10(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867C2EECLL);
  }

  JUMPOUT(0x1867C2EC0LL);
}

LABEL_94:
      objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A60] reason:v62 userInfo:0]);
LABEL_95:
      __break(1u);
      return;
    }

void sub_1867C37C0( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1867C3504LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1867C3CE4()
{
}

void sub_1867C424C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867C40E4LL);
  }

  JUMPOUT(0x1867C4284LL);
}

void sub_1867C4264()
{
}

id sub_1867C427C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    sub_1867C4280(a1);
  }
  objc_terminate();
  return -[NSSQLCore _rebuildDerivedAttributeTriggerSchemaUsingConnection:recomputeValues:error:](v2, v3);
}

void sub_1867C4280(_Unwind_Exception *exception_object)
{
}

void sub_1867C4608(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867C45E4LL);
  }

  JUMPOUT(0x1867C457CLL);
}

#error "1867C489C: call analysis failed (funcsize=15)"
void *-[NSSQLCore schemaValidationConnection](void *result)
{
  void *v1;
  if ((result[25] & 0x40) != 0)
  {
    __break(1u);
  }

  else
  {
    uint64_t v1 = result;
    BOOL result = (void *)result[15];
    if (!result)
    {
      BOOL result = -[NSSQLiteConnection initForSQLCore:]( objc_alloc(&OBJC_CLASS___NSSQLiteConnection),  "initForSQLCore:",  v1);
      v1[15] = result;
    }
  }

  return result;
}

LABEL_239:
            -[NSSQLiteConnection connect]((uint64_t)v156);
            -[NSSQLiteConnection beginTransaction]((uint64_t)v156);
            -[NSSQLiteConnection commitTransaction]((uint64_t)v156);
            -[NSSQLiteConnection endFetchAndRecycleStatement:]((uint64_t)v156, 0);
            goto LABEL_242;
          }

LABEL_245:
  uint64_t v192 = a1;
  if ([*(id *)(a1 + 40) _persistentStoreCoordinator]
    && (*(_BYTE *)(*(void *)(a1 + 40) + 202LL) & 1) != 0
    && (-[NSSQLiteConnection setUpIndexTracking](*(id **)(a1 + 32)) & 1) == 0)
  {
    _NSCoreDataLog( 2LL,  (uint64_t)@"failed to set up index tracking, disabling",  v193,  v194,  v195,  v196,  v197,  v198,  (uint64_t)v243);
    *(_DWORD *)(*(void *)(a1 + 40) + 200LL) &= ~0x10000u;
  }

  unint64_t v199 = *(void *)(a1 + 40);
  if (!v199) {
    goto LABEL_292;
  }
  uint64_t v200 = *(void **)(a1 + 32);
  os_unfair_lock_lock_with_options();
  v201 = (void *)[*(id *)(v199 + 160) objectForKey:0x189EBA2C8];
  os_unfair_lock_unlock((os_unfair_lock_t)(v199 + 152));
  uint64_t v202 = [v201 unsignedIntegerValue];
  if ([(id)v199 _persistentStoreCoordinator]
    && (int)[v201 intValue] <= 639
    && ([(id)v199 isReadOnly] & 1) == 0)
  {
    if (v202 - 496 > 0x8F)
    {
      uint64_t v219 = v202 > 0x27F;
      uint64_t v192 = a1;
      if (v219)
      {
LABEL_292:
        *(_BYTE *)(*(void *)(*(void *)(v192 + 48) + 8LL) + 24LL) = 0;
        goto LABEL_293;
      }

      size_t v203 = (void *)[MEMORY[0x189603FA8] array];
      v299 = 0u;
      v300 = 0u;
      v301 = 0u;
      v302 = 0u;
      uint64_t v220 = *(void *)(v199 + 104);
      if (v220) {
        uint64_t v221 = *(void **)(v220 + 32);
      }
      else {
        uint64_t v221 = 0LL;
      }
      uint64_t v222 = [v221 countByEnumeratingWithState:&v299 objects:&v286 count:16];
      if (v222)
      {
        uint64_t v223 = *(void *)v300;
        do
        {
          for (kuint64_t k = 0LL; kk != v222; ++kk)
          {
            if (*(void *)v300 != v223) {
              objc_enumerationMutation(v221);
            }
            uint64_t v225 = *(void **)(*((void *)&v299 + 1) + 8 * kk);
            if (v225 && !v225[20])
            {
              uint64_t v226 = -[NSSQLiteAdapter newSimplePrimaryKeyUpdateStatementForEntity:]( *(NSSQLiteStatement **)(v199 + 112),  v225);
              [v203 addObject:v226];
            }
          }

          uint64_t v222 = [v221 countByEnumeratingWithState:&v299 objects:&v286 count:16];
        }

        while (v222);
      }
    }

    else
    {
      size_t v203 = (void *)[MEMORY[0x189603FA8] array];
      v299 = 0u;
      v300 = 0u;
      v301 = 0u;
      v302 = 0u;
      uint64_t v204 = *(void *)(v199 + 104);
      if (v204) {
        uint64_t v205 = *(void **)(v204 + 32);
      }
      else {
        uint64_t v205 = 0LL;
      }
      unint64_t v206 = [v205 countByEnumeratingWithState:&v299 objects:&v286 count:16];
      if (v206)
      {
        unint64_t v207 = *(void *)v300;
        do
        {
          for (muint64_t m = 0LL; mm != v206; ++mm)
          {
            if (*(void *)v300 != v207) {
              objc_enumerationMutation(v205);
            }
            v209 = *(void **)(*((void *)&v299 + 1) + 8 * mm);
            if (v209 && !v209[20])
            {
              unint64_t v210 = -[NSSQLiteAdapter newComplexPrimaryKeyUpdateStatementForEntity:](*(void *)(v199 + 112), v209);
              [v203 addObject:v210];
            }
          }

          unint64_t v206 = [v205 countByEnumeratingWithState:&v299 objects:&v286 count:16];
        }

        while (v206);
      }
    }

    -[NSSQLCore _updateToVersion640PrimaryKeyTableUsingStatements:connection:](v199, v203, v200);
    uint64_t v192 = a1;
    goto LABEL_292;
  }

LABEL_293:
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL))
  {
    if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"finished upgrade checks, bumping metadata",  v227,  v228,  v229,  v230,  v231,  v232,  (uint64_t)v243);
    }
    -[NSSQLiteConnection beginTransaction](*(void *)(a1 + 32));
    uint64_t v233 = (__CFString *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 40), "metadata"), "mutableCopy");
    -[__CFString setObject:forKey:]( v233,  "setObject:forKey:",  +[_PFRoutines _getPFBundleVersionNumber](),  0x189EBA2C8LL);
    -[NSSQLiteConnection saveMetadata:](*(void **)(a1 + 32), v233);

    os_unfair_lock_lock_with_options();
    [*(id *)(*(void *)(a1 + 40) + 160) setObject:+[_PFRoutines _getPFBundleVersionNumber]() forKey:0x189EBA2C8];
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 40) + 152LL));
    -[NSSQLiteConnection commitTransaction](*(void *)(a1 + 32));
    -[NSSQLiteConnection endFetchAndRecycleStatement:](*(void *)(a1 + 32), 0);
  }

void sub_1867C7E7C(void *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    objc_begin_catch(a1);
    JUMPOUT(0x1867C7E24LL);
  }

  JUMPOUT(0x1867C803CLL);
}

void sub_1867C7EA8()
{
  if ((v0 & 1) != 0) {
    JUMPOUT(0x1867C7EB0LL);
  }
  JUMPOUT(0x1867C803CLL);
}

void sub_1867C7EB8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867C8038LL);
  }
  JUMPOUT(0x1867C7CECLL);
}

void sub_1867C7EC0(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1867C7ECCLL);
  }
  JUMPOUT(0x1867C803CLL);
}

void sub_1867C8014(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867C8028LL);
  }

  JUMPOUT(0x1867C803CLL);
}

void __Block_byref_object_copy__22(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__22(uint64_t a1)
{
}

void sub_1867C84F4()
{
}

void sub_1867C8504()
{
}

void sub_1867C8800( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1867C8D18(_Unwind_Exception *a1)
{
}

void sub_1867C8D34()
{
}

void sub_1867C8E64(void *a1)
{
}

void sub_1867C98D0(_Unwind_Exception *a1)
{
  if (v1) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_1867C98E8(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1867C98F4LL);
}

void sub_1867C9D00(_Unwind_Exception *a1)
{
}

void sub_1867C9D1C()
{
}

void sub_1867C9F14()
{
}

void sub_1867C9F84(_Unwind_Exception *a1)
{
}

void sub_1867C9FA0()
{
}

void sub_1867CA22C(void *a1)
{
}

void sub_1867CAA00(_Unwind_Exception *a1)
{
}

void sub_1867CAE20(_Unwind_Exception *a1)
{
}

void sub_1867CB130(_Unwind_Exception *a1)
{
}

void sub_1867CB404(void *a1)
{
}

void sub_1867CBA18(void *a1)
{
}

void sub_1867CBBC0(_Unwind_Exception *a1)
{
}

void sub_1867CBBDC()
{
}

void sub_1867CBD48(void *a1)
{
}

void sub_1867CBDA4()
{
}

void sub_1867CC064( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1867CC198(_Unwind_Exception *a1)
{
}

void sub_1867CC43C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

void sub_1867CC864(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v4 = objc_begin_catch(exception_object);
    -[NSSQLiteConnection disconnect](v3);
    if (v2) {
      objc_setProperty_nonatomic(v2, v5, v4, 48LL);
    }
    objc_exception_rethrow();
    __break(1u);
    JUMPOUT(0x1867CC8A4LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867CCFA4(_Unwind_Exception *a1)
{
}

void sub_1867CD598()
{
}

void sub_1867CD620(_Unwind_Exception *a1)
{
}

void sub_1867CD63C()
{
  if (v3 == 2)
  {
    id v4 = objc_begin_catch(v2);
    -[NSSQLiteConnection _forceDisconnectOnError](v0);
    if (v1) {
      objc_setProperty_nonatomic(v1, v5, v4, 48LL);
    }
    objc_end_catch();
    JUMPOUT(0x1867CD5ECLL);
  }

  objc_begin_catch(v2);
  JUMPOUT(0x1867CD5F0LL);
}

void sub_1867CDBBC(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867CDA64LL);
  }

  _Unwind_Resume(a1);
}

void sub_1867CDBCC(_Unwind_Exception *a1)
{
}

void sub_1867CDF10(_Unwind_Exception *exc_buf, int a2)
{
  if (!a2) {
    _Unwind_Resume(exc_buf);
  }
  if (a2 == 2)
  {
    id v3 = objc_begin_catch(exc_buf);
    if (v2) {
      objc_setProperty_nonatomic(v2, v4, v3, 48LL);
    }
    objc_end_catch();
  }

  else
  {
    objc_begin_catch(exc_buf);
  }

  JUMPOUT(0x1867CDE6CLL);
}

void sub_1867CE3A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1867CE464(_Unwind_Exception *exception_object, int a2)
{
  if (a2 == 1)
  {
    id v4 = objc_begin_catch(exception_object);
    -[NSSQLiteConnection disconnect](v3);
    if (v2) {
      objc_setProperty_nonatomic(v2, v5, v4, 48LL);
    }
    objc_exception_rethrow();
    __break(1u);
    JUMPOUT(0x1867CE4A4LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867CE7F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1867CEE24()
{
}

void sub_1867CEE34()
{
}

void sub_1867CEEA4()
{
}

void sub_1867CF634(_Unwind_Exception *a1)
{
}

void __cache_handle_memory_pressure_block_invoke(uint64_t a1, dispatch_queue_s **a2)
{
  uint64_t v3 = (void *)MEMORY[0x186E3E5D8]();
  -[NSSQLiteConnection _clearCachedStatements](a2);
  objc_autoreleasePoolPop(v3);
}

void sub_1867D0504( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, id location)
{
}

void __Block_byref_object_copy__23(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__23(uint64_t a1)
{
}

void sub_1867D0848( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, const __CFString *a12, uint64_t a13, uint64_t a14, const __CFString *a15)
{
  if (a2 == 1)
  {
    id v16 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v15 + 72) + 8LL) + 24LL) = 0;
    id v17 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v18 = *MEMORY[0x1896075F0];
    a12 = @"NSUnderlyingException";
    a13 = v18;
    a14 = (uint64_t)v16;
    a15 = @"Import failed because fetching the database metadata encountered an unhandled exception.";
    uint64_t v19 = [MEMORY[0x189603F68] dictionaryWithObjects:&a14 forKeys:&a12 count:2];
    *(void *)(*(void *)(*(void *)(v15 + 64) + 8) + 40) = [v17 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v19];
    objc_end_catch();
    JUMPOUT(0x1867D0810LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867D1420( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45)
{
}

void sub_1867D169C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, const __CFString *a21, uint64_t a22, uint64_t a23, const __CFString *a24)
{
  if (a2 == 1)
  {
    id v25 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v24 + 56) + 8LL) + 24LL) = 0;
    id v26 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v27 = *MEMORY[0x1896075F0];
    a21 = @"NSUnderlyingException";
    a22 = v27;
    a23 = (uint64_t)v25;
    a24 = @"Import failed because an unhandled exception was encountered while trying to process the results of the database fetch operation.";
    uint64_t v28 = [MEMORY[0x189603F68] dictionaryWithObjects:&a23 forKeys:&a21 count:2];
    *(void *)(*(void *)(*(void *)(v24 + 64) + 8) + 40) = [v26 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v28];
    objc_end_catch();
    JUMPOUT(0x1867D1664LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867D1908(_Unwind_Exception *exception_object)
{
}

void sub_1867D1C98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_1867D24A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47)
{
}

void sub_1867D270C(_Unwind_Exception *exception_object)
{
}

LABEL_79:
            uint64_t v42 = (char *)v42 + 1;
          }

          while (v40 != v42);
          BOOL result = (void *)[v11 countByEnumeratingWithState:&v74 objects:v86 count:16];
          unint64_t v40 = result;
          if (!result) {
            return result;
          }
        }
      }

      MEMORY[0x1895F8858](v4);
      __int128 v14 = (char *)&v72 - v27;
      else {
        bzero((char *)&v72 - v27, 8 * v26);
      }
      uint64_t v53 = *(void **)(v1 + 248);
      uint64_t v54 = v53[1];
      if (v54 >= 1)
      {
        uint64_t v55 = 0LL;
        uint64_t v56 = (uint64_t *)v53[9];
        do
        {
          unint64_t v58 = *v56++;
          uint64_t v57 = v58;
          unint64_t v59 = v53[8];
          if (v59 != v58 && v57 != ~v59) {
            *(void *)&v14[8 * v55++] = v57;
          }
          --v54;
        }

        while (v54);
      }

      uint64_t v61 = [*(id *)(v1 + 40) count];
      unsigned int v62 = PF_Tiger_CFDictionaryCreate(0LL, v61, 1);
      unint64_t v63 = v61;
      MEMORY[0x1895F8858](v62);
      unint64_t v66 = (unint64_t *)((char *)&v72 - v65);
      uint64_t v72 = (unint64_t)v67;
      uint64_t v73 = &v72;
      if (v68 > 0x200) {
        unint64_t v66 = (void *)NSAllocateScannedUncollectable();
      }
      else {
        bzero((char *)&v72 - v65, 8 * v64);
      }
      for (uint64_t m = 0LL; m != v26; ++m)
      {
        uint64_t v70 = *(__CFString **)&v14[8 * m];
        Value = _PF_Leopard_CFDictionaryGetValue(*(void **)(v1 + 248), v70);
        PF_Tiger_CFDictionarySetValue((uint64_t)v62, v70, Value);
      }

      PF_Tiger_CFDictionaryGetKeysAndValues((uint64_t)v62, 0LL, v66);
      unint64_t v11 = (void *)[MEMORY[0x189603F18] arrayWithObjects:v66 count:v63];
      PF_Tiger_CFDictionaryDestroy(v62);
      if (HIDWORD(v72) >= 0x201) {
        NSZoneFree(0LL, v66);
      }
    }

    NSZoneFree(0LL, v14);
    goto LABEL_56;
  }

  return result;
}

        uint64_t v75 = *MEMORY[0x189603B38];
        __int128 v76 = @"realloc failed";
        goto LABEL_80;
      }

      *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2C0], 8) = v24;
      v24[v22 + 511] = 0LL;
      *(_DWORD *)(a1 + 24) = v22 + 512;
    }

    id v25 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if ((*(_BYTE *)(a1 + 40) & 4) != 0)
    {
      if (!_PF_Private_Malloc_Zone) {
        id v25 = malloc_default_zone();
      }
      id v26 = malloc_zone_calloc(v25, 1uLL, v8);
    }

    else
    {
      if (!_PF_Private_Malloc_Zone) {
        id v25 = malloc_default_zone();
      }
      id v26 = malloc_zone_malloc(v25, v8);
    }

    *(void *)(a1 + 64) = v26;
    *(void *)(*(void *)(a1 + 48) + 8LL * v21) = v26;
    unint64_t v10 = *(unsigned int **)(a1 + 64);
    *(void *)(a1 + 72) = v10;
    if (!v10)
    {
      unsigned int v60 = [NSString stringWithUTF8String:"PF_MALLOC failed to allocate buffer to %ld bytes"];
      _NSCoreDataLog(17LL, v60, v61, v62, v63, v64, v65, v66, v8);
      unint64_t v67 = (os_log_s *)__pflogFaultLog;
      if (!os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
LABEL_72:
        uint64_t v75 = *MEMORY[0x189603B38];
        __int128 v76 = @"malloc failed";
LABEL_80:
        uint64_t v79 = 0LL;
        goto LABEL_81;
      }

      *(_DWORD *)address = 134217984;
      *(void *)&address[4] = v8;
LABEL_71:
      _os_log_fault_impl( &dword_186681000,  v67,  OS_LOG_TYPE_FAULT,  "CoreData: PF_MALLOC failed to allocate buffer to %ld bytes",  address,  0xCu);
      goto LABEL_72;
    }

    *(void *)unint64_t v10 = 0LL;
    uint64_t v18 = (char *)(v10 + 2);
    *(void *)(a1 + 72) = v10 + 2;
    *(_DWORD *)(a1 + 36) = v21;
  }

      uint64_t v18 = (char *)v18 + 1;
    }

    while (obja != v18);
    unsigned int v60 = [v89 countByEnumeratingWithState:&v103 objects:v111 count:16];
    id obja = (id)v60;
  }

  while (v60);
LABEL_88:
  unint64_t v103 = 0u;
  unint64_t v104 = 0u;
  unint64_t v105 = 0u;
  unint64_t v106 = 0u;
  uint64_t v61 = (void *)-[NSSQLEntity properties](*(void *)(v2 + 32));
  BOOL result = [v61 countByEnumeratingWithState:&v103 objects:v111 count:16];
  if (result)
  {
    unsigned int v62 = result;
    unint64_t v63 = *(void *)v104;
    objb = v61;
    do
    {
      unint64_t v64 = 0LL;
      do
      {
        if (*(void *)v104 != v63) {
          objc_enumerationMutation(v61);
        }
        unsigned int v65 = *(void *)(*((void *)&v103 + 1) + 8 * v64);
        if (v65 && *(_BYTE *)(v65 + 24) == 7 && *(_BYTE *)(v65 + 88))
        {
          unint64_t v66 = (void *)[*(id *)(*((void *)&v103 + 1) + 8 * v64) foreignKey];
          unint64_t v67 = *(void **)(v65 + 56);
          uint64_t v68 = (void *)-[_NSSQLiteStoreMigrator entityMigrationDescriptionForEntity:]( a2,  (void *)[v67 entity]);
          int v69 = v68;
          if (v68) {
            uint64_t v68 = (void *)v68[1];
          }
          uint64_t v70 = (void *)[v68 userInfo];
          if (objc_msgSend( (id)objc_msgSend(v70, "objectForKey:", _NSInferredMappedPropertiesKey),  "containsObject:",  objc_msgSend(v67, "name")))
          {
            if (v67) {
              unint64_t v71 = (void *)[v67 propertyDescription];
            }
            else {
              unint64_t v71 = 0LL;
            }
            uint64_t v72 = (void *)-[NSSQLEntity _sqlPropertyWithRenamingIdentifier:]( [v69 sourceEntity],  objc_msgSend(v71, "renamingIdentifier"));
            if (![v72 isToMany])
            {
              uint64_t v83 = (void *)MEMORY[0x189603F70];
              id v84 = *MEMORY[0x189603A58];
              v109[0] = @"sourceRelationship";
              v109[1] = @"destinationRelationship";
              v110[0] = v72;
              v110[1] = v65;
              uint64_t v81 = [MEMORY[0x189603F68] dictionaryWithObjects:v110 forKeys:v109 count:2];
              __int128 v82 = @"Unsupported relationship migration: A to-one's inverse to-many source must be a to-many";
              uint64_t v85 = v83;
              uint64_t v86 = v84;
              goto LABEL_123;
            }

            if (v72) {
              uint64_t v73 = (void *)v72[7];
            }
            else {
              uint64_t v73 = 0LL;
            }
            -[_NSSQLEntityMigrationDescription _populateSQLValuesForDestinationToOne:fromSourceToOne:]( v2,  (void *)v65,  v73);
          }

          else
          {
            uint64_t v74 = *(void **)(v65 + 72);
            uint64_t v75 = *(void **)(v65 + 80);
            __int128 v76 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( [NSSQLBindVariable alloc],  "initWithValue:sqlType:propertyDescription:",  0,  [v66 sqlType],  0);
            objc_msgSend(*(id *)(v2 + 16), "setObject:forKey:", v76, objc_msgSend(v66, "columnName"));

            if (v74)
            {
              uint64_t v77 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( [NSSQLBindVariable alloc],  "initWithValue:sqlType:propertyDescription:",  0,  [v74 sqlType],  0);
              objc_msgSend(*(id *)(v2 + 16), "setObject:forKey:", v77, objc_msgSend(v74, "columnName"));
            }

            uint64_t v61 = objb;
            if (v75)
            {
              uint64_t v78 = -[NSSQLBindVariable initWithValue:sqlType:propertyDescription:]( [NSSQLBindVariable alloc],  "initWithValue:sqlType:propertyDescription:",  0,  [v75 sqlType],  0);
              objc_msgSend(*(id *)(v2 + 16), "setObject:forKey:", v78, objc_msgSend(v75, "columnName"));
            }
          }
        }

        ++v64;
      }

      while (v62 != v64);
      BOOL result = [v61 countByEnumeratingWithState:&v103 objects:v111 count:16];
      unsigned int v62 = result;
    }

    while (result);
  }

  return result;
}

        ++v11;
      }

      while (v10 != v11);
      BOOL result = [v7 countByEnumeratingWithState:&v60 objects:v69 count:16];
      unint64_t v10 = result;
    }

    while (result);
  }

  return result;
}

            if ([v44 count]
              && (-[PFCloudKitExportContext insertRecordMetadataForObjectIDsInBatch:inManagedObjectContext:withPendingTransactionNumber:error:]( *(void *)(a1 + 56),  v44,  *(void **)(a1 + 40),  *(void *)(a1 + 64),  (void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL)) & 1) == 0)
            {
              *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
              uint64_t v53 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
            }

            if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL)
              && [*(id *)(a1 + 40) hasChanges])
            {
              if (([*(id *)(a1 + 40) save:*(void *)(*(void *)(a1 + 80) + 8) + 40] & 1) == 0)
              {
                *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
                uint64_t v54 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
              }

              [*(id *)(a1 + 40) reset];
            }

            if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
            {
LABEL_88:

              v98[5] = 0LL;
              uint64_t v55 = 1;
            }

            else
            {
              uint64_t v55 = 0;
            }

            objc_autoreleasePoolPop(v81);
            if (!v55) {
              break;
            }
            uint64_t v36 = obja + 1;
            if (obja + 1 == (char *)v75)
            {
              uint64_t v56 = [v70 countByEnumeratingWithState:&v93 objects:v123 count:16];
              uint64_t v75 = v56;
              if (v56) {
                goto LABEL_56;
              }
              break;
            }
          }
        }

        if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
        {
          uint64_t v57 = +[NSCKMetadataEntry entryForKey:fromStore:inManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMetadataEntry,  (uint64_t)@"NSCloudKitMirroringDelegateScanForRowsMissingFromHistoryKey",  *(void *)(a1 + 48),  *(void **)(a1 + 40),  *(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
          if (v57)
          {
            [*(id *)(a1 + 40) deleteObject:v57];
          }

          else
          {
            unsigned int v60 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
            if (v60)
            {
              uint64_t v61 = v60;
              *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
            }
          }

          if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL)
            && ([*(id *)(a1 + 40) save:*(void *)(*(void *)(a1 + 80) + 8) + 40] & 1) == 0)
          {
            *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
            unsigned int v62 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
          }
        }

        v98[5] = 0LL;
        _Block_object_dispose(&v97, 8);
      }

      else
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
        unint64_t v59 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
      }
    }

    else if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = 0;
      unint64_t v58 = *(id *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
    }
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
  {
    unint64_t v63 = +[NSFetchRequest fetchRequestWithEntityName:]( &OBJC_CLASS___NSFetchRequest,  "fetchRequestWithEntityName:",  +[NSCKRecordZoneMoveReceipt entityPath](&OBJC_CLASS___NSCKRecordZoneMoveReceipt, "entityPath"));
    -[NSFetchRequest setPredicate:]( v63,  "setPredicate:",  [MEMORY[0x1896079C8] predicateWithFormat:@"needsCloudDelete == 1"]);
    -[NSFetchRequest setFetchBatchSize:](v63, "setFetchBatchSize:", 500LL);
    -[NSFetchRequest setReturnsObjectsAsFaults:](v63, "setReturnsObjectsAsFaults:", 0LL);
    uint64_t v121 = *(void *)(a1 + 48);
    -[NSFetchRequest setAffectedStores:]( v63,  "setAffectedStores:",  [MEMORY[0x189603F18] arrayWithObjects:&v121 count:1]);
    v85[0] = MEMORY[0x1895F87A8];
    v85[1] = 3221225472LL;
    v85[2] = __86__PFCloudKitExportContext_processAnalyzedHistoryInStore_inManagedObjectContext_error___block_invoke_10;
    v85[3] = &unk_189EAB898;
    unint64_t v64 = *(int8x16_t *)(a1 + 40);
    unsigned int v65 = vextq_s8(*(int8x16_t *)(a1 + 72), *(int8x16_t *)(a1 + 72), 8uLL);
    uint64_t v86 = vextq_s8(v64, v64, 8uLL);
    uint64_t v87 = v65;
    +[_PFRoutines efficientlyEnumerateManagedObjectsInFetchRequest:usingManagedObjectContext:andApplyBlock:]( (uint64_t)&OBJC_CLASS____PFRoutines,  (uint64_t)v63,  (void *)v64.i64[0],  (uint64_t)v85);
  }

LABEL_121:
      ++v83;
    }

    if ((v120 & 1) != 0) {
      _PF_SnowLeopard_CFDictionaryDestroy((uint64_t)v79);
    }
    else {

    }
    if ((v121 & 1) == 0)
    {
      unint64_t v96 = *v123;
      if ((uint64_t)*v123 >= 1)
      {
        MEMORY[0x1895F8858](v95);
        uint64_t v98 = (char *)&v116 - v97;
        if (v96 > 0x200) {
          uint64_t v98 = (char *)NSAllocateScannedUncollectable();
        }
        else {
          bzero((char *)&v116 - v97, 8 * v96);
        }
        uint64_t v99 = v123[1];
        if (v99 > 0)
        {
          unint64_t v100 = 0LL;
          unint64_t v101 = (uint64_t *)v123[9];
          do
          {
            unint64_t v103 = *v101++;
            unint64_t v102 = v103;
            unint64_t v104 = v123[8];
            if (v104 != v103 && v102 != ~v104) {
              *(void *)&v98[8 * v100++] = v102;
            }
            --v99;
          }

          while (v99);
        }

        unint64_t v106 = 0LL;
        do
        {
          unsigned int v107 = (void *)_PF_Leopard_CFDictionaryGetValue(v123, *(__CFString **)&v98[8 * v106]);
          if (([v107 isTransient] & 1) == 0)
          {
            uint64_t v108 = [v107 name];
            uint64_t v109 = (id *)[v122 objectForKey:v108];
            if (v109)
            {
              if ([v107 maxCount] == 1)
              {
                unint64_t v110 = (void *)[v109 foreignKey];
                _PF_Leopard_CFDictionarySetValue(*(void **)(v1 + 248), (__CFString *)[v110 name], v110);
                unint64_t v111 = v109[9];
                if (v111) {
                  _PF_Leopard_CFDictionarySetValue( *(void **)(v1 + 248),  (__CFString *)[v109[9] name],  v111);
                }
              }

              _PF_Leopard_CFDictionarySetValue(*(void **)(v1 + 248), (__CFString *)[v109 name], v109);
            }
          }

          ++v106;
        }

        while (v96 != v106);
        if (v96 >= 0x201) {
          NSZoneFree(0LL, v98);
        }
      }

      _PF_Leopard_CFDictionaryDestroy(v123);
      _PF_Leopard_CFDictionaryDestroy(v124);
    }

    unint64_t v127 = 0u;
    unint64_t v128 = 0u;
    uint64_t v125 = 0u;
    uint64_t v126 = 0u;
    unint64_t v112 = *(void **)(v1 + 152);
    BOOL result = (void *)[v112 countByEnumeratingWithState:&v125 objects:v138 count:16];
    __int16 v113 = result;
    if (result)
    {
      char v114 = *(void *)v126;
      do
      {
        uint64_t v115 = 0LL;
        do
        {
          if (*(void *)v126 != v114) {
            objc_enumerationMutation(v112);
          }
          -[NSSQLEntity _generateProperties](*(void *)(*((void *)&v125 + 1) + 8LL * (void)v115));
          uint64_t v115 = (void *)((char *)v115 + 1);
        }

        while (v113 != v115);
        BOOL result = (void *)[v112 countByEnumeratingWithState:&v125 objects:v138 count:16];
        __int16 v113 = result;
      }

      while (result);
    }
  }

  return result;
}

void sub_1867D5344(_Unwind_Exception *a1)
{
}

void __Block_byref_object_copy__24(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__24(uint64_t a1)
{
}

LABEL_100:
      *(void *)(*(void *)&buf[8] + 40LL) = 0LL;
    }
  }

  uint64_t v140 = *(unsigned __int8 *)(*(void *)&v278[8] + 24LL);
  _Block_object_dispose(buf, 8);
  _Block_object_dispose(v278, 8);
  int v141 = v269;
  *((_BYTE *)v269 + 24) = v140;
  if (v140)
  {
    if ((unint64_t)(v71 - 1) > 1)
    {
      *(_BYTE *)(*(void *)&v237[8] + 24LL) = 1;
    }

    else
    {
      uint64_t v227 = MEMORY[0x1895F87A8];
      uint64_t v228 = 3221225472LL;
      uint64_t v229 = (uint64_t)__51__PFCloudKitSetupAssistant__createZoneIfNecessary___block_invoke;
      uint64_t v230 = (void (*)(uint64_t, uint64_t))&unk_189EA9E40;
      uint64_t v231 = v70;
      uint64_t v232 = (_BYTE *)v4;
      uint64_t v233 = v237;
      uint64_t v234 = &v268;
      uint64_t v235 = v239;
      uint64_t v236 = v71;
      -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v70, (uint64_t)&v227);
      int v141 = v269;
    }
  }

  if (*((_BYTE *)v141 + 24) && !*(_BYTE *)(*(void *)&v237[8] + 24LL))
  {
    *((_BYTE *)v141 + 24) = 0;
    if (v71 == 3)
    {
      *((_BYTE *)v141 + 24) = 1;
      goto LABEL_107;
    }

    if (v71 != 2)
    {
      unint64_t v161 = +[PFCloudKitSerializer defaultRecordZoneIDForDatabaseScope:]( &OBJC_CLASS___PFCloudKitSerializer,  "defaultRecordZoneIDForDatabaseScope:",  v71);
      unint64_t v162 = (void *)[objc_alloc(getCloudKitCKRecordZoneClass()) initWithZoneID:v161];
      *(void *)v278 = 0LL;
      *(void *)&v278[8] = v278;
      *(void *)&v278[16] = 0x2020000000LL;
      v279 = 0;
      *(void *)buf = 0LL;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3052000000LL;
      v275 = __Block_byref_object_copy__25;
      v276 = __Block_byref_object_dispose__25;
      v277 = 0LL;
      uint64_t v163 = [*(id *)(v4 + 8) databaseScope];
      unint64_t v164 = *(dispatch_semaphore_s **)(v4 + 48);
      unint64_t v165 = objc_alloc((Class)getCloudKitCKFetchRecordZonesOperationClass[0]());
      v258 = [v162 zoneID];
      unint64_t v166 = (void *)objc_msgSend( v165,  "initWithRecordZoneIDs:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", &v258, 1));
      -[NSCloudKitMirroringRequestOptions applyToOperation:]([*(id *)(v4 + 72) options], v166);
      *(void *)v272 = 0LL;
      *(void *)&v272[8] = v272;
      *(void *)&v272[16] = 0x2020000000LL;
      v273 = 0LL;
      *(void *)v259 = MEMORY[0x1895F87A8];
      *(void *)&v259[8] = 3221225472LL;
      *(void *)&v259[16] = __53__PFCloudKitSetupAssistant__checkIfZoneExists_error___block_invoke;
      v260 = &unk_189EA9E90;
      v263 = (uint64_t *)buf;
      v264 = v278;
      v265 = (uint64_t)v272;
      v266 = v163;
      v261 = v162;
      v262 = (uint64_t *)v164;
      [v166 setFetchRecordZonesCompletionBlock:v259];
      [*(id *)(v4 + 24) addOperation:v166];
      dispatch_semaphore_wait(v164, 0xFFFFFFFFFFFFFFFFLL);
      if (*(_BYTE *)(*(void *)&v278[8] + 24LL))
      {
        uint64_t v167 = (void (*)(uint64_t))*(id *)(v4 + 56);
        *(void *)uint64_t v246 = MEMORY[0x1895F87A8];
        uint64_t v247 = 3221225472LL;
        id v248 = (uint64_t)__53__PFCloudKitSetupAssistant__checkIfZoneExists_error___block_invoke_87;
        unint64_t v249 = (void (*)(uint64_t, uint64_t))&unk_189EA9E40;
        uint64_t v250 = v167;
        uint64_t v251 = (uint64_t *)v162;
        v252 = (uint64_t *)v272;
        v253 = v278;
        uint64_t v254 = (uint64_t)buf;
        uint64_t v255 = v163;
        -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v167, (uint64_t)v246);
      }

      else if (v163 == 1 && [*(id *)(*(void *)&buf[8] + 40) code] == 9)
      {
        unint64_t v179 = (void *)[*(id *)(*(void *)&buf[8] + 40) domain];
        if ([v179 isEqualToString:getCloudKitCKErrorDomain()])
        {
          uint64_t v180 = (void *)objc_msgSend((id)objc_msgSend(v162, "zoneID"), "zoneName");
          if (([v180 isEqualToString:getCloudKitCKRecordZoneDefaultName()] & 1) == 0)
          {
            v181 = [NSString stringWithUTF8String:"Custom zones aren't supported yet with the public database."];
            _NSCoreDataLog(17LL, v181, v182, v183, v184, v185, v186, v187, v225);
            unint64_t v188 = (os_log_s *)__pflogFaultLog;
            if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)uint64_t v246 = 0;
              _os_log_fault_impl( &dword_186681000,  v188,  OS_LOG_TYPE_FAULT,  "CoreData: Custom zones aren't supported yet with the public database.",  v246,  2u);
            }
          }

          *(_BYTE *)(*(void *)&v278[8] + 24LL) = 1;

          *(void *)(*(void *)&buf[8] + 40LL) = 0LL;
          unsigned int v189 = (void (*)(uint64_t))*(id *)(v4 + 56);
          *(void *)uint64_t v246 = MEMORY[0x1895F87A8];
          uint64_t v247 = 3221225472LL;
          id v248 = (uint64_t)__53__PFCloudKitSetupAssistant__checkIfZoneExists_error___block_invoke_89;
          unint64_t v249 = (void (*)(uint64_t, uint64_t))&unk_189EA9EB8;
          uint64_t v250 = v189;
          uint64_t v251 = (uint64_t *)v162;
          uint64_t v254 = 1LL;
          v252 = (uint64_t *)v278;
          v253 = buf;
          -[PFCloudKitStoreMonitor performBlock:]((uint64_t)v189, (uint64_t)v246);
        }
      }

      if (!*(_BYTE *)(*(void *)&v278[8] + 24LL))
      {
        uint64_t v190 = (__CFString *)*(id *)(*(void *)&buf[8] + 40LL);
        if (v190)
        {
          v257 = v190;
        }

        else
        {
          size_t v203 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
          _NSCoreDataLog( 17LL,  v203,  v204,  v205,  v206,  v207,  v208,  v209,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
          unint64_t v210 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)uint64_t v243 = 136315394;
            *(void *)&v243[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloud"
                                  "KitSetupAssistant.m";
            unint64_t v244 = 1024;
            id v245 = 1170;
            _os_log_fault_impl( &dword_186681000,  v210,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v243,  0x12u);
          }
        }
      }

      *(void *)(*(void *)&buf[8] + 40LL) = 0LL;
      unint64_t v211 = *(_BYTE *)(*(void *)&v278[8] + 24LL);
      _Block_object_dispose(v272, 8);
      _Block_object_dispose(buf, 8);
      _Block_object_dispose(v278, 8);
      *((_BYTE *)v269 + 24) = v211;

      goto LABEL_107;
    }

    uint64_t v149 = +[PFCloudKitSerializer defaultRecordZoneIDForDatabaseScope:]( &OBJC_CLASS___PFCloudKitSerializer,  "defaultRecordZoneIDForDatabaseScope:",  2LL);
    __int128 v150 = (void *)[objc_alloc(getCloudKitCKRecordZoneClass()) initWithZoneID:v149];
    if (-[PFCloudKitSetupAssistant _saveZone:error:](v4, (uint64_t)v150, &v257))
    {
      *((_BYTE *)v269 + 24) = 1;
LABEL_185:

      goto LABEL_107;
    }

    unint64_t v176 = v257;
    unint64_t v177 = (void *)-[__CFString domain](v257, "domain");
    if ([v177 isEqualToString:getCloudKitCKErrorDomain()])
    {
      if (-[__CFString code](v176, "code") == 112) {
        goto LABEL_149;
      }
      if (-[__CFString code](v176, "code") == 2)
      {
        uint64_t v212 = (void *)-[__CFString userInfo](v176, "userInfo");
        v213 = (void *)objc_msgSend( (id)objc_msgSend(v212, "objectForKey:", getCloudKitCKPartialErrorsByItemIDKey[0]()),  "objectForKey:",  objc_msgSend(v150, "zoneID"));
        unint64_t v214 = (void *)[v213 domain];
        if ([v214 isEqualToString:getCloudKitCKErrorDomain()])
        {
          if ([v213 code] == 112)
          {
LABEL_149:
            *(void *)v259 = 0LL;
            if ((-[PFCloudKitSetupAssistant _deleteZone:error:](v4, v150, v259) & 1) == 0)
            {
              unint64_t v178 = *((unsigned __int8 *)v269 + 24);
              goto LABEL_181;
            }

  unsigned int v50 = 0;
  a1[13] = (id)v51;
LABEL_101:
  if (([a1[13] BOOLValue] & 1) != 0
    || ![a1[19] count]
    && ![a1[14] count]
    && ![a1[15] count]
    && ![a1[16] count]
    && ![a1[21] count]
    && ![a1[18] count]
    && ![a1[20] count]
    && ![a1[22] count])
  {

    a1[19] = 0LL;
    a1[14] = 0LL;

    a1[15] = 0LL;
    a1[16] = 0LL;

    a1[21] = 0LL;
    a1[18] = 0LL;

    a1[20] = 0LL;
    a1[22] = 0LL;
  }

  if ((v50 & 1) != 0 && !a1[13]) {
    a1[13] = (id)[objc_alloc(MEMORY[0x189607968]) initWithBool:0];
  }
}

LABEL_150:
            unint64_t v178 = -[PFCloudKitSetupAssistant _saveZone:error:](v4, (uint64_t)v150, v259);
            *((_BYTE *)v269 + 24) = v178;
LABEL_181:
            if (v178)
            {
              unint64_t v215 = 0LL;
            }

            else
            {
              int v216 = (void *)MEMORY[0x186E3E5D8]();
              uint64_t v217 = __ckLoggingOverride;
              uint64_t v218 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ unable to recover from error: %@\nEncountered subsequent error: %@"];
              _NSCoreDataLog( v217 != 0,  v218,  v219,  v220,  v221,  v222,  v223,  v224,  (uint64_t)"-[PFCloudKitSetupAssistant _createZoneIfNecessary:]");
              objc_autoreleasePoolPop(v216);
              unint64_t v215 = *(__CFString **)v259;
            }

            v257 = v215;
            goto LABEL_185;
          }

          if ([v213 code] == 14)
          {
            *(void *)v259 = 0LL;
            goto LABEL_150;
          }
        }
      }
    }

    *((_BYTE *)v269 + 24) = 0;
    goto LABEL_185;
  }

    uint64_t v120 = 0;
    goto LABEL_151;
  }

  uint64_t v118 = (void *)+[NSCKMetadataEntry entryForKey:fromStore:inManagedObjectContext:error:]( (uint64_t)&OBJC_CLASS___NSCKMetadataEntry,  (uint64_t)@"PFCloudKitMetadataClientVersionHashesKey",  *(void *)(*(void *)(a1 + 32) + 8LL),  *(void **)(*(void *)(a1 + 32) + 16LL),  (uint64_t)&v172);
  uint64_t v119 = v172;
  if (v172)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
    uint64_t v117 = v119;
    goto LABEL_147;
  }

  if (!v118) {
    goto LABEL_150;
  }
  uint64_t v120 = objc_msgSend( (id)objc_msgSend(v118, "transformedValue"),  "isEqual:",  objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(*(id *)(*(void *)(a1 + 32) + 16), "persistentStoreCoordinator"),  "managedObjectModel"),  "entityVersionHashesByName"));
LABEL_151:
  uint64_t v121 = a1;
LABEL_152:
  if (!*(_BYTE *)(*(void *)(*(void *)(v121 + 40) + 8LL) + 24LL)) {
    goto LABEL_159;
  }
  if ([*(id *)(*(void *)(v121 + 32) + 16) hasChanges])
  {
    uint64_t v122 = [*(id *)(*(void *)(a1 + 32) + 16) save:&v172];
  }

  else
  {
    uint64_t v123 = +[_PFRoutines _isInMemoryStore:]( (uint64_t)&OBJC_CLASS____PFRoutines,  *(unsigned __int8 **)(*(void *)(a1 + 32) + 8LL));
    uint64_t v121 = a1;
    if (v123) {
      goto LABEL_159;
    }
    uint64_t v122 = objc_msgSend( *(id *)(*(void *)(a1 + 32) + 16),  "setQueryGenerationFromToken:error:",  +[NSQueryGenerationToken currentQueryGenerationToken]( NSQueryGenerationToken,  "currentQueryGenerationToken"),  &v172);
  }

  uint64_t v121 = a1;
  if ((v122 & 1) == 0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
    uint64_t v124 = v172;
    uint64_t v121 = a1;
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) = v124;
  }

LABEL_163:
  -[PFCloudKitSetupAssistant endActivityForPhase:withError:](v4, 5LL, *(void *)(*(void *)&buf[8] + 40LL));
  if (!*(_BYTE *)(*(void *)&v239[8] + 24LL))
  {
    unint64_t v194 = (__CFString *)*(id *)(*(void *)&buf[8] + 40LL);
    if (v194) {
      goto LABEL_166;
    }
    int v195 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
    _NSCoreDataLog( 17LL,  v195,  v196,  v197,  v198,  v199,  v200,  v201,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
    uint64_t v202 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t v237 = 136315394;
      *(void *)&v237[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m";
      *(_WORD *)&v237[12] = 1024;
      *(_DWORD *)&v237[14] = 1427;
      _os_log_fault_impl( &dword_186681000,  v202,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v237,  0x12u);
    }
  }

  unint64_t v194 = v11;
LABEL_166:

  *(void *)(*(void *)&buf[8] + 40LL) = 0LL;
  uint64_t v144 = *(_BYTE *)(*(void *)&v239[8] + 24LL) != 0;
  unint64_t v11 = v194;
LABEL_167:
  _Block_object_dispose(&v268, 8);
  _Block_object_dispose(v272, 8);
  _Block_object_dispose(buf, 8);
  _Block_object_dispose(v278, 8);
  _Block_object_dispose(v239, 8);
  uint64_t v8 = v11;
  if (v144)
  {
LABEL_9:
    *(void *)buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2020000000LL;
    LOBYTE(v275) = 1;
    *(void *)uint64_t v246 = 0LL;
    uint64_t v247 = (uint64_t)v246;
    id v248 = 0x3052000000LL;
    unint64_t v249 = __Block_byref_object_copy__25;
    uint64_t v250 = __Block_byref_object_dispose__25;
    uint64_t v251 = 0LL;
    unint64_t v10 = *(void *)(v4 + 56);
    uint64_t v227 = 0LL;
    uint64_t v228 = (uint64_t)&v227;
    uint64_t v229 = 0x3052000000LL;
    uint64_t v230 = __Block_byref_object_copy__25;
    uint64_t v231 = __Block_byref_object_dispose__25;
    uint64_t v232 = 0LL;
    -[PFCloudKitSetupAssistant beginActivityForPhase:](v4, 6LL);
    *(void *)v259 = MEMORY[0x1895F87A8];
    *(void *)&v259[8] = 3221225472LL;
    *(void *)&v259[16] = __60__PFCloudKitSetupAssistant__initializeAssetStorageURLError___block_invoke;
    v260 = &unk_189EA9CD8;
    v261 = (void *)v10;
    v262 = &v227;
    v263 = (uint64_t *)buf;
    v264 = v246;
    -[PFCloudKitStoreMonitor performBlock:](v10, (uint64_t)v259);
    -[PFCloudKitSetupAssistant endActivityForPhase:withError:](v4, 6LL, *(void *)(v247 + 40));
    if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
    {
      *(void *)(v4 + 40) = *(id *)(v228 + 40);
    }

    else
    {
      unint64_t v11 = (__CFString *)*(id *)(v247 + 40);
      if (v11)
      {
LABEL_22:

        *(void *)(v228 + 40) = 0LL;
        *(void *)(v247 + 40) = 0LL;
        uint64_t v28 = *(unsigned __int8 *)(*(void *)&buf[8] + 24LL);
        _Block_object_dispose(&v227, 8);
        _Block_object_dispose(v246, 8);
        _Block_object_dispose(buf, 8);
        if (v28) {
          return 1LL;
        }
        goto LABEL_71;
      }

      unsigned int v35 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m");
      uint64_t v42 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)v239 = 136315394;
        *(void *)&v239[4] = "/Library/Caches/com.apple.xbs/Sources/Persistence/Classes/Persistency/CloudKit/PFCloudKitSetupAssistant.m";
        *(_WORD *)&v239[12] = 1024;
        *(_DWORD *)&v239[14] = 275;
        _os_log_fault_impl( &dword_186681000,  v42,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  v239,  0x12u);
      }
    }

    unint64_t v11 = v8;
    goto LABEL_22;
  }

void sub_1867D9750( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t buf,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
}

void __Block_byref_object_copy__25(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__25(uint64_t a1)
{
}

void sub_1867D9F34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_1867DB170( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, const __CFString *a21, uint64_t a22, uint64_t a23, const __CFString *a24)
{
  if (a2 == 1)
  {
    id v25 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v24 + 64) + 8LL) + 24LL) = 0;
    id v26 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v27 = *MEMORY[0x1896075F0];
    a21 = @"NSUnderlyingException";
    a22 = v27;
    a23 = (uint64_t)v25;
    a24 = @"An unhandled exception was caught during a fetch for zone in manatee identity loss recovery.";
    uint64_t v28 = [MEMORY[0x189603F68] dictionaryWithObjects:&a23 forKeys:&a21 count:2];
    *(void *)(*(void *)(*(void *)(v24 + 56) + 8) + 40) = [v26 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v28];
    objc_end_catch();
    JUMPOUT(0x1867DB134LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867DB6AC( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, const __CFString *a25, uint64_t a26, uint64_t a27, const __CFString *a28)
{
  if (a2 == 1)
  {
    id v29 = objc_begin_catch(exc_buf);
    *(_BYTE *)(*(void *)(*(void *)(v28 + 72) + 8LL) + 24LL) = 0;
    id v30 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v31 = *MEMORY[0x1896075F0];
    a25 = @"NSUnderlyingException";
    a26 = v31;
    a27 = (uint64_t)v29;
    a28 = @"An unhandled exception was caught during a fetch for zone in manatee identity loss recovery.";
    uint64_t v32 = [MEMORY[0x189603F68] dictionaryWithObjects:&a27 forKeys:&a25 count:2];
    *(void *)(*(void *)(*(void *)(v28 + 64) + 8) + 40) = [v30 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v32];
    objc_end_catch();
    JUMPOUT(0x1867DB670LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1867DB770()
{
}

void sub_1867DBAE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, const __CFString *a21, uint64_t a22, uint64_t a23, const __CFString *a24)
{
  if (a2 == 1)
  {
    id v25 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v24 + 64) + 8LL) + 24LL) = 0;
    id v26 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v27 = *MEMORY[0x1896075F0];
    a21 = @"NSUnderlyingException";
    a22 = v27;
    a23 = (uint64_t)v25;
    a24 = @"An unhandled exception was caught during a fetch for zone in manatee identity loss recovery.";
    uint64_t v28 = [MEMORY[0x189603F68] dictionaryWithObjects:&a23 forKeys:&a21 count:2];
    *(void *)(*(void *)(*(void *)(v24 + 56) + 8) + 40) = [v26 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v28];
    objc_end_catch();
    JUMPOUT(0x1867DBAA4LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867DC028( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, const __CFString *a25, uint64_t a26, uint64_t a27, const __CFString *a28)
{
  if (a2 == 1)
  {
    id v29 = objc_begin_catch(exc_buf);
    *(_BYTE *)(*(void *)(*(void *)(v28 + 72) + 8LL) + 24LL) = 0;
    id v30 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v31 = *MEMORY[0x1896075F0];
    a25 = @"NSUnderlyingException";
    a26 = v31;
    a27 = (uint64_t)v29;
    a28 = @"An unhandled exception was caught during a fetch for zone in manatee identity loss recovery.";
    uint64_t v32 = [MEMORY[0x189603F68] dictionaryWithObjects:&a27 forKeys:&a25 count:2];
    *(void *)(*(void *)(*(void *)(v28 + 64) + 8) + 40) = [v30 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v32];
    objc_end_catch();
    JUMPOUT(0x1867DBFECLL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1867DC0EC()
{
}

void sub_1867DC33C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const __CFString *a10, uint64_t a11, uint64_t a12, const __CFString *a13)
{
  if (a2 == 1)
  {
    id v14 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v13 + 64) + 8LL) + 24LL) = 0;
    id v15 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v16 = *MEMORY[0x1896075F0];
    a10 = @"NSUnderlyingException";
    a11 = v16;
    a12 = (uint64_t)v14;
    a13 = @"Setup failed because an unhandled exception was caught during a fetch for zone creation.";
    uint64_t v17 = [MEMORY[0x189603F68] dictionaryWithObjects:&a12 forKeys:&a10 count:2];
    *(void *)(*(void *)(*(void *)(v13 + 72) + 8) + 40) = [v15 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v17];
    objc_end_catch();
    JUMPOUT(0x1867DC304LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867DC6EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

void sub_1867DC990( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1867DE4F0(_Unwind_Exception *exception_object)
{
}

void sub_1867DEC20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, const __CFString *a9, uint64_t a10, uint64_t a11, const __CFString *a12)
{
  if (a2 == 1)
  {
    id v13 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v12 + 48) + 8LL) + 24LL) = 0;
    id v14 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v15 = *MEMORY[0x1896075F0];
    a9 = @"NSUnderlyingException";
    a10 = v15;
    a11 = (uint64_t)v13;
    a12 = @"Setup failed because an unhandled exception was caught during event history truncation.";
    uint64_t v16 = [MEMORY[0x189603F68] dictionaryWithObjects:&a11 forKeys:&a9 count:2];
    *(void *)(*(void *)(*(void *)(v12 + 40) + 8) + 40) = [v14 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v16];
    objc_end_catch();
    JUMPOUT(0x1867DEBF0LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867DEE38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_1867DF078( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void __Block_byref_object_copy__26(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__26(uint64_t a1)
{
}

void sub_1867E4944(_Unwind_Exception *a1)
{
}

#error "1867E49DC: call analysis failed (funcsize=38)"
id -[PFCloudKitArchivingUtilities encodeRecord:error:](uint64_t a1, uint64_t a2, void *a3)
{
  void *v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  os_log_s *v18;
  id v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;
  id v25 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v20 = 0LL;
  id v5 = (void *)MEMORY[0x186E3E5D8]();
  uint64_t v6 = (void *)[MEMORY[0x1896078F8] archivedDataWithRootObject:a2 requiringSecureCoding:1 error:&v20];
  if (!v6 || (uint64_t v7 = (id)[v6 compressedDataUsingAlgorithm:0 error:&v20]) == 0)
  {
    uint64_t v9 = v20;
    objc_autoreleasePoolPop(v5);
    unint64_t v10 = v20;
    if (v10)
    {
      if (a3)
      {
        uint64_t v8 = 0LL;
        *a3 = v10;
        goto LABEL_11;
      }
    }

    else
    {
      unint64_t v11 = [NSString stringWithUTF8String:"Illegal attempt to return an error without one in %s:%d"];
      _NSCoreDataLog( 17LL,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitArchivingUtilities.m");
      uint64_t v18 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        uint64_t v22 = "/Library/Caches/com.apple.xbs/Sources/Persistence/PFCloudKitArchivingUtilities.m";
        unint64_t v23 = 1024;
        uint64_t v24 = 55;
        _os_log_fault_impl( &dword_186681000,  v18,  OS_LOG_TYPE_FAULT,  "CoreData: Illegal attempt to return an error without one in %s:%d",  buf,  0x12u);
      }
    }

    uint64_t v8 = 0LL;
    goto LABEL_11;
  }

  uint64_t v8 = v7;
  objc_autoreleasePoolPop(v5);
LABEL_11:

  return v8;
}

void sub_1867E62FC(_Unwind_Exception *a1)
{
}

void sub_1867E6F5C(_Unwind_Exception *a1)
{
}

CFStringRef NSSQLiteAdapter_typeStringForSQLType(int a1)
{
  else {
    return off_189EAA160[(char)(a1 - 1)];
  }
}

uint64_t sortColumnsByType(void *a1, void *a2)
{
  int v4 = [a1 sqlType];
  int v5 = [a2 sqlType];
  int v6 = [a1 propertyType];
  switch(v6)
  {
    case 2:
      uint64_t v7 = 0LL;
      break;
    case 6:
      uint64_t v7 = 2LL;
      break;
    case 5:
      uint64_t v7 = 1LL;
      break;
    default:
      else {
        uint64_t v7 = qword_1868D5ED0[(char)(v4 - 1)];
      }
      break;
  }

  int v8 = [a2 propertyType];
  switch(v8)
  {
    case 2:
      uint64_t v9 = 0LL;
      break;
    case 6:
      uint64_t v9 = -2LL;
      break;
    case 5:
      uint64_t v9 = -1LL;
      break;
    default:
      else {
        uint64_t v9 = qword_1868D5F58[(char)(v5 - 1)];
      }
      break;
  }

  return v9 + v7;
}

LABEL_62:
          objc_autoreleasePoolPop(v57);
          ++v55;
        }

        while (v53 != v55);
        uint64_t v61 = [v52 countByEnumeratingWithState:&v82 objects:v95 count:16];
        uint64_t v53 = v61;
      }

      while (v61);
    }

    unsigned int v62 = (void *)[v51 _uniquenessConstraintsAsFetchIndexes];
    uint64_t v80 = 0u;
    uint64_t v81 = 0u;
    uint64_t v78 = 0u;
    uint64_t v79 = 0u;
    unint64_t v63 = [v62 countByEnumeratingWithState:&v78 objects:v94 count:16];
    if (v63)
    {
      unint64_t v64 = *(void *)v79;
      do
      {
        for (uint64_t k = 0LL; k != v63; ++k)
        {
          if (*(void *)v79 != v64) {
            objc_enumerationMutation(v62);
          }
          unint64_t v66 = *(void *)(*((void *)&v78 + 1) + 8 * k);
          unint64_t v67 = (void *)MEMORY[0x186E3E5D8]();
          uint64_t v68 = -[NSSQLiteAdapter generateBinaryIndexStatementsForIndex:onEntity:](a1, v66, a2);
          if (v68) {
            [v74 addObjectsFromArray:v68];
          }
          objc_autoreleasePoolPop(v67);
        }

        unint64_t v63 = [v62 countByEnumeratingWithState:&v78 objects:v94 count:16];
      }

      while (v63);
    }
  }

  return v74;
}

                    unsigned int v34 = [NSString stringWithUTF8String:"Unsupported unique attribute type: %@"];
                    _NSCoreDataLog(17LL, v34, v35, v36, v37, v38, v39, v40, v29);
                    unsigned int v41 = (os_log_s *)__pflogFaultLog;
                    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 138412290;
                      uint64_t v242 = v29;
                      _os_log_fault_impl( &dword_186681000,  v41,  OS_LOG_TYPE_FAULT,  "CoreData: Unsupported unique attribute type: %@",  buf,  0xCu);
                    }

                    unsigned int v33 = 0LL;
                    goto LABEL_72;
                  }

                  uint64_t v42 = (void *)[v192 objectAtIndex:v27];
                  unsigned int v43 = [(id)v29 destinationEntity];
                  if (*(void *)(v29 + 72))
                  {
                    unint64_t v44 = (void *)[v192 objectAtIndex:++v27];
                    if (v205) {
                      sqlCore = v205->super._sqlCore;
                    }
                    else {
                      sqlCore = 0LL;
                    }
                    unsigned int v43 = -[NSSQLModel entityForID:]( -[NSSQLCore model](sqlCore, "model"),  "entityForID:",  [v44 longValue]);
                  }

                  uint64_t v46 = v43;
                  id v47 = [v42 longLongValue];
                  if (v205) {
                    unint64_t v48 = -[NSSQLCore newObjectIDForEntity:pk:]( v205->super._sqlCore,  "newObjectIDForEntity:pk:",  v46,  v47);
                  }
                  else {
                    unint64_t v48 = 0LL;
                  }
                  unsigned int v33 = v48;
                  uint64_t v31 = (void *)[v31 objectID];
LABEL_72:
                  if ([v33 isEqual:v31])
                  {
                    objc_msgSend(v197, "addObject:", objc_msgSend((id)v29, "name"));
                    goto LABEL_81;
                  }

void sub_1867EAA6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  if (a2)
  {
    objc_begin_catch(exception_object);

    objc_exception_rethrow();
    __break(1u);
    JUMPOUT(0x1867EAAECLL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867EB0BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  if (a2)
  {
    objc_begin_catch(exception_object);

    objc_exception_rethrow();
    __break(1u);
    JUMPOUT(0x1867EB134LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_1867EB680(_Unwind_Exception *a1)
{
}

uint64_t sub_1867EB68C(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867EB694LL);
  }
  objc_terminate();
  return -[NSSQLiteAdapter generateTriggerForEntity:alreadyCreated:correlations:batchHistory:fragments:error:]( v2,  v3,  v4,  v5,  v6,  v7,  v8);
}

LABEL_87:
            uint64_t v15 = (uint64_t)&unk_189F0B2B0;
            a5 = v126;
            a3 = theDict;
LABEL_88:
            a1 = v131;
            a7 = v127;
            uint64_t v19 = v125;
            goto LABEL_90;
          }

          if (!v38) {
            goto LABEL_87;
          }
          if (v38 != 1)
          {
            BOOL v93 = v127;
            if (!v127) {
              goto LABEL_136;
            }
            unint64_t v103 = (void *)MEMORY[0x189607870];
            unint64_t v104 = *MEMORY[0x189607460];
            v147[0] = @"Delete rule is not supported for batch deletes";
            v146[0] = @"Reason";
            v146[1] = @"Relationship";
            v147[1] = [NSString stringWithFormat:@"%@.%@", objc_msgSend((id)objc_msgSend(v21, "entity"), "name"), objc_msgSend(v21, "name")];
            uint64_t v99 = [MEMORY[0x189603F68] dictionaryWithObjects:v147 forKeys:v146 count:2];
            unint64_t v100 = v103;
            unint64_t v101 = v104;
            goto LABEL_135;
          }

          if (v29 && *(_BYTE *)(v29 + 24) == 7)
          {
            if (v37)
            {
              uint64_t v17 = v129;
              unsigned int v41 = [objc_alloc(NSString) initWithFormat:@"SELECT RAISE(FAIL, 'Batch delete failed due to mandatory OTO nullify inverse on %@/%@') FROM %@ WHERE Z_PK = OLD.%@", objc_msgSend(v22, "name"), objc_msgSend(v21, "name"), objc_msgSend(v130, "tableName"), objc_msgSend((id)v29, "columnName"), 0];
LABEL_82:
              id v47 = (void *)v41;
              goto LABEL_60;
            }

            if (!v36 || *(_BYTE *)(v36 + 24) != 7)
            {
              if ([(id)v36 isToMany])
              {
                id v47 = (void *)[objc_alloc(NSString) initWithFormat:@"UPDATE OR FAIL %@ SET Z_OPT = (Z_OPT + 1) WHERE Z_PK = OLD.%@", objc_msgSend(v130, "tableName"), objc_msgSend((id)v29, "columnName"), 0];
                unsigned int v62 = *(_BYTE **)(v131 + 8);
                if (v62 && (v62[201] & 4) != 0)
                {
                  unint64_t v63 = (void *)-[NSSQLiteAdapter generateBatchDeleteUpdateHistoryStatementEntity:andRelationship:useInverse:]( v62,  v130,  v29,  0);
                  unint64_t v64 = [objc_alloc(NSString) initWithFormat:@"%@; %@", v63, v47];

                  id v47 = (void *)v64;
                }

                goto LABEL_60;
              }

              goto LABEL_87;
            }

            uint64_t v56 = *(void *)(v36 + 72);
            uint64_t v57 = objc_alloc(NSString);
            unint64_t v58 = [v130 tableName];
            unint64_t v59 = [(id)v36 columnName];
            if (v56)
            {
              unsigned int v60 = [*(id *)(v36 + 72) columnName];
              char v114 = [(id)v36 columnName];
              uint64_t v115 = 0LL;
              uint64_t v61 = [v57 initWithFormat:@"UPDATE OR FAIL %@ SET %@ = NULL, %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK", v58, v59, v60];
            }

            else
            {
              char v114 = 0LL;
              uint64_t v61 = [v57 initWithFormat:@"UPDATE OR FAIL %@ SET %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK", v58, v59, objc_msgSend((id)v36, "columnName")];
            }
          }

          else
          {
            if (!v36 || *(_BYTE *)(v36 + 24) != 7)
            {
              if (v29 && *(_BYTE *)(v29 + 24) == 9)
              {
                if (!-[NSSQLiteAdapter generateCorrelationTableTriggerStatementsForRelationship:existing:correlationTableTriggers:error:]( v131,  v21,  a4,  v127)) {
                  goto LABEL_136;
                }
                if (v37)
                {
                  uint64_t v52 = [(id)v29 correlationTableName];
                  uint64_t v53 = [(id)v29 columnName];
                  uint64_t v54 = [(id)v36 columnName];
                  uint64_t v55 = [objc_alloc(NSString) initWithFormat:@"WITH ZCTE_INTERMEDIATE AS (SELECT %@, %@ FROM %@ WHERE %@ = OLD.Z_PK) SELECT RAISE(FAIL, 'Batch delete failed due to mandatory MTM nullify inverse on %@/%@') FROM ZCTE_INTERMEDIATE T0 WHERE (0 == (SELECT COUNT(*) FROM %@ T1 where T1.%@ = T0.%@ and T1.%@ != OLD.Z_PK))", v53, v54, v52, v53, objc_msgSend(v22, "name"), objc_msgSend(v21, "name"), v52, v54, v54, v53, 0];
                }

                else
                {
                  uint64_t v55 = [objc_alloc(NSString) initWithFormat:@"DELETE FROM %@ WHERE %@ = OLD.Z_PK", objc_msgSend((id)v29, "correlationTableName"), objc_msgSend((id)v29, "columnName"), 0, v114, v115, v116, v117, v118, v119, v120, v121];
                }

                id v47 = (void *)v55;
                goto LABEL_59;
              }

              goto LABEL_87;
            }

            if (v37)
            {
              uint64_t v17 = v129;
              unsigned int v41 = [objc_alloc(NSString) initWithFormat:@"SELECT RAISE(FAIL, 'Batch delete failed due to manadatory OTM nullify inverse on %@/%@') FROM %@ WHERE %@ = OLD.Z_PK", objc_msgSend(v22, "name"), objc_msgSend(v21, "name"), objc_msgSend(v130, "tableName"), objc_msgSend((id)v36, "columnName"), 0];
              goto LABEL_82;
            }

            if ([v21 isOrdered])
            {
              uint64_t v17 = v129;
              unsigned int v41 = [objc_alloc(NSString) initWithFormat:@"UPDATE OR FAIL %@ SET %@ = NULL, %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK", objc_msgSend(v130, "tableName"), objc_msgSend((id)v36, "columnName"), objc_msgSend(*(id *)(v36 + 80), "columnName"), objc_msgSend((id)v36, "columnName"), 0];
              goto LABEL_82;
            }

            uint64_t v65 = *(void *)(v36 + 72);
            unint64_t v66 = objc_alloc(NSString);
            unint64_t v67 = [v130 tableName];
            uint64_t v68 = [(id)v36 columnName];
            if (v65)
            {
              int v69 = [*(id *)(v36 + 72) columnName];
              char v114 = [(id)v36 columnName];
              uint64_t v115 = 0LL;
              uint64_t v61 = [v66 initWithFormat:@"UPDATE OR FAIL %@ SET %@ = NULL, %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK", v67, v68, v69];
            }

            else
            {
              char v114 = 0LL;
              uint64_t v61 = [v66 initWithFormat:@"UPDATE OR FAIL %@ SET %@ = NULL, Z_OPT = (Z_OPT + 1) WHERE %@ = OLD.Z_PK", v67, v68, objc_msgSend((id)v36, "columnName")];
            }
          }

          id v47 = (void *)v61;
          uint64_t v70 = *(_BYTE **)(v131 + 8);
          if (v70 && (v70[201] & 4) != 0) {
            -[NSSQLiteAdapter generateBatchDeleteUpdateHistoryTriggerForEntity:andRelationship:batchHistory:error:]( v70,  v130,  (void *)v36,  v126);
          }
          goto LABEL_60;
        }

void sub_1867ED1AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,char a51)
{
}

void __Block_byref_object_copy__27(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__27(uint64_t a1)
{
}

void sub_1867EE248( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_unfair_lock_t lock)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(lock);
    objc_exception_rethrow();
    __break(1u);
    JUMPOUT(0x1867EE268LL);
  }

  _Unwind_Resume(exception_object);
}

void __Block_byref_object_copy__324(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__325(uint64_t a1)
{
}

void sub_1867EFB70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  if ((v7 & 1) != 0) {
    objc_end_catch();
  }
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1867EFF58(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    objc_begin_catch(a1);
    JUMPOUT(0x1867EFE04LL);
  }

  _Unwind_Resume(a1);
}

void sub_1867EFF9C(_Unwind_Exception *a1)
{
}

uint64_t sub_1867EFFB4(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867EFFBCLL);
  }
  objc_terminate();
  return -[NSSQLiteConnection _ensureWalFileExists](v2);
}

void sub_1867F0114(void *a1)
{
}

void sub_1867F0130(_Unwind_Exception *a1)
{
}

void sub_1867F0614()
{
}

void sub_1867F14A4(void *a1)
{
}

void __Block_byref_object_copy__28(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__28(uint64_t a1)
{
}

void sub_1867F19FC()
{
}

void sub_1867F1A08()
{
  if (v0) {
    JUMPOUT(0x1867F1A10LL);
  }
  JUMPOUT(0x1867F1A14LL);
}

void sub_1867F1AA4(_Unwind_Exception *a1)
{
}

void rawIntegerRowsRelease(int a1, void *ptr)
{
  uint64_t v3 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v3 = malloc_default_zone();
  }
  malloc_zone_free(v3, ptr);
}

void sub_1867F2A8C(_Unwind_Exception *a1)
{
}

void sub_1867F2AA8()
{
}

uint64_t readMagicWordFromDBHandle(sqlite3 *a1)
{
  *(void *)&v10[15] = *MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  int v2 = sqlite3_file_control(a1, 0LL, 7, &v9);
  if (v9) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3) {
    return 92LL;
  }
  if (*(void *)v9)
  {
    int v5 = (*(uint64_t (**)(void))(*(void *)v9 + 16LL))();
    if (!v5)
    {
      if (*(void *)v10 ^ 0x66206574694C5153LL | *(void *)&v10[7] ^ 0x332074616D726F66LL) {
        return 92LL;
      }
      else {
        return 0LL;
      }
    }
  }

  else
  {
    int v5 = 1;
  }

  unsigned int v8 = 0;
  int v6 = sqlite3_file_control(a1, 0LL, 4, &v8);
  if (v6) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = 92;
  }
  if (v5 == 522) {
    unsigned int v7 = 0;
  }
  if (v8) {
    return v8;
  }
  else {
    return v7;
  }
}

void sub_1867F3320(_Unwind_Exception *a1)
{
}

void sub_1867F379C(void *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    objc_begin_catch(a1);
    JUMPOUT(0x1867F3748LL);
  }

  JUMPOUT(0x1867F37D4LL);
}

void sub_1867F37B4()
{
}

void sub_1867F37CC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1867F37D0LL);
  }
  objc_terminate();
  if (v2) {
    JUMPOUT(0x1867F3804LL);
  }
  JUMPOUT(0x1867F37D4LL);
}

void sub_1867F37F0(uint64_t a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1867F37F8LL);
  }
  JUMPOUT(0x1867F37D4LL);
}

void sub_1867F3800(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    JUMPOUT(0x1867F3804LL);
  }
  _Unwind_Resume(a1);
}

void sub_1867F3B7C(_Unwind_Exception *a1)
{
}

void sub_1867F3B94(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1867F3BA0LL);
}

CFStringRef _NSSQLiteConnectionLockProxyValueFromPragmas(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  uint64_t v2 = [a1 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = *(void *)v13;
    uint64_t v5 = *MEMORY[0x189603A60];
    while (2)
    {
      for (uint64_t i = 0LL; i != v3; ++i)
      {
        if (*(void *)v13 != v4) {
          objc_enumerationMutation(a1);
        }
        unsigned int v7 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        if (objc_msgSend( @"lock_proxy_file",  "isEqualToString:",  objc_msgSend(v7, "lowercaseString")))
        {
          unsigned int v8 = (void *)[a1 objectForKey:v7];
          if ([v8 isNSString]) {
            return (const __CFString *)v8;
          }
          uint64_t v9 = (void *)MEMORY[0x189603F70];
          unint64_t v10 = (objc_class *)objc_opt_class();
          [v9 raise:v5, @"Invalid class type '%@' for lock_proxy_file pragma value, must be an NSNull or NSString", NSStringFromClass(v10) format];
        }
      }

      uint64_t v3 = [a1 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v3) {
        continue;
      }
      break;
    }
  }

  return @":auto:";
}

uint64_t readFileSizeFromJournalHandle(sqlite3 *a1)
{
  uint64_t v1 = -1LL;
  uint64_t v3 = 0LL;
  uint64_t v4 = -1LL;
  if (!sqlite3_file_control(a1, 0LL, 28, &v3) && v3 && *(void *)v3)
  {
    else {
      return v4;
    }
  }

  return v1;
}

uint64_t PFVectorEqual(const __CFBitVector *a1, const __CFBitVector *a2)
{
  CFIndex Count = CFBitVectorGetCount(a1);
  if (Count == CFBitVectorGetCount(a2))
  {
    if (Count < 1) {
      return 1LL;
    }
    CFIndex v5 = 0LL;
    while (1)
    {
      CFBit BitAtIndex = CFBitVectorGetBitAtIndex(a1, v5);
      if (BitAtIndex != CFBitVectorGetBitAtIndex(a2, v5)) {
        break;
      }
      if (Count == ++v5) {
        return 1LL;
      }
    }
  }

  return 0LL;
}

uint64_t PFVectorHash(const __CFBitVector *a1)
{
  *(void *)bytes = 0LL;
  uint64_t Count = CFBitVectorGetCount(a1);
  if (Count >= 64) {
    v3.length = 64LL;
  }
  else {
    v3.length = Count;
  }
  v3.location = 0LL;
  CFBitVectorGetBits(a1, v3, bytes);
  return *(void *)bytes;
}

void sub_1867F81F8(_Unwind_Exception *a1)
{
}

void sub_1867F8E1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1867F92C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1867F9808( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_1867F9BD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1867FA9D8()
{
}

LABEL_116:
            ++v186;
LABEL_117:
            *(void *)&v26[8 * (v25 - v184)] = v52 - v22;
            uint64_t v22 = v52;
LABEL_118:
            ++v23;
            ++v25;
            uint64_t v27 = v22;
            if (v23 >= v182) {
              goto LABEL_161;
            }
            break;
          case 7:
          case 8:
            uint64_t v61 = &v189[6 * v23];
            unint64_t v63 = v61[3];
            unsigned int v62 = v61 + 3;
            unint64_t v64 = sqlite3_column_double(*(sqlite3_stmt **)(v185 + 80), v63);
            uint64_t v65 = v64;
            id v26 = v187;
            if ((v189[6 * v23 + 4] & 1) == 0) {
              goto LABEL_109;
            }
            if (v64 == 0.0)
            {
              unint64_t v104 = sqlite3_column_type(*(sqlite3_stmt **)(v185 + 80), *v62);
              *(_DWORD *)uint64_t v22 = v104 == 5;
              if (v104 == 5) {
                goto LABEL_118;
              }
            }

            else
            {
              *(_DWORD *)uint64_t v22 = 0;
            }

LABEL_149:
            uint64_t v135 = (objc_class *)objc_opt_class();
            uint64_t v136 = ((class_getInstanceSize(v135) + 7) & 0xFFFFFFF8) + v133;
            if (v190 - (v22 - (char *)v188) >= v136)
            {
              id v26 = v187;
            }

            else
            {
              v190 += v136;
              uint64_t v137 = (char *)bufferResultSetRealloc(v188, (unint64_t *)&v190);
              uint64_t v22 = &v137[v22 - (char *)v188];
              id v26 = &v137[v187 - (char *)v188];
              unint64_t v188 = v137;
            }

            if (!v22)
            {
              unint64_t v156 = [NSString stringWithUTF8String:"bufferResultSetRealloc failed to realloc buffer to %ld bytes"];
              _NSCoreDataLog(17LL, v156, v157, v158, v159, v160, v161, v162, v190);
              uint64_t v163 = (os_log_s *)__pflogFaultLog;
              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = v190;
                _os_log_fault_impl( &dword_186681000,  v163,  OS_LOG_TYPE_FAULT,  "CoreData: bufferResultSetRealloc failed to realloc buffer to %ld bytes",  buf,  0xCu);
              }

              goto LABEL_175;
            }

            *(void *)uint64_t v22 = 0LL;
            *((_DWORD *)v22 + 3) = v133;
            memcpy(v22 + 24, -[_PFExternalReferenceData bytes](v131, "bytes"), v133);

            ++v186;
            uint64_t v52 = &v22[v133 + 24];
            goto LABEL_117;
          default:
LABEL_91:
            unint64_t v92 = &v189[6 * v23];
            uint64_t v94 = v92[3];
            BOOL v93 = v92 + 3;
            unint64_t v95 = sqlite3_column_bytes(*(sqlite3_stmt **)(v185 + 80), v94);
            unint64_t v96 = v95;
            id v26 = v187;
            if ((v189[6 * v23 + 4] & 1) == 0) {
              goto LABEL_111;
            }
            if (v95)
            {
              *(_DWORD *)uint64_t v22 = 0;
            }

            else
            {
              unint64_t v105 = sqlite3_column_type(*(sqlite3_stmt **)(v185 + 80), *v93);
              *(_DWORD *)uint64_t v22 = v105 == 5;
              if (v105 == 5) {
                goto LABEL_118;
              }
            }

        __int128 v76 = (void *)MEMORY[0x186E3E5D8](v29);
        int v186 = __ckLoggingOverride != 0;
        unint64_t v187 = [@"CoreData+CloudKit: %s(%d): " stringByAppendingString:@"%@ - Failed to recover from error: %@:%ld\nRecovery encountered the following error: %@:%ld"];
        [a2 domain];
        [a2 code];
        [v202 domain];
        [v202 code];
        _NSCoreDataLog( v186,  v187,  v188,  v189,  v190,  v191,  v192,  v193,  (uint64_t)"-[NSCloudKitMirroringDelegate _recoverFromError:withZoneIDs:forStore:inMonitor:]");
        uint64_t v85 = 0LL;
LABEL_150:
        objc_autoreleasePoolPop(v76);
        return v85;
      }

      uint64_t v27 = *(void **)(v9 + 56);
LABEL_155:
      id v29 = [v27 databaseScope];
      goto LABEL_149;
    }

    if ([a2 code] == 9)
    {
      -[NSCloudKitMirroringDelegate resetAfterError:andKeepContainer:](v9, a2);
      -[NSCloudKitMirroringDelegate _setUpCloudKitIntegration:](v9, 0LL);
      goto LABEL_89;
    }

    if ([a2 code] == 2)
    {
      unint64_t v64 = [NSString stringWithUTF8String:"Invalid recursion detected, this method should never have been passed a partial error: %@"];
      _NSCoreDataLog(17LL, v64, v65, v66, v67, v68, v69, v70, (uint64_t)a2);
      unint64_t v71 = __pflogFaultLog;
      id v29 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)v29) {
        goto LABEL_149;
      }
      *(_DWORD *)buf = 138412290;
      unint64_t v206 = a2;
      unint64_t v40 = "CoreData: Invalid recursion detected, this method should never have been passed a partial error: %@";
      goto LABEL_102;
    }

    if ([a2 code] != 27)
    {
      if ([a2 code] == 6
        || [a2 code] == 4
        || [a2 code] == 3
        || [a2 code] == 22
        || [a2 code] == 7
        || [a2 code] == 23)
      {
        goto LABEL_89;
      }

      id v29 = [a2 code];
      if (v29 == 15)
      {
        id v29 = [*(id *)(v9 + 8) databaseScope];
        if (v29 == 1)
        {
          uint64_t v99 = *(void *)(v9 + 8);
          unint64_t v100 = v99 ? *(void *)(v99 + 96) : 0LL;
          id v29 = -[PFCloudKitMetadataPurger deleteZoneMetadataFromStore:inMonitor:forRecordZones:inDatabaseWithScope:error:]( v100,  a4,  a5,  (uint64_t)a3,  [*(id *)(v9 + 56) databaseScope],  &v202);
          if ((v29 & 1) != 0) {
            goto LABEL_89;
          }
        }
      }

      goto LABEL_149;
    }

    uint64_t v86 = *(void *)(v9 + 96);
    if (v86)
    {
      uint64_t v87 = *(void *)(v86 + 24);
      if (v87 == 512000)
      {
        *(void *)(v86 + 24) = 256000LL;
        uint64_t v88 = *(void *)(v9 + 96);
        if (!v88) {
          goto LABEL_89;
        }
        unint64_t v89 = 100LL;
        goto LABEL_144;
      }

      if (v87 == 1572864)
      {
        *(void *)(v86 + 24) = 512000LL;
        uint64_t v88 = *(void *)(v9 + 96);
        if (!v88) {
          goto LABEL_89;
        }
        unint64_t v89 = 200LL;
LABEL_144:
        *(void *)(v88 + 32) = v89;
        goto LABEL_89;
      }
    }

    uint64_t v185 = *MEMORY[0x189607460];
    size_t v203 = *MEMORY[0x1896075F0];
    uint64_t v204 = @"The mirroring delegate can no longer export because it cannot stay under the CloudKit operation limits.";
    id v29 = objc_msgSend( MEMORY[0x189607870],  "errorWithDomain:code:userInfo:",  v185,  134411,  objc_msgSend(MEMORY[0x189603F68], "dictionaryWithObjects:forKeys:count:", &v204, &v203, 1));
    uint64_t v202 = (id)v29;
    goto LABEL_149;
  }

  return 0LL;
}

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL)
    && (-[PFCloudKitExportContext currentBatchExceedsThresholds:](*(void *)(a1 + 40), *(void *)(a1 + 56)) & 1) == 0)
  {
    uint64_t v118 = +[NSFetchRequest fetchRequestWithEntityName:]( &OBJC_CLASS___NSFetchRequest,  "fetchRequestWithEntityName:",  +[NSCKRecordZoneMoveReceipt entityPath](&OBJC_CLASS___NSCKRecordZoneMoveReceipt, "entityPath"));
    unint64_t v193 = *(void *)(a1 + 32);
    -[NSFetchRequest setAffectedStores:]( v118,  "setAffectedStores:",  [MEMORY[0x189603F18] arrayWithObjects:&v193 count:1]);
    uint64_t v119 = *(void *)(*(void *)(a1 + 40) + 8LL);
    if (v119) {
      uint64_t v120 = *(void *)(v119 + 32);
    }
    else {
      uint64_t v120 = 0LL;
    }
    -[NSFetchRequest setFetchLimit:](v118, "setFetchLimit:", v120);
    -[NSFetchRequest setRelationshipKeyPathsForPrefetching:]( v118,  "setRelationshipKeyPathsForPrefetching:",  &unk_189F0B358);
    -[NSFetchRequest setPredicate:]( v118,  "setPredicate:",  [MEMORY[0x1896079C8] predicateWithFormat:@"(needsCloudDelete == 1) AND !(SELF IN %@)", *(void *)(a1 + 64)]);
    -[NSFetchRequest setReturnsObjectsAsFaults:](v118, "setReturnsObjectsAsFaults:", 0LL);
    uint64_t v121 = (void *)[*(id *)(a1 + 48) executeFetchRequest:v118 error:*(void *)(*(void *)(a1 + 72) + 8) + 40];
    uint64_t v122 = v121;
    if (v121)
    {
      unint64_t v162 = 0u;
      uint64_t v163 = 0u;
      uint64_t v160 = 0u;
      unint64_t v161 = 0u;
      uint64_t v123 = [v121 countByEnumeratingWithState:&v160 objects:v192 count:16];
      if (v123)
      {
        uint64_t v124 = *(void *)v161;
LABEL_156:
        uint64_t v125 = 0LL;
        while (1)
        {
          if (*(void *)v161 != v124) {
            objc_enumerationMutation(v122);
          }
          uint64_t v126 = *(void **)(*((void *)&v160 + 1) + 8 * v125);
          unint64_t v127 = (void *)MEMORY[0x186E3E5D8]();
          unint64_t v128 = -[PFCloudKitExportContext currentBatchExceedsThresholds:](*(void *)(a1 + 40), *(void *)(a1 + 56));
          if ((v128 & 1) == 0)
          {
            uint64_t v129 = (void *)[v126 createRecordIDForMovedRecord];
            uint64_t v130 = -[NSCKRecordMetadata createObjectIDForLinkedRow]((void *)[v126 recordMetadata]);
            uint64_t v131 = +[PFCloudKitSerializer recordTypeForEntity:]( (uint64_t)PFCloudKitSerializer,  [v130 entity]);
            -[PFCloudKitOperationBatch addDeletedRecordID:forRecordOfType:](*(void *)(a1 + 56), v129, v131);
          }

          objc_autoreleasePoolPop(v127);
          if ((v128 & 1) != 0) {
            break;
          }
          if (v123 == ++v125)
          {
            uint64_t v123 = [v122 countByEnumeratingWithState:&v160 objects:v192 count:16];
            if (v123) {
              goto LABEL_156;
            }
            break;
          }
        }
      }
    }

    else
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
      uint64_t v132 = *(id *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
    }
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL))
  {
    if ([*(id *)(a1 + 48) hasChanges])
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = [*(id *)(a1 + 48) save:*(void *)(*(void *)(a1 + 72) + 8) + 40];
      uint64_t v133 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 40LL);
      if (v133) {
        uint64_t v134 = v133;
      }
    }
  }
}

LABEL_111:
            unint64_t v106 = (objc_class *)objc_opt_class();
            unsigned int v107 = ((class_getInstanceSize(v106) + 7) & 0xFFFFFFF8) + v96;
            if (v190 - (v22 - (char *)v188) >= v107)
            {
              id v26 = v187;
            }

            else
            {
              v190 += v107;
              uint64_t v108 = (char *)bufferResultSetRealloc(v188, (unint64_t *)&v190);
              uint64_t v22 = &v108[v22 - (char *)v188];
              id v26 = &v108[v187 - (char *)v188];
              unint64_t v188 = v108;
            }

            if (!v22)
            {
              uint64_t v147 = [NSString stringWithUTF8String:"bufferResultSetRealloc failed to realloc buffer to %ld bytes"];
              _NSCoreDataLog(17LL, v147, v148, v149, v150, v151, v152, v153, v190);
              unint64_t v154 = (os_log_s *)__pflogFaultLog;
              if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 134217984;
                *(void *)&uint8_t buf[4] = v190;
                _os_log_fault_impl( &dword_186681000,  v154,  OS_LOG_TYPE_FAULT,  "CoreData: bufferResultSetRealloc failed to realloc buffer to %ld bytes",  buf,  0xCu);
              }

LABEL_175:
              unint64_t v155 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603B38],  134183LL,  (uint64_t)@"realloc failed",  0LL);
              objc_exception_throw(v155);
LABEL_183:
              __break(1u);
            }

            *(void *)uint64_t v22 = 0LL;
            *((_DWORD *)v22 + 3) = v96;
            uint64_t v109 = sqlite3_column_blob(*(sqlite3_stmt **)(v185 + 80), *v93);
            memcpy(v22 + 24, v109, v96);
            uint64_t v52 = &v22[v96 + 24];
            goto LABEL_116;
        }
      }
    }

    unint64_t v176 = 0;
LABEL_167:
    PF_FREE_OBJECT_ARRAY(v188);
    if (v176 <= 0x40000000) {
      BOOL result = v176;
    }
    else {
      BOOL result = 0LL;
    }
    if ((*(_BYTE *)(v185 + 312) & 2) == 0) {
      *(_DWORD *)(a2 + 40) |= 1u;
    }
  }

  return result;
}

void sub_1867FB970(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1867FB758LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_1867FBB08(_Unwind_Exception *a1)
{
}

void sub_1867FBB24()
{
}

void sub_1867FBE58(_Unwind_Exception *a1)
{
}

void sub_1867FC280(_Unwind_Exception *a1)
{
}

void sub_1867FC698(_Unwind_Exception *a1)
{
}

void sub_1867FCD08(_Unwind_Exception *a1)
{
}

void sub_1867FCD20(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1867FCD2CLL);
}

void sub_1867FE48C(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    objc_end_catch();
  }
  if (v2) {
    objc_end_catch();
  }
  _Unwind_Resume(a1);
}

void sub_1867FE4B4(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1867FE4C0LL);
}

void sub_1867FE7D8(void *a1)
{
}

void sub_1867FECD0(_Unwind_Exception *a1)
{
}

void sub_1867FF10C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1867FF0DCLL);
  }

  JUMPOUT(0x1867FF0BCLL);
}

#error "1867FF4C0: call analysis failed (funcsize=43)"
void -[NSSQLiteConnection generatePrimaryKeysForEntity:batch:]( sqlite3_int64 a1,  uint64_t a2,  unsigned int a3)
{
  dispatch_queue_s *v6;
  uint64_t v7;
  sqlite3_stmt *v8;
  sqlite3_stmt **v9;
  __objc2_class *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFStringRef v18;
  const char *v19;
  id v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  sqlite3_int64 v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  sqlite3_stmt **v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  CFStringRef v43;
  const char *v44;
  id v45;
  uint64_t v46;
  sqlite3_int64 v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  CFStringRef v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  CFStringRef v77;
  void *v78;
  void *v79;
  uint64_t v80;
  id v81;
  _BYTE *v82;
  char *pzTail;
  if (a1)
  {
    int v6 = *(dispatch_queue_s **)(a1 + 8);
    if (v6) {
      dispatch_assert_queue_V2(v6);
    }
    if (*(_BYTE *)(a1 + 40))
    {
      if (a2)
      {
        unsigned int v7 = *(unsigned int *)(a2 + 184);
        goto LABEL_7;
      }
    }

    else
    {
      objc_exception_throw((id)[MEMORY[0x189603F70] exceptionWithName:*MEMORY[0x189603A58] reason:@"primary keys must be generated within a transaction" userInfo:0]);
    }

    unsigned int v7 = 0LL;
LABEL_7:
    uint64_t v9 = (sqlite3_stmt **)(a1 + 112);
    unsigned int v8 = *(sqlite3_stmt **)(a1 + 112);
    unint64_t v10 = &OBJC_CLASS___NSSQLCoreDispatchManager;
    if (!v8)
    {
      unint64_t v11 = (void *)[objc_alloc(NSString) initWithFormat:@"SELECT %@ FROM %@ WHERE %@ = ?", @"Z_MAX", @"Z_PRIMARYKEY", @"Z_ENT"];
      if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1)
      {
        if (*(_BYTE *)(a1 + 42)) {
          uint64_t v18 = @"\x1B[32msql: \x1B[34m\x1B[47m%@\x1B[0m";
        }
        else {
          uint64_t v18 = @"%@";
        }
        _NSCoreDataLog(6LL, (uint64_t)v18, v12, v13, v14, v15, v16, v17, (uint64_t)v11);
      }

      uint64_t v19 = (const char *)[v11 UTF8String];
      uint64_t v20 = v11;
      -[NSSQLiteConnection _ensureDatabaseOpen]((void *)a1);
      unint64_t v21 = sqlite3_prepare_v3(*(sqlite3 **)(a1 + 72), v19, -1, 1u, (sqlite3_stmt **)(a1 + 112), (const char **)&pzTail);
      if ((_DWORD)v21)
      {
        int v69 = v21;
        uint64_t v70 = sqlite3_errmsg(*(sqlite3 **)(a1 + 72));
        if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 1)
        {
          if (*(_BYTE *)(a1 + 42)) {
            uint64_t v77 = @"\x1B[31m\x1B[47mERROR:\x1B[0m\x1B[31m (%d) %s\x1B[0m";
          }
          else {
            uint64_t v77 = @"(%d) %s";
          }
          _NSCoreDataLog(1LL, (uint64_t)v77, v71, v72, v73, v74, v75, v76, v69);
        }

        void *v9 = 0LL;
        unint64_t v63 = [NSString stringWithUTF8String:v70];
        unint64_t v64 = *MEMORY[0x189603A58];
        uint64_t v78 = (void *)MEMORY[0x189603F68];
        uint64_t v79 = (void *)MEMORY[0x189607968];
        uint64_t v80 = v69;
        goto LABEL_55;
      }

      unsigned int v8 = *v9;
    }

    sqlite3_bind_int(v8, 1, v7);
    if (+[NSSQLCore debugDefault](&OBJC_CLASS___NSSQLCore, "debugDefault") >= 2) {
      _NSCoreDataLog(4LL, (uint64_t)@"getting max pk for entityID = %u", v22, v23, v24, v25, v26, v27, v7);
    }
    uint64_t v28 = sqlite3_step(*v9);
    if ((_DWORD)v28 == 100)
    {
      id v30 = sqlite3_column_int64(*v9, 0);
    }

    else
    {
      id v29 = v28;
      if ((_DWORD)v28 != 101)
      {
        sqlite3_reset(*v9);
        sqlite3_clear_bindings(*v9);
        uint64_t v68 = *MEMORY[0x189603A58];
        unsigned int v60 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithInt:", v29),  @"NSSQLiteErrorDomain");
        unsigned int v62 = @"Fetching maximum primary key failed";
        uint64_t v61 = v68;
        goto LABEL_57;
      }

      id v30 = -[NSSQLiteConnection fetchMaxPrimaryKeyForEntity:](a1, (void *)a2);
      uint64_t v31 = (void *)NSString;
      uint64_t v32 = [(id)a2 name];
      if (a2)
      {
        unsigned int v33 = *(void *)(a2 + 160);
        if (v33) {
          unsigned int v33 = *(unsigned int *)(v33 + 184);
        }
      }

      else
      {
        unsigned int v33 = 0LL;
      }

      -[NSSQLiteConnection _executeSQLString:]( a1,  (void *)[v31 stringWithFormat:@"INSERT INTO %@(%@, %@, %@, %@) VALUES(%u, '%@', %u, %qd)", @"Z_PRIMARYKEY", @"Z_ENT", @"Z_NAME", @"Z_SUPER", @"Z_MAX", v7, v32, v33, v30]);
      unint64_t v10 = &OBJC_CLASS___NSSQLCoreDispatchManager;
    }

    unsigned int v34 = sqlite3_reset(*v9);
    sqlite3_clear_bindings(*v9);
    if ((_DWORD)v34)
    {
      uint64_t v56 = (void *)NSString;
    }

    else
    {
      uint64_t v35 = (sqlite3_stmt **)(a1 + 120);
      if (*(void *)(a1 + 120)) {
        goto LABEL_32;
      }
      uint64_t v36 = (void *)[objc_alloc(NSString) initWithFormat:@"UPDATE OR FAIL %@ SET %@ = ? WHERE %@ = ? AND %@ = ?", @"Z_PRIMARYKEY", @"Z_MAX", @"Z_ENT", @"Z_MAX"];
      if ((int)[&v10[76] debugDefault] >= 1)
      {
        if (*(_BYTE *)(a1 + 42)) {
          unsigned int v43 = @"\x1B[32msql: \x1B[34m\x1B[47m%@\x1B[0m";
        }
        else {
          unsigned int v43 = @"%@";
        }
        _NSCoreDataLog(6LL, (uint64_t)v43, v37, v38, v39, v40, v41, v42, (uint64_t)v36);
      }

      unint64_t v44 = (const char *)[v36 UTF8String];
      __int128 v45 = v36;
      -[NSSQLiteConnection _ensureDatabaseOpen]((void *)a1);
      uint64_t v46 = sqlite3_prepare_v3(*(sqlite3 **)(a1 + 72), v44, -1, 1u, (sqlite3_stmt **)(a1 + 120), (const char **)&pzTail);
      if (!(_DWORD)v46)
      {
LABEL_32:
        id v47 = v30;
        if (v30 == -1) {
          id v47 = -[NSSQLiteConnection fetchMaxPrimaryKeyForEntity:](a1, (void *)a2);
        }
        sqlite3_bind_int64(*v35, 1, v47 + a3);
        sqlite3_bind_int(*v35, 2, v7);
        sqlite3_bind_int64(*v35, 3, v30);
        if ((int)[&v10[76] debugDefault] >= 2) {
          _NSCoreDataLog( 4LL,  (uint64_t)@"updating max pk for entityID = %u with old = %qd and new = %qd",  v48,  v49,  v50,  v51,  v52,  v53,  v7);
        }
        uint64_t v54 = sqlite3_step(*v35);
        uint64_t v55 = sqlite3_reset(*v35);
        sqlite3_clear_bindings(*v35);
        if ((_DWORD)v54 == 101)
        {
          if (!(_DWORD)v55) {
            return;
          }
          unint64_t v63 = [NSString stringWithUTF8String:sqlite3_errmsg(*(sqlite3 **)(a1 + 72))];
          unint64_t v64 = *MEMORY[0x189603A58];
          uint64_t v65 = (void *)MEMORY[0x189603F68];
          unint64_t v66 = [MEMORY[0x189607968] numberWithInt:v55];
          unint64_t v67 = v65;
          goto LABEL_56;
        }

        uint64_t v57 = [NSString stringWithUTF8String:sqlite3_errmsg(*(sqlite3 **)(a1 + 72))];
        unint64_t v58 = *MEMORY[0x189603A58];
        unint64_t v59 = [NSString stringWithFormat:@"Updating max pk failed: %@", v57];
        unsigned int v60 = (void *)objc_msgSend( MEMORY[0x189603F68],  "dictionaryWithObject:forKey:",  objc_msgSend(MEMORY[0x189607968], "numberWithInt:", v54),  @"NSSQLiteErrorDomain");
        uint64_t v61 = v58;
        unsigned int v62 = (const __CFString *)v59;
LABEL_57:
        uint64_t v81 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  v61,  134030LL,  (uint64_t)v62,  v60);
        objc_exception_throw(v81);
        -[NSSQLiteConnection didCreateSchema](v82);
        return;
      }

      unsigned int v34 = v46;
      *(void *)(a1 + 120) = 0LL;
      uint64_t v56 = (void *)NSString;
    }

    unint64_t v63 = [v56 stringWithUTF8String:sqlite3_errmsg(*(sqlite3 **)(a1 + 72))];
    unint64_t v64 = *MEMORY[0x189603A58];
    uint64_t v78 = (void *)MEMORY[0x189603F68];
    uint64_t v79 = (void *)MEMORY[0x189607968];
    uint64_t v80 = v34;
LABEL_55:
    unint64_t v66 = [v79 numberWithInt:v80];
    unint64_t v67 = v78;
LABEL_56:
    unsigned int v60 = (void *)[v67 dictionaryWithObject:v66 forKey:@"NSSQLiteErrorDomain"];
    uint64_t v61 = v64;
    unsigned int v62 = (const __CFString *)v63;
    goto LABEL_57;
  }

void sub_1868000A4(_Unwind_Exception *a1)
{
}

uint64_t sub_1868000BC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1868000C4LL);
  }
  objc_terminate();
  return __37__NSSQLiteConnection_recreateIndices__block_invoke(v2, v3);
}

void sub_1868005E8()
{
}

void sub_186800F64(void *a1)
{
}

void sub_186800F74(_Unwind_Exception *a1)
{
}

LABEL_190:
  if ([v89 count]) {
    [v125 setValue:v89 forKey:@"deleted"];
  }

LABEL_193:
  if (![v125 count])
  {
    uint64_t v121 = 0LL;
LABEL_251:

    return;
  }

  uint64_t v132 = (id)-[NSSQLiteConnection _insertTransactionStringsForRequestContext:](a1, a2);
  uint64_t v99 = -[NSSQLiteConnection _insertTransactionForRequestContext:andStrings:](a1, a2, v132);
  if ([v125 objectForKey:@"inserted"]) {
    -[NSSQLiteConnection insertChanges:type:transactionID:context:]( a1,  (void *)[v125 objectForKey:@"inserted"],  0,  v99,  a2);
  }
  if ([v125 objectForKey:@"updated"]) {
    -[NSSQLiteConnection insertChanges:type:transactionID:context:]( a1,  (void *)[v125 objectForKey:@"updated"],  1,  v99,  a2);
  }
  if ([v125 objectForKey:@"deleted"]) {
    -[NSSQLiteConnection insertChanges:type:transactionID:context:]( a1,  (void *)[v125 objectForKey:@"deleted"],  2,  v99,  a2);
  }
  if (![v146 count]) {
    goto LABEL_248;
  }
  unint64_t v100 = *(dispatch_queue_s **)(a1 + 8);
  if (v100) {
    dispatch_assert_queue_V2(v100);
  }
  if (![v146 count])
  {
LABEL_248:
    uint64_t v124 = [MEMORY[0x189607968] numberWithLongLong:v99];
    if (a2) {
      *(void *)(a2 + 72) = v124;
    }
    uint64_t v121 = v132;
    goto LABEL_251;
  }

  unint64_t v128 = objc_alloc_init(MEMORY[0x1896077E8]);
  contexta = (void *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(*(id *)(a1 + 16), "ancillarySQLModels"),  "objectForKey:",  @"NSPersistentHistoryTrackingKey"),  "entityNamed:",  @"CHANGE");
  -[NSSQLiteConnection generatePrimaryKeysForEntity:batch:](a1, (uint64_t)contexta, [v146 count]);
  unint64_t v102 = v101;
  if (v101)
  {
    unint64_t v103 = [v146 count];
    uint64_t v202 = 0u;
    v201 = 0u;
    uint64_t v200 = 0u;
    unint64_t v199 = 0u;
    unint64_t v104 = [v146 countByEnumeratingWithState:&v199 objects:v204 count:16];
    if (!v104) {
      goto LABEL_241;
    }
    uint64_t v137 = v104;
    unint64_t v105 = v102 - v103;
    uint64_t v134 = *(void *)v200;
    while (1)
    {
      for (n = 0LL; n != (id)v137; n = (char *)n + 1)
      {
        if (*(void *)v200 != v134) {
          objc_enumerationMutation(v146);
        }
        unint64_t v106 = *(void **)(*((void *)&v199 + 1) + 8LL * (void)n);
        int v141 = (void *)MEMORY[0x186E3E5D8]();
        unsigned int v107 = (void *)[v106 componentsSeparatedByString:@"-"];
        -[NSSQLiteConnection prepareInsertStatementForAncillaryEntity:](a1, contexta);
        unint64_t v198 = 0u;
        v197 = 0u;
        v196 = 0u;
        int v195 = 0u;
        uint64_t v108 = (void *)[*(id *)(a1 + 48) bindVariables];
        uint64_t v109 = [v108 countByEnumeratingWithState:&v195 objects:v203 count:16];
        ++v105;
        if (v109)
        {
          unint64_t v110 = *(void *)v196;
          do
          {
            unint64_t v111 = 0LL;
            do
            {
              if (*(void *)v196 != v110) {
                objc_enumerationMutation(v108);
              }
              unint64_t v112 = *(void **)(*((void *)&v195 + 1) + 8 * v111);
              __int16 v113 = (void *)MEMORY[0x186E3E5D8]();
              if (![v112 index])
              {
                char v114 = [v112 sqlType];
                uint64_t v115 = v105;
                if (v114 == 2)
                {
LABEL_221:
                  [v112 setInt64:v115];
                  goto LABEL_229;
                }
              }

              if ([v112 index] != 1 && objc_msgSend(v112, "index") != 2)
              {
                if ([v112 index] == 3)
                {
                  uint64_t v116 = [v112 sqlType];
                  uint64_t v115 = v99;
                  if (v116 == 2) {
                    goto LABEL_221;
                  }
                }

                if (objc_msgSend(v112, "index", v115) == 4)
                {
                  uint64_t v117 = [MEMORY[0x189607968] numberWithUnsignedInteger:1];
LABEL_224:
                  [v112 setValue:v117];
                  goto LABEL_229;
                }

                if ([v112 index] == 5)
                {
                  if (a2) {
                    uint64_t v118 = [*(id *)(a2 + 144) objectForKey:v106];
                  }
                  else {
                    uint64_t v118 = 0LL;
                  }
                  [v112 setValue:v118];
                }

                else
                {
                  if ([v112 index] == 6)
                  {
                    uint64_t v117 = [v107 firstObject];
                    goto LABEL_224;
                  }

                  if ([v112 index] == 7)
                  {
                    uint64_t v117 = [v107 lastObject];
                    goto LABEL_224;
                  }
                }
              }

LABEL_229:
              objc_autoreleasePoolPop(v113);
              ++v111;
            }

            while (v109 != v111);
            uint64_t v119 = [v108 countByEnumeratingWithState:&v195 objects:v203 count:16];
            uint64_t v109 = v119;
          }

          while (v119);
        }

        [(id)a1 execute];
        if (!*(void *)(a1 + 80))
        {
          uint64_t v120 = -[NSSQLiteConnection statementCacheForEntity:](a1, contexta);
          -[NSSQLiteStatementCache cacheInsertStatement:](v120, 0LL);
        }

        -[NSSQLiteConnection _clearBindVariablesForInsertedRow](a1);
        -[NSSQLiteConnection resetSQLStatement](a1);
        objc_autoreleasePoolPop(v141);
      }

      uint64_t v137 = [v146 countByEnumeratingWithState:&v199 objects:v204 count:16];
      if (!v137)
      {
LABEL_241:
        [v128 drain];
        uint64_t v123 = 0LL;
        goto LABEL_248;
      }
    }
  }

  uint64_t v122 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603A58],  134030LL,  (uint64_t)@"unable to generate primary keys",  0LL);
  objc_exception_throw(v122);
  __break(1u);
}

void sub_18680282C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186802730LL);
  }

  JUMPOUT(0x1868026F4LL);
}

void sub_18680283C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186802708LL);
  }

  JUMPOUT(0x1868026F4LL);
}

void sub_186802860(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_terminate();
    if (v2) {
      JUMPOUT(0x186802890LL);
    }
    JUMPOUT(0x1868026F4LL);
  }

  JUMPOUT(0x1868026F0LL);
}

void sub_186803044(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186802E9CLL);
  }

  JUMPOUT(0x186802E50LL);
}

void sub_186803AB0(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186803894LL);
  }

  JUMPOUT(0x18680386CLL);
}

void sub_186803AE4()
{
}

uint64_t sub_186803AFC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x186803868LL);
  }
  objc_terminate();
  return __67__NSSQLiteConnection_processRelationshipUpdates_forRequestContext___block_invoke();
}

void sub_186804B90(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186804AB4LL);
  }

  JUMPOUT(0x186804A70LL);
}

void sub_186804BA0()
{
}

uint64_t sub_186804BB8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x186804A6CLL);
  }
  objc_terminate();
  return -[NSSQLiteConnection gatherHistoryChangesFromTable:](v2, v3);
}

void sub_1868053A8(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186805384LL);
  }

  JUMPOUT(0x186805348LL);
}

void sub_186805AB0(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186805A14LL);
  }

  JUMPOUT(0x1868059B0LL);
}

void sub_186805AC0()
{
}

void sub_186805AD8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1868059ACLL);
  }
  objc_terminate();
  -[NSSQLiteConnection processUpdateRequest:withOIDs:forAttributes:](v2, v3, v4, v5);
}

uint64_t sqlite3Callback(void *a1, uint64_t a2, void *a3)
{
  if (*a3)
  {
    uint64_t v4 = (void *)[objc_alloc(NSString) initWithCString:*a3 encoding:1];
    if (v4) {
      [a1 addObject:v4];
    }
  }

  return 0LL;
}

void sub_186806300(_Unwind_Exception *a1)
{
}

void sub_186806E9C(_Unwind_Exception *a1)
{
}

void sub_186807938(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18680790CLL);
  }

  JUMPOUT(0x1868078ACLL);
}

void sub_186807DDC()
{
  if (v0) {
    objc_end_catch();
  }
  JUMPOUT(0x186807E08LL);
}

uint64_t sub_186807E00(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x186807E04LL);
  }
  objc_terminate();
  return -[NSSQLiteConnection _transactionsStringAndPKsForStrings:](v2, v3);
}

void sub_18680847C(_Unwind_Exception *a1)
{
}

void sub_18680849C(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1868084C0LL);
}

void sub_1868084A4(_Unwind_Exception *a1)
{
  if ((v1 & 1) != 0) {
    JUMPOUT(0x1868084ACLL);
  }
  _Unwind_Resume(a1);
}

void sub_18680875C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_186808814( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_186809010(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186808F68LL);
  }

  JUMPOUT(0x186808F44LL);
}

void sub_186809020()
{
}

uint64_t sub_18680903C(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x186808F40LL);
  }
  objc_terminate();
  return -[NSSQLiteConnection _batchInsertThrowWithErrorCode:andMessage:forKey:andValue:additionalDetail:]( v2,  v3,  v4,  v5,  v6);
}

void sub_186809D34(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x186809C94LL);
  }

  _Unwind_Resume(a1);
}

void sub_186809D44(_Unwind_Exception *a1)
{
}

uint64_t sub_186809D5C(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x186809D64LL);
  }
  objc_terminate();
  return -[NSSQLiteConnection gatherObjectIDsFromTable:](v2, v3);
}

void sub_18680A208(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18680A1E4LL);
  }

  JUMPOUT(0x18680A180LL);
}

void sub_18680A7CC(_Unwind_Exception *a1)
{
}

void sub_18680A808(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18680A7F8LL);
  }
  JUMPOUT(0x18680A824LL);
}

void sub_18680A814(void *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x18680A740LL);
  }

  JUMPOUT(0x18680A7F8LL);
}

void sub_18680AA34(_Unwind_Exception *a1)
{
}

void sub_18680AA70(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18680AA60LL);
  }
  JUMPOUT(0x18680AA8CLL);
}

void sub_18680AA7C(void *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x18680A9A8LL);
  }

  JUMPOUT(0x18680AA60LL);
}

#error "18680AE40: call analysis failed (funcsize=38)"
uint64_t -[NSSQLiteConnection registerCurrentQueryGenerationWithStore:retries:]( uint64_t a1,  uint64_t a2,  uint64_t a3)
{
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  id v11;
  if (!a1) {
    return 0LL;
  }
  -[NSSQLiteConnection connect](a1);
  if (-[NSSQLiteConnection _ensureWalFileExists](a1) < 0) {
    return 14LL;
  }
  -[NSSQLiteConnection beginReadTransaction](a1);
  unint64_t v11 = 0LL;
  -[NSSQLiteConnection _currentQueryGenerationSnapshot:](a1, (uint64_t *)&v11);
  unsigned int v7 = (void *)v6;
  if (v6) {
    unsigned int v8 = -[NSSQLCore _registerNewQueryGenerationSnapshot:](a2, v6);
  }
  else {
    unsigned int v8 = 0LL;
  }
  -[NSSQLiteConnection rollbackTransaction](a1);
  if (!v7)
  {
    if (v11)
    {
      uint64_t v9 = [v11 code];
      if (a3)
      {
        if (v9 == 134181) {
          unsigned int v8 = -[NSSQLiteConnection registerCurrentQueryGenerationWithStore:retries:](a1, a2, 0LL);
        }
      }
    }
  }

  return v8;
}

void sub_18680B2EC(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x18680B0B4LL);
  }

  _Unwind_Resume(exc_buf);
}

#error "18680B698: call analysis failed (funcsize=54)"
void sub_18680B740()
{
  objc_end_catch();
  JUMPOUT(0x18680B630LL);
}

uint64_t sub_18680B758(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18680B62CLL);
  }
  objc_terminate();
  return -[NSSQLiteConnection adoptQueryGenerationWithIdentifier:](v2, v3);
}

#error "18680BA84: call analysis failed (funcsize=35)"
id *-[NSSQLiteConnection _activeGenerations](id *result)
{
  void *v1;
  id v2;
  void v3[5];
  if (result)
  {
    char v1 = (void *)[result[41] copy];
    uint64_t v2 = objc_alloc_init(MEMORY[0x189603FA8]);
    v3[0] = MEMORY[0x1895F87A8];
    v3[1] = 3221225472LL;
    v3[2] = __40__NSSQLiteConnection__activeGenerations__block_invoke;
    v3[3] = &unk_189EAA420;
    v3[4] = v2;
    [v1 enumerateObjectsUsingBlock:v3];

    return (id *)v2;
  }

  return result;
}

void sub_18680C898(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18680C7F8LL);
  }

  JUMPOUT(0x18680C780LL);
}

void sub_18680CD14(_Unwind_Exception *a1)
{
}

uint64_t NSSQLiteRegisterFunctions(sqlite3 *a1, void **a2)
{
  if (a2) {
    uint64_t v4 = a2 + 31;
  }
  else {
    uint64_t v4 = 0LL;
  }
  uint64_t function = sqlite3_create_function( a1,  "NSCoreDataNow",  0,  5,  0LL,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataNow,  0LL,  0LL);
  if (!(_DWORD)function)
  {
    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataPrependExternalReferenceMarker",  2,  5,  0LL,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataPrependExternalReferenceMarker,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_42:
      sqlite3_create_function(a1, "NSCoreDataNow", 0, 5, 0LL, 0LL, 0LL, 0LL);
      return function;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataLike",  3,  1,  *v4,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataLikeBridge,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_41:
      sqlite3_create_function(a1, "NSCoreDataPrependExternalReferenceMarker", 0, 5, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_42;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataStringSearch",  4,  1,  0LL,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataStringSearch,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_40:
      sqlite3_create_function(a1, "NSCoreDataLike", 0, 1, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_41;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataToUpper",  1,  4,  0LL,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataToUpper,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_39:
      sqlite3_create_function(a1, "NSCoreDataStringSearch", 0, 1, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_40;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataToLower",  1,  4,  0LL,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataToLower,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_38:
      sqlite3_create_function(a1, "NSCoreToUpper", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_39;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataCanonical",  1,  4,  0LL,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataCanonical,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_37:
      sqlite3_create_function(a1, "NSCoreDataToLower", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_38;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataMatches",  3,  1,  v4[4],  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataMatchesBridge,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_36:
      sqlite3_create_function(a1, "NSCoreCanonical", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_37;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataStringCompare",  5,  4,  0LL,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataStringCompareWithFlags,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_35:
      sqlite3_create_function(a1, "NSCoreDataMatches", 0, 1, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_36;
    }

    uint64_t function = sqlite3_create_collation( a1,  "NSCollateNoCase",  4,  0LL,  (int (__cdecl *)(void *, int, const void *, int, const void *))_NSCoreDataCollateNoCaseBridge);
    if ((_DWORD)function)
    {
LABEL_34:
      sqlite3_create_function(a1, "NSCoreDataStringCompare", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_35;
    }

    uint64_t function = sqlite3_create_collation( a1,  "NSCollateNumericallyNoCase",  4,  0LL,  (int (__cdecl *)(void *, int, const void *, int, const void *))_NSCoreDataCollateNumericallyNoCaseBridge);
    if ((_DWORD)function)
    {
LABEL_33:
      sqlite3_create_collation(a1, "NSCollateNoCase", 4, 0LL, 0LL);
      goto LABEL_34;
    }

    uint64_t function = sqlite3_create_collation( a1,  "NSCollateLocaleSensitive",  4,  0LL,  (int (__cdecl *)(void *, int, const void *, int, const void *))_NSCoreDataCollateLocaleSensitiveBridge);
    if ((_DWORD)function)
    {
LABEL_32:
      sqlite3_create_collation(a1, "NSCollateNumericallyNoCase", 4, 0LL, 0LL);
      goto LABEL_33;
    }

    uint64_t function = sqlite3_create_collation( a1,  "NSCollateLocaleSensitiveNoCase",  4,  0LL,  (int (__cdecl *)(void *, int, const void *, int, const void *))_NSCoreDataCollateLocaleSensitiveCaseInsensitiveBridge);
    if ((_DWORD)function)
    {
LABEL_31:
      sqlite3_create_collation(a1, "NSCollateLocaleSensitive", 4, 0LL, 0LL);
      goto LABEL_32;
    }

    uint64_t function = sqlite3_create_collation( a1,  "NSCollateFinderlike",  4,  0LL,  (int (__cdecl *)(void *, int, const void *, int, const void *))_NSCoreDataCollateFinderlikeBridge);
    if ((_DWORD)function)
    {
LABEL_30:
      sqlite3_create_collation(a1, "NSCollateLocaleSensitiveNoCase", 4, 0LL, 0LL);
      goto LABEL_31;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataTriggerUpdateAffectedObjectValue",  5,  2052,  a2,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataTriggerUpdateAffectedObjectValue,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_29:
      sqlite3_create_function(a1, "NSCollateFinderlike", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_30;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataDATriggerInsertUpdatedAffectedObjectValue",  5,  2052,  a2,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataDATriggerInsertUpdatedAffectedObjectValue,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_28:
      sqlite3_create_function(a1, "NSCoreDataTriggerUpdateAffectedObjectValue", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_29;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataDATriggerUpdatedAffectedObjectValue",  5,  2052,  a2,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataDATriggerUpdatedAffectedObjectValue,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_27:
      sqlite3_create_function(a1, "NSCoreDataDATriggerInsertUpdatedAffectedObjectValue", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_28;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSPersistentHistoryBatchDeleteUpdateTrigger",  -1,  2052,  a2,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSPersistentHistoryBatchDeleteUpdateTrigger,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_26:
      sqlite3_create_function(a1, "NSCoreDataDATriggerUpdatedAffectedObjectValue", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_27;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSPersistentHistoryBatchDeleteUpdateTriggerDataBlobOperator",  -1,  2052,  0LL,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSPersistentHistoryBatchDeleteUpdateTriggerDataBlobOperator,  0LL,  0LL);
    if ((_DWORD)function)
    {
LABEL_25:
      sqlite3_create_function(a1, "NSPersistentHistoryBatchDeleteUpdateTrigger", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_26;
    }

    uint64_t function = sqlite3_create_function( a1,  "NSCoreDataDATriggerMergeableString",  5,  2052,  a2,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSCoreDataDATriggerMergeableString,  0LL,  0LL);
    if ((_DWORD)function)
    {
      sqlite3_create_function(a1, "NSCoreDataDATriggerMergeableString", 0, 4, 0LL, 0LL, 0LL, 0LL);
      goto LABEL_25;
    }
  }

  return function;
}

void _NSCoreDataNow(sqlite3_context *a1, int a2)
{
  if (a2)
  {
    sqlite3_result_error(a1, "NSCoreDataNow: requires no arguments", 1);
  }

  else
  {
    objc_msgSend((id)objc_msgSend(MEMORY[0x189603F50], "date"), "timeIntervalSinceReferenceDate");
    sqlite3_result_double(a1, v3);
  }

void _NSCoreDataPrependExternalReferenceMarker(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  if (a2 == 2)
  {
    int v5 = sqlite3_value_int(*a3);
    uint64_t v6 = sqlite3_value_blob(a3[1]);
    unsigned int v7 = sqlite3_malloc(v5 + 1);
    if (v7)
    {
      unsigned int v8 = v7;
      _BYTE *v7 = 1;
      memcpy(v7 + 1, v6, v5);
      sqlite3_result_blob(a1, v8, v5 + 1, (void (__cdecl *)(void *))MEMORY[0x189617208]);
      return;
    }

    uint64_t v9 = "NSCoreDataPrependExternalReferenceMarker: malloc failure";
  }

  else
  {
    uint64_t v9 = "NSCoreDataPrependExternalReferenceMarker: wrong number of parameters";
  }

  sqlite3_result_error(a1, v9, 1);
}

void _NSCoreDataLikeBridge(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  _BYTE v16[128] = *MEMORY[0x1895F89C0];
  if (a2 != 3)
  {
    uint64_t v6 = "NSCoreDataLike: requres 3 arguments (value, pattern, variant)";
    goto LABEL_5;
  }

  unsigned int v5 = sqlite3_value_int(a3[2]);
  if (v5 >= 4)
  {
    uint64_t v6 = "NSCoreDataLike: variant must be an integer in the range [0,3]";
LABEL_5:
    sqlite3_result_error(a1, v6, 1);
    return;
  }

  unsigned int v7 = v5;
  unsigned int v8 = sqlite3_value_text(*a3);
  uint64_t v9 = sqlite3_value_text(a3[1]);
  if (v8 && (unint64_t v10 = (const char *)v9) != 0LL)
  {
    unint64_t v11 = _PFStackAllocatorCreate(v16, 1024LL);
    __int128 v12 = (const __CFAllocator *)*MEMORY[0x189604DC8];
    CFStringRef v13 = CFStringCreateWithCStringNoCopy(v11, (const char *)v8, 0x8000100u, (CFAllocatorRef)*MEMORY[0x189604DC8]);
    CFStringRef v14 = CFStringCreateWithCStringNoCopy(v11, v10, 0x8000100u, v12);
    uint64_t v15 = sqlite3_user_data(a1);
    if (!*v15)
    {
      *uint64_t v15 = (id)[MEMORY[0x1896079D0] operatorWithType:7 modifier:0 options:0];
      v15[1] = (id)[MEMORY[0x1896079D0] operatorWithType:7 modifier:0 options:1];
      id v15[2] = (id)[MEMORY[0x1896079D0] operatorWithType:7 modifier:0 options:2];
      void v15[3] = (id)[MEMORY[0x1896079D0] operatorWithType:7 modifier:0 options:3];
    }

    sqlite3_result_int(a1, [(id)v15[v7] performOperationUsingObject:v13 andObject:v14]);
    if (v16[3])
    {
      if (v13) {
        CFRelease(v13);
      }
      if (v14) {
        CFRelease(v14);
      }
    }
  }

  else
  {
    sqlite3_result_int(a1, 0);
  }

void _NSCoreDataStringSearch(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  _BYTE v14[128] = *MEMORY[0x1895F89C0];
  if (a2 != 4)
  {
    sqlite3_result_error(a1, "NSCoreStringSearch: requires 4 arguments (string1, string2, flags, localized)", 1);
    return;
  }

  unsigned int v5 = sqlite3_value_text(*a3);
  uint64_t v6 = sqlite3_value_text(a3[1]);
  int v7 = sqlite3_value_int(a3[2]);
  if (sqlite3_value_int(a3[3]))
  {
    unsigned int v8 = (const __CFLocale *)[MEMORY[0x1896079C8] retainedLocale];
    if (!v5) {
      goto LABEL_13;
    }
  }

  else
  {
    unsigned int v8 = 0LL;
    if (!v5) {
      goto LABEL_13;
    }
  }

  if (v6)
  {
    uint64_t v9 = _PFStackAllocatorCreate(v14, 1024LL);
    unint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DC8];
    unint64_t v11 = CFStringCreateWithCStringNoCopy(v9, (const char *)v5, 0x8000100u, (CFAllocatorRef)*MEMORY[0x189604DC8]);
    __int128 v12 = CFStringCreateWithCStringNoCopy(v9, (const char *)v6, 0x8000100u, v10);
    v15.length = CFStringGetLength(v11);
    v15.location = 0LL;
    BOOL v13 = CFStringFindWithOptionsAndLocale(v11, v12, v15, v7, v8, 0LL) != 0;
    sqlite3_result_int(a1, v13);
    if (v14[3])
    {
      if (v11) {
        CFRelease(v11);
      }
      if (v12) {
        CFRelease(v12);
      }
    }

    goto LABEL_14;
  }

void _NSCoreDataToUpper(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
}

void _NSCoreDataToLower(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
}

void _NSCoreDataCanonical(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  if (a2 == 1)
  {
    uint64_t v4 = sqlite3_value_text(*a3);
    if (v4)
    {
      id v5 = (id)-[objc_class newStringFrom:usingUnicodeTransforms:]( NSClassFromString((NSString *)@"_NSPredicateOperatorUtilities"),  "newStringFrom:usingUnicodeTransforms:",  [NSString stringWithUTF8String:v4],  387);
      sqlite3_result_text( a1,  (const char *)[v5 UTF8String],  -1,  (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    }

    else
    {
      sqlite3_result_null(a1);
    }
  }

  else
  {
    sqlite3_result_error(a1, "NSCoreDataCanonical: requires one argument", 1);
  }

void _NSCoreDataMatchesBridge(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  _BYTE v16[128] = *MEMORY[0x1895F89C0];
  if (a2 != 3)
  {
    uint64_t v6 = "NSCoreDataMatches: requres 3 arguments (value, pattern, variant)";
    goto LABEL_5;
  }

  unsigned int v5 = sqlite3_value_int(a3[2]);
  if (v5 >= 4)
  {
    uint64_t v6 = "NSCoreDataMatches: variant must be an integer in the range [0,3]";
LABEL_5:
    sqlite3_result_error(a1, v6, 1);
    return;
  }

  unsigned int v7 = v5;
  unsigned int v8 = sqlite3_value_text(*a3);
  uint64_t v9 = sqlite3_value_text(a3[1]);
  if (v8 && (unint64_t v10 = (const char *)v9) != 0LL)
  {
    unint64_t v11 = _PFStackAllocatorCreate(v16, 1024LL);
    __int128 v12 = (const __CFAllocator *)*MEMORY[0x189604DC8];
    CFStringRef v13 = CFStringCreateWithCStringNoCopy(v11, (const char *)v8, 0x8000100u, (CFAllocatorRef)*MEMORY[0x189604DC8]);
    CFStringRef v14 = CFStringCreateWithCStringNoCopy(v11, v10, 0x8000100u, v12);
    CFRange v15 = sqlite3_user_data(a1);
    if (!*v15)
    {
      *CFRange v15 = (id)[MEMORY[0x1896079D0] operatorWithType:6 modifier:0 options:0];
      v15[1] = (id)[MEMORY[0x1896079D0] operatorWithType:6 modifier:0 options:1];
      id v15[2] = (id)[MEMORY[0x1896079D0] operatorWithType:6 modifier:0 options:2];
      void v15[3] = (id)[MEMORY[0x1896079D0] operatorWithType:6 modifier:0 options:3];
    }

    sqlite3_result_int(a1, [(id)v15[v7] performOperationUsingObject:v13 andObject:v14]);
    if (v16[3])
    {
      if (v13) {
        CFRelease(v13);
      }
      if (v14) {
        CFRelease(v14);
      }
    }
  }

  else
  {
    sqlite3_result_int(a1, 0);
  }

void _NSCoreDataStringCompareWithFlags(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  _BYTE v24[128] = *MEMORY[0x1895F89C0];
  if (a2 == 5)
  {
    unsigned int v5 = sqlite3_value_text(*a3);
    uint64_t v6 = sqlite3_value_text(a3[1]);
    if (v5) {
      BOOL v7 = v6 == 0LL;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7)
    {
      sqlite3_result_int(a1, 0);
    }

    else
    {
      unsigned int v8 = (const char *)v6;
      uint64_t v9 = _PFStackAllocatorCreate(v24, 1024LL);
      int v10 = sqlite3_value_int(a3[2]);
      int v11 = sqlite3_value_int(a3[3]);
      int v12 = sqlite3_value_int(a3[4]);
      size_t v13 = strlen((const char *)v5);
      CFStringRef v14 = (const __CFAllocator *)*MEMORY[0x189604DC8];
      CFRange v15 = CFStringCreateWithBytesNoCopy(v9, v5, v13, 0x8000100u, 0, (CFAllocatorRef)*MEMORY[0x189604DC8]);
      size_t v16 = strlen(v8);
      uint64_t v17 = CFStringCreateWithBytesNoCopy(v9, (const UInt8 *)v8, v16, 0x8000100u, 0, v14);
      if (v12) {
        uint64_t v18 = (const __CFLocale *)[MEMORY[0x1896079C8] retainedLocale];
      }
      else {
        uint64_t v18 = 0LL;
      }
      v25.length = CFStringGetLength(v15);
      v25.location = 0LL;
      CFComparisonResult v19 = CFStringCompareWithOptionsAndLocale(v15, v17, v25, v11, v18);
      switch(v10)
      {
        case 1:
          BOOL v20 = v19 == kCFCompareLessThan;
          goto LABEL_23;
        case 2:
          BOOL v23 = (unint64_t)(v19 + 1) >= 2;
          goto LABEL_19;
        case 3:
          BOOL v20 = v19 == kCFCompareEqualTo;
          goto LABEL_23;
        case 4:
          BOOL v23 = (unint64_t)v19 >= 2;
LABEL_19:
          BOOL v22 = !v23;
          goto LABEL_27;
        case 5:
          BOOL v20 = v19 == kCFCompareGreaterThan;
LABEL_23:
          BOOL v22 = v20;
          goto LABEL_27;
        case 6:
          BOOL v22 = v19 != kCFCompareEqualTo;
LABEL_27:
          int v21 = 1;
          if (v18) {
            goto LABEL_28;
          }
          goto LABEL_29;
        default:
          sqlite3_result_error(a1, "NSCoreDataStringCompare: unknown operation type", 1);
          int v21 = 0;
          BOOL v22 = 0;
          if (!v18) {
            goto LABEL_29;
          }
LABEL_28:
          CFRelease(v18);
LABEL_29:
          if (v24[3])
          {
            if (v15) {
              CFRelease(v15);
            }
            if (v17) {
              CFRelease(v17);
            }
            if (v21) {
              goto LABEL_35;
            }
          }

          else
          {
            v24[1] = v24[0];
            if (v21)
            {
LABEL_35:
              sqlite3_result_int(a1, v22);
              return;
            }
          }

          break;
      }
    }
  }

  else
  {
    sqlite3_result_error(a1, "NSCoreDataStringCompare: incorrect number of arguments", 1);
  }

CFComparisonResult _NSCoreDataCollateNoCaseBridge( uint64_t a1, int a2, const UniChar *a3, int a4, const UniChar *a5)
{
  return _NSCoreDataDoStringCompare(a2, a3, a4, a5, 1uLL);
}

CFComparisonResult _NSCoreDataCollateNumericallyNoCaseBridge( uint64_t a1, int a2, const UniChar *a3, int a4, const UniChar *a5)
{
  return _NSCoreDataDoStringCompare(a2, a3, a4, a5, 0x41uLL);
}

CFComparisonResult _NSCoreDataCollateLocaleSensitiveBridge( uint64_t a1, int a2, const UniChar *a3, int a4, const UniChar *a5)
{
  return _NSCoreDataDoStringCompare(a2, a3, a4, a5, 0x20uLL);
}

CFComparisonResult _NSCoreDataCollateLocaleSensitiveCaseInsensitiveBridge( uint64_t a1, int a2, const UniChar *a3, int a4, const UniChar *a5)
{
  return _NSCoreDataDoStringCompare(a2, a3, a4, a5, 0x21uLL);
}

CFComparisonResult _NSCoreDataCollateFinderlikeBridge( uint64_t a1, int a2, const UniChar *a3, int a4, const UniChar *a5)
{
  return _NSCoreDataDoStringCompare(a2, a3, a4, a5, 0x361uLL);
}

void _NSCoreDataTriggerUpdateAffectedObjectValue(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  if (a2 == 5)
  {
    unsigned int v5 = sqlite3_value_text(*a3);
    sqlite3_int64 v6 = sqlite3_value_int64(a3[1]);
    sqlite3_int64 v7 = sqlite3_value_int64(a3[2]);
    unsigned int v8 = sqlite3_value_text(a3[3]);
    sqlite3_value_int64(a3[4]);
    if (v5)
    {
      if (v8)
      {
        uint64_t v9 = sqlite3_user_data(a1);
        -[NSSQLiteConnection triggerUpdatedRowInTable:withEntityID:primaryKey:columnName:newValue:]( (uint64_t)v9,  (uint64_t)v5,  v6,  v7);
      }
    }
  }

void _NSCoreDataDATriggerInsertUpdatedAffectedObjectValue(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  if (a2 == 5)
  {
    uint64_t v4 = sqlite3_user_data(a1);
    if (v4)
    {
      uint64_t v5 = (uint64_t)v4;
      if (v4[24])
      {
        sqlite3_int64 v6 = sqlite3_value_text(*a3);
        sqlite3_int64 v7 = sqlite3_value_int64(a3[1]);
        sqlite3_int64 v8 = sqlite3_value_int64(a3[2]);
        uint64_t v9 = sqlite3_value_text(a3[3]);
        if (v6)
        {
          uint64_t v10 = (uint64_t)v9;
          if (v9)
          {
            int v11 = sqlite3_value_type(a3[4]);
            switch(v11)
            {
              case 3:
                uint64_t v12 = [objc_alloc(NSString) initWithUTF8String:sqlite3_value_text(a3[4])];
                break;
              case 2:
                uint64_t v12 = [objc_alloc(MEMORY[0x189603F50]) initWithTimeIntervalSinceReferenceDate:sqlite3_value_double(a3[4])];
                break;
              case 1:
                uint64_t v12 = [objc_alloc(MEMORY[0x189607968]) initWithLongLong:sqlite3_value_int64(a3[4])];
                break;
              default:
                uint64_t v13 = 0LL;
                goto LABEL_15;
            }

            uint64_t v13 = v12;
LABEL_15:
            id v14 = (id)v13;
            -[NSSQLiteConnection derivedAttributeUpdatedInsertedRowInTable:withEntityID:primaryKey:columnName:newValue:]( v5,  (uint64_t)v6,  v7,  v8,  v10,  v13);
          }
        }
      }
    }
  }

void _NSCoreDataDATriggerUpdatedAffectedObjectValue(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  if (a2 == 5)
  {
    uint64_t v4 = sqlite3_user_data(a1);
    if (v4)
    {
      uint64_t v5 = (uint64_t)v4;
      if (v4[24])
      {
        sqlite3_int64 v6 = sqlite3_value_text(*a3);
        sqlite3_int64 v7 = sqlite3_value_int64(a3[1]);
        sqlite3_int64 v8 = sqlite3_value_int64(a3[2]);
        uint64_t v9 = sqlite3_value_text(a3[3]);
        if (v6)
        {
          uint64_t v10 = (uint64_t)v9;
          if (v9)
          {
            int v11 = sqlite3_value_type(a3[4]);
            switch(v11)
            {
              case 3:
                uint64_t v12 = [objc_alloc(NSString) initWithUTF8String:sqlite3_value_text(a3[4])];
                break;
              case 2:
                uint64_t v12 = [objc_alloc(MEMORY[0x189603F50]) initWithTimeIntervalSinceReferenceDate:sqlite3_value_double(a3[4])];
                break;
              case 1:
                uint64_t v12 = [objc_alloc(MEMORY[0x189607968]) initWithLongLong:sqlite3_value_int64(a3[4])];
                break;
              default:
                uint64_t v13 = 0LL;
                goto LABEL_15;
            }

            uint64_t v13 = v12;
LABEL_15:
            id v14 = (id)v13;
            -[NSSQLiteConnection derivedAttributeUpdatedRowInTable:withEntityID:primaryKey:columnName:newValue:]( v5,  (uint64_t)v6,  v7,  v8,  v10,  v13);
          }
        }
      }
    }
  }

void _NSPersistentHistoryBatchDeleteUpdateTrigger(sqlite3_context *a1, uint64_t a2, sqlite3_value **a3)
{
  uint64_t v5 = sqlite3_user_data(a1);
  sqlite3_int64 v6 = sqlite3_value_int64(*a3);
  sqlite3_int64 v7 = sqlite3_value_text(a3[1]);
  sqlite3_int64 v8 = (void *)_sqlCoreLookupSQLEntityForEntityID((void *)objc_msgSend((id)objc_msgSend(v5, "adapter"), "sqlCore"), v6);
  uint64_t v9 = +[_NSPersistentHistoryChange _propertyDataForEntity:withSetOfPropertyNames:]( (uint64_t)_NSPersistentHistoryChange,  v8,  (void *)objc_msgSend( MEMORY[0x189604010],  "setWithObject:",  objc_msgSend(NSString, "stringWithUTF8String:", v7)));
  uint64_t v10 = [v9 length];
  int v11 = sqlite3_malloc(v10);
  if (!v11) {
    sqlite3_result_error(a1, "NSPersistentHistoryBatchDeleteUpdateTrigger: malloc failure", 1);
  }
  [v9 getBytes:v11 length:v10];

  sqlite3_result_blob(a1, v11, v10, (void (__cdecl *)(void *))MEMORY[0x189617208]);
}

void _NSPersistentHistoryBatchDeleteUpdateTriggerDataBlobOperator(sqlite3_context *a1, int a2, uint64_t a3)
{
  if (a2 < 1)
  {
    sqlite3_int64 v6 = 0LL;
  }

  else
  {
    uint64_t v5 = 0LL;
    sqlite3_int64 v6 = 0LL;
    uint64_t v7 = 8LL * a2;
    do
    {
      if (sqlite3_value_type(*(sqlite3_value **)(a3 + v5)) == 4)
      {
        id v8 = objc_alloc(MEMORY[0x189603F48]);
        uint64_t v9 = sqlite3_value_blob(*(sqlite3_value **)(a3 + v5));
        uint64_t v10 = (void *)[v8 initWithBytes:v9 length:sqlite3_value_bytes(*(sqlite3_value **)(a3 + v5))];
        int v11 = v10;
        if (v5)
        {
          id v12 = +[_NSPersistentHistoryChange _mergeOldMask:andNewMask:]( (uint64_t)&OBJC_CLASS____NSPersistentHistoryChange,  v6,  v10);

          sqlite3_int64 v6 = v12;
        }

        else
        {
          sqlite3_int64 v6 = v10;
        }
      }

      v5 += 8LL;
    }

    while (v7 != v5);
  }

  uint64_t v13 = [v6 length];
  id v14 = sqlite3_malloc(v13);
  if (!v14) {
    sqlite3_result_error(a1, "_NSPersistentHistoryBatchDeleteUpdateTriggerDataBlobOperator: malloc failure", 1);
  }
  [v6 getBytes:v14 length:v13];

  sqlite3_result_blob(a1, v14, v13, (void (__cdecl *)(void *))MEMORY[0x189617208]);
}

void _NSCoreDataDATriggerMergeableString(sqlite3_context *a1, int a2, sqlite3_value **a3)
{
  v45[1] = *MEMORY[0x1895F89C0];
  if (a2 != 5)
  {
    unsigned int v33 = "_NSCoreDataDATriggerMergeableString: requires five arguments";
LABEL_17:
    sqlite3_result_error(a1, v33, 1);
    return;
  }

  if (sqlite3_value_type(a3[4]) != 4)
  {
    if (sqlite3_value_type(a3[4]) == 5)
    {
      sqlite3_result_null(a1);
      return;
    }

    unsigned int v33 = "_NSCoreDataDATriggerMergeableString: requires a transformable blob";
    goto LABEL_17;
  }

  uint64_t v5 = sqlite3_user_data(a1);
  sqlite3_int64 v6 = sqlite3_value_text(*a3);
  sqlite3_int64 v7 = sqlite3_value_int64(a3[1]);
  id v8 = sqlite3_value_text(a3[3]);
  if (v6)
  {
    uint64_t v9 = v8;
    if (v8)
    {
      id v10 = objc_alloc(MEMORY[0x189603F48]);
      int v11 = sqlite3_value_blob(a3[4]);
      id v12 = (void *)[v10 initWithBytes:v11 length:sqlite3_value_bytes(a3[4])];
      uint64_t v43 = 0LL;
      uint64_t v13 = _sqlCoreLookupSQLEntityForEntityID((void *)objc_msgSend((id)objc_msgSend(v5, "adapter"), "sqlCore"), v7);
      id v14 = v13;
      if (v13) {
        CFRange v15 = (void *)v13[5];
      }
      else {
        CFRange v15 = 0LL;
      }
      uint64_t v16 = objc_msgSend( (id)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend( v15,  "objectForKey:",  objc_msgSend(NSString, "stringWithUTF8String:", v9)),  "propertyDescription"),  "derivationExpression"),  "keyPath");
      if (v14) {
        uint64_t v17 = (void *)v14[5];
      }
      else {
        uint64_t v17 = 0LL;
      }
      uint64_t v18 = -[objc_class transformedValueClass]( NSClassFromString((NSString *)objc_msgSend( (id)objc_msgSend( (id)objc_msgSend(v17, "objectForKey:", v16),  "propertyDescription"),  "valueTransformerName")),  "transformedValueClass");
      if (v18)
      {
        id v25 = (id)objc_msgSend( (id)+[_PFRoutines unarchiveCylicGraphObjectOfClasses:fromData:error:]( (uint64_t)_PFRoutines,  objc_msgSend(MEMORY[0x189604010], "setWithObject:", v18),  (uint64_t)v12,  (uint64_t)&v43),  "computedValue");
        if (!v43)
        {
          uint64_t v32 = v25;
          sqlite3_result_text( a1,  (const char *)[v25 UTF8String],  -1,  (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);

          return;
        }

        _NSCoreDataLog( 1LL,  (uint64_t)@"Mergeable transformer failed with an error while trying to save a mergeable value, %@.",  v26,  v27,  v28,  v29,  v30,  v31,  v43);
        unint64_t v38 = (void *)MEMORY[0x189603F70];
        uint64_t v39 = *MEMORY[0x189603A58];
        uint64_t v44 = *MEMORY[0x189607798];
        v45[0] = v43;
        uint64_t v37 = [MEMORY[0x189603F68] dictionaryWithObjects:v45 forKeys:&v44 count:1];
        uint64_t v36 = @"Mergeable transformer failed with an error while trying to save a mergeable value.";
        unsigned int v34 = v38;
        uint64_t v35 = v39;
      }

      else
      {
        _NSCoreDataLog( 1LL,  (uint64_t)@"Mergeable transformer class name is nil while trying to save a mergeable value.",  v19,  v20,  v21,  v22,  v23,  v24,  v42);
        unsigned int v34 = (void *)MEMORY[0x189603F70];
        uint64_t v35 = *MEMORY[0x189603A58];
        uint64_t v36 = @"Mergeable transformer class name is nil while trying to save a mergeable value.";
        uint64_t v37 = 0LL;
      }

      objc_exception_throw((id)[v34 exceptionWithName:v35 reason:v36 userInfo:v37]);
      NSSQLiteRegisterMigrationFunctions(v40, v41);
    }
  }

uint64_t NSSQLiteRegisterMigrationFunctions(sqlite3 *a1, void *pApp)
{
  uint64_t function = sqlite3_create_function( a1,  "NSPersistentHistoryMigrateUpdates",  -1,  2052,  pApp,  (void (__cdecl *)(sqlite3_context *, int, sqlite3_value **))_NSPersistentHistoryMigrateUpdates,  0LL,  0LL);
  if ((_DWORD)function) {
    sqlite3_create_function(a1, "NSPersistentHistoryMigrateUpdates", 0, 4, 0LL, 0LL, 0LL, 0LL);
  }
  return function;
}

void _NSPersistentHistoryMigrateUpdates(sqlite3_context *a1, uint64_t a2, sqlite3_value **a3)
{
  uint64_t v5 = sqlite3_user_data(a1);
  sqlite3_int64 v6 = sqlite3_value_int64(a3[1]);
  sqlite3_int64 v7 = sqlite3_value_int64(a3[2]);
  id v8 = objc_alloc(MEMORY[0x189603F48]);
  uint64_t v9 = sqlite3_value_blob(a3[3]);
  id v10 = (void *)[v8 initWithBytes:v9 length:sqlite3_value_bytes(a3[3])];
  if (v5)
  {
    int v11 = (void *)*((void *)v5 + 25);
    id v12 = (void *)[*((id *)v5 + 3) entityForID:v7];
    uint64_t v13 = (void *)*((void *)v5 + 2);
  }

  else
  {
    id v12 = (void *)[0 entityForID:v7];
    int v11 = 0LL;
    uint64_t v13 = 0LL;
  }

  id v14 = (void *)[v13 entityForID:v6];
  CFRange v15 = (void *)objc_msgSend(v11, "objectForKey:", objc_msgSend(v12, "name"));
  if (v15)
  {
    id v16 = v15;
    id v17 = (id)[v15 objectForKey:v10];
    if (v17) {
      goto LABEL_13;
    }
  }

  else
  {
    id v16 = objc_alloc_init(MEMORY[0x189603FC8]);
    objc_msgSend(v11, "setObject:forKey:", v16, objc_msgSend(v12, "name"));
  }

  CFMutableSetRef v18 = +[_NSPersistentHistoryChange _updatedPropertiesForEntity:andData:]( (uint64_t)&OBJC_CLASS____NSPersistentHistoryChange,  v12,  v10);
  if (-[__CFSet count](v18, "count")) {
    uint64_t v19 = (void *)-[__CFSet valueForKey:](v18, "valueForKey:", @"name");
  }
  else {
    uint64_t v19 = 0LL;
  }
  id v17 = +[_NSPersistentHistoryChange _propertyDataForEntity:withSetOfPropertyNames:]( (uint64_t)&OBJC_CLASS____NSPersistentHistoryChange,  v14,  v19);
  [v16 setObject:v17 forKey:v10];

LABEL_13:
  uint64_t v20 = [v17 length];
  uint64_t v21 = sqlite3_malloc(v20);
  if (!v21) {
    sqlite3_result_error(a1, "NSPersistentHistoryMigrateUpdates: malloc failure", 1);
  }
  [v17 getBytes:v21 length:v20];

  sqlite3_result_blob(a1, v21, v20, (void (__cdecl *)(void *))MEMORY[0x189617208]);
}

void _NSCoreDataCaseSwitch(sqlite3_context *a1, int a2, sqlite3_value **a3, int a4)
{
  v17[128] = *MEMORY[0x1895F89C0];
  if (a2 == 1)
  {
    sqlite3_int64 v6 = sqlite3_value_text(*a3);
    if (v6)
    {
      sqlite3_int64 v7 = (const char *)v6;
      id v8 = _PFStackAllocatorCreate(v17, 1024LL);
      CFMutableStringRef Mutable = CFStringCreateMutable(v8, 0LL);
      CFStringAppendCString(Mutable, v7, 0x8000100u);
      if (a4) {
        CFStringUppercase(Mutable, 0LL);
      }
      else {
        CFStringLowercase(Mutable, 0LL);
      }
      uint64_t v10 = -[__CFString lengthOfBytesUsingEncoding:](Mutable, "lengthOfBytesUsingEncoding:", 4LL);
      CFIndex v11 = v10 + 1;
      CFIndex Length = CFStringGetLength(Mutable);
      if (v10 + 1 >= 1024) {
        p_UInt8 buffer = (UInt8 *)malloc(v10 + 2);
      }
      else {
        p_UInt8 buffer = &buffer;
      }
      CFIndex usedBufLen = 0LL;
      v18.location = 0LL;
      v18.length = Length;
      CFStringGetBytes(Mutable, v18, 0x8000100u, 0, 0, p_buffer, v11, &usedBufLen);
      CFIndex v14 = usedBufLen;
      if (usedBufLen >= v11) {
        CFIndex v14 = v11;
      }
      p_buffer[v14] = 0;
      sqlite3_result_text(a1, (const char *)p_buffer, -1, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
      if (v17[3] && Mutable) {
        CFRelease(Mutable);
      }
      if (v11 >= 1024) {
        free(p_buffer);
      }
    }

    else
    {
      sqlite3_result_null(a1);
    }
  }

  else
  {
    sqlite3_result_error(a1, "NSCoreDataTo(Uppercase|Lowercase): requires one argument", 1);
  }

CFComparisonResult _NSCoreDataDoStringCompare( int a1, const UniChar *a2, int a3, const UniChar *a4, CFStringCompareFlags a5)
{
  v17[128] = *MEMORY[0x1895F89C0];
  uint64_t v10 = _PFStackAllocatorCreate(v17, 1024LL);
  CFIndex v11 = (uint64_t)a1 >> 1;
  id v12 = (const __CFAllocator *)*MEMORY[0x189604DC8];
  uint64_t v13 = CFStringCreateWithCharactersNoCopy(v10, a2, v11, (CFAllocatorRef)*MEMORY[0x189604DC8]);
  CFIndex v14 = CFStringCreateWithCharactersNoCopy(v10, a4, (uint64_t)a3 >> 1, v12);
  v18.location = 0LL;
  v18.length = v11;
  CFComparisonResult v15 = CFStringCompareWithOptions(v13, v14, v18, a5);
  if (v17[3])
  {
    if (v13) {
      CFRelease(v13);
    }
    if (v14) {
      CFRelease(v14);
    }
  }

  return v15;
}

void sub_1868108E0(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x1868107F4LL);
  }

  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__29(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__29(uint64_t a1)
{
}

void sub_186810C04(_Unwind_Exception *a1)
{
}

void sub_186810E80( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const __CFString *a18, uint64_t a19, uint64_t a20, const __CFString *a21)
{
  if (a2 == 1)
  {
    id v22 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v21 + 80) + 8LL) + 24LL) = 0;
    id v23 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v24 = *MEMORY[0x1896075F0];
    a18 = @"NSUnderlyingException";
    a19 = v24;
    a20 = (uint64_t)v22;
    a21 = @"Record fetch failed because fetching the record metadata hit an unhandled exception.";
    uint64_t v25 = [MEMORY[0x189603F68] dictionaryWithObjects:&a20 forKeys:&a18 count:2];
    *(void *)(*(void *)(*(void *)(v21 + 72) + 8) + 40) = [v23 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v25];
    objc_end_catch();
    JUMPOUT(0x186810E44LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_186813C2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_186814EB0(_Unwind_Exception *a1)
{
}

void sub_186814EDC(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x186814DBCLL);
  }

  JUMPOUT(0x186814ED4LL);
}

void sub_186815B60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void __Block_byref_object_copy__30(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__30(uint64_t a1)
{
}

LABEL_75:
  if (!*(_BYTE *)(*(void *)(*(void *)(v9 + 64) + 8LL) + 24LL)) {
    goto LABEL_139;
  }
  int v91 = *(void *)(v130 + 80);
  if ((v91 & 0x20) != 0)
  {
    [v124 addObject:@"NSCloudKitMirroringDelegateLastHistoryTokenKey"];
    int v91 = *(void *)(v130 + 80);
  }

  if ((v91 & 0xC) != 0 && *(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8LL) + 24LL))
  {
    if ((v91 & 4) == 0)
    {
      if ((v91 & 8) != 0)
      {
        if (![v2 count])
        {
          unint64_t v92 = [NSString stringWithUTF8String:"Asked to purge zone metadata (trying to recreate after the purge) without any zones from which to purge."];
          _NSCoreDataLog(17LL, v92, v93, v94, v95, v96, v97, v98, v122);
          uint64_t v99 = (os_log_s *)__pflogFaultLog;
          if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)uint64_t v160 = 0;
            _os_log_fault_impl( &dword_186681000,  v99,  OS_LOG_TYPE_FAULT,  "CoreData: Asked to purge zone metadata (trying to recreate after the purge) without any zones from which to purge.",  v160,  2u);
          }
        }

        uint64_t v137 = 0u;
        uint64_t v138 = 0u;
        uint64_t v135 = 0u;
        uint64_t v136 = 0u;
        unint64_t v100 = [v2 countByEnumeratingWithState:&v135 objects:v187 count:16];
        if (v100)
        {
          unint64_t v101 = *(void *)v136;
          while (1)
          {
            for (uint64_t j = 0LL; j != v100; ++j)
            {
              if (*(void *)v136 != v101) {
                objc_enumerationMutation(v2);
              }
              unint64_t v103 = *(void **)(*((void *)&v135 + 1) + 8 * j);
              if (!-[PFCloudKitMetadataPurger _purgeZoneRelatedObjectsInZoneWithID:inDatabaseWithScope:withOptions:inStore:usingContext:error:]( *(void *)(v130 + 56),  v103,  *(void *)(v130 + 80),  *(void *)(v130 + 32),  *(void **)(v130 + 48),  &v159))
              {
                unint64_t v106 = v130;
LABEL_96:
                *(_BYTE *)(*(void *)(*(void *)(v106 + 64) + 8LL) + 24LL) = 0;
                goto LABEL_101;
              }

              unint64_t v104 = +[NSCKRecordZoneMetadata zoneMetadataForZoneID:inDatabaseWithScope:forStore:inContext:createIfMissing:error:]( (uint64_t)&OBJC_CLASS___NSCKRecordZoneMetadata,  v103,  *(void *)(v130 + 88),  *(void *)(v130 + 32),  *(void **)(v130 + 48),  0,  (uint64_t)&v159);
              unint64_t v105 = v104;
              if (v104)
              {
                unint64_t v106 = v130;
                if (*(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8LL) + 24LL))
                {
                  if ((*(_BYTE *)(v130 + 80) & 1) != 0)
                  {
                    [*(id *)(v130 + 48) deleteObject:v104];
                  }

                  else
                  {
                    -[NSManagedObject setCurrentChangeToken:](v104, "setCurrentChangeToken:", 0LL);
                    -[NSManagedObject setHasRecordZone:](v105, "setHasRecordZone:", 0LL);
                    -[NSManagedObject setHasSubscription:](v105, "setHasSubscription:", 0LL);
                  }

                  unint64_t v106 = v130;
                }
              }

              else
              {
                unint64_t v106 = v130;
                if (v159) {
                  goto LABEL_96;
                }
              }

        uint64_t v70 = [NSString stringWithUTF8String:"Couldn't find sql for table '%@', did you check if it exists first?"];
        unint64_t v71 = [v60 tableName];
        _NSCoreDataLog(17LL, v70, v72, v73, v74, v75, v76, v77, v71);
        uint64_t v78 = (os_log_s *)__pflogFaultLog;
        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
        {
          uint64_t v131 = [v60 tableName];
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v131;
          _os_log_fault_impl( &dword_186681000,  v78,  OS_LOG_TYPE_FAULT,  "CoreData: Couldn't find sql for table '%@', did you check if it exists first?",  (uint8_t *)&buf,  0xCu);
        }

        v351 = 0LL;
LABEL_78:
        uint64_t v79 = (void *)[v60 name];
        uint64_t v80 = (objc_class *)objc_opt_class();
        if (([v79 isEqualToString:NSStringFromClass(v80)] & 1) == 0)
        {
          uint64_t v81 = (void *)[v60 name];
          __int128 v82 = (objc_class *)objc_opt_class();
          if (![v81 isEqualToString:NSStringFromClass(v82)])
          {
            uint64_t v122 = (void *)[v60 name];
            uint64_t v123 = (objc_class *)objc_opt_class();
            uint64_t v124 = *(void **)(v50 + 16);
            v388[0] = MEMORY[0x1895F87A8];
            v388[1] = 3221225472LL;
            v388[2] = __79__PFCloudKitMetadataModelMigrator_calculateMigrationStepsWithConnection_error___block_invoke;
            v388[3] = &unk_189EABB30;
            v388[4] = v50;
            v388[5] = v60;
            v388[6] = &v401;
            v388[7] = &v407;
            [v124 performBlockAndWait:v388];
            [*(id *)(v50 + 24) addConstrainedEntityToPreflight:v60];
            uint64_t v125 = [v347 adapter];
            if (v125) {
              uint64_t v126 = -[NSSQLiteAdapter newCreateIndexStatementsForEntity:defaultIndicesOnly:](v125, (uint64_t)v60, 0);
            }
            else {
              uint64_t v126 = 0LL;
            }
            v386 = 0u;
            v387 = 0u;
            v384 = 0u;
            v385 = 0u;
            unint64_t v127 = [v126 countByEnumeratingWithState:&v384 objects:v423 count:16];
            if (v127)
            {
              unint64_t v128 = *(void *)v385;
              do
              {
                for (uint64_t j = 0LL; j != v127; ++j)
                {
                  if (*(void *)v385 != v128) {
                    objc_enumerationMutation(v126);
                  }
                  uint64_t v130 = *(void *)(v50 + 24);
                  if (v130)
                  {
                    [*(id *)(v130 + 8) addObject:*(void *)(*((void *)&v384 + 1) + 8 * j)];
                    *(_BYTE *)(v130 + 32) = 1;
                  }
                }

                unint64_t v127 = [v126 countByEnumeratingWithState:&v384 objects:v423 count:16];
              }

              while (v127);
            }

LABEL_125:
  if (*(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8LL) + 24LL))
  {
    if ((*(_BYTE *)(v130 + 80) & 0x10) == 0
      || ([v124 addObject:@"NSCloudKitMirroringDelegateCheckedCKIdentityDefaultsKey"],
          [v124 addObject:@"NSCloudKitMirroringDelegateCKIdentityRecordNameDefaultsKey"],
          *(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8LL) + 24LL)))
    {
      if ([v124 count])
      {
        uint64_t v117 = +[NSCKMetadataEntry entriesForKeys:fromStore:inManagedObjectContext:error:]( (uint64_t)NSCKMetadataEntry,  [v124 allObjects],  *(void *)(v130 + 32),  *(void **)(v130 + 48),  (uint64_t)&v159);
        if (v117)
        {
          uint64_t v133 = 0u;
          uint64_t v134 = 0u;
          uint64_t v131 = 0u;
          uint64_t v132 = 0u;
          uint64_t v118 = (void *)[v117 allValues];
          uint64_t v119 = [v118 countByEnumeratingWithState:&v131 objects:v186 count:16];
          if (v119)
          {
            uint64_t v120 = *(void *)v132;
            do
            {
              for (uint64_t m = 0LL; m != v119; ++m)
              {
                if (*(void *)v132 != v120) {
                  objc_enumerationMutation(v118);
                }
                [*(id *)(v130 + 48) deleteObject:*(void *)(*((void *)&v131 + 1) + 8 * m)];
              }

              uint64_t v119 = [v118 countByEnumeratingWithState:&v131 objects:v186 count:16];
            }

            while (v119);
          }
        }

        else
        {
          *(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8LL) + 24LL) = 0;
        }
      }
    }
  }

LABEL_139:
  if (!*(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8LL) + 24LL)
    || (*(_BYTE *)(*(void *)(*(void *)(v130 + 64) + 8) + 24) = [*(id *)(v130 + 48) save:&v159]) == 0)
  {
    *(void *)(*(void *)(*(void *)(v130 + 72) + 8LL) + 40LL) = v159;
  }
}

          int v97 = (os_log_s *)v39;
          uint64_t v98 = 2;
          goto LABEL_140;
        }

        if ((unint64_t)(v31 + 3007) >= 8)
        {
          switch(v31)
          {
            case -1206LL:
              unint64_t v49 = [NSString stringWithUTF8String:"NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorClientCertificateRequired and prob ably shouldn't have."];
              _NSCoreDataLog(17LL, v49, v50, v51, v52, v53, v54, v55, v195);
              uint64_t v39 = __pflogFaultLog;
              uint64_t v29 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
              if (!(_DWORD)v29) {
                goto LABEL_149;
              }
              *(_WORD *)buf = 0;
              int v40 = "CoreData: NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorClientCertificateRequired "
                    "and probably shouldn't have.";
              goto LABEL_139;
            case -1205LL:
              uint64_t v108 = [NSString stringWithUTF8String:"NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorClientCertificateRejected and pro bably shouldn't have."];
              _NSCoreDataLog(17LL, v108, v109, v110, v111, v112, v113, v114, v195);
              uint64_t v39 = __pflogFaultLog;
              uint64_t v29 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
              if (!(_DWORD)v29) {
                goto LABEL_149;
              }
              *(_WORD *)buf = 0;
              int v40 = "CoreData: NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorClientCertificateRejected "
                    "and probably shouldn't have.";
              goto LABEL_139;
            case -1204LL:
              uint64_t v115 = [NSString stringWithUTF8String:"NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorServerCertificateNotYetValid and probably shouldn't have."];
              _NSCoreDataLog(17LL, v115, v116, v117, v118, v119, v120, v121, v195);
              uint64_t v39 = __pflogFaultLog;
              uint64_t v29 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
              if (!(_DWORD)v29) {
                goto LABEL_149;
              }
              *(_WORD *)buf = 0;
              int v40 = "CoreData: NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorServerCertificateNotYetVal"
                    "id and probably shouldn't have.";
              goto LABEL_139;
            case -1203LL:
              unint64_t v101 = [NSString stringWithUTF8String:"NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorServerCertificateHasUnknownRoot a nd probably shouldn't have."];
              _NSCoreDataLog(17LL, v101, v102, v103, v104, v105, v106, v107, v195);
              uint64_t v39 = __pflogFaultLog;
              uint64_t v29 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
              if (!(_DWORD)v29) {
                goto LABEL_149;
              }
              *(_WORD *)buf = 0;
              int v40 = "CoreData: NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorServerCertificateHasUnknow"
                    "nRoot and probably shouldn't have.";
              goto LABEL_139;
            case -1202LL:
              uint64_t v122 = [NSString stringWithUTF8String:"NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorServerCertificateUntrusted and pr obably shouldn't have."];
              _NSCoreDataLog(17LL, v122, v123, v124, v125, v126, v127, v128, v195);
              uint64_t v39 = __pflogFaultLog;
              uint64_t v29 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
              if (!(_DWORD)v29) {
                goto LABEL_149;
              }
              *(_WORD *)buf = 0;
              int v40 = "CoreData: NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorServerCertificateUntrusted"
                    " and probably shouldn't have.";
              goto LABEL_139;
            case -1201LL:
              uint64_t v129 = [NSString stringWithUTF8String:"NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorServerCertificateHasBadDate and p robably shouldn't have."];
              _NSCoreDataLog(17LL, v129, v130, v131, v132, v133, v134, v135, v195);
              uint64_t v39 = __pflogFaultLog;
              uint64_t v29 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
              if (!(_DWORD)v29) {
                goto LABEL_149;
              }
              *(_WORD *)buf = 0;
              int v40 = "CoreData: NSCloudKitMirroringDelegate recieved NSURLErrorDomain:NSURLErrorServerCertificateHasBadDat"
                    "e and probably shouldn't have.";
              goto LABEL_139;
            case -1200LL:
              goto LABEL_89;
            default:
              if (v31 == -2000) {
                goto LABEL_89;
              }
LABEL_100:
              unint64_t v90 = [NSString stringWithUTF8String:"NSCloudKitMirroringDelegate was handed a scary NRULErrorDomain error (of some code that's not alre ady in the switch) that it probably shouldn't have been: %@"];
              _NSCoreDataLog(17LL, v90, v91, v92, v93, v94, v95, v96, (uint64_t)a2);
              unint64_t v71 = __pflogFaultLog;
              uint64_t v29 = os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT);
              if (!(_DWORD)v29) {
                goto LABEL_149;
              }
              *(_DWORD *)buf = 138412290;
              unint64_t v206 = a2;
              int v40 = "CoreData: NSCloudKitMirroringDelegate was handed a scary NRULErrorDomain error (of some code that's "
                    "not already in the switch) that it probably shouldn't have been: %@";
              break;
          }

void sub_186816E8C(_Unwind_Exception *a1)
{
}

void sub_18681748C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_186818218( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_1868188E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_186819378( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void *bufferResultSetRealloc(void *ptr, unint64_t *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (((*a2 + 7) & 0xFFFFFFFFFFFFFFF8LL) <= 0x4000) {
    unint64_t v4 = 0x4000LL;
  }
  else {
    unint64_t v4 = (*a2 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  }
  uint64_t v5 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v5 = malloc_default_zone();
  }
  BOOL result = malloc_zone_realloc(v5, ptr, v4);
  if (!result)
  {
    uint64_t v7 = [NSString stringWithUTF8String:"bufferResultSetRealloc failed to realloc buffer to %ld bytes"];
    _NSCoreDataLog(17LL, v7, v8, v9, v10, v11, v12, v13, v4);
    CFIndex v14 = (os_log_s *)__pflogFaultLog;
    if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134217984;
      unint64_t v17 = v4;
      _os_log_fault_impl( &dword_186681000,  v14,  OS_LOG_TYPE_FAULT,  "CoreData: bufferResultSetRealloc failed to realloc buffer to %ld bytes",  buf,  0xCu);
    }

    id v15 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  *MEMORY[0x189603B38],  134183LL,  (uint64_t)@"realloc failed",  0LL);
    objc_exception_throw(v15);
  }

  *a2 = v4;
  return result;
}

void fetchResultSetReallocCurrentRow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  if ((v3 & 0x80000000) != 0) {
    unint64_t v4 = 0LL;
  }
  else {
    unint64_t v4 = (const void *)(*(void *)(*(void *)(a1 + 64) + 8 * v3) + *(void *)(a1 + 32));
  }
  size_t v5 = *(void *)(a1 + 88) - (void)v4;
  unsigned int v6 = (a2 + v5 + 7) & 0xFFFFFFF8;
  if (v6 >= 0x3BFF) {
    size_t v7 = v6 + 15359;
  }
  else {
    size_t v7 = 15359LL;
  }
  *(_DWORD *)(a1 + 16) = v7;
  if (!(_DWORD)v3 && !*(void *)(a1 + 32))
  {
    id v16 = **(void ***)(a1 + 64);
    uint64_t v19 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if ((*(_BYTE *)(a1 + 48) & 4) != 0)
    {
      if (!_PF_Private_Malloc_Zone) {
        uint64_t v19 = malloc_default_zone();
      }
      uint64_t v20 = malloc_zone_calloc(v19, 1uLL, v7);
    }

    else
    {
      if (!_PF_Private_Malloc_Zone) {
        uint64_t v19 = malloc_default_zone();
      }
      uint64_t v20 = malloc_zone_malloc(v19, v7);
    }

    LODWORD(v_Block_object_dispose((const void *)(v13 - 112), 8) = 0;
    *(void *)(a1 + 80) = v20;
    **(void **)(a1 + 64) = v20;
    uint64_t v21 = *(void *)(a1 + 80);
    **(void **)(a1 + 72) = v7;
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v13 - 112), 8) = v21;
    *(_DWORD *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0LL;
    goto LABEL_30;
  }

  uint64_t v8 = *(unsigned int *)(a1 + 20);
  uint64_t v9 = (v8 + 1);
  *(_DWORD *)(a1 + 20) = v9;
  uint64_t v10 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v10 = malloc_default_zone();
  }
  uint64_t v11 = malloc_zone_realloc(v10, *(void **)(a1 + 64), 8LL * (v8 + 2));
  *(void *)(a1 + 64) = v11;
  v11[v9] = 0LL;
  uint64_t v12 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if ((*(_BYTE *)(a1 + 48) & 4) != 0)
  {
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v12 = malloc_default_zone();
    }
    uint64_t v13 = malloc_zone_calloc(v12, 1uLL, v7);
  }

  else
  {
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v12 = malloc_default_zone();
    }
    uint64_t v13 = malloc_zone_malloc(v12, v7);
  }

  *(void *)(a1 + 80) = v13;
  *(void *)(*(void *)(a1 + 64) + 8 * v_Block_object_dispose((const void *)(v13 - 112), 8) = v13;
  CFIndex v14 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    CFIndex v14 = malloc_default_zone();
  }
  id v15 = malloc_zone_realloc(v14, *(void **)(a1 + 72), 8LL * (v8 + 2));
  id v16 = 0LL;
  unint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  *(void *)(a1 + 72) = v15;
  v15[v9] = 0LL;
  v15[v8] = v7;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v13 - 112), 8) = *(void *)(a1 + 80);
  *(_DWORD *)(a1 + 24) = v8;
  *(void *)(a1 + 32) = 0LL;
  if ((v8 & 0x80000000) == 0)
  {
LABEL_30:
    uint64_t v18 = *(void **)(*(void *)(a1 + 64) + 8LL * v8);
    unint64_t v17 = v16;
  }

  memcpy(v18, v4, v5);
  *(void *)(a1 + 88) += v5;
  if (v17)
  {
    id v22 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      id v22 = malloc_default_zone();
    }
    malloc_zone_free(v22, v17);
  }

void *bufferResultSetAllocateInitialize(unint64_t a1, uint64_t a2)
{
  if (a1 <= 0x800) {
    size_t v2 = 0x4000LL;
  }
  else {
    size_t v2 = a1;
  }
  unsigned int v3 = *(_DWORD *)(a2 + 72) & 0x20;
  unint64_t v4 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    unint64_t v4 = malloc_default_zone();
  }
  size_t v5 = malloc_zone_calloc(v4, 1uLL, 0x50uLL);
  v5[2] = v2;
  *((_DWORD *)v5 + 6) = 512;
  *((_DWORD *)v5 + _Block_object_dispose((const void *)(v13 - 112), 8) = 1;
  unsigned int v6 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    unsigned int v6 = malloc_default_zone();
  }
  size_t v7 = malloc_zone_malloc(v6, 0x1000uLL);
  void v5[6] = v7;
  v7[511] = 0LL;
  uint64_t v8 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (v3)
  {
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v8 = malloc_default_zone();
    }
    uint64_t v9 = malloc_zone_calloc(v8, 1uLL, v2);
  }

  else
  {
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v8 = malloc_default_zone();
    }
    uint64_t v9 = malloc_zone_malloc(v8, v2);
  }

  v5[8] = v9;
  *(void *)void v5[6] = v9;
  uint64_t v10 = (void *)v5[8];
  void *v10 = 0LL;
  v5[9] = v10 + 1;
  *((_DWORD *)v5 + 9) = 0;
  uint64_t v11 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v11 = malloc_default_zone();
  }
  uint64_t v12 = malloc_zone_calloc(v11, 1uLL, 0x800uLL);
  void v5[7] = v12;
  v12[511] = 0;
  _DWORD *v12 = 0;
  *((_DWORD *)v5 + 10) = v5[5] & 0xFFFFFFFB | (v3 >> 3);
  *(_DWORD *)size_t v5 = 0;
  return v5;
}

void *bufferResultSetAllocateWithVMMemory(unint64_t a1, int a2)
{
  if (a1 <= 0x800) {
    vm_size_t v3 = 0xFFFFLL;
  }
  else {
    vm_size_t v3 = a1;
  }
  unint64_t v4 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    unint64_t v4 = malloc_default_zone();
  }
  size_t v5 = malloc_zone_calloc(v4, 1uLL, 0x50uLL);
  v5[2] = v3;
  *((_DWORD *)v5 + 6) = 2;
  *((_DWORD *)v5 + _Block_object_dispose((const void *)(v13 - 112), 8) = 1;
  unsigned int v6 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    unsigned int v6 = malloc_default_zone();
  }
  size_t v7 = malloc_zone_malloc(v6, 0x10uLL);
  void v5[6] = v7;
  v7[1] = 0LL;
  uint64_t v8 = (vm_map_t *)MEMORY[0x1895FBBE0];
  if (a2) {
    int v9 = 754974723;
  }
  else {
    int v9 = 754974721;
  }
  if (vm_allocate(*MEMORY[0x1895FBBE0], &address, v3, v9)
    || (vm_address_t v16 = address,
        v5[8] = address,
        *(void *)void v5[6] = v16,
        unint64_t v17 = (void *)v5[8],
        v5[9] = v17,
        *unint64_t v17 = 0LL,
        vm_address_t address = 0LL,
        vm_allocate(*v8, &address, 0x800uLL, 754974721)))
  {
    _NSCoreDataLog( 1LL,  (uint64_t)@"*** vm_allocate(size=%lld) failed (error code=%d)\n",  v10,  v11,  v12,  v13,  v14,  v15,  v3);
    return 0LL;
  }

  else
  {
    uint64_t v19 = (_DWORD *)address;
    void v5[7] = address;
    v19[511] = 0;
    _DWORD *v19 = 0;
    *((_DWORD *)v5 + 7) = 512;
    int v20 = *((_DWORD *)v5 + 10);
    *((_DWORD *)v5 + 10) = v20 | 8;
    if (a2)
    {
      *((_DWORD *)v5 + 10) = v20 | 0x18;
      bufferResultSetNonPurgeable((uint64_t)v5);
    }

    *((_DWORD *)v5 + 9) = 0;
    *(_DWORD *)size_t v5 = 0;
    v5[9] += 8LL;
  }

  return v5;
}

BOOL bufferResultSetNonPurgeable(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 40) & 0x10) == 0) {
    return 0LL;
  }
  int v11 = 0;
  int v3 = MEMORY[0x186E3F160](*MEMORY[0x1895FBBE0], *(void *)(a1 + 64), 0LL, &v11);
  BOOL v1 = v3 == 0;
  if (v3) {
    _NSCoreDataLog( 1LL,  (uint64_t)@"%@ bufferResultSetNonPurgeable failed to set vm buffer as non-purgeable: %d",  v4,  v5,  v6,  v7,  v8,  v9,  a1);
  }
  else {
    *(_DWORD *)(a1 + 40) &= ~0x20u;
  }
  return v1;
}

void *bufferResultSetAllocateWithBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v4 = malloc_default_zone();
  }
  uint64_t v5 = malloc_zone_calloc(v4, 1uLL, 0x50uLL);
  v5[2] = a1;
  *((_DWORD *)v5 + 6) = 2;
  *((_DWORD *)v5 + _Block_object_dispose((const void *)(v13 - 112), 8) = 1;
  uint64_t v6 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v6 = malloc_default_zone();
  }
  uint64_t v7 = malloc_zone_malloc(v6, 0x10uLL);
  void v5[6] = v7;
  v7[1] = 0LL;
  v5[8] = a2;
  *(void *)void v5[6] = a2;
  uint64_t v8 = (_DWORD *)v5[8];
  v5[9] = v8;
  *((_DWORD *)v5 + 9) = 0;
  *(_DWORD *)uint64_t v5 = *v8;
  return v5;
}

void bufferResultSetDeallocate(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((_DWORD)v2)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = 8 * v2;
    uint64_t v5 = (unsigned int *)MEMORY[0x1895FBBE0];
    do
    {
      if ((*(_BYTE *)(a1 + 40) & 8) != 0)
      {
        MEMORY[0x186E3F154](*v5, *(void *)(a1 + 64), *(void *)(a1 + 16));
      }

      else
      {
        uint64_t v6 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
        if (!_PF_Private_Malloc_Zone) {
          uint64_t v6 = malloc_default_zone();
        }
        malloc_zone_free(v6, *(void **)(*(void *)(a1 + 48) + v3));
      }

      v3 += 8LL;
    }

    while (v4 != v3);
  }

  uint64_t v7 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v7 = malloc_default_zone();
  }
  malloc_zone_free(v7, *(void **)(a1 + 48));
  if ((*(_BYTE *)(a1 + 40) & 8) == 0 && *(_DWORD *)(a1 + 28))
  {
    uint64_t v8 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      uint64_t v8 = malloc_default_zone();
    }
    malloc_zone_free(v8, *(void **)(a1 + 56));
  }

  uint64_t v9 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v9 = malloc_default_zone();
  }
  malloc_zone_free(v9, (void *)a1);
}

void *bufferResultSetIngestRow(uint64_t a1, const void *a2, size_t a3)
{
  v99[1] = *MEMORY[0x1895F89C0];
  unint64_t v5 = (a3 & 7) + a3;
  unint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = v6 >> 1;
  size_t v8 = v5 + 8;
  uint64_t v9 = *(_BYTE **)(a1 + 72);
  uint64_t v10 = *(unsigned int **)(a1 + 64);
  int64_t v11 = v9 - (_BYTE *)v10;
  if (v5 >= v6 >> 1) {
    size_t v12 = v5 + 8;
  }
  else {
    size_t v12 = (a3 & 7) + a3;
  }
  size_t v13 = 4 * *v10;
  unsigned int v14 = v13 + 4;
  if (v5 < v6 >> 1 && v6 - v11 >= v5 + v14)
  {
    uint64_t v18 = (char *)((unint64_t)(v9 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  }

  else if ((*(_BYTE *)(a1 + 40) & 8) != 0)
  {
    unint64_t v19 = v12 + v13;
    if (v6 <= v12 + v13)
    {
      uint64_t v20 = v19 + v6;
    }

    else if (v6 <= 0x7EFF81 || v19 >= 0x7EFF81)
    {
      uint64_t v20 = 2 * v6;
    }

    else
    {
      uint64_t v20 = v6 + 8322945;
    }

    int v27 = getpagesize();
    vm_size_t v28 = (v20 + v27 - 1) / (unint64_t)v27 * v27;
    uint64_t v29 = (vm_map_t *)MEMORY[0x1895FBBE0];
    if (vm_allocate(*MEMORY[0x1895FBBE0], (vm_address_t *)address, v28, 754974721))
    {
      vm_size_t v30 = v12 + v14 + *(void *)(a1 + 16);
      uint64_t v31 = vm_allocate(*v29, (vm_address_t *)address, v30, 754974721);
      if ((_DWORD)v31)
      {
        uint64_t v77 = v31;
        _NSCoreDataLog( 1LL,  (uint64_t)@"*** vm_allocate(size=%lld) failed (error code=%d)\n",  v32,  v33,  v34,  v35,  v36,  v37,  v30);
        uint64_t v78 = *MEMORY[0x189603A58];
        uint64_t v98 = @"VMErrorCode";
        v99[0] = [MEMORY[0x189607968] numberWithInt:v77];
        uint64_t v79 = (void *)[MEMORY[0x189603F68] dictionaryWithObjects:v99 forKeys:&v98 count:1];
        __int128 v76 = @"Unable to allocate VM Memory";
        uint64_t v75 = v78;
LABEL_81:
        id v95 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)&OBJC_CLASS____NSCoreDataException,  v75,  134183LL,  (uint64_t)v76,  v79);
        objc_exception_throw(v95);
        return (void *)bufferResultSetPack();
      }
    }

    vm_copy(*v29, *(void *)(a1 + 64), *(void *)(a1 + 16), *(vm_address_t *)address);
    MEMORY[0x186E3F154](*v29, *(void *)(a1 + 64), *(void *)(a1 + 16));
    uint64_t v38 = *(void *)address;
    *(void *)(a1 + 64) = *(void *)address;
    *(void *)(*(void *)(a1 + 48) + 8LL * (*(_DWORD *)(a1 + 32) - 1)) = v38;
    uint64_t v10 = *(unsigned int **)(a1 + 64);
    uint64_t v18 = (char *)v10 + v11;
    *(void *)(a1 + 72) = (char *)v10 + v11;
    *(_DWORD *)a1 = *v10;
    *(void *)(a1 + 16) = v28;
  }

  else
  {
    memcpy(v9, *(const void **)(a1 + 56), v13);
    *(_DWORD *)(*(void *)(a1 + 64) + 4LL) = v11;
    bzero(*(void **)(a1 + 56), v13);
    BOOL v15 = v5 >= v7 && v11 == 8;
    if (v15 && v12 > *(void *)(a1 + 16))
    {
      vm_address_t v16 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        vm_address_t v16 = malloc_default_zone();
      }
      unint64_t v17 = malloc_zone_realloc(v16, *(void **)(a1 + 64), v12 + 8);
      *(void *)(a1 + 64) = v17;
      *(void *)(*(void *)(a1 + 48) + 8LL * (*(_DWORD *)(a1 + 32) - 1)) = v17;
      uint64_t v10 = *(unsigned int **)(a1 + 64);
      *(void *)(a1 + 72) = v10;
      if (v10)
      {
        *(void *)uint64_t v10 = 0LL;
        uint64_t v18 = (char *)(v10 + 2);
        *(void *)(a1 + 72) = v10 + 2;
        goto LABEL_43;
      }

      uint64_t v88 = [NSString stringWithUTF8String:"PF_REALLOC failed to allocate buffer to %ld bytes"];
      _NSCoreDataLog(17LL, v88, v89, v90, v91, v92, v93, v94, v12 + 8);
      uint64_t v87 = (os_log_s *)__pflogFaultLog;
      if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)vm_address_t address = 134217984;
        *(void *)&address[4] = v12 + 8;
        goto LABEL_78;
      }

      goto LABEL_79;
    }

    int v21 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v21 + 1;
    if (v5 < v7) {
      size_t v8 = *(void *)(a1 + 16);
    }
    unsigned int v22 = *(_DWORD *)(a1 + 24);
    if (v21 + 1 >= v22)
    {
      id v23 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
      if (!_PF_Private_Malloc_Zone) {
        id v23 = malloc_default_zone();
      }
      uint64_t v24 = malloc_zone_realloc(v23, *(void **)(a1 + 48), 8LL * (v22 + 512));
      if (!v24)
      {
        uint64_t v80 = [NSString stringWithUTF8String:"PF_REALLOC failed to allocate buffer to %ld bytes"];
        _NSCoreDataLog(17LL, v80, v81, v82, v83, v84, v85, v86, 8LL * (v22 + 512));
        uint64_t v87 = (os_log_s *)__pflogFaultLog;
        if (os_log_type_enabled((os_log_t)__pflogFaultLog, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)vm_address_t address = 134217984;
          *(void *)&address[4] = 8LL * (v22 + 512);
LABEL_78:
          _os_log_fault_impl( &dword_186681000,  v87,  OS_LOG_TYPE_FAULT,  "CoreData: PF_REALLOC failed to allocate buffer to %ld bytes",  address,  0xCu);
        }

void bufferResultSetPack(uint64_t a1)
{
  v31[1] = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(a1 + 72);
  uint64_t v3 = *(unsigned int **)(a1 + 64);
  int v4 = (_DWORD)v2 - (_DWORD)v3;
  size_t v5 = 4LL * *v3;
  memcpy(v2, *(const void **)(a1 + 56), v5);
  uint64_t v6 = *(void *)(a1 + 64);
  *(_DWORD *)(v6 + 4) = v4;
  if ((*(_BYTE *)(a1 + 40) & 8) != 0)
  {
    size_t v8 = *(void *)(a1 + 72) + v5;
    *(void *)(a1 + 72) = v8;
    uint64_t v9 = v8 - v6;
    int v10 = getpagesize();
    unint64_t v11 = (v9 + v10 - 1) / (unint64_t)v10 * v10;
    size_t v12 = (unsigned int *)MEMORY[0x1895FBBE0];
    if (*(void *)(a1 + 16) > v11
      && (*(void *)(a1 + 72) = v8 + v11 - v9, uint64_t v13 = MEMORY[0x186E3F154](*v12), (_DWORD)v13))
    {
      uint64_t v27 = v13;
      _NSCoreDataLog( 1LL,  (uint64_t)@"*** vm_deallocate(size=%lld) oldSize= %lld, failed (error code=%d)\n",  v14,  v15,  v16,  v17,  v18,  v19,  v9);
      uint64_t v28 = *MEMORY[0x189603A58];
      vm_size_t v30 = @"VMErrorCode";
      v31[0] = [MEMORY[0x189607968] numberWithInt:v27];
      id v29 = +[_NSCoreDataException exceptionWithName:code:reason:userInfo:]( (uint64_t)_NSCoreDataException,  v28,  134183,  (uint64_t)@"Unable to deallocate VM Memory",  (void *)[MEMORY[0x189603F68] dictionaryWithObjects:v31 forKeys:&v30 count:1]);
      objc_exception_throw(v29);
      bufferResultSetPurgeable();
    }

    else
    {
      uint64_t v20 = 4LL * *(unsigned int *)(a1 + 28);
      if (MEMORY[0x186E3F154](*v12, *(void *)(a1 + 56), v20)) {
        _NSCoreDataLog( 2LL,  (uint64_t)@"*** vm_deallocate(size=%lld), failed (error code=%d)\n",  v21,  v22,  v23,  v24,  v25,  v26,  v20);
      }
      *(void *)(a1 + 16) = v9;
    }
  }

  else
  {
    *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v13 - 112), 8) = 0;
    unint64_t v7 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone) {
      unint64_t v7 = malloc_default_zone();
    }
    malloc_zone_free(v7, *(void **)(a1 + 56));
  }

BOOL bufferResultSetPurgeable(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 40) & 0x50) != 0x10) {
    return 0LL;
  }
  int v11 = 1;
  int v2 = MEMORY[0x186E3F160](*MEMORY[0x1895FBBE0], *(void *)(a1 + 64), 0LL, &v11);
  BOOL v9 = v2 == 0;
  if (v2) {
    _NSCoreDataLog( 1LL,  (uint64_t)@"%@ bufferResultSetPurgeable failed to set vm buffer as purgeable: %d",  v3,  v4,  v5,  v6,  v7,  v8,  a1);
  }
  else {
    *(_DWORD *)(a1 + 40) |= 0x20u;
  }
  return v9;
}

uint64_t _prepareObjectIDsOnBackgroundThread(uint64_t a1)
{
  v66[128] = *MEMORY[0x1895F89C0];
  int v2 = *(uint64_t **)(a1 + 24);
  uint64_t v3 = *v2;
  if (*v2) {
    uint64_t v4 = *(void *)(v3 + 136);
  }
  else {
    uint64_t v4 = 0LL;
  }
  uint64_t v5 = (void *)v2[1];
  id v56 = (id)v2[2];
  uint64_t v6 = (unsigned __int8 *)v2[3];
  PF_FREE_OBJECT_ARRAY(v2);
  *(void *)(a1 + 24) = 0LL;
  if (v3)
  {
    uint64_t v7 = (void *)[*(id *)(v3 + 8) objectIDFactoryForSQLEntity:*(void *)(v4 + 40)];
    uint64_t v53 = *(void *)(v3 + 112);
  }

  else
  {
    uint64_t v7 = 0LL;
    uint64_t v53 = 0LL;
  }

  int v60 = *(_DWORD *)(v4 + 72);
  unsigned __int8 v65 = 1;
  int v61 = v60 & 0x1C;
  uint64_t v51 = v6;
  uint64_t v52 = v5;
  uint64_t v58 = v3;
  if (v61 == 4)
  {
    uint64_t v8 = 0LL;
    uint64_t v57 = 0LL;
  }

  else
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
    int v10 = PF_CALLOC_SCANNED_BYTES(0x28uLL);
    void *v10 = v3;
    v10[1] = Mutable;
    uint64_t v57 = Mutable;
    id v10[2] = v56;
    v10[3] = &v65;
    v10[4] = 0LL;
    uint64_t v8 = -[_PFTask initWithFunction:withArgument:andPriority:]( objc_alloc(&OBJC_CLASS____PFTask),  "initWithFunction:withArgument:andPriority:",  _prepareFaultsOnBackgroundThread,  v10,  2LL);
  }

  int v11 = 0LL;
  uint64_t v49 = (pthread_cond_t *)(a1 + 96);
  uint64_t v50 = (pthread_mutex_t *)(a1 + 32);
  uint64_t v48 = v8;
  p_condition = &v8->condition;
  p_locuint64_t k = &v8->lock;
LABEL_9:
  uint64_t v13 = v51;
  size_t v12 = v52;
  uint64_t v15 = v49;
  uint64_t v14 = v50;
  do
  {
    while (1)
    {
      pthread_mutex_lock(v14);
      do
      {
        uint64_t v16 = [v12 count];
        if (v16 > 0)
        {
          objc_msgSend(v12, "getObjects:range:", v66, 0, v16);
          [v12 removeAllObjects];
          atomic_load(v13);
          uint64_t v21 = pthread_mutex_unlock(v14);
          uint64_t v22 = 0LL;
          uint64_t v62 = v16;
          while (1)
          {
            uint64_t v23 = v66[v22];
            unsigned int v24 = *(_DWORD *)(v23 + 4) <= 0x40000000u ? *(_DWORD *)(v23 + 4) : 0;
            MEMORY[0x1895F8858](v21);
            uint64_t v27 = (char *)&v47 - v26;
            uint64_t v63 = v28;
            if (v24 > 0x200) {
              uint64_t v27 = (char *)NSAllocateScannedUncollectable();
            }
            else {
              bzero((char *)&v47 - v26, 8LL * v25);
            }
            uint64_t v29 = v27 ? v24 : 0LL;
            uint64_t v30 = **(void **)(v23 + 64);
            if ((v60 & 1) != 0) {
              break;
            }
            uint64_t v64 = v7;
            uint64_t v29 = 0LL;
LABEL_52:
            int v40 = -[_PFArray initWithObjects:count:andFlags:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:",  v27,  v29,  30LL);
            if (v24 >= 0x201) {
              NSZoneFree(0LL, v27);
            }
            fetchResultSetDeallocate(v23);
            uint64_t v41 = v62;
            if (v61 == 4)
            {
              [v56 addObject:v40];
            }

            else
            {
              uint64_t v42 = p_lock;
              pthread_mutex_lock(p_lock);
              CFRetain(v40);
              CFArrayAppendValue(v57, v40);
              pthread_mutex_unlock(v42);
              pthread_cond_signal(p_condition);
            }

            uint64_t v7 = v64;
            if (++v22 == v41) {
              goto LABEL_9;
            }
          }

          uint64_t v31 = _sqlEntityForEntityID(v53, *(unsigned int *)(v30 + 8));
          if (v31 != v11) {
            uint64_t v7 = 0LL;
          }
          if (v58)
          {
            uint64_t v32 = v31;
            if (v31 != v11) {
              uint64_t v7 = (void *)[*(id *)(v58 + 8) objectIDFactoryForSQLEntity:v31];
            }
          }

          else
          {
            uint64_t v32 = v31;
          }

          [v7 allocateBatch:v27 count:v29];
          int v11 = v32;
LABEL_40:
          uint64_t v64 = v7;
          if ((int)v29 >= 1)
          {
            unint64_t v59 = v11;
            for (uint64_t i = 0LL; i != v29; ++i)
            {
              while ((*(_DWORD *)v30 & 0x80000000) != 0)
              {
                uint64_t v34 = *(unsigned int *)(v30 + 4);
                if ((v34 & 0x80000000) != 0) {
                  uint64_t v30 = 0LL;
                }
                else {
                  uint64_t v30 = *(void *)(*(void *)(v23 + 64) + 8 * v34) + *(void *)(v30 + 16);
                }
              }

              uint64_t v35 = *(void **)&v27[8 * i];
              unint64_t v36 = _PFSetPrimaryKey((unint64_t)v35, *(void *)(v30 + 24));
              if (v35 != (void *)v36)
              {
                unint64_t v37 = v36;

                *(void *)&v27[8 * i] = v37;
              }

              uint64_t v38 = *(unsigned int *)(v30 + 4);
              if ((v38 & 0x80000000) != 0) {
                break;
              }
              uint64_t v39 = *(void *)(*(void *)(v23 + 64) + 8 * v38);
              if (!v39) {
                break;
              }
              uint64_t v30 = v39 + *(void *)(v30 + 16);
            }

            int v11 = v59;
          }

          goto LABEL_52;
        }

        unsigned __int8 v17 = atomic_load(v13);
        if ((v17 & 1) != 0) {
          pthread_cond_wait(v15, v14);
        }
        unsigned __int8 v18 = atomic_load(v13);
      }

      while ((v18 & 1) != 0);
      unsigned __int8 v19 = atomic_load(v13);
      if (!v16 && (v19 & 1) == 0) {
        break;
      }
      pthread_mutex_unlock(v14);
    }

    uint64_t v20 = [v12 count];
    pthread_mutex_unlock(v14);
  }

  while (v20);
  if (v61 != 4)
  {
    atomic_store(0, &v65);
    __dmb(0xBu);
    uint64_t v43 = p_lock;
    pthread_mutex_lock(p_lock);
    uint64_t v44 = v48;
    uint64_t v45 = p_condition;
    if (!v48->isFinishedFlag)
    {
      pthread_cond_signal(p_condition);
      while (!v44->isFinishedFlag)
        pthread_cond_wait(v45, v43);
    }

    pthread_mutex_unlock(v43);

    if (v57) {
      CFRelease(v57);
    }
  }

  return 0LL;
}

uint64_t _prepareRowsOnBackgroundThreads(uint64_t a1)
{
  values[128] = *(void **)MEMORY[0x1895F89C0];
  int v2 = *(uint64_t **)(a1 + 24);
  uint64_t v3 = *v2;
  if (*v2) {
    uint64_t v4 = *(void *)(v3 + 136);
  }
  else {
    uint64_t v4 = 0LL;
  }
  uint64_t v53 = (__CFArray *)v2[2];
  uint64_t v5 = v2[4];
  uint64_t v49 = (unsigned __int8 *)v2[3];
  uint64_t v50 = (const __CFArray *)v2[1];
  int v55 = (*(_DWORD *)(v4 + 72) >> 2) & 7;
  char v6 = [*(id *)(v4 + 8) _disablePersistentStoreResultCaching];
  PF_FREE_OBJECT_ARRAY(*(void **)(a1 + 24));
  *(void *)(a1 + 24) = 0LL;
  if (v3) {
    uint64_t v58 = (void *)[*(id *)(v3 + 8) objectIDFactoryForSQLEntity:*(void *)(v4 + 40)];
  }
  else {
    uint64_t v58 = 0LL;
  }
  uint64_t v56 = v4;
  int v7 = *(_DWORD *)(v4 + 72);
  unsigned __int8 v64 = 1;
  __dmb(0xBu);
  uint64_t v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  unsigned int v61 = v55 - 1;
  if ((v55 - 1) >= 2)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(v8, 0LL, 0LL);
    int v10 = PF_CALLOC_SCANNED_BYTES(0x28uLL);
    void *v10 = v3;
    v10[1] = Mutable;
    theArray = Mutable;
    id v10[2] = v53;
    v10[3] = &v64;
    v10[4] = v5;
    uint64_t v46 = -[_PFTask initWithFunction:withArgument:andPriority:]( objc_alloc(&OBJC_CLASS____PFTask),  "initWithFunction:withArgument:andPriority:",  _prepareFaultsOnBackgroundThread,  v10,  2LL);
  }

  else
  {
    uint64_t v46 = 0LL;
    theArray = 0LL;
  }

  char v63 = 1;
  if ((v6 & 1) != 0)
  {
    int v11 = 0LL;
    CFMutableArrayRef v12 = 0LL;
  }

  else
  {
    CFMutableArrayRef v12 = CFArrayCreateMutable(v8, 0LL, 0LL);
    uint64_t v13 = PF_CALLOC_SCANNED_BYTES(0x28uLL);
    *uint64_t v13 = v3;
    v13[1] = v12;
    void v13[2] = 0LL;
    v13[3] = &v63;
    int v11 = -[_PFTask initWithFunction:withArgument:andPriority:]( objc_alloc(&OBJC_CLASS____PFTask),  "initWithFunction:withArgument:andPriority:",  _prepareRowCacheOnBackgroundThread,  v13,  2LL);
  }

  uint64_t v14 = CFArrayCreateMutable(v8, 0LL, 0LL);
  uint64_t v15 = PF_CALLOC_SCANNED_BYTES(0x40uLL);
  *uint64_t v15 = v3;
  v15[1] = v14;
  id v15[2] = 0LL;
  void v15[3] = &v64;
  if ((v6 & 1) == 0)
  {
    void v15[4] = v11;
    v15[5] = v12;
    v15[6] = &v63;
  }

  uint64_t v44 = v11;
  CFMutableArrayRef v45 = v12;
  uint64_t v47 = (pthread_cond_t *)(a1 + 96);
  uint64_t v48 = (pthread_mutex_t *)(a1 + 32);
  p_condition = &v46->condition;
  p_locuint64_t k = &v46->lock;
  uint64_t v43 = -[_PFTask initWithFunction:withArgument:andPriority:]( objc_alloc(&OBJC_CLASS____PFTask),  "initWithFunction:withArgument:andPriority:",  _populateRowValuesOnBackgroundThread,  v15,  2LL);
  unint64_t v59 = &v43->condition;
  int v60 = &v43->lock;
  char v57 = v7;
  do
  {
LABEL_14:
    while (1)
    {
      pthread_mutex_lock(v48);
      do
      {
        CFIndex Count = CFArrayGetCount(v50);
        unint64_t v17 = Count;
        if (Count >= 1)
        {
          if (Count >= 128) {
            CFIndex v22 = 128LL;
          }
          else {
            CFIndex v22 = Count;
          }
          v66.location = 0LL;
          v66.length = v22;
          CFArrayGetValues(v50, v66, (const void **)values);
          if (v17 > 0x7F)
          {
            v67.location = 0LL;
            v67.length = v22;
            CFArrayReplaceValues(v50, v67, 0LL, 0LL);
          }

          else
          {
            CFArrayRemoveAllValues(v50);
          }

          atomic_load(v49);
          pthread_mutex_unlock(v48);
          uint64_t v23 = 0LL;
          CFIndex v62 = v22;
          while (1)
          {
            unsigned int v24 = values[v23];
            if (v24[1] <= 0x40000000u) {
              unsigned int v25 = v24[1];
            }
            else {
              unsigned int v25 = 0;
            }
            uint64_t v26 = PF_ALLOCATE_OBJECT_ARRAY((int)v25);
            if (v26) {
              uint64_t v27 = v25;
            }
            else {
              uint64_t v27 = 0LL;
            }
            uint64_t v28 = PF_ALLOCATE_OBJECT_ARRAY((int)v27);
            if (v28)
            {
              if ((v7 & 1) == 0) {
                goto LABEL_40;
              }
            }

            else
            {
              PF_FREE_OBJECT_ARRAY(v26);
              uint64_t v27 = 0LL;
              uint64_t v26 = 0LL;
              if ((v7 & 1) == 0)
              {
LABEL_40:
                uint64_t v29 = v14;
                uint64_t v30 = **((void **)v24 + 8);
                else {
                  uint64_t v27 = 0LL;
                }
                if ((int)v27 >= 1)
                {
                  for (uint64_t i = 0LL; i != v27; ++i)
                  {
                    while ((*(_DWORD *)v30 & 0x80000000) != 0)
                    {
                      uint64_t v32 = *(unsigned int *)(v30 + 4);
                      if ((v32 & 0x80000000) != 0) {
                        uint64_t v30 = 0LL;
                      }
                      else {
                        uint64_t v30 = *(void *)(*((void *)v24 + 8) + 8 * v32) + *(void *)(v30 + 16);
                      }
                    }

                    uint64_t v33 = (void *)*((void *)v26 + i);
                    unint64_t v34 = _PFSetPrimaryKey((unint64_t)v33, *(void *)(v30 + 24));
                    if (v33 != (void *)v34)
                    {
                      unint64_t v35 = v34;

                      *((void *)v26 + i) = v35;
                    }

                    uint64_t v36 = *(unsigned int *)(v30 + 4);
                    if ((v36 & 0x80000000) != 0) {
                      break;
                    }
                    uint64_t v37 = *(void *)(*((void *)v24 + 8) + 8 * v36);
                    if (!v37) {
                      break;
                    }
                    uint64_t v30 = v37 + *(void *)(v30 + 16);
                  }
                }

                uint64_t v14 = v29;
                if ((_DWORD)v27)
                {
                  if ((_DWORD)v27 == +[NSSQLRow newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:]( &OBJC_CLASS___NSSQLRow,  "newBatchRowAllocation:count:forSQLEntity:withOwnedObjectIDs:andTimestamp:",  v28,  v27,  *(void *)(v56 + 40),  v26,  *((double *)v24 + 1))) {
                    uint64_t v27 = v27;
                  }
                  else {
                    uint64_t v27 = 0LL;
                  }
                }

                LOBYTE(v7) = v57;
              }
            }

            uint64_t v38 = -[_PFArray initWithObjects:count:andFlags:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:",  v26,  v27,  (v55 == 1) | 8u);
            uint64_t v39 = -[_PFArray initWithObjects:count:andFlags:andContext:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:andContext:",  v28,  v27,  10LL,  0LL);
            int v40 = v39;
            if ((_DWORD)v27 && v38 && v39)
            {
              if (v61 >= 2)
              {
                pthread_mutex_lock(p_lock);
                CFRetain(v38);
                CFRetain(v40);
                CFArrayAppendValue(theArray, v38);
                CFArrayAppendValue(theArray, v40);
                pthread_mutex_unlock(p_lock);
                pthread_cond_signal(p_condition);
              }

              else
              {
                if (v55 == 1) {
                  uint64_t v41 = v38;
                }
                else {
                  uint64_t v41 = v39;
                }
                CFArrayAppendValue(v53, v41);
              }

              pthread_mutex_lock(v60);
              CFRetain(v40);
              CFArrayAppendValue(v14, v24);
              CFArrayAppendValue(v14, v40);
              pthread_mutex_unlock(v60);
              pthread_cond_signal(v59);
            }

            if (++v23 == v62) {
              goto LABEL_14;
            }
          }
        }

        unsigned __int8 v18 = atomic_load(v49);
        if ((v18 & 1) != 0) {
          pthread_cond_wait(v47, v48);
        }
        unsigned __int8 v19 = atomic_load(v49);
      }

      while ((v19 & 1) != 0);
      unsigned __int8 v20 = atomic_load(v49);
      if (!v17 && (v20 & 1) == 0) {
        break;
      }
      pthread_mutex_unlock(v48);
    }

    CFIndex v21 = CFArrayGetCount(v50);
    pthread_mutex_unlock(v48);
  }

  while (v21);
  atomic_store(0, &v64);
  __dmb(0xBu);
  if (v61 >= 2)
  {
    pthread_mutex_lock(p_lock);
    if (!v46->isFinishedFlag)
    {
      pthread_cond_signal(p_condition);
      while (!v46->isFinishedFlag)
        pthread_cond_wait(p_condition, p_lock);
    }

    pthread_mutex_unlock(p_lock);
  }

  pthread_mutex_lock(v60);
  if (!v43->isFinishedFlag)
  {
    pthread_cond_signal(v59);
    while (!v43->isFinishedFlag)
      pthread_cond_wait(v59, v60);
  }

  pthread_mutex_unlock(v60);
  if (v44)
  {
    pthread_mutex_lock(&v44->lock);
    if (!v44->isFinishedFlag)
    {
      pthread_cond_signal(&v44->condition);
      while (!v44->isFinishedFlag)
        pthread_cond_wait(&v44->condition, &v44->lock);
    }

    pthread_mutex_unlock(&v44->lock);
  }

  if (theArray) {
    CFRelease(theArray);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v45) {
    CFRelease(v45);
  }
  return 0LL;
}

uint64_t _prepareFaultsOnBackgroundThread(uint64_t a1)
{
  values[128] = *(void **)MEMORY[0x1895F89C0];
  int v2 = *(void **)(a1 + 24);
  uint64_t v3 = (void *)*v2;
  if (*v2) {
    uint64_t v4 = v3[17];
  }
  else {
    uint64_t v4 = 0LL;
  }
  uint64_t v36 = (void *)v2[2];
  uint64_t v27 = (unsigned __int8 *)v2[3];
  uint64_t v30 = (const __CFArray *)v2[1];
  theArray = (__CFArray *)v2[4];
  char v35 = [*(id *)(v4 + 8) _isAsyncRequest];
  PF_FREE_OBJECT_ARRAY(*(void **)(a1 + 24));
  *(void *)(a1 + 24) = 0LL;
  int v5 = *(_DWORD *)(v4 + 72);
  if (!v3)
  {
    char v6 = 0LL;
    goto LABEL_8;
  }

  char v6 = (void *)v3[4];
  if ((*(_DWORD *)(v4 + 72) & 0x1C) != 0xC)
  {
LABEL_8:
    uint64_t v34 = 0LL;
    goto LABEL_9;
  }

  uint64_t v34 = v3[16];
LABEL_9:
  uint64_t v32 = v4;
  char v33 = [*(id *)(v4 + 8) _disablePersistentStoreResultCaching];
  unint64_t v7 = 0LL;
  uint64_t v28 = (pthread_cond_t *)(a1 + 96);
  uint64_t v29 = (pthread_mutex_t *)(a1 + 32);
  char v8 = 1;
  do
  {
LABEL_10:
    while (2)
    {
      pthread_mutex_lock(v29);
      do
      {
        CFIndex Count = CFArrayGetCount(v30);
        unint64_t v10 = Count;
        if (Count >= 1)
        {
          if (Count >= 128) {
            CFIndex v15 = 128LL;
          }
          else {
            CFIndex v15 = Count;
          }
          v43.location = 0LL;
          v43.length = v15;
          CFArrayGetValues(v30, v43, (const void **)values);
          if (v10 > 0x7F)
          {
            v44.location = 0LL;
            v44.length = v15;
            CFArrayReplaceValues(v30, v44, 0LL, 0LL);
          }

          else
          {
            CFArrayRemoveAllValues(v30);
          }

          atomic_load(v27);
          pthread_mutex_unlock(v29);
          uint64_t v16 = 0LL;
          LODWORD(v17) = 0;
          do
          {
            CFIndex v18 = v15;
            unsigned __int8 v19 = values[v16];
            if ((v5 & 2) != 0)
            {
              unsigned __int8 v20 = 0LL;
            }

            else
            {
              uint64_t v17 = (int)v17 + 1LL;
              unsigned __int8 v20 = values[v17];
            }

            uint64_t v21 = [v19 count];
            v7 += v21;
            if (!((v7 < 0x2711 || (v8 & 1) == 0) | v35 & 1))
            {
              uint64_t v22 = [v6 persistentStoreCoordinator];
              if (v22) {
                uint64_t v23 = *(void *)(v22 + 96);
              }
              else {
                uint64_t v23 = 0LL;
              }
              _PFModelMapSlotForEntity(v23, (void *)[*(id *)(v32 + 40) entityDescription]);
              char v8 = 0;
            }

            unsigned int v24 = PF_ALLOCATE_OBJECT_ARRAY(v21);
            v37[0] = MEMORY[0x1895F87A8];
            v37[1] = 3221225472LL;
            v37[2] = ___prepareFaultsOnBackgroundThread_block_invoke;
            v37[3] = &unk_189EAA600;
            v37[7] = v20;
            v37[8] = v24;
            int v38 = v21;
            v37[4] = v6;
            v37[5] = v19;
            BOOL v39 = (v5 & 0x1C) == 12;
            BOOL v40 = (v5 & 2) == 0;
            char v41 = v33;
            void v37[6] = v34;
            ___prepareFaultsOnBackgroundThread_block_invoke((uint64_t)v37);
            unsigned int v25 = -[_PFArray initWithObjects:count:andFlags:andContext:]( objc_alloc(&OBJC_CLASS____PFArray),  "initWithObjects:count:andFlags:andContext:",  v24,  v21,  46LL,  v6);
            [v36 addObject:v25];

            if ((v5 & 2) == 0) {
              CFArrayAppendValue(theArray, v20);
            }
            if (v20) {
              CFRelease(v20);
            }
            if (v19) {
              CFRelease(v19);
            }
            LODWORD(v17) = v17 + 1;
            uint64_t v16 = (int)v17;
            CFIndex v15 = v18;
          }

          while (v18 > (int)v17);
          goto LABEL_10;
        }

        unsigned __int8 v11 = atomic_load(v27);
        if ((v11 & 1) != 0) {
          pthread_cond_wait(v28, v29);
        }
        unsigned __int8 v12 = atomic_load(v27);
      }

      while ((v12 & 1) != 0);
      unsigned __int8 v13 = atomic_load(v27);
      if (v10 || (v13 & 1) != 0)
      {
        pthread_mutex_unlock(v29);
        continue;
      }

      break;
    }

    CFIndex v14 = CFArrayGetCount(v30);
    pthread_mutex_unlock(v29);
  }

  while (v14);
  return 0LL;
}

uint64_t ___prepareFaultsOnBackgroundThread_block_invoke(uint64_t a1)
{
  uint64_t result = -[NSManagedObjectContext _batchRetainedObjects:forCount:withIDs:optionalHandler:withInlineStorage:]( *(void *)(a1 + 32),  *(void *)(a1 + 64),  *(unsigned int *)(a1 + 72),  (id *)[*(id *)(a1 + 40) _objectsPointer],  *(void *)(a1 + 48));
  if (*(_BYTE *)(a1 + 77))
  {
    if (!*(_BYTE *)(a1 + 78))
    {
      uint64_t result = [*(id *)(a1 + 56) _objectsPointer];
      if (*(_DWORD *)(a1 + 72))
      {
        uint64_t v3 = 0LL;
        while (1)
        {
          uint64_t v4 = *(void *)(*(void *)(a1 + 64) + 8 * v3);
          uint64_t v5 = *(void *)(result + 8 * v3);
          int v6 = *(_DWORD *)(v4 + 16);
          if ((v6 & 0x200) != 0) {
            break;
          }
          *(_DWORD *)(v4 + 16) = v6 | 0x200;
          if (v5) {
            goto LABEL_12;
          }
LABEL_14:
        }

        if (!v5) {
          goto LABEL_14;
        }
        unint64_t v7 = (unsigned int *)(v5 + 12);
        do
          signed int v8 = __ldaxr(v7);
        while (__stlxr(v8, v7));
        if (v8 >= 1) {
          goto LABEL_14;
        }
LABEL_12:
        BOOL v9 = (unsigned int *)(v5 + 12);
        do
          unsigned int v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
        goto LABEL_14;
      }
    }
  }

  return result;
}

uint64_t _prepareRowCacheOnBackgroundThread(uint64_t a1)
{
  values[128] = *(void **)MEMORY[0x1895F89C0];
  int v2 = *(void **)(a1 + 24);
  if (*v2) {
    uint64_t v3 = *(void *)(*v2 + 136LL);
  }
  else {
    uint64_t v3 = 0LL;
  }
  theArray = (const __CFArray *)v2[1];
  uint64_t v26 = v2[3];
  PF_FREE_OBJECT_ARRAY(v2);
  *(void *)(a1 + 24) = 0LL;
  if ((*(_DWORD *)(v3 + 72) & 2) == 0 && (*(_DWORD *)(v3 + 72) & 0x18) != 0x10) {
    [*(id *)(v3 + 8) _disablePersistentStoreResultCaching];
  }
  char v4 = objc_msgSend(*(id *)(v3 + 8), "_disablePersistentStoreResultCaching", v26);
  int v5 = *(_DWORD *)(v3 + 72) & 0x1C;
  uint64_t v6 = *(void *)(v3 + 56);
  uint64_t v28 = (pthread_cond_t *)(a1 + 96);
  uint64_t v29 = (pthread_mutex_t *)(a1 + 32);
  do
  {
LABEL_7:
    while (2)
    {
      pthread_mutex_lock(v29);
      do
      {
        CFIndex Count = CFArrayGetCount(theArray);
        unint64_t v8 = Count;
        if (Count >= 1)
        {
          if (Count >= 128) {
            CFIndex v13 = 128LL;
          }
          else {
            CFIndex v13 = Count;
          }
          v32.location = 0LL;
          v32.length = v13;
          CFArrayGetValues(theArray, v32, (const void **)values);
          if (v8 > 0x7F)
          {
            v33.location = 0LL;
            v33.length = v13;
            CFArrayReplaceValues(theArray, v33, 0LL, 0LL);
          }

          else
          {
            CFArrayRemoveAllValues(theArray);
          }

          atomic_load(v27);
          pthread_mutex_unlock(v29);
          uint64_t v14 = 0LL;
          do
          {
            CFIndex v15 = v13;
            uint64_t v16 = values[v14];
            uint64_t v17 = (id *)[v16 _objectsPointer];
            uint64_t v18 = [v16 count];
            if (v18)
            {
              uint64_t v19 = v18;
              do
              {
                id v20 = *v17;
                uint64_t v21 = [*v17 objectID];
                if ((v4 & 1) != 0)
                {
                  if (v5 != 8)
                  {
                    [v20 knownKeyValuesPointer];
                    uint64_t v22 = (void *)[v20 _snapshot];
                    id v23 = v22;
                    *uint64_t v17 = v22;
                  }
                }

                else
                {
                  unsigned int v24 = (void *)v21;
                  [v20 knownKeyValuesPointer];
                  -[NSPersistentStoreCache registerRow:forObjectID:options:](v6, (unsigned int *)v20, v24, 0);
                }

                ++v17;
                --v19;
              }

              while (v19);
            }

            if (v16) {
              CFRelease(v16);
            }
            ++v14;
            CFIndex v13 = v15;
          }

          while (v14 != v15);
          goto LABEL_7;
        }

        unsigned __int8 v9 = atomic_load(v27);
        if ((v9 & 1) != 0) {
          pthread_cond_wait(v28, v29);
        }
        unsigned __int8 v10 = atomic_load(v27);
      }

      while ((v10 & 1) != 0);
      unsigned __int8 v11 = atomic_load(v27);
      if (v8 || (v11 & 1) != 0)
      {
        pthread_mutex_unlock(v29);
        continue;
      }

      break;
    }

    CFIndex v12 = CFArrayGetCount(theArray);
    pthread_mutex_unlock(v29);
  }

  while (v12);
  return 0LL;
}

uint64_t _populateRowValuesOnBackgroundThread(uint64_t a1)
{
  values[128] = *(void **)MEMORY[0x1895F89C0];
  int v2 = *(uint64_t **)(a1 + 24);
  uint64_t v118 = *v2;
  uint64_t v3 = v2[4];
  unint64_t v105 = (unsigned __int8 *)v2[3];
  unint64_t v102 = (__CFArray *)v2[5];
  theArray = (const __CFArray *)v2[1];
  int v97 = (unsigned __int8 *)v2[6];
  PF_FREE_OBJECT_ARRAY(v2);
  *(void *)(a1 + 24) = 0LL;
  unint64_t v111 = (void (*)(uint64_t, char *, void, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  uint64_t v117 = (void (*)(uint64_t, char *, void, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  unint64_t v110 = (void (*)(uint64_t, char *, void, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  uint64_t v116 = (void (*)(uint64_t, char *, uint64_t))+[NSSQLRow instanceMethodForSelector:]( &OBJC_CLASS___NSSQLRow,  "instanceMethodForSelector:");
  uint64_t v98 = (pthread_cond_t *)(a1 + 96);
  uint64_t v99 = (pthread_mutex_t *)(a1 + 32);
  uint64_t v104 = v3;
  unint64_t v100 = (pthread_cond_t *)(v3 + 96);
  unint64_t v101 = (pthread_mutex_t *)(v3 + 32);
LABEL_2:
  pthread_mutex_lock(v99);
  char v4 = theArray;
  do
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      if (Count >= 128) {
        CFIndex v8 = 128LL;
      }
      else {
        CFIndex v8 = Count;
      }
      v126.location = 0LL;
      v126.length = v8;
      CFArrayGetValues(theArray, v126, (const void **)values);
      if ((unint64_t)Count > 0x7F)
      {
        v127.location = 0LL;
        v127.length = v8;
        CFArrayReplaceValues(theArray, v127, 0LL, 0LL);
      }

      else
      {
        CFArrayRemoveAllValues(theArray);
      }

      atomic_load(v105);
      CFIndex Count = v8;
LABEL_18:
      pthread_mutex_unlock(v99);
      if (v118)
      {
        uint64_t v119 = *(void *)(v118 + 112);
        unint64_t v112 = (void *)[MEMORY[0x1896078A8] defaultManager];
        BOOL v106 = *(_BYTE *)(v118 + 201) != 0;
      }

      else
      {
        unint64_t v112 = (void *)[MEMORY[0x1896078A8] defaultManager];
        uint64_t v119 = 0LL;
        BOOL v106 = 0;
      }

      if (Count >= 1)
      {
        CFIndex v9 = 0LL;
        char v114 = 0LL;
        uint64_t v115 = 0LL;
        uint64_t v113 = 0LL;
        while (1)
        {
          CFIndex v109 = v9;
          unsigned __int8 v10 = values[v9];
          unsigned __int8 v11 = *(void **)((char *)values + ((8 * v9) | 8));
          uint64_t v122 = [v11 _objectsPointer];
          uint64_t v108 = v11;
          uint64_t v120 = [v11 count];
          if (!v120) {
            goto LABEL_153;
          }
          uint64_t v12 = 0LL;
          CFIndex v13 = (uint64_t *)v10[8];
          uint64_t v14 = *v13;
          uint64_t v121 = v10;
          while (1)
          {
            while ((*(_DWORD *)v14 & 0x80000000) != 0)
            {
              uint64_t v15 = *(unsigned int *)(v14 + 4);
              if ((v15 & 0x80000000) != 0) {
                uint64_t v14 = 0LL;
              }
              else {
                uint64_t v14 = v13[v15] + *(void *)(v14 + 16);
              }
            }

            uint64_t v123 = v12;
            uint64_t v124 = *(void *)(v122 + 8 * v12);
            uint64_t v16 = *(void **)(v124 + 40);
            uint64_t v17 = (unint64_t *)_sqlEntityForEntityID(v119, *(unsigned int *)(v14 + 8));
            unint64_t plan_for_entity = _sql_fetch_plan_for_entity(v17);
            uint64_t v19 = *(unsigned int *)(plan_for_entity + 4);
            if ((_DWORD)v19)
            {
              id v20 = (unsigned __int8 *)(v14 + 32);
              uint64_t v21 = (id *)(plan_for_entity + 24);
              while (1)
              {
                int v22 = *((unsigned __int8 *)v21 - 4);
                else {
                  uint64_t v23 = qword_1868D6220[(char)(v22 - 2)];
                }
                id v20 = (unsigned __int8 *)((unint64_t)&v20[v23] & ~v23);
                if ((*(_BYTE *)(v21 - 1) & 1) != 0)
                {
                  int v25 = *v20++;
                  BOOL v24 = v25 != 0;
                }

                else
                {
                  BOOL v24 = 0;
                }

                uint64_t v26 = (unsigned int *)(v21 - 2);
                uint64_t v27 = ~v23;
                switch(*((_BYTE *)v21 - 4))
                {
                  case 1:
                    unint64_t v50 = (unint64_t)&v20[v23];
                    uint64_t v51 = (__int16 *)(v50 & v27);
                    uint64_t v37 = (v50 & v27) + 4;
                    if (v24) {
                      uint64_t v38 = (uint64_t)v20;
                    }
                    else {
                      uint64_t v38 = (v50 & v27) + 4;
                    }
                    int v52 = *((unsigned __int8 *)v21 - 3);
                    if (v52 == 10)
                    {
                      if (v24) {
                        uint64_t v73 = 0LL;
                      }
                      else {
                        uint64_t v73 = *(unsigned int *)v51;
                      }
                      v110(v124, sel_setForeignOrderKeySlot_orderKey_, *v26, v73);
                      goto LABEL_113;
                    }

                    if (v52 == 4)
                    {
                      if (v24) {
                        uint64_t v72 = 0LL;
                      }
                      else {
                        uint64_t v72 = *(unsigned int *)v51;
                      }
                      v111(v124, sel_setForeignEntityKeySlot_entityKey_, *v26, v72);
                      goto LABEL_113;
                    }

                    if (v52 != 1) {
                      goto LABEL_77;
                    }
                    uint64_t v40 = objc_msgSend((id)objc_msgSend(*v21, "propertyDescription"), "superCompositeAttribute");
                    if (v24) {
                      goto LABEL_65;
                    }
                    if (v40)
                    {
                      uint64_t v75 = (void *)[MEMORY[0x189607968] numberWithInt:*(unsigned int *)v51];
                      goto LABEL_116;
                    }

                    uint64_t v87 = *v26;
                    Class Class = object_getClass(v16);
                    int v89 = *(char *)(*((void *)object_getIndexedIvars(Class) + 7) + v87);
                    if (v89 == 115)
                    {
                      snapshot_set_int16((char *)v16, *v26, *v51);
                    }

                    else if (v89 == 99)
                    {
                      snapshot_set_int8(v16, *v26, *(_BYTE *)v51);
                    }

                    else
                    {
                      snapshot_set_int32((char *)v16, *v26, *(_DWORD *)v51);
                    }

                    goto LABEL_120;
                  case 2:
                  case 3:
                    unint64_t v35 = (unint64_t)&v20[v23];
                    uint64_t v36 = (uint64_t *)(v35 & v27);
                    uint64_t v37 = (v35 & v27) + 8;
                    if (v24) {
                      uint64_t v38 = (uint64_t)v20;
                    }
                    else {
                      uint64_t v38 = (v35 & v27) + 8;
                    }
                    int v39 = *((unsigned __int8 *)v21 - 3);
                    if (v39 == 6)
                    {
                      if (v24) {
                        uint64_t v58 = 0LL;
                      }
                      else {
                        uint64_t v58 = *v36;
                      }
                      v116(v124, sel_setOptLock_, v58);
                      goto LABEL_113;
                    }

                    if (v39 == 3)
                    {
                      if (v24) {
                        uint64_t v57 = 0LL;
                      }
                      else {
                        uint64_t v57 = *v36;
                      }
                      v117(v124, sel_setForeignKeySlot_int64_, *v26, v57);
LABEL_113:
                      id v20 = (unsigned __int8 *)v38;
                      goto LABEL_124;
                    }

                    if (v39 != 1)
                    {
LABEL_77:
                      id v20 = (unsigned __int8 *)v38;
                      goto LABEL_124;
                    }

                    uint64_t v40 = objc_msgSend((id)objc_msgSend(*v21, "propertyDescription"), "superCompositeAttribute");
                    if (v24)
                    {
LABEL_65:
                      if (v40) {
                        goto LABEL_69;
                      }
LABEL_66:
                      *((_BYTE *)v16 + ((unint64_t)*v26 >> 3) + 28) |= 1 << (*v26 & 7);
                    }

                    else
                    {
                      uint64_t v74 = *v36;
                      if (v40)
                      {
                        uint64_t v75 = (void *)[MEMORY[0x189607968] numberWithLongLong:v74];
LABEL_116:
                        setMultiColumnValueDictionary((char *)v16, v21 - 2, v75);
                      }

                      else
                      {
                        snapshot_set_int64((char *)v16, *v26, v74);
                      }

LABEL_148:
            uint64_t v92 = *(unsigned int *)(v14 + 4);
            if ((v92 & 0x80000000) != 0) {
              break;
            }
            unsigned __int8 v10 = v121;
            CFIndex v13 = (uint64_t *)v121[8];
            uint64_t v93 = v13[v92];
            if (v93)
            {
              uint64_t v14 = v93 + *(void *)(v14 + 16);
              uint64_t v12 = v123 + 1;
              if (v123 + 1 != v120) {
                continue;
              }
            }

            goto LABEL_153;
          }

          unsigned __int8 v10 = v121;
LABEL_153:
          if (v108) {
            BOOL v94 = v104 == 0;
          }
          else {
            BOOL v94 = 1;
          }
          if (!v94)
          {
            pthread_mutex_lock(v101);
            CFRetain(v108);
            CFArrayAppendValue(v102, v108);
            pthread_mutex_unlock(v101);
            pthread_cond_signal(v100);
            fetchResultSetDeallocate((uint64_t)v10);
            CFIndex v95 = v109;
            goto LABEL_159;
          }

          fetchResultSetDeallocate((uint64_t)v10);
          CFIndex v95 = v109;
          if (v108) {
LABEL_159:
          }
            CFRelease(v108);
          CFIndex v9 = v95 + 2;
          if (Count <= v9) {
            goto LABEL_2;
          }
        }
      }

      goto LABEL_2;
    }

    unsigned __int8 v5 = atomic_load(v105);
    if ((v5 & 1) != 0) {
      pthread_cond_wait(v98, v99);
    }
    unsigned __int8 v6 = atomic_load(v105);
    char v4 = theArray;
  }

  while ((v6 & 1) != 0);
  unsigned __int8 v7 = atomic_load(v105);
  if (Count || (v7 & 1) != 0) {
    goto LABEL_18;
  }
  if (CFArrayGetCount(theArray))
  {
    CFIndex Count = 0LL;
    goto LABEL_18;
  }

  if (v97) {
    atomic_store(0, v97);
  }
  pthread_mutex_unlock(v99);
  return 0LL;
}

void setMultiColumnValueDictionary(char *a1, id *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(unsigned int *)a2;
  Class Class = object_getClass(a1);
  CFIndex v8 = *(NSKnownKeysDictionary **)&a1[*((unsigned int *)object_getIndexedIvars(Class) + v6 + 19)];
  CFIndex v9 = v8;
  unsigned __int8 v10 = (__CFString *)[a2[2] propertyDescription];
  if (!v8)
  {
    int v22 = v10;
    unsigned __int8 v11 = (void *)objc_msgSend((id)objc_msgSend(a2[2], "propertyDescription"), "superCompositeAttribute");
    if (v11)
    {
      do
      {
        uint64_t v12 = v11;
        unsigned __int8 v11 = (void *)[v11 superCompositeAttribute];
      }

      while (v11);
    }

    else
    {
      uint64_t v12 = 0LL;
    }

    id v13 = -[NSKnownKeysMappingStrategy initForKeys:]( [NSKnownKeysMappingStrategy alloc],  "initForKeys:",  objc_msgSend((id)objc_msgSend(v12, "elements"), "valueForKeyPath:", @"name"));
    CFIndex v8 = -[NSKnownKeysDictionary initWithSearchStrategy:]( objc_alloc(&OBJC_CLASS___NSKnownKeysDictionary),  "initWithSearchStrategy:",  v13);

    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    uint64_t v14 = (void *)[v12 elements];
    uint64_t v15 = [v14 countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)v24;
      do
      {
        uint64_t v18 = 0LL;
        do
        {
          if (*(void *)v24 != v17) {
            objc_enumerationMutation(v14);
          }
          uint64_t v19 = *(__CFString **)(*((void *)&v23 + 1) + 8 * v18);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0) {
            _createKnownKeysDictionaryForMultiColumnValue(v19, v8);
          }
          ++v18;
        }

        while (v16 != v18);
        uint64_t v16 = [v14 countByEnumeratingWithState:&v23 objects:v27 count:16];
      }

      while (v16);
    }

    unsigned __int8 v10 = v22;
  }

  id v20 = -[NSPropertyDescription _elementPath](v10);
  if (*((_BYTE *)a2 + 12) == 8)
  {
    uint64_t v21 = (void *)MEMORY[0x189603F50];
    [a3 doubleValue];
    a3 = (void *)objc_msgSend(v21, "dateWithTimeIntervalSinceReferenceDate:");
  }

  -[NSKnownKeysDictionary setValue:forKeyPath:](v8, "setValue:forKeyPath:", a3, v20);
  snapshot_set_object(a1, *(_DWORD *)a2, (uint64_t)v8);
}

void setMultiColumnValueNullFlag(char *a1, _DWORD *a2)
{
  uint64_t v4 = *a2;
  Class Class = object_getClass(a1);
  id v7 = *(id *)&a1[*((unsigned int *)object_getIndexedIvars(Class) + v4 + 19)];
  id v6 = v7;
  if (!v7) {
    a1[((unint64_t)*a2 >> 3) + 28] |= 1 << (*a2 & 7);
  }
}

uint64_t _createKnownKeysDictionaryForMultiColumnValue(__CFString *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v4 = objc_alloc_init(MEMORY[0x189603FA8]);
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  unsigned __int8 v5 = (void *)-[__CFString elements](a1, "elements");
  uint64_t v6 = [v5 countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v23;
    do
    {
      uint64_t v9 = 0LL;
      do
      {
        if (*(void *)v23 != v8) {
          objc_enumerationMutation(v5);
        }
        objc_msgSend(v4, "addObject:", objc_msgSend(*(id *)(*((void *)&v22 + 1) + 8 * v9++), "name"));
      }

      while (v7 != v9);
      uint64_t v7 = [v5 countByEnumeratingWithState:&v22 objects:v27 count:16];
    }

    while (v7);
  }

  if ([v4 count])
  {
    id v10 = -[NSKnownKeysMappingStrategy initForKeys:]( objc_alloc(&OBJC_CLASS___NSKnownKeysMappingStrategy),  "initForKeys:",  v4);
    unsigned __int8 v11 = -[NSKnownKeysDictionary initWithSearchStrategy:]( objc_alloc(&OBJC_CLASS___NSKnownKeysDictionary),  "initWithSearchStrategy:",  v10);

    [a2 setValue:v11 forKeyPath:-[NSPropertyDescription _elementPath](a1)];
  }

  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  uint64_t v12 = (void *)-[__CFString elements](a1, "elements", 0LL);
  uint64_t result = [v12 countByEnumeratingWithState:&v18 objects:v26 count:16];
  if (result)
  {
    uint64_t v14 = result;
    uint64_t v15 = *(void *)v19;
    do
    {
      uint64_t v16 = 0LL;
      do
      {
        if (*(void *)v19 != v15) {
          objc_enumerationMutation(v12);
        }
        uint64_t v17 = *(void *)(*((void *)&v18 + 1) + 8 * v16);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0) {
          _createKnownKeysDictionaryForMultiColumnValue(v17, a2);
        }
        ++v16;
      }

      while (v14 != v16);
      uint64_t result = [v12 countByEnumeratingWithState:&v18 objects:v26 count:16];
      uint64_t v14 = result;
    }

    while (result);
  }

  return result;
}

uint64_t _fireFaultsOnBackgroundThread(uint64_t a1)
{
  int v2 = *(uint64_t **)(a1 + 24);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  uint64_t v5 = v2[2];
  unint64_t v6 = v2[3];
  uint64_t v7 = v2[4];
  uint64_t v8 = v2[5];
  PF_FREE_OBJECT_ARRAY(v2);
  *(void *)(a1 + 24) = 0LL;
  if (v3)
  {
    uint64_t v9 = *(void *)(v3 + 32);
    uint64_t v3 = *(void *)(v3 + 128);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  if (v6 < v7 + v6)
  {
    id v10 = (char *)(v8 + v6);
    unsigned __int8 v11 = (void **)(v5 + 8 * v6);
    uint64_t v12 = (uint64_t *)(v4 + 8 * v6);
    do
    {
      uint64_t v13 = *v12;
      if (((*(_DWORD *)(*v12 + 16) >> 15) & 3 | 4) == 5)
      {
        uint64_t v14 = *(void **)(v13 + 48);
        if (v14 && *v14)
        {
          char v15 = 3;
        }

        else
        {
          _PFFaultHandlerFulfillFault(v3, v13, v9, *v11, 0);
          char v15 = 1;
        }

        char *v10 = v15;
      }

      ++v10;
      ++v11;
      ++v12;
      --v7;
    }

    while (v7);
  }

  return 0LL;
}

#error "18681E1DC: call analysis failed (funcsize=68)"
BOOL __cdecl -[NSCKMetadataEntry BOOLValue](NSCKMetadataEntry *self, SEL a2)
{
  return objc_msgSend((id)-[NSCKMetadataEntry BOOLValueNum](self, "BOOLValueNum"), "BOOLValue");
}

void __Block_byref_object_copy__31(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__31(uint64_t a1)
{
}

uint64_t _deallocateSQLRowCacheOnBackgroundThread(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(void **)v2;
  unint64_t v4 = *(void *)(v2 + 8);
  if (v4)
  {
    uint64_t v5 = 0LL;
    unsigned int v6 = 1;
    do
    {
      uint64_t v7 = v3[v5];

      *(void *)(v7 + 40) = 0LL;
      uint64_t v5 = v6;
      BOOL v8 = v4 > v6++;
    }

    while (v8);
  }

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  while (!*(void *)(v2 + 16))
    pthread_cond_wait((pthread_cond_t *)(a1 + 96), (pthread_mutex_t *)(a1 + 32));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
  if (v4)
  {
    uint64_t v9 = 0LL;
    unsigned int v10 = 1;
    do
    {
      _PFDeallocateObject((id)v3[v9]);
      uint64_t v9 = v10;
      BOOL v8 = v4 > v10++;
    }

    while (v8);
  }

  unsigned __int8 v11 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    unsigned __int8 v11 = malloc_default_zone();
  }
  malloc_zone_free(v11, v3);
  uint64_t v12 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v12 = malloc_default_zone();
  }
  malloc_zone_free(v12, *(void **)(a1 + 24));
  *(void *)(a1 + 24) = 0LL;
  return 0LL;
}

void sub_186825110( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
  if (a2)
  {
    objc_destroyWeak(v33);
    objc_destroyWeak((id *)(v34 - 96));
    objc_begin_catch(exception_object);
    JUMPOUT(0x186824FA0LL);
  }

  _Unwind_Resume(exception_object);
}

void __Block_byref_object_copy__32(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__32(uint64_t a1)
{
}

void sub_18682537C(_Unwind_Exception *a1)
{
}

void sub_1868253BC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x18682539CLL);
  }
  objc_terminate();
  __48__PFCloudKitExporter_checkForZonesNeedingExport__block_invoke_2(v2);
}

void sub_18682594C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, id location, const __CFString *a30, uint64_t a31, uint64_t a32, const __CFString *a33)
{
  if (a2 == 1)
  {
    id v36 = objc_begin_catch(a1);
    *(_BYTE *)(*(void *)(*(void *)(a15 + 72) + 8LL) + 24LL) = 0;
    id v37 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v38 = *MEMORY[0x1896075F0];
    a30 = @"NSUnderlyingException";
    a31 = v38;
    a32 = (uint64_t)v36;
    a33 = @"Export encountered an unhandled exception while analyzing history in the store.";
    uint64_t v39 = [MEMORY[0x189603F68] dictionaryWithObjects:&a32 forKeys:&a30 count:2];
    *(void *)(*(void *)(*(void *)(a15 + 64) + 8) + 40) = [v37 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v39];
    objc_end_catch();
    JUMPOUT(0x186825900LL);
  }

  _Unwind_Resume(a1);
}

void sub_186825A4C()
{
}

void sub_186825C64()
{
}

void sub_186825EA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void sub_186825EE0(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_terminate();
    JUMPOUT(0x186825EF0LL);
  }

  JUMPOUT(0x186825ED8LL);
}

void sub_18682632C(_Unwind_Exception *a1)
{
}

void sub_186826354(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_terminate();
    if (v3)
    {
      objc_begin_catch(v2);
      JUMPOUT(0x18682623CLL);
    }

    JUMPOUT(0x18682634CLL);
  }

  JUMPOUT(0x186826334LL);
}

void sub_186827270( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, const __CFString *a26, uint64_t a27, uint64_t a28, const __CFString *a29)
{
  if (a2 == 3)
  {
    id v29 = objc_begin_catch(exc_buf);
    *(_BYTE *)(*(void *)(*(void *)(a18 + 56) + 8LL) + 24LL) = 0;
    id v30 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v31 = *MEMORY[0x1896075F0];
    a26 = @"NSUnderlyingException";
    a27 = v31;
    a28 = (uint64_t)v29;
    a29 = @"Export encountered an unhandled exception while analyzing history in the store.";
    uint64_t v32 = [MEMORY[0x189603F68] dictionaryWithObjects:&a28 forKeys:&a26 count:2];
    *(void *)(*(void *)(*(void *)(a18 + 64) + 8) + 40) = [v30 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v32];
    objc_end_catch();
    JUMPOUT(0x186826C8CLL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_186827544()
{
}

void sub_18682781C()
{
}

void sub_186827B2C(_Unwind_Exception *a1)
{
}

void sub_186828248( _Unwind_Exception *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, int a24, int a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x186828100LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_186828688( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1868286CC(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_terminate();
    if (v3)
    {
      objc_begin_catch(v2);
      JUMPOUT(0x1868284F4LL);
    }
  }

  JUMPOUT(0x1868286C4LL);
}

void sub_18682889C(_Unwind_Exception *a1)
{
}

uint64_t sub_1868288DC(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1868288BCLL);
  }
  objc_terminate();
  return __56__PFCloudKitExporter_updateMetadataForSavedZones_error___block_invoke_2(v2);
}

void sub_186828ACC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, const __CFString *a18, uint64_t a19, uint64_t a20, const __CFString *a21)
{
  if (a2 == 1)
  {
    id v22 = objc_begin_catch(exception_object);
    *(_BYTE *)(*(void *)(*(void *)(v21 + 72) + 8LL) + 24LL) = 0;
    id v23 = objc_alloc(MEMORY[0x189607870]);
    uint64_t v24 = *MEMORY[0x1896075F0];
    a18 = @"NSUnderlyingException";
    a19 = v24;
    a20 = (uint64_t)v22;
    a21 = @"Export encountered an unhandled exception while analyzing history in the store.";
    uint64_t v25 = [MEMORY[0x189603F68] dictionaryWithObjects:&a20 forKeys:&a18 count:2];
    *(void *)(*(void *)(*(void *)(v21 + 64) + 8) + 40) = [v23 initWithDomain:*MEMORY[0x189607460] code:134421 userInfo:v25];
    objc_end_catch();
    JUMPOUT(0x186828A90LL);
  }

  _Unwind_Resume(exception_object);
}

void sub_186828E0C()
{
}

LABEL_244:
                    uint64_t v93 = 0LL;
                    goto LABEL_220;
                  }

                  [v147 lastObject];
                }

                uint64_t v93 = 0LL;
                goto LABEL_220;
              }

              if (v146)
              {
                uint64_t v118 = -[NSSQLFetchIntermediate finalJoinForKeypathWithComponents:]( (uint64_t)self->_fetchIntermediate,  v147);
                if (v118)
                {
                  uint64_t v119 = v118;
                  uint64_t v120 = [*(id *)(v118 + 16) destinationEntity];
                  if (v120) {
                    uint64_t v121 = *(void **)(v120 + 128);
                  }
                  else {
                    uint64_t v121 = 0LL;
                  }
                  -[NSSQLSubqueryExpressionIntermediate _setVariableColumn:]((uint64_t)self, v121);
                  uint64_t v122 = *(void **)(v119 + 32);
                }

                else
                {
                  -[NSSQLSubqueryExpressionIntermediate _setVariableColumn:]((uint64_t)self, 0LL);
                  uint64_t v122 = 0LL;
                }

                self->_variableAlias = (NSString *)v122;
                uint64_t v123 = v48;
                if (v76) {
                  uint64_t v123 = (void *)objc_msgSend(v48, "subarrayWithRange:", 0, v145);
                }
                uint64_t v124 = -[NSSQLFetchIntermediate finalJoinForKeypathWithComponents:]( (uint64_t)self->_fetchIntermediate,  v123);
                if (v124)
                {
                  self->_targetAlias = *(NSString **)(v124 + 32);
                  uint64_t v125 = *(void **)(v124 + 16);
                  goto LABEL_210;
                }

LABEL_236:
                CFIndex v95 = &OBJC_IVAR___NSSQLSubqueryExpressionIntermediate__targetColumn;
                self->_targetAlias = 0LL;
                if (v76)
                {
                  [v48 lastObject];
                  selectEntityAlias = 0LL;
                  CFIndex v95 = &OBJC_IVAR___NSSQLSubqueryExpressionIntermediate__targetColumn;
                }

                else
                {
                  selectEntityAlias = 0LL;
                }

                goto LABEL_138;
              }

              uint64_t v130 = v48;
              if (v76) {
                uint64_t v130 = (void *)objc_msgSend(v48, "subarrayWithRange:", 0, v145);
              }
              uint64_t v131 = -[NSSQLFetchIntermediate finalJoinForKeypathWithComponents:]( (uint64_t)self->_fetchIntermediate,  v130);
              self->_variableAlias = self->_selectEntityAlias;
              if (!v131) {
                goto LABEL_236;
              }
              self->_targetAlias = *(NSString **)(v131 + 32);
              uint64_t v125 = *(void **)(v131 + 16);
LABEL_210:
              uint64_t v132 = [v125 destinationEntity];
              uint64_t v133 = v132;
              if ((v76 & 1) != 0)
              {
                uint64_t v134 = [v48 lastObject];
                if (v133)
                {
                  selectEntityAlias = (objc_class *)[*(id *)(v133 + 40) objectForKey:v134];
LABEL_215:
                  CFIndex v95 = &OBJC_IVAR___NSSQLSubqueryExpressionIntermediate__targetColumn;
                  goto LABEL_138;
                }
              }

              else if (v132)
              {
                selectEntityAlias = *(objc_class **)(v132 + 128);
                goto LABEL_215;
              }

              selectEntityAlias = 0LL;
              goto LABEL_215;
            }

            int v3 = v143;
LABEL_114:
            uint64_t v81 = -[NSSQLColumn destinationEntity](v64, "destinationEntity");
            if (v81) {
              uint64_t v82 = *(NSSQLColumn **)(v81 + 128);
            }
            else {
              uint64_t v82 = 0LL;
            }
            uint64_t v83 = 0;
            self->_targetColumn = v82;
            int v142 = v57 == v146;
            goto LABEL_117;
          }
        }

        uint64_t v73 = (void *)MEMORY[0x189603F70];
        uint64_t v74 = *MEMORY[0x189603A60];
        uint64_t v75 = [NSString stringWithFormat:@"Bad collection keypath (%@) can't find property named (%@) ", self->super._expression, v62];
LABEL_112:
        int v3 = v143;
        objc_msgSend( v143,  "setObject:forKey:",  objc_msgSend(v73, "exceptionWithName:reason:userInfo:", v74, v75, 0),  @"NSUnderlyingException");
        goto LABEL_139;
      }

      if (self->_hasTrailingFunction) {
        uint64_t v47 = 0;
      }
      else {
LABEL_62:
      }
        uint64_t v47 = -[NSArray count](v46, "count") != 0;
      if (![v147 count] && !v47)
      {
        self->_targetAlias = self->_variableAlias;
        self->_targetColumn = self->_variableColumn;
        goto LABEL_139;
      }

      goto LABEL_66;
    }

LABEL_226:
    CFRange v44 = 0LL;
    goto LABEL_52;
  }

  uint64_t v5 = (void *)MEMORY[0x189603F70];
  unsigned int v6 = *MEMORY[0x189603A60];
  uint64_t v7 = [MEMORY[0x189603F68] dictionaryWithObject:self->super._expression forKey:@"expression"];
  BOOL v8 = @"Subquery expressions not allowed in indexes";
  uint64_t v9 = v5;
  uint64_t v10 = v6;
LABEL_8:
  objc_msgSend( v3,  "setObject:forKey:",  objc_msgSend(v9, "exceptionWithName:reason:userInfo:", v10, v8, v7),  @"NSUnderlyingException");
  return 0LL;
}

id _PFModelMapPathForEntity(void *a1)
{
  uint64_t v2 = objc_msgSend((id)objc_msgSend(a1, "managedObjectModel"), "_modelsReferenceIDOffset");
  if (v2 <= 16049)
  {
    if (!v2) {
      return (id)[a1 name];
    }
    if (v2 == 16000)
    {
      int v3 = (void *)NSString;
      unint64_t v4 = &OBJC_CLASS____PFPersistentHistoryModel;
      return (id)[v3 stringWithFormat:@"%@/%@", -[__objc2_class ancillaryModelNamespace](v4, "ancillaryModelNamespace"), objc_msgSend(a1, "name")];
    }
  }

  else
  {
    switch(v2)
    {
      case 16050LL:
        int v3 = (void *)NSString;
        unint64_t v4 = &OBJC_CLASS____PFPersistentHistoryFetchModel;
        return (id)[v3 stringWithFormat:@"%@/%@", -[__objc2_class ancillaryModelNamespace](v4, "ancillaryModelNamespace"), objc_msgSend(a1, "name")];
      case 17000LL:
        int v3 = (void *)NSString;
        unint64_t v4 = &OBJC_CLASS___PFCloudKitMetadataModel;
        return (id)[v3 stringWithFormat:@"%@/%@", -[__objc2_class ancillaryModelNamespace](v4, "ancillaryModelNamespace"), objc_msgSend(a1, "name")];
      case 18000LL:
        int v3 = (void *)NSString;
        unint64_t v4 = &OBJC_CLASS___NSSQLiteIndexTrackingModel;
        return (id)[v3 stringWithFormat:@"%@/%@", -[__objc2_class ancillaryModelNamespace](v4, "ancillaryModelNamespace"), objc_msgSend(a1, "name")];
    }
  }

  unsigned int v6 = (void *)MEMORY[0x189603F70];
  uint64_t v7 = *MEMORY[0x189603A58];
  BOOL v8 = (void *)NSString;
  uint64_t v9 = v2;
  uint64_t v10 = (objc_class *)objc_opt_class();
  unsigned __int8 v11 = (void *)[v6 exceptionWithName:v7, objc_msgSend( v8, "stringWithFormat:", @"Managed object model with offset %lu is not known to %@", v9, NSStringFromClass(v10)), 0 reason userInfo];
  objc_exception_throw(v11);
  return (id)_PFModelMapTotalEntityCountForModel();
}

uint64_t _PFModelMapTotalEntityCountForModel(void *a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  id v2 = +[_PFModelMap ancillaryModelFactoryClasses](&OBJC_CLASS____PFModelMap, "ancillaryModelFactoryClasses");
  uint64_t v3 = objc_msgSend((id)objc_msgSend(a1, "entities"), "count");
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  uint64_t v4 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v10;
    do
    {
      uint64_t v7 = 0LL;
      do
      {
        if (*(void *)v10 != v6) {
          objc_enumerationMutation(v2);
        }
        v3 += [*(id *)(*((void *)&v9 + 1) + 8 * v7++) ancillaryEntityCount];
      }

      while (v5 != v7);
      uint64_t v5 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }

    while (v5);
  }

  return v3;
}

void sub_18682C158(_Unwind_Exception *a1)
{
}

void sub_18682F054(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x18682EFF4LL);
  }

  _Unwind_Resume(exc_buf);
}

uint64_t _PFCoreDataProcessInstanceUUID()
{
  uint64_t result = qword_18C4ABC88;
  if (!qword_18C4ABC88)
  {
    objc_opt_class();
    return qword_18C4ABC88;
  }

  return result;
}

void _PFfastFactoryRelease2(void *a1)
{
  IndexedIvars = (unsigned int *)object_getIndexedIvars(a1);
  id v2 = IndexedIvars;
  do
    unsigned int v3 = __ldxr(IndexedIvars);
  while (__stxr(v3 - 1, IndexedIvars));
  if (!v3)
  {
    uint64_t v4 = (const void *)*((void *)IndexedIvars + 2);
    if (v4)
    {
      CFRelease(v4);
      *((void *)v2 + 2) = 0LL;
    }

    *((void *)v2 + 1) = 0LL;
    __dmb(0xBu);
  }

void *_PFFastTemporaryIDCreation(void *a1)
{
  id v2 = _PFAllocateObject((Class)_NSTemporaryObjectID_Default_Class, 0LL);
  if (v2)
  {
    v2[2] = a1;
    do
    {
      unsigned int v3 = __ldxr((unsigned int *)&_CoreDataProcessInstanceTempIDCounter);
      unsigned int v4 = v3 + 1;
    }

    while (__stxr(v4, (unsigned int *)&_CoreDataProcessInstanceTempIDCounter));
    *((_DWORD *)v2 + 3) = v4;
  }

  return v2;
}

LABEL_72:
      objc_exception_throw((id)[v88 exceptionWithName:v89 reason:v90 userInfo:0]);
    }

    objc_registerClassPair(v11);
    object_setClass(v8, v11);
    v8[4] |= 0x100000u;
    v8[2] = 10000;
    uint64_t v77 = generateReturnPointerMethod((uint64_t)v8);
    class_addMethod(v16, sel__PFPlaceHolderSingleton, v77, "@@:");
    LOBYTE(v76) = 0;
LABEL_49:
    *((_BYTE *)v35 + 32) = v76;
    v35[5] = 0LL;
LABEL_50:
    uint64_t v78 = -[objc_class _PFMOClassFactoryData](v11, "_PFMOClassFactoryData");
    uint64_t v79 = *(_BYTE **)(v78 + 8);
    if (!v79 || v79 == v3)
    {
      uint64_t v81 = v78;
      if (!*(void *)(v78 + 56)) {
        goto LABEL_59;
      }
    }

    uint64_t v82 = class_getName((Class)a1);
    snprintf(__str, 0x200uLL, "%s_%s_%x", v82, v6, v9++);
  }

  uint64_t v79 = *(_BYTE **)(v81 + 8);
LABEL_59:
  if (!v79)
  {
    *(_DWORD *)uint64_t v81 = 0;
    *(void *)(v81 + _Block_object_dispose((const void *)(v13 - 128), 8) = v3;
    *(void *)(v81 + 16) = objc_msgSend((id)objc_msgSend(v3, "name"), "copy");
    *(void *)(v81 + 24) = 0LL;
    uint64_t v83 = (void *)-[objc_class _PFPlaceHolderSingleton](v11, "_PFPlaceHolderSingleton");
    object_setClass(v83, v11);
    *(void *)(v81 + 4_Block_object_dispose((const void *)(v13 - 128), 8) = v83;
  }

  os_unfair_lock_unlock(&_MergedGlobals_79);
  if (v8)
  {
    os_unfair_lock_lock_with_options();
    CFMutableArrayRef Mutable = (__CFArray *)qword_18C4ABAC0;
    if (!qword_18C4ABAC0)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
      qword_18C4ABAC0 = (uint64_t)Mutable;
    }

    CFArrayAppendValue(Mutable, v8);
    os_unfair_lock_unlock(&stru_18C4ABABC);
  }

  objc_opt_self();
  __dmb(0xBu);
  return v11;
}

Class override_instace_class_0(void *a1)
{
  Class Class = object_getClass(a1);
  return class_getSuperclass(Class);
}

Class override_class_superclass_0(objc_class *a1)
{
  Class Superclass = class_getSuperclass(a1);
  return class_getSuperclass(Superclass);
}

IMP generateReturnPointerMethod(uint64_t a1)
{
  aBlock[0] = MEMORY[0x1895F87A8];
  aBlock[1] = 3221225472LL;
  aBlock[2] = __generateReturnPointerMethod_block_invoke_0;
  aBlock[3] = &__block_descriptor_40_e9__v16__0_8l;
  aBlock[4] = a1;
  BOOL v1 = _Block_copy(aBlock);
  os_unfair_lock_lock_with_options();
  CFMutableArrayRef Mutable = (__CFArray *)qword_18C4ABAC0;
  if (!qword_18C4ABAC0)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
    qword_18C4ABAC0 = (uint64_t)Mutable;
  }

  CFArrayAppendValue(Mutable, v1);
  os_unfair_lock_unlock(&stru_18C4ABABC);
  return imp_implementationWithBlock(v1);
}

void PF_Tiger_CFDictionaryDestroy(void *ptr)
{
  id v2 = (void *)ptr[5];
  if (v2)
  {
    unsigned int v3 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone)
    {
      unsigned int v3 = malloc_default_zone();
      id v2 = (void *)ptr[5];
    }

    malloc_zone_free(v3, v2);
  }

  unsigned int v4 = (void *)ptr[6];
  if (v4)
  {
    uint64_t v5 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
    if (!_PF_Private_Malloc_Zone)
    {
      uint64_t v5 = malloc_default_zone();
      unsigned int v4 = (void *)ptr[6];
    }

    malloc_zone_free(v5, v4);
  }

  uint64_t v6 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v6 = malloc_default_zone();
  }
  malloc_zone_free(v6, ptr);
}

void *PF_Tiger_CFDictionaryCreate(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v5 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v5 = malloc_default_zone();
  }
  uint64_t v6 = malloc_zone_calloc(v5, 1uLL, 0x38uLL);
  uint64_t v7 = v6;
  *(_DWORD *)uint64_t v6 = 0;
  v6[3] = 0LL;
  v6[4] = 0LL;
  v6[2] = 2712781267LL;
  if (a3)
  {
    for (uint64_t i = 0LL; i != 42; ++i)
    {
      if (__CFDictionaryCapacities[i] >= a2) {
        break;
      }
    }

    uint64_t v9 = 0LL;
    unsigned int v10 = __CFDictionaryCapacities[i];
    *((_DWORD *)v6 + 1) = v10;
    do
    {
      if (__CFDictionaryCapacities[v9] >= v10) {
        break;
      }
      ++v9;
    }

    while (v9 != 42);
  }

  else
  {
    uint64_t v9 = 0LL;
    *((_DWORD *)v6 + 1) = a2;
    do
    {
      if (__CFDictionaryCapacities[v9] >= a2) {
        break;
      }
      ++v9;
    }

    while (v9 != 42);
  }

  int v11 = __CFDictionaryBuckets[v9];
  *((_DWORD *)v6 + 2) = v11;
  __int128 v12 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone)
  {
    __int128 v12 = malloc_default_zone();
    int v11 = *((_DWORD *)v7 + 2);
  }

  v7[5] = malloc_zone_calloc(v12, v11, 8uLL);
  uint64_t v13 = (malloc_zone_t *)_PF_Private_Malloc_Zone;
  if (!_PF_Private_Malloc_Zone) {
    uint64_t v13 = malloc_default_zone();
  }
  v7[6] = malloc_zone_calloc(v13, *((int *)v7 + 2), 8uLL);
  uint64_t v14 = *((int *)v7 + 2);
  if ((_DWORD)v14)
  {
    uint64_t v15 = v14 - 1;
    do
      *(void *)(v7[5] + 8 * v15) = 2712781267LL;
    while ((_DWORD)v15--);
  }

  return v7;
}

uint64_t PF_Tiger_CFDictionaryGetKeysAndValues(uint64_t result, void *a2, void *a3)
{
  uint64_t v3 = *(unsigned int *)(result + 8);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = *(void *)(result + 16);
    uint64_t v6 = 8 * v3;
    do
    {
      uint64_t v7 = *(void *)(*(void *)(result + 40) + v4);
      if (v5 != v7 && ~v5 != v7)
      {
        if (a2) {
          *a2++ = v7;
        }
        if (a3) {
          *a3++ = *(void *)(*(void *)(result + 48) + v4);
        }
      }

      v4 += 8LL;
    }

    while (v6 != v4);
  }

  return result;
}

void PF_Tiger_CFDictionarySetValue(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  unsigned int v6 = _PF_TigerHashCFString(a2);
  uint64_t v7 = *(void *)(a1 + 40);
  unint64_t v8 = *(void *)(a1 + 16);
  int v9 = v6 % *(_DWORD *)(a1 + 8);
  unsigned int v38 = -1;
  unsigned int v10 = &v38;
  signed int v11 = v9;
  while (1)
  {
    __int128 v12 = *(const __CFString **)(v7 + 8LL * v11);
    if ((const __CFString *)v8 == v12)
    {
      if (v10) {
        unsigned int *v10 = v11;
      }
      goto LABEL_17;
    }

    if ((const __CFString *)~v8 == v12)
    {
      if (v10)
      {
        unsigned int *v10 = v11;
        unsigned int v10 = 0LL;
      }

      goto LABEL_8;
    }

    if (v12 == a2 || CFEqual(v12, a2)) {
      break;
    }
LABEL_8:
    int v13 = v11 + 1;
    int v14 = *(_DWORD *)(a1 + 8);
    if (v14 <= v11 + 1) {
      int v15 = *(_DWORD *)(a1 + 8);
    }
    else {
      int v15 = 0;
    }
    signed int v11 = v13 - v15;
    if (v9 == v13 - v15) {
      goto LABEL_18;
    }
  }

  if (v11 != -1)
  {
    *(void *)(*(void *)(a1 + 48) + 8LL * v11) = a3;
    return;
  }

uint64_t _PF_TigerHashCFString(const __CFString *a1)
{
  v13[1] = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  int v3 = MEMORY[0x1895F8858](Length);
  uint64_t v5 = (UniChar *)((char *)v13 - ((v4 + 15) & 0x3FFFFFFF0LL));
  uint64_t v6 = v3;
  v14.location = 0LL;
  v14.length = v3;
  CFStringGetCharacters(a1, v14, v5);
  if ((int)Length > 23)
  {
    unsigned int v10 = &v5[(Length - 16)];
    int v8 = 16974593 * v10[12]
       + 66049 * v10[13]
       + 257 * v10[14]
       + v10[15]
       + 67503105
       * (16974593 * v10[8]
        + 66049 * v10[9]
        + 257 * v10[10]
        + v10[11]
        + 67503105
        * (16974593 * v10[4]
         + 66049 * v10[5]
         + 257 * v10[6]
         + v10[7]
         + 67503105
         * (16974593 * *v10
          + 66049 * v10[1]
          + 67503105
          * (16974593 * v5[4]
           + 67503105 * (67503105 * Length + 16974593 * *v5 + 66049 * v5[1] + 257 * v5[2] + v5[3])
           + 66049 * v5[5]
           + 257 * v5[6]
           + v5[7])
          + 257 * v10[2]
          + v10[3])));
  }

  else
  {
    uint64_t v7 = &v5[v6];
    if ((int)(Length & 0xFFFFFFFC) < 1)
    {
      int v8 = Length;
    }

    else
    {
      int v8 = Length;
      int v9 = &v5[Length & 0xFFFFFFFC];
      do
      {
        int v8 = 67503105 * v8 + 16974593 * *v5 + 66049 * v5[1] + 257 * v5[2] + v5[3];
        v5 += 4;
      }

      while (v5 < v9);
    }

    while (v5 < v7)
    {
      int v11 = *v5++;
      int v8 = 257 * v8 + v11;
    }
  }

  return ((v8 << Length) + v8);
}

void sub_18683318C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x18683315CLL);
  }

  JUMPOUT(0x1868331C8LL);
}

void sub_1868331C0(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x1868331C4LL);
  }
  objc_terminate();
  -[PFCloudKitMetricsClient logMetric:](v2, v3);
}

void sub_186835DD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void __Block_byref_object_copy__33(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__33(uint64_t a1)
{
}

void sub_186836D5C(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x186836B6CLL);
  }

  _Unwind_Resume(exc_buf);
}

LABEL_93:
        ++v47;
      }

      while (v45 != v47);
      unint64_t v59 = [v6 countByEnumeratingWithState:&v68 objects:v92 count:16];
      uint64_t v45 = v59;
    }

    while (v59);
  }

void sub_18683909C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  objc_begin_catch(a1);
  JUMPOUT(0x186838DD0LL);
}

void sub_186839978(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1868398E8LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_18683A9D0(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x18683A984LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_18683B7B0(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x18683B73CLL);
  }

  _Unwind_Resume(exception_object);
}

void sub_18683DCC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void __Block_byref_object_copy__34(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__34(uint64_t a1)
{
}

LABEL_129:
        uint64_t v85 = v1059;
        uint64_t v86 = (uint64_t)v1064;
        uint64_t v87 = contexta;
LABEL_139:
        if (v1109)
        {
          *((_BYTE *)v1109 + memset(&v6.st_mtimespec, 0, 96) = 1;
          [v88 setMappingType:4];
          objc_msgSend( v88,  "setName:",  objc_msgSend((id)objc_msgSend(v88, "name"), "stringByAppendingString:", @"_AsCopy"));
          *((_DWORD *)v1109 + 12) = 2;
        }

        else
        {
          [v88 setMappingType:4];
          objc_msgSend( v88,  "setName:",  objc_msgSend((id)objc_msgSend(v88, "name"), "stringByAppendingString:", @"_AsCopy"));
        }

LABEL_232:
        objc_autoreleasePoolPop(v173);
      }

      uint64_t v169 = [v1110 countByEnumeratingWithState:&v1278 objects:&v1372 count:16];
      if (!v169) {
        goto LABEL_236;
      }
    }
  }

  LOBYTE(v1097) = 0;
LABEL_236:
  if ([obja count])
  {
    [obja sortUsingComparator:&__block_literal_global_384];
    v1277 = 0u;
    v1276 = 0u;
    v1275 = 0u;
    v1274 = 0u;
    uint64_t v185 = [obja countByEnumeratingWithState:&v1274 objects:&v1370 count:16];
    if (v185)
    {
      int v186 = *(void *)v1275;
      do
      {
        for (i6 = 0LL; i6 != v185; ++i6)
        {
          if (*(void *)v1275 != v186) {
            objc_enumerationMutation(obja);
          }
          unint64_t v188 = *(void **)(*((void *)&v1274 + 1) + 8 * i6);
          unsigned int v189 = (void *)MEMORY[0x186E3E5D8]();
          if (v1085)
          {
            uint64_t v190 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
            uint64_t v191 = (void *)NSString;
            v1035 = (const __CFString *)[v188 objectAtIndexedSubscript:1];
            [v188 objectAtIndexedSubscript:0];
            uint64_t v192 = -[NSSQLiteStatement initWithEntity:sqlString:]( v190,  "initWithEntity:sqlString:",  0,  [v191 stringWithFormat:@"UPDATE ANSCKRECORDMETADATA SET ZENTITYID = %@ WHERE ZENTITYID = %@"]);
            [*(id *)(v20 + 208) addObject:v192];
          }

          if (v1081)
          {
            unint64_t v193 = objc_alloc(&OBJC_CLASS___NSSQLiteStatement);
            unint64_t v194 = (void *)NSString;
            v1035 = (const __CFString *)[v188 objectAtIndexedSubscript:1];
            [v188 objectAtIndexedSubscript:0];
            int v195 = -[NSSQLiteStatement initWithEntity:sqlString:]( v193,  "initWithEntity:sqlString:",  0,  [v194 stringWithFormat:@"UPDATE ANSCKHISTORYANALYZERSTATE SET ZENTITYID = %@ WHERE ZENTITYID = %@"]);
            [*(id *)(v20 + 208) addObject:v195];
          }

          objc_autoreleasePoolPop(v189);
        }

        uint64_t v185 = [obja countByEnumeratingWithState:&v1274 objects:&v1370 count:16];
      }

      while (v185);
    }
  }

  if (([*(id *)(v20 + 208) count] != 0) | v1097 & 1)
  {
    v196 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(v20 + 8), "metadata"), "mutableCopy");
    [v196 setObject:MEMORY[0x189604A60] forKey:@"PFCloudKitMetadataNeedsZoneFetchAfterClientMigrationKey"];
    v197 = *(void *)(v20 + 8);
    if (v197) {
      -[NSSQLCore _setMetadata:clean:](v197, v196, 0);
    }
  }

  unint64_t v198 = (void *)[MEMORY[0x189603FA8] array];
  v1273 = 0u;
  v1272 = 0u;
  v1271 = 0u;
  v1270 = 0u;
  unint64_t v199 = [v1130 countByEnumeratingWithState:&v1270 objects:&v1366 count:16];
  if (v199)
  {
    uint64_t v200 = *(void *)v1271;
    do
    {
      for (i7 = 0LL; i7 != v199; ++i7)
      {
        if (*(void *)v1271 != v200) {
          objc_enumerationMutation(v1130);
        }
        uint64_t v202 = *(void **)(*((void *)&v1270 + 1) + 8 * i7);
      }

      unint64_t v199 = [v1130 countByEnumeratingWithState:&v1270 objects:&v1366 count:16];
    }

    while (v199);
  }

  if ([v198 count])
  {
    v1086 = (id)MEMORY[0x186E3E5D8]();
    size_t v203 = (void *)[MEMORY[0x189603FA8] array];
    v1098 = (id)[MEMORY[0x189603FA8] array];
    v1269 = 0u;
    v1268 = 0u;
    v1267 = 0u;
    v1266 = 0u;
    uint64_t v204 = [v198 countByEnumeratingWithState:&v1266 objects:&v1362 count:16];
    if (v204)
    {
      uint64_t v205 = *(void *)v1267;
      do
      {
        for (i8 = 0LL; i8 != v204; ++i8)
        {
          if (*(void *)v1267 != v205) {
            objc_enumerationMutation(v198);
          }
          unint64_t v207 = *(void **)(*((void *)&v1266 + 1) + 8 * i8);
          uint64_t v208 = (void *)MEMORY[0x186E3E5D8]();
          v209 = (void *)objc_msgSend((id)objc_msgSend(v207, "sqlString"), "componentsSeparatedByString:", @" ");
          if ([v209 count] == 6)
          {
            objc_msgSend(v203, "addObject:", objc_msgSend(v209, "objectAtIndexedSubscript:", 2));
            objc_msgSend(v1098, "addObject:", objc_msgSend(v209, "lastObject"));
          }

          objc_autoreleasePoolPop(v208);
        }

        uint64_t v204 = [v198 countByEnumeratingWithState:&v1266 objects:&v1362 count:16];
      }

      while (v204);
    }

    unint64_t v210 = (void *)[MEMORY[0x189603FA8] array];
    unint64_t v211 = (void *)[MEMORY[0x189603FA8] array];
    for (i9 = 0; [v203 count] > i9; ++i9)
    {
      v213 = (void *)MEMORY[0x186E3E5D8]();
      unint64_t v214 = (void *)[v203 objectAtIndexedSubscript:i9];
      unint64_t v215 = [v1098 objectAtIndexedSubscript:i9];
      int v216 = [v214 stringByAppendingString:@"TEMP"];
      uint64_t v217 = -[NSSQLiteAdapter newRenameTableStatementFrom:to:](*(NSSQLiteStatement **)(v20 + 32), (uint64_t)v214, v216);
      [v210 addObject:v217];
      uint64_t v218 = -[NSSQLiteAdapter newRenameTableStatementFrom:to:](*(NSSQLiteStatement **)(v20 + 32), v216, v215);
      [v211 addObject:v218];

      objc_autoreleasePoolPop(v213);
    }

    [v1130 removeObjectsInArray:v198];
    objc_msgSend( v1130,  "insertObjects:atIndexes:",  v211,  objc_msgSend(MEMORY[0x1896078D0], "indexSetWithIndexesInRange:", 0, objc_msgSend(v211, "count")));
    objc_msgSend( v1130,  "insertObjects:atIndexes:",  v210,  objc_msgSend(MEMORY[0x1896078D0], "indexSetWithIndexesInRange:", 0, objc_msgSend(v210, "count")));
    objc_autoreleasePoolPop(v1086);
  }

  v1265 = 0u;
  v1264 = 0u;
  v1263 = 0u;
  v1262 = 0u;
  uint64_t v219 = [v1110 countByEnumeratingWithState:&v1262 objects:&v1358 count:16];
  if (v219)
  {
    uint64_t v220 = *(void *)v1263;
    do
    {
      for (i10 = 0LL; i10 != v219; ++i10)
      {
        if (*(void *)v1263 != v220) {
          objc_enumerationMutation(v1110);
        }
        uint64_t v222 = *(void *)(*((void *)&v1262 + 1) + 8 * i10);
        uint64_t v223 = (void *)MEMORY[0x186E3E5D8]();
        -[_NSSQLTableMigrationDescription appendStatementsToCreateOrDropTables:migrationContext:](v222, v1130, v20);
        objc_autoreleasePoolPop(v223);
      }

      uint64_t v219 = [v1110 countByEnumeratingWithState:&v1262 objects:&v1358 count:16];
    }

    while (v219);
  }

  v1261 = 0u;
  v1260 = 0u;
  v1259 = 0u;
  v1258 = 0u;
  uint64_t v224 = [v1110 countByEnumeratingWithState:&v1258 objects:&v1354 count:16];
  if (v224)
  {
    uint64_t v225 = *(void *)v1259;
    do
    {
      for (i11 = 0LL; i11 != v224; ++i11)
      {
        if (*(void *)v1259 != v225) {
          objc_enumerationMutation(v1110);
        }
        uint64_t v227 = *(void *)(*((void *)&v1258 + 1) + 8 * i11);
        uint64_t v228 = (void *)MEMORY[0x186E3E5D8]();
        -[_NSSQLTableMigrationDescription appendStatementsToPerformMigration:migrationContext:](v227, v1130, v20);
        objc_autoreleasePoolPop(v228);
      }

      uint64_t v224 = [v1110 countByEnumeratingWithState:&v1258 objects:&v1354 count:16];
    }

    while (v224);
  }

  v1257 = 0u;
  v1256 = 0u;
  v1255 = 0u;
  v1254 = 0u;
  uint64_t v229 = [v1110 countByEnumeratingWithState:&v1254 objects:&v1350 count:16];
  if (v229)
  {
    uint64_t v230 = *(void *)v1255;
    do
    {
      for (i12 = 0LL; i12 != v229; ++i12)
      {
        if (*(void *)v1255 != v230) {
          objc_enumerationMutation(v1110);
        }
        uint64_t v232 = *(void *)(*((void *)&v1254 + 1) + 8 * i12);
        uint64_t v233 = (void *)MEMORY[0x186E3E5D8]();
        -[_NSSQLTableMigrationDescription appendStatementsToCompleteMigration:migrationContext:](v232, v1130, v20);
        objc_autoreleasePoolPop(v233);
      }

      uint64_t v229 = [v1110 countByEnumeratingWithState:&v1254 objects:&v1350 count:16];
    }

    while (v229);
  }

  *(void *)(v20 + 176) = objc_alloc_init(MEMORY[0x189603FA8]);
  v1250 = 0u;
  v1251 = 0u;
  v1252 = 0u;
  v1253 = 0u;
  uint64_t v234 = [v1110 countByEnumeratingWithState:&v1250 objects:&v1346 count:16];
  if (v234)
  {
    uint64_t v235 = *(void *)v1251;
    do
    {
      for (i13 = 0LL; i13 != v234; ++i13)
      {
        if (*(void *)v1251 != v235) {
          objc_enumerationMutation(v1110);
        }
        uint64_t v237 = *(void *)(*((void *)&v1250 + 1) + 8 * i13);
        v238 = (void *)MEMORY[0x186E3E5D8]();
        -[_NSSQLTableMigrationDescription appendDefaultValueStatementsToCompleteMigration:migrationContext:]( v237,  *(void **)(v20 + 176),  v20);
        objc_autoreleasePoolPop(v238);
      }

      uint64_t v234 = [v1110 countByEnumeratingWithState:&v1250 objects:&v1346 count:16];
    }

    while (v234);
  }

  v1249 = 0u;
  v1248 = 0u;
  v1247 = 0u;
  v1246 = 0u;
  v239 = *(void *)(v20 + 16);
  if (v239) {
    unint64_t v240 = *(void **)(v239 + 32);
  }
  else {
    unint64_t v240 = 0LL;
  }
  uint64_t v241 = [v240 countByEnumeratingWithState:&v1246 objects:&v1342 count:16];
  if (v241)
  {
    uint64_t v242 = *(void *)v1247;
    do
    {
      for (i14 = 0LL; i14 != v241; ++i14)
      {
        if (*(void *)v1247 != v242) {
          objc_enumerationMutation(v240);
        }
        unint64_t v244 = *(void *)(*((void *)&v1246 + 1) + 8 * i14);
        id v245 = (void *)MEMORY[0x186E3E5D8]();
        uint64_t v246 = -[NSSQLiteAdapter newCreateIndexStatementsForEntity:defaultIndicesOnly:](*(void *)(v20 + 32), v244, 0);
        [v1130 addObjectsFromArray:v246];

        objc_autoreleasePoolPop(v245);
      }

      uint64_t v241 = [v240 countByEnumeratingWithState:&v1246 objects:&v1342 count:16];
    }

    while (v241);
  }

  objc_autoreleasePoolPop(v1042);
  v1049 = v1130;
LABEL_313:
  objc_autoreleasePoolPop(v1045);
  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v1341[0] = @"Creation of entity migration statements";
  v1341[1] = [MEMORY[0x189607968] numberWithDouble:v247 - v19];
  objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1341, 2),  @"1.1");
  if (!v1049)
  {
    v309 = (void *)MEMORY[0x189607870];
    v1035 = @"reason";
    v310 = [MEMORY[0x189603F68] dictionaryWithObjectsAndKeys:@"Failed to generate statements to perform migration"];
    v311 = (id)[v309 errorWithDomain:*MEMORY[0x189607460] code:134110 userInfo:v310];
    v1132 = 0LL;
    v1083 = 0LL;
    v1049 = 0LL;
    v312 = 0;
    v313 = v1141;
    *(void *)(*(void *)(*(void *)(v1141 + 40) + 8LL) + 40LL) = v311;
    *(_BYTE *)(*(void *)(*(void *)(v1141 + 48) + 8LL) + 24LL) = 0;
    goto LABEL_1005;
  }

  if ([*(id *)(*(void *)(v1141 + 32) + 72) count])
  {
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Creating statements to update entity keys",  v248,  v249,  v250,  v251,  v252,  v253,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    uint64_t v255 = v254;
    v1040 = (void *)MEMORY[0x186E3E5D8]();
    uint64_t v256 = *(void *)(v1141 + 32);
    if (v256 && [*(id *)(v256 + 72) count])
    {
      v1036 = (void *)MEMORY[0x186E3E5D8]();
      v1065 = (void *)objc_msgSend( objc_alloc(MEMORY[0x189603FA8]),  "initWithCapacity:",  2 * objc_msgSend(*(id *)(v256 + 72), "count"));
      v1131 = (id)objc_msgSend( objc_alloc(MEMORY[0x189603FC8]),  "initWithCapacity:",  objc_msgSend(*(id *)(v256 + 72), "count"));
      v1099 = (id)objc_msgSend( objc_alloc(MEMORY[0x189603FC8]),  "initWithCapacity:",  objc_msgSend(*(id *)(v256 + 72), "count"));
      v1357 = 0u;
      v1356 = 0u;
      v1355 = 0u;
      v1354 = 0u;
      v257 = *(void **)(v256 + 72);
      v258 = [v257 countByEnumeratingWithState:&v1354 objects:&v1372 count:16];
      if (v258)
      {
        v259 = *(void *)v1355;
        do
        {
          v260 = 0LL;
          do
          {
            if (*(void *)v1355 != v259) {
              objc_enumerationMutation(v257);
            }
            v261 = *(void *)(*((void *)&v1354 + 1) + 8 * v260);
            v262 = (void *)MEMORY[0x186E3E5D8]();
            v263 = [*(id *)(v256 + 24) entityNamed:v261];
            v264 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(v256 + 72), "objectForKey:", v261), "rootEntity");
            v265 = (void *)objc_msgSend(v1131, "objectForKey:", objc_msgSend(v264, "name"));
            if (v265)
            {
              [v265 addObject:v263];
            }

            else
            {
              v266 = (void *)objc_msgSend(objc_alloc(MEMORY[0x189603FA8]), "initWithObjects:", v263, 0);
              objc_msgSend(v1131, "setObject:forKey:", v266, objc_msgSend(v264, "name"));
            }

            v267 = (void *)objc_msgSend(v1099, "objectForKey:", objc_msgSend(v264, "name"));
            if (v267)
            {
              if (v263) {
                v268 = *(unsigned int *)(v263 + 184);
              }
              else {
                v268 = 0LL;
              }
              objc_msgSend(v267, "appendFormat:", @",%u", v268);
            }

            else
            {
              v269 = objc_alloc(MEMORY[0x189607940]);
              if (v263) {
                v270 = *(unsigned int *)(v263 + 184);
              }
              else {
                v270 = 0LL;
              }
              v271 = (void *)objc_msgSend(v269, "initWithFormat:", @"%u", v270);
              objc_msgSend(v1099, "setObject:forKey:", v271, objc_msgSend(v264, "name"));
            }

            objc_autoreleasePoolPop(v262);
            ++v260;
          }

          while (v258 != v260);
          v272 = [v257 countByEnumeratingWithState:&v1354 objects:&v1372 count:16];
          v258 = v272;
        }

        while (v272);
      }

      v1353 = 0u;
      v1352 = 0u;
      v1351 = 0u;
      v1350 = 0u;
      v1038 = *(id *)(v256 + 128);
      v273 = [v1038 countByEnumeratingWithState:&v1350 objects:&v1370 count:16];
      if (v273)
      {
        v1039 = *(void *)v1351;
        do
        {
          v1046 = 0LL;
          v1037 = (id)v273;
          do
          {
            if (*(void *)v1351 != v1039) {
              objc_enumerationMutation(v1038);
            }
            v274 = *(void *)(*((void *)&v1350 + 1) + 8LL * (void)v1046);
            v1043 = (void *)MEMORY[0x186E3E5D8]();
            v275 = (void *)[*(id *)(v256 + 16) entityNamed:v274];
            v276 = (void *)objc_msgSend(v1131, "objectForKey:", objc_msgSend(v275, "name"));
            if ([v276 count])
            {
              v1111 = (id)objc_msgSend(v1099, "objectForKey:", objc_msgSend(v275, "name"));
              v277 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:@"UPDATE OR FAIL "];
              objc_msgSend(v277, "appendString:", objc_msgSend(v275, "tableName"));
              [v277 appendString:@" SET "];
              [v277 appendString:@"Z_ENT"];
              objc_msgSend(v277, "appendString:", @" =(CASE");
              v1349 = 0u;
              v1348 = 0u;
              v1347 = 0u;
              v1346 = 0u;
              v278 = [v276 countByEnumeratingWithState:&v1346 objects:&v1366 count:16];
              v279 = v275;
              if (!v278) {
                goto LABEL_358;
              }
              v280 = *(void *)v1347;
              while (1)
              {
                v281 = 0LL;
                do
                {
                  if (*(void *)v1347 != v280) {
                    objc_enumerationMutation(v276);
                  }
                  v282 = *(unsigned int **)(*((void *)&v1346 + 1) + 8 * v281);
                  v283 = objc_msgSend(*(id *)(v256 + 72), "objectForKey:", objc_msgSend(v282, "name"));
                  [v277 appendString:@" WHEN "];
                  [v277 appendString:@"Z_ENT"];
                  if (v282)
                  {
                    v284 = v282[46];
                    if (v283) {
                      goto LABEL_352;
                    }
                  }

                  else
                  {
                    v284 = 0LL;
                    if (v283)
                    {
LABEL_352:
                      v285 = *(unsigned int *)(v283 + 184);
                      goto LABEL_353;
                    }
                  }

                  v285 = 0LL;
LABEL_353:
                  objc_msgSend(v277, "appendFormat:", @" = %d THEN %d", v284, v285);
                  ++v281;
                }

                while (v278 != v281);
                v286 = [v276 countByEnumeratingWithState:&v1346 objects:&v1366 count:16];
                v278 = v286;
                if (!v286)
                {
LABEL_358:
                  [v277 appendString:@" ELSE "];
                  v275 = v279;
                  [v277 appendString:@"Z_ENT"];
                  [v277 appendString:@" END WHERE "]);
                  [v277 appendString:@"Z_ENT"];
                  objc_msgSend(v277, "appendString:", @" IN (");
                  [v277 appendString:v1111];
                  [v277 appendString:@""]);
                  v287 = -[NSSQLiteAdapter newStatementWithSQLString:]( *(NSSQLiteStatement **)(v256 + 32),  (uint64_t)v277);
                  [v1065 addObject:v287];

                  break;
                }
              }
            }

            v1345 = 0u;
            v1344 = 0u;
            v1343 = 0u;
            v1342 = 0u;
            if (v275)
            {
              v288 = v275;
              do
              {
                if (!v288) {
                  goto LABEL_390;
                }
                v289 = v288;
                v288 = (void *)v288[21];
              }

              while (v288 != v289);
              v290 = (void *)v289[9];
            }

            else
            {
LABEL_390:
              v290 = 0LL;
            }

            v291 = [v290 countByEnumeratingWithState:&v1342 objects:&v1362 count:16];
            v1060 = v275;
            if (!v291) {
              goto LABEL_388;
            }
            v292 = *(void *)v1343;
            contextb = v290;
            v1051 = *(void *)v1343;
            do
            {
              v293 = 0LL;
              v1069 = v291;
              do
              {
                if (*(void *)v1343 != v292) {
                  objc_enumerationMutation(v290);
                }
                v294 = *(_BYTE **)(*((void *)&v1342 + 1) + 8LL * (void)v293);
                v1112 = (id)MEMORY[0x186E3E5D8]();
                if (v294)
                {
                  if (v294[24] == 4)
                  {
                    v295 = (void *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v294, "toOneRelationship"), "destinationEntity"),  "rootEntity");
                    v296 = (void *)objc_msgSend(v1131, "objectForKey:", objc_msgSend(v295, "name"));
                    if ([v296 count])
                    {
                      v1082 = (id)objc_msgSend(v1099, "objectForKey:", objc_msgSend(v295, "name"));
                      v297 = [v294 columnName];
                      v298 = (void *)[objc_alloc(MEMORY[0x189607940]) initWithString:@"UPDATE OR FAIL "];
                      objc_msgSend(v298, "appendString:", objc_msgSend(v1060, "tableName"));
                      [v298 appendString:@" SET "];
                      [v298 appendString:v297];
                      objc_msgSend(v298, "appendString:", @" =(CASE");
                      v1281 = 0u;
                      v1280 = 0u;
                      v1279 = 0u;
                      v1278 = 0u;
                      v299 = [v296 countByEnumeratingWithState:&v1278 objects:&v1358 count:16];
                      objb = v293;
                      v300 = v256;
                      if (!v299) {
                        goto LABEL_385;
                      }
                      v301 = *(void *)v1279;
                      while (1)
                      {
                        v302 = 0LL;
                        do
                        {
                          if (*(void *)v1279 != v301) {
                            objc_enumerationMutation(v296);
                          }
                          v303 = *(unsigned int **)(*((void *)&v1278 + 1) + 8 * v302);
                          v304 = objc_msgSend(*(id *)(v300 + 72), "objectForKey:", objc_msgSend(v303, "name"));
                          [v298 appendString:@" WHEN "];
                          [v298 appendString:v297];
                          if (v303)
                          {
                            v305 = v303[46];
                            if (v304) {
                              goto LABEL_379;
                            }
                          }

                          else
                          {
                            v305 = 0LL;
                            if (v304)
                            {
LABEL_379:
                              v306 = *(unsigned int *)(v304 + 184);
                              goto LABEL_380;
                            }
                          }

                          v306 = 0LL;
LABEL_380:
                          objc_msgSend(v298, "appendFormat:", @" = %d THEN %d", v305, v306);
                          ++v302;
                        }

                        while (v299 != v302);
                        v307 = [v296 countByEnumeratingWithState:&v1278 objects:&v1358 count:16];
                        v299 = v307;
                        if (!v307)
                        {
LABEL_385:
                          [v298 appendString:@" ELSE "];
                          uint64_t v256 = v300;
                          v290 = contextb;
                          v292 = v1051;
                          v291 = v1069;
                          v293 = objb;
                          [v298 appendString:v297];
                          [v298 appendString:@" END WHERE "]);
                          [v298 appendString:v297];
                          objc_msgSend(v298, "appendString:", @" IN (");
                          [v298 appendString:v1082];
                          [v298 appendString:@""]);
                          v308 = -[NSSQLiteAdapter newStatementWithSQLString:]( *(NSSQLiteStatement **)(v256 + 32),  (uint64_t)v298);
                          [v1065 addObject:v308];

                          break;
                        }
                      }
                    }
                  }
                }

                objc_autoreleasePoolPop(v1112);
                v293 = (char *)v293 + 1;
              }

              while (v293 != (id)v291);
              v291 = [v290 countByEnumeratingWithState:&v1342 objects:&v1362 count:16];
            }

            while (v291);
LABEL_388:
            objc_autoreleasePoolPop(v1043);
            v1046 = (char *)v1046 + 1;
          }

          while (v1046 != v1037);
          v273 = [v1038 countByEnumeratingWithState:&v1350 objects:&v1370 count:16];
        }

        while (v273);
      }

      objc_autoreleasePoolPop(v1036);
      v1083 = v1065;
    }

    else
    {
      v1083 = 0LL;
    }

    objc_autoreleasePoolPop(v1040);
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1340[0] = @"Creation of update entity keys statements";
    v1340[1] = [MEMORY[0x189607968] numberWithDouble:v314 - v255];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1340, 2),  @"1.2");
  }

  else
  {
    v1083 = 0LL;
  }

  if (*(_BYTE *)(*(void *)(v1141 + 32) + 136LL))
  {
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Creating statements to update primary key table",  v248,  v249,  v250,  v251,  v252,  v253,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v316 = v315;
    v1066 = (void *)MEMORY[0x186E3E5D8]();
    v317 = *(void *)(v1141 + 32);
    if (v317)
    {
      v1061 = (void *)MEMORY[0x186E3E5D8]();
      *(void *)(v317 + 144) = objc_alloc_init(MEMORY[0x189603FA8]);
      v1113 = (NSString *)[objc_alloc(NSString) initWithFormat:@"ALTER TABLE %@ RENAME TO %@_ORIG", @"Z_PRIMARYKEY", @"Z_PRIMARYKEY"];
      v318 = -[NSSQLiteStatement initWithEntity:](objc_alloc(&OBJC_CLASS___NSSQLiteStatement), "initWithEntity:", 0LL);
      v319 = v318;
      if (v318)
      {
        sqlString = v318->_sqlString;
        if (sqlString != v1113)
        {

          v319->_sqlString = (NSString *)-[NSString copy](v1113, "copy");
        }
      }

      [*(id *)(v317 + 144) addObject:v319];
      PrimaryKeyTable = -[NSSQLiteAdapter newCreatePrimaryKeyTableStatement](*(NSSQLiteStatement **)(v317 + 32));
      [*(id *)(v317 + 144) addObject:PrimaryKeyTable];

      v322 = *(void *)(v317 + 16);
      if (v322) {
        v323 = *(void **)(v322 + 32);
      }
      else {
        v323 = 0LL;
      }
      v1353 = 0u;
      v1352 = 0u;
      v1351 = 0u;
      v1350 = 0u;
      v324 = [v323 countByEnumeratingWithState:&v1350 objects:&v1372 count:16];
      if (v324)
      {
        v325 = *(void *)v1351;
        do
        {
          v326 = 0LL;
          do
          {
            if (*(void *)v1351 != v325) {
              objc_enumerationMutation(v323);
            }
            v327 = *(void *)(*((void *)&v1350 + 1) + 8 * v326);
            v328 = (void *)MEMORY[0x186E3E5D8]();
            if (v327) {
              v329 = *(void *)(v327 + 160) == 0LL;
            }
            else {
              v329 = 0LL;
            }
            v330 = -[NSSQLiteAdapter newPrimaryKeyInitializeStatementForEntity:withInitialMaxPK:]( *(NSSQLiteStatement **)(v317 + 32),  v327,  v329 << 63 >> 63);
            [*(id *)(v317 + 144) addObject:v330];

            objc_autoreleasePoolPop(v328);
            ++v326;
          }

          while (v324 != v326);
          v331 = [v323 countByEnumeratingWithState:&v1350 objects:&v1372 count:16];
          v324 = v331;
        }

        while (v331);
      }

      v1070 = (void *)MEMORY[0x186E3E5D8]();
      v1349 = 0u;
      v1348 = 0u;
      v1347 = 0u;
      v1346 = 0u;
      v332 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(v317 + 8), "ancillarySQLModels"), "allValues");
      v333 = [v332 countByEnumeratingWithState:&v1346 objects:&v1370 count:16];
      if (v333)
      {
        v1087 = *(id *)v1347;
        objc = v332;
        do
        {
          v334 = 0LL;
          v1100 = (id)v333;
          do
          {
            if (*(id *)v1347 != v1087) {
              objc_enumerationMutation(objc);
            }
            v335 = *(void *)(*((void *)&v1346 + 1) + 8LL * (void)v334);
            v1342 = 0u;
            v1343 = 0u;
            v1344 = 0u;
            v1345 = 0u;
            if (v335) {
              v336 = *(void **)(v335 + 32);
            }
            else {
              v336 = 0LL;
            }
            v337 = [v336 countByEnumeratingWithState:&v1342 objects:&v1366 count:16];
            if (v337)
            {
              v338 = *(void *)v1343;
              do
              {
                v339 = 0LL;
                do
                {
                  if (*(void *)v1343 != v338) {
                    objc_enumerationMutation(v336);
                  }
                  v340 = *(void *)(*((void *)&v1342 + 1) + 8 * v339);
                  v341 = (void *)MEMORY[0x186E3E5D8]();
                  if (v340) {
                    v342 = *(void *)(v340 + 160) == 0LL;
                  }
                  else {
                    v342 = 0LL;
                  }
                  v343 = -[NSSQLiteAdapter newPrimaryKeyInitializeStatementForEntity:withInitialMaxPK:]( *(NSSQLiteStatement **)(v317 + 32),  v340,  v342 << 63 >> 63);
                  [*(id *)(v317 + 144) addObject:v343];

                  objc_autoreleasePoolPop(v341);
                  ++v339;
                }

                while (v337 != v339);
                v344 = [v336 countByEnumeratingWithState:&v1342 objects:&v1366 count:16];
                v337 = v344;
              }

              while (v344);
            }

            v334 = (char *)v334 + 1;
          }

          while (v334 != v1100);
          v345 = [objc countByEnumeratingWithState:&v1346 objects:&v1370 count:16];
          v333 = v345;
        }

        while (v345);
      }

      objc_autoreleasePoolPop(v1070);
      v1281 = 0u;
      v1280 = 0u;
      v1279 = 0u;
      v1278 = 0u;
      v346 = *(void **)(v317 + 96);
      v347 = [v346 countByEnumeratingWithState:&v1278 objects:&v1362 count:16];
      if (v347)
      {
        v348 = *(void *)v1279;
        do
        {
          v349 = 0LL;
          do
          {
            if (*(void *)v1279 != v348) {
              objc_enumerationMutation(v346);
            }
            v350 = *(void *)(*((void *)&v1278 + 1) + 8 * v349);
            v351 = (void *)MEMORY[0x186E3E5D8]();
            v352 = [*(id *)(v317 + 96) valueForKey:v350];
            if (v352)
            {
              v353 = *(void *)(v352 + 32);
              if (v353)
              {
                if (!*(void *)(v353 + 160))
                {
                  if ([*(id *)(v353 + 152) count])
                  {
                    v354 = -[_NSSQLiteStoreMigrator _originalRootsForAddedEntity:](v317, (void *)v353);
                    v355 = v354;
                    if (!v354 || ![v354 count]) {
                      goto LABEL_461;
                    }
                    if ([v355 count] == 1)
                    {
                      v356 = objc_alloc(NSString);
                      v357 = [v355 lastObject];
                      if (v357) {
                        v358 = *(unsigned int *)(v357 + 184);
                      }
                      else {
                        v358 = 0LL;
                      }
                      v1113 = (NSString *)[v356 initWithFormat:@"UPDATE OR FAIL %@ SET %@ = (SELECT %@ FROM %@_ORIG WHERE %@ = %d) WHERE %@ = %d", @"Z_PRIMARYKEY", @"Z_MAX", @"Z_MAX", @"Z_PRIMARYKEY", @"Z_ENT", v358, @"Z_ENT", *(unsigned int *)(v353 + 184)];
                    }

                    else
                    {
                      v360 = v1113;
                    }

                    v359 = -[NSSQLiteStatement initWithEntity:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:",  0LL);
                  }

                  else
                  {
                    v1113 = (NSString *)[objc_alloc(NSString) initWithFormat:@"UPDATE OR FAIL %@ SET %@ = 0 WHERE %@ = %d", @"Z_PRIMARYKEY", @"Z_MAX", @"Z_ENT", *(unsigned int *)(v353 + 184)];
                    v359 = -[NSSQLiteStatement initWithEntity:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:",  0LL);
                  }

                  v361 = v359;
                  if (v359)
                  {
                    v362 = v359->_sqlString;
                    if (v362 != v1113)
                    {

                      v361->_sqlString = (NSString *)-[NSString copy](v1113, "copy");
                    }
                  }

                  [*(id *)(v317 + 144) addObject:v361];
                }
              }
            }

LABEL_461:
            objc_autoreleasePoolPop(v351);
            ++v349;
          }

          while (v347 != v349);
          v363 = [v346 countByEnumeratingWithState:&v1278 objects:&v1362 count:16];
          v347 = v363;
        }

        while (v363);
      }

      v1277 = 0u;
      v1276 = 0u;
      v1275 = 0u;
      v1274 = 0u;
      v1114 = *(id *)(v317 + 120);
      v364 = [v1114 countByEnumeratingWithState:&v1274 objects:&v1358 count:16];
      if (v364)
      {
        v365 = *(void *)v1275;
        do
        {
          v366 = 0LL;
          do
          {
            if (*(void *)v1275 != v365) {
              objc_enumerationMutation(v1114);
            }
            v367 = *(void *)(*((void *)&v1274 + 1) + 8 * v366);
            v368 = (void *)MEMORY[0x186E3E5D8]();
            v369 = (void *)[*(id *)(v317 + 120) valueForKey:v367];
            if (v369)
            {
              v370 = v369[4];
              if (v370)
              {
                if (!*(void *)(v370 + 160))
                {
                  v371 = [v369 sourceEntity];
                  v372 = objc_alloc(NSString);
                  if (v371) {
                    v373 = *(unsigned int *)(v371 + 184);
                  }
                  else {
                    v373 = 0LL;
                  }
                  v374 = (NSString *)[v372 initWithFormat:@"UPDATE OR FAIL %@ SET %@ = (SELECT %@ FROM %@_ORIG WHERE %@ = %d) WHERE %@ = %d", @"Z_PRIMARYKEY", @"Z_MAX", @"Z_MAX", @"Z_PRIMARYKEY", @"Z_ENT", v373, @"Z_ENT", *(unsigned int *)(v370 + 184)];
                  v375 = -[NSSQLiteStatement initWithEntity:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:",  0LL);
                  v376 = v375;
                  if (v375)
                  {
                    v377 = v375->_sqlString;
                    if (v377 != v374)
                    {

                      v376->_sqlString = (NSString *)-[NSString copy](v374, "copy");
                    }
                  }

                  [*(id *)(v317 + 144) addObject:v376];
                }
              }
            }

            objc_autoreleasePoolPop(v368);
            ++v366;
          }

          while (v364 != v366);
          v378 = [v1114 countByEnumeratingWithState:&v1274 objects:&v1358 count:16];
          v364 = v378;
        }

        while (v378);
      }

      v1273 = 0u;
      v1272 = 0u;
      v1271 = 0u;
      v1270 = 0u;
      v1115 = *(id *)(v317 + 112);
      v379 = [v1115 countByEnumeratingWithState:&v1270 objects:&v1354 count:16];
      if (v379)
      {
        v380 = *(void *)v1271;
        do
        {
          for (i15 = 0LL; i15 != v379; ++i15)
          {
            if (*(void *)v1271 != v380) {
              objc_enumerationMutation(v1115);
            }
            v382 = *(void *)(*((void *)&v1270 + 1) + 8 * i15);
            v383 = (void *)MEMORY[0x186E3E5D8]();
            v384 = (void *)[*(id *)(v317 + 112) valueForKey:v382];
            if (v384)
            {
              v385 = v384[4];
              if (v385)
              {
                if (!*(void *)(v385 + 160))
                {
                  v386 = (void *)[v384 sourceEntity];
                  v387 = (uint64_t)v386;
                  if (v386 && !v386[20])
                  {
                    v388 = objc_alloc(NSString);
                  }

                  else
                  {
                    v387 = [v386 rootEntity];
                    v388 = objc_alloc(NSString);
                    if (!v387)
                    {
                      v389 = 0LL;
                      goto LABEL_497;
                    }
                  }

                  v389 = *(unsigned int *)(v387 + 184);
LABEL_497:
                  v390 = (NSString *)[v388 initWithFormat:@"UPDATE OR FAIL %@ SET %@ = (SELECT %@ FROM %@_ORIG WHERE %@ = %d) WHERE %@ = %d", @"Z_PRIMARYKEY", @"Z_MAX", @"Z_MAX", @"Z_PRIMARYKEY", @"Z_ENT", v389, @"Z_ENT", *(unsigned int *)(v385 + 184)];
                  v391 = -[NSSQLiteStatement initWithEntity:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:",  0LL);
                  v392 = v391;
                  if (v391)
                  {
                    v393 = v391->_sqlString;
                    if (v393 != v390)
                    {

                      v392->_sqlString = (NSString *)-[NSString copy](v390, "copy");
                    }
                  }

                  [*(id *)(v317 + 144) addObject:v392];
                }
              }
            }

            objc_autoreleasePoolPop(v383);
          }

          v379 = [v1115 countByEnumeratingWithState:&v1270 objects:&v1354 count:16];
        }

        while (v379);
      }

      v1035 = @"Z_PRIMARYKEY";
      v394 = (NSString *)[objc_alloc(NSString) initWithFormat:@"DROP TABLE %@_ORIG"];
      v395 = -[NSSQLiteStatement initWithEntity:](objc_alloc(&OBJC_CLASS___NSSQLiteStatement), "initWithEntity:", 0LL);
      v396 = v395;
      if (v395)
      {
        v397 = v395->_sqlString;
        if (v397 != v394)
        {

          v396->_sqlString = (NSString *)-[NSString copy](v394, "copy");
        }
      }

      [*(id *)(v317 + 144) addObject:v396];
      objc_autoreleasePoolPop(v1061);
    }

    objc_autoreleasePoolPop(v1066);
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1339[0] = @"Creation of update primary key table statements";
    v1339[1] = [MEMORY[0x189607968] numberWithDouble:v398 - v316];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1339, 2),  @"1.3");
  }

  if (*(_BYTE *)(v1141 + 64)) {
    _NSCoreDataLog( 4LL,  (uint64_t)@"Finished creating schema migration statements",  v248,  v249,  v250,  v251,  v252,  v253,  (uint64_t)v1035);
  }
  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v1338[0] = @"Total preparation time for schema migration statements";
  v1338[1] = [MEMORY[0x189607968] numberWithDouble:v399 - v19];
  objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1338, 2),  @"1.0");
  if (*(_BYTE *)(v1141 + 64)) {
    _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning formal transaction",  v400,  v401,  v402,  v403,  v404,  v405,  (uint64_t)v1035);
  }
  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v407 = v406;
  -[NSSQLiteConnection beginTransaction](*(void *)(*(void *)(v1141 + 32) + 48LL));
  v414 = *(void *)(v1141 + 32);
  if (v414 && *(_BYTE *)(v414 + 218))
  {
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning forced migration",  v408,  v409,  v410,  v411,  v412,  v413,  (uint64_t)v1035);
    }
  }

  else
  {
    if (*(_BYTE *)(v1141 + 64))
    {
      _NSCoreDataLog(4LL, (uint64_t)@"Checking metadata", v408, v409, v410, v411, v412, v413, (uint64_t)v1035);
      v414 = *(void *)(v1141 + 32);
    }

    if (v414) {
      v415 = *(void **)(v414 + 16);
    }
    else {
      v415 = 0LL;
    }
    v416 = -[NSManagedObjectModel _entityVersionHashesDigest]((id)[v415 managedObjectModel]);
    -[NSSQLiteConnection fetchMetadata](*(void *)(*(void *)(v1141 + 32) + 48LL));
    if (objc_msgSend((id)objc_msgSend(v417, "objectForKey:", 0x189EB9D88), "isEqualToString:", v416))
    {
      _NSCoreDataLog( 2LL,  (uint64_t)@"Migration was completed by another client",  v418,  v419,  v420,  v421,  v422,  v423,  (uint64_t)v1035);
      v1132 = 0LL;
      goto LABEL_522;
    }
  }

  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  __int128 v19 = v468;
  v1337[0] = @"Beginning formal transaction";
  v1337[1] = [MEMORY[0x189607968] numberWithDouble:v468 - v407];
  objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1337, 2),  @"2.1");
  if (objc_msgSend( (id)objc_msgSend(*(id *)(*(void *)(v1141 + 32) + 152), "objectForKey:", @"deleted"),  "count"))
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v476 = v475;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin dropping attribute extensions.",  v469,  v470,  v471,  v472,  v473,  v474,  (uint64_t)v1035);
    }
    v1245 = 0u;
    v1244 = 0u;
    v1243 = 0u;
    v1242 = 0u;
    v477 = (void *)[*(id *)(*(void *)(v1141 + 32) + 152) objectForKey:@"deleted"];
    v478 = [v477 countByEnumeratingWithState:&v1242 objects:v1336 count:16];
    if (v478)
    {
      v1116 = *(id *)v1243;
      v1088 = v477;
      do
      {
        v485 = 0LL;
        v1101 = (id)v478;
        do
        {
          if (*(id *)v1243 != v1116) {
            objc_enumerationMutation(v1088);
          }
          v486 = *(void **)(*((void *)&v1242 + 1) + 8LL * (void)v485);
          v1133 = (id)MEMORY[0x186E3E5D8]();
          v487 = [v486 validate:*(void *)(v1141 + 56)];
          if (v487)
          {
            v1241 = 0u;
            v1240 = 0u;
            v1239 = 0u;
            v1238 = 0u;
            v488 = (void *)[v486 dropSQLStrings];
            v489 = [v488 countByEnumeratingWithState:&v1238 objects:v1335 count:16];
            if (v489)
            {
              v490 = *(void *)v1239;
              do
              {
                for (i16 = 0LL; i16 != v489; ++i16)
                {
                  if (*(void *)v1239 != v490) {
                    objc_enumerationMutation(v488);
                  }
                  v492 = *(void *)(*((void *)&v1238 + 1) + 8 * i16);
                  v493 = (void *)MEMORY[0x186E3E5D8]();
                  v494 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  0LL,  v492);
                  v501 = v494;
                  if (*(_BYTE *)(v1141 + 64)) {
                    _NSCoreDataLog( 4LL,  (uint64_t)@"Executing drop attribute extension statement: %@",  v495,  v496,  v497,  v498,  v499,  v500,  (uint64_t)v494);
                  }
                  -[NSSQLiteConnection prepareAndExecuteSQLStatement:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  v501);

                  objc_autoreleasePoolPop(v493);
                }

                v489 = [v488 countByEnumeratingWithState:&v1238 objects:v1335 count:16];
              }

              while (v489);
            }
          }

          else
          {
            v502 = *(id *)(*(void *)(*(void *)(v1141 + 40) + 8LL) + 40LL);
            *(_BYTE *)(*(void *)(*(void *)(v1141 + 48) + 8LL) + 24LL) = 0;
          }

          objc_autoreleasePoolPop(v1133);
          if (!v487)
          {
LABEL_844:
            v1132 = 0LL;
            v312 = 1;
            v313 = v1141;
LABEL_1005:
            -[NSSQLiteConnection endFetchAndRecycleStatement:](*(void *)(*(void *)(v313 + 32) + 48LL), 0);

            if (!*(_BYTE *)(*(void *)(*(void *)(v1141 + 48) + 8LL) + 24LL) && *(_BYTE *)(v1141 + 64)) {
              _NSCoreDataLog( 4LL,  (uint64_t)@"Failed lightweight migration on connection",  v1029,  v1030,  v1031,  v1032,  v1033,  v1034,  (uint64_t)v1035);
            }
            if (*(_BYTE *)(v1141 + 65)) {
              -[NSSQLiteConnection _executeSQLString:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  @"pragma cache_size = 512");
            }
            if (v312)
            {
              if (*(_BYTE *)(v1141 + 64)) {
                _NSCoreDataLog( 4LL,  (uint64_t)@"Rolling back formal transaction",  v1029,  v1030,  v1031,  v1032,  v1033,  v1034,  (uint64_t)v1035);
              }
              -[NSSQLiteConnection rollbackTransaction](*(void *)(*(void *)(v1141 + 32) + 48LL));
              *(_BYTE *)(*(void *)(*(void *)(v1141 + 48) + 8LL) + 24LL) = 0;
            }

            return;
          }

          v485 = (char *)v485 + 1;
        }

        while (v485 != v1101);
        v478 = [v1088 countByEnumeratingWithState:&v1242 objects:v1336 count:16];
      }

      while (v478);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished dropping attribute extensions.",  v479,  v480,  v481,  v482,  v483,  v484,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1334[0] = @"Drop attribute extensions";
    v1334[1] = [MEMORY[0x189607968] numberWithDouble:v503 - v476];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1334, 2),  @"2.2");
  }

  if ([*(id *)(*(void *)(v1141 + 32) + 184) count])
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v511 = v510;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin dropping derived properties.",  v504,  v505,  v506,  v507,  v508,  v509,  (uint64_t)v1035);
    }
    v1237 = 0u;
    v1236 = 0u;
    v1235 = 0u;
    v1234 = 0u;
    v1117 = *(id *)(*(void *)(v1141 + 32) + 184LL);
    v518 = [v1117 countByEnumeratingWithState:&v1234 objects:v1333 count:16];
    if (v518)
    {
      v1134 = *(id *)v1235;
      do
      {
        v519 = 0LL;
        do
        {
          if (*(id *)v1235 != v1134) {
            objc_enumerationMutation(v1117);
          }
          v520 = *(void *)(*((void *)&v1234 + 1) + 8 * v519);
          v521 = (void *)MEMORY[0x186E3E5D8]();
          if (v520)
          {
            -[NSSQLEntity_DerivedAttributesExtension _generateTriggerSQL](v520);
            v522 = *(void **)(v520 + 32);
          }

          else
          {
            v522 = 0LL;
          }

          v523 = (void *)[v522 valueForKey:@"dropStatements"];
          v1233 = 0u;
          v1232 = 0u;
          v1231 = 0u;
          v1230 = 0u;
          v524 = [v523 countByEnumeratingWithState:&v1230 objects:v1332 count:16];
          if (v524)
          {
            v525 = *(void *)v1231;
            do
            {
              for (i17 = 0LL; i17 != v524; ++i17)
              {
                if (*(void *)v1231 != v525) {
                  objc_enumerationMutation(v523);
                }
                v527 = *(void **)(*((void *)&v1230 + 1) + 8 * i17);
                v534 = (void *)MEMORY[0x186E3E5D8]();
                if (*(_BYTE *)(v1141 + 64)) {
                  _NSCoreDataLog( 4LL,  (uint64_t)@"Executing drop derived property statement: %@",  v528,  v529,  v530,  v531,  v532,  v533,  (uint64_t)v527);
                }
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v527);
                objc_autoreleasePoolPop(v534);
              }

              v524 = [v523 countByEnumeratingWithState:&v1230 objects:v1332 count:16];
            }

            while (v524);
          }

          objc_autoreleasePoolPop(v521);
          ++v519;
        }

        while (v519 != v518);
        v535 = [v1117 countByEnumeratingWithState:&v1234 objects:v1333 count:16];
        v518 = v535;
      }

      while (v535);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"End dropping derived properties.",  v512,  v513,  v514,  v515,  v516,  v517,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1331[0] = @"Drop derived properties";
    v1331[1] = [MEMORY[0x189607968] numberWithDouble:v536 - v511];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1331, 2),  @"2.3");
  }

  if ([*(id *)(*(void *)(v1141 + 32) + 168) count])
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v544 = v543;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog(4LL, (uint64_t)@"Begin dropping indices.", v537, v538, v539, v540, v541, v542, (uint64_t)v1035);
    }
    v1229 = 0u;
    v1228 = 0u;
    v1227 = 0u;
    v1226 = 0u;
    v1118 = *(id *)(*(void *)(v1141 + 32) + 168LL);
    v551 = [v1118 countByEnumeratingWithState:&v1226 objects:v1330 count:16];
    if (v551)
    {
      v1135 = *(id *)v1227;
      do
      {
        for (i18 = 0LL; i18 != v551; ++i18)
        {
          if (*(id *)v1227 != v1135) {
            objc_enumerationMutation(v1118);
          }
          v553 = *(void **)(*((void *)&v1226 + 1) + 8 * i18);
          v554 = (void *)MEMORY[0x186E3E5D8]();
          v555 = (void *)[v553 dropStatementsForStore:*(void *)(*(void *)(v1141 + 32) + 8)];
          v1225 = 0u;
          v1224 = 0u;
          v1223 = 0u;
          v1222 = 0u;
          v556 = [v555 countByEnumeratingWithState:&v1222 objects:v1329 count:16];
          if (v556)
          {
            v557 = *(void *)v1223;
            do
            {
              for (i19 = 0LL; i19 != v556; ++i19)
              {
                if (*(void *)v1223 != v557) {
                  objc_enumerationMutation(v555);
                }
                v559 = *(void **)(*((void *)&v1222 + 1) + 8 * i19);
                v566 = (void *)MEMORY[0x186E3E5D8]();
                if (*(_BYTE *)(v1141 + 64)) {
                  _NSCoreDataLog( 4LL,  (uint64_t)@"Executing drop index statement: %@",  v560,  v561,  v562,  v563,  v564,  v565,  (uint64_t)v559);
                }
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v559);
                objc_autoreleasePoolPop(v566);
              }

              v556 = [v555 countByEnumeratingWithState:&v1222 objects:v1329 count:16];
            }

            while (v556);
          }

          objc_autoreleasePoolPop(v554);
        }

        v551 = [v1118 countByEnumeratingWithState:&v1226 objects:v1330 count:16];
      }

      while (v551);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished dropping indices.",  v545,  v546,  v547,  v548,  v549,  v550,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1328[0] = @"Drop indices";
    v1328[1] = [MEMORY[0x189607968] numberWithDouble:v567 - v544];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1328, 2),  @"2.4");
  }

  if ([v1049 count])
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v575 = v574;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin entity schema & data migration statements.",  v568,  v569,  v570,  v571,  v572,  v573,  (uint64_t)v1035);
    }
    v1221 = 0u;
    v1220 = 0u;
    v1219 = 0u;
    v1218 = 0u;
    v582 = [v1049 countByEnumeratingWithState:&v1218 objects:v1327 count:16];
    if (v582)
    {
      v583 = *(void *)v1219;
      do
      {
        v584 = 0LL;
        do
        {
          if (*(void *)v1219 != v583) {
            objc_enumerationMutation(v1049);
          }
          v585 = *(void **)(*((void *)&v1218 + 1) + 8 * v584);
          v592 = (void *)MEMORY[0x186E3E5D8]();
          if (*(_BYTE *)(v1141 + 64)) {
            _NSCoreDataLog( 4LL,  (uint64_t)@"Executing entity schema & data migration statement: %@",  v586,  v587,  v588,  v589,  v590,  v591,  (uint64_t)v585);
          }
          if (*(_BYTE *)(v1141 + 66))
          {
            v593 = (void *)[v585 sqlString];
            if ([v593 hasPrefix:@"CREATE TABLE Z_48ACTIONMEDIAPLAYBACKS_"])
            {
              v594 = *(void *)(*(void *)(v1141 + 32) + 48LL);
              if (!v594
                || (-[NSSQLiteConnection _hasTableWithName:isTemp:]( v594,  (uint64_t)@"Z_48ACTIONMEDIAPLAYBACKS_",  0) & 1) == 0)
              {
                goto LABEL_636;
              }

              goto LABEL_635;
            }

            if (![v593 isEqualToString:@"DROP TABLE Z_47ACTIONMEDIAPLAYBACKS_"])
            {
              v597 = [v593 isEqualToString:@"ALTER TABLE Z_47ACTIONMEDIAPLAYBACKS_TEMP RENAME TO Z_48ACTIONMEDIAPLAYBACKS_"];
              v595 = *(void *)(*(void *)(v1141 + 32) + 48LL);
              if (!v597) {
                goto LABEL_637;
              }
              if (!v595
                || !-[NSSQLiteConnection _hasTableWithName:isTemp:]( v595,  (uint64_t)@"Z_48ACTIONMEDIAPLAYBACKS_",  0))
              {
LABEL_636:
                v595 = *(void *)(*(void *)(v1141 + 32) + 48LL);
LABEL_637:
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:](v595, v585);
                goto LABEL_639;
              }

LABEL_635:
              -[NSSQLiteConnection _executeSQLString:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  @"DROP TABLE Z_48ACTIONMEDIAPLAYBACKS_");
              goto LABEL_636;
            }

            v596 = *(void *)(*(void *)(v1141 + 32) + 48LL);
            if (v596
              && -[NSSQLiteConnection _hasTableWithName:isTemp:]( v596,  (uint64_t)@"Z_47ACTIONMEDIAPLAYBACKS_",  0))
            {
              -[NSSQLiteConnection _executeSQLString:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  @"DROP TABLE Z_47ACTIONMEDIAPLAYBACKS_");
            }
          }

          else
          {
            -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v585);
          }

LABEL_639:
          objc_autoreleasePoolPop(v592);
          ++v584;
        }

        while (v582 != v584);
        v598 = [v1049 countByEnumeratingWithState:&v1218 objects:v1327 count:16];
        v582 = v598;
      }

      while (v598);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished entity schema & data migration statements.",  v576,  v577,  v578,  v579,  v580,  v581,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1326[0] = @"Execution of entity schema and data migration statements";
    v1326[1] = [MEMORY[0x189607968] numberWithDouble:v599 - v575];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1326, 2),  @"2.5");

    v1049 = 0LL;
  }

  if ([v1083 count])
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v607 = v606;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin updating entity key columns.",  v600,  v601,  v602,  v603,  v604,  v605,  (uint64_t)v1035);
    }
    v1217 = 0u;
    v1216 = 0u;
    v1215 = 0u;
    v1214 = 0u;
    v614 = [v1083 countByEnumeratingWithState:&v1214 objects:v1325 count:16];
    if (v614)
    {
      v615 = *(void *)v1215;
      do
      {
        for (i20 = 0LL; i20 != v614; ++i20)
        {
          if (*(void *)v1215 != v615) {
            objc_enumerationMutation(v1083);
          }
          v617 = *(void **)(*((void *)&v1214 + 1) + 8 * i20);
          v624 = (void *)MEMORY[0x186E3E5D8]();
          if (*(_BYTE *)(v1141 + 64)) {
            _NSCoreDataLog( 4LL,  (uint64_t)@"Executing entity key column update statement: %@",  v618,  v619,  v620,  v621,  v622,  v623,  (uint64_t)v617);
          }
          -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v617);
          objc_autoreleasePoolPop(v624);
        }

        v614 = [v1083 countByEnumeratingWithState:&v1214 objects:v1325 count:16];
      }

      while (v614);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished updating entity key columns.",  v608,  v609,  v610,  v611,  v612,  v613,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1324[0] = @"Execution of entity key column updates";
    v1324[1] = [MEMORY[0x189607968] numberWithDouble:v625 - v607];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1324, 2),  @"2.6");

    v1083 = 0LL;
  }

  v626 = *(void *)(v1141 + 32);
  if (*(_BYTE *)(v626 + 136))
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v634 = v633;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin updating primary key table.",  v627,  v628,  v629,  v630,  v631,  v632,  (uint64_t)v1035);
    }
    v1213 = 0u;
    v1212 = 0u;
    v1211 = 0u;
    v1210 = 0u;
    v635 = *(void **)(*(void *)(v1141 + 32) + 144LL);
    v642 = [v635 countByEnumeratingWithState:&v1210 objects:v1323 count:16];
    if (v642)
    {
      v643 = *(void *)v1211;
      do
      {
        for (i21 = 0LL; i21 != v642; ++i21)
        {
          if (*(void *)v1211 != v643) {
            objc_enumerationMutation(v635);
          }
          v645 = *(void **)(*((void *)&v1210 + 1) + 8 * i21);
          v646 = (void *)MEMORY[0x186E3E5D8]();
          -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v645);
          objc_autoreleasePoolPop(v646);
        }

        v642 = [v635 countByEnumeratingWithState:&v1210 objects:v1323 count:16];
      }

      while (v642);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished updating primary key table.",  v636,  v637,  v638,  v639,  v640,  v641,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1322[0] = @"Update primary key table";
    v1322[1] = [MEMORY[0x189607968] numberWithDouble:v647 - v634];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1322, 2),  @"2.7");
    v626 = *(void *)(v1141 + 32);
  }

  if ([*(id *)(v626 + 176) count])
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v655 = v654;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin updating default values.",  v648,  v649,  v650,  v651,  v652,  v653,  (uint64_t)v1035);
    }
    v1209 = 0u;
    v1208 = 0u;
    v1207 = 0u;
    v1206 = 0u;
    v656 = *(void **)(*(void *)(v1141 + 32) + 176LL);
    v663 = [v656 countByEnumeratingWithState:&v1206 objects:v1321 count:16];
    if (v663)
    {
      v664 = *(void *)v1207;
      do
      {
        for (i22 = 0LL; i22 != v663; ++i22)
        {
          if (*(void *)v1207 != v664) {
            objc_enumerationMutation(v656);
          }
          v666 = *(void **)(*((void *)&v1206 + 1) + 8 * i22);
          v667 = (void *)MEMORY[0x186E3E5D8]();
          -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v666);
          objc_autoreleasePoolPop(v667);
        }

        v663 = [v656 countByEnumeratingWithState:&v1206 objects:v1321 count:16];
      }

      while (v663);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished updating default values.",  v657,  v658,  v659,  v660,  v661,  v662,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1320[0] = @"Update default values";
    v1320[1] = [MEMORY[0x189607968] numberWithDouble:v668 - v655];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1320, 2),  @"2.7.1");
  }

  if (objc_msgSend( (id)objc_msgSend(*(id *)(*(void *)(v1141 + 32) + 152), "objectForKey:", @"inserted"),  "count"))
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v676 = v675;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin attribute extension updates.",  v669,  v670,  v671,  v672,  v673,  v674,  (uint64_t)v1035);
    }
    v1205 = 0u;
    v1204 = 0u;
    v1203 = 0u;
    v1202 = 0u;
    v677 = (void *)[*(id *)(*(void *)(v1141 + 32) + 152) objectForKey:@"inserted"];
    v678 = [v677 countByEnumeratingWithState:&v1202 objects:v1319 count:16];
    if (v678)
    {
      v1089 = *(id *)v1203;
      v1071 = v677;
      do
      {
        v1136 = 0LL;
        objd = (id)v678;
        do
        {
          if (*(id *)v1203 != v1089) {
            objc_enumerationMutation(v1071);
          }
          v685 = *(void **)(*((void *)&v1202 + 1) + 8LL * (void)v1136);
          v1119 = (id)MEMORY[0x186E3E5D8]();
          v1102 = [v685 validate:*(void *)(*(void *)(v1141 + 40) + 8) + 40];
          if (v1102)
          {
            v1201 = 0u;
            v1200 = 0u;
            v1199 = 0u;
            v1198 = 0u;
            v686 = (void *)[v685 insertSQLStrings];
            v687 = [v686 countByEnumeratingWithState:&v1198 objects:v1318 count:16];
            if (v687)
            {
              v688 = *(void *)v1199;
              do
              {
                for (i23 = 0LL; i23 != v687; ++i23)
                {
                  if (*(void *)v1199 != v688) {
                    objc_enumerationMutation(v686);
                  }
                  v690 = *(void *)(*((void *)&v1198 + 1) + 8 * i23);
                  v691 = (void *)MEMORY[0x186E3E5D8]();
                  v692 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  0LL,  v690);
                  v699 = v692;
                  if (*(_BYTE *)(v1141 + 64)) {
                    _NSCoreDataLog( 4LL,  (uint64_t)@"Executing attribute extension insert statement: %@",  v693,  v694,  v695,  v696,  v697,  v698,  (uint64_t)v692);
                  }
                  -[NSSQLiteConnection prepareAndExecuteSQLStatement:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  v699);

                  objc_autoreleasePoolPop(v691);
                }

                v687 = [v686 countByEnumeratingWithState:&v1198 objects:v1318 count:16];
              }

              while (v687);
            }

            v1197 = 0u;
            v1196 = 0u;
            v1195 = 0u;
            v1194 = 0u;
            v700 = (void *)[v685 bulkUpdateSQLStrings];
            v701 = [v700 countByEnumeratingWithState:&v1194 objects:v1317 count:16];
            if (v701)
            {
              v702 = *(void *)v1195;
              do
              {
                for (i24 = 0LL; i24 != v701; ++i24)
                {
                  if (*(void *)v1195 != v702) {
                    objc_enumerationMutation(v700);
                  }
                  v704 = *(void *)(*((void *)&v1194 + 1) + 8 * i24);
                  v705 = (void *)MEMORY[0x186E3E5D8]();
                  v706 = -[NSSQLiteStatement initWithEntity:sqlString:]( objc_alloc(&OBJC_CLASS___NSSQLiteStatement),  "initWithEntity:sqlString:",  0LL,  v704);
                  v713 = v706;
                  if (*(_BYTE *)(v1141 + 64)) {
                    _NSCoreDataLog( 4LL,  (uint64_t)@"Executing attribute extension change statement: %@",  v707,  v708,  v709,  v710,  v711,  v712,  (uint64_t)v706);
                  }
                  -[NSSQLiteConnection prepareAndExecuteSQLStatement:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  v713);

                  objc_autoreleasePoolPop(v705);
                }

                v701 = [v700 countByEnumeratingWithState:&v1194 objects:v1317 count:16];
              }

              while (v701);
            }
          }

          else
          {
            v714 = *(id *)(*(void *)(*(void *)(v1141 + 40) + 8LL) + 40LL);
            *(_BYTE *)(*(void *)(*(void *)(v1141 + 48) + 8LL) + 24LL) = 0;
          }

          objc_autoreleasePoolPop(v1119);
          if (!v1102) {
            goto LABEL_844;
          }
          v1136 = (char *)v1136 + 1;
        }

        while (v1136 != objd);
        v678 = [v1071 countByEnumeratingWithState:&v1202 objects:v1319 count:16];
      }

      while (v678);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished attribute extension updates.",  v679,  v680,  v681,  v682,  v683,  v684,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1316[0] = @"Update attribute extensions";
    v1316[1] = [MEMORY[0x189607968] numberWithDouble:v715 - v676];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1316, 2),  @"2.8");
  }

  if ([*(id *)(*(void *)(v1141 + 32) + 160) count])
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v723 = v722;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin index creation and updates.",  v716,  v717,  v718,  v719,  v720,  v721,  (uint64_t)v1035);
    }
    v1193 = 0u;
    v1192 = 0u;
    v1191 = 0u;
    v1190 = 0u;
    v1090 = *(id *)(*(void *)(v1141 + 32) + 160LL);
    v730 = [v1090 countByEnumeratingWithState:&v1190 objects:v1315 count:16];
    if (v730)
    {
      v1103 = *(id *)v1191;
      do
      {
        v731 = 0LL;
        v1120 = (id)v730;
        do
        {
          if (*(id *)v1191 != v1103) {
            objc_enumerationMutation(v1090);
          }
          v732 = *(void **)(*((void *)&v1190 + 1) + 8LL * (void)v731);
          v1137 = (id)MEMORY[0x186E3E5D8]();
          [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
          v734 = v733;
          v735 = (void *)[v732 generateStatementsForStore:*(void *)(*(void *)(v1141 + 32) + 8)];
          [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
          v737 = v736;
          v1314[0] = @"Generate index creation statements";
          v1314[1] = [MEMORY[0x189607968] numberWithDouble:v736 - v734];
          objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1314, 2),  @"2.9.1");
          v1188 = 0u;
          v1189 = 0u;
          v1186 = 0u;
          v1187 = 0u;
          v738 = [v735 countByEnumeratingWithState:&v1186 objects:v1313 count:16];
          if (v738)
          {
            v739 = *(void *)v1187;
            do
            {
              for (i25 = 0LL; i25 != v738; ++i25)
              {
                if (*(void *)v1187 != v739) {
                  objc_enumerationMutation(v735);
                }
                v741 = *(void **)(*((void *)&v1186 + 1) + 8 * i25);
                v748 = (void *)MEMORY[0x186E3E5D8]();
                if (*(_BYTE *)(v1141 + 64)) {
                  _NSCoreDataLog( 4LL,  (uint64_t)@"Executing index creation statement: %@",  v742,  v743,  v744,  v745,  v746,  v747,  (uint64_t)v741);
                }
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v741);
                objc_autoreleasePoolPop(v748);
              }

              v738 = [v735 countByEnumeratingWithState:&v1186 objects:v1313 count:16];
            }

            while (v738);
          }

          [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
          v750 = v749;
          v1312[0] = @"Execute index creation statements";
          v1312[1] = [MEMORY[0x189607968] numberWithDouble:v749 - v737];
          objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1312, 2),  @"2.9.2");
          v751 = (void *)[v732 bulkUpdateStatementsForStore:*(void *)(*(void *)(v1141 + 32) + 8)];
          [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
          v753 = v752;
          v1311[0] = @"Generate index update statements";
          v1311[1] = [MEMORY[0x189607968] numberWithDouble:v752 - v750];
          objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1311, 2),  @"2.9.3");
          v1184 = 0u;
          v1185 = 0u;
          v1182 = 0u;
          v1183 = 0u;
          v754 = [v751 countByEnumeratingWithState:&v1182 objects:v1310 count:16];
          if (v754)
          {
            v755 = *(void *)v1183;
            do
            {
              for (i26 = 0LL; i26 != v754; ++i26)
              {
                if (*(void *)v1183 != v755) {
                  objc_enumerationMutation(v751);
                }
                v757 = *(void **)(*((void *)&v1182 + 1) + 8 * i26);
                v764 = (void *)MEMORY[0x186E3E5D8]();
                if (*(_BYTE *)(v1141 + 64)) {
                  _NSCoreDataLog( 4LL,  (uint64_t)@"Executing index update statement: %@",  v758,  v759,  v760,  v761,  v762,  v763,  (uint64_t)v757);
                }
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v757);
                objc_autoreleasePoolPop(v764);
              }

              v754 = [v751 countByEnumeratingWithState:&v1182 objects:v1310 count:16];
            }

            while (v754);
          }

          [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
          v1309[0] = @"Execute index update statements";
          v1309[1] = [MEMORY[0x189607968] numberWithDouble:v765 - v753];
          objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1309, 2),  @"2.9.4");
          objc_autoreleasePoolPop(v1137);
          v731 = (char *)v731 + 1;
        }

        while (v731 != v1120);
        v730 = [v1090 countByEnumeratingWithState:&v1190 objects:v1315 count:16];
      }

      while (v730);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished index creation and updates.",  v724,  v725,  v726,  v727,  v728,  v729,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1308[0] = @"Total index creation and update time";
    v1308[1] = [MEMORY[0x189607968] numberWithDouble:v766 - v723];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1308, 2),  @"2.9");
  }

  v767 = *(void *)(*(void *)(v1141 + 32) + 16LL);
  if (v767) {
    v768 = *(void **)(v767 + 24);
  }
  else {
    v768 = 0LL;
  }
  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v770 = v769;
  v1180 = 0u;
  v1181 = 0u;
  v1178 = 0u;
  v1179 = 0u;
  v771 = [v768 countByEnumeratingWithState:&v1178 objects:v1307 count:16];
  if (v771)
  {
    v1138 = 0;
    v772 = *(void *)v1179;
    do
    {
      v773 = 0LL;
      do
      {
        if (*(void *)v1179 != v772) {
          objc_enumerationMutation(v768);
        }
        v774 = *(void *)(*((void *)&v1178 + 1) + 8 * v773);
        v775 = (void *)MEMORY[0x186E3E5D8]();
        v776 = [v768 objectForKey:v774];
        v777 = (void *)v776;
        if (v776)
        {
          if (!*(void *)(v776 + 160))
          {
            v778 = *(void **)(v776 + 152);
            if (v778)
            {
              if ([v778 count])
              {
                v779 = (void *)objc_msgSend( (id)objc_msgSend((id)objc_msgSend(v777, "entityDescription"), "userInfo"),  "objectForKey:",  @"_NSEntityOmitSubentityColumnIndex");
                v780 = v779;
                if (v779)
                {
                  if ([v779 isNSString])
                  {
                    v781 = (void *)[v780 lowercaseString];
                    v782 = v781;
                    if (v781)
                    {
                      if (([v781 isEqualToString:@"yes"] & 1) != 0
                        || [v782 isEqualToString:@"1"])
                      {
                        v783 = (void *)NSString;
                        v1035 = (const __CFString *)[v777 tableName];
                        v784 = [v783 stringWithFormat:@"DROP INDEX IF EXISTS %@_Z_ENT_INDEX"];
                        v791 = (void *)v784;
                        if (*(_BYTE *)(v1141 + 64)) {
                          _NSCoreDataLog( 4LL,  (uint64_t)@"Executing drop Z_ENT index statement: %@",  v785,  v786,  v787,  v788,  v789,  v790,  v784);
                        }
                        -[NSSQLiteConnection _executeSQLString:](*(void *)(*(void *)(v1141 + 32) + 48LL), v791);
                        v1138 = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }

        objc_autoreleasePoolPop(v775);
        ++v773;
      }

      while (v771 != v773);
      v792 = [v768 countByEnumeratingWithState:&v1178 objects:v1307 count:16];
      v771 = v792;
    }

    while (v792);
    if ((v1138 & 1) != 0)
    {
      [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
      v1306[0] = @"Dropping Z_ENT indices";
      v1306[1] = [MEMORY[0x189607968] numberWithDouble:v793 - v770];
      objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1306, 2),  @"2.10");
    }
  }

  if ([*(id *)(*(void *)(v1141 + 32) + 192) count])
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v801 = v800;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Begin updating derived properties.",  v794,  v795,  v796,  v797,  v798,  v799,  (uint64_t)v1035);
    }
    v1176 = 0u;
    v1177 = 0u;
    v1174 = 0u;
    v1175 = 0u;
    v1091 = *(id *)(*(void *)(v1141 + 32) + 192LL);
    v802 = [v1091 countByEnumeratingWithState:&v1174 objects:v1305 count:16];
    if (v802)
    {
      v1104 = *(id *)v1175;
      do
      {
        v809 = 0LL;
        v1121 = (id)v802;
        do
        {
          if (*(id *)v1175 != v1104) {
            objc_enumerationMutation(v1091);
          }
          v810 = *(void *)(*((void *)&v1174 + 1) + 8LL * (void)v809);
          v1139 = (id)MEMORY[0x186E3E5D8]();
          if (v810)
          {
            -[NSSQLEntity_DerivedAttributesExtension _generateTriggerSQL](v810);
            v811 = *(void **)(v810 + 32);
          }

          else
          {
            v811 = 0LL;
          }

          v812 = (void *)[v811 valueForKey:@"dataStatements"];
          v1172 = 0u;
          v1173 = 0u;
          v1170 = 0u;
          v1171 = 0u;
          v813 = [v812 countByEnumeratingWithState:&v1170 objects:v1304 count:16];
          if (v813)
          {
            v814 = *(void *)v1171;
            do
            {
              for (i27 = 0LL; i27 != v813; ++i27)
              {
                if (*(void *)v1171 != v814) {
                  objc_enumerationMutation(v812);
                }
                v816 = *(void **)(*((void *)&v1170 + 1) + 8 * i27);
                v823 = (void *)MEMORY[0x186E3E5D8]();
                if (*(_BYTE *)(v1141 + 64)) {
                  _NSCoreDataLog( 4LL,  (uint64_t)@"Executing derived property update statement (data): %@",  v817,  v818,  v819,  v820,  v821,  v822,  (uint64_t)v816);
                }
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v816);
                objc_autoreleasePoolPop(v823);
              }

              v813 = [v812 countByEnumeratingWithState:&v1170 objects:v1304 count:16];
            }

            while (v813);
          }

          if (v810)
          {
            -[NSSQLEntity_DerivedAttributesExtension _generateTriggerSQL](v810);
            v824 = *(void **)(v810 + 32);
          }

          else
          {
            v824 = 0LL;
          }

          v825 = (void *)[v824 valueForKey:@"triggerCreationStatements"];
          v1168 = 0u;
          v1169 = 0u;
          v1166 = 0u;
          v1167 = 0u;
          v826 = [v825 countByEnumeratingWithState:&v1166 objects:v1303 count:16];
          if (v826)
          {
            v827 = *(void *)v1167;
            do
            {
              for (i28 = 0LL; i28 != v826; ++i28)
              {
                if (*(void *)v1167 != v827) {
                  objc_enumerationMutation(v825);
                }
                v829 = *(void **)(*((void *)&v1166 + 1) + 8 * i28);
                v836 = (void *)MEMORY[0x186E3E5D8]();
                if (*(_BYTE *)(v1141 + 64)) {
                  _NSCoreDataLog( 4LL,  (uint64_t)@"Executing derived property update statement (trigger): %@",  v830,  v831,  v832,  v833,  v834,  v835,  (uint64_t)v829);
                }
                -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v829);
                objc_autoreleasePoolPop(v836);
              }

              v826 = [v825 countByEnumeratingWithState:&v1166 objects:v1303 count:16];
            }

            while (v826);
          }

          objc_autoreleasePoolPop(v1139);
          v809 = (char *)v809 + 1;
        }

        while (v809 != v1121);
        v802 = [v1091 countByEnumeratingWithState:&v1174 objects:v1305 count:16];
      }

      while (v802);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished updating derived properties.",  v803,  v804,  v805,  v806,  v807,  v808,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1302[0] = @"Update derived properties";
    v1302[1] = [MEMORY[0x189607968] numberWithDouble:v837 - v801];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1302, 2),  @"2.11");
  }

  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v839 = v838;
  v1092 = (id)MEMORY[0x186E3E5D8]();
  v1164 = 0u;
  v1165 = 0u;
  v1162 = 0u;
  v1163 = 0u;
  v840 = (void *)objc_msgSend( (id)objc_msgSend(*(id *)(*(void *)(v1141 + 32) + 8), "ancillarySQLModels"),  "allValues");
  v841 = [v840 countByEnumeratingWithState:&v1162 objects:v1301 count:16];
  if (v841)
  {
    v842 = 0;
    v1105 = v840;
    v1122 = *(id *)v1163;
    do
    {
      v843 = 0LL;
      v1140 = (id)v841;
      do
      {
        if (*(id *)v1163 != v1122) {
          objc_enumerationMutation(v1105);
        }
        v844 = *(void *)(*((void *)&v1162 + 1) + 8LL * (void)v843);
        v845 = (void *)MEMORY[0x186E3E5D8]();
        v1160 = 0u;
        v1161 = 0u;
        v1158 = 0u;
        v1159 = 0u;
        if (v844) {
          v846 = *(void **)(v844 + 32);
        }
        else {
          v846 = 0LL;
        }
        v847 = [v846 countByEnumeratingWithState:&v1158 objects:v1300 count:16];
        if (v847)
        {
          v848 = *(void *)v1159;
          do
          {
            for (i29 = 0LL; i29 != v847; ++i29)
            {
              if (*(void *)v1159 != v848) {
                objc_enumerationMutation(v846);
              }
              v850 = *(void **)(*((void *)&v1158 + 1) + 8 * i29);
              v851 = (void *)MEMORY[0x186E3E5D8]();
              v852 = *(void *)(*(void *)(v1141 + 32) + 48LL);
              v853 = [v850 tableName];
              if (v852 && -[NSSQLiteConnection _hasTableWithName:isTemp:](v852, v853, 0))
              {
                -[NSSQLiteConnection generatePrimaryKeysForEntity:batch:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  (uint64_t)v850,  0);
                v842 = 1;
              }

              objc_autoreleasePoolPop(v851);
            }

            v847 = [v846 countByEnumeratingWithState:&v1158 objects:v1300 count:16];
          }

          while (v847);
        }

        objc_autoreleasePoolPop(v845);
        v843 = (char *)v843 + 1;
      }

      while (v843 != v1140);
      v841 = [v1105 countByEnumeratingWithState:&v1162 objects:v1301 count:16];
    }

    while (v841);
  }

  else
  {
    v842 = 0;
  }

  objc_autoreleasePoolPop(v1092);
  if ((v842 & 1) != 0)
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1299[0] = @"Update ancillary model primary keys";
    v1299[1] = [MEMORY[0x189607968] numberWithDouble:v854 - v839];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1299, 2),  @"2.12");
  }

  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v856 = v855;
  v857 = (void *)MEMORY[0x186E3E5D8]();
  if (-[NSSQLiteConnection hasIndexTrackingTable](*(void *)(*(void *)(v1141 + 32) + 48LL)))
  {
    -[NSSQLiteConnection dropIndexTrackingTable](*(void **)(*(void *)(v1141 + 32) + 48LL));
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1298[0] = @"Drop index tracking table";
    v1298[1] = [MEMORY[0x189607968] numberWithDouble:v858 - v856];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1298, 2),  @"2.13");
  }

  objc_autoreleasePoolPop(v857);
  hasPersistentHistory = -[NSSQLiteConnection _hasPersistentHistoryTables](*(void *)(*(void *)(v1141 + 32) + 48LL));
  if (hasPersistentHistory)
  {
    v860 = (void *)MEMORY[0x186E3E5D8]();
    v861 = [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v869 = v868;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning persistent history metadata tables update",  v862,  v863,  v864,  v865,  v866,  v867,  (uint64_t)v1035);
    }
    v870 = (void *)MEMORY[0x186E3E5D8](v861);
    v871 = -[_NSSQLiteStoreMigrator deleteStatementsForHistory](*(void *)(v1141 + 32));
    objc_autoreleasePoolPop(v870);
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v873 = v872;
    v1297[0] = @"Generate persistent history delete statements";
    v1297[1] = [MEMORY[0x189607968] numberWithDouble:v872 - v869];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1297, 2),  @"2.14.1");
    v874 = -[_NSSQLiteStoreMigrator updateStatementsForHistoryChanges](*(NSSQLiteStatement ***)(v1141 + 32));
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v876 = v875;
    v1296[0] = @"Generate persistent history update statements";
    v1296[1] = [MEMORY[0x189607968] numberWithDouble:v875 - v873];
    v877 = objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1296, 2),  @"2.14.2");
    if (v874) {
      v884 = v871;
    }
    else {
      v884 = 0;
    }
    if ((v884 & 1) != 0)
    {
      v1156 = 0u;
      v1157 = 0u;
      v1154 = 0u;
      v1155 = 0u;
      v885 = [v874 countByEnumeratingWithState:&v1154 objects:v1294 count:16];
      if (v885)
      {
        v886 = *(void *)v1155;
        do
        {
          for (i30 = 0LL; i30 != v885; ++i30)
          {
            if (*(void *)v1155 != v886) {
              objc_enumerationMutation(v874);
            }
            v888 = *(void **)(*((void *)&v1154 + 1) + 8 * i30);
            v895 = (void *)MEMORY[0x186E3E5D8]();
            if (*(_BYTE *)(v1141 + 64)) {
              _NSCoreDataLog( 4LL,  (uint64_t)@"Executing history migration statement: %@",  v889,  v890,  v891,  v892,  v893,  v894,  (uint64_t)v888);
            }
            -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v888);
            objc_autoreleasePoolPop(v895);
          }

          v885 = [v874 countByEnumeratingWithState:&v1154 objects:v1294 count:16];
        }

        while (v885);
      }

      [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
      v1293[0] = @"Execution of persistent history migration";
      v1293[1] = [MEMORY[0x189607968] numberWithDouble:v896 - v876];
      objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1293, 2),  @"2.14.4");
    }

    else
    {
      if (*(_BYTE *)(v1141 + 64)) {
        _NSCoreDataLog( 2LL,  (uint64_t)@"Dropping Persistent History b/c of an issue with migration",  v878,  v879,  v880,  v881,  v882,  v883,  (uint64_t)v1035);
      }
      v903 = (void *)MEMORY[0x186E3E5D8](v877);
      -[NSSQLiteConnection dropHistoryTrackingTables](*(id **)(*(void *)(v1141 + 32) + 48LL));
      objc_autoreleasePoolPop(v903);
      if (*(_BYTE *)(v1141 + 64)) {
        _NSCoreDataLog( 2LL,  (uint64_t)@"Finished dropping Persistent History b/c of an issue with migration",  v904,  v905,  v906,  v907,  v908,  v909,  (uint64_t)v1035);
      }
      [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
      v1295[0] = @"Drop persistent history tables";
      v1295[1] = [MEMORY[0x189607968] numberWithDouble:v910 - v876];
      objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1295, 2),  @"2.14.3");
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Completed persistent history metadata tables update",  v897,  v898,  v899,  v900,  v901,  v902,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1292[0] = @"Total persistent history migration";
    v1292[1] = [MEMORY[0x189607968] numberWithDouble:v911 - v869];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1292, 2),  @"2.14");
    objc_autoreleasePoolPop(v860);
  }

  if ([*(id *)(*(void *)(v1141 + 32) + 208) count])
  {
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v919 = v918;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Beginning CloudKit metadata tables update",  v912,  v913,  v914,  v915,  v916,  v917,  (uint64_t)v1035);
    }
    v1152 = 0u;
    v1153 = 0u;
    v1150 = 0u;
    v1151 = 0u;
    v920 = *(void **)(*(void *)(v1141 + 32) + 208LL);
    v927 = [v920 countByEnumeratingWithState:&v1150 objects:v1291 count:16];
    if (v927)
    {
      v928 = *(void *)v1151;
      do
      {
        for (i31 = 0LL; i31 != v927; ++i31)
        {
          if (*(void *)v1151 != v928) {
            objc_enumerationMutation(v920);
          }
          v930 = *(void **)(*((void *)&v1150 + 1) + 8 * i31);
          v937 = (void *)MEMORY[0x186E3E5D8]();
          if (*(_BYTE *)(v1141 + 64)) {
            _NSCoreDataLog( 4LL,  (uint64_t)@"Executing CloudKit metadata table update: %@",  v931,  v932,  v933,  v934,  v935,  v936,  (uint64_t)v930);
          }
          -[NSSQLiteConnection prepareAndExecuteSQLStatement:](*(void *)(*(void *)(v1141 + 32) + 48LL), v930);
          objc_autoreleasePoolPop(v937);
        }

        v927 = [v920 countByEnumeratingWithState:&v1150 objects:v1291 count:16];
      }

      while (v927);
    }

    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished CloudKit metadata tables update",  v921,  v922,  v923,  v924,  v925,  v926,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1290[0] = @"CloudKit metadata updates";
    v1290[1] = [MEMORY[0x189607968] numberWithDouble:v938 - v919];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1290, 2),  @"2.15");
  }

  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v946 = v945;
  if (*(_BYTE *)(v1141 + 64)) {
    _NSCoreDataLog(4LL, (uint64_t)@"Updating metadata", v939, v940, v941, v942, v943, v944, (uint64_t)v1035);
  }
  v947 = (__CFString *)objc_msgSend((id)objc_msgSend(*(id *)(*(void *)(v1141 + 32) + 8), "metadata"), "mutableCopy");
  v1132 = v947;
  v948 = (void *)[*(id *)(*(void *)(v1141 + 32) + 16) managedObjectModel];
  v949 = (void *)[v948 entityVersionHashesByName];
  -[__CFString setObject:forKey:](v947, "setObject:forKey:", v949, @"NSStoreModelVersionHashes");
  v950 = -[NSManagedObjectModel _entityVersionHashesDigestFrom:](v948, v949);
  -[__CFString setObject:forKey:](v947, "setObject:forKey:", v950, 0x189EB9D88LL);
  -[__CFString setObject:forKey:]( v947,  "setObject:forKey:",  [v948 versionChecksum],  @"NSStoreModelVersionChecksumKey");
  if (v948) {
    v951 = objc_msgSend((id)objc_msgSend(v948, "versionIdentifiers"), "allObjects");
  }
  else {
    v951 = 0LL;
  }
  -[__CFString setObject:forKey:](v947, "setObject:forKey:", v951, @"NSStoreModelVersionIdentifiers");
  v952 = [(id)objc_opt_class() _annotatesMigrationMetadata];
  if ((_DWORD)v952) {
    v952 = -[__CFString setObject:forKey:]( v947,  "setObject:forKey:",  @"NSSQLiteInPlaceMigrationManager",  @"migrationManagerClass");
  }
  v953 = *(void *)(v1141 + 32);
  if (v953 && *(_BYTE *)(v953 + 217)) {
    v952 = -[__CFString setValue:forKey:]( v947,  "setValue:forKey:",  MEMORY[0x189604A88],  @"NSPersistentStoreDeferredLightweightMigrationOptionKey");
  }
  v954 = (void *)MEMORY[0x186E3E5D8](v952);
  -[NSSQLiteConnection saveMetadata:](*(void **)(*(void *)(v1141 + 32) + 48LL), v947);
  -[NSSQLiteConnection saveCachedModel:](*(void *)(*(void *)(v1141 + 32) + 48LL), (uint64_t)v948);
  if (hasPersistentHistory) {
    -[NSSQLiteConnection processMigrationRequestForHash:stageLabel:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  (uint64_t)v950,  *(void *)(*(void *)(v1141 + 32) + 232LL));
  }
  objc_autoreleasePoolPop(v954);
  if (*(_BYTE *)(v1141 + 64)) {
    _NSCoreDataLog( 4LL,  (uint64_t)@"Finished updating metadata",  v955,  v956,  v957,  v958,  v959,  v960,  (uint64_t)v1035);
  }
  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v407 = v961;
  v1289[0] = @"Update store metadata";
  v1289[1] = [MEMORY[0x189607968] numberWithDouble:v961 - v946];
  objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1289, 2),  @"2.16");
  if (!-[NSMappingModel _hasInferredMappingNeedingValidation](*(void *)(*(void *)(v1141 + 32) + 40LL)))
  {
LABEL_522:
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Committing formal transaction",  v424,  v425,  v426,  v427,  v428,  v429,  (uint64_t)v1035);
    }
    -[NSSQLiteConnection commitTransaction](*(void *)(*(void *)(v1141 + 32) + 48LL));
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished committing formal transaction",  v430,  v431,  v432,  v433,  v434,  v435,  (uint64_t)v1035);
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v437 = v436;
    v1286[0] = @"Time for COMMIT";
    v1286[1] = [MEMORY[0x189607968] numberWithDouble:v436 - v407];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1286, 2),  @"2.17");
    v1285[0] = @"Total formal transaction time";
    v1285[1] = [MEMORY[0x189607968] numberWithDouble:v437 - v19];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1285, 2),  @"2.0");
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Checkpointing WAL journal",  v438,  v439,  v440,  v441,  v442,  v443,  (uint64_t)v1035);
    }
    v444 = -[NSSQLiteConnection copyRawIntegerRowsForSQL:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  @"pragma wal_checkpoint(truncate)");
    if (v444) {
      CFRelease(v444);
    }
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished checkpointing WAL journal",  v445,  v446,  v447,  v448,  v449,  v450,  (uint64_t)v1035);
    }
    *(_BYTE *)(*(void *)(*(void *)(v1141 + 48) + 8LL) + 24LL) = 1;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Successfully completed lightweight migration on connection",  v445,  v446,  v447,  v448,  v449,  v450,  (uint64_t)v1035);
    }
    if (*v1041) {
      -[NSSQLiteConnection _executeSQLString:]( *(void *)(*(void *)(v1141 + 32) + 48LL),  @"pragma cache_size = 512");
    }
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v452 = v451;
    v1284[0] = @"Checkpoint time";
    v1284[1] = [MEMORY[0x189607968] numberWithDouble:v451 - v437];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1284, 2),  @"3.0");
    v1283[0] = @"Total migration time (on connection)";
    v1283[1] = [MEMORY[0x189607968] numberWithDouble:v452 - v3];
    v453 = MEMORY[0x186E3E5D8]( objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1283, 2),  @"0.0"));
    if (*(_BYTE *)(v1141 + 64))
    {
      v454 = (void *)objc_msgSend( (id)objc_msgSend(v1053, "allKeys"),  "sortedArrayUsingSelector:",  sel_localizedStandardCompare_);
      v1144 = 0u;
      v1145 = 0u;
      v1142 = 0u;
      v1143 = 0u;
      v455 = [v454 countByEnumeratingWithState:&v1142 objects:v1282 count:16];
      if (v455)
      {
        v456 = *(void *)v1143;
        do
        {
          for (i32 = 0LL; i32 != v455; ++i32)
          {
            if (*(void *)v1143 != v456) {
              objc_enumerationMutation(v454);
            }
            v458 = *(void *)(*((void *)&v1142 + 1) + 8 * i32);
            v459 = (void *)[v1053 objectForKey:v458];
            [v459 firstObject];
            objc_msgSend((id)objc_msgSend(v459, "lastObject"), "doubleValue");
            if (v466 > 0.01) {
              _NSCoreDataLog( 4LL,  (uint64_t)@"    Migration step %@ '%@' took %2.2f seconds",  v460,  v461,  v462,  v463,  v464,  v465,  v458);
            }
          }

          v455 = [v454 countByEnumeratingWithState:&v1142 objects:v1282 count:16];
        }

        while (v455);
      }
    }

    v312 = 0;
    v467 = (void *)v453;
    v313 = v1141;
    objc_autoreleasePoolPop(v467);
    goto LABEL_1005;
  }

  [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
  v969 = v968;
  if (*(_BYTE *)(v1141 + 64)) {
    _NSCoreDataLog( 4LL,  (uint64_t)@"Starting inferred mapping validation",  v962,  v963,  v964,  v965,  v966,  v967,  (uint64_t)v1035);
  }
  v1148 = 0u;
  v1149 = 0u;
  v1146 = 0u;
  v1147 = 0u;
  v1047 = (id)[*(id *)(*(void *)(v1141 + 32) + 40) entityMappings];
  v1052 = [v1047 countByEnumeratingWithState:&v1146 objects:v1288 count:16];
  if (!v1052)
  {
LABEL_980:
    [MEMORY[0x189603F50] timeIntervalSinceReferenceDate];
    v1015 = v1014;
    if (*(_BYTE *)(v1141 + 64)) {
      _NSCoreDataLog( 4LL,  (uint64_t)@"Finished inferred mapping validation",  v1008,  v1009,  v1010,  v1011,  v1012,  v1013,  (uint64_t)v1035);
    }
    v1287[0] = @"Inferred mapping validation";
    v1287[1] = [MEMORY[0x189607968] numberWithDouble:v1015 - v969];
    objc_msgSend( v1053,  "setObject:forKey:",  objc_msgSend(MEMORY[0x189603F18], "arrayWithObjects:count:", v1287, 2),  @"2.16b");
    goto LABEL_522;
  }

  contextc = *(void **)v1147;
LABEL_908:
  v1067 = 0LL;
  while (1)
  {
    v1072 = *(void **)(*((void *)&v1146 + 1) + 8LL * (void)v1067);
    v1062 = (void *)MEMORY[0x186E3E5D8]();
    if (v1072)
    {
      v970 = (void *)[v1072 userInfo];
      if (objc_msgSend( (id)objc_msgSend(v970, "objectForKey:", _NSInferredMappingCouldFailValidation),  "BOOLValue")) {
        break;
      }
    }