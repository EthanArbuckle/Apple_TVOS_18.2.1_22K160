uint64_t _CFURLCopyFileURL(__objc2_class **a1)
{
  uint64_t v1;
  uint64_t v2;
  CFAllocatorRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  BOOL v11;
  size_t v12;
  uint64_t Instance;
  const void *v14;
  uint64_t v15;
  CFStringRef v16;
  uint64_t v17;
  const void *v18;
  CFAllocatorRef v19;
  CFStringRef Copy;
  uint64_t v21;
  int v22;
  v1 = (uint64_t)a1;
  if (*(void *)(v1 + 32) || !_CFURLHasFileURLScheme((__objc2_class **)v1, 0LL)) {
    return 0LL;
  }
  v4 = CFGetAllocator((CFTypeRef)v1);
  v9 = *(_DWORD *)(v1 + 16) & 0x1FF;
  if (v9)
  {
    v10 = 0LL;
    do
    {
      v10 += v9 & 1;
      v11 = v9 > 1;
      v9 >>= 1;
    }

    while (v11);
    v12 = 16 * v10;
  }

  else
  {
    v12 = 0LL;
  }

  Instance = _CFRuntimeCreateInstance(v4, 0x1DuLL, (v12 & 0xFF0) + 40, 0LL, v5, v6, v7, v8);
  v2 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 20) = 134217984;
    *(void *)(Instance + 16) = *(void *)(v1 + 16);
    v14 = (const void *)atomic_load((unint64_t *)(v1 + 24));
    atomic_store((unint64_t)CFRetain(v14), (unint64_t *)(v2 + 24));
    *(void *)(v2 + 32) = 0LL;
    *(void *)(v2 + 40) = 0LL;
    if ((*(_BYTE *)(v2 + 18) & 1) == 0)
    {
      v15 = *(void *)(v1 + 40);
      if (v15)
      {
        v16 = *(const __CFString **)(v15 + 8);
        if (v16)
        {
          _CFURLAllocateExtraDataspace((void *)v2);
          v17 = *(void *)(v2 + 40);
          if (v17)
          {
            v18 = *(const void **)(v17 + 8);
            if (v18) {
              CFRelease(v18);
            }
            v19 = CFGetAllocator((CFTypeRef)v2);
            Copy = CFStringCreateCopy(v19, v16);
            v17 = *(void *)(v2 + 40);
            *(void *)(v17 + 8) = Copy;
          }

          v21 = *(void *)(v1 + 40);
          if (v21)
          {
            v22 = *(_DWORD *)(v21 + 16);
            if (v22 && !v17)
            {
              _CFURLAllocateExtraDataspace((void *)v2);
              v17 = *(void *)(v2 + 40);
            }
          }

          else
          {
            v22 = 0;
          }

          if (v17) {
            *(_DWORD *)(v17 + 16) = v22;
          }
        }
      }
    }

    memcpy((void *)(v2 + 56), (const void *)(v1 + 56), v12);
  }

  return v2;
}

BOOL _CFURLHasFileURLScheme(__objc2_class **a1, _BYTE *a2)
{
  do
  {
    while (1)
    {
      v3 = a1;
      a1 = (__objc2_class **)[v3 baseURL];
      if (!a1) {
        goto LABEL_5;
      }
    }

    a1 = (__objc2_class **)v3[4];
  }

  while (a1);
LABEL_5:
  if (!CF_IS_OBJC(0x1DuLL, v3) && (unsigned int v4 = *((_DWORD *)v3 + 4), v4 >> 29))
  {
    if (a2)
    {
      *a2 = v4 & 1;
      unsigned int v4 = *((_DWORD *)v3 + 4);
    }

    return v4 >> 29 == 3;
  }

  else
  {
    CFStringRef v5 = CFURLCopyScheme((CFURLRef)v3);
    if (v5)
    {
      CFStringRef v6 = v5;
      if (v5 == @"file")
      {
        BOOL v7 = 1LL;
        if (!a2) {
          goto LABEL_11;
        }
      }

      else
      {
        BOOL v7 = CFStringCompare(v5, @"file", 1uLL) == kCFCompareEqualTo;
        if (!a2)
        {
LABEL_11:
          CFRelease(v6);
          return v7;
        }
      }

      *a2 = 1;
      goto LABEL_11;
    }

    BOOL v7 = 0LL;
    if (a2) {
      *a2 = 0;
    }
  }

  return v7;
}

CFURLRef CFURLCreateWithBytes( CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  else {
    v10 = CFStringCreateWithBytes(allocator, URLBytes, length, encoding, 0);
  }
  v11 = v10;
  if (!v10) {
    return 0LL;
  }
  v12 = _CFURLCreateWithURLString(allocator, v10, 0, baseURL);
  v13 = (const __CFURL *)v12;
  if (encoding != 134217984 && v12) {
    *((_DWORD *)v12 + 5) = encoding;
  }
  CFRelease(v11);
  return v13;
}

CFStringRef _CFURLCreateURLStringWithBytes( const __CFAllocator *a1, UInt8 *bytes, size_t numBytes, CFStringEncoding encoding)
{
  usedBufLen[1] = *MEMORY[0x1895F89C0];
  BOOL v7 = 0LL;
  switch(BYTE1(encoding))
  {
    case 0:
      BOOL v7 = 0LL;
      if ((encoding > 0x22 || ((1LL << encoding) & 0x600000032LL) == 0) && encoding != 152) {
        goto LABEL_20;
      }
      return v7;
    case 1:
      if (encoding != 134217984) {
        return 0LL;
      }
      goto LABEL_20;
    case 2:
      if (encoding != 518) {
        goto LABEL_20;
      }
      return 0LL;
    case 6:
      if (encoding == 1536) {
        goto LABEL_20;
      }
      return 0LL;
    case 8:
    case 0xC:
      return v7;
    case 0xA:
      if (encoding - 2561 > 0xF) {
        goto LABEL_20;
      }
      int v8 = 1 << (encoding - 1);
      int v9 = 32785;
      break;
    case 0xB:
      if (encoding - 3059 > 0xC) {
        goto LABEL_20;
      }
      int v8 = 1 << (encoding + 13);
      int v9 = 4099;
      break;
    default:
      if ((encoding & 0xFF00) <= 0xC00) {
        goto LABEL_20;
      }
      return 0LL;
  }

  if ((v8 & v9) != 0) {
    return 0LL;
  }
LABEL_20:
  v10 = CFStringCreateWithBytes(a1, bytes, numBytes, encoding, 0);
  BOOL v7 = v10;
  if (!v10) {
    return v7;
  }
  CStringPtr = CFStringGetCStringPtr(v10, encoding);
  if (CStringPtr)
  {
    v12 = (UInt8 *)CStringPtr;
    int v13 = 0;
    if (strlen(CStringPtr) != numBytes) {
      goto LABEL_31;
    }
  }

  else
  {
    CFIndex Length = CFStringGetLength(v7);
    CFIndex v15 = CFStringGetMaximumSizeForEncoding(Length, encoding) + 1;
    v12 = (UInt8 *)malloc(v15);
    if (!v12)
    {
      int v13 = 0;
      goto LABEL_32;
    }

    usedBufLen[0] = 0LL;
    v18.location = 0LL;
    v18.length = Length;
    CFStringGetBytes(v7, v18, encoding, 0, 0, v12, v15, usedBufLen);
    if (usedBufLen[0] != numBytes)
    {
      free(v12);
      int v13 = 0;
LABEL_31:
      v12 = 0LL;
      goto LABEL_32;
    }

    int v13 = 1;
  }

  if (memcmp(bytes, v12, numBytes))
  {
LABEL_32:
    CFRelease(v7);
    BOOL v7 = 0LL;
  }

  if (v13) {
    free(v12);
  }
  return v7;
}

CFDataRef CFURLCreateData( CFAllocatorRef allocator, CFURLRef url, CFStringEncoding encoding, Boolean escapeWhitespace)
{
  if (url && (CFStringRef v6 = CFURLGetString(url)) != 0LL) {
    return CFStringCreateExternalRepresentation(allocator, v6, encoding, 0);
  }
  else {
    return 0LL;
  }
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  if ((*((_BYTE *)anURL + 18) & 1) != 0) {
    return (CFStringRef)atomic_load((unint64_t *)anURL + 3);
  }
  uint64_t v3 = *((void *)anURL + 5);
  if (v3) {
    return *(CFStringRef *)(v3 + 8);
  }
  else {
    return 0LL;
  }
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  if (URLString) {
    return (CFURLRef)_CFURLCreateWithURLString(allocator, URLString, 1, baseURL);
  }
  else {
    return 0LL;
  }
}

CFURLRef _CFURLInitAbsoluteURLWithBytes( unint64_t *a1, const UInt8 *a2, CFIndex a3, CFStringEncoding a4, const __CFURL *a5)
{
  CFURLRef result = CFURLCreateAbsoluteURLWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, a3, a4, a5, 0);
  if (result)
  {
    BOOL v7 = result;
    a1[2] = *((void *)result + 2);
    unint64_t v8 = atomic_load((unint64_t *)result + 3);
    atomic_store(v8, a1 + 3);
    a1[5] = *((void *)result + 5);
    unint64_t v9 = atomic_load((unint64_t *)result + 6);
    atomic_store(v9, a1 + 6);
    a1[4] = *((void *)result + 4);
    LODWORD(v8) = *((_DWORD *)result + 4);
    unint64_t v10 = *(void *)&vshl_u16( (uint16x4_t)(*(void *)&vdup_n_s16(v8) & 0xFF00FF00FF00FFLL),  (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01LL;
    LOWORD(v10) = vaddv_s16((int16x4_t)v10);
    int v11 = v10
        + (v8 & 1)
        + ((v8 >> 5) & 1)
        + ((v8 >> 6) & 1)
    if ((_BYTE)v11) {
      memcpy(a1 + 7, (char *)result + 56, 16LL * v11);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
    return (CFURLRef)1;
  }

  return result;
}

CFURLRef CFURLCreateAbsoluteURLWithBytes( CFAllocatorRef alloc, const UInt8 *relativeURLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL, Boolean useCompatibilityMode)
{
  v51[18] = *MEMORY[0x1895F89C0];
  if (useCompatibilityMode)
  {
    unsigned int v49 = 0;
    else {
      int v11 = CFStringCreateWithBytes(alloc, relativeURLBytes, length, encoding, 0);
    }
    v12 = (__CFString *)v11;
    if (!v11) {
      return 0LL;
    }
    if (!baseURL)
    {
      int v19 = 0;
      goto LABEL_33;
    }

    if (CFStringGetLength(v11) >= 1)
    {
      int CharacterAtIndex = CFStringGetCharacterAtIndex(v12, 0LL);
      if (CharacterAtIndex == 63 || CharacterAtIndex == 35)
      {
        else {
          v14 = (const __CFString *)atomic_load((unint64_t *)baseURL + 3);
        }
        CFIndex v31 = CFStringGetLength(v14);
        CFIndex v32 = CFStringGetLength(v12);
        Mutable = CFStringCreateMutable(alloc, v32 + v31);
        CFStringAppend(Mutable, v14);
        CFStringAppend(Mutable, v12);
LABEL_28:
        int v19 = 1;
        goto LABEL_32;
      }
    }

    int v47 = 0;
    _parseComponents(v12, baseURL, (unsigned int *)&v47, v51, &v48);
    if ((v47 & 1) == 0)
    {
      CFRetain(v12);
      v20 = v12;
      goto LABEL_17;
    }

    v28 = CFURLCopyScheme(baseURL);
    if (v28)
    {
      v29 = v28;
      uint64_t v30 = v51[1];
      if (CFStringGetLength(v28) == v30 && CFStringHasPrefix(v12, v29))
      {
        v54.length = CFStringGetLength(v12) + ~v30;
        v54.location = v30 + 1;
        v20 = CFStringCreateWithSubstring(alloc, v12, v54);
        int v47 = 0;
        _parseComponents(v20, baseURL, (unsigned int *)&v47, v51, &v48);
        CFRelease(v29);
LABEL_17:
        if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)baseURL))
        {
          unsigned int v46 = 0;
          v21 = CFURLGetString(baseURL);
          _parseComponents(v21, 0LL, &v46, v50, &v48);
          unsigned int v23 = v46;
          unsigned int v22 = v47;
          v24 = v50;
          v25 = alloc;
          v26 = v20;
          v27 = v21;
        }

        else
        {
          unsigned int v22 = v47;
          v27 = (const __CFString *)atomic_load((unint64_t *)baseURL + 3);
          unsigned int v23 = *((_DWORD *)baseURL + 4);
          v24 = (CFIndex *)((char *)baseURL + 56);
          v25 = alloc;
          v26 = v20;
        }

        Mutable = (__CFString *)resolveAbsoluteURLString(v25, v26, v22, (uint64_t)v51, v27, v23, v24);
        if (v20) {
          CFRelease(v20);
        }
        goto LABEL_28;
      }

      CFRetain(v12);
      CFRelease(v29);
    }

    else
    {
      CFRetain(v12);
    }

    int v19 = 0;
    Mutable = v12;
LABEL_32:
    CFRelease(v12);
    v12 = Mutable;
    if (Mutable)
    {
LABEL_33:
      _parseComponents(v12, 0LL, &v49, v51, &v48);
      unsigned int v34 = v49;
      if ((v49 & 0x20) == 0) {
        goto LABEL_41;
      }
      unsigned int v35 = 0;
      unsigned int v36 = 32;
      do
      {
        char v37 = v36;
        v36 >>= 1;
        v35 += v34 & 1;
        v34 >>= 1;
      }

      while ((v37 & 2) == 0);
      v38 = &v51[2 * v35];
      CFIndex v39 = *v38;
      CFIndex v40 = v38[1];
      v41 = (UniChar *)CFAllocatorAllocate(alloc, 2 * v40 + 2, 0LL);
      v52.location = v39;
      v52.length = v40;
      CFStringGetCharacters(v12, v52, v41);
      v42 = &v41[v40];
      UniChar *v42 = 0;
      v43 = _resolvedPath((char *)v41, (unint64_t)v42, 47, 1, 0, alloc);
      if (CFStringGetLength(v43) != v40)
      {
        if (!v19)
        {
          CFIndex v44 = CFStringGetLength(v12);
          CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(alloc, v44, v12);
          CFRelease(v12);
          v12 = MutableCopy;
        }

        v53.location = v39;
        v53.length = v40;
        CFStringReplace(v12, v53, v43);
      }

      CFRelease(v43);
      if (v12)
      {
LABEL_41:
        v16 = _CFURLCreateWithURLString(alloc, v12, 0, 0LL);
        CFRelease(v12);
        if (v16) {
          *((_DWORD *)v16 + 5) = encoding;
        }
        return (CFURLRef)v16;
      }

      CFRelease(0LL);
    }

    return 0LL;
  }

  CFIndex v15 = CFURLCreateWithBytes(alloc, relativeURLBytes, length, encoding, baseURL);
  v16 = (unint64_t *)v15;
  if (v15 && baseURL)
  {
    v17 = CFURLCopyAbsoluteURL(v15);
    CFRelease(v16);
    return v17;
  }

  return (CFURLRef)v16;
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  v16[18] = *MEMORY[0x1895F89C0];
  v2 = CFGetAllocator(relativeURL);
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)relativeURL))
  {
    uint64_t v3 = (unint64_t *)-[__CFURL absoluteURL](relativeURL, "absoluteURL");
    unsigned int v4 = v3;
    if (v3) {
      CFRetain(v3);
    }
    return (CFURLRef)v4;
  }

  CFURLRef v5 = (CFURLRef)*((void *)relativeURL + 4);
  if (!v5) {
    return (CFURLRef)CFRetain(relativeURL);
  }
  if (CFURLIsFileReferenceURL(*((CFURLRef *)relativeURL + 4)) && !CFURLHasDirectoryPath(v5))
  {
    CFURLRef v13 = CFURLCreateFilePathURL(v2, v5, 0LL);
    if (!v13) {
      return 0LL;
    }
    CFURLRef v5 = v13;
    char v6 = 0;
  }

  else
  {
    char v6 = 1;
  }

  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)v5))
  {
    BOOL v7 = CFURLGetString(v5);
    unsigned int v15 = 0;
    unint64_t v8 = v16;
    _parseComponents(v7, 0LL, &v15, v16, &v14);
  }

  else
  {
    BOOL v7 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
    unsigned int v15 = *((_DWORD *)v5 + 4);
    unint64_t v8 = (CFIndex *)((char *)v5 + 56);
  }

  unint64_t v10 = (const __CFString *)atomic_load((unint64_t *)relativeURL + 3);
  int v11 = resolveAbsoluteURLString(v2, v10, *((_DWORD *)relativeURL + 4), (uint64_t)relativeURL + 56, v7, v15, v8);
  if (v11)
  {
    v12 = v11;
    unsigned int v4 = _CFURLCreateWithURLString(v2, (CFStringRef)v11, 0, 0LL);
    CFRelease(v12);
    *((_DWORD *)v4 + 5) = *((_DWORD *)relativeURL + 5);
    if ((v6 & 1) != 0) {
      return (CFURLRef)v4;
    }
    goto LABEL_16;
  }

  unsigned int v4 = 0LL;
  if ((v6 & 1) == 0) {
LABEL_16:
  }
    CFRelease(v5);
  return (CFURLRef)v4;
}

void _parseComponents(const __CFString *a1, const __CFURL *a2, unsigned int *a3, void *a4, char *a5)
{
  uint64_t v114 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  v100 = 0LL;
  v101 = 0LL;
  constructBuffers(a1, v104, &v101, &v100, (char *)&v103, &v102);
  int v11 = v103;
  if (v103)
  {
    __int128 v112 = 0u;
    __int128 v113 = 0u;
    __int128 v110 = 0u;
    __int128 v111 = 0u;
    __int128 v108 = 0u;
    __int128 v109 = 0u;
    __int128 v106 = 0u;
    __int128 v107 = 0u;
    __int128 v105 = 0u;
    unsigned int v12 = *a3;
    if (Length < 1)
    {
      int v17 = 0;
      char v14 = 0;
      unsigned int v18 = 0;
    }

    else
    {
      uint64_t v13 = 0LL;
      while (v101[v13] != 35)
      {
        if (Length == ++v13)
        {
          char v14 = 0;
          uint64_t v13 = Length;
          goto LABEL_14;
        }
      }

      v12 |= 0x100u;
      *(void *)&__int128 v113 = v13 + 1;
      *((void *)&v113 + 1) = ~v13 + Length;
      char v14 = 1;
LABEL_14:
      if (v13 < 1)
      {
        int v17 = 0;
        unsigned int v18 = 0;
      }

      else
      {
        unsigned int v18 = *v101;
        int v17 = 1;
        if ((v18 & 0x80000000) != 0)
        {
          int v19 = 0;
          goto LABEL_20;
        }
      }

      CFIndex Length = v13;
    }

    int v19 = (sURLValidCharacters[(unsigned __int16)v18] >> 3) & 1;
    uint64_t v13 = Length;
LABEL_20:
    uint64_t v20 = 0LL;
    BOOL v23 = v18 > 0x40 && v19 != 0 || v18 == 58;
    if (v17 && v23)
    {
      uint64_t v20 = 0LL;
      while (1)
      {
        uint64_t v24 = v101[v20];
        if (v24 == 58) {
          break;
        }
        if ((v24 & 0x80) == 0 && (sURLValidCharacters[v24] & 8) != 0 && ++v20 < v13) {
          continue;
        }
        uint64_t v20 = 0LL;
        uint64_t v25 = 0LL;
        goto LABEL_38;
      }

      v12 |= 1u;
      *(void *)&__int128 v105 = 0LL;
      *((void *)&v105 + 1) = v20;
      ++v14;
      switch(v20)
      {
        case 3LL:
          if (*v101 != 102 || v101[1] != 116)
          {
            uint64_t v25 = 4LL;
            uint64_t v20 = 3LL;
            goto LABEL_38;
          }

          uint64_t v60 = 4LL;
          uint64_t v61 = 3LL;
          BOOL v62 = v101[2] == 112;
          unsigned int v63 = v12 & 0x1FFFFFFF | 0xA0000000;
          uint64_t v64 = 4LL;
          uint64_t v20 = 3LL;
          break;
        case 4LL:
          int v65 = *v101;
          if (v65 == 100)
          {
            if (v101[1] != 97 || v101[2] != 116) {
              goto LABEL_256;
            }
            uint64_t v60 = 5LL;
            uint64_t v61 = 4LL;
            BOOL v62 = v101[3] == 97;
            unsigned int v90 = 0x80000000;
          }

          else
          {
            if (v65 != 102)
            {
              if (v65 == 104 && v101[1] == 116 && v101[2] == 116 && v101[3] == 112)
              {
                int v33 = v12 & 0x1FFFFFFF | 0x20000000;
                uint64_t v25 = 5LL;
                uint64_t v20 = 4LL;
LABEL_183:
                unsigned int v12 = v33;
                goto LABEL_38;
              }

LABEL_256:
              uint64_t v25 = 5LL;
              uint64_t v20 = 4LL;
              goto LABEL_38;
            }

            if (v101[1] != 105 || v101[2] != 108) {
              goto LABEL_256;
            }
            uint64_t v60 = 5LL;
            uint64_t v61 = 4LL;
            BOOL v62 = v101[3] == 101;
            unsigned int v90 = 1610612736;
          }

          unsigned int v63 = v90 & 0xE0000000 | v12 & 0x1FFFFFFF;
          uint64_t v64 = 5LL;
          uint64_t v20 = 4LL;
          break;
        case 5LL:
          if (*v101 != 104 || v101[1] != 116 || v101[2] != 116 || v101[3] != 112 || v101[4] != 115)
          {
            uint64_t v25 = 6LL;
            uint64_t v20 = 5LL;
            goto LABEL_38;
          }

          int v33 = v12 & 0x1FFFFFFF | 0x40000000;
          uint64_t v25 = 6LL;
          uint64_t v20 = 5LL;
          goto LABEL_183;
        default:
          uint64_t v25 = v20 + 1;
          goto LABEL_38;
      }

      if (v62) {
        unsigned int v12 = v63;
      }
      else {
        uint64_t v20 = v61;
      }
      if (v62) {
        uint64_t v25 = v64;
      }
      else {
        uint64_t v25 = v60;
      }
    }

    else
    {
      uint64_t v25 = 0LL;
    }

LABEL_284:
          if ((v26 & 4) == 0) {
            *((void *)&v106 + 1) = v86 + 1;
          }
          uint64_t v27 = v25 + v86 + 4;
        }

        v26 |= 8u;
        char v14 = v87 + 1;
        *(void *)&__int128 v108 = v27;
        if (v28 > v27)
        {
          for (uint64_t i = v27; i < v28; ++i)
          {
            int v97 = v101[i];
            if (v97 == 91)
            {
              if (i < v28)
              {
                while (v101[i] != 93)
                {
                  if (v28 == ++i)
                  {
                    uint64_t i = v28;
                    goto LABEL_297;
                  }
                }

                v26 |= 0x400u;
              }
            }

            else if (v97 == 58)
            {
              v26 |= 0x10u;
              char v14 = v87 + 2;
              *(void *)&__int128 v109 = i + 1;
              *((void *)&v109 + 1) = v28 - (i + 1);
              *((void *)&v108 + 1) = i - v27;
              break;
            }

LABEL_297:
            ;
          }
        }

        if ((v26 & 0x10) == 0) {
          *((void *)&v108 + 1) = v28 - v27;
        }
      }
    }

    else
    {
      uint64_t v28 = v25;
    }

    if (v28 >= v13)
    {
LABEL_54:
      uint64_t v29 = v13;
    }

    else
    {
      uint64_t v29 = v28;
      while (v101[v29] != 63)
      {
        if (v13 == ++v29) {
          goto LABEL_54;
        }
      }

      v26 |= 0x80u;
      ++v14;
      *(void *)&__int128 v112 = v29 + 1;
      *((void *)&v112 + 1) = ~v29 + v13;
    }

    if ((v26 & 0x1E) == 0 && v29 == v28) {
      goto LABEL_168;
    }
    uint64_t v34 = v29 - v28;
    int v35 = v26 | 0x20;
    ++v14;
    *(void *)&__int128 v110 = v28;
    *((void *)&v110 + 1) = v29 - v28;
    if (v29 - v28 < 1)
    {
      if (a2 && CFURLHasDirectoryPath(a2))
      {
LABEL_166:
        int v26 = v35 | 0x800;
        goto LABEL_168;
      }
    }

    else
    {
      if (v29 <= v28)
      {
        BOOL v36 = 0;
      }

      else if (v101[v28] == 37)
      {
        BOOL v36 = 1;
      }

      else
      {
        uint64_t v50 = v28 + 1;
        do
        {
          uint64_t v51 = v50;
          if (v29 == v50) {
            break;
          }
          int v52 = v101[v50++];
        }

        while (v52 != 37);
        BOOL v36 = v51 < v29;
      }

      if (v34 >= 7
        && v101[v28] == 47
        && v101[v28 + 1] == 46
        && v101[v28 + 2] == 102
        && v101[v28 + 3] == 105
        && v101[v28 + 4] == 108
        && (CFRange v53 = &v101[v28], v53[5] == 101)
        && v53[6] == 47)
      {
        int v35 = v26 | 0x2020;
      }

      else
      {
        int v54 = v26 | 0x8020;
        if (!v36) {
          int v35 = v54;
        }
      }

      int v55 = v101[v29 - 1];
      if (v55 == 47) {
        goto LABEL_166;
      }
      if ((unsigned __int16)v55 == 46)
      {
        if (v34 == 1) {
          goto LABEL_166;
        }
        int v56 = v101[v29 - 2];
      }
    }

    int v26 = v35;
LABEL_168:
    uint64_t v57 = 0LL;
    int v58 = 0;
    *a3 = v26;
    *a5 = v14;
    int v59 = 1;
    do
    {
      if ((*a3 & v59) != 0) {
        *(_OWORD *)&a4[2 * v58++] = *(__int128 *)((char *)&v105 + v57);
      }
      v59 *= 2;
      v57 += 16LL;
    }

    while (v57 != 144);
    goto LABEL_215;
  }

  __int128 v112 = 0u;
  __int128 v113 = 0u;
  __int128 v110 = 0u;
  __int128 v111 = 0u;
  __int128 v108 = 0u;
  __int128 v109 = 0u;
  __int128 v106 = 0u;
  __int128 v107 = 0u;
  __int128 v105 = 0u;
  unsigned int v12 = *a3;
  if (Length < 1)
  {
    int v30 = 0;
    char v16 = 0;
    unsigned int v31 = 0;
  }

  else
  {
    uint64_t v15 = 0LL;
    while (v100[v15] != 35)
    {
      if (Length == ++v15)
      {
        char v16 = 0;
        uint64_t v15 = Length;
        goto LABEL_60;
      }
    }

    v12 |= 0x100u;
    *(void *)&__int128 v113 = v15 + 1;
    *((void *)&v113 + 1) = ~v15 + Length;
    char v16 = 1;
LABEL_60:
    if (v15 < 1)
    {
      int v30 = 0;
      unsigned int v31 = 0u;
    }

    else
    {
      unsigned int v31 = *v100;
      int v30 = 1;
      if (v31 > 0x7F)
      {
        int v32 = 0;
        goto LABEL_82;
      }
    }

    CFIndex Length = v15;
  }

  int v32 = (sURLValidCharacters[v31] >> 3) & 1;
  uint64_t v15 = Length;
LABEL_82:
  uint64_t v20 = 0LL;
  BOOL v39 = v31 > 0x40 && v32 != 0 || v31 == 58;
  if (!v30 || !v39)
  {
    uint64_t v41 = 0LL;
    goto LABEL_100;
  }

  uint64_t v20 = 0LL;
  while (1)
  {
    uint64_t v40 = v100[v20];
    if ((_DWORD)v40 == 58) {
      break;
    }
    uint64_t v20 = 0LL;
    uint64_t v41 = 0LL;
    goto LABEL_100;
  }

  v12 |= 1u;
  *(void *)&__int128 v105 = 0LL;
  *((void *)&v105 + 1) = v20;
  ++v16;
  switch(v20)
  {
    case 3LL:
      if (*v100 != 102 || v100[1] != 116)
      {
        uint64_t v41 = 4LL;
        uint64_t v20 = 3LL;
        break;
      }

      uint64_t v79 = 4LL;
      uint64_t v80 = 3LL;
      BOOL v81 = v100[2] == 112;
      unsigned int v82 = v12 & 0x1FFFFFFF | 0xA0000000;
      uint64_t v83 = 4LL;
      uint64_t v20 = 3LL;
      goto LABEL_260;
    case 4LL:
      int v84 = *v100;
      if (v84 != 100)
      {
        if (v84 == 102)
        {
          if (v100[1] == 105 && v100[2] == 108 && v100[3] == 101)
          {
            int v85 = 1610612736;
            goto LABEL_270;
          }
        }

        else if (v84 == 104 && v100[1] == 116 && v100[2] == 116 && v100[3] == 112)
        {
          int v85 = 0x20000000;
LABEL_270:
          unsigned int v46 = v85 & 0xE0000000 | v12 & 0x1FFFFFFF;
          uint64_t v41 = 5LL;
          uint64_t v20 = 4LL;
          goto LABEL_271;
        }

LABEL_272:
        uint64_t v41 = 5LL;
        uint64_t v20 = 4LL;
        break;
      }

      if (v100[1] != 97 || v100[2] != 116) {
        goto LABEL_272;
      }
      uint64_t v79 = 5LL;
      uint64_t v80 = 4LL;
      BOOL v81 = v100[3] == 97;
      unsigned int v82 = v12 & 0x1FFFFFFF | 0x80000000;
      uint64_t v83 = 5LL;
      uint64_t v20 = 4LL;
LABEL_260:
      if (v81) {
        unsigned int v12 = v82;
      }
      else {
        uint64_t v20 = v80;
      }
      if (v81) {
        uint64_t v41 = v83;
      }
      else {
        uint64_t v41 = v79;
      }
      break;
    case 5LL:
      if (*v100 == 104 && v100[1] == 116 && v100[2] == 116 && v100[3] == 112 && v100[4] == 115)
      {
        unsigned int v46 = v12 & 0x1FFFFFFF | 0x40000000;
        uint64_t v41 = 6LL;
        uint64_t v20 = 5LL;
LABEL_271:
        unsigned int v12 = v46;
        break;
      }

      uint64_t v41 = 6LL;
      uint64_t v20 = 5LL;
      break;
    default:
      uint64_t v41 = v20 + 1;
      break;
  }

LABEL_100:
  if ((v12 & 1) != 0 && (v15 == v41 || v100[v41] != 47)) {
    goto LABEL_113;
  }
  int v42 = v12 | 0x4000;
  if (v15 - v41 >= 2 && v100[v41] == 47 && v100[v41 + 1] == 47)
  {
    uint64_t v43 = v41 + 2;
    if (v41 + 2 >= v15) {
      goto LABEL_112;
    }
    uint64_t v44 = v41 + 2;
    while ((v100[v44] | 0x10) != 0x3F)
    {
      if (v15 == ++v44)
      {
        uint64_t v44 = v15;
        break;
      }
    }

    if (v44 == v43)
    {
LABEL_112:
      uint64_t v44 = v41 + 2;
    }

    else
    {
      if (v43 >= v44)
      {
LABEL_242:
        char v89 = v16;
      }

      else
      {
        uint64_t v88 = 0LL;
        while (v100[v41 + 2 + v88] != 64)
        {
          ++v88;
          if (!(v41 - v44 + 2 + v88)) {
            goto LABEL_242;
          }
        }

        int v42 = v12 | 0x4002;
        char v89 = v16 + 1;
        *(void *)&__int128 v106 = v41 + 2;
        if (v43 < v41 + v88 + 2)
        {
          uint64_t v94 = 0LL;
          uint64_t v95 = v88 - 1;
          while (v100[v41 + 2 + v94] != 58)
          {
            ++v94;
            if (--v95 == -1) {
              goto LABEL_301;
            }
          }

          int v42 = v12 | 0x4006;
          char v89 = v16 + 2;
          *(void *)&__int128 v107 = v41 + v94 + 3;
          *((void *)&v107 + 1) = v95;
          *((void *)&v106 + 1) = v94;
        }

LABEL_301:
        if ((v42 & 4) == 0) {
          *((void *)&v106 + 1) = v88;
        }
        uint64_t v43 = v41 + v88 + 3;
      }

      v42 |= 8u;
      char v16 = v89 + 1;
      *(void *)&__int128 v108 = v43;
      if (v44 > v43)
      {
        for (uint64_t j = v43; j < v44; ++j)
        {
          int v99 = v100[j];
          if (v99 == 91)
          {
            if (j < v44)
            {
              while (v100[j] != 93)
              {
                if (v44 == ++j)
                {
                  uint64_t j = v44;
                  goto LABEL_314;
                }
              }

              v42 |= 0x400u;
            }
          }

          else if (v99 == 58)
          {
            v42 |= 0x10u;
            char v16 = v89 + 2;
            *(void *)&__int128 v109 = j + 1;
            *((void *)&v109 + 1) = v44 - (j + 1);
            *((void *)&v108 + 1) = j - v43;
            break;
          }

LABEL_314:
          ;
        }
      }

      if ((v42 & 0x10) == 0) {
        *((void *)&v108 + 1) = v44 - v43;
      }
    }
  }

  else
  {
    uint64_t v44 = v41;
  }

  if (v44 >= v15)
  {
LABEL_119:
    uint64_t v45 = v15;
  }

  else
  {
    uint64_t v45 = v44;
    while (v100[v45] != 63)
    {
      if (v15 == ++v45) {
        goto LABEL_119;
      }
    }

    v42 |= 0x80u;
    ++v16;
    *(void *)&__int128 v112 = v45 + 1;
    *((void *)&v112 + 1) = ~v45 + v15;
  }

  if ((v42 & 0x1E) == 0 && v45 == v44) {
    goto LABEL_211;
  }
  uint64_t v47 = v45 - v44;
  int v48 = v42 | 0x20;
  ++v16;
  *(void *)&__int128 v110 = v44;
  *((void *)&v110 + 1) = v45 - v44;
  if (v45 - v44 < 1)
  {
    if (a2 && CFURLHasDirectoryPath(a2))
    {
LABEL_209:
      int v42 = v48 | 0x800;
      goto LABEL_211;
    }
  }

  else
  {
    if (v45 <= v44)
    {
      BOOL v49 = 0;
    }

    else if (v100[v44] == 37)
    {
      BOOL v49 = 1;
    }

    else
    {
      uint64_t v66 = v44 + 1;
      do
      {
        uint64_t v67 = v66;
        if (v45 == v66) {
          break;
        }
        int v68 = v100[v66++];
      }

      while (v68 != 37);
      BOOL v49 = v67 < v45;
    }

    if (v47 >= 7
      && v100[v44] == 47
      && (v69 = &v100[v44], v69[1] == 46)
      && v69[2] == 102
      && (v70 = &v100[v44], v70[3] == 105)
      && v70[4] == 108
      && (v71 = &v100[v44], v71[5] == 101)
      && v71[6] == 47)
    {
      int v48 = v42 | 0x2020;
    }

    else
    {
      int v72 = v42 | 0x8020;
      if (!v49) {
        int v48 = v72;
      }
    }

    int v73 = v100[v45 - 1];
    if (v73 == 47) {
      goto LABEL_209;
    }
    if (v73 == 46)
    {
      if (v47 == 1) {
        goto LABEL_209;
      }
      int v74 = v100[v45 - 2];
      if (v74 == 47 || v74 == 46 && (v47 == 2 || v100[v45 - 3] == 47)) {
        goto LABEL_209;
      }
    }
  }

  int v42 = v48;
LABEL_211:
  uint64_t v75 = 0LL;
  int v76 = 0;
  *a3 = v42;
  *a5 = v16;
  int v77 = 1;
  do
  {
    if ((*a3 & v77) != 0) {
      *(_OWORD *)&a4[2 * v76++] = *(__int128 *)((char *)&v105 + v75);
    }
    v77 *= 2;
    v75 += 16LL;
  }

  while (v75 != 144);
LABEL_215:
  if (v102)
  {
    v78 = (void **)&v101;
    if (!v11) {
      v78 = (void **)&v100;
    }
    free(*v78);
  }

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  while (2)
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
    {
      CFURLRef v5 = (const __CFString *)-[__CFURL scheme](anURL, "scheme");
      uint64_t v3 = v5;
      if (v5) {
        CFRetain(v5);
      }
    }

    else
    {
      switch(*((_DWORD *)anURL + 4) >> 29)
      {
        case 1:
          unsigned int v4 = @"http";
          return (CFStringRef)CFRetain(v4);
        case 2:
          unsigned int v4 = @"https";
          return (CFStringRef)CFRetain(v4);
        case 3:
          unsigned int v4 = @"file";
          return (CFStringRef)CFRetain(v4);
        case 4:
          unsigned int v4 = @"data";
          return (CFStringRef)CFRetain(v4);
        case 5:
          unsigned int v4 = @"ftp";
          return (CFStringRef)CFRetain(v4);
        default:
          v2 = _retainedComponentString((uint64_t)anURL, 1, 1, 0);
          if (v2) {
            return v2;
          }
          anURL = (CFURLRef)*((void *)anURL + 4);
          if (anURL) {
            continue;
          }
          uint64_t v3 = 0LL;
          break;
      }
    }

    break;
  }

  return v3;
}

UniChar *resolveAbsoluteURLString( const __CFAllocator *a1, const __CFString *a2, unsigned int a3, uint64_t a4, CFStringRef theString, unsigned int a6, CFIndex *a7)
{
  v21[1] = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(theString);
  CFIndex v15 = CFStringGetLength(a2);
  if (v15 + Length > 1024)
  {
    CFURLRef result = (UniChar *)malloc(2 * (v15 + Length));
    if (result)
    {
      int v19 = result;
      CFMutableStringRef v20 = resolveAbsoluteURLStringBuffer(a1, a2, a3, a4, theString, a6, a7, result);
      free(v19);
      return (UniChar *)v20;
    }
  }

  else
  {
    MEMORY[0x1895F8858](v15, v16);
    return (UniChar *)resolveAbsoluteURLStringBuffer(a1, a2, a3, a4, theString, a6, a7, (UniChar *)((char *)v21 - v17));
  }

  return result;
}

CFStringRef _resolvedPath(char *__dst, unint64_t a2, int a3, int a4, int a5, CFAllocatorRef alloc)
{
  unint64_t v8 = (char *)a2;
  int v11 = (unsigned __int16 *)__dst;
  while (2)
  {
    unsigned int v12 = (char *)(v11 + 1);
    uint64_t v13 = (char *)(v11 + 2);
    unint64_t v14 = (unint64_t)(v11 + 3);
    while (1)
    {
      if (*v11 != 46) {
        goto LABEL_32;
      }
      if (v12 == v8)
      {
        unint64_t v8 = (char *)(v11 + 1);
        if (v11 != (unsigned __int16 *)__dst)
        {
          unsigned __int16 *v11 = 0;
          unint64_t v8 = (char *)v11;
        }

        goto LABEL_40;
      }

      int v15 = *(unsigned __int16 *)v12;
      if (v15 == a3)
      {
        if (v11 == (unsigned __int16 *)__dst && v13 == v8)
        {
          unint64_t v8 = (char *)(v11 + 2);
          goto LABEL_40;
        }

        memmove(v11, v11 + 2, v8 - v13 + 2);
        uint64_t v16 = -2LL;
        goto LABEL_19;
      }

      if (v8 - (char *)v11 < 3
        || v15 != 46
        || v13 != v8 && ((unint64_t)(v8 - (char *)v11) < 5 || *(unsigned __int16 *)v13 != a3))
      {
        goto LABEL_32;
      }

      if (!a4) {
        goto LABEL_32;
      }
      memmove(v11, v11 + 3, (unint64_t)&v8[-v14 + 2] & 0x1FFFFFFFELL);
      uint64_t v16 = -3LL;
LABEL_19:
      v8 += 2 * v16;
    }

    unsigned int v18 = i + 2;
    if (i + 2 == (char *)v11 || (char *)v11 - v18 == 6 && *(_WORD *)v18 == 46 && *((_WORD *)i + 2) == 46)
    {
LABEL_32:
      unsigned int v18 = (char *)(v11 + 1);
      goto LABEL_35;
    }

    if (v13 == v8)
    {
      if (v18 == __dst)
      {
        *(_DWORD *)__dst = 3080238;
        *((_WORD *)__dst + 2) = 0;
        unint64_t v8 = __dst + 6;
      }

      else
      {
        *(_WORD *)unsigned int v18 = 0;
        unint64_t v8 = i + 2;
      }

      break;
    }

    memmove(v18, v11 + 3, (unint64_t)&v8[-v14 + 2] & 0x1FFFFFFFELL);
    unint64_t v8 = &v18[(void)v8 - v14];
LABEL_35:
    int v11 = (unsigned __int16 *)v18;
    if (v18 < v8) {
      continue;
    }
    break;
  }

Boolean CFURLIsFileReferenceURL(CFURLRef url)
{
  do
  {
    while (1)
    {
      CFURLRef v1 = url;
      url = (CFURLRef)-[__CFURL baseURL](v1, "baseURL");
      if (!url) {
        goto LABEL_5;
      }
    }

    url = (CFURLRef)*((void *)v1 + 4);
  }

  while (url);
LABEL_5:
  else {
    return (*((_DWORD *)v1 + 4) & 0xE0002000) == 1610620928;
  }
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  do
  {
    unsigned int v2 = *((_DWORD *)anURL + 4);
    anURL = (CFURLRef)*((void *)anURL + 4);
    if (anURL) {
      BOOL v3 = (v2 & 0x3E) == 0;
    }
    else {
      BOOL v3 = 0;
    }
  }

  while (v3);
  return (v2 >> 11) & 1;
}

CFURLRef CFURLCreateFilePathURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (!_CFURLHasFileURLScheme((__objc2_class **)url, (_BYTE *)&v45 + 7))
  {
    if (HIBYTE(v45))
    {
      if (error)
      {
LABEL_11:
        v21 = 0LL;
        *error = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 262LL, 0LL);
        return (CFURLRef)v21;
      }
    }

    else
    {
      CFLog( 4LL,  (uint64_t)@"CFURLCreateFilePathURL failed because it was passed a URL which has no scheme",  v6,  v7,  v8,  v9,  v10,  v11,  v45);
      if (error) {
        goto LABEL_11;
      }
    }

    return 0LL;
  }

  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
  {
    if (-[__CFURL baseURL](url, "baseURL")) {
      goto LABEL_4;
    }
  }

  else if (*((void *)url + 4))
  {
LABEL_4:
    CFURLRef v12 = CFURLCopyAbsoluteURL(url);
    uint64_t v13 = CFGetAllocator(v12);
    unint64_t v14 = CFURLCreateStringWithFileSystemPath(v13, (__objc2_class **)v12, 0LL, 0);
    int v15 = CFURLCopyNetLocation(v12);
    uint64_t v16 = CFURLCopyResourceSpecifier(v12);
    CFRelease(v12);
    if (v14) {
      goto LABEL_5;
    }
    goto LABEL_14;
  }

  unsigned int v22 = CFGetAllocator(url);
  unint64_t v14 = CFURLCreateStringWithFileSystemPath(v22, (__objc2_class **)url, 0LL, 0);
  int v15 = CFURLCopyNetLocation(url);
  uint64_t v16 = CFURLCopyResourceSpecifier(url);
  if (v14)
  {
LABEL_5:
    unint64_t Length = CFStringGetLength(v14);
    if (Length <= 1) {
      unint64_t Length = 1LL;
    }
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFIndex v19 = MaximumSizeForEncoding + 1;
    if (MaximumSizeForEncoding >= 1024) {
      CFMutableStringRef v20 = (char *)malloc(MaximumSizeForEncoding + 1);
    }
    else {
      CFMutableStringRef v20 = (char *)buffer;
    }
    if (CFStringGetCString(v14, v20, v19, 0x8000100u))
    {
      size_t v23 = strlen(v20);
      StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes( 0LL,  v20,  v23,  0,  0,  0,  0LL);
    }

    else
    {
      StringFromFileSystemRepresentationByAddingPercentEscapes = 0LL;
    }

    CFIndex v47 = 0LL;
    CFMutableStringRef Mutable = CFStringCreateMutable(allocator, 0LL);
    CFIndex v25 = CFStringGetLength(@"file://");
    CFIndex v26 = v47;
    if (v25 < 1025)
    {
      CFIndex v27 = v25;
      if (v47 + v25 >= 1025)
      {
        CFStringAppendCharacters(Mutable, buffer, v47);
        CFIndex v26 = 0LL;
        CFIndex v47 = 0LL;
      }

      uint64_t v28 = &buffer[v26];
      v50.location = 0LL;
      v50.length = v27;
      CFStringGetCharacters(@"file://", v50, v28);
      v47 += v27;
      if (!v15)
      {
LABEL_40:
        CFIndex v33 = CFStringGetLength(StringFromFileSystemRepresentationByAddingPercentEscapes);
        CFIndex v34 = v47;
        if (v33 < 1025)
        {
          CFIndex v35 = v33;
          if (v47 + v33 >= 1025)
          {
            CFStringAppendCharacters(Mutable, buffer, v47);
            CFIndex v34 = 0LL;
            CFIndex v47 = 0LL;
          }

          BOOL v36 = &buffer[v34];
          v52.location = 0LL;
          v52.length = v35;
          CFStringGetCharacters(StringFromFileSystemRepresentationByAddingPercentEscapes, v52, v36);
          v47 += v35;
        }

        else
        {
          if (v47)
          {
            CFStringAppendCharacters(Mutable, buffer, v47);
            CFIndex v47 = 0LL;
          }

          CFStringAppend(Mutable, StringFromFileSystemRepresentationByAddingPercentEscapes);
        }

        if (CFURLHasDirectoryPath(url)
          && CFStringCompare(StringFromFileSystemRepresentationByAddingPercentEscapes, @"/", 0LL))
        {
          CFIndex v37 = v47;
          if (v47 >= 1024)
          {
            CFStringAppendCharacters(Mutable, buffer, v47);
            CFIndex v37 = 0LL;
            CFIndex v47 = 0LL;
          }

          buffer[v37] = 47;
          ++v47;
        }

        if (v16)
        {
          CFIndex v38 = CFStringGetLength(v16);
          CFIndex v39 = v47;
          if (v38 < 1025)
          {
            CFIndex v43 = v38;
            if (v47 + v38 >= 1025)
            {
              CFStringAppendCharacters(Mutable, buffer, v47);
              CFIndex v39 = 0LL;
              CFIndex v47 = 0LL;
            }

            uint64_t v44 = &buffer[v39];
            v53.location = 0LL;
            v53.length = v43;
            CFStringGetCharacters(v16, v53, v44);
            CFIndex v40 = v47 + v43;
            CFIndex v47 = v40;
            if (!v40)
            {
LABEL_59:
              uint64_t v41 = Mutable;
              CFMutableStringRef Mutable = 0LL;
              if (v41)
              {
                v21 = _CFURLCreateWithURLString(allocator, v41, 1, 0LL);
                CFRelease(v41);
              }

              else
              {
                v21 = 0LL;
              }

              CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
              CFRelease(v14);
              if (!v15) {
                goto LABEL_64;
              }
              goto LABEL_63;
            }

uint64_t _CFURLGetEncoding(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  CFURLRef v1 = anURL;
  return (*((_DWORD *)v1 + 4) >> 14) & 1;
}

CFIndex CFURLGetBytes(CFURLRef url, UInt8 *buffer, CFIndex bufferLength)
{
  usedBufLen[1] = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
  {
    uint64_t v6 = CFURLGetString(url);
    CFStringEncoding v7 = 134217984;
  }

  else
  {
    uint64_t v6 = (const __CFString *)atomic_load((unint64_t *)url + 3);
    CFStringEncoding v7 = *((_DWORD *)url + 5);
  }

  CFIndex Length = CFStringGetLength(v6);
  v11.location = 0LL;
  v11.length = Length;
  if (CFStringGetBytes(v6, v11, v7, 0, 0, buffer, bufferLength, usedBufLen) == Length) {
    return usedBufLen[0];
  }
  else {
    return -1LL;
  }
}

CFIndex CFURLGetBytesUsingEncoding(unint64_t *a1, UInt8 *a2, CFIndex a3, CFStringEncoding a4)
{
  usedBufLen[1] = *MEMORY[0x1895F89C0];
  else {
    uint64_t v8 = (const __CFString *)atomic_load(a1 + 3);
  }
  CFIndex Length = CFStringGetLength(v8);
  v12.location = 0LL;
  v12.length = Length;
  if (CFStringGetBytes(v8, v12, a4, 0, 0, a2, a3, usedBufLen) == Length) {
    return usedBufLen[0];
  }
  else {
    return -1LL;
  }
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  else {
    return (CFURLRef)*((void *)anURL + 4);
  }
}

CFStringRef _retainedComponentString(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  uint64_t v8 = CFGetAllocator((CFTypeRef)a1);
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if ((v9 & a2) == 0) {
    return 0LL;
  }
  uint64_t v10 = v8;
  if ((a2 & 1) != 0)
  {
    v16.location = *(void *)(a1 + 56);
    if (v16.location != -1)
    {
      v16.length = *(void *)(a1 + 64);
      goto LABEL_10;
    }

    return 0LL;
  }

  unsigned int v11 = 0;
  unsigned int v12 = a2;
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  do
  {
    char v14 = v12;
    v12 >>= 1;
    v11 += v13 & 1;
    v13 >>= 1;
  }

  while ((v14 & 2) == 0);
  int v15 = (CFIndex *)(a1 + 56 + 16LL * v11);
  v16.location = *v15;
  if (*v15 == -1) {
    return 0LL;
  }
  v16.length = v15[1];
  if ((a2 & 1) == 0)
  {
LABEL_13:
    CFIndex v19 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    CFMutableStringRef v20 = CFStringCreateWithSubstring(v8, v19, v16);
    goto LABEL_19;
  }

CFStringRef CFURLCopyNetLocation(CFURLRef anURL)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  while (1)
  {
    int v2 = *((_DWORD *)anURL + 4);
    if ((v2 & 0x1E) != 0) {
      break;
    }
    anURL = (CFURLRef)*((void *)anURL + 4);
    if (!anURL) {
      return 0LL;
    }
  }

  uint64_t v4 = _netLocationRange(*((_DWORD *)anURL + 4), (uint64_t)anURL + 56);
  CFIndex v6 = v5;
  if ((v2 & 0x10000) == 0 && (uint64_t v7 = *((void *)anURL + 5)) != 0 && (*(_BYTE *)(v7 + 16) & 0x1E) != 0)
  {
    uint64_t v8 = *(const __CFString **)(v7 + 8);
    CFIndex v9 = CFStringGetLength(v8) - v4;
    v15.location = v4;
    v15.length = v9;
    if (CFStringFindWithOptions(v8, @"/", v15, 0LL, &result)) {
      CFIndex v9 = result.location - v4;
    }
    uint64_t v10 = CFGetAllocator(anURL);
    v16.location = v4;
    v16.length = v9;
    return CFStringCreateWithSubstring(v10, v8, v16);
  }

  else
  {
    unsigned int v11 = CFGetAllocator(anURL);
    unsigned int v12 = (const __CFString *)atomic_load((unint64_t *)anURL + 3);
    v17.location = v4;
    v17.length = v6;
    return CFStringCreateWithSubstring(v11, v12, v17);
  }

uint64_t _netLocationRange(unsigned int a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if ((a1 & 0x1E) == 0) {
    return -1LL;
  }
  __int128 v2 = xmmword_180C33AB0;
  __int128 v3 = xmmword_180C33AB0;
  if ((a1 & 2) != 0) {
    __int128 v3 = *(_OWORD *)(a2 + 16LL * (a1 & 1));
  }
  v12[0] = v3;
  int v4 = (a1 >> 1) & 1;
  __int128 v5 = xmmword_180C33AB0;
  if ((a1 & 4) != 0) {
    __int128 v5 = *(_OWORD *)(a2 + 16LL * (v4 + (a1 & 1)));
  }
  v12[1] = v5;
  __int128 v6 = xmmword_180C33AB0;
  if ((a1 & 8) != 0) {
    __int128 v6 = *(_OWORD *)(a2 + 16LL * (((a1 >> 2) & 1) + v4 + (a1 & 1)));
  }
  v12[2] = v6;
  if ((a1 & 0x10) != 0)
  {
    unsigned int v7 = 0;
    unsigned int v8 = 16;
    do
    {
      char v9 = v8;
      v8 >>= 1;
      v7 += a1 & 1;
      a1 >>= 1;
    }

    while ((v9 & 2) == 0);
    __int128 v2 = *(_OWORD *)(a2 + 16LL * v7);
  }

  uint64_t v10 = 0LL;
  v12[3] = v2;
  uint64_t result = -1LL;
  do
  {
    if (*(void *)&v12[v10] != -1LL && result == -1) {
      uint64_t result = *(void *)&v12[v10];
    }
    ++v10;
  }

  while (v10 != 4);
  return result;
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  CFURLRef v1 = anURL;
  return _retainedComponentString((uint64_t)v1, 32, 0, 0);
}

CFStringRef _CFURLCopyPath(__objc2_class **a1, int a2)
{
  __int128 v3 = a1;
  return _retainedComponentString((uint64_t)v3, 32, 0, a2);
}

CFStringRef CFURLCopyStrictPath(CFURLRef anURL, Boolean *isAbsolute)
{
  __int128 v3 = CFURLCopyPath(anURL);
  if (!v3) {
    goto LABEL_8;
  }
  int v4 = v3;
  if (!CFStringGetLength(v3))
  {
    CFRelease(v4);
LABEL_8:
    int v4 = 0LL;
    goto LABEL_9;
  }

  if (CFStringGetCharacterAtIndex(v4, 0LL) == 47)
  {
    if (isAbsolute) {
      *isAbsolute = 1;
    }
    __int128 v5 = CFGetAllocator(v4);
    v8.length = CFStringGetLength(v4) - 1;
    v8.location = 1LL;
    __int128 v6 = CFStringCreateWithSubstring(v5, v4, v8);
    CFRelease(v4);
    return v6;
  }

CFStringRef CFURLCopyResourceSpecifier(CFURLRef anURL)
{
  CFURLRef v1 = anURL;
  uint64_t v40 = *MEMORY[0x1895F89C0];
  int v2 = *((_DWORD *)v1 + 4);
  if ((v2 & 0x4000) != 0)
  {
    unsigned int v4 = 0;
    for (unsigned int i = 256; i != 32; i >>= 1)
    {
      if ((i & v2) != 0) {
        unsigned int v4 = i;
      }
    }

    if (!v4) {
      return 0LL;
    }
    CFAllocatorRef v6 = CFGetAllocator(v1);
    if (v1 && (uint64_t v7 = *((void *)v1 + 5)) != 0)
    {
      int v8 = *(_DWORD *)(v7 + 16);
      char v9 = *(const __CFString **)(v7 + 8);
    }

    else
    {
      int v8 = 0;
      char v9 = 0LL;
    }

    unsigned int v19 = *((_DWORD *)v1 + 4);
    if ((v19 & 0x10000) != 0 || v4 == 512)
    {
LABEL_27:
      if ((v19 & v4) != 0)
      {
        if ((v4 & 1) != 0)
        {
          uint64_t v21 = 0LL;
        }

        else
        {
          LODWORD(v21) = 0;
          do
          {
            char v22 = v4;
            v4 >>= 1;
            uint64_t v21 = (v19 & 1) + v21;
            v19 >>= 1;
          }

          while ((v22 & 2) == 0);
        }

        CFIndex v24 = *((void *)v1 + 2 * v21 + 7) - 1LL;
      }

      else
      {
        CFIndex v24 = -2LL;
      }

      unint64_t v30 = (unint64_t *)((char *)v1 + 24);
      CFStringEncoding v31 = (const __CFString *)atomic_load(v30);
      CFIndex Length = CFStringGetLength(v31);
      uint64_t v14 = (const __CFString *)atomic_load(v30);
      v12.length = Length - v24;
      uint64_t v13 = v6;
      v12.location = v24;
    }

    else
    {
      unsigned int v20 = v4;
      while ((v20 & v8) == 0)
      {
        v20 *= 2;
        if (v20 == 512) {
          goto LABEL_27;
        }
      }

      unsigned int v25 = v4;
      while (v25 >= 2)
      {
        BOOL v26 = (v8 & (v25 >> 1)) == 0;
        v25 >>= 1;
        if (!v26)
        {
          unsigned int v38 = 0;
          _parseComponents(v9, *((const __CFURL **)v1 + 4), &v38, v39, &v37);
          unsigned int v27 = v38;
          if ((v38 & v4) != 0)
          {
            if ((v4 & 1) != 0)
            {
              uint64_t v28 = 0LL;
            }

            else
            {
              LODWORD(v28) = 0;
              do
              {
                char v29 = v4;
                v4 >>= 1;
                uint64_t v28 = (v27 & 1) + v28;
                v27 >>= 1;
              }

              while ((v29 & 2) == 0);
            }

            uint64_t v3 = v39[2 * v28] - 1LL;
          }

          else
          {
            uint64_t v3 = -2LL;
          }

          CFIndex v36 = CFStringGetLength(v9);
          uint64_t v13 = CFGetAllocator(v1);
          v12.length = v36 - v3;
          goto LABEL_18;
        }
      }

      if ((v19 & v4) != 0)
      {
        if ((v4 & 1) != 0)
        {
          uint64_t v33 = 0LL;
        }

        else
        {
          LODWORD(v33) = 0;
          do
          {
            char v34 = v4;
            v4 >>= 1;
            uint64_t v33 = (v19 & 1) + v33;
            v19 >>= 1;
          }

          while ((v34 & 2) == 0);
        }

        uint64_t v35 = *((void *)v1 + 2 * v33 + 7) - 1LL;
      }

      else
      {
        uint64_t v35 = -2LL;
      }

      v12.length = CFStringGetLength(v9) - v35;
      uint64_t v13 = v6;
      uint64_t v14 = v9;
      v12.location = v35;
    }
  }

  else
  {
    if ((v2 & 1) != 0) {
      uint64_t v3 = *((void *)v1 + 7) + *((void *)v1 + 8) + 1LL;
    }
    else {
      uint64_t v3 = 0LL;
    }
    uint64_t v10 = *((void *)v1 + 5);
    if (v10 && (char v9 = *(const __CFString **)(v10 + 8)) != 0LL)
    {
      CFAllocatorRef v11 = CFGetAllocator(v1);
      v12.length = CFStringGetLength(v9) - v3;
      uint64_t v13 = v11;
LABEL_18:
      uint64_t v14 = v9;
    }

    else
    {
      CFAllocatorRef v15 = CFGetAllocator(v1);
      CFRange v16 = (unint64_t *)((char *)v1 + 24);
      unint64_t v17 = atomic_load((unint64_t *)v1 + 3);
      unsigned int v18 = (const __CFString *)atomic_load(v16);
      v12.length = CFStringGetLength(v18) - v3;
      uint64_t v13 = v15;
      uint64_t v14 = (const __CFString *)v17;
    }

    v12.location = v3;
  }

  return CFStringCreateWithSubstring(v13, v14, v12);
}

CFStringRef _CFURLCopyHostName(uint64_t a1, int a2)
{
  while (1)
  {
    if (!a1) {
      _CFURLCopyHostName_cold_1();
    }
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
    {
      uint64_t v7 = (const __CFString *)[(id)a1 host];
      CFAllocatorRef v6 = v7;
      if (v7) {
        CFRetain(v7);
      }
      return v6;
    }

    unsigned int v4 = _retainedComponentString(a1, 8, 1, a2);
    if (v4) {
      break;
    }
    if (*(void *)(a1 + 32))
    {
      char v5 = *(_BYTE *)(a1 + 16);
      a1 = *(void *)(a1 + 32);
      if ((v5 & 0x1F) == 0) {
        continue;
      }
    }

    return 0LL;
  }

  CFAllocatorRef v6 = v4;
  if ((*(_BYTE *)(a1 + 17) & 4) == 0) {
    return v6;
  }
  char v9 = CFGetAllocator((CFTypeRef)a1);
  v11.length = CFStringGetLength(v6) - 2;
  v11.location = 1LL;
  CFStringRef v10 = CFStringCreateWithSubstring(v9, v6, v11);
  CFRelease(v6);
  return v10;
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return _CFURLCopyHostName((uint64_t)anURL, 1);
}

SInt32 CFURLGetPortNumber(CFURLRef anURL)
{
  *(void *)&v11[47] = *MEMORY[0x1895F89C0];
  while (1)
  {
    if (!anURL) {
      CFURLGetPortNumber_cold_1();
    }
    int v2 = _retainedComponentString((uint64_t)anURL, 16, 1, 0);
    if (v2)
    {
      CFAllocatorRef v6 = v2;
      int Length = CFStringGetLength(v2);
      *(void *)&v11[33] = v6;
      *(void *)&v11[39] = 0LL;
      *(void *)&v11[41] = Length;
      CharactersPtr = CFStringGetCharactersPtr(v6);
      CStringPtr = 0LL;
      *(void *)&v11[35] = CharactersPtr;
      if (!CharactersPtr) {
        CStringPtr = CFStringGetCStringPtr(v6, 0x600u);
      }
      *(void *)&v11[43] = 0LL;
      *(void *)&v11[45] = 0LL;
      *(void *)&v11[37] = CStringPtr;
      int v10 = 0;
      CFRelease(v6);
      return v11[0];
    }

    if (*((void *)anURL + 4))
    {
      char v3 = *((_BYTE *)anURL + 16);
      anURL = (CFURLRef)*((void *)anURL + 4);
      if ((v3 & 0x1F) == 0) {
        continue;
      }
    }

    return -1;
  }

  unsigned int v4 = (const __CFNumber *)-[__CFURL port](anURL, "port");
  if (!v4) {
    return -1;
  }
  if (CFNumberGetValue(v4, kCFNumberSInt32Type, &v11[1])) {
    return v11[1];
  }
  else {
    return -1;
  }
}

CFStringRef _CFURLCopyUserName(uint64_t a1, int a2)
{
  while (1)
  {
    if (!a1) {
      _CFURLCopyUserName_cold_1();
    }
    unsigned int v4 = _retainedComponentString(a1, 2, 1, a2);
    if (v4) {
      return v4;
    }
    if (*(void *)(a1 + 32))
    {
      char v5 = *(_BYTE *)(a1 + 16);
      a1 = *(void *)(a1 + 32);
      if ((v5 & 0x1F) == 0) {
        continue;
      }
    }

    return 0LL;
  }

  uint64_t v7 = (const void *)[(id)a1 user];
  CFAllocatorRef v6 = v7;
  if (v7) {
    CFRetain(v7);
  }
  return (const __CFString *)v6;
}

CFStringRef CFURLCopyUserName(CFURLRef anURL)
{
  return _CFURLCopyUserName((uint64_t)anURL, 1);
}

CFStringRef _CFURLCopyPassword(uint64_t a1, int a2)
{
  while (1)
  {
    if (!a1) {
      _CFURLCopyPassword_cold_1();
    }
    unsigned int v4 = _retainedComponentString(a1, 4, 1, a2);
    if (v4) {
      return v4;
    }
    if (*(void *)(a1 + 32))
    {
      char v5 = *(_BYTE *)(a1 + 16);
      a1 = *(void *)(a1 + 32);
      if ((v5 & 0x1F) == 0) {
        continue;
      }
    }

    return 0LL;
  }

  uint64_t v7 = (const void *)[(id)a1 password];
  CFAllocatorRef v6 = v7;
  if (v7) {
    CFRetain(v7);
  }
  return (const __CFString *)v6;
}

CFStringRef CFURLCopyPassword(CFURLRef anURL)
{
  return _CFURLCopyPassword((uint64_t)anURL, 1);
}

CFStringRef CFURLCopyParameterString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  v3[5] = *MEMORY[0x1895F89C0];
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  v3[2] = __CFURLCopyParameterString_block_invoke_24;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = anURL;
  if (CFURLCopyParameterString_onceToken != -1) {
    dispatch_once(&CFURLCopyParameterString_onceToken, v3);
  }
  return 0LL;
}

void __CFURLCopyParameterString_block_invoke_24(uint64_t a1)
{
  int v2 = (os_log_s *)_CFOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
    __CFURLCopyParameterString_block_invoke_24_cold_1(a1, v2);
  }
}

CFStringRef CFURLCopyQueryString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  String = _unescapedQueryString((uint64_t)anURL);
  if (!String) {
    return 0LL;
  }
  char v5 = String;
  int v6 = *((_DWORD *)anURL + 5);
  uint64_t v7 = CFGetAllocator(anURL);
  if (v6 == 134217984) {
    CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapes(v7, v5, charactersToLeaveEscaped);
  }
  else {
    CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding( v7,  v5,  charactersToLeaveEscaped,  *((_DWORD *)anURL + 5));
  }
  char v9 = v8;
  CFRelease(v5);
  return v9;
}

CFStringRef _unescapedQueryString(uint64_t a1)
{
  while (1)
  {
    if (!a1) {
      _unescapedQueryString_cold_1();
    }
    int v2 = _retainedComponentString(a1, 128, 0, 0);
    if (v2) {
      return v2;
    }
    int v3 = *(_DWORD *)(a1 + 16);
    if ((v3 & 0x4000) == 0) {
      return 0LL;
    }
    unsigned int v4 = 0LL;
    if ((v3 & 0x3F) == 0)
    {
      a1 = *(void *)(a1 + 32);
      if (a1) {
        continue;
      }
    }

    return (const __CFString *)v4;
  }

  char v5 = (const void *)[(id)a1 query];
  unsigned int v4 = v5;
  if (v5) {
    CFRetain(v5);
  }
  return (const __CFString *)v4;
}

CFStringRef _CFURLCopyQueryString(const __CFURL *a1, int a2)
{
  if (a2) {
    return CFURLCopyQueryString(a1, &stru_1899EF170);
  }
  else {
    return _unescapedQueryString((uint64_t)a1);
  }
}

CFStringRef CFURLCopyFragment(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  unsigned int v4 = _unescapedFragment((__objc2_class **)anURL);
  if (!v4) {
    return 0LL;
  }
  char v5 = v4;
  int v6 = *((_DWORD *)anURL + 5);
  uint64_t v7 = CFGetAllocator(anURL);
  if (v6 == 134217984) {
    CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapes(v7, v5, charactersToLeaveEscaped);
  }
  else {
    CFStringRef v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding( v7,  v5,  charactersToLeaveEscaped,  *((_DWORD *)anURL + 5));
  }
  char v9 = v8;
  CFRelease(v5);
  return v9;
}

CFStringRef _unescapedFragment(__objc2_class **a1)
{
  int v2 = (const void *)[a1 fragment];
  int v3 = v2;
  if (v2) {
    CFRetain(v2);
  }
  return (const __CFString *)v3;
}

CFStringRef _CFURLCopyFragment(const __CFURL *a1, int a2)
{
  if (a2) {
    return CFURLCopyFragment(a1, &stru_1899EF170);
  }
  else {
    return _unescapedFragment((__objc2_class **)a1);
  }
}

CFRange CFURLGetByteRangeForComponent( CFURLRef url, CFURLComponentType component, CFRange *rangeIncludingSeparators)
{
  CFURLRef v5 = url;
  v47[1] = *MEMORY[0x1895F89C0];
  uint64_t v6 = *((unsigned int *)v5 + 4);
  if ((v6 & 0x4000) == 0)
  {
    if (component == kCFURLComponentResourceSpecifier)
    {
      if ((v6 & 1) != 0) {
        CFIndex v17 = *((void *)v5 + 8);
      }
      else {
        CFIndex v17 = 0LL;
      }
      unsigned int v19 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      CFIndex Length = CFStringGetLength(v19);
      if (v17 + 1 == Length) {
        CFIndex v11 = Length;
      }
      else {
        CFIndex v11 = v17;
      }
      if (v17 + 1 == Length) {
        CFIndex v18 = 0LL;
      }
      else {
        CFIndex v18 = Length - v17;
      }
      if (v17 + 1 == Length) {
        CFIndex v7 = 0LL;
      }
      else {
        CFIndex v7 = Length - v17 - 1;
      }
      if (v17 + 1 == Length) {
        CFIndex v8 = -1LL;
      }
      else {
        CFIndex v8 = v17 + 1;
      }
      goto LABEL_60;
    }

    if (component == kCFURLComponentScheme)
    {
      if ((v6 & 1) != 0)
      {
        CFIndex v8 = *((void *)v5 + 7);
        CFIndex v7 = *((void *)v5 + 8);
      }

      else
      {
        CFIndex v7 = 0LL;
        CFIndex v8 = -1LL;
      }

      CFIndex v11 = 0LL;
      CFIndex v18 = v7 + 1;
      goto LABEL_60;
    }

    CFIndex v18 = 0LL;
    CFIndex v7 = 0LL;
    CFIndex v11 = -1LL;
    goto LABEL_29;
  }

  uint64_t v9 = component - 1;
  unint64_t v10 = qword_180CA5180[v9];
  if ((v10 & v6) == 0)
  {
    if (component == kCFURLComponentScheme || component == kCFURLComponentParameterString) {
      goto LABEL_56;
    }
    uint64_t v21 = 0LL;
    uint64_t v22 = 1LL;
    do
    {
      if ((v22 & v6) != 0) {
        uint64_t v21 = v22;
      }
      if (2 * v22 > 256) {
        break;
      }
      uint64_t v23 = v10 & (2 * v22);
      v22 *= 2LL;
    }

    while (!v23);
    if (!v21)
    {
LABEL_56:
      if (!rangeIncludingSeparators)
      {
        CFIndex v7 = 0LL;
        goto LABEL_76;
      }

      CFIndex v18 = 0LL;
      CFIndex v11 = 0LL;
      CFIndex v7 = 0LL;
      CFIndex v25 = 0LL;
      CFIndex v8 = -1LL;
LABEL_63:
      BOOL v26 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v49.CFIndex location = 0LL;
      v49.length = v11;
      CFStringGetBytes(v26, v49, *((_DWORD *)v5 + 5), 0, 0, 0LL, 0LL, &rangeIncludingSeparators->location);
      if (v8 == -1)
      {
        CFIndex v46 = -1LL;
        v47[0] = v25;
        CFStringRef v32 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
        v52.CFIndex location = v11;
        v52.length = v18;
        CFStringGetBytes(v32, v52, *((_DWORD *)v5 + 5), 0, 0, 0LL, 0LL, &rangeIncludingSeparators->length);
      }

      else
      {
        CFIndex v27 = v8 + v25;
        CFIndex v28 = v11 + v18;
        if (v8 == v11)
        {
          CFIndex location = rangeIncludingSeparators->location;
        }

        else
        {
          uint64_t v33 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
          v53.CFIndex location = v11;
          v53.length = v8 - v11;
          CFStringGetBytes(v33, v53, *((_DWORD *)v5 + 5), 0, 0, 0LL, 0LL, &v46);
          CFIndex location = v46 + v11;
        }

        CFIndex v46 = location;
        char v34 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
        v54.CFIndex location = v8;
        v54.length = v7;
        CFStringGetBytes(v34, v54, *((_DWORD *)v5 + 5), 0, 0, 0LL, 0LL, v47);
        if (v28 == v27)
        {
          CFIndex v35 = v47[0] + v46;
        }

        else
        {
          CFIndex v36 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
          v55.CFIndex location = v27;
          v55.length = v28 - v27;
          CFStringGetBytes(v36, v55, *((_DWORD *)v5 + 5), 0, 0, 0LL, 0LL, &v45);
          CFIndex v35 = v47[0] + v46 + v45;
        }

        rangeIncludingSeparators->length = v35 - rangeIncludingSeparators->location;
      }

LABEL_77:
      CFIndex v37 = v46;
      CFIndex v38 = v47[0];
      goto LABEL_98;
    }

    if (v21 == 1)
    {
      if ((v6 & 1) != 0) {
        uint64_t v24 = *((void *)v5 + 8);
      }
      else {
        uint64_t v24 = 0LL;
      }
      if ((v6 & 0x20) != 0)
      {
        unsigned int v42 = 0;
        unsigned int v43 = 32;
        do
        {
          char v44 = v43;
          v43 >>= 1;
          v42 += v6 & 1;
          LODWORD(v6) = v6 >> 1;
        }

        while ((v44 & 2) == 0);
        uint64_t v41 = *((void *)v5 + 2 * v42 + 7);
      }

      else
      {
        uint64_t v41 = -1LL;
      }

      CFIndex v18 = 0LL;
      CFIndex v7 = 0LL;
      if (v24 + 1 == v41) {
        CFIndex v11 = v24 + 1;
      }
      else {
        CFIndex v11 = v24 + 3;
      }
    }

    else
    {
      if ((v21 & 1) != 0)
      {
        uint64_t v39 = 0LL;
      }

      else
      {
        LODWORD(v39) = 0;
        do
        {
          char v40 = v21;
          LODWORD(v21) = v21 >> 1;
          uint64_t v39 = (v6 & 1) + v39;
          LODWORD(v6) = v6 >> 1;
        }

        while ((v40 & 2) == 0);
      }

      CFIndex v18 = 0LL;
      CFIndex v7 = 0LL;
      CFIndex v11 = *((void *)v5 + 2 * v39 + 8) + *((void *)v5 + 2 * v39 + 7);
    }

        CFRange result = 6LL;
        if ((_DWORD)v41 == 230) {
          return result;
        }
      }

      LODWORD(v41) = 0;
      goto LABEL_77;
    }

    if (a1 - 73 >= 2 && a1 != 302) {
      goto LABEL_45;
    }
    unsigned int v42 = (unsigned __int16 *)(a2 + 2 * (a3 + 1));
    unsigned int v43 = a4 - (a3 + 1);
    while (1)
    {
      if (v43 < 1) {
        return 0LL;
      }
      char v44 = v42 + 1;
      CFIndex v45 = *v42;
      if (v43 != 1 && (v45 & 0xFC00) == 0xD800 && (CFIndex v46 = v42[2], v42 += 2, (v46 & 0xFC00) == 0xDC00))
      {
        CFIndex v45 = (v45 << 10) - 56613888 + *v44;
        v43 -= 2LL;
      }

      else
      {
        unsigned int v42 = v44;
        --v43;
      }

      CFRange result = CFUniCharIsMemberOf(v45, 8u);
      if (!(_DWORD)result) {
        return result;
      }
      if (BYTE2(v45) > 1u) {
        break;
      }
      CFIndex v47 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(v45));
      if (v47)
      {
        if (!*(_BYTE *)(v47 + BYTE1(v45))) {
          break;
        }
        LODWORD(v47) = *(unsigned __int8 *)(v47
                                          + (*(unsigned __int8 *)(v47 + BYTE1(v45)) << 8)
                                          - 256
                                          + v45
                                          + 256);
      }

        uint64_t v79 = v58 - 200;
        if (v58 <= 200) {
          uint64_t v79 = 0LL;
        }
        if (v58 >= 200) {
          uint64_t v80 = 200LL;
        }
        else {
          uint64_t v80 = v58;
        }
        BOOL v81 = v68;
        HyphensForString = __CFHyphenationGetHyphensForString( v68,  0LL,  v80,  (uint64_t)v61,  v95 + v96 + v79,  v100 - (v95 + v96 + v79),  (uint64_t)v9,  (uint64_t)v104,  v106);
        int v68 = v81;
        v71 = HyphensForString;
        goto LABEL_83;
      }

LABEL_83:
  CFIndex v38 = 0LL;
  if (rangeIncludingSeparators) {
    *rangeIncludingSeparators = (CFRange)xmmword_180C33AB0;
  }
  CFIndex v37 = -1LL;
LABEL_98:
  result.length = v38;
  result.CFIndex location = v37;
  return result;
}

          unsigned int v20 = v11;
          break;
        }

uint64_t _CFURLCopyComponents(__objc2_class **a1, uint64_t a2, uint64_t a3)
{
  CFURLRef v5 = a1;
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (a2 == 2)
  {
    CFIndex v7 = CFGetAllocator(v5);
    uint64_t result = decomposeToRFC1808((uint64_t)v5, v18);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v9 = v18[1];
    *(const __CFString **)a3 = v18[0];
    if (v9)
    {
      unint64_t v10 = v19;
      if (v19)
      {
        *(void *)(a3 + 8) = CFStringCreateWithFormat(v7, 0LL, @"%@:%@", v9, v19);
        CFRelease(v10);
        CFRelease(v9);
      }

      else
      {
        *(void *)(a3 + 8) = v9;
      }
    }

    else
    {
      *(void *)(a3 + 8) = 0LL;
    }

    uint64_t v11 = v21;
    *(void *)(a3 + 16) = v20;
    *(void *)(a3 + 24) = v11;
    uint64_t v13 = v22;
    BOOL v12 = v23;
    if (v23)
    {
      int Count = CFArrayGetCount(v22);
      CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(v7, Count, v13);
      *(void *)(a3 + 32) = MutableCopy;
      ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, Count - 1);
      CFStringRef v17 = CFStringCreateWithFormat(v7, 0LL, @"%@;%@", ValueAtIndex, v12);
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a3 + 32), Count - 1, v17);
      CFRelease(v17);
      if (v13) {
        CFRelease(v13);
      }
      CFRelease(v12);
    }

    else
    {
      *(void *)(a3 + 32) = v22;
    }

    *(_OWORD *)(a3 + 40) = v24;
    *(void *)(a3 + 56) = v25;
    return 1LL;
  }

  if (a2 == 1) {
    return decomposeToRFC1808((uint64_t)v5, (const __CFString **)a3);
  }
  if (a2) {
    return 0LL;
  }
  if (!CF_IS_OBJC(0x1DuLL, v5))
  {
    if (v5[4]) {
      goto LABEL_8;
    }
LABEL_16:
    CFStringRef v6 = CFURLCopyScheme((CFURLRef)v5);
    goto LABEL_17;
  }

  if (![v5 baseURL]) {
    goto LABEL_16;
  }
LABEL_8:
  CFStringRef v6 = 0LL;
LABEL_17:
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = CFURLCopyResourceSpecifier((CFURLRef)v5);
  return 1LL;
}

uint64_t decomposeToRFC1808(uint64_t a1, const __CFString **a2)
{
  unsigned int v4 = CFGetAllocator((CFTypeRef)a1);
  int v5 = CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1);
  uint64_t v6 = a1;
  if (v5) {
    uint64_t v6 = [(id)a1 _cfurl];
  }
  if ((*(_BYTE *)(v6 + 17) & 0x40) == 0) {
    return 0LL;
  }
  CFIndex v8 = CFURLCopyPath((CFURLRef)a1);
  if (v8)
  {
    uint64_t v9 = v8;
    a2[5] = (const __CFString *)CFStringCreateArrayBySeparatingStrings(v4, v8, @"/");
    CFRelease(v9);
  }

  else
  {
    a2[5] = 0LL;
  }

  else {
    unint64_t v10 = *(const __CFString **)(a1 + 32);
  }
  a2[9] = v10;
  if (v10)
  {
    CFRetain(v10);
    uint64_t v11 = 0LL;
  }

  else
  {
    uint64_t v11 = _retainedComponentString(a1, 1, 1, 0);
  }

  *a2 = v11;
  a2[1] = _retainedComponentString(a1, 2, 0, 0);
  a2[2] = _retainedComponentString(a1, 4, 0, 0);
  a2[3] = _retainedComponentString(a1, 8, 0, 0);
  if ((*(_BYTE *)(a1 + 16) & 0x10) != 0) {
    uint64_t v12 = CFURLGetPortNumber((CFURLRef)a1);
  }
  else {
    uint64_t v12 = -1LL;
  }
  a2[4] = (const __CFString *)v12;
  a2[6] = 0LL;
  a2[7] = _retainedComponentString(a1, 128, 0, 0);
  a2[8] = _retainedComponentString(a1, 256, 0, 0);
  return 1LL;
}

unint64_t *_CFURLCreateFromComponents(CFAllocatorRef alloc, uint64_t a2, uint64_t a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (a2 == 2)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(alloc, 0LL);
    CFMutableStringRef MutableCopy = Mutable;
    CFStringRef v11 = *(CFStringRef *)a3;
    if (*(void *)a3)
    {
      CFStringAppend(Mutable, *(CFStringRef *)a3);
      CFStringAppend(MutableCopy, @"://");
      uint64_t v12 = 0LL;
    }

    else
    {
      uint64_t v12 = *(const __CFURL **)(a3 + 56);
    }

    BOOL v15 = *(const __CFString **)(a3 + 8);
    if (v15)
    {
      CFStringAppend(MutableCopy, v15);
      CFStringAppend(MutableCopy, @"@");
      CFIndex v16 = *(const __CFString **)(a3 + 16);
      if (!v16)
      {
LABEL_26:
        CFIndex v18 = *(const __CFArray **)(a3 + 32);
        if (!v18
          || (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, 0LL), CFStringGetLength(ValueAtIndex)))
        {
          CFStringAppend(MutableCopy, @"/");
        }

uint64_t __CFURLReservedPtr(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 40);
    if (v1) {
      return *(void *)v1;
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void *__CFURLSetReservedPtr(void *result, uint64_t a2)
{
  if (result)
  {
    int v3 = result;
    unsigned int v4 = (void *)result[5];
    if (a2 && !v4)
    {
      uint64_t result = _CFURLAllocateExtraDataspace(result);
      unsigned int v4 = (void *)v3[5];
    }

    if (v4) {
      *unsigned int v4 = a2;
    }
  }

  return result;
}

__objc2_class **__CFURLResourceInfoPtr(__objc2_class **result)
{
  if (result)
  {
    uint64_t v1 = (unint64_t *)result;
    uint64_t result = (__objc2_class **)[v1 _cfurl];
    uint64_t v1 = (unint64_t *)result;
    if (result) {
      return (__objc2_class **)atomic_load(v1 + 6);
    }
  }

  return result;
}

__objc2_class **__CFURLSetResourceInfoPtr(__objc2_class **result, const void *a2)
{
  if (result)
  {
    int v3 = (unint64_t *)result;
    uint64_t result = (__objc2_class **)CF_IS_OBJC(0x1DuLL, result);
    if (!(_DWORD)result
      || (result = (__objc2_class **)[v3 _cfurl], (int v3 = (unint64_t *)result) != 0))
    {
      unsigned int v4 = v3 + 6;
      while (!__ldaxr(v4))
      {
      }

      __clrex();
    }
  }

  return result;
}

uint64_t _CFURLCreateCurrentDirectoryURL(int a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (!_CFGetCurrentDirectory(__s, 1026)) {
    return 0LL;
  }
  int v2 = strlen(__s);
  return _CFURLCreateWithFileSystemRepresentation(a1, __s, v2, 1, 0LL);
}

CFURLRef CFURLCreateFromFileSystemRepresentation( CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)_CFURLCreateWithFileSystemRepresentation(allocator, (char *)buffer, bufLen, isDirectory, 0LL);
}

CFURLRef CFURLCreateWithFileSystemPath( CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)_CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory, 0LL);
}

CFTypeRef _CFURLCreateWithFileSystemPath( const __CFAllocator *a1, CFStringRef theString, uint64_t a3, BOOL a4, const void *a5)
{
  CFIndex v8 = theString;
  uint64_t v81 = *MEMORY[0x1895F89C0];
  BOOL v79 = 0;
  CFIndex Length = CFStringGetLength(theString);
  if (Length < 1)
  {
    if (a5) {
      return CFRetain(a5);
    }
    return 0LL;
  }

  CFIndex v11 = Length;
  if (a3 != 2)
  {
    if (a3 != 1)
    {
      if (!a3)
      {
        BOOL v12 = CFStringGetCharacterAtIndex(v8, 0LL) == 47;
        if (v8) {
          BOOL v13 = CFStringHasPrefix(v8, @"/.file/id=") != 0;
        }
        else {
          BOOL v13 = 0;
        }
        CFRange v52 = POSIXPathToURLPath(v8, a4, v12, &v79);
LABEL_76:
        uint64_t v53 = 0LL;
        if (!v52) {
          return 0LL;
        }
LABEL_98:
        if (v12)
        {
          int v59 = 0;
          int v60 = 0;
          a5 = 0LL;
          if (a4) {
            goto LABEL_108;
          }
          goto LABEL_106;
        }

LABEL_102:
        if (a5)
        {
          int v60 = 0;
          int v59 = 1;
          if (a4) {
            goto LABEL_108;
          }
        }

        else
        {
          a5 = (const void *)_CFURLCreateCurrentDirectoryURL((int)a1);
          int v59 = 1;
          int v60 = 1;
          if (a4)
          {
LABEL_108:
            if (v59) {
              uint64_t v62 = 56LL;
            }
            else {
              uint64_t v62 = 72LL;
            }
            uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x1DuLL, v62, 0LL, v31, v32, v33, v34);
            uint64_t v61 = Instance;
            if (Instance)
            {
              *(_DWORD *)(Instance + 20) = 134217984;
              atomic_store((unint64_t)CFStringCreateCopy(a1, v52), (unint64_t *)(Instance + 24));
              if (a5) {
                CFURLRef v64 = CFURLCopyAbsoluteURL((CFURLRef)a5);
              }
              else {
                CFURLRef v64 = 0LL;
              }
              *(void *)(v61 + 32) = v64;
              if ((v59 & 1) != 0)
              {
                if (a4) {
                  int v65 = 84000;
                }
                else {
                  int v65 = 81952;
                }
                *(_DWORD *)(v61 + 16) = v65;
                uint64_t v66 = (const __CFString *)atomic_load((unint64_t *)(v61 + 24));
                CFIndex v67 = CFStringGetLength(v66);
                *(void *)(v61 + 56) = 0LL;
                *(void *)(v61 + 64) = v67;
              }

              else
              {
                int v68 = 84001;
                if (!a4) {
                  int v68 = 81953;
                }
                if (v13) {
                  int v69 = v68 | 0x2000;
                }
                else {
                  int v69 = (v79 << 15) | ((v53 == 0) << 12) | v68;
                }
                *(_DWORD *)(v61 + 16) = v69 | 0x60000000;
                *(_OWORD *)(v61 + 56) = xmmword_180CA51E0;
                CFIndex v70 = CFStringGetLength(v52);
                *(void *)(v61 + 72) = 7LL;
                *(void *)(v61 + 80) = v70 - 7;
              }
            }

            if (a5) {
              int v71 = v60;
            }
            else {
              int v71 = 0;
            }
            if (v71 == 1) {
              CFRelease(a5);
            }
            CFRelease(v52);
            return (CFTypeRef)v61;
          }
        }

unint64_t *_CFURLCreateWithFileSystemPathCachingResourcePropertiesForKeys( const __CFAllocator *a1, const __CFString *a2, const __CFArray *a3, CFErrorRef *a4)
{
  error[1] = *(CFErrorRef *)MEMORY[0x1895F89C0];
  error[0] = 0LL;
  CFIndex v8 = (unint64_t *)_CFURLCreateWithFileSystemPath(a1, a2, 0LL, 0, 0LL);
  if (!v8)
  {
LABEL_21:
    CFErrorRef v17 = error[0];
    if (a4)
    {
      if (!error[0]) {
        CFErrorRef v17 = CFErrorCreate(0LL, @"NSPOSIXErrorDomain", 12LL, 0LL);
      }
      uint64_t v9 = 0LL;
      *a4 = v17;
    }

    else
    {
      if (error[0]) {
        CFRelease(error[0]);
      }
      return 0LL;
    }

    return v9;
  }

  uint64_t v9 = v8;
  if (!a3 || (CFIndex Count = CFArrayGetCount(a3)) == 0)
  {
    uint64_t IsDirectoryKeyArray = _CopyIsDirectoryKeyArray();
    goto LABEL_7;
  }

  CFIndex v11 = Count;
  v23.CFIndex location = 0LL;
  v23.length = Count;
  if (CFArrayContainsValue(a3, v23, @"NSURLIsDirectoryKey"))
  {
    uint64_t IsDirectoryKeyArray = (uint64_t)CFRetain(a3);
LABEL_7:
    CFArrayRef Copy = (CFArrayRef)IsDirectoryKeyArray;
    goto LABEL_8;
  }

  CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(0LL, v11 + 1, a3);
  if (MutableCopy)
  {
    CFIndex v20 = MutableCopy;
    CFArrayAppendValue(MutableCopy, @"NSURLIsDirectoryKey");
    CFArrayRef Copy = CFArrayCreateCopy(0LL, v20);
    CFRelease(v20);
  }

  else
  {
    CFArrayRef Copy = 0LL;
  }

uint64_t _CFURLCacheResourcePropertiesForKeys(__objc2_class **a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme(a1, &v10))
  {
    __CFURLResourceInfoPtr(a1);
    _FSURLCacheResourcePropertiesForKeys();
  }

  else if (!v10)
  {
    CFLog( 4LL,  (uint64_t)@"_CFURLCacheResourcePropertiesForKeys failed because it was passed a URL which has no scheme",  v2,  v3,  v4,  v5,  v6,  v7,  v9);
  }

  return 1LL;
}

Boolean CFURLCopyResourcePropertyForKey( CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!_CFURLHasFileURLScheme((__objc2_class **)url, &v14))
  {
    if (!v14) {
      CFLog( 4LL,  (uint64_t)@"CFURLCopyResourcePropertyForKey failed because it was passed a URL which has no scheme",  v6,  v7,  v8,  v9,  v10,  v11,  v13);
    }
    goto LABEL_6;
  }

  __CFURLResourceInfoPtr((__objc2_class **)url);
  if (!_FSURLCopyResourcePropertyForKey()) {
LABEL_6:
  }
    *(void *)CFBooleanRef propertyValueTypeRefPtr = 0LL;
  return 1;
}

void _CFURLInitWithFileSystemPathRelativeToBase( unint64_t *a1, const __CFString *a2, uint64_t a3, BOOL a4, const void *a5)
{
  uint64_t v6 = (unint64_t *)_CFURLCreateWithFileSystemPath( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  a2,  a3,  a4,  a5);
  if (v6)
  {
    uint64_t v7 = v6;
    a1[2] = v6[2];
    unint64_t v8 = atomic_load(v6 + 3);
    atomic_store(v8, a1 + 3);
    a1[5] = v6[5];
    unint64_t v9 = atomic_load(v6 + 6);
    atomic_store(v9, a1 + 6);
    a1[4] = v6[4];
    LODWORD(v8) = *((_DWORD *)v6 + 4);
    unint64_t v10 = *(void *)&vshl_u16( (uint16x4_t)(*(void *)&vdup_n_s16(v8) & 0xFF00FF00FF00FFLL),  (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01LL;
    LOWORD(v10) = vaddv_s16((int16x4_t)v10);
    int v11 = v10
        + (v8 & 1)
        + ((v8 >> 5) & 1)
        + ((v8 >> 6) & 1)
    if ((_BYTE)v11) {
      memcpy(a1 + 7, v6 + 7, 16LL * v11);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
  }

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v4 = CFGetAllocator(anURL);
  if (pathStyle) {
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
  }
  if (!CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
  {
    if (!*((void *)anURL + 4)) {
      goto LABEL_6;
    }
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
  }

  if (-[__CFURL baseURL](anURL, "baseURL")) {
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
  }
LABEL_6:
  uint64_t v5 = CFURLGetString(anURL);
  unint64_t Length = CFStringGetLength(v5);
  if (Length <= 1) {
    unint64_t Length = 1LL;
  }
  int64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  uint64_t v8 = MaximumSizeForEncoding;
  unint64_t v9 = MaximumSizeForEncoding >= 1025 ? (char *)malloc(MaximumSizeForEncoding) : v14;
  unint64_t v10 = (const __CFString *)atomic_load((unint64_t *)anURL + 3);
  if (CanonicalFileURLStringToFileSystemRepresentation(v10, v9, v8))
  {
    size_t v11 = strlen(v9);
    BOOL v12 = CFStringCreateWithBytes(v4, (const UInt8 *)v9, v11, 0x8000100u, 0);
  }

  else
  {
    BOOL v12 = 0LL;
  }

  if (v9 != v14) {
    free(v9);
  }
  if (!v12) {
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
  }
  return v12;
}

uint64_t CanonicalFileURLStringToFileSystemRepresentation(const __CFString *a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a2 && a3)
  {
    uint64_t v5 = a2;
    CFIndex Length = CFStringGetLength(a1);
    CFIndex v8 = Length - 7;
    if (Length == 7)
    {
      *uint64_t v5 = 0;
      return 1LL;
    }

    else
    {
      if (v8 >= 1025)
      {
        unint64_t v9 = (UInt8 *)malloc(3 * v8);
        if (!v9) {
          return 0LL;
        }
      }

      else
      {
        unint64_t v9 = buffer;
      }

      v24.CFIndex location = 7LL;
      v24.length = v8;
      if (CFStringGetBytes(a1, v24, 0x8000100u, 0, 0, v9, 3 * v8, &usedBufLen))
      {
        CFIndex v10 = usedBufLen;
        if (usedBufLen >= 1)
        {
          BOOL v11 = 0;
          CFIndex v12 = 0LL;
          uint64_t v13 = 0LL;
          char v14 = v9;
          while (1)
          {
            if (a3 == v13)
            {
              uint64_t v3 = 0LL;
              goto LABEL_28;
            }

            LODWORD(v15) = *v14;
            if ((_DWORD)v15 != 37) {
              break;
            }
            v12 += 2LL;
            if (v12 < v10)
            {
              char v16 = CanonicalFileURLStringToFileSystemRepresentation_hexvalues[v14[1]];
              v5[v13] = 16 * v16;
              uint64_t v15 = v14[2];
              v14 += 3;
              LOBYTE(v15) = CanonicalFileURLStringToFileSystemRepresentation_hexvalues[v15] + 16 * v16;
LABEL_16:
              v5[v13] = v15;
              BOOL v11 = v15 == 47;
            }

            ++v13;
            if (++v12 >= v10)
            {
              LODWORD(v17) = v13 != 1;
              uint64_t v18 = &v5[v13];
              goto LABEL_21;
            }
          }

          ++v14;
          goto LABEL_16;
        }

        LODWORD(v17) = 0;
        BOOL v11 = 0;
        uint64_t v18 = v5;
LABEL_21:
        int v19 = &v5[a3];
        if (v11) {
          uint64_t v17 = v17;
        }
        else {
          uint64_t v17 = 0LL;
        }
        uint64_t v5 = &v18[-v17];
        uint64_t v3 = 1LL;
        if (&v18[-v17] < v19) {
LABEL_28:
        }
          *uint64_t v5 = 0;
      }

      else
      {
        uint64_t v3 = 0LL;
      }

      if (v9 != buffer) {
        free(v9);
      }
    }
  }

  return v3;
}

CFStringRef CFURLCreateStringWithFileSystemPath( const __CFAllocator *a1, __objc2_class **a2, uint64_t a3, int a4)
{
  uint64_t v5 = (uint64_t)a2;
  if (a4)
  {
    if (CF_IS_OBJC(0x1DuLL, a2))
    {
      uint64_t v7 = (const __CFURL *)[(id)v5 baseURL];
      if (!v7) {
        goto LABEL_6;
      }
LABEL_8:
      CFIndex v8 = (const __CFString *)CFURLCreateStringWithFileSystemPath(a1, v7, a3, 0LL);
      int v9 = 0;
      goto LABEL_9;
    }

    uint64_t v7 = *(const __CFURL **)(v5 + 32);
    if (v7) {
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

CFStringRef FileReferenceURLPathToFullURLPath(const __CFString *a1, const __CFAllocator *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!CFStringGetCString(a1, buffer, 2048LL, 0x8000100u)) {
    return 0LL;
  }
  if (*(void *)buffer != 0x692F656C69662E2FLL || v19 != 15716) {
    return 0LL;
  }
  strtoll(v20, &__endptr, 10);
  if (*__endptr != 46) {
    return 0LL;
  }
  strtoll(__endptr + 1, &__endptr, 10);
  uint64_t v4 = *__endptr == 47 ? __endptr + 1 : __endptr;
  uint64_t v5 = (const __CFString *)_FSCreatePathForFileID();
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  unint64_t Length = CFStringGetLength(v5);
  if (Length <= 1) {
    unint64_t Length = 1LL;
  }
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex v9 = MaximumSizeForEncoding + 1;
  if (MaximumSizeForEncoding >= 1024) {
    int v10 = (char *)malloc(MaximumSizeForEncoding + 1);
  }
  else {
    int v10 = v21;
  }
  if (CFStringGetCString(v6, v10, v9, 0x8000100u))
  {
    size_t v13 = strlen(v10);
    CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes( 0LL,  v10,  v13,  0,  0,  0,  0LL);
  }

  else
  {
    CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = 0LL;
  }

  if (v10 != v21) {
    free(v10);
  }
  CFRelease(v6);
  if (*v4)
  {
    CFStringRef v14 = CFStringCreateWithCString(a2, v4, 0x8000100u);
    if (v14)
    {
      CFStringRef v15 = v14;
      CFStringRef v16 = CFStringCreateWithFormat( a2,  0LL,  @"%@/%@",  StringFromFileSystemRepresentationByAddingPercentEscapes,  v14);
      CFRelease(v15);
    }

    else
    {
      CFStringRef v16 = 0LL;
    }

    CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
    return v16;
  }

  return StringFromFileSystemRepresentationByAddingPercentEscapes;
}

CFStringRef URLPathToPOSIXPath( CFStringRef origString, CFAllocatorRef allocator, CFStringEncoding encoding, int a4)
{
  if (a4) {
    uint64_t v6 = @"/";
  }
  else {
    uint64_t v6 = &stru_1899EF170;
  }
  uint64_t v7 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(allocator, origString, v6, encoding);
  CFIndex v8 = v7;
  if (!v7) {
    return v8;
  }
  CFIndex Length = CFStringGetLength(v7);
  if (Length < 2) {
    return v8;
  }
  CFIndex v10 = Length - 1;
  if (CFStringGetCharacterAtIndex(v8, Length - 1) != 47) {
    return v8;
  }
  v13.CFIndex location = 0LL;
  v13.length = v10;
  CFStringRef v11 = CFStringCreateWithSubstring(allocator, v8, v13);
  CFRelease(v8);
  return v11;
}

BOOL _CFURLIsFileURL(__objc2_class **a1)
{
  return _CFURLHasFileURLScheme(a1, 0LL);
}

Boolean CFURLGetFileSystemRepresentation( CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  int v6 = resolveAgainstBase;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  CFAllocatorRef v8 = CFGetAllocator(url);
  if (!url) {
    return 0;
  }
  CFIndex v9 = v8;
  if (v6)
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
    {
      if (-[__CFURL baseURL](url, "baseURL")) {
        goto LABEL_9;
      }
    }

    else if (*((void *)url + 4))
    {
      goto LABEL_9;
    }
  }

  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url) || (*((_BYTE *)url + 17) & 0x10) == 0)
  {
LABEL_9:
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
    {
      if (-[__CFURL baseURL](url, "baseURL")) {
        goto LABEL_26;
      }
    }

    else if (*((void *)url + 4))
    {
      goto LABEL_26;
    }

    if (CFURLIsFileReferenceURL(url))
    {
      CFIndex v10 = CFURLCopyPath(url);
      if (v10)
      {
        CFStringRef v11 = v10;
        if (!CFStringGetCString(v10, buffera, 2048LL, 0x8000100u)) {
          goto LABEL_25;
        }
        if (*(void *)buffera != 0x692F656C69662E2FLL || v22 != 15716) {
          goto LABEL_25;
        }
        strtoll(v23, &v20, 10);
        if (*v20 != 46) {
          goto LABEL_25;
        }
        strtoll(v20 + 1, &v20, 10);
        CFRange v13 = v20;
        if (*v20 == 47) {
          CFRange v13 = v20 + 1;
        }
        if (!*v13)
        {
          int v19 = _FSGetFileSystemRepresentationForFileID();
          CFRelease(v11);
          if (v19) {
            return 1;
          }
        }

        else
        {
LABEL_25:
          CFRelease(v11);
        }
      }
    }

CFTypeRef _CFURLCreateWithFileSystemRepresentation( const __CFAllocator *a1, char *__s1, uint64_t a3, int a4, const __CFURL *cf)
{
  uint64_t v5 = cf;
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    if (cf) {
      return CFRetain(cf);
    }
    return 0LL;
  }

  int v10 = *__s1;
  if (v10 == 47)
  {
    BOOL v11 = (unint64_t)a3 >= 0xA && strncmp(__s1, "/.file/id=", 0xAuLL) == 0;
    CFStringRef v21 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(a1, __s1, a3, a4, 1, 0, &v31);
    if (v21)
    {
      int v19 = v21;
      BOOL v13 = 0;
      uint64_t v5 = 0LL;
      uint64_t v20 = 72LL;
LABEL_15:
      uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x1DuLL, v20, 0LL, v15, v16, v17, v18);
      uint64_t v23 = Instance;
      if (Instance)
      {
        *(_DWORD *)(Instance + 20) = 134217984;
        atomic_store((unint64_t)CFStringCreateCopy(a1, v19), (unint64_t *)(Instance + 24));
        if (v5) {
          CFURLRef v24 = CFURLCopyAbsoluteURL(v5);
        }
        else {
          CFURLRef v24 = 0LL;
        }
        *(void *)(v23 + 32) = v24;
        if (v10 == 47)
        {
          if (v31) {
            int v25 = 4096;
          }
          else {
            int v25 = 36864;
          }
          if (v11) {
            int v25 = 0x2000;
          }
          if (a4) {
            int v26 = 1610696737;
          }
          else {
            int v26 = 1610694689;
          }
          *(_DWORD *)(v23 + 16) = v26 | v25;
          *(_OWORD *)(v23 + 56) = xmmword_180CA51E0;
          CFIndex Length = CFStringGetLength(v19);
          *(void *)(v23 + 72) = 7LL;
          *(void *)(v23 + 80) = Length - 7;
        }

        else
        {
          if (a4) {
            int v28 = 84000;
          }
          else {
            int v28 = 81952;
          }
          *(_DWORD *)(v23 + 16) = v28 | ((v31 == 0) << 15);
          char v29 = (const __CFString *)atomic_load((unint64_t *)(v23 + 24));
          CFIndex v30 = CFStringGetLength(v29);
          *(void *)(v23 + 56) = 0LL;
          *(void *)(v23 + 64) = v30;
        }
      }

      CFRelease(v19);
      if (!v13) {
        return (CFTypeRef)v23;
      }
      goto LABEL_37;
    }

    return 0LL;
  }

  BOOL v13 = cf == 0LL;
  if (!cf) {
    uint64_t v5 = (const __CFURL *)_CFURLCreateCurrentDirectoryURL((int)a1);
  }
  CFStringRef v14 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(a1, __s1, a3, a4, v10 == 47, 0, &v31);
  if (v14)
  {
    int v19 = v14;
    BOOL v11 = 0;
    uint64_t v20 = 56LL;
    goto LABEL_15;
  }

  uint64_t v23 = 0LL;
  if (v13)
  {
LABEL_37:
    if (v5) {
      CFRelease(v5);
    }
  }

  return (CFTypeRef)v23;
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  CFURLRef v1 = url;
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
  {
    uint64_t v2 = CFGetAllocator(v1);
    uint64_t v3 = CFURLCreateStringWithFileSystemPath(v2, (__objc2_class **)v1, 0LL, 0);
    uint64_t v4 = v3;
    if (v3)
    {
      CFIndex Length = CFStringGetLength(v3);
      if (Length)
      {
        CFIndex v6 = Length;
        CFIndex v7 = Length - 1;
        if (CFStringGetCharacterAtIndex(v4, Length - 1) != 47) {
          CFIndex v7 = v6;
        }
        if (v7)
        {
          v30.CFIndex location = 0LL;
          v30.length = v7;
          if (CFStringFindWithOptions(v4, @"/", v30, 4uLL, &result)) {
            CFIndex v8 = result.location + 1;
          }
          else {
            CFIndex v8 = 0LL;
          }
          CFIndex v9 = v7 - v8;
          if (v8) {
            BOOL v10 = 0;
          }
          else {
            BOOL v10 = v9 == v6;
          }
          if (!v10)
          {
            BOOL v11 = CFGetAllocator(v1);
            v31.CFIndex location = v8;
            v31.length = v9;
            CFIndex v12 = CFStringCreateWithSubstring(v11, v4, v31);
            CFRelease(v4);
            return v12;
          }
        }
      }
    }

    return v4;
  }

  int v13 = CFURLIsFileReferenceURL(v1);
  if (v13)
  {
    CFStringRef v14 = CFGetAllocator(v1);
    CFURLRef v1 = CFURLCreateFilePathURL(v14, v1, 0LL);
    if (!v1) {
      return 0LL;
    }
  }

  CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)v1);
  if (PathComponent == -1 || (CFIndex v17 = v16) == 0)
  {
    if (v13) {
      CFRelease(v1);
    }
    return (CFStringRef)CFRetain(&stru_1899EF170);
  }

  else
  {
    CFIndex v18 = PathComponent;
    if (v16 != 1
      || (int v19 = (const __CFString *)atomic_load((unint64_t *)v1 + 3), CFStringGetCharacterAtIndex(v19, v18) != 47))
    {
      CFStringRef v21 = CFGetAllocator(v1);
      __int16 v22 = (const __CFString *)atomic_load((unint64_t *)v1 + 3);
      v32.CFIndex location = v18;
      v32.length = v17;
      uint64_t v4 = CFStringCreateWithSubstring(v21, v22, v32);
      if ((*((_BYTE *)v1 + 17) & 0x80) == 0)
      {
        int v23 = *((_DWORD *)v1 + 5);
        if (_CFURLHasFileURLScheme((__objc2_class **)v1, 0LL)) {
          CFURLRef v24 = @"/";
        }
        else {
          CFURLRef v24 = &stru_1899EF170;
        }
        int v25 = CFGetAllocator(v1);
        if (v23 == 134217984) {
          CFStringRef v26 = CFURLCreateStringByReplacingPercentEscapes(v25, v4, v24);
        }
        else {
          CFStringRef v26 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v25, v4, v24, *((_DWORD *)v1 + 5));
        }
        unsigned int v27 = v26;
        CFRelease(v4);
        uint64_t v4 = v27;
      }

      if (v13) {
        CFRelease(v1);
      }
      return v4;
    }

    if (v13) {
      CFRelease(v1);
    }
    return (CFStringRef)CFRetain(@"/");
  }

CFIndex _rangeOfLastPathComponent(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if ((v1 & 0x20) == 0) {
    return -1LL;
  }
  unsigned int v3 = 0;
  unsigned int v4 = 32;
  do
  {
    char v5 = v4;
    v4 >>= 1;
    v3 += v1 & 1;
    v1 >>= 1;
  }

  while ((v5 & 2) == 0);
  CFIndex v6 = (CFIndex *)(a1 + 56 + 16LL * v3);
  CFIndex v2 = *v6;
  CFIndex v7 = v6[1];
  if (*v6 != -1 && v7 != 0)
  {
    CFIndex v9 = (unint64_t *)(a1 + 24);
    BOOL v10 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    CFIndex v11 = v7 - 1;
    if (CFStringGetCharacterAtIndex(v10, v7 - 1 + v2) != 47 || (--v7, v11))
    {
      CFIndex v12 = (const __CFString *)atomic_load(v9);
      v16.CFIndex location = v2;
      v16.length = v7;
      if (CFStringFindWithOptions(v12, @"/", v16, 4uLL, &result)) {
        return result.location + 1;
      }
    }
  }

  return v2;
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  CFIndex PathComponent = CFURLCopyLastPathComponent(url);
  if (!PathComponent) {
    return 0LL;
  }
  unsigned int v3 = PathComponent;
  _CFGetPathExtensionRangesFromPathComponent(PathComponent, &v7.location, 0LL);
  if (v7.location == -1)
  {
    char v5 = 0LL;
  }

  else
  {
    unsigned int v4 = CFGetAllocator(url);
    char v5 = CFStringCreateWithSubstring(v4, v3, v7);
  }

  CFRelease(v3);
  return v5;
}

CFURLRef CFURLCreateCopyAppendingPathComponent( CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)__CFURLCreateCopyAppendingPathComponent( allocator,  (__objc2_class **)url,  pathComponent,  isDirectory,  @";?");
}

unint64_t *__CFURLCreateCopyAppendingPathComponent( const __CFAllocator *a1, __objc2_class **a2, const __CFString *a3, int a4, const __CFString *a5)
{
  uint64_t v8 = (uint64_t)a2;
  if (CFURLIsFileReferenceURL((CFURLRef)v8))
  {
    CFURLRef v10 = CFURLCreateFilePathURL(a1, (CFURLRef)v8, 0LL);
    BOOL v11 = v10 != 0LL;
    if (v10) {
      uint64_t v8 = (uint64_t)v10;
    }
  }

  else
  {
    BOOL v11 = 0;
  }

  if ((*(_BYTE *)(v8 + 16) & 0x20) != 0)
  {
    CFIndex v12 = (const __CFString *)atomic_load((unint64_t *)(v8 + 24));
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(a1, 0LL, v12);
    if (MutableCopy)
    {
      CFStringRef v14 = MutableCopy;
      if (_CFURLHasFileURLScheme((__objc2_class **)v8, 0LL)) {
        CFStringRef v15 = POSIXPathToURLPath(a3, 0, 0, 0LL);
      }
      else {
        CFStringRef v15 = CFURLCreateStringByAddingPercentEscapes(a1, a3, 0LL, a5, *(_DWORD *)(v8 + 20));
      }
      CFIndex v18 = v15;
      if (!v15)
      {
        CFRange v16 = 0LL;
        goto LABEL_30;
      }

      unsigned int v19 = *(_DWORD *)(v8 + 16);
      if ((v19 & 0x20) != 0)
      {
        unsigned int v22 = 0;
        unsigned int v23 = 32;
        do
        {
          char v24 = v23;
          v23 >>= 1;
          v22 += v19 & 1;
          v19 >>= 1;
        }

        while ((v24 & 2) == 0);
        int v25 = (uint64_t *)(v8 + 56 + 16LL * v22);
        uint64_t v21 = *v25;
        uint64_t v20 = v25[1];
        if (v20)
        {
          CFStringRef v26 = (const __CFString *)atomic_load((unint64_t *)(v8 + 24));
          if (CFStringGetCharacterAtIndex(v26, v21 + v20 - 1) == 47)
          {
LABEL_27:
            CFIndex v27 = v20 + v21;
            CFStringInsert(v14, v27, v18);
            if (a4)
            {
              CFIndex Length = CFStringGetLength(v18);
              CFStringInsert(v14, Length + v27, @"/");
            }

            CFRelease(v18);
            CFRange v16 = _CFURLCreateWithURLString(a1, v14, 0, *(const __CFURL **)(v8 + 32));
LABEL_30:
            CFRelease(v14);
            if (!v11) {
              return v16;
            }
            goto LABEL_13;
          }
        }
      }

      else
      {
        uint64_t v20 = 0LL;
        uint64_t v21 = -1LL;
      }

      if (!CFStringGetLength(v18) || CFStringGetCharacterAtIndex(v18, 0LL) != 47) {
        CFStringInsert(v14, v21 + v20++, @"/");
      }
      goto LABEL_27;
    }
  }

  CFRange v16 = 0LL;
  if (v11) {
LABEL_13:
  }
    CFRelease((CFTypeRef)v8);
  return v16;
}

unint64_t *_CFURLCreateCopyAppendingPathComponent(__objc2_class **a1, const __CFString *a2, int a3)
{
  return __CFURLCreateCopyAppendingPathComponent(0LL, a1, a2, a3, @";?/");
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  CFURLRef v2 = url;
  int v4 = CFURLIsFileReferenceURL(v2);
  if (!v4)
  {
    unsigned int v6 = *((_DWORD *)v2 + 4);
    if ((v6 & 0x20) != 0) {
      goto LABEL_9;
    }
    return 0LL;
  }

  CFURLRef v5 = CFURLCreateFilePathURL(allocator, v2, 0LL);
  if (!v5) {
    return 0LL;
  }
  CFURLRef v2 = v5;
  unsigned int v6 = *((_DWORD *)v5 + 4);
  if ((v6 & 0x20) == 0)
  {
    CFRange v7 = 0LL;
LABEL_37:
    CFRelease(v2);
    return (CFURLRef)v7;
  }

CFURLRef CFURLCreateCopyAppendingPathExtension(CFAllocatorRef allocator, CFURLRef url, CFStringRef extension)
{
  if (!CFStringGetLength(extension)) {
    return (CFURLRef)CFRetain(url);
  }
  int v6 = CFURLIsFileReferenceURL(url);
  if (v6)
  {
    CFRange v7 = CFURLCreateFilePathURL(allocator, url, 0LL);
    if (!v7) {
      return 0LL;
    }
    url = v7;
    CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)v7);
    if (PathComponent == -1)
    {
      CFRelease(url);
      return 0LL;
    }
  }

  else
  {
    CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)url);
    if (PathComponent == -1) {
      return 0LL;
    }
  }

  CFIndex v11 = PathComponent;
  uint64_t v12 = v9;
  CFIndex v13 = (const __CFString *)atomic_load((unint64_t *)url + 3);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(allocator, 0LL, v13);
  if (MutableCopy)
  {
    uint64_t v15 = MutableCopy;
    CFIndex v16 = v11 + v12;
    CFStringInsert(MutableCopy, v16, @".");
    if (_CFURLHasFileURLScheme((__objc2_class **)url, 0LL)) {
      CFIndex v17 = POSIXPathToURLPath(extension, 0, 0, 0LL);
    }
    else {
      CFIndex v17 = CFURLCreateStringByAddingPercentEscapes(allocator, extension, 0LL, @";?/", *((_DWORD *)url + 5));
    }
    unsigned int v19 = v17;
    if (v17)
    {
      CFStringInsert(v15, v16 + 1, v17);
      CFRelease(v19);
      CFIndex v18 = _CFURLCreateWithURLString(allocator, v15, 0, *((const __CFURL **)url + 4));
    }

    else
    {
      CFIndex v18 = 0LL;
    }

    CFRelease(v15);
    if (!v6) {
      return (CFURLRef)v18;
    }
  }

  else
  {
    CFIndex v18 = 0LL;
    if (!v6) {
      return (CFURLRef)v18;
    }
  }

  CFRelease(url);
  return (CFURLRef)v18;
}

CFStringRef POSIXPathToURLPath(const __CFString *a1, int a2, int a3, BOOL *a4)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  char v14 = 0;
  if (CFStringGetLength(a1))
  {
    MaximumSizeOfBoolean FileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(a1);
    CFIndex v9 = MaximumSizeOfFileSystemRepresentation;
    if (MaximumSizeOfFileSystemRepresentation >= 1025) {
      char v10 = (char *)malloc(MaximumSizeOfFileSystemRepresentation);
    }
    else {
      char v10 = buffer;
    }
  }

  else
  {
    char v10 = buffer;
    CFIndex v9 = 1LL;
  }

  if (CFStringGetFileSystemRepresentation(a1, v10, v9))
  {
    size_t v11 = strlen(v10);
    CFStringRef v12 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0LL, v10, v11, a2, a3, 0, &v14);
  }

  else
  {
    CFStringRef v12 = 0LL;
  }

  if (v10 != buffer) {
    free(v10);
  }
  if (a4) {
    *a4 = v14 == 0;
  }
  return v12;
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  CFURLRef v2 = url;
  v15[2] = *MEMORY[0x1895F89C0];
  int v4 = CFURLIsFileReferenceURL(v2);
  if (v4)
  {
    CFURLRef v2 = CFURLCreateFilePathURL(allocator, v2, 0LL);
    if (!v2) {
      return 0LL;
    }
  }

  CFIndex PathComponent = _rangeOfLastPathComponent((uint64_t)v2);
  if (PathComponent == -1
    || (CFIndex v7 = PathComponent,
        v17.length = v6,
        unsigned int v8 = (const __CFString *)atomic_load((unint64_t *)v2 + 3),
        v17.CFIndex location = PathComponent,
        (CFIndex v9 = CFStringCreateWithSubstring(allocator, v8, v17)) == 0LL))
  {
    CFIndex v13 = 0LL;
    if (!v4) {
      return v13;
    }
    goto LABEL_17;
  }

  char v10 = v9;
  _CFGetPathExtensionRangesFromPathComponent(v9, v15, 0LL);
  if (v15[0] == -1)
  {
    CFIndex v13 = (const __CFURL *)CFRetain(v2);
  }

  else
  {
    size_t v11 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(allocator, 0LL, v11);
    v16.CFIndex location = v7 + v15[0] - 1;
    v16.length = v15[1] + 1;
    CFStringDelete(MutableCopy, v16);
    if (MutableCopy) {
      CFIndex v13 = (const __CFURL *)_CFURLCreateWithURLString(allocator, MutableCopy, 0, *((const __CFURL **)v2 + 4));
    }
    else {
      CFIndex v13 = 0LL;
    }
    CFRelease(MutableCopy);
  }

  CFRelease(v10);
  if (v4) {
LABEL_17:
  }
    CFRelease(v2);
  return v13;
}

CFURLRef CFURLCreateFromFSRef(CFAllocatorRef allocator, const FSRef *fsRef)
{
  return 0LL;
}

Boolean CFURLGetFSRef(CFURLRef url, FSRef *fsRef)
{
  return 0;
}

CFDictionaryRef _CFURLCopyPropertyListRepresentation(unint64_t *a1)
{
  keys[4] = *(void **)MEMORY[0x1895F89C0];
  CFURLRef v2 = CFGetAllocator(a1);
  else {
    unsigned int v3 = (unint64_t *)a1[4];
  }
  keys[0] = @"_CFURLStringType";
  keys[1] = @"_CFURLString";
  keys[2] = @"_CFURLBaseStringType";
  keys[3] = @"_CFURLBaseURLString";
  int valuePtr = 15;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
  {
    values[0] = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    int v4 = (void *)CFURLGetString((CFURLRef)a1);
  }

  else
  {
    values[0] = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    CFURLRef v5 = (const void *)atomic_load(a1 + 3);
    int v4 = (void *)CFRetain(v5);
  }

  values[1] = v4;
  if (v3)
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)v3))
    {
      int valuePtr = 15;
      CFNumberRef v16 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      CFIndex v6 = (void *)CFURLGetString((CFURLRef)v3);
    }

    else
    {
      int valuePtr = 15;
      CFNumberRef v16 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      unsigned int v8 = (const void *)atomic_load(v3 + 3);
      CFIndex v6 = (void *)CFRetain(v8);
    }

    CFRange v17 = v6;
    CFIndex v7 = 4LL;
  }

  else
  {
    CFIndex v7 = 2LL;
  }

  CFIndex v9 = CFGetAllocator(a1);
  CFDictionaryRef v10 = CFDictionaryCreate( v9,  (const void **)keys,  (const void **)values,  v7,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  unint64_t v11 = 0LL;
  uint64_t v12 = 8 * v7;
  do
  {
    CFRelease(values[v11 / 8]);
    v11 += 8LL;
  }

  while (v12 != v11);
  return v10;
}

CFNumberRef _CFURLCreateFromPropertyListRepresentation(const __CFAllocator *a1, CFTypeRef cf)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (CFGetTypeID(cf) != 18) {
    return 0LL;
  }
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_CFURLString");
  if (!Value) {
    return 0LL;
  }
  CFURLRef v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFStringGetTypeID()) {
    return 0LL;
  }
  CFIndex v7 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_CFURLStringType");
  unsigned int v8 = v7;
  if (!v7) {
    return v8;
  }
  CFTypeID v9 = CFGetTypeID(v7);
  if (v9 != CFNumberGetTypeID() || !CFNumberGetValue(v8, kCFNumberSInt32Type, &v26)) {
    return 0LL;
  }
  unsigned int v8 = 0LL;
  if (v26 > 0xF || ((1 << v26) & 0x8007) == 0) {
    return v8;
  }
  CFDictionaryRef v10 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_CFURLBaseURLString");
  if (v10)
  {
    unint64_t v11 = v10;
    CFTypeID v12 = CFGetTypeID(v10);
    if (v12 == CFStringGetTypeID())
    {
      CFIndex v13 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"_CFURLBaseStringType");
      if (v13)
      {
        char v14 = v13;
        CFTypeID v15 = CFGetTypeID(v13);
        if (v15 == CFNumberGetTypeID())
        {
          if (CFNumberGetValue(v14, kCFNumberSInt32Type, &valuePtr))
          {
            uint64_t v16 = valuePtr;
            if (valuePtr < 3)
            {
              CFIndex Length = CFStringGetLength(v11);
              BOOL v18 = CFStringGetCharacterAtIndex(v11, Length - 1) == 47;
              unsigned int v19 = (const __CFURL *)_CFURLCreateWithFileSystemPath(a1, v11, v16, v18, 0LL);
LABEL_24:
              uint64_t v20 = v19;
              goto LABEL_17;
            }

            if (valuePtr == 15)
            {
              unsigned int v19 = (const __CFURL *)_CFURLCreateWithURLString(a1, v11, 0, 0LL);
              goto LABEL_24;
            }
          }
        }
      }
    }

    return 0LL;
  }

  uint64_t v20 = 0LL;
LABEL_17:
  uint64_t v21 = (int)v26;
  if (v26 == 15)
  {
    unsigned int v22 = (const __CFNumber *)_CFURLCreateWithURLString(a1, v5, 0, v20);
  }

  else
  {
    CFIndex v23 = CFStringGetLength(v5);
    BOOL v24 = CFStringGetCharacterAtIndex(v5, v23 - 1) == 47;
    unsigned int v22 = (const __CFNumber *)_CFURLCreateWithFileSystemPath(a1, v5, v21, v24, v20);
  }

  unsigned int v8 = v22;
  if (v20) {
    CFRelease(v20);
  }
  return v8;
}

CFURLRef CFURLCreateFileReferenceURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (url)
  {
    CFURLRef v5 = (__objc2_class **)CFURLCopyAbsoluteURL(url);
    if (v5)
    {
      CFTypeID v6 = (CFStringEncoding *)v5;
      if (_CFURLHasFileURLScheme(v5, &v28))
      {
        CFIndex v13 = CFURLCopyPath((CFURLRef)v6);
        CFStringRef v14 = CFURLCopyNetLocation((CFURLRef)v6);
        CFStringRef v15 = CFURLCopyResourceSpecifier((CFURLRef)v6);
        if (v13)
        {
          if (CFStringHasPrefix(v13, @"/.file/id="))
          {
            v31.length = CFStringGetLength(v13) - 10;
            v31.CFIndex location = 10LL;
            if (!CFStringFindWithOptions(v13, @"/", v31, 0LL, &result)) {
              goto LABEL_10;
            }
            CFIndex location = result.location;
            if (location == CFStringGetLength(v13) - 1) {
              goto LABEL_10;
            }
          }

          CFRelease(v13);
        }

        CFIndex v13 = _CFURLCopyFileReferenceURLPath(v6, error);
        if (!v13)
        {
          unsigned int v22 = 0LL;
          if (!v14)
          {
LABEL_32:
            if (v15) {
              CFRelease(v15);
            }
            goto LABEL_34;
          }

CFStringRef _CFURLCopyFileReferenceURLPath(const void *a1, CFErrorRef *a2)
{
  valuePtr[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  int v4 = CFGetAllocator(a1);
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___CFURLCopyFileReferenceURLPath_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v4;
  if (_CFURLCopyFileReferenceURLPath_onceToken != -1) {
    dispatch_once(&_CFURLCopyFileReferenceURLPath_onceToken, block);
  }
  CFURLRef v5 = CFURLCopyResourcePropertiesForKeys((CFURLRef)a1, (CFArrayRef)_CFURLCopyFileReferenceURLPath_sPropertyKeys, a2);
  if (v5)
  {
    CFTypeID v6 = v5;
    CFRange v31 = v4;
    Value = (__objc2_class **)CFDictionaryGetValue(v5, @"NSURLIsDirectoryKey");
    if (Value == &__kCFBooleanTrue)
    {
      uint64_t v9 = (const __CFNumber *)CFDictionaryGetValue(v6, @"_NSURLVolumeIDKey");
      int v10 = 1;
    }

    else
    {
      uint64_t v8 = (__objc2_class **)CFDictionaryGetValue(v6, @"_NSURLVolumeIsHFSStandardKey");
      uint64_t v9 = (const __CFNumber *)CFDictionaryGetValue(v6, @"_NSURLVolumeIDKey");
      if (v8 == &__kCFBooleanTrue)
      {
        uint64_t v12 = (const __CFNumber *)CFDictionaryGetValue(v6, @"_NSURLParentDirectoryIDKey");
        CFStringRef v14 = CFDictionaryGetValue(v6, @"NSURLNameKey");
        int v10 = 0;
        int v15 = 0;
        char v13 = 1;
LABEL_12:
        if (v14) {
          int v15 = 1;
        }
        if (v9 && v12 && v15)
        {
          if (CFNumberGetValue(v9, kCFNumberLongLongType, valuePtr)
            && CFNumberGetValue(v12, kCFNumberLongLongType, &propertyValueTypeRefPtr))
          {
            uint64_t v16 = (uint64_t)propertyValueTypeRefPtr;
            if ((v13 & 1) != 0)
            {
              int v4 = v31;
              CFRange v17 = v31;
              uint64_t v18 = (uint64_t)propertyValueTypeRefPtr;
              uint64_t v16 = 0LL;
              uint64_t v19 = (uint64_t)v14;
              int v20 = 0;
            }

            else
            {
              int v4 = v31;
              CFRange v17 = v31;
              uint64_t v18 = 0LL;
              uint64_t v19 = 0LL;
              int v20 = v10;
            }

            CFStringRef FileReferencePath = createFileReferencePath(v17, (uint64_t)valuePtr[0], v18, v16, v19, v20);
            CFStringRef v11 = FileReferencePath;
            if (a2 && !FileReferencePath) {
              goto LABEL_47;
            }
            goto LABEL_54;
          }

          CFStringRef v11 = 0LL;
          if (a2) {
            *a2 = 0LL;
          }
LABEL_41:
          int v4 = v31;
          goto LABEL_54;
        }

        if (!CFURLCopyResourcePropertyForKey((CFURLRef)a1, @"NSURLParentDirectoryURLKey", valuePtr, a2))
        {
          CFStringRef v11 = 0LL;
          goto LABEL_41;
        }

        int v4 = v31;
        if (!valuePtr[0])
        {
          CFStringRef v11 = 0LL;
          if (a2) {
LABEL_47:
          }
            *a2 = 0LL;
LABEL_54:
          CFRelease(v6);
          if (!a2) {
            return v11;
          }
          goto LABEL_55;
        }

        uint64_t v21 = (const __CFString *)_CFURLCopyFileReferenceURLPath(valuePtr[0], a2);
        if (!v21)
        {
          CFStringRef v11 = 0LL;
LABEL_53:
          CFRelease(valuePtr[0]);
          goto LABEL_54;
        }

        unsigned int v22 = v21;
        CFIndex Length = CFStringGetLength(v21);
        CFIndex v24 = Length - 1;
        if (Length < 1)
        {
          if (a2)
          {
            CFStringRef v11 = 0LL;
            *a2 = 0LL;
LABEL_52:
            CFRelease(v22);
            goto LABEL_53;
          }
        }

        else if (CFURLCopyResourcePropertyForKey((CFURLRef)a1, @"NSURLNameKey", &propertyValueTypeRefPtr, a2))
        {
          int CharacterAtIndex = CFStringGetCharacterAtIndex(v22, v24);
          unsigned int v26 = @"%@/%@";
          if (Value == &__kCFBooleanTrue) {
            unsigned int v26 = @"%@/%@/";
          }
          uint64_t v27 = @"%@%@";
          if (Value == &__kCFBooleanTrue) {
            uint64_t v27 = @"%@%@/";
          }
          if (CharacterAtIndex == 47) {
            CFStringRef v28 = CFStringCreateWithFormat(v31, 0LL, v27, v22, propertyValueTypeRefPtr);
          }
          else {
            CFStringRef v28 = CFStringCreateWithFormat(v31, 0LL, v26, v22, propertyValueTypeRefPtr);
          }
          CFStringRef v11 = v28;
          if (a2 && !v28) {
            *a2 = 0LL;
          }
          if (propertyValueTypeRefPtr) {
            CFRelease(propertyValueTypeRefPtr);
          }
          goto LABEL_52;
        }

        CFStringRef v11 = 0LL;
        goto LABEL_52;
      }

      int v10 = 0;
    }

    uint64_t v12 = (const __CFNumber *)CFDictionaryGetValue(v6, @"_NSURLFileIDKey");
    char v13 = 0;
    CFStringRef v14 = 0LL;
    int v15 = 1;
    goto LABEL_12;
  }

  CFStringRef v11 = 0LL;
  if (!a2) {
    return v11;
  }
LABEL_55:
  if (!v11 && !*a2) {
    *a2 = CFErrorCreate(v4, @"NSCocoaErrorDomain", 256LL, 0LL);
  }
  return v11;
}

CFDictionaryRef CFURLCopyResourcePropertiesForKeys(CFURLRef url, CFArrayRef keys, CFErrorRef *error)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme((__objc2_class **)url, &v13))
  {
    __CFURLResourceInfoPtr((__objc2_class **)url);
    CFDictionaryRef result = (CFDictionaryRef)_FSURLCopyResourcePropertiesForKeys();
    if (result) {
      return result;
    }
  }

  else if (!v13)
  {
    CFLog( 4LL,  (uint64_t)@"CFURLCopyResourcePropertiesForKeys failed because it was passed a URL which has no scheme",  v4,  v5,  v6,  v7,  v8,  v9,  v12);
  }

  CFStringRef v11 = CFGetAllocator(url);
  return CFDictionaryCreate(v11, 0LL, 0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

Boolean CFURLSetResourcePropertyForKey( CFURLRef url, CFStringRef key, CFTypeRef propertyValue, CFErrorRef *error)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme((__objc2_class **)url, &v13))
  {
    __CFURLResourceInfoPtr((__objc2_class **)url);
    _FSURLSetResourcePropertyForKey();
  }

  else if (!v13)
  {
    CFLog( 4LL,  (uint64_t)@"CFURLSetResourcePropertyForKey failed because it was passed a URL which has no scheme",  v5,  v6,  v7,  v8,  v9,  v10,  v12);
  }

  return 1;
}

Boolean CFURLSetResourcePropertiesForKeys(CFURLRef url, CFDictionaryRef keyedPropertyValues, CFErrorRef *error)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme((__objc2_class **)url, &v12))
  {
    __CFURLResourceInfoPtr((__objc2_class **)url);
    _FSURLSetResourcePropertiesForKeys();
  }

  else if (!v12)
  {
    CFLog( 4LL,  (uint64_t)@"CFURLSetResourcePropertiesForKeys failed because it was passed a URL which has no scheme",  v4,  v5,  v6,  v7,  v8,  v9,  v11);
  }

  return 1;
}

uint64_t __CFURLBeginResourcePropertyCacheAccess(__objc2_class **a1)
{
  return _FSURLBeginResourcePropertyCacheAccess();
}

uint64_t __CFURLEndResourcePropertyCacheAccess(__objc2_class **a1)
{
  return _FSURLEndResourcePropertyCacheAccess();
}

void CFURLClearResourcePropertyCacheForKey(CFURLRef url, CFStringRef key)
{
}

void CFURLClearResourcePropertyCache(CFURLRef url)
{
}

void CFURLSetTemporaryResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue)
{
  v10[1] = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme((__objc2_class **)url, (_BYTE *)v10 + 7))
  {
    __CFURLResourceInfoPtr((__objc2_class **)url);
    _FSURLSetResourcePropertyForKey();
  }

  else if (!HIBYTE(v10[0]))
  {
    CFLog( 4LL,  (uint64_t)@"CFURLSetTemporaryResourcePropertyForKey failed because it was passed a URL which has no scheme",  v4,  v5,  v6,  v7,  v8,  v9,  v10[0]);
  }

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!_CFURLHasFileURLScheme((__objc2_class **)url, &v13))
  {
    if (v13)
    {
      if (error)
      {
LABEL_7:
        uint64_t v10 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 262LL, 0LL);
        LOBYTE(IsReachable) = 0;
        goto LABEL_8;
      }
    }

    else
    {
      CFLog( 4LL,  (uint64_t)@"CFURLResourceIsReachable failed because it was passed a URL which has no scheme",  v3,  v4,  v5,  v6,  v7,  v8,  v12);
      if (error) {
        goto LABEL_7;
      }
    }

    LOBYTE(IsReachable) = 0;
    return IsReachable;
  }

  int IsReachable = _FSURLResourceIsReachable();
  if (!IsReachable && error)
  {
    uint64_t v10 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 4LL, 0LL);
LABEL_8:
    *error = v10;
  }

  return IsReachable;
}

uint64_t _CFURLCreateDisplayPathComponentsArray(__objc2_class **a1, CFErrorRef *a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!_CFURLHasFileURLScheme(a1, &v13))
  {
    if (v13)
    {
      if (a2)
      {
LABEL_7:
        CFErrorRef v10 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 262LL, 0LL);
        uint64_t v9 = 0LL;
        goto LABEL_8;
      }
    }

    else
    {
      CFLog( 4LL,  (uint64_t)@"_CFURLCreateDisplayPathComponentsArray failed because it was passed a URL which has no scheme",  v3,  v4,  v5,  v6,  v7,  v8,  v12);
      if (a2) {
        goto LABEL_7;
      }
    }

    return 0LL;
  }

  uint64_t v9 = _FileURLCreateDisplayPathComponentsArray();
  if (!v9 && a2)
  {
    CFErrorRef v10 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 4LL, 0LL);
LABEL_8:
    *a2 = v10;
  }

  return v9;
}

uint64_t _CFURLGetResourcePropertyFlags(__objc2_class **a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme(a1, &v13))
  {
    __CFURLResourceInfoPtr(a1);
    uint64_t result = _FSURLGetResourcePropertyFlags();
    if ((_DWORD)result) {
      return result;
    }
  }

  else if (!v13)
  {
    CFLog( 4LL,  (uint64_t)@"_CFURLGetResourcePropertyFlags failed because it was passed a URL which has no scheme",  v5,  v6,  v7,  v8,  v9,  v10,  v12);
  }

  *a3 = 0LL;
  return 1LL;
}

uint64_t _CFURLCopyResourcePropertyValuesAndFlags( __objc2_class **a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme(a1, &v17))
  {
    __CFURLResourceInfoPtr(a1);
    uint64_t result = _FSURLCopyResourcePropertyValuesAndFlags();
    if ((_DWORD)result) {
      return result;
    }
  }

  else if (!v17)
  {
    CFLog( 4LL,  (uint64_t)@"_CFURLCopyResourcePropertyValuesAndFlags failed because it was passed a URL which has no scheme",  v9,  v10,  v11,  v12,  v13,  v14,  v16);
  }

  *a3 = 0LL;
  *a6 = 0LL;
  return 1LL;
}

uint64_t _CFURLGetVolumePropertyFlags(__objc2_class **a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme(a1, &v13))
  {
    __CFURLResourceInfoPtr(a1);
    uint64_t result = _FSURLGetVolumePropertyFlags();
    if ((_DWORD)result) {
      return result;
    }
  }

  else if (!v13)
  {
    CFLog( 4LL,  (uint64_t)@"_CFURLGetVolumePropertyFlags failed because it was passed a URL which has no scheme",  v5,  v6,  v7,  v8,  v9,  v10,  v12);
  }

  *a3 = 0LL;
  return 1LL;
}

uint64_t _CFURLCopyResourcePropertyForKeyFromCache(__objc2_class **a1, uint64_t a2, void *a3)
{
  v12[1] = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme(a1, (_BYTE *)v12 + 7))
  {
    __CFURLResourceInfoPtr(a1);
    return _FSURLCopyResourcePropertyForKeyFromCache();
  }

  else
  {
    if (!HIBYTE(v12[0])) {
      CFLog( 4LL,  (uint64_t)@"_CFURLCopyResourcePropertyForKeyFromCache failed because it was passed a URL which has no scheme",  v5,  v6,  v7,  v8,  v9,  v10,  v12[0]);
    }
    *a3 = 0LL;
    return 1LL;
  }

CFDictionaryRef _CFURLCopyResourcePropertiesForKeysFromCache(__objc2_class **a1)
{
  v10[1] = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme(a1, (_BYTE *)v10 + 7))
  {
    __CFURLResourceInfoPtr(a1);
    return (CFDictionaryRef)_FSURLCopyResourcePropertiesForKeysFromCache();
  }

  else
  {
    if (!HIBYTE(v10[0])) {
      CFLog( 4LL,  (uint64_t)@"_CFURLCopyResourcePropertiesForKeysFromCache failed because it was passed a URL which has no scheme",  v2,  v3,  v4,  v5,  v6,  v7,  v10[0]);
    }
    uint64_t v9 = CFGetAllocator(a1);
    return CFDictionaryCreate(v9, 0LL, 0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }

uint64_t _CFURLCacheResourcePropertyForKey(__objc2_class **a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (_CFURLHasFileURLScheme(a1, &v10))
  {
    __CFURLResourceInfoPtr(a1);
    _FSURLCacheResourcePropertyForKey();
  }

  else if (!v10)
  {
    CFLog( 4LL,  (uint64_t)@"_CFURLCacheResourcePropertyForKey failed because it was passed a URL which has no scheme",  v2,  v3,  v4,  v5,  v6,  v7,  v9);
  }

  return 1LL;
}

uint64_t _CFURLCacheSetAutoFlushingEnabled(__objc2_class **a1)
{
  return _FSURLSetCacheAutoFlushingEnabled();
}

uint64_t _CFURLCacheGetAutoFlushingEnabled(__objc2_class **a1)
{
  return _FSURLGetCacheAutoFlushingEnabled();
}

Boolean CFURLStartAccessingSecurityScopedResource(CFURLRef url)
{
  return MEMORY[0x186E02CEC](url) != 0;
}

uint64_t _CFURLNoteSecurityScopedResourceMoved(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (_CFURLNoteSecurityScopedResourceMoved_onceToken != -1) {
    dispatch_once(&_CFURLNoteSecurityScopedResourceMoved_onceToken, &__block_literal_global_22);
  }
  if (_CFURLNoteSecurityScopedResourceMoved__NS_FSURLNoteSecurityScopedResourceMovedWithFileIdentifier) {
    return _CFURLNoteSecurityScopedResourceMoved__NS_FSURLNoteSecurityScopedResourceMovedWithFileIdentifier( a1,  a2,  a3,  a4);
  }
  else {
    return _FSURLNoteSecurityScopedResourceMoved();
  }
}

CFStringRef CreateTruncatedURLString(const __CFAllocator *a1, CFStringRef theString)
{
  CFIndex Length = CFStringGetLength(theString);
  if (Length <= 128) {
    return CFStringCreateCopy(a1, theString);
  }
  CFIndex v6 = Length;
  v10.CFIndex location = 0LL;
  v10.length = 120LL;
  CFStringRef v7 = CFStringCreateWithSubstring(a1, theString, v10);
  v11.CFIndex location = v6 - 8;
  v11.length = 8LL;
  CFStringRef v8 = CFStringCreateWithSubstring(a1, theString, v11);
  CFStringRef v9 = CFStringCreateWithFormat(a1, 0LL, @"%@ ... %@", v7, v8);
  if (v7) {
    CFRelease(v7);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v9;
}

void constructBuffers(const __CFString *a1, UInt8 *a2, void *a3, void *a4, char *a5, char *a6)
{
  usedBufLen[1] = *MEMORY[0x1895F89C0];
  CStringPtr = CFStringGetCStringPtr(a1, 0x201u);
  *a3 = CStringPtr;
  if (CStringPtr)
  {
    *a4 = 0LL;
    *a5 = 1;
LABEL_5:
    *a6 = 0;
    return;
  }

  CharactersPtr = CFStringGetCharactersPtr(a1);
  *a4 = CharactersPtr;
  if (CharactersPtr)
  {
    *a5 = 0;
    goto LABEL_5;
  }

  CFIndex Length = CFStringGetLength(a1);
  v20.CFIndex location = 0LL;
  v20.length = Length;
  CFStringGetBytes(a1, v20, 0x201u, 0, 0, 0LL, 0x7FFFFFFFLL, usedBufLen);
  if (usedBufLen[0] == Length)
  {
    if (a2 && Length < 1025)
    {
      char v15 = 0;
    }

    else
    {
      a2 = (UInt8 *)malloc(Length);
      char v15 = 1;
    }

    *a6 = v15;
    v21.CFIndex location = 0LL;
    v21.length = Length;
    CFStringGetBytes(a1, v21, 0x201u, 0, 0, a2, Length, 0LL);
    *a3 = a2;
    char v18 = 1;
  }

  else
  {
    size_t v16 = 2 * Length;
    if (a2 && v16 < 0x401)
    {
      char v17 = 0;
    }

    else
    {
      a2 = (UInt8 *)malloc(v16);
      char v17 = 1;
    }

    *a6 = v17;
    v22.CFIndex location = 0LL;
    v22.length = Length;
    CFStringGetCharacters(a1, v22, (UniChar *)a2);
    char v18 = 0;
    *a4 = a2;
  }

  *a5 = v18;
}

uint64_t scanCharacters( const __CFAllocator *a1, __CFString **a2, _DWORD *a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, void *a9, int a10, unsigned int a11)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (!a6)
  {
    if (a7 >= a8) {
      return 0;
    }
    unsigned __int8 v15 = 0;
    uint64_t v46 = a8 - 1;
    if (a3) {
      BOOL v30 = a10 == 0;
    }
    else {
      BOOL v30 = 1;
    }
    int v31 = !v30;
    uint64_t v32 = a7;
    while (1)
    {
      unsigned __int16 v49 = *(_WORD *)(a5 + 2 * v32);
      if (v49 <= 0x7Fu)
      {
        if ((sURLValidCharacters[v49] & 1) != 0)
        {
          if (a10 == 4 || a10 == 2)
          {
            unsigned int v37 = v49 - 47;
            BOOL v21 = v37 > 0x11;
            int v38 = (1 << v37) & 0x30001;
            if (!v21 && v38 != 0) {
              goto LABEL_81;
            }
          }

          goto LABEL_94;
        }

        uint64_t v34 = v32 + 2;
        if (v49 == 37 && v34 < a8)
        {
          unint64_t v42 = *(unsigned __int16 *)(a5 + 2 * v32 + 2);
          if (v42 <= 0x7F && (sURLValidCharacters[v42] & 0x10) != 0)
          {
            unint64_t v43 = *(unsigned __int16 *)(a5 + 2 * v34);
            if (v43 <= 0x7F && (sURLValidCharacters[v43] & 0x10) != 0) {
              goto LABEL_94;
            }
          }
        }
      }

      if (a10 != 8) {
        goto LABEL_81;
      }
      if (v32 != a7 || v49 != 91)
      {
        if (v32 == v46)
        {
          uint64_t v36 = v46;
          if (v49 == 93) {
            goto LABEL_95;
          }
        }

void *_CFURLAllocateExtraDataspace(void *result)
{
  if (!result[5])
  {
    unsigned int v1 = result;
    uint64_t v2 = CFGetAllocator(result);
    uint64_t result = CFAllocatorAllocate(v2, 24LL, 0LL);
    uint64_t v3 = v1[5];
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 8);
      *uint64_t result = *(void *)v3;
      *((_DWORD *)result + 4) = *(_DWORD *)(v3 + 16);
    }

    else
    {
      uint64_t v4 = 0LL;
      *uint64_t result = 0LL;
      *((_DWORD *)result + 4) = 0;
    }

    result[1] = v4;
    v1[5] = result;
  }

  return result;
}

CFMutableStringRef resolveAbsoluteURLStringBuffer( const __CFAllocator *a1, const __CFString *a2, unsigned int a3, uint64_t a4, const __CFString *a5, unsigned int a6, CFIndex *a7, UniChar *a8)
{
  uint64_t v120 = *MEMORY[0x1895F89C0];
  CFIndex numChars = 0LL;
  CFMutableStringRef Mutable = CFStringCreateMutable(a1, 0LL);
  CFIndex v17 = 0LL;
  CFMutableStringRef theString = Mutable;
  if ((a6 & 1) != 0)
  {
    if (*a7 == -1)
    {
      CFIndex v17 = 0LL;
    }

    else
    {
      uint64_t v18 = Mutable;
      CFIndex v19 = a7[1];
      v121.length = v19;
      v121.CFIndex location = *a7;
      CFStringGetCharacters(a5, v121, a8);
      if (v19 < 1025)
      {
        __memcpy_chk();
        uint64_t v20 = numChars + v19;
        numChars += v19;
      }

      else
      {
        CFStringAppendCharacters(v18, a8, v19);
        uint64_t v20 = numChars;
      }

      if (v20 >= 1024)
      {
        CFStringAppendCharacters(theString, v117, v20);
        uint64_t v20 = 0LL;
        CFIndex numChars = 0LL;
      }

      v117[v20] = 58;
      CFIndex v17 = ++numChars;
    }
  }

  if ((a3 & 0x1E) != 0)
  {
    CFIndex Length = CFStringGetLength(a2);
    CFIndex v22 = numChars;
    if (Length >= 1025)
    {
      if (numChars)
      {
        CFStringAppendCharacters(theString, v117, numChars);
        CFIndex numChars = 0LL;
      }

      CFStringAppend(theString, a2);
      goto LABEL_158;
    }

    CFIndex v34 = Length;
    if (numChars + Length >= 1025)
    {
      CFStringAppendCharacters(theString, v117, numChars);
      CFIndex v22 = 0LL;
      CFIndex numChars = 0LL;
    }

    uint64_t v35 = &v117[v22];
    v124.CFIndex location = 0LL;
    v124.length = v34;
    CFStringGetCharacters(a2, v124, v35);
    CFIndex v36 = numChars + v34;
LABEL_156:
    CFIndex numChars = v36;
    if (!v36) {
      return theString;
    }
    goto LABEL_159;
  }

  if (v17 >= 1023)
  {
    CFStringAppendCharacters(theString, v117, v17);
    CFIndex v17 = 0LL;
    CFIndex numChars = 0LL;
  }

  *(_DWORD *)&v117[v17] = 3080239;
  numChars += 2LL;
  CFIndex v23 = _netLocationRange(a6, (uint64_t)a7);
  if (v23 != -1)
  {
    CFIndex v25 = v24;
    v122.CFIndex location = v23;
    v122.length = v25;
    CFStringGetCharacters(a5, v122, a8);
    CFIndex v26 = numChars;
    if (v25 < 1025)
    {
      if (numChars + v25 >= 1025)
      {
        CFStringAppendCharacters(theString, v117, numChars);
        CFIndex v26 = 0LL;
        CFIndex numChars = 0LL;
      }

      memcpy(&v117[v26], a8, 2 * v25);
      numChars += v25;
      if ((a3 & 0x20) == 0) {
        goto LABEL_23;
      }
      goto LABEL_37;
    }

    if (numChars)
    {
      CFStringAppendCharacters(theString, v117, numChars);
      CFIndex numChars = 0LL;
    }

    CFStringAppendCharacters(theString, a8, v25);
  }

  if ((a3 & 0x20) == 0)
  {
LABEL_23:
    if ((a6 & 0x20) != 0)
    {
      unsigned int v27 = 0;
      unsigned int v28 = 32;
      unsigned int v29 = a6;
      do
      {
        char v30 = v28;
        v28 >>= 1;
        v27 += v29 & 1;
        v29 >>= 1;
      }

      while ((v30 & 2) == 0);
      int v31 = &a7[2 * v27];
      if (*v31 != -1)
      {
        CFIndex v32 = v31[1];
        v123.length = v32;
        v123.CFIndex location = *v31;
        CFStringGetCharacters(a5, v123, a8);
        CFIndex v33 = numChars;
        if (v32 < 1025)
        {
          if (numChars + v32 >= 1025)
          {
            CFStringAppendCharacters(theString, v117, numChars);
            CFIndex v33 = 0LL;
            CFIndex numChars = 0LL;
          }

          memcpy(&v117[v33], a8, 2 * v32);
          numChars += v32;
        }

        else
        {
          if (numChars)
          {
            CFStringAppendCharacters(theString, v117, numChars);
            CFIndex numChars = 0LL;
          }

          CFStringAppendCharacters(theString, a8, v32);
        }
      }
    }

    if ((a3 & 0x1C0) != 0)
    {
      if ((a3 & 0x40) == 0)
      {
        if ((a6 & 0x40) != 0)
        {
          unsigned int v64 = 0;
          unsigned int v65 = 64;
          unsigned int v66 = a6;
          do
          {
            char v67 = v65;
            v65 >>= 1;
            v64 += v66 & 1;
            v66 >>= 1;
          }

          while ((v67 & 2) == 0);
          int v68 = &a7[2 * v64];
          CFIndex v69 = *v68;
          if (*v68 != -1)
          {
            CFIndex v70 = v68[1];
            CFIndex v71 = numChars;
            if (numChars >= 1024)
            {
              CFStringAppendCharacters(theString, v117, numChars);
              CFIndex v71 = 0LL;
              CFIndex numChars = 0LL;
            }

            v117[v71] = 59;
            ++numChars;
            v127.CFIndex location = v69;
            v127.length = v70;
            CFStringGetCharacters(a5, v127, a8);
            CFIndex v72 = numChars;
            if (v70 <= 1024)
            {
              if (numChars + v70 >= 1025)
              {
                CFStringAppendCharacters(theString, v117, numChars);
                CFIndex v72 = 0LL;
                CFIndex numChars = 0LL;
              }

              memcpy(&v117[v72], a8, 2 * v70);
              numChars += v70;
            }

            else
            {
              if (numChars)
              {
                CFStringAppendCharacters(theString, v117, numChars);
                CFIndex numChars = 0LL;
              }

              CFStringAppendCharacters(theString, a8, v70);
            }
          }
        }

        if ((a3 & 0x80) == 0) {
          goto LABEL_168;
        }
        unsigned int v88 = 0;
        unsigned int v89 = 128;
        unsigned int v90 = a3;
        do
        {
          char v91 = v89;
          v89 >>= 1;
          v88 += v90 & 1;
          v90 >>= 1;
        }

        while ((v91 & 2) == 0);
        v92 = (CFIndex *)(a4 + 16LL * v88);
        CFIndex v93 = *v92;
        if (*v92 == -1)
        {
LABEL_168:
          if ((a6 & 0x80) == 0) {
            goto LABEL_146;
          }
          unsigned int v100 = 0;
          unsigned int v101 = 128;
          do
          {
            char v102 = v101;
            v101 >>= 1;
            v100 += a6 & 1;
            a6 >>= 1;
          }

          while ((v102 & 2) == 0);
          unsigned __int8 v103 = &a7[2 * v100];
          CFIndex v104 = *v103;
          if (*v103 == -1)
          {
LABEL_146:
            if ((a3 & 0x100) == 0) {
              goto LABEL_158;
            }
            unsigned int v110 = 0;
            unsigned int v111 = 256;
            do
            {
              char v112 = v111;
              v111 >>= 1;
              v110 += a3 & 1;
              a3 >>= 1;
            }

            while ((v112 & 2) == 0);
            __int128 v113 = (CFIndex *)(a4 + 16LL * v110);
            CFIndex v114 = *v113;
            if (*v113 == -1) {
              goto LABEL_158;
            }
            CFIndex v63 = v113[1];
            CFIndex v115 = numChars;
            if (numChars >= 1024)
            {
              CFStringAppendCharacters(theString, v117, numChars);
              CFIndex v115 = 0LL;
              CFIndex numChars = 0LL;
            }

            v117[v115] = 35;
            ++numChars;
            v132.CFIndex location = v114;
            v132.length = v63;
            CFStringGetCharacters(a2, v132, a8);
            CFIndex v80 = numChars;
            if (v63 <= 1024) {
              goto LABEL_153;
            }
LABEL_98:
            if (v80)
            {
              CFStringAppendCharacters(theString, v117, v80);
              CFIndex numChars = 0LL;
            }

            uint64_t v81 = theString;
            CFRange v82 = a8;
            CFIndex v83 = v63;
            goto LABEL_109;
          }

          CFIndex v105 = v103[1];
          CFIndex v106 = numChars;
          if (numChars >= 1024)
          {
            CFStringAppendCharacters(theString, v117, numChars);
            CFIndex v106 = 0LL;
            CFIndex numChars = 0LL;
          }

          v117[v106] = 63;
          ++numChars;
          v131.CFIndex location = v104;
          v131.length = v105;
          CFStringGetCharacters(a5, v131, a8);
          CFIndex v107 = numChars;
          if (v105 > 1024)
          {
            if (numChars)
            {
              CFStringAppendCharacters(theString, v117, numChars);
              CFIndex numChars = 0LL;
            }

            int v97 = theString;
            v98 = a8;
            CFIndex v99 = v105;
            goto LABEL_136;
          }

          if (numChars + v105 >= 1025)
          {
            CFStringAppendCharacters(theString, v117, numChars);
            CFIndex v107 = 0LL;
            CFIndex numChars = 0LL;
          }

          memcpy(&v117[v107], a8, 2 * v105);
          CFIndex v108 = numChars + v105;
        }

        else
        {
          CFIndex v94 = v92[1];
          CFIndex v95 = numChars;
          if (numChars >= 1024)
          {
            CFStringAppendCharacters(theString, v117, numChars);
            CFIndex v95 = 0LL;
            CFIndex numChars = 0LL;
          }

          v117[v95] = 63;
          ++numChars;
          v130.CFIndex location = v93;
          v130.length = v94;
          CFStringGetCharacters(a2, v130, a8);
          CFIndex v96 = numChars;
          if (v94 > 1024)
          {
            if (numChars)
            {
              CFStringAppendCharacters(theString, v117, numChars);
              CFIndex numChars = 0LL;
            }

            int v97 = theString;
            v98 = a8;
            CFIndex v99 = v94;
LABEL_136:
            CFStringAppendCharacters(v97, v98, v99);
            goto LABEL_146;
          }

          if (numChars + v94 >= 1025)
          {
            CFStringAppendCharacters(theString, v117, numChars);
            CFIndex v96 = 0LL;
            CFIndex numChars = 0LL;
          }

          memcpy(&v117[v96], a8, 2 * v94);
          CFIndex v108 = numChars + v94;
        }

        CFIndex numChars = v108;
        goto LABEL_146;
      }

      unsigned int v77 = 0;
      unsigned int v78 = 64;
      do
      {
        char v79 = v78;
        v78 >>= 1;
        v77 += a3 & 1;
        a3 >>= 1;
      }

      while ((v79 & 2) == 0);
      uint64_t v61 = *(void *)(a4 + 16LL * v77) - 1LL;
      CFIndex v63 = CFStringGetLength(a2) - v61;
LABEL_97:
      v128.CFIndex location = v61;
      v128.length = v63;
      CFStringGetCharacters(a2, v128, a8);
      CFIndex v80 = numChars;
      if (v63 < 1025)
      {
LABEL_153:
        if (v80 + v63 >= 1025)
        {
          CFStringAppendCharacters(theString, v117, v80);
          CFIndex v80 = 0LL;
          CFIndex numChars = 0LL;
        }

        memcpy(&v117[v80], a8, 2 * v63);
        CFIndex v36 = numChars + v63;
        goto LABEL_156;
      }

      goto LABEL_98;
    }

    unsigned int v73 = 0;
    for (unsigned int i = 256; i != 32; i >>= 1)
    {
      if ((i & a6) != 0) {
        unsigned int v73 = i;
      }
    }

    if (v73)
    {
      if ((v73 & a6) != 0)
      {
        if ((v73 & 1) != 0)
        {
          uint64_t v75 = 0LL;
        }

        else
        {
          LODWORD(v75) = 0;
          do
          {
            char v76 = v73;
            v73 >>= 1;
            uint64_t v75 = (a6 & 1) + v75;
            a6 >>= 1;
          }

          while ((v76 & 2) == 0);
        }

        uint64_t v84 = a7[2 * v75];
      }

      else
      {
        uint64_t v84 = -1LL;
      }

      uint64_t v85 = CFStringGetLength(a5) - v84;
      v129.CFIndex location = v84 - 1;
      uint64_t v86 = v85 + 1;
      v129.length = v85 + 1;
      CFStringGetCharacters(a5, v129, a8);
      CFIndex v87 = numChars;
      if (v85 < 1024)
      {
        if (numChars + v86 > 1024)
        {
          CFStringAppendCharacters(theString, v117, numChars);
          CFIndex v87 = 0LL;
          CFIndex numChars = 0LL;
        }

        memcpy(&v117[v87], a8, 2 * v86);
        CFIndex v36 = numChars + v86;
        goto LABEL_156;
      }

      if (numChars)
      {
        CFStringAppendCharacters(theString, v117, numChars);
        CFIndex numChars = 0LL;
      }

      uint64_t v81 = theString;
      CFRange v82 = a8;
      CFIndex v83 = v85 + 1;
LABEL_109:
      CFStringAppendCharacters(v81, v82, v83);
    }

LABEL_158:
    CFIndex v36 = numChars;
    if (!numChars) {
      return theString;
    }
LABEL_159:
    CFStringAppendCharacters(theString, v117, v36);
    return theString;
  }

CFStringRef WindowsPathToURLPath(const __CFString *a1, const __CFAllocator *a2, int a3, int a4)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!CFStringGetLength(a1)) {
    return CFStringCreateWithCString(a2, "", 0x600u);
  }
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(a2, 0LL, a1);
  v31.length = CFStringGetLength(MutableCopy);
  v31.CFIndex location = 0LL;
  CFStringFindAndReplace(MutableCopy, @"/", @"\\"", v31, 0LL);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a2, MutableCopy, @"\\"");
  CFRelease(MutableCopy);
  CFRange v10 = CFArrayCreateMutableCopy(a2, 0LL, ArrayBySeparatingStrings);
  CFRelease(ArrayBySeparatingStrings);
  if (!a3)
  {
    CFIndex v11 = CFArrayGetCount(v10) - 1;
    ValueAtIndex = CFArrayGetValueAtIndex(v10, v11);
    if (CFEqual(ValueAtIndex, &stru_1899EF170)) {
      CFArrayRemoveValueAtIndex(v10, v11);
    }
  }

  char v13 = (const __CFString *)CFArrayGetValueAtIndex(v10, 0LL);
  CFIndex v15 = a4 && (v14 = v13, CFStringGetLength(v13) == 2) && CFStringGetCharacterAtIndex(v14, 1LL) == 58;
  CFIndex Count = CFArrayGetCount(v10);
  if (v15 < Count)
  {
    CFIndex v17 = Count;
    while (1)
    {
      uint64_t v18 = (const __CFString *)CFArrayGetValueAtIndex(v10, v15);
      unint64_t Length = CFStringGetLength(v18);
      if (Length <= 1) {
        unint64_t Length = 1LL;
      }
      CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
      CFIndex v21 = MaximumSizeForEncoding + 1;
      if (MaximumSizeForEncoding >= 1024) {
        CFIndex v22 = (char *)malloc(MaximumSizeForEncoding + 1);
      }
      else {
        CFIndex v22 = buffer;
      }
      if (CFStringGetCString(v18, v22, v21, 0x8000100u))
      {
        size_t v23 = strlen(v22);
        CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes( 0LL,  v22,  v23,  0,  0,  1,  0LL);
      }

      else
      {
        CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes = 0LL;
      }

      if (v22 != buffer) {
        free(v22);
      }
      if (!StringFromFileSystemRepresentationByAddingPercentEscapes) {
        break;
      }
      if (StringFromFileSystemRepresentationByAddingPercentEscapes != v18) {
        CFArraySetValueAtIndex(v10, v15, StringFromFileSystemRepresentationByAddingPercentEscapes);
      }
      CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
      if (v17 == ++v15) {
        goto LABEL_25;
      }
    }

    CFRelease(v10);
    return CFStringCreateWithCString(a2, "", 0x600u);
  }

uint64_t _CopyIsDirectoryKeyArray()
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  v3[2] = ___CopyIsDirectoryKeyArray_block_invoke;
  v3[3] = &unk_18999BD28;
  v3[4] = &v4;
  if (_CopyIsDirectoryKeyArray_onceToken != -1) {
    dispatch_once(&_CopyIsDirectoryKeyArray_onceToken, v3);
  }
  v0 = (const void *)v5[3];
  if (v0)
  {
    CFRetain(v0);
    uint64_t v1 = v5[3];
  }

  else
  {
    uint64_t v1 = 0LL;
  }

  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_180B317D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

CFStringRef CreateStringFromFileSystemRepresentationByAddingPercentEscapes( const __CFAllocator *a1, _BYTE *a2, uint64_t a3, int a4, int a5, int a6, char *a7)
{
  v34[1] = *MEMORY[0x1895F89C0];
  size_t v14 = (a4 != 0) | (8LL * (a5 != 0)) | 0xC00;
  MEMORY[0x1895F8858](a1, a2);
  uint64_t v18 = (char *)v34 - v17;
  if (v19 >= 1025)
  {
    size_t v14 = 3 * a3 + 8LL * v15 + v16;
    CFIndex v21 = (char *)malloc(v14);
    if (!v21)
    {
      CFStringRef v32 = 0LL;
      char v23 = 0;
      goto LABEL_62;
    }

    uint64_t v20 = v21;
    v34[0] = a7;
  }

  else
  {
    v34[0] = a7;
    uint64_t v20 = (char *)v34 - v17;
  }

  CFIndex v22 = v20;
  if (a5)
  {
    strlcpy(v20, "file://", v14);
    CFIndex v22 = v20 + 7;
  }

  if (!a6)
  {
    if (a3 >= 1)
    {
      char v23 = 0;
      uint64_t v24 = 0LL;
      while (1)
      {
        uint64_t v27 = a2[v24];
        if (!a2[v24]) {
          goto LABEL_28;
        }
        if ((sURLValidBytes[v27] & 1) != 0)
        {
          *v22++ = v27;
        }

        else
        {
          *CFIndex v22 = 37;
          v22[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)a2[v24] >> 4];
          v22[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[a2[v24] & 0xF];
          v22 += 3;
          char v23 = 1;
        }

        if (a3 == ++v24) {
          goto LABEL_34;
        }
      }
    }

CFStringRef createFileReferencePath( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return 0LL;
  }
  if (!a5)
  {
    char v13 = "/";
    if (!a6) {
      char v13 = "";
    }
    return 0LL;
  }

  MEMORY[0x1895F8858](a1, a2);
  if (!CFStringGetCString(v10, v14, 1024LL, 0x8000100u)) {
    return 0LL;
  }
  CFIndex v11 = "/";
  if (!a6) {
    CFIndex v11 = "";
  }
  else {
    return 0LL;
  }
}

Boolean CFURLCreateDataAndPropertiesFromResource( CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  bytes[9] = *(UInt8 **)MEMORY[0x1895F89C0];
  uint64_t v12 = CFURLCopyScheme(url);
  if (v12)
  {
    char v13 = v12;
    if (CFStringCompare(v12, @"file", 1uLL))
    {
      if (CFStringCompare(v13, @"data", 1uLL) == kCFCompareEqualTo)
      {
        char v14 = _CFDataURLCreateDataAndPropertiesFromResource( alloc,  url,  (__CFString *)resourceData,  (const __CFString *)desiredProperties,  properties,  errorCode);
        goto LABEL_24;
      }

      if (__CFNetwork__CFURLCreateDataAndPropertiesFromResource_onceToken != -1) {
        dispatch_once(&__CFNetwork__CFURLCreateDataAndPropertiesFromResource_onceToken, &__block_literal_global_23);
      }
      if (__CFNetwork__CFURLCreateDataAndPropertiesFromResource_dyfunc)
      {
        char v14 = __CFNetwork__CFURLCreateDataAndPropertiesFromResource_dyfunc( alloc,  url,  resourceData,  properties,  desiredProperties,  errorCode);
LABEL_24:
        LOBYTE(v15) = v14;
LABEL_106:
        CFRelease(v13);
        return v15;
      }

      if (resourceData) {
        *resourceData = 0LL;
      }
      if (properties) {
        *properties = 0LL;
      }
      if (errorCode)
      {
        LOBYTE(v15) = 0;
        *errorCode = -15;
        goto LABEL_106;
      }

LABEL_105:
      LOBYTE(v15) = 0;
      goto LABEL_106;
    }

    if (errorCode) {
      *errorCode = 0;
    }
    if (resourceData)
    {
      uint64_t v16 = alloc;
      if (!alloc)
      {
        uint64_t v17 = (__objc2_class **)_CFGetTSD(1u);
        if (!v17) {
          uint64_t v17 = &__kCFAllocatorSystemDefault;
        }
        uint64_t v16 = (const __CFAllocator *)CFRetain(v17);
      }

      if (_CFReadBytesFromFile(v16, url, (void **)bytes, &length, 0LL, 0))
      {
        uint64_t v18 = CFDataCreateWithBytesNoCopy(v16, bytes[0], length, v16);
        int v15 = 1;
      }

      else
      {
        uint64_t v18 = 0LL;
        int v15 = 0;
        if (errorCode) {
          *errorCode = -10;
        }
      }

      *resourceData = v18;
      if (!alloc) {
        CFRelease(v16);
      }
    }

    else
    {
      int v15 = 1;
      uint64_t v16 = alloc;
    }

    if (!properties)
    {
LABEL_101:
      if (!resourceData || v15) {
        goto LABEL_106;
      }
      if (*resourceData)
      {
        CFRelease(*resourceData);
        LOBYTE(v15) = 0;
        *resourceData = 0LL;
        goto LABEL_106;
      }

      goto LABEL_105;
    }

    value = 0LL;
    CFIndex length = 0LL;
    if (errorCode) {
      *errorCode = 0;
    }
    if (!desiredProperties)
    {
      desiredProperties = (CFArrayRef)_CFFileURLCreatePropertiesFromResource__allProps;
      if (!_CFFileURLCreatePropertiesFromResource__allProps)
      {
        bytes[0] = (UInt8 *)@"kCFURLFileExists";
        bytes[1] = (UInt8 *)@"kCFURLFilePOSIXMode";
        bytes[2] = (UInt8 *)@"kCFURLFileDirectoryContents";
        bytes[3] = (UInt8 *)@"kCFURLFileLength";
        bytes[4] = (UInt8 *)@"kCFURLFileLastModificationTime";
        bytes[5] = (UInt8 *)@"kCFURLFileOwnerID";
        desiredProperties = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)bytes,  6LL,  &kCFTypeArrayCallBacks);
        _CFFileURLCreatePropertiesFromResource__allProps = (uint64_t)desiredProperties;
      }
    }

    uint64_t Count = CFArrayGetCount(desiredProperties);
    theDict = CFDictionaryCreateMutable(v16, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Count)
    {
LABEL_99:
      *properties = theDict;
      if (!theDict) {
        int v15 = 0;
      }
      goto LABEL_101;
    }

    v46.CFIndex location = 0LL;
    v46.CFIndex length = Count;
    if (CFArrayContainsValue(desiredProperties, v46, @"kCFURLFileDirectoryContents")) {
      p_value = &value;
    }
    else {
      p_value = 0LL;
    }
    v47.CFIndex location = 0LL;
    v47.CFIndex length = Count;
    if (CFArrayContainsValue(desiredProperties, v47, @"kCFURLFileLastModificationTime")) {
      p_CFIndex length = (CFDateRef *)&length;
    }
    else {
      p_CFIndex length = 0LL;
    }
    if (_CFGetFileProperties( v16,  url,  &v44,  &valuePtr,  (off_t *)bytes,  p_length,  &v40,  (__CFArray **)p_value))
    {
      if (Count == 1
        && (v48.CFIndex location = 0LL, v48.length = 1LL,
                                CFArrayContainsValue(desiredProperties, v48, @"kCFURLFileExists")))
      {
        CFDictionarySetValue(theDict, @"kCFURLFileExists", &__kCFBooleanFalse);
      }

      else if (errorCode)
      {
        *errorCode = -10;
      }

      goto LABEL_99;
    }

    allocator = v16;
    if (Count < 1)
    {
LABEL_95:
      if (length) {
        CFRelease((CFTypeRef)length);
      }
      if (value) {
        CFRelease(value);
      }
      goto LABEL_99;
    }

    CFIndex v22 = 0LL;
    char v23 = @"kCFURLFileLength";
    while (1)
    {
      uint64_t v24 = (__CFString *)v23;
      ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(desiredProperties, v22);
      if (ValueAtIndex == @"kCFURLFilePOSIXMode" || CFEqual(@"kCFURLFilePOSIXMode", ValueAtIndex)) {
        break;
      }
      uint64_t v29 = @"kCFURLFileDirectoryContents";
      if (ValueAtIndex == @"kCFURLFileDirectoryContents"
        || (int v30 = CFEqual(@"kCFURLFileDirectoryContents", ValueAtIndex),
            uint64_t v29 = @"kCFURLFileDirectoryContents",
            v30))
      {
        if (v44)
        {
          if ((valuePtr & 0xF000) == 0x4000)
          {
            BOOL v31 = (__objc2_class **)value;
            if (value) {
              goto LABEL_68;
            }
          }
        }

    uint64_t v86 = (char *)calloc((M >> 3) + 1, 1uLL);
    CFIndex v87 = v86;
    if ((M & 0xFFFFFFF8) != 0)
    {
      unsigned int v88 = 0LL;
      unsigned int v89 = 6LL;
      do
      {
        unsigned int v90 = 2 * (*((_BYTE *)v68 + (v88 | 7)) != 0);
        char v91 = v89;
        do
          unsigned int v90 = 2 * (v90 | (*((_BYTE *)v68 + v91--) != 0));
        while (v91 >= (v88 | 1));
        v86[v88 >> 3] = v90 | (*((_BYTE *)v68 + v88) != 0);
        v88 += 8LL;
        v89 += 8LL;
      }

      while (v88 < (M & 0xFFFFFFF8));
      v92 = M - 2;
      CFIndex v93 = *((_BYTE *)v68 + (M - 1)) != 0;
      if ((int)M - 2 < v88)
      {
LABEL_116:
        v86[M >> 3] = v93;
        free(v68);
        v8->_g = v87;
        v8->_rankTable = v75;
        CFMutableStringRef result = (NSSharedKeySet *)calloc(v31, 8uLL);
        v8->_keys = (id *)&result->super.isa;
        CFIndex v96 = v125;
        if (v31)
        {
          int v97 = 0LL;
          v98 = 1;
          do
          {
            CFIndex v99 = v8->_seeds;
            factor = v8->_factor;
            rankTable = (unsigned int *)v8->_rankTable;
            g = v8->_g;
            unsigned __int8 v103 = v8->_select;
            CFIndex v104 = v130[v97];
            if (v8->_algorithmType == 1)
            {
              CFIndex v108 = *v99 - 559038729;
              CFIndex v107 = v108 + v99[1];
              CFIndex v106 = v108 + HIDWORD(v104);
            }

            else
            {
              if (v8->_algorithmType) {
                goto LABEL_137;
              }
              CFIndex v105 = v99[1];
              CFIndex v106 = *v99 - 559038733;
              CFIndex v107 = v106 + v105;
              CFIndex v108 = v106;
            }

            HIDWORD(v109) = v106;
            LODWORD(v109) = v106;
            unsigned int v110 = (v107 ^ v106) - (v109 >> 18);
            HIDWORD(v109) = v110;
            LODWORD(v109) = v110;
            unsigned int v111 = ((v108 + v104) ^ v110) - (v109 >> 21);
            HIDWORD(v109) = v111;
            LODWORD(v109) = v111;
            char v112 = (v111 ^ v106) - (v109 >> 7);
            HIDWORD(v109) = v112;
            LODWORD(v109) = v112;
            __int128 v113 = (v112 ^ v110) - (v109 >> 16);
            HIDWORD(v109) = v113;
            LODWORD(v109) = v113;
            HIDWORD(v109) = (v113 ^ v111) - (v109 >> 28);
            LODWORD(v109) = HIDWORD(v109);
            HIDWORD(v109) = (HIDWORD(v109) ^ v112) - (v109 >> 18);
            LODWORD(v109) = HIDWORD(v109);
            CFIndex v114 = 2 * (((HIDWORD(v109) ^ v113) - (v109 >> 8)) % factor);
            CFIndex v115 = HIDWORD(v109) % factor;
            v139[0] = v114;
            v139[1] = (2 * v115) | 1;
            v116 = v139[((g[(unint64_t)(2 * v115) >> 3] >> ((2 * v115) & 6 | 1)) ^ (g[v114 >> 3] >> (v114 & 6))) & 1];
            if (v103 == 2)
            {
              v117 = rankTable[v116];
            }

            else if (v103 == 1)
            {
              v117 = *((unsigned __int16 *)rankTable + v116);
            }

            else
            {
              if (v103) {
                goto LABEL_137;
              }
              v117 = *((unsigned __int8 *)rankTable + v116);
            }

            CFMutableStringRef result = (NSSharedKeySet *)[v129[v97] copyWithZone:0];
            v8->_keys[v117] = result;
            int v97 = v98;
            unsigned int v38 = v31 > v98++;
          }

          while (v38);
        }

        if (v96)
        {
          v118 = objc_alloc((Class)objc_opt_class());
          v119 = [v118 initWithKeys:v124 count:v96];
          if (v119)
          {
            v8->_subSharedKeySet = (NSSharedKeySet *)v119;
          }

          else
          {

            uint64_t v8 = 0LL;
          }
        }

        free(v66);
LABEL_134:

        free(v130);
        free(v127);
        free(v128);
        return v8;
      }
    }

    else
    {
      LODWORD(v8_Block_object_dispose(va, 8) = 0;
      v92 = M - 2;
      CFIndex v93 = *((_BYTE *)v68 + (M - 1)) != 0;
    }

    CFIndex v94 = v92;
    do
    {
      CFIndex v93 = (*((_BYTE *)v68 + v94) != 0) | (2 * v93);
      if (!v94) {
        break;
      }
      --v92;
      --v94;
    }

    while (v92 >= v88);
    goto LABEL_116;
  }

  uint64_t v120 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  a4);
  CFRange v121 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v120,  0LL);
  CFRelease(v120);
  objc_exception_throw(v121);
LABEL_137:
  __break(1u);
  return result;
}

LABEL_82:
      if (Count == ++v22) {
        goto LABEL_95;
      }
    }

    if (v44)
    {
      CFNumberRef v26 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
      uint64_t v27 = theDict;
      unsigned int v28 = @"kCFURLFilePOSIXMode";
      goto LABEL_61;
    }

    goto LABEL_78;
  }

  if (errorCode) {
    *errorCode = -15;
  }
  if (resourceData) {
    *resourceData = 0LL;
  }
  LOBYTE(v15) = 0;
  if (properties) {
    *properties = 0LL;
  }
  return v15;
}

          CFIndex v21 = v11;
          break;
        }

          CFIndex v22 = v11;
          break;
        }

BOOL _CFDataURLCreateDataAndPropertiesFromResource( const __CFAllocator *a1, CFTypeRef cf, __CFString *a3, const __CFString *a4, CFDictionaryRef *a5, _DWORD *a6)
{
  uint64_t v6 = a6;
  CFAllocatorRef v127 = a1;
  uint64_t v138 = *MEMORY[0x1895F89C0];
  if (a6) {
    *a6 = 0;
  }
  CFIndex v11 = CFGetAllocator(cf);
  uint64_t v12 = CFURLCopyResourceSpecifier((CFURLRef)cf);
  if (!v12) {
    goto LABEL_195;
  }
  char v13 = v12;
  CFIndex location = CFStringFind(v12, @",", 0LL).location;
  if (location == -1)
  {
    CFRelease(v13);
    goto LABEL_195;
  }

  v144.CFIndex length = location;
  CFRange v121 = v13;
  CFRange v122 = v6;
  v144.CFIndex location = 0LL;
  int v15 = CFStringCreateWithSubstring(v11, v13, v144);
  uint64_t v16 = CFURLCreateStringByReplacingPercentEscapes(v11, v15, &stru_1899EF170);
  if (v16)
  {
    uint64_t v17 = v16;
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v11, 0LL, v16);
    CFRelease(v17);
  }

  else
  {
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v11, 0LL, v15);
  }

  CFRelease(v15);
  CFStringTrimWhitespace(MutableCopy);
  uint64_t Length = CFStringGetLength(MutableCopy);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  CFStringRef v131 = MutableCopy;
  uint64_t v134 = 0LL;
  uint64_t v135 = Length;
  CFStringRef Copy = MutableCopy;
  CharactersPtr = CFStringGetCharactersPtr(MutableCopy);
  CStringPtr = 0LL;
  CFRange v132 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(Copy, 0x600u);
  }
  CFStringRef v123 = (CFStringRef)v11;
  uint64_t v136 = 0LL;
  uint64_t v137 = 0LL;
  CFRange v133 = CStringPtr;
  uint64_t v120 = a5;
  if (Length < 1)
  {
    uid_t v40 = 0LL;
    CFIndex v41 = Copy;
    goto LABEL_52;
  }

  uint64_t v119 = Length - 1;
  CFRange v124 = a3;
  CFRange v125 = (__CFString *)a4;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  CFIndex v25 = -1LL;
  uint64_t v26 = 64LL;
  uint64_t v27 = -1LL;
  while (1)
  {
    uint64_t v28 = (unint64_t)v24 >= 4 ? 4LL : v24;
    uint64_t v29 = v135;
    if (v135 > v24) {
      break;
    }
    UniChar v30 = 0;
LABEL_33:
    int IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, v30);
    if (IsCharacterMember) {
      uint64_t v38 = v27;
    }
    else {
      uint64_t v38 = v24;
    }
    if (IsCharacterMember) {
      uint64_t v39 = -1LL;
    }
    else {
      uint64_t v39 = v24;
    }
    if (v25 == -1) {
      CFIndex v25 = v39;
    }
    else {
      uint64_t v27 = v38;
    }
    ++v24;
    --v23;
    ++v26;
    if (Length == v24) {
      goto LABEL_43;
    }
  }

  if (v132)
  {
    UniChar v30 = v132[v24 + v134];
  }

  else if (v133)
  {
    UniChar v30 = v133[v134 + v24];
  }

  else
  {
    uint64_t v31 = v136;
    if (v137 <= v24 || v136 > v24)
    {
      uint64_t v33 = v28 + v23;
      uint64_t v34 = v26 - v28;
      uint64_t v35 = v24 - v28;
      uint64_t v36 = v35 + 64;
      if (v35 + 64 >= v135) {
        uint64_t v36 = v135;
      }
      uint64_t v136 = v35;
      uint64_t v137 = v36;
      if (v135 >= v34) {
        uint64_t v29 = v34;
      }
      v139.CFIndex length = v29 + v33;
      v139.CFIndex location = v134 + v35;
      CFStringGetCharacters(v131, v139, (UniChar *)&v129);
      uint64_t v31 = v136;
    }

    UniChar v30 = *((_WORD *)&v129 + v24 - v31);
  }

  if (v30 != 59) {
    goto LABEL_33;
  }
LABEL_43:
  uid_t v40 = 0LL;
  CFIndex v41 = Copy;
  if (v25 == -1)
  {
    a5 = v120;
    a3 = v124;
    a4 = v125;
  }

  else
  {
    a5 = v120;
    a3 = v124;
    a4 = v125;
    if (v27 != -1)
    {
      CFIndex v42 = CFGetAllocator(Copy);
      CFIndex v43 = CFStringCreateMutableCopy(v42, Length, Copy);
      uid_t v40 = v43;
      if (v27 != v119)
      {
        v140.CFIndex location = v27 + 1;
        v140.CFIndex length = Length + ~v27;
        CFStringDelete(v43, v140);
      }

      if (v25 >= 1)
      {
        v141.CFIndex location = 0LL;
        v141.CFIndex length = v25;
        CFStringDelete(v40, v141);
      }

      CFStringLowercase(v40, 0LL);
    }
  }

LABEL_181:
  if (v125) {
    CFStringRef Copy = CFStringCreateCopy(v46, v125);
  }
  else {
    CFStringRef Copy = 0LL;
  }
  if (v124) {
    CFStringRef v123 = CFStringCreateCopy(v46, v124);
  }
  else {
    CFStringRef v123 = 0LL;
  }
  int v67 = 0;
LABEL_188:
  free(v59);
  if (v41) {
    CFRelease(v41);
  }
  if (v125) {
    CFRelease(v125);
  }
  if (v124) {
    CFRelease(v124);
  }
  CFRelease(v121);
  if (v67)
  {
LABEL_195:
    if (v6) {
      *uint64_t v6 = -10;
    }
    BOOL v99 = 0LL;
    if (a3) {
      a3->isa = 0LL;
    }
    return v99;
  }

  if (a3)
  {
    CFDataRef v97 = CFDataCreateCopy(v127, v72);
    a3->isa = v97;
  }

  if (a5)
  {
    __int128 v129 = xmmword_1899E9C20;
    CFRange v130 = @"kCFDataURLTextEncodingName";
    if (!a4)
    {
      a4 = (const __CFString *)_CFDataURLCreateDataAndPropertiesFromResource_sAllProps;
      if (!_CFDataURLCreateDataAndPropertiesFromResource_sAllProps)
      {
        CFDataRef v97 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)&v129,  3LL,  &kCFTypeArrayCallBacks);
        a4 = (const __CFString *)v97;
        _CFDataURLCreateDataAndPropertiesFromResource_sAllProps = (uint64_t)v97;
      }
    }

    CFRange v125 = (__CFString *)&v119;
    uint64_t v101 = MEMORY[0x1895F8858](v97, v98);
    char v102 = v118;
    MEMORY[0x1895F8858](v101, v103);
    CFIndex Count = CFArrayGetCount((CFArrayRef)a4);
    if (Count >= 1)
    {
      CFIndex v105 = Count;
      CFIndex v106 = (const __CFArray *)a4;
      CFIndex v107 = 0LL;
      int v108 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v106, v107);
        if (CFEqual(ValueAtIndex, @"kCFDataURLDataLength"))
        {
          CFIndex v128 = CFDataGetLength(v72);
          v117[v108] = ValueAtIndex;
          unsigned int v110 = CFNumberCreate(v127, kCFNumberCFIndexType, &v128);
        }

        else
        {
          if (CFEqual(ValueAtIndex, @"kCFDataURLMimeType"))
          {
            unsigned int v111 = Copy;
            if (!Copy) {
              goto LABEL_217;
            }
          }

          else
          {
            if (!CFEqual(ValueAtIndex, @"kCFDataURLTextEncodingName")) {
              goto LABEL_217;
            }
            unsigned int v111 = v123;
            if (!v123) {
              goto LABEL_217;
            }
          }

          v117[v108] = ValueAtIndex;
          unsigned int v110 = CFStringCreateCopy(v127, v111);
        }

        v118[v108++] = v110;
LABEL_217:
        if (v105 == ++v107) {
          goto LABEL_221;
        }
      }
    }

    int v108 = 0;
LABEL_221:
    uint64_t v112 = v108;
    CFDictionaryRef v113 = CFDictionaryCreate(v127, v117, v118, v108, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFIndex v114 = v120;
    *uint64_t v120 = v113;
    if (v108 >= 1)
    {
      do
      {
        CFIndex v115 = *v102++;
        CFRelease(v115);
        --v112;
      }

      while (v112);
      CFDictionaryRef v113 = *v114;
    }

    BOOL v99 = v113 != 0LL;
  }

  else
  {
    BOOL v99 = 1LL;
  }

  CFStringRef v116 = Copy;
  if (v72)
  {
    CFRelease(v72);
    CFStringRef v116 = Copy;
  }

  if (v116) {
    CFRelease(v116);
  }
  if (v123) {
    CFRelease(v123);
  }
  return v99;
}

CFTypeRef CFURLCreatePropertyFromResource( CFAllocatorRef alloc, CFURLRef url, CFStringRef property, SInt32 *errorCode)
{
  values[1] = *(void **)MEMORY[0x1895F89C0];
  values[0] = (void *)property;
  CFArrayRef v7 = CFArrayCreate(alloc, (const void **)values, 1LL, &kCFTypeArrayCallBacks);
  CFDictionaryRef properties = 0LL;
  if (CFURLCreateDataAndPropertiesFromResource(alloc, url, 0LL, &properties, v7, errorCode))
  {
    Value = CFDictionaryGetValue(properties, values[0]);
    CFStringRef v9 = Value;
    if (Value) {
      CFRetain(Value);
    }
    CFRelease(v7);
    CFArrayRef v7 = properties;
  }

  else
  {
    if (properties) {
      CFRelease(properties);
    }
    CFStringRef v9 = 0LL;
  }

  CFRelease(v7);
  return v9;
}

Boolean CFURLWriteDataAndPropertiesToResource( CFURLRef url, CFDataRef dataToWrite, CFDictionaryRef propertiesToWrite, SInt32 *errorCode)
{
  v36[8] = *(const void **)MEMORY[0x1895F89C0];
  uint64_t v8 = CFURLCopyScheme(url);
  if (!v8)
  {
    if (errorCode)
    {
      LOBYTE(v11) = 0;
      SInt32 v12 = -15;
LABEL_22:
      *errorCode = v12;
      return v11;
    }

    goto LABEL_61;
  }

  CFStringRef v9 = v8;
  CFComparisonResult v10 = CFStringCompare(v8, @"file", 0LL);
  CFRelease(v9);
  if (v10 == kCFCompareEqualTo)
  {
    if (errorCode) {
      *errorCode = 0;
    }
    if (!dataToWrite)
    {
      LOBYTE(v11) = 1;
      if (!propertiesToWrite) {
        return v11;
      }
      goto LABEL_36;
    }

    if (CFURLHasDirectoryPath(url))
    {
      if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026LL))
      {
        if (!errorCode)
        {
          LOBYTE(v11) = 0;
          if (!propertiesToWrite) {
            return v11;
          }
          goto LABEL_36;
        }

        SInt32 v14 = -15;
        goto LABEL_29;
      }

      BOOL v13 = _CFCreateDirectory((char *)buffer);
      LOBYTE(v11) = v13;
      if (errorCode && !v13)
      {
        SInt32 v14 = -10;
LABEL_29:
        LOBYTE(v11) = 0;
LABEL_34:
        *errorCode = v14;
      }
    }

    else
    {
      int Length = CFDataGetLength(dataToWrite);
      if (Length) {
        BytePtr = CFDataGetBytePtr(dataToWrite);
      }
      else {
        BytePtr = (const UInt8 *)"";
      }
      int v17 = _CFWriteBytesToFile(url, BytePtr, Length);
      LOBYTE(v11) = v17;
      if (errorCode && !v17)
      {
        SInt32 v14 = -10;
        goto LABEL_34;
      }
    }

    if (!propertiesToWrite) {
      return v11;
    }
LABEL_36:
    if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026LL))
    {
      if (!errorCode) {
        goto LABEL_61;
      }
      char v22 = 0;
      SInt32 v23 = -15;
      goto LABEL_59;
    }

    int Count = CFDictionaryGetCount(propertiesToWrite);
    if (Count >= 8)
    {
      CFURLRef cf = url;
      uint64_t v24 = CFGetAllocator(url);
      uint64_t v20 = Count;
      CFIndex v21 = (const void **)CFAllocatorAllocate(v24, 16LL * Count, 0LL);
      uint64_t v19 = &v21[Count];
      CFDictionaryGetKeysAndValues(propertiesToWrite, v21, v19);
    }

    else
    {
      uint64_t v19 = v36;
      CFDictionaryGetKeysAndValues(propertiesToWrite, (const void **)keys, v36);
      if (Count < 1)
      {
        char v22 = 1;
        if (errorCode)
        {
LABEL_56:
          if (v22) {
            SInt32 v23 = 0;
          }
          else {
            SInt32 v23 = -10;
          }
LABEL_59:
          *errorCode = v23;
        }

Boolean CFURLDestroyResource(CFURLRef url, SInt32 *errorCode)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v4 = CFURLCopyScheme(url);
  if (!v4)
  {
LABEL_11:
    if (errorCode)
    {
      SInt32 v7 = -15;
LABEL_22:
      *errorCode = v7;
      return v4;
    }

    return v4;
  }

  uint64_t v5 = v4;
  CFComparisonResult v6 = CFStringCompare(v4, @"file", 0LL);
  CFRelease(v5);
  if (v6 == kCFCompareEqualTo)
  {
    LODWORD(v4) = CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026LL);
    if ((_DWORD)v4)
    {
      if (CFURLHasDirectoryPath(url)) {
        LODWORD(v4) = _CFRemoveDirectory((char *)buffer);
      }
      else {
        LODWORD(v4) = _CFDeleteFile((char *)buffer);
      }
      BOOL v8 = (_DWORD)v4 == 0;
      LOBYTE(v4) = (_DWORD)v4 != 0;
      if (v8) {
        SInt32 v7 = -10;
      }
      else {
        SInt32 v7 = 0;
      }
      if (errorCode) {
        goto LABEL_22;
      }
      return v4;
    }

    goto LABEL_11;
  }

  if (__CFNetwork__CFURLDestroyResource_onceToken != -1) {
    dispatch_once(&__CFNetwork__CFURLDestroyResource_onceToken, &__block_literal_global_42);
  }
  if (__CFNetwork__CFURLDestroyResource_dyfunc)
  {
    LODWORD(v4) = __CFNetwork__CFURLDestroyResource_dyfunc(url, errorCode);
    if (!errorCode) {
      return v4;
    }
  }

  else
  {
    LODWORD(v4) = 0;
    if (!errorCode) {
      return v4;
    }
    *errorCode = -15;
  }

  if (!(_DWORD)v4)
  {
    SInt32 v7 = -11;
    goto LABEL_22;
  }

  return v4;
}

CFDataRef percentEscapeDecodeBuffer( const __CFAllocator *a1, uint64_t a2, uint64_t a3, int64_t __size, int a5)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (__size < 1025)
  {
    if (__size <= 0) {
      return CFDataCreate(a1, bytes, 0LL);
    }
    allocator = a1;
    CFStringRef v9 = bytes;
  }

  else
  {
    allocator = a1;
    CFStringRef v9 = (UInt8 *)malloc(__size);
  }

  CFIndex v10 = 0LL;
  uint64_t v11 = a3 + __size;
  uint64_t v12 = MEMORY[0x1895F8770];
  do
  {
    int v13 = *(unsigned __int8 *)(a2 + a3);
    if (v13 != 37) {
      goto LABEL_36;
    }
    uint64_t v14 = a3 + 2;
    if (v11 <= a3 + 2
      || (char v15 = *(_BYTE *)(a3 + a2 + 1), v16 = v15 - 48, (v15 - 48) >= 0xAu)
      && (*(unsigned __int8 *)(a3 + a2 + 1) - 65 <= 0x25
        ? (BOOL v17 = ((1LL << (v15 - 65)) & 0x3F0000003FLL) == 0)
        : (BOOL v17 = 1),
          v17)
      || (char v18 = *(_BYTE *)(a2 + v14), v19 = v18 - 48, v20 = (v18 - 48), v20 >= 0xA)
      && (*(unsigned __int8 *)(a2 + v14) - 65 <= 0x25
        ? (BOOL v21 = ((1LL << (v18 - 65)) & 0x3F0000003FLL) == 0)
        : (BOOL v21 = 1),
          v21))
    {
      LOBYTE(v13) = 37;
LABEL_36:
      uint64_t v14 = a3;
      if (!a5) {
        goto LABEL_39;
      }
      goto LABEL_37;
    }

    unsigned __int8 v22 = v18 - 65;
    unsigned int v23 = (v15 - 65);
    else {
      unsigned __int8 v24 = v15 - 87;
    }
    unsigned __int8 v25 = v15 - 55;
    if (v23 > 5) {
      unsigned __int8 v25 = v24;
    }
    if (v16 >= 0xAu) {
      unsigned __int8 v16 = v25;
    }
    char v26 = 16 * v16;
    else {
      char v27 = v18 - 87;
    }
    char v28 = v18 - 55;
    if (v22 <= 5u) {
      char v29 = v28;
    }
    else {
      char v29 = v27;
    }
    if (v20 < 0xA) {
      char v29 = v19;
    }
    LOBYTE(v13) = v29 | v26;
    if (!a5) {
      goto LABEL_39;
    }
LABEL_37:
    if ((v13 & 0x80) == 0)
    {
LABEL_39:
      v9[v10++] = v13;
      goto LABEL_40;
    }

uint64_t CFUniCharIsMemberOf(int a1, unsigned int a2)
{
  if (a2 - 16 >= 0x54) {
    unsigned int v2 = a2;
  }
  else {
    unsigned int v2 = a2 + 85;
  }
  if (a2 == 1) {
    unsigned int v3 = 108;
  }
  else {
    unsigned int v3 = v2;
  }
  if (v3 == 15)
  {
    BOOL v5 = (a1 - 8232) < 2 || a1 == 133;
    return (a1 - 10) < 4 || v5;
  }

  if (v3 != 3)
  {
    if (v3 == 2)
    {
      uint64_t v4 = 1LL;
      if (a1 > 159)
      {
        if (a1 == 160 || a1 == 5760) {
          return v4;
        }
      }

      else if (a1 == 9 || a1 == 32)
      {
        return v4;
      }

      if ((a1 - 0x2000) >= 0xC)
      {
        uint64_t v4 = 1LL;
        if (a1 == 8239 || a1 == 8287) {
          return v4;
        }
        goto LABEL_38;
      }

      return 1LL;
    }

    unsigned int v6 = v3 - 85;
    if (v3 <= 0x63) {
      unsigned int v6 = v3;
    }
    uint64_t v7 = v6 - 4;
    BOOL v8 = (unsigned int *)&__CFUniCharBitmapDataArray[2 * v7];
    if (v3 == 108)
    {
      unsigned int v10 = BYTE2(a1);
      if (BYTE2(a1) == 14)
      {
        BOOL v9 = a1 != 1 && a1 - 32 >= 0x60;
        return !v9;
      }
    }

    else
    {
      if (v3 == 12)
      {
        if (BYTE2(a1) == 14)
        {
          BOOL v9 = a1 == 1 || a1 - 128 >= 0xFFFFFFA0;
          return !v9;
        }

        if (BYTE2(a1) - 15 >= 2)
        {
          if (BYTE2(a1) < *v8)
          {
            uint64_t v12 = *(void *)(__CFUniCharBitmapDataArray[2 * v7 + 1] + 8LL * BYTE2(a1));
            if (v12) {
              return ((*(unsigned __int8 *)(v12 + ((unsigned __int16)a1 >> 3)) >> (a1 & 7)) & 1) == 0;
            }
          }

          return 1LL;
        }

        return 0LL;
      }

      unsigned int v10 = BYTE2(a1);
    }

    if (v10 < *v8)
    {
      uint64_t v4 = *(void *)(__CFUniCharBitmapDataArray[2 * v7 + 1] + 8LL * v10);
      if (v4) {
        return (*(unsigned __int8 *)(v4 + ((unsigned __int16)a1 >> 3)) >> (a1 & 7)) & 1;
      }
      return v4;
    }

    return 0LL;
  }

  uint64_t v4 = 1LL;
  if (a1 > 159)
  {
    if (a1 == 160 || a1 == 5760) {
      return v4;
    }
  }

  else if (a1 == 9 || a1 == 32)
  {
    return v4;
  }

  uint64_t v4 = 1LL;
  if (a1 <= 8231)
  {
    return v4;
  }

uint64_t CFUniCharGetBitmapPtrForPlane(unsigned int a1, unsigned int a2)
{
  if (a1 - 16 >= 0x54) {
    unsigned int v2 = a1;
  }
  else {
    unsigned int v2 = a1 + 85;
  }
  if (a1 == 1) {
    unsigned int v2 = 108;
  }
  if (v2 <= 0xF && ((1 << v2) & 0x900F) != 0) {
    return 0LL;
  }
  if (v2 > 0x63) {
    v2 -= 85;
  }
  uint64_t v5 = v2 - 4;
  else {
    return 0LL;
  }
}

uint64_t CFUniCharGetBitmapForPlane(unsigned int a1, unsigned int a2, _BYTE *a3, int a4)
{
  BitmapPtrForPlane = (char *)CFUniCharGetBitmapPtrForPlane(a1, a2);
  if (BitmapPtrForPlane)
  {
    unsigned int v9 = 8193;
    if ((a4 & 1) != 0)
    {
      do
      {
        char v10 = *BitmapPtrForPlane++;
        *a3++ = ~v10;
        --v9;
      }

      while (v9 > 1);
    }

    else
    {
      do
      {
        char v11 = *BitmapPtrForPlane++;
        *a3++ = v11;
        --v9;
      }

      while (v9 > 1);
    }

uint64_t CFUniCharGetNumberOfPlanes(unsigned int a1)
{
  uint64_t result = 15LL;
  if (a1 != 1 && a1 != 108)
  {
    if (a1 >= 4)
    {
      if (a1 == 12)
      {
        return 17LL;
      }

      else
      {
        if (a1 - 16 < 0x54) {
          a1 += 85;
        }
        if (a1 > 0x63) {
          a1 -= 85;
        }
        return LODWORD(__CFUniCharBitmapDataArray[2 * a1 - 8]);
      }
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

uint64_t CFUniCharGetMappingData(unsigned int a1)
{
  return (uint64_t)*(&__CFUniCharMappingTables + a1);
}

uint64_t CFUniCharMapCaseTo( unsigned int a1, __int16 *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, unsigned __int16 *a6)
{
  uint64_t v8 = a4;
  *(void *)&v62[36] = *MEMORY[0x1895F89C0];
  uint64_t v10 = (a1 == 931) & a5;
  char v11 = (unsigned int *)v62;
  unsigned int v58 = a1 & 0xFFFFFFDF;
  BOOL v12 = (a5 & 2) != 0 && a1 == 775;
  int v13 = !v12;
  uint64_t v14 = BYTE2(a1);
  int v15 = 1 << (a1 & 7);
  uint64_t v60 = (unsigned __int16)a1 >> 3;
  int v55 = a4;
  char v16 = __CFUniCharBitmapDataArray;
  while (1)
  {
    if ((_DWORD)v10)
    {
      BOOL v31 = v55 == 0;
      __int16 v32 = 931;
      __int16 v33 = 962;
      goto LABEL_75;
    }

    if (!a6) {
      goto LABEL_51;
    }
    if ((a5 & 0x10) != 0)
    {
      if (a1 == 769) {
        return 0LL;
      }
      if (a1 == 836)
      {
        __int16 v32 = 776;
        goto LABEL_77;
      }

      BOOL v17 = v16;
      uint64_t v18 = v10;
      int IsMemberOf = CFUniCharIsMemberOf(a1, 9u);
      uint64_t v10 = v18;
      char v16 = v17;
      if (IsMemberOf) {
        break;
      }
    }

uint64_t CFUniCharMapTo(unsigned int a1, __int16 *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  uint64_t v5 = a2;
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if ((_DWORD)a4 != 4) {
    return CFUniCharMapCaseTo(a1, a2, a3, a4, a5, 0LL);
  }
  if (a1 >= 0x80 && CFUniCharIsMemberOf(a1, 0x65u))
  {
    uint64_t result = CFUniCharDecomposeCharacter(a1, v11, 10LL);
    if (result >= 1)
    {
      uint64_t v8 = v11;
      uint64_t v9 = result;
      do
      {
        int v10 = *v8++;
        *v5++ = v10;
        --v9;
      }

      while (v9);
    }
  }

  else
  {
    *uint64_t v5 = a1;
    return 1LL;
  }

  return result;
}

uint64_t CFUniCharGetConditionalCaseMappingFlags( unsigned int a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned __int16 *a6, unsigned int a7)
{
  uint64_t v8 = a3;
  *(void *)&v62[36] = *MEMORY[0x1895F89C0];
  if (a1 == 931)
  {
    if (a3 >= 1 && !a5)
    {
      unint64_t v10 = a2 + 2 * a4;
      char v11 = (unsigned __int16 *)(a2 + 2 * a3 - 2);
      while ((unint64_t)v11 >= a2)
      {
        int v13 = v11 - 1;
        int v12 = *v11;
        if ((v12 & 0xFC00) == 0xDC00 && (unint64_t)v13 >= a2)
        {
          int v15 = *v13;
          int v16 = v15 & 0xFC00;
          BOOL v17 = v11 - 2;
          int v18 = v12 - 56613888 + (v15 << 10);
          if (v16 == 55296)
          {
            int v13 = v17;
            int v12 = v18;
          }
        }

        char IsMemberOf = CFUniCharIsMemberOf(v12, 0x6Du);
        char v11 = v13;
        if ((IsMemberOf & 1) == 0)
        {
          if ((CFUniCharIsMemberOf(v12, 7u) & 1) == 0)
          {
            uint64_t result = CFUniCharIsMemberOf(v12, 6u);
            if (!(_DWORD)result) {
              return result;
            }
          }

          break;
        }
      }

      unint64_t v21 = (unsigned __int16 *)(a2 + 2 * v8 + 2);
      do
      {
        unsigned int v23 = v21 + 1;
        int v22 = *v21;
        if ((v22 & 0xFC00) == 0xD800 && (unint64_t)v23 < v10)
        {
          int v25 = *v23;
          BOOL v26 = (v25 & 0xFC00) == 56320;
          uint64_t v27 = v21 + 2;
          int v28 = (v22 << 10) - 56613888 + v25;
          if (v26) {
            unsigned int v23 = v27;
          }
          if (v26) {
            int v22 = v28;
          }
        }

        char v29 = CFUniCharIsMemberOf(v22, 0x6Du);
        unint64_t v21 = v23;
      }

      while ((v29 & 1) != 0);
      if ((CFUniCharIsMemberOf(v22, 7u) & 1) == 0 && (CFUniCharIsMemberOf(v22, 6u) & 1) == 0) {
        return 1LL;
      }
    }

    return 0LL;
  }

  if (!a6) {
    return 0LL;
  }
  unsigned int v31 = *a6;
  if (v31 > 0x746B)
  {
    if (v31 == 31329) {
      goto LABEL_44;
    }
    if (v31 != 29804) {
      goto LABEL_45;
    }
    if (a1 == 775 && (a7 & 6) == 6)
    {
      uint64_t v32 = a3 - 1;
      if (a3 >= 1)
      {
        unint64_t v33 = a2 + 2 * a3;
        if (a3 == 1)
        {
LABEL_43:
          unsigned int v34 = *(unsigned __int16 *)(v33 - 2);
        }

        else
        {
          do
          {
            unint64_t v48 = v33 - 2;
            unsigned int v34 = *(unsigned __int16 *)(v33 - 2);
            if ((v34 & 0xFC00) == 0xDC00)
            {
              if (v8 < 3) {
                goto LABEL_113;
              }
              int v50 = *(unsigned __int16 *)(v33 - 4);
              v33 -= 4LL;
              int v49 = v50;
              if ((v50 & 0xFC00) != 0xD800) {
                goto LABEL_113;
              }
              unsigned int v34 = v34 - 56613888 + (v49 << 10);
              v8 -= 2LL;
            }

            else
            {
              v33 -= 2LL;
              uint64_t v8 = v32;
            }

            if (!CFUniCharIsMemberOf(v34, 8u))
            {
              unint64_t v48 = v33;
              goto LABEL_113;
            }

            if (!(v34 >> 17))
            {
              uint64_t v51 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + HIWORD(v34));
              if (v51)
              {
                if (*(_BYTE *)(v51 + BYTE1(v34))
                  && *(unsigned __int8 *)(v51
                                        + (*(unsigned __int8 *)(v51 + BYTE1(v34)) << 8)
                                        - 256
                                        + v34
                                        + 256) == 230)
                {
                  return 0LL;
                }
              }
            }

            uint64_t v32 = v8 - 1;
          }

          while ((unint64_t)v8 >= 2);
          unint64_t v48 = v33;
          if (v8 == 1) {
            goto LABEL_43;
          }
LABEL_113:
          if ((v34 & 0xFC00) == 0xDC00)
          {
            int v52 = *(unsigned __int16 *)(v48 - 2);
            BOOL v26 = (v52 & 0xFC00) == 55296;
            int v53 = (unsigned __int16)v34 - 56613888 + (v52 << 10);
            if (v26) {
              unsigned int v34 = v53;
            }
          }
        }

        uint64_t v54 = CFUniCharDecomposeCharacter(v34, &v61, 10LL);
        if (v54 < 2) {
          return 2LL;
        }
        int v55 = (int *)v62;
        uint64_t v56 = v54 - 1;
        while (1)
        {
          int v58 = *v55++;
          __int16 v57 = v58;
          uint64_t v59 = BYTE2(v58);
          if (BYTE2(v58) <= 1u)
          {
            uint64_t v60 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + v59);
            if (v60)
            {
              if (*(_BYTE *)(v60 + HIBYTE(v57))
                && *(unsigned __int8 *)(v60
                                      + (*(unsigned __int8 *)(v60 + HIBYTE(v57)) << 8)
                                      - 256
                                      + v57
                                      + 256) == 230)
              {
                break;
              }
            }
          }

          if (!--v56) {
            return 2LL;
          }
        }
      }

      return 0LL;
    }

    if (a5)
    {
      if (a1 - 105 > 1) {
        goto LABEL_45;
      }
      char v36 = (unsigned __int16 *)(a2 + 2 * (a3 + 1));
      uint64_t v37 = a4 - (a3 + 1);
      while (1)
      {
        if (v37 < 1) {
          return 0LL;
        }
        char v38 = v36 + 1;
        int v39 = *v36;
        if (v37 != 1 && (v39 & 0xFC00) == 0xD800 && (unsigned __int16 v40 = v36[2], v36 += 2, (v40 & 0xFC00) == 0xDC00))
        {
          int v39 = (v39 << 10) - 56613888 + *v38;
          v37 -= 2LL;
        }

        else
        {
          char v36 = v38;
          --v37;
        }

        uint64_t result = CFUniCharIsMemberOf(v39, 8u);
        if (!(_DWORD)result) {
          return result;
        }
        if (BYTE2(v39) > 1u) {
          break;
        }
        uint64_t v41 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(v39));
        if (v41)
        {
          if (!*(_BYTE *)(v41 + BYTE1(v39))) {
            break;
          }
          LODWORD(v41) = *(unsigned __int8 *)(v41
                                            + (*(unsigned __int8 *)(v41 + BYTE1(v39)) << 8)
                                            - 256
                                            + v39
                                            + 256);
        }

uint64_t CFUniCharGetUnicodePropertyDataForPlane(unsigned int a1, unsigned int a2)
{
  if (*((_DWORD *)&__CFUniCharUnicodePropertyTable + 4 * a1) <= a2) {
    return 0LL;
  }
  else {
    return *(void *)(*((void *)&__CFUniCharUnicodePropertyTable + 2 * a1 + 1) + 8LL * a2);
  }
}

uint64_t CFUniCharGetNumberOfPlanesForUnicodePropertyData(int a1)
{
  return __CFUniCharUnicodePropertyTable[4 * a1];
}

uint64_t CFUniCharGetUnicodeProperty(int a1, int a2)
{
  if (a2 == 1)
  {
    if (BYTE2(a1) > 0xEu) {
      return 1LL;
    }
    uint64_t v2 = (uint64_t)*(&__CFUniCharBidiProperty + BYTE2(a1));
    if (!v2) {
      return 1LL;
    }
    uint64_t v3 = *(unsigned __int8 *)(v2 + BYTE1(a1));
    if (v3 >= 0x13)
    {
      int v4 = -4864;
      return *(unsigned __int8 *)(v2 + ((v4 + ((_DWORD)v3 << 8)) & 0xFFFFFF00) + a1 + 256);
    }
  }

  else
  {
    if (a2) {
      return 0LL;
    }
    if (BYTE2(a1) > 1u) {
      return 0LL;
    }
    uint64_t v2 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(a1));
    if (!v2)
    {
      return 0LL;
    }

    else
    {
      uint64_t v3 = *(unsigned __int8 *)(v2 + BYTE1(a1));
      if (*(_BYTE *)(v2 + BYTE1(a1)))
      {
        int v4 = -256;
        return *(unsigned __int8 *)(v2 + ((v4 + ((_DWORD)v3 << 8)) & 0xFFFFFF00) + a1 + 256);
      }
    }
  }

  return v3;
}

uint64_t CFUniCharFillDestinationBuffer( unsigned int *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, int a6)
{
  uint64_t v6 = *a5;
  if (a6 != 2)
  {
    if (a6)
    {
      uint64_t v7 = *a3;
      if (a2 >= 1)
      {
        uint64_t v11 = v6 + a2;
        unint64_t v20 = a2 + 1;
        do
        {
          int v22 = *a1++;
          int v21 = v22;
          if (a4)
          {
            if (v6 >= a4) {
              return 0LL;
            }
            *(_DWORD *)uint64_t v7 = v21;
            v7 += 4LL;
          }

          --v20;
          ++v6;
        }

        while (v20 > 1);
        goto LABEL_47;
      }
    }

    else
    {
      uint64_t v7 = *a3;
      if (a2 >= 1)
      {
        unint64_t v8 = a2 + 1;
        do
        {
          unsigned int v10 = *a1++;
          unsigned int v9 = v10;
          if (v10 < 0x10000)
          {
            uint64_t v11 = v6 + 1;
            if (a4)
            {
              if (v6 >= a4) {
                return 0LL;
              }
              *(_WORD *)uint64_t v7 = v9;
              v7 += 2LL;
            }
          }

          else
          {
            uint64_t v11 = v6 + 2;
            if (a4)
            {
              if (v11 > a4) {
                return 0LL;
              }
              *(_WORD *)uint64_t v7 = ((v9 + 67043328) >> 10) - 10240;
              *(_WORD *)(v7 + 2) = v9 & 0x3FF | 0xDC00;
              v7 += 4LL;
            }
          }

          --v8;
          uint64_t v6 = v11;
        }

        while (v8 >= 2);
        goto LABEL_47;
      }
    }

uint64_t CFUniCharDecomposeCharacter(unsigned int a1, unsigned int *a2, uint64_t a3)
{
  if (a1 - 44032 > 0x2BA4) {
    return __CFUniCharRecursivelyDecomposeCharacter(a1, a2, a3);
  }
  uint64_t v3 = 2LL;
  if (v3 > a3) {
    return 0LL;
  }
  *a2 = ((28533 * (unsigned __int16)(a1 + 21504)) >> 24) | 0x1100;
  a2[1] = (unsigned __int16)(a1 + 21504) % 0x24Cu / 0x1C + 4449;
  a2[2] = (unsigned __int16)((unsigned __int16)(a1 + 21504) % 0x1Cu + 4519);
  return 3LL;
}

uint64_t __CFUniCharRecursivelyDecomposeCharacter(unsigned int a1, _DWORD *a2, uint64_t a3)
{
  int v4 = a2;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a1 - 195102 < 0xFFFD06A2)
  {
LABEL_8:
    unsigned int v8 = 0;
    goto LABEL_9;
  }

  uint64_t v5 = (char *)&__CFUniCharDecompositionTable;
  uint64_t v6 = (char *)&__CFUniCharDecompositionTable + 16480;
  while (1)
  {
    uint64_t v7 = &v5[8 * ((v6 - v5) >> 4)];
    if (*(_DWORD *)v7 <= a1) {
      break;
    }
    uint64_t v6 = v7 - 8;
LABEL_7:
    if (v5 > v6) {
      goto LABEL_8;
    }
  }

  if (*(_DWORD *)v7 < a1)
  {
    uint64_t v5 = v7 + 8;
    goto LABEL_7;
  }

  unsigned int v8 = *((_DWORD *)v7 + 1);
LABEL_9:
  uint64_t v9 = HIBYTE(v8) & 0x1F;
  int v18 = v8 & 0xFFFFFF;
  unsigned int v10 = (int *)((char *)&__CFUniCharMultipleDecompositionTable + 4 * (v8 & 0xFFFFFF));
  uint64_t v11 = &v18;
  if ((v8 & 0x1E000000) != 0) {
    uint64_t v11 = (int *)((char *)&__CFUniCharMultipleDecompositionTable + 4 * (v8 & 0xFFFFFF));
  }
  uint64_t v12 = a3 - v9;
  if (a3 < v9) {
    return 0LL;
  }
  if ((v8 & 0x40000000) == 0)
  {
    uint64_t v13 = 0LL;
    goto LABEL_23;
  }

  uint64_t v13 = __CFUniCharRecursivelyDecomposeCharacter(*v11, a2, v12);
  if (!v13 || v13 + v9 - 1 > a3) {
    return 0LL;
  }
  unsigned int v16 = &v18;
  uint64_t v11 = v16 + 1;
  v4 += v13;
  --v9;
LABEL_23:
  for (uint64_t result = v13 + v9; v9; --v9)
  {
    int v17 = *v11++;
    *v4++ = v17;
  }

  return result;
}

BOOL CFUniCharDecomposeWithErrorLocation( unsigned __int16 *a1, uint64_t a2, void *a3, unsigned int *a4, uint64_t a5, void *a6, int a7, int a8, char a9, uint64_t *a10)
{
  uint64_t v12 = a6;
  uint64_t v13 = a5;
  unsigned int v14 = a3;
  uint64_t v15 = a2;
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t v51 = 0LL;
  int v52 = a4;
  if (a10) {
    *a10 = -1LL;
  }
  uint64_t v16 = a2;
  if (a2 < 1) {
    goto LABEL_90;
  }
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  if (a9) {
    uint64_t v19 = &__CFUniCharHfsPlusDecomposableCharacterSetBitmapPlane0_0;
  }
  else {
    uint64_t v19 = &__CFUniCharCanonicalDecomposableCharacterSetBitmapPlane0_0;
  }
  uint64_t v49 = (uint64_t)v19;
  uint64_t v44 = 32LL;
  unint64_t v20 = a2;
  int v21 = a1;
  int v22 = (unsigned int *)v53;
  uint64_t v16 = a2;
LABEL_8:
  unsigned int v23 = v21;
  while (1)
  {
    unsigned int v25 = *v21++;
    unsigned int v24 = v25;
    if (v25 <= 0x7F)
    {
      if (v18 < 1)
      {
        unint64_t v20 = v16;
      }

      else
      {
        if (v18 != 1) {
          __CFUniCharPrioritySort(v22, v18);
        }
        if (!CFUniCharFillDestinationBuffer(v22, v18, (uint64_t *)&v52, v13, &v51, a8))
        {
LABEL_74:
          unsigned int v14 = a3;
          uint64_t v12 = a6;
          uint64_t v15 = a2;
          goto LABEL_80;
        }

        uint64_t v18 = 0LL;
        uint64_t v17 = 0LL;
      }

      uint64_t v33 = v51;
      if (v13 < 1) {
        goto LABEL_65;
      }
      if (v51 >= v13)
      {
        uint64_t v16 = v20;
LABEL_87:
        unsigned int v14 = a3;
        uint64_t v12 = a6;
        uint64_t v15 = a2;
        goto LABEL_88;
      }

      if (a8)
      {
        if (a8 != 3)
        {
          if (a8 == 2)
          {
            *(_BYTE *)int v52 = v24;
            int v52 = (unsigned int *)((char *)v52 + 1);
            uint64_t v33 = v51;
          }

          goto LABEL_65;
        }

        int v39 = v52;
        *int v52 = v24;
        char v38 = v39 + 1;
      }

      else
      {
        uint64_t v37 = v52;
        *(_WORD *)int v52 = v24;
        char v38 = (unsigned int *)((char *)v37 + 2);
      }

      int v52 = v38;
LABEL_65:
      uint64_t v16 = v20 - 1;
      uint64_t v51 = v33 + 1;
      goto LABEL_71;
    }

    if ((v24 & 0xFC00) == 0xD800) {
      break;
    }
    if ((v24 & 0xFC00) == 0xDC00 && a8 != 0) {
      goto LABEL_76;
    }
LABEL_20:
    if (a7)
    {
      if (!(v24 >> 17))
      {
        uint64_t v28 = (uint64_t)*(&__CFUniCharCombiningPriorityTable_0 + HIWORD(v24));
        if (*(_BYTE *)(v28 + BYTE1(v24)))
        {
          if (*(_BYTE *)(v28 + (*(unsigned __int8 *)(v28 + BYTE1(v24)) << 8) - 256 + v24 + 256))
          {
            uint64_t v32 = v44;
            if (v18 + 1 >= v44)
            {
              uint64_t v32 = v44 + 32;
              unsigned int v34 = (unsigned int *)CFAllocatorAllocate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  4 * (v44 + 32),  0LL);
              size_t v35 = 4 * v44;
              int v45 = v34;
              memmove(v34, v22, v35);
              int v22 = v45;
            }

            uint64_t BitmapPtrForPlane = v49;
            if ((v24 < 0x10000 || (uint64_t BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v24))) != 0)
              && ((*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v24 >> 3)) >> (v24 & 7)) & 1) != 0)
            {
              v18 += CFUniCharDecomposeCharacter(v24, &v22[v18], v32 - v18);
            }

            else
            {
              v22[v18++] = v24;
            }

            uint64_t v13 = a5;
LABEL_68:
            uint64_t v40 = 1LL;
            if (HIWORD(v24)) {
              uint64_t v40 = 2LL;
            }
            v17 += v40;
            uint64_t v44 = v32;
LABEL_71:
            unint64_t v20 = v16 - v17;
            if (v16 > v17) {
              goto LABEL_8;
            }
            goto LABEL_79;
          }
        }
      }
    }

    if (v18 < 1)
    {
      unint64_t v20 = v16;
      uint64_t v13 = a5;
    }

    else
    {
      uint64_t v13 = a5;
      if (v18 != 1) {
        __CFUniCharPrioritySort(v22, v18);
      }
      uint64_t v17 = 0LL;
    }

    uint64_t v29 = v49;
    if ((v24 < 0x10000 || (uint64_t v29 = CFUniCharGetBitmapPtrForPlane(9u, BYTE2(v24))) != 0)
      && ((*(unsigned __int8 *)(v29 + ((unsigned __int16)v24 >> 3)) >> (v24 & 7)) & 1) != 0)
    {
      uint64_t v30 = CFUniCharDecomposeCharacter(v24, v22, 32LL);
      uint64_t v18 = v30;
      if (a7 && v30 != 1)
      {
        uint64_t v16 = v20;
        uint64_t v32 = v44;
        goto LABEL_68;
      }
    }

    else
    {
      *int v22 = v24;
      uint64_t v18 = 1LL;
    }

    if (!CFUniCharFillDestinationBuffer(v22, v18, (uint64_t *)&v52, v13, &v51, a8))
    {
      uint64_t v16 = v20;
      goto LABEL_79;
    }

    uint64_t v18 = 0LL;
    uint64_t v31 = -2LL;
    if (!HIWORD(v24)) {
      uint64_t v31 = -1LL;
    }
    uint64_t v16 = v20 + v31;
    unsigned int v23 = v21;
    unint64_t v20 = v16 - v17;
    if (v16 <= v17) {
      goto LABEL_87;
    }
  }

  if (v20 >= 2)
  {
    int v27 = *v21;
    if ((v27 & 0xFC00) == 0xDC00)
    {
      int v21 = v23 + 2;
      unsigned int v24 = v27 + (v24 << 10) - 56613888;
      goto LABEL_20;
    }
  }

  if (!a8) {
    goto LABEL_20;
  }
  unsigned int v23 = v21;
LABEL_76:
  if (a10) {
    *a10 = v23 - a1;
  }
  uint64_t v13 = a5;
LABEL_79:
  unsigned int v14 = a3;
  uint64_t v12 = a6;
  uint64_t v15 = a2;
  if (v18 < 1) {
    goto LABEL_88;
  }
LABEL_80:
  else {
    uint64_t v41 = 0LL;
  }
  v16 -= v41;
LABEL_88:
LABEL_90:
  if (v14) {
    void *v14 = v15 - v16;
  }
  if (v12) {
    void *v12 = v51;
  }
  return v16 < 1;
}

BOOL CFUniCharDecompose( unsigned __int16 *a1, uint64_t a2, void *a3, unsigned int *a4, uint64_t a5, void *a6, int a7, int a8, char a9)
{
  return CFUniCharDecomposeWithErrorLocation(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0LL);
}

uint64_t CFUniCharCompatibilityDecompose(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a2 >= 1)
  {
    uint64_t v5 = a1;
    unint64_t v6 = (unint64_t)&a1[a2];
    do
    {
      unsigned int v7 = *v5;
      if (CFUniCharIsMemberOf(*v5, 0x64u))
      {
        uint64_t v8 = __CFUniCharRecursivelyCompatibilityDecomposeCharacter(v7, v15);
        uint64_t v3 = v3 + v8 - 1;
        if (v3 > a3) {
          return 0LL;
        }
        if (v8 > 1)
        {
          unint64_t v9 = (v6 - (unint64_t)v5) >> 2;
          do
            v5[v8 - 2 + v9] = v5[v9 - 1];
          while (v9-- > 2);
        }

        if (v8 >= 1)
        {
LABEL_10:
          unint64_t v11 = v8 + 1;
          uint64_t v12 = v15;
          do
          {
            int v13 = *v12++;
            *v5++ = v13;
            --v11;
          }

          while (v11 > 1);
        }
      }

      else
      {
        ++v5;
      }
    }

    while ((unint64_t)v5 < v6);
  }

  return v3;
}

uint64_t __CFUniCharRecursivelyCompatibilityDecomposeCharacter(unsigned int a1, _DWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a1 - 130042 >= 0xFFFE04A6)
  {
    uint64_t v3 = (char *)&__CFUniCharCompatibilityDecompositionTable;
    int v4 = (char *)&__CFUniCharCompatibilityDecompositionTable + 30360;
    while (1)
    {
      uint64_t v5 = &v3[8 * ((v4 - v3) >> 4)];
      if (*(_DWORD *)v5 <= a1) {
        break;
      }
      int v4 = v5 - 8;
LABEL_7:
      if (v3 > v4) {
        return 0LL;
      }
    }

    if (*(_DWORD *)v5 < a1)
    {
      uint64_t v3 = v5 + 8;
      goto LABEL_7;
    }

    unint64_t v8 = *((unsigned int *)v5 + 1);
    uint64_t v6 = (v8 >> 24) & 0x1F;
    uint64_t v9 = v8 & 0xFFFFFF;
    int v18 = v9;
    if ((_DWORD)v6)
    {
      unsigned int v10 = (unsigned int *)((char *)&__CFUniCharCompatibilityMultipleDecompositionTable + 4 * v9);
      if ((_DWORD)v6 == 1) {
        unint64_t v11 = (unsigned int *)&v18;
      }
      else {
        unint64_t v11 = v10;
      }
      uint64_t v12 = v6 + 1;
      for (uint64_t i = 33 - v6; ; ++i)
      {
        unsigned int v15 = *v11++;
        uint64_t v14 = v15;
        uint64_t BitmapPtrForPlane = (unsigned __int8 *)&__CFUniCharCanonicalDecomposableCharacterSetBitmapPlane0_0;
        if ((v15 < 0x10000
           || (uint64_t BitmapPtrForPlane = (unsigned __int8 *)CFUniCharGetBitmapPtrForPlane(9u, BYTE2(v14))) != 0LL)
          && ((BitmapPtrForPlane[(unsigned __int16)v14 >> 3] >> (v14 & 7)) & 1) != 0)
        {
          uint64_t v17 = __CFUniCharRecursivelyDecomposeCharacter(v14, a2, i);
        }

        else
        {
          if (!CFUniCharIsMemberOf(v14, 0x64u))
          {
            *a2++ = v14;
            goto LABEL_23;
          }

          uint64_t v17 = __CFUniCharRecursivelyCompatibilityDecomposeCharacter(v14, a2);
        }

        a2 += v17;
        uint64_t v6 = v6 + v17 - 1;
LABEL_23:
      }
    }
  }

  return 0LL;
}

unsigned int *__CFUniCharPrioritySort(unsigned int *result, uint64_t a2)
{
  unint64_t v2 = (unint64_t)&result[a2];
  if (a2 >= 1)
  {
    do
    {
      unint64_t v3 = *result;
      if (!(v3 >> 17))
      {
        uint64_t v4 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v3 >> 13) & 0x7FFF8));
        if (*(_BYTE *)(v4 + BYTE1(v3)))
        {
        }
      }

      ++result;
    }

    while ((unint64_t)result < v2);
  }

  if ((uint64_t)(v2 - (void)result) >= 5)
  {
    do
    {
      unint64_t v5 = *result;
      if (v5 >> 17)
      {
        unsigned int v7 = 0;
      }

      else
      {
        uint64_t v6 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v5 >> 13) & 0x7FFF8));
        unsigned int v7 = *(unsigned __int8 *)(v6 + BYTE1(v5));
        if (*(_BYTE *)(v6 + BYTE1(v5))) {
          unsigned int v7 = *(unsigned __int8 *)(v6 + (v7 << 8) - 256 + v5 + 256);
        }
      }

      char v8 = 0;
      uint64_t v9 = result + 1;
      do
      {
        unint64_t v10 = *v9;
        if (v10 >> 17
          || (uint64_t v11 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v10 >> 13) & 0x7FFF8)),
              !*(_BYTE *)(v11 + BYTE1(v10))))
        {
          unsigned int v12 = 0;
        }

        else
        {
          unsigned int v12 = *(unsigned __int8 *)(v11
                                   + (*(unsigned __int8 *)(v11 + BYTE1(v10)) << 8)
                                   - 256
                                   + v10
                                   + 256);
        }

        if (v7 > v12)
        {
          int v13 = *(v9 - 1);
          *(v9 - 1) = v10;
          *uint64_t v9 = v13;
          char v8 = 1;
        }

        ++v9;
        unsigned int v7 = v12;
      }

      while ((unint64_t)v9 < v2);
    }

    while ((v8 & 1) != 0);
  }

  return result;
}

uint64_t (**__CFStringEncodingGetTraditionalChineseConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter_1)
  {
    __CFStringEncodingIsDecomposableCharacter_1 = (_UNKNOWN *)a2(1LL);
    __CFStringEncodingDecomposeCharacter_1 = (_UNKNOWN *)a2(2LL);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_3 = (_UNKNOWN *)a2(3LL);
    __CFStringEncodingPrecomposeLatinCharacter_5 = (_UNKNOWN *)a2(4LL);
  }

  uint64_t v4 = __CFConverterMacTraditionalChinese;
  if (a1 != 2) {
    uint64_t v4 = 0LL;
  }
  if (a1 == 2563) {
    return __CFConverterBig5;
  }
  else {
    return v4;
  }
}

uint64_t __CFToBig5(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 < 0x80)
  {
    uint64_t result = 1LL;
    goto LABEL_3;
  }

  if (a2 < 0xA2) {
    return 0LL;
  }
  uint64_t v4 = (unsigned __int16 *)&__CFToBig5CharMap;
  unint64_t v5 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + 42642);
  while (1)
  {
    uint64_t v6 = (uint64_t)(0x8E38E38E38E38E39LL * (v5 - v4)) >> 1;
    unsigned int v7 = &v4[9 * v6];
    unsigned int v8 = *v7;
    if (v8 <= a2) {
      break;
    }
    unint64_t v5 = v7 - 9;
LABEL_10:
    if (v4 > v5) {
      return 0LL;
    }
  }

  if (v8 + 8 <= a2)
  {
    uint64_t v4 = v7 + 9;
    goto LABEL_10;
  }

  LOWORD(a2) = v4[9 * v6 + 1 + (int)(a2 - v8)];
  *a3++ = BYTE1(a2);
  uint64_t result = 2LL;
LABEL_3:
  *a3 = a2;
  return result;
}

uint64_t __CFFromBig5(uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4)
{
  int v4 = *a2;
  if ((*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1LL;
  }

  if (a3 < 2) {
    return 0LL;
  }
  unsigned int v6 = a2[1] | (v4 << 8);
  unsigned int v7 = (unsigned __int16 *)&__CFFromBig5CharMap;
  unsigned int v8 = (unsigned __int16 *)((char *)&__CFFromBig5CharMap + 28248);
  while (1)
  {
    uint64_t v9 = (0xF83E0F83E0F83E1LL * (v8 - v7)) >> 1;
    unint64_t v10 = &v7[33 * v9];
    unsigned int v11 = *v10;
    if (v11 <= v6) {
      break;
    }
    unsigned int v8 = v10 - 33;
LABEL_10:
    if (v7 > v8) {
      goto LABEL_11;
    }
  }

  if (v11 + 32 <= v6)
  {
    unsigned int v7 = v10 + 33;
    goto LABEL_10;
  }

  unsigned __int16 v12 = v7[33 * v9 + 1 + (int)(v6 - v11)];
  if (!v12)
  {
LABEL_11:
    *a4 = -3;
    return 0LL;
  }

  *a4 = v12;
  if (v12 == 65533) {
    return 0LL;
  }
  return 2LL;
}

uint64_t __CFToBig5Len(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    unsigned int v4 = *a2++;
    if (v4 < 0x80) {
      uint64_t v5 = 1LL;
    }
    else {
      uint64_t v5 = 2LL;
    }
    result += v5;
  }

  return result;
}

uint64_t __CFFromBig5Len(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    BOOL v5 = a3 == 1 || *a2 >= 0;
    BOOL v6 = !v5;
    if (v5) {
      uint64_t v7 = 1LL;
    }
    else {
      uint64_t v7 = 2LL;
    }
    a2 += v7;
    if (v6) {
      uint64_t v8 = -2LL;
    }
    else {
      uint64_t v8 = -1LL;
    }
    ++result;
    BOOL v9 = __OFADD__(v8, a3);
    a3 += v8;
  }

  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFToBig5Precompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  unsigned int v9 = *a2;
  if (v9 > 0x7F)
  {
    int v11 = a2[1];
    if (v9 == 12454) {
      int v12 = 12532;
    }
    else {
      int v12 = v9 + 1;
    }
    int v13 = v9 + 2;
    if (v11 != 12442) {
      int v13 = 65533;
    }
    if (v11 == 12441) {
      unsigned int v14 = v12;
    }
    else {
      unsigned int v14 = v13;
    }
    if ((v9 & 0xFFFFFFDF) == 0x418) {
      int v15 = v9 + 1;
    }
    else {
      int v15 = -3;
    }
    if (v9 == 1077) {
      int v16 = 1105;
    }
    else {
      int v16 = -3;
    }
    if (v9 == 1045) {
      unsigned int v17 = 1025;
    }
    else {
      unsigned int v17 = v16;
    }
    if (v11 != 776) {
      unsigned int v17 = 65533;
    }
    if (v11 == 774) {
      unsigned int v17 = v15;
    }
    if (a2[1] <= 0x3098u) {
      uint64_t v10 = v17;
    }
    else {
      uint64_t v10 = v14;
    }
  }

  else
  {
    uint64_t v10 = __CFStringEncodingPrecomposeLatinCharacter_5(a2, a3, 0LL);
  }

  int v18 = __CFToBig5(v10, (unsigned __int16)v10, v22);
  char v19 = v22[0];
  if (v18) {
    BOOL v20 = v22[0] == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    uint64_t result = 2LL;
    *a6 = 2LL;
    if (!a5) {
      return result;
    }
    if (a5 >= 2)
    {
      *a4 = v19;
      a4[1] = v22[1];
      return 2LL;
    }
  }

  return 0LL;
}

uint64_t __CFIsValidCombiningCharTraditionalChinese(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1LL << (a1 - 6)) & 0x4000000000005LL) != 0
    || (a1 - 12441) < 2)
  {
    return 1LL;
  }

  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_3();
  }

uint64_t __CFToMacTraditionalChinese( char a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    uint64_t v11 = 0LL;
    goto LABEL_159;
  }

  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  int v13 = (unsigned int (**)(void, uint64_t, void *))&unk_18C539000;
  uint64_t v14 = 0xA692u;
  while (1)
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_159;
      }
      uint64_t v15 = *a2;
      if ((v15 & 0xFFF0) != 0xF870) {
        goto LABEL_159;
      }
    }

    else
    {
      uint64_t v15 = *a2;
    }

    if (v15 < 0x80 || (_DWORD)v15 == 160 || a1 < 0 && (unsigned __int16)(v15 - 131) <= 0x1Cu)
    {
      ++v11;
      if (a5) {
        *a4++ = v15;
      }
      goto LABEL_41;
    }

    int v16 = (unsigned __int16 *)&__CFToMacTraditionalChineseMap;
    unsigned int v17 = (unsigned __int16 *)&unk_180D631EA;
    while (1)
    {
      uint64_t v18 = ((char *)v17 - (char *)v16) >> 3;
      char v19 = &v16[2 * v18];
      unsigned int v20 = *v19;
      unsigned int v17 = v19 - 2;
LABEL_21:
      if (v16 > v17) {
        goto LABEL_22;
      }
    }

    if (v20 < v15)
    {
      int v16 = v19 + 2;
      goto LABEL_21;
    }

    unsigned int v26 = v16[2 * v18 + 1];
    if (v26 > 0xFF)
    {
      if (a5)
      {
        if (v11 + 2 > a5) {
          goto LABEL_159;
        }
        *a4 = BYTE1(v26);
        a4[1] = v26;
        a4 += 2;
      }

      v11 += 2LL;
      goto LABEL_41;
    }

    ++v11;
    if (a5) {
      *a4++ = v26;
    }
LABEL_41:
    ++a2;
    if (++v12 == a3)
    {
      uint64_t v12 = a3;
      goto LABEL_159;
    }
  }

LABEL_151:
          char v44 = -95;
          goto LABEL_155;
        }

        if (*(a2 - 1) > 0x3014u)
        {
          switch(v42)
          {
            case 0x3015u:
              char v43 = -92;
              goto LABEL_151;
            case 0x5341u:
              char v43 = -52;
              break;
            case 0x5345u:
              char v43 = -50;
              break;
            default:
              goto LABEL_159;
          }
        }

        else
        {
          if (v42 == 92)
          {
            if (!a5) {
              goto LABEL_41;
            }
            char v43 = 0x80;
LABEL_157:
            *(a4 - 1) = v43;
            goto LABEL_41;
          }

          if (v42 != 9474)
          {
            if (v42 != 12308) {
              goto LABEL_159;
            }
            char v43 = -93;
            goto LABEL_151;
          }

          char v43 = 121;
        }

        char v44 = -94;
        goto LABEL_155;
      default:
        goto LABEL_159;
    }
  }

uint64_t __CFFromMacTraditionalChinese( uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  unint64_t v9 = a3;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  int v14 = a1 & 0xC0;
  if ((a1 & 0x200) != 0) {
    uint64_t v15 = 1LL;
  }
  else {
    uint64_t v15 = 2LL;
  }
LABEL_5:
  if (a5 && v12 >= a5) {
    return v13;
  }
  int v16 = (char)*a2;
  int v17 = *a2;
  if (v17 != 128)
  {
    if ((v17 + 3) <= 0x85u)
    {
      if (*a2 > 0xFCu)
      {
        if (v17 == 253)
        {
          LOWORD(v17) = 169;
        }

        else if (v17 == 254)
        {
          LOWORD(v17) = 8482;
        }

        else
        {
          LOWORD(v17) = 8230;
        }

        goto LABEL_11;
      }

      if (v17 == 129)
      {
        if ((a1 & 0x200) == 0)
        {
          LOWORD(v17) = -1920;
          goto LABEL_11;
        }
      }

      else if (v17 == 130 && (a1 & 0x200) == 0)
      {
        LOWORD(v17) = -1919;
LABEL_11:
        if (a5) {
          *a4++ = v17;
        }
        ++v12;
        goto LABEL_14;
      }

      uint64_t v18 = 1LL;
      goto LABEL_16;
    }

    if (v9 < 2) {
      return v13;
    }
    if (v17 != 161)
    {
      if (v17 == 162)
      {
        unsigned int v20 = a2[1];
        if (v20 > 0xCB)
        {
          if (v20 == 204)
          {
            if ((a1 & 0x200) != 0)
            {
              __int16 v22 = 21313;
              goto LABEL_157;
            }

            int v21 = 1396832383;
            goto LABEL_92;
          }

          if (v20 == 206)
          {
            if ((a1 & 0x200) != 0)
            {
              __int16 v22 = 21317;
              goto LABEL_157;
            }

            int v21 = 1397094527;
            goto LABEL_92;
          }
        }

        else
        {
          if (v20 == 64)
          {
            if ((a1 & 0x200) != 0)
            {
              __int16 v22 = -196;
              goto LABEL_157;
            }

            int v21 = -12781441;
            goto LABEL_92;
          }

          if (v20 == 121)
          {
            if ((a1 & 0x200) != 0)
            {
              __int16 v22 = 9474;
              goto LABEL_157;
            }

            int v21 = 620951679;
            goto LABEL_92;
          }
        }
      }

      else
      {
        unsigned int v20 = a2[1];
      }

      goto LABEL_46;
    }

    unsigned int v20 = a2[1];
    if (v20 <= 0x7D)
    {
      __int16 v22 = 183;
      switch(a2[1])
      {
        case 'E':
          goto LABEL_157;
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'L':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
          goto LABEL_46;
        case 'K':
          __int16 v22 = 8943;
          goto LABEL_157;
        case 'M':
          if ((a1 & 0x200) == 0)
          {
            int v21 = -15927171;
            goto LABEL_92;
          }

          __int16 v22 = -244;
          goto LABEL_157;
        case 'N':
          if ((a1 & 0x200) == 0)
          {
            int v21 = 805435517;
            goto LABEL_92;
          }

          __int16 v22 = 12289;
          goto LABEL_157;
        case 'O':
          if ((a1 & 0x200) != 0) {
            goto LABEL_139;
          }
          int v21 = -15796099;
          goto LABEL_92;
        case 'P':
          if ((a1 & 0x200) == 0)
          {
            int v21 = -15796098;
            goto LABEL_92;
          }

LABEL_139:
          __int16 v22 = -242;
          goto LABEL_157;
        case 'Q':
          if ((a1 & 0x200) == 0)
          {
            int v21 = -14944131;
            goto LABEL_92;
          }

          __int16 v22 = -229;
          goto LABEL_157;
        case 'R':
          if ((a1 & 0x200) == 0)
          {
            int v21 = -15009667;
            goto LABEL_92;
          }

          __int16 v22 = -230;
          goto LABEL_157;
        case 'S':
          if ((a1 & 0x200) == 0)
          {
            int v21 = -14681987;
            goto LABEL_92;
          }

          __int16 v22 = -225;
          goto LABEL_157;
        case 'T':
          if ((a1 & 0x200) == 0)
          {
            int v21 = -16648067;
            goto LABEL_92;
          }

          __int16 v22 = -255;
          goto LABEL_157;
        case 'Z':
          if ((a1 & 0x200) != 0) {
            goto LABEL_138;
          }
          int v21 = -12584833;
          goto LABEL_92;
        default:
          if (v20 != 125) {
            goto LABEL_46;
          }
          if ((a1 & 0x200) == 0)
          {
            int v21 = -16189313;
            goto LABEL_92;
          }

          __int16 v22 = -248;
          break;
      }

      goto LABEL_157;
    }

    if (a2[1] <= 0xC2u)
    {
      switch(a2[1])
      {
        case 0xA1u:
          if ((a1 & 0x200) != 0)
          {
            __int16 v22 = -165;
            goto LABEL_157;
          }

          int v21 = -10749825;
          break;
        case 0xA2u:
          if ((a1 & 0x200) == 0)
          {
            int v21 = -10618753;
            break;
          }

          __int16 v22 = -163;
          goto LABEL_157;
        case 0xA3u:
          if ((a1 & 0x200) == 0)
          {
            int v21 = 806680703;
            break;
          }

          __int16 v22 = 12308;
          goto LABEL_157;
        case 0xA4u:
          if ((a1 & 0x200) == 0)
          {
            int v21 = 806746239;
            break;
          }

          __int16 v22 = 12309;
          goto LABEL_157;
        default:
          if (v20 != 126) {
            goto LABEL_46;
          }
          if ((a1 & 0x200) == 0)
          {
            int v21 = -16123777;
            break;
          }

          __int16 v22 = -247;
          goto LABEL_157;
      }

uint64_t __CFFromMacTraditionalChineseLen(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    if ((*a2 & 0x80) != 0
      && (*a2 - 129 <= 0x1F ? (BOOL v4 = ((1 << (*a2 + 127)) & 0x80000003) == 0) : (BOOL v4 = 1),
          v4 ? (BOOL v5 = (unint64_t)a3 >= 2) : (BOOL v5 = 0),
          v5 && *a2 < 0xFDu))
    {
      int v6 = *a2;
      uint64_t v7 = a3 - 1;
      if (v6 == 128) {
        uint64_t v8 = a2 + 1;
      }
      else {
        uint64_t v8 = a2 + 2;
      }
      if (v6 == 128)
      {
        uint64_t v9 = result + 1;
      }

      else
      {
        uint64_t v7 = a3 - 2;
        uint64_t v9 = result;
      }

      if (v6 == 161) {
        a2 += 2;
      }
      else {
        a2 = v8;
      }
      if (v6 == 161) {
        a3 -= 2LL;
      }
      else {
        a3 = v7;
      }
      if (v6 == 161) {
        ++result;
      }
      else {
        uint64_t result = v9;
      }
    }

    else
    {
      ++a2;
      --a3;
    }

    ++result;
  }

  while (a3 > 0);
  return result;
}

uint64_t CFUniCharPrecomposeCharacter(unsigned int a1, unsigned int a2)
{
  if (a2 - 71985 < 0xFFFEE9CF) {
    return 65533LL;
  }
  unint64_t v2 = (unsigned int *)&__CFUniCharPrecompSourceTable;
  unint64_t v3 = (unsigned int *)&unk_180D633E0;
  while (1)
  {
    uint64_t v4 = ((char *)v3 - (char *)v2) >> 4;
    BOOL v5 = &v2[2 * v4];
    if (*v5 <= a2) {
      break;
    }
    unint64_t v3 = v5 - 2;
LABEL_7:
    if (v2 > v3) {
      return 65533LL;
    }
  }

  if (*v5 < a2)
  {
    unint64_t v2 = v5 + 2;
    goto LABEL_7;
  }

  unsigned int v7 = v2[2 * v4 + 1];
  if (!v7) {
    return 65533LL;
  }
  uint64_t v8 = (unsigned __int16)v2[2 * v4 + 1];
  if ((v7 & 0x80000000) != 0)
  {
    int v14 = (char *)&__CFUniCharNonBMPPrecompDestinationTable + 4 * v8;
    if (*(_DWORD *)v14 > a1) {
      return 65533LL;
    }
    uint64_t v15 = &v14[8 * (HIWORD(v7) & 0x7FFF) - 8];
    if (*(_DWORD *)v15 < a1) {
      return 65533LL;
    }
    while (1)
    {
      uint64_t v16 = (v15 - v14) >> 4;
      int v17 = &v14[8 * v16];
      if (*(_DWORD *)v17 <= a1)
      {
        if (*(_DWORD *)v17 >= a1)
        {
          uint64_t result = *(unsigned int *)&v14[8 * v16 + 4];
LABEL_30:
          if (!(_DWORD)result) {
            return 65533LL;
          }
          return result;
        }

        int v14 = v17 + 8;
      }

      else
      {
        uint64_t v15 = v17 - 8;
      }

      if (v14 > v15) {
        return 65533LL;
      }
    }
  }

  uint64_t v9 = (char *)&__CFUniCharBMPPrecompDestinationTable + 4 * v8;
  if (*(unsigned __int16 *)v9 <= (unsigned __int16)a1)
  {
    uint64_t v10 = (unsigned __int16 *)&v9[4 * HIWORD(v7) - 4];
    if (*v10 >= (unsigned __int16)a1)
    {
      do
      {
        uint64_t v11 = ((char *)v10 - v9) >> 3;
        uint64_t v12 = (unsigned __int16 *)&v9[4 * v11];
        unsigned int v13 = *v12;
        if (v13 <= (unsigned __int16)a1)
        {
          if (v13 >= (unsigned __int16)a1)
          {
            uint64_t result = *(unsigned __int16 *)&v9[4 * v11 + 2];
            goto LABEL_30;
          }

          uint64_t v9 = (char *)(v12 + 2);
        }

        else
        {
          uint64_t v10 = v12 - 2;
        }
      }

      while (v9 <= (char *)v10);
    }
  }

  return 65533LL;
}

uint64_t CFUniCharPrecompose(unsigned __int16 *a1, uint64_t a2, void *a3, _WORD *a4, uint64_t a5, void *a6)
{
  int v6 = a6;
  unsigned int v7 = a3;
  if (a2 < 1)
  {
    uint64_t v28 = 0LL;
    uint64_t v12 = a2;
    goto LABEL_100;
  }

  unsigned int v9 = 0;
  uint64_t v10 = 0LL;
  unsigned int v11 = 0;
  char v49 = 1;
  uint64_t v12 = a2;
  int v52 = a4;
  int v50 = a4;
  int v13 = 65533;
  while (1)
  {
    unsigned int v14 = *a1;
    if (v12 == 1 || (v14 & 0xFC00) != 0xD800)
    {
      --v12;
      ++a1;
      if (!v11) {
        break;
      }
      goto LABEL_14;
    }

    int v15 = a1[1];
    int v16 = v15 & 0xFC00;
    int v17 = v15 + (v14 << 10) - 56613888;
    if (v16 == 56320)
    {
      unsigned int v14 = v17;
      v12 -= 2LL;
    }

    else
    {
      --v12;
    }

    a1 = (unsigned __int16 *)((char *)a1 + (v16 == 56320 ? 4LL : 2LL));
    if (!v11) {
      break;
    }
LABEL_14:
    uint64_t BitmapPtrForPlane = (unsigned __int8 *)&__CFUniCharNonBaseCharacterSetBitmapPlane0_0;
    if (v14 >= 0x10000)
    {
      uint64_t BitmapPtrForPlane = (unsigned __int8 *)CFUniCharGetBitmapPtrForPlane(8u, BYTE2(v14));
      if (!BitmapPtrForPlane) {
        break;
      }
    }

    if (v13 != 65533) {
      unsigned int v11 = v13;
    }
    if (v14 < 0x10000)
    {
      if (!__CFUniCharCombiningPriorityTablePlane0_1[(unint64_t)v14 >> 8])
      {
        unsigned __int8 UnicodeProperty = 0;
        if (!v9) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }

      unsigned __int8 UnicodeProperty = __CFUniCharCombiningPriorityTablePlane0_1[256
                                                                * __CFUniCharCombiningPriorityTablePlane0_1[(unint64_t)v14 >> 8]
                                                                + v14];
      if (v9) {
        goto LABEL_26;
      }
LABEL_27:
      int v20 = CFUniCharPrecomposeCharacter(v11, v14);
      if (v20 == 65533)
      {
        unsigned int v9 = UnicodeProperty;
        goto LABEL_45;
      }

      int v21 = v20;
      int v13 = v20;
      if (v12 < 1) {
        goto LABEL_85;
      }
    }

    else
    {
      unsigned __int8 UnicodeProperty = CFUniCharGetUnicodeProperty(v14, 0);
      if (!v9) {
        goto LABEL_27;
      }
LABEL_26:
      if (UnicodeProperty > v9) {
        goto LABEL_27;
      }
LABEL_45:
      unsigned int v27 = v14 - 0x10000;
      if (v14 < 0x10000)
      {
        uint64_t v28 = v10 + 1;
        if (v10 >= a5) {
          goto LABEL_80;
        }
        *int v52 = v14;
        BOOL v30 = v52 + 1;
LABEL_74:
        int v52 = v30;
        goto LABEL_75;
      }

      uint64_t v28 = v10 + 2;
      if (v10 + 2 > a5) {
        goto LABEL_80;
      }
      *int v52 = (v27 >> 10) - 10240;
      v52[1] = v14 & 0x3FF | 0xDC00;
      unsigned __int16 v29 = v52 + 2;
LABEL_71:
      unsigned int v14 = v27;
      int v52 = v29;
LABEL_75:
      uint64_t v10 = v28;
      if (v12 <= 0)
      {
LABEL_80:
        int v21 = v13;
        uint64_t v10 = v28;
        BOOL v23 = v13 == 65533;
        unsigned int v7 = a3;
        int v6 = a6;
        if (v23) {
          goto LABEL_100;
        }
        goto LABEL_86;
      }
    }
  }

  int v22 = v14 << 24;
  BOOL v23 = v14 - 4352 > 0xFE || v12 == 0;
  if (!v23 && v22 >= -16777215 && v22 <= 335544319)
  {
    unsigned int v31 = *a1 - 4449;
    if (v31 <= 0x15)
    {
      uint64_t v32 = a1 + 1;
      if ((unint64_t)v12 < 2)
      {
        uint64_t v12 = 0LL;
        __int16 v34 = 0;
      }

      else
      {
        int v33 = *v32 - 4519;
        else {
          --v12;
        }
        if ((v33 << 16) > 0x1C0000)
        {
          __int16 v34 = 0;
        }

        else
        {
          uint64_t v32 = a1 + 2;
          __int16 v34 = v33;
        }
      }

      unsigned int v14 = 28 * ((__int16)v31 + 21 * (char)v14) + v34 + 44032;
      a1 = v32;
    }
  }

  if (v13 == 65533) {
    goto LABEL_68;
  }
  if ((v49 & 1) != 0)
  {
    if (v11 < 0x10000)
    {
      uint64_t v26 = v50;
    }

    else
    {
      --v10;
      uint64_t v26 = v50;
      memmove(v50 + 1, v50 + 2, (char *)v52 - (char *)(v50 + 2));
    }

    _WORD *v26 = v13;
    goto LABEL_68;
  }

  if (HIWORD(v11))
  {
    size_t v35 = v50;
LABEL_67:
    *size_t v35 = ((v13 + 67043328) >> 10) - 10240;
    v35[1] = v13 & 0x3FF | 0xDC00;
LABEL_68:
    unsigned int v27 = v14 - 0x10000;
    if (v14 < 0x10000)
    {
      uint64_t v28 = v10 + 1;
      if (v10 >= a5)
      {
LABEL_83:
        unsigned int v7 = a3;
        int v6 = a6;
        goto LABEL_100;
      }

      unsigned int v9 = 0;
      int v50 = v52;
      *int v52 = v14;
      BOOL v30 = v52 + 1;
      char v49 = 1;
      int v13 = 65533;
      unsigned int v11 = v14;
      goto LABEL_74;
    }

    uint64_t v28 = v10 + 2;
    if (v10 + 2 > a5) {
      goto LABEL_83;
    }
    unsigned int v9 = 0;
    char v49 = 0;
    *int v52 = (v27 >> 10) - 10240;
    v52[1] = v14 & 0x3FF | 0xDC00;
    int v50 = v52;
    unsigned __int16 v29 = v52 + 2;
    int v13 = 65533;
    unsigned int v11 = v14;
    goto LABEL_71;
  }

  if (v10 < a5)
  {
    size_t v35 = v50;
    uint64_t v36 = (char *)v52 - (char *)v50 - 2;
    if (v36 >= 1)
    {
      unint64_t v37 = (unint64_t)v36 >> 1;
      do
      {
        v50[v37 + 1] = v50[v37];
        unint64_t v38 = v37-- + 1;
      }

      while (v38 > 2);
    }

    ++v10;
    goto LABEL_67;
  }

  int v21 = v13;
  ++v10;
LABEL_85:
  unsigned int v7 = a3;
  int v6 = a6;
LABEL_86:
  if (v14 < 0x10000)
  {
    if (v11 < 0x10000)
    {
      char v43 = v50;
    }

    else
    {
      --v10;
      char v43 = v50;
      memmove(v50 + 1, v50 + 2, (char *)v52 - (char *)(v50 + 2));
    }

    _WORD *v43 = v21;
    goto LABEL_99;
  }

  if (HIWORD(v11))
  {
    uint64_t v39 = v50;
    goto LABEL_96;
  }

  uint64_t v28 = v10 + 1;
  if (v10 >= a5)
  {
    if (v7) {
      *unsigned int v7 = a2 - v12;
    }
    uint64_t v44 = 0LL;
    uint64_t result = 0LL;
    if (v6) {
      goto LABEL_103;
    }
  }

  else
  {
    uint64_t v39 = v50;
    uint64_t v40 = (char *)v52 - (char *)v50 - 2;
    if (v40 >= 1)
    {
      unint64_t v41 = (unint64_t)v40 >> 1;
      do
      {
        v50[v41 + 1] = v50[v41];
        unint64_t v42 = v41-- + 1;
      }

      while (v42 > 2);
    }

    ++v10;
LABEL_96:
    *uint64_t v39 = ((v21 + 67043328) >> 10) - 10240;
    v39[1] = v21 & 0x3FF | 0xDC00;
LABEL_99:
    uint64_t v28 = v10;
LABEL_100:
    if (v7) {
      *unsigned int v7 = a2 - v12;
    }
    uint64_t v44 = 1LL;
    uint64_t result = 1LL;
    if (v6)
    {
LABEL_103:
      *int v6 = v28;
      return v44;
    }
  }

  return result;
}

void __CFUserNotificationDeallocate(uint64_t a1)
{
  unint64_t v2 = (unint64_t *)(a1 + 64);
  do
    unint64_t v3 = (__CFMachPort *)__ldaxr(v2);
  while (__stlxr(0LL, v2));
  if (v3)
  {
    CFMachPortInvalidate(v3);
    CFRelease(v3);
  }

  else
  {
    mach_port_name_t v4 = *(_DWORD *)(a1 + 16);
    if (v4) {
      mach_port_mod_refs(*MEMORY[0x1895FBBE0], v4, 1u, -1);
    }
  }

  BOOL v5 = *(const void **)(a1 + 48);
  if (v5) {
    CFRelease(v5);
  }
  int v6 = *(const void **)(a1 + 56);
  if (v6) {
    CFRelease(v6);
  }
}

__CFString *__CFUserNotificationCopyDescription(const void *a1)
{
  unint64_t v2 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0LL);
  CFStringAppendFormat(Mutable, 0LL, @"<CFUserNotification %p>", a1);
  return Mutable;
}

CFTypeID CFUserNotificationGetTypeID(void)
{
  return 54LL;
}

CFUserNotificationRef CFUserNotificationCreate( CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  pid_t v10 = getpid();
  int v11 = (unsigned __int16)_getNextToken_tokenCounter++;
  if (dictionary) {
    Value = (const __CFString *)CFDictionaryGetValue(dictionary, @"SessionID");
  }
  else {
    Value = 0LL;
  }
  mach_port_name_t name = 0;
  if (!allocator)
  {
    int v13 = (const __CFAllocator *)_CFGetTSD(1u);
    if (v13) {
      allocator = v13;
    }
    else {
      allocator = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    }
  }

  int v14 = v11 | (v10 << 16);
  options.reserved[1] = 0LL;
  *(_OWORD *)&options.flags = xmmword_180D684D0;
  int v15 = (ipc_space_t *)MEMORY[0x1895FBBE0];
  SInt32 v20 = mach_port_construct(*MEMORY[0x1895FBBE0], &options, 0LL, &name);
  if (v20) {
    BOOL v21 = 1;
  }
  else {
    BOOL v21 = name == 0;
  }
  if (!v21) {
    SInt32 v20 = _CFUserNotificationSendRequest(allocator, Value, name, v14, flags, dictionary, timeout);
  }
  if (v20)
  {
    if (dictionary)
    {
      int v22 = CFDictionaryGetValue(dictionary, @"AlertHeader");
      CFDictionaryGetValue(dictionary, @"AlertMessage");
      CFLog(3LL, (uint64_t)@"%@:  %@", v23, v24, v25, v26, v27, v28, (uint64_t)v22);
    }
  }

  else
  {
    uint64_t Instance = _CFRuntimeCreateInstance(allocator, 0x36uLL, 64LL, 0LL, v16, v17, v18, v19);
    if (Instance)
    {
      BOOL v30 = (__CFUserNotification *)Instance;
      *(_DWORD *)(Instance + 16) = name;
      *(_DWORD *)(Instance + 20) = v14;
      *(CFTimeInterval *)(Instance + 24) = timeout;
      *(void *)(Instance + 32) = flags;
      if (Value)
      {
        SInt32 v20 = 0;
        *(void *)(Instance + 4_Block_object_dispose(va, 8) = CFStringCreateCopy(allocator, Value);
        if (!error) {
          return v30;
        }
      }

      else
      {
        SInt32 v20 = 0;
        if (!error) {
          return v30;
        }
      }

      goto LABEL_28;
    }

    SInt32 v20 = 49164;
  }

  if (name) {
    mach_port_mod_refs(*v15, name, 1u, -1);
  }
  BOOL v30 = 0LL;
  if (error) {
LABEL_28:
  }
    *error = v20;
  return v30;
}

uint64_t _CFUserNotificationSendRequest( const __CFAllocator *a1, const __CFString *a2, int a3, int a4, int a5, const __CFDictionary *a6, double a7)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  if (a7 >= 2147483650.0 || a7 <= 0.0) {
    int v14 = 0;
  }
  else {
    int v14 = (int)a7;
  }
  int v48 = 0;
  mach_port_t special_port = 0;
  __strlcpy_chk();
  if (a2)
  {
    v54.CFIndex length = CFStringGetLength(a2);
    v54.CFIndex location = 0LL;
    CFStringGetBytes(a2, v54, 0x8000100u, 0, 0, buffer, 24LL, &usedBufLen);
    char v52 = 0;
    __strlcat_chk();
    __strlcat_chk();
  }

  uint64_t v15 = task_get_special_port(*MEMORY[0x1895FBBE0], 4, &special_port);
  if ((_DWORD)v15) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = special_port == 0;
  }
  if (!v16)
  {
    uint64_t v15 = bootstrap_look_up2();
    if (!(_DWORD)v15)
    {
      if (v48)
      {
        uint64_t v17 = (const void *)_CFProcessNameString();
        int valuePtr = v14;
        *(_DWORD *)buffer = a4;
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( a1,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        CFNumberRef v19 = CFNumberCreate(a1, kCFNumberSInt32Type, buffer);
        CFNumberRef v20 = CFNumberCreate(a1, kCFNumberSInt32Type, &valuePtr);
        if (a6) {
          CFDictionaryApplyFunction(a6, (CFDictionaryApplierFunction)_CFUserNotificationAddToDictionary, Mutable);
        }
        if (v17) {
          CFDictionaryAddValue(Mutable, @"AlertSource", v17);
        }
        if (v19)
        {
          CFDictionaryAddValue(Mutable, @"Token", v19);
          CFRelease(v19);
        }

        if (v20)
        {
          CFDictionaryAddValue(Mutable, @"Timeout", v20);
          CFRelease(v20);
        }

        Value = (const __CFURL *)CFDictionaryGetValue(Mutable, @"IconURL");
        if (Value)
        {
          int v22 = Value;
          CFTypeID v23 = CFGetTypeID(Value);
          if (v23 == CFURLGetTypeID())
          {
            uint64_t v24 = CFURLCopyAbsoluteURL(v22);
            CFDictionaryRemoveValue(Mutable, @"IconURL");
            CFStringRef v25 = CFURLCopyFileSystemPath(v24, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, @"IconPath", v25);
            CFRelease(v24);
            CFRelease(v25);
          }
        }

        uint64_t v26 = (const __CFURL *)CFDictionaryGetValue(Mutable, @"SoundURL");
        if (v26)
        {
          uint64_t v27 = v26;
          CFTypeID v28 = CFGetTypeID(v26);
          if (v28 == CFURLGetTypeID())
          {
            unsigned __int16 v29 = CFURLCopyAbsoluteURL(v27);
            CFDictionaryRemoveValue(Mutable, @"SoundURL");
            CFStringRef v30 = CFURLCopyFileSystemPath(v29, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, @"SoundPath", v30);
            CFRelease(v29);
            CFRelease(v30);
          }
        }

        unsigned int v31 = (const __CFURL *)CFDictionaryGetValue(Mutable, @"LocalizationURL");
        if (v31)
        {
          uint64_t v32 = v31;
          CFTypeID v33 = CFGetTypeID(v31);
          if (v33 == CFURLGetTypeID())
          {
            uint64_t v34 = CFURLCopyAbsoluteURL(v32);
            CFDictionaryRemoveValue(Mutable, @"LocalizationURL");
            CFStringRef v35 = CFURLCopyFileSystemPath(v34, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, @"LocalizationPath", v35);
            CFRelease(v34);
            CFRelease(v35);
          }
        }

        uint64_t v36 = (const __CFURL *)CFDictionaryGetValue(Mutable, @"HelpBundleURL");
        if (v36)
        {
          unint64_t v37 = v36;
          CFTypeID v38 = CFGetTypeID(v36);
          if (v38 == CFURLGetTypeID())
          {
            uint64_t v39 = CFURLCopyAbsoluteURL(v37);
            CFDictionaryRemoveValue(Mutable, @"HelpBundleURL");
            CFStringRef v40 = CFURLCopyFileSystemPath(v39, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, @"HelpBundlePath", v40);
            CFRelease(v39);
            CFRelease(v40);
          }
        }

        if (Mutable)
        {
          Data = CFPropertyListCreateData(a1, Mutable, kCFPropertyListXMLFormat_v1_0, 0LL, 0LL);
          if (Data)
          {
            unint64_t v42 = Data;
            CFIndex usedBufLen = ((CFDataGetLength(Data) + 3) & 0xFFFFFFFFFFFFFFFCLL) + 28;
            char v43 = CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, usedBufLen, 0LL);
            if (__CFOASafe) {
              __CFSetLastAllocationEventName();
            }
            if (v43)
            {
              bzero(v43, usedBufLen);
              if (a3) {
                int v44 = 5395;
              }
              else {
                int v44 = 19;
              }
              _DWORD *v43 = v44;
              int v45 = v48;
              v43[1] = usedBufLen;
              v43[2] = v45;
              v43[3] = a3;
              v43[5] = a5;
              v43[6] = 0;
              v55.CFIndex length = CFDataGetLength(v42);
              v55.CFIndex location = 0LL;
              CFDataGetBytes(v42, v55, (UInt8 *)v43 + 28);
              uint64_t v15 = mach_msg((mach_msg_header_t *)v43, 17, usedBufLen, 0, 0, 0x64u, 0);
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v43);
            }

            else
            {
              uint64_t v15 = 49164LL;
            }

            CFRelease(v42);
          }

          else
          {
            uint64_t v15 = 49164LL;
          }

          CFRelease(Mutable);
        }

        else
        {
          return 49164LL;
        }
      }
    }
  }

  return v15;
}

SInt32 CFUserNotificationReceiveResponse( CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  mach_msg_return_t v11;
  uint64_t v12;
  CFDataRef v13;
  CFDataRef v14;
  unint64_t *v15;
  __CFMachPort *v16;
  if (userNotification)
  {
    unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v6 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v6);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (timeout <= 0.0 || timeout * 1000.0 >= 2147483650.0)
  {
    unsigned int v7 = 0;
    if (!userNotification) {
      return 0;
    }
  }

  else
  {
    unsigned int v7 = (timeout * 1000.0);
    if (!userNotification) {
      return 0;
    }
  }

  if (!*((_DWORD *)userNotification + 4)) {
    return 0;
  }
  uint64_t v8 = (int *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0x4000LL, 0LL);
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  if (!v8) {
    return 49164;
  }
  bzero(v8, 0x4000uLL);
  v8[1] = 0x4000;
  if (v7)
  {
    mach_msg_option_t v9 = 258;
    mach_msg_timeout_t v10 = v7;
  }

  else
  {
    mach_msg_option_t v9 = 2;
    mach_msg_timeout_t v10 = 0;
  }

  int v11 = mach_msg((mach_msg_header_t *)v8, v9, 0, 0x4000u, *((_DWORD *)userNotification + 4), v10, 0);
  if (!v11)
  {
    if (responseFlags) {
      *responseFlags = v8[5];
    }
    uint64_t v12 = v8[1];
    if (v12 >= 0x1D)
    {
      int v13 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v8 + 28, v12 - 28);
      if (v13)
      {
        int v14 = v13;
        *((void *)userNotification + 7) = CFPropertyListCreateWithData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v13,  0LL,  0LL,  0LL);
        CFRelease(v14);
      }
    }

    uint64_t v15 = (unint64_t *)((char *)userNotification + 64);
    do
      BOOL v16 = (__CFMachPort *)__ldaxr(v15);
    while (__stlxr(0LL, v15));
    if (v16)
    {
      CFMachPortInvalidate(v16);
      CFRelease(v16);
    }

    mach_port_mod_refs(*MEMORY[0x1895FBBE0], *((_DWORD *)userNotification + 4), 1u, -1);
    *((_DWORD *)userNotification + 4) = 0;
  }

  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8);
  return v11;
}

CFStringRef CFUserNotificationGetResponseValue( CFUserNotificationRef userNotification, CFStringRef key, CFIndex idx)
{
  if (userNotification)
  {
    unint64_t v6 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v6 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v6);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!userNotification) {
    return 0LL;
  }
  CFStringRef result = (CFStringRef)*((void *)userNotification + 7);
  if (result)
  {
    CFStringRef result = (CFStringRef)CFDictionaryGetValue((CFDictionaryRef)result, key);
    if (result)
    {
      uint64_t v8 = result;
      CFTypeID v9 = CFGetTypeID(result);
      if (v9 == CFStringGetTypeID())
      {
        if (idx) {
          return 0LL;
        }
        else {
          return v8;
        }
      }

      CFTypeID v10 = CFGetTypeID(v8);
      CFTypeID TypeID = CFArrayGetTypeID();
      CFStringRef result = 0LL;
      if ((idx & 0x8000000000000000LL) == 0 && v10 == TypeID)
      {
        if (CFArrayGetCount((CFArrayRef)v8) > idx) {
          return (CFStringRef)CFArrayGetValueAtIndex((CFArrayRef)v8, idx);
        }
        return 0LL;
      }
    }
  }

  return result;
}

CFDictionaryRef CFUserNotificationGetResponseDictionary(CFUserNotificationRef userNotification)
{
  if (userNotification)
  {
    unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v2 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v2);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (userNotification) {
    return (CFDictionaryRef)*((void *)userNotification + 7);
  }
  else {
    return 0LL;
  }
}

SInt32 CFUserNotificationUpdate( CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags flags, CFDictionaryRef dictionary)
{
  int v5 = flags;
  if (userNotification)
  {
    unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v8 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v8);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!userNotification || !*((_DWORD *)userNotification + 4)) {
    return 0;
  }
  CFTypeID v9 = CFGetAllocator(userNotification);
  return _CFUserNotificationSendRequest( v9,  *((const __CFString **)userNotification + 6),  0,  *((_DWORD *)userNotification + 5),  v5 | 0x10u,  dictionary,  timeout);
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  if (userNotification)
  {
    unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v2 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v2);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (!userNotification || !*((_DWORD *)userNotification + 4)) {
    return 0;
  }
  unint64_t v3 = CFGetAllocator(userNotification);
  return _CFUserNotificationSendRequest( v3,  *((const __CFString **)userNotification + 6),  0,  *((_DWORD *)userNotification + 5),  8,  0LL,  0.0);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource( CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (userNotification)
  {
    unint64_t v8 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v8 != 54) {
      _CFAssertMismatchedTypeID(0x36uLL, v8);
    }
  }

  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if (userNotification && callout)
  {
    if (!atomic_load((unint64_t *)userNotification + 8))
    {
      if (*((_DWORD *)userNotification + 4))
      {
        v14.version = 0LL;
        memset(&v14.retain, 0, 24);
        v14.info = userNotification;
        CFTypeID v10 = CFGetAllocator(userNotification);
        atomic_store( (unint64_t)CFMachPortCreateWithPort( v10,  *((_DWORD *)userNotification + 4),  (CFMachPortCallBack)_CFUserNotificationMachPortCallBack,  &v14,  0LL),  (unint64_t *)userNotification + 8);
      }
    }
  }

  else if (!userNotification)
  {
    return 0LL;
  }

  if (atomic_load((unint64_t *)userNotification + 8))
  {
    uint64_t v12 = (__CFMachPort *)atomic_load((unint64_t *)userNotification + 8);
    CFRunLoopSourceRef result = CFMachPortCreateRunLoopSource(allocator, v12, order);
    *((void *)userNotification + 9) = callout;
    return result;
  }

  return 0LL;
}

uint64_t _CFUserNotificationMachPortCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(int *)(a2 + 20);
  uint64_t v6 = *(unsigned int *)(a2 + 4);
  if (v6 >= 0x1D)
  {
    unsigned int v7 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)(a2 + 28), v6 - 28);
    if (v7)
    {
      unint64_t v8 = v7;
      *(void *)(a4 + 56) = CFPropertyListCreateWithData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v7,  0LL,  0LL,  0LL);
      CFRelease(v8);
    }
  }

  CFTypeID v9 = (unint64_t *)(a4 + 64);
  do
    CFTypeID v10 = (__CFMachPort *)__ldaxr(v9);
  while (__stlxr(0LL, v9));
  if (v10)
  {
    CFMachPortInvalidate(v10);
    CFRelease(v10);
  }

  mach_port_mod_refs(*MEMORY[0x1895FBBE0], *(_DWORD *)(a4 + 16), 1u, -1);
  *(_DWORD *)(a4 + 16) = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 72))(a4, v5);
}

SInt32 CFUserNotificationDisplayNotice( CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle)
{
  int v14 = flags;
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  uint64_t v17 = Mutable;
  if (iconURL) {
    CFDictionaryAddValue(Mutable, @"IconURL", iconURL);
  }
  if (soundURL) {
    CFDictionaryAddValue(v17, @"SoundURL", soundURL);
  }
  if (localizationURL) {
    CFDictionaryAddValue(v17, @"LocalizationURL", localizationURL);
  }
  if (alertHeader) {
    CFDictionaryAddValue(v17, @"AlertHeader", alertHeader);
  }
  if (alertMessage) {
    CFDictionaryAddValue(v17, @"AlertMessage", alertMessage);
  }
  if (defaultButtonTitle) {
    CFDictionaryAddValue(v17, @"DefaultButtonTitle", defaultButtonTitle);
  }
  uint64_t v18 = _CFGetTSD(1u);
  if (v18) {
    CFNumberRef v19 = (const __CFAllocator *)v18;
  }
  else {
    CFNumberRef v19 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  pid_t v20 = getpid();
  int v21 = (unsigned __int16)_getNextToken_tokenCounter++;
  SInt32 v28 = _CFUserNotificationSendRequest(v19, 0LL, 0, v21 | (v20 << 16), v14, v17, timeout);
  if (v28) {
    CFLog(3LL, (uint64_t)@"%@:  %@", v22, v23, v24, v25, v26, v27, (uint64_t)alertHeader);
  }
  CFRelease(v17);
  return v28;
}

uint64_t _CFUserNotificationSetWarningThread(uint64_t result)
{
  __CFUserNotificationWarningThread = result;
  return result;
}

SInt32 CFUserNotificationDisplayAlert( CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle, CFStringRef alternateButtonTitle, CFStringRef otherButtonTitle, CFOptionFlags *responseFlags)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  SInt32 error = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  int v21 = Mutable;
  if (iconURL) {
    CFDictionaryAddValue(Mutable, @"IconURL", iconURL);
  }
  if (soundURL) {
    CFDictionaryAddValue(v21, @"SoundURL", soundURL);
  }
  if (localizationURL) {
    CFDictionaryAddValue(v21, @"LocalizationURL", localizationURL);
  }
  if (alertHeader) {
    CFDictionaryAddValue(v21, @"AlertHeader", alertHeader);
  }
  if (alertMessage) {
    CFDictionaryAddValue(v21, @"AlertMessage", alertMessage);
  }
  if (defaultButtonTitle) {
    CFDictionaryAddValue(v21, @"DefaultButtonTitle", defaultButtonTitle);
  }
  if (alternateButtonTitle) {
    CFDictionaryAddValue(v21, @"AlternateButtonTitle", alternateButtonTitle);
  }
  if (otherButtonTitle) {
    CFDictionaryAddValue(v21, @"OtherButtonTitle", otherButtonTitle);
  }
  CFUserNotificationRef v22 = CFUserNotificationCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, timeout, flags, &error, v21);
  if (v22)
  {
    uint64_t v23 = v22;
    uint64_t v24 = pthread_self();
    if (pthread_equal(v24, (pthread_t)__CFUserNotificationWarningThread)) {
      CFLog( 3LL,  (uint64_t)@"%@:  %@",  v25,  v26,  v27,  v28,  v29,  v30,  (uint64_t)@"CFUserNotificationDisplayAlert");
    }
    SInt32 error = CFUserNotificationReceiveResponse(v23, timeout, responseFlags);
    if (error == 268451843)
    {
      SInt32 error = CFUserNotificationCancel(v23);
      if (responseFlags) {
        *responseFlags = 3LL;
      }
    }

    CFRelease(v23);
  }

  CFRelease(v21);
  return error;
}

void _CFUserNotificationAddToDictionary(const void *a1, const void *a2, __CFDictionary *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID()) {
    CFDictionarySetValue(a3, a1, a2);
  }
}

uint64_t _CFOSLog()
{
  if (_CFOSLog_onceToken != -1) {
    dispatch_once(&_CFOSLog_onceToken, &__block_literal_global_24);
  }
  return _CFOSLog_logger;
}

uint64_t _CFMethodSignatureROMLog()
{
  if (_CFMethodSignatureROMLog_onceToken != -1) {
    dispatch_once(&_CFMethodSignatureROMLog_onceToken, &__block_literal_global_4);
  }
  return _CFMethodSignatureROMLog_logger;
}

uint64_t _CFRuntimeIssuesLog()
{
  if (_CFRuntimeIssuesLog_onceToken != -1) {
    dispatch_once(&_CFRuntimeIssuesLog_onceToken, &__block_literal_global_7);
  }
  return _CFRuntimeIssuesLog_logger;
}

uint64_t _CFFoundationRuntimeIssuesLog()
{
  if (_CFFoundationRuntimeIssuesLog_onceToken != -1) {
    dispatch_once(&_CFFoundationRuntimeIssuesLog_onceToken, &__block_literal_global_11_0);
  }
  return _CFFoundationRuntimeIssuesLog_logger;
}

uint64_t CFBSearch( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, unint64_t, uint64_t), uint64_t a6)
{
  uint64_t v8 = a3;
  if (a4 >= 1)
  {
    unint64_t v11 = a4;
    uint64_t v8 = a3;
    while (1)
    {
      unint64_t v13 = v11 >> 1;
      uint64_t v14 = a5(a1, v8 + (v11 >> 1) * a2, a6);
      if (!v14) {
        break;
      }
      if (v14 < 0)
      {
        uint64_t v15 = 0LL;
      }

      else
      {
        v8 += (v11 >> 1) * a2 + a2;
        uint64_t v15 = (v11 & 1) - 1;
      }

      unint64_t v11 = v13 + v15;
    }

    v8 += (v11 >> 1) * a2;
  }

  return (v8 - a3) / a2;
}

uint64_t CFHashBytes(uint64_t a1, uint64_t a2)
{
  if ((int)a2 < 4)
  {
    unsigned int v2 = 0;
    unsigned int v9 = a2;
  }

  else
  {
    unsigned int v2 = 0;
    unint64_t v3 = (unsigned __int8 *)((a2 & 0xFFFFFFFF00000000LL) + a1 + 1);
    unsigned int v4 = a2;
    do
    {
      unsigned int v5 = *(v3 - 1) + 16 * v2;
      unsigned int v6 = *v3 + 16 * (v5 ^ (16 * (v5 >> 28)));
      unsigned int v7 = v3[1] + 16 * (v6 ^ (16 * (v6 >> 28)));
      int v8 = v3[2] + 16 * (v7 ^ (16 * (v7 >> 28)));
      unsigned int v2 = (v8 ^ ((v8 & 0xF0000000) >> 24)) & ~(v8 & 0xF0000000);
      unsigned int v9 = v4 - 4;
      v3 += 4;
      BOOL v10 = v4 > 7;
      v4 -= 4;
    }

    while (v10);
  }

  switch(v9)
  {
    case 1u:
      goto LABEL_11;
    case 2u:
LABEL_10:
      int v12 = *(unsigned __int8 *)(a2 + a1 - 2) + 16 * v2;
      unsigned int v2 = (v12 ^ ((v12 & 0xF0000000) >> 24)) & ~(v12 & 0xF0000000);
LABEL_11:
      int v13 = *(unsigned __int8 *)(a2 + a1 - 1) + 16 * v2;
      return (v13 ^ ((v13 & 0xF0000000) >> 24)) & ~(v13 & 0xF0000000);
    case 3u:
      int v11 = *(unsigned __int8 *)(a2 + a1 - 3) + 16 * v2;
      unsigned int v2 = (v11 ^ ((v11 & 0xF0000000) >> 24)) & ~(v11 & 0xF0000000);
      goto LABEL_10;
  }

  return v2;
}

mach_vm_address_t __CFFindPointer(uint64_t a1, mach_vm_address_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  vm_map_read_t v4 = *MEMORY[0x1895FBBE0];
  mach_vm_size_t size = 0LL;
  for (mach_vm_address_t address = a2; ; mach_vm_address_t address = v6)
  {
    mach_msg_type_number_t infoCnt = 9;
    if (mach_vm_region(v4, &address, &size, 9, info, &infoCnt, &object_name)) {
      return 0LL;
    }
    mach_vm_address_t result = address;
    if ((info[0] & 2) == 0)
    {
      mach_vm_address_t v6 = address + size;
      goto LABEL_10;
    }

    mach_vm_address_t v6 = size + address;
    if (address < size + address) {
      break;
    }
LABEL_10:
    mach_vm_size_t size = 0LL;
  }

  unsigned int v7 = (void *)address;
  while ((unint64_t)v7 < a2 || *v7 != a1)
  {
    ++v7;
    result += 8LL;
  }

  return result;
}

uint64_t __CFDumpAllPointerLocations(uint64_t a1)
{
  unsigned int v2 = 0LL;
  do
  {
    unsigned int v2 = (const void *)__CFFindPointer(a1, (mach_vm_address_t)v2 + 8);
    uint64_t result = printf("%p\n", v2);
  }

  while (v2);
  return result;
}

CFDataRef _CFDataCreateFromURL(CFURLRef url, CFErrorRef *a2)
{
  resourceData[1] = *(CFDataRef *)MEMORY[0x1895F89C0];
  resourceData[0] = 0LL;
  SInt32 errorCode = 0;
  int v3 = CFURLCreateDataAndPropertiesFromResource( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  url,  resourceData,  0LL,  0LL,  &errorCode);
  if (!a2 || v3) {
    return resourceData[0];
  }
  CFErrorRef v4 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"NSOSStatusErrorDomain", errorCode, 0LL);
  CFDataRef result = 0LL;
  *a2 = v4;
  return result;
}

const void *_CFCopySystemVersionDictionaryValue(const void *a1)
{
  unsigned int v2 = (const __CFDictionary *)_CFCopyServerVersionDictionary();
  if (!v2)
  {
    unsigned int v2 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (!v2) {
      return 0LL;
    }
  }

  Value = CFDictionaryGetValue(v2, a1);
  CFErrorRef v4 = Value;
  if (Value) {
    CFRetain(Value);
  }
  CFRelease(v2);
  return v4;
}

CFTypeRef _CFCopyServerVersionDictionary()
{
  if (_CFCopyServerVersionDictionary_onceToken != -1) {
    dispatch_once(&_CFCopyServerVersionDictionary_onceToken, &__block_literal_global_24);
  }
  CFTypeRef result = (CFTypeRef)_CFCopyServerVersionDictionary_result;
  if (_CFCopyServerVersionDictionary_result) {
    return CFRetain((CFTypeRef)_CFCopyServerVersionDictionary_result);
  }
  return result;
}

CFTypeRef _CFCopySystemVersionDictionary()
{
  if (_CFCopySystemVersionDictionary_onceToken != -1) {
    dispatch_once(&_CFCopySystemVersionDictionary_onceToken, &__block_literal_global_16);
  }
  CFTypeRef result = (CFTypeRef)_CFCopySystemVersionDictionary_result;
  if (_CFCopySystemVersionDictionary_result) {
    return CFRetain((CFTypeRef)_CFCopySystemVersionDictionary_result);
  }
  return result;
}

const void *CFCopySystemVersionString()
{
  v0 = (const __CFDictionary *)_CFCopySupplementalVersionDictionary();
  if (!v0) {
    return 0LL;
  }
  uint64_t v1 = v0;
  Value = CFDictionaryGetValue(v0, @"FullVersionString");
  int v3 = Value;
  if (Value) {
    CFRetain(Value);
  }
  CFRelease(v1);
  return v3;
}

CFTypeRef _CFCopySupplementalVersionDictionary()
{
  if (_CFCopySupplementalVersionDictionary_onceToken != -1) {
    dispatch_once(&_CFCopySupplementalVersionDictionary_onceToken, &__block_literal_global_28);
  }
  CFTypeRef result = (CFTypeRef)_CFCopySupplementalVersionDictionary_result;
  if (_CFCopySupplementalVersionDictionary_result) {
    return CFRetain((CFTypeRef)_CFCopySupplementalVersionDictionary_result);
  }
  return result;
}

CFDictionaryRef _CFCopyVersionDictionary(CFStringRef filePath)
{
  resourceData[1] = *(CFDataRef *)MEMORY[0x1895F89C0];
  uint64_t v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, filePath, kCFURLPOSIXPathStyle, 0);
  if (!v1) {
    return 0LL;
  }
  unsigned int v2 = v1;
  if (!CFURLCreateDataAndPropertiesFromResource( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v1,  resourceData,  0LL,  0LL,  0LL))
  {
    CFRelease(v2);
    return 0LL;
  }

  int v3 = (const __CFDictionary *)CFPropertyListCreateWithData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  resourceData[0],  1uLL,  0LL,  0LL);
  CFRelease(resourceData[0]);
  CFRelease(v2);
  if (v3)
  {
    CFTypeRef cf = 0LL;
    CFStringRef v4 = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, @"Version");
    CFStringRef v5 = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, @"Build");
    format = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, @"FullVersionString");
    if (cf) {
      CFRelease(cf);
    }
    Value = CFDictionaryGetValue(v3, @"ProductBuildVersionOverride");
    if (Value) {
      CFDictionarySetValue(v3, @"ProductBuildVersion", Value);
    }
    unsigned int v7 = (const __CFString *)CFDictionaryGetValue(v3, @"ProductVersion");
    int v8 = CFDictionaryGetValue(v3, @"ProductVersionExtra");
    unsigned int v9 = v8;
    if (v7 && v8) {
      unsigned int v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@ %@", v7, v8);
    }
    BOOL v10 = (const __CFString *)CFDictionaryGetValue(v3, @"ProductBuildVersion");
    int v11 = @"?";
    if (v7) {
      int v12 = v7;
    }
    else {
      int v12 = @"?";
    }
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
    if (v10) {
      int v11 = v10;
    }
    CFStringRef StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@ %@",  format,  0LL,  v12,  v11);
    CFStringRef v15 = StringWithValidatedFormat;
    if (StringWithValidatedFormat && !CFEqual(StringWithValidatedFormat, @"FullVersionString")) {
      BOOL v16 = (void *)CFRetain(v15);
    }
    else {
      BOOL v16 = (void *)CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@ %@ (%@ %@)",  v4,  v12,  v5,  v11);
    }
    uint64_t v17 = v16;
    if (v7 && v9) {
      CFRelease(v7);
    }
    if (v15) {
      CFRelease(v15);
    }
    CFDictionarySetValue(v3, @"Version", v4);
    CFDictionarySetValue(v3, @"Build", v5);
    CFDictionarySetValue(v3, @"FullVersionString", v17);
    CFDictionarySetValue(v3, @"ShortVersionString", Copy);
    CFRelease(v4);
    CFRelease(v5);
    CFRelease(format);
    CFRelease(v17);
    CFRelease(Copy);
  }

  return v3;
}

CFTypeRef _CFCopySystemVersionPlatformDictionary()
{
  if (_CFCopySystemVersionPlatformDictionary_onceToken != -1) {
    dispatch_once(&_CFCopySystemVersionPlatformDictionary_onceToken, &__block_literal_global_20);
  }
  CFTypeRef result = (CFTypeRef)_CFCopySystemVersionPlatformDictionary_result;
  if (_CFCopySystemVersionPlatformDictionary_result) {
    return CFRetain((CFTypeRef)_CFCopySystemVersionPlatformDictionary_result);
  }
  return result;
}

double _CFOperatingSystemVersionGetCurrent@<D0>(uint64_t a1@<X8>)
{
  if (_CFOperatingSystemVersionGetCurrent_onceToken != -1) {
    dispatch_once(&_CFOperatingSystemVersionGetCurrent_onceToken, &__block_literal_global_32);
  }
  double result = *(double *)&_CFOperatingSystemVersionGetCurrent_version;
  *(_OWORD *)a1 = _CFOperatingSystemVersionGetCurrent_version;
  *(void *)(a1 + 16) = qword_18C45C918;
  return result;
}

unint64_t _CFBuildVersionForCFSystemVersion(unint64_t a1, unsigned int a2)
{
  if (a1 > 0x14)
  {
    if (a1 - 1000 > 0xF)
    {
      if (a2 == 6)
      {
        if ((_DWORD)a1 == 659456) {
          int v3 = 917504;
        }
        else {
          int v3 = -65536;
        }
        if ((_DWORD)a1 == 720896) {
          int v4 = 917504;
        }
        else {
          int v4 = v3;
        }
        if ((_DWORD)a1 == 659201) {
          unsigned int v5 = 852480;
        }
        else {
          unsigned int v5 = v4;
        }
        a2 = 2;
        else {
          uint64_t v2 = 851968LL;
        }
      }

      else
      {
        uint64_t v2 = a1;
      }

      return a2 | (unint64_t)(v2 << 32);
    }

    if (a1 > 0x3EC && a2 == 1)
    {
      if (a1 - 1005 >= 0xB) {
        uint64_t v2 = 4294901760LL;
      }
      else {
        uint64_t v2 = dword_180D68538[a1 - 1005];
      }
      a2 = 1;
      return a2 | (unint64_t)(v2 << 32);
    }
  }

  else if (a1 > 4)
  {
    if (a1 >= 0xA) {
      uint64_t v2 = 4294901760LL;
    }
    else {
      uint64_t v2 = 0LL;
    }
    if (a2 == 6 || a2 == 1)
    {
      uint64_t v2 = _CFBuildVersionForCFSystemVersion_macos_map[a1 - 5];
      if (a2 == 6)
      {
        if (a1 - 5 >= 0xB)
        {
          if ((_DWORD)v2 == 659456) {
            int v6 = 917504;
          }
          else {
            int v6 = -65536;
          }
          if ((_DWORD)v2 == 720896) {
            unsigned int v7 = 917504;
          }
          else {
            unsigned int v7 = v6;
          }
          a2 = 2;
          if ((_DWORD)v2 == 659201) {
            uint64_t v2 = 852480LL;
          }
          else {
            uint64_t v2 = v7;
          }
        }

        else
        {
          uint64_t v2 = 851968LL;
          a2 = 2;
        }
      }
    }

    return a2 | (unint64_t)(v2 << 32);
  }

  uint64_t v2 = 0LL;
  if (a2 == 6) {
    a2 = 2;
  }
  return a2 | (unint64_t)(v2 << 32);
}

uint64_t _CFPlatformExecutableLinkedOnOrAfter(unint64_t a1, unsigned int a2)
{
  if (a2 != 6) {
    _CFBuildVersionForCFSystemVersion(a1, a2);
  }
  return dyld_program_sdk_at_least();
}

uint64_t _CFExecutableLinkedOnOrAfter(unint64_t a1)
{
  unsigned int active_platform = dyld_get_active_platform();
  _CFBuildVersionForCFSystemVersion(a1, active_platform);
  return dyld_program_sdk_at_least();
}

void *__CFLookupCFNetworkFunction(char *__symbol)
{
  if (__CFLookupCFNetworkFunction_onceToken != -1) {
    dispatch_once(&__CFLookupCFNetworkFunction_onceToken, &__block_literal_global_54);
  }
  double result = (void *)__CFLookupCFNetworkFunction_image;
  if (__CFLookupCFNetworkFunction_image) {
    return dlsym((void *)__CFLookupCFNetworkFunction_image, __symbol);
  }
  return result;
}

uint64_t __CFActiveProcessorCount()
{
  return MEMORY[0xFFFFFC034];
}

uint64_t __CFProcessorCount()
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  *(void *)unsigned int v5 = 0x300000006LL;
  size_t v3 = 4LL;
  int v0 = sysctl(v5, 2u, &v4, &v3, 0LL, 0LL);
  int v1 = v4;
  if (v0) {
    return 0;
  }
  return v1;
}

uint64_t __CFMemorySize()
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  uint64_t v2 = 0LL;
  *(void *)size_t v3 = 0x1800000006LL;
  size_t v1 = 8LL;
  if (sysctl(v3, 2u, &v2, &v1, 0LL, 0LL)) {
    return 0LL;
  }
  else {
    return v2;
  }
}

unint64_t __CFGetUGIDs(_DWORD *a1, _DWORD *a2)
{
  v6[5] = *MEMORY[0x1895F89C0];
  if (_CFCanChangeEUIDs_onceToken != -1) {
    dispatch_once(&_CFCanChangeEUIDs_onceToken, &__block_literal_global_87);
  }
  if (_CFCanChangeEUIDs_canChangeEUIDs)
  {
    unint64_t result = ____CFGetUGIDs_block_invoke();
    unint64_t v5 = HIDWORD(result);
    if (!a1) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 0x40000000LL;
  v6[2] = ____CFGetUGIDs_block_invoke_2;
  v6[3] = &unk_1899EA690;
  v6[4] = &__block_literal_global_59;
  if (__CFGetUGIDs_onceToken != -1) {
    dispatch_once(&__CFGetUGIDs_onceToken, v6);
  }
  unint64_t result = __CFGetUGIDs_cachedUGIDs;
  LODWORD(v5) = HIDWORD(__CFGetUGIDs_cachedUGIDs);
  if (a1) {
LABEL_5:
  }
    *a1 = result;
LABEL_6:
  if (a2) {
    *a2 = v5;
  }
  return result;
}

uint64_t _CFGetEUID()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  __CFGetUGIDs(&v1, 0LL);
  return v1;
}

uint64_t _CFGetEGID()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  __CFGetUGIDs(0LL, &v1);
  return v1;
}

_BYTE *_CFPrintForDebugger(void *a1)
{
  maxBufLen[1] = *MEMORY[0x1895F89C0];
  maxBufLen[0] = 0LL;
  free((void *)_CFPrintForDebugger_result);
  _CFPrintForDebugger_unint64_t result = 0LL;
  if (a1)
  {
    CFTypeID v2 = CFGetTypeID(a1);
    if (v2 == CFStringGetTypeID())
    {
      size_t v3 = (const __CFString *)__CFCopyFormattingDescription((unint64_t *)a1, 0LL);
      if (v3) {
        goto LABEL_7;
      }
    }

    uint64_t v4 = CFCopyDescription(a1);
  }

  else
  {
    uint64_t v4 = (const __CFString *)CFRetain(@"(null)");
  }

  size_t v3 = v4;
  if (v4)
  {
LABEL_7:
    v7.CFIndex length = CFStringGetLength(v3);
    v7.CFIndex location = 0LL;
    CFStringGetBytes(v3, v7, 0x8000100u, 0, 0, 0LL, 0LL, maxBufLen);
    _CFPrintForDebugger_unint64_t result = (uint64_t)malloc(maxBufLen[0] + 2);
    v8.CFIndex length = CFStringGetLength(v3);
    v8.CFIndex location = 0LL;
    CFStringGetBytes(v3, v8, 0x8000100u, 0, 0, (UInt8 *)_CFPrintForDebugger_result, maxBufLen[0], maxBufLen);
    *(_BYTE *)(_CFPrintForDebugger_result + maxBufLen[0]) = 0;
    CFRelease(v3);
    return (_BYTE *)_CFPrintForDebugger_result;
  }

  unint64_t result = malloc(2uLL);
  _CFPrintForDebugger_unint64_t result = (uint64_t)result;
  *unint64_t result = 0;
  return result;
}

void CFShow(CFTypeRef obj)
{
}

void _CFShowToFile(FILE *a1, void *cf)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!cf)
  {
    uint64_t v6 = (const __CFString *)CFRetain(@"(null)");
    goto LABEL_6;
  }

  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID()
    || (unint64_t v5 = (const __CFString *)__CFCopyFormattingDescription((unint64_t *)cf, 0LL)) == 0LL)
  {
    uint64_t v6 = CFCopyDescription(cf);
LABEL_6:
    unint64_t v5 = v6;
  }

  CFIndex Length = CFStringGetLength(v5);
  CFStringRef theString = v5;
  uint64_t v29 = 0LL;
  CFIndex v30 = Length;
  CharactersPtr = CFStringGetCharactersPtr(v5);
  CStringPtr = 0LL;
  uint64_t v27 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(v5, 0x600u);
  }
  int64_t v31 = 0LL;
  int64_t v32 = 0LL;
  uint64_t v28 = CStringPtr;
  if (Length < 1) {
    goto LABEL_33;
  }
  cfa = v5;
  uint64_t v10 = 0LL;
  int64_t v11 = 0LL;
  BOOL v12 = 0;
  uint64_t v13 = 64LL;
  do
  {
    else {
      uint64_t v14 = v11;
    }
    if (v27)
    {
      UniChar v15 = v27[v11 + v29];
    }

    else if (v28)
    {
      UniChar v15 = v28[v29 + v11];
    }

    else
    {
      int64_t v16 = v31;
      if (v32 <= v11 || v31 > v11)
      {
        uint64_t v18 = -v14;
        uint64_t v19 = v14 + v10;
        uint64_t v20 = v13 - v14;
        int64_t v21 = v11 + v18;
        CFIndex v22 = v21 + 64;
        if (v21 + 64 >= v30) {
          CFIndex v22 = v30;
        }
        int64_t v31 = v21;
        int64_t v32 = v22;
        if (v30 < v20) {
          uint64_t v20 = v30;
        }
        v34.CFIndex length = v20 + v19;
        v34.CFIndex location = v21 + v29;
        CFStringGetCharacters(theString, v34, buffer);
        int64_t v16 = v31;
      }

      UniChar v15 = buffer[v11 - v16];
    }

    int v23 = v15;
    if (v15 > 0x7Fu)
    {
      fprintf_l(a1, 0LL, "\\u%04x", v15);
    }

    else
    {
      fprintf_l(a1, 0LL, "%c", v15);
      BOOL v12 = v23 == 10;
    }

    ++v11;
    --v10;
    ++v13;
  }

  while (Length != v11);
  unint64_t v5 = cfa;
  if (!v12)
  {
LABEL_33:
    fprintf_l(a1, 0LL, "\n");
    fflush(a1);
  }

  if (v5) {
    CFRelease(v5);
  }
}

unint64_t _CFLogvEx2( void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return _CFLogvEx2Predicate(a1, a2, a3, a4, a5, a6, a7, 1);
}

unint64_t _CFLogvEx2Predicate( void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unint64_t result = _CFGetTSD(2u);
  if (result <= 3)
  {
    uint64_t v17 = result;
    _CFSetTSD(2u, result + 1, 0LL);
    if (a6)
    {
      uint64_t v18 = (const __CFString *)_CFStringCreateWithFormatAndArgumentsAux2( (uint64_t)&__kCFAllocatorSystemDefault,  a2,  a3,  a4,  0LL,  a6,  a7);
      if (v18)
      {
        uint64_t v19 = v18;
        CFIndex Length = CFStringGetLength(v18);
        CFIndex v21 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
        CFIndex v22 = (char *)malloc(v21);
        if (v22)
        {
          int v23 = v22;
          int CString = CFStringGetCString(v19, v22, v21, 0x8000100u);
          size_t v25 = strlen(v23);
          if (a5 <= 7)
          {
            if (CString) {
              BOOL v26 = v25 == 0;
            }
            else {
              BOOL v26 = 1;
            }
            if (!v26 && v25 <= 0x1000000)
            {
              if (a1)
              {
                a1(a5, v23, v25, 1LL);
              }

              else if (a8)
              {
                __CFLogCStringLegacy(a5, v23, v25, 1);
              }

              else
              {
                __CFLogCString((uint64_t)v23, v25);
              }
            }
          }

          free(v23);
        }

        CFRelease(v19);
      }
    }

    return _CFSetTSD(2u, v17, 0LL);
  }

  return result;
}

unint64_t _CFLogvEx3( void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t result = _CFGetTSD(2u);
  if (result <= 3)
  {
    uint64_t v15 = result;
    _CFSetTSD(2u, result + 1, 0LL);
    _CFSetTSD(2u, v15, 0LL);
    unint64_t result = also_do_stderr(0);
    if ((_DWORD)result) {
      return _CFLogvEx2Predicate(a1, a2, a3, a4, a5, a6, a7, 0);
    }
  }

  return result;
}

BOOL also_do_stderr(int a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (issetugid() || !getenv("CFLOG_FORCE_STDERR"))
    {
      if (fstat(2, &buffer) < 0) {
        return 0LL;
      }
      if ((buffer.st_mode & 0xB000) != 0x8000)
      {
        int v1 = buffer.st_mode & 0xF000;
        if (v1 != 4096 && v1 != 0x2000) {
          return 0LL;
        }
      }
    }

    return 1LL;
  }

  pid_t v2 = getpid();
  if (proc_pidinfo(v2, 13, 0LL, &buffer, 64) == 64 && (buffer.st_atimespec.tv_sec & 2) != 0
    || getenv("OS_ACTIVITY_DT_MODE")
    || getenv("CFLOG_FORCE_DISABLE_STDERR"))
  {
    return 0LL;
  }

  int v4 = fstat(2, &buffer);
  if ((v4 & 0x80000000) == 0)
  {
    unsigned int v5 = buffer.st_mode & 0xF000;
    if (v5 >= 0x8000)
    {
      if (v5 != 49152 && v5 != 0x8000) {
        return 0LL;
      }
    }

    else if (v5 != 4096 && v5 != 0x2000)
    {
      return 0LL;
    }
  }

  return v4 >= 0;
}

unint64_t _CFLogvEx( void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return _CFLogvEx2Predicate(a1, a2, 0LL, a3, a4, a5, a6, 1);
}

void _CFLogSimple(int a1, char *__format, ...)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  int v3 = vsnprintf(__str, 0x400uLL, __format, va);
  if (v3 >= 1) {
    __CFLogCStringLegacy(a1, __str, v3, 0);
  }
}

void __CFLogCStringLegacy(int a1, const char *a2, uint64_t a3, int a4)
{
  __s[1] = *(char **)MEMORY[0x1895F89C0];
  value = 0LL;
  __s[0] = 0LL;
  int64_t v11 = 0LL;
  BOOL v12 = 0LL;
  if (a4) {
    _populateBanner(__s, &value, &v11);
  }
  __CFGetUGIDs(&v10, 0LL);
  asprintf(&v12, "%d", v10);
  uint64_t v7 = "com.apple.console";
  if (__CFBundleMainID && *(_BYTE *)__CFBundleMainID) {
    uint64_t v7 = (const char *)__CFBundleMainID;
  }
  CFRange v8 = asl_open(0LL, v7, 2u);
  unsigned int v9 = asl_new(0);
  asl_set(v9, "CFLog Local Time", value);
  asl_set(v9, "CFLog Thread", v11);
  asl_set(v9, "ReadUID", v12);
  asl_set(v9, "Level", __CFLogCStringLegacy_levstr[a1]);
  asl_set(v9, "Message", a2);
  asl_send(v8, v9);
  MEMORY[0x186E03244](v9);
  MEMORY[0x186E03238](v8);
  if (also_do_stderr(1)) {
    _logToStderr(__s[0], (uint64_t)a2, a3);
  }
  if (v11) {
    free(v11);
  }
  if (value) {
    free(value);
  }
  if (__s[0]) {
    free(__s[0]);
  }
  if (v12) {
    free(v12);
  }
}

void _CFLogSimpleCString(int a1, const char *a2, uint64_t a3)
{
}

unint64_t CFLog( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return _CFLogvEx3(0LL, 0LL, 0LL, 0LL, a1, a2, (uint64_t)&a9);
}

void CFLogTest(char a1, CFStringRef format, ...)
{
  *(void *)&v21[6] = *MEMORY[0x1895F89C0];
  uint64_t v3 = CFLogTest_file;
  if (CFLogTest_file) {
    goto LABEL_14;
  }
  if ((a1 & 1) == 0)
  {
    int v4 = CFCopySearchPathForDirectoriesInDomains(5LL, 1LL, 1);
    if (!v4) {
      goto LABEL_13;
    }
    uint64_t v5 = v4;
    if (CFArrayGetCount(v4) >= 1
      && (ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v5, 0LL),
          CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, (UInt8 *)buffer, 1026LL)))
    {
      uint64_t v7 = (uint64_t)buffer + strlen((const char *)buffer);
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    CFRelease(v5);
    if (!v7) {
      goto LABEL_13;
    }
    goto LABEL_11;
  }

  uint64_t v7 = __stpcpy_chk();
  if (v7)
  {
LABEL_11:
    snprintf((char *)v7, (size_t)&v21[-v7], "/Logs");
    mkdir((const char *)buffer, 0x1FFu);
    CFRange v8 = (char *)(v7 + strlen((const char *)v7));
    unsigned int v9 = (const char *)*_CFGetProgname();
    pid_t v10 = getpid();
    snprintf(v8, v21 - v8, "/%s_%d.selftest.txt", v9, v10);
    CFLogTest_file = (uint64_t)fopen((const char *)buffer, "w");
    if (!CFLogTest_file)
    {
      CFLog( 3LL,  (uint64_t)@"Couldn't write to self test log file %s",  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)buffer);
      CFLogTest_file = -1LL;
    }
  }

uint64_t _CFDiscorporateMemoryAllocate(uint64_t a1, uint64_t a2, int a3)
{
  char v3 = a3;
  if (((a2 + *MEMORY[0x1895FD590] - 1) & -*MEMORY[0x1895FD590]) != 0) {
    mach_vm_size_t v5 = (a2 + *MEMORY[0x1895FD590] - 1) & -*MEMORY[0x1895FD590];
  }
  else {
    mach_vm_size_t v5 = *MEMORY[0x1895FD590];
  }
  *(void *)(a1 + 32) = 0LL;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v6 = (mach_vm_address_t *)(a1 + 16);
  uint64_t v7 = (vm_map_t *)MEMORY[0x1895FBBE0];
  *(_OWORD *)a1 = 0u;
  if (a3) {
    int v8 = 687865859;
  }
  else {
    int v8 = 687865857;
  }
  uint64_t result = mach_vm_allocate(*v7, v6, v5, v8);
  if ((_DWORD)result)
  {
    *uint64_t v6 = 0LL;
  }

  else
  {
    *(void *)a1 = *(void *)(a1 + 16);
    *(void *)(a1 + _Block_object_dispose(va, 8) = v5;
    *(_BYTE *)(a1 + 24) = v3;
  }

  return result;
}

uint64_t _CFDiscorporateMemoryDeallocate(uint64_t a1)
{
  mach_vm_address_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = mach_vm_deallocate(*MEMORY[0x1895FBBE0], v2, *(void *)(a1 + 8));
    uint64_t v4 = v3;
    if ((_DWORD)v3)
    {
      mach_vm_size_t v5 = mach_error_string(v3);
      CFLog( 3LL,  (uint64_t)@"CFDiscorporateMemoryDeallocate: mach_vm_deallocate returned %s",  v6,  v7,  v8,  v9,  v10,  v11,  (uint64_t)v5);
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0LL;
  return v4;
}

uint64_t _CFDiscorporateMemoryDematerialize(uint64_t *a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *a1;
  int v4 = 1;
  if (!v1) {
    return 34LL;
  }
  MEMORY[0x186E04CFC](*MEMORY[0x1895FBBE0], v1, 0LL, &v4);
  uint64_t result = 0LL;
  *a1 = 0LL;
  return result;
}

uint64_t _CFDiscorporateMemoryMaterialize(uint64_t *a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  uint64_t v1 = *a1;
  int v5 = 0;
  if (v1)
  {
    char v2 = 0;
    LODWORD(result) = 34;
  }

  else
  {
    LODWORD(result) = MEMORY[0x186E04CFC](*MEMORY[0x1895FBBE0], a1[2], 0LL, &v5);
    if ((_DWORD)result)
    {
      char v2 = 0;
    }

    else
    {
      *a1 = a1[2];
      char v2 = 1;
    }
  }

  else {
    return result;
  }
}

uint64_t _CFReadMappedFromFile(__CFString *a1, int a2, int a3, void *a4, off_t *a5, CFErrorRef *a6)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!CFStringGetFileSystemRepresentation(a1, buffer, 1026LL))
  {
    if (!a6) {
      return 0LL;
    }
    timeval v18 = @"NSCocoaErrorDomain";
    CFIndex v19 = -1LL;
LABEL_32:
    CFErrorRef v25 = _CFErrorWithFilePathCodeDomain(v18, v19, a1);
    uint64_t result = 0LL;
    *a6 = v25;
    return result;
  }

  int v12 = open(buffer, 0, 438LL);
  if (v12 < 0)
  {
    if (!a6) {
      return 0LL;
    }
    CFIndex v19 = *__error();
    timeval v18 = @"NSPOSIXErrorDomain";
    goto LABEL_32;
  }

  int v13 = v12;
  if (a3) {
    fcntl(v12, 48, 1LL);
  }
  if (fstat(v13, &v27) < 0) {
    goto LABEL_16;
  }
  if ((v27.st_mode & 0xF000) != 0x8000)
  {
    close(v13);
    if (a6)
    {
      timeval v18 = @"NSPOSIXErrorDomain";
      CFIndex v19 = 13LL;
      goto LABEL_32;
    }

    return 0LL;
  }

  st_mach_vm_size_t size = v27.st_size;
  if (v27.st_size < 0)
  {
LABEL_30:
    close(v13);
    if (a6)
    {
      timeval v18 = @"NSPOSIXErrorDomain";
      CFIndex v19 = 12LL;
      goto LABEL_32;
    }

    return 0LL;
  }

  if (!v27.st_size)
  {
    uint64_t v16 = malloc(8uLL);
    off_t v17 = 0LL;
    goto LABEL_36;
  }

  if (!a2)
  {
    CFIndex v21 = (char *)malloc(v27.st_size);
    if (v21)
    {
      uint64_t v16 = v21;
      CFIndex v22 = v21;
      while (1)
      {
        size_t v23 = st_size >= 0x7FFFFFFF ? 0x7FFFFFFFLL : st_size;
        ssize_t v24 = read(v13, v22, v23);
        if (v24 <= 0) {
          break;
        }
        v22 += v24;
        st_size -= v24;
        if (!st_size) {
          goto LABEL_35;
        }
      }

      if ((v24 & 0x8000000000000000LL) == 0)
      {
LABEL_35:
        off_t v17 = v27.st_size - st_size;
        goto LABEL_36;
      }

      CFIndex v20 = *__error();
      free(v16);
LABEL_17:
      close(v13);
      if (a6)
      {
        timeval v18 = @"NSPOSIXErrorDomain";
        CFIndex v19 = v20;
        goto LABEL_32;
      }

      return 0LL;
    }

    goto LABEL_30;
  }

  uint64_t v15 = mmap(0LL, v27.st_size, 1, 2, v13, 0LL);
  if (v15 == (void *)-1LL)
  {
LABEL_16:
    CFIndex v20 = *__error();
    goto LABEL_17;
  }

  uint64_t v16 = v15;
  off_t v17 = v27.st_size;
LABEL_36:
  close(v13);
  *a4 = v16;
  *a5 = v17;
  return 1LL;
}

CFErrorRef _CFErrorWithFilePathCodeDomain(const __CFString *a1, CFIndex a2, void *a3)
{
  values[1] = *(void **)MEMORY[0x1895F89C0];
  keys = @"NSFilePath";
  values[0] = a3;
  int v5 = CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)&keys,  (const void **)values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFErrorRef v6 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, a2, v5);
  CFRelease(v5);
  return v6;
}

void _CFGetPathExtensionRangesFromPathComponentUniChars(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v103 = *MEMORY[0x1895F89C0];
  CFStringRef theString = 0LL;
  uint64_t v97 = a1;
  uint64_t v98 = 0LL;
  CFIndex v99 = 0LL;
  uint64_t v101 = 0LL;
  CFIndex length = 0LL;
  CFIndex v100 = a2;
  if (a2 < 2) {
    goto LABEL_58;
  }
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  unint64_t v10 = a2 - 1;
  uint64_t v11 = 1 - a2;
  uint64_t v12 = a2 + 63;
  int v13 = &buffer[a2 - 1];
  uint64_t v14 = 2 - 2 * a2;
  while (1)
  {
    uint64_t v15 = a2 + v8;
    if (v10 >= 0x3F) {
      uint64_t v16 = 63LL;
    }
    else {
      uint64_t v16 = v10;
    }
    if (v97)
    {
      UniChar v17 = *(_WORD *)(v97 + 2 * (v15 + v99) - 2);
    }

    else if (v98)
    {
      UniChar v17 = *(char *)(v98 + v99 + a2 + v8 - 1);
    }

    else
    {
      CFIndex v18 = v15 - 1;
      BOOL v19 = length > v18 && v9 <= v18;
      if (!v19)
      {
        uint64_t v20 = ~v16;
        uint64_t v21 = v16 ^ 0x3F;
        CFIndex v22 = v12 - v16;
        uint64_t v23 = v16 + v7;
        uint64_t v24 = a2 + v8 + v20;
        uint64_t v25 = a2 + v8 + v21;
        if (v25 >= v100) {
          uint64_t v25 = v100;
        }
        uint64_t v101 = v24;
        CFIndex length = v25;
        v26.CFIndex location = v24 + v99;
        if (v100 >= v22) {
          CFIndex v27 = v22;
        }
        else {
          CFIndex v27 = v100;
        }
        v26.CFIndex length = v11 + v23 + v27;
        uint64_t v28 = v11;
        uint64_t v29 = v13;
        CFStringGetCharacters(theString, v26, buffer);
        int v13 = v29;
        uint64_t v11 = v28;
        uint64_t v9 = v101;
      }

      UniChar v17 = v13[v8 - v9];
    }

    uint64_t v30 = 0LL;
    int v31 = v17;
    uint64_t v32 = -1LL;
    if (v31 > 8233)
    {
      unsigned int v33 = v31 - 8234;
      BOOL v19 = v33 > 0x3F;
      unint64_t v34 = (1LL << v33) & 0xF00000000000001FLL;
      BOOL v35 = v19 || v34 == 0;
      uint64_t v36 = -1LL;
      uint64_t v37 = 0LL;
      if (!v35) {
        goto LABEL_61;
      }
      goto LABEL_35;
    }

    if (v31 > 1563)
    {
      if ((v31 - 8206) < 2)
      {
LABEL_37:
        uint64_t v36 = -1LL;
        uint64_t v37 = 0LL;
        goto LABEL_61;
      }

      uint64_t v36 = -1LL;
      uint64_t v37 = 0LL;
      if (v31 == 1564) {
        goto LABEL_61;
      }
      goto LABEL_35;
    }

    if (v31 == 32) {
      goto LABEL_37;
    }
    if (v31 == 46) {
      break;
    }
    uint64_t v36 = -1LL;
    uint64_t v37 = 0LL;
    if (v31 == 47) {
      goto LABEL_61;
    }
LABEL_35:
    --v10;
    v14 += 2LL;
    --v12;
    --v8;
    ++v7;
    if (a2 + v8 <= 1)
    {
      uint64_t v30 = 0LL;
      uint64_t v37 = 0LL;
LABEL_89:
      uint64_t v32 = -1LL;
      goto LABEL_61;
    }
  }

  if (!v8)
  {
    uint64_t v30 = 0LL;
    uint64_t v37 = 0LL;
    goto LABEL_60;
  }

  uint64_t v38 = a2 + v8;
  unint64_t v39 = a2 + v8 - 1;
  if (v39 > 2) {
    goto LABEL_66;
  }
  if (v97)
  {
    CFStringRef v40 = (UniChar *)(v97 + 2 * v99);
  }

  else
  {
    if ((uint64_t)v39 > length || v9 >= 1)
    {
      if (v100 >= 64) {
        v41.CFIndex length = 64LL;
      }
      else {
        v41.CFIndex length = v100;
      }
      uint64_t v101 = 0LL;
      CFIndex length = v41.length;
      v41.CFIndex location = v99;
      if (v98)
      {
        if (v41.length)
        {
          unint64_t v42 = (char *)(v98 + v99);
          char v43 = buffer;
          do
          {
            UniChar v44 = *v42++;
            *v43++ = v44;
            --v41.length;
          }

          while (v41.length);
        }
      }

      else
      {
        uint64_t v45 = v11;
        CFStringGetCharacters(theString, v41, buffer);
        uint64_t v11 = v45;
      }
    }

    uint64_t v9 = v101;
    CFStringRef v40 = &buffer[-v101];
  }

  if (*v40 != 46) {
    goto LABEL_66;
  }
  uint64_t v30 = v38 - 2;
  if (v38 == 2) {
    goto LABEL_59;
  }
  if (v40[1] != 46)
  {
LABEL_66:
    uint64_t v36 = a2 + v8;
    uint64_t v37 = -v8;
    if (!a4)
    {
LABEL_88:
      uint64_t v30 = 0LL;
      goto LABEL_89;
    }

    uint64_t v46 = v38 + 63;
    uint64_t v47 = v11 - v8;
    while (1)
    {
      if (v39 >= 0x40) {
        uint64_t v48 = 64LL;
      }
      else {
        uint64_t v48 = v39;
      }
      CFIndex v49 = v38 - 1;
      if (v38 - 1 < 2) {
        goto LABEL_88;
      }
      if (v97)
      {
        int v50 = (UniChar *)(v97 + 2 * (v38 + v99));
      }

      else
      {
        if (v98)
        {
          __int16 v51 = *(char *)(v98 + v99 + v38 - 2);
          goto LABEL_77;
        }

        if (length < v49 || v9 >= v49)
        {
          uint64_t v52 = -v48;
          uint64_t v53 = v48 + v47;
          CFIndex v54 = v46 - v48;
          uint64_t v55 = v38 + v52;
          CFIndex v56 = v55 + 63;
          if (v55 + 63 >= v100) {
            CFIndex v56 = v100;
          }
          uint64_t v101 = v55 - 1;
          CFIndex length = v56;
          v57.CFIndex location = v55 + v99 - 1;
          if (v100 >= v54) {
            CFIndex v58 = v54;
          }
          else {
            CFIndex v58 = v100;
          }
          v57.CFIndex length = v58 + v53;
          CFStringGetCharacters(theString, v57, buffer);
          uint64_t v9 = v101;
        }

        int v50 = &buffer[v38 - v9];
      }

      __int16 v51 = *(v50 - 2);
LABEL_77:
      v14 += 2LL;
      ++v47;
      --v46;
      --v39;
      --v38;
      if (v51 != 32)
      {
        uint64_t v59 = 0LL;
        CFIndex v60 = 1 - v49;
        unsigned int v61 = (char *)buffer - v14;
        CFIndex v62 = v49 + 63;
        int64_t v63 = v49 - 1;
        while (1)
        {
          uint64_t v64 = (unint64_t)v63 >= 0x3F ? 63LL : v63;
          if (v97)
          {
            __int16 v65 = *(_WORD *)(v97 + 2 * (v63 + v99));
          }

          else if (v98)
          {
            __int16 v65 = *(char *)(v98 + v99 + v63);
          }

          else
          {
            if (length <= v63 || v9 > v63)
            {
              uint64_t v67 = -v64;
              uint64_t v68 = v64 + v60;
              CFIndex v69 = v62 - v64;
              uint64_t v70 = v63 + v67;
              CFIndex v71 = v70 + 64;
              if (v70 + 64 >= v100) {
                CFIndex v71 = v100;
              }
              uint64_t v101 = v70;
              CFIndex length = v71;
              v72.CFIndex location = v70 + v99;
              if (v100 >= v69) {
                CFIndex v73 = v69;
              }
              else {
                CFIndex v73 = v100;
              }
              v72.CFIndex length = v73 + v68;
              CFStringGetCharacters(theString, v72, buffer);
              uint64_t v9 = v101;
            }

            __int16 v65 = *(_WORD *)&v61[-2 * v9];
          }

          if (v65 == 32 || v65 == 46) {
            break;
          }
          ++v59;
          --v62;
          v61 -= 2;
          ++v60;
          uint64_t v32 = -1LL;
          BOOL v19 = v63-- <= 1;
          if (v19)
          {
LABEL_135:
            uint64_t v30 = 0LL;
            goto LABEL_61;
          }
        }

        int64_t v94 = v63 + 1;
        int64_t v74 = -v63;
        int64_t v75 = v63 + 64;
        while (1)
        {
          uint64_t v76 = (unint64_t)v63 >= 0x3F ? 63LL : v63;
          if (v97)
          {
            __int16 v77 = *(_WORD *)(v97 + 2 * (v63 + v99));
          }

          else if (v98)
          {
            __int16 v77 = *(char *)(v98 + v99 + v63);
          }

          else
          {
            if (length <= v63 || v9 > v63)
            {
              uint64_t v79 = -v76;
              uint64_t v80 = v76 + v74;
              CFIndex v81 = v75 - v76;
              uint64_t v82 = v63 + v79;
              CFIndex v83 = v82 + 64;
              if (v82 + 64 >= v100) {
                CFIndex v83 = v100;
              }
              uint64_t v101 = v82;
              CFIndex length = v83;
              v84.CFIndex location = v82 + v99;
              if (v100 >= v81) {
                CFIndex v85 = v81;
              }
              else {
                CFIndex v85 = v100;
              }
              v84.CFIndex length = v85 + v80;
              CFStringGetCharacters(theString, v84, buffer);
              uint64_t v9 = v101;
            }

            __int16 v77 = *(_WORD *)&v61[-2 * v9];
          }

          if (v77 != 32) {
            break;
          }
          --v75;
          v61 -= 2;
          ++v74;
          uint64_t v32 = -1LL;
          BOOL v19 = v63-- <= 1;
          if (v19) {
            goto LABEL_135;
          }
        }

        if (v97)
        {
          __int16 v86 = *(_WORD *)(v97 + 2 * (v99 + v63));
          uint64_t v87 = v94;
        }

        else
        {
          uint64_t v87 = v94;
          if (v98)
          {
            __int16 v86 = *(char *)(v98 + v99 + v63);
          }

          else
          {
            if (length <= v63 || v9 > v63)
            {
              uint64_t v88 = 63LL;
              uint64_t v89 = v63 - v88 + 64;
              if (v89 >= v100) {
                uint64_t v89 = v100;
              }
              uint64_t v101 = v63 - v88;
              CFIndex length = v89;
              CFIndex v90 = v75 - v88;
              if (v100 < v75 - v88) {
                CFIndex v90 = v100;
              }
              v104.CFIndex length = v88 + v90 - v63;
              v104.CFIndex location = v63 - v88 + v99;
              CFStringGetCharacters(theString, v104, buffer);
              uint64_t v9 = v101;
            }

            __int16 v86 = *(_WORD *)&v61[-2 * v9];
          }
        }

        BOOL v91 = v86 == 46;
        BOOL v92 = v59 != 0;
        BOOL v93 = !v91 || !v92;
        if (v91 && v92) {
          uint64_t v32 = v87;
        }
        else {
          uint64_t v32 = -1LL;
        }
        if (v93) {
          uint64_t v30 = 0LL;
        }
        else {
          uint64_t v30 = v59;
        }
        goto LABEL_61;
      }
    }
  }

void _CFGetPathExtensionRangesFromPathComponent(const __CFString *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v105 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  CFIndex v101 = 0LL;
  CFIndex v102 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0LL;
  CFIndex v99 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v103 = 0LL;
  CFIndex v104 = 0LL;
  CFIndex v100 = CStringPtr;
  if (Length < 2) {
    goto LABEL_60;
  }
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  unint64_t v12 = Length - 1;
  CFIndex v13 = 1 - Length;
  CFIndex v14 = Length + 63;
  uint64_t v15 = &buffer[Length - 1];
  uint64_t v16 = 2 - 2 * Length;
  while (1)
  {
    CFIndex v17 = Length + v10;
    if (v12 >= 0x3F) {
      uint64_t v18 = 63LL;
    }
    else {
      uint64_t v18 = v12;
    }
    if (v99)
    {
      UniChar v19 = v99[v17 - 1 + v101];
    }

    else if (v100)
    {
      UniChar v19 = v100[v101 - 1 + Length + v10];
    }

    else
    {
      CFIndex v20 = v17 - 1;
      BOOL v21 = v104 > v20 && v11 <= v20;
      if (!v21)
      {
        uint64_t v22 = ~v18;
        uint64_t v23 = v18 ^ 0x3F;
        CFIndex v24 = v14 - v18;
        uint64_t v25 = v18 + v9;
        uint64_t v26 = Length + v10 + v22;
        CFIndex v27 = Length + v10 + v23;
        if (v27 >= v102) {
          CFIndex v27 = v102;
        }
        uint64_t v103 = v26;
        CFIndex v104 = v27;
        v28.CFIndex location = v26 + v101;
        if (v102 >= v24) {
          CFIndex v29 = v24;
        }
        else {
          CFIndex v29 = v102;
        }
        v28.CFIndex length = v13 + v25 + v29;
        CFIndex v30 = v13;
        int v31 = v15;
        CFStringGetCharacters(theString, v28, buffer);
        uint64_t v15 = v31;
        CFIndex v13 = v30;
        uint64_t v11 = v103;
      }

      UniChar v19 = v15[v10 - v11];
    }

    uint64_t v32 = 0LL;
    int v33 = v19;
    uint64_t v34 = -1LL;
    if (v33 > 8233)
    {
      unsigned int v35 = v33 - 8234;
      BOOL v21 = v35 > 0x3F;
      unint64_t v36 = (1LL << v35) & 0xF00000000000001FLL;
      BOOL v37 = v21 || v36 == 0;
      uint64_t v38 = -1LL;
      uint64_t v39 = 0LL;
      if (!v37) {
        goto LABEL_63;
      }
      goto LABEL_37;
    }

    if (v33 > 1563)
    {
      if ((v33 - 8206) < 2)
      {
LABEL_39:
        uint64_t v38 = -1LL;
        uint64_t v39 = 0LL;
        goto LABEL_63;
      }

      uint64_t v38 = -1LL;
      uint64_t v39 = 0LL;
      if (v33 == 1564) {
        goto LABEL_63;
      }
      goto LABEL_37;
    }

    if (v33 == 32) {
      goto LABEL_39;
    }
    if (v33 == 46) {
      break;
    }
    uint64_t v38 = -1LL;
    uint64_t v39 = 0LL;
    if (v33 == 47) {
      goto LABEL_63;
    }
LABEL_37:
    --v12;
    v16 += 2LL;
    --v14;
    --v10;
    ++v9;
    if (Length + v10 <= 1)
    {
      uint64_t v32 = 0LL;
      uint64_t v39 = 0LL;
LABEL_91:
      uint64_t v34 = -1LL;
      goto LABEL_63;
    }
  }

  if (!v10)
  {
    uint64_t v32 = 0LL;
    uint64_t v39 = 0LL;
    goto LABEL_62;
  }

  CFIndex v40 = Length + v10;
  unint64_t v41 = Length + v10 - 1;
  if (v41 > 2) {
    goto LABEL_68;
  }
  if (v99)
  {
    unint64_t v42 = (UniChar *)&v99[v101];
  }

  else
  {
    if ((uint64_t)v41 > v104 || v11 >= 1)
    {
      if (v102 >= 64) {
        v43.CFIndex length = 64LL;
      }
      else {
        v43.CFIndex length = v102;
      }
      uint64_t v103 = 0LL;
      CFIndex v104 = v43.length;
      v43.CFIndex location = v101;
      if (v100)
      {
        if (v43.length)
        {
          UniChar v44 = &v100[v101];
          uint64_t v45 = buffer;
          do
          {
            UniChar v46 = *v44++;
            *v45++ = v46;
            --v43.length;
          }

          while (v43.length);
        }
      }

      else
      {
        CFIndex v47 = v13;
        CFStringGetCharacters(theString, v43, buffer);
        CFIndex v13 = v47;
      }
    }

    uint64_t v11 = v103;
    unint64_t v42 = &buffer[-v103];
  }

  if (*v42 != 46) {
    goto LABEL_68;
  }
  uint64_t v32 = v40 - 2;
  if (v40 == 2) {
    goto LABEL_61;
  }
  if (v42[1] != 46)
  {
LABEL_68:
    uint64_t v38 = Length + v10;
    uint64_t v39 = -v10;
    if (!a3)
    {
LABEL_90:
      uint64_t v32 = 0LL;
      goto LABEL_91;
    }

    CFIndex v48 = v40 + 63;
    CFIndex v49 = v13 - v10;
    while (1)
    {
      if (v41 >= 0x40) {
        uint64_t v50 = 64LL;
      }
      else {
        uint64_t v50 = v41;
      }
      CFIndex v51 = v40 - 1;
      if (v40 - 1 < 2) {
        goto LABEL_90;
      }
      if (v99)
      {
        uint64_t v52 = (UniChar *)&v99[v40 + v101];
      }

      else
      {
        if (v100)
        {
          __int16 v53 = v100[v101 - 2 + v40];
          goto LABEL_79;
        }

        if (v104 < v51 || v11 >= v51)
        {
          uint64_t v54 = -v50;
          uint64_t v55 = v50 + v49;
          CFIndex v56 = v48 - v50;
          CFIndex v57 = v40 + v54;
          CFIndex v58 = v57 + 63;
          if (v57 + 63 >= v102) {
            CFIndex v58 = v102;
          }
          uint64_t v103 = v57 - 1;
          CFIndex v104 = v58;
          v59.CFIndex location = v57 + v101 - 1;
          if (v102 >= v56) {
            CFIndex v60 = v56;
          }
          else {
            CFIndex v60 = v102;
          }
          v59.CFIndex length = v60 + v55;
          CFStringGetCharacters(theString, v59, buffer);
          uint64_t v11 = v103;
        }

        uint64_t v52 = &buffer[v40 - v11];
      }

      __int16 v53 = *(v52 - 2);
LABEL_79:
      v16 += 2LL;
      ++v49;
      --v48;
      --v41;
      --v40;
      if (v53 != 32)
      {
        uint64_t v61 = 0LL;
        CFIndex v62 = 1 - v51;
        int64_t v63 = (char *)buffer - v16;
        CFIndex v64 = v51 + 63;
        int64_t v65 = v51 - 1;
        while (1)
        {
          uint64_t v66 = (unint64_t)v65 >= 0x3F ? 63LL : v65;
          if (v99)
          {
            UniChar v67 = v99[v65 + v101];
          }

          else if (v100)
          {
            UniChar v67 = v100[v101 + v65];
          }

          else
          {
            if (v104 <= v65 || v11 > v65)
            {
              uint64_t v69 = -v66;
              uint64_t v70 = v66 + v62;
              CFIndex v71 = v64 - v66;
              uint64_t v72 = v65 + v69;
              CFIndex v73 = v72 + 64;
              if (v72 + 64 >= v102) {
                CFIndex v73 = v102;
              }
              uint64_t v103 = v72;
              CFIndex v104 = v73;
              v74.CFIndex location = v72 + v101;
              if (v102 >= v71) {
                CFIndex v75 = v71;
              }
              else {
                CFIndex v75 = v102;
              }
              v74.CFIndex length = v75 + v70;
              CFStringGetCharacters(theString, v74, buffer);
              uint64_t v11 = v103;
            }

            UniChar v67 = *(_WORD *)&v63[-2 * v11];
          }

          if (v67 == 32 || v67 == 46) {
            break;
          }
          ++v61;
          --v64;
          v63 -= 2;
          ++v62;
          uint64_t v34 = -1LL;
          BOOL v21 = v65-- <= 1;
          if (v21)
          {
LABEL_137:
            uint64_t v32 = 0LL;
            goto LABEL_63;
          }
        }

        int64_t v96 = v65 + 1;
        int64_t v76 = -v65;
        int64_t v77 = v65 + 64;
        while (1)
        {
          uint64_t v78 = (unint64_t)v65 >= 0x3F ? 63LL : v65;
          if (v99)
          {
            UniChar v79 = v99[v65 + v101];
          }

          else if (v100)
          {
            UniChar v79 = v100[v101 + v65];
          }

          else
          {
            if (v104 <= v65 || v11 > v65)
            {
              uint64_t v81 = -v78;
              uint64_t v82 = v78 + v76;
              CFIndex v83 = v77 - v78;
              uint64_t v84 = v65 + v81;
              CFIndex v85 = v84 + 64;
              if (v84 + 64 >= v102) {
                CFIndex v85 = v102;
              }
              uint64_t v103 = v84;
              CFIndex v104 = v85;
              v86.CFIndex location = v84 + v101;
              if (v102 >= v83) {
                CFIndex v87 = v83;
              }
              else {
                CFIndex v87 = v102;
              }
              v86.CFIndex length = v87 + v82;
              CFStringGetCharacters(theString, v86, buffer);
              uint64_t v11 = v103;
            }

            UniChar v79 = *(_WORD *)&v63[-2 * v11];
          }

          if (v79 != 32) {
            break;
          }
          --v77;
          v63 -= 2;
          ++v76;
          uint64_t v34 = -1LL;
          BOOL v21 = v65-- <= 1;
          if (v21) {
            goto LABEL_137;
          }
        }

        if (v99)
        {
          UniChar v88 = v99[v101 + v65];
          uint64_t v89 = v96;
        }

        else
        {
          uint64_t v89 = v96;
          if (v100)
          {
            UniChar v88 = v100[v101 + v65];
          }

          else
          {
            if (v104 <= v65 || v11 > v65)
            {
              uint64_t v90 = 63LL;
              uint64_t v91 = v65 - v90 + 64;
              if (v91 >= v102) {
                uint64_t v91 = v102;
              }
              uint64_t v103 = v65 - v90;
              CFIndex v104 = v91;
              CFIndex v92 = v77 - v90;
              if (v102 < v77 - v90) {
                CFIndex v92 = v102;
              }
              v106.CFIndex length = v90 + v92 - v65;
              v106.CFIndex location = v65 - v90 + v101;
              CFStringGetCharacters(theString, v106, buffer);
              uint64_t v11 = v103;
            }

            UniChar v88 = *(_WORD *)&v63[-2 * v11];
          }
        }

        BOOL v93 = v88 == 46;
        BOOL v94 = v61 != 0;
        BOOL v95 = !v93 || !v94;
        if (v93 && v94) {
          uint64_t v34 = v89;
        }
        else {
          uint64_t v34 = -1LL;
        }
        if (v95) {
          uint64_t v32 = 0LL;
        }
        else {
          uint64_t v32 = v61;
        }
        goto LABEL_63;
      }
    }
  }

uint64_t _CFExtensionUniCharsIsValidToAppend(uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  CFStringRef theString = 0LL;
  uint64_t v37 = a1;
  uint64_t v38 = 0LL;
  uint64_t v39 = 0LL;
  uint64_t v41 = 0LL;
  uint64_t v42 = 0LL;
  uint64_t v40 = a2;
  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = a2 - 1;
  if (a2 < 1) {
    return 1LL;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = 1 - a2;
  uint64_t v5 = a2 + 63;
  uint64_t v6 = a2 - 1;
  while (1)
  {
    uint64_t v7 = (unint64_t)v6 >= 0x3F ? 63LL : v6;
    if (v37)
    {
      UniChar v8 = *(_WORD *)(v37 + 2 * (v6 + v39));
    }

    else if (v38)
    {
      UniChar v8 = *(char *)(v38 + v39 + v6);
    }

    else
    {
      BOOL v9 = v42 > v6 && v3 <= v6;
      if (!v9)
      {
        uint64_t v10 = -v7;
        uint64_t v11 = v7 + v4;
        uint64_t v12 = v5 - v7;
        uint64_t v13 = v6 + v10;
        uint64_t v14 = v13 + 64;
        if (v13 + 64 >= v40) {
          uint64_t v14 = v40;
        }
        uint64_t v41 = v13;
        uint64_t v42 = v14;
        v15.CFIndex location = v13 + v39;
        if (v40 >= v12) {
          uint64_t v16 = v12;
        }
        else {
          uint64_t v16 = v40;
        }
        v15.CFIndex length = v16 + v11;
        CFStringGetCharacters(theString, v15, buffer);
        uint64_t v3 = v41;
      }

      UniChar v8 = buffer[v6 - v3];
    }

    uint64_t result = 0LL;
    if (v8 <= 0x2029u) {
      break;
    }
    unsigned int v18 = v8 - 8234;
    BOOL v9 = v18 > 0x3F;
    unint64_t v19 = (1LL << v18) & 0xF00000000000001FLL;
    if (!v9 && v19 != 0) {
      return result;
    }
LABEL_35:
    ++v4;
    --v5;
    BOOL v9 = v6-- <= 0;
    if (v9) {
      return 1LL;
    }
  }

  if (v8 > 0x61Bu)
  {
    goto LABEL_35;
  }

  if (v8 == 32) {
    return result;
  }
  if (v8 != 46)
  {
    if (v8 == 47) {
      return result;
    }
    goto LABEL_35;
  }

  if (v6 >= v2) {
    return 0LL;
  }
  uint64_t v21 = v6 + 64;
  uint64_t v22 = -v6;
  for (uint64_t i = v6 + 1; ; --i)
  {
    uint64_t v24 = (unint64_t)v6 >= 0x40 ? 64LL : v6;
    uint64_t v25 = i - 1;
    if (i - 1 < 1) {
      break;
    }
    if (v37)
    {
      UniChar v26 = *(_WORD *)(v37 + 2 * (i + v39) - 4);
    }

    else if (v38)
    {
      UniChar v26 = *(char *)(v38 + v39 + i - 2);
    }

    else
    {
      if (v42 < v25 || v3 >= v25)
      {
        uint64_t v27 = -v24;
        uint64_t v28 = v24 + v22;
        uint64_t v29 = v21 - v24;
        uint64_t v30 = i + v27;
        uint64_t v31 = v30 + 63;
        if (v30 + 63 >= v40) {
          uint64_t v31 = v40;
        }
        uint64_t v41 = v30 - 1;
        uint64_t v42 = v31;
        v32.CFIndex location = v30 + v39 - 1;
        if (v40 >= v29) {
          uint64_t v33 = v29;
        }
        else {
          uint64_t v33 = v40;
        }
        v32.CFIndex length = v33 + v28;
        CFStringGetCharacters(theString, v32, buffer);
        uint64_t v3 = v41;
      }

      UniChar v26 = buffer[i - 2 - v3];
    }

    uint64_t result = 0LL;
    ++v22;
    --v21;
    --v6;
    if (v26 == 47) {
      return result;
    }
  }

  return 1LL;
}

uint64_t _CFExtensionIsValidToAppend(const __CFString *a1)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v42 = 0LL;
  CFIndex v43 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0LL;
  uint64_t v40 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  uint64_t v44 = 0LL;
  uint64_t v45 = 0LL;
  uint64_t v41 = CStringPtr;
  if (!Length) {
    return 0LL;
  }
  uint64_t v5 = Length - 1;
  if (Length < 1) {
    return 1LL;
  }
  uint64_t v6 = 0LL;
  CFIndex v7 = 1 - Length;
  CFIndex v8 = Length + 63;
  uint64_t v9 = Length - 1;
  while (1)
  {
    uint64_t v10 = (unint64_t)v9 >= 0x3F ? 63LL : v9;
    if (v40)
    {
      UniChar v11 = v40[v9 + v42];
    }

    else if (v41)
    {
      UniChar v11 = v41[v42 + v9];
    }

    else
    {
      BOOL v12 = v45 > v9 && v6 <= v9;
      if (!v12)
      {
        uint64_t v13 = -v10;
        uint64_t v14 = v10 + v7;
        CFIndex v15 = v8 - v10;
        uint64_t v16 = v9 + v13;
        CFIndex v17 = v16 + 64;
        if (v16 + 64 >= v43) {
          CFIndex v17 = v43;
        }
        uint64_t v44 = v16;
        uint64_t v45 = v17;
        v18.CFIndex location = v16 + v42;
        if (v43 >= v15) {
          CFIndex v19 = v15;
        }
        else {
          CFIndex v19 = v43;
        }
        v18.CFIndex length = v19 + v14;
        CFStringGetCharacters(theString, v18, buffer);
        uint64_t v6 = v44;
      }

      UniChar v11 = buffer[v9 - v6];
    }

    uint64_t result = 0LL;
    if (v11 <= 0x2029u) {
      break;
    }
    unsigned int v21 = v11 - 8234;
    BOOL v12 = v21 > 0x3F;
    unint64_t v22 = (1LL << v21) & 0xF00000000000001FLL;
    if (!v12 && v22 != 0) {
      return result;
    }
LABEL_37:
    ++v7;
    --v8;
    BOOL v12 = v9-- <= 0;
    if (v12) {
      return 1LL;
    }
  }

  if (v11 > 0x61Bu)
  {
    goto LABEL_37;
  }

  if (v11 == 32) {
    return result;
  }
  if (v11 != 46)
  {
    if (v11 == 47) {
      return result;
    }
    goto LABEL_37;
  }

  if (v9 >= v5) {
    return 0LL;
  }
  uint64_t v24 = v9 + 64;
  uint64_t v25 = -v9;
  for (uint64_t i = v9 + 1; ; --i)
  {
    uint64_t v27 = (unint64_t)v9 >= 0x40 ? 64LL : v9;
    uint64_t v28 = i - 1;
    if (i - 1 < 1) {
      break;
    }
    if (v40)
    {
      UniChar v29 = v40[i - 2 + v42];
    }

    else if (v41)
    {
      UniChar v29 = v41[v42 - 2 + i];
    }

    else
    {
      if (v45 < v28 || v6 >= v28)
      {
        uint64_t v30 = -v27;
        uint64_t v31 = v27 + v25;
        CFIndex v32 = v24 - v27;
        uint64_t v33 = i + v30;
        CFIndex v34 = v33 + 63;
        if (v33 + 63 >= v43) {
          CFIndex v34 = v43;
        }
        uint64_t v44 = v33 - 1;
        uint64_t v45 = v34;
        v35.CFIndex location = v33 + v42 - 1;
        if (v43 >= v32) {
          CFIndex v36 = v32;
        }
        else {
          CFIndex v36 = v43;
        }
        v35.CFIndex length = v36 + v31;
        CFStringGetCharacters(theString, v35, buffer);
        uint64_t v6 = v44;
      }

      UniChar v29 = buffer[i - 2 - v6];
    }

    uint64_t result = 0LL;
    ++v25;
    --v24;
    --v9;
    if (v29 == 47) {
      return result;
    }
  }

  return 1LL;
}

BOOL _CFOperatingSystemVersionIsAtLeastVersion(void *a1)
{
  if (_CFOperatingSystemVersionGetCurrent_onceToken != -1) {
    dispatch_once(&_CFOperatingSystemVersionGetCurrent_onceToken, &__block_literal_global_32);
  }
  uint64_t v3 = a1[1];
  return qword_18C45C918 >= a1[2];
}

uint64_t _CFSuddenTerminationDisablingCount()
{
  return 1LL;
}

CFStringRef _CFCopyLocalizedVersionKey(CFBundleRef *a1, CFStringRef key)
{
  if (a1 && (uint64_t v4 = *a1) != 0LL)
  {
    CFStringRef v5 = CFBundleCopyLocalizedString(*a1, key, key, @"SystemVersion");
  }

  else
  {
    CFStringRef Copy = CFStringCreateCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  @"/System/Library/CoreServices/SystemVersion.bundle");
    CFIndex v7 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, Copy, kCFURLPOSIXPathStyle, 0);
    CFRelease(Copy);
    if (!v7) {
      return (CFStringRef)CFRetain(key);
    }
    uint64_t v4 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
    CFRelease(v7);
    if (!v4) {
      return (CFStringRef)CFRetain(key);
    }
    CFStringRef v5 = CFBundleCopyLocalizedString(v4, key, key, @"SystemVersion");
    if (!a1)
    {
      CFRelease(v4);
      if (v5) {
        return v5;
      }
      return (CFStringRef)CFRetain(key);
    }
  }

  *a1 = v4;
  if (v5) {
    return v5;
  }
  return (CFStringRef)CFRetain(key);
}

void __CFLogCString(uint64_t a1, uint64_t a2)
{
  __s[1] = *(char **)MEMORY[0x1895F89C0];
  CFStringRef v5 = 0LL;
  __s[0] = 0LL;
  uint64_t v4 = 0LL;
  _populateBanner(__s, (char **)&v5, (char **)&v4);
  _logToStderr(__s[0], a1, a2);
  if (v4) {
    free(v4);
  }
  if (v5) {
    free(v5);
  }
  if (__s[0]) {
    free(__s[0]);
  }
}

uint64_t _populateBanner(char **a1, char **a2, char **a3)
{
  v26[1] = *(double *)MEMORY[0x1895F89C0];
  double Current = CFAbsoluteTimeGetCurrent();
  time_t v25 = vcvtmd_s64_f64(Current + 978307200.0);
  localtime_r(&v25, &v24);
  int tm_mon = v24.tm_mon;
  int tm_year = v24.tm_year;
  int tm_hour = v24.tm_hour;
  int tm_mday = v24.tm_mday;
  int tm_sec = v24.tm_sec;
  int tm_min = v24.tm_min;
  double v12 = modf(Current, v26);
  __uint64_t v23 = 0LL;
  if (pthread_threadid_np(0LL, &v23))
  {
    uint64_t v13 = pthread_self();
    __uint64_t v23 = pthread_mach_thread_np(v13);
  }

  unsigned int v14 = vcvtmd_s64_f64(v12 * 1000.0);
  int v15 = tm_mon + 1;
  int v16 = tm_year + 1900;
  CFIndex v17 = (const char *)*_CFGetProgname();
  pid_t v18 = getpid();
  asprintf( a1,  "%04d-%02d-%02d %02d:%02d:%02d.%03d %s[%d:%llu] ",  v16,  v15,  tm_mday,  tm_hour,  tm_min,  tm_sec,  v14,  v17,  v18,  v23);
  CFIndex v19 = pthread_self();
  mach_port_t v20 = pthread_mach_thread_np(v19);
  asprintf(a3, "%x", v20);
  return asprintf(a2, "%04d-%02d-%02d %02d:%02d:%02d.%03d", v16, v15, tm_mday, tm_hour, tm_min, tm_sec, v14);
}

void _logToStderr(char *__s, uint64_t a2, uint64_t a3)
{
  CFStringRef v5 = __s;
  v10[6] = *MEMORY[0x1895F89C0];
  v10[0] = __s;
  if (__s)
  {
    __s = (char *)strlen(__s);
    int v6 = 2;
  }

  else
  {
    int v6 = 1;
  }

  BOOL v7 = v5 == 0LL;
  v10[1] = __s;
  uint64_t v10[2] = a2;
  v10[3] = a3;
  v10[4] = "\n";
  int v8 = *(unsigned __int8 *)(a3 + a2 - 1);
  v10[5] = v8 != 10;
  if (v8 == 10) {
    int v9 = v6;
  }
  else {
    int v9 = v6 + 1;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&_logToStderr_lock);
  writev(2, (const iovec *)&v10[2 * v7], v9);
  os_unfair_lock_unlock((os_unfair_lock_t)&_logToStderr_lock);
}

uint64_t _CFAppVersionCheck(CFTypeRef cf2, const void *a2)
{
  if (_bundleInfo_onceToken != -1) {
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  }
  uint64_t result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if ((_DWORD)result)
  {
    if (!a2) {
      return 1LL;
    }
    uint64_t result = CFEqual((CFTypeRef)_bundleInfo_info_1, a2);
    if ((_DWORD)result) {
      return 1LL;
    }
  }

  return result;
}

uint64_t _CFAppVersionLessThan(CFTypeRef cf2, double a2)
{
  if (_bundleInfo_onceToken != -1) {
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  }
  uint64_t result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if ((_DWORD)result) {
    return *(double *)&_bundleInfo_info_2 < a2 || a2 < 0.0;
  }
  return result;
}

uint64_t _CFAppVersionCheckLessThan(CFTypeRef cf2, int a2, double a3)
{
  if (!cf2) {
    _CFAppVersionCheckLessThan_cold_1();
  }
  if (a2 != -1)
  {
    unint64_t v5 = a2;
    unsigned int active_platform = dyld_get_active_platform();
  }

  if (_bundleInfo_onceToken != -1) {
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  }
  if (!_bundleInfo_info_0) {
    _CFAppVersionCheckLessThan_cold_2();
  }
  uint64_t result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if ((_DWORD)result) {
    return *(double *)&_bundleInfo_info_2 < a3 || a3 < 0.0;
  }
  return result;
}

const char *_CFGetExecutableLinkedLibraryVersion@<X0>(const char *result@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0LL;
  *(_OWORD *)a2 = xmmword_180D68568;
  if (result)
  {
    uint64_t result = (const char *)NSVersionOfLinkTimeLibrary(result);
    if ((_DWORD)result != -1)
    {
      *(void *)a2 = result >> 16;
      *(void *)(a2 + _Block_object_dispose(va, 8) = BYTE1(result);
      *(void *)(a2 + 16) = result;
    }
  }

  return result;
}

uint64_t _CFLibraryVersionCompare(void *a1, void *a2)
{
  BOOL v2 = (*a1 & 0x8000000000000000LL) == 0 && (a1[1] & 0x8000000000000000LL) == 0 && a1[2] >= 0LL;
  if ((*a2 & 0x8000000000000000LL) != 0
    || (a2[1] & 0x8000000000000000LL) != 0
    || ((uint64_t)a2[2] >= 0 ? (BOOL v3 = v2) : (BOOL v3 = 0), !v3))
  {
    if (v2) {
      return -1LL;
    }
    else {
      return 1LL;
    }
  }

  else
  {
    unsigned int v4 = (*a1 << 16) | (*((_DWORD *)a1 + 2) << 8) | *((unsigned __int8 *)a1 + 16);
    unsigned int v5 = (*a2 << 16) | (a2[1] << 8) | a2[2];
    BOOL v6 = v4 == v5;
    BOOL v7 = v4 > v5;
    uint64_t v8 = 1LL;
    if (!v7) {
      uint64_t v8 = -1LL;
    }
    if (v6) {
      return 0LL;
    }
    else {
      return v8;
    }
  }

BOOL _CFLinkedOnOrAfter(__int128 *a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  __int128 v4 = *a1;
  uint64_t v5 = *((void *)a1 + 2);
  v3[1] = 0LL;
  int v3[2] = 0LL;
  v3[0] = a2;
  return _CFLibraryVersionCompare(&v4, v3) != -1;
}

void ___bundleInfo_block_invoke()
{
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle && (InfoDictionary = CFBundleGetInfoDictionary(MainBundle)) != 0LL)
  {
    BOOL v2 = InfoDictionary;
    Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, @"CFBundleIdentifier");
    __int128 v4 = (const __CFString *)CFDictionaryGetValue(v2, @"CFBundleShortVersionString");
    if (Value) {
      CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value);
    }
    else {
      CFStringRef Copy = &stru_1899EF170;
    }
    _bundleInfo_info_0 = (uint64_t)Copy;
    if (v4) {
      uint64_t v6 = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4);
    }
    else {
      uint64_t v6 = &stru_1899EF170;
    }
  }

  else
  {
    uint64_t v6 = &stru_1899EF170;
    _bundleInfo_info_0 = (uint64_t)&stru_1899EF170;
  }

  _bundleInfo_info_1 = (uint64_t)v6;
  _bundleInfo_info_2 = CFStringGetDoubleValue(v6);
}

CFMutableDictionaryRef _CFBundleCreateInfoDictFromMainExecutable()
{
  v3[1] = *MEMORY[0x1895F89C0];
  v3[0] = 0LL;
  SectData = (UInt8 *)getsegbyname("__TEXT");
  if (SectData)
  {
    SectData = (UInt8 *)_CFBundleGetSectData("__TEXT", "__info_plist", v3);
    CFIndex v1 = LODWORD(v3[0]);
  }

  else
  {
    CFIndex v1 = 0LL;
  }

  return _CFBundleCreateInfoDictFromData(SectData, v1);
}

const section_64 *_CFBundleGetSectData(const char *a1, const char *a2, uint64_t *a3)
{
  uint32_t v6 = _dyld_image_count();
  BOOL v7 = _NSGetMachExecuteHeader();
  if (v6)
  {
    uint64_t v8 = (const mach_header *)v7;
    uint32_t v9 = 0;
    while (v8 != _dyld_get_image_header(v9))
    {
      if (v6 == ++v9) {
        goto LABEL_5;
      }
    }

    uint64_t result = getsectbynamefromheader_64((const mach_header_64 *)v8, a1, a2);
    if (result)
    {
      double v12 = result;
      uint64_t addr = result->addr;
      uint64_t result = (const section_64 *)(_dyld_get_image_vmaddr_slide(v9) + addr);
      uint64_t size = v12->size;
      if (!a3) {
        return result;
      }
    }

    else
    {
      uint64_t size = 0LL;
      if (!a3) {
        return result;
      }
    }
  }

  else
  {
LABEL_5:
    uint64_t size = 0LL;
    uint64_t result = 0LL;
    if (!a3) {
      return result;
    }
  }

  *a3 = size;
  return result;
}

CFMutableDictionaryRef _CFBundleCreateInfoDictFromData(UInt8 *bytes, CFIndex length)
{
  CFMutableDictionaryRef Mutable = 0LL;
  if (bytes && (_DWORD)length)
  {
    BOOL v3 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  bytes,  length,  (CFAllocatorRef)&__kCFAllocatorNull);
    if (v3)
    {
      __int128 v4 = v3;
      uint64_t v5 = (__CFDictionary *)CFPropertyListCreateWithData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v3,  1uLL,  0LL,  0LL);
      if (v5)
      {
        CFMutableDictionaryRef Mutable = v5;
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(Mutable))
        {
          CFRelease(v4);
LABEL_10:
          _CFBundleInfoPlistProcessInfoDictionary(Mutable);
          return Mutable;
        }

        CFRelease(Mutable);
      }

      CFRelease(v4);
    }

    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (Mutable) {
      goto LABEL_10;
    }
  }

  return Mutable;
}

uint64_t _CFBundleGrokObjCImageInfoFromMainExecutable(_DWORD *a1, _DWORD *a2)
{
  v8[1] = *MEMORY[0x1895F89C0];
  v8[0] = 0LL;
  uint64_t result = (uint64_t)getsegbyname("__DATA");
  if (!result)
  {
    int v6 = 0;
    int v7 = 0;
    goto LABEL_7;
  }

  SectData = _CFBundleGetSectData("__DATA", "__objc_imageinfo", v8);
  uint64_t result = 0LL;
  if (SectData)
  {
    int v6 = 0;
    int v7 = 0;
    if (v8[0] >= 8)
    {
      int v6 = *(_DWORD *)SectData->sectname;
      int v7 = *(_DWORD *)&SectData->sectname[4];
      uint64_t result = 1LL;
      if (!a1) {
        goto LABEL_9;
      }
LABEL_8:
      *a1 = v6;
      goto LABEL_9;
    }

CFStringRef _CFBundleCopyFileTypeForFileURL(const __CFURL *a1, int32x4_t a2)
{
  v3[1] = *(CFStringRef *)MEMORY[0x1895F89C0];
  v3[0] = 0LL;
  _CFBundleGrokFileType(a1, 0LL, v3, 0LL, 0LL, 0LL, 0LL, 0LL, a2, 0LL);
  return v3[0];
}

BOOL _CFBundleGrokFileType( const __CFURL *a1, const __CFData *a2, CFStringRef *a3, int *a4, const __CFArray **a5, CFMutableDictionaryRef *a6, char *a7, unsigned int *a8, int32x4_t a9, unsigned int *a10)
{
  uint64_t v151 = *MEMORY[0x1895F89C0];
  char v147 = 0;
  if (a5) {
    *a5 = 0LL;
  }
  if (a6) {
    *a6 = 0LL;
  }
  if (a7) {
    *a7 = 0;
  }
  if (a8) {
    *a8 = 0;
  }
  if (a10) {
    *a10 = 0;
  }
  if (a1
    && CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026LL)
    && !stat((const char *)buffer, &valuePtr)
    && (valuePtr.st_mode & 0xF000) == 0x8000)
  {
    int v17 = open((const char *)buffer, 0, 511LL);
    int v18 = v17;
    if (v17 < 0)
    {
      int v144 = 0;
      st_uint64_t size = 0LL;
      ssize_t v20 = 0LL;
      CFIndex v19 = 0LL;
      if (!a2) {
        goto LABEL_22;
      }
    }

    else
    {
      CFIndex v19 = (unsigned __int16 *)v150;
      ssize_t v20 = read(v17, v150, 0x200uLL);
      int v144 = 1;
      st_uint64_t size = valuePtr.st_size;
      if (!a2) {
        goto LABEL_22;
      }
    }
  }

  else
  {
    int v144 = 0;
    st_uint64_t size = 0LL;
    ssize_t v20 = 0LL;
    CFIndex v19 = 0LL;
    int v18 = -1;
    if (!a2) {
      goto LABEL_22;
    }
  }

  if (!v144)
  {
    CFIndex Length = CFDataGetLength(a2);
    unint64_t v22 = a2;
    off_t v23 = Length;
    BytePtr = CFDataGetBytePtr(v22);
    CFIndex v19 = (unsigned __int16 *)BytePtr;
    if (!v23)
    {
      int v30 = 0;
      uint64_t v27 = "txt";
      if (!BytePtr) {
        goto LABEL_521;
      }
      uint64_t v146 = 0LL;
      st_uint64_t size = 0LL;
      goto LABEL_506;
    }

    st_uint64_t size = v23;
    ssize_t v20 = v23;
  }

LABEL_488:
      int v30 = v139;
      CFNumberRef v114 = v133;
      if (a5 && v133)
      {
        *a5 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)buffer,  1LL,  &kCFTypeArrayCallBacks);
        CFNumberRef v114 = *(CFNumberRef *)buffer;
      }

      if (v114) {
        CFRelease(v114);
      }
      int v26 = v134;
      goto LABEL_494;
    }

    CFStringRef v131 = v60;
    int v134 = -17958194;
    unsigned int v139 = *((_DWORD *)__s1 + 3);
    valuePtr.st_dev = *((_DWORD *)__s1 + 1);
    if (a5)
    {
      CFNumberRef v133 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
      *(void *)stat buffer = v133;
    }

    else
    {
      CFNumberRef v133 = 0LL;
    }

    if (a3 && v139 == 2) {
      *CFStringRef v131 = _CFBundleGrokX11FromFile(v18, (uint64_t)__s1, v146, 0, 0, 0);
    }
    if (a6) {
      *a6 = _CFBundleCreateInfoDictFromFile(v18, (UInt8 *)__s1, v146, 0, 0, 0);
    }
    if (!a7 && !a8 && !a10) {
      goto LABEL_488;
    }
    CFAllocatorRef v127 = a10;
    int v109 = v18;
    uint64_t v110 = (uint64_t)__s1;
    uint64_t v111 = v146;
    int v112 = 0;
LABEL_486:
    int v113 = 0;
    goto LABEL_487;
  }

  if (v26 > -822415875)
  {
    if (v26 != -822415874)
    {
      if (v26 != -805638658) {
        goto LABEL_216;
      }
      CFRange v130 = v60;
      int v134 = -805638658;
      uint64_t v137 = a3;
      unsigned int v70 = *((_DWORD *)__s1 + 3);
      valuePtr.st_dev = bswap32(*((_DWORD *)__s1 + 1));
      if (a5)
      {
        CFNumberRef v133 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
        *(void *)stat buffer = v133;
      }

      else
      {
        CFNumberRef v133 = 0LL;
      }

      if (v137 && v70 == 0x2000000) {
        *CFRange v130 = _CFBundleGrokX11FromFile(v18, (uint64_t)__s1, v146, 0, 1, 1);
      }
      unsigned int v139 = bswap32(v70);
      if (a6) {
        *a6 = _CFBundleCreateInfoDictFromFile(v18, (UInt8 *)__s1, v146, 0, 1, 1);
      }
      a3 = v137;
      if (a7 || a8 || a10)
      {
        CFAllocatorRef v127 = a10;
        int v109 = v18;
        uint64_t v110 = (uint64_t)__s1;
        uint64_t v111 = v146;
        int v112 = 1;
        goto LABEL_465;
      }

      goto LABEL_488;
    }

    CFRange v132 = v60;
    int v134 = -822415874;
    uint64_t v138 = a3;
    unsigned int v81 = *((_DWORD *)__s1 + 3);
    valuePtr.st_dev = bswap32(*((_DWORD *)__s1 + 1));
    if (a5)
    {
      CFNumberRef v133 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
      *(void *)stat buffer = v133;
    }

    else
    {
      CFNumberRef v133 = 0LL;
    }

    if (v138 && v81 == 0x2000000) {
      *CFRange v132 = _CFBundleGrokX11FromFile(v18, (uint64_t)__s1, v146, 0, 1, 0);
    }
    unsigned int v139 = bswap32(v81);
    if (a6) {
      *a6 = _CFBundleCreateInfoDictFromFile(v18, (UInt8 *)__s1, v146, 0, 1, 0);
    }
    a3 = v138;
    if (!a7 && !a8 && !a10) {
      goto LABEL_488;
    }
    CFAllocatorRef v127 = a10;
    int v109 = v18;
    uint64_t v110 = (uint64_t)__s1;
    uint64_t v111 = v146;
    int v112 = 1;
    goto LABEL_486;
  }

  if (v26 == -1095041334)
  {
    CFRange v126 = a8;
    CFIndex v128 = a10;
    int v61 = v18;
    CFIndex v62 = (UInt8 *)__s1;
    uint64_t v63 = v20;
    int v64 = 1;
    goto LABEL_312;
  }

  if (v26 != -889275714)
  {
LABEL_216:
    int v30 = 0;
    goto LABEL_217;
  }

  CFRange v126 = a8;
  CFIndex v128 = a10;
  int v61 = v18;
  CFIndex v62 = (UInt8 *)__s1;
  uint64_t v63 = v20;
  int v64 = 0;
LABEL_312:
  uint64_t v78 = a6;
  int v79 = v26;
  int v80 = _CFBundleGrokMachTypeForFatFile(v61, v62, v63, v64, v60, a5, v78, a7, v126, v128);
  int v26 = v79;
  int v30 = v80;
LABEL_494:
  ssize_t v20 = v146;
  switch(v30)
  {
    case 1:
      uint64_t v27 = "o";
      goto LABEL_505;
    case 2:
      if (v147) {
        uint64_t v27 = "x11app";
      }
      else {
        uint64_t v27 = "tool";
      }
      int v30 = 2;
      goto LABEL_505;
    case 3:
    case 5:
    case 7:
      break;
    case 4:
      uint64_t v27 = "core";
      goto LABEL_505;
    case 6:
      uint64_t v27 = "dylib";
      goto LABEL_505;
    case 8:
      uint64_t v27 = "bundle";
      goto LABEL_505;
    default:
      if (v30 == 4096)
      {
        uint64_t v27 = "pef";
        goto LABEL_505;
      }

      ssize_t v20 = v146;
      break;
  }

LABEL_217:
  if (v28 <= 1112493394)
  {
    if (v28 > 626017349)
    {
      if (v28 > 808923190)
      {
        switch(v28)
        {
          case 808923191:
            if (v20 < 6) {
              goto LABEL_432;
            }
            CFIndex v19 = (unsigned __int16 *)__s1;
            if (__s1[4] != 48) {
              goto LABEL_536;
            }
            break;
          case 1031365221:
            if (v20 < 12) {
              goto LABEL_432;
            }
            CFIndex v19 = (unsigned __int16 *)__s1;
            if (*((_DWORD *)__s1 + 1) != 544106855) {
              goto LABEL_536;
            }
            int v71 = *((_DWORD *)__s1 + 2);
            if (v71 == 1701734764) {
              goto LABEL_425;
            }
            int v72 = 1953653104;
            goto LABEL_424;
          case 1094922544:
            CFIndex v19 = (unsigned __int16 *)__s1;
            if (v20 < 6 || __s1[4] != 49) {
              goto LABEL_536;
            }
            break;
          default:
            goto LABEL_142;
        }

        goto LABEL_536;
      }

      switch(v28)
      {
        case 626017350:
          if (v20 >= 6)
          {
            CFIndex v19 = (unsigned __int16 *)__s1;
            if (__s1[4] == 45) {
              goto LABEL_425;
            }
            goto LABEL_536;
          }

          goto LABEL_432;
        case 675567430:
          if (v20 < 6) {
            goto LABEL_432;
          }
          CFIndex v19 = (unsigned __int16 *)__s1;
          int v71 = *((unsigned __int16 *)__s1 + 2);
          int v72 = 22048;
          break;
        case 807842421:
          CFIndex v19 = (unsigned __int16 *)__s1;
          if (v20 < 8) {
            goto LABEL_536;
          }
          int v71 = *((_DWORD *)__s1 + 1);
          int v72 = 298804878;
          break;
        default:
          goto LABEL_142;
      }
    }

    else
    {
      if (v28 < 0x10000)
      {
        if (v28 != -1991225785)
        {
          if (v28 != -791735840)
          {
            if (v28 != 12) {
              goto LABEL_142;
            }
            CFIndex v19 = (unsigned __int16 *)__s1;
            if (v20 >= 6)
            {
              int v71 = *((unsigned __int16 *)__s1 + 2);
              int v72 = 20586;
              goto LABEL_424;
            }

LABEL_536:
            uint64_t v27 = 0LL;
            goto LABEL_31;
          }

          if (v20 < 52) {
            goto LABEL_142;
          }
          CFIndex v19 = (unsigned __int16 *)__s1;
          uint64_t v91 = _CFBundleGrokFileTypeForOLEFile( v18,  (uint64_t)__s1,  v20,  ((*((_DWORD *)__s1 + 12) << 9) + 512));
LABEL_413:
          uint64_t v27 = v91;
          goto LABEL_506;
        }

        if (v20 >= 8)
        {
          CFIndex v19 = (unsigned __int16 *)__s1;
          int v71 = *((_DWORD *)__s1 + 1);
          int v72 = 169478669;
          goto LABEL_424;
        }

LABEL_424:
    if (v71 == v72) {
      goto LABEL_425;
    }
    goto LABEL_536;
  }

  if (v28 <= 1400141157)
  {
    if (v28 > 1230262091)
    {
      if (v28 == 1230262092)
      {
        if (v20 < 8) {
          goto LABEL_432;
        }
        CFIndex v19 = (unsigned __int16 *)__s1;
        int v71 = *((_DWORD *)__s1 + 1);
        int v72 = 1397511241;
        goto LABEL_424;
      }

      if (v28 == 1347093252)
      {
        CFIndex v19 = (unsigned __int16 *)__s1;
        uint64_t v91 = _CFBundleGrokFileTypeForZipFile(v18, (uint64_t)__s1, v20, st_size);
        goto LABEL_413;
      }

      if (v28 != 1380533830) {
        goto LABEL_142;
      }
      if (v20 < 12) {
        goto LABEL_432;
      }
      CFIndex v19 = (unsigned __int16 *)__s1;
      unsigned int v77 = bswap32(*((_DWORD *)__s1 + 2));
      if (v77 == 1096173856)
      {
        uint64_t v27 = "avi";
        goto LABEL_506;
      }

      if (v77 == 1463899717)
      {
        uint64_t v27 = "wav";
        goto LABEL_506;
      }
    }

    else
    {
      if (v28 == 1112493395)
      {
        if (v20 < 8) {
          goto LABEL_432;
        }
        CFIndex v19 = (unsigned __int16 *)__s1;
        int v71 = *((_DWORD *)__s1 + 1);
        int v72 = 1701998452;
        goto LABEL_424;
      }

      if (v28 != 1179603533)
      {
        if (v28 != 1195984440) {
          goto LABEL_142;
        }
        CFIndex v19 = (unsigned __int16 *)__s1;
        if (v20 < 6) {
          goto LABEL_536;
        }
        int v71 = *((unsigned __int16 *)__s1 + 2);
        if (v71 == 24887) {
          goto LABEL_425;
        }
        int v72 = 24889;
        goto LABEL_424;
      }

      if (v20 < 12) {
        goto LABEL_432;
      }
      CFIndex v19 = (unsigned __int16 *)__s1;
      unsigned int v92 = bswap32(*((_DWORD *)__s1 + 2));
      if (v92 == 4278598)
      {
        uint64_t v27 = "aifc";
        goto LABEL_506;
      }

      if (v92 == 1095321158)
      {
        uint64_t v27 = "aiff";
        goto LABEL_506;
      }
    }

    uint64_t v27 = 0LL;
    ssize_t v20 = v146;
    goto LABEL_31;
  }

  if (v28 > 1734962543)
  {
    if (v28 != 1734962544)
    {
      if (v28 != 1920231012)
      {
        if (v28 != 2069656180) {
          goto LABEL_142;
        }
        CFIndex v19 = (unsigned __int16 *)__s1;
        if (v20 >= 6 && __s1[4] == 102) {
          goto LABEL_425;
        }
        goto LABEL_536;
      }

      if (v20 >= 8)
      {
        CFIndex v19 = (unsigned __int16 *)__s1;
        if (!*((_DWORD *)__s1 + 1)) {
          goto LABEL_425;
        }
        goto LABEL_536;
      }

      goto LABEL_432;
    }

    if (v20 < 8) {
      goto LABEL_432;
    }
    CFIndex v19 = (unsigned __int16 *)__s1;
    int v71 = *((_DWORD *)__s1 + 1);
    int v72 = 1717794848;
    goto LABEL_424;
  }

  if (v28 == 1400141158)
  {
    if (v20 < 8) {
      goto LABEL_432;
    }
    CFIndex v19 = (unsigned __int16 *)__s1;
    int v71 = *((_DWORD *)__s1 + 1);
    int v72 = 544491878;
    goto LABEL_424;
  }

  if (v28 != 1650812777)
  {
    if (v28 != 1667327590) {
      goto LABEL_142;
    }
    CFIndex v19 = (unsigned __int16 *)__s1;
    if (v20 < 12 || __s1[4]) {
      goto LABEL_536;
    }
    int v71 = *((_DWORD *)__s1 + 2);
    int v72 = 1668506980;
    goto LABEL_424;
  }

  if (v20 < 76) {
    goto LABEL_432;
  }
  CFIndex v19 = (unsigned __int16 *)__s1;
  if (__s1[4] != 110
    || __s1[5] != 32
    || __s1[6] - 48 > 9
    || __s1[7] - 48 > 9)
  {
    goto LABEL_536;
  }

  int v93 = v26;
  BOOL v94 = a3;
  if (__s1[8] - 48 > 9)
  {
    uint64_t v27 = 0LL;
  }

  else
  {
    if (__s1[9] != 32) {
      goto LABEL_588;
    }
    uint64_t v95 = 0LL;
    do
    {
      int v96 = __s1[v95 + 10];
      uint64_t v97 = v95 + 11;
      ++v95;
    }

    while (v96 != 10 && v97 < v146);
    uint64_t v99 = v95 + 9;
    unint64_t v100 = v96 == 10 ? v99 : 0LL;
    if (v100 >= 0xA && (unint64_t v101 = v100 + 62, (uint64_t)(v100 + 62) < v146) && __s1[v100 + 1] == 77 && __s1[v101] == 10)
    {
      CFIndex v102 = __s1 + 1;
      uint64_t v103 = MEMORY[0x1895F8770];
      do
      {
        uint64_t v104 = v102[v100];
        if (v102[v100] < 0) {
          int v105 = __maskrune(v104, 0x40000uLL);
        }
        else {
          int v105 = *(_DWORD *)(v103 + 4 * v104 + 60) & 0x40000;
        }
        unint64_t v106 = v100 + 2;
        ++v100;
        if (v105) {
          BOOL v107 = v106 >= v101;
        }
        else {
          BOOL v107 = 1;
        }
      }

      while (!v107);
      if (v105) {
        uint64_t v27 = "uu";
      }
      else {
        uint64_t v27 = 0LL;
      }
    }

    else
    {
LABEL_588:
      uint64_t v27 = 0LL;
    }

    a3 = v94;
    int v18 = v141;
    CFIndex v19 = (unsigned __int16 *)__s1;
  }

  ssize_t v20 = v146;
  int v26 = v93;
LABEL_31:
  if (!a3 || v27) {
    goto LABEL_44;
  }
  unsigned int v31 = *v19;
  if (v20 < 5)
  {
    BOOL v65 = 0;
    char v66 = 0;
    goto LABEL_188;
  }

  unsigned int v32 = v31 >> 8;
  if (!*((_BYTE *)v19 + 3) && !*((_BYTE *)v19 + 4))
  {
    if (v32)
    {
      if (v32 != 1 || (v19[1] & 0xF7) != 1) {
        goto LABEL_36;
      }
    }

    else if ((v19[1] & 0xF6) != 2)
    {
      goto LABEL_36;
    }

    uint64_t v27 = "tga";
    goto LABEL_444;
  }

LABEL_310:
    uint64_t v27 = "qtif";
    goto LABEL_444;
  }

  if (v33 == 1952539753) {
    goto LABEL_310;
  }
  if (v33 == 1952539757) {
    goto LABEL_444;
  }
  int v34 = 1987014509;
LABEL_249:
  if (v33 == v34) {
    goto LABEL_444;
  }
  if (v26 == 1768714338
    && (unsigned __int16)*((_DWORD *)v19 + 1) == 29811
    && (HIWORD(v33) & 0xFE) - 48 <= 9u
    && HIBYTE(v33) - 48 <= 9u)
  {
    uint64_t v27 = "plist";
    if ((unint64_t)v20 >= 0x18)
    {
      unint64_t v73 = 8LL;
      do
      {
        int v74 = strncmp((const char *)v19 + v73, "WebMainResource", 0xFuLL);
        if (!v74) {
          break;
        }
        if (v73 > 0x7E) {
          break;
        }
        uint64_t v75 = v73 + 17;
        ++v73;
      }

      while (v75 <= v146);
      if (!v74) {
        uint64_t v27 = "webarchive";
      }
      int v18 = v141;
      goto LABEL_506;
    }

LABEL_444:
    int v18 = v141;
    goto LABEL_507;
  }

  BOOL v65 = (unint64_t)v20 > 0xB;
  if (*v19 || (unint64_t)v20 < 0xC)
  {
    if (v31 == 19778 && (unint64_t)v20 >= 0x12)
    {
      int v119 = *(_DWORD *)(v19 + 7);
      uint64_t v27 = "bmp";
      int v18 = v141;
      if (v119 == 108 || v119 == 124) {
        goto LABEL_507;
      }
      goto LABEL_43;
    }
  }

  else if (v33 == 1887007846)
  {
    signed int v108 = bswap32(*((_DWORD *)v19 + 2));
    if (v108 > 1769172785)
    {
      uint64_t v27 = "mp4";
      int v18 = v141;
      if (v108 == 1769172845) {
        goto LABEL_507;
      }
    }

    else
    {
      int v18 = v141;
      if (v108 > 1295275551)
      {
        if ((v108 - 1295275552) <= 0x30
          && ((1LL << (v108 - 32)) & 0x1010000000001LL) != 0)
        {
          uint64_t v27 = "m4v";
          goto LABEL_507;
        }
      }

      else
      {
        switch(v108)
        {
          case 1295270176:
            uint64_t v27 = "m4a";
            goto LABEL_507;
          case 1295270432:
            uint64_t v27 = "m4b";
            goto LABEL_507;
          case 1295274016:
            uint64_t v27 = "m4p";
            goto LABEL_507;
        }
      }
    }

    if (HIWORD(v108) != 13159)
    {
      uint64_t v27 = 0LL;
LABEL_592:
      int v18 = v141;
      CFIndex v19 = (unsigned __int16 *)__s1;
LABEL_593:
      ssize_t v20 = v146;
LABEL_44:
      if (!a3 || v27) {
        goto LABEL_425;
      }
      uint64_t v135 = a4;
      uint64_t v136 = a3;
      int v142 = v18;
      if (*(unsigned __int8 *)v19 == 239 && *((unsigned __int8 *)v19 + 1) == 187)
      {
        int v35 = *((unsigned __int8 *)v19 + 2);
        BOOL v36 = v35 != 191;
        if (v35 == 191) {
          uint64_t v37 = 3LL;
        }
        else {
          uint64_t v37 = 0LL;
        }
      }

      else
      {
        uint64_t v37 = 0LL;
        BOOL v36 = 1;
      }

      if (v20 >= 512) {
        uint64_t v38 = 512LL;
      }
      else {
        uint64_t v38 = v20;
      }
      BOOL v39 = 1;
      char v40 = 1;
      int v41 = 1;
      while (1)
      {
        if (v37 >= v38)
        {
          a4 = v135;
          a3 = v136;
          int v18 = v142;
LABEL_166:
          if (v40)
          {
            uint64_t v27 = "afm";
            goto LABEL_425;
          }

          uint64_t v27 = 0LL;
          if (v36 && v20 >= 512 && st_size >= 526)
          {
            if (v144)
            {
              if (lseek(v18, 512LL, 0) == 512 && read(v18, v150, 0x200uLL) >= 14)
              {
                if (*(_DWORD *)((char *)&v150[2] + 2) != -16641792)
                {
LABEL_427:
                  ssize_t v20 = v146;
                  goto LABEL_428;
                }

LABEL_277:
                uint64_t v27 = "pict";
                goto LABEL_507;
              }
            }

            else if ((unint64_t)v20 >= 0x20E)
            {
              if (*(_DWORD *)((char *)v140 + 265) != -16641792)
              {
LABEL_428:
                uint64_t v27 = 0LL;
                if (v20 < 512 || st_size < 512) {
                  goto LABEL_521;
                }
                goto LABEL_510;
              }

              goto LABEL_277;
            }

            uint64_t v27 = 0LL;
          }

LABEL_425:
          if (!a3) {
            goto LABEL_526;
          }
          if (v27) {
            goto LABEL_507;
          }
          goto LABEL_427;
        }

        uint64_t v42 = (char *)v19 + v37;
        __darwin_ct_rune_t v43 = *v42;
        ssize_t v44 = v37 + 14;
        if (v39 && v43 == 60 && v44 <= v20)
        {
          int v46 = strncasecmp_l(v42 + 1, "!doctype html", 0xDuLL, 0LL);
          ssize_t v20 = v146;
          if (v46) {
            uint64_t v27 = 0LL;
          }
          else {
            uint64_t v27 = "html";
          }
          if (!v41) {
            goto LABEL_115;
          }
        }

        else
        {
          uint64_t v27 = 0LL;
          if (!v41) {
            goto LABEL_115;
          }
        }

        if (v43 != 60 || v44 > v20) {
          goto LABEL_115;
        }
        CFIndex v48 = v42 + 1;
        if (!strncasecmp_l(v48, "!doctype html", 0xDuLL, 0LL)
          || !strncasecmp_l(v48, "head", 4uLL, 0LL)
          || !strncasecmp_l(v48, "title", 5uLL, 0LL)
          || !strncasecmp_l(v48, "script", 6uLL, 0LL)
          || !strncasecmp_l(v48, "html", 4uLL, 0LL))
        {
          uint64_t v27 = "html";
LABEL_114:
          ssize_t v20 = v146;
          goto LABEL_115;
        }

        if (strncasecmp_l(v48, "?xml", 4uLL, 0LL)) {
          goto LABEL_114;
        }
        uint64_t v49 = v37 + 4;
        BOOL v50 = v27 != 0LL;
        ssize_t v20 = v146;
        if (!v27 && v37 <= 123)
        {
          for (ssize_t i = v37 + 24; i <= v20; ssize_t i = v54 + 21)
          {
            uint64_t v52 = &__s1[v49];
            if (__s1[v49] == 60)
            {
              __int16 v53 = v52 + 1;
              if (!strncasecmp_l(v52 + 1, "abiword", 7uLL, 0LL))
              {
                uint64_t v27 = "abw";
                goto LABEL_100;
              }

              if (!strncasecmp_l(v53, "!doctype svg", 0xCuLL, 0LL))
              {
                uint64_t v27 = "svg";
                goto LABEL_100;
              }

              if (!strncasecmp_l(v53, "!doctype rdf", 0xCuLL, 0LL))
              {
                uint64_t v27 = "rdf";
                goto LABEL_100;
              }

              if (!strncasecmp_l(v53, "!doctype x3d", 0xCuLL, 0LL))
              {
                uint64_t v27 = "x3d";
                goto LABEL_100;
              }

              if (!strncasecmp_l(v53, "!doctype html", 0xDuLL, 0LL))
              {
                uint64_t v27 = "html";
                goto LABEL_100;
              }

              if (!strncasecmp_l(v53, "!doctype posingfont", 0x13uLL, 0LL))
              {
                uint64_t v27 = "sfont";
                goto LABEL_100;
              }

              if (strncasecmp_l(v53, "!doctype plist", 0xEuLL, 0LL))
              {
                uint64_t v27 = 0LL;
LABEL_100:
                uint64_t v54 = v49;
                ssize_t v20 = v146;
                goto LABEL_101;
              }

              uint64_t v54 = v49 + 14;
              ssize_t v20 = v146;
              if (v49 + 30 <= v146)
              {
                do
                {
                  int v55 = strncmp(&__s1[v54], "WebMainResource", 0xFuLL);
                  ssize_t v20 = v146;
                  uint64_t v56 = v54 + 1;
                  if (!v55) {
                    break;
                  }
                  if (v54 > 254) {
                    break;
                  }
                  uint64_t v57 = v54 + 17;
                  ++v54;
                }

                while (v57 <= v146);
                if (v55) {
                  uint64_t v27 = "plist";
                }
                else {
                  uint64_t v27 = "webarchive";
                }
                uint64_t v54 = v56;
              }

              else
              {
                uint64_t v27 = "plist";
              }
            }

            else
            {
              uint64_t v27 = 0LL;
              uint64_t v54 = v49;
            }

LABEL_101:
            uint64_t v49 = v54 + 1;
            BOOL v50 = v27 != 0LL;
            if (v27 || v54 > 126) {
              break;
            }
          }
        }

        if (!v50) {
          uint64_t v27 = "xml";
        }
        uint64_t v37 = v49;
LABEL_115:
        if (v43) {
          BOOL v36 = 0;
        }
        CFIndex v19 = (unsigned __int16 *)__s1;
        if (v36 || v43 == 127)
        {
          char v40 = 0;
          if (v36) {
            goto LABEL_129;
          }
        }

        else
        {
          if (v43 > 31) {
            goto LABEL_127;
          }
          if (v43 < 0)
          {
            int v58 = __maskrune(v43, 0x4000uLL);
            ssize_t v20 = v146;
            if (v58) {
              goto LABEL_127;
            }
          }

          else if ((*(_DWORD *)(MEMORY[0x1895F8770] + 4LL * v43 + 60) & 0x4000) != 0)
          {
            goto LABEL_127;
          }

          char v40 = 0;
        }

        *int v6 = v8;
        return v9;
      default:
        goto LABEL_93;
    }
  }

LABEL_127:
        if ((v43 & 0x80000000) == 0)
        {
LABEL_129:
          int v41 = 0;
          goto LABEL_130;
        }

        int v59 = __maskrune(v43, 0x4000uLL);
        ssize_t v20 = v146;
        if (!v59) {
          goto LABEL_129;
        }
LABEL_130:
        BOOL v39 = v40 != 0;
        if (v40 | v36)
        {
          ++v37;
          if (!v27) {
            continue;
          }
        }

        a4 = v135;
        a3 = v136;
        int v18 = v142;
        if (v27) {
          goto LABEL_425;
        }
        goto LABEL_166;
      }
    }

    *(int8x8_t *)a9.i8 = vand_s8((int8x8_t)vdup_n_s32(v108), (int8x8_t)0xFDFF0000FFFELL);
    uint64_t v27 = "3gp";
    if ((vmaxv_u16((uint16x4_t)vmovn_s32( vceqq_s32( vzip1q_s32(a9, vdupq_lane_s32(*(int32x2_t *)a9.i8, 0)),  (int32x4_t)xmmword_180D68590))) & 1) == 0 && (unsigned __int16)v108 != 26422)
    {
      else {
        uint64_t v27 = 0LL;
      }
      goto LABEL_592;
    }

LABEL_594:
    int v18 = v141;
    CFIndex v19 = (unsigned __int16 *)__s1;
    goto LABEL_507;
  }

  if (!strncmp((const char *)v19 + 6, "%!PS-AdobeFont", 0xEuLL))
  {
    uint64_t v27 = "pfb";
    goto LABEL_444;
  }

  ssize_t v20 = v146;
  if (*(_DWORD *)(v19 + 17) == 1215195458 && v19[19] == 30821)
  {
    uint64_t v27 = "hqx";
    goto LABEL_444;
  }

  if ((unint64_t)v146 < 0x80)
  {
LABEL_577:
    BOOL v65 = 1;
LABEL_578:
    char v66 = 1;
    goto LABEL_187;
  }

  uint64_t v27 = "bin";
  if (*(_DWORD *)(v19 + 51) == 1313423981) {
    goto LABEL_444;
  }
  if (!*(_BYTE *)v19 && v32 - 1 <= 0x3E && !__s1[74] && !__s1[82] && (st_size & 0x7F) == 0)
  {
    CFIndex v19 = (unsigned __int16 *)__s1;
    unsigned int v120 = bswap32(*(_DWORD *)(__s1 + 83));
    unsigned int v121 = bswap32(*(_DWORD *)(__s1 + 87));
    unsigned int v122 = ((v120 + 127) >> 7) + ((v121 + 127) >> 7) + 1;
    if (st_size != v122 << 7 || v122 <= 1 || v121 >= 0x800000 || v120 >= 0x800000) {
      uint64_t v27 = 0LL;
    }
    int v18 = v141;
    goto LABEL_593;
  }

  if ((unint64_t)v146 >= 0x109 && *v140 == 1635021685)
  {
    uint64_t v27 = "tar";
  }

  BOOL v65 = 1;
  char v66 = 1;
  int v18 = v141;
  CFIndex v19 = (unsigned __int16 *)__s1;
  ssize_t v20 = v146;
LABEL_188:
  int v67 = __rev16(v31);
  if (v67 > 18755)
  {
    if (v67 > 63233)
    {
      if (v67 > 65495)
      {
        if (v67 == 65496)
        {
          if (*((unsigned __int8 *)v19 + 2) == 255)
          {
            uint64_t v27 = "jpeg";
            goto LABEL_507;
          }

          goto LABEL_353;
        }

        int v69 = 65534;
      }

      else
      {
        if (v67 == 63234)
        {
          uint64_t v27 = "dvi";
          goto LABEL_507;
        }

        int v69 = 65279;
      }

      if (v67 == v69)
      {
        if (v65)
        {
          if (*(_DWORD *)v19 == -115712)
          {
            if (*((_DWORD *)v19 + 1) != 1744860160 || *((_DWORD *)v19 + 2) != 1828744192) {
              goto LABEL_169;
            }
          }

          else if (*(_DWORD *)v19 != 3997439 || *((_DWORD *)v19 + 1) != 7602280 || *((_DWORD *)v19 + 2) != 7077997)
          {
            goto LABEL_169;
          }

          uint64_t v27 = "html";
          goto LABEL_507;
        }

LABEL_169:
        uint64_t v27 = "txt";
        goto LABEL_507;
      }

      goto LABEL_353;
    }

    if (v67 == 18756)
    {
      if (*((_BYTE *)v19 + 2) == 51 && *((unsigned __int8 *)v19 + 3) < 0x20u)
      {
        uint64_t v27 = "mp3";
        goto LABEL_507;
      }
    }

    else if (v67 == 29127 || v67 == 51057)
    {
      uint64_t v27 = "cpio";
      goto LABEL_507;
    }

LABEL_353:
    int v90 = v19[1];
    uint64_t v27 = "tfm";
    if (v90 == 4352 || v90 == 4608) {
      goto LABEL_507;
    }
    goto LABEL_43;
  }

  if (v67 <= 8992)
  {
    switch(v67)
    {
      case 474:
        if (*((unsigned __int8 *)v19 + 2) <= 1u && *((unsigned __int8 *)v19 + 3) - 1 < 0xF)
        {
          uint64_t v27 = "sgi";
          goto LABEL_507;
        }

        break;
      case 8075:
        uint64_t v27 = "gz";
        goto LABEL_507;
      case 8093:
        uint64_t v27 = "Z";
        goto LABEL_507;
    }

    goto LABEL_353;
  }

  if (v67 > 17238)
  {
    if (v67 == 17239)
    {
      if (*((_BYTE *)v19 + 2) == 83)
      {
        uint64_t v27 = "swc";
        goto LABEL_507;
      }
    }

    else if (v67 == 18007 && *((_BYTE *)v19 + 2) == 83)
    {
      uint64_t v27 = "swf";
      goto LABEL_507;
    }

    goto LABEL_353;
  }

  if (v67 == 8993)
  {
    uint64_t v82 = 0LL;
    do
    {
      int v83 = *((unsigned __int8 *)v19 + v82 + 2);
      ssize_t v84 = v82 + 3;
      ++v82;
    }

    while (v83 != 10 && v84 < v20);
    uint64_t v27 = 0LL;
    do
    {
      if (*((_BYTE *)v19 + v82) == 47) {
        uint64_t v86 = v82;
      }
      else {
        uint64_t v86 = 0LL;
      }
      --v82;
    }

    while (!v86);
    if (v86)
    {
      CFIndex v87 = (char *)v19 + v86 + 1;
      if (!strncmp(v87, "perl", 4uLL))
      {
        uint64_t v27 = "pl";
      }

      else if (!strncmp(v87, "python", 6uLL))
      {
        uint64_t v27 = "py";
      }

      else if (!strncmp(v87, "ruby", 4uLL))
      {
        uint64_t v27 = "rb";
      }

      else
      {
        uint64_t v27 = "sh";
      }

      goto LABEL_506;
    }

    goto LABEL_43;
  }

  if (v67 != 16986) {
    goto LABEL_353;
  }
  int v68 = *((unsigned __int8 *)v19 + 2);
  if ((v68 - 48) <= 9 && *((unsigned __int8 *)v19 + 3) - 48 < 0xA)
  {
    uint64_t v27 = "bz";
    goto LABEL_507;
  }

  if (v68 != 104) {
    goto LABEL_353;
  }
  char v88 = v66 ^ 1;
  if ((v88 & 1) != 0) {
    goto LABEL_353;
  }
  int v89 = *((_DWORD *)v19 + 1);
  uint64_t v27 = "bz2";
  if (v89 != 643383601 && v89 != 944075287) {
    goto LABEL_353;
  }
LABEL_507:
  if (strcmp(v27, "bz2")) {
    goto LABEL_521;
  }
  ssize_t v20 = v146;
  if (v146 < 512 || st_size <= 511) {
    goto LABEL_521;
  }
LABEL_510:
  if (!v144)
  {
    CFStringRef v116 = (char *)v19 + v20;
    if (*(_DWORD *)((char *)v19 + v20 - 512) != 2037149547)
    {
      if (*((_DWORD *)v116 - 2) != 1634952291) {
        goto LABEL_521;
      }
      int v115 = *((_DWORD *)v116 - 1);
LABEL_519:
      if (v115 != 1919118949) {
        goto LABEL_521;
      }
    }

LABEL_520:
    uint64_t v27 = "dmg";
    goto LABEL_521;
  }

  if (lseek(v18, st_size - 512, 0) == st_size - 512 && read(v18, v150, 0x200uLL) >= 512)
  {
    if (v150[0] != 2037149547)
    {
      if (v150[126] != 1634952291) {
        goto LABEL_521;
      }
      int v115 = v150[127];
      goto LABEL_519;
    }

    goto LABEL_520;
  }

LABEL_521:
  if (a3)
  {
    if (v27) {
      CFStringRef v117 = CFStringCreateWithCStringNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v27,  0x8000100u,  (CFAllocatorRef)&__kCFAllocatorNull);
    }
    else {
      CFStringRef v117 = 0LL;
    }
    *a3 = v117;
  }

LABEL_526:
  if (a4) {
    *a4 = v30;
  }
  if ((v18 & 0x80000000) == 0) {
    close(v18);
  }
  return v27 != 0LL;
}

CFStringRef _CFBundleCopyFileTypeForFileData(const __CFData *a1, int32x4_t a2)
{
  v3[1] = *(CFStringRef *)MEMORY[0x1895F89C0];
  v3[0] = 0LL;
  _CFBundleGrokFileType(0LL, a1, v3, 0LL, 0LL, 0LL, 0LL, 0LL, a2, 0LL);
  return v3[0];
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryForExecutableFileData( const __CFData *a1, BOOL *a2, int32x4_t a3)
{
  v6[1] = *(CFMutableDictionaryRef *)MEMORY[0x1895F89C0];
  v6[0] = 0LL;
  int v5 = 0;
  _CFBundleGrokFileType(0LL, a1, 0LL, &v5, 0LL, v6, 0LL, 0LL, a3, 0LL);
  if (a2) {
    *a2 = (v5 & 0xFFFFFFFB) == 2;
  }
  return v6[0];
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInExecutable(const __CFURL *a1, int32x4_t a2)
{
  v3[1] = *(CFMutableDictionaryRef *)MEMORY[0x1895F89C0];
  v3[0] = 0LL;
  _CFBundleGrokFileType(a1, 0LL, 0LL, 0LL, 0LL, v3, 0LL, 0LL, a2, 0LL);
  return v3[0];
}

CFArrayRef _CFBundleCopyArchitecturesForExecutable(const __CFURL *a1, int32x4_t a2)
{
  v3[1] = *(const __CFArray **)MEMORY[0x1895F89C0];
  v3[0] = 0LL;
  _CFBundleGrokFileType(a1, 0LL, 0LL, 0LL, v3, 0LL, 0LL, 0LL, a2, 0LL);
  return v3[0];
}

uint64_t _CFBundleGetObjCImageInfo(__CFBundle *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  unsigned int v10 = 0;
  unsigned int v11 = 0;
  int v5 = CFBundleCopyExecutableURL(a1);
  if (v5)
  {
    int v7 = v5;
    unsigned __int8 v12 = 0;
    _CFBundleGrokFileType(v5, 0LL, 0LL, 0LL, 0LL, 0LL, (char *)&v12, &v11, v6, &v10);
    uint64_t v8 = v12;
    CFRelease(v7);
    if (!a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  uint64_t v8 = 0LL;
  if (a2) {
LABEL_3:
  }
    *a2 = v11;
LABEL_4:
  if (a3) {
    *a3 = v10;
  }
  return v8;
}

uint64_t _CFBundleGrokBinaryType(const __CFURL *a1, int32x4_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a1) {
    uint64_t v2 = 6LL;
  }
  else {
    uint64_t v2 = 7LL;
  }
  int v8 = 0;
  if (_CFBundleGrokFileType(a1, 0LL, 0LL, &v8, 0LL, 0LL, 0LL, 0LL, a2, 0LL))
  {
    if (v8 == 4096) {
      int v3 = 1;
    }
    else {
      int v3 = v2;
    }
    if (v8 == 8) {
      unsigned int v4 = 3;
    }
    else {
      unsigned int v4 = v3;
    }
    if (v8 == 6) {
      int v5 = 4;
    }
    else {
      int v5 = v2;
    }
    if (v8 == 2) {
      unsigned int v6 = 2;
    }
    else {
      unsigned int v6 = v5;
    }
    if (v8 <= 7) {
      return v6;
    }
    else {
      return v4;
    }
  }

  return v2;
}

const char *_CFBundleGrokFileTypeForZipFile(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = a1;
  if (a3 < 31)
  {
    uint64_t v57 = 0LL;
    uint64_t v58 = 0LL;
    __int128 v56 = 0uLL;
    uint64_t v59 = 0LL;
    int v33 = 0;
    uint64_t v9 = "zip";
    goto LABEL_125;
  }

  int v55 = 0;
  uint64_t v57 = 0LL;
  uint64_t v58 = 0LL;
  __int128 v56 = 0uLL;
  uint64_t v59 = 0LL;
  uint64_t v8 = 0LL;
  unint64_t v53 = a2 + a3;
  uint64_t v9 = "zip";
  while (1)
  {
    unsigned int v10 = (const char *)(a2 + v8);
    if (*(_BYTE *)(a2 + v8) != 80 || *(_BYTE *)(v8 + a2 + 1) != 75) {
      goto LABEL_12;
    }
    int v11 = *(unsigned __int8 *)(v8 + a2 + 2);
    if (v11 != 3) {
      break;
    }
    if (*(_BYTE *)(v8 + a2 + 3) == 4)
    {
      unsigned int v13 = 30;
      char v12 = 1;
      uint64_t v14 = 26LL;
      goto LABEL_11;
    }

LABEL_133:
          uint64_t v40 = 0LL;
          while (2)
          {
            uint64_t v41 = v37 + v40;
            if (*(_BYTE *)(v37 + v40) != 80 || *(_BYTE *)(v40 + v37 + 1) != 75) {
              goto LABEL_185;
            }
            int v42 = *(unsigned __int8 *)(v40 + v37 + 2);
            if (v42 != 3)
            {
              if (v42 == 1 && *(_BYTE *)(v40 + v37 + 3) == 2)
              {
                unsigned int v43 = 46;
                uint64_t v44 = 28LL;
                goto LABEL_142;
              }

              goto LABEL_185;
            }

            if (*(_BYTE *)(v40 + v37 + 3) != 4) {
              goto LABEL_185;
            }
            unsigned int v43 = 30;
            uint64_t v44 = 26LL;
LABEL_142:
            uint64_t v45 = *(unsigned __int16 *)(v41 + v44);
            if (v40 + v43 + v45 > 1024)
            {
LABEL_185:
              BOOL v34 = v40++ < 993;
              if (!v34) {
                goto LABEL_192;
              }
              continue;
            }

            break;
          }

          uint64_t v46 = v43;
          if (*(unsigned __int16 *)(v41 + v44) <= 0x12u)
          {
            if ((_DWORD)v45 == 9)
            {
              if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/", 9uLL, 0LL))
              {
                LODWORD(v56) = 1;
                goto LABEL_184;
              }

              goto LABEL_161;
            }

            if ((_DWORD)v45 == 11)
            {
              if (!strncasecmp_l((const char *)(v41 + v43), "content.xml", 0xBuLL, 0LL))
              {
                DWORD1(v56) = 1;
                goto LABEL_184;
              }

              if (!strncasecmp_l((const char *)(v41 + v46), "_rels/.rels", 0xBuLL, 0LL))
              {
                LODWORD(v59) = 1;
                goto LABEL_184;
              }

              goto LABEL_161;
            }
          }

          else
          {
            switch((_DWORD)v45)
            {
              case 0x13:
                if (!strncasecmp_l((const char *)(v41 + v43), "[Content_Types].xml", 0x13uLL, 0LL))
                {
                  HIDWORD(v59) = 1;
                  goto LABEL_184;
                }

                goto LABEL_161;
              case 0x14:
                if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/MANIFEST.MF", 0x14uLL, 0LL))
                {
                  int v33 = 1;
                  goto LABEL_184;
                }

                goto LABEL_161;
              case 0x15:
                if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/manifest.xml", 0x15uLL, 0LL))
                {
                  DWORD2(v56) = 1;
                  goto LABEL_184;
                }

LABEL_161:
                CFIndex v47 = (const char *)(v41 + v46);
                if (!strncasecmp_l(&v47[v45 - 4], ".opf", 4uLL, 0LL))
                {
                  HIDWORD(v5_Block_object_dispose(va, 8) = 1;
                  goto LABEL_184;
                }

                if (!strncasecmp_l(&v47[v45 - 4], ".sml", 4uLL, 0LL)) {
                  goto LABEL_182;
                }
                if (!strncasecmp_l(&v47[v45 - 5], ".smil", 5uLL, 0LL))
                {
LABEL_182:
                  HIDWORD(v57) = 1;
                  goto LABEL_184;
                }

                if (strncasecmp_l(v47, "xl/", 3uLL, 0LL) || strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0LL))
                {
                  if (!strncasecmp_l(v47, "ppt/", 4uLL, 0LL) && !strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0LL))
                  {
                    int v49 = 1;
LABEL_189:
                    HIDWORD(v56) = v49;
                    goto LABEL_184;
                  }

                  if (!strncasecmp_l(v47, "word/", 5uLL, 0LL) && !strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0LL))
                  {
                    LODWORD(v5_Block_object_dispose(va, 8) = 1;
                    goto LABEL_184;
                  }

                  if (v45 < 0xB)
                  {
LABEL_184:
                    v40 += (v46 + v45 - 1);
                    goto LABEL_185;
                  }

                  if (strncasecmp_l(v47, "excel/", 6uLL, 0LL) || strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0LL))
                  {
                    int v48 = strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0LL);
                    int v49 = HIDWORD(v56);
                    if (!v48) {
                      int v49 = 1;
                    }
                    goto LABEL_189;
                  }
                }

                LODWORD(v57) = 1;
                goto LABEL_184;
            }
          }

          goto LABEL_161;
        }
      }
    }

    BOOL v39 = 0LL;
LABEL_192:
    if (v33)
    {
LABEL_193:
      uint64_t v9 = "jar";
    }

    else
    {
      BOOL v50 = v59 != 0;
      if (v59 && (_DWORD)v58)
      {
        uint64_t v9 = "docx";
      }

      else
      {
        if ((_DWORD)v57) {
          BOOL v51 = v59 != 0;
        }
        else {
          BOOL v51 = 0;
        }
        if (v51)
        {
          uint64_t v9 = "xlsx";
        }

        else
        {
          if (!BYTE12(v56)) {
            BOOL v50 = 0;
          }
          if (v50)
          {
            uint64_t v9 = "pptx";
          }

          else if (*(void *)((char *)&v56 + 4))
          {
            uint64_t v9 = "odt";
          }

          else
          {
            if ((_DWORD)v56) {
              goto LABEL_193;
            }
            if (HIDWORD(v58) && HIDWORD(v57))
            {
              uint64_t v9 = "dtb";
            }

            else if (HIDWORD(v58))
            {
              uint64_t v9 = "oeb";
            }
          }
        }
      }
    }

    if (v39) {
      free(v39);
    }
  }

  return v9;
}

const char *_CFBundleGrokFileTypeForOLEFile(int a1, uint64_t a2, off_t a3, off_t a4)
{
  if (a1 < 0 || lseek(a1, a4, 0) != a4)
  {
    int v11 = "ole";
    if (a4 + 512 > a3 || !a2) {
      return v11;
    }
    uint64_t v9 = 0LL;
    unsigned int v10 = (unsigned __int8 *)(a2 + a4);
  }

  else
  {
    uint64_t v8 = (unsigned __int8 *)malloc(0x200uLL);
    if (!v8) {
      return "ole";
    }
    uint64_t v9 = v8;
    if (read(a1, v8, 0x200uLL) <= 511)
    {
      int v11 = "ole";
      goto LABEL_60;
    }

    unsigned int v10 = v9;
  }

  unint64_t v12 = 0LL;
  int v11 = "xls";
  while (1)
  {
    unint64_t v13 = v12 << 7;
    unsigned int v14 = v10[128 * v12 + 64];
    int v15 = (int)((v14 + (v14 >> 7)) << 24) >> 25;
    int v16 = v14 & 0xFE;
    if (v16 <= 25)
    {
      if (v16 == 10)
      {
        unint64_t v29 = (v15 - 1);
        if (v15 == 1) {
          goto LABEL_56;
        }
        uint64_t v30 = 0LL;
        unint64_t v31 = 0LL;
        unsigned int v32 = &v10[v13];
        do
        {
          int v33 = v32[v30 & 0xFFFFFFFE];
          int v34 = aBook[v31++];
          v30 += 2LL;
        }

        while (v33 == v34 && v31 < v29);
        if (v33 == v34) {
          goto LABEL_56;
        }
      }

      else if (v16 == 18)
      {
        unint64_t v17 = (v15 - 1);
        if (!(_DWORD)v17) {
          goto LABEL_56;
        }
        uint64_t v18 = 0LL;
        unint64_t v19 = 0LL;
        do
        {
          int v20 = v10[v13 + (v18 & 0xFFFFFFFE)];
          int v21 = aWorkbook[v19++];
          v18 += 2LL;
          BOOL v22 = v20 != v21 || v19 >= v17;
        }

        while (!v22);
        if (v20 == v21) {
          goto LABEL_56;
        }
      }

      goto LABEL_50;
    }

    if (v16 != 40) {
      break;
    }
    unsigned int v36 = v15 - 1;
    if (!v36) {
      goto LABEL_55;
    }
    uint64_t v37 = 0LL;
    unint64_t v38 = 0LL;
    BOOL v39 = &v10[v13];
    do
    {
      int v40 = v39[v37 & 0xFFFFFFFE];
      int v41 = aPowerpointDocu[v38++];
      v37 += 2LL;
    }

    while (v40 == v41 && v38 < v36);
    if (v40 == v41)
    {
LABEL_55:
      int v11 = "ppt";
LABEL_56:
      if (v9) {
        goto LABEL_60;
      }
      return v11;
    }

BOOL _CFBundleGrokX11FromFile(int a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t v11 = a4;
  if ((a1 & 0x80000000) == 0 && lseek(a1, a4, 0) == a4)
  {
    unint64_t v13 = malloc(0x1000uLL);
    if (v13)
    {
      unsigned int v14 = v13;
      if (read(a1, v13, 0x1000uLL) <= 4095)
      {
        BOOL v19 = 0LL;
LABEL_51:
        free(v14);
        return v19;
      }

      int v40 = v14;
      int v15 = (unsigned int *)v14;
      if (!a6) {
        goto LABEL_6;
      }
      goto LABEL_15;
    }

    return 0LL;
  }

  int v15 = (unsigned int *)(a2 + v11);
  if (a4 + 4096 > a3 || v15 == 0LL) {
    return 0LL;
  }
  int v40 = 0LL;
  if (!a6)
  {
LABEL_6:
    unsigned int v16 = v15[4];
    if (a5)
    {
      unsigned int v16 = bswap32(v16);
      unsigned int v17 = bswap32(v15[5]);
    }

    else
    {
      unsigned int v17 = v15[5];
    }

    if (v17 <= 0xFE4) {
      unint64_t v30 = v17 + 28LL;
    }
    else {
      unint64_t v30 = 4096LL;
    }
    if (v16) {
      BOOL v31 = v30 >= 0x1D;
    }
    else {
      BOOL v31 = 0;
    }
    if (!v31)
    {
      BOOL v19 = 0LL;
      goto LABEL_50;
    }

    int v33 = (int *)(v15 + 7);
    unsigned int v34 = 1;
    unint64_t v35 = 28LL;
    while (1)
    {
      int v36 = *v33;
      if (a5) {
        break;
      }
      if (v36 == 12)
      {
        unsigned int v37 = v33[2];
LABEL_59:
        unint64_t v38 = (char *)v15 + v35 + v37;
        BOOL v19 = v38 + 20 <= (const char *)v15 + v30 && strncmp(v38, "/usr/X11R6/lib/libX", 0x13uLL) == 0;
        unsigned int v39 = v33[1];
        if (a5) {
          goto LABEL_64;
        }
        goto LABEL_65;
      }

      BOOL v19 = 0LL;
      unsigned int v39 = v33[1];
LABEL_66:
      if (v34 < v16)
      {
        v35 += v39;
        int v33 = (int *)((char *)v15 + v35);
        ++v34;
        if (v35 < v30) {
          continue;
        }
      }

      goto LABEL_50;
    }

    if (v36 == 201326592)
    {
      unsigned int v37 = bswap32(v33[2]);
      goto LABEL_59;
    }

    BOOL v19 = 0LL;
    unsigned int v39 = v33[1];
LABEL_64:
    unsigned int v39 = bswap32(v39);
LABEL_65:
    if (v19) {
      goto LABEL_50;
    }
    goto LABEL_66;
  }

CFMutableDictionaryRef _CFBundleCreateInfoDictFromFile( int a1, UInt8 *a2, unint64_t st_size, int a4, int a5, int a6)
{
  LODWORD(v_Block_object_dispose(va, 8) = a4;
  uint64_t v66 = *MEMORY[0x1895F89C0];
  if (a1 < 0 || fstat(a1, &v65))
  {
    uint64_t v58 = 0LL;
  }

  else
  {
    int v15 = (UInt8 *)mmap(0LL, v65.st_size, 1, 8194, a1, 0LL);
    if (v15 == (UInt8 *)-1LL)
    {
      uint64_t v58 = -1LL;
    }

    else
    {
      st_uint64_t size = v65.st_size;
      uint64_t v58 = (uint64_t)v15;
      a2 = v15;
    }
  }

  uint64_t v8 = v8;
  unint64_t v12 = (unsigned int *)&a2[v8];
  int v62 = a5;
  CFIndex v60 = v12;
  uint64_t v61 = v8;
  if (!a6)
  {
    unsigned int v16 = v12[4];
    if (a5)
    {
      unsigned int v16 = bswap32(v16);
      unsigned int v17 = bswap32(v12[5]);
    }

    else
    {
      unsigned int v17 = v12[5];
    }

    int v36 = (int *)(v12 + 7);
    unint64_t v37 = (unint64_t)v12 + v17 + 28;
    uint64_t v57 = &a2[st_size];
    else {
      unint64_t v38 = (unint64_t)&a2[st_size];
    }
    if (v16) {
      BOOL v39 = (unint64_t)v36 >= v38;
    }
    else {
      BOOL v39 = 1;
    }
    if (v39) {
      goto LABEL_65;
    }
    int v41 = 0;
    CFMutableDictionaryRef InfoDictFromData = 0LL;
    unint64_t v42 = 28LL;
    unsigned int v64 = v16;
    while (1)
    {
      int v43 = *v36;
      if (a5) {
        break;
      }
      if (v43 == 1)
      {
        unsigned int v44 = v36[12];
        goto LABEL_74;
      }

      unsigned int v49 = v36[1];
LABEL_88:
      if (++v41 < v16)
      {
        v42 += v49;
        int v36 = (int *)((char *)v12 + v42);
      }

      goto LABEL_66;
    }

    if (v43 == 0x1000000)
    {
      unsigned int v44 = bswap32(v36[12]);
LABEL_74:
      int v45 = 0;
      if (v44 && (unint64_t)v12 + v42 + 56 < v38)
      {
        uint64_t v46 = v8 + v42;
        unsigned int v47 = 1;
        while (1)
        {
          int v48 = &a2[v46];
          if (!strncmp((const char *)&a2[v46 + 56], "__info_plist", 0x10uLL)
            && !strncmp((const char *)v48 + 72, "__TEXT", 0x10uLL))
          {
            break;
          }

          if (v47 < v44)
          {
            v46 += 68LL;
            ++v47;
          }

          int v45 = 0;
          a5 = v62;
          unint64_t v12 = v60;
          uint64_t v8 = v61;
          goto LABEL_82;
        }

        BOOL v51 = &a2[v46];
        CFIndex v52 = *(unsigned int *)&a2[v46 + 92];
        a5 = v62;
        unint64_t v12 = v60;
        if (v62)
        {
          CFIndex v52 = bswap32(v52);
          unsigned int v53 = bswap32(*((_DWORD *)v51 + 24));
        }

        else
        {
          unsigned int v53 = *((_DWORD *)v51 + 24);
        }

        uint64_t v8 = v61;
        unsigned int v16 = v64;
        uint64_t v54 = (UInt8 *)v60 + v53;
        int v45 = 1;
      }

      else
      {
LABEL_82:
        unsigned int v16 = v64;
      }

      unsigned int v49 = v36[1];
      if (!a5)
      {
LABEL_87:
        if (v45) {
          goto LABEL_66;
        }
        goto LABEL_88;
      }
    }

    else
    {
      int v45 = 0;
      unsigned int v49 = v36[1];
    }

    unsigned int v49 = bswap32(v49);
    goto LABEL_87;
  }

  unsigned int v13 = v12[4];
  if (a5)
  {
    unsigned int v13 = bswap32(v13);
    unsigned int v14 = bswap32(v12[5]);
  }

  else
  {
    unsigned int v14 = v12[5];
  }

  uint64_t v18 = (int *)(v12 + 8);
  unint64_t v19 = (unint64_t)v12 + v14 + 32;
  __int128 v56 = &a2[st_size];
  else {
    unint64_t v20 = (unint64_t)&a2[st_size];
  }
  if (v13) {
    BOOL v21 = (unint64_t)v18 >= v20;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    int v22 = 0;
    CFMutableDictionaryRef InfoDictFromData = 0LL;
    unint64_t v23 = 32LL;
    unsigned int v63 = v13;
    while (1)
    {
      int v24 = *v18;
      if (a5) {
        break;
      }
      if (v24 == 25)
      {
        unsigned int v25 = v18[16];
        goto LABEL_26;
      }

      unsigned int v30 = v18[1];
LABEL_40:
      if (++v22 < v13)
      {
        v23 += v30;
        uint64_t v18 = (int *)((char *)v12 + v23);
      }

      goto LABEL_66;
    }

    if (v24 == 419430400)
    {
      unsigned int v25 = bswap32(v18[16]);
LABEL_26:
      int v26 = 0;
      if (v25 && (unint64_t)v12 + v23 + 72 < v20)
      {
        uint64_t v27 = v8 + v23;
        unsigned int v28 = 1;
        while (1)
        {
          unsigned int v29 = &a2[v27];
          if (!strncmp((const char *)&a2[v27 + 72], "__info_plist", 0x10uLL)
            && !strncmp((const char *)v29 + 88, "__TEXT", 0x10uLL))
          {
            break;
          }

          if (v28 < v25)
          {
            v27 += 80LL;
            ++v28;
          }

          int v26 = 0;
          a5 = v62;
          unint64_t v12 = v60;
          uint64_t v8 = v61;
          goto LABEL_34;
        }

        unsigned int v32 = &a2[v27];
        unint64_t v33 = *(void *)&a2[v27 + 112];
        a5 = v62;
        if (v62)
        {
          unint64_t v33 = bswap64(v33);
          unsigned int v34 = bswap32(*((_DWORD *)v32 + 30));
        }

        else
        {
          unsigned int v34 = *((_DWORD *)v32 + 30);
        }

        unint64_t v12 = v60;
        uint64_t v8 = v61;
        unsigned int v13 = v63;
        int v26 = 1;
        if (!HIDWORD(v33))
        {
          unint64_t v35 = (UInt8 *)v60 + v34;
          if (a2 <= v35 && &v35[v33] <= v56)
          {
            CFMutableDictionaryRef InfoDictFromData = _CFBundleCreateInfoDictFromData(v35, v33);
            int v26 = 1;
          }
        }
      }

      else
      {
LABEL_34:
        unsigned int v13 = v63;
      }

      unsigned int v30 = v18[1];
      if (!a5)
      {
LABEL_39:
        if (v26) {
          goto LABEL_66;
        }
        goto LABEL_40;
      }
    }

    else
    {
      int v26 = 0;
      unsigned int v30 = v18[1];
    }

    unsigned int v30 = bswap32(v30);
    goto LABEL_39;
  }

void _CFBundleGrokObjcImageInfoFromFile( int a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, char *a7, unsigned int *a8, unsigned int *a9)
{
  uint64_t v84 = *MEMORY[0x1895F89C0];
  uint64_t v17 = a4;
  if (a1 < 0 || lseek(a1, a4, 0) != a4)
  {
    unint64_t v20 = (unsigned int *)(a2 + v17);
    if (a4 + 4096 <= a3 && v20 != 0LL)
    {
      unint64_t v19 = 0LL;
      goto LABEL_12;
    }

uint64_t _CFBundleGrokMachTypeForFatFile( int a1, UInt8 *a2, uint64_t a3, int a4, BOOL *a5, const __CFArray **a6, CFMutableDictionaryRef *a7, char *a8, unsigned int *a9, unsigned int *a10)
{
  uint64_t v68 = *MEMORY[0x1895F89C0];
  uint64_t v18 = NXGetLocalArchInfo();
  cpu_type_t v19 = _CFBundleCurrentArchitecture();
  if (a5) {
    *a5 = 0;
  }
  unsigned int v63 = a5;
  if (a6) {
    *a6 = 0LL;
  }
  unint64_t v20 = a9;
  if (a7) {
    *a7 = 0LL;
  }
  if (a8) {
    *a8 = 0;
  }
  if (a9) {
    *a9 = 0;
  }
  int v62 = a7;
  if (a10) {
    *a10 = 0;
  }
  if (a3 >= 512) {
    uint64_t v21 = 512LL;
  }
  else {
    uint64_t v21 = a3;
  }
  __memmove_chk();
  if (a4 && a3 >= 1)
  {
    uint64_t v22 = 0LL;
    do
    {
      *(_DWORD *)&v65[v22 + 32] = bswap32(*(_DWORD *)&v65[v22 + 32]);
      v22 += 4LL;
    }

    while (v21 > v22);
  }

  else {
    uint32_t v23 = v66;
  }
  if (!v23) {
    return 0LL;
  }
  if (v18) {
    char v24 = NXFindBestFatArch(v18->cputype, v18->cpusubtype, v67, v23);
  }
  else {
    char v24 = 0LL;
  }
  int v25 = a1;
  unsigned int v26 = a2;
  if (!v24 && v19) {
    char v24 = NXFindBestFatArch(v19, 0, v67, v23);
  }
  unsigned int v64 = v24;
  if (a6)
  {
    unsigned int v27 = v67;
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
    uint64_t v29 = -(uint64_t)v23;
    do
    {
      CFNumberRef v30 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, v27);
      v69.CFIndex length = CFArrayGetCount(Mutable);
      v69.CFIndex location = 0LL;
      if (CFArrayGetFirstIndexOfValue(Mutable, v69, v30) < 0) {
        CFArrayAppendValue(Mutable, v30);
      }
      CFRelease(v30);
      ++v27;
    }

    while (!__CFADD__(v29++, 1LL));
    *a6 = Mutable;
    unint64_t v20 = a9;
    char v24 = v64;
  }

  if (v25 < 0
    || (v24 ? (unint64_t v32 = &v24->offset) : (unint64_t v32 = &v67[0].offset),
        (BOOL v37 = lseek(v25, *v32, 0) == *v32, v24 = v64, !v37)
     || (v33 = (int *)v65, BOOL v34 = read(v25, v65, 0x20uLL) <= 31, v24 = v64, v34)))
  {
    p_offset = &v67[0].offset;
    if (v24) {
      p_offset = &v24->offset;
    }
    uint64_t v36 = *p_offset;
    int v33 = (int *)&v26[v36];
    BOOL v37 = v36 + 32 > (unint64_t)a3 || v33 == 0LL;
    if (v37) {
      return 0LL;
    }
  }

  uint64_t v38 = 0LL;
  int v40 = *v33;
  if (*v33 <= -17958195)
  {
    if (v40 != -822415874)
    {
      if (v40 == -805638658)
      {
        unsigned int v41 = v33[3];
        if (v63 && v41 == 0x2000000)
        {
          unsigned int v42 = &v67[0].offset;
          if (v24) {
            unsigned int v42 = &v24->offset;
          }
          *unsigned int v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v42, 1, 1);
          char v24 = v64;
        }

        uint64_t v38 = bswap32(v41);
        if (v62)
        {
          int v43 = (int *)&v67[0].offset;
          if (v24) {
            int v43 = (int *)&v24->offset;
          }
          *int v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v43, 1, 1);
          char v24 = v64;
        }

        if (a8 || v20 || a10)
        {
          BOOL v44 = &v67[0].offset;
          if (v24) {
            BOOL v44 = &v24->offset;
          }
          unsigned int v45 = *v44;
          unsigned int v61 = a10;
          int v46 = v25;
          uint64_t v47 = (uint64_t)v26;
          uint64_t v48 = a3;
          int v49 = 1;
LABEL_120:
          int v57 = 1;
          goto LABEL_121;
        }
      }

      return v38;
    }

    unsigned int v53 = v33[3];
    if (v63 && v53 == 0x2000000)
    {
      unsigned int v54 = &v67[0].offset;
      if (v24) {
        unsigned int v54 = &v24->offset;
      }
      *unsigned int v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v54, 1, 0);
      char v24 = v64;
    }

    uint64_t v38 = bswap32(v53);
    if (v62)
    {
      unint64_t v55 = (int *)&v67[0].offset;
      if (v24) {
        unint64_t v55 = (int *)&v24->offset;
      }
      *int v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v55, 1, 0);
      char v24 = v64;
    }

    if (!a8 && !v20 && !a10) {
      return v38;
    }
    __int128 v56 = &v67[0].offset;
    if (v24) {
      __int128 v56 = &v24->offset;
    }
    unsigned int v45 = *v56;
    unsigned int v61 = a10;
    int v46 = v25;
    uint64_t v47 = (uint64_t)v26;
    uint64_t v48 = a3;
    int v49 = 1;
LABEL_104:
    int v57 = 0;
LABEL_121:
    _CFBundleGrokObjcImageInfoFromFile(v46, v47, v48, v45, v49, v57, a8, v20, v61);
    return v38;
  }

  if (v40 != -17958193)
  {
    if (v40 != -17958194) {
      return v38;
    }
    uint64_t v38 = v33[3];
    if (v63 && (_DWORD)v38 == 2)
    {
      BOOL v50 = &v67[0].offset;
      if (v24) {
        BOOL v50 = &v24->offset;
      }
      *unsigned int v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v50, 0, 0);
      char v24 = v64;
    }

    if (v62)
    {
      unint64_t v51 = (int *)&v67[0].offset;
      if (v24) {
        unint64_t v51 = (int *)&v24->offset;
      }
      *int v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v51, 0, 0);
      char v24 = v64;
    }

    if (!a8 && !v20 && !a10) {
      return v38;
    }
    int v52 = &v67[0].offset;
    if (v24) {
      int v52 = &v24->offset;
    }
    unsigned int v45 = *v52;
    unsigned int v61 = a10;
    int v46 = v25;
    uint64_t v47 = (uint64_t)v26;
    uint64_t v48 = a3;
    int v49 = 0;
    goto LABEL_104;
  }

  uint64_t v38 = v33[3];
  if (v63 && (_DWORD)v38 == 2)
  {
    int v58 = &v67[0].offset;
    if (v24) {
      int v58 = &v24->offset;
    }
    *unsigned int v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v58, 0, 1);
    char v24 = v64;
  }

  if (v62)
  {
    unint64_t v59 = (int *)&v67[0].offset;
    if (v24) {
      unint64_t v59 = (int *)&v24->offset;
    }
    *int v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v59, 0, 1);
    char v24 = v64;
  }

  if (a8 || v20 || a10)
  {
    int v60 = &v67[0].offset;
    if (v24) {
      int v60 = &v24->offset;
    }
    unsigned int v45 = *v60;
    unsigned int v61 = a10;
    int v46 = v25;
    uint64_t v47 = (uint64_t)v26;
    uint64_t v48 = a3;
    int v49 = 0;
    goto LABEL_120;
  }

  return v38;
}

uint64_t _CFURLComponentsGetURLUserAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)sURLAllowedCharacterSets;
}

uint64_t _CFURLComponentsGetURLPasswordAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 8);
}

uint64_t _CFURLComponentsGetURLHostAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 16);
}

uint64_t _CFURLComponentsGetURLPortAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 48);
}

uint64_t _CFURLComponentsGetURLPathAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 24);
}

uint64_t _CFURLComponentsGetURLQueryAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 32);
}

uint64_t _CFURLComponentsGetURLFragmentAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1) {
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  }
  return *(void *)(sURLAllowedCharacterSets + 40);
}

CFStringRef _CFStringCreateByAddingPercentEncodingWithAllowedCharacters( const __CFAllocator *a1, CFStringRef theString, const __CFCharacterSet *a3)
{
  v46[1] = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(theString);
  if (!Length) {
    return CFStringCreateCopy(a1, theString);
  }
  CFIndex v7 = Length;
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding != -1)
  {
    CFIndex v10 = MaximumSizeForEncoding;
    CFStringRef v11 = 0LL;
    unint64_t v12 = 4 * MaximumSizeForEncoding;
    if (!(4 * MaximumSizeForEncoding)) {
      return v11;
    }
    *((void *)&v13 + 1) = ((MaximumSizeForEncoding + __PAIR128__(1LL, 0xC000000000000000LL)) >> 64) & 1;
    *(void *)&__int128 v13 = MaximumSizeForEncoding - 0x4000000000000000LL;
    if (v12 < 0x401)
    {
      MEMORY[0x1895F8858](MaximumSizeForEncoding, v9);
      unsigned int v14 = (UInt8 *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    }

    else
    {
      unsigned int v14 = (UInt8 *)malloc(4 * MaximumSizeForEncoding);
    }

    v47.CFIndex location = 0LL;
    v47.CFIndex length = v7;
    CFStringRef v11 = 0LL;
    if (CFStringGetBytes(theString, v47, 0x8000100u, 0, 0, v14, v10, v46) != v7) {
      goto LABEL_74;
    }
    unsigned int v16 = &v14[v10];
    if (InitializeURLAllowedCharacterSets_static_init == -1)
    {
      if (a3)
      {
LABEL_14:
        uint64_t v17 = 0LL;
        while (*(const __CFCharacterSet **)(sURLAllowedCharacterSets + 8 * v17) != a3)
        {
          if (++v17 == 7) {
            goto LABEL_17;
          }
        }

        __int16 v21 = 2;
        switch(v17)
        {
          case 0LL:
            goto LABEL_66;
          case 1LL:
            __int16 v21 = 4;
            goto LABEL_66;
          case 2LL:
            uint64_t v22 = v46[0];
            if (v46[0] <= 1) {
              goto LABEL_77;
            }
            if (*v14 == 91)
            {
              if (v14[v46[0] - 1] == 93)
              {
                char v23 = 0;
                char v24 = v14 + 1;
                UInt8 *v16 = 91;
                uint64_t v18 = v16 + 1;
                v22 -= 2LL;
                v46[0] = v22;
                char v25 = 1;
              }

              else
              {
LABEL_77:
                char v25 = 0;
                char v23 = 1;
                char v24 = v14;
                uint64_t v18 = &v14[v10];
              }

              if (v22 < 1)
              {
LABEL_91:
                if ((v23 & 1) == 0) {
                  *v18++ = 93;
                }
                goto LABEL_73;
              }
            }

            else
            {
              char v25 = 0;
              char v23 = 1;
              uint64_t v18 = &v14[v10];
              char v24 = v14;
            }

            CFIndex v40 = 0LL;
            do
            {
              int v41 = (char)v24[v40];
              unint64_t v42 = v24[v40];
              if ((v41 & 0x80000000) == 0
                && (v41 == 58 ? (char v43 = v25) : (char v43 = 0), (v43 & 1) != 0 || (sURLAllowedCharacters[v42] & 8) != 0))
              {
                *v18++ = v41;
              }

              else
              {
                *uint64_t v18 = 37;
                v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v42 >> 4];
                v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v42 & 0xF];
                v18 += 3;
              }

              ++v40;
            }

            while (v40 < v46[0]);
            goto LABEL_91;
          case 3LL:
            uint64_t v18 = &v14[v10];
            if (v46[0] < 1) {
              goto LABEL_73;
            }
            uint64_t v26 = 0LL;
            char v27 = 0;
            p_info = &OBJC_METACLASS_____NSCFTimer.info;
            uint64_t v29 = &OBJC_METACLASS_____NSCFTimer.info;
            CFNumberRef v30 = "0123456789ABCDEF";
            uint64_t v18 = v16;
            break;
          case 4LL:
            __int16 v21 = 64;
            goto LABEL_66;
          case 5LL:
            __int16 v21 = 128;
            goto LABEL_66;
          case 7LL:
            goto LABEL_17;
          default:
            __int16 v21 = 0;
LABEL_66:
            uint64_t v18 = &v14[v10];
            if (v46[0] >= 1)
            {
              CFIndex v37 = 0LL;
              uint64_t v18 = v16;
              do
              {
                int v38 = (char)v14[v37];
                unint64_t v39 = v14[v37];
                if (v38 < 0 || ((unsigned __int16)v21 & sURLAllowedCharacters[v39]) == 0)
                {
                  *uint64_t v18 = 37;
                  v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v39 >> 4];
                  v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v39 & 0xF];
                  v18 += 3;
                }

                else
                {
                  *v18++ = v38;
                }

                ++v37;
              }

              while (v37 < v46[0]);
            }

            goto LABEL_73;
        }

        while (1)
        {
          unint64_t v31 = v14[v26];
          if (v27) {
            break;
          }
          int v33 = 0;
          char v27 = (_DWORD)v31 == 47;
          if ((v31 & 0x80) == 0 && (_DWORD)v31 != 58) {
            int v33 = (sURLAllowedCharacters[v31] >> 5) & 1;
          }
          if (p_info[354] != (__objc2_class_ro *)-1LL)
          {
            HIDWORD(v44) = v31 == 47;
            unint64_t v45 = v31;
            dispatch_once(&_CFURIParserSemicolonAllowedInPath_onceToken, &__block_literal_global_13);
            unint64_t v31 = v45;
            char v27 = BYTE4(v44);
            CFNumberRef v30 = "0123456789ABCDEF";
            uint64_t v29 = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
            p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
          }

          if (*((_BYTE *)v29 + 2808))
          {
            if (!v33) {
              goto LABEL_60;
            }
          }

          else
          {
            if ((_DWORD)v31 == 59) {
              char v35 = 0;
            }
            else {
              char v35 = v33;
            }
            if ((v35 & 1) == 0)
            {
LABEL_60:
              *uint64_t v18 = 37;
              v18[1] = v30[v31 >> 4];
              v18[2] = v30[v31 & 0xF];
              v18 += 3;
              goto LABEL_61;
            }
          }

          *v18++ = v31;
LABEL_61:
          if (++v26 >= v46[0]) {
            goto LABEL_73;
          }
        }

        if ((v31 & 0x80) != 0) {
          int v32 = 0;
        }
        else {
          int v32 = (sURLAllowedCharacters[v31] >> 5) & 1;
        }
        if (p_info[354] != (__objc2_class_ro *)-1LL)
        {
          uint64_t v36 = v30;
          unint64_t v45 = v14[v26];
          dispatch_once(&_CFURIParserSemicolonAllowedInPath_onceToken, &__block_literal_global_13);
          unint64_t v31 = v45;
          CFNumberRef v30 = v36;
          uint64_t v29 = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
          p_info = (__objc2_class_ro **)(&OBJC_METACLASS_____NSCFTimer + 32);
        }

        if (*((_BYTE *)v29 + 2808))
        {
          if (v32)
          {
LABEL_49:
            *v18++ = v31;
LABEL_55:
            char v27 = 1;
            goto LABEL_61;
          }
        }

        else
        {
          if ((_DWORD)v31 == 59) {
            char v34 = 0;
          }
          else {
            char v34 = v32;
          }
          if ((v34 & 1) != 0) {
            goto LABEL_49;
          }
        }

        *uint64_t v18 = 37;
        v18[1] = v30[v31 >> 4];
        v18[2] = v30[v31 & 0xF];
        v18 += 3;
        goto LABEL_55;
      }
    }

    else
    {
      dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
      if (a3) {
        goto LABEL_14;
      }
    }

CFStringRef _CFStringCreateByRemovingPercentEncoding(const __CFAllocator *a1, CFStringRef theString)
{
  v19[1] = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(theString);
  if (!Length) {
    return CFStringCreateCopy(a1, theString);
  }
  CFIndex v5 = Length;
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding == -1) {
    return 0LL;
  }
  CFIndex v8 = MaximumSizeForEncoding;
  CFStringRef v9 = 0LL;
  if ((MaximumSizeForEncoding & 0x8000000000000000LL) == 0)
  {
    unint64_t v10 = 2 * MaximumSizeForEncoding;
    if (2 * MaximumSizeForEncoding)
    {
      if (v10 < 0x401)
      {
        MEMORY[0x1895F8858](MaximumSizeForEncoding, v7);
        CFStringRef v11 = (UInt8 *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      }

      else
      {
        CFStringRef v11 = (UInt8 *)malloc(2 * MaximumSizeForEncoding);
      }

      v20.CFIndex location = 0LL;
      v20.CFIndex length = v5;
      if (CFStringGetBytes(theString, v20, 0x8000100u, 0, 0, v11, v8, v19))
      {
        CFIndex v13 = v19[0];
        unsigned int v14 = &v11[v8];
        if (v19[0] >= 1)
        {
          CFIndex v15 = 0LL;
          unsigned int v16 = v11;
          unsigned int v14 = &v11[v8];
          do
          {
            int v17 = *v16;
            if (v17 == 37)
            {
              v15 += 2LL;
              if (v15 >= v13) {
                goto LABEL_20;
              }
              int v18 = _CFStringCreateByRemovingPercentEncoding_hexvalues[v16[1]];
              int v17 = _CFStringCreateByRemovingPercentEncoding_hexvalues[v16[2]];
              if (((v17 | v18) & 0x80) != 0) {
                goto LABEL_20;
              }
              v16 += 3;
              LOBYTE(v17) = v17 + 16 * v18;
            }

            else
            {
              ++v16;
            }

            *v14++ = v17;
            ++v15;
            CFIndex v13 = v19[0];
          }

          while (v15 < v19[0]);
        }

        CFStringRef v9 = CFStringCreateWithBytes(0LL, &v11[v8], v14 - &v11[v8], 0x8000100u, 0);
      }

      else
      {
LABEL_20:
        CFStringRef v9 = 0LL;
      }

      if (v10 >= 0x401) {
        free(v11);
      }
    }
  }

  return v9;
}

CFCharacterSetRef __InitializeURLAllowedCharacterSets_block_invoke()
{
  sURLAllowedCharacterSets = (uint64_t)CFAllocatorAllocate(0LL, 56LL, 0LL);
  *(void *)sURLAllowedCharacterSets = CFCharacterSetCreateWithCharactersInString( 0LL,  @"!$&'()*+,-.0123456789;=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~");
  *(void *)(sURLAllowedCharacterSets + _Block_object_dispose(va, 8) = CFCharacterSetCreateWithCharactersInString( 0LL,  @"!$&'()*+,-.0123456789;=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~");
  *(void *)(sURLAllowedCharacterSets + 16) = CFCharacterSetCreateWithCharactersInString( 0LL,  @"!$&'()*+,-.0123456789:;=ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz~");
  *(void *)(sURLAllowedCharacterSets + 4_Block_object_dispose(va, 8) = CFCharacterSetCreateWithCharactersInString(0LL, @"0123456789");
  if (_CFURIParserSemicolonAllowedInPath_onceToken != -1) {
    dispatch_once(&_CFURIParserSemicolonAllowedInPath_onceToken, &__block_literal_global_13);
  }
  if (_CFURIParserSemicolonAllowedInPath_allowSemicolon) {
    int v0 = @"!$&'()*+,-./0123456789:;=@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~";
  }
  else {
    int v0 = @"!$&'()*+,-./0123456789:=@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~";
  }
  *(void *)(sURLAllowedCharacterSets + 24) = CFCharacterSetCreateWithCharactersInString(0LL, v0);
  *(void *)(sURLAllowedCharacterSets + 32) = CFCharacterSetCreateWithCharactersInString( 0LL,  @"!$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~");
  CFCharacterSetRef result = CFCharacterSetCreateWithCharactersInString( 0LL,  @"!$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~");
  *(void *)(sURLAllowedCharacterSets + 40) = result;
  return result;
}

uint64_t (**__CFStringEncodingGetJapaneseConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter_2)
  {
    __CFStringEncodingIsDecomposableCharacter_2 = (_UNKNOWN *)a2(1LL);
    __CFStringEncodingDecomposeCharacter_2 = (_UNKNOWN *)a2(2LL);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_4 = (_UNKNOWN *)a2(3LL);
    __CFStringEncodingPrecomposeLatinCharacter_6 = (_UNKNOWN *)a2(4LL);
  }

  if (a1 > 2560)
  {
    switch(a1)
    {
      case 3056:
        return __CFConverterShiftJIS_NTT_Docomo;
      case 3057:
        return __CFConverterShiftJIS_KDDI;
      case 3058:
        return __CFConverterShiftJIS_SoftBank;
      case 3059:
        return 0LL;
      case 3060:
        return __CFConverterISO_2022_JP_KDDI;
      default:
        if (a1 == 2561)
        {
          CFCharacterSetRef result = __CFConverterShiftJIS;
        }

        else
        {
          if (a1 != 2814) {
            return 0LL;
          }
          CFCharacterSetRef result = __CFConverterAutoDetect_JP;
        }

        break;
    }
  }

  else
  {
    if (a1 > 2079)
    {
      if (a1 == 2080) {
        return __CFConverterISO_2022_JP;
      }
      if (a1 == 2336) {
        return __CFConverterEUC_JP;
      }
    }

    else
    {
      if (a1 == 1) {
        return __CFConverterMacJapanese;
      }
      if (a1 == 1056) {
        return __CFConverterDOSJapanese;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t __CFToDOSJapanese(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F) {
    goto LABEL_4;
  }
  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    LOBYTE(a2) = a2 + 64;
LABEL_4:
    *a3 = a2;
    return 1LL;
  }

  unsigned int v4 = (unsigned __int16 *)&DOSJapanese_from_uni;
  CFIndex v5 = (unsigned __int16 *)&unk_180D69856;
  while (1)
  {
    uint64_t v6 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v5 - v4)) >> 1;
    uint64_t v7 = &v4[5 * v6];
    unsigned int v8 = *v7;
    if (v8 <= a2) {
      break;
    }
    CFIndex v5 = v7 - 5;
LABEL_11:
    if (v4 > v5) {
      goto LABEL_12;
    }
  }

  if (v8 + 4 <= a2)
  {
    unsigned int v4 = v7 + 5;
    goto LABEL_11;
  }

  unsigned int v15 = v4[5 * v6 + 1 + (int)(a2 - v8)];
  if (v15)
  {
    unsigned int v16 = v15 >> 8;
LABEL_37:
    *a3 = v16;
    a3[1] = v15;
    return 2LL;
  }

uint64_t __CFFromDOSJapanese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  int v5 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    *a4 = v5;
    return 1LL;
  }

  if ((v5 + 95) <= 0x3Eu)
  {
    *a4 = v5 - 320;
    return 1LL;
  }

  if (a3 < 2) {
    return 0LL;
  }
  int v7 = a2[1];
  unsigned int v8 = v7 | (v5 << 8);
  if ((int)v8 <= 33147)
  {
    switch(v8)
    {
      case 0x815Cu:
        __int16 v9 = 8213;
        goto LABEL_29;
      case 0x815Du:
      case 0x815Eu:
      case 0x815Fu:
      case 0x8162u:
        goto LABEL_20;
      case 0x8160u:
        __int16 v9 = -162;
        goto LABEL_29;
      case 0x8161u:
        __int16 v9 = 8741;
        goto LABEL_29;
      case 0x8163u:
        __int16 v9 = 8230;
        goto LABEL_29;
      default:
        if (v8 != 33104) {
          goto LABEL_20;
        }
        __int16 v9 = -29;
        break;
    }

    goto LABEL_29;
  }

  if ((int)v8 > 33169)
  {
    if (v8 == 33170)
    {
      __int16 v9 = -31;
      goto LABEL_29;
    }

    if (v8 == 33226)
    {
      __int16 v9 = -30;
      goto LABEL_29;
    }
  }

  else
  {
    if (v8 == 33148)
    {
      __int16 v9 = -243;
      goto LABEL_29;
    }

    if (v8 == 33169)
    {
      __int16 v9 = -32;
LABEL_29:
      *a4 = v9;
      return 2LL;
    }
  }

uint64_t __CFToShiftJISLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    unsigned int v5 = *a2++;
    unsigned int v4 = v5;
    else {
      uint64_t v7 = 1LL;
    }
    result += v7;
  }

  return result;
}

uint64_t __CFFromShiftJISLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t result = 0LL;
    while (1)
    {
      if (*a2 < 0xA1u) {
        break;
      }
      uint64_t v4 = -1LL;
      if ((unint64_t)a3 >= 2)
      {
        uint64_t v5 = 1LL;
        if (*a2 < 0xE0u) {
          goto LABEL_6;
        }
LABEL_14:
        uint64_t v4 = -2LL;
        uint64_t v5 = 2LL;
        goto LABEL_6;
      }

uint64_t __CFFromShiftJISFallback(char *a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5)
{
  if (a4) {
    *a3 = 63;
  }
  *a5 = 1LL;
  if (*a1 > -1 || a2 < 2) {
    return 1LL;
  }
  else {
    return 2LL;
  }
}

uint64_t __CFToShiftJISPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v9 = __CFPrecomposeCharJapanese(a2, 0);
  int v10 = __CFToShiftJIS(v9, v9, v13);
  uint64_t result = 0LL;
  if (v10)
  {
    char v12 = v13[0];
    if (v13[0])
    {
      uint64_t result = 2LL;
      *a6 = 2LL;
      if (a5)
      {
        if (a5 >= 2)
        {
          *a4 = v12;
          a4[1] = v13[1];
          return 2LL;
        }

        else
        {
          return 0LL;
        }
      }
    }
  }

  return result;
}

BOOL __CFIsValidCombiningCharJapanese(int a1)
{
  BOOL result = 1LL;
  return result;
}

uint64_t __CFToJIS(unsigned int a1, int a2)
{
  uint64_t v2 = (unsigned __int16 *)&__CFToJISCharMap;
  int v3 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    uint64_t v4 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v3 - v2)) >> 1;
    uint64_t v5 = &v2[17 * v4];
    unsigned int v6 = *v5;
    if (v6 <= a1) {
      break;
    }
    int v3 = v5 - 17;
LABEL_7:
    if (v2 > v3) {
      return 65533LL;
    }
  }

  if (v6 + 16 <= a1)
  {
    uint64_t v2 = v5 + 17;
    goto LABEL_7;
  }

  uint64_t v8 = v2[17 * v4 + 1 + (int)(a1 - v6)];
  if (!(_DWORD)v8) {
    return 65533LL;
  }
  if (!a2) {
    return v8;
  }
  uint64_t result = 65533LL;
  return result;
}

uint64_t JIS0208ToShiftJIS(uint64_t result, _BYTE *a2)
{
  if ((result & 0x100) != 0) {
    int v2 = 31;
  }
  else {
    int v2 = 125;
  }
  unsigned int v3 = v2 + (result & 0x7F);
  unsigned int v4 = ((result >> 8) + 479) >> 1;
  char v5 = v4 - 127;
  unsigned int v6 = (v4 - 127);
  if (v3 > 0x7E) {
    LOBYTE(v3) = v3 + 1;
  }
  char v7 = v4 - 63;
  if (v6 <= 0x9F) {
    char v7 = v5;
  }
  *a2 = v7;
  a2[1] = v3;
  return result;
}

uint64_t __CFFromJIS0208(unsigned int a1)
{
  if (a1 - 30067 < 0xFFFFABAE) {
    return (unsigned __int16)-3;
  }
  CFIndex v1 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
  int v2 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
  while (1)
  {
    uint64_t v3 = (0xF83E0F83E0F83E1LL * (v2 - v1)) >> 1;
    unsigned int v4 = &v1[33 * v3];
    unsigned int v5 = *v4;
    if (v5 <= a1) {
      break;
    }
    int v2 = v4 - 33;
LABEL_7:
    if (v1 > v2) {
      return (unsigned __int16)-3;
    }
  }

  if (v5 + 32 <= a1)
  {
    CFIndex v1 = v4 + 33;
    goto LABEL_7;
  }

  unsigned __int16 v6 = v1[33 * v3 + 1 + (int)(a1 - v5)];
  if (!v6) {
    return (unsigned __int16)-3;
  }
  return v6;
}

uint64_t ShiftJISToJIS0208(unsigned __int8 *a1)
{
  unsigned int v1 = *a1;
  if (v1 >= 0xA0) {
    __int16 v2 = 79;
  }
  else {
    __int16 v2 = 15;
  }
  __int16 v3 = v2 + v1;
  unsigned int v4 = (a1[1] + ((char)a1[1] >> 7));
  BOOL v5 = v4 > 0x9D;
  if (v4 <= 0x9D) {
    __int16 v6 = (2 * (v3 & 0x1FF)) | 1;
  }
  else {
    __int16 v6 = 2 * v3 + 2;
  }
  if (v5) {
    char v7 = -125;
  }
  else {
    char v7 = -31;
  }
  return (unsigned __int16)((v7 + a1[1] + ((char)a1[1] >> 7)) | (unsigned __int16)((v6 & 0x7FF) << 8));
}

uint64_t __CFToShiftJIS(uint64_t a1, unsigned int a2, char *a3)
{
  if ((int)a2 <= 164)
  {
    if (a2 == 92)
    {
      LOWORD(v5) = 24449;
      goto LABEL_11;
    }

    if (a2 == 126) {
      return 0LL;
    }
    goto LABEL_8;
  }

  if (a2 == 165)
  {
    char v4 = 92;
    goto LABEL_16;
  }

  if (a2 == 8254)
  {
    char v4 = 126;
LABEL_16:
    *a3 = v4;
    return 1LL;
  }

uint64_t __CFPrecomposeCharJapanese(unsigned __int16 *a1, int a2)
{
  int v2 = *a1;
  unsigned int v3 = a1[1];
  if (v3 > 0x337)
  {
    if (v3 == 824)
    {
      if (v2 == 61) {
        return 8800;
      }
    }

    else
    {
      if (v3 != 12441)
      {
        if (v3 == 12442
          && ((v2 - 12399) <= 0xC && ((1 << (v2 - 111)) & 0x1249) != 0
           || (v2 - 12495) <= 0xC && ((1 << (v2 + 49)) & 0x1249) != 0))
        {
          return (unsigned __int16)(v2 + 2);
        }

        return (unsigned __int16)-3;
      }

      if (*a1 > 0x309Cu)
      {
        uint64_t v6 = (v2 - 12445);
        if (((1LL << (v2 + 99)) & 0x49240A9555554001LL) == 0)
        {
          if (v6 == 9)
          {
            BOOL v7 = a2 == 0;
            unsigned __int16 v8 = 12532;
            goto LABEL_41;
          }

uint64_t __CFToEUC_JP(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    *a3 = a2;
    return 1LL;
  }

  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    *a3 = -114;
    LOBYTE(v4) = a2 + 64;
    goto LABEL_5;
  }

  unsigned int v5 = (unsigned __int16 *)&__CFToJISCharMap;
  uint64_t v6 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    uint64_t v7 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v6 - v5)) >> 1;
    unsigned __int16 v8 = &v5[17 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 17;
LABEL_13:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 + 16 <= a2)
  {
    unsigned int v5 = v8 + 17;
    goto LABEL_13;
  }

  int v10 = v5[17 * v7 + 1 + (int)(a2 - v9)];
  if (!v10) {
    return 0LL;
  }
  uint64_t result = 0LL;
  if ((v10 - 30002) >= 0xFFFF8BCE && (v10 - 10529) >= 0x62E)
  {
    __int16 v4 = v10 | 0x8080;
    *a3 = HIBYTE(v4);
LABEL_5:
    a3[1] = v4;
    return 2LL;
  }

  return result;
}

uint64_t __CFFromEUC_JP(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  int v4 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1LL;
  }

  switch(v4)
  {
    case 160:
      if (a3 < 2) {
        return 0LL;
      }
      __int16 v6 = 169;
      goto LABEL_10;
    case 143:
      if (a3 < 3) {
        return 0LL;
      }
      unsigned int v7 = *(unsigned __int16 *)(a2 + 1);
      if ((unsigned __int16)((bswap32(v7) >> 16) + 4638) >= 0xB4CDu)
      {
        unsigned int v8 = __rev16(v7);
        unsigned int v9 = (unsigned __int16 *)&__CFFromJIS0212CharMap;
        int v10 = (unsigned __int16 *)((char *)&__CFFromJIS0212CharMap + 13002);
        do
        {
          uint64_t v11 = (0xF83E0F83E0F83E1LL * (v10 - v9)) >> 1;
          BOOL v12 = &v9[33 * v11];
          unsigned int v13 = *v12;
          if (v13 <= v8)
          {
            if (v13 + 32 > v8)
            {
              uint64_t v20 = (uint64_t)&v9[33 * v11 + (int)(v8 - v13)];
              goto LABEL_32;
            }

            unsigned int v9 = v12 + 33;
          }

          else
          {
            int v10 = v12 - 33;
          }
        }

        while (v9 <= v10);
      }

      goto LABEL_35;
    case 142:
      if (a3 < 2) {
        return 0LL;
      }
      __int16 v6 = a2[1] - 320;
LABEL_10:
      *a4 = v6;
      return 2LL;
  }

  if (a3 < 2) {
    return 0LL;
  }
  unsigned int v14 = a2[1] & 0x7F | ((v4 & 0x7F) << 8);
  unsigned int v15 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
  unsigned int v16 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
  while (1)
  {
    uint64_t v17 = (0xF83E0F83E0F83E1LL * (v16 - v15)) >> 1;
    unsigned int v18 = &v15[33 * v17];
    unsigned int v19 = *v18;
    if (v19 <= v14) {
      break;
    }
    unsigned int v16 = v18 - 33;
LABEL_28:
    if (v15 > v16) {
      goto LABEL_35;
    }
  }

  if (v19 + 32 <= v14)
  {
    unsigned int v15 = v18 + 33;
    goto LABEL_28;
  }

  uint64_t v20 = (uint64_t)&v15[33 * v17 + (int)(v14 - v19)];
LABEL_32:
  unsigned __int16 v21 = *(_WORD *)(v20 + 2);
  if (!v21)
  {
LABEL_35:
    *a4 = -3;
    return 0LL;
  }

  *a4 = v21;
  if (v21 != 65533) {
    return 2LL;
  }
  return 0LL;
}

unint64_t __CFToEUC_JPLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  if (!a3)
  {
    unint64_t v7 = 0LL;
    unint64_t v3 = 0LL;
    unint64_t v4 = 0LL;
LABEL_13:
    unint64_t v9 = v3 - v7;
    unint64_t v8 = 3 * v7 + v4;
    return v8 + 2 * v9;
  }

  unint64_t v3 = 0LL;
  unint64_t v4 = 0LL;
  do
  {
    unsigned int v6 = *a2++;
    unsigned int v5 = v6;
    if (v6 < 0x80) {
      ++v4;
    }
    if (v5 > 0x7F) {
      ++v3;
    }
    --a3;
  }

  while (a3);
  unint64_t v7 = v3 / 3;
  if (v4 <= v3 / 3) {
    goto LABEL_13;
  }
  unint64_t v8 = v4 - v7;
  if (v3 < 3) {
    unint64_t v7 = 1LL;
  }
  unint64_t v9 = v7 + v3;
  return v8 + 2 * v9;
}

uint64_t __CFFromEUC_JPLen(uint64_t a1, char *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    uint64_t v4 = -1LL;
    if (a3 == 1)
    {
      uint64_t v12 = 1LL;
    }

    else
    {
      int v5 = *a2;
      BOOL v6 = v5 == -113;
      BOOL v7 = (unint64_t)a3 > 2;
      BOOL v8 = !v7 || !v6;
      if (v7 && v6) {
        uint64_t v9 = 3LL;
      }
      else {
        uint64_t v9 = 2LL;
      }
      if (v8) {
        uint64_t v10 = -2LL;
      }
      else {
        uint64_t v10 = -3LL;
      }
      BOOL v11 = v5 >= 0;
      if (v5 < 0) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 1LL;
      }
      if (!v11) {
        uint64_t v4 = v10;
      }
    }

    a2 += v12;
    ++result;
    BOOL v13 = __OFADD__(a3, v4);
    a3 += v4;
  }

  while (!((a3 < 0) ^ v13 | (a3 == 0)));
  return result;
}

uint64_t __CFFromEUC_JPFallback(unsigned __int8 *a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5)
{
  if (a4) {
    *a3 = 63;
  }
  *a5 = 1LL;
  int v5 = *a1;
  int v6 = (char)v5;
  BOOL v7 = v5 != 143 || a2 <= 2;
  uint64_t v8 = 2LL;
  if (!v7) {
    uint64_t v8 = 3LL;
  }
  if (v6 > -1 || a2 < 2) {
    return 1LL;
  }
  else {
    return v8;
  }
}

uint64_t __CFToEUC_JPPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (*a2 > 0x7Fu) {
    uint64_t v9 = __CFPrecomposeCharJapanese(a2, 0);
  }
  else {
    uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_6(a2, a3, 0LL);
  }
  int v10 = __CFToEUC_JP(v9, v9, v13);
  uint64_t result = 0LL;
  if (v10)
  {
    char v12 = v13[0];
    if (v13[0])
    {
      uint64_t result = 2LL;
      *a6 = 2LL;
      if (a5)
      {
        if (a5 >= 2)
        {
          *a4 = v12;
          a4[1] = v13[1];
          return 2LL;
        }

        else
        {
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t __CFIsValidCombiningCharJapaneseWithJIS212(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1LL << (a1 - 6)) & 0x4000000000005LL) != 0
    || (a1 - 12441) < 2)
  {
    return 1LL;
  }

  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_4();
  }

uint64_t __CFToISO_2022_JP(char a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v8 = 0LL;
    uint64_t v46 = 0LL;
    goto LABEL_142;
  }

  uint64_t v8 = a3;
  unsigned int v53 = a6;
  uint64_t v9 = a2 - 2;
  uint64_t v54 = a2;
  while (2)
  {
    BOOL v10 = 0;
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    unsigned int v13 = 0;
    while (2)
    {
      if (a5 && a5 <= v11)
      {
        if ((a1 & 0x10) == 0) {
          goto LABEL_116;
        }
        unsigned int v14 = *(unsigned __int16 *)(a2 + 2 * v12);
        BOOL v15 = v14 - 774 > 0x32 || ((1LL << (v14 - 6)) & 0x4000000000005LL) == 0;
        if (v15 && v14 - 12441 >= 2) {
          goto LABEL_116;
        }
      }

      else
      {
        unsigned int v14 = *(unsigned __int16 *)(a2 + 2 * v12);
        if (v14 <= 0x7F)
        {
          BOOL v10 = v13 != 0;
          if (v13) {
            uint64_t v17 = 4LL;
          }
          else {
            uint64_t v17 = 1LL;
          }
          if (!a5)
          {
            unsigned int v13 = 0;
            goto LABEL_114;
          }

          if (a5 - v11 >= v17)
          {
            if (v13)
            {
              *a4 = 27;
              *(_WORD *)(a4 + 1) = 16936;
              a4 += 3;
            }

            unsigned int v13 = 0;
            *a4++ = v14;
            goto LABEL_114;
          }

          goto LABEL_116;
        }
      }

      if ((unsigned __int16)(v14 + 159) <= 0x3Eu)
      {
        BOOL v10 = v13 != 3;
        if (v13 == 3) {
          uint64_t v17 = 1LL;
        }
        else {
          uint64_t v17 = 4LL;
        }
        if (a5)
        {
          if (a5 - v11 < v17) {
            goto LABEL_116;
          }
          if (v13 != 3)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 18728;
            a4 += 3;
          }

          *a4++ = v14 - 64;
        }

        unsigned int v13 = 3;
        goto LABEL_114;
      }

      if (v14 == 8254 || v14 == 165)
      {
        BOOL v10 = v13 != 2;
        if (v13 == 2) {
          uint64_t v17 = 1LL;
        }
        else {
          uint64_t v17 = 4LL;
        }
        if (a5)
        {
          if (a5 - v11 < v17) {
            goto LABEL_116;
          }
          if (v13 != 2)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 18984;
            a4 += 3;
          }

          if (v14 == 165) {
            char v18 = 92;
          }
          else {
            char v18 = 126;
          }
          *a4++ = v18;
        }

        unsigned int v13 = 2;
        goto LABEL_114;
      }

      unsigned int v19 = (unsigned __int16 *)&__CFToJISCharMap;
      uint64_t v20 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
      while (1)
      {
        uint64_t v21 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v20 - v19)) >> 1;
        unsigned int v22 = &v19[17 * v21];
        unsigned int v23 = *v22;
        if (v23 <= v14) {
          break;
        }
        uint64_t v20 = v22 - 17;
LABEL_55:
        if (v19 > v20) {
          goto LABEL_72;
        }
      }

      if (v23 + 16 <= v14)
      {
        unsigned int v19 = v22 + 17;
        goto LABEL_55;
      }

      unsigned int v24 = v19[17 * v21 + 1 + (int)(v14 - v23)];
      else {
        BOOL v25 = 1;
      }
      if (!v25 && v24 - 10529 >= 0x62E)
      {
        if (v24 < 0x100) {
          goto LABEL_116;
        }
        BOOL v10 = v13 != 1;
        if (v13 == 1) {
          uint64_t v17 = 2LL;
        }
        else {
          uint64_t v17 = 5LL;
        }
        if (!a5) {
          goto LABEL_102;
        }
        if (a5 - v11 < v17) {
          goto LABEL_116;
        }
        if (v13 != 1)
        {
          *a4 = 27;
          *(_WORD *)(a4 + 1) = 16932;
          a4 += 3;
        }

        *a4 = BYTE1(v24);
        a4[1] = v24 & 0x7F;
        a4 += 2;
LABEL_102:
        unsigned int v13 = 1;
LABEL_114:
        v11 += v17;
        if (++v12 == v8)
        {
LABEL_117:
          unint64_t v45 = (uint64_t (**)(void))&unk_18C539000;
          if (v13) {
            goto LABEL_118;
          }
LABEL_139:
          uint64_t v46 = v11;
          goto LABEL_141;
        }

        continue;
      }

      break;
    }

uint64_t __CFFromISO_2022_JP( unsigned int a1, const char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, void *a6)
{
  int v6 = a6;
  unint64_t v7 = (unint64_t)&a2[a3];
  if (__CFADD__(a2, a3))
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    if (a6) {
      goto LABEL_101;
    }
    return v9;
  }

  unint64_t v10 = a3;
  if (a3 < 1)
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    goto LABEL_101;
  }

  unsigned int v13 = a2;
  uint64_t v14 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  int v44 = a1 & 0xC0;
  while (2)
  {
    if (a5 && v8 >= a5) {
      goto LABEL_93;
    }
    int v15 = *(unsigned __int8 *)v13;
    if (v15 == 27)
    {
      uint64_t v46 = a4;
      unint64_t v47 = v10;
      uint64_t v16 = v9;
      uint64_t v17 = a5;
      uint64_t v18 = v8;
      uint64_t v19 = v14;
      for (uint64_t i = 0LL; i != 18; i += 2LL)
      {
        uint64_t v21 = LOBYTE((&__CFISO2022JPSequences)[i + 1]);
        if (v7 >= (unint64_t)&v13[v21 + 1]
          && !strncmp((&__CFISO2022JPSequences)[i], v13 + 1, LOBYTE((&__CFISO2022JPSequences)[i + 1])))
        {
          uint64_t v14 = *((unsigned __int8 *)&__CFISO2022JPSequences + 8 * i + 9);
          uint64_t v23 = v21 + 1;
          uint64_t v8 = v18;
          a5 = v17;
          uint64_t v9 = v16;
          a4 = v46;
          unint64_t v10 = v47;
          goto LABEL_85;
        }
      }

      uint64_t v14 = v19;
      if ((v19 & 0xFD) == 0)
      {
        uint64_t v22 = v18;
        a5 = v17;
        if (v17)
        {
          *uint64_t v46 = 27;
          a4 = v46 + 1;
          uint64_t v9 = v16;
        }

        else
        {
          uint64_t v9 = v16;
          a4 = v46;
        }

        unint64_t v10 = v47;
        uint64_t v8 = v22 + 1;
        uint64_t v23 = 1LL;
        goto LABEL_85;
      }

      uint64_t v8 = v18;
      a5 = v17;
      uint64_t v9 = v16;
      unint64_t v10 = v47;
      goto LABEL_93;
    }

    switch((int)v14)
    {
      case 0:
        if (!a5) {
          goto LABEL_43;
        }
        goto LABEL_42;
      case 1:
        if (v10 < 2) {
          goto LABEL_92;
        }
        unsigned int v24 = *((unsigned __int8 *)v13 + 1) | (v15 << 8);
        if (v24 - 30067 < 0xFFFFABAE) {
          goto LABEL_58;
        }
        BOOL v25 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
        uint64_t v26 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
        while (2)
        {
          uint64_t v27 = (0xF83E0F83E0F83E1LL * (v26 - v25)) >> 1;
          unsigned int v28 = &v25[33 * v27];
          unsigned int v29 = *v28;
          if (v29 <= v24)
          {
            if (v29 + 32 > v24)
            {
              unsigned __int16 v37 = v25[33 * v27 + 1 + (int)(v24 - v29)];
              if (v37 == 65533 || v37 == 0)
              {
LABEL_58:
                if ((a1 & 1) == 0) {
                  goto LABEL_91;
                }
                unsigned __int16 v37 = 63;
              }

              if (!v44 || !__CFStringEncodingIsDecomposableCharacter_2(v37, (a1 >> 7) & 1))
              {
                if (a5) {
                  *a4++ = v37;
                }
                uint64_t v23 = 2LL;
                goto LABEL_84;
              }

              if (!a5)
              {
                ++v8;
                uint64_t v23 = 2LL;
                goto LABEL_84;
              }

              if (v8 + 2 <= a5)
              {
                __CFStringEncodingDecomposeCharacter_2(a1, v37, a4);
                ++v8;
                uint64_t v23 = 2LL;
                a4 += 2;
                goto LABEL_84;
              }

              return v9;
            }

            BOOL v25 = v28 + 33;
          }

          else
          {
            uint64_t v26 = v28 - 33;
          }

          if (v25 > v26) {
            goto LABEL_58;
          }
          continue;
        }

      case 2:
        if (!a5) {
          goto LABEL_43;
        }
        if (v15 == 126) {
          __int16 v30 = 8254;
        }
        else {
          __int16 v30 = *(unsigned __int8 *)v13;
        }
        if (v15 == 92) {
          LOWORD(v15) = 165;
        }
        else {
          LOWORD(v15) = v30;
        }
        goto LABEL_42;
      case 3:
        if (!a5) {
          goto LABEL_43;
        }
        LOWORD(v15) = v15 - 192;
LABEL_42:
        *a4++ = v15;
LABEL_43:
        uint64_t v23 = 1LL;
        goto LABEL_84;
      case 4:
        if (v10 < 2)
        {
LABEL_92:
          LODWORD(v14) = 4;
          unint64_t v10 = 1LL;
          goto LABEL_93;
        }

        unsigned int v31 = *((unsigned __int8 *)v13 + 1) | (v15 << 8);
        __int16 v32 = (unsigned __int16 *)&__CFFromJIS0212CharMap;
        int v33 = (unsigned __int16 *)((char *)&__CFFromJIS0212CharMap + 13002);
        while (2)
        {
          uint64_t v34 = (0xF83E0F83E0F83E1LL * (v33 - v32)) >> 1;
          char v35 = &v32[33 * v34];
          unsigned int v36 = *v35;
          if (v36 > v31)
          {
            int v33 = v35 - 33;
            goto LABEL_51;
          }

          if (v36 + 32 <= v31)
          {
            __int16 v32 = v35 + 33;
LABEL_51:
            if (v32 > v33) {
              goto LABEL_73;
            }
            continue;
          }

          break;
        }

        unsigned __int16 v39 = v32[33 * v34 + 1 + (int)(v31 - v36)];
        if (v39 != 65533 && v39 != 0)
        {
LABEL_75:
          if (!v44 || !__CFStringEncodingIsDecomposableCharacter_2(v39, (a1 >> 7) & 1))
          {
            if (a5) {
              *a4++ = v39;
            }
            goto LABEL_83;
          }

          if (!a5) {
            goto LABEL_80;
          }
          if (v8 >= a5) {
            return v9;
          }
          __CFStringEncodingDecomposeCharacter_2(a1, v39, a4);
          a4 += 2;
LABEL_80:
          ++v8;
LABEL_83:
          uint64_t v23 = 2LL;
LABEL_84:
          ++v8;
LABEL_85:
          v9 += v23;
          v13 += v23;
          BOOL v41 = (uint64_t)v10 <= v23;
          v10 -= v23;
          if (v41) {
            goto LABEL_93;
          }
          continue;
        }

uint64_t __CFToMacJapanese(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    goto LABEL_238;
  }

  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  int v67 = a1 & 0x480;
  uint64_t v9 = (unsigned __int16 *)&__CFToJISCharMap;
  uint64_t v10 = 0x4E4Bu;
LABEL_3:
  uint64_t v11 = a2;
  uint64_t v12 = v7;
  uint64_t v13 = v8;
  while (1)
  {
    if (a5 && v12 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_238;
      }
      unsigned int v14 = *v11;
      if (v14 != 8413 && (v14 & 0xFFF0) != 0xF870) {
        goto LABEL_238;
      }
    }

    else
    {
      unsigned int v14 = *v11;
    }

    if (v14 <= 0x7F)
    {
      uint64_t v7 = v12 + 1;
      if (!a5) {
        goto LABEL_232;
      }
      if (v14 != 92 || v67 == 1024) {
        char v40 = v14;
      }
      else {
        char v40 = 0x80;
      }
      goto LABEL_114;
    }

LABEL_231:
            uint64_t v7 = v12;
LABEL_232:
            a2 = v11 + 1;
            uint64_t v8 = v13 + 1;
            uint64_t v12 = v7;
            uint64_t v13 = v8;
            if (v8 >= a3) {
              goto LABEL_238;
            }
            goto LABEL_3;
          }

LABEL_229:
          if (a5) {
            *((_WORD *)a4 - 1) = __rev16(v31);
          }
          goto LABEL_231;
        }

        goto LABEL_92;
      }

      unsigned __int16 v45 = *(v11 - 1) - 8678;
      if (v45 > 3u) {
        goto LABEL_238;
      }
      if (!a5) {
        goto LABEL_231;
      }
      unsigned int v29 = 0xD6D3D5D4 >> (8 * v45);
LABEL_106:
      char v50 = -122;
      goto LABEL_126;
    }

    int v25 = *(v11 - 1);
    if (v25 != 8230)
    {
      if (v25 == 65351)
      {
        LOBYTE(v29) = 75;
        if (!a5) {
          goto LABEL_231;
        }
      }

      else
      {
        if (v25 != 65357) {
          goto LABEL_238;
        }
        LOBYTE(v29) = 69;
        if (!a5) {
          goto LABEL_231;
        }
      }

      goto LABEL_106;
    }

    if (a5) {
      *(a4 - 2) = -1;
    }
    --v12;
    ++v11;
    ++v13;
    if (v17 >= a3)
    {
      if (a3 <= v8 + 1) {
        uint64_t v13 = v8 + 1;
      }
      else {
        uint64_t v13 = a3;
      }
      goto LABEL_238;
    }
  }

  if ((__int16)v11[1] == -1921)
  {
    ++v11;
    uint64_t v7 = v12 + 1;
    if (a5) {
      *a4++ = -1;
    }
    ++v13;
    goto LABEL_232;
  }

uint64_t __CFFromMacJapanese( uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v9 = a3;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  unsigned int v50 = a1 & 0x200;
  int v51 = a1 & 0x480;
  int v52 = a1 & 0xC0;
  while (1)
  {
    if (a5 && v12 >= a5) {
      return v13;
    }
    unsigned int v14 = *a2;
    if (v14 < 0x81 || v14 == 160)
    {
      if (v14 == 128) {
        __int16 v16 = 92;
      }
      else {
        __int16 v16 = *a2;
      }
      if (v14 == 92) {
        __int16 v16 = 165;
      }
      if (v51 == 1024) {
        unsigned __int16 v15 = *a2;
      }
      else {
        unsigned __int16 v15 = v16;
      }
      uint64_t v17 = 1LL;
      goto LABEL_23;
    }

    if ((v14 + 95) <= 0x3Eu)
    {
      unsigned __int16 v15 = v14 - 320;
LABEL_22:
      uint64_t v17 = 1LL;
LABEL_23:
      if (v52 && __CFStringEncodingIsDecomposableCharacter_2(v15, (a1 >> 7) & 1))
      {
        unsigned int v18 = __CFStringEncodingDecomposeCharacter_2(a1, v15, v53);
        uint64_t v19 = *a6;
        uint64_t v12 = *a6 + v18;
        *a6 = v12;
        if (a5)
        {
          if (v12 > a5)
          {
            *a6 = v19;
            return v13;
          }

          if (v18)
          {
            unint64_t v20 = v18 + 1LL;
            uint64_t v21 = (unsigned __int16 *)v53;
            do
            {
              unsigned __int16 v22 = *v21++;
              *a4++ = v22;
              --v20;
            }

            while (v20 > 1);
          }
        }
      }

      else
      {
        if (a5) {
          *a4++ = v15;
        }
        uint64_t v12 = *a6 + 1;
        *a6 = v12;
      }

      v13 += v17;
      a2 += v17;
      v9 -= v17;
      goto LABEL_35;
    }

    if (v14 == 253)
    {
      unsigned __int16 v15 = 169;
      goto LABEL_22;
    }

    if (v14 == 254)
    {
      unsigned __int16 v15 = 8482;
      goto LABEL_22;
    }

    if ((unint64_t)v9 >= 2)
    {
      int v23 = a2[1];
      if (v14 >= 0xA0) {
        __int16 v24 = 79;
      }
      else {
        __int16 v24 = 15;
      }
      __int16 v25 = v24 + v14;
      else {
        __int16 v26 = 2 * v25 + 2;
      }
      else {
        char v27 = -125;
      }
      unsigned int v28 = (unsigned __int16)((v27 + v23 + ((char)v23 >> 7)) | (unsigned __int16)(v26 << 8));
      unsigned int v29 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
      unsigned int v30 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
      while (1)
      {
        uint64_t v31 = (0xF83E0F83E0F83E1LL * (v30 - v29)) >> 1;
        uint64_t v32 = &v29[33 * v31];
        unsigned int v33 = *v32;
        if (v33 <= v28) {
          break;
        }
        unsigned int v30 = v32 - 33;
LABEL_53:
        if (v29 > v30) {
          goto LABEL_60;
        }
      }

      if (v33 + 32 <= v28)
      {
        unsigned int v29 = v32 + 33;
        goto LABEL_53;
      }

      unsigned __int16 v15 = v29[33 * v31 + 1 + (int)(v28 - v33)];
      if (v15 != 65533 && v15 != 0)
      {
LABEL_64:
        uint64_t v17 = 2LL;
        goto LABEL_23;
      }

uint64_t __CFFromMacJapaneseLen(__int16 a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  int v5 = a1 & 0x480;
  do
  {
    unsigned int v6 = *a2;
    if (v6 == 255)
    {
      ++a2;
      --a3;
      ++result;
    }

    else if ((v6 & 0x80) == 0 {
           || (v6 + 95) < 0x3Fu
    }
           || (v5 != 1024 ? (BOOL v7 = v6 == 128) : (BOOL v7 = 0),
               !v7 ? (int v8 = 0) : (int v8 = 1),
               (unint64_t)a3 < 2 || v6 > 0xFC || v8))
    {
      ++a2;
      --a3;
    }

    else
    {
      if (v6 - 235 >= 3 && v6 - 133 > 2)
      {
        a2 += 2;
      }

      else
      {
        a2 += 2;
        result += 5LL;
      }

      a3 -= 2LL;
    }

    ++result;
  }

  while (a3 > 0);
  return result;
}

uint64_t __CFFromShiftJIS(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  unsigned int v5 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    if (v5 == 126) {
      __int16 v6 = 8254;
    }
    else {
      __int16 v6 = *a2;
    }
    if (v5 == 92) {
      __int16 v7 = 165;
    }
    else {
      __int16 v7 = v6;
    }
    goto LABEL_10;
  }

  if ((v5 + 95) <= 0x3Eu)
  {
    __int16 v7 = v5 - 320;
LABEL_10:
    *a4 = v7;
    return 1LL;
  }

  if (a3 < 2) {
    return 0LL;
  }
  if ((v5 + 16) <= 0xCu)
  {
    uint64_t result = 0LL;
    int v9 = a2[1];
    if (v9 != 127 && (v9 + 3) >= 0x43u)
    {
      *a4 = (v9 | ((_WORD)v5 << 8)) - 68 * (v5 & 0xF) + ((char)v9 >> 7) - 4160;
      return 2LL;
    }

    return result;
  }

  if (v5 == 128) {
    return 0LL;
  }
  uint64_t result = 0LL;
  if (v5 <= 0xEA && (v5 + 123) >= 3u)
  {
    unsigned int v10 = ShiftJISToJIS0208(a2);
    int v11 = __CFFromJIS0208(v10);
    *a4 = v11;
    return 2 * (v11 != 65533);
  }

  return result;
}

uint64_t __CFToAutoDetect_JP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  *a6 = 0LL;
  return 0LL;
}

uint64_t __CFFromAutoDetect_JP( uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  int v8 = a4;
  uint64_t v9 = a3;
  unsigned int v10 = (unsigned __int8 *)a2;
  uint64_t v11 = a1;
  uint64_t v60 = *MEMORY[0x1895F89C0];
  uint64_t v12 = a2;
  uint64_t v13 = a3;
  do
  {
    BOOL v14 = v13-- < 1;
    if (v14)
    {
      if (a3 < 1)
      {
LABEL_41:
        if (a5 >= a3 || a5 == 0) {
          uint64_t v30 = a3;
        }
        else {
          uint64_t v30 = a5;
        }
        *a6 = v30;
        if (v30 && a5)
        {
          for (uint64_t i = 0LL; i != v30; ++i)
            a4[i] = a2[i];
        }

        return v30;
      }

      unsigned __int16 v22 = (unsigned __int8 *)(a2 + 1);
      unint64_t v23 = a3;
      while (1)
      {
        if (*(v22 - 1) == 27)
        {
          if (v23 < 5)
          {
            if (v23 == 4)
            {
              unsigned int v26 = *v22 - 96;
              BOOL v14 = v26 > 0x1E;
              int v27 = (1 << v26) & 0x7000C00F;
              if (!v14 && v27 != 0) {
                return __CFFromISO_2022_JP(a1, a2, a3, a4, a5, a6);
              }
            }
          }

          else
          {
            unsigned int v24 = *v22;
            BOOL v25 = v24 - 96 > 0x1E || ((1 << (v24 - 96)) & 0x7000C00F) == 0;
            if (!v25 || v24 <= 0x28 && ((1LL << v24) & 0x11600000000LL) != 0) {
              return __CFFromISO_2022_JP(a1, a2, a3, a4, a5, a6);
            }
          }
        }

        --v23;
        ++v22;
        if (v23 + 1 <= 1) {
          goto LABEL_41;
        }
      }
    }

    int v15 = *v12++;
  }

  while ((v15 & 0x80000000) == 0);
  if (a3 < 1) {
    goto LABEL_92;
  }
  uint64_t v16 = a3;
  uint64_t v17 = a2;
  while (1)
  {
    if ((*v17 & 0x80000000) == 0)
    {
      --v16;
      goto LABEL_8;
    }

    unsigned int v18 = *v17;
    if (v18 == 142)
    {
      char v20 = *++v17;
      v16 -= 2LL;
      goto LABEL_8;
    }

    if (v18 != 143) {
      break;
    }
    char v21 = v17[2];
    v17 += 2;
    v16 -= 3LL;
LABEL_8:
    ++v17;
    if (v16 <= 0)
    {
      char v33 = 1;
      goto LABEL_54;
    }
  }

  if (v18 != 255)
  {
    char v33 = 0;
    v16 -= 2LL;
    if (!v16 || v18 < 0xA0) {
      goto LABEL_54;
    }
    char v19 = *++v17;
  }

uint64_t __CFToNTTDocomoSJIS(char a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v58[1] = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    uint64_t v20 = 0LL;
    goto LABEL_85;
  }

  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_83;
      }
      int v13 = *a2;
      BOOL v14 = (v13 - 774) > 0x32 || ((1LL << (v13 - 6)) & 0x4000000000005LL) == 0;
      unsigned int v15 = v13 - 12441;
      if (v14 && v15 >= 2) {
        goto LABEL_83;
      }
    }

    uint64_t v17 = __CFToEmojiIndex(a2, a3 - v12, v58);
    if (v17 != -1)
    {
      if (v17 == 312 || v17 == 69)
      {
        unsigned int v18 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFNTTDocomoTable[v17] - 6;
        size_t v19 = strlen(v18);
        uint64_t v20 = v19 + v11;
        if (a5)
        {
          if (v20 > a5) {
            goto LABEL_83;
          }
          size_t v21 = v19;
          memcpy(a4, v18, v19);
          a4 += v21;
        }
      }

      else
      {
        uint64_t v20 = v11 + 2;
        if (a5)
        {
          if (v20 > a5) {
            goto LABEL_83;
          }
          *(_WORD *)a4 = __rev16(__CFNTTDocomoTable[v17]);
          a4 += 2;
        }
      }

      uint64_t v23 = v58[0];
      goto LABEL_32;
    }

    unsigned int v22 = *a2;
    if (v22 <= 0x7F)
    {
      uint64_t v20 = v11 + 1;
      if (!a5) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }

    if ((unsigned __int16)(v22 + 159) <= 0x3Eu)
    {
      uint64_t v20 = v11 + 1;
      if (!a5) {
        goto LABEL_31;
      }
      LOBYTE(v22) = v22 + 64;
LABEL_30:
      *a4++ = v22;
      goto LABEL_31;
    }

    if ((unsigned __int16)(v22 + 12) < 0xACu)
    {
      LOWORD(v24) = -3;
      goto LABEL_43;
    }

    BOOL v25 = (unsigned __int16 *)&__CFToJISCharMap;
    unsigned int v26 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      uint64_t v27 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v26 - v25)) >> 1;
      unsigned int v28 = &v25[17 * v27];
      unsigned int v29 = *v28;
      if (v29 <= v22) {
        break;
      }
      unsigned int v26 = v28 - 17;
LABEL_41:
      if (v25 > v26) {
        goto LABEL_42;
      }
    }

    if (v29 + 16 <= v22)
    {
      BOOL v25 = v28 + 17;
      goto LABEL_41;
    }

    uint64_t v36 = (char *)&v25[17 * v27];
    int v24 = *(__int16 *)&v36[2 * (v22 - v29) + 2];
    if (*(_WORD *)&v36[2 * (v22 - v29) + 2])
    {
      if (v24 >= 256)
      {
        uint64_t v20 = v11 + 2;
        if (a5)
        {
          if (v20 <= a5)
          {
            int v37 = BYTE1(v24);
            int v38 = v24 & 0x7F;
            if ((v24 & 0x100) != 0) {
              int v39 = 31;
            }
            else {
              int v39 = 125;
            }
            unsigned int v40 = v39 + v38;
            unsigned int v41 = (v37 + 479) >> 1;
            char v42 = v41 - 127;
            unsigned int v43 = (v41 - 127);
            if (v40 > 0x7E) {
              LOBYTE(v40) = v40 + 1;
            }
            char v44 = v41 - 63;
            if (v43 <= 0x9F) {
              char v44 = v42;
            }
            *a4 = v44;
            a4[1] = v40;
            a4 += 2;
            goto LABEL_31;
          }

uint64_t __CFFromNTTDocomoSJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v9 = a3;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  unsigned int v44 = (a1 >> 7) & 1;
  int v45 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11) {
      return v12;
    }
    unsigned int v13 = *a2;
    if ((*a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      uint64_t v14 = 1LL;
LABEL_9:
      if (v45 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v44))
      {
        unsigned int v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v47);
        uint64_t v16 = *a6;
        uint64_t v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }

          if (v15)
          {
            unint64_t v17 = v15 + 1LL;
            unsigned int v18 = (__int16 *)v47;
            do
            {
              __int16 v19 = *v18++;
              *a4++ = v19;
              --v17;
            }

            while (v17 > 1);
          }
        }
      }

      else
      {
        if (a5) {
          *a4++ = v13;
        }
        uint64_t v11 = *a6 + 1;
        *a6 = v11;
      }

      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }

    uint64_t v20 = v9 - 2;
    int v21 = a2[1];
    if (v13 >= 0xA0) {
      __int16 v22 = 79;
    }
    else {
      __int16 v22 = 15;
    }
    __int16 v23 = v22 + v13;
    else {
      __int16 v24 = 2 * v23 + 2;
    }
    else {
      char v25 = -125;
    }
    unsigned int v26 = (unsigned __int16)((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8));
    uint64_t v27 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    unsigned int v28 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      uint64_t v29 = (0xF83E0F83E0F83E1LL * (v28 - v27)) >> 1;
      unsigned int v30 = &v27[33 * v29];
      unsigned int v31 = *v30;
      if (v31 <= v26) {
        break;
      }
      unsigned int v28 = v30 - 33;
LABEL_36:
      if (v27 > v28) {
        goto LABEL_46;
      }
    }

    if (v31 + 32 <= v26)
    {
      uint64_t v27 = v30 + 33;
      goto LABEL_36;
    }

    unsigned __int16 v32 = v27[33 * v29 + 1 + (int)(v26 - v31)];
    if (v32 != 65533 && v32 != 0)
    {
      LOWORD(v13) = v32;
      uint64_t v14 = 2LL;
      goto LABEL_9;
    }

uint64_t __CFToEmojiIndex(unsigned __int16 *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *a1;
  if (v4 <= 0x7F)
  {
    if (a2 >= 2 && a1[1] == 8419)
    {
      *a3 = 2LL;
      else {
        uint64_t v5 = v4 + 654;
      }
      if ((_DWORD)v4 == 35) {
        return 701LL;
      }
      else {
        return v5;
      }
    }

    return -1LL;
  }

  if ((v4 & 0xFFFE) != 0xD83C)
  {
    uint64_t v11 = (unsigned __int16 *)&unk_180D7BCD8;
    uint64_t v12 = __CFBMPEmojiList;
    while (1)
    {
      unsigned int v13 = (char *)&v12[((char *)v11 - (char *)v12) >> 2];
      unsigned int v14 = *(unsigned __int16 *)v13;
      if (v14 == (_DWORD)v4) {
        break;
      }
      unsigned int v15 = (unsigned __int16 *)(v13 - 2);
      uint64_t v16 = (unsigned __int16 *)(v13 + 2);
      else {
        uint64_t v12 = v16;
      }
      if (v12 > v11) {
        goto LABEL_29;
      }
    }

    if (v13 - (char *)__CFBMPEmojiList == -2)
    {
LABEL_29:
      unint64_t v17 = (__int16 *)&unk_180D7BCDC;
      unsigned int v18 = __CFCompatibilityEmojiList;
      while (1)
      {
        __int16 v19 = (char *)&v18[((char *)v17 - (char *)v18) >> 2];
        unsigned int v20 = *(unsigned __int16 *)v19;
        if (v20 == (_DWORD)v4) {
          break;
        }
        int v21 = (unsigned __int16 *)(v19 - 2);
        __int16 v22 = (__int16 *)(v19 + 2);
        else {
          unsigned int v18 = v22;
        }
        if (v18 > v17) {
          return -1LL;
        }
      }

      uint64_t result = ((v19 - (char *)__CFCompatibilityEmojiList) >> 1) + 722;
    }

    else
    {
      uint64_t result = (v13 - (char *)__CFBMPEmojiList) >> 1;
    }

    uint64_t v23 = 1LL;
    goto LABEL_41;
  }

  if (a2 < 2) {
    return -1LL;
  }
  unsigned int v7 = a1[1];
  if (v7 >> 10 != 55) {
    return -1LL;
  }
  unsigned int v8 = v7 + ((_DWORD)v4 << 10);
  if (v8 - 56741350 > 0x19)
  {
    __int16 v24 = (unsigned __int16 *)&unk_180D7BAF0;
    unsigned int v25 = ((_WORD)v8 + 1024) & 0xFFF;
    unsigned int v26 = __CFSMPEmojiList;
    while (1)
    {
      uint64_t v27 = (char *)&v26[((char *)v24 - (char *)v26) >> 2];
      unsigned int v28 = *(unsigned __int16 *)v27;
      if (v28 == v25) {
        break;
      }
      uint64_t v29 = (unsigned __int16 *)(v27 - 2);
      unsigned int v30 = (unsigned __int16 *)(v27 + 2);
      if (v28 > v25) {
        __int16 v24 = v29;
      }
      else {
        unsigned int v26 = v30;
      }
      if (v26 > v24) {
        goto LABEL_50;
      }
    }

    if (v27 - (char *)__CFSMPEmojiList != -2)
    {
      uint64_t result = ((v27 - (char *)__CFSMPEmojiList) >> 1) + 119;
      uint64_t v23 = 2LL;
      goto LABEL_41;
    }

uint64_t __CFFromEmojiIndex(unint64_t a1, __int16 *a2)
{
  if ((uint64_t)a1 <= 118)
  {
    __int16 v2 = __CFBMPEmojiList[a1];
LABEL_3:
    *a2 = v2;
    return 1LL;
  }

  if (a1 <= 0x2BC)
  {
    if (a2)
    {
      int v4 = __CFSMPEmojiList[a1 - 119];
      *a2 = ((v4 + 61440) >> 10) | 0xD800;
      a2[1] = v4 & 0x3FF | 0xDC00;
    }

    return 2LL;
  }

  if (a1 <= 0x2C7)
  {
    __int16 v5 = a1 - 654;
    if (a1 == 701) {
      __int16 v5 = 35;
    }
    *a2 = v5;
    a2[1] = 8419;
    return 2LL;
  }

  if (a1 > 0x2D1)
  {
    if (a1 <= 0x2D3)
    {
      __int16 v2 = __CFCompatibilityEmojiList[a1 - 722];
      goto LABEL_3;
    }

    return 0LL;
  }

  else
  {
    __int16 v6 = __CFRegionSequences[a1 - 712];
    if (a2)
    {
      __int16 v7 = *v6;
      *a2 = -10180;
      a2[1] = (v7 + 421) | 0xDC00;
    }

    __int16 v8 = v6[1];
    a2[2] = -10180;
    a2[3] = (v8 + 421) | 0xDC00;
    return 4LL;
  }

uint64_t __CFToKDDISJIS(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v60[1] = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    uint64_t v21 = 0LL;
    goto LABEL_84;
  }

  uint64_t v8 = a3;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_82;
      }
      int v13 = *a2;
      BOOL v14 = (v13 - 774) > 0x32 || ((1LL << (v13 - 6)) & 0x4000000000005LL) == 0;
      unsigned int v15 = v13 - 12441;
      if (v14 && v15 >= 2) {
        goto LABEL_82;
      }
    }

    uint64_t v17 = __CFToEmojiIndex(a2, v8 - v12, v60);
    if (v17 != -1)
    {
      if (v17 == 613)
      {
        uint64_t v18 = a1;
        __int16 v19 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFKDDITable[613] - 6;
        size_t v20 = strlen(v19);
        uint64_t v21 = v20 + v11;
        if (a5)
        {
          if (v21 > a5) {
            goto LABEL_82;
          }
          size_t v22 = v20;
          memcpy(a4, v19, v20);
          a4 += v22;
          a1 = v18;
          uint64_t v8 = a3;
        }

        else
        {
          a1 = v18;
          uint64_t v8 = a3;
        }
      }

      else
      {
        uint64_t v21 = v11 + 2;
        if (a5)
        {
          if (v21 > a5) {
            goto LABEL_82;
          }
          *(_WORD *)a4 = __rev16(__CFKDDITable[v17]);
          a4 += 2;
        }
      }

      uint64_t v24 = v60[0];
      goto LABEL_31;
    }

    unsigned int v23 = *a2;
    if (v23 <= 0x7F)
    {
      uint64_t v21 = v11 + 1;
      if (!a5) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }

    if ((unsigned __int16)(v23 + 159) <= 0x3Eu)
    {
      uint64_t v21 = v11 + 1;
      if (!a5) {
        goto LABEL_28;
      }
      LOBYTE(v23) = v23 + 64;
LABEL_27:
      *a4++ = v23;
      goto LABEL_28;
    }

    if ((unsigned __int16)(v23 + 12) < 0xACu)
    {
      LOWORD(v25) = -3;
      goto LABEL_42;
    }

    unsigned int v26 = (unsigned __int16 *)&__CFToJISCharMap;
    uint64_t v27 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      uint64_t v28 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v27 - v26)) >> 1;
      uint64_t v29 = &v26[17 * v28];
      unsigned int v30 = *v29;
      if (v30 <= v23) {
        break;
      }
      uint64_t v27 = v29 - 17;
LABEL_40:
      if (v26 > v27) {
        goto LABEL_41;
      }
    }

    if (v30 + 16 <= v23)
    {
      unsigned int v26 = v29 + 17;
      goto LABEL_40;
    }

    uint64_t v37 = (char *)&v26[17 * v28];
    int v25 = *(__int16 *)&v37[2 * (v23 - v30) + 2];
    if (*(_WORD *)&v37[2 * (v23 - v30) + 2])
    {
      if (v25 >= 256)
      {
        uint64_t v21 = v11 + 2;
        if (a5)
        {
          if (v21 <= a5)
          {
            int v38 = BYTE1(v25);
            int v39 = v25 & 0x7F;
            if ((v25 & 0x100) != 0) {
              int v40 = 31;
            }
            else {
              int v40 = 125;
            }
            unsigned int v41 = v40 + v39;
            unsigned int v42 = (v38 + 479) >> 1;
            char v43 = v42 - 127;
            unsigned int v44 = (v42 - 127);
            if (v41 > 0x7E) {
              LOBYTE(v41) = v41 + 1;
            }
            char v45 = v42 - 63;
            if (v44 <= 0x9F) {
              char v45 = v43;
            }
            *a4 = v45;
            a4[1] = v41;
            a4 += 2;
            goto LABEL_28;
          }

uint64_t __CFFromKDDISJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v9 = a3;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  unsigned int v47 = (a1 >> 7) & 1;
  int v48 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11) {
      return v12;
    }
    unsigned int v13 = *a2;
    if ((*a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      uint64_t v14 = 1LL;
      goto LABEL_9;
    }

    uint64_t v20 = v9 - 2;
    int v21 = a2[1];
    unsigned int v22 = v21 | (v13 << 8);
    if (v13 >= 0xA0) {
      __int16 v23 = 79;
    }
    else {
      __int16 v23 = 15;
    }
    __int16 v24 = v23 + v13;
    __int16 v25 = (2 * (v24 & 0x1FF)) | 1;
    int v26 = v21 + ((char)v21 >> 7);
    __int16 v27 = 2 * v24 + 2;
    else {
      __int16 v28 = v27;
    }
    else {
      char v29 = -125;
    }
    unsigned __int16 v30 = (v29 + v26) | (unsigned __int16)(v28 << 8);
    unsigned int v31 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    unsigned __int16 v32 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      uint64_t v33 = (0xF83E0F83E0F83E1LL * (v32 - v31)) >> 1;
      uint64_t v34 = &v31[33 * v33];
      unsigned int v35 = *v34;
      if (v35 <= v30) {
        break;
      }
      unsigned __int16 v32 = v34 - 33;
LABEL_36:
      if (v31 > v32) {
        goto LABEL_37;
      }
    }

    if (v35 + 32 <= v30)
    {
      unsigned int v31 = v34 + 33;
      goto LABEL_36;
    }

    LOWORD(v13) = v31[33 * v33 + 1 + (int)(v30 - v35)];
    if ((_WORD)v13)
    {
      unsigned int v36 = (unsigned __int16)(v22 + 31054);
      if ((unsigned __int16)v13 == 65533 || v36 <= 3)
      {
        if (v36 > 3) {
          goto LABEL_48;
        }
LABEL_38:
        LOWORD(v22) = __CFFromKDDISJIS_KDDI_old_2_new_table[v22 - 34482] - 2128;
        goto LABEL_49;
      }

      uint64_t v14 = 2LL;
LABEL_9:
      if (v48 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v47))
      {
        unsigned int v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v50);
        uint64_t v16 = *a6;
        uint64_t v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }

          if (v15)
          {
            unint64_t v17 = v15 + 1LL;
            uint64_t v18 = (__int16 *)v50;
            do
            {
              __int16 v19 = *v18++;
              *a4++ = v19;
              --v17;
            }

            while (v17 > 1);
          }
        }
      }

      else
      {
        if (a5) {
          *a4++ = v13;
        }
        uint64_t v11 = *a6 + 1;
        *a6 = v11;
      }

      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }

uint64_t __CFToISO_2022_JP_KDDI(char a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, void *a6)
{
  v78[1] = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    uint64_t v13 = 0LL;
    uint64_t v67 = 0LL;
    goto LABEL_172;
  }

  uint64_t v8 = a3;
  unsigned int v74 = a6;
  uint64_t v9 = a2 - 2;
  uint64_t v76 = a2;
LABEL_3:
  BOOL v10 = 0;
  unsigned int v11 = 0;
  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  do
  {
    if (a5 && a5 <= v12)
    {
      if ((a1 & 0x10) == 0) {
        break;
      }
      uint64_t v14 = (unsigned __int16 *)(a2 + 2 * v13);
      uint64_t v15 = *v14;
      BOOL v16 = (v15 - 774) > 0x32 || ((1LL << (v15 - 6)) & 0x4000000000005LL) == 0;
    }

    else
    {
      uint64_t v14 = (unsigned __int16 *)(a2 + 2 * v13);
      uint64_t v15 = *v14;
      if (v15 <= 0x7F)
      {
        if (v13 + 1 >= v8 || *(_WORD *)(a2 + 2 * (v13 + 1)) != 8419)
        {
          BOOL v10 = v11 != 0;
          if (v11) {
            uint64_t v18 = 4LL;
          }
          else {
            uint64_t v18 = 1LL;
          }
          if (!a5)
          {
            unsigned int v11 = 0;
            goto LABEL_147;
          }

          if (a5 - v12 >= v18)
          {
            if (v11)
            {
              *a4 = 27;
              *(_WORD *)(a4 + 1) = 16936;
              a4 += 3;
            }

            unsigned int v11 = 0;
            *a4++ = v15;
            goto LABEL_147;
          }

          break;
        }

        goto LABEL_37;
      }
    }

    if ((unsigned __int16)(v15 + 159) <= 0x3Eu)
    {
      BOOL v10 = v11 != 3;
      if (v11 == 3) {
        uint64_t v18 = 1LL;
      }
      else {
        uint64_t v18 = 4LL;
      }
      if (a5)
      {
        if (a5 - v12 < v18) {
          break;
        }
        if (v11 != 3)
        {
          *a4 = 27;
          *(_WORD *)(a4 + 1) = 18728;
          a4 += 3;
        }

        *a4++ = v15 - 64;
      }

      unsigned int v11 = 3;
      goto LABEL_147;
    }

LABEL_166:
      a2 = v76;
      if (!v11) {
        goto LABEL_167;
      }
LABEL_150:
      uint64_t v67 = v12 + 3;
      if (!a5) {
        goto LABEL_171;
      }
      if (v67 <= a5)
      {
        *a4 = 27;
        *(_WORD *)(a4 + 1) = 16936;
        goto LABEL_171;
      }

      do
      {
        uint64_t v68 = v13;
        uint64_t v69 = *(unsigned __int16 *)(v9 + 2 * v13);
        if (((v69 - 774) > 0x32 || ((1LL << (v69 - 6)) & 0x4000000000005LL) == 0)
          && (v69 - 12441) >= 2)
        {
          char IsValidCombiningCharacterForLatin1_4 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4(v69);
          a2 = v76;
        }

        else
        {
          char IsValidCombiningCharacterForLatin1_4 = 1;
        }

        --v13;
      }

      while (v68 >= 2 && (IsValidCombiningCharacterForLatin1_4 & 1) != 0);
      if (v68 < 2)
      {
        uint64_t v67 = 0LL;
        goto LABEL_171;
      }

      a4 -= v12;
      uint64_t v8 = v68 - 1;
      goto LABEL_3;
    }

    BOOL v10 = v75;
    uint64_t v40 = (unsigned __int16 *)&__CFToJISCharMap;
    unsigned int v41 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      uint64_t v42 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v41 - v40)) >> 1;
      uint64_t v43 = &v40[17 * v42];
      unsigned int v44 = *v43;
      unsigned int v41 = v43 - 17;
LABEL_84:
      if (v40 > v41) {
        goto LABEL_120;
      }
    }

    if (v44 + 16 <= v15)
    {
      uint64_t v40 = v43 + 17;
      goto LABEL_84;
    }

    unsigned int v52 = v40[17 * v42 + 1 + (int)(v15 - v44)];
    else {
      BOOL v53 = 1;
    }
    if (v53 || v52 - 10529 < 0x62E)
    {
LABEL_120:
      if ((a1 & 8) == 0)
      {
        if ((v15 - 774) <= 0x32 && ((1LL << (v15 - 6)) & 0x4000000000005LL) != 0
          || (v15 - 12441) < 2
          || (v56 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4(v15), BOOL v10 = v75, v56))
        {
          if ((a1 & 0x10) != 0)
          {
            uint64_t v57 = v76 + 2 * v13;
            unsigned int v59 = *(unsigned __int16 *)(v57 - 2);
            unsigned int v58 = (unsigned __int16 *)(v57 - 2);
            if (v59 > 0x7F) {
              unsigned int v60 = __CFPrecomposeCharJapanese(v58, 0);
            }
            else {
              unsigned int v60 = __CFStringEncodingPrecomposeLatinCharacter_6(v58, v8 - v13 + 1, 0LL);
            }
            unsigned int v61 = __CFToJIS(v60, 1);
            if (!v61 || v61 == 65533 || (v61 & 0x8000) != 0) {
              goto LABEL_166;
            }
            if (v11 == 1)
            {
              uint64_t v18 = 0LL;
              unsigned int v62 = 0LL;
              BOOL v10 = 0;
              uint64_t v63 = 2LL;
              if (!a5) {
                goto LABEL_145;
              }
LABEL_135:
              if (a5 - v12 >= v18)
              {
                a4 -= v63;
                char v54 = v61;
                unsigned int v55 = v61 >> 8;
                if (v11 != 1)
                {
                  *a4 = 27;
                  unsigned int v64 = a4 + 1;
                  BOOL v65 = v10;
                  __int16 v66 = v61;
                  strncpy(v64, *v62, *((unsigned __int8 *)v62 + 8));
                  LOBYTE(v55) = HIBYTE(v66);
                  char v54 = v66;
                  BOOL v10 = v65;
                  a4 = &v64[*((unsigned __int8 *)v62 + 8)];
                }

                goto LABEL_138;
              }

              goto LABEL_166;
            }

            if (v11) {
              uint64_t v63 = 2LL;
            }
            else {
              uint64_t v63 = 1LL;
            }
            if (v75) {
              v63 += LOBYTE((&__CFISO2022JPSequences)[2 * v11 + 1]) + 1LL;
            }
            uint64_t v18 = 5 - v63;
            BOOL v10 = 1;
            unsigned int v62 = &off_1899EA8D8;
            if (a5) {
              goto LABEL_135;
            }
LABEL_145:
            unsigned int v11 = 1;
          }

          else
          {
            uint64_t v18 = 0LL;
          }

          a2 = v76;
          goto LABEL_147;
        }
      }

      goto LABEL_166;
    }

    if (v52 < 0x100) {
      goto LABEL_166;
    }
    BOOL v10 = v11 != 1;
    if (v11 == 1) {
      uint64_t v18 = 2LL;
    }
    else {
      uint64_t v18 = 5LL;
    }
    if (!a5) {
      goto LABEL_145;
    }
    if (a5 - v12 < v18) {
      goto LABEL_166;
    }
    char v54 = v40[17 * v42 + 1 + (int)(v15 - v44)];
    unsigned int v55 = v52 >> 8;
    if (v11 != 1)
    {
      *a4 = 27;
      *(_WORD *)(a4 + 1) = 16932;
      a4 += 3;
    }

uint64_t __CFFromISO_2022_JP_KDDI( unsigned int a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, void *a6)
{
  __int16 v6 = a6;
  uint64_t v64 = *MEMORY[0x1895F89C0];
  if (__CFADD__(a2, a3))
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    if (a6) {
      goto LABEL_104;
    }
  }

  else
  {
    uint64_t v10 = a3;
    if (a3 < 1)
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = 0LL;
      goto LABEL_104;
    }

    unsigned int v11 = a4;
    uint64_t v12 = a2;
    unint64_t v56 = (unint64_t)&a2[a3];
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v8 = 0LL;
    int v59 = a1 & 0xC0;
    unsigned int v60 = a1;
    uint64_t v7 = 0LL;
    BOOL v16 = a4;
    uint64_t v62 = a5;
    while (2)
    {
      unint64_t v17 = (const char *)v12;
      uint64_t v9 = v8;
      uint64_t v18 = v10;
LABEL_8:
      if (a5 && a5 <= v7) {
        goto LABEL_93;
      }
      int v19 = *(unsigned __int8 *)v17;
      if (v19 != 27)
      {
        switch((_DWORD)v14)
        {
          case 1:
            int v20 = *((unsigned __int8 *)v17 + 1);
            if ((v19 & 1) != 0) {
              int v21 = 31;
            }
            else {
              int v21 = 125;
            }
            unsigned int v22 = (v20 & 0x7F) + v21;
            unsigned int v23 = (v19 + 479) >> 1;
            __int16 v24 = v23 - 127;
            unsigned int v25 = (v23 - 127);
            if (v22 > 0x7E) {
              LOBYTE(v22) = v22 + 1;
            }
            __int16 v26 = v23 - 63;
            if (v25 <= 0x9F) {
              __int16 v26 = v24;
            }
            unsigned __int16 v27 = v22 | (unsigned __int16)(v26 << 8);
            unsigned int v28 = (unsigned __int16)(v27 + 4800);
            else {
              unsigned __int16 v29 = v27 + 2816;
            }
            unsigned __int16 v30 = v27 + 1536;
            if (v28 > 0x14D) {
              unsigned __int16 v30 = v29;
            }
            if ((unsigned __int16)(v30 + 2051) < 0xFB43u)
            {
LABEL_39:
              if ((a1 & 1) != 0)
              {
                unsigned __int16 v45 = 63;
                unsigned int v11 = v16;
                goto LABEL_58;
              }

              unsigned int v39 = v20 | (v19 << 8);
              if ((unsigned __int16)(v39 - 30067) < 0xABAEu)
              {
LABEL_92:
                LODWORD(v14) = 1;
LABEL_93:
                uint64_t v10 = v18;
                uint64_t v8 = v9;
                uint64_t v12 = (unsigned __int8 *)v17;
                goto LABEL_94;
              }

              unsigned int v11 = v16;
              uint64_t v40 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
              unsigned int v41 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
              while (2)
              {
                uint64_t v42 = (0xF83E0F83E0F83E1LL * (v41 - v40)) >> 1;
                uint64_t v43 = &v40[33 * v42];
                unsigned int v44 = *v43;
                if (v44 > v39)
                {
                  unsigned int v41 = v43 - 33;
                  goto LABEL_46;
                }

                if (v44 + 32 <= v39)
                {
                  uint64_t v40 = v43 + 33;
LABEL_46:
                  if (v40 > v41) {
                    goto LABEL_92;
                  }
                  continue;
                }

                break;
              }

              unsigned __int16 v45 = v40[33 * v42 + 1 + (int)(v39 - v44)];
              if (v45) {
                BOOL v46 = v45 == 65533;
              }
              else {
                BOOL v46 = 1;
              }
              if (v46) {
                goto LABEL_92;
              }
LABEL_58:
              uint64_t v47 = v14;
              if (!v59
                || (int IsDecomposableCharacter_2 = __CFStringEncodingIsDecomposableCharacter_2(v45, (a1 >> 7) & 1),
                    a1 = v60,
                    a5 = v62,
                    !IsDecomposableCharacter_2))
              {
                if (a5) {
                  *v11++ = v45;
                }
                uint64_t v12 = (unsigned __int8 *)v17;
                uint64_t v8 = v9;
                uint64_t v10 = v18;
                uint64_t v15 = v7;
                goto LABEL_67;
              }

              uint64_t v15 = v7 + 1;
              if (!v62) {
                goto LABEL_63;
              }
              if (v7 + 2 > v62) {
                return v9;
              }
              __CFStringEncodingDecomposeCharacter_2(v60, v45, v11);
              uint64_t v15 = v7 + 1;
              a1 = v60;
              a5 = v62;
              v11 += 2;
LABEL_63:
              uint64_t v12 = (unsigned __int8 *)v17;
              uint64_t v8 = v9;
              uint64_t v10 = v18;
LABEL_67:
              uint64_t v49 = 2LL;
              uint64_t v14 = v47;
              __int16 v6 = a6;
LABEL_68:
              uint64_t v7 = v15 + 1;
              unint64_t v17 = (const char *)v12;
              uint64_t v9 = v8;
              uint64_t v18 = v10;
LABEL_69:
              uint64_t v8 = v49 + v9;
              uint64_t v12 = (unsigned __int8 *)&v17[v49];
              uint64_t v10 = v18 - v49;
              uint64_t v15 = v7;
              BOOL v16 = v11;
              if (v18 - v49 < 1) {
                goto LABEL_94;
              }
              continue;
            }

            char v31 = (unsigned __int16 *)&__CFEmojiIndexFromKDDI_SJIS;
            char v32 = (unsigned __int16 *)&unk_180D7D040;
            while (1)
            {
              uint64_t v33 = ((char *)v32 - (char *)v31) >> 3;
              int v34 = &v31[2 * v33];
              unsigned int v35 = *v34;
              if (v35 <= v30)
              {
                if (v35 >= v30)
                {
                  uint64_t v57 = v15;
                  uint64_t v36 = __CFFromEmojiIndex(v31[2 * v33 + 1], __src);
                  a5 = v62;
                  uint64_t v37 = v36;
                  if (v62)
                  {
                    if (v62 - v7 < v36)
                    {
                      LODWORD(v14) = 1;
                      uint64_t v10 = v18;
                      uint64_t v8 = v9;
                      uint64_t v12 = (unsigned __int8 *)v17;
                      __int16 v6 = a6;
                      goto LABEL_94;
                    }

                    memcpy(v16, __src, 2 * v36);
                    a5 = v62;
                    v16 += v37;
                  }

                  a1 = v60;
                  v7 += v37;
                  v9 += 2LL;
                  v17 += 2;
                  BOOL v38 = v18 <= 2;
                  v18 -= 2LL;
                  __int16 v6 = a6;
                  uint64_t v14 = 1LL;
                  uint64_t v15 = v57;
                  if (v38) {
                    goto LABEL_92;
                  }
                  goto LABEL_8;
                }

                char v31 = v34 + 2;
              }

              else
              {
                char v32 = v34 - 2;
              }

              if (v31 > v32) {
                goto LABEL_39;
              }
            }

          case 3:
            if ((v19 - 96) < 0xFFFFFFC1)
            {
              LODWORD(v14) = 1;
              goto LABEL_108;
            }

            if (a5)
            {
              LOWORD(v19) = v19 - 192;
LABEL_89:
              *v11++ = v19;
            }

            break;
          case 2:
            if (a5)
            {
              if (v19 == 126) {
                __int16 v54 = 8254;
              }
              else {
                __int16 v54 = *(unsigned __int8 *)v17;
              }
              if (v19 == 92) {
                LOWORD(v19) = 165;
              }
              else {
                LOWORD(v19) = v54;
              }
              goto LABEL_89;
            }

            break;
          case 0:
            if (!a5) {
              break;
            }
            goto LABEL_89;
          default:
LABEL_108:
            uint64_t v7 = v15;
            goto LABEL_94;
        }

        uint64_t v49 = 1LL;
        goto LABEL_68;
      }

      break;
    }

    uint64_t v58 = v7;
    uint64_t v50 = v14;
    for (uint64_t i = 0LL; i != 18; i += 2LL)
    {
      uint64_t v52 = LOBYTE((&__CFISO2022JPSequences)[i + 1]);
      if (v56 >= (unint64_t)&v17[v52 + 1])
      {
        int v53 = strncmp((&__CFISO2022JPSequences)[i], v17 + 1, LOBYTE((&__CFISO2022JPSequences)[i + 1]));
        a5 = v62;
        if (!v53)
        {
          uint64_t v14 = *((unsigned __int8 *)&__CFISO2022JPSequences + 8 * i + 9);
          uint64_t v49 = v52 + 1;
          __int16 v6 = a6;
          a1 = v60;
          unsigned int v11 = v16;
          uint64_t v7 = v58;
          goto LABEL_69;
        }
      }
    }

    uint64_t v14 = v50;
    if ((v50 & 0xFD) == 0)
    {
      unsigned int v11 = v16;
      __int16 v6 = a6;
      if (a5)
      {
        unsigned __int16 *v16 = 27;
        unsigned int v11 = v16 + 1;
      }

      a1 = v60;
      uint64_t v7 = v58 + 1;
      uint64_t v49 = 1LL;
      goto LABEL_69;
    }

    uint64_t v10 = v18;
    uint64_t v8 = v9;
    uint64_t v12 = (unsigned __int8 *)v17;
    __int16 v6 = a6;
    uint64_t v7 = v58;
LABEL_94:
    if (a5
      && (_DWORD)v14
      && v10 == 3
      && v7 == a5
      && *v12 == 27
      && v56 >= (unint64_t)(v12 + 3)
      && !strncmp("(B", (const char *)v12 + 1, 2uLL))
    {
      v8 += 3LL;
    }

uint64_t __CFToSoftBankSJIS(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v61[1] = *MEMORY[0x1895F89C0];
  if (a3 < 1)
  {
    uint64_t v12 = 0LL;
    uint64_t v22 = 0LL;
    goto LABEL_84;
  }

  uint64_t v8 = a3;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0) {
        goto LABEL_82;
      }
      int v13 = *a2;
      BOOL v14 = (v13 - 774) > 0x32 || ((1LL << (v13 - 6)) & 0x4000000000005LL) == 0;
      unsigned int v15 = v13 - 12441;
      if (v14 && v15 >= 2) {
        goto LABEL_82;
      }
    }

    uint64_t v17 = __CFToEmojiIndex(a2, v8 - v12, v61);
    if (v17 != -1)
    {
      unsigned int v18 = __CFSoftBankTable[v17];
      if (v18 > 6)
      {
        uint64_t v22 = v11 + 2;
        if (a5)
        {
          if (v22 > a5) {
            goto LABEL_82;
          }
          *a4 = BYTE1(v18);
          a4[1] = v18;
          a4 += 2;
        }
      }

      else
      {
        uint64_t v19 = a1;
        int v20 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFSoftBankTable[v17] - 6;
        size_t v21 = strlen(v20);
        uint64_t v22 = v21 + v11;
        if (a5)
        {
          if (v22 > a5) {
            goto LABEL_82;
          }
          size_t v23 = v21;
          memcpy(a4, v20, v21);
          a4 += v23;
          a1 = v19;
          uint64_t v8 = a3;
        }

        else
        {
          a1 = v19;
          uint64_t v8 = a3;
        }
      }

      uint64_t v25 = v61[0];
      goto LABEL_31;
    }

    unsigned int v24 = *a2;
    if (v24 <= 0x7F)
    {
      uint64_t v22 = v11 + 1;
      if (!a5) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }

    if ((unsigned __int16)(v24 + 159) <= 0x3Eu)
    {
      uint64_t v22 = v11 + 1;
      if (!a5) {
        goto LABEL_28;
      }
      LOBYTE(v24) = v24 + 64;
LABEL_27:
      *a4++ = v24;
      goto LABEL_28;
    }

    if ((unsigned __int16)(v24 + 12) < 0xACu)
    {
      LOWORD(v26) = -3;
      goto LABEL_42;
    }

    unsigned __int16 v27 = (unsigned __int16 *)&__CFToJISCharMap;
    unsigned int v28 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      uint64_t v29 = (uint64_t)(0xF0F0F0F0F0F0F0F1LL * (v28 - v27)) >> 1;
      unsigned __int16 v30 = &v27[17 * v29];
      unsigned int v31 = *v30;
      if (v31 <= v24) {
        break;
      }
      unsigned int v28 = v30 - 17;
LABEL_40:
      if (v27 > v28) {
        goto LABEL_41;
      }
    }

    if (v31 + 16 <= v24)
    {
      unsigned __int16 v27 = v30 + 17;
      goto LABEL_40;
    }

    BOOL v38 = (char *)&v27[17 * v29];
    int v26 = *(__int16 *)&v38[2 * (v24 - v31) + 2];
    if (*(_WORD *)&v38[2 * (v24 - v31) + 2])
    {
      if (v26 >= 256)
      {
        uint64_t v22 = v11 + 2;
        if (a5)
        {
          if (v22 <= a5)
          {
            int v39 = BYTE1(v26);
            int v40 = v26 & 0x7F;
            if ((v26 & 0x100) != 0) {
              int v41 = 31;
            }
            else {
              int v41 = 125;
            }
            unsigned int v42 = v41 + v40;
            unsigned int v43 = (v39 + 479) >> 1;
            char v44 = v43 - 127;
            unsigned int v45 = (v43 - 127);
            if (v42 > 0x7E) {
              LOBYTE(v42) = v42 + 1;
            }
            char v46 = v43 - 63;
            if (v45 <= 0x9F) {
              char v46 = v44;
            }
            *a4 = v46;
            a4[1] = v42;
            a4 += 2;
            goto LABEL_28;
          }

uint64_t __CFFromSoftBankSJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v48 = *MEMORY[0x1895F89C0];
  *a6 = 0LL;
  if (a3 < 1) {
    return 0LL;
  }
  uint64_t v9 = a3;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  unsigned int v44 = (a1 >> 7) & 1;
  int v45 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11) {
      return v12;
    }
    unsigned int v13 = *a2;
    if ((*a2 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      uint64_t v14 = 1LL;
LABEL_9:
      if (v45 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v44))
      {
        unsigned int v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v47);
        uint64_t v16 = *a6;
        uint64_t v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }

          if (v15)
          {
            unint64_t v17 = v15 + 1LL;
            unsigned int v18 = (__int16 *)v47;
            do
            {
              __int16 v19 = *v18++;
              *a4++ = v19;
              --v17;
            }

            while (v17 > 1);
          }
        }
      }

      else
      {
        if (a5) {
          *a4++ = v13;
        }
        uint64_t v11 = *a6 + 1;
        *a6 = v11;
      }

      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }

    uint64_t v20 = v9 - 2;
    int v21 = a2[1];
    if (v13 >= 0xA0) {
      __int16 v22 = 79;
    }
    else {
      __int16 v22 = 15;
    }
    __int16 v23 = v22 + v13;
    else {
      __int16 v24 = 2 * v23 + 2;
    }
    else {
      char v25 = -125;
    }
    unsigned int v26 = (unsigned __int16)((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8));
    unsigned __int16 v27 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    unsigned int v28 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      uint64_t v29 = (0xF83E0F83E0F83E1LL * (v28 - v27)) >> 1;
      unsigned __int16 v30 = &v27[33 * v29];
      unsigned int v31 = *v30;
      if (v31 <= v26) {
        break;
      }
      unsigned int v28 = v30 - 33;
LABEL_36:
      if (v27 > v28) {
        goto LABEL_46;
      }
    }

    if (v31 + 32 <= v26)
    {
      unsigned __int16 v27 = v30 + 33;
      goto LABEL_36;
    }

    unsigned __int16 v32 = v27[33 * v29 + 1 + (int)(v26 - v31)];
    if (v32 != 65533 && v32 != 0)
    {
      LOWORD(v13) = v32;
      uint64_t v14 = 2LL;
      goto LABEL_9;
    }

void sub_180B47F1C(_Unwind_Exception *exception_object)
{
}

void sub_180B49248(_Unwind_Exception *a1)
{
}

void sub_180B4CD5C(_Unwind_Exception *a1)
{
}

void sub_180B4E7DC(_Unwind_Exception *a1)
{
}

void sub_180B4EDF4(_Unwind_Exception *a1)
{
}

void sub_180B4F07C(_Unwind_Exception *a1)
{
}

void sub_180B4F358(_Unwind_Exception *a1)
{
}

void sub_180B4F82C(_Unwind_Exception *a1)
{
}

uint64_t __createArray(void *a1, uint64_t a2)
{
  v3[1] = *MEMORY[0x1895F89C0];
  v3[0] = a2;
  return [a1 initWithObjects:v3 count:1];
}

void sub_180B4FFAC(_Unwind_Exception *a1)
{
}

void sub_180B504B0(_Unwind_Exception *a1)
{
}

void sub_180B50A58(_Unwind_Exception *exception_object)
{
}

void sub_180B50DF0(_Unwind_Exception *a1)
{
}

void sub_180B51188(_Unwind_Exception *a1)
{
}

NSUInteger OUTLINED_FUNCTION_0_14(objc_class *a1)
{
  return __CFRequireConcreteImplementation(a1, v1);
}

  ;
}

double decodeTaggedTimeInterval(unint64_t a1)
{
  if (!a1) {
    return 0.0;
  }
  if (a1 == -1LL)
  {
    uint64_t v1 = 0x8000000000000000LL;
  }

  else
  {
    if (a1 >> 60) {
      decodeTaggedTimeInterval_cold_1();
    }
    uint64_t v1 = a1 & 0xFFFFFFFFFFFFFLL | (a1 >> 59 << 63) | (((uint64_t)(32 * a1) >> 57 << 52) + 0x3EF0000000000000LL);
  }

  return *(double *)&v1;
}

CFTypeID CFDateGetTypeID(void)
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  }
  return 42LL;
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  clock_gettime(_CLOCK_REALTIME, &__tp);
  return (double)__tp.tv_sec + -978307200.0 + (double)__tp.tv_nsec * 0.000000001;
}

void _systemClockChangedNotification()
{
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, @"NSSystemClockDidChangeNotification", 0LL, 0LL, 1u);
}

unint64_t __CFTimeIntervalToTSR(double a1)
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  }
  else {
    return 0x3FFFFFFFFFFFFFFFLL;
  }
}

double __CFTSRToTimeInterval(unint64_t a1)
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  }
  return *(double *)&__CF1_TSRRate * (double)a1;
}

double __CFTimeIntervalUntilTSR(unint64_t a1)
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  }
  uint64_t v2 = mach_absolute_time();
  unint64_t v3 = v2 - a1;
  if (v2 <= a1)
  {
    unint64_t v5 = a1 - v2;
    if (CFDateGetTypeID_initOnce != -1) {
      dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
    }
    return *(double *)&__CF1_TSRRate * (double)v5;
  }

  else
  {
    if (CFDateGetTypeID_initOnce != -1) {
      dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
    }
    return -(*(double *)&__CF1_TSRRate * (double)v3);
  }

unint64_t __CFTSRToNanoseconds(unint64_t a1)
{
  return vcvtmd_u64_f64(*(double *)&__CF1_TSRRate * (double)a1 * 1000000000.0);
}

dispatch_time_t __CFTSRToDispatchTime(unint64_t a1)
{
  unint64_t v1 = vcvtmd_u64_f64(*(double *)&__CF1_TSRRate * (double)a1 * 1000000000.0);
  if (v1 >= 0x7FFFFFFFFFFFFFFELL) {
    int64_t v2 = 0x7FFFFFFFFFFFFFFELL;
  }
  else {
    int64_t v2 = v1;
  }
  return dispatch_time(1uLL, v2);
}

double CFGetSystemUptime()
{
  if (CFDateGetTypeID_initOnce != -1) {
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  }
  return *(double *)&__CF1_TSRRate * (double)mach_absolute_time();
}

const void *__CFDateCopyDescription(void *a1)
{
  int64_t v2 = (void *)_CFAutoreleasePoolPush();
  unint64_t v3 = (const void *)[a1 description];
  int v4 = v3;
  if (v3) {
    CFRetain(v3);
  }
  _CFAutoreleasePoolPop(v2);
  return v4;
}

double __CFDateGetTypeID_block_invoke()
{
  v3[1] = *(mach_timebase_info *)MEMORY[0x1895F89C0];
  mach_timebase_info(v3);
  LODWORD(v0) = v3[0].numer;
  LODWORD(v1) = v3[0].denom;
  *(double *)&__CFTSRRate = 1000000000.0 / (double)v0 * (double)v1;
  double result = 1.0 / *(double *)&__CFTSRRate;
  *(double *)&__CF1_TSRRate = 1.0 / *(double *)&__CFTSRRate;
  return result;
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)-[NSDate initWithTimeIntervalSinceReferenceDate:]( objc_alloc(&OBJC_CLASS___NSDate),  "initWithTimeIntervalSinceReferenceDate:",  at);
}

CFTimeInterval CFDateGetTimeIntervalSinceDate(CFDateRef theDate, CFDateRef otherDate)
{
  return result;
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return -[__CFDate compare:](theDate, "compare:", otherDate);
}

NSUInteger OUTLINED_FUNCTION_0_15(objc_class *a1)
{
  return __CFRequireConcreteImplementation(a1, v1);
}

uint64_t _NSCFCalendarLogger()
{
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  return _NSCFCalendarLogger__logger;
}

void _CFICULog( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    if (a1)
    {
      uint64_t v10 = (const __CFString *)_CFStringCreateWithFormatAndArgumentsAux2( (uint64_t)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  0LL,  a1,  (uint64_t)&a9);
      if (v10)
      {
        uint64_t v11 = v10;
        CFIndex Length = CFStringGetLength(v10);
        CFIndex v13 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 16;
        uint64_t v14 = (char *)malloc(v13);
        if (!v14)
        {
LABEL_17:
          CFRelease(v11);
          return;
        }

        unsigned int v15 = v14;
        int CString = CFStringGetCString(v11, v14, v13, 0x8000100u);
        size_t v17 = strlen(v15);
        os_unfair_lock_lock((os_unfair_lock_t)&__CFICULogLock);
        fputs("// ", (FILE *)___CFICULoggingFD);
        unsigned int v18 = (FILE *)___CFICULoggingFD;
        if (CString) {
          BOOL v19 = v17 == 0;
        }
        else {
          BOOL v19 = 1;
        }
        if (v19 || v17 > 0x10000)
        {
          uint64_t v20 = "<unloggable message>\n";
        }

        else
        {
          fputs(v15, (FILE *)___CFICULoggingFD);
          if (v15[v17 - 1] == 10)
          {
LABEL_16:
            os_unfair_lock_unlock((os_unfair_lock_t)&__CFICULogLock);
            free(v15);
            goto LABEL_17;
          }

          unsigned int v18 = (FILE *)___CFICULoggingFD;
          uint64_t v20 = "\n";
        }

        fputs(v20, v18);
        goto LABEL_16;
      }
    }
  }

uint64_t __cficu_ucal_open(UChar *a1, int32_t a2, uint64_t a3, int a4, void *a5)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v10 = ucal_open();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      uint64_t v11 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", v10);
      uint64_t v12 = (const void *)___CFICUCreateVariableNameForStatus(a5);
      CFStringRef v13 = ___CFICUCreateErrorStringWithComment((int *)a5, 1);
      CFStringRef v14 = ___CFICUCreateArgumentForUCharInput(a1, a2, 0LL);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      unsigned int v15 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        size_t v17 = "<unknown UCalendarType>";
        int v18 = 138413826;
        __int16 v22 = 1024;
        BOOL v19 = v11;
        if (a4 == 1) {
          size_t v17 = "UCAL_GREGORIAN";
        }
        __int16 v20 = 2112;
        CFStringRef v21 = v14;
        if (!a4) {
          size_t v17 = "UCAL_TRADITIONAL";
        }
        int32_t v23 = a2;
        __int16 v24 = 2080;
        uint64_t v25 = a3;
        __int16 v26 = 2080;
        unsigned __int16 v27 = v17;
        __int16 v28 = 2112;
        uint64_t v29 = v12;
        __int16 v30 = 2112;
        CFStringRef v31 = v13;
        _os_log_debug_impl( &dword_180A4C000,  v15,  OS_LOG_TYPE_DEBUG,  "UCalendar *%@ = ucal_open(%@, %d, %s, %s, &%@); %@",
          (uint8_t *)&v18,
          0x44u);
      }

      CFRelease(v11);
      CFRelease(v14);
      CFRelease(v12);
      CFRelease(v13);
    }
  }

  return v10;
}

uint64_t ___CFICUCreateVariableNameForStatus(const void *a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 0LL;
  __int16 v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  CFStringRef v2 = ___CFICUCreateVariableNameForStackPointerLocked("status", a1);
  v6[3] = (uint64_t)v2;
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  uint64_t v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  ___CFICULogWithArguments(1, &stru_1899EF170);
  ___CFICULogWithArguments(1, @"UErrorCode %@ = U_ZERO_ERROR;", v3);
  return v3;
}

void sub_180B53214(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

CFStringRef ___CFICUCreateErrorStringWithComment(int *a1, int a2)
{
  CFTypeRef v4 = CFRetain(&stru_1899EF170);
  if (*a1 < 1) {
    return (CFStringRef)v4;
  }
  uint64_t v5 = u_errorName((UErrorCode)*a1);
  if (a2) {
    return CFStringCreateWithFormat(0LL, 0LL, @"// ERROR: %s", v5);
  }
  else {
    return CFStringCreateWithFormat(0LL, 0LL, @"(ERROR: %s)", v5);
  }
}

CFStringRef ___CFICUCreateArgumentForUCharInput(UChar *s, int32_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!s) {
    return (CFStringRef)CFRetain(@"NULL");
  }
  int32_t v4 = a2;
  if (a2 == -1) {
    int32_t v4 = u_strlen(s);
  }
  uint64_t v10 = MEMORY[0x1895F87A8];
  uint64_t v11 = 0x40000000LL;
  uint64_t v12 = _____CFICUCreateArgumentForUCharInput_block_invoke;
  CFStringRef v13 = &__block_descriptor_tmp_183;
  LODWORD(v14) = a3;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateArgumentForUCharInput_block_invoke((uint64_t)&v10);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  __int16 v6 = (const void *)___CFICUCreateVariableName("temp");
  CFStringRef v7 = CFStringCreateWithCharacters(0LL, s, v4);
  CFStringRef v8 = CFStringCreateWithFormat(0LL, 0LL, @"TEMP_UCHAR%d(%@)", a3, v7, v10, v11, v12, v13, v14, v15);
  CFRelease(v7);
  CFRelease(v6);
  return v8;
}

void __cficu_ucal_close(const void *a1)
{
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (!os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    ucal_close();
    return;
  }

  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
  }

  else
  {
    CFStringRef v2 = 0LL;
  }

  ucal_close();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled != 1) {
    goto LABEL_16;
  }
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  uint64_t v3 = (os_log_s *)_NSCFCalendarLogger__logger;
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    __cficu_ucal_close_cold_1((uint64_t)v2, v3, v4, v5, v6, v7, v8, v9);
    if (!v2) {
      return;
    }
  }

  else
  {
LABEL_16:
    if (!v2) {
      return;
    }
  }

  CFRelease(v2);
}

uint64_t __cficu_ucal_clone(uint64_t a1, int *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v4 = ucal_clone();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      uint64_t v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", v4);
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      uint64_t v9 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        uint64_t v12 = v5;
        __int16 v13 = 2112;
        CFStringRef v14 = v6;
        __int16 v15 = 2112;
        uint64_t v16 = v7;
        __int16 v17 = 2112;
        CFStringRef v18 = v8;
        _os_log_debug_impl( &dword_180A4C000,  v9,  OS_LOG_TYPE_DEBUG,  "UCalendar *%@ = ucal_clone(%@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }

      CFRelease(v5);
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }

  return v4;
}

uint64_t ___CFICUCreateVariableNameForStatusIfNeeded(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  char v3 = 0;
  uint64_t v5 = 0LL;
  CFStringRef v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  v4[0] = MEMORY[0x1895F87A8];
  v4[2] = _____CFICUCreateVariableNameForStackPointerIfNeeded_block_invoke;
  v4[3] = &unk_1899EAE50;
  v4[1] = 0x40000000LL;
  v4[4] = &v5;
  v4[5] = "status";
  v4[6] = a1;
  v4[7] = &v3;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateVariableNameForStackPointerIfNeeded_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  uint64_t v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  if (v3)
  {
    ___CFICULogWithArguments(1, &stru_1899EF170);
    ___CFICULogWithArguments(1, @"UErrorCode %@ = U_ZERO_ERROR;", v1);
  }

  return v1;
}

void sub_180B53850(_Unwind_Exception *a1)
{
}

void __cficu_ucal_setAttribute(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  ucal_setAttribute();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      uint64_t v7 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if (a2 > 4) {
          uint64_t v8 = "<unknown UCalendarAttribute>";
        }
        else {
          uint64_t v8 = off_1899EAE70[a2];
        }
        int v9 = 138412802;
        CFStringRef v10 = v6;
        __int16 v11 = 2080;
        uint64_t v12 = v8;
        __int16 v13 = 1024;
        int v14 = a3;
        _os_log_debug_impl( &dword_180A4C000,  v7,  OS_LOG_TYPE_DEBUG,  "ucal_setAttribute(%@, %s, %d);",
          (uint8_t *)&v9,
          0x1Cu);
      }

      CFRelease(v6);
    }
  }

uint64_t __cficu_ucal_getAttribute(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t Attribute = ucal_getAttribute();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v6 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if (a2 > 4) {
          uint64_t v8 = "<unknown UCalendarAttribute>";
        }
        else {
          uint64_t v8 = off_1899EAE70[a2];
        }
        int v9 = 138412802;
        CFStringRef v10 = v5;
        __int16 v11 = 2080;
        uint64_t v12 = v8;
        __int16 v13 = 1024;
        int v14 = Attribute;
        _os_log_debug_impl( &dword_180A4C000,  v6,  OS_LOG_TYPE_DEBUG,  "ucal_getAttribute(%@, %s); // %d",
          (uint8_t *)&v9,
          0x1Cu);
      }

      CFRelease(v5);
    }
  }

  return Attribute;
}

void __cficu_ucal_setGregorianChange(uint64_t a1, int *a2, double a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  ucal_setGregorianChange();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateArgumentForDouble(a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v10 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        CFStringRef v12 = v6;
        __int16 v13 = 2112;
        CFStringRef v14 = v8;
        __int16 v15 = 2112;
        uint64_t v16 = v7;
        __int16 v17 = 2112;
        CFStringRef v18 = v9;
        _os_log_debug_impl( &dword_180A4C000,  v10,  OS_LOG_TYPE_DEBUG,  "ucal_setGregorianChange(%@, %@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }

      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }

CFStringRef ___CFICUCreateArgumentForDouble(double a1)
{
  if (fabs(a1) != INFINITY) {
    return CFStringCreateWithFormat(0LL, 0LL, @"%f", *(void *)&a1);
  }
  if (a1 <= 0.0) {
    return (CFStringRef)CFRetain(@"-INFINITY");
  }
  return (CFStringRef)CFRetain(@"INFINITY");
}

double __cficu_ucal_getGregorianChange(uint64_t a1, int *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  ucal_getGregorianChange();
  double v5 = v4;
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v9 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        CFStringRef v12 = v6;
        __int16 v13 = 2112;
        CFStringRef v14 = v7;
        __int16 v15 = 2048;
        double v16 = v5;
        __int16 v17 = 2112;
        CFStringRef v18 = v8;
        _os_log_debug_impl( &dword_180A4C000,  v9,  OS_LOG_TYPE_DEBUG,  "ucal_getGregorianChange(%@, &%@); // %f %@",
          (uint8_t *)&v11,
          0x2Au);
      }

      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }

  return v5;
}

double __cficu_ucal_getMillis(uint64_t a1, int *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  ucal_getMillis();
  double v5 = v4;
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v9 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        CFStringRef v12 = v6;
        __int16 v13 = 2112;
        CFStringRef v14 = v7;
        __int16 v15 = 2048;
        double v16 = v5;
        __int16 v17 = 2112;
        CFStringRef v18 = v8;
        _os_log_debug_impl( &dword_180A4C000,  v9,  OS_LOG_TYPE_DEBUG,  "ucal_getMillis(%@, &%@); // %f %@",
          (uint8_t *)&v11,
          0x2Au);
      }

      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }

  return v5;
}

void __cficu_ucal_setMillis(uint64_t a1, int *a2, double a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  ucal_setMillis();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v8 = ___CFICUCreateArgumentForDouble(a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v10 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 138413058;
        CFStringRef v12 = v6;
        __int16 v13 = 2112;
        CFStringRef v14 = v8;
        __int16 v15 = 2112;
        double v16 = v7;
        __int16 v17 = 2112;
        CFStringRef v18 = v9;
        _os_log_debug_impl( &dword_180A4C000,  v10,  OS_LOG_TYPE_DEBUG,  "ucal_setMillis(%@, %@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }

      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }

void __cficu_ucal_set(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  ucal_set();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      uint64_t v7 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v8 = 138412802;
        CFStringRef v9 = v6;
        __int16 v10 = 2080;
        int v11 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v12 = 1024;
        int v13 = a3;
        _os_log_debug_impl(&dword_180A4C000, v7, OS_LOG_TYPE_DEBUG, "ucal_set(%@, %s, %d);", (uint8_t *)&v8, 0x1Cu);
      }

      CFRelease(v6);
    }
  }

const char *___CFICUGetEnumStringForUCalendarDateFields(unsigned int a1)
{
  if (a1 > 0x18) {
    return "<unknown UCalendarDateFields>";
  }
  else {
    return off_1899EAE98[a1];
  }
}

uint64_t __cficu_ucal_get(uint64_t a1, unsigned int a2, int *a3)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v6 = ucal_get();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      int v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      __int16 v10 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v12 = 138413314;
        CFStringRef v13 = v7;
        __int16 v14 = 2080;
        __int16 v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v16 = 2112;
        __int16 v17 = v8;
        __int16 v18 = 1024;
        int v19 = v6;
        __int16 v20 = 2112;
        CFStringRef v21 = v9;
        _os_log_debug_impl( &dword_180A4C000,  v10,  OS_LOG_TYPE_DEBUG,  "ucal_get(%@, %s, &%@); // %d %@",
          (uint8_t *)&v12,
          0x30u);
      }

      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }

  return v6;
}

uint64_t __cficu_ucal_getDayOfWeekType(uint64_t a1, int a2, int *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t DayOfWeekType = ucal_getDayOfWeekType();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      int v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      __int16 v10 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        else {
          int v12 = off_1899EAF78[a2 - 1];
        }
        else {
          CFStringRef v13 = off_1899EAF60[(int)DayOfWeekType - 1];
        }
        int v14 = 138413314;
        CFStringRef v15 = v7;
        __int16 v16 = 2080;
        __int16 v17 = v12;
        __int16 v18 = 2112;
        int v19 = v8;
        __int16 v20 = 2080;
        CFStringRef v21 = v13;
        __int16 v22 = 2112;
        CFStringRef v23 = v9;
        _os_log_debug_impl( &dword_180A4C000,  v10,  OS_LOG_TYPE_DEBUG,  "ucal_getDayOfWeekType(%@, %s, &%@); // %s %@",
          (uint8_t *)&v14,
          0x34u);
      }

      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }

  return DayOfWeekType;
}

uint64_t __cficu_ucal_getWeekendTransition(uint64_t a1, int a2, int *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t WeekendTransition = ucal_getWeekendTransition();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      int v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      __int16 v10 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        else {
          int v12 = off_1899EAF78[a2 - 1];
        }
        int v13 = 138413314;
        CFStringRef v14 = v7;
        __int16 v15 = 2080;
        __int16 v16 = v12;
        __int16 v17 = 2112;
        __int16 v18 = v8;
        __int16 v19 = 1024;
        int v20 = WeekendTransition;
        __int16 v21 = 2112;
        CFStringRef v22 = v9;
        _os_log_debug_impl( &dword_180A4C000,  v10,  OS_LOG_TYPE_DEBUG,  "ucal_getWeekendTransition(%@, %s, &%@); // %d %@",
          (uint8_t *)&v13,
          0x30u);
      }

      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }

  return WeekendTransition;
}

uint64_t __cficu_ucal_isWeekend(uint64_t a1, int *a2, double a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t isWeekend = ucal_isWeekend();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      int v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      CFStringRef v9 = ___CFICUCreateArgumentForDouble(a3);
      CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      int v11 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v13 = 138413314;
        CFStringRef v14 = v7;
        __int16 v15 = 2112;
        CFStringRef v16 = v9;
        __int16 v17 = 2112;
        __int16 v18 = v8;
        __int16 v19 = 1024;
        int v20 = isWeekend;
        __int16 v21 = 2112;
        CFStringRef v22 = v10;
        _os_log_debug_impl( &dword_180A4C000,  v11,  OS_LOG_TYPE_DEBUG,  "ucal_isWeekend(%@, %@, &%@); // %d %@",
          (uint8_t *)&v13,
          0x30u);
      }

      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v10);
      CFRelease(v9);
    }
  }

  return isWeekend;
}

void __cficu_ucal_clear(uint64_t a1)
{
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      char v3 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG)) {
        __cficu_ucal_clear_cold_1((uint64_t)v2, v3, v4, v5, v6, v7, v8, v9);
      }
      CFRelease(v2);
    }
  }

uint64_t __cficu_ucal_getLimit(uint64_t a1, unsigned int a2, unsigned int a3, int *a4)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t Limit = ucal_getLimit();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      CFStringRef v11 = ___CFICUCreateErrorStringWithComment(a4, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      int v12 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v14 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        if (a3 > 5) {
          __int16 v15 = "<unknown UCalendarLimitType>";
        }
        else {
          __int16 v15 = off_1899EAFB0[a3];
        }
        int v16 = 138413570;
        CFStringRef v17 = v9;
        __int16 v18 = 2080;
        __int16 v19 = v14;
        __int16 v20 = 2080;
        __int16 v21 = v15;
        __int16 v22 = 2112;
        uint64_t v23 = v10;
        __int16 v24 = 1024;
        int v25 = Limit;
        __int16 v26 = 2112;
        CFStringRef v27 = v11;
        _os_log_debug_impl( &dword_180A4C000,  v12,  OS_LOG_TYPE_DEBUG,  "ucal_getLimit(%@, %s, %s, &%@); // %d %@",
          (uint8_t *)&v16,
          0x3Au);
      }

      CFRelease(v9);
      CFRelease(v10);
      CFRelease(v11);
    }
  }

  return Limit;
}

void __cficu_ucal_add(uint64_t a1, unsigned int a2, int a3, int *a4)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  ucal_add();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v11 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v12 = 138413314;
        CFStringRef v13 = v8;
        __int16 v14 = 2080;
        __int16 v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v16 = 1024;
        int v17 = a3;
        __int16 v18 = 2112;
        __int16 v19 = v9;
        __int16 v20 = 2112;
        CFStringRef v21 = v10;
        _os_log_debug_impl( &dword_180A4C000,  v11,  OS_LOG_TYPE_DEBUG,  "ucal_add(%@, %s, %d, &%@); %@",
          (uint8_t *)&v12,
          0x30u);
      }

      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }

void __cficu_ucal_roll(uint64_t a1, unsigned int a2, int a3, int *a4)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  ucal_roll();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v11 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v12 = 138413314;
        CFStringRef v13 = v8;
        __int16 v14 = 2080;
        __int16 v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v16 = 1024;
        int v17 = a3;
        __int16 v18 = 2112;
        __int16 v19 = v9;
        __int16 v20 = 2112;
        CFStringRef v21 = v10;
        _os_log_debug_impl( &dword_180A4C000,  v11,  OS_LOG_TYPE_DEBUG,  "ucal_roll(%@, %s, %d, &%@); %@",
          (uint8_t *)&v12,
          0x30u);
      }

      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }

uint64_t __cficu_ucal_getFieldDifference(uint64_t a1, unsigned int a2, int *a3, double a4)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t FieldDifference = ucal_getFieldDifference();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      CFStringRef v11 = ___CFICUCreateArgumentForDouble(a4);
      CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v13 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v15 = 138413570;
        CFStringRef v16 = v9;
        __int16 v17 = 2112;
        CFStringRef v18 = v11;
        __int16 v19 = 2080;
        __int16 v20 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        __int16 v21 = 2112;
        uint64_t v22 = v10;
        __int16 v23 = 1024;
        int v24 = FieldDifference;
        __int16 v25 = 2112;
        CFStringRef v26 = v12;
        _os_log_debug_impl( &dword_180A4C000,  v13,  OS_LOG_TYPE_DEBUG,  "ucal_getFieldDifference(%@, %@, %s, &%@); // %d %@",
          (uint8_t *)&v15,
          0x3Au);
      }

      CFRelease(v9);
      CFRelease(v10);
      CFRelease(v11);
      CFRelease(v12);
    }
  }

  return FieldDifference;
}

double __cficu_ucal_getNow()
{
  double v0 = MEMORY[0x186E046D8]();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  uint64_t v1 = (os_log_s *)_NSCFCalendarLogger__logger;
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG)) {
    __cficu_ucal_getNow_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
  }
  return v0;
}

void __cficu_ucal_setTimeZone(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  ucal_setTimeZone();
  if (_NSCFCalendarLogger_onceToken != -1) {
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  }
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1) {
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    }
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      CFStringRef v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      CFStringRef v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      CFStringRef v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      CFStringRef v11 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0LL);
      if (_NSCFCalendarLogger_onceToken != -1) {
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      }
      CFStringRef v12 = (os_log_s *)_NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        int v13 = 138413314;
        CFStringRef v14 = v8;
        __int16 v15 = 2112;
        CFStringRef v16 = v11;
        __int16 v17 = 1024;
        int32_t v18 = a3;
        __int16 v19 = 2112;
        __int16 v20 = v9;
        __int16 v21 = 2112;
        CFStringRef v22 = v10;
        _os_log_debug_impl( &dword_180A4C000,  v12,  OS_LOG_TYPE_DEBUG,  "ucal_setTimeZone(%@, %@, %d, &%@); %@",
          (uint8_t *)&v13,
          0x30u);
      }

      CFRelease(v11);
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }

uint64_t __cficu_udatpg_open(uint64_t a1, int *a2)
{
  uint64_t v4 = udatpg_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    uint64_t v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dtpg", v4);
    uint64_t v6 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v7 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, @"UDateTimePatternGenerator *%@ = udatpg_open(%s, &%@); %@", v5, a1, v6, v7);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
  }

  return v4;
}

void ___CFICULogWithArguments(int a1, CFStringRef format, ...)
{
  uint64_t v3 = CFStringCreateWithFormatAndArguments(0LL, 0LL, format, va);
  if (CFStringGetCStringPtr(v3, 0x8000100u))
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    CFIndex Length = CFStringGetLength(v3);
    CFIndex v6 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    uint64_t v4 = (char *)malloc(v6);
    CFStringGetCString(v3, v4, v6, 0x8000100u);
  }

  os_unfair_lock_lock((os_unfair_lock_t)&__CFICULogLock);
  if (a1) {
    fprintf((FILE *)___CFICULoggingFD, "\t%s\n");
  }
  else {
    fprintf((FILE *)___CFICULoggingFD, "%s\n");
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFICULogLock);
  if (v4) {
    free(v4);
  }
  CFRelease(v3);
}

void __cficu_udatpg_close(const void *a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    udatpg_close();
    ___CFICULogWithArguments(1, @"udatpg_close(%@);", v2);
    CFRelease(v2);
  }

  else
  {
    udatpg_close();
  }

uint64_t __cficu_udatpg_getSkeleton( uint64_t a1, UChar *a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t Skeleton = udatpg_getSkeleton();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", a1);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput("skeleton", (uint64_t)a4, a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    CFStringRef v17 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0LL);
    if (*a6 <= 0) {
      CFStringRef v18 = CFStringCreateWithCharacters(0LL, a4, (int)Skeleton);
    }
    else {
      CFStringRef v18 = 0LL;
    }
    ___CFICULogWithArguments( 1,  @"udatpg_getSkeleton(%@, %@, %d, %@, %d, &%@); // %d %@ %@",
      v13,
      v17,
      a3,
      v15,
      a5,
      v14,
      Skeleton,
      v18,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v17);
    if (v18) {
      CFRelease(v18);
    }
    CFRelease(v16);
  }

  return Skeleton;
}

CFTypeRef ___CFICUCreateVariableNameForUCharOutput(char *a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    return CFRetain(@"NULL");
  }
  uint64_t v4 = ___CFICUCreateVariableName(a1);
  ___CFICULogWithArguments(1, @"UChar %@[%d];", v4, a3);
  return (CFTypeRef)v4;
}

uint64_t __cficu_udatpg_getBestPattern( uint64_t a1, UChar *a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t BestPattern = udatpg_getBestPattern();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", a1);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput("pattern", (uint64_t)a4, a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    CFStringRef v17 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0LL);
    if (*a6 <= 0) {
      CFStringRef v18 = CFStringCreateWithCharacters(0LL, a4, (int)BestPattern);
    }
    else {
      CFStringRef v18 = 0LL;
    }
    ___CFICULogWithArguments( 1,  @"udatpg_getBestPattern(%@, %@, %d, %@, %d, &%@); // %d %@ %@",
      v13,
      v17,
      a3,
      v15,
      a5,
      v14,
      BestPattern,
      v18,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    if (v18) {
      CFRelease(v18);
    }
    CFRelease(v17);
    CFRelease(v16);
  }

  return BestPattern;
}

void __cficu_udat_applyPattern(uint64_t a1, int a2, UChar *a3, uint64_t a4)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v8 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0LL);
    CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, @"udat_applyPattern(%@, %d, %@, %d);", v9, a2, v8, a4);
    CFRelease(v8);
    CFRelease(v9);
  }

void __cficu_udat_applyPatternRelative(uint64_t a1, UChar *a2, uint64_t a3, UChar *a4, uint64_t a5, int *a6)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    CFStringRef v15 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0LL);
    CFStringRef v16 = ___CFICUCreateArgumentForUCharInput(a4, a5, 1LL);
    ___CFICULogWithArguments( 1,  @"udat_applyPatternRelative(%@, %@, %d, %@, %d, &%@); %@",
      v12,
      v15,
      a3,
      v16,
      a5,
      v13,
      v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v14);
  }

uint64_t __cficu_udat_clone(uint64_t a1, int *a2)
{
  uint64_t v4 = udat_clone();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    uint64_t v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", v4);
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, @"UDateFormat *%@ = udat_clone(%@, &%@); %@", v5, v6, v7, v8);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v8);
  }

  return v4;
}

void __cficu_udat_close(const void *a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    udat_close();
    ___CFICULogWithArguments(1, @"udat_close(%@);", v2);
    CFRelease(v2);
  }

  else
  {
    udat_close();
  }

uint64_t __cficu_udat_countSymbols(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = udat_countSymbols();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v6 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments(1, @"udat_countSymbols(%@, %s); // %d", v5, v6, v4);
    CFRelease(v5);
  }

  return v4;
}

const char *___CFICUGetEnumStringForUDateFormatSymbolType(unsigned int a1)
{
  if (a1 > 0x15) {
    return "<unknown UDateFormatSymbolType>";
  }
  else {
    return off_1899EAFE0[a1];
  }
}

uint64_t __cficu_udat_format(uint64_t a1, const UniChar *a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = udat_format();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a2, a3);
    CFStringRef v16 = ___CFICUCreateArgumentForDouble(a6);
    CFStringRef v17 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
    {
      CFStringRef v18 = CFStringCreateWithCharacters(0LL, a2, (int)v12);
      if (!a4) {
        goto LABEL_7;
      }
    }

    else
    {
      CFStringRef v18 = 0LL;
      if (!a4)
      {
LABEL_7:
        ___CFICULogWithArguments( 1,  @"udat_format(%@, %@, %@, %d, NULL, &%@); // %d %@ %@",
          v13,
          v16,
          v15,
          a3,
          v14,
          v12,
          v18,
          v17);
        ___CFICULogWithArguments(1, @"u_printf(%@: '%%S'\\n, %@);", v15, v15);
        CFRelease(v13);
        CFRelease(v14);
        CFRelease(v15);
        CFRelease(v16);
        if (v18) {
          CFRelease(v18);
        }
        CFRelease(v17);
        return v12;
      }
    }

    ___CFICULogWithArguments(1, @"#warning non-NULL position ignored");
    goto LABEL_7;
  }

  return v12;
}

uint64_t __cficu_udat_formatForFields( uint64_t a1, const UniChar *a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = udat_formatForFields();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a2, a3);
    CFStringRef v16 = ___CFICUCreateArgumentForDouble(a6);
    CFStringRef v17 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
    {
      CFStringRef v18 = CFStringCreateWithCharacters(0LL, a2, (int)v12);
      if (!a4) {
        goto LABEL_7;
      }
    }

    else
    {
      CFStringRef v18 = 0LL;
      if (!a4)
      {
LABEL_7:
        ___CFICULogWithArguments( 1,  @"udat_format(%@, %@, %@, %d, NULL, &%@); // %d %@ %@",
          v13,
          v16,
          v15,
          a3,
          v14,
          v12,
          v18,
          v17);
        ___CFICULogWithArguments(1, @"u_printf(%@: '%%S'\\n, %@);", v15, v15);
        CFRelease(v13);
        CFRelease(v14);
        CFRelease(v15);
        CFRelease(v16);
        if (v18) {
          CFRelease(v18);
        }
        CFRelease(v17);
        return v12;
      }
    }

    ___CFICULogWithArguments(1, @"#warning non-NULL UFieldPositionIterator ignored");
    goto LABEL_7;
  }

  return v12;
}

double __cficu_udat_get2DigitYearStart(uint64_t a1, int *a2)
{
  double v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
    ___CFICULogWithArguments(1, @"udat_get2DigitYearStart(%@, &%@); // %f %@", v6, v7, *(void *)&v5, v8);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v8);
  }

  return v5;
}

uint64_t __cficu_udat_getCalendar(uint64_t a1)
{
  uint64_t Calendar = udat_getCalendar();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    uint64_t v3 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", Calendar);
    CFStringRef v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, @"const UCalendar *%@ = udat_getCalendar(%@);", v3, v4);
    CFRelease(v4);
    CFRelease(v3);
  }

  return Calendar;
}

uint64_t __cficu_udat_getSymbols( uint64_t a1, unsigned int a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t Symbols = udat_getSymbols();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a4, a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    if (*a6 <= 0) {
      CFStringRef v17 = CFStringCreateWithCharacters(0LL, a4, (int)Symbols);
    }
    else {
      CFStringRef v17 = 0LL;
    }
    CFStringRef v18 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments( 1,  @"udat_getSymbols(%@, %s, %d, %@, %d, &%@); // %d %@ %@",
      v13,
      v18,
      a3,
      v15,
      a5,
      v14,
      Symbols,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    if (v17) {
      CFRelease(v17);
    }
    CFRelease(v16);
  }

  return Symbols;
}

uint64_t __cficu_udat_isLenient(uint64_t a1)
{
  uint64_t isLenient = udat_isLenient();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v3 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, @"udat_isLenient(%@); // %d", v3, (int)isLenient);
    CFRelease(v3);
  }

  return isLenient;
}

void __cficu_udat_setContext(uint64_t a1, int a2, void *a3)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v7 = (const void *)___CFICUCreateVariableNameForStatus(a3);
    CFStringRef v8 = ___CFICUCreateErrorStringWithComment((int *)a3, 1);
    CFStringRef v9 = v8;
    else {
      CFStringRef v10 = off_1899EB268[a2 - 256];
    }
    ___CFICULogWithArguments(1, @"udat_setContext(%@, %s, %@); %@", v6, v10, v7, v8);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v9);
  }

uint64_t __cficu_udat_getContext(uint64_t a1, int a2, void *a3)
{
  uint64_t Context = udat_getContext();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v7 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v8 = (const void *)___CFICUCreateVariableName("cxt");
    CFStringRef v9 = (const void *)___CFICUCreateVariableNameForStatus(a3);
    CFStringRef v10 = ___CFICUCreateErrorStringWithComment((int *)a3, 1);
    CFStringRef v11 = v10;
    uint64_t v12 = "<unknown UDisplayContextType>";
    if (a2 == 1) {
      uint64_t v12 = "UDISPCTX_TYPE_CAPITALIZATION";
    }
    if (!a2) {
      uint64_t v12 = "UDISPCTX_TYPE_DIALECT_HANDLING";
    }
    ___CFICULogWithArguments(1, @"UDisplayContext %@ = udat_getContext(%@, %s, %@); %@", v8, v7, v12, v9, v10);
    CFRelease(v7);
    CFRelease(v8);
    CFRelease(v9);
    CFRelease(v11);
  }

  return Context;
}

uint64_t ___CFICUCreateVariableName(char *a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 0LL;
  CFStringRef v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  CFStringRef v2 = ___CFICUCreateVariableNameLocked(a1);
  v6[3] = (uint64_t)v2;
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  uint64_t v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v3;
}

void sub_180B56C50(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t __cficu_udat_open( int a1, int a2, uint64_t a3, UChar *a4, uint64_t a5, UChar *a6, uint64_t a7, void *a8)
{
  uint64_t v16 = udat_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    int v24 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", v16);
    CFStringRef v17 = (const void *)___CFICUCreateVariableNameForStatus(a8);
    CFStringRef v18 = ___CFICUCreateErrorStringWithComment((int *)a8, 1);
    CFStringRef v19 = ___CFICUCreateArgumentForUCharInput(a4, a5, 0LL);
    CFStringRef v20 = ___CFICUCreateArgumentForUCharInput(a6, a7, 1LL);
    __int16 v21 = ___CFICUGetEnumStringForUDateFormatStyle(a1);
    CFStringRef v22 = ___CFICUGetEnumStringForUDateFormatStyle(a2);
    ___CFICULogWithArguments( 1,  @"UDateFormat *%@ = udat_open(%s, %s, %s, %@, %d, %@, %d, &%@); %@",
      v24,
      v21,
      v22,
      a3,
      v19,
      a5,
      v20,
      a7,
      v17,
      v18);
    CFRelease(v19);
    CFRelease(v20);
    CFRelease(v24);
    CFRelease(v17);
    CFRelease(v18);
  }

  return v16;
}

const char *___CFICUGetEnumStringForUDateFormatStyle(int a1)
{
  int v1 = a1 + 2;
  CFTimeInterval result = "UDAT_FULL";
  switch(v1)
  {
    case 0:
      CFTimeInterval result = "UDAT_IGNORE";
      break;
    case 1:
      CFTimeInterval result = "UDAT_NONE";
      break;
    case 2:
      return result;
    case 3:
      CFTimeInterval result = "UDAT_LONG";
      break;
    case 4:
      CFTimeInterval result = "UDAT_MEDIUM";
      break;
    case 5:
      CFTimeInterval result = "UDAT_SHORT";
      break;
    default:
      switch("UDAT_FULL")
      {
        case 0x80u:
          CFTimeInterval result = "UDAT_RELATIVE";
          break;
        case 0x81u:
          CFTimeInterval result = "UDAT_LONG_RELATIVE";
          break;
        case 0x82u:
          CFTimeInterval result = "UDAT_MEDIUM_RELATIVE";
          break;
        case 0x83u:
          CFTimeInterval result = "UDAT_SHORT_RELATIVE";
          break;
        default:
          CFTimeInterval result = "<unknown UDateFormatStyle>";
          break;
      }

      break;
  }

  return result;
}

void __cficu_udat_parseCalendar(uint64_t a1, uint64_t a2, UChar *a3, uint64_t a4, unsigned int *a5, int *a6)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    CFStringRef v12 = ___CFICUCreateArgumentForParsePosition(a5);
    udat_parseCalendar();
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v14 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a2);
    CFTypeRef v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    CFStringRef v17 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0LL);
    CFStringRef v18 = v17;
    if (a5) {
      uint64_t v19 = *a5;
    }
    else {
      uint64_t v19 = 0xFFFFFFFFLL;
    }
    ___CFICULogWithArguments( 1,  @"udat_parseCalendar(%@, %@, %@, %d, %@, &%@); // %d %@",
      v13,
      v14,
      v17,
      a4,
      v12,
      v15,
      v19,
      v16);
    CFRelease(v12);
    CFRelease(v15);
    CFRelease(v14);
    CFRelease(v13);
    CFRelease(v18);
    CFRelease(v16);
  }

  else
  {
    udat_parseCalendar();
  }

CFStringRef ___CFICUCreateArgumentForParsePosition(unsigned int *a1)
{
  if (!a1) {
    return (CFStringRef)CFRetain(@"NULL");
  }
  CFStringRef v2 = (const void *)___CFICUCreateVariableName("parsePos");
  CFStringRef v3 = CFStringCreateWithFormat(0LL, 0LL, @"&%@", v2);
  ___CFICULogWithArguments(1, @"int32_t %@ = %d;", v2, *a1);
  CFRelease(v2);
  return v3;
}

void __cficu_udat_set2DigitYearStart(uint64_t a1, int *a2, double a3)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    uint64_t v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v8 = ___CFICUCreateArgumentForDouble(a3);
    CFStringRef v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, @"udat_set2DigitYearStart(%@, %@, &%@); %@", v6, v8, v7, v9);
    CFRelease(v7);
    CFRelease(v6);
    CFRelease(v8);
    CFRelease(v9);
  }

void __cficu_udat_setCalendar(uint64_t a1, uint64_t a2)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a2);
    ___CFICULogWithArguments(1, @"udat_setCalendar(%@, %@);", v4, v5);
    CFRelease(v4);
    CFRelease(v5);
  }

void __cficu_udat_setLenient(uint64_t a1, int a2)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, @"udat_setLenient(%@, %d);", v4, a2);
    CFRelease(v4);
  }

void __cficu_udat_setSymbols(uint64_t a1, unsigned int a2, uint64_t a3, UChar *a4, uint64_t a5, int *a6)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    CFStringRef v15 = ___CFICUCreateArgumentForUCharInput(a4, a5, 0LL);
    CFStringRef v16 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments(1, @"udat_setSymbols(%@, %s, %d, %@, %d, &%@); %@", v12, v16, a3, v15, a5, v13, v14);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v15);
    CFRelease(v14);
  }

uint64_t __cficu_udat_toPattern(uint64_t a1, int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t v10 = udat_toPattern();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    CFStringRef v12 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v13 = ___CFICUCreateVariableNameForUCharOutput("pattern", (uint64_t)a3, a4);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    CFStringRef v15 = v14;
    if (*a5 < 1)
    {
      CFStringRef v16 = CFStringCreateWithCharacters(0LL, a3, (int)v10);
      ___CFICULogWithArguments( 1,  @"udat_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@",
        v11,
        a2,
        v13,
        a4,
        v12,
        v10,
        v16,
        v15);
      if (v16) {
        CFRelease(v16);
      }
    }

    else
    {
      ___CFICULogWithArguments( 1,  @"udat_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@",
        v11,
        a2,
        v13,
        a4,
        v12,
        v10,
        0LL,
        v14);
    }

    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v15);
  }

  return v10;
}

uint64_t __cficu_udat_toPatternRelativeDate(uint64_t a1, const UniChar *a2, uint64_t a3, int *a4)
{
  uint64_t v8 = udat_toPatternRelativeDate();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    uint64_t v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
    CFTypeRef v11 = ___CFICUCreateVariableNameForUCharOutput("pattern", (uint64_t)a2, a3);
    CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a4, 0);
    CFStringRef v13 = v12;
    if (*a4 < 1)
    {
      CFStringRef v14 = CFStringCreateWithCharacters(0LL, a2, (int)v8);
      ___CFICULogWithArguments( 1,  @"udat_toPatternRelativeDate(%@,  %@, %d, &%@); // %d %@ %@",
        v9,
        v11,
        a3,
        v10,
        v8,
        v14,
        v13);
      if (v14) {
        CFRelease(v14);
      }
    }

    else
    {
      ___CFICULogWithArguments( 1,  @"udat_toPatternRelativeDate(%@,  %@, %d, &%@); // %d %@ %@",
        v9,
        v11,
        a3,
        v10,
        v8,
        0LL,
        v12);
    }

    CFRelease(v9);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
  }

  return v8;
}

uint64_t __cficu_udat_toPatternRelativeTime(uint64_t a1, const UniChar *a2, uint64_t a3, int *a4)
{
  uint64_t v8 = udat_toPatternRelativeTime();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    uint64_t v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
    CFTypeRef v11 = ___CFICUCreateVariableNameForUCharOutput("pattern", (uint64_t)a2, a3);
    CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a4, 0);
    CFStringRef v13 = v12;
    if (*a4 < 1)
    {
      CFStringRef v14 = CFStringCreateWithCharacters(0LL, a2, (int)v8);
      ___CFICULogWithArguments( 1,  @"udat_toPatternRelativeTime(%@,  %@, %d, &%@); // %d %@ %@",
        v9,
        v11,
        a3,
        v10,
        v8,
        v14,
        v13);
      if (v14) {
        CFRelease(v14);
      }
    }

    else
    {
      ___CFICULogWithArguments( 1,  @"udat_toPatternRelativeTime(%@,  %@, %d, &%@); // %d %@ %@",
        v9,
        v11,
        a3,
        v10,
        v8,
        0LL,
        v12);
    }

    CFRelease(v9);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
  }

  return v8;
}

void __cficu_unum_applyPattern(uint64_t a1, int a2, UChar *a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    CFStringRef v15 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0LL);
    if (a5) {
      ___CFICULogWithArguments(1, @"#warning non-NULL parseError ignored");
    }
    ___CFICULogWithArguments(1, @"unum_applyPattern(%@, %d, %@, %d, NULL, &%@); %@", v12, a2, v15, a4, v13, v14);
    CFRelease(v15);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v14);
  }

void __cficu_unum_close(const void *a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    unum_close();
    ___CFICULogWithArguments(1, @"unum_close(%@);", v2);
    CFRelease(v2);
  }

  else
  {
    unum_close();
  }

uint64_t __cficu_unum_formatDecimal( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  uint64_t v14 = unum_formatDecimal();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v15 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v16 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
    CFTypeRef v17 = ___CFICUCreateVariableNameForUCharOutput("result", a4, a5);
    CFStringRef v18 = ___CFICUCreateErrorStringWithComment(a7, 1);
    if (a2)
    {
      int v19 = a3;
      if ((_DWORD)a3 == -1) {
        int v19 = strlen(a2);
      }
      CFStringRef v20 = (void *)CFStringCreateWithBytes(0LL, (const UInt8 *)a2, v19, 0x8000100u, 0);
    }

    else
    {
      CFStringRef v20 = (void *)CFRetain(@"NULL");
    }

    __int16 v21 = v20;
    if (a6) {
      ___CFICULogWithArguments(1, @"#warning non-NULL pos ignored.");
    }
    ___CFICULogWithArguments( 1,  @"unum_formatDecimal(%@, %@, %d, %@, %d, NULL, &%@); %@",
      v15,
      v21,
      a3,
      v17,
      a5,
      v16,
      v18);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
    CFRelease(v21);
    CFRelease(v18);
  }

  return v14;
}

uint64_t __cficu_unum_formatDouble(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = unum_formatDouble();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v15 = ___CFICUCreateVariableNameForUCharOutput("result", a2, a3);
    CFStringRef v16 = ___CFICUCreateArgumentForDouble(a6);
    CFStringRef v17 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (a4) {
      ___CFICULogWithArguments(1, @"#warning non-NULL pos ignored.");
    }
    ___CFICULogWithArguments(1, @"unum_formatDouble(%@, %@, %@, %d, NULL, &%@); %@", v13, v16, v15, a3, v14, v17);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }

  return v12;
}

uint64_t __cficu_unum_getAttribute(uint64_t a1, int a2)
{
  uint64_t Attribute = unum_getAttribute();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v6 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, @"unum_getAttribute(%@, %s); // %d", v5, v6, Attribute);
    CFRelease(v5);
  }

  return Attribute;
}

const char *___CFICUGetEnumStringForUNumberFormatAttribute(int a1)
{
  CFTimeInterval result = "UNUM_PARSE_INT_ONLY";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      CFTimeInterval result = "UNUM_GROUPING_USED";
      break;
    case 2:
      CFTimeInterval result = "UNUM_DECIMAL_ALWAYS_SHOWN";
      break;
    case 3:
      CFTimeInterval result = "UNUM_MAX_INTEGER_DIGITS";
      break;
    case 4:
      CFTimeInterval result = "UNUM_MIN_INTEGER_DIGITS";
      break;
    case 5:
      CFTimeInterval result = "UNUM_INTEGER_DIGITS";
      break;
    case 6:
      CFTimeInterval result = "UNUM_MAX_FRACTION_DIGITS";
      break;
    case 7:
      CFTimeInterval result = "UNUM_MIN_FRACTION_DIGITS";
      break;
    case 8:
      CFTimeInterval result = "UNUM_FRACTION_DIGITS";
      break;
    case 9:
      CFTimeInterval result = "UNUM_MULTIPLIER";
      break;
    case 10:
      CFTimeInterval result = "UNUM_GROUPING_SIZE";
      break;
    case 11:
      CFTimeInterval result = "UNUM_ROUNDING_MODE";
      break;
    case 12:
      CFTimeInterval result = "UNUM_ROUNDING_INCREMENT";
      break;
    case 13:
      CFTimeInterval result = "UNUM_FORMAT_WIDTH";
      break;
    case 14:
      CFTimeInterval result = "UNUM_PADDING_POSITION";
      break;
    case 15:
      CFTimeInterval result = "UNUM_SECONDARY_GROUPING_SIZE";
      break;
    case 16:
      CFTimeInterval result = "UNUM_SIGNIFICANT_DIGITS_USED";
      break;
    case 17:
      CFTimeInterval result = "UNUM_MIN_SIGNIFICANT_DIGITS";
      break;
    case 18:
      CFTimeInterval result = "UNUM_MAX_SIGNIFICANT_DIGITS";
      break;
    case 19:
      CFTimeInterval result = "UNUM_LENIENT_PARSE";
      break;
    case 20:
      CFTimeInterval result = "UNUM_PARSE_ALL_INPUT";
      break;
    default:
      switch(a1)
      {
        case 4095:
          CFTimeInterval result = "UNUM_MAX_NONBOOLEAN_ATTRIBUTE";
          break;
        case 4096:
          CFTimeInterval result = "UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS";
          break;
        case 4097:
          CFTimeInterval result = "UNUM_PARSE_NO_EXPONENT";
          break;
        case 4101:
          CFTimeInterval result = "UNUM_LIMIT_BOOLEAN_ATTRIBUTE";
          break;
        default:
          CFTimeInterval result = "<unknown UNumberFormatAttribute>";
          break;
      }

      break;
  }

  return result;
}

double __cficu_unum_getDoubleAttribute(uint64_t a1, int a2)
{
  double v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v7 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, @"unum_getAttribute(%@, %s); // %f", v6, v7, *(void *)&v5);
    CFRelease(v6);
  }

  return v5;
}

uint64_t __cficu_unum_getSymbol(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t Symbol = unum_getSymbol();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFTypeRef v12 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0) {
      CFStringRef v15 = CFStringCreateWithCharacters(0LL, a3, (int)Symbol);
    }
    else {
      CFStringRef v15 = 0LL;
    }
    CFStringRef v16 = ___CFICUGetEnumStringForUNumberFormatSymbol(a2);
    ___CFICULogWithArguments( 1,  @"unum_getSymbol(%@, %s, %@, %d, &%@); // %d %@ %@",
      v11,
      v16,
      v12,
      a4,
      v13,
      Symbol,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15) {
      CFRelease(v15);
    }
    CFRelease(v14);
  }

  return Symbol;
}

const char *___CFICUGetEnumStringForUNumberFormatSymbol(unsigned int a1)
{
  if (a1 > 0x1D) {
    return "<unknown UNumberFormatSymbol>";
  }
  else {
    return off_1899EB090[a1];
  }
}

uint64_t __cficu_unum_getTextAttribute(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  Textuint64_t Attribute = unum_getTextAttribute();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFTypeRef v12 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0) {
      CFStringRef v15 = CFStringCreateWithCharacters(0LL, a3, (int)TextAttribute);
    }
    else {
      CFStringRef v15 = 0LL;
    }
    if (a2 > 7) {
      CFStringRef v16 = "<unknown UNumberFormatTextAttribute>";
    }
    else {
      CFStringRef v16 = off_1899EB210[a2];
    }
    ___CFICULogWithArguments( 1,  @"unum_getTextAttribute(%@, %s, %@, %d, &%@); // %d %@ %@",
      v11,
      v16,
      v12,
      a4,
      v13,
      TextAttribute,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15) {
      CFRelease(v15);
    }
    CFRelease(v14);
  }

  return TextAttribute;
}

uint64_t __cficu_unum_open(unsigned int a1, UChar *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v12 = unum_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"numFmt", v12);
    CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatus(a6);
    CFStringRef v15 = ___CFICUCreateErrorStringWithComment((int *)a6, 1);
    CFStringRef v16 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0LL);
    if (a5) {
      ___CFICULogWithArguments(1, @"#warning non-NULL parseErr ignored");
    }
    if (a1 > 0x11) {
      CFStringRef v17 = "<unknown UNumberFormatStyle>";
    }
    else {
      CFStringRef v17 = off_1899EB180[a1];
    }
    ___CFICULogWithArguments( 1,  @"UNumberFormat *%@ = unum_open(%s, %@, %d, %s, NULL, &%@); %@",
      v13,
      v17,
      v16,
      a3,
      a4,
      v14,
      v15);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v16);
    CFRelease(v15);
  }

  return v12;
}

uint64_t __cficu_unum_parse(uint64_t a1, UChar *a2, uint64_t a3, unsigned int *a4, int *a5)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if ((___CFICULoggingEnabled_loggingEnabled & 1) == 0) {
    return unum_parse();
  }
  CFStringRef v10 = ___CFICUCreateArgumentForParsePosition(a4);
  uint64_t v11 = unum_parse();
  CFStringRef v12 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0LL);
  CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
  CFStringRef v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
  CFStringRef v15 = ___CFICUCreateErrorStringWithComment(a5, 0);
  ___CFICULogWithArguments(1, @"unum_parse(%@, %@, %d, %@, &%@); // %d %@", v13, v12, a3, v10, v14, v11, v15);
  CFRelease(v13);
  CFRelease(v14);
  CFRelease(v12);
  CFRelease(v10);
  CFRelease(v15);
  return v11;
}

uint64_t __cficu_unum_parseDecimal( uint64_t a1, UChar *a2, uint64_t a3, unsigned int *a4, const UInt8 *a5, uint64_t a6, int *a7)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if ((___CFICULoggingEnabled_loggingEnabled & 1) == 0) {
    return unum_parseDecimal();
  }
  CFStringRef v14 = ___CFICUCreateArgumentForParsePosition(a4);
  uint64_t v15 = unum_parseDecimal();
  CFStringRef v16 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
  CFStringRef v17 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
  CFStringRef v18 = ___CFICUCreateErrorStringWithComment(a7, 0);
  if (*a7 <= 0) {
    CFStringRef v19 = CFStringCreateWithBytes(0LL, a5, (int)v15, 0x8000100u, 0);
  }
  else {
    CFStringRef v19 = 0LL;
  }
  CFStringRef v21 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0LL);
  CFStringRef v22 = (const void *)___CFICUCreateVariableName("result");
  ___CFICULogWithArguments(1, @"char %@[%d];", v22, a6);
  ___CFICULogWithArguments( 1,  @"unum_parseDecimal(%@, %@, %d, %@, %@, %d, &%@); // %d %@ %@",
    v16,
    v21,
    a3,
    v14,
    v22,
    a6,
    v17,
    v15,
    v19,
    v18);
  CFRelease(v16);
  CFRelease(v17);
  CFRelease(v22);
  CFRelease(v14);
  if (v19) {
    CFRelease(v19);
  }
  CFRelease(v21);
  CFRelease(v18);
  return v15;
}

void __cficu_unum_setAttribute(uint64_t a1, int a2, uint64_t a3)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v7 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, @"unum_setAttribute(%@, %s, %d);", v6, v7, a3);
    CFRelease(v6);
  }

void __cficu_unum_setDoubleAttribute(uint64_t a1, int a2, double a3)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v7 = ___CFICUCreateArgumentForDouble(a3);
    uint64_t v8 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, @"unum_setDoubleAttribute(%@, %s, %@);", v6, v8, v7);
    CFRelease(v6);
    CFRelease(v7);
  }

void __cficu_unum_setContext(uint64_t a1, uint64_t a2, int *a3)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v7 = ___CFICUCreateErrorStringWithComment(a3, 1);
    ___CFICULogWithArguments(1, @"unum_setContext(%@, %d, &%@);", v6, a2, v7);
    CFRelease(v7);
    CFRelease(v6);
  }

uint64_t __cficu_unum_getContext(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t Context = unum_getContext();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v8 = ___CFICUCreateErrorStringWithComment(a3, 1);
    ___CFICULogWithArguments(1, @"unum_getContext(%@, %d, &%@); // %d", v7, a2, v8, Context);
    CFRelease(v8);
    CFRelease(v7);
  }

  return Context;
}

void __cficu_unum_setSymbol(uint64_t a1, unsigned int a2, UChar *a3, uint64_t a4, int *a5)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v10 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v11 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a5, 1);
    CFStringRef v13 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0LL);
    CFStringRef v14 = ___CFICUGetEnumStringForUNumberFormatSymbol(a2);
    ___CFICULogWithArguments(1, @"unum_setSymbol(%@, %s, %@, %d, &%@); %@", v10, v14, v13, a4, v11, v12);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
    CFRelease(v12);
  }

void __cficu_unum_setTextAttribute(uint64_t a1, unsigned int a2, UChar *a3, uint64_t a4, int *a5)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v10 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    uint64_t v11 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v12 = ___CFICUCreateErrorStringWithComment(a5, 1);
    CFStringRef v13 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0LL);
    CFStringRef v14 = v13;
    if (a2 > 7) {
      uint64_t v15 = "<unknown UNumberFormatTextAttribute>";
    }
    else {
      uint64_t v15 = off_1899EB210[a2];
    }
    ___CFICULogWithArguments(1, @"unum_setTextAttribute(%@, %s, %@, %d, &%@); %@", v10, v15, v13, a4, v11, v12);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v14);
    CFRelease(v12);
  }

uint64_t __cficu_unum_toPattern(uint64_t a1, int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t v10 = unum_toPattern();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    CFStringRef v12 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFTypeRef v13 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0) {
      CFStringRef v15 = CFStringCreateWithCharacters(0LL, a3, (int)v10);
    }
    else {
      CFStringRef v15 = 0LL;
    }
    ___CFICULogWithArguments( 1,  @"unum_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@",
      v11,
      a2,
      v13,
      a4,
      v12,
      v10,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15) {
      CFRelease(v15);
    }
    CFRelease(v14);
  }

  return v10;
}

uint64_t __cficu_ulistfmt_open(uint64_t a1, void *a2)
{
  uint64_t v4 = ulistfmt_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    double v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"listFmt", v4);
    CFStringRef v6 = (const void *)___CFICUCreateVariableNameForStatus(a2);
    CFStringRef v7 = ___CFICUCreateErrorStringWithComment((int *)a2, 1);
    ___CFICULogWithArguments(1, @"UListFormatter *%@ = ulistfmt_open(%s, &%@); %@", v5, a1, v6, v7);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
  }

  return v4;
}

uint64_t __cficu_ulistfmt_format( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const UniChar *a5, uint64_t a6, int *a7)
{
  uint64_t v14 = ulistfmt_format();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    uint64_t v28 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"listFmt", a1);
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, (int)a4, &kCFTypeArrayCallBacks);
    if ((int)a4 >= 1)
    {
      uint64_t v16 = 0LL;
      do
      {
        CFStringRef v17 = ___CFICUCreateArgumentForUCharInput(*(UChar **)(a2 + 8 * v16), *(_DWORD *)(a3 + 4 * v16), v16);
        CFArrayAppendValue(Mutable, v17);
        CFRelease(v17);
        ++v16;
      }

      while (a4 != v16);
    }

    uint64_t v27 = (const void *)___CFICUCreateVariableName("strings");
    ___CFICULogWithArguments(1, @"UChar* const %@[%d] = {", v27, a4);
    if ((int)a4 >= 1)
    {
      unint64_t v18 = 0LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v18);
        else {
          ___CFICULogWithArguments(1, @"%@,", ValueAtIndex);
        }
        ++v18;
      }

      while (a4 != v18);
    }

    ___CFICULogWithArguments(1, @"};\n");
    CFRelease(Mutable);
    CFStringRef v20 = (const void *)___CFICUCreateVariableName("stringLengths");
    ___CFICULogWithArguments(1, @"int32_t %@[%d] = {", v20, a4);
    if ((int)a4 >= 1)
    {
      unint64_t v21 = 0LL;
      do
      {
        else {
          ___CFICULogWithArguments(1, @"%d,", *(unsigned int *)(a3 + 4 * v21));
        }
        ++v21;
      }

      while (a4 != v21);
    }

    ___CFICULogWithArguments(1, @"};\n");
    CFStringRef v22 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
    CFTypeRef v23 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a5, a6);
    CFStringRef v24 = ___CFICUCreateErrorStringWithComment(a7, 0);
    if (*a7 <= 0) {
      CFStringRef v25 = CFStringCreateWithCharacters(0LL, a5, (int)v14);
    }
    else {
      CFStringRef v25 = 0LL;
    }
    ___CFICULogWithArguments( 1,  @"ulistfmt_format(%@, %@, %@, %d, %@, %d, &%@); // %d %@  %@",
      v28,
      v27,
      v20,
      a4,
      v23,
      a6,
      v22,
      v14,
      v25,
      v24);
    CFRelease(v28);
    CFRelease(v27);
    CFRelease(v20);
    CFRelease(v22);
    CFRelease(v23);
    CFRelease(v24);
    if (v25) {
      CFRelease(v25);
    }
  }

  return v14;
}

void __cficu_ulistfmt_close(const void *a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"listFmt", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    ulistfmt_close();
    ___CFICULogWithArguments(1, @"ulistfmt_close(%@);", v2);
    CFRelease(v2);
  }

  else
  {
    ulistfmt_close();
  }

uint64_t __cficu_ucurr_getDefaultFractionDigits(UChar *a1, int *a2)
{
  uint64_t DefaultFractionDigits = ucurr_getDefaultFractionDigits();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    double v5 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v6 = ___CFICUCreateErrorStringWithComment(a2, 0);
    int32_t v7 = u_strlen(a1);
    CFStringRef v8 = ___CFICUCreateArgumentForUCharInput(a1, v7, 0LL);
    ___CFICULogWithArguments( 1,  @"ucurr_getDefaultFractionDigits(%@, &%@); // %d %@",
      v8,
      v5,
      DefaultFractionDigits,
      v6);
    CFRelease(v5);
    CFRelease(v8);
    CFRelease(v6);
  }

  return DefaultFractionDigits;
}

double __cficu_ucurr_getRoundingIncrement(UChar *a1, int *a2)
{
  double v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v6 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    CFStringRef v7 = ___CFICUCreateErrorStringWithComment(a2, 0);
    int32_t v8 = u_strlen(a1);
    CFStringRef v9 = ___CFICUCreateArgumentForUCharInput(a1, v8, 0LL);
    ___CFICULogWithArguments( 1,  @"ucurr_getRoundingIncrement(%@, &%@); // %d %@",
      v9,
      v6,
      (int)v5,
      v7);
    CFRelease(v6);
    CFRelease(v9);
    CFRelease(v7);
  }

  return (double)(int)v5;
}

uint64_t __cficu_ureldatefmt_open(uint64_t a1, uint64_t a2, unsigned int a3, int a4, void *a5)
{
  uint64_t v10 = ureldatefmt_open();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v11 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"relDateFmt", v10);
    CFStringRef v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a2);
    CFTypeRef v13 = (const void *)___CFICUCreateVariableNameForStatus(a5);
    CFStringRef v14 = ___CFICUCreateErrorStringWithComment((int *)a5, 1);
    CFStringRef v15 = v14;
    if (a3 > 2) {
      uint64_t v16 = "<unknown UDateRelativeDateTimeFormatterStyle>";
    }
    else {
      uint64_t v16 = off_1899EB250[a3];
    }
    else {
      CFStringRef v17 = off_1899EB268[a4 - 256];
    }
    ___CFICULogWithArguments( 1,  @"URelativeDateTimeFormatter *%@ = ureldatefmt_open(%s, %@, %s, %s, &%@); %@",
      v11,
      a1,
      v12,
      v16,
      v17,
      v13,
      v14);
    CFRelease(v11);
    CFRelease(v13);
    CFRelease(v15);
    CFRelease(v12);
  }

  return v10;
}

uint64_t __cficu_ureldatefmt_formatNumeric( uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = ureldatefmt_formatNumeric();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", a1);
    CFTypeRef v14 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    CFStringRef v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (*a5 <= 0) {
      CFStringRef v17 = CFStringCreateWithCharacters(0LL, a3, (int)v12);
    }
    else {
      CFStringRef v17 = 0LL;
    }
    if (a2 > 7) {
      unint64_t v18 = "<unknown URelativeDateTimeUnit>";
    }
    else {
      unint64_t v18 = off_1899EB290[a2];
    }
    ___CFICULogWithArguments( 1,  @"ureldatefmt_formatNumeric(%@, %lf, %s, %@, %d, &%@); // %d, %@, %@",
      v13,
      *(void *)&a6,
      v18,
      v14,
      a4,
      v15,
      v12,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }

  return v12;
}

uint64_t __cficu_ureldatefmt_format( uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12 = ureldatefmt_format();
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    CFStringRef v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", a1);
    CFTypeRef v14 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    CFStringRef v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    CFStringRef v16 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (*a5 <= 0) {
      CFStringRef v17 = CFStringCreateWithCharacters(0LL, a3, (int)v12);
    }
    else {
      CFStringRef v17 = 0LL;
    }
    if (a2 > 7) {
      unint64_t v18 = "<unknown URelativeDateTimeUnit>";
    }
    else {
      unint64_t v18 = off_1899EB290[a2];
    }
    ___CFICULogWithArguments( 1,  @"ureldatefmt_formatNumeric(%@, %lf, %s, %@, %d, &%@); // %d, %@, %@",
      v13,
      *(void *)&a6,
      v18,
      v14,
      a4,
      v15,
      v12,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }

  return v12;
}

void __cficu_ureldatefmt_close(const void *a1)
{
  if (___CFICULoggingEnabled_oncep != -1) {
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  }
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    CFStringRef v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    ureldatefmt_close();
    ___CFICULogWithArguments(1, @"ureldatefmt_close(%@);", v2);
    CFRelease(v2);
  }

  else
  {
    ureldatefmt_close();
  }

void ___CFICUEmitPostamble()
{
  ___CFICULogWithArguments(1, @"return 0;");
  ___CFICULogWithArguments(0, @"}");
}

uint64_t ___CFICUCreateVariableNameForHeapPointer(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 0LL;
  CFStringRef v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  uint64_t v8 = 0LL;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = _____CFICUCreateVariableNameForHeapPointer_block_invoke;
  v4[3] = &unk_1899EADE0;
  v4[4] = &v5;
  v4[5] = a1;
  v4[6] = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateVariableNameForHeapPointer_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_180B59D00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

CFStringRef ___CFICUCreateVariableNameLocked(char *cStr)
{
  valuePtr[1] = *MEMORY[0x1895F89C0];
  if (!generationByPrefix) {
    generationByPrefix = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  CFStringRef v2 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
  valuePtr[0] = 0LL;
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)generationByPrefix, v2);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberCFIndexType, valuePtr);
    uint64_t v4 = valuePtr[0];
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  CFStringRef v5 = CFStringCreateWithFormat(0LL, 0LL, @"%@%ld", v2, v4);
  uint64_t v8 = valuePtr[0] + 1LL;
  CFNumberRef v6 = CFNumberCreate(0LL, kCFNumberCFIndexType, &v8);
  CFDictionarySetValue((CFMutableDictionaryRef)generationByPrefix, v2, v6);
  CFRelease(v6);
  CFRelease(v2);
  return v5;
}

CFStringRef ___CFICUCreateVariableNameForStackPointerLocked(char *a1, const void *a2)
{
  CFStringRef v4 = ___CFICUCreateVariableNameLocked(a1);
  if (!lastStackPointerVariableNamesByPrefix) {
    lastStackPointerVariableNamesByPrefix = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  CFStringRef v5 = CFStringCreateWithCString(0LL, a1, 0x8000100u);
  CFDictionarySetValue((CFMutableDictionaryRef)stackPointersByPrefix, v5, a2);
  CFDictionarySetValue((CFMutableDictionaryRef)lastStackPointerVariableNamesByPrefix, v5, v4);
  CFRelease(v5);
  return v4;
}

CFStringRef ___CFICUCopyVariableNameForHeapPointer(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000LL;
  uint64_t v9 = 0LL;
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  int v5[2] = _____CFICUCopyVariableNameForHeapPointer_block_invoke;
  v5[3] = &unk_1899EAE28;
  v5[4] = &v6;
  v5[5] = a2;
  v5[6] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCopyVariableNameForHeapPointer_block_invoke((uint64_t)v5);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  CFStringRef v3 = (CFStringRef)v7[3];
  if (!v3)
  {
    CFStringRef v3 = CFStringCreateWithFormat(0LL, 0LL, @"<unknown variable for %s>", a1);
    v7[3] = (uint64_t)v3;
  }

  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_180B5A108(_Unwind_Exception *a1)
{
}

void ___CFICURemoveVariableNameForHeapPointer(const void *a1)
{
}

void OUTLINED_FUNCTION_0_16( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void sub_180B5B164(_Unwind_Exception *exception_object)
{
}

void sub_180B5B318(_Unwind_Exception *exception_object)
{
}

void sub_180B5B4BC(_Unwind_Exception *exception_object)
{
}

void sub_180B5B660(_Unwind_Exception *exception_object)
{
}

void sub_180B5C2BC(_Unwind_Exception *a1)
{
  *(void *)(v3 - 272) = v2;
  *(void *)(v3 - 264) = v1;
  free(*(void **)(v3 - 272));
  free(*(void **)(v3 - 264));
  _Unwind_Resume(a1);
}

void sub_180B5E3E8(_Unwind_Exception *a1)
{
}

void sub_180B5E944(_Unwind_Exception *a1)
{
}

void sub_180B5ECF0(_Unwind_Exception *a1)
{
}

void sub_180B5F198(_Unwind_Exception *a1)
{
}

uint64_t __createDictionary(void *a1, uint64_t a2, uint64_t a3)
{
  v5[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3;
  v5[0] = a2;
  return [a1 initWithObjects:v5 forKeys:&v4 count:1];
}

void sub_180B5F5D4(_Unwind_Exception *a1)
{
}

NSUInteger OUTLINED_FUNCTION_0_17(objc_class *a1)
{
  return __CFRequireConcreteImplementation(a1, v1);
}

  ;
}

  ;
}

SInt32 CFBundleOpenBundleResourceFiles( CFBundleRef bundle, CFBundleRefNum *refNum, CFBundleRefNum *localizedRefNum)
{
  return -1;
}

CFBundleRefNum CFBundleOpenBundleResourceMap(CFBundleRef bundle)
{
  return -1;
}

uint64_t _CFBundleCopyInfoDictionaryInResourceFork()
{
  return 0LL;
}

uint64_t _CFBundleOpenBundleResourceFork()
{
  return 0xFFFFFFFFLL;
}

uint64_t __NSCollectionsShouldCopy()
{
  return 0LL;
}

uint64_t __NSFastEnumerationShouldThrowExceptionOnMutation()
{
  return 1LL;
}

id __NSFastEnumerationMutationHandler(uint64_t a1)
{
  uint64_t v2 = (objc_class *)objc_opt_class();
  Name = class_getName(v2);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** Collection <%s: %p> was mutated while being enumerated.",  Name,  a1);
  uint64_t v4 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  _CFAutoreleasePoolAddObject(),  0LL);
  objc_exception_throw(v4);
  return +[__NSFastEnumerationEnumerator allocWithZone:](v5, v6, v7);
}

objc_uncaught_exception_handler __exceptionInit()
{
  return objc_setUncaughtExceptionHandler((objc_uncaught_exception_handler)__handleUncaughtException);
}

id *__exceptionPreprocess(id *a1)
{
  if (objectIsKindOfClass(a1, (objc_class *)&OBJC_CLASS___NSException))
  {
    id v2 = a1[4];
    if (v2)
    {
      if ([a1[4] objectForKey:@"callStackReturnAddresses"]
        || [v2 objectForKey:@"callStackSymbols"])
      {
        return a1;
      }
    }

    else
    {
      __CFLookUpClass("NSMutableDictionary");
      id v2 = (id)objc_opt_new();
      a1[4] = v2;
    }

    if ((objc_msgSend( (id)objc_msgSend((id)objc_msgSend(a1, "userInfo"), "objectForKey:", @"NSExceptionOmitCallstacks"),  "BOOLValue") & 1) == 0)
    {
      Class v3 = __CFLookUpClass("NSThread");
      uint64_t v4 = -[objc_class callStackReturnAddresses](v3, "callStackReturnAddresses");
      uint64_t v5 = -[objc_class callStackSymbols](v3, "callStackSymbols");
      if (v4) {
        [v2 setObject:v4 forKey:@"callStackReturnAddresses"];
      }
      if (v5) {
        [v2 setObject:v5 forKey:@"callStackSymbols"];
      }
    }
  }

  return a1;
}

uint64_t __exceptionMatch(objc_class *a1, void *a2)
{
  return objectIsKindOfClass(a2, a1);
}

void __handleUncaughtException(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (objectIsKindOfClass((void *)a1, (objc_class *)&OBJC_CLASS___NSException))
  {
    uint64_t v2 = [(id)a1 name];
    uint64_t v3 = [(id)a1 reason];
    uint64_t v4 = (void *)[*(id *)(a1 + 32) objectForKey:@"callStackReturnAddresses"];
    os_unfair_lock_lock((os_unfair_lock_t)&__last_exception_backtrace_lock__);
    if (v4)
    {
      uint64_t v5 = [v4 count];
      __strlcpy_chk();
      if (v5)
      {
        for (uint64_t i = 0LL; i != v5; ++i)
        {
          snprintf( __str,  0x44uLL,  "%p ",  (const void *)objc_msgSend((id)objc_msgSend(v4, "objectAtIndex:", i), "unsignedIntegerValue"));
          __strlcat_chk();
        }
      }

      uint64_t v7 = strrchr(__last_exception_backtrace__, 32);
      if (v7) {
        *(_WORD *)uint64_t v7 = 41;
      }
      else {
        __strlcat_chk();
      }
    }

    else
    {
      __strlcpy_chk();
    }

    __last_exception_class_name__ = (uint64_t)object_getClassName((id)a1);
    uint64_t v8 = *(const __CFString **)(a1 + 8);
    if (_NSIsNSCFConstantString((uint64_t)v8))
    {
      CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
      CStringPtr = CFStringGetCStringPtr(v8, SystemEncoding);
    }

    else
    {
      CStringPtr = 0LL;
    }

    __last_exception_name__ = (uint64_t)CStringPtr;
    bzero(&__last_exception_os_log_pack__, 0x400uLL);
    CFStringRef v11 = (void *)[*(id *)(a1 + 32) objectForKey:@"osLogPack"];
    if (v11) {
      [v11 getBytes:&__last_exception_os_log_pack__ length:1024];
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__last_exception_backtrace_lock__);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0,  @"*** Terminating app due to uncaught exception '%@', reason: '%@'\n*** First throw call stack:\n%@\n",  v2,  v3,  [v4 description]);
  }

  else
  {
    ClassName = object_getClassName((id)a1);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** Terminating app due to uncaught exception of class '%s'",  ClassName);
  }

  qword_18C539A70 = [(id)_CFAutoreleasePoolAddObject() UTF8String];
  size_t v12 = strlen((const char *)qword_18C539A70);
  _CFLogSimpleCString(3, (const char *)qword_18C539A70, v12);
  if (__uncaughtExceptionHandler)
  {
  }

id (__cdecl *_CFDoExceptionOperation(uint64_t a1, id (__cdecl *exception)(id)))(id)
{
  if (a1 <= 139)
  {
    if (a1 == 100) {
      return (id (__cdecl *)(id))__uncaughtExceptionHandler;
    }
    if (a1 == 101)
    {
      CFTimeInterval result = 0LL;
      __uncaughtExceptionHandler = (uint64_t (*)(void))exception;
      return result;
    }
  }

  else
  {
    CFTimeInterval result = (id (__cdecl *)(id))__exceptionPreprocess;
    switch(a1)
    {
      case 160LL:
        return result;
      case 161LL:
        if (exception) {
          CFTimeInterval result = exception;
        }
        objc_setExceptionPreprocessor(result);
        break;
      case 140LL:
        objc_exception_throw(exception);
        return (id (__cdecl *)(id))objectIsKindOfClass(v4, v5);
    }
  }

  return 0LL;
}

uint64_t objectIsKindOfClass(void *a1, objc_class *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    Class = object_getClass(a1);
    if (class_respondsToSelector(Class, sel_isKindOfClass_))
    {
      LOBYTE(a1) = objc_opt_isKindOfClass();
    }

    else
    {
      Superclass = object_getClass(v3);
      for (LOBYTE(a1) = Superclass != 0LL; Superclass != a2 && Superclass; LOBYTE(a1) = Superclass != 0LL)
        Superclass = class_getSuperclass(Superclass);
    }
  }

  return a1 & 1;
}

const char *__cdecl NSGetSizeAndAlignment(const char *typePtr, NSUInteger *sizep, NSUInteger *alignp)
{
  return __NSGetSizeAndAlignment(typePtr, (uint64_t *)sizep, alignp, (uint64_t)typePtr, 1LL, 0LL, 1uLL);
}

_BYTE *__NSGetSizeAndAlignment( _BYTE *result, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  uint64_t v9 = result;
  v74[1] = *MEMORY[0x1895F89C0];
  if (a3) {
    *a3 = 0LL;
  }
  if (a2) {
    *a2 = 0LL;
  }
  while (2)
  {
    uint64_t v10 = result;
    unsigned int v12 = (char)*result++;
    uint64_t v11 = v12;
    switch(v12)
    {
      case '""':
        CFTimeInterval result = v10 + 2;
LABEL_7:
        if (*(result - 1) == 34) {
          continue;
        }
        if (*(result - 1))
        {
          ++result;
          goto LABEL_7;
        }

        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): unterminated ivar name spec at '%s' in '%s'",  v9,  a4);
        goto LABEL_174;
      case '#':
      case '*':
      case ':':
      case 'D':
      case 'Q':
      case 'd':
      case 'q':
        goto LABEL_41;
      case '$':
      case '%':
      case '&':
      case '\'':
      case ')':
      case ',':
      case '-':
      case '.':
      case '/':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case 'A':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'J':
      case 'K':
      case 'M':
      case 'P':
      case 'U':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '\\':
      case ']':
      case '_':
      case 'a':
      case 'b':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'm':
      case 'p':
      case 'u':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
        goto LABEL_175;
      case '(':
        int v22 = 0;
        CFStringRef v20 = "union";
        int v21 = 41;
        goto LABEL_66;
      case '+':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'N':
      case 'O':
      case 'R':
      case 'V':
      case 'n':
      case 'o':
      case 'r':
        continue;
      case '@':
        if (a3) {
          *a3 = 8LL;
        }
        if (a2) {
          *a2 = 8LL;
        }
        int v23 = *result;
        if (v23 == 34)
        {
          int v48 = v10[2];
          if (v10[2])
          {
            CFTimeInterval result = v10 + 3;
            while (v48 != 34)
            {
              int v49 = *result++;
              int v48 = v49;
              if (!v49) {
                goto LABEL_143;
              }
            }

            goto LABEL_46;
          }

LABEL_143:
          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): malformed extended class info spec at '%s' in '%s'",  v9,  a4);
        }

        else
        {
          if (v23 != 63) {
            goto LABEL_46;
          }
          CFTimeInterval result = v10 + 2;
          if (v10[2] != 60) {
            goto LABEL_46;
          }
          int v24 = v10[3];
          if (v10[3])
          {
            uint64_t v25 = 0LL;
            CFTimeInterval result = v10 + 4;
            do
            {
              if (v24 == 62)
              {
                if (!v25) {
                  goto LABEL_46;
                }
                uint64_t v26 = -1LL;
              }

              else
              {
                uint64_t v26 = v24 == 60;
              }

              v25 += v26;
              int v27 = *result++;
              int v24 = v27;
            }

            while (v27);
          }

          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): malformed extended block spec at '%s' in '%s'",  v9,  a4);
        }

        goto LABEL_174;
      case 'B':
      case 'C':
      case 'c':
        if (a3) {
          *a3 = 1LL;
        }
        if (!a2) {
          goto LABEL_46;
        }
        uint64_t v13 = 1LL;
        goto LABEL_45;
      case 'I':
      case 'L':
      case 'f':
      case 'i':
      case 'l':
        if (a3) {
          *a3 = 4LL;
        }
        if (!a2) {
          goto LABEL_46;
        }
        uint64_t v13 = 4LL;
        goto LABEL_45;
      case 'S':
      case 's':
        if (a3) {
          *a3 = 2LL;
        }
        if (!a2) {
          goto LABEL_46;
        }
        uint64_t v13 = 2LL;
        goto LABEL_45;
      case 'T':
      case 't':
        if (a3) {
          *a3 = 16LL;
        }
        if (!a2) {
          goto LABEL_46;
        }
        uint64_t v13 = 16LL;
        goto LABEL_45;
      case '[':
        if (a6 >= 0x200) {
          goto LABEL_178;
        }
        int v14 = *result;
        if (!*result) {
          goto LABEL_36;
        }
        uint64_t v15 = 0LL;
        uint64_t v16 = 0LL;
        int v17 = *result;
        while (1)
        {
          if (v17 == 93)
          {
            if (!v16)
            {
              if ((v14 - 48) > 9)
              {
                if (v15)
                {
                  unint64_t v38 = 0LL;
                  goto LABEL_126;
                }

                goto LABEL_36;
              }

              unint64_t v38 = 0LL;
              uint64_t v39 = v15;
              while (v38 < 0x19999999)
              {
                unint64_t v38 = (v14 - 48) + 10 * v38;
                int v40 = *++result;
                int v14 = v40;
                --v39;
                if ((v40 - 48) >= 0xA)
                {
                  if (v39)
                  {
                    if (v38 && !is_mul_ok(v38, a7))
                    {
                      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"NSGetSizeAndAlignment(): cumulative nesting of arrays has reached ridiculous proportions at '%s' in '%s'",  v9,  a4);
                      goto LABEL_174;
                    }

void sub_180B61F94(_Unwind_Exception *a1)
{
}

char *typeStringRetain(int a1, char *__s)
{
  uint64_t v2 = __s;
  size_t v3 = strlen(__s) + 1;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    uint64_t v4 = malloc(v3);
    memcpy(v4, v2, v3);
    return (char *)v4;
  }

  return v2;
}

void typeStringRelease(int a1, char *__s)
{
  if ((_dyld_is_memory_immutable() & 1) == 0) {
    free(__s);
  }
}

CFStringRef copyTypeStringDesc(char *cStr)
{
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr, 0x600u);
}

BOOL typeStringEqual(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t typeStringHash(char *a1)
{
  size_t v2 = strlen(a1);
  return CFStringHashCString((unsigned __int8 *)a1, v2);
}

void __NSMethodFrameArgInfoDestroy(void *a1)
{
  if (a1)
  {
    __NSMethodFrameArgInfoDestroy(*a1);
    __NSMethodFrameArgInfoDestroy(a1[1]);
    free(a1);
  }

uint64_t _getFrameDescriptor(uint64_t a1)
{
  if ((a1 & 0x8000000000000000LL) == 0) {
    goto LABEL_12;
  }
  uint64_t v1 = 0LL;
  uint64_t v2 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    uint64_t v2 = 0LL;
  }
  unint64_t v3 = v2 ^ a1;
  uint64_t v4 = v3 & 7;
  do
  {
    ++v1;
  }

  while (v1 != 7);
  if ((~(_BYTE)v1 & 7) == 0 && ((v1 | v3) & 0x7F80000000000000LL) == 0x600000000000000LL)
  {
    BOOL v5 = v4 == 7;
    uint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5) {
      uint64_t v6 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v7 = __CFGetSignatureROMEntryAtIndex(v6 & (v3 >> 3));
  }

  else
  {
LABEL_12:
    uint64_t v7 = (_UNKNOWN **)(a1 + 8);
  }

  return (uint64_t)*v7;
}

uint64_t _getFlags(uint64_t a1)
{
  if ((a1 & 0x8000000000000000LL) == 0) {
    goto LABEL_12;
  }
  uint64_t v1 = 0LL;
  uint64_t v2 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    uint64_t v2 = 0LL;
  }
  unint64_t v3 = v2 ^ a1;
  uint64_t v4 = v3 & 7;
  do
  {
    ++v1;
  }

  while (v1 != 7);
  if ((~(_BYTE)v1 & 7) == 0 && ((v1 | v3) & 0x7F80000000000000LL) == 0x600000000000000LL)
  {
    BOOL v5 = v4 == 7;
    uint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5) {
      uint64_t v6 = 0xFFFFFFFFFFFFFLL;
    }
    uint64_t v7 = __CFGetSignatureROMEntryAtIndex(v6 & (v3 >> 3)) + 2;
  }

  else
  {
LABEL_12:
    uint64_t v7 = (_UNKNOWN **)(a1 + 24);
  }

  return (uint64_t)*v7;
}

void *__NSMS5(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = __NSMS5(*result);
    uint64_t v3 = __NSMS5(v1[1]) + v2;
    uint64_t v1 = (void *)((char *)v1 + 37);
    size_t v4 = strlen((const char *)v1);
    return (void *)(v3 + CFStringHashCString((unsigned __int8 *)v1, v4));
  }

  return result;
}

uint64_t __NSMS6(uint64_t a1, uint64_t a2)
{
  BOOL v2 = a1 != 0;
  BOOL v3 = a2 != 0;
  if (!(a1 | a2)) {
    return 1LL;
  }
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  while (1)
  {
    uint64_t result = 0LL;
    if (!v2 || !v3) {
      break;
    }
    if (*(_BYTE *)(v5 + 36) != 64 || *(_BYTE *)(v4 + 36) != 64)
    {
      uint64_t result = __NSMS6(*(void *)v5, *(void *)v4);
      if ((_DWORD)result)
      {
        uint64_t result = __NSMS6(*(void *)(v5 + 8), *(void *)(v4 + 8));
        if ((_DWORD)result) {
          return strcmp((const char *)(v5 + 37), (const char *)(v4 + 37)) == 0;
        }
      }

      return result;
    }

    int v7 = *(unsigned __int16 *)(v5 + 34);
    int v8 = *(unsigned __int16 *)(v4 + 34);
    if (((v8 ^ v7) & 0x8000) != 0) {
      return 0LL;
    }
    uint64_t v9 = *(void *)v5;
    if (*(void *)v5)
    {
      uint64_t v10 = *(void *)v4;
      if (*(void *)v4)
      {
        if ((v8 & v7 & 0x8000) != 0)
        {
          if ((__NSMS6(v9, v10) & 1) == 0) {
            return 0LL;
          }
        }

        else if (strcmp((const char *)(v9 + 37), (const char *)(v10 + 37)))
        {
          return 0LL;
        }
      }
    }

    uint64_t v5 = *(void *)(v5 + 8);
    uint64_t v4 = *(void *)(v4 + 8);
    BOOL v2 = v5 != 0;
    BOOL v3 = v4 != 0;
    if (!(v5 | v4)) {
      return 1LL;
    }
  }

  return result;
}

void __NSMS7(__CFString *a1, uint64_t *a2, uint64_t a3)
{
  if (!a3)
  {
    if (*((_BYTE *)a2 + 36))
    {
      CFStringAppendFormat(a1, 0LL, @"type encoding (%c) '%s'\n", *((unsigned __int8 *)a2 + 36), (char *)a2 + 37);
      goto LABEL_11;
    }

void *_NSMessageBuilder(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = __CFLookUpClass("__NSMessageBuilder");
  uint64_t result = class_createInstance(v4, 0LL);
  result[1] = a1;
  result[2] = a2;
  return result;
}

void __NSICreateBackingForArgumentIfNeeded(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if ((*(_WORD *)(a2 + 34) & 0x80) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (!v8)
    {
      CFMutableDictionaryRef Mutable = CFDataCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  [*(id *)(a1 + 24) numberOfArguments] + 1);
      if (!Mutable) {
        __NSICreateBackingForArgumentIfNeeded_cold_1();
      }
      uint64_t v10 = Mutable;
      *(void *)(a1 + 40) = CFDataGetMutableBytePtr(Mutable);
      uint64_t v11 = *(void **)(a1 + 32);
      if (!v11)
      {
        uint64_t v11 = (void *)objc_opt_new();
        *(void *)(a1 + 32) = v11;
        if (!v11) {
          __NSICreateBackingForArgumentIfNeeded_cold_2();
        }
      }

      [v11 addObject:v10];
      CFRelease(v10);
      uint64_t v8 = *(void *)(a1 + 40);
    }

    uint64_t v12 = a3 + 1;
    if (!*(_BYTE *)(v8 + a3 + 1))
    {
      uint64_t v13 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
      int v14 = v13;
      if (a4)
      {
        uint64_t v15 = *(const UInt8 **)(*(void *)(a1 + 8) + *(_DWORD *)(a2 + 28) + *(unsigned __int8 *)(a2 + 32));
        if (v15)
        {
          CFDataAppendBytes(v13, v15, *(unsigned int *)(*(void *)a2 + 16LL));
LABEL_14:
          int v17 = *(void **)(a1 + 32);
          if (!v17)
          {
            int v17 = (void *)objc_opt_new();
            *(void *)(a1 + 32) = v17;
          }

          [v17 addObject:v14];
          *(void *)(*(void *)(a1 + 8) + *(unsigned int *)(a2 + 28)) = CFDataGetMutableBytePtr(v14);
          *(_BYTE *)(v8 + v12) = 1;
          return;
        }

        CFIndex v16 = *(unsigned int *)(*(void *)a2 + 16LL);
      }

      else
      {
        CFIndex v16 = *(unsigned int *)(*(void *)a2 + 16LL);
      }

      CFDataSetLength(v13, v16);
      goto LABEL_14;
    }
  }

const UInt8 *__NSI3(const UInt8 *result, uint64_t a2, id *a3, char a4)
{
  if (result)
  {
    uint64_t v7 = result;
    while (1)
    {
      unsigned int v8 = (a4 & 1) != 0 ? *((_DWORD *)v7 + 7) + v7[32] : *((_DWORD *)v7 + 5);
      uint64_t v9 = v8;
      int v10 = *((unsigned __int16 *)v7 + 17);
      if ((v10 & 0x80) == 0) {
        break;
      }
      a4 = 0;
      uint64_t v7 = *(const UInt8 **)v7;
      a2 = *(void *)(a2 + v9);
      if (!v7) {
        return result;
      }
    }

    if ((~v10 & 0x1800) != 0)
    {
      if ((v10 & 0xC00) != 0)
      {
        for (uint64_t i = *(const UInt8 **)v7; i; uint64_t i = (const UInt8 *)*((void *)i + 1))
          uint64_t result = (const UInt8 *)__NSI3(i, a2, a3, a4 & 1);
      }

      else if ((v10 & 0x2000) != 0)
      {
        CFStringRef v20 = *(const UInt8 **)(a2 + v9);
        if ((v10 & 0x8000) != 0)
        {
          uint64_t result = (const UInt8 *)(id)[*(id *)(a2 + v9) copy];
          CFStringRef v20 = result;
          *(void *)(a2 + v9) = result;
        }

        if (v20)
        {
          id v21 = *a3;
          if (!*a3)
          {
            id v21 = (id)objc_opt_new();
            *a3 = v21;
          }

          return (const UInt8 *)[v21 addObject:v20];
        }
      }

      else if ((v10 & 0x4000) != 0)
      {
        int v17 = *(const char **)(a2 + v9);
        if (v17)
        {
          if (!*a3) {
            *a3 = (id)objc_opt_new();
          }
          uint64_t v18 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
          size_t v19 = strlen(v17);
          CFDataAppendBytes(v18, (const UInt8 *)v17, v19 + 1);
          [*a3 addObject:v18];
          uint64_t result = CFDataGetMutableBytePtr(v18);
          *(void *)(a2 + v9) = result;
        }
      }
    }

    else
    {
      uint64_t v11 = *(const UInt8 **)(a2 + v9);
      if (v11)
      {
        int v12 = v10 & 3;
        uint64_t result = (const UInt8 *)_CFExecutableLinkedOnOrAfter(6uLL);
        if (v12 == 1 || !(_DWORD)result)
        {
          uint64_t v13 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
          CFDataAppendBytes(v13, v11, *((unsigned int *)v7 + 4));
          int v14 = *a3;
          if (!*a3)
          {
            int v14 = (void *)objc_opt_new();
            *a3 = v14;
          }

          [v14 addObject:v13];
          uint64_t result = CFDataGetMutableBytePtr(v13);
          uint64_t v11 = result;
          *(void *)(a2 + v9) = result;
        }

        uint64_t v15 = *(const UInt8 **)v7;
        if (*(void *)v7)
        {
          do
          {
            uint64_t result = (const UInt8 *)__NSI3(v15, v11, a3, 0LL);
            uint64_t v15 = (const UInt8 *)*((void *)v15 + 1);
          }

          while (v15);
        }
      }
    }
  }

  return result;
}

void __NSI2(uint64_t a1, uint64_t a2, double *a3, char a4)
{
  if (a1)
  {
    uint64_t v5 = a3;
    uint64_t v7 = a1;
    while (1)
    {
      unsigned int v8 = (a4 & 1) != 0 ? *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32) : *(_DWORD *)(v7 + 20);
      __int16 v9 = *(_WORD *)(v7 + 34);
      if ((v9 & 0x80) == 0) {
        break;
      }
      a4 = 0;
      uint64_t v7 = *(void *)v7;
      a2 = *(void *)(a2 + v8);
      if (!v7) {
        return;
      }
    }

    if ((*(_WORD *)(v7 + 34) & 0x400) != 0 || (v9 & 0x1800) == 0x800)
    {
      uint64_t v13 = *(void *)v7;
      if (v13)
      {
        do
        {
          __NSI2(v13, a2, v5, a4 & 1);
          uint64_t v13 = *(void *)(v13 + 8);
        }

        while (v13);
      }

      else
      {
        CFIndex v16 = "array";
        if ((v9 & 0x400) != 0) {
          CFIndex v16 = "struct";
        }
        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%s with unknown contents found while setting argument",  v16);
        int v17 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
        objc_exception_throw(v17);
        -[NSInvocation invoke](v18, v19);
      }
    }

    else
    {
      if ((*(_WORD *)(v7 + 34) & 0x2000) == 0)
      {
        if ((v9 & 0x1800) == 0x1800)
        {
          LOWORD(v10) = 8;
          if ((a4 & 1) == 0)
          {
LABEL_14:
            unsigned int v11 = *(_DWORD *)(v7 + 20);
            LOWORD(v12) = *(_WORD *)(v7 + 16);
LABEL_22:
            int v14 = (void *)(a2 + v11);
            int v15 = (unsigned __int16)v12;
            bzero(v14, (unsigned __int16)v12);
            __NSI0(v7, v5, (unsigned __int16)v10, (double *)v14, v15);
            return;
          }
        }

        else
        {
          int v10 = *(_DWORD *)(v7 + 16);
          uint64_t v5 = (double *)((char *)a3 + *(unsigned int *)(v7 + 20));
          if ((a4 & 1) == 0) {
            goto LABEL_14;
          }
        }

        unsigned int v11 = *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32);
        int v12 = *(_DWORD *)(v7 + 24) + *(char *)(v7 + 33);
        goto LABEL_22;
      }

      *(double *)(a2 + v_Block_object_dispose((const void *)(v1 - 56), 8) = *(double *)((char *)a3 + *(unsigned int *)(v7 + 20));
    }
  }

__n128 *___forwarding___(uint64_t a1, uint64_t a2)
{
  BOOL v3 = (__n128 *)a1;
  uint64_t v63 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(const char **)(a1 + 8);
  if ((*(void *)a1 & 0x8000000000000000LL) != 0)
  {
    uint64_t v6 = 0LL;
    int v7 = *MEMORY[0x189616658];
    if ((~v4 & 0xC000000000000007LL) == 0) {
      LOBYTE(v7) = 0;
    }
    uint64_t v8 = (v7 ^ v4) & 7;
    while (v8 != *(unsigned __int8 *)(MEMORY[0x189616648] + v6))
    {
      if (++v6 == 7) {
        goto LABEL_9;
      }
    }

    if (!v6)
    {
LABEL_43:
      uint64_t AtomTarget = getAtomTarget(v4);
      v3->n128_u64[0] = AtomTarget;
      __invoking___( (uint64_t (*)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))MEMORY[0x189616718],  (uint64_t)v3,  v3,  1024LL);
      if (v3->n128_u64[0] == AtomTarget) {
        v3->n128_u64[0] = v4;
      }
      return v3;
    }
  }

uint64_t __block_forwarding___(id *a1)
{
  BOOL v2 = *a1;
  Class = object_getClass(*a1);
  Name = class_getName(Class);
  if (!strncmp(Name, "_NSZombie_", 0xAuLL)) {
    __block_forwarding____cold_1((uint64_t)v2, v5, v6, v7, v8, v9, v10, v11);
  }
  uint64_t v12 = _Block_signature(v2);
  if (!v12) {
    __block_forwarding____cold_2((uint64_t)v2, v13, v14, v15, v16, v17, v18, v19);
  }
  id v20 = +[NSInvocation _invocationWithMethodSignature:frame:]( &OBJC_CLASS___NSBlockInvocation,  "_invocationWithMethodSignature:frame:",  +[NSMethodSignature signatureWithObjCTypes:](&OBJC_CLASS___NSMethodSignature, "signatureWithObjCTypes:", v12),  a1);
  [v20 setTarget:0];
  uint64_t result = v2[4];
  if (result) {
    return (*(uint64_t (**)(uint64_t, id))(result + 16))(result, v20);
  }
  __break(1u);
  return result;
}

char *__NSMakeSpecialForwardingCaptureBlock(const char *a1, uint64_t a2)
{
  BOOL v2 = 0LL;
  if (a1 && a2)
  {
    size_t v5 = strnlen(a1, 0x400uLL);
    if (v5 == 1024)
    {
      CFLog( 3LL,  (uint64_t)@"Error: Attempt to make special forwarding block with a signature that is too large.",  v6,  v7,  v8,  v9,  v10,  v11,  v14);
      return 0LL;
    }

    else
    {
      size_t v12 = v5 + 1;
      BOOL v2 = (char *)calloc(1uLL, v5 + 89);
      *(void *)BOOL v2 = MEMORY[0x1895F8798];
      *((_DWORD *)v2 + 3) = 0;
      *((_DWORD *)v2 + 2) = -1023410174;
      *(_OWORD *)(v2 + 40) = xmmword_180D7DFC0;
      *((void *)v2 + 2) = __forwarding_prep_b___;
      *((void *)v2 + 3) = v2 + 40;
      *((void *)v2 + 4) = a2;
      *((void *)v2 + 7) = copyBlock;
      *((void *)v2 + _Block_object_dispose((const void *)(v1 - 56), 8) = destroyBlock;
      *((void *)v2 + 9) = v2 + 88;
      *((void *)v2 + 10) = 256LL;
      strlcpy(v2 + 88, a1, v12);
      *((void *)v2 + 4) = _Block_copy(*((const void **)v2 + 4));
    }
  }

  return v2;
}

void copyBlock(uint64_t a1, uint64_t a2)
{
}

void destroyBlock(uint64_t a1)
{
}

uint64_t *parseFrameArgumentInfo(uint64_t *a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  v161[1] = *MEMORY[0x1895F89C0];
  if (a4 >= 0x401)
  {
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: exceeded maximum nesting depth %d",  1024LL);
    uint64_t v138 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
    objc_exception_throw(v138);
    goto LABEL_253;
  }

  uint64_t v4 = a1;
  size_t v5 = __NSGetSizeAndAlignment((_BYTE *)*a1, &v158, 0LL, *a1, 0LL, 0LL, 1uLL);
  uint64_t v6 = &v5[-*v4];
  uint64_t v7 = (char *)calloc(1uLL, (size_t)(v6 + 42));
  uint64_t v8 = (uint64_t *)v7;
  if (!v7)
  {
LABEL_253:
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: memory error - offset: %lu",  a2);
    unsigned int v139 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
    objc_exception_throw(v139);
    goto LABEL_263;
  }

  uint64_t v9 = v7 + 37;
  *((_DWORD *)v7 + 4) = v158;
  *((_DWORD *)v7 + 5) = a2;
  uint64_t v10 = (char *)*v4;
  v154 = v7 + 37;
  v148 = v4;
  unint64_t v11 = (unint64_t)&v9[(void)v6 + 2];
  if (a3) {
    __int16 v12 = 2048;
  }
  else {
    __int16 v12 = 6144;
  }
  __int16 v147 = v12;
  unint64_t v152 = a4 + 2;
  int v144 = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed extended block spec '%s'; exceeded maximum nesting depth %d";
  format = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed extended block spec '%s'";
  uint64_t v146 = @"+[NSMethodSignature signatureWithObjCTypes:]: malformed array spec '%s'";
  v149 = v5;
  while (2)
  {
    uint64_t v13 = v10 + 1;
    uint64_t v14 = *v10;
    unint64_t v157 = (unint64_t)(v10 + 1);
    char v15 = v14;
    switch((int)v14)
    {
      case '#':
        *((_WORD *)v8 + 17) |= 0x2000u;
        *((_BYTE *)v8 + 36) = v14;
        uint64_t v16 = v154;
        goto LABEL_74;
      case '*':
        *((_WORD *)v8 + 17) |= 0x4000u;
        *((_BYTE *)v8 + 36) = v14;
        uint64_t v16 = v154;
        goto LABEL_37;
      case '+':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        goto LABEL_75;
      case ':':
      case 'B':
      case 'v':
        *((_BYTE *)v8 + 36) = v14;
        uint64_t v16 = v154;
        goto LABEL_74;
      case '@':
        *((_WORD *)v8 + 17) |= 0x2000u;
        *((_BYTE *)v8 + 36) = v14;
        unsigned int v34 = v154;
        _BYTE *v154 = v14;
        unint64_t v35 = ++v154;
        int v36 = *v13;
        if (v36 == 34)
        {
          int v90 = (unsigned __int8 *)(v10 + 2);
          unint64_t v157 = (unint64_t)(v10 + 2);
          uint64_t v91 = v34 + 2;
          v154 = v34 + 2;
          v34[1] = 34;
          if (a4 < 0x400)
          {
            int v92 = *v90;
            if (*v90)
            {
              uint64_t v93 = 0LL;
              int v94 = *v90;
              size_t v5 = v149;
              while (v94 != 34)
              {
                int v94 = v10[v93++ + 3];
                if (!v94) {
                  goto LABEL_249;
                }
              }

              if (!v93) {
                goto LABEL_75;
              }
              unint64_t v95 = (unint64_t)&v10[v93 + 2];
              if (v92 == 60)
              {
                int v96 = 0LL;
              }

              else
              {
                CFStringRef v116 = v10 + 2;
                if ((unint64_t)(v93 + 2) >= 3)
                {
                  CFStringRef v117 = (unsigned __int8 *)(v10 + 3);
                  do
                  {
                    *v91++ = v92;
                    BOOL v118 = (unint64_t)v117 >= v95;
                    int v119 = *v117++;
                    int v92 = v119;
                  }

                  while (!v118 && v92 != 60);
                  v154 = v91;
                  CFStringRef v116 = (char *)(v117 - 1);
                }

                unsigned int v120 = (char *)calloc(1uLL, v116 - (char *)v90 + 40);
                int v96 = v120;
                if (!v120)
                {
LABEL_254:
                  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: memory error - offset: %lu",  a2,  v142,  v143);
                  goto LABEL_251;
                }

                *((_WORD *)v120 + 17) |= 0x2000u;
                strncpy(v120 + 37, v10 + 2, v116 - (char *)v90)[v116 - (char *)v90] = 0;
                *uint64_t v8 = (uint64_t)v96;
                int v90 = (unsigned __int8 *)v116;
              }

              if ((unsigned __int8 *)v95 == v90)
              {
                int v90 = (unsigned __int8 *)&v10[v93 + 2];
              }

              else
              {
                if (v10 - (char *)v90 + v93 + 2 >= 3 && *v90 == 60)
                {
                  unsigned int v121 = v154;
                  while ((unint64_t)v121 < v11)
                  {
                    unsigned int v122 = v90 + 1;
                    *unsigned int v121 = 60;
                    CFStringRef v123 = v121 + 1;
                    v156 = v123;
                    CFRange v124 = v90 + 1;
                    if ((unint64_t)(v90 + 1) < v95)
                    {
                      int v125 = *v122;
                      CFRange v124 = v90 + 1;
                      if (v125 != 62)
                      {
                        CFRange v126 = v90 + 2;
                        do
                        {
                          v156 = v123 + 1;
                          *CFStringRef v123 = v125;
                          BOOL v118 = (unint64_t)v126 >= v95;
                          int v127 = *v126++;
                          int v125 = v127;
                          if (v118) {
                            break;
                          }
                          ++v123;
                        }

                        while (v125 != 62);
                        CFRange v124 = v126 - 1;
                      }
                    }

                    CFIndex v128 = (char *)calloc(1uLL, v124 - v122 + 40);
                    __int128 v129 = v128;
                    if (!v128) {
                      goto LABEL_254;
                    }
                    *((_WORD *)v128 + 17) &= ~0x2000u;
                    strncpy(v128 + 37, (const char *)v90 + 1, v124 - v122)[v124 - v122] = 0;
                    CFRange v130 = (uint64_t *)(v96 + 8);
                    if (!v96) {
                      CFRange v130 = v8;
                    }
                    *CFRange v130 = (uint64_t)v129;
                    unsigned __int8 *v156 = *v124;
                    unsigned int v121 = v156 + 1;
                    v154 = v156 + 1;
                    int v90 = v124 + 1;
                    if (&v10[v93] - (char *)v124 + 1 >= 3)
                    {
                      int v96 = v129;
                      if (v124[1] == 60) {
                        continue;
                      }
                    }

                    goto LABEL_216;
                  }

                  goto LABEL_237;
                }

LABEL_216:
                if ((unint64_t)v90 > v95)
                {
LABEL_222:
                  uint64_t v115 = (uint64_t)&v10[v93 + 3];
LABEL_223:
                  unint64_t v157 = v115;
                  size_t v5 = v149;
                  goto LABEL_75;
                }
              }

              CFStringRef v131 = v154;
              while ((unint64_t)v131 < v11)
              {
                char v132 = *v90++;
                *v131++ = v132;
                v154 = v131;
              }

              goto LABEL_237;
            }

LABEL_228:
                      CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'",  v157);
                      CFNumberRef v133 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
                      objc_exception_throw(v133);
LABEL_263:
                      __break(1u);
                      JUMPOUT(0x180B66624LL);
                    }

LABEL_250:
            CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, format, v37, v142, v143);
            goto LABEL_251;
          }
        }

        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v144, v37, 1024LL, v143);
        goto LABEL_251;
      case 'C':
      case 'I':
      case 'L':
      case 'Q':
      case 'S':
      case 'T':
        *((_BYTE *)v8 + 36) = v14;
        uint64_t v16 = v154;
        goto LABEL_74;
      case 'D':
      case 'd':
      case 'f':
        *((_WORD *)v8 + 17) |= 0x200u;
        *((_BYTE *)v8 + 36) = v14;
        uint64_t v16 = v154;
        goto LABEL_74;
      case 'N':
        *((_WORD *)v8 + 17) |= 3u;
        uint64_t v16 = v154;
        goto LABEL_74;
      case 'O':
        *((_WORD *)v8 + 17) |= 4u;
        uint64_t v16 = v154;
        goto LABEL_74;
      case 'R':
        *((_WORD *)v8 + 17) |= 8u;
        uint64_t v16 = v154;
        goto LABEL_74;
      case 'V':
        *((_WORD *)v8 + 17) |= 0x20u;
        uint64_t v16 = v154;
        goto LABEL_74;
      case '[':
        *((_BYTE *)v8 + 36) = v14;
        _BYTE *v154 = v14;
        id v20 = v154 + 1;
        *((_WORD *)v8 + 17) |= v147;
        if (a4 >= 0x400)
        {
          CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: malformed array spec '%s'; exceeded maximum nesting depth %d",
            v10,
            1024LL);
          goto LABEL_251;
        }

        int v21 = *v13;
        if (!*v13) {
          goto LABEL_247;
        }
        uint64_t v22 = 0LL;
        uint64_t v23 = (unsigned __int8 *)(v10 + 2);
        int v24 = *v13;
        while (2)
        {
          if (v24 != 93)
          {
            uint64_t v25 = v24 == 91;
LABEL_30:
            v22 += v25;
            int v26 = *v23++;
            int v24 = v26;
            if (!v26) {
              goto LABEL_247;
            }
            continue;
          }

          break;
        }

        if (v22)
        {
          uint64_t v25 = -1LL;
          goto LABEL_30;
        }

        if ((v21 - 48) > 9)
        {
          unint64_t v157 = (unint64_t)(v10 + 1);
LABEL_256:
          uint64_t v136 = @"+[NSMethodSignature signatureWithObjCTypes:]: array too small or too large in spec '%s'";
LABEL_246:
          uint64_t v146 = v136;
LABEL_247:
          CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v146, v10, v142, v143);
LABEL_251:
          uint64_t v135 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
          goto LABEL_238;
        }

        uint64_t v44 = 0LL;
        unint64_t v45 = 0LL;
        do
        {
          if (v45 >= 0x19999999)
          {
            unint64_t v157 = (unint64_t)&v10[v44 + 1];
            uint64_t v136 = @"+[NSMethodSignature signatureWithObjCTypes:]: array too large in spec '%s'";
            goto LABEL_246;
          }

          if ((unint64_t)&v20[v44] >= v11)
          {
            unint64_t v157 = (unint64_t)&v10[v44 + 1];
            goto LABEL_237;
          }

          unint64_t v45 = (v21 - 48) + 10 * v45;
          v20[v44] = v21;
          int v21 = v10[v44++ + 2];
        }

        while ((v21 - 48) < 0xA);
        uint64_t v46 = &v10[v44 + 1];
        unint64_t v157 = (unint64_t)v46;
        v155 = &v20[v44];
        if (v45 - 65537 < 0xFFFFFFFFFFFF0000LL) {
          goto LABEL_256;
        }
        __NSGetSizeAndAlignment(v46, v161, &v160, (uint64_t)v46, 1LL, 0LL, 1uLL);
        if (!v160) {
          unint64_t v160 = 1LL;
        }
        unint64_t v47 = 0LL;
        uint64_t v48 = 0LL;
        uint64_t v49 = v155;
        while (2)
        {
          unint64_t v50 = (v160 + v47 - 1) / v160 * v160;
          v159 = v46;
          uint64_t v51 = parseFrameArgumentInfo(&v159, v50 + a2, a3, v152);
          uint64_t v58 = v51;
          if (!v51)
          {
            CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'",  v10);
            uint64_t v137 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
            objc_exception_throw(v137);
            goto LABEL_263;
          }

          uint64_t v59 = v161[0];
          if (v161[0] != *(_DWORD *)(v51 + 16))
          {
            uint64_t v142 = v51 + 37;
            uint64_t v143 = *(unsigned int *)(v51 + 16);
            CFLog( 4LL,  (uint64_t)@"*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)",  v52,  v53,  v54,  v55,  v56,  v57,  v161[0]);
            uint64_t v59 = *(unsigned int *)(v58 + 16);
          }

          if (*v8)
          {
            if (v48) {
              goto LABEL_91;
            }
          }

          else
          {
            char v60 = *(_BYTE *)(v58 + 37);
            if (v60)
            {
              int v61 = (unsigned __int8 *)(v58 + 38);
              while ((unint64_t)v49 < v11)
              {
                *v49++ = v60;
                int v62 = *v61++;
                char v60 = v62;
                if (!v62) {
                  goto LABEL_98;
                }
              }

LABEL_98:
            *uint64_t v8 = v58;
            if (v48) {
LABEL_91:
            }
              *(void *)(v48 + _Block_object_dispose((const void *)(v1 - 56), 8) = v58;
          }

          unint64_t v47 = v59 + v50;
          uint64_t v48 = v58;
          if (--v45) {
            continue;
          }
          break;
        }

        v154 = v49 + 1;
        *uint64_t v49 = 93;
        unint64_t v157 = (unint64_t)v23;
        int v65 = (v160 + v47 - 1) / v160 * v160;
LABEL_167:
        *((_DWORD *)v8 + 4) = v65;
        size_t v5 = v149;
        if (!v65)
        {
LABEL_168:
          if (*v8)
          {
            __NSMethodFrameArgInfoDestroy((void *)*v8);
            *uint64_t v8 = 0LL;
          }
        }

      if ((v40 & 1) == 0) {
        goto LABEL_103;
      }
    }
  }

  int v38 = 0LL;
LABEL_103:
  uint64_t v87 = (__CFString *)CFLocaleGetIdentifier(v9);
  os_unfair_lock_lock_with_options();
  int v88 = (const __CFArray *)getTokenizersForLocale(v87);
  if (v88 && (uint64_t v89 = v88, v90 = CFArrayGetCount(v88), v90 <= 2))
  {
    CFArraySetValueAtIndex(v89, v90, ValueAtIndex);
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
    ubrk_close();
  }

  return v38;
}

unint64_t computeReturnFrameExtent(uint64_t *a1, uint64_t *a2)
{
  BOOL v2 = a2;
  v32[1] = *MEMORY[0x1895F89C0];
  uint64_t v4 = *a1;
  uint64_t v6 = a2 + 2;
  uint64_t v5 = a2[2];
  if (!v5)
  {
    *(_OWORD *)a2 = xmmword_180D7DFA0;
    uint64_t v5 = 224LL;
    a2[2] = 224LL;
  }

  int v7 = *(unsigned __int8 *)(v4 + 36);
  uint64_t v8 = (v7 - 35);
  if (v8 <= 0x3B)
  {
    if (((1LL << (v7 - 35)) & 0x8034241A0800081LL) != 0)
    {
LABEL_8:
      unint64_t v10 = *a2;
      uint64_t v11 = *(unsigned int *)(v4 + 16);
      if ((unint64_t)(*a2 + v11) > 0x40)
      {
        *a2 = 72LL;
        v32[0] = 0LL;
        __NSGetSizeAndAlignment((_BYTE *)(v4 + 37), 0LL, v32, 0LL, 1LL, 0LL, 1uLL);
        unint64_t v13 = v32[0];
        if (v32[0] <= 1) {
          unint64_t v13 = 1LL;
        }
        unint64_t v10 = (v5 + v13 - 225) / v13 * v13 + 224;
        unsigned int v12 = *(_DWORD *)(v4 + 16);
        BOOL v2 = v6;
        LOBYTE(v11) = v12;
      }

      else
      {
        unsigned int v12 = ((v11 - 1) & 0xFFFFFFF8) + 8;
      }

      uint64_t *v2 = v10 + v12;
LABEL_14:
      *(_DWORD *)(v4 + 24) = v12;
      *(_DWORD *)(v4 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = v10;
      *(_BYTE *)(v4 + 33) = v11 - v12;
      return (*v6 + 7) & 0xFFFFFFFFFFFFFFF8LL;
    }

    if (v8 == 33)
    {
LABEL_17:
      unint64_t v10 = a2[1];
      if (v10 > 0xC0)
      {
        *a2 = 72LL;
        v32[0] = 0LL;
        __NSGetSizeAndAlignment((_BYTE *)(v4 + 37), 0LL, v32, 0LL, 1LL, 0LL, 1uLL);
        unint64_t v17 = v32[0];
        if (v32[0] <= 1) {
          unint64_t v17 = 1LL;
        }
        unint64_t v10 = (v5 + v17 - 225) / v17 * v17 + 224;
        uint64_t v11 = *(unsigned int *)(v4 + 16);
        v2[2] = v10 + v11;
        unsigned int v12 = v11;
      }

      else
      {
        a2[1] = v10 + 16;
        LODWORD(v11) = *(_DWORD *)(v4 + 16);
        unsigned int v12 = 16;
      }

      goto LABEL_14;
    }
  }

  unsigned int v9 = v7 - 99;
  if (v9 <= 0x18)
  {
    if (((1 << v9) & 0x34241) != 0) {
      goto LABEL_8;
    }
    if (((1 << v9) & 0xA) != 0) {
      goto LABEL_17;
    }
    if (v9 == 24)
    {
      v32[0] = 0LL;
      char v31 = 0;
      if (__NSMFAIsHFA_arm64(v4, &v31, v32))
      {
        uint64_t v15 = v2[1];
        if (v15 + (unint64_t)*(unsigned int *)(v4 + 16) > 0xC0)
        {
          *(_OWORD *)BOOL v2 = xmmword_180D7DFD0;
          unint64_t v24 = _NSMS3StackAlignedOffset_arm64(v4, v5 - 224);
          uint64_t v25 = *(unsigned int *)(v4 + 16);
          *(_DWORD *)(v4 + 24) = v25;
          *(_DWORD *)(v4 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = v24 + 224;
          v2[2] = v24 + 224 + v25;
          __NSMFASetOffsetsForCompositeElements_arm64(*(void *)v4, (v24 + 224));
        }

        else
        {
          unint64_t v16 = v32[0];
          *(_DWORD *)(v4 + 24) = 16 * LODWORD(v32[0]);
          *(_DWORD *)(v4 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = v15;
          v2[1] = v15 + 16 * v16;
          uint64_t v30 = 0LL;
          __NSMFASetRegisterOffsetsForHFA_arm64(*(void *)v4, v15, &v30);
        }

        *(_BYTE *)(v4 + 33) = 0;
      }

      else
      {
        uint64_t v18 = *(unsigned int *)(v4 + 16);
        if (v18 < 0x11)
        {
          uint64_t v26 = 8LL * (((v18 - 1) >> 3) + 1);
          uint64_t v27 = *v2;
          if ((unint64_t)(*v2 + v18) > 0x40)
          {
            unint64_t v29 = _NSMS3StackAlignedOffset_arm64(v4, v5 - 224);
            LODWORD(v27) = v29 + 224;
            *uint64_t v6 = v29 + 224 + v26;
            uint64_t v28 = 72LL;
          }

          else
          {
            uint64_t v28 = v27 + v26;
          }

          *(_DWORD *)(v4 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = v27;
          uint64_t *v2 = v28;
          *(_DWORD *)(v4 + 24) = v26;
          *(_BYTE *)(v4 + 33) = *(_BYTE *)(v4 + 16) - v26;
          uint64_t v22 = *(void *)v4;
          uint64_t v23 = *(unsigned int *)(v4 + 28);
        }

        else
        {
          size_t v19 = strlen((const char *)(v4 + 37));
          id v20 = calloc(1uLL, v19 + 42);
          void *v20 = v4;
          v20[2] = 8LL;
          *((_DWORD *)v20 + 6) = 8;
          *((_WORD *)v20 + 17) |= 0x1082u;
          *((_WORD *)v20 + 1_Block_object_dispose((const void *)(v1 - 56), 8) = 24158;
          size_t v21 = strlen((const char *)(v4 + 37));
          memmove((char *)v20 + 38, (const void *)(v4 + 37), v21 + 1);
          *a1 = (uint64_t)v20;
          computeReturnFrameExtent(a1, v2);
          uint64_t v22 = *(void *)v4;
          uint64_t v23 = 0LL;
        }

        __NSMFASetOffsetsForCompositeElements_arm64(v22, v23);
      }
    }
  }

  return (*v6 + 7) & 0xFFFFFFFFFFFFFFF8LL;
}

_BYTE **setAndAdvance(_BYTE **result, unint64_t a2, char a3)
{
  BOOL v3 = *result;
  if ((unint64_t)*result >= a2)
  {
    objc_exception_throw( +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  @"+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec",  0LL));
    return (_BYTE **)__NSMFAIsHFA_arm64(v4, v5, v6);
  }

  else
  {
    *uint64_t result = v3 + 1;
    *BOOL v3 = a3;
  }

  return result;
}

uint64_t __NSMFAIsHFA_arm64(uint64_t a1, _BYTE *a2, unint64_t *a3)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v5 = a1;
  while (1)
  {
    uint64_t result = 0LL;
    int v7 = *(unsigned __int8 *)(v5 + 36);
    char v8 = v7 - 68;
    if (((1LL << v8) & 0x500000001LL) != 0)
    {
      unint64_t v9 = *a3 + 1;
      *a3 = v9;
      if (v9 > 4) {
        return 0LL;
      }
      if (*a2)
      {
      }

      else
      {
        *a2 = v7;
      }
    }

    else
    {
      if (((1LL << v8) & 0x80000000800000LL) == 0) {
        return result;
      }
      if ((__NSMFAIsHFA_arm64(*(void *)v5, a2, a3) & 1) == 0) {
        return 0LL;
      }
    }

    uint64_t v5 = *(void *)(v5 + 8);
    if (!v5) {
      return 1LL;
    }
  }

  return result;
}

uint64_t __NSMFASetRegisterOffsetsForHFA_arm64(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v5 = a1;
  uint64_t v6 = 0LL;
  do
  {
    __int16 v7 = *(_WORD *)(v5 + 34);
    uint64_t v8 = *a3;
    *(_DWORD *)(v5 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = a2 + 16 * *a3;
    if ((v7 & 0xC00) != 0)
    {
      uint64_t v9 = __NSMFASetRegisterOffsetsForHFA_arm64(*(void *)v5, a2, a3);
      char v10 = 0;
    }

    else
    {
      char v10 = *(_BYTE *)(v5 + 16) - 16;
      *a3 = v8 + 1;
      uint64_t v9 = 16LL;
    }

    *(_DWORD *)(v5 + 24) = v9;
    *(_BYTE *)(v5 + 33) = v10;
    v6 += v9;
    uint64_t v5 = *(void *)(v5 + 8);
  }

  while (v5);
  return v6;
}

uint64_t copyMemStateToFrameState(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t *)result;
    do
    {
      v1[3] = v1[2];
      uint64_t result = *v1;
      if (*v1) {
        uint64_t result = copyMemStateToFrameState();
      }
      uint64_t v1 = (uint64_t *)v1[1];
    }

    while (v1);
  }

  return result;
}

unint64_t _NSMS3StackAlignedOffset_arm64(uint64_t a1, uint64_t a2)
{
  v5[1] = *MEMORY[0x1895F89C0];
  v5[0] = 0LL;
  __NSGetSizeAndAlignment((_BYTE *)(a1 + 37), 0LL, v5, 0LL, 1LL, 0LL, 1uLL);
  unint64_t v3 = v5[0];
  if (v5[0] <= 1uLL) {
    unint64_t v3 = 1LL;
  }
  return (a2 + v3 - 1) / v3 * v3;
}

uint64_t __NSMFASetOffsetsForCompositeElements_arm64(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    do
    {
      int v4 = *(_DWORD *)(v3 + 20) + a2;
      *(_DWORD *)(v3 + 24) = *(_DWORD *)(v3 + 16);
      *(_DWORD *)(v3 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = v4;
      if ((*(_BYTE *)(v3 + 35) & 0xC) != 0) {
        uint64_t result = __NSMFASetOffsetsForCompositeElements_arm64(*(void *)v3, a2);
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }

    while (v3);
  }

  return result;
}

void __magic_cookie_block_invoke()
{
  while (!magic_cookie_oValue)
    arc4random_buf(&magic_cookie_oValue, 4uLL);
}

uint64_t __NSI1(uint64_t result, uint64_t a2, char *a3, char a4)
{
  if (result)
  {
    uint64_t v5 = a3;
    uint64_t v7 = result;
    while (1)
    {
      unsigned int v8 = (a4 & 1) != 0 ? *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32) : *(_DWORD *)(v7 + 20);
      __int16 v9 = *(_WORD *)(v7 + 34);
      if ((v9 & 0x80) == 0) {
        break;
      }
      a4 = 0;
      uint64_t v7 = *(void *)v7;
      a2 = *(void *)(a2 + v8);
      if (!v7) {
        return result;
      }
    }

    if ((*(_WORD *)(v7 + 34) & 0x400) != 0 || (v9 & 0x1800) == 0x800)
    {
      uint64_t v12 = *(void *)v7;
      if (!v12)
      {
        id v20 = "array";
        if ((v9 & 0x400) != 0) {
          id v20 = "struct";
        }
        CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%s with unknown contents found while getting argument",  v20);
        size_t v21 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
        objc_exception_throw(v21);
        return __NSI0(v17, v18, v15, v19, v16);
      }

      do
      {
        uint64_t result = __NSI1(v12, a2, v5, a4 & 1);
        uint64_t v12 = *(void *)(v12 + 8);
      }

      while (v12);
    }

    else
    {
      if ((*(_WORD *)(v7 + 34) & 0x2000) == 0)
      {
        if ((a4 & 1) != 0)
        {
          unsigned int v10 = *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32);
          int v11 = *(_DWORD *)(v7 + 24) + *(char *)(v7 + 33);
        }

        else
        {
          int v11 = *(_DWORD *)(v7 + 16);
          unsigned int v10 = *(_DWORD *)(v7 + 20);
        }

        unint64_t v13 = (double *)(a2 + v10);
        if ((v9 & 0x1800) == 0x1800)
        {
          LOWORD(v14) = 8;
        }

        else
        {
          int v14 = *(_DWORD *)(v7 + 16);
          uint64_t v5 = &a3[*(unsigned int *)(v7 + 20)];
        }

        bzero(v5, (unsigned __int16)v14);
        int v15 = (unsigned __int16)v11;
        int v16 = (unsigned __int16)v14;
        uint64_t v17 = v7;
        uint64_t v18 = v13;
        size_t v19 = (double *)v5;
        return __NSI0(v17, v18, v15, v19, v16);
      }

      *(void *)&a3[*(unsigned int *)(v7 + 20)] = *(void *)(a2 + v8);
    }
  }

  return result;
}

uint64_t __NSI0(uint64_t result, double *a2, int a3, double *a4, int a5)
{
  if ((*(_WORD *)(result + 34) & 0x200) != 0)
  {
    int v7 = a5 + (a3 << 8);
    if (v7 > 2055)
    {
      if (v7 <= 4099)
      {
        if (v7 != 2056 && v7 != 2064) {
          goto LABEL_60;
        }
LABEL_26:
        double v9 = *a2;
LABEL_31:
        *a4 = v9;
        return result;
      }

      if (v7 != 4100)
      {
        if (v7 != 4104 && v7 != 4112) {
          goto LABEL_60;
        }
        goto LABEL_26;
      }

      goto LABEL_29;
    }

    if (v7 > 1039)
    {
      if (v7 != 1040)
      {
        if (v7 == 2052)
        {
LABEL_29:
          float v10 = *a2;
LABEL_42:
          *(float *)a4 = v10;
          return result;
        }

uint64_t OUTLINED_FUNCTION_0_18()
{
  return __CFRecordAllocationEvent();
}

id _CF_forwarding_prep_0@<X0>( void *a1@<X0>, const char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, __n128 a10@<Q0>, __n128 a11@<Q1>, __n128 a12@<Q2>, __n128 a13@<Q3>, __n128 a14@<Q4>, __n128 a15@<Q5>, __n128 a16@<Q6>, __n128 a17@<Q7>)
{
  __n128 v35 = a17;
  __n128 v34 = a16;
  __n128 v33 = a15;
  __n128 v32 = a14;
  __n128 v31 = a13;
  __n128 v30 = a12;
  __n128 v29 = a11;
  __n128 v28 = a10;
  uint64_t v27 = a9;
  uint64_t v26 = a8;
  uint64_t v25 = a7;
  uint64_t v24 = a6;
  uint64_t v23 = a5;
  uint64_t v22 = a4;
  uint64_t v21 = a3;
  SEL v20 = a2;
  id v19 = a1;
  uint64_t v17 = ___forwarding___((uint64_t)&v19, 0LL);
  if (v17) {
    return (id)v17->n128_u64[0];
  }
  else {
    return objc_msgSend( v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v28.n128_f64[0],  v29.n128_f64[0],  v30.n128_f64[0],  v31.n128_f64[0],  v32.n128_f64[0],  v33.n128_f64[0],  v34.n128_f64[0],  v35.n128_f64[0]);
  }
}

uint64_t __forwarding_prep_b___@<X0>( void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X3>, void *a5@<X4>, void *a6@<X5>, void *a7@<X6>, void *a8@<X7>, void *a9@<X8>, __n128 a10@<Q0>, __n128 a11@<Q1>, __n128 a12@<Q2>, __n128 a13@<Q3>, __n128 a14@<Q4>, __n128 a15@<Q5>, __n128 a16@<Q6>, __n128 a17@<Q7>)
{
  __n128 v26 = a17;
  __n128 v25 = a16;
  __n128 v24 = a15;
  __n128 v23 = a14;
  __n128 v22 = a13;
  __n128 v21 = a12;
  __n128 v20 = a11;
  __n128 v19 = a10;
  v18[8] = a9;
  v18[7] = a8;
  v18[6] = a7;
  v18[5] = a6;
  v18[4] = a5;
  v18[3] = a4;
  v18[2] = a3;
  v18[1] = a2;
  v18[0] = a1;
  return __block_forwarding___(v18);
}

uint64_t __invoking___( uint64_t (*a1)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128), uint64_t a2, __n128 *a3, uint64_t a4)
{
  uint64_t v26 = a2;
  uint64_t v4 = a4 - 224;
  int v5 = a3 + 14;
  float v6 = (unint64_t *)(((unint64_t)&v26 - a4 + 224) & 0xFFFFFFFFFFFFFFF0LL);
  while (v4)
  {
    unint64_t v7 = v5->n128_u64[0];
    int v5 = (__n128 *)((char *)v5 + 8);
    v4 -= 8LL;
    *v6++ = v7;
  }

  uint64_t result = a1( a3->n128_u64[0],  a3->n128_u64[1],  a3[1].n128_u64[0],  a3[1].n128_u64[1],  a3[2].n128_u64[0],  a3[2].n128_u64[1],  a3[3].n128_u64[0],  a3[3].n128_u64[1],  a3[5],  a3[6],  a3[7],  a3[8],  a3[9],  a3[10],  a3[11],  a3[12]);
  uint64_t v9 = v26;
  *(_OWORD *)(v26 + 192) = v10;
  *(_OWORD *)(v9 + 176) = v11;
  *(_OWORD *)(v9 + 160) = v12;
  *(_OWORD *)(v9 + 144) = v13;
  *(_OWORD *)(v9 + 12_Block_object_dispose((const void *)(v1 - 56), 8) = v14;
  *(_OWORD *)(v9 + 112) = v15;
  *(_OWORD *)(v9 + 96) = v16;
  *(_OWORD *)(v9 + 80) = v17;
  *(void *)(v9 + 64) = v18;
  *(void *)(v9 + 56) = v19;
  *(void *)(v9 + 4_Block_object_dispose((const void *)(v1 - 56), 8) = v20;
  *(void *)(v9 + 40) = v21;
  *(void *)(v9 + 32) = v22;
  *(void *)(v9 + 24) = v23;
  *(void *)(v9 + 16) = v24;
  *(void *)(v9 + _Block_object_dispose((const void *)(v1 - 56), 8) = v25;
  *(void *)uint64_t v9 = result;
  return result;
}

void __CFDateIntervalDeallocate(uint64_t a1)
{
}

BOOL __CFDateIntervalEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  return 0LL;
}

uint64_t __CFDateIntervalHash(uint64_t a1)
{
  void v5[2] = *MEMORY[0x1895F89C0];
  CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  CFAbsoluteTime v3 = AbsoluteTime + *(double *)(a1 + 24);
  *(CFAbsoluteTime *)int v5 = AbsoluteTime;
  *(CFAbsoluteTime *)&v5[1] = v3;
  return CFHashBytes((uint64_t)v5, 16LL);
}

CFStringRef __CFDateIntervalCopyDescription(void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFDateInterval %p [%p]> %@ %f",  a1,  v2,  a1[2],  a1[3]);
}

uint64_t CFDateIntervalGetTypeID()
{
  return 71LL;
}

uint64_t CFDateIntervalCreate( const __CFAllocator *Default, const void *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!Default) {
    Default = CFAllocatorGetDefault();
  }
  uint64_t result = _CFRuntimeCreateInstance(Default, 0x47uLL, 16LL, 0LL, a6, a7, a8, a9);
  if (result)
  {
    uint64_t v12 = result;
    *(void *)(result + 16) = CFRetain(a2);
    *(double *)(v12 + 24) = a3;
    return v12;
  }

  else
  {
    __break(1u);
  }

  return result;
}

uint64_t CFDateIntervalCreateWithEndDate(const __CFAllocator *a1, const __CFDate *a2, CFDateRef theDate)
{
  double AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  double v6 = AbsoluteTime - CFDateGetAbsoluteTime(a2);
  return CFDateIntervalCreate(a1, a2, v6, v7, v8, v9, v10, v11, v12);
}

double CFDateIntervalGetDuration(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

CFTypeRef CFDateIntervalCopyStartDate(uint64_t a1)
{
  return CFRetain(*(CFTypeRef *)(a1 + 16));
}

CFDateRef CFDateIntervalCopyEndDate(uint64_t a1)
{
  CFAbsoluteTime v1 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)) + *(double *)(a1 + 24);
  return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
}

CFComparisonResult CFDateIntervalCompare(uint64_t a1, uint64_t a2)
{
  CFComparisonResult result = CFDateCompare(*(CFDateRef *)(a1 + 16), *(CFDateRef *)(a2 + 16), 0LL);
  if (result == kCFCompareEqualTo)
  {
    double v5 = *(double *)(a1 + 24);
    double v6 = *(double *)(a2 + 24);
    if (v5 >= v6) {
      return (unint64_t)(v5 > v6);
    }
    else {
      return -1LL;
    }
  }

  return result;
}

BOOL CFDateIntervalIntersectsDateInterval(uint64_t a1, uint64_t a2)
{
  CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
  double v5 = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, AbsoluteTime + *(double *)(a2 + 24));
  CFAbsoluteTime v6 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  uint64_t v7 = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6 + *(double *)(a1 + 24));
  double v8 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
  double v9 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  BOOL v10 = v8 < v9 || v8 > v9 + *(double *)(a1 + 24);
  if (v10
    && ((double v11 = CFDateGetAbsoluteTime(v5), v12 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)), v11 >= v12)
      ? (BOOL v13 = v11 > v12 + *(double *)(a1 + 24))
      : (BOOL v13 = 1),
        v13
     && ((double v14 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)),
          double v15 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16)),
          v14 < v15)
      || v14 > v15 + *(double *)(a2 + 24))))
  {
    double v18 = CFDateGetAbsoluteTime(v7);
    double v19 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
    BOOL v16 = v18 <= v19 + *(double *)(a2 + 24) && v18 >= v19;
  }

  else
  {
    BOOL v16 = 1LL;
  }

  CFRelease(v5);
  CFRelease(v7);
  return v16;
}

BOOL CFDateIntervalContainsDate(uint64_t a1, CFDateRef theDate)
{
  double AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  double v4 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  return AbsoluteTime <= v4 + *(double *)(a1 + 24) && AbsoluteTime >= v4;
}

CFTypeRef CFDateIntervalCreateIntersectionWithDateInterval( const __CFAllocator *a1, CFDateRef *cf1, CFDateRef *cf2)
{
  if (CFEqual(cf1, cf2)) {
    return CFRetain(cf1);
  }
  double AbsoluteTime = CFDateGetAbsoluteTime(cf1[2]);
  double v8 = AbsoluteTime + *((double *)cf1 + 3);
  double v9 = CFDateGetAbsoluteTime(cf2[2]);
  if (v9 >= AbsoluteTime) {
    BOOL v10 = cf2;
  }
  else {
    BOOL v10 = cf1;
  }
  CFDateRef v11 = v10[2];
  else {
    double v12 = v8;
  }
  double v13 = v12 - CFDateGetAbsoluteTime(v10[2]);
  return (CFTypeRef)CFDateIntervalCreate(a1, v11, v13, v14, v15, v16, v17, v18, v19);
}

void sub_180B68850( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state)
{
}

size_t _CFPrefsCreatePreferencesDirectory(const char *a1)
{
  size_t result = strlen(a1);
  if (!result) {
    return result;
  }
  CFAbsoluteTime v3 = (char *)&a1[result];
  uint64_t v4 = 0xFFFFFFFFLL;
  do
  {
    while (1)
    {
      if (*v3 != 47) {
        goto LABEL_6;
      }
      *CFAbsoluteTime v3 = 0;
      uint64_t v5 = open(a1, 1074790400);
      uint64_t v4 = v5;
      *CFAbsoluteTime v3 = 47;
      if ((_DWORD)v5 != -1) {
        break;
      }
      --v3;
      if (*__error() != 2 || v3 == a1) {
        return 0LL;
      }
    }

    if ((v5 & 0x80000000) == 0)
    {
      uint64_t v7 = (uint64_t)(v3 + 1);
      goto LABEL_18;
    }

uint64_t _safe_recursive_mkdir_chown(uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v2 = (const char *)MEMORY[0x1895F8858](a1, a2);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v9 = v8;
  uint64_t v11 = v10;
  int v12 = v3;
  double v13 = v2;
  uint64_t v28 = *MEMORY[0x1895F89C0];
  for (unint64_t i = (char *)v2; ; ++i)
  {
    int v15 = *i;
    if (!*i || v15 == 47) {
      break;
    }
  }

  *unint64_t i = 0;
  uint64_t v16 = openat(v3, v2, 0x100000);
  uint64_t v17 = v16;
  if ((v16 & 0x80000000) != 0)
  {
    if ((_DWORD)v16 == -1)
    {
      if (*__error() != 2) {
        return 0xFFFFFFFFLL;
      }
      goto LABEL_26;
    }
  }

  else if (fstatfs(v16, &v27) != -1 && (v27.f_flags & 1) != 0 && fstatfs(v12, &v26) != -1 && (v26.f_flags & 0x20) != 0)
  {
    close(v17);
LABEL_26:
    if (mkdirat(v12, v13, v11) != -1)
    {
      uint64_t v23 = openat(v12, v13, 1048832);
      if ((_DWORD)v23 != -1)
      {
        uint64_t v17 = v23;
        if (fchown(v23, v9, v7) != -1
          || (int v24 = *__error(), !fstat(v17, (stat *)&v27)) && v27.f_bfree == __PAIR64__(v7, v9))
        {
          char v18 = 1;
          goto LABEL_13;
        }

        close(v17);
        unlinkat(v12, v13, 128);
        *__error() = v24;
      }
    }

    return 0xFFFFFFFFLL;
  }

  char v18 = 0;
LABEL_13:
  *unint64_t i = v15;
  while (v15 == 47)
  {
    char v19 = *++i;
    LOBYTE(v15) = v19;
  }

  if ((_BYTE)v15)
  {
    uint64_t v20 = _safe_recursive_mkdir_chown(i, v17, v11, v9, v7, v5);
    int v21 = *__error();
    close(v17);
    char v22 = v18 ^ 1;
    if ((_DWORD)v20 != -1) {
      char v22 = 1;
    }
    if ((v22 & 1) == 0) {
      unlinkat(v12, v13, 128);
    }
    *__error() = v21;
  }

  else if (v5)
  {
    uint64_t v20 = 0LL;
    *uint64_t v5 = v17;
  }

  else
  {
    close(v17);
    return 0LL;
  }

  return v20;
}

CFURLRef _CFPrefsCopyDirectoryURLForTriplet_testing( uint64_t a1, const __CFString *a2, int a3, const void *a4)
{
  return _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, a4);
}

CFURLRef _CFPrefsCreatePreferencesDirectoryURLForTriplet(const __CFString *a1, int a2, const void *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!CFEqual(a1, @"kCFPreferencesAnyUser"))
  {
    if (a3)
    {
      uint64_t v7 = (const __CFURL *)CFRetain(a3);
    }

    else
    {
      if (CFEqual(a1, @"kCFPreferencesCurrentUser"))
      {
        uid_t v8 = geteuid();
        uint64_t v9 = getpwuid(v8);
      }

      else
      {
        CFIndex Length = CFStringGetLength(a1);
        unint64_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        CFIndex v12 = MaximumSizeForEncoding;
        if (MaximumSizeForEncoding >= 0x7F) {
          double v13 = (char *)malloc(MaximumSizeForEncoding + 1);
        }
        else {
          double v13 = buffer;
        }
        if (CFStringGetCString(a1, v13, v12, 0x8000100u)) {
          uint64_t v9 = getpwnam(v13);
        }
        else {
          uint64_t v9 = 0LL;
        }
        if (buffer != v13) {
          free(v13);
        }
      }

      if (v9 && (pw_dir = v9->pw_dir) != 0LL)
      {
        size_t v15 = strlen(pw_dir);
        uint64_t v7 = CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)pw_dir,  v15,  1u);
      }

      else
      {
        uint64_t v7 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  @"/var/empty",  kCFURLPOSIXPathStyle,  1u);
      }
    }

    uint64_t v16 = v7;
    if (v7)
    {
      if (a2) {
        uint64_t v17 = @"Library/Preferences/ByHost/";
      }
      else {
        uint64_t v17 = @"Library/Preferences/";
      }
      CFURLRef v18 = CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v17,  kCFURLPOSIXPathStyle,  1u,  v7);
      CFRelease(v16);
      return v18;
    }

    return 0LL;
  }

  if (a3) {
    return CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  @"Library/Preferences/",  kCFURLPOSIXPathStyle,  1u,  (CFURLRef)a3);
  }
  else {
    return CFURLCreateWithFileSystemPath( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  @"/private/var/preferences",  kCFURLPOSIXPathStyle,  1u);
  }
}

__CFArray *_CFPreferencesCopyApplicationList(const __CFString *a1, int a2)
{
  char v2 = a2;
  PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a1, a2, 0LL);
  if (!PreferencesDirectoryURLForTriplet) {
    return 0LL;
  }
  uint64_t v4 = PreferencesDirectoryURLForTriplet;
  CFURLRef v5 = CFURLCopyAbsoluteURL(PreferencesDirectoryURLForTriplet);
  CFRelease(v4);
  if ((v2 & 1) != 0)
  {
    uint64_t v6 = _CFXPreferencesGetByHostIdentifierString();
    uint64_t v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @".%@.plist", v6);
  }

  else
  {
    uint64_t v7 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, ".plist", 0x600u);
  }

  uint64_t v9 = v7;
  CFIndex Length = CFStringGetLength(v7);
  uint64_t v11 = _CFCreateContentsOfDirectory((uint64_t)&__kCFAllocatorSystemDefault, 0LL);
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  CFURLRef cf = v5;
  if (v11)
  {
    CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v11);
    CFRelease(v11);
  }

  else
  {
    CFMutableStringRef MutableCopy = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  }

  CFIndex Count = CFArrayGetCount(MutableCopy);
  if (Count >= 1)
  {
    unint64_t v14 = Count + 1;
    do
    {
      ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(MutableCopy, v14 - 2);
      uint64_t v16 = CFURLCopyFileSystemPath(ValueAtIndex, kCFURLPOSIXPathStyle);
      if (CFStringHasSuffix(v16, v9))
      {
        v21.CFIndex length = CFStringGetLength(v16) - Length;
        v21.CFIndex location = 0LL;
        CFStringRef v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, v21);
        if (CFEqual(v17, @".GlobalPreferences")) {
          CFURLRef v18 = @"kCFPreferencesAnyApplication";
        }
        else {
          CFURLRef v18 = v17;
        }
        CFArrayAppendValue(Mutable, v18);
        CFRelease(v17);
      }

      CFRelease(v16);
      --v14;
    }

    while (v14 > 1);
  }

  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  CFRelease(cf);
  CFRelease(v9);
  return Mutable;
}

uint64_t _CFPreferencesCopyApplicationMap()
{
  return 0LL;
}

uint64_t _CFPreferencesCopyInUseContainerURLMatchingApplication()
{
  return 0LL;
}

CFURLRef _CFPreferencesCopyManagedPreferencesContainerURL()
{
  v15[1] = *MEMORY[0x1895F89C0];
  v15[0] = 1LL;
  double v0 = (const char *)container_system_group_path_for_identifier();
  if (v0)
  {
    CFAbsoluteTime v1 = (UInt8 *)v0;
    size_t v2 = strlen(v0);
    int v3 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, v2, 1u);
    if (v3)
    {
      uint64_t v4 = v3;
      CFURLRef v5 = CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  @"Library/Managed Preferences/",  kCFURLPOSIXPathStyle,  1u,  v3);
      CFRelease(v4);
      if (v5)
      {
LABEL_7:
        free(v1);
        return v5;
      }

      uint64_t v6 = (os_log_s *)_CFPrefsDaemonLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT)) {
        _CFPreferencesCopyManagedPreferencesContainerURL_cold_2();
      }
    }

    CFURLRef v5 = 0LL;
    goto LABEL_7;
  }

  uint64_t v7 = (os_log_s *)_CFPrefsDaemonLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT)) {
    _CFPreferencesCopyManagedPreferencesContainerURL_cold_1((uint64_t)v15, v7, v8, v9, v10, v11, v12, v13);
  }
  return 0LL;
}

BOOL _CFPrefsGetPathForManagedBundleID(__CFString *a1, const void *a2, int a3, UInt8 *a4)
{
  if (_CFPrefsGetPathForManagedBundleID_onceToken == -1)
  {
    if (!a3) {
      goto LABEL_5;
    }
  }

  else
  {
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_onceToken, &__block_literal_global_30);
    if (!a3) {
      goto LABEL_5;
    }
  }

  if (_CFPrefsGetPathForManagedBundleID_containerizedOnceToken != -1) {
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_containerizedOnceToken, &__block_literal_global_5);
  }
LABEL_5:
  if (a1 && (CacheStringForBundleID = (const __CFString *)_CFPrefsGetCacheStringForBundleID(a1)) != 0LL)
  {
    uint64_t v9 = CacheStringForBundleID;
    if (CFEqual(CacheStringForBundleID, @"kCFPreferencesAnyApplication")) {
      uint64_t v10 = @".GlobalPreferences";
    }
    else {
      uint64_t v10 = v9;
    }
    if (!a3) {
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v10 = 0LL;
    if (!a3)
    {
LABEL_11:
      uint64_t v11 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (CFStringRef)_CFPrefsGetPathForManagedBundleID_containingDirectoryPath,  kCFURLPOSIXPathStyle,  1u);
      goto LABEL_14;
    }
  }

  uint64_t v11 = (const __CFURL *)CFRetain((CFTypeRef)_CFPrefsGetPathForManagedBundleID_containerizedContainingDirectoryURL);
LABEL_14:
  uint64_t v12 = v11;
  if (!v11) {
    return 0LL;
  }
  if (CFEqual(a2, @"kCFPreferencesAnyUser"))
  {
    if (!v10)
    {
      unint64_t v14 = &stru_1899EF170;
      goto LABEL_29;
    }

    uint64_t v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@.plist", v10);
    goto LABEL_18;
  }

  if (!CFEqual(a2, @"kCFPreferencesCurrentUser"))
  {
    if (v10) {
      uint64_t v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@/%@.plist", a2, v10);
    }
    else {
      uint64_t v13 = (const __CFString *)CFRetain(a2);
    }
LABEL_18:
    unint64_t v14 = v13;
    goto LABEL_19;
  }

  if (_CFPrefsGetPathForManagedBundleID_onceToken_12 != -1) {
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_onceToken_12, &__block_literal_global_13_0);
  }
  CFStringRef v15 = (CFStringRef)_CFPrefsGetPathForManagedBundleID_ourUserName;
  if (!_CFPrefsGetPathForManagedBundleID_ourUserName)
  {
    CFStringRef v15 = CFCopyUserName();
    if (v10) {
      goto LABEL_26;
    }
LABEL_37:
    uint64_t v16 = (const __CFString *)CFRetain(v15);
    goto LABEL_38;
  }

  if (!v10) {
    goto LABEL_37;
  }
LABEL_26:
  uint64_t v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@/%@.plist", v15, v10);
LABEL_38:
  unint64_t v14 = v16;
  if (!_CFPrefsGetPathForManagedBundleID_ourUserName && v15) {
    CFRelease(v15);
  }
LABEL_19:
  if (v14)
  {
LABEL_29:
    CFURLRef v18 = CFURLCreateWithFileSystemPathRelativeToBase( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v14,  kCFURLPOSIXPathStyle,  0,  v12);
    CFRelease(v14);
    CFRelease(v12);
    if (v18)
    {
      BOOL v17 = CFURLGetFileSystemRepresentation(v18, 1u, a4, 1024LL) != 0;
      uint64_t v12 = v18;
      goto LABEL_31;
    }

    return 0LL;
  }

  BOOL v17 = 0LL;
LABEL_31:
  CFRelease(v12);
  return v17;
}

CFStringRef _CFPreferencesCopyPathForManagedDomain(__CFString *a1, const void *a2, int a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  bzero(buffer, 0x402uLL);
  if (!_CFPrefsGetPathForManagedBundleID(a1, a2, a3 != 0, (UInt8 *)buffer)) {
    return 0LL;
  }
  CFStringRef result = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
  if (!result) {
    return 0LL;
  }
  return result;
}

CFStringRef _CFPreferencesGetUserIdentifierForUID()
{
  return &stru_1899EF170;
}

BOOL _CFPrefsGetPathForTriplet( __CFString *a1, const __CFString *a2, int a3, CFStringRef filePath, UInt8 *a5)
{
  if (filePath)
  {
    CFURLRef v9 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, filePath, kCFURLPOSIXPathStyle, 1u);
    PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, v9);
    if (v9) {
      CFRelease(v9);
    }
    if (!PreferencesDirectoryURLForTriplet) {
      return 0LL;
    }
  }

  else
  {
    PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, 0LL);
    if (!PreferencesDirectoryURLForTriplet) {
      return 0LL;
    }
  }

  CacheStringForBundleID = (const __CFString *)_CFPrefsGetCacheStringForBundleID(a1);
  if (CFEqual(CacheStringForBundleID, @"kCFPreferencesAnyApplication")) {
    CacheStringForBundleID = @".GlobalPreferences";
  }
  CFIndex location = CFStringFind(CacheStringForBundleID, @".plist", 0xDuLL).location;
  if (location == -1)
  {
    CFRetain(CacheStringForBundleID);
    if (!a3) {
      goto LABEL_14;
    }
  }

  else
  {
    v19.CFIndex length = location;
    v19.CFIndex location = 0LL;
    CacheStringForBundleID = CFStringCreateWithSubstring( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  CacheStringForBundleID,  v19);
    if (!a3) {
      goto LABEL_14;
    }
  }

  if (!CFEqual(a2, @"kCFPreferencesAnyUser"))
  {
    CFURLRef v18 = _CFXPreferencesGetByHostIdentifierString();
    CFStringRef v13 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@.%@.plist",  CacheStringForBundleID,  v18);
    goto LABEL_16;
  }

uint64_t _CFPrefsTemporaryFDToWriteTo(uint64_t a1, uint64_t a2)
{
  size_t v2 = (const __CFURL *)MEMORY[0x1895F8858](a1, a2);
  uint64_t v30 = *MEMORY[0x1895F89C0];
  unsigned int v7 = atomic_load((unsigned int *)&unk_18C536DA8);
  if (v7 == 1)
  {
    uint64_t v8 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      _CFPrefsTemporaryFDToWriteTo_cold_1();
    }
    *__error() = 28;
    return 0xFFFFFFFFLL;
  }

  int v9 = v6;
  mode_t v10 = v5;
  gid_t v11 = v4;
  uid_t v12 = v3;
  CFStringRef v13 = v2;
  if (!CFURLGetFileSystemRepresentation(v2, 1u, buffer, 1026LL))
  {
    char v22 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      _CFPrefsTemporaryFDToWriteTo_cold_2();
    }
    return 0xFFFFFFFFLL;
  }

  unint64_t v14 = CFURLCopyAbsoluteURL(v13);
  CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
  BOOL v16 = (const __CFURL *)CFRetain(PathComponent);
  CFStringRef v17 = CFURLCopyLastPathComponent(v14);
  CFRelease(v14);
  CFURLRef v18 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"%@.XXXXXXX", v17);
  CFRange v19 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, v18, 0);
  CFRelease(v18);
  if (v17) {
    CFRelease(v17);
  }
  if (!CFURLGetFileSystemRepresentation(v19, 1u, v29, 1026LL))
  {
    uint64_t v23 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      _CFPrefsTemporaryFDToWriteTo_cold_3();
    }
    goto LABEL_24;
  }

  if (!v9)
  {
LABEL_14:
    uint64_t v20 = mkstemp((char *)v29);
    goto LABEL_15;
  }

  uint64_t v20 = mkstemp_dprotected_np((char *)v29, v9, 0);
  CFRange v21 = __error();
  if ((_DWORD)v20 == -1 && *v21 == 45)
  {
    goto LABEL_14;
  }

uint64_t _CFPrefsWritePlistToFDThenClose( void *a1, int a2, uid_t a3, gid_t a4, mode_t a5, int a6, int a7, const char *a8, uint64_t a9)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  if (a2 < 0)
  {
    char v22 = (os_log_s *)_CFPrefsDaemonLog();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    *(_DWORD *)buf = 67109120;
    int v58 = a2;
    _os_log_fault_impl(&dword_180A4C000, v22, OS_LOG_TYPE_FAULT, "Invalid file descriptor %d", buf, 8u);
LABEL_15:
    if (!buf[0]) {
      return 22LL;
    }
LABEL_16:
    unlinkat(-2, (const char *)buf, 2048);
    return 22LL;
  }

  if (!a1)
  {
    uint64_t v23 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT)) {
      _CFPrefsWritePlistToFDThenClose_cold_1(v23, v24, v25, v26, v27, v28, v29, v30);
    }
    close(a2);
    goto LABEL_15;
  }

  size_t v17 = [a1 length];
  CFURLRef v18 = (char *)[a1 bytes];
  if (fcntl(a2, 50, buf) < 0)
  {
    uint64_t v21 = *__error();
    __n128 v32 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT)) {
      _CFPrefsWritePlistToFDThenClose_cold_2(a2, v32);
    }
    goto LABEL_21;
  }

  unsigned int v19 = atomic_load((unsigned int *)&unk_18C536DA8);
  if (v19 == 2)
  {
    uint64_t v20 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT)) {
      _CFPrefsWritePlistToFDThenClose_cold_3();
    }
    close(a2);
    if (buf[0]) {
      unlinkat(-2, (const char *)buf, 2048);
    }
    return 28LL;
  }

  int v50 = a7;
  if (v17)
  {
    uint64_t v49 = a8;
    int v33 = write(a2, v18, v17);
    uint64_t v34 = v33;
    if (v33 != v17)
    {
      int v35 = v33;
      do
      {
        int v36 = __error();
        if (v35 == -1)
        {
          if (*v36 != 4 && *v36 != 35)
          {
            uint64_t v21 = *__error();
            uint64_t v43 = (os_log_s *)_CFPrefsDaemonLog();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT)) {
              _CFPrefsWritePlistToFDThenClose_cold_8();
            }
            goto LABEL_21;
          }
        }

        else
        {
          v18 += v34;
          v17 -= v34;
        }

        int v35 = write(a2, v18, v17);
        uint64_t v34 = v35;
      }

      while (v35 != v17);
    }

    a8 = v49;
    while (fsync(a2) < 0)
    {
      if (*__error() != 4)
      {
        uint64_t v21 = *__error();
        unint64_t v37 = (os_log_s *)_CFPrefsDaemonLog();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT)) {
          _CFPrefsWritePlistToFDThenClose_cold_7();
        }
        goto LABEL_21;
      }
    }
  }

  if (byte_18C536D9F)
  {
    sleep(1u);
    byte_18C536D9F = 0;
  }

  fchown(a2, a3, a4);
  fchmod(a2, a5);
  int v38 = v50;
  if ([a1 validatePlist])
  {
    if (a6)
    {
      LOBYTE(value) = 1;
      uint64_t v39 = fsetxattr(a2, "com.apple.MobileBackup", &value, 1uLL, 0, 0);
      if ((_DWORD)v39)
      {
        uint64_t v40 = v39;
        uint64_t v21 = *__error();
        uint64_t v41 = (os_log_s *)_CFPrefsDaemonLog();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT)) {
          _CFPrefsWritePlistToFDThenClose_cold_5((uint64_t)buf, v40, v41);
        }
LABEL_21:
        close(a2);
LABEL_22:
        if (buf[0]) {
          unlinkat(-2, (const char *)buf, 2048);
        }
        return v21;
      }

      int v38 = v50;
    }

    close(a2);
    int v45 = renameat(-2, (const char *)buf, v38, a8);
    uint64_t v21 = *__error();
    uint64_t v46 = (os_log_s *)_CFPrefsDaemonLog();
    unint64_t v47 = v46;
    if (v45)
    {
      if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
      {
        int value = 136315650;
        uint64_t v52 = buf;
        __int16 v53 = 2080;
        uint64_t v54 = a9;
        __int16 v55 = 1024;
        int v56 = v21;
        _os_log_fault_impl( &dword_180A4C000,  v47,  OS_LOG_TYPE_FAULT,  "error renaming file %s to %s (errno: %d).",  (uint8_t *)&value,  0x1Cu);
      }

      goto LABEL_22;
    }

    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v48 = (os_log_s *)_CFPrefsDaemonLog();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG)) {
        _CFPrefsWritePlistToFDThenClose_cold_4();
      }
    }

    return 0LL;
  }

  else
  {
    uint64_t v42 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT)) {
      _CFPrefsWritePlistToFDThenClose_cold_6();
    }
    close(a2);
    if (buf[0]) {
      unlinkat(-2, (const char *)buf, 2048);
    }
    return 47837LL;
  }

void OUTLINED_FUNCTION_0_19(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

void OUTLINED_FUNCTION_2_8( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

void OUTLINED_FUNCTION_4_2( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_5_2( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

  ;
}

void sub_180B6C0B8(_Unwind_Exception *a1)
{
}

void sub_180B6C514(_Unwind_Exception *a1)
{
}

void sub_180B6CB4C(_Unwind_Exception *a1)
{
}

void sub_180B6CFA8(_Unwind_Exception *a1)
{
}

void sub_180B6D400(_Unwind_Exception *a1)
{
}

void sub_180B6DACC(_Unwind_Exception *a1)
{
}

void sub_180B6E23C(_Unwind_Exception *a1)
{
}

void sub_180B7248C(_Unwind_Exception *a1)
{
}

void sub_180B72ADC(_Unwind_Exception *a1)
{
}

void sub_180B72F50(_Unwind_Exception *a1)
{
}

void sub_180B73598(_Unwind_Exception *a1)
{
}

void sub_180B73A0C(_Unwind_Exception *a1)
{
}

void sub_180B73E7C(_Unwind_Exception *a1)
{
}

void sub_180B747BC(_Unwind_Exception *exception_object)
{
}

void sub_180B74A50(_Unwind_Exception *exception_object)
{
}

void sub_180B75DE4(_Unwind_Exception *exception_object)
{
}

NSUInteger OUTLINED_FUNCTION_0_20(objc_class *a1, uint64_t a2)
{
  return __CFRequireConcreteImplementation(a1, a2);
}

  ;
}

  ;
}

void __CFZombifyNSObject()
{
  double v0 = objc_lookUpClass("NSObject");
  InstanceMethod = class_getInstanceMethod(v0, sel_dealloc);
  size_t v2 = class_getInstanceMethod(v0, sel___dealloc_zombie);
  method_exchangeImplementations(InstanceMethod, v2);
}

void __CFOAInitializeNSObject()
{
  double v0 = objc_lookUpClass("NSObject");
  InstanceMethod = class_getInstanceMethod(v0, sel_retain);
  size_t v2 = class_getInstanceMethod(v0, sel___retain_OA);
  method_exchangeImplementations(InstanceMethod, v2);
  uid_t v3 = class_getInstanceMethod(v0, sel_release);
  gid_t v4 = class_getInstanceMethod(v0, sel___release_OA);
  method_exchangeImplementations(v3, v4);
  mode_t v5 = class_getInstanceMethod(v0, sel_autorelease);
  int v6 = class_getInstanceMethod(v0, sel___autorelease_OA);
  method_exchangeImplementations(v5, v6);
  unsigned int v7 = class_getInstanceMethod(v0, sel__tryRetain);
  uint64_t v8 = class_getInstanceMethod(v0, sel____tryRetain_OA);
  method_exchangeImplementations(v7, v8);
  Class = object_getClass(v0);
  mode_t v10 = class_getInstanceMethod(Class, sel_allocWithZone_);
  gid_t v11 = class_getInstanceMethod(Class, sel___allocWithZone_OA_);
  method_exchangeImplementations(v10, v11);
}

uint64_t couldNotInstantiate(objc_class *a1)
{
  Name = class_getName(a1);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** -[NSObject allocWithZone:]: attempt to allocate object of class '%s' failed",  Name);
  size_t v2 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSMallocException",  _CFAutoreleasePoolAddObject(),  0LL);
  objc_exception_throw(v2);
  return +[NSObject(NSObject) doesNotRecognizeSelector:](v3, v4, v5);
}

uint64_t _CFAutoreleasePoolAddObject()
{
  if (__CFOASafe) {
    __CFRecordAllocationEvent();
  }
  return _objc_rootAutorelease();
}

SEL __methodDescriptionForSelector(Class cls, SEL name)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (cls)
  {
    Class Superclass = cls;
    while (1)
    {
      outCFIndex Count = 0;
      SEL v5 = class_copyProtocolList(Superclass, &outCount);
      int v6 = v5;
      if (outCount) {
        break;
      }
      if (v5) {
LABEL_10:
      }
        free(v6);
      Class Superclass = class_getSuperclass(Superclass);
      if (!Superclass) {
        goto LABEL_12;
      }
    }

    uint64_t v7 = 0LL;
    while (1)
    {
      uint64_t v8 = v6[v7];
      BOOL isMetaClass = class_isMetaClass(Superclass);
      SEL v10 = protocol_getMethodDescription(v8, name, 1, !isMetaClass).name;
      if (v10) {
        break;
      }
      gid_t v11 = v6[v7];
      BOOL v12 = class_isMetaClass(Superclass);
      SEL v10 = protocol_getMethodDescription(v11, name, 0, !v12).name;
      if (v10) {
        break;
      }
    }

    SEL v15 = v10;
    free(v6);
  }

  else
  {
LABEL_12:
    InstanceMethod = class_getInstanceMethod(cls, name);
    if (InstanceMethod)
    {
      unint64_t v14 = InstanceMethod;
      SEL v15 = method_getName(InstanceMethod);
      method_getTypeEncoding(v14);
    }

    else
    {
      return 0LL;
    }
  }

  return v15;
}

uint64_t _CFAutoreleasePoolPush()
{
  return MEMORY[0x186E03CAC]();
}

void *_CFAutoreleasePoolPop(void *context)
{
  return context;
}

uint64_t _NSIsNSArray(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }

  return a1 & 1;
}

uint64_t _NSIsNSData(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }

  return a1 & 1;
}

uint64_t _NSIsNSDate(uint64_t a1)
{
  if (a1 < 0)
  {
    uint64_t v2 = 0LL;
    int v3 = *MEMORY[0x189616658];
    if ((~a1 & 0xC000000000000007LL) == 0) {
      LOBYTE(v3) = 0;
    }
    uint64_t v4 = (v3 ^ a1) & 7;
    do
    {
      ++v2;
    }

    while (v2 != 7);
    char isKindOfClass = (v2 & 7) == 6;
  }

  else if (a1)
  {
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();
  }

  else
  {
    char isKindOfClass = 0;
  }

  return isKindOfClass & 1;
}

uint64_t _objc_getTaggedPointerTag_0(uint64_t a1)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    uint64_t v2 = 0LL;
  }
  uint64_t v3 = v2 ^ a1;
  do
  {
    if ((v3 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v1)) {
      break;
    }
    ++v1;
  }

  while (v1 != 7);
  unint64_t v4 = v1 | v3;
  uint64_t v5 = v1 & 7;
  unsigned int v6 = (v4 >> 55) + 8;
  if (v5 == 7) {
    return v6;
  }
  else {
    return v5;
  }
}

uint64_t _NSIsNSDictionary(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }

  return a1 & 1;
}

uint64_t _NSIsNSObject(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }

  return a1 & 1;
}

uint64_t _NSIsNSOrderedSet(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }

  return a1 & 1;
}

uint64_t _NSIsNSNumber(uint64_t a1)
{
  if (a1 < 0)
  {
    uint64_t v2 = 0LL;
    int v3 = *MEMORY[0x189616658];
    if ((~a1 & 0xC000000000000007LL) == 0) {
      LOBYTE(v3) = 0;
    }
    uint64_t v4 = (v3 ^ a1) & 7;
    do
    {
      ++v2;
    }

    while (v2 != 7);
    LOBYTE(Class) = (v2 & 7) == 3;
    return Class & 1;
  }

  if (_NSNumberClass)
  {
    if (a1) {
      goto LABEL_10;
    }
LABEL_14:
    LOBYTE(Class) = 0;
    return Class & 1;
  }

  Class Class = objc_getClass("NSNumber");
  _NSNumberClass Class = (uint64_t)Class;
  if (!Class) {
    return Class & 1;
  }
  if (!a1) {
    goto LABEL_14;
  }
LABEL_10:
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  LOBYTE(Class) = objc_opt_isKindOfClass();
  return Class & 1;
}

uint64_t _NSIsNSSet(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }

  return a1 & 1;
}

uint64_t _NSIsNSString(uint64_t a1)
{
  if (a1 < 0)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = *MEMORY[0x189616658];
    if ((~a1 & 0xC000000000000007LL) == 0) {
      uint64_t v3 = 0LL;
    }
    uint64_t v4 = v3 ^ a1;
    do
    {
      if ((v4 & 7) == *(_BYTE *)(MEMORY[0x189616648] + v2)) {
        break;
      }
      ++v2;
    }

    while (v2 != 7);
    unint64_t v5 = v2 | v4;
    uint64_t v6 = v2 & 7;
    int v7 = (v5 >> 55) + 8;
    if (v6 == 7) {
      LODWORD(v6) = v7;
    }
    LOBYTE(Class) = (_DWORD)v6 == 2 || (_DWORD)v6 == 22;
    return Class & 1;
  }

  if (_NSStringClass)
  {
    if (a1) {
      goto LABEL_17;
    }
LABEL_21:
    LOBYTE(Class) = 0;
    return Class & 1;
  }

  Class Class = objc_getClass("NSString");
  _NSStringClass Class = (uint64_t)Class;
  if (!Class) {
    return Class & 1;
  }
  if (!a1) {
    goto LABEL_21;
  }
LABEL_17:
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  LOBYTE(Class) = objc_opt_isKindOfClass();
  return Class & 1;
}

uint64_t _NSIsNSTimeZone(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }

  return a1 & 1;
}

uint64_t _NSIsNSValue(uint64_t a1)
{
  if (_NSValueClass || (Class Class = objc_getClass("NSValue"), (_NSValueClass Class = (uint64_t)Class) != 0))
  {
    if (a1)
    {
      MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
      LOBYTE(Class) = objc_opt_isKindOfClass();
    }

    else
    {
      LOBYTE(Class) = 0;
    }
  }

  return Class & 1;
}

uint64_t _NSIsNSCFConstantString(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }

  return a1 & 1;
}

uint64_t _NSIsNSIndexSet()
{
  return Class & 1;
}

uint64_t _NSIsNSURL(uint64_t a1)
{
  if (_NSURLClass)
  {
    if (a1) {
      goto LABEL_3;
    }
LABEL_7:
    LOBYTE(Class) = 0;
    return Class & 1;
  }

  Class Class = objc_getClass("NSURL");
  _NSURLClass Class = (uint64_t)Class;
  if (!Class) {
    return Class & 1;
  }
  if (!a1) {
    goto LABEL_7;
  }
LABEL_3:
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  LOBYTE(Class) = objc_opt_isKindOfClass();
  return Class & 1;
}

uint64_t _NSIsNSAttributedString()
{
  if (_NSAttributedStringClass
    || (Class Class = objc_getClass("NSAttributedString"), (_NSAttributedStringClass Class = (uint64_t)Class) != 0))
  {
    LOBYTE(Class) = objc_opt_isKindOfClass();
  }

  return Class & 1;
}

unint64_t makeAtom(unint64_t a1)
{
  if ((dyld_program_sdk_at_least() & 1) != 0 || !*MEMORY[0x189616650]) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  while (2)
  {
    uint64_t v4 = *(&__atom_buckets + v3);
    if (v4)
    {
      unsigned int v5 = 16 << v3;
      else {
        uint64_t v6 = v5;
      }
      signed int v7 = v5 - 16;
      do
      {
        if (*v4 == a1)
        {
          a1 = ((uint64_t)v7 << 7) | 0x8000000000000000LL;
          unint64_t v17 = *MEMORY[0x189616658] ^ a1;
          if ((~v17 & 0xC000000000000007LL) != 0) {
            return v17 & 0xFFFFFFFFFFFFFFF8LL | *(unsigned __int8 *)(MEMORY[0x189616648] + (*MEMORY[0x189616658] & 7LL));
          }
          return a1;
        }

        ++v7;
        ++v4;
        --v6;
      }

      while (v6);
      if (++v3 != 24) {
        continue;
      }
    }

    break;
  }

  do
    unsigned int v8 = __ldxr((unsigned int *)&__natoms);
  while (__stxr(v8 + 1, (unsigned int *)&__natoms));
  id v9 = (id)a1;
  unsigned int v19 = v8 + 1;
  unint64_t result = flsl(((v8 + 1) >> 4) + 1);
  if ((int)result < 25)
  {
    int v10 = 1 << (result + 3);
    int v11 = v8 - v10 + 17;
    BOOL v12 = &__atom_buckets + (int)result;
    SEL v15 = *(v12 - 1);
    unint64_t v14 = (unint64_t *)(v12 - 1);
    CFStringRef v13 = v15;
    if (!v15)
    {
      CFStringRef v13 = calloc(8uLL, v10);
      while (!__ldaxr(v14))
      {
      }

      __clrex();
      free(v13);
      CFStringRef v13 = (void *)*v14;
    }

uint64_t getAtomTarget(uint64_t a1)
{
  uint64_t result = dyld_program_sdk_at_least();
  if ((result & 1) != 0) {
    return 0LL;
  }
  uint64_t v3 = *MEMORY[0x189616658];
  if ((~a1 & 0xC000000000000007LL) == 0) {
    uint64_t v3 = 0LL;
  }
  unint64_t v4 = v3 ^ a1;
  uint64_t v5 = 0xFFFFFFFFFFFFFFFLL;
  if ((~(_BYTE)v4 & 7) == 0) {
    uint64_t v5 = 0xFFFFFFFFFFFFFLL;
  }
  unint64_t v6 = v5 & (v4 >> 3);
  if (__natoms < v6 >> 4)
  {
    __break(1u);
  }

  else
  {
    unint64_t v7 = v6 >> 4;
    int v8 = flsl((v6 >> 8) + 1);
    return *((void *)*(&__atom_buckets + v8 - 1) + (int)v7 + (-1 << (v8 + 3)) + 16);
  }

  return result;
}

void _NSSetDeallocHandler()
{
  qword_18C539A70 = (uint64_t)"Unsupported functionality";
  __break(1u);
}

uint64_t __CFFullMethodName(objc_class *a1, objc_class *a2, const char *a3)
{
  cStr[1] = *(char **)MEMORY[0x1895F89C0];
  cStr[0] = 0LL;
  if (a2 == a1) {
    uint64_t v4 = 43LL;
  }
  else {
    uint64_t v4 = 45LL;
  }
  if (a1)
  {
    Name = class_getName(a1);
    if (a3)
    {
LABEL_6:
      unint64_t v6 = sel_getName(a3);
      goto LABEL_9;
    }
  }

  else
  {
    Name = "(null class)";
    if (a3) {
      goto LABEL_6;
    }
  }

  unint64_t v6 = "(null selector)";
LABEL_9:
  asprintf(cStr, "%c[%s %s]", v4, Name, v6);
  if (!cStr[0]) {
    return 0LL;
  }
  CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr[0], 0x8000100u);
  uint64_t v7 = _CFAutoreleasePoolAddObject();
  free(cStr[0]);
  return v7;
}

uint64_t __CFExceptionProem(objc_class *a1, const char *a2)
{
  uint64_t v4 = (objc_class *)objc_opt_class();
  return __CFFullMethodName(v4, a1, a2);
}

uint64_t __CFAllocateObject(objc_class *a1, size_t a2)
{
  id Instance = class_createInstance(a1, a2);
  if (Instance)
  {
    id v3 = Instance;
    if (__CFOASafe)
    {
      object_getClassName(Instance);
      __CFSetLastAllocationEventName();
    }

    return (uint64_t)v3;
  }

  else
  {
    objc_exception_throw( +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSMallocException",  @"*** NSAllocateObject(): attempt to allocate object failed",  0LL));
    return __CFLookUpClass();
  }

Class __CFLookUpClass(const char *a1)
{
  Class result = objc_lookUpClass(a1);
  if (!result)
  {
    if (!dlopen("/System/Library/Frameworks/Foundation.framework/Foundation", 5))
    {
      dlerror();
      CFLog( 3LL,  (uint64_t)@"*** Error: Could not load Foundation for class %s; error is '%s'; if this seems unreasonable, perhaps seatbelt has prevented the load due to file access limitations on the process",
        v3,
        v4,
        v5,
        v6,
        v7,
        v8,
        (uint64_t)a1);
    }

    Class result = objc_lookUpClass(a1);
    if (!result)
    {
      if (!strcmp(a1, "NSString") || !strcmp(a1, "NSMutableString"))
      {
        id v9 = (objc_class *)objc_opt_self();
        ClassPair = objc_allocateClassPair(v9, "NSString", 0x20uLL);
        objc_registerClassPair(ClassPair);
        int v11 = objc_allocateClassPair(ClassPair, "NSMutableString", 0x20uLL);
        objc_registerClassPair(v11);
        return objc_lookUpClass(a1);
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

id _NSObjectStoreWeak(id *location, id obj, _BYTE *a3)
{
  if (!obj)
  {
    if (*location)
    {
      if (*a3)
      {
        id v5 = 0LL;
        *CFIndex location = 0LL;
        return v5;
      }

      objc_storeWeakOrNil(location, 0LL);
    }

    return 0LL;
  }

  id v5 = obj;
  if (*a3) {
    *CFIndex location = 0LL;
  }
  id v6 = objc_storeWeakOrNil(location, obj);
  if (v6)
  {
    *a3 = 0;
    return v6;
  }

  else
  {
    *a3 = 1;
    *CFIndex location = v5;
  }

  return v5;
}

id _NSObjectLoadWeak(id *a1, _BYTE *a2)
{
  if (*a2) {
    return *a1;
  }
  else {
    return objc_loadWeakRetained(a1);
  }
}

id _NSObjectLoadWeakRetained(id *a1, _BYTE *a2)
{
  if (*a2) {
    return *a1;
  }
  else {
    return objc_loadWeakRetained(a1);
  }
}

uint64_t OUTLINED_FUNCTION_0_21(objc_class *a1)
{
  return __CFFullMethodName(a1, v1, v2);
}

void sub_180B77CDC(_Unwind_Exception *exception_object)
{
}

void sub_180B78428(_Unwind_Exception *a1)
{
}

void sub_180B7A238(_Unwind_Exception *a1)
{
}

void sub_180B7B374(_Unwind_Exception *a1)
{
}

void sub_180B7B7F0(_Unwind_Exception *a1)
{
}

void sub_180B7BD00(_Unwind_Exception *a1)
{
}

void sub_180B7C160(_Unwind_Exception *a1)
{
}

uint64_t __createSet(void *a1, uint64_t a2)
{
  v3[1] = *MEMORY[0x1895F89C0];
  v3[0] = a2;
  return [a1 initWithObjects:v3 count:1];
}

void sub_180B7C7EC(_Unwind_Exception *a1)
{
}

void sub_180B7D3C4(_Unwind_Exception *a1)
{
}

NSUInteger OUTLINED_FUNCTION_0_22(objc_class *a1)
{
  return __CFRequireConcreteImplementation(a1, v1);
}

  ;
}

  ;
}

void __rehashs(uint64_t a1, int a2)
{
  unsigned __int8 v2 = a2;
  unint64_t v4 = __NSSetSizes_0[2 * a2];
  id v5 = calloc(1uLL, 8 * v4);
  unint64_t v6 = *(unsigned int *)(a1 + 28);
  uint64_t v7 = *(void **)(a1 + 16);
  if (v6 >> 26)
  {
    uint64_t v8 = 0LL;
    unint64_t v9 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v6 >> 23) & 0x1F8));
    if (v9 <= 1) {
      uint64_t v10 = 1LL;
    }
    else {
      uint64_t v10 = v9;
    }
    do
    {
      int v11 = (void *)v7[v8];
      if (v11) {
        BOOL v12 = v11 == &___NSSetM_DeletedMarker;
      }
      else {
        BOOL v12 = 1;
      }
      if (!v12)
      {
        unint64_t v13 = [(id)v7[v8] hash] % v4;
        do
        {
          unint64_t v14 = v13;
          uint64_t v15 = v5[v13];
          unint64_t v16 = v13 + 1;
          if (v16 >= v4) {
            unint64_t v17 = v4;
          }
          else {
            unint64_t v17 = 0LL;
          }
          unint64_t v13 = v16 - v17;
        }

        while (v15);
        v5[v14] = v11;
      }

      ++v8;
    }

    while (v8 != v10);
  }

  free(v7);
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = *(_DWORD *)(a1 + 28) & 0x3FFFFFF | (v2 << 26);
}

void sub_180B7E08C(_Unwind_Exception *a1)
{
}

uint64_t __NSSetM_new(uint64_t a1, unint64_t a2, char a3)
{
  int v4 = 0;
  unint64_t v5 = 0LL;
  while (__NSSetCapacities_0[v5 / 2] < a2)
  {
    v5 += 2LL;
    v4 -= 0x4000000;
    if (v5 == 128)
    {
      __break(1u);
      break;
    }
  }

  unint64_t v6 = __NSSetSizes_0[v5];
  uint64_t v7 = (objc_class *)objc_opt_self();
  uint64_t v8 = __CFAllocateObject(v7, 0LL);
  atomic_store(0LL, (unint64_t *)(v8 + 8));
  *(void *)(v8 + 16) = 0LL;
  *(_DWORD *)(v8 + 24) = 1;
  uint64_t v23 = v8;
  *(_DWORD *)(v8 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = (*(_DWORD *)(v8 + 28) & 0x3FFFFFF) - v4;
  if (a2)
  {
    unint64_t v9 = calloc(1uLL, 8 * v6);
    *(void *)(v23 + 16) = v9;
    if (a1)
    {
      uint64_t v10 = v9;
      uint64_t v11 = 0LL;
      if (v6 <= 1) {
        uint64_t v12 = 1LL;
      }
      else {
        uint64_t v12 = v6;
      }
      uint64_t v25 = v12;
      do
      {
        unint64_t v13 = *(void **)(a1 + 8 * v11);
        unint64_t v14 = [v13 hash];
        unint64_t v15 = v6;
        if ((_DWORD)(v5 * 4))
        {
          unint64_t v16 = v14 % v6;
          uint64_t v17 = v25;
          unint64_t v15 = v6;
          while (1)
          {
            unint64_t v18 = (void *)v10[v16];
            if (!v18) {
              break;
            }
            if (v18 == &___NSSetM_DeletedMarker)
            {
              if (v15 == v6) {
                unint64_t v15 = v16;
              }
            }

            else if (v18 == v13 || ([v18 isEqual:v13] & 1) != 0)
            {
              unint64_t v15 = v16;
              goto LABEL_28;
            }

            if (v16 + 1 >= v6) {
              unint64_t v19 = v6;
            }
            else {
              unint64_t v19 = 0LL;
            }
            unint64_t v16 = v16 + 1 - v19;
            if (!--v17) {
              goto LABEL_28;
            }
          }

          if (v15 == v6) {
            unint64_t v15 = v16;
          }
        }

void __RELEASE_OBJECTS_IN_THE_SET__(uint64_t a1, int a2)
{
  unsigned __int8 v2 = &OBJC_IVAR_____NSFrozenSetM_storage;
  if (a2 == 1) {
    unsigned __int8 v2 = &OBJC_IVAR_____NSSetM_storage;
  }
  uint64_t v3 = a1 + *v2;
  unint64_t v4 = *(unsigned int *)(v3 + 12);
  unint64_t v5 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v4 >> 23) & 0x1F8));
  int v6 = v4 & 0x3FFFFFF;
  uint64_t v7 = *(void **)v3;
  *(_DWORD *)(v3 + 12) = 0;
  *(void *)uint64_t v3 = 0LL;
  if ((v4 & 0x3FFFFFF) != 0 && v4 >> 26 != 0)
  {
    unint64_t v9 = 0LL;
    do
    {
      unint64_t v10 = v7[v9];
      if (v10) {
        BOOL v11 = v10 == (void)&___NSSetM_DeletedMarker;
      }
      else {
        BOOL v11 = 1;
      }
      if (!v11)
      {
        if ((v10 & 0x8000000000000000LL) == 0) {

        }
        --v6;
      }

      if (!v6) {
        break;
      }
      ++v9;
    }

    while (v9 < v5);
  }

  free(v7);
}

uint64_t __NSSetM_copy(uint64_t Function, uint64_t a2)
{
  uint64_t v3 = Function;
  v16[1] = *MEMORY[0x1895F89C0];
  if (__cf_tsanReadFunction) {
    Function = __cf_tsanReadFunction(Function, v2, __CFTSANTagMutableSet);
  }
  uint64_t v4 = *(_DWORD *)(v3 + 28) & 0x3FFFFFF;
  if (!atomic_load((unint64_t *)(v3 + 8)))
  {
LABEL_11:
    MEMORY[0x1895F8858](Function, a2);
    BOOL v11 = (char *)v16 - v10;
    [(id)v3 getObjects:(char *)v16 - v10 count:v4];
    return [objc_allocWithZone((Class)NSSet) initWithObjects:v11 count:v4];
  }

void sub_180B7FA44(_Unwind_Exception *exception_object)
{
}

uint64_t __NSFrozenSetM_mutableCopy(uint64_t a1)
{
  if (__cf_tsanReadFunction) {
    __cf_tsanReadFunction(a1, v1, __CFTSANTagMutableSet);
  }
  uint64_t v3 = (unint64_t *)(a1 + 24);
  if (!atomic_load((unint64_t *)(a1 + 24)))
  {
    unint64_t v5 = _cow_create(a1, 0);
    while (!__ldaxr(v3))
    {
    }

    __clrex();
    free(v5);
  }

__n128 cow_copy_instance_1(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4 = &OBJC_IVAR_____NSFrozenSetM_storage;
  if (a2 == 1) {
    unint64_t v5 = &OBJC_IVAR_____NSSetM_storage;
  }
  else {
    unint64_t v5 = &OBJC_IVAR_____NSFrozenSetM_storage;
  }
  int v6 = &OBJC_IVAR_____NSFrozenSetM_cow;
  if (a2 == 1) {
    uint64_t v7 = &OBJC_IVAR_____NSSetM_cow;
  }
  else {
    uint64_t v7 = &OBJC_IVAR_____NSFrozenSetM_cow;
  }
  uint64_t v8 = *v5;
  unint64_t v9 = atomic_load((unint64_t *)(a1 + *v7));
  if (a4 == 1)
  {
    int v6 = &OBJC_IVAR_____NSSetM_cow;
    uint64_t v4 = &OBJC_IVAR_____NSSetM_storage;
  }

  atomic_store(v9, (unint64_t *)(a3 + *v6));
  __n128 result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v4) = result;
  return result;
}

uint64_t cow_copy_storage_1(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 16);
  unint64_t v3 = *(unsigned int *)(a1 + 28);
  if ((v3 & 0x3FFFFFF) == 0)
  {
    uint64_t v6 = 0LL;
    *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v1 - 56), 8) = 0;
LABEL_16:
    uint64_t result = 1LL;
    goto LABEL_17;
  }

  unint64_t v4 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v3 >> 23) & 0x1F8));
  uint64_t result = (uint64_t)malloc(8 * v4);
  uint64_t v6 = result;
  if (result)
  {
    if (v3 >> 26)
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = *v2;
      if (v4 <= 1) {
        uint64_t v9 = 1LL;
      }
      else {
        uint64_t v9 = v4;
      }
      uint64_t v10 = 8 * v9;
      do
      {
        uint64_t v11 = *(void *)(v8 + v7);
        if (v11 >= 1 && v11 != (void)&___NSSetM_DeletedMarker) {
          id v13 = (id)v11;
        }
        *(void *)(v6 + v7) = v11;
        v7 += 8LL;
      }

      while (v10 != v7);
    }

    goto LABEL_16;
  }

uint64_t cow_set_cow_1(uint64_t result, unint64_t a2)
{
  return result;
}

uint64_t _compare_clumpiness_1(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

void *__mset_enumerateObjectsWithOptionsUsingBlock_block_invoke(void *result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result[5] + 8 * a2);
  if (v2) {
    BOOL v3 = v2 == &___NSSetM_DeletedMarker;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    unint64_t v4 = result;
    unint64_t v5 = (void *)_CFAutoreleasePoolPush();
    __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(v4[4]);
    return _CFAutoreleasePoolPop(v5);
  }

  return result;
}

uint64_t _CFListFormatterGetTypeID()
{
  return 68LL;
}

void __CFListFormatterDeallocate(uint64_t a1)
{
  if (!a1) {
    __CFListFormatterDeallocate_cold_1();
  }
  uint64_t v1 = *(const void **)(a1 + 16);
  if (v1) {
    CFRelease(v1);
  }
}

CFStringRef __CFListFormatterCopyDescription(const void *a1)
{
  if (!a1) {
    __CFListFormatterCopyDescription_cold_1();
  }
  uint64_t v2 = CFGetAllocator(a1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0LL, @"<CFListFormatter %p>[%p]", a1, v3);
}

uint64_t _CFListFormatterCreate( const __CFAllocator *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    _CFListFormatterCreate_cold_1();
  }
  if (!a2) {
    _CFListFormatterCreate_cold_2();
  }
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x44uLL, 8LL, 0LL, a5, a6, a7, a8);
  if (Instance) {
    *(void *)(Instance + 16) = CFRetain(a2);
  }
  return Instance;
}

CFStringRef _CFListFormatterCreateStringByJoiningStrings( const __CFAllocator *a1, unint64_t *a2, const __CFArray *a3)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  unint64_t v6 = _CFGetNonObjCTypeID(a2);
  if (v6 != 68) {
    _CFAssertMismatchedTypeID(0x44uLL, v6);
  }
  if (!a3) {
    return 0LL;
  }
  CFIndex Count = CFArrayGetCount(a3);
  if (!Count) {
    return &stru_1899EF170;
  }
  uint64_t v8 = Count;
  alloc = a1;
  locale = (const __CFLocale *)a2[2];
  uint64_t v9 = malloc(8 * Count);
  uint64_t v10 = malloc(4 * v8);
  uint64_t v11 = calloc(v8, 1uLL);
  if (v8 >= 1)
  {
    for (CFIndex i = 0LL; i != v8; ++i)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, i);
      CFIndex Length = CFStringGetLength(ValueAtIndex);
      CharactersPtr = (UniChar *)CFStringGetCharactersPtr(ValueAtIndex);
      if (!CharactersPtr)
      {
        CharactersPtr = (UniChar *)malloc(2 * Length);
        v40.CFIndex location = 0LL;
        v40.CFIndex length = Length;
        CFStringGetCharacters(ValueAtIndex, v40, CharactersPtr);
        v11[i] = 1;
      }

      v10[i] = Length;
      v9[i] = CharactersPtr;
    }
  }

  int v36 = 0;
  Identifier = CFLocaleGetIdentifier(locale);
  CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    if (CFStringGetCString(Identifier, buffer, 256LL, 0x600u)) {
      CStringPtr = buffer;
    }
    else {
      CStringPtr = 0LL;
    }
  }

  uint64_t v18 = __cficu_ulistfmt_open((uint64_t)CStringPtr, &v36);
  v28[0] = MEMORY[0x1895F87A8];
  v28[1] = 0x40000000LL;
  uint64_t v29 = ___CFListFormatterCreateStringByJoiningStrings_block_invoke;
  uint64_t v30 = &__block_descriptor_tmp_20;
  uint64_t v31 = v18;
  uint64_t v32 = v8;
  int v33 = v9;
  uint64_t v34 = v11;
  int v35 = v10;
  if (v36 >= 1)
  {
    ___CFListFormatterCreateStringByJoiningStrings_block_invoke((uint64_t)v28);
    return 0LL;
  }

  uint64_t v20 = v18;
  int v36 = 0;
  int v21 = __cficu_ulistfmt_format(v18, (uint64_t)v9, (uint64_t)v10, v8, chars, 768LL, &v36);
  if (v36 <= 0)
  {
    CFStringRef v19 = CFStringCreateWithCharacters(alloc, chars, v21);
  }

  else if (v36 == 15 || v8 < v21)
  {
    int v36 = 0;
    uint64_t v22 = (v21 + 1);
    uint64_t v23 = (UniChar *)malloc(2LL * (int)v22);
    int v24 = __cficu_ulistfmt_format(v20, (uint64_t)v9, (uint64_t)v10, v8, v23, v22, &v36);
    if (v36 <= 0) {
      CFStringRef v19 = CFStringCreateWithCharacters(alloc, v23, v24);
    }
    else {
      CFStringRef v19 = 0LL;
    }
    free(v23);
  }

  else
  {
    CFStringRef v19 = 0LL;
  }

  v29((uint64_t)v28);
  return v19;
}

uint64_t cbInit(void ***a1, unsigned int a2)
{
  uint64_t result = (uint64_t)malloc(0x68uLL);
  *a1 = (void **)result;
  if (result)
  {
    uint64_t v5 = result;
    unint64_t v6 = (char *)malloc(a2);
    *(void *)uint64_t v5 = v6;
    if (!v6)
    {
      uint64_t v8 = (void **)v5;
      goto LABEL_6;
    }

    *(void *)(v5 + _Block_object_dispose((const void *)(v1 - 56), 8) = v6;
    *(void *)(v5 + 16) = v6;
    *(_DWORD *)(v5 + 32) = a2;
    *(_DWORD *)(v5 + 36) = a2;
    *(void *)(v5 + 24) = &v6[a2];
    if (pthread_mutex_init((pthread_mutex_t *)(v5 + 40), 0LL))
    {
      free(**a1);
      **a1 = 0LL;
      (*a1)[1] = 0LL;
      (*a1)[2] = 0LL;
      uint64_t v7 = *a1;
      v7[3] = 0LL;
      v7[4] = 0LL;
      uint64_t v8 = *a1;
LABEL_6:
      free(v8);
      uint64_t result = 0LL;
      *a1 = 0LL;
      return result;
    }

    return 1LL;
  }

  return result;
}

uint64_t cbDestroy(void **a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *a1;
  if (v2)
  {
    free(v2);
    uint64_t v3 = 1LL;
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  free(a1);
  return v3;
}

BOOL _cbCanRead(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 36) < *(_DWORD *)(result + 32);
  }
  return result;
}

size_t cbRead(uint64_t a1, char *a2, int a3)
{
  size_t v3 = 0LL;
  if (a1 && a2 && a3 >= 1)
  {
    uint64_t v7 = (pthread_mutex_t *)(a1 + 40);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
    unsigned int v8 = *(_DWORD *)(a1 + 32);
    uint64_t v9 = (_BYTE *)*(unsigned int *)(a1 + 36);
    if (v8 <= v9)
    {
      size_t v3 = 0LL;
    }

    else
    {
      unsigned int v10 = v8 - (_DWORD)v9;
      if (v10 >= a3) {
        size_t v3 = a3;
      }
      else {
        size_t v3 = v10;
      }
      uint64_t v11 = *(char **)(a1 + 8);
      uint64_t v12 = *(_BYTE **)(a1 + 16);
      int64_t v13 = v12 - v11;
      if (v12 == v11)
      {
        if ((_DWORD)v9) {
          cbRead_cold_3();
        }
        uint64_t v18 = *(void *)(a1 + 24);
        int v19 = v18 - (_DWORD)v12;
        size_t v20 = (v3 - (v18 - (_DWORD)v12));
        if (v3 <= (int)v18 - (int)v12)
        {
          __cbRead((uint64_t *)a1, a2, *(void **)(a1 + 16), v3);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_2();
          }
        }

        else
        {
          __cbRead((uint64_t *)a1, a2, *(void **)(a1 + 16), v18 - (void)v12);
          __cbRead((uint64_t *)a1, &a2[v19], *(void **)(a1 + 8), v20);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_1();
          }
        }
      }

      else if (v12 >= v11)
      {
        if ((_BYTE *)(v11 - &v12[*(void *)a1] + *(void *)(a1 + 24)) != v9) {
          cbRead_cold_10();
        }
        if (v13 <= v3)
        {
          size_t v3 = v12 - v11;
          __cbRead((uint64_t *)a1, a2, v11, v13);
          unint64_t v21 = *(void *)(a1 + 8);
          if (v21 != *(void *)(a1 + 16)) {
            cbRead_cold_9();
          }
          if (v21 > *(void *)(a1 + 24)) {
            cbRead_cold_8();
          }
        }

        else
        {
          __cbRead((uint64_t *)a1, a2, v11, v3);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_7();
          }
        }
      }

      else
      {
        if ((_BYTE *)(v11 - v12) != v9) {
          cbRead_cold_6();
        }
        uint64_t v14 = *(void *)(a1 + 24);
        int v15 = v14 - (_DWORD)v11;
        size_t v16 = (v3 - (v14 - (_DWORD)v11));
        if (v3 <= (int)v14 - (int)v11)
        {
          __cbRead((uint64_t *)a1, a2, v11, v3);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_5();
          }
        }

        else
        {
          __cbRead((uint64_t *)a1, a2, v11, v14 - (void)v11);
          __cbRead((uint64_t *)a1, &a2[v15], *(void **)(a1 + 8), v16);
          if (*(void *)(a1 + 8) > *(void *)(a1 + 24)) {
            cbRead_cold_4();
          }
        }
      }
    }

    pthread_mutex_unlock(v7);
  }

  return v3;
}

size_t __cbRead(uint64_t *a1, void *__dst, void *__src, size_t __len)
{
  if (!__dst) {
    __cbRead_cold_1();
  }
  if (!__src) {
    __cbRead_cold_2();
  }
  memmove(__dst, __src, __len);
  uint64_t v6 = *((unsigned int *)a1 + 8);
  *((_DWORD *)a1 + 9) += __len;
  uint64_t v7 = a1[1] + __len;
  if (v7 == *a1 + v6) {
    uint64_t v7 = *a1;
  }
  a1[1] = v7;
  return __len;
}

BOOL _cbCanWrite(uint64_t a1)
{
  return *(_DWORD *)(a1 + 36) != 0;
}

size_t cbWrite(uint64_t a1, char *a2, unsigned int a3)
{
  size_t v3 = 0LL;
  if (a1 && a2 && (int)a3 >= 1)
  {
    uint64_t v7 = (pthread_mutex_t *)(a1 + 40);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
    size_t v8 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v8)
    {
      else {
        size_t v3 = v8;
      }
      unsigned int v10 = *(_BYTE **)(a1 + 8);
      uint64_t v9 = *(_BYTE **)(a1 + 16);
      if (v9 == v10)
      {
        if ((_DWORD)v8 != *(_DWORD *)(a1 + 32)) {
          cbWrite_cold_1();
        }
        uint64_t v11 = *(void *)(a1 + 24);
        int v12 = v11 - (_DWORD)v9;
        unsigned int v13 = v3 - (v11 - (_DWORD)v9);
        if (v3 > (int)v11 - (int)v9)
        {
          __cbWrite((uint64_t *)a1, v9, a2, v11 - (void)v9);
          unsigned int v14 = *(_DWORD *)(a1 + 36);
          if (v13 >= v14) {
            size_t v15 = v14;
          }
          else {
            size_t v15 = v13;
          }
          __cbWrite((uint64_t *)a1, *(void **)(a1 + 16), &a2[v12], v15);
          size_t v3 = (v15 + v12);
          goto LABEL_27;
        }
      }

      else if (v9 >= v10)
      {
        uint64_t v16 = *(void *)(a1 + 24) - (void)v9;
        if (&v10[v16 - *(void *)a1] != (_BYTE *)v8) {
          cbWrite_cold_3();
        }
        unsigned int v17 = v3 - v16;
        if (v3 > v16)
        {
          __cbWrite((uint64_t *)a1, v9, a2, *(void *)(a1 + 24) - (void)v9);
          unsigned int v18 = *(_DWORD *)(a1 + 36);
          if (v17 >= v18) {
            size_t v19 = v18;
          }
          else {
            size_t v19 = v17;
          }
          __cbWrite((uint64_t *)a1, *(void **)(a1 + 16), &a2[v16], v19);
          size_t v3 = (v19 + v16);
          goto LABEL_27;
        }
      }

      else
      {
        if (v10 - v9 != v8) {
          cbWrite_cold_2();
        }
        if (v8 <= a3)
        {
          __cbWrite((uint64_t *)a1, v9, a2, *(unsigned int *)(a1 + 36));
          size_t v3 = v8;
LABEL_27:
          pthread_mutex_unlock(v7);
          return v3;
        }
      }

      __cbWrite((uint64_t *)a1, v9, a2, v3);
      goto LABEL_27;
    }

    size_t v3 = 0LL;
    goto LABEL_27;
  }

  return v3;
}

size_t __cbWrite(uint64_t *a1, void *__dst, void *__src, size_t __len)
{
  if (!__dst) {
    __cbWrite_cold_1();
  }
  if (!__src) {
    __cbWrite_cold_2();
  }
  memmove(__dst, __src, __len);
  uint64_t v6 = *((unsigned int *)a1 + 8);
  *((_DWORD *)a1 + 9) -= __len;
  uint64_t v7 = a1[2] + __len;
  if (v7 == *a1 + v6) {
    uint64_t v7 = *a1;
  }
  a1[2] = v7;
  return __len;
}

uint64_t _CFCalendarResetCurrent()
{
  return +[NSCalendar _resetCurrent](&OBJC_CLASS___NSCalendar, "_resetCurrent");
}

uint64_t _CFCalendarGetMidnightNoteCount()
{
  return __CFMidnightNoteCount;
}

void __postAndResetMidnight(int a1, int a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  gettimeofday(&v11, 0LL);
  localtime_r(&v11.tv_sec, &v10);
  uint64_t v4 = (v10.tm_gmtoff + v11.tv_sec) / 86400;
  if (a1 && v4 < __CFLastLocalMidnightDay || a2 && v4 > __CFLastLocalMidnightDay)
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    do
      unint64_t v6 = __ldaxr((unint64_t *)&__CFMidnightNoteCount);
    while (__stlxr(v6 + 1, (unint64_t *)&__CFMidnightNoteCount));
    CFNotificationCenterPostNotification(LocalCenter, @"NSCalendarDayChangedNotification", 0LL, 0LL, 1u);
  }

  gettimeofday(&v11, 0LL);
  localtime_r(&v11.tv_sec, &v10);
  __CFLastLocalMidnightDay = (v11.tv_sec + v10.tm_gmtoff) / 86400;
  v9.tv_sec = 86400 * __CFLastLocalMidnightDay - v10.tm_gmtoff + 86400;
  v9.tv_nsec = 0LL;
  uint64_t v7 = (dispatch_source_s *)__CFMidnightTimer;
  dispatch_time_t v8 = dispatch_walltime(&v9, 0LL);
  dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0xB2D05E00uLL);
}

void __initDayChangedNotification()
{
  if (__initDayChangedNotification_onceToken != -1) {
    dispatch_once(&__initDayChangedNotification_onceToken, &__block_literal_global_31);
  }
}

void ____initDayChangedNotification_block_invoke()
{
  qos_class_t v0 = qos_class_main();
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(v0, 2uLL);
  __CFMidnightTimer = (uint64_t)dispatch_source_create(MEMORY[0x1895F8B78], 0LL, 0LL, global_queue);
  dispatch_source_set_event_handler((dispatch_source_t)__CFMidnightTimer, &__block_literal_global_2);
  __postAndResetMidnight(0, 0);
  dispatch_resume((dispatch_object_t)__CFMidnightTimer);
}

void ____initDayChangedNotification_block_invoke_2()
{
}

void _dayChangedNotification(int a1, int a2, CFTypeRef cf2)
{
  int v3 = CFEqual(@"com.apple.system.timezone", cf2);
  __postAndResetMidnight(1, v3);
}

void sub_180B82794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

void sub_180B82B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t __CFCalendarCreateUCalendar(const void *a1, CFLocaleIdentifier localeID, const __CFTimeZone *a3)
{
  LocaleIdentifierFromComponents = localeID;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  localeID);
    CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  ComponentsFromLocaleIdentifier);
    CFDictionarySetValue(MutableCopy, @"calendar", a1);
    LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  MutableCopy);
    CFRelease(MutableCopy);
    CFRelease(ComponentsFromLocaleIdentifier);
  }

  MEMORY[0x1895F8858](a1, localeID);
  CStringPtr = (char *)CFStringGetCStringPtr(LocaleIdentifierFromComponents, 0x600u);
  tm v10 = CStringPtr;
  if (CStringPtr
    || (CStringPtr = (char *)CFStringGetCString(LocaleIdentifierFromComponents, v17, 512LL, 0x600u),
        tm v10 = v17,
        (_DWORD)CStringPtr))
  {
    MEMORY[0x1895F8858](CStringPtr, v9);
    Name = CFTimeZoneGetName(a3);
    unint64_t Length = CFStringGetLength(Name);
    if (Length >= 0x200) {
      CFIndex v13 = 512LL;
    }
    else {
      CFIndex v13 = Length;
    }
    v20.CFIndex location = 0LL;
    v20.CFIndex length = v13;
    CFStringGetCharacters(Name, v20, v16);
    int v18 = 0;
    uint64_t v14 = __cficu_ucal_open(v16, v13, (uint64_t)v10, 0, &v18);
    if (a1) {
      CFRelease(LocaleIdentifierFromComponents);
    }
  }

  else
  {
    if (a1) {
      CFRelease(LocaleIdentifierFromComponents);
    }
    return 0LL;
  }

  return v14;
}

uint64_t _CFCalendarGetUnitsFromDateFormat(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  if (Length < 1) {
    return 0LL;
  }
  CFIndex v3 = Length;
  uint64_t v4 = 0LL;
  for (CFIndex i = 0LL; i != v3; ++i)
  {
    CFStringGetCharacterAtIndex(a1, i);
    udat_patternCharToDateFormatField();
    unsigned int v6 = udat_toCalendarDateField();
    if (v6 > 0x16) {
      uint64_t v7 = 0LL;
    }
    else {
      uint64_t v7 = qword_180D7E370[v6];
    }
    v4 |= v7;
  }

  return v4;
}

NSUInteger OUTLINED_FUNCTION_0_23(objc_class *a1)
{
  return __CFRequireConcreteImplementation(a1, v1);
}

  ;
}

NSUInteger OUTLINED_FUNCTION_2_11(objc_class *a1, uint64_t a2)
{
  return __CFRequireConcreteImplementation(a1, a2);
}

  ;
}

  ;
}

  ;
}

uint64_t _CFTimeZoneGetNoteCount()
{
  return __noteCount_0;
}

void _systemTimeZoneChangedNotification()
{
  qos_class_t v0 = (const void *)+[NSTimeZone _resetSystemTimeZone](&OBJC_CLASS___NSTimeZone, "_resetSystemTimeZone");
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification( LocalCenter,  @"kCFTimeZoneSystemTimeZoneDidChangeNotification-4",  v0,  0LL,  1u);
  CFNotificationCenterPostNotification( LocalCenter,  @"kCFTimeZoneSystemTimeZoneDidChangeNotification-2",  v0,  0LL,  1u);
  CFNotificationCenterPostNotification( LocalCenter,  @"kCFTimeZoneSystemTimeZoneDidChangeNotification",  v0,  0LL,  1u);
}

NSUInteger OUTLINED_FUNCTION_0_24(objc_class *a1)
{
  return __CFRequireConcreteImplementation(a1, v1);
}

  ;
}

  ;
}

uint64_t __NSArrayI_new(id *a1, void *a2, unint64_t a3, char a4)
{
  int v18 = a2;
  dispatch_time_t v8 = (objc_class *)objc_opt_self();
  uint64_t v9 = __CFAllocateObject(v8, 8 * a3);
  uint64_t v10 = v9;
  if (a3)
  {
    timeval v11 = (id *)(v9 + 16);
    if (a2)
    {
      id *v11 = *a1;
      if (a3 >= 2)
      {
        unint64_t v12 = a3 - 1;
        CFIndex v13 = (void *)(v9 + 24);
        do
        {
          uint64_t v14 = v18++;
          *v13++ = *v14;
          --v12;
        }

        while (v12);
      }
    }

    else if (a1)
    {
      memmove((void *)(v9 + 16), a1, 8 * a3);
    }

    if ((a4 & 1) == 0)
    {
      if (a3 <= 1) {
        uint64_t v15 = 1LL;
      }
      else {
        uint64_t v15 = a3;
      }
      do
      {
        ++v11;
        --v15;
      }

      while (v15);
    }

    *(void *)(v10 + _Block_object_dispose(va, 8) = a3;
  }

  return v10;
}

uint64_t __NSArrayI_transferNew(void *a1, uint64_t a2)
{
  uint64_t v4 = (objc_class *)objc_opt_self();
  uint64_t v5 = __CFAllocateObject(v4, 0LL);
  uint64_t v6 = v5;
  if (v5)
  {
    *(void *)(v5 + _Block_object_dispose(va, 8) = a2;
    *(void *)(v5 + 16) = a1;
  }

  else
  {
    free(a1);
  }

  return v6;
}

uint64_t __NSCollectionHandleConcurrentEnumerationIfSpecified(char a1, char a2, size_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if ((a1 & 1) == 0 || __CFActiveProcessorCount() < 2) {
    return 0LL;
  }
  v10[0] = 0LL;
  v10[1] = v10;
  uint64_t v10[2] = 0x2020000000LL;
  char v11 = 0;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  uint64_t v8[2] = ____NSCollectionHandleConcurrentEnumerationIfSpecified_block_invoke;
  v8[3] = &unk_1899EB790;
  char v9 = a2;
  v8[4] = a4;
  v8[5] = v10;
  dispatch_apply(a3, 0LL, v8);
  _Block_object_dispose(v10, 8);
  return 1LL;
}

uint64_t OUTLINED_FUNCTION_0_25()
{
  return _os_log_pack_fill();
}

uint64_t OUTLINED_FUNCTION_1_17()
{
  return _CFAutoreleasePoolAddObject();
}

BOOL _CFIsMatchingLibrary(const char *a1, const char *a2)
{
  CFIndex v3 = a1;
  uint64_t v4 = strrchr(a1, 47);
  if (v4) {
    CFIndex v3 = v4 + 1;
  }
  size_t v5 = strlen(a2);
  return strncmp(v3, a2, v5) == 0;
}

void *_CFGetHandleForLoadedLibrary(const char *a1)
{
  uint32_t v2 = _dyld_image_count();
  if (!v2) {
    return 0LL;
  }
  uint32_t v3 = v2;
  uint32_t v4 = 0;
  while (1)
  {
    image_mach_port_name_t name = _dyld_get_image_name(v4);
    if (_CFIsMatchingLibrary(image_name, a1)) {
      break;
    }
    if (v3 == ++v4) {
      return 0LL;
    }
  }

  if (!image_name) {
    return 0LL;
  }
  uint64_t result = dlopen(image_name, 21);
  if (!result) {
    _CFGetHandleForLoadedLibrary_cold_1();
  }
  return result;
}

void *_CFGetHandleForInsertedOrInterposingLibrary(const char *a1)
{
  if (!a1) {
    _CFGetHandleForInsertedOrInterposingLibrary_cold_1();
  }
  else {
    return 0LL;
  }
}

CFTypeID CFTimeZoneGetTypeID(void)
{
  return 48LL;
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  qos_class_t v0 = (void *)_CFAutoreleasePoolPush();
  uint64_t v1 = +[NSTimeZone systemTimeZone](&OBJC_CLASS___NSTimeZone, "systemTimeZone");
  if (v1) {
    uint32_t v2 = (const __CFTimeZone *)CFRetain(v1);
  }
  else {
    uint32_t v2 = 0LL;
  }
  _CFAutoreleasePoolPop(v0);
  return v2;
}

void CFTimeZoneResetSystem(void)
{
  qos_class_t v0 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone resetSystemTimeZone](&OBJC_CLASS___NSTimeZone, "resetSystemTimeZone");
  _CFAutoreleasePoolPop(v0);
}

CFTimeZoneRef CFTimeZoneCopyDefault(void)
{
  qos_class_t v0 = (void *)_CFAutoreleasePoolPush();
  uint64_t v1 = +[NSTimeZone defaultTimeZone](&OBJC_CLASS___NSTimeZone, "defaultTimeZone");
  if (v1) {
    uint32_t v2 = (const __CFTimeZone *)CFRetain(v1);
  }
  else {
    uint32_t v2 = 0LL;
  }
  _CFAutoreleasePoolPop(v0);
  return v2;
}

void CFTimeZoneSetDefault(CFTimeZoneRef tz)
{
  uint32_t v2 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone setDefaultTimeZone:](&OBJC_CLASS___NSTimeZone, "setDefaultTimeZone:", tz);
  _CFAutoreleasePoolPop(v2);
}

CFArrayRef CFTimeZoneCopyKnownNames(void)
{
  qos_class_t v0 = (void *)_CFAutoreleasePoolPush();
  uint64_t v1 = +[NSTimeZone knownTimeZoneNames](&OBJC_CLASS___NSTimeZone, "knownTimeZoneNames");
  if (v1) {
    uint32_t v2 = (const __CFArray *)CFRetain(v1);
  }
  else {
    uint32_t v2 = 0LL;
  }
  _CFAutoreleasePoolPop(v0);
  return v2;
}

CFDictionaryRef CFTimeZoneCopyAbbreviationDictionary(void)
{
  qos_class_t v0 = (void *)_CFAutoreleasePoolPush();
  uint64_t v1 = +[NSTimeZone abbreviationDictionary](&OBJC_CLASS___NSTimeZone, "abbreviationDictionary");
  if (v1) {
    uint32_t v2 = (const __CFDictionary *)CFRetain(v1);
  }
  else {
    uint32_t v2 = 0LL;
  }
  _CFAutoreleasePoolPop(v0);
  return v2;
}

void CFTimeZoneSetAbbreviationDictionary(CFDictionaryRef dict)
{
  uint32_t v2 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone setAbbreviationDictionary:](&OBJC_CLASS___NSTimeZone, "setAbbreviationDictionary:", dict);
  _CFAutoreleasePoolPop(v2);
}

CFTimeZoneRef CFTimeZoneCreate(CFAllocatorRef allocator, CFStringRef name, CFDataRef data)
{
  size_t v5 = (void *)_CFAutoreleasePoolPush();
  uint64_t v6 = -[NSTimeZone initWithName:data:](objc_alloc(&OBJC_CLASS___NSTimeZone), "initWithName:data:", name, data);
  _CFAutoreleasePoolPop(v5);
  return (CFTimeZoneRef)v6;
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  uint32_t v3 = (void *)_CFAutoreleasePoolPush();
  uint32_t v4 = (const __CFTimeZone *)(id)+[NSTimeZone _timeZoneWithSecondsFromGMT:]( &OBJC_CLASS___NSTimeZone,  "_timeZoneWithSecondsFromGMT:",  vcvtmd_s64_f64(ti));
  _CFAutoreleasePoolPop(v3);
  return v4;
}

CFTimeZoneRef CFTimeZoneCreateWithName(CFAllocatorRef allocator, CFStringRef name, Boolean tryAbbrev)
{
  int v3 = tryAbbrev;
  if (CFEqual(&stru_1899EF170, name)) {
    return 0LL;
  }
  uint64_t v6 = (void *)_CFAutoreleasePoolPush();
  uint64_t v7 = (const __CFTimeZone *)(id)+[NSTimeZone _timeZoneWithName:tryAbbrev:]( &OBJC_CLASS___NSTimeZone,  "_timeZoneWithName:tryAbbrev:",  name,  v3 != 0);
  _CFAutoreleasePoolPop(v6);
  return v7;
}

CFTimeInterval CFTimeZoneGetSecondsFromGMT(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  CFTimeInterval v5 = (double)-[__CFTimeZone secondsFromGMTForDate:]( tz,  "secondsFromGMTForDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
  _CFAutoreleasePoolPop(v4);
  return v5;
}

CFStringRef CFTimeZoneCopyAbbreviation(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  CFTimeInterval v5 = (const void *)-[__CFTimeZone abbreviationForDate:]( tz,  "abbreviationForDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
  if (v5) {
    uint64_t v6 = (const __CFString *)CFRetain(v5);
  }
  else {
    uint64_t v6 = 0LL;
  }
  _CFAutoreleasePoolPop(v4);
  return v6;
}

Boolean CFTimeZoneIsDaylightSavingTime(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  LOBYTE(tz) = -[__CFTimeZone isDaylightSavingTimeForDate:]( tz,  "isDaylightSavingTimeForDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
  _CFAutoreleasePoolPop(v4);
  return tz;
}

CFTimeInterval CFTimeZoneGetDaylightSavingTimeOffset(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  -[__CFTimeZone daylightSavingTimeOffsetForDate:]( tz,  "daylightSavingTimeOffsetForDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
  double v6 = v5;
  _CFAutoreleasePoolPop(v4);
  return v6;
}

CFAbsoluteTime CFTimeZoneGetNextDaylightSavingTimeTransition(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  uint32_t v4 = (void *)_CFAutoreleasePoolPush();
  double v5 = (void *)-[__CFTimeZone nextDaylightSavingTimeTransitionAfterDate:]( tz,  "nextDaylightSavingTimeTransitionAfterDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  at));
  if (v5)
  {
    [v5 timeIntervalSinceReferenceDate];
    double v7 = v6;
  }

  else
  {
    double v7 = 0.0;
  }

  _CFAutoreleasePoolPop(v4);
  return v7;
}

CFStringRef CFTimeZoneCopyLocalizedName(CFTimeZoneRef tz, CFTimeZoneNameStyle style, CFLocaleRef locale)
{
  double v6 = (void *)_CFAutoreleasePoolPush();
  double v7 = (const void *)-[__CFTimeZone localizedName:locale:](tz, "localizedName:locale:", style, locale);
  if (v7) {
    dispatch_time_t v8 = (const __CFString *)CFRetain(v7);
  }
  else {
    dispatch_time_t v8 = 0LL;
  }
  _CFAutoreleasePoolPop(v6);
  return v8;
}

NSUInteger OUTLINED_FUNCTION_0_26(objc_class *a1)
{
  return __CFRequireConcreteImplementation(a1, v1);
}

const char *__CFStringEncodingGetICUName(int a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  if (a1 == 2576) {
    return "IMAP-mailbox-name";
  }
  if ((a1 & 0xF00) == 0x100
    || (int WindowsCodePage = __CFStringEncodingGetWindowsCodePage(a1)) == 0
    || snprintf(__str, 0x3CuLL, "windows-%d", WindowsCodePage) > 59
    || (uint64_t result = (const char *)ucnv_getAlias()) == 0LL)
  {
    if (__CFStringEncodingGetCanonicalName(a1, __str, 60LL)) {
      return (const char *)ucnv_getAlias();
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t __CFStringEncodingGetFromICUName(const char *a1)
{
  __endptr[1] = *(char **)MEMORY[0x1895F89C0];
  if (!strncasecmp_l(a1, "windows-", 8uLL, 0LL))
  {
    int v12 = strtol(a1 + 8, __endptr, 10);
    if (v12)
    {
      if (!*__endptr[0]) {
        return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)v12);
      }
    }
  }

  StandardName = (const char *)ucnv_getStandardName();
  if (!StandardName) {
    goto LABEL_23;
  }
  int v3 = StandardName;
  if (!strncasecmp_l(StandardName, "windows-", 8uLL, 0LL))
  {
    int v12 = strtol(v3 + 8, __endptr, 10);
    if (v12)
    {
      if (!*__endptr[0]) {
        return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)v12);
      }
    }
  }

  size_t v4 = strlen(v3);
  if (!strncasecmp_l(a1, v3, v4, 0LL) || (uint64_t result = __CFStringEncodingGetFromCanonicalName(v3), (_DWORD)result == -1))
  {
LABEL_23:
    double v6 = (const char *)ucnv_getStandardName();
    if (!v6
      || (double v7 = v6, v8 = strlen(v6), !strncasecmp_l(a1, v7, v8, 0LL))
      || (uint64_t result = __CFStringEncodingGetFromCanonicalName(v7), (_DWORD)result == -1))
    {
      char v9 = (const char *)ucnv_getStandardName();
      if (v9)
      {
        uint64_t v10 = v9;
        size_t v11 = strlen(v9);
        if (strncasecmp_l(a1, v10, v11, 0LL)) {
          return __CFStringEncodingGetFromCanonicalName(v10);
        }
      }

      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t __CFStringEncodingICUToBytes( uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, void *a8)
{
  if ((a2 & 0xFF0000) == 0) {
    goto LABEL_6;
  }
  uint64_t v15 = (void *)_CFGetTSD(7u);
  if (!v15)
  {
    uint64_t v15 = CFAllocatorAllocate(0LL, 16LL, 0LL);
    *uint64_t v15 = 0LL;
    v15[1] = 0LL;
    _CFSetTSD(7u, (uint64_t)v15, (uint64_t)__CFICUThreadDataDestructor);
  }

  if (*(unsigned __int8 *)v15 <= (BYTE2(a2) - 1)
    || (uint64_t v16 = *(void *)(v15[1] + 8LL * (BYTE2(a2) - 1))) == 0)
  {
LABEL_6:
    uint64_t v17 = ucnv_open();
    if (!v17) {
      return 3LL;
    }
    uint64_t v16 = v17;
    int v18 = HIBYTE(a2);
    if ((a2 & 0xFF000001) == 1) {
      int v18 = 63;
    }
    if (v18) {
      ucnv_setSubstChars();
    }
    else {
      ucnv_setFromUCallBack();
    }
  }

  unint64_t v20 = a3 + 2 * a4;
  if (a7)
  {
    ucnv_fromUnicode();
    if (a8) {
      *a8 = a6 - a6;
    }
  }

  else
  {
    while (a3 < v20)
      ucnv_fromUnicode();
    if (a8) {
      *a8 = 0LL;
    }
  }

  if (a5) {
    *a5 = (uint64_t)(a3 - a3) >> 1;
  }
  return __CFStringEncodingConverterReleaseICUConverter(v16, a2, 0LL);
}

uint64_t __CFStringEncodingConverterReleaseICUConverter(uint64_t a1, unsigned int a2, uint64_t a3)
{
  LODWORD(v4) = HIWORD(a2);
  if (a3 != 1 && ((a2 & 0x1000) != 0 || a3 == 2 && (a2 & 0x2000) != 0))
  {
    if ((a2 & 0xFF0000) != 0) {
      return v4 << 16;
    }
    size_t v8 = (unsigned __int8 *)_CFGetTSD(7u);
    if (!v8)
    {
      size_t v8 = (unsigned __int8 *)CFAllocatorAllocate(0LL, 16LL, 0LL);
      *(void *)size_t v8 = 0LL;
      *((void *)v8 + __postAndResetMidnight(1, 1) = 0LL;
      _CFSetTSD(7u, (uint64_t)v8, (uint64_t)__CFICUThreadDataDestructor);
    }

    size_t v4 = (void *)*((void *)v8 + 1);
    if (!v4)
    {
      size_t v11 = CFAllocatorAllocate(0LL, 80LL, 0LL);
      LOBYTE(v9) = 0;
      *((void *)v8 + __postAndResetMidnight(1, 1) = v11;
      _OWORD *v11 = 0u;
      v11[1] = 0u;
      v11[2] = 0u;
      v11[3] = 0u;
      v11[4] = 0u;
      LOBYTE(v10) = 10;
      *size_t v8 = 10;
      size_t v4 = (void *)*((void *)v8 + 1);
      goto LABEL_29;
    }

    uint64_t v9 = v8[1];
    uint64_t v10 = *v8;
    if (v9 >= v10)
    {
      if (!*v8)
      {
        uint64_t v10 = 0LL;
LABEL_28:
        unsigned __int8 v13 = v10 + 10;
        uint64_t v14 = 8 * (v10 + 10);
        size_t v4 = CFAllocatorAllocate(0LL, v14, 0LL);
        bzero(v4, v14);
        memcpy(v4, *((const void **)v8 + 1), 8LL * *v8);
        CFAllocatorDeallocate(0LL, *((void **)v8 + 1));
        *((void *)v8 + __postAndResetMidnight(1, 1) = v4;
        LOBYTE(v9) = *v8;
        LOBYTE(v10) = v13;
        *size_t v8 = v13;
        goto LABEL_29;
      }
    }

    else if (!*((void *)v4 + v9))
    {
      goto LABEL_29;
    }

    uint64_t v9 = 0LL;
    while (*((void *)v4 + v9))
    {
      if (v10 == ++v9)
      {
        CFLog(3LL, @"Per-thread streaming ID for ICU converters exhausted. Ignoring...");
        goto LABEL_26;
      }
    }

uint64_t __CFStringEncodingICUToUnicode( uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  if ((a2 & 0xFF0000) == 0) {
    goto LABEL_6;
  }
  unsigned __int8 v15 = (void *)_CFGetTSD(7u);
  if (!v15)
  {
    unsigned __int8 v15 = CFAllocatorAllocate(0LL, 16LL, 0LL);
    *unsigned __int8 v15 = 0LL;
    v15[1] = 0LL;
    _CFSetTSD(7u, (uint64_t)v15, (uint64_t)__CFICUThreadDataDestructor);
  }

  if (*(unsigned __int8 *)v15 <= (BYTE2(a2) - 1)
    || (uint64_t v16 = *(void *)(v15[1] + 8LL * (BYTE2(a2) - 1))) == 0)
  {
LABEL_6:
    uint64_t v17 = ucnv_open();
    if (!v17) {
      return 3LL;
    }
    uint64_t v16 = v17;
    int v18 = HIBYTE(a2);
    if ((a2 & 0xFF000001) == 1) {
      int v18 = 63;
    }
    if (v18) {
      ucnv_setSubstChars();
    }
    else {
      ucnv_setToUCallBack();
    }
  }

  if (a7)
  {
    ucnv_toUnicode();
    if (a8) {
      *a8 = (a6 - a6) >> 1;
    }
    goto LABEL_20;
  }

  if (a4 < 1)
  {
    if (!a8) {
      goto LABEL_20;
    }
  }

  else
  {
    do
      ucnv_toUnicode();
    while (a3 < a3 + a4);
    if (!a8) {
      goto LABEL_20;
    }
  }

  *a8 = 0LL;
LABEL_20:
  if (a5) {
    *a5 = a3 - a3;
  }
  return __CFStringEncodingConverterReleaseICUConverter(v16, a2, 0LL);
}

uint64_t __CFStringEncodingICUCharLength(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  v5[1] = *MEMORY[0x1895F89C0];
  if (__CFStringEncodingICUToUnicode(a1, a2, a3, a4, 0LL, 0LL, 0LL, v5)) {
    return 0LL;
  }
  else {
    return v5[0];
  }
}

uint64_t __CFStringEncodingICUByteLength(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  v5[1] = *MEMORY[0x1895F89C0];
  if (__CFStringEncodingICUToBytes(a1, a2, a3, a4, 0LL, 0LL, 0LL, v5)) {
    return 0LL;
  }
  else {
    return v5[0];
  }
}

_DWORD *__CFStringEncodingCreateICUEncodings(const __CFAllocator *a1, void *a2)
{
  int v4 = ucnv_countAvailable();
  if (!v4) {
    return 0LL;
  }
  uint64_t v5 = v4;
  unsigned __int8 v6 = CFAllocatorAllocate(0LL, 4LL * v4, 0LL);
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  do
  {
    AvailableName = (const char *)ucnv_getAvailableName();
    int v10 = __CFStringEncodingGetFromICUName(AvailableName);
    if (v10 != -1) {
      v6[v8++] = v10;
    }
    ++v7;
  }

  while (v5 != v7);
  if (!v8)
  {
LABEL_8:
    CFAllocatorDeallocate(a1, v6);
    uint64_t v8 = 0LL;
    unsigned __int8 v6 = 0LL;
  }

  *a2 = v8;
  return v6;
}

void __CFICUThreadDataDestructor(void *ptr)
{
  uint32_t v2 = (char *)ptr[1];
  if (v2)
  {
    if (*(_BYTE *)ptr)
    {
      int v3 = &v2[8 * *(unsigned __int8 *)ptr];
      do
      {
        v2 += 8;
        ucnv_close();
      }

      while (v2 < v3);
      uint32_t v2 = (char *)ptr[1];
    }

    CFAllocatorDeallocate(0LL, v2);
  }

  CFAllocatorDeallocate(0LL, ptr);
}

uint64_t __CFStringEncodingGetWindowsCodePage(int a1)
{
  if ((a1 & 0xF00) == 0x200) {
    return a1 + 28590;
  }
  if ((a1 & 0xF00) == 0x100)
  {
    HIDWORD(v2) = a1 - 256;
    LODWORD(v2) = a1 - 256;
    unsigned int v1 = v2 >> 26;
    if (v1 < 7) {
      return word_180D7E5D4[v1];
    }
    return 0LL;
  }

  int v4 = (__int16 *)&unk_180D7E5D2;
  unsigned int v5 = a1 & 0xFFF;
  unsigned __int8 v6 = &__CFKnownEncodingList;
  while (1)
  {
    uint64_t v7 = (char *)&v6[((char *)v4 - (char *)v6) >> 2];
    unsigned int v8 = *(unsigned __int16 *)v7;
    if (v5 == v8) {
      break;
    }
    uint64_t v9 = (unsigned __int16 *)(v7 - 2);
    int v10 = (__int16 *)(v7 + 2);
    if (v5 < v8) {
      int v4 = (__int16 *)v9;
    }
    else {
      unsigned __int8 v6 = v10;
    }
    if (v6 > v4) {
      return 0LL;
    }
  }

  return *(unsigned __int16 *)((char *)&__CFWindowsCPList + v7 - (char *)&__CFKnownEncodingList);
}

uint64_t __CFStringEncodingGetFromWindowsCodePage(int a1)
{
  v4[1] = *(const void **)MEMORY[0x1895F89C0];
  if (a1 <= 64999)
  {
    if (a1)
    {
      if (a1 == 1200)
      {
        return 256LL;
      }

      else if (a1 == 1201)
      {
        return 268435712LL;
      }

      else
      {
LABEL_12:
        if ((a1 - 28591) > 0xF)
        {
          os_unfair_lock_lock_with_options();
          if (!__CFStringEncodingGetFromWindowsCodePage_mappingTable)
          {
            uint64_t v3 = 0LL;
            __CFStringEncodingGetFromWindowsCodePage_mappingTable = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  0LL,  0LL);
            do
            {
              if (__CFWindowsCPList[v3]) {
                CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromWindowsCodePage_mappingTable,  (const void *)(unsigned __int16)__CFWindowsCPList[v3],  (const void *)(unsigned __int16)__CFKnownEncodingList[v3]);
              }
              ++v3;
            }

            while (v3 != 98);
          }

          os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringEncodingGetFromWindowsCodePage_lock);
          if (CFDictionaryGetValueIfPresent( (CFDictionaryRef)__CFStringEncodingGetFromWindowsCodePage_mappingTable,  (const void *)a1,  v4))
          {
            return LODWORD(v4[0]);
          }

          else
          {
            return 0xFFFFFFFFLL;
          }
        }

        else
        {
          return (a1 - 28078);
        }
      }
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    uint64_t result = 134217984LL;
    switch(a1)
    {
      case 65000:
        uint64_t result = 67109120LL;
        break;
      case 65001:
        return result;
      case 65005:
        uint64_t result = 201326848LL;
        break;
      case 65006:
        uint64_t result = 402653440LL;
        break;
      default:
        goto LABEL_12;
    }
  }

  return result;
}

BOOL __CFStringEncodingGetCanonicalName(int a1, char *__str, int64_t __size)
{
  unsigned int v4 = ((a1 & 0xF00u) - 256) >> 8;
  if (v4 - 3 < 2)
  {
    uint64_t v7 = (__int16 *)&unk_180D7E5D2;
    unsigned int v8 = a1 & 0xFFF;
    uint64_t v9 = &__CFKnownEncodingList;
    while (1)
    {
      int v10 = (char *)&v9[((char *)v7 - (char *)v9) >> 2];
      unsigned int v11 = *(unsigned __int16 *)v10;
      if (v8 == v11) {
        break;
      }
      int v12 = (unsigned __int16 *)(v10 - 2);
      unsigned __int8 v13 = (__int16 *)(v10 + 2);
      if (v8 < v11) {
        uint64_t v7 = (__int16 *)v12;
      }
      else {
        uint64_t v9 = v13;
      }
      if (v9 > v7) {
        return 0LL;
      }
    }

    if (v10 - (char *)&__CFKnownEncodingList != -2
      && *(__int16 *)((char *)&__CFWindowsCPList + v10 - (char *)&__CFKnownEncodingList))
    {
      if ((a1 & 0xF00) == 0x400) {
        uint64_t v14 = "cp%d";
      }
      else {
        uint64_t v14 = "windows-%d";
      }
      int v6 = snprintf( __str,  __size,  v14,  *(unsigned __int16 *)((char *)&__CFWindowsCPList + v10 - (char *)&__CFKnownEncodingList));
      return v6 < __size;
    }
  }

  else
  {
    if (v4 == 1)
    {
      int v6 = snprintf(__str, __size, "iso-8859-%u");
      return v6 < __size;
    }

    if (v4)
    {
      uint64_t v16 = (__int16 *)&unk_180D7E5D2;
      unsigned int v17 = a1 & 0xFFF;
      int v18 = &__CFKnownEncodingList;
      while (1)
      {
        uint64_t v19 = (char *)&v18[((char *)v16 - (char *)v18) >> 2];
        unsigned int v20 = *(unsigned __int16 *)v19;
        if (v17 == v20) {
          break;
        }
        unint64_t v21 = (unsigned __int16 *)(v19 - 2);
        uint64_t v22 = (__int16 *)(v19 + 2);
        if (v17 < v20) {
          uint64_t v16 = (__int16 *)v21;
        }
        else {
          int v18 = v22;
        }
        if (v18 > v16) {
          return 0LL;
        }
      }

      if (v19 - (char *)&__CFKnownEncodingList != -2
        && *(char **)((char *)__CFCanonicalNameList + 4 * (v19 - (char *)&__CFKnownEncodingList)))
      {
        int v6 = snprintf(__str, __size, "%s%s");
        return v6 < __size;
      }
    }

    else
    {
      HIDWORD(v5) = a1 - 256;
      LODWORD(v5) = a1 - 256;
      if ((v5 >> 26) <= 7)
      {
        int v6 = snprintf(__str, __size, "%s");
        return v6 < __size;
      }
    }
  }

  return 0LL;
}

uint64_t __CFStringEncodingGetFromCanonicalName(const char *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (!strncasecmp_l(a1, "iso-8859-", 9uLL, 0LL))
  {
    int v7 = strtol(a1 + 9, 0LL, 10);
    else {
      return (v7 + 512);
    }
  }

  if (!strncasecmp_l(a1, "cp", 2uLL, 0LL))
  {
    unsigned int v8 = a1 + 2;
LABEL_22:
    unsigned __int16 v9 = strtol(v8, 0LL, 10);
    return __CFStringEncodingGetFromWindowsCodePage(v9);
  }

  if (!strncasecmp_l(a1, "windows-", 8uLL, 0LL))
  {
    unsigned int v8 = a1 + 8;
    goto LABEL_22;
  }

  os_unfair_lock_lock_with_options();
  if (!__CFStringEncodingGetFromCanonicalName_mappingTable)
  {
    memset(&v10, 0, 32);
    *(_OWORD *)&v10.equal = xmmword_1899EBEF8;
    __CFStringEncodingGetFromCanonicalName_mappingTable = (uint64_t)CFDictionaryCreateMutable(0LL, 0LL, &v10, 0LL);
    CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  "utf-7",  (const void *)0x4000100);
    CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  "utf-8",  (const void *)0x8000100);
    CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  "utf-16",  (const void *)0x100);
    CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  "utf-16be",  (const void *)0x10000100);
    CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  "utf-16le",  (const void *)0x14000100);
    CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  "utf-32",  (const void *)0xC000100);
    CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  "utf-32be",  (const void *)0x18000100);
    CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  "utf-32le",  (const void *)0x1C000100);
    for (uint64_t i = 0LL; i != 98; ++i)
    {
      uint64_t v3 = __CFCanonicalNameList[i];
      if (v3) {
        CFDictionarySetValue( (CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable,  v3,  (const void *)(unsigned __int16)__CFKnownEncodingList[i]);
      }
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringEncodingGetFromCanonicalName_lock);
  uint64_t result = strncasecmp_l(a1, "macintosh", 9uLL, 0LL);
  if ((_DWORD)result)
  {
    unint64_t v5 = (const __CFDictionary *)__CFStringEncodingGetFromCanonicalName_mappingTable;
    if (strncasecmp_l(a1, "x-mac-", 6uLL, 0LL)) {
      uint64_t v6 = 0LL;
    }
    else {
      uint64_t v6 = 6LL;
    }
    LODWORD(result) = CFDictionaryGetValue(v5, &a1[v6]);
    if ((_DWORD)result) {
      return result;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

BOOL __CFCanonicalNameCompare(const char *a1, const char *a2)
{
  return strncasecmp_l(a1, a2, 0x100uLL, 0LL) == 0;
}

uint64_t __CFCanonicalNameHash(char *a1)
{
  char v1 = *a1;
  if (!*a1) {
    return 0LL;
  }
  uint64_t v2 = 0LL;
  uint64_t v3 = 1LL;
  do
  {
    v2 += v1 + 32LL * ((v1 - 65) < 0x1Au);
    char v1 = a1[v3];
    uint64_t v4 = v3 + 1;
    if (!v1) {
      break;
    }
  }

  while (v3++ < 256);
  return (v4 - 1) * v2;
}

uint64_t __CFStringEncodingGetMostCompatibleMacScript()
{
  return 0xFFFFFFFFLL;
}

const char *__CFStringEncodingGetName(int a1)
{
  if (a1 > 67109119)
  {
    if (a1 <= 268435711)
    {
      switch(a1)
      {
        case 67109120:
          return "Unicode (UTF-7)";
        case 134217984:
          return "Unicode (UTF-8)";
        case 201326848:
          return "Unicode (UTF-32)";
      }
    }

    else if (a1 > 402653439)
    {
      if (a1 == 402653440) {
        return "Unicode (UTF-32BE)";
      }
      if (a1 == 469762304) {
        return "Unicode (UTF-32LE)";
      }
    }

    else
    {
      if (a1 == 268435712) {
        return "Unicode (UTF-16BE)";
      }
      if (a1 == 335544576) {
        return "Unicode (UTF-16LE)";
      }
    }

    return 0LL;
  }

  else
  {
    switch(a1)
    {
      case 3056:
        uint64_t result = "Japanese (NTT Docomo Shift JIS)";
        break;
      case 3057:
        uint64_t result = "Japanese (KDDI Shift JIS)";
        break;
      case 3058:
        uint64_t result = "Japanese (SoftBank Shift JIS)";
        break;
      case 3059:
        uint64_t result = "Japanese (NTT Docomo ISO 2022-JP)";
        break;
      case 3060:
        uint64_t result = "Japanese (KDDI ISO 2022-JP)";
        break;
      default:
        if (a1 == 256)
        {
          uint64_t result = "Unicode (UTF-16)";
        }

        else
        {
          if (a1 != 3071) {
            return 0LL;
          }
          uint64_t result = "Non-lossy ASCII";
        }

        break;
    }
  }

  return result;
}

CFStringRef _CFPrefsCopyDescriptionOfAllSearchLists()
{
  return @"Obsolete";
}

void _CFPrefsDumpDescriptionOfAllSearchLists(const char *a1)
{
  id v2 = +[_CFXPreferences copyDefaultPreferences](&OBJC_CLASS____CFXPreferences, "copyDefaultPreferences");
  uint64_t v3 = -[_CFXPreferences copyDescriptionOfSearchLists]((uint64_t)v2);

  if (v3)
  {
    if (a1)
    {
      size_t v4 = strlen(a1);
      unint64_t v5 = CFURLCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)a1, v4, 0x8000100u, 0LL);
      if (!v5) {
        goto LABEL_9;
      }
    }

    else
    {
      uint64_t v6 = _CFProcessNameString();
      uint64_t v7 = getpid();
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      unsigned __int16 v9 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"/tmp/%@-preferences-search-lists(%d:%f).txt",  v6,  v7,  *(void *)&Current);
      if (!v9) {
        goto LABEL_9;
      }
      CFDictionaryKeyCallBacks v10 = v9;
      unint64_t v5 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 0);
      CFRelease(v10);
      if (!v5) {
        goto LABEL_9;
      }
    }

    CFIndex Length = CFStringGetLength(v3);
    CFIndex v12 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    unsigned __int8 v13 = (char *)calloc(v12, 1uLL);
    CFStringGetCString(v3, v13, v12, 0x8000100u);
    size_t v14 = strlen(v13);
    _CFWriteBytesToFile(v5, v13, v14);
    CFRelease(v5);
    free(v13);
LABEL_9:
    CFRelease(v3);
  }

uint64_t _CFPrefsSetEphemeralMultiUserEnabled(uint64_t result)
{
  eduModeOverride = result;
  return result;
}

uint64_t eduModeEnabled()
{
  return eduModeOverride;
}

__CFString *_CFPrefsCreateConfigurationFileNameFromIdentifier(CFStringRef theString)
{
  if (!theString) {
    return 0LL;
  }
  int v1 = eduModeOverride;
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, theString);
  uint64_t v3 = MutableCopy;
  if (v1) {
    size_t v4 = @"-cloud-users.defaults";
  }
  else {
    size_t v4 = @".defaults";
  }
  CFStringAppend(MutableCopy, v4);
  return v3;
}

CFURLRef _CFPrefsCopyCloudConfigurationURLFromBundle(__CFBundle *a1, const __CFString *Identifier)
{
  CFURLRef v4 = CFBundleCopyResourcesDirectoryURL(a1);
  if (!v4) {
    return 0LL;
  }
  unint64_t v5 = v4;
  if (!Identifier) {
    Identifier = CFBundleGetIdentifier(a1);
  }
  ConfigurationFileNameFromIdentifier = _CFPrefsCreateConfigurationFileNameFromIdentifier(Identifier);
  if (ConfigurationFileNameFromIdentifier)
  {
    uint64_t v7 = ConfigurationFileNameFromIdentifier;
    CFURLRef v8 = CFURLCreateCopyAppendingPathComponent( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v5,  ConfigurationFileNameFromIdentifier,  0);
    CFRelease(v7);
  }

  else
  {
    CFURLRef v8 = 0LL;
  }

  CFRelease(v5);
  return v8;
}

void sub_180B8896C(_Unwind_Exception *a1)
{
}

uint64_t _CFPrefsClientLog()
{
  if (makeLogHandles_logToken != -1) {
    dispatch_once(&makeLogHandles_logToken, &__block_literal_global_133);
  }
  return clientHandle;
}

void sub_180B88E4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state)
{
}

void sub_180B89960( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void sub_180B899B8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x180B899B0LL);
  }
  objc_terminate();
  -[CFPrefsSearchListSource addNamedVolatileSourceForIdentifier:](v2, v3);
}

void sub_180B89D28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_180B8ADA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_SYSTEM_AND_USER_CFPREFSDS(os_unfair_lock_s *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_SYSTEM_CFPREFSD(os_unfair_lock_s *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_USER_CFPREFSD(os_unfair_lock_s *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_DIRECT_CFPREFSD(os_unfair_lock_s *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

uint64_t _CFPrefsDaemonLog()
{
  if (makeLogHandles_logToken != -1) {
    dispatch_once(&makeLogHandles_logToken, &__block_literal_global_133);
  }
  return daemonHandle;
}

uint64_t generationCountFromListOfSources(uint64_t *a1, uint64_t a2, _BYTE *a3)
{
  v22[1] = *MEMORY[0x1895F89C0];
  if (a2 >= 1)
  {
    uint64_t v4 = a2;
    uint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *a1;
      if (*(_BYTE *)(*a1 + 56))
      {
        CFURLRef v8 = *(const __CFArray **)(v7 + 80);
        if (v8)
        {
          CFIndex Count = CFArrayGetCount(v8);
          if (Count >= 1)
          {
            CFIndex v11 = Count;
            MEMORY[0x1895F8858](Count, v10);
            unsigned __int8 v13 = (const void **)((char *)v22 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL));
            v23.CFIndex location = 0LL;
            v23.CFIndex length = v11;
            CFArrayGetValues(*(CFArrayRef *)(v7 + 80), v23, v13);
            v6 += generationCountFromListOfSources(v13, v11, a3);
          }
        }

        goto LABEL_13;
      }

      size_t v14 = (unsigned int *)atomic_load((unint64_t *)(v7 + 40));
      if (!v14) {
        break;
      }
      unsigned int v15 = atomic_load(v14);
      unsigned int v16 = atomic_load((unsigned int *)&sentinelGeneration);
      if (v15 == v16)
      {
        unint64_t v17 = atomic_load((unint64_t *)(v7 + 32));
        v6 += v17;
      }

      else
      {
        unsigned int v19 = atomic_load((unsigned int *)(v7 + 48));
        unint64_t v20 = atomic_load((unint64_t *)(v7 + 32));
        v6 += v20;
        if (v15 != v19) {
          goto LABEL_12;
        }
      }

void sub_180B8BD4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void pendingKVODestructor()
{
  qword_18C539A70 = (uint64_t)"Unexpected pending notifications upon thread exit";
  abort();
}

void sub_180B8C754(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t notifySearchListOfRemoteChangesCallback(uint64_t a1, void *a2, uint64_t a3)
{
  return [a2 handleChangeNotificationForDomainIdentifier:a3 isRemote:1];
}

void sub_180B8CBA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void sub_180B8D16C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180B8D66C(_Unwind_Exception *a1)
{
}

void *copyDescriptionApplier(uint64_t a1, void *a2, __CFString *a3)
{
  unint64_t v5 = (void *)_CFAutoreleasePoolPush();
  CFStringAppend(a3, @"\n*********\n");
  uint64_t v6 = (const __CFString *)[a2 description];
  if (v6) {
    CFStringAppend(a3, v6);
  }
  return _CFAutoreleasePoolPop(v5);
}

os_log_t __makeLogHandles_block_invoke()
{
  clientHandle = (uint64_t)os_log_create("com.apple.defaults", "User Defaults");
  os_log_t result = os_log_create("com.apple.defaults", "cfprefsd");
  daemonHandle = (uint64_t)result;
  return result;
}

void OUTLINED_FUNCTION_0_27(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

  ;
}

uint64_t OUTLINED_FUNCTION_0_28(objc_class *a1)
{
  return __CFFullMethodName(a1, v2, v1);
}

uint64_t OUTLINED_FUNCTION_1_19(uint64_t a1, const __CFString *a2)
{
  return _CFThrowFormattedException(v2, a2);
}

void __CFMakeNSBlockClasses()
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (objc_lookUpClass("__NSStackBlock__"))
  {
    qos_class_t v0 = (objc_class *)objc_opt_class();
    int v1 = objc_lookUpClass("__NSStackBlock__");
    class_setSuperclass(v1, v0);
    uint64_t v2 = objc_lookUpClass("__NSMallocBlock__");
    class_setSuperclass(v2, v0);
    uint64_t v3 = objc_lookUpClass("__NSAutoBlock__");
    class_setSuperclass(v3, v0);
    uint64_t v4 = objc_lookUpClass("__NSGlobalBlock__");
    class_setSuperclass(v4, v0);
  }

  else
  {
    objc_lookUpClass("__NSStackBlock");
    unint64_t v5 = (objc_class *)MEMORY[0x1895F87A8];
    objc_initializeClassPair();
    objc_lookUpClass("__NSMallocBlock");
    uint64_t v6 = (objc_class *)MEMORY[0x1895F8798];
    objc_initializeClassPair();
    objc_lookUpClass("__NSAutoBlock");
    uint64_t v7 = (objc_class *)MEMORY[0x1895F8780];
    objc_initializeClassPair();
    objc_lookUpClass("__NSFinalizingBlock");
    CFURLRef v8 = (objc_class *)MEMORY[0x1895F8788];
    objc_initializeClassPair();
    objc_lookUpClass("__NSGlobalBlock");
    unsigned __int16 v9 = (objc_class *)MEMORY[0x1895F8790];
    objc_initializeClassPair();
    objc_lookUpClass("__NSBlockVariable");
    uint64_t v10 = (objc_class *)MEMORY[0x1895F87B0];
    objc_initializeClassPair();
    objc_registerClassPair(v5);
    objc_registerClassPair(v6);
    objc_registerClassPair(v7);
    objc_registerClassPair(v8);
    objc_registerClassPair(v9);
    objc_registerClassPair(v10);
  }

  Block_callbacks_RR v11 = *(Block_callbacks_RR *)ymmword_1899ECA30;
  _Block_use_RR2(&v11);
}

void NSMoribundCache_invalidAccess()
{
  if (NSMoribundCache_invalidAccess_oGuard != -1) {
    dispatch_once(&NSMoribundCache_invalidAccess_oGuard, &__block_literal_global_34);
  }
}

BOOL __NSCacheKeyEqual(const void *a1, const void *a2)
{
  return CFEqual(a1, a2) != 0;
}

CFTypeRef __NSCacheKeyRetain(const void *a1, void *a2)
{
  CFTypeRef result = CFRetain(a1);
  *a2 = result;
  return result;
}

void __NSCacheValueRelease(void *cf, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 28))
  {
    if (dyld_program_sdk_at_least() && *(_BYTE *)(a2 + 27))
    {
      if (__NSCacheValueRelease_oGuard != -1) {
        dispatch_once(&__NSCacheValueRelease_oGuard, &__block_literal_global_120);
      }
      uint64_t v4 = *(void **)(a2 + 8);
      uint64_t v5 = __NSCacheValueRelease_oMoribundCache;
    }

    else
    {
      uint64_t v4 = *(void **)(a2 + 8);
      uint64_t v5 = a2;
    }

    __NSCacheCallDelegateWillEvictObjectCallbackWithValue(v4, v5, (uint64_t)cf);
  }

  if (*(_BYTE *)(a2 + 24) != 1
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0)
  {
    [cf discardContentIfPossible];
  }

  CFRelease(cf);
}

void sub_180B8EF88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void __NSCheckReentrancy(objc_class *a1, const char *a2)
{
  if ((objc_class *)_CFGetTSD(3u) == a1)
  {
    uint64_t v4 = __CFExceptionProem(a1, a2);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@: invalid re-entrancy into cache %p",  v4,  a1);
    uint64_t v5 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
    objc_exception_throw(v5);
    -[NSCache setObject:forKey:cost:](v6, v7, v8, v9, v10);
  }

void __NSCacheApplicationDidEnterBackgroundCallBack(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = a2;
  if (a2[24] != 255) {
    cache_remove_with_block();
  }
}

void sub_180B8F618(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x180B8F5DCLL);
  }

  _Unwind_Resume(exception_object);
}

uint64_t _allObjectsInvokeFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t __NSCacheCallDelegateWillEvictObjectCallbackWithValue(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = _CFGetTSD(3u);
  _CFSetTSD(3u, a2, 0LL);
  [a1 cache:a2 willEvictObject:a3];
  return _CFSetTSD(3u, v6, 0LL);
}

uint64_t __CFBasicHashGetCallbacks@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *(void *)(a1 + 24);
  unint64_t v2 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(CFBasicHashCallBackPtrs[(v3 >> 39) & 0x1F] + 8 * ((v3 >> 34) & 0x1F));
  uint64_t v5 = *(void *)(CFBasicHashCallBackPtrs[((v3 >> 24) >> 5) & 0x1F] + 8 * ((v3 >> 24) & 0x1F));
  uint64_t v6 = *(void *)(*(uint64_t *)((char *)CFBasicHashCallBackPtrs + (HIBYTE(v3) & 0xF8)) + 8 * ((v3 >> 54) & 0x1F));
  uint64_t v7 = *(void *)(CFBasicHashCallBackPtrs[(v3 >> 49) & 0x1F] + 8 * ((v3 >> 44) & 0x1F));
  uint64_t v8 = *(void *)(CFBasicHashCallBackPtrs[((v2 >> 34) >> 5) & 0x1F] + 8 * ((v2 >> 34) & 0x1F));
  uint64_t v9 = *(void *)(CFBasicHashCallBackPtrs[((v2 >> 24) >> 5) & 0x1F] + 8 * ((v2 >> 24) & 0x1F));
  uint64_t result = (v2 >> 44) & 0x1F;
  uint64_t v11 = *(void *)(CFBasicHashCallBackPtrs[((v2 >> 44) >> 5) & 0x1F] + 8 * result);
  *a2 = v4;
  a2[1] = v5;
  uint64_t v12 = CFBasicHashCallBackPtrs[(v2 >> 54) >> 5];
  a2[2] = v6;
  a2[3] = v7;
  uint64_t v13 = *(void *)(v12 + 8 * ((v2 >> 54) & 0x1F));
  uint64_t v14 = *(void *)(CFBasicHashCallBackPtrs[((v2 >> 14) >> 5) & 0x1F] + 8 * ((v2 >> 14) & 0x1F));
  a2[4] = v8;
  a2[5] = v9;
  uint64_t v15 = CFBasicHashCallBackPtrs[((v2 >> 4) >> 5) & 0x1F];
  a2[6] = v11;
  a2[7] = v13;
  uint64_t v16 = *(void *)(v15 + 8 * ((v2 >> 4) & 0x1F));
  a2[8] = v14;
  a2[9] = v16;
  return result;
}

uint64_t CFBasicHashHasStrongValues()
{
  return 0LL;
}

uint64_t CFBasicHashHasStrongKeys()
{
  return 0LL;
}

uint64_t CFBasicHashGetNumBuckets(uint64_t a1)
{
  return __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
}

uint64_t CFBasicHashGetCapacity(uint64_t a1)
{
  return __CFBasicHashTableCapacities[*(unsigned __int8 *)(a1 + 26)];
}

uint64_t CFBasicHashGetBucket@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = a2;
  uint64_t result = *(void *)(*(void *)(a1 + 40) + 8 * a2);
  if ((unint64_t)(result - 1) >= 0xFFFFFFFFFFFFFFFELL)
  {
    a3[1] = 0LL;
    a3[2] = 0LL;
    a3[3] = 0LL;
    return result;
  }

  unint64_t v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 0x18) != 0) {
    __asm { BR              X13 }
  }

  uint64_t v7 = -1LL;
  if (result != 2780474809LL) {
    uint64_t v7 = result;
  }
  if (result == 2814029233LL) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = v7;
  }
  a3[2] = v8;
  a3[3] = 1LL;
  if ((v6 & 4) != 0)
  {
    uint64_t result = *(void *)(*(void *)(a1 + 8 * ((v6 >> 2) & 1) + 40) + 8 * a2);
LABEL_16:
    if (result == 2814029233LL)
    {
      uint64_t result = 0LL;
    }

    else if (result == 2780474809LL)
    {
      uint64_t result = -1LL;
    }

    goto LABEL_23;
  }

  if ((v6 & 0x8000) == 0) {
    goto LABEL_16;
  }
  if (result == 2814029233LL)
  {
    uint64_t result = 0LL;
  }

  else if (result == 2780474809LL)
  {
    uint64_t result = -1LL;
  }

  uint64_t v9 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 32) >> 54) >> 5]
                                         + 8 * ((*(void *)(a1 + 32) >> 54) & 0x1FLL));
  if (v9) {
    uint64_t result = v9(result);
  }
LABEL_23:
  a3[1] = result;
  return result;
}

uint64_t CFBasicHashFindBucket@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  BOOL v3 = a2 == 2814029233 || a2 == 2780474809;
  if (v3 || !*(_BYTE *)(a1 + 26))
  {
    *(_OWORD *)a3 = xmmword_180D7EA48;
    *((_OWORD *)a3 + __postAndResetMidnight(1, 1) = unk_180D7EA58;
    return a1;
  }

  int v4 = *(_WORD *)(a1 + 18) & 3;
  if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
  {
    switch(v4)
    {
      case 3:
        return ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, a3);
      case 2:
        return ___CFBasicHashFindBucket_Double_Indirect(a1, a2, a3);
      case 1:
        return ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, a3);
    }
  }

  else
  {
    switch(v4)
    {
      case 3:
        return ___CFBasicHashFindBucket_Exponential(a1, a2, a3);
      case 2:
        return ___CFBasicHashFindBucket_Double(a1, a2, a3);
      case 1:
        return ___CFBasicHashFindBucket_Linear(a1, a2, a3);
    }
  }

  __break(1u);
  return a1;
}

uint64_t CFBasicHashSuppressRC(uint64_t result)
{
  *(void *)(result + 32) |= 2uLL;
  return result;
}

uint64_t CFBasicHashUnsuppressRC(uint64_t result)
{
  *(void *)(result + 32) &= ~2uLL;
  return result;
}

unint64_t CFBasicHashGetFlags(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 18);
  if ((v1 & 0x18) != 0) {
    return (unsigned __int16)(*(__int128 *)(a1 + 24) >> 51) & 0x8000 | (unint64_t)(((v1 & 3) << 13) | (v1 >> 2) & 1) | 2;
  }
  else {
    return (unsigned __int16)(*(__int128 *)(a1 + 24) >> 51) & 0x8000 | (unint64_t)(((v1 & 3) << 13) | (v1 >> 2) & 1);
  }
}

uint64_t CFBasicHashGetCount(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 18);
  if ((v1 & 0x18) == 0) {
    return *(unsigned int *)(a1 + 20);
  }
  return ((uint64_t (*)(void))((char *)&loc_180B8FC38 + 4 * byte_180D7E5F4[(v1 >> 5) & 3]))(0LL);
}

uint64_t CFBasicHashGetUsedBucketCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t CFBasicHashGetCountOfKey(uint64_t result, unint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  BOOL v2 = a2 == 2780474809 || a2 == 2814029233;
  if (v2 || !*(_DWORD *)(result + 20)) {
    return 0LL;
  }
  if (!*(_BYTE *)(result + 26))
  {
    __int128 v4 = xmmword_180D7EA48;
    __int128 v5 = unk_180D7EA58;
    return *((void *)&v5 + 1);
  }

  int v3 = *(_WORD *)(result + 18) & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v4);
        return *((void *)&v5 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v4);
        return *((void *)&v5 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v4);
        return *((void *)&v5 + 1);
    }

uint64_t CFBasicHashGetCountOfValue(uint64_t result, unint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a2 == 2814029233 || !*(_DWORD *)(result + 20)) {
    return 0LL;
  }
  __int16 v2 = *(_WORD *)(result + 18);
  if ((v2 & 4) != 0)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = &v6;
    uint64_t v8 = 0x2020000000LL;
    uint64_t v9 = 0LL;
    v5[0] = MEMORY[0x1895F87A8];
    v5[1] = 3221225472LL;
    void v5[2] = __CFBasicHashGetCountOfValue_block_invoke;
    void v5[3] = &unk_1899ECB08;
    v5[5] = a2;
    v5[6] = result;
    v5[4] = &v6;
    CFBasicHashApply(result, (uint64_t)v5);
    uint64_t v4 = v7[3];
    _Block_object_dispose(&v6, 8);
    return v4;
  }

  if (!*(_BYTE *)(result + 26))
  {
    __int128 v10 = xmmword_180D7EA48;
    __int128 v11 = unk_180D7EA58;
    return *((void *)&v11 + 1);
  }

  int v3 = v2 & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
    }
  }

  else
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v10);
        return *((void *)&v11 + 1);
    }
  }

  __break(1u);
  return result;
}

void sub_180B8FF10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t CFBasicHashApply(uint64_t result, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(unsigned int *)(result + 20);
  uint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)];
  if ((_DWORD)v2) {
    BOOL v4 = v3 < 1;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v6 = result;
    uint64_t v7 = 1LL;
    do
    {
      uint64_t result = CFBasicHashGetBucket(v6, v7 - 1, &v11);
      if (*((void *)&v12 + 1))
      {
        uint64_t v8 = *(uint64_t (**)(uint64_t, _OWORD *))(a2 + 16);
        v10[0] = v11;
        v10[1] = v12;
        uint64_t result = v8(a2, v10);
        if (!(_DWORD)result) {
          return result;
        }
        v2 -= (_DWORD)result != 0;
      }
    }

    while (v2 >= 1 && v7++ < v3);
  }

  return result;
}

uint64_t __CFBasicHashGetCountOfValue_block_invoke(void *a1, uint64_t a2)
{
  if (a1[5] == *(void *)(a2 + 16)
    || (BOOL v4 = *(unsigned int (**)(void))(CFBasicHashCallBackPtrs[((*(void *)(a1[6] + 32LL) >> 34) >> 5) & 0x1F]
                                      + 8 * ((*(void *)(a1[6] + 32LL) >> 34) & 0x1FLL))) != 0LL
    && v4())
  {
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) += *(void *)(a2 + 24);
  }

  return 1LL;
}

uint64_t CFBasicHashesAreEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t Count = CFBasicHashGetCount(a1);
  if (Count != CFBasicHashGetCount(a2)) {
    return 0LL;
  }
  uint64_t v5 = 1LL;
  if (Count)
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = &v8;
    uint64_t v10 = 0x2020000000LL;
    char v11 = 1;
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = __CFBasicHashesAreEqual_block_invoke;
    v7[3] = &unk_1899ECB08;
    v7[4] = &v8;
    v7[5] = a2;
    v7[6] = a1;
    CFBasicHashApply(a1, (uint64_t)v7);
    uint64_t v5 = *((unsigned __int8 *)v9 + 24);
    _Block_object_dispose(&v8, 8);
  }

  return v5;
}

void sub_180B9017C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t __CFBasicHashesAreEqual_block_invoke(void *a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uint64_t result = a1[5];
  if (!*(_BYTE *)(result + 26))
  {
    __int128 v10 = xmmword_180D7EA48;
    __int128 v11 = unk_180D7EA58;
    goto LABEL_16;
  }

  unint64_t v5 = a2[1];
  int v6 = *(_WORD *)(result + 18) & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v6)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, v5, (uint64_t *)&v10);
        goto LABEL_16;
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, v5, (uint64_t *)&v10);
        goto LABEL_16;
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, v5, (uint64_t *)&v10);
        goto LABEL_16;
    }

uint64_t CFBasicHashApplyIndexed(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a3 < 0) {
    goto LABEL_8;
  }
  uint64_t v4 = a3;
  if (!a3) {
    return result;
  }
  uint64_t v5 = a2;
  uint64_t v6 = result;
  if (__CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)] < a2 + a3) {
LABEL_8:
  }
    __break(1u);
  do
  {
    uint64_t result = CFBasicHashGetBucket(v6, v5, &v10);
    if (*((void *)&v11 + 1))
    {
      uint64_t v8 = *(uint64_t (**)(uint64_t, _OWORD *))(a4 + 16);
      v9[0] = v10;
      v9[1] = v11;
      uint64_t result = v8(a4, v9);
      if (!(_DWORD)result) {
        break;
      }
    }

    ++v5;
    --v4;
  }

  while (v4);
  return result;
}

uint64_t CFBasicHashGetElements(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(unsigned int *)(result + 20);
  uint64_t v5 = __CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)];
  if ((_DWORD)v4) {
    BOOL v6 = v5 < 1;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6 && a2 >= 1)
  {
    uint64_t v11 = result;
    uint64_t v12 = 0LL;
    uint64_t v13 = 0LL;
    do
    {
      uint64_t result = CFBasicHashGetBucket(v11, v12, v18);
      if (v19)
      {
        --v4;
        if (v13 < a2)
        {
          uint64_t v15 = v18[1];
          uint64_t v14 = v18[2];
          uint64_t v16 = v19 - 1;
          do
          {
            if (a3) {
              *(void *)(a3 + 8 * v13) = v14;
            }
            if (a4) {
              *(void *)(a4 + 8 * v13) = v15;
            }
            ++v13;
            BOOL v17 = v16-- != 0;
          }

          while (v17 && v13 < a2);
        }
      }

      if (v4 < 1) {
        break;
      }
      if (++v12 >= v5) {
        break;
      }
    }

    while (v13 < a2);
  }

  return result;
}

uint64_t __CFBasicHashFastEnumeration(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  v14[4] = *MEMORY[0x1895F89C0];
  uint64_t v7 = *a2;
  if (!*a2) {
    a2[2] = a1 + 16;
  }
  a2[1] = a3;
  uint64_t v8 = *(unsigned int *)(a1 + 20);
  uint64_t v9 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  if ((_DWORD)v8) {
    BOOL v10 = v7 < v9;
  }
  else {
    BOOL v10 = 0;
  }
  uint64_t v11 = 0LL;
  if (v10 && a4 >= 1)
  {
    do
    {
      CFBasicHashGetBucket(a1, v7, v14);
      if (v14[3])
      {
        *(void *)(a2[1] + 8 * v11++) = v14[1];
        --v8;
      }

      ++*a2;
      if (v8 < 1) {
        break;
      }
      if (++v7 >= v9) {
        break;
      }
    }

    while (v11 < a4);
  }

  return v11;
}

void CFBasicHashSetCapacity(uint64_t a1, uint64_t a2)
{
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0)
  {
    __break(1u);
  }

  else
  {
    uint64_t v3 = *(unsigned int *)(a1 + 20);
    BOOL v4 = a2 <= v3;
    uint64_t v5 = a2 - v3;
    if (!v4)
    {
      ++*(_WORD *)(a1 + 16);
      __CFBasicHashRehash(a1, v5);
    }
  }

void __CFBasicHashRehash(uint64_t cf, uint64_t a2)
{
  unint64_t v5 = BYTE2(*(void *)(cf + 24));
  unint64_t v6 = v5;
  if (!a2) {
    goto LABEL_9;
  }
  uint64_t v7 = 0LL;
  unint64_t v2 = *(void *)(cf + 32);
  uint64_t v3 = (uint64_t *)(a2 & ~(a2 >> 63));
  do
  {
    ++v7;
  }

  while (v7 != 64);
  do
  {
    while (1)
    {
      do
      {
        while (1)
        {
          do
          {
            while (1)
            {
LABEL_5:
              __break(1u);
LABEL_6:
              unint64_t v2 = ((v2 >> 2) & 1) + v7;
              else {
                unint64_t v6 = v7;
              }
LABEL_9:
              uint64_t v8 = __CFBasicHashTableSizes[v6];
              uint64_t v9 = __CFBasicHashTableSizes[v5];
              if (v8 < 1)
              {
                uint64_t v11 = 0LL;
                uint64_t v12 = 0LL;
LABEL_32:
                uint64_t v19 = 0LL;
                goto LABEL_37;
              }

              BOOL v10 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
              uint64_t v11 = CFAllocatorAllocate((CFAllocatorRef)v10, 8 * v8, 1uLL);
              if (v11) {
                goto LABEL_17;
              }
            }

            uint64_t v13 = CFAllocatorAllocate((CFAllocatorRef)v10, 8 * v8, 0LL);
          }

          while (!v13);
          uint64_t v11 = v13;
          bzero(v13, 8 * v8);
LABEL_17:
          if (__CFOASafe) {
            __CFSetLastAllocationEventName();
          }
          if ((*(_WORD *)(cf + 18) & 4) == 0)
          {
            uint64_t v12 = 0LL;
            goto LABEL_28;
          }

          uint64_t v14 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
          uint64_t v12 = CFAllocatorAllocate((CFAllocatorRef)v14, 8 * v8, 1uLL);
          if (v12) {
            goto LABEL_26;
          }
        }

        uint64_t v15 = CFAllocatorAllocate((CFAllocatorRef)v14, 8 * v8, 0LL);
      }

      while (!v15);
      uint64_t v12 = v15;
      bzero(v15, 8 * v8);
LABEL_26:
      if (__CFOASafe) {
        __CFSetLastAllocationEventName();
      }
LABEL_28:
      unint64_t v16 = *(unsigned __int16 *)(cf + 18);
      if ((v16 & 0x18) == 0) {
        goto LABEL_32;
      }
      size_t v17 = v8 << ((v16 >> 5) & 3);
      unint64_t v18 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
      uint64_t v19 = CFAllocatorAllocate((CFAllocatorRef)v18, v17, 1uLL);
      if (v19) {
        goto LABEL_35;
      }
    }

    uint64_t v20 = CFAllocatorAllocate((CFAllocatorRef)v18, v17, 0LL);
  }

  while (!v20);
  uint64_t v19 = v20;
  bzero(v20, v17);
LABEL_35:
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
LABEL_37:
  *(void *)(cf + 24) = *(void *)(cf + 24) & 0xFFFFFFFFFF000000LL | ((unint64_t)v6 << 16);
  unint64_t v21 = *(void **)(cf + 40);
  *(void *)(cf + 40) = v11;
  unint64_t v22 = *(unsigned __int16 *)(cf + 18);
  if ((v22 & 4) != 0)
  {
    int v24 = (char *)(cf + 8 * ((v22 >> 2) & 1));
    CFRange v23 = (void *)*((void *)v24 + 5);
    *((void *)v24 + 5) = v12;
  }

  else
  {
    CFRange v23 = 0LL;
  }

  if ((v22 & 0x18) != 0)
  {
    uint64_t v25 = (char *)(cf + (v22 & 0x18));
    ptr = (void *)*((void *)v25 + 5);
    *((void *)v25 + 5) = v19;
  }

  else
  {
    ptr = 0LL;
  }

  if (v9 >= 1)
  {
    uint64_t v26 = 0LL;
    if (v19) {
      BOOL v27 = ptr == 0LL;
    }
    else {
      BOOL v27 = 1;
    }
    int v28 = !v27;
    int v53 = v28;
    do
    {
      uint64_t v29 = v21[v26];
      if ((unint64_t)(v29 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v29 == 2814029233LL) {
          uint64_t v29 = 0LL;
        }
        if (v29 == 2780474809LL) {
          uint64_t v30 = -1LL;
        }
        else {
          uint64_t v30 = v29;
        }
        unint64_t v31 = v30;
        if (v23)
        {
          unint64_t v32 = v23[v26];
          if (v32 == 2814029233) {
            unint64_t v32 = 0LL;
          }
          if (v32 == 2780474809) {
            unint64_t v31 = -1LL;
          }
          else {
            unint64_t v31 = v32;
          }
        }

        uint64_t v33 = *(void *)(cf + 24);
        if (*(__int16 *)(cf + 18) < 0)
        {
          unint64_t v34 = *(void *)(cf + 32);
          uint64_t v3 = CFBasicHashCallBackPtrs;
          unint64_t v2 = CFBasicHashCallBackPtrs[(v34 >> 54) >> 5];
          int v35 = *(uint64_t (**)(uint64_t))(v2 + 8 * ((v34 >> 54) & 0x1F));
          if (v35)
          {
            unint64_t v31 = v35(v30);
            uint64_t v33 = *(void *)(cf + 24);
          }

          else
          {
            unint64_t v31 = v30;
          }
        }

        if ((v33 & 0xFF0000) != 0)
        {
          uint64_t v7 = *(unsigned __int16 *)(cf + 18);
          unint64_t v5 = v7 & 3;
          if ((v7 & 0x8000) != 0)
          {
            switch((_DWORD)v5)
            {
              case 3:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision( cf,  v31);
                break;
              case 2:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(cf, v31);
                break;
              case 1:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(cf, v31);
                break;
              default:
                goto LABEL_5;
            }
          }

          else
          {
            switch((_DWORD)v5)
            {
              case 3:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_NoCollision(cf, v31);
                break;
              case 2:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_NoCollision(cf, v31);
                break;
              case 1:
                unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_NoCollision(cf, v31);
                break;
              default:
                goto LABEL_5;
            }
          }

          uint64_t v37 = Bucket_Exponential_Indirect_NoCollision;
        }

        else
        {
          uint64_t v37 = -1LL;
        }

        uint64_t v38 = *(void *)(cf + 40);
        uint64_t v39 = *(void *)(v38 + 8 * v37);
        if (v30) {
          unint64_t v2 = v30;
        }
        else {
          unint64_t v2 = 2814029233LL;
        }
        if (v2 == -1LL) {
          unint64_t v2 = 2780474809LL;
        }
        *(void *)(v38 + 8 * v37) = v2;
        uint64_t v7 = v39 + 1;
        if ((unint64_t)(v39 + 1) >= 2)
        {
          if (v39 == 2814029233LL) {
            uint64_t v39 = 0LL;
          }
          if (v39 == 2780474809LL) {
            uint64_t v40 = -1LL;
          }
          else {
            uint64_t v40 = v39;
          }
          if ((*(void *)(cf + 32) & 2) == 0)
          {
            unint64_t v41 = *(void *)(cf + 24);
            unint64_t v2 = (unint64_t)CFBasicHashCallBackPtrs;
            uint64_t v7 = *(uint64_t *)((char *)CFBasicHashCallBackPtrs + (HIBYTE(v41) & 0xF8));
            uint64_t v42 = *(void (**)(const CFAllocatorRef, uint64_t))(v7 + 8 * ((v41 >> 54) & 0x1F));
            if (v42)
            {
              uint64_t v43 = &kCFAllocatorSystemDefault;
              if ((cf & 0x8000000000000000LL) == 0)
              {
                char v44 = atomic_load((unint64_t *)(cf + 8));
                BOOL v27 = (v44 & 0x80) == 0;
                uint64_t v43 = (const CFAllocatorRef *)(cf - 16);
                if (!v27) {
                  uint64_t v43 = &kCFAllocatorSystemDefault;
                }
              }

              v42(*v43, v40);
            }
          }
        }

        if (v23)
        {
          unint64_t v5 = *(unsigned __int16 *)(cf + 18);
          if ((v5 & 4) == 0) {
            goto LABEL_5;
          }
          uint64_t v45 = *(void *)(cf + 8 * ((v5 >> 2) & 1) + 40);
          uint64_t v46 = *(void *)(v45 + 8 * v37);
          if (v31) {
            unint64_t v2 = v31;
          }
          else {
            unint64_t v2 = 2814029233LL;
          }
          if (v2 == -1LL) {
            unint64_t v2 = 2780474809LL;
          }
          *(void *)(v45 + 8 * v37) = v2;
          if ((unint64_t)(v46 + 1) >= 2)
          {
            if (v46 == 2814029233LL) {
              uint64_t v46 = 0LL;
            }
            if (v46 == 2780474809LL) {
              uint64_t v47 = -1LL;
            }
            else {
              uint64_t v47 = v46;
            }
            if ((*(void *)(cf + 32) & 2) == 0)
            {
              unint64_t v2 = (unint64_t)CFBasicHashCallBackPtrs;
              uint64_t v48 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(cf + 24) >> 49) & 0x1FLL]
                                                                         + 8 * ((*(void *)(cf + 24) >> 44) & 0x1FLL));
              if (v48)
              {
                uint64_t v49 = &kCFAllocatorSystemDefault;
                if ((cf & 0x8000000000000000LL) == 0)
                {
                  char v50 = atomic_load((unint64_t *)(cf + 8));
                  BOOL v27 = (v50 & 0x80) == 0;
                  uint64_t v49 = (const CFAllocatorRef *)(cf - 16);
                  if (!v27) {
                    uint64_t v49 = &kCFAllocatorSystemDefault;
                  }
                }

                v48(*v49, v47);
              }
            }
          }
        }

        if (v53) {
          __asm { BR              X9 }
        }
      }

      ++v26;
    }

    while (v9 != v26);
  }

  uint64_t v51 = CFGetAllocator((CFTypeRef)cf);
  CFAllocatorDeallocate(v51, v21);
  CFAllocatorDeallocate(v51, v23);
  CFAllocatorDeallocate(v51, ptr);
  CFAllocatorDeallocate(v51, 0LL);
}

uint64_t CFBasicHashAddValue(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  char v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809LL || a3 == 2814029233LL) {
    goto LABEL_28;
  }
  if (*(_BYTE *)(a1 + 26))
  {
    int v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        default:
          goto LABEL_28;
      }
    }

    else if (v7 == 3)
    {
      ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v10);
    }

    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v10);
          goto LABEL_21;
        }

void __CFBasicHashIncSlotCount(uint64_t a1)
{
  __asm { BR              X9 }

void sub_180B90E30( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  unsigned int v23 = *(unsigned __int8 *)(v22 + v20);
  if (v23 > 0x7E)
  {
    CFGetAllocator(v21);
    __asm { BR              X10 }
  }

  *(_BYTE *)(v22 + v20) = v23 + 1;
}

void __CFBasicHashAddValue(uint64_t cf, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(cf + 24);
  if (__CFBasicHashTableCapacities[BYTE2(v7)] >= (uint64_t)(*(_DWORD *)(cf + 20) + 1))
  {
    uint64_t v10 = a2;
    if (*(void *)(*(void *)(cf + 40) + 8 * a2) == -1LL)
    {
      uint64_t v11 = *(void *)(cf + 32);
      *(void *)(cf + 24) = v7 & 0xFFFFFFFFFFFF0000LL | (unsigned __int16)(v7 - 1);
      *(void *)(cf + 32) = v11;
    }

    goto LABEL_20;
  }

  __CFBasicHashRehash(cf, 1LL);
  if (!*(_BYTE *)(cf + 26))
  {
    uint64_t v10 = -1LL;
    goto LABEL_20;
  }

  int v8 = *(_WORD *)(cf + 18) & 3;
  if ((*(_WORD *)(cf + 18) & 0x8000) != 0)
  {
    switch(v8)
    {
      case 3:
        unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
      case 2:
        unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
      case 1:
        unint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
    }

unint64_t CFBasicHashReplaceValue(unint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  char v3 = atomic_load((unint64_t *)(result + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809LL || a3 == 2814029233LL) {
    goto LABEL_24;
  }
  uint64_t v6 = result;
  if (*(_BYTE *)(result + 26))
  {
    int v7 = *(_WORD *)(result + 18) & 3;
    if ((*(_WORD *)(result + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          uint64_t result = ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v8);
          break;
        case 2:
          uint64_t result = ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v8);
          break;
        case 1:
          uint64_t result = ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v8);
          break;
        default:
          goto LABEL_24;
      }
    }

    else if (v7 == 3)
    {
      uint64_t result = ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v8);
    }

    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          uint64_t result = ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v8);
          goto LABEL_21;
        }

uint64_t __CFBasicHashReplaceValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v7 = result;
  ++*(_WORD *)(result + 16);
  if ((*(void *)(result + 32) & 2) == 0)
  {
    __int128 v8 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(result + 24) >> 39) & 0x1FLL]
                                                                 + 8 * ((*(void *)(result + 24) >> 34) & 0x1FLL));
    if (v8)
    {
      if (result < 0)
      {
        __int128 v9 = &kCFAllocatorSystemDefault;
      }

      else
      {
        char v10 = atomic_load((unint64_t *)(result + 8));
        if (v10 < 0) {
          __int128 v9 = &kCFAllocatorSystemDefault;
        }
        else {
          __int128 v9 = (const CFAllocatorRef *)(result - 16);
        }
      }

      uint64_t result = v8(*v9, a4);
      uint64_t v4 = result;
    }
  }

  if ((*(_WORD *)(v7 + 18) & 4) != 0 && (*(void *)(v7 + 32) & 2) == 0)
  {
    uint64_t v11 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v7 + 27) >> 5) & 0x1F]
                                                                  + 8 * (*(_DWORD *)(v7 + 27) & 0x1FLL));
    if (v11)
    {
      if (v7 < 0)
      {
        uint64_t v12 = &kCFAllocatorSystemDefault;
      }

      else
      {
        char v13 = atomic_load((unint64_t *)(v7 + 8));
        if (v13 < 0) {
          uint64_t v12 = &kCFAllocatorSystemDefault;
        }
        else {
          uint64_t v12 = (const CFAllocatorRef *)(v7 - 16);
        }
      }

      uint64_t result = v11(*v12, a3);
      a3 = result;
    }
  }

  uint64_t v14 = *(void *)(v7 + 40);
  uint64_t v15 = *(void *)(v14 + 8 * a2);
  if (v4) {
    uint64_t v16 = v4;
  }
  else {
    uint64_t v16 = 2814029233LL;
  }
  if (v16 == -1) {
    uint64_t v16 = 2780474809LL;
  }
  *(void *)(v14 + 8 * a2) = v16;
  if ((unint64_t)(v15 + 1) >= 2)
  {
    if (v15 == 2814029233LL) {
      uint64_t v15 = 0LL;
    }
    if (v15 == 2780474809LL) {
      uint64_t v17 = -1LL;
    }
    else {
      uint64_t v17 = v15;
    }
    if ((*(void *)(v7 + 32) & 2) == 0)
    {
      uint64_t v18 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                                 + (HIBYTE(*(void *)(v7 + 24)) & 0xF8LL))
                                                                    + 8 * ((*(void *)(v7 + 24) >> 54) & 0x1FLL));
      if (v18)
      {
        if (v7 < 0)
        {
          uint64_t v19 = &kCFAllocatorSystemDefault;
        }

        else
        {
          char v20 = atomic_load((unint64_t *)(v7 + 8));
          if (v20 < 0) {
            uint64_t v19 = &kCFAllocatorSystemDefault;
          }
          else {
            uint64_t v19 = (const CFAllocatorRef *)(v7 - 16);
          }
        }

        uint64_t result = v18(*v19, v17);
      }
    }
  }

  unint64_t v21 = *(unsigned __int16 *)(v7 + 18);
  if ((v21 & 4) != 0)
  {
    uint64_t v22 = *(void *)(v7 + 8 * ((v21 >> 2) & 1) + 40);
    uint64_t v23 = *(void *)(v22 + 8 * a2);
    if (a3) {
      uint64_t v24 = a3;
    }
    else {
      uint64_t v24 = 2814029233LL;
    }
    if (v24 == -1) {
      uint64_t v24 = 2780474809LL;
    }
    *(void *)(v22 + 8 * a2) = v24;
    if ((unint64_t)(v23 + 1) >= 2)
    {
      if (v23 == 2814029233LL) {
        uint64_t v23 = 0LL;
      }
      if (v23 == 2780474809LL) {
        uint64_t v25 = -1LL;
      }
      else {
        uint64_t v25 = v23;
      }
      if ((*(void *)(v7 + 32) & 2) == 0)
      {
        uint64_t v26 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(v7 + 24) >> 49) & 0x1FLL]
                                                                      + 8 * ((*(void *)(v7 + 24) >> 44) & 0x1FLL));
        if (v26)
        {
          else {
            uint64_t v28 = (const CFAllocatorRef *)(v7 - 16);
          }
          return v26(*v28, v25);
        }
      }
    }
  }

  return result;
}

void CFBasicHashSetValue(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  char v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809LL || a3 == 2814029233LL) {
    goto LABEL_24;
  }
  if (*(_BYTE *)(a1 + 26))
  {
    int v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v8);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v8);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v8);
          break;
        default:
          goto LABEL_24;
      }
    }

    else if (v7 == 3)
    {
      ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v8);
    }

    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v8);
          goto LABEL_21;
        }

uint64_t CFBasicHashRemoveValue(uint64_t result, unint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  char v2 = atomic_load((unint64_t *)(result + 8));
  if ((v2 & 0x40) != 0) {
    goto LABEL_26;
  }
  unint64_t v3 = 0LL;
  if (a2 == 2780474809 || a2 == 2814029233) {
    return v3;
  }
  uint64_t v4 = result;
  if (!*(_BYTE *)(result + 26))
  {
    __int128 v7 = xmmword_180D7EA48;
    __int128 v8 = unk_180D7EA58;
    goto LABEL_20;
  }

  int v5 = *(_WORD *)(result + 18) & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v5)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v7);
        break;
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v7);
        break;
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v7);
        break;
      default:
        goto LABEL_26;
    }

void __CFBasicHashRemoveValue(uint64_t cf, uint64_t a2)
{
  uint64_t v4 = *(void *)(cf + 40);
  uint64_t v5 = *(void *)(v4 + 8 * a2);
  *(void *)(v4 + 8 * a2) = -1LL;
  if ((unint64_t)(v5 + 1) >= 2)
  {
    if (v5 == 2814029233LL) {
      uint64_t v5 = 0LL;
    }
    if (v5 == 2780474809LL) {
      uint64_t v6 = -1LL;
    }
    else {
      uint64_t v6 = v5;
    }
    if ((*(void *)(cf + 32) & 2) == 0)
    {
      __int128 v7 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                             + (HIBYTE(*(void *)(cf + 24)) & 0xF8LL))
                                                                + 8 * ((*(void *)(cf + 24) >> 54) & 0x1FLL));
      if (v7)
      {
        if (cf < 0)
        {
          __int128 v8 = &kCFAllocatorSystemDefault;
        }

        else
        {
          char v9 = atomic_load((unint64_t *)(cf + 8));
          if (v9 < 0) {
            __int128 v8 = &kCFAllocatorSystemDefault;
          }
          else {
            __int128 v8 = (const CFAllocatorRef *)(cf - 16);
          }
        }

        v7(*v8, v6);
      }
    }
  }

  unint64_t v10 = *(unsigned __int16 *)(cf + 18);
  if ((v10 & 4) != 0)
  {
    uint64_t v11 = *(void *)(cf + 8 * ((v10 >> 2) & 1) + 40);
    uint64_t v12 = *(void *)(v11 + 8 * a2);
    *(void *)(v11 + 8 * a2) = -1LL;
    if ((unint64_t)(v12 + 1) >= 2)
    {
      if (v12 == 2814029233LL) {
        uint64_t v12 = 0LL;
      }
      if (v12 == 2780474809LL) {
        uint64_t v13 = -1LL;
      }
      else {
        uint64_t v13 = v12;
      }
      if ((*(void *)(cf + 32) & 2) == 0)
      {
        uint64_t v14 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(cf + 24) >> 49) & 0x1FLL]
                                                                   + 8 * ((*(void *)(cf + 24) >> 44) & 0x1FLL));
        if (v14)
        {
          else {
            uint64_t v16 = (const CFAllocatorRef *)(cf - 16);
          }
          v14(*v16, v13);
        }
      }
    }
  }

  int v17 = *(unsigned __int16 *)(cf + 18);
  if ((v17 & 0x18) != 0) {
    __asm { BR              X11 }
  }

  unsigned int v18 = *(_DWORD *)(cf + 20) - 1;
  *(_DWORD *)(cf + 20) = v18;
  uint64_t v19 = *(void *)(cf + 24);
  uint64_t v20 = *(void *)(cf + 32);
  unsigned int v21 = BYTE2(v19);
  unint64_t v22 = v19 & 0xFFFFFFFFFFFF0000LL | (unsigned __int16)(v19 + 1);
  *(void *)(cf + 24) = v22;
  if ((v20 & 4) != 0)
  {
    if (v21 < 6) {
      goto LABEL_37;
    }
    unsigned int v23 = v21 - 5;
  }

  else
  {
    if (v21 < 3) {
      goto LABEL_37;
    }
    unsigned int v23 = v21 - 2;
  }

  if (__CFBasicHashTableCapacities[v23] > (uint64_t)v18)
  {
    uint64_t v24 = -1LL;
LABEL_45:
    __CFBasicHashRehash(cf, v24);
    return;
  }

unint64_t CFBasicHashRemoveValueAtIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0) {
    __break(1u);
  }
  CFBasicHashGetBucket(a1, a2, v8);
  unint64_t v4 = v9;
  if (v9 < 2)
  {
    if (v9 == 1) {
      __CFBasicHashRemoveValue(a1, v8[0]);
    }
  }

  else
  {
    ++*(_WORD *)(a1 + 16);
    int v5 = *(unsigned __int16 *)(a1 + 18);
    if (v4 <= 0x7FFFFFFFFFFFFFFELL && (v5 & 0x18) != 0) {
      __asm { BR              X12 }
    }
  }

  return v4;
}

void CFBasicHashRemoveAllValues(uint64_t a1)
{
  char v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 0x40) != 0)
  {
    __break(1u);
  }

  else if (*(_BYTE *)(a1 + 26))
  {
    __CFBasicHashDrain(a1);
  }

void __CFBasicHashDrain(uint64_t a1)
{
  uint64_t v2 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unint64_t v3 = 0LL;
  unint64_t v22 = CFGetAllocator((CFTypeRef)a1);
  unsigned int v23 = *(uint64_t **)(a1 + 40);
  *(void *)(a1 + 40) = 0LL;
  unint64_t v4 = *(unsigned __int16 *)(a1 + 18);
  if ((v4 & 4) != 0)
  {
    uint64_t v5 = a1 + 8 * ((v4 >> 2) & 1);
    unint64_t v3 = *(uint64_t **)(v5 + 40);
    *(void *)(v5 + 40) = 0LL;
  }

  if ((v4 & 0x18) != 0)
  {
    uint64_t v6 = a1 + (v4 & 0x18);
    ptr = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = 0LL;
  }

  else
  {
    ptr = 0LL;
  }

  ++*(_WORD *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  *(_DWORD *)(a1 + 20) = 0;
  *(void *)(a1 + 24) = v7 & 0xFFFFFFFFFF000000LL;
  if (v2 >= 1)
  {
    __int128 v8 = v23;
    unint64_t v9 = v3;
    do
    {
      uint64_t v11 = *v8++;
      uint64_t v10 = v11;
      if ((unint64_t)(v11 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v10 == 2814029233LL) {
          uint64_t v10 = 0LL;
        }
        if (v10 == 2780474809LL) {
          uint64_t v12 = -1LL;
        }
        else {
          uint64_t v12 = v10;
        }
        if ((*(void *)(a1 + 32) & 2) == 0)
        {
          uint64_t v13 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                                  + (HIBYTE(*(void *)(a1 + 24)) & 0xF8LL))
                                                                     + 8 * ((*(void *)(a1 + 24) >> 54) & 0x1FLL));
          if (v13)
          {
            uint64_t v14 = &kCFAllocatorSystemDefault;
            if ((a1 & 0x8000000000000000LL) == 0)
            {
              char v15 = atomic_load((unint64_t *)(a1 + 8));
              if (v15 < 0) {
                uint64_t v14 = &kCFAllocatorSystemDefault;
              }
              else {
                uint64_t v14 = (const CFAllocatorRef *)(a1 - 16);
              }
            }

            v13(*v14, v12);
          }
        }

        if (v3)
        {
          uint64_t v16 = *v9;
          if (*v9 == 2814029233LL) {
            uint64_t v16 = 0LL;
          }
          if (v16 == 2780474809LL) {
            uint64_t v17 = -1LL;
          }
          else {
            uint64_t v17 = v16;
          }
          if ((*(void *)(a1 + 32) & 2) == 0)
          {
            unsigned int v18 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 24) >> 49) & 0x1FLL]
                                                                       + 8 * ((*(void *)(a1 + 24) >> 44) & 0x1FLL));
            if (v18)
            {
              uint64_t v19 = &kCFAllocatorSystemDefault;
              if ((a1 & 0x8000000000000000LL) == 0)
              {
                char v20 = atomic_load((unint64_t *)(a1 + 8));
                if (v20 < 0) {
                  uint64_t v19 = &kCFAllocatorSystemDefault;
                }
                else {
                  uint64_t v19 = (const CFAllocatorRef *)(a1 - 16);
                }
              }

              v18(*v19, v17);
            }
          }
        }
      }

      ++v9;
      --v2;
    }

    while (v2);
  }

  CFAllocatorDeallocate(v22, v23);
  CFAllocatorDeallocate(v22, v3);
  CFAllocatorDeallocate(v22, ptr);
  CFAllocatorDeallocate(v22, 0LL);
}

uint64_t CFBasicHashAddIntValueAndInc(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  char v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233) {
    goto LABEL_57;
  }
  if (*(_BYTE *)(a1 + 26))
  {
    int v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        default:
          goto LABEL_57;
      }
    }

    else
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v18);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v18);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v18);
          break;
        default:
          goto LABEL_57;
      }
    }
  }

  else
  {
    __int128 v18 = xmmword_180D7EA48;
    __int128 v19 = unk_180D7EA58;
  }

  if (*((void *)&v19 + 1))
  {
    uint64_t result = 0LL;
    ++*(_WORD *)(a1 + 16);
    return result;
  }

  uint64_t v9 = *(unsigned __int8 *)(a1 + 26);
  if (__CFBasicHashTableCapacities[v9] < (uint64_t)(*(_DWORD *)(a1 + 20) + 1))
  {
    __CFBasicHashRehash(a1, 1LL);
    if (!*(_BYTE *)(a1 + 26))
    {
      uint64_t Bucket_Exponential_Indirect_NoCollision = -1LL;
      goto LABEL_39;
    }

    int v10 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v10)
      {
        case 3:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
        case 2:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
        case 1:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
      }
    }

    else
    {
      switch(v10)
      {
        case 3:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_NoCollision(a1, a2);
          goto LABEL_39;
        case 2:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_NoCollision(a1, a2);
          goto LABEL_39;
        case 1:
          uint64_t Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_NoCollision(a1, a2);
LABEL_39:
          *(void *)&__int128 v18 = Bucket_Exponential_Indirect_NoCollision;
          uint64_t v9 = *(unsigned __int8 *)(a1 + 26);
          goto LABEL_40;
      }
    }

void CFBasicHashRemoveIntValueAndDec(uint64_t a1, unint64_t a2)
{
  char v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233)
  {
    __break(1u);
  }

  else
  {
    uint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
    if (v3 >= 1)
    {
      uint64_t v4 = 0LL;
      uint64_t v5 = -1LL;
      while (1)
      {
        uint64_t v6 = *(void *)(a1 + 40);
        unint64_t v7 = *(void *)(v6 + 8 * v4);
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          if (v7 == 2780474809)
          {
            unint64_t v7 = -1LL;
LABEL_13:
            if (v7 == a2) {
              uint64_t v5 = v4;
            }
            if (v7 > a2)
            {
              uint64_t v8 = v7 - 1;
              if (!v8) {
                uint64_t v8 = 2814029233LL;
              }
              *(void *)(v6 + 8 * v4) = v8;
              ++*(_WORD *)(a1 + 16);
            }

            goto LABEL_19;
          }

          if (v7 != 2814029233) {
            goto LABEL_13;
          }
          if (!a2) {
            uint64_t v5 = v4;
          }
        }

uint64_t CFBasicHashGetSize(uint64_t a1, int a2)
{
  __int16 v2 = *(_WORD *)(a1 + 18);
  uint64_t v3 = 56LL;
  if ((v2 & 4) == 0) {
    uint64_t v3 = 48LL;
  }
  if ((v2 & 0x18) != 0) {
    uint64_t v4 = v3 + 8;
  }
  else {
    uint64_t v4 = v3;
  }
  if (a2 && (uint64_t)__CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)] >= 1)
  {
    v4 += malloc_size(*(const void **)(a1 + 40));
    unint64_t v6 = *(unsigned __int16 *)(a1 + 18);
    if ((v6 & 4) != 0)
    {
      v4 += malloc_size(*(const void **)(a1 + 8 * ((v6 >> 2) & 1) + 40));
      LODWORD(v6) = *(unsigned __int16 *)(a1 + 18);
    }

    if ((v6 & 0x18) != 0) {
      v4 += malloc_size(*(const void **)(a1 + 8LL * ((v6 >> 3) & 3) + 40));
    }
  }

  return v4;
}

__CFString *CFBasicHashCopyDescription(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL);
  char v11 = atomic_load((unint64_t *)(a1 + 8));
  if ((v11 & 0x40) != 0) {
    uint64_t v12 = "immutable";
  }
  else {
    uint64_t v12 = "mutable";
  }
  __int16 v13 = *(_WORD *)(a1 + 18);
  if ((v13 & 0x18) != 0) {
    uint64_t v14 = "multi";
  }
  else {
    uint64_t v14 = "";
  }
  if ((v13 & 4) != 0) {
    unint64_t v15 = "dict";
  }
  else {
    unint64_t v15 = "set";
  }
  uint64_t Count = CFBasicHashGetCount(a1);
  CFStringAppendFormat(Mutable, 0LL, @"%@{type = %s %s%s, count = %ld,\n", a3, v12, v14, v15, Count);
  if (a2)
  {
    CFStringAppendFormat( Mutable,  0LL,  @"%@hash cache = %s, strong values = %s, strong keys = %s, cb = %s,\n",  a3,  "no",  "no",  "no",  "custom");
    CFStringAppendFormat( Mutable,  0LL,  @"%@num bucket index = %d, num buckets = %ld, capacity = %ld, num buckets used = %u,\n",  a3,  BYTE2(*(void *)(a1 + 24)),  __CFBasicHashTableSizes[BYTE2(*(void *)(a1 + 24))],  __CFBasicHashTableCapacities[BYTE2(*(void *)(a1 + 24))],  *(unsigned int *)(a1 + 20));
    unsigned int v17 = *(unsigned __int16 *)(a1 + 18);
    if ((v17 & 0x18) != 0) {
      uint64_t v18 = (1 << ((v17 >> 5) & 3));
    }
    else {
      uint64_t v18 = 0LL;
    }
    if ((*(void *)(a1 + 32) & 8LL) != 0) {
      __int128 v19 = "yes";
    }
    else {
      __int128 v19 = "no";
    }
    CFStringAppendFormat(Mutable, 0LL, @"%@counts width = %d, finalized = %s,\n", a3, v18, v19);
    uint64_t v20 = *(unsigned __int16 *)(a1 + 16);
    uint64_t v21 = *(unsigned __int16 *)(a1 + 24);
    __int16 v22 = *(_WORD *)(a1 + 18);
    uint64_t v23 = 56LL;
    if ((v22 & 4) == 0) {
      uint64_t v23 = 48LL;
    }
    if ((v22 & 0x18) != 0) {
      uint64_t v24 = v23 + 8;
    }
    else {
      uint64_t v24 = v23;
    }
    uint64_t Size = CFBasicHashGetSize(a1, 1);
    CFStringAppendFormat( Mutable,  0LL,  @"%@num mutations = %ld, num deleted = %ld, uint64_t size = %ld, total uint64_t size = %ld,\n",  a3,  v20,  v21,  v24,  Size);
    uint64_t v26 = 0LL;
    unint64_t v27 = *(unsigned __int16 *)(a1 + 18);
    if ((v27 & 4) != 0) {
      uint64_t v26 = *(void *)(a1 + 8 * ((v27 >> 2) & 1) + 40);
    }
    if ((v27 & 0x18) != 0) {
      uint64_t v28 = *(void *)(a1 + (v27 & 0x18) + 40);
    }
    else {
      uint64_t v28 = 0LL;
    }
    CFStringAppendFormat( Mutable,  0LL,  @"%@values ptr = %p, keys ptr = %p, counts ptr = %p, hashes ptr = %p,\n",  a3,  *(void *)(a1 + 40),  v26,  v28,  0LL);
  }

  CFStringAppendFormat(Mutable, 0LL, @"%@entries =>\n", a3);
  v30[0] = MEMORY[0x1895F87A8];
  v30[1] = 3221225472LL;
  v30[2] = __CFBasicHashCopyDescription_block_invoke;
  v30[3] = &__block_descriptor_57_e15_C40__0___qQQQ_8l;
  char v31 = a5;
  v30[4] = a1;
  v30[5] = Mutable;
  v30[6] = a4;
  CFBasicHashApply(a1, (uint64_t)v30);
  CFStringAppendFormat(Mutable, 0LL, @"%@}\n", a3);
  return Mutable;
}

uint64_t __CFBasicHashCopyDescription_block_invoke(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)(a1 + 56))
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[((*(void *)(*(void *)(a1 + 32)
                                                                                               + 32LL) >> 14) >> 5) & 0x1F]
                                           + 8 * ((*(void *)(*(void *)(a1 + 32) + 32LL) >> 14) & 0x1FLL));
    if (v4) {
      CFStringRef v5 = (CFStringRef)v4(a2[2]);
    }
    else {
      CFStringRef v5 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"<%p>", a2[2]);
    }
    CFStringRef v6 = v5;
    uint64_t v7 = *(void *)(a1 + 32);
    if ((*(_WORD *)(v7 + 18) & 4) == 0) {
      goto LABEL_8;
    }
    uint64_t v9 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[((*(void *)(v7 + 32) >> 4) >> 5) & 0x1F]
                                           + 8 * ((*(void *)(v7 + 32) >> 4) & 0x1FLL));
    if (v9)
    {
      CFStringRef v10 = (CFStringRef)v9(a2[1]);
LABEL_12:
      CFStringRef v8 = v10;
      goto LABEL_13;
    }

void CFBasicHashShow(uint64_t a1)
{
  char v1 = CFBasicHashCopyDescription(a1, 1, (uint64_t)&stru_1899EF170, (uint64_t)@"\t", 0);
  CFShow(v1);
  CFRelease(v1);
}

CFStringRef __CFBasicHashCopyDescription(const void *a1)
{
  __int16 v2 = CFBasicHashCopyDescription((uint64_t)a1, 0, (uint64_t)&stru_1899EF170, (uint64_t)@"\t", 1);
  CFAllocatorRef v3 = CFGetAllocator(a1);
  CFStringRef v4 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"<CFBasicHash %p [%p]>%@",  a1,  v3,  v2);
  CFRelease(v2);
  return v4;
}

void __CFBasicHashDeallocate(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if ((v1 & 8) != 0)
  {
    __break(1u);
  }

  else
  {
    *(void *)(a1 + 24) = *(void *)(a1 + 24);
    *(void *)(a1 + 32) = v1 | 8;
    __CFBasicHashDrain(a1);
  }

uint64_t CFBasicHashGetTypeID()
{
  return 3LL;
}

uint64_t CFBasicHashCreate(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v5 = 40LL;
  if ((a2 & 1) == 0) {
    uint64_t v5 = 32LL;
  }
  if ((a2 & 2) != 0) {
    v5 += 8LL;
  }
  if ((a2 & 4) != 0) {
    uint64_t v6 = v5 + 8;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t result = _CFRuntimeCreateInstance(a1, 3LL, v6, 0LL);
  uint64_t v8 = result;
  if (!result) {
    return v8;
  }
  int v9 = *(_WORD *)(result + 18) & 0xFFFC | (a2 >> 13) & 3;
  *(_WORD *)(result + 1_Block_object_dispose(va, 8) = *(_WORD *)(result + 18) & 0xFFFC | (a2 >> 13) & 3;
  if ((a2 & 0x8000) != 0) {
    *(void *)(result + 32) |= 4uLL;
  }
  int v10 = ((_WORD)a2 << 7) & 0x6000 | (((a2 >> 8) & 0xF) << 9) & 0x7FFF | (a2 >> 12 << 15) | v9;
  if ((a2 & 0x1FC0) != 0) {
    *(_WORD *)(result + 1_Block_object_dispose(va, 8) = v10;
  }
  *(_WORD *)(result + ++*(_WORD *)(cf + 16) = 1;
  if ((~v10 & 0xA00) != 0
    && (~v10 & 0x2200) != 0
    && (~v10 & 0x1400) != 0
    && (~v10 & 0x4400) != 0
    && (~v10 & 0x2800) != 0
    && (~v10 & 0x5000) != 0
    && (~v10 & 0x8400) != 0
    && (~v10 & 0x9000) != 0
    && (unsigned __int16)v10 < 0xC000u)
  {
    if ((a2 & 1) != 0)
    {
      LOWORD(v10) = v10 | 4;
      *(_WORD *)(result + 1_Block_object_dispose(va, 8) = v10;
      char v11 = 2;
      if ((a2 & 2) == 0)
      {
LABEL_27:
        if ((a2 & 4) != 0) {
          *(_WORD *)(result + 1_Block_object_dispose(va, 8) = v10 & 0xFE7F | ((v11 & 3) << 7);
        }
        *(void *)(result + 24) = *(void *)(result + 24) & 0xFFFFFFFC00FFFFFFLL | ((CFBasicHashGetPtrIndex(a3[1]) & 0x3FF) << 24);
        *(void *)(v8 + 24) = *(void *)(v8 + 24) & 0xFFFFF003FFFFFFFFLL | ((CFBasicHashGetPtrIndex(*a3) & 0x3FF) << 34);
        *(void *)(v8 + 24) = *(void *)(v8 + 24) & 0xFFC00FFFFFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[3]) & 0x3FF) << 44);
        *(void *)(v8 + 24) = *(void *)(v8 + 24) & 0x3FFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)CFBasicHashGetPtrIndex(a3[2]) << 54);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFFFFFFFFFFFC00FLL | (16
                                                                            * (CFBasicHashGetPtrIndex(a3[9]) & 0x3FF));
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFFFFFFFFF003FFFLL | ((CFBasicHashGetPtrIndex(a3[8]) & 0x3FF) << 14);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFFFFFFC00FFFFFFLL | ((CFBasicHashGetPtrIndex(a3[5]) & 0x3FF) << 24);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFFFF003FFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[4]) & 0x3FF) << 34);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0xFFC00FFFFFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[6]) & 0x3FF) << 44);
        *(void *)(v8 + 32) = *(void *)(v8 + 32) & 0x3FFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)CFBasicHashGetPtrIndex(a3[7]) << 54);
        return v8;
      }
    }

    else
    {
      char v11 = 1;
      if ((a2 & 2) == 0) {
        goto LABEL_27;
      }
    }

    LOWORD(v10) = v10 & 0xFFE7 | (8 * (v11++ & 3));
    *(_WORD *)(result + 1_Block_object_dispose(va, 8) = v10;
    goto LABEL_27;
  }

  __break(1u);
  return result;
}

uint64_t CFBasicHashGetPtrIndex(uint64_t a1)
{
  if (CFBasicHashGetPtrIndex_once != -1) {
    dispatch_once(&CFBasicHashGetPtrIndex_once, &__block_literal_global_35);
  }
  uint64_t result = os_unfair_lock_lock_with_options();
  int v3 = atomic_load(&CFBasicHashCallBackPtrsCount);
  if (v3 >= 1)
  {
    uint64_t v4 = 0LL;
    while (*(void *)(CFBasicHashCallBackPtrs[v4 >> 5] + 8 * (v4 & 0x1F)) != a1)
    {
      uint64_t v4 = (v4 + 1);
      int v5 = atomic_load(&CFBasicHashCallBackPtrsCount);
    }

    goto LABEL_13;
  }

uint64_t CFBasicHashCreateCopy( CFAllocatorRef allocator, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v10 = *(_WORD *)(a2 + 18);
  uint64_t v11 = 56LL;
  if ((v10 & 4) == 0) {
    uint64_t v11 = 48LL;
  }
  if ((v10 & 0x18) != 0) {
    uint64_t v12 = v11 + 8;
  }
  else {
    uint64_t v12 = v11;
  }
  uint64_t v13 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a2 + 26)];
  if (v13 < 1)
  {
    unsigned int v17 = 0LL;
    BOOL v16 = 0LL;
    unint64_t v15 = 0LL;
    goto LABEL_23;
  }

  uint64_t v14 = CFAllocatorAllocate(allocator, 8 * v13, 0LL);
  if (!v14) {
    return 0LL;
  }
  unint64_t v15 = v14;
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
  if ((*(_WORD *)(a2 + 18) & 4) != 0)
  {
    uint64_t v18 = CFAllocatorAllocate(allocator, 8 * v13, 0LL);
    if (!v18) {
      return 0LL;
    }
    BOOL v16 = v18;
    if (__CFOASafe) {
      __CFSetLastAllocationEventName();
    }
  }

  else
  {
    BOOL v16 = 0LL;
  }

  unint64_t v19 = *(unsigned __int16 *)(a2 + 18);
  if ((v19 & 0x18) == 0)
  {
    unsigned int v17 = 0LL;
    goto LABEL_23;
  }

  uint64_t v20 = CFAllocatorAllocate(allocator, v13 << ((v19 >> 5) & 3), 0LL);
  if (!v20) {
    return 0LL;
  }
  unsigned int v17 = v20;
  if (__CFOASafe) {
    __CFSetLastAllocationEventName();
  }
LABEL_23:
  uint64_t Instance = _CFRuntimeCreateInstance(allocator, 3uLL, v12 - 16, 0LL, a5, a6, a7, a8);
  uint64_t v21 = Instance;
  if (Instance)
  {
    uint64_t v23 = *(void *)(a2 + 32);
    *(_OWORD *)(Instance + ++*(_WORD *)(cf + 16) = *(_OWORD *)(a2 + 16);
    *(void *)(Instance + 32) = v23 & 0xFFFFFFFFFFFFFFF7LL;
    *(_WORD *)(Instance + ++*(_WORD *)(cf + 16) = 1;
    if (v13)
    {
      unint64_t v24 = *(unsigned __int16 *)(a2 + 18);
      if ((v24 & 4) != 0) {
        uint64_t v25 = *(void *)(a2 + 8 * ((v24 >> 2) & 1) + 40);
      }
      else {
        uint64_t v25 = 0LL;
      }
      if ((v24 & 0x18) != 0) {
        uint64_t v26 = *(void **)(a2 + (v24 & 0x18) + 40);
      }
      else {
        uint64_t v26 = 0LL;
      }
      uint64_t v27 = *(void *)(a2 + 40);
      *(void *)(Instance + 40) = v15;
      if (v16) {
        *(void *)(Instance + 8 * (((unint64_t)*(unsigned __int16 *)(Instance + 18) >> 2) & 1) + 40) = v16;
      }
      __src = v26;
      if (v17) {
        *(void *)(Instance + (*(_WORD *)(Instance + 18) & 0x18) + 40) = v17;
      }
      if (v13 >= 1)
      {
        uint64_t v28 = 0LL;
        uint64_t v47 = (const CFAllocatorRef *)(Instance - 16);
        do
        {
          uint64_t v29 = *(void *)(v27 + 8 * v28);
          if ((unint64_t)(v29 - 1) > 0xFFFFFFFFFFFFFFFDLL)
          {
            *(void *)(*(void *)(v21 + 40) + 8 * v2_Block_object_dispose(va, 8) = v29;
            if (v16)
            {
              unint64_t v44 = *(unsigned __int16 *)(v21 + 18);
              if ((v44 & 4) == 0) {
                goto LABEL_81;
              }
              *(void *)(*(void *)(v21 + 8 * ((v44 >> 2) & 1) + 40) + 8 * v2_Block_object_dispose(va, 8) = v29;
            }
          }

          else
          {
            if (v29 == 2814029233LL) {
              uint64_t v29 = 0LL;
            }
            if (v29 == 2780474809LL) {
              uint64_t v30 = -1LL;
            }
            else {
              uint64_t v30 = v29;
            }
            if ((*(void *)(v21 + 32) & 2) == 0)
            {
              char v31 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(v21 + 24) >> 39) & 0x1FLL]
                                                                            + 8
                                                                            * ((*(void *)(v21 + 24) >> 34) & 0x1FLL));
              if (v31)
              {
                uint64_t v32 = &kCFAllocatorSystemDefault;
                if ((v21 & 0x8000000000000000LL) == 0)
                {
                  char v33 = atomic_load((unint64_t *)(v21 + 8));
                  BOOL v34 = (v33 & 0x80) == 0;
                  uint64_t v32 = v47;
                  if (!v34) {
                    uint64_t v32 = &kCFAllocatorSystemDefault;
                  }
                }

                uint64_t v30 = v31(*v32, v30);
              }
            }

            if (v30) {
              uint64_t v35 = v30;
            }
            else {
              uint64_t v35 = 2814029233LL;
            }
            if (v35 == -1) {
              uint64_t v35 = 2780474809LL;
            }
            *(void *)(*(void *)(v21 + 40) + 8 * v2_Block_object_dispose(va, 8) = v35;
            if (v16)
            {
              uint64_t v36 = *(void *)(v25 + 8 * v28);
              if (v36 == 2814029233LL) {
                uint64_t v36 = 0LL;
              }
              if (v36 == 2780474809LL) {
                uint64_t v37 = -1LL;
              }
              else {
                uint64_t v37 = v36;
              }
              if ((*(void *)(v21 + 32) & 2) == 0)
              {
                uint64_t v38 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v21 + 27) >> 5) & 0x1F]
                                                                              + 8 * (*(_DWORD *)(v21 + 27) & 0x1FLL));
                if (v38)
                {
                  uint64_t v39 = &kCFAllocatorSystemDefault;
                  if ((v21 & 0x8000000000000000LL) == 0)
                  {
                    char v40 = atomic_load((unint64_t *)(v21 + 8));
                    BOOL v34 = (v40 & 0x80) == 0;
                    uint64_t v39 = v47;
                    if (!v34) {
                      uint64_t v39 = &kCFAllocatorSystemDefault;
                    }
                  }

                  uint64_t v37 = v38(*v39, v37);
                }
              }

              unint64_t v41 = *(unsigned __int16 *)(v21 + 18);
              if ((v41 & 4) == 0)
              {
LABEL_81:
                __break(1u);
LABEL_82:
                CFBasicHashCreateCopy_cold_1();
              }

              uint64_t v42 = *(void *)(v21 + 8 * ((v41 >> 2) & 1) + 40);
              if (v37) {
                uint64_t v43 = v37;
              }
              else {
                uint64_t v43 = 2814029233LL;
              }
              if (v43 == -1) {
                uint64_t v43 = 2780474809LL;
              }
              *(void *)(v42 + 8 * v2_Block_object_dispose(va, 8) = v43;
            }
          }

          ++v28;
        }

        while (v13 != v28);
      }

      if (v17 && __src) {
        memmove(v17, __src, v13 << (((unint64_t)*(unsigned __int16 *)(v21 + 18) >> 5) & 3));
      }
    }
  }

  return v21;
}

unint64_t ___CFBasicHashFindBucket_Linear_Indirect@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unsigned int v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v7) {
    unint64_t result = v7(a2);
  }
  unint64_t v9 = *(unsigned __int16 *)(a1 + 18);
  if ((v9 & 4) != 0) {
    __int16 v10 = (uint64_t *)(a1 + 40 + 8 * ((v9 >> 2) & 1));
  }
  else {
    __int16 v10 = (uint64_t *)(a1 + 40);
  }
  unint64_t v24 = a3;
  if (!v6)
  {
    uint64_t v13 = -1LL;
LABEL_29:
    uint64_t v15 = 0LL;
    uint64_t v20 = v24;
    uint64_t *v24 = v13;
    goto LABEL_30;
  }

  unint64_t v11 = result % v6;
  uint64_t v12 = *v10;
  uint64_t v13 = -1LL;
  unint64_t v14 = v6;
  while (1)
  {
    uint64_t v15 = *(void *)(v12 + 8 * v11);
    switch(v15)
    {
      case -1LL:
        if (v13 == -1) {
          uint64_t v13 = v11;
        }
        goto LABEL_23;
      case 0LL:
        if (v13 == -1) {
          uint64_t v21 = v11;
        }
        else {
          uint64_t v21 = v13;
        }
        uint64_t v20 = v24;
        uint64_t *v24 = v21;
        goto LABEL_30;
      case 2814029233LL:
        uint64_t v15 = 0LL;
        break;
    }

    if (v15 == 2780474809LL) {
      uint64_t v16 = -1LL;
    }
    else {
      uint64_t v16 = v15;
    }
    unsigned int v17 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(void *)(a1 + 32) >> 54) & 0x1FLL));
    if (v17)
    {
      unint64_t result = v17(v16);
      uint64_t v16 = result;
    }

    if (v16 == a2) {
      break;
    }
    uint64_t v18 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8LL * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v18)
    {
      unint64_t result = v18(v16, a2);
      if ((_DWORD)result) {
        goto LABEL_36;
      }
    }

void sub_180B939F8()
{
}

void sub_180B93A00()
{
}

void sub_180B93A08()
{
}

unint64_t ___CFBasicHashFindBucket_Double_Indirect@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unsigned int v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v7) {
    unint64_t result = v7(a2);
  }
  if (result / v6 % v6) {
    unint64_t v9 = result / v6 % v6;
  }
  else {
    unint64_t v9 = v6 - 1;
  }
  unint64_t v10 = *(unsigned __int16 *)(a1 + 18);
  if ((v10 & 4) != 0) {
    unint64_t v11 = (uint64_t *)(a1 + 40 + 8 * ((v10 >> 2) & 1));
  }
  else {
    unint64_t v11 = (uint64_t *)(a1 + 40);
  }
  uint64_t v25 = a3;
  if (!v6)
  {
    uint64_t v14 = -1LL;
LABEL_32:
    uint64_t v16 = 0LL;
    uint64_t v21 = v25;
    uint64_t *v25 = v14;
    goto LABEL_33;
  }

  unint64_t v12 = result % v6;
  uint64_t v13 = *v11;
  uint64_t v14 = -1LL;
  unint64_t v15 = v6;
  while (1)
  {
    uint64_t v16 = *(void *)(v13 + 8 * v12);
    switch(v16)
    {
      case -1LL:
        if (v14 == -1) {
          uint64_t v14 = v12;
        }
        goto LABEL_26;
      case 0LL:
        if (v14 == -1) {
          uint64_t v22 = v12;
        }
        else {
          uint64_t v22 = v14;
        }
        uint64_t v21 = v25;
        uint64_t *v25 = v22;
        goto LABEL_33;
      case 2814029233LL:
        uint64_t v16 = 0LL;
        break;
    }

    if (v16 == 2780474809LL) {
      uint64_t v17 = -1LL;
    }
    else {
      uint64_t v17 = v16;
    }
    uint64_t v18 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(void *)(a1 + 32) >> 54) & 0x1FLL));
    if (v18)
    {
      unint64_t result = v18(v17);
      uint64_t v17 = result;
    }

    if (v17 == a2) {
      break;
    }
    unint64_t v19 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8LL * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v19)
    {
      unint64_t result = v19(v17, a2);
      if ((_DWORD)result) {
        goto LABEL_39;
      }
    }

void sub_180B93C48()
{
}

void sub_180B93C50()
{
}

void sub_180B93C58()
{
}

unint64_t ___CFBasicHashFindBucket_Exponential_Indirect@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = *(unsigned __int8 *)(a1 + 26);
  unint64_t v7 = __CFBasicHashTableSizes[v6];
  unsigned int v8 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v8) {
    unint64_t result = v8(a2);
  }
  uint64_t v30 = a2;
  if (result / v7 % v7) {
    unint64_t v10 = result / v7 % v7;
  }
  else {
    unint64_t v10 = v7 - 1;
  }
  unint64_t v11 = *(unsigned __int16 *)(a1 + 18);
  if ((v11 & 4) != 0) {
    unint64_t v12 = (uint64_t *)(a1 + 40 + 8 * ((v11 >> 2) & 1));
  }
  else {
    unint64_t v12 = (uint64_t *)(a1 + 40);
  }
  uint64_t v28 = a3;
  if (!v7)
  {
    uint64_t v16 = -1LL;
LABEL_35:
    uint64_t v20 = 0LL;
    int v24 = v28;
    uint64_t *v28 = v16;
    goto LABEL_36;
  }

  unint64_t v13 = result % v7;
  unint64_t v14 = __CFBasicHashPrimitiveRoots[v6];
  uint64_t v15 = *v12;
  uint64_t v16 = -1LL;
  unint64_t v17 = v7;
  unint64_t v18 = v14;
  unint64_t v19 = result % v7;
  unint64_t v29 = v10;
  while (1)
  {
    uint64_t v20 = *(void *)(v15 + 8 * v19);
    switch(v20)
    {
      case -1LL:
        if (v16 == -1) {
          uint64_t v16 = v19;
        }
        goto LABEL_28;
      case 0LL:
        if (v16 == -1) {
          uint64_t v25 = v19;
        }
        else {
          uint64_t v25 = v16;
        }
        int v24 = v28;
        uint64_t *v28 = v25;
        goto LABEL_36;
      case 2814029233LL:
        uint64_t v20 = 0LL;
        break;
    }

    if (v20 == 2780474809LL) {
      uint64_t v21 = -1LL;
    }
    else {
      uint64_t v21 = v20;
    }
    uint64_t v22 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(void *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(void *)(a1 + 32) >> 54) & 0x1FLL));
    if (v22)
    {
      unint64_t result = v22(v21);
      uint64_t v21 = result;
    }

    if (v21 == v30) {
      break;
    }
    uint64_t v23 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                            + 8LL * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v23)
    {
      unint64_t result = v23(v21);
      unint64_t v10 = v29;
      if ((_DWORD)result) {
        goto LABEL_42;
      }
    }

    else
    {
      unint64_t v10 = v29;
    }

void sub_180B93EE8()
{
}

void sub_180B93EF0()
{
}

void sub_180B93EF8()
{
}

unint64_t ___CFBasicHashFindBucket_Linear@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unint64_t v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v7) {
    unint64_t result = v7(a2);
  }
  unint64_t v9 = *(unsigned __int16 *)(a1 + 18);
  unint64_t v10 = (void *)(a1 + 40);
  if ((v9 & 4) != 0) {
    unint64_t v11 = (uint64_t *)(a1 + 40 + 8 * ((v9 >> 2) & 1));
  }
  else {
    unint64_t v11 = (uint64_t *)(a1 + 40);
  }
  uint64_t v26 = a3;
  if (!v6)
  {
    uint64_t v14 = -1LL;
LABEL_27:
    uint64_t v16 = 0LL;
    uint64_t v20 = v26;
    uint64_t *v26 = v14;
    goto LABEL_28;
  }

  unint64_t v12 = result % v6;
  uint64_t v13 = *v11;
  uint64_t v14 = -1LL;
  unint64_t v15 = v6;
  while (1)
  {
    uint64_t v16 = *(void *)(v13 + 8 * v12);
    switch(v16)
    {
      case -1LL:
        if (v14 == -1) {
          uint64_t v14 = v12;
        }
        goto LABEL_21;
      case 0LL:
        if (v14 == -1) {
          uint64_t v21 = v12;
        }
        else {
          uint64_t v21 = v14;
        }
        uint64_t v20 = v26;
        uint64_t *v26 = v21;
        goto LABEL_28;
      case 2814029233LL:
        uint64_t v16 = 0LL;
        break;
    }

    uint64_t v17 = v16 == 2780474809LL ? -1LL : v16;
    if (v17 == a2) {
      break;
    }
    unint64_t v18 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8LL * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v18)
    {
      unint64_t result = v18(v17, a2);
      if ((_DWORD)result) {
        goto LABEL_34;
      }
    }

void sub_180B940F8()
{
}

void sub_180B94100()
{
}

void sub_180B94108()
{
}

unint64_t ___CFBasicHashFindBucket_Double@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unint64_t v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  if (v7) {
    unint64_t result = v7(a2);
  }
  if (result / v6 % v6) {
    unint64_t v9 = result / v6 % v6;
  }
  else {
    unint64_t v9 = v6 - 1;
  }
  unint64_t v10 = *(unsigned __int16 *)(a1 + 18);
  unint64_t v11 = (void *)(a1 + 40);
  if ((v10 & 4) != 0) {
    unint64_t v12 = (uint64_t *)(a1 + 40 + 8 * ((v10 >> 2) & 1));
  }
  else {
    unint64_t v12 = (uint64_t *)(a1 + 40);
  }
  int v27 = a3;
  if (!v6)
  {
    uint64_t v15 = -1LL;
LABEL_30:
    uint64_t v17 = 0LL;
    uint64_t v21 = v27;
    uint64_t *v27 = v15;
    goto LABEL_31;
  }

  unint64_t v13 = result % v6;
  uint64_t v14 = *v12;
  uint64_t v15 = -1LL;
  unint64_t v16 = v6;
  while (1)
  {
    uint64_t v17 = *(void *)(v14 + 8 * v13);
    switch(v17)
    {
      case -1LL:
        if (v15 == -1) {
          uint64_t v15 = v13;
        }
        goto LABEL_24;
      case 0LL:
        if (v15 == -1) {
          uint64_t v22 = v13;
        }
        else {
          uint64_t v22 = v15;
        }
        uint64_t v21 = v27;
        uint64_t *v27 = v22;
        goto LABEL_31;
      case 2814029233LL:
        uint64_t v17 = 0LL;
        break;
    }

    uint64_t v18 = v17 == 2780474809LL ? -1LL : v17;
    if (v18 == a2) {
      break;
    }
    unint64_t v19 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8LL * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v19)
    {
      unint64_t result = v19(v18, a2);
      if ((_DWORD)result) {
        goto LABEL_37;
      }
    }

void sub_180B9431C()
{
}

void sub_180B94324()
{
}

void sub_180B9432C()
{
}

unint64_t ___CFBasicHashFindBucket_Exponential@<X0>( uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = a1;
  uint64_t v5 = *(unsigned __int8 *)(a1 + 26);
  unint64_t v6 = __CFBasicHashTableSizes[v5];
  unint64_t v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  unint64_t result = a2;
  uint64_t v30 = v3;
  unint64_t v31 = a2;
  if (v7)
  {
    unint64_t result = v7(a2);
    uint64_t v3 = v30;
    a2 = v31;
  }

  if (result / v6 % v6) {
    unint64_t v9 = result / v6 % v6;
  }
  else {
    unint64_t v9 = v6 - 1;
  }
  unint64_t v10 = *(unsigned __int16 *)(v3 + 18);
  if ((v10 & 4) != 0) {
    unint64_t v11 = (uint64_t *)(v3 + 40 + 8 * ((v10 >> 2) & 1));
  }
  else {
    unint64_t v11 = (uint64_t *)(v3 + 40);
  }
  unint64_t v29 = a3;
  if (!v6)
  {
    uint64_t v15 = -1LL;
LABEL_31:
    uint64_t v19 = 0LL;
    uint64_t v22 = v29;
    uint64_t *v29 = v15;
    goto LABEL_32;
  }

  uint64_t v28 = (void *)(v3 + 40);
  unint64_t v12 = result % v6;
  unint64_t v13 = __CFBasicHashPrimitiveRoots[v5];
  uint64_t v14 = *v11;
  uint64_t v15 = -1LL;
  unint64_t v16 = v6;
  unint64_t v17 = v13;
  unint64_t v18 = result % v6;
  while (1)
  {
    uint64_t v19 = *(void *)(v14 + 8 * v18);
    switch(v19)
    {
      case -1LL:
        if (v15 == -1) {
          uint64_t v15 = v18;
        }
        goto LABEL_24;
      case 0LL:
        if (v15 == -1) {
          uint64_t v23 = v18;
        }
        else {
          uint64_t v23 = v15;
        }
        uint64_t v22 = v29;
        uint64_t *v29 = v23;
        goto LABEL_32;
      case 2814029233LL:
        uint64_t v19 = 0LL;
        break;
    }

    uint64_t v20 = v19 == 2780474809LL ? -1LL : v19;
    if (v20 == a2) {
      break;
    }
    uint64_t v21 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v3 + 35) >> 5) & 0x1F]
                                                              + 8LL * (*(_DWORD *)(v3 + 35) & 0x1F));
    if (v21)
    {
      unint64_t result = v21(v20, v31);
      uint64_t v3 = v30;
      a2 = v31;
      if ((_DWORD)result) {
        goto LABEL_38;
      }
    }

void sub_180B94578()
{
}

void sub_180B94580()
{
}

void sub_180B94588()
{
}

uint64_t ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  uint64_t v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4) {
    a2 = v4(a2);
  }
  unint64_t v5 = *(unsigned __int16 *)(a1 + 18);
  if ((v5 & 4) != 0) {
    unint64_t v6 = (uint64_t *)(a1 + 40 + 8 * ((v5 >> 2) & 1));
  }
  else {
    unint64_t v6 = (uint64_t *)(a1 + 40);
  }
  if (!v3) {
    return -1LL;
  }
  uint64_t v7 = *v6;
  uint64_t result = a2 % v3;
  unint64_t v9 = v3;
  while (*(void *)(v7 + 8 * result))
  {
    if (v3 <= result + 1) {
      unint64_t v10 = v3;
    }
    else {
      unint64_t v10 = 0LL;
    }
    uint64_t result = result + 1 - v10;
    if (!--v9) {
      return -1LL;
    }
  }

  return result;
}

uint64_t ___CFBasicHashFindBucket_Double_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  uint64_t v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4) {
    a2 = v4(a2);
  }
  unint64_t v5 = a2 / v3 % v3;
  if (!v5) {
    unint64_t v5 = v3 - 1;
  }
  unint64_t v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 4) != 0) {
    uint64_t v7 = (uint64_t *)(a1 + 40 + 8 * ((v6 >> 2) & 1));
  }
  else {
    uint64_t v7 = (uint64_t *)(a1 + 40);
  }
  uint64_t v8 = *v7;
  uint64_t result = a2 % v3;
  unint64_t v10 = v3;
  while (*(void *)(v8 + 8 * result))
  {
    if (v3 <= result + v5) {
      unint64_t v11 = v3;
    }
    else {
      unint64_t v11 = 0LL;
    }
    uint64_t result = result + v5 - v11;
    if (!--v10) {
      return -1LL;
    }
  }

  return result;
}

unint64_t ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 26);
  unint64_t v4 = __CFBasicHashTableSizes[v3];
  unint64_t v5 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v5) {
    a2 = v5(a2);
  }
  unint64_t v6 = a2 / v4 % v4;
  if (!v6) {
    unint64_t v6 = v4 - 1;
  }
  unint64_t v7 = *(unsigned __int16 *)(a1 + 18);
  uint64_t v8 = (uint64_t *)(a1 + 40 + 8 * ((v7 >> 2) & 1));
  if ((v7 & 4) == 0) {
    uint64_t v8 = (uint64_t *)(a1 + 40);
  }
  uint64_t v9 = *v8;
  unint64_t v10 = v4;
  unint64_t result = a2 % v4;
  unint64_t v12 = __CFBasicHashPrimitiveRoots[v3];
  while (*(void *)(v9 + 8 * result))
  {
    unint64_t result = a2 % v4 + v12 * v6;
    if (v4 <= result) {
      result %= v4;
    }
    v12 *= __CFBasicHashPrimitiveRoots[v3];
    if (v4 <= v12) {
      v12 %= v4;
    }
    if (!--v10) {
      return -1LL;
    }
  }

  return result;
}

uint64_t ___CFBasicHashFindBucket_Linear_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unint64_t v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4) {
    a2 = v4(a2);
  }
  unint64_t v5 = *(unsigned __int16 *)(a1 + 18);
  if ((v5 & 4) != 0) {
    unint64_t v6 = (uint64_t *)(a1 + 40 + 8 * ((v5 >> 2) & 1));
  }
  else {
    unint64_t v6 = (uint64_t *)(a1 + 40);
  }
  if (!v3) {
    return -1LL;
  }
  uint64_t v7 = *v6;
  uint64_t result = a2 % v3;
  unint64_t v9 = v3;
  while (*(void *)(v7 + 8 * result))
  {
    if (v3 <= result + 1) {
      unint64_t v10 = v3;
    }
    else {
      unint64_t v10 = 0LL;
    }
    uint64_t result = result + 1 - v10;
    if (!--v9) {
      return -1LL;
    }
  }

  return result;
}

uint64_t ___CFBasicHashFindBucket_Double_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  unint64_t v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4) {
    a2 = v4(a2);
  }
  unint64_t v5 = a2 / v3 % v3;
  if (!v5) {
    unint64_t v5 = v3 - 1;
  }
  unint64_t v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 4) != 0) {
    uint64_t v7 = (uint64_t *)(a1 + 40 + 8 * ((v6 >> 2) & 1));
  }
  else {
    uint64_t v7 = (uint64_t *)(a1 + 40);
  }
  uint64_t v8 = *v7;
  uint64_t result = a2 % v3;
  unint64_t v10 = v3;
  while (*(void *)(v8 + 8 * result))
  {
    if (v3 <= result + v5) {
      unint64_t v11 = v3;
    }
    else {
      unint64_t v11 = 0LL;
    }
    uint64_t result = result + v5 - v11;
    if (!--v10) {
      return -1LL;
    }
  }

  return result;
}

unint64_t ___CFBasicHashFindBucket_Exponential_NoCollision(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 26);
  unint64_t v4 = __CFBasicHashTableSizes[v3];
  unint64_t v5 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(void *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(void *)(a1 + 32) >> 44) & 0x1FLL));
  if (v5) {
    a2 = v5(a2);
  }
  unint64_t v6 = a2 / v4 % v4;
  if (!v6) {
    unint64_t v6 = v4 - 1;
  }
  unint64_t v7 = *(unsigned __int16 *)(a1 + 18);
  uint64_t v8 = (uint64_t *)(a1 + 40 + 8 * ((v7 >> 2) & 1));
  if ((v7 & 4) == 0) {
    uint64_t v8 = (uint64_t *)(a1 + 40);
  }
  uint64_t v9 = *v8;
  unint64_t v10 = v4;
  unint64_t result = a2 % v4;
  unint64_t v12 = __CFBasicHashPrimitiveRoots[v3];
  while (*(void *)(v9 + 8 * result))
  {
    unint64_t result = a2 % v4 + v12 * v6;
    if (v4 <= result) {
      result %= v4;
    }
    v12 *= __CFBasicHashPrimitiveRoots[v3];
    if (v4 <= v12) {
      v12 %= v4;
    }
    if (!--v10) {
      return -1LL;
    }
  }

  return result;
}

void *__CFBasicHashGetPtrIndex_block_invoke()
{
  CFBasicHashCallBackPtrsLocuint64_t k = 0;
  unint64_t result = malloc(0x100uLL);
  CFBasicHashCallBackPtrs[0] = (uint64_t)result;
  if (result)
  {
    *unint64_t result = 0LL;
    result[1] = CFCopyDescription;
    result[2] = __CFTypeCollectionRelease;
    result[3] = __CFTypeCollectionRetain;
    result[4] = CFEqual;
    result[5] = CFHash;
    result[6] = __CFStringCollectionCopy;
    result[7] = 0LL;
    atomic_store(8u, &CFBasicHashCallBackPtrsCount);
  }

  else
  {
    __break(1u);
  }

  return result;
}

void *CFXNotificationHandlerCopy(void *result, void *aBlock, CFTypeRef cf, int a4)
{
  unint64_t v4 = result;
  *unint64_t result = 0LL;
  result[1] = 0LL;
  if ((a4 & 0x20000) != 0)
  {
    if (aBlock)
    {
      unint64_t result = _Block_copy(aBlock);
      *unint64_t v4 = result;
    }

    if (cf)
    {
      unint64_t result = CFRetain(cf);
      v4[1] = result;
    }
  }

  else if ((a4 & 0x40000) != 0 || (a4 & 0x80000) != 0)
  {
    *unint64_t result = aBlock;
  }

  return result;
}

void CFXNotificationHandlerRelease(uint64_t *a1, int a2)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  memset(v2, 0, sizeof(v2));
  _CFXNotificationHandlerRelease(a1, a2, (unsigned int *)v2);
  _CFXNotificationDisposalListRelease((unsigned int *)v2);
}

uint64_t *_CFXNotificationHandlerRelease(uint64_t *result, int a2, unsigned int *a3)
{
  uint64_t v3 = result;
  if ((a2 & 0x20000) != 0)
  {
    if (*result) {
      unint64_t result = (uint64_t *)__CFXNotificationDisposalListAddItem(a3, *result);
    }
    uint64_t v5 = v3[1];
    if (v5) {
      unint64_t result = (uint64_t *)__CFXNotificationDisposalListAddItem(a3, v5);
    }
  }

  *uint64_t v3 = 0LL;
  v3[1] = 0LL;
  return result;
}

void _CFXNotificationDisposalListRelease(unsigned int *a1)
{
  unsigned int v2 = *a1;
  if (*a1 >= 4) {
    int v3 = 4;
  }
  else {
    int v3 = *a1;
  }
  if (v3)
  {
    unint64_t v4 = 1LL;
    do
    {
      CFRelease(*(CFTypeRef *)&a1[2 * v4]);
      unsigned int v2 = *a1;
      if (*a1 >= 4) {
        unint64_t v5 = 4LL;
      }
      else {
        unint64_t v5 = v2;
      }
    }

    while (v4++ < v5);
  }

  if (v2 >= 5)
  {
    uint64_t v7 = 0LL;
    do
    {
      CFRelease(*(CFTypeRef *)(*((void *)a1 + 5) + 8 * v7));
      unint64_t v8 = v7 + 5;
      ++v7;
    }

    while (v8 < *a1);
  }

void __CFXNotificationRegistrarDeallocate(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  unint64_t v2 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v2)
  {
    for (unint64_t i = 0LL; i < v2; ++i)
    {
      int v4 = *(_DWORD *)(*(void *)(a1 + 32) + 4 * i);
      if (v4 != -1)
      {
        unint64_t v5 = *(void **)(*(void *)(a1 + 96) + 40LL * v4 + 24);
        if (v5)
        {
          free(v5);
          unint64_t v2 = *(unsigned int *)(a1 + 40);
        }
      }
    }
  }

  unint64_t v6 = *(void **)(a1 + 96);
  if (v6)
  {
    unint64_t v7 = *(unsigned int *)(a1 + 108);
    if ((_DWORD)v7)
    {
      unint64_t v8 = 0LL;
      uint64_t v9 = 8LL;
      do
      {
        unint64_t v10 = (const void **)(*(void *)(a1 + 96) + v9);
        if (*v10)
        {
          _CFXNotificationRegistrarRemoveCachedName(v10);
          unint64_t v7 = *(unsigned int *)(a1 + 108);
        }

        ++v8;
        v9 += 40LL;
      }

      while (v8 < v7);
      unint64_t v6 = *(void **)(a1 + 96);
    }

    free(v6);
  }

  unint64_t v11 = *(void **)(a1 + 120);
  if (v11)
  {
    if ((*(_BYTE *)(a1 + 24) & 2) != 0)
    {
      unint64_t v12 = *(unsigned int *)(a1 + 132);
      if ((_DWORD)v12)
      {
        unint64_t v13 = 0LL;
        uint64_t v14 = 8LL;
        do
        {
          uint64_t v15 = (const void **)(*(void *)(a1 + 120) + v14);
          if (*v15)
          {
            _CFXNotificationRegistrarRemoveCachedName(v15);
            unint64_t v12 = *(unsigned int *)(a1 + 132);
          }

          ++v13;
          v14 += 32LL;
        }

        while (v13 < v12);
        unint64_t v11 = *(void **)(a1 + 120);
      }
    }

    free(v11);
  }

  unint64_t v16 = *(unsigned int *)(a1 + 156);
  if ((_DWORD)v16)
  {
    unint64_t v17 = 0LL;
    uint64_t v18 = 44LL;
    do
    {
      uint64_t v19 = *(void *)(a1 + 144);
      int v20 = *(_DWORD *)(v19 + v18);
      if ((v20 & 0x8000) == 0)
      {
        if ((v20 & 0x400) != 0)
        {
          objc_destroyWeak((id *)(v19 + v18 - 36));
          int v20 = *(_DWORD *)(v19 + v18);
        }

        memset(v25, 0, sizeof(v25));
        _CFXNotificationHandlerRelease((uint64_t *)(v19 + v18 - 28), v20, (unsigned int *)v25);
        _CFXNotificationDisposalListRelease((unsigned int *)v25);
        unint64_t v16 = *(unsigned int *)(a1 + 156);
      }

      ++v17;
      v18 += 56LL;
    }

    while (v17 < v16);
  }

  free(*(void **)(a1 + 144));
  uint64_t v21 = *(void **)(a1 + 32);
  if (v21) {
    free(v21);
  }
  uint64_t v22 = *(void **)(a1 + 48);
  if (v22) {
    free(v22);
  }
  uint64_t v23 = *(void **)(a1 + 64);
  if (v23) {
    free(v23);
  }
  uint64_t v24 = *(const void **)(a1 + 88);
  if (v24) {
    CFRelease(v24);
  }
}

uint64_t CFXNotificationRegistrarGetTypeID()
{
  return 70LL;
}

void CFXNotificationRegistrarCreate( const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance = _CFRuntimeCreateInstance(a1, 0x46uLL, 160LL, 0LL, a5, a6, a7, a8);
  *(void *)(Instance + 24) = a2;
  *(_DWORD *)(Instance + ++*(_WORD *)(cf + 16) = 0;
  *(_DWORD *)(Instance + 112) = -1;
  *(_DWORD *)(Instance + 136) = -1;
  *(_DWORD *)(Instance + 160) = -1;
  *(_DWORD *)(Instance + 80) = -1;
  atomic_store(1u, (unsigned int *)(Instance + 168));
}

uint64_t CFXNotificationRegistrarGetOptions(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void _CFXNotificationRegistrationDispose(uint64_t a1, int a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 24);
  memset(v6, 0, sizeof(v6));
  _CFXNotificationHandlerRelease((uint64_t *)(a1 + 32), v4, (unsigned int *)v6);
  _CFXNotificationDisposalListRelease((unsigned int *)v6);
  if (a2)
  {
    unint64_t v5 = *(const void **)(a1 + 8);
    if (v5) {
      CFRelease(v5);
    }
  }

  if ((*(_BYTE *)(a1 + 25) & 4) != 0) {

  }
  if (*(void *)a1) {
    CFRelease(*(CFTypeRef *)a1);
  }
}

void _CFXNotificationRegistrationBufferDestroy(unsigned int *a1)
{
  if (*a1)
  {
    uint64_t v2 = 0LL;
    unint64_t v3 = 0LL;
    do
    {
      _CFXNotificationRegistrationDispose(*((void *)a1 + 2) + v2, *((unsigned __int8 *)a1 + 8));
      ++v3;
      v2 += 64LL;
    }

    while (v3 < *a1);
  }

  uint64_t v4 = (unsigned int *)*((void *)a1 + 2);
  if (v4 != a1 + 6) {
    free(v4);
  }
}

void CFXNotificationRegistrarFind(uint64_t a1, const __CFString *cf1, const __CFString *a3, unsigned int *a4)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  int v27 = &v29;
  unsigned int v26 = 0;
  size_t v25 = 32LL;
  char v24 = 0;
  int v7 = (*(unsigned __int8 *)(a1 + 24) >> 1) & 1;
  *((_BYTE *)a4 + _Block_object_dispose(va, 8) = (*(_BYTE *)(a1 + 24) & 2) != 0;
  unint64_t v8 = @"kCFNotificationAnyName";
  if (cf1)
  {
    uint64_t v9 = cf1;
    if (@"kCFNotificationAnyName" == cf1)
    {
      unint64_t v8 = cf1;
    }

    else if (CFEqual(cf1, @"kCFNotificationAnyName"))
    {
      uint64_t v9 = @"kCFNotificationAnyName";
    }
  }

  else
  {
    uint64_t v9 = @"kCFNotificationAnyName";
  }

  if (!a3)
  {
    a3 = @"kCFNotificationAnyObject";
    CFHashCode v10 = CFHash(v9);
    if (!v7) {
      goto LABEL_12;
    }
LABEL_17:
    unint64_t v11 = CFHash(a3);
    goto LABEL_18;
  }

  if (v7)
  {
    if (@"kCFNotificationAnyObject" != a3 && CFEqual(a3, @"kCFNotificationAnyObject")) {
      a3 = @"kCFNotificationAnyObject";
    }
    CFHashCode v10 = CFHash(v9);
    goto LABEL_17;
  }

  CFHashCode v10 = CFHash(v9);
LABEL_12:
  unint64_t v11 = ((unint64_t)a3 >> 5) & 0x7F;
LABEL_18:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v9 != v8)
  {
    uint64_t Name = _CFXNotificationRegistrarFindName(a1, a1 + 32, v9, v10, 0LL);
    if (Name)
    {
      uint64_t v13 = Name;
      uint64_t Object = _CFXNotificationRegistrarFindObject(a1, Name + 24, a3, v11, v7, 0LL);
      if (Object)
      {
        uint64_t v15 = Object;
        unint64_t v16 = (const __CFString *)CFCachedStringCopyString((CFTypeRef *)(v13 + 8));
        _CFXNotificationRegistrarFindObservers( (void *)a1,  (unsigned int *)(v15 + 16),  v16,  *(const __CFString **)(v15 + 8),  a4,  &v27,  &v26,  &v25,  &v24);
        CFRelease(v16);
      }
    }
  }

  if (a3 != @"kCFNotificationAnyObject")
  {
    uint64_t v17 = _CFXNotificationRegistrarFindObject(a1, a1 + 48, a3, v11, v7, 0LL);
    if (v17) {
      _CFXNotificationRegistrarFindObservers( (void *)a1,  (unsigned int *)(v17 + 16),  v8,  *(const __CFString **)(v17 + 8),  a4,  &v27,  &v26,  &v25,  &v24);
    }
  }

  uint64_t v18 = _CFXNotificationRegistrarFindName(a1, a1 + 64, v9, v10, 0LL);
  if (v18)
  {
    uint64_t v19 = v18;
    int v20 = (const __CFString *)CFCachedStringCopyString((CFTypeRef *)(v18 + 8));
    _CFXNotificationRegistrarFindObservers( (void *)a1,  (unsigned int *)(v19 + 24),  v20,  @"kCFNotificationAnyObject",  a4,  &v27,  &v26,  &v25,  &v24);
    CFRelease(v20);
  }

  _CFXNotificationRegistrarFindObservers( (void *)a1,  (unsigned int *)(a1 + 80),  v8,  @"kCFNotificationAnyObject",  a4,  &v27,  &v26,  &v25,  &v24);
  memset(v28, 0, sizeof(v28));
  uint64_t v21 = v26;
  if (v26)
  {
    uint64_t v22 = (unsigned int *)v27;
    do
    {
      unsigned int v23 = *v22++;
      _CFXNotificationRegistrarInvalidateObserver(a1, v23, -1, -1, (unsigned int *)v28);
      --v21;
    }

    while (v21);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v28);
  if ((*(_BYTE *)(a1 + 24) & 1) != 0) {
    qsort(*((void **)a4 + 2), *a4, 0x40uLL, (int (__cdecl *)(const void *, const void *))_registrar_compare);
  }
  if (v24) {
    free(v27);
  }
}

uint64_t _CFXNotificationRegistrarFindName( uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, _DWORD *a5)
{
  unint64_t v5 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v5)
  {
    uint64_t v9 = *(unsigned int *)(*(void *)a2 + 4 * (a4 % v5));
    while (v9 != 0xFFFFFFFFLL)
    {
      uint64_t v10 = v9;
      uint64_t v11 = *(void *)(a1 + 96);
      uint64_t v12 = v11 + 40 * v9;
      uint64_t v9 = *(unsigned int *)(v12 + 4);
      if (CFCachedStringEqual((CFTypeRef *)(v12 + 8), a3))
      {
        uint64_t result = v11 + 40 * v10;
        if (a5) {
          *a5 = v10;
        }
        return result;
      }
    }
  }

  return 0LL;
}

uint64_t _CFXNotificationRegistrarFindObject( uint64_t a1, uint64_t a2, CFTypeRef cf1, unint64_t a4, int a5, _DWORD *a6)
{
  unint64_t v6 = *(unsigned int *)(a2 + 8);
  if (!(_DWORD)v6) {
    return 0LL;
  }
  uint64_t v7 = *(unsigned int *)(*(void *)a2 + 4 * (a4 % v6));
  if ((_DWORD)v7 == -1) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v12 = *(void *)(a1 + 120);
    uint64_t v13 = v12 + 32 * v7;
    CFTypeRef v14 = *(CFTypeRef *)(v13 + 8);
    if (v14 == cf1 || a5 && CFEqual(cf1, v14)) {
      break;
    }
    uint64_t v7 = *(unsigned int *)(v12 + 32 * v7 + 4);
    if ((_DWORD)v7 == -1) {
      return 0LL;
    }
  }

  if (a6) {
    *a6 = v7;
  }
  return v13;
}

CFTypeRef CFCachedStringCopyString(CFTypeRef *a1)
{
  CFTypeRef v2 = CFRetain(*a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  return v2;
}

void *_CFXNotificationRegistrarFindObservers( void *result, unsigned int *a2, const __CFString *a3, const __CFString *a4, unsigned int *a5, void **a6, unsigned int *a7, size_t *a8, _BYTE *a9)
{
  char v40 = result;
  __ptr = *a6;
  unsigned int v37 = *a7;
  size_t v35 = *a8;
  int v34 = *a9;
  uint64_t v9 = *a2;
  if ((_DWORD)v9 != -1)
  {
    uint64_t v12 = a5 + 6;
    uint64_t v39 = a5 + 6;
    do
    {
      uint64_t v13 = v40[18];
      uint64_t v14 = *(unsigned int *)(v13 + 56 * v9 + 4);
      LODWORD(v15) = *a5;
      if (a5[1] >= *a5 + 1)
      {
        uint64_t v18 = (char *)*((void *)a5 + 2);
      }

      else
      {
        size_t v16 = malloc_good_size((unint64_t)(v15 + 1) << 6);
        uint64_t v17 = (unsigned int *)*((void *)a5 + 2);
        if (v17 == v12)
        {
          uint64_t v18 = (char *)malloc(v16 & 0x3FFFFFFFC0LL);
          uint64_t v15 = *a5;
          memcpy(v18, v12, v15 << 6);
        }

        else
        {
          uint64_t v18 = (char *)realloc(v17, v16 & 0x3FFFFFFFC0LL);
          LODWORD(v15) = *a5;
        }

        a5[1] = v16 >> 6;
        *((void *)a5 + 2) = v18;
      }

      uint64_t v19 = v15;
      int v20 = (CFStringRef *)&v18[64 * (unint64_t)v15];
      uint64_t v21 = v13 + 56 * v9;
      uint64_t v22 = (id *)(v21 + 8);
      if ((*(_BYTE *)(v21 + 45) & 4) != 0)
      {
        uint64_t result = objc_loadWeakRetained(v22);
        if (!result)
        {
          size_t v27 = v37 + 1;
          if (v35 >= v27)
          {
            uint64_t v12 = v39;
          }

          else
          {
            size_t v28 = malloc_good_size(4 * v27);
            size_t v29 = v28;
            uint64_t v12 = v39;
            if (v34)
            {
              uint64_t result = realloc(__ptr, v28 & 0x3FFFFFFFCLL);
              __ptr = result;
            }

            else
            {
              uint64_t v30 = malloc(v28 & 0x3FFFFFFFCLL);
              uint64_t result = memcpy(v30, __ptr, 4LL * v37);
              int v34 = 1;
              __ptr = v30;
            }

            size_t v35 = v29 >> 2;
          }

          *((_DWORD *)__ptr + v37++) = v9;
          goto LABEL_17;
        }

        *(void *)&v18[64 * (unint64_t)v15 + 16] = result;
        LODWORD(v15) = *a5;
      }

      else
      {
        v20[2] = (CFStringRef)*v22;
      }

      *a5 = v15 + 1;
      unsigned int v23 = &v18[64 * v19];
      int v25 = *(_DWORD *)(v21 + 44);
      char v24 = (unsigned int *)(v21 + 44);
      CFXNotificationHandlerCopy( (void *)v23 + 4,  *(void **)(v13 + 56 * v9 + 16),  *(CFTypeRef *)(v13 + 56 * v9 + 24),  v25);
      CFStringRef *v20 = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
      uint64_t result = &a4->isa;
      if (*((_BYTE *)a5 + 8)) {
        uint64_t result = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4);
      }
      *((void *)v23 + __postAndResetMidnight(1, 1) = result;
      *((void *)v23 + 3) = *v24;
      uint64_t v26 = v13 + 56 * v9;
      *((void *)v23 + 6) = v9 | ((unint64_t)*(unsigned int *)(v26 + 40) << 32);
      *((void *)v23 + 7) = *(void *)(v26 + 32);
      uint64_t v12 = v39;
LABEL_17:
      uint64_t v9 = v14;
    }

    while (v14 != 0xFFFFFFFFLL);
  }

  *a6 = __ptr;
  *a7 = v37;
  *a8 = v35;
  *a9 = v34;
  return result;
}

void _CFXNotificationRegistrarInvalidateObserver( uint64_t a1, unsigned int a2, int a3, int a4, unsigned int *a5)
{
  if (*(_DWORD *)(a1 + 156) > a2)
  {
    uint64_t v7 = *(void *)(a1 + 144);
    int v8 = *(_DWORD *)(v7 + 56LL * a2 + 44);
    if ((v8 & 0x800) != 0)
    {
      unsigned int v23 = *(_DWORD *)(v7 + 56LL * a2 + 48);
      BOOL v24 = _CFXNotificationRegistrarRecycleObserverRegistration( a1,  (unsigned int *)(*(void *)(a1 + 96) + 40LL * v23 + 24),  a2,  a5);
      if (v23 != a3 && v24)
      {
        uint64_t v19 = (uint64_t *)(a1 + 64);
        uint64_t v20 = a1;
        unsigned int v21 = v23;
        int v22 = 1;
        goto LABEL_22;
      }
    }

    else if ((v8 & 0x8000) == 0)
    {
      uint64_t v9 = *(unsigned int *)(v7 + 56LL * a2 + 48);
      if ((_DWORD)v9 == -1)
      {
        _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(a1 + 80), a2, a5);
      }

      else if (v9 < *(_DWORD *)(a1 + 132))
      {
        int v11 = (*(unsigned __int8 *)(a1 + 24) >> 1) & 1;
        uint64_t v12 = *(void *)(a1 + 120) + 32 * v9;
        unsigned int v13 = *(_DWORD *)(v12 + 24);
        if (v13 == -1)
        {
          BOOL v26 = _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(v12 + 16), a2, a5);
          if ((_DWORD)v9 != a4 && v26) {
            _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)(a1 + 48), v9, v11);
          }
        }

        else
        {
          uint64_t v14 = *(void *)(a1 + 96);
          BOOL v15 = _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(v12 + 16), a2, a5);
          if ((_DWORD)v9 != a4 && v15)
          {
            BOOL v17 = _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)(v14 + 40LL * v13 + 24), v9, v11);
            if (v13 != a3 && v17)
            {
              uint64_t v19 = (uint64_t *)(a1 + 32);
              uint64_t v20 = a1;
              unsigned int v21 = v13;
              int v22 = 0;
LABEL_22:
              _CFXNotificationRegistrarRecycleNameRegistration(v20, v19, v21, v22);
            }
          }
        }
      }
    }
  }

uint64_t _registrar_compare(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void *)(a2 + 48);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t CFXNotificationRegistrarFindToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  unsigned int v6 = *(unsigned __int8 *)(a1 + 24);
  int v7 = (v6 >> 1) & 1;
  *(_BYTE *)(a3 + _Block_object_dispose(va, 8) = (v6 & 2) != 0;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  int v8 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  uint64_t v9 = *(void *)(a1 + 144);
  uint64_t v10 = a2;
  uint64_t v11 = v9 + 56LL * a2;
  int v13 = *(_DWORD *)(v11 + 40);
  uint64_t v12 = (unsigned int *)(v11 + 40);
  if (v13 != HIDWORD(a2)
    || (uint64_t v14 = v9 + 56LL * a2,
        int v17 = *(_DWORD *)(v14 + 44),
        size_t v16 = (int *)(v14 + 44),
        LOWORD(v15) = v17,
        (v17 & 0x8000) != 0))
  {
LABEL_6:
    uint64_t v19 = 0LL;
LABEL_7:
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v35 = 0u;
    goto LABEL_8;
  }

  uint64_t v18 = (id *)(v9 + 56LL * a2 + 8);
  if ((v15 & 0x400) == 0)
  {
    *(void *)&__int128 v32 = *v18;
LABEL_14:
    uint64_t v25 = *(unsigned int *)(v9 + 56LL * a2 + 48);
    if ((v15 & 0x800) != 0)
    {
      size_t v29 = @"kCFNotificationAnyObject";
      if (v7) {
        size_t v29 = (const __CFString *)CFRetain(@"kCFNotificationAnyObject");
      }
      *((void *)&v31 + __postAndResetMidnight(1, 1) = v29;
      *(void *)&__int128 v31 = CFCachedStringCopyString((CFTypeRef *)(*(void *)(a1 + 96) + 40LL * v25 + 8));
    }

    else
    {
      if ((_DWORD)v25 == -1)
      {
        CFStringRef Copy = @"kCFNotificationAnyObject";
        if (v7) {
          CFStringRef Copy = (const __CFString *)CFRetain(@"kCFNotificationAnyObject");
        }
      }

      else
      {
        uint64_t v26 = *(void *)(a1 + 120);
        unsigned int v27 = *(_DWORD *)(v26 + 32 * v25 + 24);
        if (v27 == -1) {
          CFTypeRef v28 = CFRetain(@"kCFNotificationAnyName");
        }
        else {
          CFTypeRef v28 = CFCachedStringCopyString((CFTypeRef *)(*(void *)(a1 + 96) + 40LL * v27 + 8));
        }
        *(void *)&__int128 v31 = v28;
        if (v7) {
          CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(v26 + 32 * v25 + 8));
        }
        else {
          CFStringRef Copy = *(const __CFString **)(v26 + 32 * v25 + 8);
        }
      }

      *((void *)&v31 + __postAndResetMidnight(1, 1) = Copy;
    }

    CFXNotificationHandlerCopy( &v33,  *(void **)(v9 + 56LL * v10 + 16),  *(CFTypeRef *)(v9 + 56LL * v10 + 24),  *v16);
    *((void *)&v32 + __postAndResetMidnight(1, 1) = *v16;
    *(void *)&__int128 v34 = v10 | ((unint64_t)*v12 << 32);
    uint64_t v19 = 1LL;
    goto LABEL_7;
  }

  id WeakRetained = objc_loadWeakRetained(v18);
  if (WeakRetained)
  {
    *(void *)&__int128 v32 = WeakRetained;
    int v15 = *v16;
    goto LABEL_14;
  }

  __int128 v36 = 0u;
  __int128 v37 = 0u;
  __int128 v35 = 0u;
  _CFXNotificationRegistrarInvalidateObserver(a1, a2, -1, -1, (unsigned int *)&v35);
  uint64_t v19 = 0LL;
LABEL_8:
  os_unfair_lock_unlock(v8);
  _CFXNotificationDisposalListRelease((unsigned int *)&v35);
  if ((_DWORD)v19)
  {
    uint64_t v20 = *(_OWORD **)(a3 + 16);
    _OWORD *v20 = v31;
    v20[1] = v32;
    __int128 v21 = v34;
    v20[2] = v33;
    v20[3] = v21;
    int v22 = 1;
  }

  else
  {
    int v22 = 0;
  }

  *(_DWORD *)a3 = v22;
  return v19;
}

void CFXNotificationRegistrarRemove(uint64_t a1, const __CFString *cf1, const __CFString *a3, uint64_t a4)
{
  unsigned int v7 = *(unsigned __int8 *)(a1 + 24);
  int v8 = @"kCFNotificationAnyName";
  if (cf1)
  {
    uint64_t v9 = (__CFString *)cf1;
    if (@"kCFNotificationAnyName" == cf1)
    {
      int v8 = cf1;
    }

    else if (CFEqual(cf1, @"kCFNotificationAnyName"))
    {
      uint64_t v9 = @"kCFNotificationAnyName";
    }
  }

  else
  {
    uint64_t v9 = @"kCFNotificationAnyName";
  }

  int v10 = (v7 >> 1) & 1;
  if (a3)
  {
    if (!v10)
    {
      CFHashCode v11 = CFHash(v9);
LABEL_12:
      unint64_t v12 = ((unint64_t)a3 >> 5) & 0x7F;
      goto LABEL_18;
    }

    if (@"kCFNotificationAnyObject" != a3 && CFEqual(a3, @"kCFNotificationAnyObject")) {
      a3 = @"kCFNotificationAnyObject";
    }
    CFHashCode v11 = CFHash(v9);
  }

  else
  {
    a3 = @"kCFNotificationAnyObject";
    CFHashCode v11 = CFHash(v9);
    if (!v10) {
      goto LABEL_12;
    }
  }

  unint64_t v12 = CFHash(a3);
LABEL_18:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationRegistrarRemoveNames(a1, a1 + 32, 0, v9, v11, a3, v12, v10, a4);
  if (v9 == v8)
  {
    _CFXNotificationRegistrarRemoveObjects(a1, a1 + 48, a3, v12, v10, a4);
    if (a3 == @"kCFNotificationAnyObject")
    {
      _CFXNotificationRegistrarRemoveNames(a1, a1 + 64, 1, v9, v11, a3, v12, v10, a4);
      _CFXNotificationRegistrarRemoveObservers(a1, (unsigned int *)(a1 + 80), a4);
    }
  }

  else if (a3 == @"kCFNotificationAnyObject")
  {
    _CFXNotificationRegistrarRemoveNames(a1, a1 + 64, 1, v9, v11, a3, v12, v10, a4);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
}

void _CFXNotificationRegistrarRemoveNames( uint64_t a1, uint64_t a2, int a3, __CFString *a4, unint64_t a5, const __CFString *cf1, unint64_t a7, int a8, uint64_t a9)
{
  unint64_t v27 = *(unsigned int *)(a2 + 8);
  if (!(_DWORD)v27) {
    return;
  }
  if (@"kCFNotificationAnyName" == a4)
  {
    uint64_t v20 = 0LL;
    while (1)
    {
      unsigned int v21 = *(_DWORD *)(*(void *)a2 + 4 * v20);
      if (v21 != -1) {
        break;
      }
LABEL_20:
      if (++v20 == v27) {
        return;
      }
    }

    while (1)
    {
      uint64_t v22 = *(void *)(a1 + 96) + 40LL * v21;
      unsigned int v23 = *(_DWORD *)(v22 + 4);
      BOOL v24 = (unsigned int *)(v22 + 24);
      if (a3 == 1)
      {
        if (_CFXNotificationRegistrarRemoveObservers(a1, v24, a9))
        {
          int v25 = 1;
LABEL_18:
          _CFXNotificationRegistrarRecycleNameRegistration(a1, (uint64_t *)a2, v21, v25);
        }
      }

      else if (_CFXNotificationRegistrarRemoveObjects(a1, (uint64_t)v24, cf1, a7, a8, a9))
      {
        int v25 = 0;
        goto LABEL_18;
      }

      unsigned int v21 = v23;
      if (v23 == -1) {
        goto LABEL_20;
      }
    }
  }

  unsigned int v15 = *(_DWORD *)(*(void *)a2 + 4 * (a5 % v27));
  if (v15 == -1) {
    return;
  }
  while (1)
  {
    uint64_t v16 = *(void *)(a1 + 96);
    uint64_t v17 = v16 + 40LL * v15;
    unsigned int v18 = *(_DWORD *)(v17 + 4);
    if (!CFCachedStringEqual((CFTypeRef *)(v17 + 8), a4)) {
      goto LABEL_9;
    }
    uint64_t v19 = (unsigned int *)(v16 + 40LL * v15 + 24);
    if (a3 != 1) {
      break;
    }
    if (_CFXNotificationRegistrarRemoveObservers(a1, v19, a9))
    {
      int v26 = 1;
      goto LABEL_23;
    }

BOOL _CFXNotificationRegistrarRemoveObjects( uint64_t a1, uint64_t a2, const __CFString *cf1, unint64_t a4, int a5, uint64_t a6)
{
  unint64_t v7 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v7)
  {
    if (@"kCFNotificationAnyObject" == cf1)
    {
      for (uint64_t i = 0LL; i != v7; ++i)
      {
        uint64_t v18 = *(unsigned int *)(*(void *)a2 + 4 * i);
        if ((_DWORD)v18 != -1)
        {
          do
          {
            uint64_t v19 = *(void *)(a1 + 120) + 32 * v18;
            uint64_t v20 = *(unsigned int *)(v19 + 4);
            uint64_t v18 = v20;
          }

          while (v20 != 0xFFFFFFFFLL);
        }
      }
    }

    else
    {
      unsigned int v12 = *(_DWORD *)(*(void *)a2 + 4 * (a4 % v7));
      while (v12 != -1)
      {
        unsigned int v13 = v12;
        uint64_t v14 = *(void *)(a1 + 120) + 32LL * v12;
        unsigned int v12 = *(_DWORD *)(v14 + 4);
        unsigned int v15 = *(const __CFString **)(v14 + 8);
        if ((v15 == cf1 || a5 && CFEqual(cf1, v15))
          && _CFXNotificationRegistrarRemoveObservers(a1, (unsigned int *)(v14 + 16), a6)
          && _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)a2, v13, a5))
        {
          return 1LL;
        }
      }
    }
  }

  return *(_DWORD *)(a2 + 12) == 0;
}

BOOL _CFXNotificationRegistrarRemoveObservers(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  unsigned int v4 = *a2;
  memset(v10, 0, sizeof(v10));
  if (v4 == -1)
  {
LABEL_6:
    _CFXNotificationDisposalListRelease((unsigned int *)v10);
    return a2[1] == 0;
  }

  else
  {
    while (1)
    {
      uint64_t v7 = *(void *)(a1 + 144);
      unsigned int v8 = v4;
      unsigned int v4 = *(_DWORD *)(v7 + 56LL * v4 + 4);
      if ((!a3 || *(void *)(v7 + 56LL * v8 + 8) == a3)
        && _CFXNotificationRegistrarRecycleObserverRegistration(a1, a2, v8, (unsigned int *)v10))
      {
        return 1LL;
      }

      if (v4 == -1) {
        goto LABEL_6;
      }
    }
  }

void CFXNotificationRegistrarRemoveToken(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  memset(v5, 0, sizeof(v5));
  unsigned int v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) > a2
    && *(_DWORD *)(*(void *)(a1 + 144) + 56LL * a2 + 40) == HIDWORD(a2))
  {
    _CFXNotificationRegistrarInvalidateObserver(a1, a2, -1, -1, (unsigned int *)v5);
  }

  os_unfair_lock_unlock(v4);
  _CFXNotificationDisposalListRelease((unsigned int *)v5);
}

uint64_t CFXNotificationRegistrarAdd( uint64_t a1, const __CFString *cf, __CFString *cf1, const __CFString *a4, int a5, void *a6, const void *a7)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  unsigned int v10 = *(unsigned __int8 *)(a1 + 24);
  if (cf)
  {
    uint64_t v11 = cf;
    if (@"kCFNotificationAnyName" != cf && CFEqual(cf, @"kCFNotificationAnyName")) {
      uint64_t v11 = @"kCFNotificationAnyName";
    }
  }

  else
  {
    uint64_t v11 = @"kCFNotificationAnyName";
  }

  int v12 = (v10 >> 1) & 1;
  if (cf1)
  {
    if (v12 && @"kCFNotificationAnyObject" != cf1 && CFEqual(cf1, @"kCFNotificationAnyObject")) {
      cf1 = @"kCFNotificationAnyObject";
    }
  }

  else
  {
    cf1 = @"kCFNotificationAnyObject";
  }

  unsigned int v13 = @"kCFNotificationAnyObserver";
  if (a4) {
    unsigned int v13 = a4;
  }
  *(void *)__int128 v31 = v13;
  CFHashCode v14 = CFHash(v11);
  if (v12) {
    CFHashCode v15 = CFHash(cf1);
  }
  else {
    CFHashCode v15 = ((unint64_t)cf1 >> 5) & 0x7F;
  }
  uint64_t v16 = (unsigned int *)(a1 + 168);
  do
    uint64_t v17 = __ldaxr(v16);
  while (__stlxr(v17 + 1, v16));
  uint64_t v18 = v17 << 32;
  unsigned int v36 = -1;
  unsigned int v37 = -1;
  unsigned int v35 = -1;
  memset(v38, 0, sizeof(v38));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v11 == @"kCFNotificationAnyName")
  {
    if (cf1 == @"kCFNotificationAnyObject")
    {
      uint64_t v20 = (unsigned int *)(a1 + 80);
      uint64_t v29 = v18;
      unint64_t v30 = -1LL;
      uint64_t v22 = a1;
      unsigned int v23 = a6;
      BOOL v24 = a7;
      int v21 = -1;
      goto LABEL_27;
    }

    uint64_t v20 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, a1 + 48, cf1, v15, &v36, -1, v12) + 16);
    int v21 = v36;
    LODWORD(v30) = -1;
    HIDWORD(v30) = v36;
  }

  else
  {
    if (cf1 == @"kCFNotificationAnyObject")
    {
      uint64_t v20 = (unsigned int *)(_CFXNotificationRegistrarAddName(a1, a1 + 64, v11, v14, &v37, 1) + 24);
      unsigned int v23 = a6;
      int v26 = a5 | 0x800;
      int v21 = v37;
      unint64_t v30 = __PAIR64__(v36, v37);
      uint64_t v29 = v18;
      uint64_t v22 = a1;
      BOOL v24 = a7;
      int v25 = *(void **)v31;
      goto LABEL_29;
    }

    uint64_t v19 = _CFXNotificationRegistrarAddName(a1, a1 + 32, v11, v14, &v37, 0);
    uint64_t v20 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, v19 + 24, cf1, v15, &v36, v37, v12) + 16);
    int v21 = v36;
    unint64_t v30 = __PAIR64__(v36, v37);
  }

  uint64_t v29 = v18;
  uint64_t v22 = a1;
  unsigned int v23 = a6;
  BOOL v24 = a7;
LABEL_27:
  int v25 = *(void **)v31;
  int v26 = a5;
LABEL_29:
  _CFXNotificationRegistrarAddObserver( v22,  v20,  v23,  v24,  v21,  v25,  &v35,  v26,  v29,  v30,  SHIDWORD(v30),  (unsigned int *)v38);
  uint64_t v27 = v35;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v38);
  return v18 | v27;
}

_DWORD *_CFXNotificationRegistrarAddObserver( uint64_t a1, unsigned int *a2, void *aBlock, CFTypeRef cf, int a5, void *a6, unsigned int *a7, int a8, uint64_t a9, int a10, int a11, unsigned int *a12)
{
  uint64_t v78 = *MEMORY[0x1895F89C0];
  if ((*(void *)&a8 & 0xE0000LL) == 0) {
    _CFXNotificationRegistrarAddObserver_cold_1();
  }
  int v12 = a8;
  CFHashCode v14 = a6;
  unsigned int v18 = *(_DWORD *)(a1 + 160);
  if (v18 != -1) {
    goto LABEL_3;
  }
  unsigned int v23 = *(_DWORD *)(a1 + 156);
  if (v23 == -1)
  {
LABEL_38:
    uint64_t v19 = *(void *)(a1 + 144);
    unsigned int v18 = -1;
    goto LABEL_39;
  }

  unint64_t v71 = aBlock;
  CFTypeRef v72 = cf;
  size_t v24 = malloc_good_size(56LL * v23 + 56);
  uint64_t v25 = *(unsigned int *)(a1 + 156);
  unint64_t v26 = v24 / 0x38;
  uint64_t v27 = *(char **)(a1 + 144);
  uint64_t v28 = (v24 / 0x38);
  uint64_t v29 = (char *)malloc(56 * v28);
  unint64_t v30 = v29;
  memset(__src, 0, sizeof(__src));
  if (!(_DWORD)v25)
  {
    *(void *)(a1 + 144) = v29;
    char v50 = v27;
LABEL_29:
    free(v50);
    goto LABEL_30;
  }

  uint64_t v66 = v28;
  int v68 = v26;
  uint64_t v69 = a7;
  unint64_t v70 = a2;
  int v31 = 0;
  uint64_t v32 = 0LL;
  unsigned int v33 = 0;
  int v34 = a11;
  int v75 = a5;
  uint64_t v35 = 32LL;
  __ptr = __src;
  uint64_t v67 = v25;
  uint64_t v36 = 56 * v25;
  do
  {
    uint64_t v37 = *(void *)&v27[v32 + 8];
    if ((v27[v32 + 45] & 4) != 0)
    {
      if (v37)
      {
        objc_moveWeak((id *)&v30[v32 + 8], (id *)&v27[v32 + 8]);
      }

      else
      {
        unsigned int v38 = v33;
        unsigned int v39 = v33 + 1;
        if (v33 + 1 <= v35)
        {
          uint64_t v40 = v35;
          unint64_t v41 = __ptr;
        }

        else
        {
          uint64_t v40 = (v35 + 1);
          if (__ptr == __src)
          {
            uint64_t v42 = malloc(4LL * (v35 + 1));
            size_t v43 = 4LL * v35;
            unint64_t v44 = v42;
            memcpy(v42, __src, v43);
            unint64_t v41 = v44;
          }

          else
          {
            unint64_t v41 = realloc(__ptr, 4LL * (v35 + 1));
          }
        }

        __ptr = v41;
        *((_DWORD *)v41 + v3_Block_object_dispose(va, 8) = v31;
        *(void *)&v30[v32 + 8] = 0LL;
        uint64_t v35 = v40;
        unsigned int v33 = v39;
        int v34 = a11;
        a5 = v75;
      }
    }

    else
    {
      *(void *)&v30[v32 + 8] = v37;
    }

    uint64_t v45 = &v30[v32];
    *(void *)uint64_t v45 = *(void *)&v27[v32];
    *((_OWORD *)v45 + __postAndResetMidnight(1, 1) = *(_OWORD *)&v27[v32 + 16];
    *((void *)v45 + 4) = *(void *)&v27[v32 + 32];
    *((void *)v45 + 5) = *(void *)&v27[v32 + 40];
    *((_DWORD *)v45 + 12) = *(_DWORD *)&v27[v32 + 48];
    v32 += 56LL;
    ++v31;
  }

  while (v36 != v32);
  *(void *)(a1 + 144) = v30;
  free(v27);
  a7 = v69;
  uint64_t v28 = v66;
  uint64_t v25 = v67;
  if (v33)
  {
    uint64_t v46 = v33;
    uint64_t v47 = (unsigned int *)__ptr;
    do
    {
      unsigned int v49 = *v47++;
      unsigned int v48 = v49;
      if (v49 != v34) {
        _CFXNotificationRegistrarInvalidateObserver(a1, v48, a10, v34, a12);
      }
      --v46;
    }

    while (v46);
  }

  char v50 = __ptr;
  a2 = v70;
  LODWORD(v26) = v68;
  if (__ptr != __src) {
    goto LABEL_29;
  }
LABEL_30:
  int v51 = *(_DWORD *)(a1 + 156);
  if (v25 < v26)
  {
    uint64_t v52 = *(void *)(a1 + 144);
    uint64_t v53 = *(unsigned int *)(a1 + 160);
    uint64_t v54 = &v30[56 * v25 + 44];
    __int16 v55 = (_DWORD *)(56 * v25 + v52 + 4);
    uint64_t v56 = v25;
    do
    {
      *(void *)(v54 - 2_Block_object_dispose(va, 8) = 0LL;
      *(void *)(v54 - 36) = 0LL;
      *(void *)(v54 - 20) = 0LL;
      *(void *)uint64_t v54 = 0xFFFFFFFF00008000LL;
      uint64_t v57 = v56;
      if (v53 != 0xFFFFFFFFLL) {
        *(_DWORD *)(v52 + 56 * v53) = v56;
      }
      *(v55 - __postAndResetMidnight(1, 1) = -1;
      *__int16 v55 = v53;
      ++v56;
      *(_DWORD *)(a1 + 160) = v57;
      v54 += 56;
      v55 += 14;
      uint64_t v53 = v57;
    }

    while (v28 != v56);
    v51 += v26 - v25;
    *(_DWORD *)(a1 + 156) = v51;
  }

  if (v51 != (_DWORD)v26) {
    _CFXNotificationRegistrarAddObserver_cold_2();
  }
  unsigned int v18 = *(_DWORD *)(a1 + 160);
  CFHashCode v14 = a6;
  int v12 = a8;
  aBlocuint64_t k = v71;
  CFURLRef cf = v72;
  if (v18 == -1) {
    goto LABEL_38;
  }
LABEL_3:
  uint64_t v19 = *(void *)(a1 + 144);
  uint64_t v20 = (unsigned int *)(v19 + 56LL * v18);
  unsigned int v21 = *v20;
  unsigned int v22 = v20[1];
  *(_DWORD *)(a1 + 160) = v22;
  if (v21 != -1) {
    *(_DWORD *)(v19 + 56LL * v21 + 4) = v22;
  }
  if (v22 != -1) {
    *(_DWORD *)(v19 + 56LL * v22) = v21;
  }
LABEL_39:
  ++*(_DWORD *)(a1 + 152);
  unsigned int v58 = v18;
  *a7 = v18;
  uint64_t v59 = v19 + 56LL * v18;
  CFXNotificationHandlerCopy((void *)(v59 + 16), aBlock, cf, v12);
  *(_DWORD *)(v59 + 40) = HIDWORD(a9);
  *(_DWORD *)(v59 + 4_Block_object_dispose(va, 8) = a5;
  char v60 = (id *)(v59 + 8);
  if ((v12 & 0x400) != 0)
  {
    if (!objc_storeWeakOrNil(v60, v14))
    {
      *char v60 = v14;
      v12 &= ~0x400u;
    }
  }

  else
  {
    *char v60 = v14;
  }

  uint64_t v61 = v19 + 56LL * v58;
  *(_DWORD *)(v61 + 44) = v12;
  *(void *)(v61 + 32) = 0LL;
  unsigned int v62 = *a7;
  unsigned int v63 = *a2;
  if (*a2 != -1) {
    *(_DWORD *)(*(void *)(a1 + 144) + 56LL * v63) = v62;
  }
  uint64_t result = (_DWORD *)(v19 + 56LL * v58);
  *uint64_t result = -1;
  result[1] = v63;
  int v65 = a2[1] + 1;
  *a2 = v62;
  a2[1] = v65;
  return result;
}

uint64_t _CFXNotificationRegistrarAddObject( uint64_t a1, uint64_t a2, void *a3, unint64_t a4, unsigned int *a5, int a6, int a7)
{
  uint64_t result = _CFXNotificationRegistrarFindObject(a1, a2, a3, a4, a7, a5);
  if (result) {
    return result;
  }
  uint64_t v15 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v15 == -1)
  {
    size_t v16 = malloc_good_size(32LL * (*(_DWORD *)(a1 + 132) + 1));
    size_t v17 = v16 >> 5;
    uint64_t v18 = *(unsigned int *)(a1 + 132);
    uint64_t v19 = *(void **)(a1 + 120);
    if (v19) {
      uint64_t v20 = realloc(v19, v16 & 0x1FFFFFFFE0LL);
    }
    else {
      uint64_t v20 = malloc(v16 & 0x1FFFFFFFE0LL);
    }
    *(_DWORD *)(a1 + 132) = v17;
    *(void *)(a1 + 120) = v20;
    if (v18 >= v17)
    {
      uint64_t v15 = *(unsigned int *)(a1 + 136);
    }

    else
    {
      uint64_t v21 = *(unsigned int *)(a1 + 136);
      uint64_t v22 = (uint64_t)&v20[8 * v18 + 4];
      do
      {
        uint64_t v15 = v18;
        if (v21 != 0xFFFFFFFFLL) {
          v20[8 * v21] = v18;
        }
        *(_DWORD *)(v22 - ++*(_WORD *)(cf + 16) = -1;
        *(_DWORD *)(v22 - 12) = v21;
        *(_DWORD *)(v22 + _Block_object_dispose(va, 8) = -1;
        *(void *)(v22 - _Block_object_dispose(va, 8) = 0LL;
        ++v18;
        *(void *)uint64_t v22 = 0xFFFFFFFFLL;
        v22 += 32LL;
        uint64_t v21 = v15;
      }

      while ((v16 >> 5) != v18);
      *(_DWORD *)(a1 + 136) = v15;
    }

    uint64_t v23 = 0xFFFFFFFFLL;
    if (v15 == 0xFFFFFFFFLL) {
      goto LABEL_20;
    }
  }

  else
  {
    uint64_t v20 = *(_DWORD **)(a1 + 120);
  }

  size_t v24 = &v20[8 * v15];
  uint64_t v25 = *v24;
  uint64_t v26 = v24[1];
  *(_DWORD *)(a1 + 136) = v26;
  if ((_DWORD)v25 != -1) {
    v20[8 * v25 + 1] = v26;
  }
  if ((_DWORD)v26 != -1) {
    v20[8 * v26] = v25;
  }
  uint64_t v23 = v15;
LABEL_20:
  ++*(_DWORD *)(a1 + 128);
  *a5 = v23;
  uint64_t v27 = (char *)&v20[8 * v23];
  *((_DWORD *)v27 + 6) = -1;
  uint64_t v28 = v27 + 24;
  *((void *)v27 + 2) = 0xFFFFFFFFLL;
  uint64_t v52 = v27;
  uint64_t v53 = v20;
  uint64_t v29 = (void **)(v27 + 8);
  if (a7) {
    _CFXNotificationRegistrarAddCachedName(a3, v29);
  }
  else {
    char *v29 = a3;
  }
  _DWORD *v28 = a6;
  unsigned int v30 = *a5;
  unsigned int v31 = 31 - __clz(*(_DWORD *)(a2 + 12) + 1);
  if (v31 <= 1) {
    unsigned int v31 = 1;
  }
  size_t v32 = malloc_good_size(4LL * v31);
  uint64_t v50 = v23;
  unint64_t v51 = a4;
  unint64_t v33 = (v32 >> 2);
  unint64_t v34 = *(unsigned int *)(a2 + 8);
  uint64_t v35 = *(unsigned int **)a2;
  if (v34 >= v33)
  {
    unsigned int v38 = *(unsigned int **)a2;
    unint64_t v33 = *(unsigned int *)(a2 + 8);
  }

  else
  {
    size_t v36 = v32 & 0x3FFFFFFFCLL;
    uint64_t v37 = (unsigned int *)malloc(v32 & 0x3FFFFFFFCLL);
    unsigned int v38 = v37;
    if (v35)
    {
      unsigned int v49 = v30;
      memset(v37, 255, v36);
      if (v34)
      {
        for (unint64_t i = 0LL; i < v34; ++i)
        {
          uint64_t v40 = v35[i];
          if ((_DWORD)v40 != -1)
          {
            do
            {
              uint64_t v41 = *(void *)(a1 + 120);
              uint64_t v42 = v41 + 32 * v40;
              unint64_t v43 = *(void *)(v42 + 8);
              if (a7) {
                CFHashCode v44 = CFHash((CFTypeRef)v43);
              }
              else {
                CFHashCode v44 = (v43 >> 5) & 0x7F;
              }
              uint64_t v45 = v41 + 32 * v40;
              uint64_t v46 = *(unsigned int *)(v45 + 4);
              uint64_t v47 = v38[v44 % v33];
              *(_DWORD *)(v45 + 4) = v47;
              *(_DWORD *)uint64_t v42 = -1;
              if ((_DWORD)v47 != -1) {
                *(_DWORD *)(*(void *)(a1 + 120) + 32 * v47) = v40;
              }
              v38[v44 % v33] = v40;
              uint64_t v40 = v46;
            }

            while (v46 != 0xFFFFFFFFLL);
            unint64_t v34 = *(unsigned int *)(a2 + 8);
          }
        }
      }

      *(void *)a2 = v38;
      *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v33;
      free(v35);
      unint64_t v33 = *(unsigned int *)(a2 + 8);
      unsigned int v38 = *(unsigned int **)a2;
      unsigned int v30 = v49;
    }

    else
    {
      *(void *)a2 = v37;
      *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v33;
      memset(v37, 255, v36);
    }
  }

  uint64_t result = (uint64_t)v52;
  uint64_t v48 = v38[v51 % v33];
  if ((_DWORD)v48 != -1) {
    *(_DWORD *)(*(void *)(a1 + 120) + 32 * v4_Block_object_dispose(va, 8) = v30;
  }
  *uint64_t v52 = -1;
  v53[8 * v50 + 1] = v48;
  v38[v51 % v33] = v30;
  ++*(_DWORD *)(a2 + 12);
  return result;
}

uint64_t _CFXNotificationRegistrarAddName( uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, unsigned int *a5, int a6)
{
  unint64_t v8 = a4;
  uint64_t Name = _CFXNotificationRegistrarFindName(a1, a2, a3, a4, a5);
  if (Name) {
    return Name;
  }
  unsigned int v13 = *(_DWORD *)(a1 + 112);
  if (v13 == -1)
  {
    size_t v15 = malloc_good_size(40LL * (*(_DWORD *)(a1 + 108) + 1)) / 0x28;
    uint64_t v16 = *(unsigned int *)(a1 + 108);
    size_t v17 = *(void **)(a1 + 96);
    if (v17) {
      uint64_t v18 = realloc(v17, 40LL * v15);
    }
    else {
      uint64_t v18 = malloc(40LL * v15);
    }
    CFHashCode v14 = v18;
    *(_DWORD *)(a1 + 10_Block_object_dispose(va, 8) = v15;
    *(void *)(a1 + 96) = v18;
    if (v16 < v15)
    {
      uint64_t v19 = 40LL * v16 + 36;
      do
      {
        uint64_t v20 = *(void *)(a1 + 96);
        unsigned int v21 = *(_DWORD *)(a1 + 112);
        if (v21 != -1) {
          *(_DWORD *)(v20 + 40LL * v2__postAndResetMidnight(1, 1) = v16;
        }
        uint64_t v22 = v20 + v19;
        *(_DWORD *)(v22 - 36) = -1;
        *(_DWORD *)(v22 - 32) = v21;
        *(_DWORD *)(a1 + 112) = v16;
        *(void *)(v22 - 2_Block_object_dispose(va, 8) = 0LL;
        *(_DWORD *)(v22 - 4) = 0;
        *(void *)(*(void *)(a1 + 96) + v19 - 12) = 0LL;
        *(_DWORD *)(*(void *)(a1 + 96) + v19) = 0;
        ++v16;
        v19 += 40LL;
      }

      while (v15 != v16);
      CFHashCode v14 = *(_DWORD **)(a1 + 96);
    }

    unsigned int v13 = *(_DWORD *)(a1 + 112);
    if (v13 == -1) {
      goto LABEL_18;
    }
  }

  else
  {
    CFHashCode v14 = *(_DWORD **)(a1 + 96);
  }

  uint64_t v23 = &v14[10 * v13];
  int v24 = *v23;
  int v25 = v23[1];
  *(_DWORD *)(a1 + 112) = v25;
  if (v24 != -1) {
    v14[10 * v24 + 1] = v25;
  }
  if (v25 != -1) {
    v14[10 * v25] = v24;
  }
LABEL_18:
  ++*(_DWORD *)(a1 + 104);
  *a5 = v13;
  uint64_t Name = (uint64_t)&v14[10 * v13];
  _CFXNotificationRegistrarAddCachedName(a3, (void **)(Name + 8));
  uint64_t v26 = (void *)(Name + 24);
  if (a6 == 1)
  {
    void *v26 = 0xFFFFFFFFLL;
  }

  else
  {
    void *v26 = 0LL;
    *(void *)(Name + 32) = 0LL;
  }

  unsigned int v27 = *a5;
  unsigned int v28 = 31 - __clz(*(_DWORD *)(a2 + 12) + 1);
  if (v28 <= 1) {
    unsigned int v28 = 1;
  }
  size_t v29 = malloc_good_size(4LL * v28);
  unsigned int v30 = v13;
  unint64_t v31 = (v29 >> 2);
  unint64_t v32 = *(unsigned int *)(a2 + 8);
  unint64_t v33 = *(_DWORD **)a2;
  if (v32 >= v31)
  {
    unsigned int v38 = *(_DWORD **)a2;
    unint64_t v31 = *(unsigned int *)(a2 + 8);
  }

  else
  {
    unsigned int v53 = v30;
    uint64_t v54 = v14;
    unint64_t v34 = v8;
    unsigned int v35 = v27;
    size_t v36 = v29 & 0x3FFFFFFFCLL;
    uint64_t v37 = malloc(v29 & 0x3FFFFFFFCLL);
    unsigned int v38 = v37;
    if (v33)
    {
      memset(v37, 255, v36);
      unsigned int v27 = v35;
      unint64_t v8 = v34;
      CFHashCode v14 = v54;
      if (v32)
      {
        unint64_t v39 = 0LL;
        unint64_t v40 = v32;
        do
        {
          uint64_t v41 = v33[v39];
          if ((_DWORD)v41 != -1)
          {
            uint64_t v42 = *(void *)(a1 + 96);
            do
            {
              unint64_t v43 = (int *)(v42 + 40 * v41);
              unint64_t v44 = *((void *)v43 + 2);
              uint64_t v45 = v43[1];
              unsigned int v46 = *v43;
              if (v33[v44 % v32] == v41) {
                v33[v44 % v32] = v45;
              }
              if (v46 != -1) {
                *(_DWORD *)(v42 + 40LL * v46 + 4) = v45;
              }
              if (v45 != 0xFFFFFFFFLL) {
                *(_DWORD *)(v42 + 40LL * v45) = v46;
              }
              if (v38)
              {
                unint64_t v47 = v44 % v31;
                unsigned int v48 = v38[v47];
                if (v48 != -1) {
                  *(_DWORD *)(v42 + 40LL * v4_Block_object_dispose(va, 8) = v41;
                }
                int *v43 = -1;
                v43[1] = v48;
                v38[v47] = v41;
              }

              uint64_t v41 = v45;
            }

            while (v45 != 0xFFFFFFFFLL);
            unint64_t v40 = *(unsigned int *)(a2 + 8);
          }

          ++v39;
        }

        while (v39 < v40);
      }

      *(void *)a2 = v38;
      *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v31;
      free(v33);
      unint64_t v31 = *(unsigned int *)(a2 + 8);
      unsigned int v38 = *(_DWORD **)a2;
    }

    else
    {
      *(void *)a2 = v37;
      *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v31;
      memset(v37, 255, v36);
      unsigned int v27 = v35;
      unint64_t v8 = v34;
      CFHashCode v14 = v54;
    }

    unsigned int v30 = v53;
  }

  *(void *)&v14[10 * v30 + 4] = v8;
  if (v27 != -1 && v38)
  {
    uint64_t v49 = *(void *)(a1 + 96);
    unsigned int v50 = v38[v8 % v31];
    if (v50 != -1) {
      *(_DWORD *)(v49 + 40LL * v50) = v27;
    }
    unint64_t v51 = (_DWORD *)(v49 + 40LL * v27);
    *unint64_t v51 = -1;
    v51[1] = v50;
    v38[v8 % v31] = v27;
  }

  ++*(_DWORD *)(a2 + 12);
  return Name;
}

void CFXNotificationRegistrarAddRemoteToken( uint64_t a1, const void *a2, const __CFString *cf, __CFString *cf1, const __CFString *a5, int a6, void *a7, const void *a8)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  unsigned int v11 = *(unsigned __int8 *)(a1 + 24);
  if (cf)
  {
    int v12 = cf;
    if (@"kCFNotificationAnyName" != cf && CFEqual(cf, @"kCFNotificationAnyName")) {
      int v12 = @"kCFNotificationAnyName";
    }
  }

  else
  {
    int v12 = @"kCFNotificationAnyName";
  }

  int v13 = (v11 >> 1) & 1;
  if (cf1)
  {
    if (v13 && @"kCFNotificationAnyObject" != cf1 && CFEqual(cf1, @"kCFNotificationAnyObject")) {
      cf1 = @"kCFNotificationAnyObject";
    }
  }

  else
  {
    cf1 = @"kCFNotificationAnyObject";
  }

  CFHashCode v14 = @"kCFNotificationAnyObserver";
  if (a5) {
    CFHashCode v14 = a5;
  }
  *(void *)unint64_t v34 = v14;
  CFHashCode v15 = CFHash(v12);
  if (v13) {
    CFHashCode v16 = CFHash(cf1);
  }
  else {
    CFHashCode v16 = ((unint64_t)cf1 >> 5) & 0x7F;
  }
  size_t v17 = (unsigned int *)(a1 + 168);
  do
    uint64_t v18 = __ldaxr(v17);
  while (__stlxr(v18 + 1, v17));
  uint64_t v19 = v18 << 32;
  unsigned int v39 = -1;
  unsigned int v40 = -1;
  unsigned int v38 = -1;
  memset(v41, 0, sizeof(v41));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v12 == @"kCFNotificationAnyName")
  {
    if (cf1 == @"kCFNotificationAnyObject")
    {
      unsigned int v21 = (unsigned int *)(a1 + 80);
      uint64_t v31 = v19;
      unint64_t v32 = -1LL;
      uint64_t v23 = a1;
      int v24 = a7;
      int v25 = a8;
      int v22 = -1;
      goto LABEL_27;
    }

    unsigned int v21 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, a1 + 48, cf1, v16, &v39, -1, v13) + 16);
    int v22 = v39;
    LODWORD(v32) = -1;
    HIDWORD(v32) = v39;
LABEL_26:
    uint64_t v31 = v19;
    uint64_t v23 = a1;
    int v24 = a7;
    int v25 = a8;
LABEL_27:
    uint64_t v26 = *(void **)v34;
    int v27 = a6;
    goto LABEL_29;
  }

  if (cf1 != @"kCFNotificationAnyObject")
  {
    uint64_t v20 = _CFXNotificationRegistrarAddName(a1, a1 + 32, v12, v15, &v40, 0);
    unsigned int v21 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, v20 + 24, cf1, v16, &v39, v40, v13) + 16);
    int v22 = v39;
    unint64_t v32 = __PAIR64__(v39, v40);
    goto LABEL_26;
  }

  unsigned int v21 = (unsigned int *)(_CFXNotificationRegistrarAddName(a1, a1 + 64, v12, v15, &v40, 1) + 24);
  int v24 = a7;
  int v27 = a6 | 0x800;
  int v22 = v40;
  unint64_t v32 = __PAIR64__(v39, v40);
  uint64_t v31 = v19;
  uint64_t v23 = a1;
  int v25 = a8;
  uint64_t v26 = *(void **)v34;
LABEL_29:
  unsigned int v28 = _CFXNotificationRegistrarAddObserver( v23,  v21,  v24,  v25,  v22,  v26,  &v38,  v27,  v31,  v32,  SHIDWORD(v32),  (unsigned int *)v41);
  if (v28)
  {
    size_t v29 = (const void *)(v19 | v38);
    CFMutableDictionaryRef Mutable = *(__CFDictionary **)(a1 + 88);
    if (!Mutable)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, 0LL, 0LL);
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = Mutable;
    }

    CFDictionarySetValue(Mutable, a2, v29);
    *((void *)v28 + 4) = a2;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v41);
}

void CFXNotificationRegistrarRemoveRemoteToken(uint64_t a1, const void *a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  memset(v7, 0, sizeof(v7));
  unsigned int v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  BOOL v5 = *(const __CFDictionary **)(a1 + 88);
  if (v5
    && CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value)
    && *(_DWORD *)(a1 + 156) > value
    && *(_DWORD *)(*(void *)(a1 + 144) + 56LL * value + 40) == HIDWORD(value))
  {
    _CFXNotificationRegistrarInvalidateObserver(a1, value, -1, -1, (unsigned int *)v7);
  }

  os_unfair_lock_unlock(v4);
  _CFXNotificationDisposalListRelease((unsigned int *)v7);
}

void CFXNotificationRegisteredObserverSetNotifyToken(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) > a2)
  {
    uint64_t v7 = *(void *)(a1 + 144);
    if (*(_DWORD *)(v7 + 56LL * a2 + 40) == HIDWORD(a2))
    {
      uint64_t v8 = v7 + 56LL * a2;
      *(_DWORD *)(v8 + 44) |= 0x4000u;
      *(_DWORD *)(v8 + 32) = a3;
    }
  }

  os_unfair_lock_unlock(v6);
}

void CFXNotificationRegisteredObserverSetDistributedConnection(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  os_unfair_lock_unlock(v6);
}

void *_CFXNotificationRegisteredObserverSetDistributedConnection( void *result, int a2, unsigned int a3, void *object)
{
  uint64_t v4 = result[18];
  if (*(_DWORD *)(v4 + 56LL * a3 + 40) == a2)
  {
    uint64_t v6 = v4 + 56LL * a3;
    uint64_t v8 = *(void **)(v6 + 32);
    uint64_t v7 = v6 + 32;
    uint64_t result = v8;
    *(_DWORD *)(v7 + 12) |= 0x2000u;
    if (v8 != object)
    {
      if (result) {
        xpc_release(result);
      }
      uint64_t result = xpc_retain(object);
      *(void *)uint64_t v7 = result;
    }
  }

  return result;
}

void CFXNotificationRegistrarEnumerate(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v4 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[8], 0, a2);
  _CFXNotificationRegistrarEnumerateObjectTable( (uint64_t)a1,  (uint64_t)&a1[12],  (uint64_t)@"kCFNotificationAnyName",  a2);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[16], 1, a2);
  _CFXNotificationRegistrarEnumerateObserverTable( (uint64_t)a1,  &a1[20]._os_unfair_lock_opaque,  (uint64_t)@"kCFNotificationAnyName",  (uint64_t)@"kCFNotificationAnyObject",  a2);
  os_unfair_lock_unlock(v4);
}

void _CFXNotificationRegistrarEnumerateNameTable(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v4)
  {
    unint64_t v8 = 0LL;
    uint64_t v13 = a2;
    do
    {
      uint64_t v9 = *(unsigned int *)(*(void *)a2 + 4 * v8);
      if ((_DWORD)v9 != -1)
      {
        do
        {
          uint64_t v10 = *(void *)(a1 + 96) + 40 * v9;
          uint64_t v9 = *(unsigned int *)(v10 + 4);
          CFTypeRef v11 = CFCachedStringCopyString((CFTypeRef *)(v10 + 8));
          int v12 = (unsigned int *)(v10 + 24);
          if (a3 == 1) {
            _CFXNotificationRegistrarEnumerateObserverTable( a1,  v12,  (uint64_t)v11,  (uint64_t)@"kCFNotificationAnyObject",  a4);
          }
          else {
            _CFXNotificationRegistrarEnumerateObjectTable(a1, (uint64_t)v12, (uint64_t)v11, a4);
          }
          CFRelease(v11);
        }

        while (v9 != 0xFFFFFFFFLL);
        a2 = v13;
        unint64_t v4 = *(unsigned int *)(v13 + 8);
      }

      ++v8;
    }

    while (v8 < v4);
  }

uint64_t _CFXNotificationRegistrarEnumerateObjectTable(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v4)
  {
    uint64_t v8 = result;
    for (unint64_t i = 0LL; i < v4; ++i)
    {
      uint64_t v10 = *(unsigned int *)(*(void *)a2 + 4 * i);
      if ((_DWORD)v10 != -1)
      {
        do
        {
          uint64_t v11 = *(void *)(v8 + 120) + 32 * v10;
          uint64_t v10 = *(unsigned int *)(v11 + 4);
          uint64_t result = _CFXNotificationRegistrarEnumerateObserverTable( v8,  (unsigned int *)(v11 + 16),  a3,  *(void *)(v11 + 8),  a4);
        }

        while ((_DWORD)v10 != -1);
        unint64_t v4 = *(unsigned int *)(a2 + 8);
      }
    }
  }

  return result;
}

uint64_t _CFXNotificationRegistrarEnumerateObserverTable( uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v5 = *a2;
  if ((_DWORD)v5 != -1)
  {
    uint64_t v9 = result;
    do
    {
      uint64_t v10 = *(void *)(v9 + 144) + 56 * v5;
      uint64_t v11 = *(unsigned int *)(v10 + 4);
      uint64_t v12[2] = *(void *)(v10 + 8);
      __int128 v13 = *(_OWORD *)(v10 + 16);
      v12[0] = a3;
      v12[1] = a4;
      v12[3] = *(unsigned int *)(v10 + 44);
      unint64_t v14 = v5 | ((unint64_t)*(unsigned int *)(v10 + 40) << 32);
      uint64_t v15 = *(void *)(v10 + 32);
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(a5 + 16))(a5, v12);
      uint64_t v5 = v11;
    }

    while ((_DWORD)v11 != -1);
  }

  return result;
}

void CFXNotificationRegistrarUpdateDistributedConnections(os_unfair_lock_s *a1, uint64_t a2, uint64_t a3)
{
  void v5[7] = *MEMORY[0x1895F89C0];
  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 0x40000000LL;
  void v5[2] = __CFXNotificationRegistrarUpdateDistributedConnections_block_invoke;
  _OWORD v5[3] = &unk_1899ECC30;
  v5[5] = a1;
  v5[6] = a2;
  v5[4] = a3;
  unint64_t v4 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[8], 0, (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateObjectTable( (uint64_t)a1,  (uint64_t)&a1[12],  (uint64_t)@"kCFNotificationAnyName",  (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[16], 1, (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateObserverTable( (uint64_t)a1,  &a1[20]._os_unfair_lock_opaque,  (uint64_t)@"kCFNotificationAnyName",  (uint64_t)@"kCFNotificationAnyObject",  (uint64_t)v5);
  os_unfair_lock_unlock(v4);
}

uint64_t __CFXNotificationRegistrarUpdateDistributedConnections_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

BOOL CFXNotificationRegistrarIsEmpty(os_unfair_lock_s *a1)
{
  unint64_t v2 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  BOOL v3 = a1[15]._os_unfair_lock_opaque
     + a1[11]._os_unfair_lock_opaque
     + a1[19]._os_unfair_lock_opaque
     + a1[21]._os_unfair_lock_opaque == 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

BOOL CFXNotificationRegistrarValidateToken(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  BOOL v6 = *(_DWORD *)(a1 + 156) > a2
  os_unfair_lock_unlock(v4);
  return v6;
}

unsigned int *__CFXNotificationDisposalListAddItem(unsigned int *result, uint64_t a2)
{
  BOOL v3 = result;
  uint64_t v4 = *result;
  uint64_t v5 = (v4 - 3);
  if (v4 > 3)
  {
    unsigned int v7 = result[1];
    uint64_t result = (unsigned int *)*((void *)result + 5);
    if (v7 < v5)
    {
      if (result)
      {
        uint64_t result = (unsigned int *)realloc(result, (v4 - 3));
        LODWORD(v4) = *v3;
      }

      else
      {
        uint64_t result = (unsigned int *)malloc(8 * v5);
      }

      *((void *)v3 + 5) = result;
      v3[1] = v5;
    }

    BOOL v6 = &result[2 * (v4 - 4)];
  }

  else
  {
    BOOL v6 = &result[2 * v4 + 2];
  }

  *(void *)BOOL v6 = a2;
  *BOOL v3 = v4 + 1;
  return result;
}

void _CFXNotificationRegistrarRemoveCachedName(const void **a1)
{
  NamePool = _CFXNotificationRegistrarGetNamePool();
  *a1 = 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
}

CFMutableDictionaryRef _CFXNotificationRegistrarGetNamePool()
{
  CFMutableDictionaryRef result = (CFMutableDictionaryRef)__CFXNotificationRegistrarNamePool;
  if (!__CFXNotificationRegistrarNamePool)
  {
    CFMutableDictionaryRef result = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  0LL);
    __CFXNotificationRegistrarNamePool = (uint64_t)result;
  }

  return result;
}

BOOL CFCachedStringEqual(CFTypeRef *a1, const void *a2)
{
  if (*a1) {
    BOOL v4 = CFEqual(*a1, a2) != 0;
  }
  else {
    BOOL v4 = 0LL;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  return v4;
}

BOOL _CFXNotificationRegistrarRecycleObserverRegistration( uint64_t a1, unsigned int *a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v8 = *(void *)(a1 + 144);
  uint64_t v9 = a3;
  if (a2 && a3 != -1)
  {
    uint64_t v10 = (unsigned int *)(v8 + 56LL * a3);
    unsigned int v11 = *v10;
    unsigned int v12 = v10[1];
    if (*a2 == a3) {
      *a2 = v12;
    }
    if (v11 != -1) {
      *(_DWORD *)(v8 + 56LL * v11 + 4) = v12;
    }
    if (v12 != -1) {
      *(_DWORD *)(v8 + 56LL * v12) = v11;
    }
  }

  if ((*(_BYTE *)(a1 + 24) & 2) != 0)
  {
    int v13 = *(_DWORD *)(v8 + 56LL * a3 + 44);
    if ((v13 & 0x2000) != 0)
    {
      uint64_t v18 = v8 + 56LL * a3;
      uint64_t v20 = *(void *)(v18 + 32);
      uint64_t v19 = (xpc_connection_t *)(v18 + 32);
      if (v20)
      {
        xpc_object_t v21 = xpc_array_create(0LL, 0LL);
        xpc_array_set_uint64( v21,  0xFFFFFFFFFFFFFFFFLL,  v9 | ((unint64_t)*(unsigned int *)(v8 + 56LL * v9 + 40) << 32));
        xpc_object_t v22 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_string(v22, "method", "unregister");
        xpc_dictionary_set_uint64(v22, "version", 1uLL);
        xpc_dictionary_set_value(v22, "tokens", v21);
        _CFSuddenTerminationDisable();
        xpc_connection_send_message(*v19, v22);
        xpc_connection_send_barrier(*v19, &__block_literal_global_36);
        xpc_release(v22);
        xpc_release(v21);
        xpc_release(*v19);
      }

      *uint64_t v19 = 0LL;
    }

    else if ((v13 & 0x4000) != 0)
    {
      uint64_t v14 = v8 + 56LL * a3;
      int v17 = *(_DWORD *)(v14 + 32);
      uint64_t v16 = (_DWORD *)(v14 + 32);
      int v15 = v17;
      if (v17) {
        notify_cancel(v15);
      }
      _DWORD *v16 = 0;
    }
  }

  uint64_t v23 = v8 + 56LL * v9;
  int v25 = *(_DWORD *)(v23 + 44);
  uint64_t v24 = v23 + 44;
  _CFXNotificationHandlerRelease((uint64_t *)(v24 - 28), v25, a4);
  if ((*(_BYTE *)(v24 + 1) & 4) != 0) {
    objc_destroyWeak((id *)(v8 + 56LL * v9 + 8));
  }
  *(void *)(v8 + 56LL * v9 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)uint64_t v24 = 0x8000;
  int v26 = a2[1] - 1;
  a2[1] = v26;
  if (a3 != -1)
  {
    uint64_t v27 = *(void *)(a1 + 144);
    unsigned int v28 = *(_DWORD *)(a1 + 160);
    if (v28 != -1) {
      *(_DWORD *)(v27 + 56LL * v2_Block_object_dispose(va, 8) = a3;
    }
    *(_DWORD *)(v27 + 56LL * v9) = -1;
    *(_DWORD *)(v27 + 56LL * v9 + 4) = v28;
    *(_DWORD *)(a1 + 160) = a3;
    int v26 = a2[1];
  }

  --*(_DWORD *)(a1 + 152);
  return v26 == 0;
}

void _CFXNotificationRegistrarRecycleNameRegistration(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 96);
  if (a3 != -1)
  {
    uint64_t v10 = *a2;
    if (*a2)
    {
      unint64_t v11 = *(void *)(v8 + 40LL * a3 + 16) % (unint64_t)*((unsigned int *)a2 + 2);
      unsigned int v12 = (unsigned int *)(v8 + 40LL * a3);
      unsigned int v13 = *v12;
      unsigned int v14 = v12[1];
      if (*(_DWORD *)(v10 + 4 * v11) == a3) {
        *(_DWORD *)(v10 + 4 * v1__postAndResetMidnight(1, 1) = v14;
      }
      if (v13 != -1) {
        *(_DWORD *)(v8 + 40LL * v13 + 4) = v14;
      }
      if (v14 != -1) {
        *(_DWORD *)(v8 + 40LL * v14) = v13;
      }
    }
  }

  uint64_t v15 = v8 + 40LL * a3;
  uint64_t v17 = *(void *)(v15 + 8);
  uint64_t v16 = (const void **)(v15 + 8);
  if (v17) {
    _CFXNotificationRegistrarRemoveCachedName(v16);
  }
  if (!a4)
  {
    uint64_t v18 = v8 + 40LL * a3;
    xpc_object_t v21 = *(void **)(v18 + 24);
    uint64_t v20 = (void *)(v18 + 24);
    uint64_t v19 = v21;
    if (v21)
    {
      free(v19);
      void *v20 = 0LL;
    }
  }

  --*((_DWORD *)a2 + 3);
  if (a3 != -1)
  {
    uint64_t v22 = *(void *)(a1 + 96);
    unsigned int v23 = *(_DWORD *)(a1 + 112);
    if (v23 != -1) {
      *(_DWORD *)(v22 + 40LL * v23) = a3;
    }
    uint64_t v24 = (_DWORD *)(v22 + 40LL * a3);
    _DWORD *v24 = -1;
    v24[1] = v23;
    *(_DWORD *)(a1 + 112) = a3;
  }

  --*(_DWORD *)(a1 + 104);
}

BOOL _CFXNotificationRegistrarRecycleObjectRegistration(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = a3;
  uint64_t v10 = v8 + 32LL * a3;
  unint64_t v13 = *(void *)(v10 + 8);
  unsigned int v12 = (const void **)(v10 + 8);
  unint64_t v11 = v13;
  if (a4)
  {
    CFHashCode v14 = CFHash((CFTypeRef)v11);
    uint64_t v8 = *(void *)(a1 + 120);
  }

  else
  {
    CFHashCode v14 = (v11 >> 5) & 0x7F;
  }

  if (a3 != -1)
  {
    uint64_t v15 = *a2;
    if (*a2)
    {
      unint64_t v16 = v14 % *((unsigned int *)a2 + 2);
      uint64_t v17 = (unsigned int *)(v8 + 32 * v9);
      uint64_t v18 = *v17;
      uint64_t v19 = v17[1];
      if (*(_DWORD *)(v15 + 4 * v16) == a3) {
        *(_DWORD *)(v15 + 4 * v++*(_WORD *)(cf + 16) = v19;
      }
      if ((_DWORD)v18 != -1) {
        *(_DWORD *)(v8 + 32 * v18 + 4) = v19;
      }
      if ((_DWORD)v19 != -1) {
        *(_DWORD *)(v8 + 32 * v19) = v18;
      }
    }
  }

  if (a4) {
    _CFXNotificationRegistrarRemoveCachedName(v12);
  }
  unsigned int *v12 = 0LL;
  int v20 = *((_DWORD *)a2 + 3);
  if (v20) {
    *((_DWORD *)a2 + 3) = --v20;
  }
  if (a3 != -1)
  {
    uint64_t v21 = *(void *)(a1 + 120);
    uint64_t v22 = *(unsigned int *)(a1 + 136);
    if ((_DWORD)v22 != -1) {
      *(_DWORD *)(v21 + 32 * v22) = a3;
    }
    unsigned int v23 = (_DWORD *)(v21 + 32 * v9);
    *unsigned int v23 = -1;
    v23[1] = v22;
    *(_DWORD *)(a1 + 136) = a3;
    int v20 = *((_DWORD *)a2 + 3);
  }

  --*(_DWORD *)(a1 + 128);
  return v20 == 0;
}

void _CFXNotificationRegistrarAddCachedName(const void *a1, void **a2)
{
  key[1] = *(void **)MEMORY[0x1895F89C0];
  key[0] = 0LL;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  NamePool = _CFXNotificationRegistrarGetNamePool();
  if ((CFDictionaryGetKeyIfPresent((uint64_t)NamePool, (unint64_t)a1, key) & 1) != 0)
  {
    Value = (char *)CFDictionaryGetValue(NamePool, key[0]);
    CFDictionarySetValue(NamePool, key[0], Value + 1);
  }

  else
  {
    CFDictionarySetValue(NamePool, a1, (const void *)1);
    CFDictionaryGetKeyIfPresent((uint64_t)NamePool, (unint64_t)a1, key);
  }

  *a2 = key[0];
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
}

__objc2_class **__NSOrderedSetImmutablePlaceholder()
{
  return &___immutablePlaceholderOrderedSet;
}

__objc2_class **__NSOrderedSetMutablePlaceholder()
{
  return &___mutablePlaceholderOrderedSet;
}

CFStringRef CFBundleCopyLocalizedString( CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption( (unint64_t *)bundle,  (void *)key,  (void *)value,  (__CFString *)tableName,  0LL,  0,  0LL);
}

CFMutableStringRef CFBundleCopyLocalizedStringForLocalization( unint64_t *a1, void *a2, void *a3, __CFString *a4, const void *a5)
{
  return _CFBundleCopyLocalizedStringForLocalizationAndTableURL(a1, a2, a3, a4, a5, 0LL);
}

uint64_t _CFBundleSearchForLocalizedString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v13 = 0LL;
  CFHashCode v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  char v16 = 0;
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  uint64_t v9 = *(void **)(a1 + 144);
  if (v9)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    uint64_t v12[2] = ___CFBundleSearchForLocalizedString_block_invoke;
    v12[3] = &unk_1899ECD00;
    v12[6] = a3;
    v12[7] = a4;
    void v12[4] = &v13;
    v12[5] = a2;
    CFDictionaryApply(v9, (uint64_t)v12);
  }

  os_unfair_lock_unlock(v8);
  uint64_t v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_180B98D5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

const void *_CFBundleGetMappedStringsFile(CFIndex a1)
{
  ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)_mappedStringsFiles, a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&_mappedStringsFilesLock);
  return ValueAtIndex;
}

uint64_t _CFBundleCreateMappedBPlistFile()
{
  return __NSCreateBPlistMappedDataFromURL();
}

__n128 _CFBundleGetStringsSources@<Q0>( uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFString *a3@<X2>, const __CFArray *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v105 = *MEMORY[0x1895F89C0];
  uint64_t v10 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  *(void *)(a5 + 64) = 0LL;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + ++*(_WORD *)(cf + 16) = 0u;
  int v11 = 1;
  *(_BYTE *)(a5 + 67) = 1;
  unsigned int v12 = *(const __CFDictionary **)(a1 + 168);
  if (v12)
  {
    Value = CFDictionaryGetValue(v12, a3);
    if (Value)
    {
      *(_OWORD *)a5 = *Value;
      __int128 v14 = Value[1];
      __int128 v15 = Value[2];
      __int128 v16 = Value[3];
      *(void *)(a5 + 64) = *((void *)Value + 8);
      *(_OWORD *)(a5 + 32) = v15;
      *(_OWORD *)(a5 + 4_Block_object_dispose(va, 8) = v16;
      *(_OWORD *)(a5 + ++*(_WORD *)(cf + 16) = v14;
      *(_OWORD *)&v101[16] = Value[1];
      __int128 v102 = Value[2];
      __int128 v103 = Value[3];
      uint64_t v104 = *((void *)Value + 8);
      *(_OWORD *)uint64_t v101 = *Value;
      _CFBundleRetainStringsSources((uint64_t)v101);
      int v11 = 0;
    }
  }

  os_unfair_lock_unlock(v10);
  if (a4) {
    BOOL v17 = 0;
  }
  else {
    BOOL v17 = *(_BYTE *)(a1 + 54) == 0;
  }
  uint64_t v18 = v17;
  if (!*(void *)(a5 + 56))
  {
    if ((v11 & 1) != 0)
    {
      uint64_t v19 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, @"loctable", 0LL);
    }

    else
    {
      int v20 = *(const void **)(a5 + 48);
      if (!v20) {
        goto LABEL_27;
      }
      uint64_t v19 = (const __CFURL *)CFRetain(v20);
    }

    uint64_t v21 = v19;
    if (v19)
    {
      else {
        int v22 = 0;
      }
      CFDataRef MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData(v19, v22, v18, (BOOL *)&v97, (CFErrorRef *)&cf);
      *(void *)(a5 + 56) = MappedOrLoadedPlistData;
      if (MappedOrLoadedPlistData)
      {
        *(_BYTE *)(a5 + 66) = (_BYTE)v97;
      }

      else
      {
        UnlocalizedDebugDescription = (const void *)_CFErrorCreateUnlocalizedDebugDescription(cf);
        int v25 = (os_log_s *)_CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)uint64_t v101 = 138412802;
          *(void *)&v101[4] = a1;
          *(_WORD *)&v101[12] = 2112;
          *(void *)&v101[14] = a3;
          *(_WORD *)&v101[22] = 2112;
          *(void *)&v101[24] = UnlocalizedDebugDescription;
          _os_log_error_impl( &dword_180A4C000,  v25,  OS_LOG_TYPE_ERROR,  "loctable failed to load for bundle: %@, table: %@: %@",  v101,  0x20u);
        }

        CFRelease(UnlocalizedDebugDescription);
        CFRelease(cf);
      }

      int v26 = *(const void **)(a5 + 48);
      if (v26) {
        CFRelease(v26);
      }
      *(void *)(a5 + 4_Block_object_dispose(va, 8) = v21;
    }
  }

LABEL_132:
  if (v44) {
    CFRelease(v44);
  }
  if (v45) {
    CFRelease(v45);
  }
  _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 1, a2);
  __int128 v67 = *(_OWORD *)(a5 + 48);
  __int128 v102 = *(_OWORD *)(a5 + 32);
  __int128 v103 = v67;
  uint64_t v104 = *(void *)(a5 + 64);
  __int128 v68 = *(_OWORD *)(a5 + 16);
  *(_OWORD *)uint64_t v101 = *(_OWORD *)a5;
  *(_OWORD *)&v101[16] = v68;
  _CFBundleIngestResultForBundleCache(a1, a3, 1, (uint64_t)v101);
  if (*(_BYTE *)(a5 + 68))
  {
    uint64_t v69 = *(const void **)(a5 + 56);
    if (v69)
    {
      CFRelease(v69);
      *(void *)(a5 + 56) = 0LL;
    }
  }

  return result;
}

CFTypeRef _CFBundleRetainStringsSources(uint64_t a1)
{
  unint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRetain(v2);
  }
  BOOL v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRetain(v3);
  }
  BOOL v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRetain(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRetain(v5);
  }
  BOOL v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRetain(v6);
  }
  unsigned int v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRetain(v7);
  }
  uint64_t v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRetain(v8);
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 56);
  if (result) {
    return CFRetain(result);
  }
  return result;
}

void _CFBundleLoadNonLocTableData(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 54)) {
    a4 = 0;
  }
  CFTypeRef cf = 0LL;
  if (!*(void *)(a3 + 16))
  {
    if (*(void *)a3)
    {
      CFDataRef MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData( *(const __CFURL **)a3,  a4,  a5,  (BOOL *)(a3 + 64),  (CFErrorRef *)&cf);
      *(void *)(a3 + ++*(_WORD *)(cf + 16) = MappedOrLoadedPlistData;
      if (!MappedOrLoadedPlistData)
      {
        int v11 = (os_log_s *)_CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412802;
          uint64_t v17 = a1;
          __int16 v18 = 2112;
          uint64_t v19 = a2;
          __int16 v20 = 2112;
          CFTypeRef v21 = cf;
          _os_log_error_impl( &dword_180A4C000,  v11,  OS_LOG_TYPE_ERROR,  "Unable to load .strings file: %@ / %@: %@",  buf,  0x20u);
        }

        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = 0LL;
      }
    }
  }

  if (!*(void *)(a3 + 40))
  {
    unsigned int v12 = *(const __CFURL **)(a3 + 24);
    if (v12)
    {
      CFDataRef v13 = _CFBundleCreateMappedOrLoadedPlistData(v12, a4, a5, (BOOL *)(a3 + 65), (CFErrorRef *)&cf);
      *(void *)(a3 + 40) = v13;
      if (!v13)
      {
        __int128 v14 = (os_log_s *)_CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412802;
          uint64_t v17 = a1;
          __int16 v18 = 2112;
          uint64_t v19 = a2;
          __int16 v20 = 2112;
          CFTypeRef v21 = cf;
          _os_log_error_impl( &dword_180A4C000,  v14,  OS_LOG_TYPE_ERROR,  "Unable to load .stringsdict file: %@ / %@: %@",  buf,  0x20u);
        }

        if (cf) {
          CFRelease(cf);
        }
      }
    }
  }

void _CFBundleIngestResultForBundleCache(uint64_t a1, const void *a2, int a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  uint64_t v8 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  uint64_t v9 = *(const __CFDictionary **)(a1 + 168);
  if (v9)
  {
    Value = (CFTypeRef *)CFDictionaryGetValue(v9, a2);
    int v11 = Value;
    BOOL v12 = a3 != 0;
    if (a3 && Value)
    {
      CFDataRef v13 = *(const void **)(a4 + 8);
      __int128 v15 = *(const void **)(a4 + 24);
      __int128 v14 = *(const void **)(a4 + 32);
      __int128 v16 = *(const void **)(a4 + 40);
      int v17 = *(unsigned __int8 *)(a4 + 65);
      if (Value[1]) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = v13 == 0LL;
      }
      if (!v18)
      {
        if (*Value) {
          _CFBundleIngestResultForBundleCache_cold_4();
        }
        if (Value[2]) {
          _CFBundleIngestResultForBundleCache_cold_3();
        }
        uint64_t v19 = *(const void **)a4;
        __int16 v20 = *(const void **)(a4 + 16);
        if (v20 && *(_BYTE *)(a4 + 64))
        {
          v11[2] = CFRetain(v20);
          *((_BYTE *)v11 + 64) = 1;
        }

        if (v19) {
          CFTypeRef *v11 = CFRetain(v19);
        }
        v11[1] = CFRetain(v13);
      }

      if (v11[4]) {
        BOOL v21 = 1;
      }
      else {
        BOOL v21 = v14 == 0LL;
      }
      if (!v21)
      {
        if (v11[3]) {
          _CFBundleIngestResultForBundleCache_cold_2();
        }
        if (v11[5]) {
          _CFBundleIngestResultForBundleCache_cold_1();
        }
        if (v16 && v17)
        {
          v11[5] = CFRetain(v16);
          *((_BYTE *)v11 + 65) = 1;
        }

        if (v15) {
          v11[3] = CFRetain(v15);
        }
        v11[4] = CFRetain(v14);
      }

      goto LABEL_44;
    }

    if (Value) {
      goto LABEL_44;
    }
  }

  else
  {
    __int128 v29 = xmmword_1899ECE28;
    __int128 v30 = *(_OWORD *)&off_1899ECE38;
    *(void *)&__int128 v31 = 0LL;
    *(void *)(a1 + 16_Block_object_dispose(va, 8) = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  (const CFDictionaryValueCallBacks *)&v29);
    BOOL v12 = a3 != 0;
  }

  uint64_t v22 = malloc(0x48uLL);
  if (!v22) {
    goto LABEL_44;
  }
  unsigned int v23 = v22;
  __int128 v24 = *(_OWORD *)(a4 + 48);
  void v22[2] = *(_OWORD *)(a4 + 32);
  v22[3] = v24;
  *((void *)v22 + _Block_object_dispose(va, 8) = *(void *)(a4 + 64);
  __int128 v25 = *(_OWORD *)(a4 + 16);
  *uint64_t v22 = *(_OWORD *)a4;
  v22[1] = v25;
  if (!v12)
  {
    *((_WORD *)v22 + 32) = 0;
    *(void *)uint64_t v22 = 0LL;
    *((void *)v22 + __postAndResetMidnight(1, 1) = 0LL;
    *((void *)v22 + 3) = 0LL;
    *((void *)v22 + 4) = 0LL;
LABEL_35:
    *((void *)v22 + 2) = 0LL;
    goto LABEL_36;
  }

  if (!*(_BYTE *)(a4 + 64)) {
    goto LABEL_35;
  }
LABEL_36:
  if (*(_BYTE *)(a4 + 65)) {
    BOOL v26 = v12;
  }
  else {
    BOOL v26 = 0;
  }
  if (!v26) {
    *((void *)v22 + 5) = 0LL;
  }
  if (!*(_BYTE *)(a4 + 66)) {
    *((void *)v22 + 7) = 0LL;
  }
  __int128 v27 = v22[3];
  __int128 v31 = v22[2];
  __int128 v32 = v27;
  uint64_t v33 = *((void *)v22 + 8);
  __int128 v28 = v22[1];
  __int128 v29 = *v22;
  __int128 v30 = v28;
  _CFBundleRetainStringsSources((uint64_t)&v29);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 168), a2, v23);
LABEL_44:
  os_unfair_lock_unlock(v8);
}

void _CFBundleFlushStringSourceCache(uint64_t a1)
{
  unint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  BOOL v3 = *(const void **)(a1 + 168);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  }

  os_unfair_lock_unlock(v2);
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption( unint64_t *a1, void *a2, void *a3, __CFString *a4, const __CFArray *a5, int a6, CFTypeRef *a7)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  key = a2;
  unint64_t v14 = _CFGetNonObjCTypeID(a1);
  if (v14 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v14);
  }
  if (a2)
  {
    CFBundleAllowMixedLocalizations();
    if (!a4 || CFEqual(a4, &stru_1899EF170)) {
      a4 = @"Localizable";
    }
    __int128 v15 = -[NSSet initWithObjects:count:](objc_alloc(&OBJC_CLASS___NSSet), "initWithObjects:count:", &key, 1LL);
    CFTypeRef cf = 0LL;
    __int128 v16 = _copyStringTable((uint64_t)a1, a4, v15, a5, a6, &cf);
    if (v16)
    {
      int v17 = v16;
      Value = (__CFString *)CFDictionaryGetValue(v16, key);
      if (Value)
      {
        CFMutableStringRef MutableCopy = Value;
        CFRetain(Value);
        CFRelease(v17);

        goto LABEL_24;
      }

      CFRelease(v17);
    }

    if (a3 && !CFEqual(a3, &stru_1899EF170)) {
      BOOL v21 = a3;
    }
    else {
      BOOL v21 = key;
    }
    uint64_t v22 = (const __CFString *)CFRetain(v21);
    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once != -1) {
      dispatch_once( &_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once,  &__block_literal_global_38);
    }
    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_capitalize)
    {
      CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v22);
      unsigned int v23 = (os_log_s *)_CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412802;
        unsigned int v38 = key;
        __int16 v39 = 2112;
        CFIndex v40 = a4;
        __int16 v41 = 2112;
        uint64_t v42 = a1;
        _os_log_error_impl( &dword_180A4C000,  v23,  OS_LOG_TYPE_ERROR,  "ERROR: %@ not found in table %@ of bundle %@",  buf,  0x20u);
      }

      CFStringUppercase(MutableCopy, 0LL);
      CFRelease(v22);
    }

    else
    {
      CFMutableStringRef MutableCopy = (CFMutableStringRef)v22;
    }

CFDictionaryRef _copyStringTable( uint64_t a1, __CFString *a2, CFTypeRef cf, const __CFArray *a4, char a5, CFTypeRef *a6)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (cf) {
    BOOL v12 = (void *)CFRetain(cf);
  }
  else {
    BOOL v12 = 0LL;
  }
  if (CFStringHasSuffix(a2, @".nocache"))
  {
    int v13 = _CFExecutableLinkedOnOrAfter(5uLL);
    int v14 = 0;
    if (a4 || v13) {
      goto LABEL_36;
    }
LABEL_10:
    os_unfair_lock_lock_with_options();
    __int128 v15 = *(const __CFDictionary **)(a1 + 144);
    if (v15 && (Value = (const __CFDictionary *)CFDictionaryGetValue(v15, a2)) != 0LL)
    {
      int v17 = Value;
      BOOL v18 = *(const __CFSet **)(a1 + 152);
      if (v18 && CFSetContainsValue(v18, a2))
      {
        CFDictionaryRef Copy = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
LABEL_18:
        CFDictionaryRef v21 = Copy;
        CFTypeRef v22 = 0LL;
        goto LABEL_28;
      }

      if (v12)
      {
        *(void *)&__int128 v50 = 0LL;
        *((void *)&v50 + __postAndResetMidnight(1, 1) = &v50;
        __int128 v51 = 0x2020000000uLL;
        *(void *)&__int128 v35 = MEMORY[0x1895F87A8];
        *((void *)&v35 + __postAndResetMidnight(1, 1) = 3221225472LL;
        *(void *)&__int128 v36 = ___stringTableFromCacheSatisfyingRequest_block_invoke;
        *((void *)&v36 + __postAndResetMidnight(1, 1) = &unk_1899ECE58;
        *(void *)&__int128 v38 = a1;
        *((void *)&v38 + __postAndResetMidnight(1, 1) = a2;
        *(void *)&__int128 v37 = &v50;
        *((void *)&v37 + __postAndResetMidnight(1, 1) = v17;
        CFSetApply(v12, (uint64_t)&v35);
        CFTypeRef v22 = *(CFTypeRef *)(*((void *)&v50 + 1) + 24LL);
        if (v22) {
          CFDictionaryRef v21 = 0LL;
        }
        else {
          CFDictionaryRef v21 = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
        }
        _Block_object_dispose(&v50, 8);
LABEL_28:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
        if (v21)
        {
          if (a6) {
            *a6 = 0LL;
          }
          if (v12) {
            goto LABEL_80;
          }
          return v21;
        }

        goto LABEL_33;
      }
    }

    else
    {
      __int16 v20 = *(const __CFSet **)(a1 + 152);
      if (v20 && CFSetContainsValue(v20, a2))
      {
        CFDictionaryRef Copy = CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        goto LABEL_18;
      }

      if (v12)
      {
        CFTypeRef v22 = CFRetain(v12);
LABEL_25:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
LABEL_33:
        if (v12) {
          CFRelease(v12);
        }
        int v14 = 1;
        BOOL v12 = (void *)v22;
        goto LABEL_36;
      }
    }

    CFTypeRef v22 = 0LL;
    goto LABEL_25;
  }

  if (!a4) {
    goto LABEL_10;
  }
  int v14 = 0;
LABEL_36:
  _CFBundleGetStringsSources(a1, 1LL, a2, a4, (uint64_t)&v35);
  char v40 = v14;
  CFTypeRef v42 = 0LL;
  memset(v41, 0, sizeof(v41));
  CFTypeRef cfa = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if ((void)v36)
  {
    if (!(_BYTE)v39) {
      v41[0] = 1;
    }
    _OWORD v41[3] = 1;
  }

  if (*((void *)&v37 + 1))
  {
    if (!BYTE1(v39)) {
      v41[0] = 1;
    }
    v41[4] = 1;
  }

  if (*((void *)&v38 + 1))
  {
    if (!BYTE2(v39)) {
      v41[0] = 1;
    }
    v41[5] = 1;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  _loadStringsInOrder((const void *)a1, a2, v12, Mutable, (uint64_t)&v35, a6);
  if (v41[2])
  {
    CFMutableDictionaryRef v24 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    *(void *)&__int128 v50 = MEMORY[0x1895F87A8];
    *((void *)&v50 + __postAndResetMidnight(1, 1) = 3221225472LL;
    *(void *)&__int128 v51 = ___postProcessStringsDict_block_invoke;
    *((void *)&v51 + __postAndResetMidnight(1, 1) = &__block_descriptor_73_e34_____CFString__16__0____CFString__8l;
    *(void *)&__int128 v52 = Mutable;
    *((void *)&v52 + __postAndResetMidnight(1, 1) = v24;
    *(void *)&__int128 v53 = a1;
    *((void *)&v53 + __postAndResetMidnight(1, 1) = a2;
    int v54 = &v35;
    char v55 = a5;
    CFTypeRef context = cfa;
    uint64_t v45 = (uint64_t)Mutable;
    unsigned int v46 = (void (*)(uint64_t, const void *))&v50;
    __int16 v47 = (void *)a1;
    CFMutableStringRef v48 = (const void *)*((void *)&v36 + 1);
    char v49 = a5;
    CFDictionaryApplyFunction( Mutable,  (CFDictionaryApplierFunction)__CFPlatformSpecificStringDictionaryApplyFunction,  &context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFLocalizedFormatStringApplyFunction, &context);
    CFDictionaryApplyFunction( Mutable,  (CFDictionaryApplierFunction)__CFVariableWidthStringDictionaryApplyFunction,  &context);
    CFDictionaryApplyFunction( Mutable,  (CFDictionaryApplierFunction)__CFAttributedLocalizedStringDictionaryApplyFunction,  &context);
    CFRelease(v24);
  }

  if (!v14)
  {
    CFDictionaryRef v21 = Mutable;
    goto LABEL_77;
  }

  os_unfair_lock_lock_with_options();
  CFStringRef v25 = *(const __CFDictionary **)(a1 + 144);
  if (!v25)
  {
    CFStringRef v26 = CFGetAllocator((CFTypeRef)a1);
    CFStringRef v25 = CFDictionaryCreateMutable(v26, 0LL, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *(void *)(a1 + 144) = v25;
  }

  CFStringRef v27 = (void *)CFDictionaryGetValue(v25, a2);
  if (!v27)
  {
    CFStringRef v28 = CFGetAllocator((CFTypeRef)a1);
    CFStringRef v27 = CFDictionaryCreateMutable(v28, 0LL, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 144), a2, v27);
    CFRelease(v27);
  }

  if (!*(_WORD *)&v41[3] && !v41[5]) {
    goto LABEL_57;
  }
  if (cf)
  {
    CFMutableSetRef MutableCopy = CFSetCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, (CFSetRef)cf);
    __int128 v30 = (const void *)MEMORY[0x1895F87A8];
    *(void *)&__int128 v50 = MEMORY[0x1895F87A8];
    *((void *)&v50 + __postAndResetMidnight(1, 1) = 3221225472LL;
    *(void *)&__int128 v51 = ___copyIngestedCacheResult_block_invoke;
    *((void *)&v51 + __postAndResetMidnight(1, 1) = &__block_descriptor_48_e18_v32__0r_v8r_v16_24l;
    *(void *)&__int128 v52 = v27;
    *((void *)&v52 + __postAndResetMidnight(1, 1) = MutableCopy;
    CFDictionaryApply(Mutable, (uint64_t)&v50);
    if (CFSetGetCount(MutableCopy) >= 1)
    {
      __int128 v31 = *(const __CFDictionary **)(a1 + 160);
      if (!v31)
      {
        __int128 v31 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFCopyStringDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        *(void *)(a1 + 160) = v31;
      }

      CFIndex v32 = CFDictionaryGetValue(v31, a2);
      if (!v32)
      {
        CFIndex v32 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFCopyStringSetCallBacks);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 160), a2, v32);
        CFRelease(v32);
      }

      CFTypeRef context = v30;
      uint64_t v45 = 3221225472LL;
      unsigned int v46 = ___copyIngestedCacheResult_block_invoke_2;
      __int16 v47 = &__block_descriptor_40_e13_v24__0r_v8_16l;
      CFMutableStringRef v48 = v32;
      CFSetApply(MutableCopy, (uint64_t)&context);
    }

    CFRelease(MutableCopy);
    goto LABEL_69;
  }

  if (CFDictionaryGetCount(Mutable) >= 1)
  {
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, v27);
  }

  else
  {
LABEL_57:
    v41[1] = 1;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 144), a2);
    CFStringRef v27 = 0LL;
  }

void sub_180B9AAEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizationAndTableURL( unint64_t *a1, void *a2, void *a3, __CFString *a4, const void *a5, CFTypeRef *a6)
{
  v14[1] = *(const void **)MEMORY[0x1895F89C0];
  v14[0] = a5;
  if (!a5) {
    return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, 0LL, 0, a6);
  }
  int v11 = CFArrayCreate(0LL, v14, 1LL, &kCFTypeArrayCallBacks);
  CFMutableStringRef v12 = _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, v11, 0, a6);
  if (v11) {
    CFRelease(v11);
  }
  return v12;
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizations( unint64_t *a1, void *a2, void *a3, __CFString *a4, const __CFArray *a5)
{
  return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, a5, 0, 0LL);
}

CFDictionaryRef CFBundleCopyLocalizedStringTableForLocalization( unint64_t *a1, __CFString *a2, const void *a3)
{
  v10[1] = *(const void **)MEMORY[0x1895F89C0];
  v10[0] = a3;
  unint64_t v6 = _CFGetNonObjCTypeID(a1);
  if (v6 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v6);
  }
  CFBundleAllowMixedLocalizations();
  if (!a2 || CFEqual(a2, &stru_1899EF170)) {
    a2 = @"Localizable";
  }
  if (!a3)
  {
    CFDictionaryRef v8 = _copyStringTable((uint64_t)a1, a2, 0LL, 0LL, 0, 0LL);
    if (v8) {
      return v8;
    }
    return CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }

  unsigned int v7 = CFArrayCreate(0LL, v10, 1LL, &kCFTypeArrayCallBacks);
  CFDictionaryRef v8 = _copyStringTable((uint64_t)a1, a2, 0LL, v7, 0, 0LL);
  if (v7) {
    CFRelease(v7);
  }
  if (!v8) {
    return CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  return v8;
}

CFMutableDictionaryRef _CFBundleCopyFilteredLocalizedStringsForAllLocalizations( __CFBundle *a1, const __CFString *a2, uint64_t a3)
{
  v10[8] = *MEMORY[0x1895F89C0];
  CFBundleAllowMixedLocalizations();
  if (!a2 || CFEqual(a2, &stru_1899EF170)) {
    a2 = @"Localizable";
  }
  unint64_t v6 = CFBundleCopyBundleLocalizations(a1);
  CFIndex Count = CFArrayGetCount(v6);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  Count,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  _OWORD v10[2] = ___CFBundleCopyFilteredLocalizedStringsForAllLocalizations_block_invoke;
  _OWORD v10[3] = &__block_descriptor_64_e13_v24__0r_v8_16l;
  v10[4] = a1;
  v10[5] = a2;
  v10[6] = a3;
  void v10[7] = Mutable;
  CFArrayApply((uint64_t)v6, 0LL, Count, (uint64_t)v10);
  CFRelease(v6);
  return Mutable;
}

CFSetRef _CFBundleCopyLocalizationInfoDictionaryKeys()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  v1[0] = xmmword_1899ECDC0;
  v1[1] = *(_OWORD *)off_1899ECDD0;
  return CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)v1, 4LL, &kCFTypeSetCallBacks);
}

CFDictionaryRef _CFBundleCopyFilteredLocalizedStringsForAllLocalizationsForURL( const __CFURL *a1, const __CFString *a2, uint64_t a3, char a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (!_CFBundleCouldBeBundle(a1)) {
    return CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  v12[0] = xmmword_1899ECDC0;
  v12[1] = *(_OWORD *)off_1899ECDD0;
  CFDictionaryRef v8 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)v12, 4LL, &kCFTypeSetCallBacks);
  UniqueWithOptions = (__CFBundle *)_CFBundleCreateUniqueWithOptions( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  a1,  v8,  a4);
  CFRelease(v8);
  if (!UniqueWithOptions) {
    return CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  CFMutableDictionaryRef v10 = _CFBundleCopyFilteredLocalizedStringsForAllLocalizations(UniqueWithOptions, a2, a3);
  CFRelease(UniqueWithOptions);
  return v10;
}

void _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants( CFDataRef theData, const __CFString *a2, void *a3, _DWORD *a4, void *a5, _DWORD *a6)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  CFSetRef v9 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, theData, 0, 0LL);
  if (!v9) {
    goto LABEL_15;
  }
  CFMutableDictionaryRef v10 = v9;
  CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 5LL, &kCFTypeSetCallBacks);
  ProductNameSuffix = (const __CFString *)_CFBundleGetProductNameSuffix();
  PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
  Append3 = _CFStringCreateAppend3(a2, ProductNameSuffix, PlatformNameSuffix);
  __int128 v15 = _CFStringCreateAppend3(a2, PlatformNameSuffix, ProductNameSuffix);
  Append2 = _CFStringCreateAppend2(a2, PlatformNameSuffix);
  int v17 = _CFStringCreateAppend2(a2, ProductNameSuffix);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, Append3);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, v15);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, Append2);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, v17);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, a2);
  if (CFSetGetCount(Mutable) < 1) {
    goto LABEL_9;
  }
  CFDictionaryRef theDict = 0LL;
  int Filtered = _CFPropertyListCreateFiltered( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  theData,  0LL,  Mutable,  (CFTypeRef *)&theDict,  0LL);
  if (!theDict) {
    int Filtered = 0;
  }
  if (Filtered == 1)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"LocProvenance");
    __int16 v20 = Value;
    if (Value && (CFIndex v21 = CFDictionaryGetCount(Value), v21 == CFSetGetCount(Mutable)))
    {
      CFTypeRef v22 = (void *)CFRetain(v20);
    }

    else
    {
      CFIndex Count = CFSetGetCount(Mutable);
      CFTypeRef v22 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  Count,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      LOBYTE(valuePtr) = 3;
      CFNumberRef v24 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt8Type, &valuePtr);
      CFIndex Length = CFStringGetLength(@"LocProvenance");
      uint64_t v42 = MEMORY[0x1895F87A8];
      uint64_t v43 = 3221225472LL;
      uint64_t v44 = (uint64_t)___CFBundleCopyLocTableProvenanceForDeviceAndPlatformVariants_block_invoke;
      uint64_t v45 = &__block_descriptor_56_e13_v24__0r_v8_16l;
      CFIndex v46 = Length + 1;
      __int16 v47 = v22;
      CFNumberRef v48 = v24;
      CFSetApply(Mutable, (uint64_t)&v42);
      CFRelease(v24);
    }

    CFRelease(theDict);
  }

  else
  {
LABEL_9:
    CFTypeRef v22 = 0LL;
  }

  CFRelease(Append3);
  CFRelease(v15);
  CFRelease(Append2);
  CFRelease(v17);
  CFRelease(v10);
  CFRelease(Mutable);
  if (v22)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v22))
    {
      uint64_t v42 = 0LL;
      uint64_t v43 = (uint64_t)&v42;
      uint64_t v44 = 0x2020000000LL;
      LODWORD(v45) = 0;
      CFDictionaryRef theDict = 0LL;
      p_CFDictionaryRef theDict = &theDict;
      uint64_t v40 = 0x2020000000LL;
      uint64_t v41 = 0LL;
      uint64_t valuePtr = 0LL;
      p_uint64_t valuePtr = &valuePtr;
      uint64_t v36 = 0x2020000000LL;
      int v37 = 0;
      uint64_t v30 = 0LL;
      __int128 v31 = &v30;
      uint64_t v32 = 0x2020000000LL;
      uint64_t v33 = 0LL;
      v29[0] = MEMORY[0x1895F87A8];
      v29[1] = 3221225472LL;
      v29[2] = ___CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants_block_invoke;
      v29[3] = &unk_1899ECDE8;
      v29[7] = &v30;
      v29[8] = v22;
      v29[4] = &v42;
      v29[5] = &theDict;
      v29[6] = &valuePtr;
      CFDictionaryApply(v22, (uint64_t)v29);
      *a3 = p_theDict[3];
      *a4 = *(_DWORD *)(v43 + 24);
      *a5 = v31[3];
      *a6 = *((_DWORD *)p_valuePtr + 6);
      CFRelease(v22);
      _Block_object_dispose(&v30, 8);
      _Block_object_dispose(&valuePtr, 8);
      _Block_object_dispose(&theDict, 8);
      _Block_object_dispose(&v42, 8);
    }

    else
    {
      *a3 = 0LL;
      *a5 = 0LL;
      *a4 = 0;
      *a6 = 0;
      CFRelease(v22);
    }
  }

  else
  {
LABEL_15:
    *a3 = 0LL;
    *a5 = 0LL;
    *a4 = 0;
    *a6 = 0;
  }

void sub_180B9B77C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

__CFString *_CFStringCreateAppend3(const __CFString *a1, const __CFString *a2, const __CFString *a3)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v7 = CFStringGetLength(a2) + Length;
  CFIndex v8 = CFStringGetLength(a3);
  CFMutableSetRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7 + v8, a1);
  CFStringAppend(MutableCopy, a2);
  CFStringAppend(MutableCopy, a3);
  return MutableCopy;
}

__CFString *_CFStringCreateAppend2(const __CFString *a1, const __CFString *a2)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetLength(a2);
  CFMutableSetRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5 + Length, a1);
  CFStringAppend(MutableCopy, a2);
  return MutableCopy;
}

void _CFBundleAddProvenanceKeyPathIfPresent(const __CFSet *a1, __CFSet *a2, const __CFString *value)
{
  if (CFSetContainsValue(a1, value))
  {
    Append3 = _CFStringCreateAppend3(@"LocProvenance", @":", value);
    CFSetAddValue(a2, Append3);
    CFRelease(Append3);
  }

uint64_t _useLoctableInsteadOfFileBasedOnVersion(CFTypeRef *a1, CFTypeRef *a2, unsigned int a3, CFTypeRef cf)
{
  if (!cf) {
    return 0LL;
  }
  CFIndex v7 = (const __CFURL *)*a1;
  if (v7)
  {
    if (*a1) {
      CFRelease(*a1);
    }
  }

  *a1 = 0LL;
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = CFRetain(cf);
  return 1LL;
}

CFURLRef _CFBundleGetFileVersionForStringsResourceURL(const __CFURL *result)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (result)
  {
    unsigned int v5 = 0;
    CFTypeRef result = (const __CFURL *)CFURLCopyLastPathComponent(result);
    if (result)
    {
      uint64_t v1 = (const __CFString *)result;
      CFTypeRef cf = 0LL;
      ProductNameSuffix = (const __CFString *)_CFBundleGetProductNameSuffix();
      PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
      _CFBundleSplitFileName(v1, (__CFString **)&cf, 0LL, 0LL, ProductNameSuffix, (CFIndex)PlatformNameSuffix, 2LL, &v5);
      if (cf) {
        CFRelease(cf);
      }
      CFRelease(v1);
      return (const __CFURL *)v5;
    }
  }

  return result;
}

void _releaseStringsSource(uint64_t a1, _OWORD *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  __int128 v3 = a2[3];
  void v5[2] = a2[2];
  _OWORD v5[3] = v3;
  uint64_t v6 = *((void *)a2 + 8);
  __int128 v4 = a2[1];
  v5[0] = *a2;
  v5[1] = v4;
  _CFBundleReleaseStringsSources((uint64_t)v5);
  free(a2);
}

void _CFBundleReleaseStringsSources(uint64_t a1)
{
  uint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  __int128 v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  __int128 v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRelease(v4);
  }
  unsigned int v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRelease(v6);
  }
  uint64_t v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRelease(v7);
  }
  CFIndex v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRelease(v8);
  }
  CFSetRef v9 = *(const void **)(a1 + 56);
  if (v9) {
    CFRelease(v9);
  }
}

CFStringRef _CFBundleCopyLanguageForStringsResourceURL(const __CFURL *a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  uint64_t v1 = CFURLCopyPath(a1);
  v7.CFIndex length = CFStringGetLength(v1);
  v7.CFIndex location = 0LL;
  if (CFStringFindWithOptions(v1, @".lproj", v7, 4uLL, &result)
    && (v8.length = result.location, v8.CFIndex location = 0LL, CFStringFindWithOptions(v1, @"/", v8, 4uLL, &v4)))
  {
    v9.CFIndex location = v4.length + v4.location;
    v9.CFIndex length = result.location - (v4.length + v4.location);
    CFStringRef v2 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, v9);
  }

  else
  {
    CFStringRef v2 = 0LL;
  }

  CFRelease(v1);
  return v2;
}

void _CFBundleGetLocTableProvenanceForLanguage( const __CFData *a1, const __CFString *a2, _BYTE *a3, BOOL *a4)
{
  v17[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  v17[0] = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, @"LocProvenance");
  CFStringAppend((CFMutableStringRef)v17[0], @":");
  CFStringAppend((CFMutableStringRef)v17[0], a2);
  CFRange v8 = -[NSSet initWithObjects:count:](objc_alloc(&OBJC_CLASS___NSSet), "initWithObjects:count:", v17, 1LL);
  CFTypeRef cf = 0LL;
  ValueWithKeyPath = (const __CFNumber *)_CFPropertyListGetValueWithKeyPath(cf, (const __CFString *)v17[0]);
  char valuePtr = 0;
  if (ValueWithKeyPath
    && (CFMutableDictionaryRef v10 = ValueWithKeyPath, CFGetTypeID(ValueWithKeyPath) == 22)
    && CFNumberGetValue(v10, kCFNumberCharType, &valuePtr))
  {
    char v11 = valuePtr;
    *a3 = valuePtr & 1;
    *a4 = (v11 & 2) != 0;
    BOOL v12 = 1;
  }

  else
  {
    BOOL v12 = CFEqual(a2, @"none") != 0;
  }

  if (cf) {
    CFRelease(cf);
  }
  if (!v12)
  {
LABEL_10:
    uint64_t v13 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, a1, 0, 0LL);
    if (v13)
    {
      int v14 = v13;
      if (CFSetContainsValue(v13, a2))
      {
        *a3 = 1;
        *a4 = 1;
      }

      CFRelease(v14);
    }
  }

  CFRelease(v17[0]);
}

void _loadStringsInOrder( const void *a1, void *a2, void *a3, const __CFDictionary *a4, uint64_t a5, CFTypeRef *a6)
{
  if (*(_BYTE *)(a5 + 67))
  {
    if (*(_BYTE *)(a5 + 77))
    {
      _loadStringsDictTable(a1, a2, a3, a4, a5, a6);
    }

    else if (*(_BYTE *)(a5 + 78))
    {
      _loadLocTable(a1, a2, *(CFTypeRef *)(a5 + 32), a3, a4, a5, (CFURLRef *)a6);
    }
  }

  if (*(_BYTE *)(a5 + 76))
  {
    int StringsFromData = _loadStringsFromData( a1,  a2,  a3,  *(const __CFData **)(a5 + 16),  *(unsigned __int8 *)(a5 + 64),  *(const __CFDictionary **)(a5 + 88),  (_BYTE *)a5);
    if (a6 && StringsFromData && !*a6) {
      *a6 = CFRetain(*(CFTypeRef *)a5);
    }
    CFDictionaryApplyFunction( *(CFDictionaryRef *)(a5 + 88),  (CFDictionaryApplierFunction)__CFStringsDictAddFunction,  a4);
  }

  else if (*(_BYTE *)(a5 + 78))
  {
    _loadLocTable(a1, a2, *(CFTypeRef *)(a5 + 8), a3, a4, a5, (CFURLRef *)a6);
  }

  if (!*(_BYTE *)(a5 + 67))
  {
    if (*(_BYTE *)(a5 + 77))
    {
      _loadStringsDictTable(a1, a2, a3, a4, a5, a6);
    }

    else if (*(_BYTE *)(a5 + 78))
    {
      _loadLocTable(a1, a2, *(CFTypeRef *)(a5 + 32), a3, a4, a5, (CFURLRef *)a6);
    }
  }

void ___stringTableFromCacheSatisfyingRequest_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), a2))
  {
    CFRange v4 = *(const __CFDictionary **)(*(void *)(a1 + 48) + 160LL);
    if (!v4
      || (Value = (const __CFSet *)CFDictionaryGetValue(v4, *(const void **)(a1 + 56))) == 0LL
      || !CFSetContainsValue(Value, a2))
    {
      uint64_t v6 = *(__CFSet **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (!v6)
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = CFSetCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeSetCallBacks);
        uint64_t v6 = *(__CFSet **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      }

      CFSetAddValue(v6, a2);
      CFRange v7 = (os_log_s *)_CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = *(void *)(a1 + 48);
        uint64_t v9 = *(void *)(a1 + 56);
        int v10 = 138412802;
        uint64_t v11 = v8;
        __int16 v12 = 2112;
        uint64_t v13 = a2;
        __int16 v14 = 2112;
        uint64_t v15 = v9;
        _os_log_debug_impl( &dword_180A4C000,  v7,  OS_LOG_TYPE_DEBUG,  "Lazy cache miss for bundle: %@ key: %@ table: %@",  (uint8_t *)&v10,  0x20u);
      }
    }
  }

CFIndex _loadStringsDictTable( const void *a1, void *a2, void *a3, CFDictionaryRef theDict, uint64_t a5, CFTypeRef *a6)
{
  CFIndex Count = CFDictionaryGetCount(theDict);
  int StringsFromData = _loadStringsFromData( a1,  a2,  a3,  *(const __CFData **)(a5 + 40),  *(unsigned __int8 *)(a5 + 65),  theDict,  (_BYTE *)a5);
  if (a6 && StringsFromData && !*a6) {
    *a6 = CFRetain(*(CFTypeRef *)(a5 + 24));
  }
  CFIndex result = CFDictionaryGetCount(theDict);
  if (result > Count) {
    *(_BYTE *)(a5 + 75) = 1;
  }
  return result;
}

void _loadLocTable(const void *a1, void *a2, CFTypeRef cf1, void *a4, void *a5, uint64_t a6, CFURLRef *a7)
{
  values[1] = *(void **)MEMORY[0x1895F89C0];
  values[0] = (void *)cf1;
  if (cf1)
  {
    uint64_t v13 = *(const void **)(a6 + 80);
    if (!v13 || !CFEqual(cf1, v13))
    {
      uint64_t v28 = 0LL;
      uint64_t v29 = &v28;
      uint64_t v30 = 0x2020000000LL;
      char v31 = 0;
      if (!a4 || *(_BYTE *)(a6 + 73) && *(_BYTE *)(a6 + 72))
      {
        CFTypeRef cf = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)values,  1LL,  &kCFTypeArrayCallBacks);
        __int16 v14 = -[NSSet initWithObjects:count:](objc_alloc(&OBJC_CLASS___NSSet), "initWithObjects:count:", &cf, 1LL);
        CFTypeRef StringsFromPlistData = __CFBundleCreateStringsFromPlistData( a1,  (const __CFSet *)v14,  *(const __CFData **)(a6 + 56),  *(unsigned __int8 *)(a6 + 66),  a2);
        ValueWithKeyPath = (const __CFDictionary *)_CFPropertyListGetValueWithKeyPath( StringsFromPlistData,  (const __CFString *)values[0]);
        int v17 = ValueWithKeyPath;
        if (ValueWithKeyPath && CFGetTypeID(ValueWithKeyPath) == 18 && CFDictionaryGetCount(v17) >= 1)
        {
          BOOL v23 = 0;
          _CFBundleGetLocTableProvenanceForLanguage( *(const __CFData **)(a6 + 56),  (const __CFString *)values[0],  &v24,  &v23);
          if (v23) {
            *(_BYTE *)(a6 + 75) = 1;
          }
          CFDictionaryApplyFunction(v17, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, a5);
          *((_BYTE *)v29 + 24) = 1;
          *(_BYTE *)(a6 + 74) = 1;
          *(void *)(a6 + 80) = CFRetain(values[0]);
        }

        CFRelease(cf);

        if (StringsFromPlistData) {
          CFRelease(StringsFromPlistData);
        }
      }

      else
      {
        if (_dictionaryContainsAllKeysInSet((uint64_t)a5, a4))
        {
LABEL_23:
          _Block_object_dispose(&v28, 8);
          return;
        }

        CFIndex Count = CFSetGetCount((CFSetRef)a4);
        CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
        uint64_t v20 = MEMORY[0x1895F87A8];
        v27[0] = MEMORY[0x1895F87A8];
        v27[1] = 3221225472LL;
        v27[2] = ___loadLocTable_block_invoke;
        v27[3] = &__block_descriptor_48_e13_v24__0r_v8_16l;
        v27[4] = values[0];
        v27[5] = Mutable;
        CFSetApply(a4, (uint64_t)v27);
        CFTypeRef v21 = __CFBundleCreateStringsFromPlistData( a1,  Mutable,  *(const __CFData **)(a6 + 56),  *(unsigned __int8 *)(a6 + 66),  a2);
        v26[0] = v20;
        v26[1] = 3221225472LL;
        v26[2] = ___loadLocTable_block_invoke_2;
        double v26[3] = &unk_1899ECE58;
        v26[6] = a6;
        v26[7] = a5;
        v26[4] = &v28;
        v26[5] = v21;
        CFSetApply(Mutable, (uint64_t)v26);
        if (v21) {
          CFRelease(v21);
        }
        CFRelease(Mutable);
      }

      if (a7 && !*a7)
      {
        if (*((_BYTE *)v29 + 24))
        {
          CFTypeRef v22 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"/LocTable/%@.lproj",  values[0]);
          *a7 = CFURLCreateWithFileSystemPath( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v22,  kCFURLPOSIXPathStyle,  1u);
          CFRelease(v22);
        }
      }

      goto LABEL_23;
    }
  }

void sub_180B9C638( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

uint64_t _loadStringsFromData( const void *a1, void *a2, void *a3, const __CFData *a4, int a5, const __CFDictionary *a6, _BYTE *a7)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v26 = 0LL;
  CFStringRef v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  char v29 = 0;
  if (a7[73])
  {
    __int16 v14 = 0LL;
    char v15 = 1;
    if (!a3)
    {
      CFMutableDictionaryRef Mutable = 0LL;
      goto LABEL_11;
    }

    CFMutableDictionaryRef Mutable = 0LL;
    if (a7[72]) {
      goto LABEL_11;
    }
  }

  else if (!a3)
  {
    __int16 v14 = 0LL;
    CFMutableDictionaryRef Mutable = 0LL;
    char v15 = 1;
    goto LABEL_11;
  }

  if (_dictionaryContainsAllKeysInSet((uint64_t)a6, a3))
  {
    uint64_t v17 = 0LL;
    goto LABEL_20;
  }

  CFIndex Count = CFSetGetCount((CFSetRef)a3);
  CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
  v25[0] = MEMORY[0x1895F87A8];
  v25[1] = 3221225472LL;
  v25[2] = ___loadStringsFromData_block_invoke;
  _OWORD v25[3] = &__block_descriptor_40_e13_v24__0r_v8_16l;
  v25[4] = Mutable;
  CFSetApply(a3, (uint64_t)v25);
  char v15 = 0;
  __int16 v14 = a3;
LABEL_11:
  CFTypeRef StringsFromPlistData = (const __CFDictionary *)__CFBundleCreateStringsFromPlistData(a1, Mutable, a4, a5, a2);
  uint64_t v20 = StringsFromPlistData;
  if (StringsFromPlistData)
  {
    if (CFGetTypeID(StringsFromPlistData) == 18)
    {
      if ((v15 & 1) != 0)
      {
        CFIndex v21 = CFDictionaryGetCount(a6);
        CFDictionaryApplyFunction(v20, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, a6);
        BOOL v22 = CFDictionaryGetCount(a6) > v21;
        *((_BYTE *)v27 + 24) = v22;
        a7[74] = 1;
      }

      else
      {
        v24[0] = MEMORY[0x1895F87A8];
        v24[1] = 3221225472LL;
        v24[2] = ___loadStringsFromData_block_invoke_2;
        v24[3] = &unk_1899ECEA0;
        v24[4] = &v26;
        v24[5] = v20;
        v24[6] = a6;
        CFSetApply(v14, (uint64_t)v24);
      }
    }

    CFRelease(v20);
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t v17 = *((unsigned __int8 *)v27 + 24);
LABEL_20:
  _Block_object_dispose(&v26, 8);
  return v17;
}

void sub_180B9C8BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

uint64_t _dictionaryContainsAllKeysInSet(uint64_t a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  char v8 = 1;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = ___dictionaryContainsAllKeysInSet_block_invoke;
  v4[3] = &unk_1899ECEC8;
  v4[4] = &v5;
  v4[5] = a1;
  CFSetApply(a2, (uint64_t)v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_180B9C9A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void ___loadStringsFromData_block_invoke(uint64_t a1, const void *a2)
{
  v4[1] = *(const void **)MEMORY[0x1895F89C0];
  v4[0] = a2;
  CFArrayRef v3 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, 1LL, &kCFTypeArrayCallBacks);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v3);
  CFRelease(v3);
}

CFTypeRef __CFBundleCreateStringsFromPlistData( CFTypeRef cf, const __CFSet *a2, const __CFData *a3, int a4, void *a5)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  CFErrorRef error = 0LL;
  if (!a2)
  {
    CFOptionFlags v12 = (unint64_t)(a4 != 0) << 16;
    uint64_t v13 = CFGetAllocator(cf);
    CFPropertyListRef v14 = CFPropertyListCreateWithData(v13, a3, v12, 0LL, &error);
    if (v14)
    {
      uint64_t v11 = (void *)v14;
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v11)) {
        return v11;
      }
      uint64_t v16 = (os_log_s *)_CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        __CFBundleCreateStringsFromPlistData_cold_1();
      }
      CFErrorRef v17 = (CFErrorRef)v11;
      goto LABEL_18;
    }

    if (error)
    {
      BOOL v22 = (os_log_s *)_CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412802;
        CFStringRef v27 = (const __CFSet *)cf;
        __int16 v28 = 2112;
        CFTypeRef v29 = a5;
        __int16 v30 = 2112;
        CFErrorRef v31 = error;
        uint64_t v19 = "Unable to load .strings file: %@ / %@: %@";
        uint64_t v20 = v22;
        uint32_t v21 = 32;
        goto LABEL_22;
      }

void ___loadStringsFromData_block_invoke_2(uint64_t a1, const void *a2)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  if (Value)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), a2, Value);
  }

void __CFStringsDictAddFunction(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

const void *___dictionaryContainsAllKeysInSet_block_invoke(uint64_t a1, const void *a2, _BYTE *a3)
{
  CFIndex result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  if (!result)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    *a3 = 1;
  }

  return result;
}

void ___loadLocTable_block_invoke(uint64_t a1, void *a2)
{
  values[2] = *(void **)MEMORY[0x1895F89C0];
  values[0] = *(void **)(a1 + 32);
  values[1] = a2;
  CFArrayRef v3 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 2LL, &kCFTypeArrayCallBacks);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), v3);
  CFRelease(v3);
}

void ___loadLocTable_block_invoke_2(uint64_t a1, const __CFString *a2)
{
  ValueWithKeyPath = _CFPropertyListGetValueWithKeyPath(*(const void **)(a1 + 40), a2);
  if (ValueWithKeyPath)
  {
    uint64_t v5 = ValueWithKeyPath;
    if (CFGetTypeID(ValueWithKeyPath) == 18) {
      *(_BYTE *)(*(void *)(a1 + 48) + 75LL) = 1;
    }
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, 1LL);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 56), ValueAtIndex, v5);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

const void *___postProcessStringsDict_block_invoke(uint64_t a1, const void *a2)
{
  v11[1] = *(const void **)MEMORY[0x1895F89C0];
  v11[0] = a2;
  CFIndex result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (!result)
  {
    CFIndex result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
    if (!result)
    {
      uint64_t v5 = -[NSSet initWithObjects:count:](objc_alloc(&OBJC_CLASS___NSSet), "initWithObjects:count:", v11, 1LL);
      _loadStringsInOrder( *(const void **)(a1 + 48),  *(void **)(a1 + 56),  v5,  *(const __CFDictionary **)(a1 + 40),  *(void *)(a1 + 64),  0LL);

      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v11[0]))
      {
        uint64_t v6 = *(void *)(a1 + 64);
        uint64_t v7 = *(const __CFDictionary **)(a1 + 40);
        uint64_t v8 = *(void *)(a1 + 48);
        v9[0] = *(void *)(v6 + 88);
        v9[1] = v7;
        _OWORD v9[2] = 0LL;
        v9[3] = v8;
        v9[4] = *(void *)(v6 + 24);
        char v10 = *(_BYTE *)(a1 + 72);
        CFDictionaryApplyFunction( v7,  (CFDictionaryApplierFunction)__CFPlatformSpecificStringDictionaryApplyFunction,  v9);
        CFDictionaryApplyFunction( *(CFDictionaryRef *)(a1 + 40),  (CFDictionaryApplierFunction)__CFLocalizedFormatStringApplyFunction,  v9);
      }

      return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v11[0]);
    }
  }

  return result;
}

void __CFPlatformSpecificStringDictionaryApplyFunction( const void *a1, const __CFDictionary *a2, CFDictionaryRef *a3)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"NSStringDeviceSpecificRuleType");
    if (Value)
    {
      uint64_t v8 = Value;
      uint64_t v9 = (const void *)_CFGetProductName();
      if (!CFDictionaryGetCount(v8)) {
        goto LABEL_13;
      }
      if (!v9 || (char v10 = CFDictionaryGetValue(v8, v9)) == 0LL)
      {
        char v10 = CFDictionaryGetValue(v8, @"other");
        if (!v10) {
          goto LABEL_13;
        }
      }

      CFTypeID v11 = CFGetTypeID(v10);
      if (v11 == CFStringGetTypeID() || (CFTypeID v12 = CFGetTypeID(v10), v12 == CFDictionaryGetTypeID())) {
        CFDictionarySetValue(a3[1], a1, v10);
      }
      CFTypeID v13 = CFGetTypeID(v10);
      if (v13 != CFStringGetTypeID())
      {
        CFTypeID v14 = CFGetTypeID(v10);
        if (v14 != CFDictionaryGetTypeID())
        {
LABEL_13:
          char v15 = CFDictionaryGetValue(*a3, a1);
          uint64_t v16 = a3[1];
          if (v15) {
            CFDictionarySetValue(v16, a1, v15);
          }
          else {
            CFDictionaryRemoveValue(v16, a1);
          }
        }
      }
    }
  }

void __CFLocalizedFormatStringApplyFunction(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Value = (void *)CFDictionaryGetValue(a2, @"NSStringLocalizedFormatKey");
    if (Value)
    {
      uint64_t v8 = (const void *)_CFStringCopyWithFomatStringConfiguration(Value, (uint64_t)a2);
      if (v8)
      {
        uint64_t v9 = v8;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v8);
        CFRelease(v9);
      }
    }
  }

void __CFVariableWidthStringDictionaryApplyFunction(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"NSStringVariableWidthRuleType");
    if (Value)
    {
      uint64_t v8 = Value;
      if (CFDictionaryGetCount(Value))
      {
        uint64_t context = *(void *)(a3 + 16);
        CFTypeRef cf = CFDictionaryCreateMutableCopy(0LL, 0LL, v8);
        CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)__CFVariableWidthStringApplyFunction, &context);
        uint64_t v9 = _CFStringCreateWithWidthContexts((uint64_t)cf);
        CFRelease(cf);
        if (v9)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v9);
          CFRelease(v9);
        }
      }

      else if (*(void *)a3 && (char v10 = CFDictionaryGetValue(*(CFDictionaryRef *)a3, a1)) != 0LL)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v10);
      }

      else
      {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), a1);
      }
    }
  }

void __CFAttributedLocalizedStringDictionaryApplyFunction( const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Value = CFDictionaryGetValue(a2, @"NSStringFormatSpecTypeKey");
    if (Value)
    {
      if (CFEqual(Value, @"NSStringDirectRuleType"))
      {
        uint64_t v8 = CFDictionaryGetValue(a2, @"NSStringLocalizationKey");
        if (v8
          && (uint64_t v9 = v8, CFGetTypeID(v8) == 7)
          && ((char v10 = CFDictionaryGetValue(a2, @"NSStringFormatIsMarkdownKey")) != 0LL
           && CFEqual(v10, &__kCFBooleanTrue)
           && !*(_BYTE *)(a3 + 40)
            ? (CFTypeID v11 = (const void *)_CFStringCreateWithMarkdownAndConfiguration( (uint64_t)v9,  (uint64_t)a2,  *(void *)(a3 + 24),  *(void *)(a3 + 32)))
            : (CFTypeID v11 = CFRetain(v9)),
              (CFTypeID v12 = v11) != 0LL))
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v11);
          CFRelease(v12);
        }

        else if (*(void *)a3 && (uint64_t v13 = CFDictionaryGetValue(*(CFDictionaryRef *)a3, a1)) != 0LL)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v13);
        }

        else
        {
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), a1);
        }
      }
    }
  }

void __CFVariableWidthStringApplyFunction(const void *a1, const void *a2, CFMutableDictionaryRef *a3)
{
  CFTypeID TypeID = CFStringGetTypeID();
  CFTypeID v7 = CFGetTypeID(a2);
  if (a3)
  {
    if (TypeID == v7)
    {
      if (a3[1])
      {
        if (*a3)
        {
          uint64_t v8 = (*((uint64_t (**)(CFMutableDictionaryRef, const void *))*a3 + 2))(*a3, a2);
          if (v8)
          {
            uint64_t v9 = (const void *)v8;
            CFTypeID v10 = CFStringGetTypeID();
            if (v10 == CFGetTypeID(v9)) {
              CFDictionarySetValue(a3[1], a1, v9);
            }
          }
        }
      }
    }
  }

void ___copyIngestedCacheResult_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
}

void ___copyIngestedCacheResult_block_invoke_2(uint64_t a1, const void *a2)
{
}

  ;
}

uint64_t (**__CFStringEncodingGetCyrillicConverterDefinition(int a1))()
{
  if (a1 > 1050)
  {
    switch(a1)
    {
      case 1051:
        return __CFConverterDOSRussian;
      case 2562:
        return __CFConverterKOI8R;
      case 1282:
        return __CFConverterWinCyrillic;
    }

    return 0LL;
  }

  CFIndex result = __CFConverterMacCyrillic;
  if (a1 != 7 && a1 != 152)
  {
    if (a1 == 517) {
      return __CFConverterISOCyrillic;
    }
    return 0LL;
  }

  return result;
}

uint64_t __CFToMacCyrillic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8806 < 0xFFFFDE3A) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&maccyrillic_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180D7EE74;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

uint64_t __CFFromMacCyrillic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = maccyrillic_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToMacCyrillicPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFPrecomposeCyrillicCharacter(a2);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8806) >= 0xDE3Au)
    {
      CFTypeID v11 = (unsigned __int16 *)&maccyrillic_from_uni;
      CFTypeID v12 = (unsigned __int16 *)&unk_180D7EE74;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        CFTypeID v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          CFTypeID v11 = v14 + 2;
        }

        else
        {
          CFTypeID v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

BOOL __CFIsValidCombiningCharacterForCyrillic(int a1)
{
  uint64_t v1 = 1LL;
  if (((1 << ~(_BYTE)a1) & 0xCA800000) == 0) {
    return a1 == 824;
  }
  return v1;
}

uint64_t __CFPrecomposeCyrillicCharacter(unsigned __int16 *a1)
{
  unsigned int v1 = a1[1] | (*a1 << 16);
  if (v1 - 82379529 < 0xFB54002F) {
    return 65533LL;
  }
  uint64_t v2 = (unsigned int *)&__CFCyrillicPrecompMap;
  char v3 = (unsigned int *)&unk_180D7F118;
  while (1)
  {
    uint64_t v4 = ((char *)v3 - (char *)v2) >> 4;
    uint64_t v5 = &v2[2 * v4];
    if (*v5 <= v1) {
      break;
    }
    char v3 = v5 - 2;
LABEL_7:
    if (v2 > v3) {
      return 65533LL;
    }
  }

  if (*v5 < v1)
  {
    uint64_t v2 = v5 + 2;
    goto LABEL_7;
  }

  return LOWORD(v2[2 * v4 + 1]);
}

uint64_t __CFToWinCyrillic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 < 0x80)
  {
LABEL_4:
    *a3 = a2;
    return 1LL;
  }

  else
  {
    if ((unsigned __int16)(a2 - 1040) <= 0x3Fu)
    {
      LOBYTE(a2) = a2 - 80;
      goto LABEL_4;
    }

    if ((unsigned __int16)(a2 - 8483) >= 0xDF7Du)
    {
      uint64_t v4 = (unsigned __int16 *)&cp1251_from_uni;
      uint64_t v5 = (unsigned __int16 *)&unk_180D7F218;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_4;
          }

          uint64_t v4 = v7 + 2;
        }

        else
        {
          uint64_t v5 = v7 - 2;
        }
      }

      while (v4 <= v5);
    }

    return 0LL;
  }

BOOL __CFFromWinCyrillic(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
  {
    if (a2 < 0xC0) {
      a2 = cp1251_to_uni[a2 - 128];
    }
    else {
      a2 += 848;
    }
  }

  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinCyrillicPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v9 = __CFPrecomposeCyrillicCharacter(a2);
  int v10 = __CFToWinCyrillic(v9, v9, &v12);
  uint64_t result = 0LL;
  if (v10 && v12)
  {
    if (a5) {
      *a4 = v12;
    }
    *a6 = 1LL;
    return 2LL;
  }

  return result;
}

uint64_t __CFToISOCyrillic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 < 0xA1) {
    goto LABEL_12;
  }
  switch(a2)
  {
    case 0xA7u:
      LOBYTE(a2) = -3;
      goto LABEL_12;
    case 0x2116u:
      LOBYTE(a2) = -16;
      goto LABEL_12;
    case 0xADu:
LABEL_12:
      *a3 = a2;
      return 1LL;
  }

  if (a2 - 1025 > 0x5E) {
    return 0LL;
  }
  uint64_t result = 0LL;
  if (a2 != 1037 && a2 != 1104 && a2 != 1117)
  {
    LOBYTE(a2) = a2 - 96;
    goto LABEL_12;
  }

  return result;
}

uint64_t __CFFromISOCyrillic(uint64_t a1, unsigned int a2, __int16 *a3)
{
  __int16 v3 = a2 + 864;
  if (a2 == 253) {
    __int16 v3 = 167;
  }
  if (a2 == 240) {
    __int16 v4 = 8470;
  }
  else {
    __int16 v4 = v3;
  }
  if (a2 == 173) {
    __int16 v4 = 173;
  }
  if (a2 < 0xA1) {
    __int16 v4 = a2;
  }
  *a3 = v4;
  return 1LL;
}

uint64_t __CFToISOCyrillicPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  uint64_t v9 = __CFPrecomposeCyrillicCharacter(a2);
  int v10 = __CFToISOCyrillic(v9, v9, &v12);
  uint64_t result = 0LL;
  if (v10 && v12)
  {
    if (a5) {
      *a4 = v12;
    }
    *a6 = 1LL;
    return 2LL;
  }

  return result;
}

uint64_t __CFToKOI8R(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&koi8r_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180D7F498;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

uint64_t __CFFromKOI8R(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = koi8r_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToDOSRussian(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&DOSRussian_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180D7F798;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromDOSRussian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSRussian_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSRussianPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFPrecomposeCyrillicCharacter(a2);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      CFTypeID v11 = (unsigned __int16 *)&DOSRussian_from_uni;
      char v12 = (unsigned __int16 *)&unk_180D7F798;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        CFTypeID v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          CFTypeID v11 = v14 + 2;
        }

        else
        {
          char v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

void sub_180B9DD64(_Unwind_Exception *exception_object)
{
}

void sub_180BA1858(_Unwind_Exception *a1)
{
}

void sub_180BA2B10(_Unwind_Exception *a1)
{
}

void sub_180BA375C(_Unwind_Exception *a1)
{
}

void sub_180BA3A10(_Unwind_Exception *a1)
{
}

void sub_180BA3E8C(_Unwind_Exception *a1)
{
}

void sub_180BA41C4(_Unwind_Exception *exception_object)
{
}

uint64_t __createOrderedSet(void *a1, uint64_t a2)
{
  v3[1] = *MEMORY[0x1895F89C0];
  v3[0] = a2;
  return [a1 initWithObjects:v3 count:1];
}

void sub_180BA4478(_Unwind_Exception *exception_object)
{
}

NSUInteger OUTLINED_FUNCTION_0_30(objc_class *a1)
{
  return __CFRequireConcreteImplementation(a1, v1);
}

  ;
}

  ;
}

uint64_t _CFStringGetFormatSpecifierConfiguration(void *a1)
{
  if ((objc_opt_respondsToSelector() & 1) != 0) {
    return [a1 formatConfiguration];
  }
  else {
    return 0LL;
  }
}

uint64_t _CFStringCopyWithFomatStringConfiguration(void *a1, uint64_t a2)
{
  if ((objc_opt_respondsToSelector() & 1) != 0) {
    return [a1 _copyFormatStringWithConfiguration:a2];
  }
  CFRetain(a1);
  return (uint64_t)a1;
}

objc_class *_CFStringCreateWithWidthContexts(uint64_t a1)
{
  uint64_t result = (objc_class *)__NSVariableWidthStringClass;
  if (__NSVariableWidthStringClass) {
    return (objc_class *)[[result alloc] initWithWidthContexts:a1];
  }
  uint64_t result = __CFLookUpClass("__NSVariableWidthString");
  __NSVariableWidthStringClass Class = (uint64_t)result;
  if (result) {
    return (objc_class *)[[result alloc] initWithWidthContexts:a1];
  }
  return result;
}

CFStringRef _CFStringFindAffixRuleFormat(const void *a1, CFStringRef theString)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (CFStringGetLength(theString) < 2) {
    return 0LL;
  }
  CFIndex Length = CFStringGetLength(theString);
  unsigned int CharacterAtIndex = CFStringGetCharacterAtIndex(theString, Length - 1);
  if (CFEqual(a1, @"fi"))
  {
    CFCharacterSetRef v7 = CFCharacterSetCreateWithCharactersInString(0LL, @"aeiouyåäö");
    CFCharacterSetRef v8 = CFCharacterSetCreateWithCharactersInString(0LL, @"bcdfghjklmnpqrstvwxzšž");
    if (CFCharacterSetIsCharacterMember(v7, CharacterAtIndex))
    {
      __int16 v4 = @"vowel";
LABEL_16:
      CFRelease(v7);
      CFRelease(v8);
      return v4;
    }

    int IsCharacterMember = CFCharacterSetIsCharacterMember(v8, CharacterAtIndex);
    int v10 = @"consonant";
    CFTypeID v11 = @"other";
    goto LABEL_13;
  }

  if (CFEqual(a1, @"ru"))
  {
    CFCharacterSetRef v7 = CFCharacterSetCreateWithCharactersInString(0LL, @"ое");
    CFCharacterSetRef v8 = CFCharacterSetCreateWithCharactersInString(0LL, @"аяую");
    __int16 v4 = @"other";
    if ((unsigned __int16)((unsigned __int16)(CharacterAtIndex - 1104) >> 6) < 0x3FFu
      || CharacterAtIndex == 1068
      || CharacterAtIndex == 1100)
    {
      goto LABEL_16;
    }

    if (CFCharacterSetIsCharacterMember(v7, CharacterAtIndex))
    {
      __int16 v4 = @"neuter";
      goto LABEL_16;
    }

    int IsCharacterMember = CFCharacterSetIsCharacterMember(v8, CharacterAtIndex);
    int v10 = @"feminine";
    CFTypeID v11 = @"masculine";
LABEL_13:
    if (IsCharacterMember) {
      __int16 v4 = v10;
    }
    else {
      __int16 v4 = v11;
    }
    goto LABEL_16;
  }

  if (!CFEqual(a1, @"ko")) {
    return 0LL;
  }
  uint64_t v13 = CFUniCharDecomposeCharacter(CharacterAtIndex, v17, 10LL);
  if (v13 < 1)
  {
    unsigned int v15 = 0LL;
  }

  else
  {
    int v14 = LOWORD(v17[v13 - 1]);
    if ((v14 - 4449) >= 0x47)
    {
      BOOL v16 = (v14 - 4520) >= 0x58 && (v14 - 4352) >= 0x5F;
      unsigned int v15 = @"consonant";
      if (v16) {
        unsigned int v15 = 0LL;
      }
    }

    else
    {
      unsigned int v15 = @"vowel";
    }
  }

  if (v15) {
    return v15;
  }
  else {
    return @"other";
  }
}

void _CFCopyResolvedFormatStringWithConfiguration(__CFString *a1, CFDictionaryRef theDict, const void *a3)
{
  value[20] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v6 = (__CFString *)CFDictionaryGetValue(theDict, @"NSStringFormatSpecTypeKey");
  if (!v6) {
    return;
  }
  CFCharacterSetRef v7 = CFDictionaryGetValue(theDict, @"NSStringFormatLocaleKey");
  if (!v7)
  {
    CFCharacterSetRef v7 = a3;
    if (!a3)
    {
      CFCharacterSetRef v7 = (const void *)_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale;
      if (!_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale)
      {
        MainBundle = CFBundleGetMainBundle();
        unsigned int v9 = CFBundleCopyBundleLocalizations(MainBundle);
        if (v9)
        {
          int v10 = v9;
          CFArrayRef v11 = CFBundleCopyPreferredLocalizationsFromArray(v9);
          CFRelease(v10);
          if (v11)
          {
            if (CFArrayGetCount(v11) <= 0)
            {
              CFRelease(v11);
            }

            else
            {
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v11, 0LL);
              CFCharacterSetRef v7 = CFLocaleCreate(0LL, ValueAtIndex);
              CFRelease(v11);
              if (v7) {
                goto LABEL_12;
              }
            }
          }
        }

        CFCharacterSetRef v7 = CFLocaleCreate(0LL, @"en");
LABEL_12:
        while (!__ldaxr((unint64_t *)&_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale))
        {
          if (!__stlxr( (unint64_t)v7,  (unint64_t *)&_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale)) {
            goto LABEL_16;
          }
        }

        __clrex();
        CFRelease(v7);
        CFCharacterSetRef v7 = (const void *)_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale;
      }
    }
  }

void sub_180BA567C(_Unwind_Exception *a1)
{
}

uint64_t _CFStringCreateWithMarkdownAndConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (__NSGetCFLocalizedAttributedStringClass_onceToken != -1) {
    dispatch_once(&__NSGetCFLocalizedAttributedStringClass_onceToken, &__block_literal_global_96_0);
  }
  return [(id)__NSCFLocalizedAttributedStringClass copyStringWithMarkdown:a1 formatConfiguration:a2 bundle:a3 tableURL:a4];
}

BOOL _CFStringObjCFormatRequiresInflection(void *a1)
{
  Class Class = object_getClass(a1);
  if (__NSGetCFLocalizedAttributedStringClass_onceToken != -1) {
    dispatch_once(&__NSGetCFLocalizedAttributedStringClass_onceToken, &__block_literal_global_96_0);
  }
  return Class == (Class)__NSCFLocalizedAttributedStringClass;
}

uint64_t _CFStringCreateFormatWithInflectionAndArguments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return [(id)__NSCFLocalizedAttributedStringClass createStringRequiringInflectionWithFormat:a3 formatOptions:a2 arguments:a4];
}

xpc_object_t _CFXPCCreateXPCMessageWithCFObject(uint64_t a1)
{
  address[1] = *MEMORY[0x1895F89C0];
  unint64_t v2 = __CFBinaryPlistWrite15(a1, 0LL);
  if (!v2) {
    return 0LL;
  }
  if (v2 <= 0x4000)
  {
    address[0] = 0LL;
    alloc = (dispatch_data_s *)dispatch_data_create_alloc();
    __CFBinaryPlistWrite15(a1, 0LL);
LABEL_7:
    address[0] = (mach_vm_address_t)xpc_data_create_with_dispatch_data(alloc);
    dispatch_release(alloc);
    keys = "ECF19A18-7AA6-4141-B4DC-A2E5123B2B5C";
    xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, (xpc_object_t *)address, 1uLL);
    xpc_release((xpc_object_t)address[0]);
    return v4;
  }

  address[0] = 0LL;
  size_t v3 = (v2 + *MEMORY[0x1895FD590] - 1) & -*MEMORY[0x1895FD590];
  if (!mach_vm_allocate(*MEMORY[0x1895FBBE0], address, v3, 687865857))
  {
    __CFBinaryPlistWrite15(a1, 0LL);
    alloc = dispatch_data_create((const void *)address[0], v3, 0LL, (dispatch_block_t)*MEMORY[0x1895F8AA0]);
    goto LABEL_7;
  }

  return 0LL;
}

CFDateRef _CFXPCCreateCFObjectFromXPCMessage(void *a1)
{
  v2[1] = *MEMORY[0x1895F89C0];
  v2[0] = 0LL;
  CFDateRef result = (CFDateRef)xpc_dictionary_get_data(a1, "ECF19A18-7AA6-4141-B4DC-A2E5123B2B5C", v2);
  if (result) {
    return __CFBinaryPlistCreate15((uint64_t)result, v2[0]);
  }
  return result;
}

xpc_object_t _CFXPCCreateXPCObjectFromCFObject(__CFString *a1)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (CFNullGetTypeID() == v2) {
    return xpc_null_create();
  }
  if (CFBooleanGetTypeID() == v2) {
    return xpc_BOOL_create(&__kCFBooleanTrue == (__objc2_class **)a1);
  }
  if (v2 == 7)
  {
    CFIndex Length = CFStringGetLength(a1);
    size_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, 0x8000100u);
    if (MaximumSizeForEncoding != -1LL)
    {
      CFIndex v6 = MaximumSizeForEncoding;
      CFCharacterSetRef v7 = (char *)malloc(MaximumSizeForEncoding);
      if (v7)
      {
        CFCharacterSetRef v8 = v7;
        if (CFStringGetCString(a1, v7, v6, 0x8000100u)) {
          unsigned int v9 = xpc_string_create(v8);
        }
        else {
          unsigned int v9 = 0LL;
        }
        free(v8);
        return v9;
      }
    }

    return 0LL;
  }

  if (CFDataGetTypeID() == v2)
  {
    DispatchData = _CFDataCreateDispatchData(a1);
    xpc_object_t v11 = xpc_data_create_with_dispatch_data(DispatchData);
    dispatch_release(DispatchData);
    return v11;
  }

  if (v2 != 42)
  {
    if (v2 == 22)
    {
      if (CFNumberIsFloatType((CFNumberRef)a1))
      {
        *(void *)&valuePtr.byte0 = 0LL;
        if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &valuePtr)) {
          return xpc_double_create(*(double *)&valuePtr.byte0);
        }
      }

      else
      {
        *(void *)&valuePtr.byte0 = 0LL;
        if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, &valuePtr)) {
          return xpc_int64_create(*(int64_t *)&valuePtr.byte0);
        }
      }

      return 0LL;
    }

    if (CFUUIDGetTypeID() == v2)
    {
      CFUUIDBytes valuePtr = CFUUIDGetUUIDBytes((CFUUIDRef)a1);
      return xpc_uuid_create(&valuePtr.byte0);
    }

    if (v2 == 18)
    {
      *(void *)&valuePtr.byte0 = xpc_dictionary_create(0LL, 0LL, 0LL);
      if (!*(void *)&valuePtr.byte0) {
        return 0LL;
      }
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a1);
      CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)__CFXPCDictionaryApplier, &valuePtr);
      size_t v19 = xpc_dictionary_get_count(*(xpc_object_t *)&valuePtr.byte0);
      unsigned int v9 = *(void **)&valuePtr.byte0;
    }

    else
    {
      if (v2 != 19)
      {
        if (CFURLGetTypeID() != v2) {
          return 0LL;
        }
        unsigned int v9 = (void *)CFURLGetString((CFURLRef)a1);
        if (!v9) {
          return v9;
        }
        CFURLRef v21 = CFURLGetBaseURL((CFURLRef)a1);
        if (!v21) {
          CFURLRef v21 = (CFURLRef)&__kCFNull;
        }
        uint64_t v22 = _CFXPCCreateXPCObjectFromCFObject(v21);
        if (!v22) {
          return 0LL;
        }
        int v23 = (void *)v22;
        unsigned int v9 = (void *)_CFXPCCreateXPCObjectFromCFObject(v9);
        if (!v9)
        {
          xpc_release(v23);
          return v9;
        }

        if (uuid_parse("C3853DCC-9776-4114-B6C1-FD9F51944A6D", uu) || (xpc_object_t v24 = xpc_uuid_create(uu)) == 0LL)
        {
          xpc_release(v9);
          CFTypeID v20 = v23;
          goto LABEL_42;
        }

        CFStringRef v25 = v24;
        *(void *)&valuePtr.byte0 = "com.apple.CFURL.magic";
        *(void *)&valuePtr.byte8 = "com.apple.CFURL.string";
        __int16 v30 = "com.apple.CFURL.base";
        values[0] = v24;
        values[1] = v9;
        values[2] = v23;
        xpc_object_t v26 = xpc_dictionary_create((const char *const *)&valuePtr, values, 3uLL);
        CFStringRef v27 = v9;
        unsigned int v9 = v26;
        xpc_release(v27);
        xpc_release(v23);
        xpc_release(v25);
        if (!v9 || xpc_dictionary_get_count(v9) == 3) {
          return v9;
        }
LABEL_41:
        CFTypeID v20 = v9;
LABEL_42:
        xpc_release(v20);
        return 0LL;
      }

      unsigned int v9 = xpc_array_create(0LL, 0LL);
      if (!v9) {
        return v9;
      }
      CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
      if (Count >= 1)
      {
        for (CFIndex i = 0LL; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, i);
          CFTypeID v17 = (void *)_CFXPCCreateXPCObjectFromCFObject(ValueAtIndex);
          if (v17)
          {
            uint64_t v18 = v17;
            xpc_array_append_value(v9, v17);
            xpc_release(v18);
          }
        }
      }

      size_t v19 = xpc_array_get_count(v9);
    }

    if (v19 == Count) {
      return v9;
    }
    goto LABEL_41;
  }

  double v13 = CFDateGetAbsoluteTime((CFDateRef)a1) + 978307200.0;
  if (v13 < -9223372040.0 || v13 > 9223372040.0) {
    return _CFXPCCreateXPCObjectFromOutOfRangeCFTimeInterval(v13);
  }
  else {
    return xpc_date_create((uint64_t)(v13 * 1000000000.0));
  }
}

xpc_object_t _CFXPCCreateXPCObjectFromOutOfRangeCFTimeInterval(double a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  xpc_object_t v1 = xpc_double_create(a1);
  if (!v1) {
    return 0LL;
  }
  CFTypeID v2 = v1;
  if (uuid_parse("C119A421-DF31-48EF-843D-21B4030D1621", uu) || (xpc_object_t v6 = xpc_uuid_create(uu)) == 0LL)
  {
    size_t v3 = v2;
LABEL_4:
    xpc_release(v3);
    return 0LL;
  }

  CFCharacterSetRef v7 = v6;
  keys[0] = "com.apple.CFDate.magic";
  keys[1] = "com.apple.CFDate.ti";
  values[0] = v6;
  values[1] = v2;
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)keys, values, 2uLL);
  xpc_release(v2);
  xpc_release(v7);
  if (v4 && xpc_dictionary_get_count(v4) != 2)
  {
    size_t v3 = v4;
    goto LABEL_4;
  }

  return v4;
}

void __CFXPCDictionaryApplier(const __CFString *a1, uint64_t a2, xpc_object_t *a3)
{
  if (CFGetTypeID(a1) == 7)
  {
    CFIndex Length = CFStringGetLength(a1);
    size_t MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, 0x8000100u);
    if (MaximumSizeForEncoding != -1LL)
    {
      CFIndex v8 = MaximumSizeForEncoding;
      unsigned int v9 = (char *)malloc(MaximumSizeForEncoding);
      if (v9)
      {
        int v10 = v9;
        if (CFStringGetCString(a1, v9, v8, 0x8000100u))
        {
          uint64_t v11 = (void *)_CFXPCCreateXPCObjectFromCFObject(a2);
          if (v11)
          {
            char v12 = v11;
            xpc_dictionary_set_value(*a3, v10, v11);
            xpc_release(v12);
          }
        }

        free(v10);
      }
    }
  }

CFDataRef _CFXPCCreateCFObjectFromXPCObject(const __CFArray *a1)
{
  CFArrayRef v1 = a1;
  uint64_t v46 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return v1;
  }
  Class Class = object_getClass(a1);
  size_t v3 = (objc_class *)MEMORY[0x1895F92A8];
  if (Class == (Class)MEMORY[0x1895F92A8])
  {
    char v12 = (CFTypeRef *)&kCFNull;
    return (CFDataRef)CFRetain(*v12);
  }

  if (Class == (Class)MEMORY[0x1895F9228])
  {
    BOOL value = xpc_BOOL_get_value(v1);
    char v12 = (CFTypeRef *)&kCFBooleanTrue;
    if (!value) {
      char v12 = (CFTypeRef *)&kCFBooleanFalse;
    }
    return (CFDataRef)CFRetain(*v12);
  }

  if (Class == (Class)MEMORY[0x1895F92E8])
  {
    string_ptr = xpc_string_get_string_ptr(v1);
    return (CFDataRef)CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, string_ptr, 0x8000100u);
  }

  if (Class == (Class)MEMORY[0x1895F9240])
  {
    size_t length = xpc_data_get_length(v1);
    if ((length & 0x8000000000000000LL) == 0)
    {
      CFIndex v17 = length;
      bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v1);
      return CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes_ptr, v17);
    }

    return 0LL;
  }

  if (Class == (Class)MEMORY[0x1895F9280])
  {
    *(void *)uu1 = xpc_int64_get_value(v1);
    return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt64Type, uu1);
  }

  if (Class == (Class)MEMORY[0x1895F9258])
  {
    *(void *)uu1 = xpc_double_get_value(v1);
    return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberDoubleType, uu1);
  }

  if (Class == (Class)MEMORY[0x1895F9248])
  {
    int64_t v19 = xpc_date_get_value(v1);
    return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (double)v19 / 1000000000.0 - 978307200.0);
  }

  xpc_object_t v4 = (objc_class *)MEMORY[0x1895F92F8];
  if (Class == (Class)MEMORY[0x1895F92F8])
  {
    CFUUIDBytes v47 = *(CFUUIDBytes *)xpc_uuid_get_bytes(v1);
    return CFUUIDCreateFromUUIDBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v47);
  }

  if (Class == (Class)MEMORY[0x1895F9220])
  {
    size_t count = xpc_array_get_count(v1);
    if (!(count >> 59))
    {
      CFIndex v21 = count;
      if (count >= 0x101)
      {
        uint64_t v22 = (const void **)malloc(8 * count);
        if (!v22) {
          return 0LL;
        }
      }

      else
      {
        uint64_t v22 = (const void **)uu1;
      }

      *(void *)uuid_t uu = 0LL;
      *(void *)&uu[8] = uu;
      uint64_t v43 = 0x2000000000LL;
      uint64_t v44 = 0LL;
      applier[0] = MEMORY[0x1895F87A8];
      applier[1] = 0x40000000LL;
      applier[2] = ___CFXPCCreateCFObjectFromXPCObject_block_invoke;
      applier[3] = &unk_1899ED1E0;
      applier[4] = uu;
      applier[5] = v22;
      xpc_array_apply(v1, applier);
      uint64_t v23 = *(void *)(*(void *)&uu[8] + 24LL);
      if (v21 == v23)
      {
        CFArrayRef v1 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v22, v21, &kCFTypeArrayCallBacks);
        uint64_t v23 = *(void *)(*(void *)&uu[8] + 24LL);
      }

      else
      {
        CFArrayRef v1 = 0LL;
      }

      if (v23 >= 1)
      {
        uint64_t v24 = 0LL;
        do
          CFRelease(v22[v24++]);
        while (v24 < *(void *)(*(void *)&uu[8] + 24LL));
      }

      CFStringRef v25 = v22;
      goto LABEL_73;
    }

    return 0LL;
  }

  uint64_t v5 = (objc_class *)MEMORY[0x1895F9250];
  if (Class != (Class)MEMORY[0x1895F9250]) {
    return 0LL;
  }
  size_t v6 = xpc_dictionary_get_count(v1);
  if (v6 >> 58) {
    return 0LL;
  }
  CFIndex v7 = v6;
  if (v6 == 3)
  {
    xpc_object_t v26 = xpc_dictionary_get_value(v1, "com.apple.CFURL.magic");
    if (!v26) {
      goto LABEL_64;
    }
    CFStringRef v27 = v26;
    if (object_getClass(v26) == v4)
    {
      *(_OWORD *)uu1 = *(_OWORD *)xpc_uuid_get_bytes(v27);
      if (uuid_parse("C3853DCC-9776-4114-B6C1-FD9F51944A6D", uu) || uuid_compare(uu1, uu)) {
        goto LABEL_64;
      }
      xpc_object_t v28 = xpc_dictionary_get_value(v1, "com.apple.CFURL.string");
      if (v28)
      {
        CFTypeID v29 = (const __CFArray *)xpc_dictionary_get_value(v1, "com.apple.CFURL.base");
        CFArrayRef v1 = v29;
        if (!v29) {
          return v1;
        }
        if (object_getClass(v29) == v5 || object_getClass(v1) == v3)
        {
          __int16 v30 = (__objc2_class **)_CFXPCCreateCFObjectFromXPCObject(v1);
          if (v30)
          {
            CFTypeID v31 = CFURLGetTypeID();
            if (v31 == CFGetTypeID(v30) || (CFTypeID TypeID = CFNullGetTypeID(), TypeID == CFGetTypeID(v30)))
            {
              CFErrorRef v33 = (const __CFString *)_CFXPCCreateCFObjectFromXPCObject(v28);
              CFTypeID v34 = v33;
              if (v33)
              {
                if (CFGetTypeID(v33) == 7)
                {
                  if (&__kCFNull == v30) {
                    __int128 v35 = 0LL;
                  }
                  else {
                    __int128 v35 = (const __CFURL *)v30;
                  }
                  CFArrayRef v1 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v35);
                  CFRelease(v30);
                  CFRelease(v34);
                  return v1;
                }

                CFRelease(v34);
              }
            }

            CFRelease(v30);
          }
        }
      }
    }

    return 0LL;
  }

  if (v6 != 2)
  {
    if (v6 < 0x81) {
      goto LABEL_64;
    }
    uint64_t v36 = (const void **)malloc(16 * v6);
    if (v36) {
      goto LABEL_65;
    }
    return 0LL;
  }

  xpc_object_t v8 = xpc_dictionary_get_value(v1, "com.apple.CFDate.magic");
  if (!v8)
  {
LABEL_64:
    uint64_t v36 = (const void **)uu1;
LABEL_65:
    *(void *)uuid_t uu = 0LL;
    *(void *)&uu[8] = uu;
    uint64_t v43 = 0x2000000000LL;
    uint64_t v44 = 0LL;
    v40[0] = MEMORY[0x1895F87A8];
    v40[1] = 0x40000000LL;
    v40[2] = ___CFXPCCreateCFObjectFromXPCObject_block_invoke_2;
    v40[3] = &unk_1899ED208;
    _BYTE v40[4] = uu;
    v40[5] = v36;
    v40[6] = v7;
    xpc_dictionary_apply(v1, v40);
    uint64_t v37 = *(void *)(*(void *)&uu[8] + 24LL);
    if (v7 == v37)
    {
      CFArrayRef v1 = CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v36,  &v36[v7],  v7,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      uint64_t v37 = *(void *)(*(void *)&uu[8] + 24LL);
    }

    else
    {
      CFArrayRef v1 = 0LL;
    }

    if (v37 >= 1)
    {
      uint64_t v38 = 0LL;
      CFTypeID v39 = &v36[v7];
      do
      {
        CFRelease(v36[v38]);
        CFRelease(v39[v38++]);
      }

      while (v38 < *(void *)(*(void *)&uu[8] + 24LL));
    }

    CFStringRef v25 = v36;
LABEL_73:
    free(v25);
LABEL_74:
    _Block_object_dispose(uu, 8);
    return v1;
  }

  unsigned int v9 = v8;
  if (object_getClass(v8) != v4) {
    return 0LL;
  }
  *(_OWORD *)uu1 = *(_OWORD *)xpc_uuid_get_bytes(v9);
  if (uuid_parse("C119A421-DF31-48EF-843D-21B4030D1621", uu) || uuid_compare(uu1, uu)) {
    goto LABEL_64;
  }
  double v10 = xpc_dictionary_get_double(v1, "com.apple.CFDate.ti");
  return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10 - 978307200.0);
}

void sub_180BA690C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

CFTypeID CFFileSecurityGetTypeID(void)
{
  return 64LL;
}

CFFileSecurityRef CFFileSecurityCreate(CFAllocatorRef allocator)
{
  CFFileSecurityRef result = filesec_init();
  if (result)
  {
    CFTypeID v2 = result;
    CFFileSecurityRef result = -[NSFileSecurity initWithFileSec:](objc_alloc(&OBJC_CLASS___NSFileSecurity), "initWithFileSec:", result);
    if (!result)
    {
      filesec_free(v2);
      return 0LL;
    }
  }

  return result;
}

CFFileSecurityRef CFFileSecurityCreateCopy(CFAllocatorRef allocator, CFFileSecurityRef fileSec)
{
  CFFileSecurityRef result = filesec_dup((filesec_t)-[__CFFileSecurity _filesec](fileSec, "_filesec"));
  if (result)
  {
    size_t v3 = result;
    CFFileSecurityRef result = -[NSFileSecurity initWithFileSec:](objc_alloc(&OBJC_CLASS___NSFileSecurity), "initWithFileSec:", result);
    if (!result)
    {
      filesec_free(v3);
      return 0LL;
    }
  }

  return result;
}

Boolean CFFileSecurityCopyOwnerUUID(CFFileSecurityRef fileSec, CFUUIDRef *ownerUUID)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  LODWORD(v4) = -[__CFFileSecurity getOwnerUUID:](fileSec, "getOwnerUUID:", &v7);
  if ((_DWORD)v4)
  {
    uint64_t v5 = CFGetAllocator(fileSec);
    xpc_object_t v4 = CFUUIDCreateFromUUIDBytes(v5, v7);
    if (v4)
    {
      *ownerUUID = v4;
      LOBYTE(v4) = 1;
    }
  }

  return v4;
}

Boolean CFFileSecuritySetOwnerUUID(CFFileSecurityRef fileSec, CFUUIDRef ownerUUID)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  CFUUIDBytes v4 = CFUUIDGetUUIDBytes(ownerUUID);
  return -[__CFFileSecurity setOwnerUUID:](fileSec, "setOwnerUUID:", &v4);
}

Boolean CFFileSecurityCopyGroupUUID(CFFileSecurityRef fileSec, CFUUIDRef *groupUUID)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  LODWORD(v4) = -[__CFFileSecurity getGroupUUID:](fileSec, "getGroupUUID:", &v7);
  if ((_DWORD)v4)
  {
    uint64_t v5 = CFGetAllocator(fileSec);
    CFUUIDBytes v4 = CFUUIDCreateFromUUIDBytes(v5, v7);
    if (v4)
    {
      *groupUUID = v4;
      LOBYTE(v4) = 1;
    }
  }

  return v4;
}

Boolean CFFileSecuritySetGroupUUID(CFFileSecurityRef fileSec, CFUUIDRef groupUUID)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  CFUUIDBytes v4 = CFUUIDGetUUIDBytes(groupUUID);
  return -[__CFFileSecurity setGroupUUID:](fileSec, "setGroupUUID:", &v4);
}

Boolean CFFileSecurityCopyAccessControlList(CFFileSecurityRef fileSec, acl_t *accessControlList)
{
  return -[__CFFileSecurity copyAccessControlList:](fileSec, "copyAccessControlList:", accessControlList);
}

Boolean CFFileSecuritySetAccessControlList(CFFileSecurityRef fileSec, acl_t accessControlList)
{
  return -[__CFFileSecurity setAccessControlList:](fileSec, "setAccessControlList:", accessControlList);
}

Boolean CFFileSecurityGetOwner(CFFileSecurityRef fileSec, uid_t *owner)
{
  return -[__CFFileSecurity getOwner:](fileSec, "getOwner:", owner);
}

Boolean CFFileSecuritySetOwner(CFFileSecurityRef fileSec, uid_t owner)
{
  return -[__CFFileSecurity setOwner:](fileSec, "setOwner:", *(void *)&owner);
}

Boolean CFFileSecurityGetGroup(CFFileSecurityRef fileSec, gid_t *group)
{
  return -[__CFFileSecurity getGroup:](fileSec, "getGroup:", group);
}

Boolean CFFileSecuritySetGroup(CFFileSecurityRef fileSec, gid_t group)
{
  return -[__CFFileSecurity setGroup:](fileSec, "setGroup:", *(void *)&group);
}

Boolean CFFileSecurityGetMode(CFFileSecurityRef fileSec, mode_t *mode)
{
  return -[__CFFileSecurity getMode:](fileSec, "getMode:", mode);
}

Boolean CFFileSecuritySetMode(CFFileSecurityRef fileSec, mode_t mode)
{
  return -[__CFFileSecurity setMode:](fileSec, "setMode:", mode);
}

Boolean CFFileSecurityClearProperties(CFFileSecurityRef fileSec, CFFileSecurityClearOptions clearPropertyMask)
{
  return -[__CFFileSecurity clearProperties:](fileSec, "clearProperties:", clearPropertyMask);
}

NSFileSecurity *_CFFileSecurityCreateFromFilesec(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return -[NSFileSecurity initWithFileSec:](objc_alloc(&OBJC_CLASS___NSFileSecurity), "initWithFileSec:", a2);
  }
  else {
    return 0LL;
  }
}

uint64_t __NSSingleObjectArrayI_new(uint64_t a1, char a2)
{
  CFUUIDBytes v4 = (objc_class *)objc_opt_self();
  uint64_t v5 = __CFAllocateObject(v4, 0LL);
  uint64_t v6 = v5;
  if (v5)
  {
    *(void *)(v5 + _Block_object_dispose(va, 8) = a1;
    if (a1 >= 1 && (a2 & 1) == 0) {
      id v7 = (id)a1;
    }
  }

  return v6;
}

_DWORD *CFBurstTrieCreateWithOptions(const __CFDictionary *a1)
{
  value[1] = *(void **)MEMORY[0x1895F89C0];
  CFTypeID v2 = calloc(1uLL, 0x830uLL);
  v2[520] = 256;
  if (CFDictionaryGetValueIfPresent(a1, @"ContainerSize", (const void **)value))
  {
    CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &valuePtr);
    int v3 = valuePtr;
    v2[520] = v3;
  }

  atomic_store(1u, v2 + 521);
  return v2;
}

_DWORD *CFBurstTrieCreate()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  int valuePtr = 256;
  CFNumberRef v0 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 1LL, 0LL, 0LL);
  CFDictionarySetValue(Mutable, @"ContainerSize", v0);
  CFTypeID v2 = CFBurstTrieCreateWithOptions(Mutable);
  CFRelease(v0);
  CFRelease(Mutable);
  return v2;
}

void *CFBurstTrieCreateFromFile(const __CFString *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (CFStringGetCString(a1, buffer, 1024LL, 0x8000100u))
  {
    if (!stat(buffer, &v10))
    {
      int v3 = open(buffer, 0, 0LL);
      if ((v3 & 0x80000000) == 0)
      {
        int v4 = v3;
        uint64_t v5 = (int *)mmap(0LL, v10.st_size, 1, 1, v3, 0LL);
        int v6 = *v5;
        if (*v5 == 14531089 || v6 == -889275714)
        {
          uint64_t v8 = calloc(1uLL, 0x830uLL);
          CFArrayRef v1 = v8;
          v8[257] = v5;
          *((_DWORD *)v8 + 5++*(_WORD *)(cf + 16) = v10.st_size;
        }

        else
        {
          CFArrayRef v1 = 0LL;
          if (v6 != -1161889074)
          {
LABEL_15:
            close(v4);
            return v1;
          }

          uint64_t v8 = calloc(1uLL, 0x830uLL);
          CFArrayRef v1 = v8;
          v8[257] = v5;
          *((_DWORD *)v8 + 5++*(_WORD *)(cf + 16) = v10.st_size;
          *((_DWORD *)v8 + 517) = v5[1];
        }

        *((_DWORD *)v8 + 51_Block_object_dispose(va, 8) = v5[4];
        *((_DWORD *)v1 + 519) = v5[2];
        atomic_store(1u, (unsigned int *)v1 + 521);
        *((_BYTE *)v1 + 208_Block_object_dispose(va, 8) = 1;
        goto LABEL_15;
      }
    }
  }

  return 0LL;
}

_DWORD *CFBurstTrieCreateFromMapBytes(_DWORD *result)
{
  if (result)
  {
    CFArrayRef v1 = result;
    int v2 = *result;
    if (*result == 14531089 || v2 == -889275714)
    {
      CFFileSecurityRef result = malloc(0x830uLL);
      *((void *)result + 257) = v1;
      int v4 = v1[4];
      result[516] = v1[3];
LABEL_10:
      result[518] = v4;
      result[519] = v1[2];
      atomic_store(1u, result + 521);
      *((_BYTE *)result + 208_Block_object_dispose(va, 8) = 0;
      return result;
    }

    if (v2 == -1161889074)
    {
      CFFileSecurityRef result = malloc(0x830uLL);
      *((void *)result + 257) = v1;
      int v4 = v1[4];
      result[516] = v1[3];
      result[517] = v1[1];
      goto LABEL_10;
    }

    return 0LL;
  }

  return result;
}

uint64_t CFBurstTrieInsert(unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5)
{
  return CFBurstTrieAddWithWeight(a1, a2, a3, a4, 1, a5);
}

uint64_t CFBurstTrieAddWithWeight( unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5, int a6)
{
  uint64_t v6 = 0LL;
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a6 && !*(void *)(a1 + 2056) && a4 <= 1023)
  {
    if (a4 < 86)
    {
      CFIndex v13 = 342LL;
      CFTypeID v14 = v18;
    }

    else
    {
      CFIndex v13 = 4 * a4;
      CFTypeID v14 = (UInt8 *)malloc((4 * a4) | 1);
    }

    v20.CFIndex location = a3;
    v20.size_t length = a4;
    CFStringGetBytes(a2, v20, 0x8000100u, 0x2Du, 0, v14, v13, &usedBufLen);
    CFIndex v15 = usedBufLen;
    v14[usedBufLen] = 0;
    uint64_t v6 = CFBurstTrieAddUTF8StringWithWeight(a1, (uint64_t)v14, v15, a5, a6);
    if (v18 != v14) {
      free(v14);
    }
  }

  return v6;
}

uint64_t CFBurstTrieAdd(unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5)
{
  return CFBurstTrieAddWithWeight(a1, a2, a3, a4, 1, a5);
}

uint64_t CFBurstTrieInsertCharacters(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddCharactersWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieAddCharactersWithWeight(unint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5 = 0LL;
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a5 && a3 <= 1023 && !*(void *)(a1 + 2056))
  {
    uint64_t v11 = v14;
    if (a3 >= 86) {
      uint64_t v11 = malloc((4 * a3) | 1);
    }
    uint64_t v12 = burstTrieConvertCharactersToUTF8(a2, a3, (uint64_t)v11);
    v11[v12] = 0;
    uint64_t v5 = CFBurstTrieAddUTF8StringWithWeight(a1, (uint64_t)v11, v12, a4, a5);
    if (v14 != v11) {
      free(v11);
    }
  }

  return v5;
}

uint64_t CFBurstTrieAddCharacters(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddCharactersWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieInsertUTF8String(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddUTF8StringWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieAddUTF8StringWithWeight(unint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  BOOL v6 = a3 >= 4096 || *(void *)(a1 + 2056) != 0LL || a5 == 0;
  uint64_t v7 = !v6;
  if (v6) {
    return v7;
  }
  unint64_t v8 = a1;
  unint64_t v9 = a1;
  if (!(_DWORD)a3)
  {
LABEL_15:
    int v13 = *(_DWORD *)(v9 + 2048);
    *(_DWORD *)(v9 + 204_Block_object_dispose(va, 8) = v13 + a4;
    *(_DWORD *)(v9 + 2052) = a5;
    if (v13) {
      return v7;
    }
LABEL_34:
    ++*(_DWORD *)(v8 + 2076);
    return v7;
  }

  uint64_t v11 = 0LL;
  unint64_t v9 = a1;
  while (1)
  {
    uint64_t v12 = *(void *)(v9 + 8LL * *(unsigned __int8 *)(a2 + v11));
    if ((v12 & 3) != 1) {
      break;
    }
    unint64_t v9 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    if ((_DWORD)a3 == (_DWORD)++v11) {
      goto LABEL_15;
    }
  }

  if ((v12 & 3) != 2)
  {
    *(void *)(v9 + 8LL * *(unsigned __int8 *)(a2 + v11)) = (unint64_t)makeCFBurstTrieListNode( (const void *)(a2 + v11 + 1),  ~(_DWORD)v11 + (int)a3,  a4,  a5) | 2;
    goto LABEL_34;
  }

  unsigned int v29 = v7;
  CFTypeID v14 = (_DWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v12 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
    CFBurstTrieAddUTF8StringWithWeight_cold_1();
  }
  uint64_t v15 = (a3 - 1);
  unsigned int v16 = 1;
  unint64_t v17 = v12 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    unint64_t v18 = v17;
    if ((_DWORD)v15 - *(unsigned __int16 *)(v17 + 16) == (_DWORD)v11
      && !memcmp((const void *)(a2 + v11 + 1), (const void *)(v17 + 18), v15 - v11))
    {
      break;
    }

    ++v16;
    unint64_t v17 = *(void *)v18;
    if (!*(void *)v18)
    {
      *(void *)unint64_t v18 = makeCFBurstTrieListNode((const void *)(a2 + v11 + 1), (int)v15 - (int)v11, a4, a5);
      int v19 = 1;
      goto LABEL_26;
    }
  }

  int v19 = 0;
  *(_DWORD *)(v18 + 8) += a4;
  *(_DWORD *)(v18 + 12) = a5;
LABEL_26:
  unint64_t v8 = a1;
  if (v16 > *(_DWORD *)(a1 + 2080))
  {
    unint64_t v20 = (unint64_t)calloc(1uLL, 0x808uLL);
    do
    {
      int v22 = v14[2];
      int v21 = v14[3];
      if (*((_WORD *)v14 + 8))
      {
        uint64_t v23 = *(void *)(v20 + 8LL * *((unsigned __int8 *)v14 + 18));
        CFBurstTrieListNode = makeCFBurstTrieListNode( (char *)v14 + 19,  *((unsigned __int16 *)v14 + 8) - 1,  v14[2],  v21);
        *((_DWORD *)CFBurstTrieListNode + 2) = v22;
        *(void *)CFBurstTrieListNode = v23 & 0xFFFFFFFFFFFFFFFCLL;
        *(void *)(v20 + 8LL * *((unsigned __int8 *)v14 + 18)) = (unint64_t)CFBurstTrieListNode | 2;
      }

      else
      {
        *(_DWORD *)(v20 + 204_Block_object_dispose(va, 8) = v22;
        *(_DWORD *)(v20 + 2052) = v21;
      }

      CFStringRef v25 = *(_DWORD **)v14;
      free(v14);
      CFTypeID v14 = v25;
    }

    while (v25);
    uint64_t v12 = v20 | 1;
  }

  *(void *)(v9 + 8LL * *(unsigned __int8 *)(a2 + v11)) = v12;
  uint64_t v7 = v29;
  if (v19) {
    goto LABEL_34;
  }
  return v7;
}

uint64_t CFBurstTrieAddUTF8String(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddUTF8StringWithWeight(a1, a2, a3, 1, a4);
}

uint64_t burstTrieConvertCharactersToUTF8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 1)
  {
    uint64_t v3 = result;
    uint64_t v4 = 0LL;
    unsigned int v5 = 0;
    LODWORD(result) = 0;
    while (1)
    {
      unsigned int v6 = *(unsigned __int16 *)(v3 + 2 * v4);
      if ((v6 & 0xFC00) == 0xD800)
      {
        uint64_t v7 = v5 + 1;
        if (v7 >= a2 || (int v8 = *(unsigned __int16 *)(v3 + 2 * v7), (v8 & 0xFC00) != 0xDC00))
        {
LABEL_11:
          *(_BYTE *)(a3 + result) = (v6 >> 12) | 0xE0;
          unsigned int v10 = result + 2;
          *(_BYTE *)(a3 + (result + 1)) = (v6 >> 6) & 0x3F | 0x80;
          char v11 = v6 & 0x3F | 0x80;
          int v12 = 3;
          goto LABEL_12;
        }

        unsigned int v9 = v8 + (v6 << 10) - 56613888;
        *(_BYTE *)(a3 + result) = (v9 >> 18) - 16;
        *(_BYTE *)(a3 + (result + 1)) = (v9 >> 12) & 0x3F | 0x80;
        unsigned int v10 = result + 3;
        *(_BYTE *)(a3 + (result + 2)) = (v9 >> 6) & 0x3F | 0x80;
        char v11 = v8 & 0x3F | 0x80;
        int v12 = 4;
        unsigned int v5 = v7;
      }

      else if (v6 > 0x7F)
      {
        if (v6 > 0x7FF) {
          goto LABEL_11;
        }
        unsigned int v10 = result + 1;
        *(_BYTE *)(a3 + result) = (v6 >> 6) - 64;
        char v11 = v6 & 0x3F | 0x80;
        int v12 = 2;
      }

      else
      {
        char v11 = *(_WORD *)(v3 + 2 * v4);
        int v12 = 1;
        unsigned int v10 = result;
      }

uint64_t CFBurstTrieFind(uint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, void *a5)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t result = CFBurstTrieContains(a1, a2, a3, a4, &v7);
  if ((_DWORD)result)
  {
    if (a5) {
      *a5 = v7;
    }
    return 1LL;
  }

  return result;
}

uint64_t CFBurstTrieContains(uint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, _DWORD *a5)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a4 > 1023) {
    return 0LL;
  }
  if (a4 < 86)
  {
    CFIndex v10 = 342LL;
    char v11 = v16;
  }

  else
  {
    CFIndex v10 = 4 * a4;
    char v11 = (UInt8 *)malloc((4 * a4) | 1);
  }

  v18.CFIndex location = a3;
  v18.size_t length = a4;
  CFStringGetBytes(a2, v18, 0x8000100u, 0x2Du, 0, v11, v10, &usedBufLen);
  CFIndex v13 = usedBufLen;
  v11[usedBufLen] = 0;
  uint64_t v12 = CFBurstTrieContainsUTF8String(a1, (uint64_t)v11, v13, a5);
  if (v16 != v11) {
    free(v11);
  }
  return v12;
}

uint64_t CFBurstTrieContainsUTF8String(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a3 > 1023) {
    return 0LL;
  }
  unsigned int v7 = *(_DWORD **)(a1 + 2056);
  if (!v7) {
    goto LABEL_13;
  }
  if (*v7 == -1161889074) {
    return burstTrieMappedFind( (uint64_t)v7 + v7[1],  (uint64_t)v7,  a2,  a3,  a4,  (*(_DWORD *)(a1 + 2072) & 8) != 0);
  }
  if ((*(_DWORD *)(a1 + 2072) & 0x18) == 0)
  {
LABEL_13:
    traverseCFBurstTrieWithCursor(a1, a2);
    return 0LL;
  }

  CFBurstTrieSetCursorForBytes(a1, (uint64_t)v11, a2, a3);
  int v10 = v9;
  uint64_t result = 0LL;
  if (v10 && v13 == 1)
  {
    if (v12)
    {
      if (a4) {
        *a4 = v12;
      }
      return 1LL;
    }

    return 0LL;
  }

  return result;
}

uint64_t CFBurstTrieFindCharacters(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t result = CFBurstTrieContainsCharacters(a1, a2, a3, &v6);
  if ((_DWORD)result)
  {
    if (a4) {
      *a4 = v6;
    }
    return 1LL;
  }

  return result;
}

uint64_t CFBurstTrieContainsCharacters(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (a3 > 1023) {
    return 0LL;
  }
  uint64_t v8 = v12;
  if (a3 >= 86) {
    uint64_t v8 = malloc((4 * a3) | 1);
  }
  uint64_t v9 = burstTrieConvertCharactersToUTF8(a2, a3, (uint64_t)v8);
  v8[v9] = 0;
  uint64_t v10 = CFBurstTrieContainsUTF8String(a1, (uint64_t)v8, v9, a4);
  if (v12 != v8) {
    free(v8);
  }
  return v10;
}

uint64_t CFBurstTrieFindUTF8String(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t result = CFBurstTrieContainsUTF8String(a1, a2, a3, &v6);
  if ((_DWORD)result)
  {
    if (a4) {
      *a4 = v6;
    }
    return 1LL;
  }

  return result;
}

uint64_t burstTrieMappedFind(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, char a6)
{
  if (a4)
  {
    int v6 = 1 - a4;
    uint64_t v7 = (char *)(a3 + 1);
    while (1)
    {
      int v8 = *(_DWORD *)(a1 + 4LL * *(v7 - 1));
      int v9 = v8 & 3;
      if (v9 != 1) {
        break;
      }
      a1 = (v8 & 0xFFFFFFFC) + a2;
      ++v6;
      ++v7;
      if (v6 == 1) {
        goto LABEL_5;
      }
    }

    if (v9 != 2)
    {
      if (v9 == 3) {
        return burstTrieCompactTrieMappedFind((int8x8_t *)((v8 & 0xFFFFFFFC) + a2), a2, v7, -v6, a5, a6);
      }
      return 0LL;
    }

    return burstTrieMappedPageFind((unsigned int *)((v8 & 0xFFFFFFFC) + a2), v7, -v6, a5, a6);
  }

  else
  {
LABEL_5:
    if (!*(_DWORD *)(a1 + 1024)) {
      return 0LL;
    }
    if (a5) {
      *a5 = *(_DWORD *)(a1 + 1028);
    }
    return 1LL;
  }

void CFBurstTrieSetCursorForBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 2056);
  if (v4)
  {
    if ((a4 & 0x8000000000000000LL) == 0 && (*(_DWORD *)(a1 + 2072) & 0x18) != 0)
    {
      *(void *)(a2 + 25) = a1;
      *(void *)(a2 + 17) = 1LL;
      *(_DWORD *)a2 = *(_DWORD *)(v4 + 4);
      *(void *)(a2 + 9) = 0LL;
      *(void *)(a2 + 4) = 0LL;
      if (a3)
      {
        if (a4) {
          CFBurstTrieCursorAdvanceForBytes(a2);
        }
      }
    }
  }

uint64_t CFBurstTrieCursorGetPayload(uint64_t a1, _DWORD *a2)
{
  if (*(void *)(a1 + 17) != 1LL) {
    return 0LL;
  }
  int v2 = *(_DWORD *)(a1 + 12);
  if (!v2) {
    return 0LL;
  }
  if (a2) {
    *a2 = v2;
  }
  return 1LL;
}

size_t traverseCFBurstTrieWithCursor(uint64_t a1, uint64_t a2)
{
  size_t result = MEMORY[0x1895F8858](a1, a2);
  int v8 = v7;
  uint64_t v9 = v6;
  uint64_t v10 = v5;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t v11 = *(void *)(result + 2056);
  if (v11)
  {
    if ((*(_BYTE *)(result + 2072) & 8) != 0)
    {
      return fwrite( "Please use CFBurstTrieCursorRef API for file based trie.\n",  0x39uLL,  1uLL,  (FILE *)*MEMORY[0x1895F89D0]);
    }

    else
    {
      unsigned int v12 = *(_DWORD *)(v11 + 4);
      *(void *)int v22 = v3;
      uint64_t v20 = __PAIR64__(v4, v12);
      v22[8] = 0;
      unsigned int v21 = 0;
      return findCFBurstTrieMappedLevel(result, (uint64_t)v19, v5, v6, v7);
    }
  }

  else
  {
    uint64_t v13 = result | 1;
    uint64_t v20 = result | 1;
    *(void *)&v22[4] = v3;
    *(_DWORD *)int v22 = v4;
    v23[0] = 0;
    if (v4)
    {
      uint64_t v14 = 0LL;
      while (1)
      {
        uint64_t v15 = *(unsigned __int8 *)(v3 + v14);
        uint64_t v13 = *(void *)((v13 & 0xFFFFFFFFFFFFFFFCLL) + 8 * v15);
        uint64_t v20 = v13;
        v23[v14] = v15;
        if ((v13 & 3) != 1) {
          break;
        }
        if (v4 == ++v14) {
          goto LABEL_8;
        }
      }

      if ((v13 & 3) == 2)
      {
        unsigned int v21 = v14 + 1;
        return findCFBurstTrieList((uint64_t)v19, v6, v7);
      }
    }

    else
    {
LABEL_8:
      unsigned int v21 = v4;
      unint64_t v16 = v13 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v17 = *(unsigned int *)((v13 & 0xFFFFFFFFFFFFFFFCLL) + 2052);
      unsigned int v18 = v4;
      if ((_DWORD)v17)
      {
        size_t result = ((uint64_t (*)(uint64_t, _BYTE *, uint64_t, uint64_t))v7)(v6, v23, v17, 1LL);
        if ((result & 1) != 0) {
          return result;
        }
        unsigned int v18 = v21;
        unsigned int v4 = *(_DWORD *)v22;
      }

      if (v18 != v4 || (v10 & 1) == 0) {
        return traverseCFBurstTrieLevel(v16, (uint64_t)v19, v10, v9, v8);
      }
    }
  }

  return result;
}

uint64_t containsKey(_DWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  if ((_DWORD)a4) {
    *a1 = a3;
  }
  return a4;
}

uint64_t CFBurstTrieSerialize(uint64_t a1, CFStringRef theString, int a3)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (*(void *)(a1 + 2056)) {
    return 0LL;
  }
  if (!CFStringGetCString(theString, buffer, 1024LL, 0x8000100u)) {
    return 0LL;
  }
  uint64_t v7 = open(buffer, 1538, 384LL);
  if ((v7 & 0x80000000) != 0) {
    return 0LL;
  }
  int v8 = v7;
  uint64_t v3 = CFBurstTrieSerializeWithFileDescriptor(a1, v7, a3);
  close(v8);
  return v3;
}

uint64_t CFBurstTrieSerializeWithFileDescriptor(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = 0LL;
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if ((a2 & 0x80000000) == 0 && !*(void *)(a1 + 2056))
  {
    off_t v7 = lseek(a2, 0LL, 2);
    *(_DWORD *)(a1 + 2072) = a3;
    uint64_t __buf = 14531089LL;
    int v12 = *(_DWORD *)(a1 + 2076);
    int v13 = 0;
    int v14 = a3;
    uint64_t v15 = 0LL;
    lseek(a2, v7, 0);
    write(a2, &__buf, 0x94uLL);
    serializeCFBurstTrieLists(a1, a1, v7, a2);
    uint64_t v3 = 1LL;
    int v10 = lseek(a2, 0LL, 1) - v7;
    pwrite(a2, &v10, 4uLL, v7 + 4);
    serializeCFBurstTrieLevels(a1, (_DWORD *)a1, &v10, v7, 0, 1, a2);
    pwrite(a2, &v10, 4uLL, v7 + 12);
    int v8 = lseek(a2, 0LL, 2);
    *(_DWORD *)(a1 + 2064) = v8 - v7;
    *(void *)(a1 + 2056) = mmap(0LL, (v8 - v7), 1, 1, a2, v7);
  }

  return v3;
}

uint64_t CFBurstTrieTraverse(uint64_t result)
{
  CFArrayRef v1 = *(int **)(result + 2056);
  if (!v1) {
    return traverseCFBurstTrieWithCursor(result, (uint64_t)"");
  }
  int v2 = *v1;
  if (v2 == 14531089 || v2 == -889275714) {
    return traverseCFBurstTrieWithCursor(result, (uint64_t)"");
  }
  return result;
}

uint64_t foundKey(void *a1)
{
  if (a1)
  {
    if (*a1)
    {
      CFArrayRef v1 = (void (*)(void))a1[1];
      if (v1) {
        v1();
      }
    }
  }

  return 0LL;
}

size_t CFBurstTrieTraverseWithCursor(uint64_t a1, uint64_t a2)
{
  return traverseCFBurstTrieWithCursor(a1, a2);
}

uint64_t CFBurstTrieGetCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 2076);
}

uint64_t CFBurstTrieRetain(uint64_t result)
{
  CFArrayRef v1 = (unsigned int *)(result + 2084);
  do
    unsigned int v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return result;
}

void CFBurstTrieRelease(void *a1)
{
  unsigned int v2 = (unsigned int *)a1 + 521;
  do
  {
    unsigned int v3 = __ldaxr(v2);
    unsigned int v4 = v3 - 1;
  }

  while (__stlxr(v4, v2));
  if (!v4)
  {
    uint64_t v5 = (void *)a1[257];
    if (v5)
    {
      if (*((_BYTE *)a1 + 2088)) {
        munmap(v5, *((unsigned int *)a1 + 516));
      }
    }

    else
    {
      finalizeCFBurstTrie((uint64_t)a1);
    }

    free(a1);
  }

__n128 CFBurstTrieCursorAdvanceForBytes(uint64_t a1)
{
  if (*(void *)(a1 + 17) == 1LL)
  {
    char v2 = *(_BYTE *)(a1 + 16);
    __n128 v5 = *(__n128 *)a1;
    advanceMapCursor(*(void *)(a1 + 25), a1);
    if (!v4)
    {
      *(_BYTE *)(a1 + ++*(_WORD *)(cf + 16) = v2;
      __n128 result = v5;
      *(__n128 *)a1 = v5;
    }
  }

  return result;
}

void *CFBurstTrieCreateCursorForBytes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = calloc(0x21uLL, 1uLL);
  CFBurstTrieSetCursorForBytes(a1, (uint64_t)v6, a2, a3);
  if (!v7 && v6)
  {
    free(v6);
    return 0LL;
  }

  return v6;
}

void CFBurstTrieCursorRelease(void *a1)
{
  if (a1) {
    free(a1);
  }
}

char *CFBurstTrieCursorCreateByCopy(char *result)
{
  if (result)
  {
    CFArrayRef v1 = result;
    __n128 result = (char *)calloc(0x21uLL, 1uLL);
    uint64_t v2 = *(void *)(v1 + 17);
    if (v2 == 1)
    {
      result[16] = v1[16];
      *(_OWORD *)__n128 result = *(_OWORD *)v1;
    }

    else if (!v2)
    {
      CFBurstTrieCursorCreateByCopy_cold_1();
    }

    *(void *)(result + 17) = v2;
    *(void *)(result + 25) = *(void *)(v1 + 25);
  }

  return result;
}

BOOL CFBurstTrieCursorIsEqual(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 25) == *(void *)(a2 + 25)
    && (*(void *)(a1 + 17) == 1LL ? (BOOL v2 = *(void *)(a2 + 17) == 1LL) : (BOOL v2 = 0),
        v2
     && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
     && *(unsigned __int8 *)(a1 + 16) == *(unsigned __int8 *)(a2 + 16)
     && *(_DWORD *)a1 == *(_DWORD *)a2))
  {
    return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
  }

  else
  {
    return 0LL;
  }

void advanceMapCursor(uint64_t a1, uint64_t a2)
{
  __asm { BR              X11 }

BOOL sub_180BAA564(uint64_t a1)
{
  return v1 == *(_DWORD *)(*(void *)(a1 + 2056) + 4LL) && advanceCursorMappedLevel(a1, v2, v4, v3) != 0;
}

void CFBurstTrieTraverseFromCursor(__int128 *a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    BOOL v2 = calloc(1uLL, 0x1000uLL);
    char v5 = 0;
    if (*(void *)((char *)a1 + 17) == 1LL)
    {
      char v4 = *((_BYTE *)a1 + 16);
      __int128 v3 = *a1;
      traverseFromMapCursor(*(void *)((char *)a1 + 25), (uint64_t)&v3);
    }

    free(v2);
  }

void traverseFromMapCursor(uint64_t a1, uint64_t a2)
{
  __asm { BR              X11 }

uint64_t sub_180BAAAC8@<X0>( int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__dst, void *__s2, size_t __n, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29)
{
  if (a1 == *(_DWORD *)(*(void *)(v33 + 2056) + 4LL)) {
    return traverseFromMapCursorMappedLevel(v33, v32, v29, v30, v31, v37, v35, v36);
  }
  return result;
}

char *makeCFBurstTrieListNode(const void *a1, unsigned int a2, int a3, int a4)
{
  size_t v8 = a2;
  uint64_t v9 = (char *)calloc(1uLL, a2 + 19LL);
  memcpy(v9 + 18, a1, v8);
  v9[a2 + 18] = 0;
  *(void *)uint64_t v9 = 0LL;
  *((_WORD *)v9 + _Block_object_dispose(va, 8) = a2;
  *((_DWORD *)v9 + 2) = a3;
  *((_DWORD *)v9 + 3) = a4;
  return v9;
}

uint64_t findCFBurstTrieMappedLevel( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v9 = result;
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  unsigned int v11 = *(_DWORD *)(a2 + 24);
  uint64_t v12 = (*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(void *)(result + 2056);
  if (v11 <= v10) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = v11;
  }
  if (v11 >= v10)
  {
    LODWORD(v15) = *(_DWORD *)(a2 + 24);
LABEL_10:
    if (*(_DWORD *)(v12 + 1024))
    {
      uint64_t result = a5(a4, a2 + 36);
      if ((result & 1) != 0) {
        return result;
      }
      unsigned int v10 = *(_DWORD *)(a2 + 20);
      LODWORD(v15) = *(_DWORD *)(a2 + 24);
    }

    if ((_DWORD)v15 != v10 || (a3 & 1) == 0) {
      return traverseCFBurstTrieMappedLevel(v9, v12, (_DWORD *)a2, a3, a4, a5);
    }
  }

  else
  {
    uint64_t v14 = *(void *)(a2 + 28);
    uint64_t v15 = *(unsigned int *)(a2 + 24);
    while (1)
    {
      uint64_t v16 = *(unsigned __int8 *)(v14 + v15);
      int v17 = *(_DWORD *)(v12 + 4 * v16);
      *(_DWORD *)(a2 + ++*(_WORD *)(cf + 16) = v17;
      *(_DWORD *)(a2 + 24) = v15 + 1;
      *(_BYTE *)(a2 + 36 + v15) = v16;
      int v18 = v17 & 3;
      if (v18 != 1) {
        break;
      }
      ++v15;
      uint64_t v12 = (v17 & 0xFFFFFFFC) + *(void *)(result + 2056);
      if (v13 == v15) {
        goto LABEL_10;
      }
    }

    if (v18 == 2)
    {
      return findCFBurstTrieMappedPage(result, a2, a4, a5);
    }

    else if (v18 == 3)
    {
      return findCFBurstTrieCompactMappedLevel(result, a2, a3, a4, a5);
    }
  }

  return result;
}

uint64_t findCFBurstTrieCompactMappedLevel( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  unsigned int v7 = a3;
  uint64_t v9 = result;
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  unsigned int v11 = *(_DWORD *)(a2 + 24);
  uint64_t v12 = (int8x8_t *)((*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(void *)(result + 2056));
  if (v11 <= v10) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = v11;
  }
  if (v11 >= v10)
  {
    LODWORD(v17) = *(_DWORD *)(a2 + 24);
LABEL_18:
    if (v12[4].i32[0])
    {
      uint64_t result = a5(a4, a2 + 36);
      if ((result & 1) != 0) {
        return result;
      }
      unsigned int v10 = *(_DWORD *)(a2 + 20);
      LODWORD(v17) = *(_DWORD *)(a2 + 24);
    }

    if ((_DWORD)v17 != v10 || (v7 & 1) == 0) {
      return traverseCFBurstTrieCompactMappedLevel(v9, v12, (_DWORD *)a2, v7, a4, a5);
    }
  }

  else
  {
    uint64_t v14 = *(void *)(a2 + 28);
    uint64_t v15 = *(unsigned int *)(a2 + 24);
    while (1)
    {
      unsigned int v16 = *(unsigned __int8 *)(v14 + v15);
      uint64_t v17 = v15 + 1;
      *(_DWORD *)(a2 + 24) = v15 + 1;
      *(_BYTE *)(a2 + v15 + 36) = v16;
      LODWORD(v1_Block_object_dispose(va, 8) = v16 >> 6;
      int8x8_t v19 = v12[v16 >> 6];
      uint64_t v20 = 1LL << v16;
      if ((*(void *)&v19 & (1LL << v16)) == 0) {
        break;
      }
      if (v16 >= 0x40)
      {
        int v21 = 0;
        else {
          uint64_t v18 = v18;
        }
        uint64_t result = (uint64_t)v12;
        do
        {
          int8x8_t v22 = *(int8x8_t *)result;
          result += 8LL;
          uint8x8_t v23 = (uint8x8_t)vcnt_s8(v22);
          v23.i16[0] = vaddlv_u8(v23);
          v21 += v23.i32[0];
          --v18;
        }

        while (v18);
      }

      else
      {
        int v21 = 0;
      }

      uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)((v20 - 1) & *(void *)&v19));
      v24.i16[0] = vaddlv_u8(v24);
      __int32 v25 = v12[4].i32[v21 + v24.i32[0] + 1];
      *(_DWORD *)(a2 + ++*(_WORD *)(cf + 16) = v25;
      int v26 = v25 & 3;
      if (v26 != 3)
      {
        if (v26 == 1) {
          return findCFBurstTrieMappedLevel(v9, a2, a3, a4, a5);
        }
        if (v26 == 2) {
          return findCFBurstTrieMappedPage(v9, a2, a4, a5);
        }
        return result;
      }

      uint64_t v12 = (int8x8_t *)((v25 & 0xFFFFFFFC) + *(void *)(v9 + 2056));
      uint64_t v15 = v17;
      if (v17 == v13) {
        goto LABEL_18;
      }
    }
  }

  return result;
}

uint64_t findCFBurstTrieMappedPage( uint64_t result, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t))
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  char v5 = (unsigned int *)((*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(void *)(result + 2056));
  unsigned int v6 = *v5;
  int v27 = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24);
  if (v27 >= 1) {
    int v7 = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24);
  }
  else {
    int v7 = 0;
  }
  if ((*(_BYTE *)(result + 2072) & 8) != 0)
  {
    if (v6)
    {
      unsigned int v14 = 0;
      uint64_t v15 = 0LL;
      uint64_t v26 = a2 + 36;
      do
      {
        unsigned int v16 = v15;
        uint64_t v17 = (char *)v5 + v14;
        unsigned int v19 = v17[4];
        uint64_t v15 = (unsigned __int8 *)(v17 + 4);
        uint64_t v18 = v19;
        int v20 = *(unsigned __int16 *)(v15 + 1);
        if ((int)v18 + v20 >= v7)
        {
          uint64_t v21 = *(unsigned int *)(a2 + 24);
          size_t v22 = *v15;
          if (v27 <= 0
            || (v23 = (char *)(*(void *)(a2 + 28) + v21), uint64_t result = memcmp(__s1, v23, *v15), !(_DWORD)result)
            && (uint64_t result = memcmp(v15 + 7, &v23[v22], (*(_DWORD *)(a2 + 20) - v21 - v22)), !(_DWORD)result))
          {
            memcpy((void *)(v26 + v21), __s1, v22);
            uint64_t result = (uint64_t)memcpy( (void *)(v26 + *(unsigned int *)(a2 + 24) + *v15),  v15 + 7,  *(unsigned __int16 *)(v15 + 1));
            *(_BYTE *)(a2 + *(_DWORD *)(a2 + 24) + *v15 + *(unsigned __int16 *)(v15 + 1) + 36) = 0;
            if (*(_DWORD *)(v15 + 3))
            {
              uint64_t result = a4(a3, v26);
              if ((result & 1) != 0) {
                break;
              }
            }
          }
        }

        v14 += *(unsigned __int16 *)(v15 + 1) + 7;
      }

      while (v14 < v6);
    }
  }

  else if (v6)
  {
    unsigned int v8 = 0;
    uint64_t v28 = a2 + 36;
    do
    {
      uint64_t v9 = (char *)v5 + v8;
      int v12 = *((unsigned __int16 *)v9 + 2);
      unsigned int v10 = (unsigned __int16 *)(v9 + 4);
      size_t v11 = v12;
      if (v7 <= v12)
      {
        uint64_t v13 = *(unsigned int *)(a2 + 24);
        uint64_t result = memcmp(v10 + 3, (const void *)(*(void *)(a2 + 28) + v13), v7);
        if (!(_DWORD)result)
        {
          uint64_t result = (uint64_t)memcpy((void *)(v28 + v13), v10 + 3, v11);
          *(_BYTE *)(a2 + *(_DWORD *)(a2 + 24) + *v10 + 36) = 0;
          if (*(_DWORD *)(v10 + 1))
          {
            uint64_t result = a4(a3, v28);
            if ((result & 1) != 0) {
              break;
            }
          }
        }
      }

      v8 += *v10 + 6;
    }

    while (v8 < v6);
  }

  return result;
}

uint64_t traverseCFBurstTrieMappedLevel( uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v11 = result;
  uint64_t v12 = 0LL;
  uint64_t v13 = a3[6];
  unsigned int v14 = (char *)a3 + v13 + 36;
  _BYTE *v14 = 0;
  uint64_t v15 = (v13 + 1);
  size_t v22 = (char *)a3 + v15 + 36;
  uint8x8_t v23 = a3 + 9;
  while (1)
  {
    int v16 = *(_DWORD *)(a2 + 4 * v12);
    a3[6] = v15;
    _BYTE *v14 = v12;
    int v17 = v16 & 3;
    if (v17 == 3) {
      break;
    }
    if (v17 == 2)
    {
      a3[4] = v16;
      *size_t v22 = 0;
      uint64_t result = findCFBurstTrieMappedPage(v11, (uint64_t)a3, a5, a6);
    }

    else if (v17 == 1)
    {
      uint64_t v18 = *(void *)(v11 + 2056) + (v16 & 0xFFFFFFFC);
      int v19 = v15;
      if (*(_DWORD *)(v18 + 1024))
      {
        uint64_t result = a6(a5, (uint64_t)v23);
        if ((result & 1) != 0) {
          return result;
        }
        int v19 = a3[6];
      }

      if (v19 == a3[5] && (a4 & 1) != 0) {
        return result;
      }
      uint64_t result = traverseCFBurstTrieMappedLevel(v11, v18, a3, a4, a5, a6);
    }

uint64_t traverseCFBurstTrieCompactMappedLevel( uint64_t result, int8x8_t *a2, _DWORD *a3, unsigned int a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v10 = result;
  unint64_t v11 = 0LL;
  uint64_t v12 = a3[6];
  uint64_t v13 = (char *)a3 + v12 + 36;
  _BYTE *v13 = 0;
  uint64_t v14 = (v12 + 1);
  uint64_t v26 = a3 + 9;
  int v27 = (char *)a3 + v14 + 36;
  while (1)
  {
    if (v11 >> 6 <= 1) {
      uint64_t v15 = 1LL;
    }
    else {
      uint64_t v15 = v11 >> 6;
    }
    int8x8_t v16 = a2[v11 >> 6];
    a3[6] = v12;
    if ((*(void *)&v16 & (1LL << v11)) == 0) {
      goto LABEL_21;
    }
    if (v11 >= 0x40)
    {
      int v17 = 0;
      uint64_t v18 = a2;
      do
      {
        int8x8_t v19 = *v18++;
        uint8x8_t v20 = (uint8x8_t)vcnt_s8(v19);
        v20.i16[0] = vaddlv_u8(v20);
        v17 += v20.i32[0];
        --v15;
      }

      while (v15);
    }

    else
    {
      int v17 = 0;
    }

    uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v16 & ((1LL << v11) - 1)));
    v21.i16[0] = vaddlv_u8(v21);
    __int32 v22 = a2[4].i32[v17 + v21.i32[0] + 1];
    a3[6] = v14;
    _BYTE *v13 = v11;
    int v23 = v22 & 3;
    if (v23 == 1)
    {
      uint64_t result = traverseCFBurstTrieMappedLevel(v10, *(void *)(v10 + 2056) + (v22 & 0xFFFFFFFC), a3, a4, a5, a6);
      goto LABEL_21;
    }

    if (v23 == 2)
    {
      a3[4] = v22;
      _BYTE *v27 = 0;
      uint64_t result = findCFBurstTrieMappedPage(v10, (uint64_t)a3, a5, a6);
      goto LABEL_21;
    }

    if (v23 == 3) {
      break;
    }
LABEL_21:
    if ((_DWORD)++v11 == 256) {
      return result;
    }
  }

  uint64_t v24 = *(void *)(v10 + 2056) + (v22 & 0xFFFFFFFC);
  int v25 = v12 + 1;
  if (*(_DWORD *)(v24 + 32))
  {
    uint64_t result = a6(a5, (uint64_t)v26);
    if ((result & 1) != 0) {
      return result;
    }
    int v25 = a3[6];
  }

  if (v25 != a3[5] || (a4 & 1) == 0)
  {
    uint64_t result = traverseCFBurstTrieCompactMappedLevel(v10, v24, a3, a4, a5, a6);
    goto LABEL_21;
  }

  return result;
}

uint64_t findCFBurstTrieList(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  uint64_t v3 = *(void *)(result + 16);
  size_t v4 = (*(_DWORD *)(result + 28) - *(_DWORD *)(result + 24));
  else {
    int v5 = 0;
  }
  unint64_t v6 = v3 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v3 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    uint64_t v9 = result;
    uint64_t v10 = result + 40;
    do
    {
      size_t v11 = *(unsigned __int16 *)(v6 + 16);
      if (v5 <= (int)v11)
      {
        uint64_t v12 = *(unsigned int *)(v9 + 24);
        if ((int)v4 <= 0
          || (uint64_t result = memcmp((const void *)(v6 + 18), (const void *)(*(void *)(v9 + 32) + v12), v4), !(_DWORD)result))
        {
          uint64_t result = (uint64_t)memcpy((void *)(v10 + v12), (const void *)(v6 + 18), v11);
          *(_BYTE *)(v9 + *(_DWORD *)(v9 + 24) + *(unsigned __int16 *)(v6 + 16) + 40) = 0;
          *(void *)(v9 + ++*(_WORD *)(cf + 16) = v6;
          if (*(_DWORD *)(v6 + 12))
          {
            uint64_t result = a3(a2, v10);
            if ((result & 1) != 0) {
              break;
            }
          }
        }
      }

      unint64_t v6 = *(void *)v6;
    }

    while (v6);
  }

  return result;
}

uint64_t traverseCFBurstTrieLevel( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v9 = result;
  uint64_t v10 = 0LL;
  uint64_t v11 = *(unsigned int *)(a2 + 24);
  uint64_t v12 = (_BYTE *)(a2 + 40 + v11);
  _BYTE *v12 = 0;
  uint64_t v13 = (v11 + 1);
  uint64_t v19 = a2 + 40;
  uint64_t v14 = (_BYTE *)(a2 + 40 + v13);
  while (1)
  {
    uint64_t v15 = *(void *)(v9 + 8 * v10);
    *(_DWORD *)(a2 + 24) = v13;
    _BYTE *v12 = v10;
    if ((v15 & 3) == 2)
    {
      *(void *)(a2 + ++*(_WORD *)(cf + 16) = v15;
      _BYTE *v14 = 0;
      uint64_t result = findCFBurstTrieList(a2, a4, a5);
      goto LABEL_11;
    }

    if ((v15 & 3) == 1) {
      break;
    }
LABEL_11:
    if (++v10 == 256) {
      return result;
    }
  }

  unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFFCLL;
  int v17 = *(_DWORD *)((v15 & 0xFFFFFFFFFFFFFFFCLL) + 2052);
  int v18 = v13;
  if (v17)
  {
    uint64_t result = a5(a4, v19);
    if ((result & 1) != 0) {
      return result;
    }
    int v18 = *(_DWORD *)(a2 + 24);
  }

  if (v18 != *(_DWORD *)(a2 + 28) || (a3 & 1) == 0)
  {
    uint64_t result = traverseCFBurstTrieLevel(v16, a2, a3, a4, a5);
    goto LABEL_11;
  }

  return result;
}

uint64_t advanceCursorMappedLevel(uint64_t a1, _DWORD *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v4 = 0LL;
  if (a3 && (a4 & 0x8000000000000000LL) == 0)
  {
    uint64_t v5 = (*a2 & 0xFFFFFFFC) + *(void *)(a1 + 2056);
    if (a4)
    {
      *a2 = *(_DWORD *)(v5 + 4LL * *a3);
      return advanceMapCursor();
    }

    a2[3] = *(_DWORD *)(v5 + 1024);
    return 1LL;
  }

  return v4;
}

uint64_t traverseFromMapCursorMappedLevel( uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, _BYTE *a6, uint64_t a7, uint64_t (*a8)(void, void, void, void, void))
{
  uint64_t v21 = (*(_DWORD *)a2 & 0xFFFFFFFC) + *(void *)(result + 2056);
  uint64_t v22 = result;
  uint64_t v12 = *(unsigned int *)(v21 + 1024);
  unsigned int v13 = a5;
  if ((_DWORD)v12)
  {
    uint64_t v14 = a7;
    uint64_t v15 = a8;
    uint64_t result = a8(a7, a3, a5, v12, a6);
    if (v13 >= a4) {
      return result;
    }
    LODWORD(a5) = v13;
    unsigned int v16 = a4;
    if (*a6) {
      return result;
    }
  }

  else
  {
    uint64_t v14 = a7;
    uint64_t v15 = a8;
    unsigned int v16 = a4;
  }

  uint64_t v17 = 0LL;
  uint64_t v18 = a5;
  do
  {
    *(_BYTE *)(a3 + v1_Block_object_dispose(va, 8) = v17;
    *(_DWORD *)a2 = *(_DWORD *)(v21 + 4 * v17);
    if (v17) {
      uint64_t v19 = v13 + 1;
    }
    else {
      uint64_t v19 = v13;
    }
    *(void *)(a2 + 4) = 0LL;
    *(void *)(a2 + 9) = 0LL;
    uint64_t result = traverseFromMapCursor(v22, a2, a3, v16 - (v17 != 0), v19, a6, v14, v15);
    if (*a6) {
      break;
    }
  }

  while (v17++ != 255);
  return result;
}

uint64_t burstTrieCompactTrieMappedFind(int8x8_t *a1, uint64_t a2, char *a3, int a4, _DWORD *a5, char a6)
{
  if (a4)
  {
    do
    {
      unint64_t v6 = *a3;
      uint64_t v7 = v6 >> 6;
      int8x8_t v8 = a1[v6 >> 6];
      uint64_t v9 = 1LL << v6;
      if (((1LL << v6) & *(void *)&v8) == 0) {
        return 0LL;
      }
      if (v6 >= 0x40)
      {
        int v10 = 0;
        else {
          uint64_t v7 = v7;
        }
        uint64_t v11 = a1;
        do
        {
          int8x8_t v12 = *v11++;
          uint8x8_t v13 = (uint8x8_t)vcnt_s8(v12);
          v13.i16[0] = vaddlv_u8(v13);
          v10 += v13.i32[0];
          --v7;
        }

        while (v7);
      }

      else
      {
        int v10 = 0;
      }

      uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)((v9 - 1) & *(void *)&v8));
      v14.i16[0] = vaddlv_u8(v14);
      __int32 v15 = a1[5].i32[v10 + v14.i32[0]];
      int v16 = v15 & 3;
      if (v16 != 3)
      {
        if (v16 == 1) {
          return burstTrieMappedFind((v15 & 0xFFFFFFFC) + a2, a2, a3 + 1, (a4 - 1));
        }
        if (v16 != 2) {
          return 0LL;
        }
        return burstTrieMappedPageFind( (unsigned int *)((v15 & 0xFFFFFFFC) + a2),  a3 + 1,  (a4 - 1),  a5,  a6);
      }

      a1 = (int8x8_t *)((v15 & 0xFFFFFFFC) + a2);
      ++a3;
    }

    while (--a4);
  }

  if (!a1[4].i32[0]) {
    return 0LL;
  }
  if (a5) {
    *a5 = a1[4].i32[1];
  }
  return 1LL;
}

uint64_t burstTrieMappedPageFind(unsigned int *a1, char *__s2, size_t __n, _DWORD *a4, char a5)
{
  unsigned int v6 = __n;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  unsigned int v9 = *a1;
  if ((a5 & 1) != 0)
  {
    if (v9)
    {
      unsigned int v10 = 0;
      while (1)
      {
        uint64_t v11 = (char *)a1 + v10;
        unsigned int v14 = v11[4];
        uint8x8_t v13 = v11 + 4;
        size_t v12 = v14;
        int v15 = (unsigned __int16)(*(_WORD *)(v13 + 1) + v14);
        else {
          size_t v16 = v12 ^ 0xFF;
        }
        memcpy(&v24[v12], v13 + 7, v16);
        unsigned int v10 = v10 - v12 + v15 + 7;
        if (v10 >= v9) {
          return 0LL;
        }
      }

      if (!a4) {
        return 1LL;
      }
      int v23 = *(_DWORD *)(v13 + 3);
LABEL_23:
      *a4 = v23;
      return 1LL;
    }
  }

  else if (v9)
  {
    unsigned int v17 = 0;
    while (1)
    {
      uint64_t v18 = (char *)a1 + v17;
      int v21 = *((unsigned __int16 *)v18 + 2);
      uint64_t v19 = v18 + 4;
      int v20 = v21;
      if (v21 == v6 && !memcmp(v19 + 6, __s2, v6)) {
        break;
      }
      v17 += v20 + 6;
      if (v17 >= v9) {
        return 0LL;
      }
    }

    if (!a4) {
      return 1LL;
    }
    int v23 = *(_DWORD *)(v19 + 2);
    goto LABEL_23;
  }

  return 0LL;
}

void serializeCFBurstTrieLists(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (uint64_t i = 0LL; i != 256; ++i)
  {
    uint64_t v9 = *(void *)(a2 + 8 * i);
    if ((v9 & 3) == 2)
    {
      unsigned int v10 = (void *)(v9 & 0xFFFFFFFFFFFFFFFCLL);
      int v11 = lseek(a4, 0LL, 1);
      serializeCFBurstTrieList(a1, (uint64_t)v10);
      do
      {
        size_t v12 = (void *)*v10;
        free(v10);
        unsigned int v10 = v12;
      }

      while (v12);
      *(void *)(a2 + 8 * i) = (v11 - a3) | 2LL;
    }

    else if ((v9 & 3) == 1)
    {
      serializeCFBurstTrieLists(a1, v9 & 0xFFFFFFFFFFFFFFFCLL, a3, a4);
    }
  }

uint64_t serializeCFBurstTrieLevels(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  uint64_t v38 = a4;
  uint64_t v12 = 0LL;
  uint64_t v40 = *MEMORY[0x1895F89C0];
  int32x4_t v13 = 0uLL;
  do
  {
    int32x4_t v13 = vsubq_s32( v13,  (int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32( (int32x4_t)vceqzq_s64(*(int64x2_t *)&a2[v12]),  (int32x4_t)vceqzq_s64(*(int64x2_t *)&a2[v12 + 4]))));
    v12 += 8LL;
  }

  while (v12 != 512);
  unsigned int v14 = vaddvq_s32(v13);
  uint64_t v15 = *a3;
  if ((*(_BYTE *)(a1 + 2072) & 4) == 0 || v14 > 0xC7) {
    a6 = 1;
  }
  unsigned int v36 = a6;
  uint64_t v18 = v15;
  if ((a6 & 1) != 0)
  {
    uint64_t v19 = 0LL;
    *a3 = v15 + 1028;
    do
    {
      uint64_t v20 = *(void *)&a2[2 * v19];
      if ((v20 & 3) == 1)
      {
        int v21 = *a3;
        else {
          int v22 = v21 | 3;
        }
        v39[v19] = v22;
      }

      else
      {
        v39[v19] = v20;
      }

      ++v19;
    }

    while (v19 != 256);
    v39[256] = a2[513];
    pwrite(a7, v39, 0x404uLL, v18 + v38);
    if (a5) {
LABEL_19:
    }
      free(a2);
  }

  else
  {
    unsigned int v37 = a7;
    int v34 = a5;
    uint64_t v35 = v14;
    size_t v24 = 4LL * v14 + 36;
    MEMORY[0x1895F8858](a1, a2);
    uint64_t v26 = (int8x16_t *)((char *)&v33 - v25);
    bzero((char *)&v33 - v25, v24);
    uint64_t v27 = 0LL;
    int v28 = 0;
    size_t v33 = v24;
    *a3 = v15 + v24;
    do
    {
      uint64_t v29 = *(void *)&a2[2 * v27];
      if (v29)
      {
        v26->i64[v27 >> 6] |= 1LL << v27;
        uint64_t v30 = &v26->i8[4 * v28];
        if ((v29 & 3) == 1)
        {
          int v31 = *a3;
          else {
            int v32 = v31 | 3;
          }
          *((_DWORD *)v30 + 9) = v32;
          uint64_t v15 = v18;
        }

        else
        {
          *((_DWORD *)v30 + 9) = v29;
          uint64_t v15 = v18;
        }

        ++v28;
      }

      ++v27;
    }

    while (v27 != 256);
    v26[2].i32[0] = a2[513];
    if (vaddvq_s32( vuzp1q_s32( (int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v26)))),  (int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(v26[1])))))) != (_DWORD)v35) {
      serializeCFBurstTrieLevels_cold_1();
    }
    pwrite(v37, v26, v33, v15 + v38);
    if (v34) {
      goto LABEL_19;
    }
  }

  return v36;
}

void serializeCFBurstTrieList(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  int v4 = v3;
  unsigned int v6 = v5;
  uint64_t v7 = v2;
  uint64_t v27 = *MEMORY[0x1895F89C0];
  unint64_t v8 = *(unsigned int *)(v2 + 2080);
  uint64_t v9 = malloc(8 * v8);
  for (unsigned int i = 0; v6; ++i)
  {
    if (v8 <= i)
    {
      uint64_t v9 = __CFSafelyReallocate(v9, 16 * v8, 0LL);
      v8 *= 2LL;
    }

    *((void *)v9 + i) = v6;
    unsigned int v6 = (void *)*v6;
  }

  if (v8 >= 0x10) {
    int v11 = malloc(1031 * v8 + 4);
  }
  else {
    int v11 = v26;
  }
  int v12 = *(_DWORD *)(v7 + 2072);
  if ((v12 & 8) != 0)
  {
    uint64_t v19 = i;
    qsort(v9, i, 8uLL, (int (__cdecl *)(const void *, const void *))nodeStringCompare);
    if (i)
    {
      uint64_t v20 = 0LL;
      uint64_t v21 = 0LL;
      unsigned int i = 0;
      uint64_t v15 = 10LL;
      do
      {
        uint64_t v22 = v21;
        uint64_t v21 = *((void *)v9 + v20);
        unsigned __int16 v23 = 0;
        if (v22)
        {
          unsigned int v24 = *(unsigned __int16 *)(v21 + 16);
          while (v24 > v23
               && *(unsigned __int16 *)(v22 + 16) > v23
               && *(unsigned __int8 *)(v21 + v23 + 18) == *(unsigned __int8 *)(v22 + v23 + 18))
          {
            if (++v23 == 255)
            {
              unsigned __int16 v23 = 255;
              break;
            }
          }
        }

        else
        {
          LOWORD(v24) = *(_WORD *)(v21 + 16);
        }

        uint64_t v25 = (char *)v11 + i;
        *(_WORD *)(v25 + 5) = v24 - v23;
        *(_DWORD *)(v25 + 7) = *(_DWORD *)(v21 + 12);
        v25[4] = v23;
        memcpy(v25 + 11, (const void *)(v21 + v23 + 18), *(unsigned __int16 *)(v21 + 16) - (unint64_t)v23);
        unsigned int i = i - v23 + *(unsigned __int16 *)(v21 + 16) + 7;
        ++v20;
      }

      while (v20 != v19);
    }

    else
    {
      uint64_t v15 = 10LL;
    }
  }

  else
  {
    uint64_t v13 = i;
    if ((v12 & 0x10) != 0) {
      unsigned int v14 = (int (__cdecl *)(const void *, const void *))nodeStringCompare;
    }
    else {
      unsigned int v14 = (int (__cdecl *)(const void *, const void *))nodeWeightCompare;
    }
    qsort(v9, i, 8uLL, v14);
    if (i)
    {
      unsigned int i = 0;
      uint64_t v15 = 7LL;
      size_t v16 = (uint64_t *)v9;
      do
      {
        uint64_t v17 = *v16++;
        uint64_t v18 = (char *)v11 + i;
        *((_WORD *)v18 + 2) = *(_WORD *)(v17 + 16);
        *(_DWORD *)(v18 + 6) = *(_DWORD *)(v17 + 12);
        memcpy(v18 + 10, (const void *)(v17 + 18), *(unsigned __int16 *)(v17 + 16));
        i += *(unsigned __int16 *)(v17 + 16) + 6;
        --v13;
      }

      while (v13);
    }

    else
    {
      uint64_t v15 = 7LL;
    }
  }

  _DWORD *v11 = i;
  write(v4, v11, (v15 + i) & 0x1FFFFFFFCLL);
  free(v9);
  if (v11 != (_DWORD *)v26) {
    free(v11);
  }
}

uint64_t nodeStringCompare(void *a1, void *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  int v4 = (const void *)(*a1 + 18LL);
  uint64_t v5 = (const void *)(*a2 + 18LL);
  unsigned int v6 = *(unsigned __int16 *)(v2 + 16);
  unsigned int v7 = *(unsigned __int16 *)(v3 + 16);
  unsigned int v8 = v6 - v7;
  if (v6 >= v7) {
    size_t v9 = v7;
  }
  else {
    size_t v9 = v6;
  }
  LODWORD(result) = memcmp(v4, v5, v9);
  if ((_DWORD)result) {
    return result;
  }
  else {
    return v8;
  }
}

uint64_t nodeWeightCompare(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(*(void *)a2 + 8LL) - *(_DWORD *)(*(void *)a1 + 8LL));
}

void finalizeCFBurstTrie(uint64_t a1)
{
  for (uint64_t i = 0LL; i != 256; ++i)
  {
    uint64_t v3 = *(void *)(a1 + 8 * i);
    if ((v3 & 3) == 2)
    {
      int v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
        uint64_t v5 = (void *)*v4;
        free(v4);
        int v4 = v5;
      }

      while (v5);
    }

    else if ((v3 & 3) == 1)
    {
      finalizeCFBurstTrie(v3 & 0xFFFFFFFFFFFFFFFCLL);
      free((void *)(*(void *)(a1 + 8 * i) & 0xFFFFFFFFFFFFFFFCLL));
    }
  }

void _CFFileCoordinateReadingItemAtURL2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[5] = *MEMORY[0x1895F89C0];
  unsigned int v8 = objc_lookUpClass("NSFileCoordinator");
  if (v8)
  {
    id v9 = objc_alloc_init(v8);
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = ___CFFileCoordinateReadingItemAtURL2_block_invoke_2;
    _DWORD v11[3] = &unk_1899ED2C0;
    v11[4] = a4;
    objc_msgSend(v9, "__coordinateReadingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, v11);
  }

  else
  {
    CFErrorRef v10 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 3328LL, 0LL);
    (*(void (**)(uint64_t, void, CFErrorRef, void *))(a4 + 16))(a4, 0LL, v10, &__block_literal_global_40);
    CFRelease(v10);
  }

void _CFFileCoordinateWritingItemAtURL2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[5] = *MEMORY[0x1895F89C0];
  unsigned int v8 = objc_lookUpClass("NSFileCoordinator");
  if (v8)
  {
    id v9 = objc_alloc_init(v8);
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = ___CFFileCoordinateWritingItemAtURL2_block_invoke_2;
    _DWORD v11[3] = &unk_1899ED2C0;
    v11[4] = a4;
    objc_msgSend(v9, "__coordinateWritingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, v11);
  }

  else
  {
    CFErrorRef v10 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 3328LL, 0LL);
    (*(void (**)(uint64_t, void, CFErrorRef, void *))(a4 + 16))(a4, 0LL, v10, &__block_literal_global_3);
    CFRelease(v10);
  }

void _CFFileCoordinateReadingWritingItemsAtURLs2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v15[5] = *MEMORY[0x1895F89C0];
  int v12 = objc_lookUpClass("NSFileCoordinator");
  if (v12)
  {
    id v13 = objc_alloc_init(v12);
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    void v15[2] = ___CFFileCoordinateReadingWritingItemsAtURLs2_block_invoke_2;
    uint64_t v15[3] = &unk_1899ED328;
    v15[4] = a6;
    objc_msgSend( v13,  "__coordinateReadingItemAtURL:options:writingItemAtURL:options:purposeID:byAccessor:",  a1,  a2,  a3,  a4,  a5,  v15);
  }

  else
  {
    CFErrorRef v14 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 3328LL, 0LL);
    (*(void (**)(uint64_t, void, void, CFErrorRef, void *))(a6 + 16))( a6,  0LL,  0LL,  v14,  &__block_literal_global_4_0);
    CFRelease(v14);
  }

void _CFFileCoordinateWritingItemsAtURLs2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v15[5] = *MEMORY[0x1895F89C0];
  int v12 = objc_lookUpClass("NSFileCoordinator");
  if (v12)
  {
    id v13 = objc_alloc_init(v12);
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    void v15[2] = ___CFFileCoordinateWritingItemsAtURLs2_block_invoke_2;
    uint64_t v15[3] = &unk_1899ED328;
    v15[4] = a6;
    objc_msgSend( v13,  "__coordinateWritingItemAtURL:options:writingItemAtURL:options:purposeID:byAccessor:",  a1,  a2,  a3,  a4,  a5,  v15);
  }

  else
  {
    CFErrorRef v14 = CFErrorCreate(0LL, @"NSCocoaErrorDomain", 3328LL, 0LL);
    (*(void (**)(uint64_t, void, void, CFErrorRef, void *))(a6 + 16))( a6,  0LL,  0LL,  v14,  &__block_literal_global_6);
    CFRelease(v14);
  }

uint64_t _CFFileDidMove2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return -[objc_class __itemAtURL:didMoveToURL:purposeID:]( objc_lookUpClass("NSFileCoordinator"),  "__itemAtURL:didMoveToURL:purposeID:",  a1,  a2,  a3);
}

uint64_t _CFFileDidDisconnect2(uint64_t a1, uint64_t a2)
{
  return -[objc_class __itemAtURL:didDisconnectWithPurposeID:]( objc_lookUpClass("NSFileCoordinator"),  "__itemAtURL:didDisconnectWithPurposeID:",  a1,  a2);
}

uint64_t _CFFileDidReconnect2(uint64_t a1, uint64_t a2)
{
  return -[objc_class __itemAtURL:didReconnectWithPurposeID:]( objc_lookUpClass("NSFileCoordinator"),  "__itemAtURL:didReconnectWithPurposeID:",  a1,  a2);
}

uint64_t _CFFileDidGainVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return -[objc_class __itemAtURL:didGainVersionWithClientID:name:purposeID:]( objc_lookUpClass("NSFileCoordinator"),  "__itemAtURL:didGainVersionWithClientID:name:purposeID:",  a1,  a2,  a3,  a4);
}

uint64_t _CFFileDidLoseVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return -[objc_class __itemAtURL:didLoseVersionWithClientID:name:purposeID:]( objc_lookUpClass("NSFileCoordinator"),  "__itemAtURL:didLoseVersionWithClientID:name:purposeID:",  a1,  a2,  a3,  a4);
}

uint64_t _CFFileDidResolveConflictVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return -[objc_class __itemAtURL:didResolveConflictVersionWithClientID:name:purposeID:]( objc_lookUpClass("NSFileCoordinator"),  "__itemAtURL:didResolveConflictVersionWithClientID:name:purposeID:",  a1,  a2,  a3,  a4);
}

void _CFFileCoordinateReadingItemAtURL(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void _CFFileCoordinateWritingItemAtURL(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void _CFFileCoordinateReadWriteItemsAtURLs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

uint64_t _CFHyphenationGetLinguisticDataPath()
{
  uint64_t result = _CFCustomHyphenationLinguisticDataPath;
  if (!_CFCustomHyphenationLinguisticDataPath)
  {
    if (_CFHyphenationGetLinguisticDataPath_once_token != -1) {
      dispatch_once(&_CFHyphenationGetLinguisticDataPath_once_token, &__block_literal_global_41);
    }
    return _CFDefaultHyphenationLinguisticDataPath;
  }

  return result;
}

void _CFHyphenationSetLinguisticDataPath(const void *a1)
{
  if (_CFCustomHyphenationLinguisticDataPath) {
    CFRelease((CFTypeRef)_CFCustomHyphenationLinguisticDataPath);
  }
  _CFCustomHyphenationLinguisticDataPath = (uint64_t)a1;
}

uint64_t _CFHyphenationGetAllPossibleHyphenationLocations( const __CFString *a1, CFIndex a2, CFIndex a3, int a4, const __CFLocale *a5, uint64_t a6, uint64_t a7)
{
  return _CFHyphenationGetHyphenationLocations(a1, a2, a3, a4, 0LL, a5, a6, a7);
}

uint64_t _CFHyphenationGetHyphenationLocations( const __CFString *a1, CFIndex a2, CFIndex a3, int a4, uint64_t a5, CFLocaleRef locale, uint64_t a7, uint64_t a8)
{
  id v9 = locale;
  uint64_t v109 = *MEMORY[0x1895F89C0];
  uint64_t v15 = 100LL;
  if (a8 < 100) {
    uint64_t v15 = a8;
  }
  uint64_t v106 = v15;
  if (!CFStringIsHyphenationAvailableForLocale(locale)) {
    return -1LL;
  }
  uint64_t v105 = a5;
  Identifier = (__CFString *)CFLocaleGetIdentifier(v9);
  os_unfair_lock_lock_with_options();
  TokenizersForLocale = (const __CFArray *)getTokenizersForLocale(Identifier);
  if (!TokenizersForLocale || (uint64_t v18 = TokenizersForLocale, (Count = CFArrayGetCount(TokenizersForLocale)) == 0))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
    goto LABEL_9;
  }

  uint64_t v104 = a1;
  uint64_t v20 = a7;
  int v21 = a4;
  CFIndex v22 = a3;
  unsigned __int16 v23 = v9;
  CFIndex v24 = a2;
  CFIndex v25 = Count - 1;
  ValueAtIndex = CFArrayGetValueAtIndex(v18, Count - 1);
  CFIndex v27 = v25;
  a2 = v24;
  id v9 = v23;
  a3 = v22;
  a4 = v21;
  a7 = v20;
  a1 = v104;
  CFArrayRemoveValueAtIndex(v18, v27);
  os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
  if (!ValueAtIndex)
  {
LABEL_9:
    int v107 = 0;
    CFStringGetCString(Identifier, (char *)v108, 256LL, 0x8000100u);
    ValueAtIndex = (const void *)ubrk_open();
    if (!ValueAtIndex) {
      return 0LL;
    }
  }

  uint64_t v104 = (const __CFString *)a7;
  CFIndex Length = CFStringGetLength(a1);
  uint64_t v30 = &v92;
  int v31 = a2 + 20 - a3;
  if (a2 <= a3) {
    int v31 = a4;
  }
  if (a2 + 20 <= Length) {
    int v32 = v31;
  }
  else {
    int v32 = Length - a3;
  }
  CFIndex v33 = v32;
  int v107 = 0;
  MEMORY[0x1895F8858](Length, v29);
  uint64_t v35 = (char *)&v92 - v34;
  v110.CFIndex location = a3;
  v110.size_t length = v33;
  CFStringGetCharacters(a1, v110, (UniChar *)((char *)&v92 - v34));
  ubrk_setText();
  int v36 = ubrk_last();
  if (v36 != -1)
  {
    int v37 = v36;
    __int128 v103 = v35;
    uint64_t v38 = 0LL;
    CFIndex v100 = a2;
    int v39 = a2 - a3;
    CFAllocatorRef v102 = 0LL;
    CFIndex v99 = a3 + 1;
    CFAllocatorRef v101 = (CFAllocatorRef)&__kCFAllocatorNull;
    char v40 = v105;
    while (1)
    {
      do
      {
        int v41 = v37;
        uint64_t v42 = ubrk_preceding();
        if ((_DWORD)v42 == -1) {
          goto LABEL_103;
        }
        int v37 = v42;
      }

      while ((int)v42 >= v39);
      uint64_t v43 = (v41 - v42);
      uint64_t v44 = &v103[2 * (int)v42];
      int v45 = *(unsigned __int16 *)v44;
      if (v45 == 39)
      {
        uint64_t v46 = 1LL;
        goto LABEL_39;
      }

      if (v45 == 99)
      {
LABEL_27:
        int v49 = *((unsigned __int16 *)v44 + 1);
        uint64_t v46 = 2LL;
        if (v49 == 39 || v49 == 8217) {
          goto LABEL_39;
        }
      }

      else
      {
        uint64_t v46 = 1LL;
        if (v45 == 8217) {
          goto LABEL_39;
        }
        uint64_t v47 = 0LL;
        while (v47 != 7)
        {
          int v48 = __CFHyphenationRangeOfCharactersExcludingContraction_singleCharacterPrefixes[v47++ + 3];
          if (v48 == v45)
          {
            goto LABEL_27;
          }
        }
      }

      if (v45 == 113 && *((_WORD *)v44 + 1) == 117)
      {
        int v50 = *((unsigned __int16 *)v44 + 2);
        BOOL v51 = v50 == 8217 || v50 == 39;
        uint64_t v46 = 3LL;
        if (!v51) {
          uint64_t v46 = 0LL;
        }
      }

      else
      {
        uint64_t v46 = 0LL;
      }

uint64_t _CFStringHyphenationCompileHyphenatorData(const char *a1)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  snprintf(__str, 0x400uLL, "%s%c%s", a1, 47LL, "patterns.txt");
  snprintf(v49, 0x400uLL, "%s%c%s", a1, 47LL, "exceptions.txt");
  snprintf(cStr, 0x400uLL, "%s%c%s", a1, 47LL, "hyphenation.dat");
  int v45 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 1LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int valuePtr = 64;
  CFNumberRef v3 = CFNumberCreate(0LL, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, @"ContainerSize", v3);
  int v4 = CFBurstTrieCreateWithOptions(Mutable);
  CFRelease(Mutable);
  CFRelease(v3);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  unsigned int v6 = __CFHyphenationMapFileContents(__str, &v45);
  if (v45)
  {
    if (v4) {
      CFBurstTrieRelease(v4);
    }
    uint64_t v7 = 1LL;
    fwrite("error: failed to map patterns file\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return v7;
  }

  uint64_t v43 = v6;
  unsigned int v8 = CFStringCreateWithBytes(0LL, *(const UInt8 **)v6, *((void *)v6 + 1), 0x8000100u, 1u);
  CFIndex Length = CFStringGetLength(v8);
  CFErrorRef v10 = (UniChar *)malloc(2 * Length);
  v52.CFIndex location = 0LL;
  v52.size_t length = Length;
  CFStringGetCharacters(v8, v52, v10);
  CFTypeRef cf = v8;
  CFIndex v11 = CFStringGetLength(v8);
  int v41 = v10;
  uint64_t v7 = 0LL;
  if (v11 >= 1)
  {
    unsigned int v12 = 0;
    int v13 = 0;
    CFErrorRef v14 = v10;
    uint64_t v15 = &v10[v11];
    do
    {
      unsigned int v16 = *v14;
      int IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, *v14);
      if (v16 != 46 && IsCharacterMember == 0)
      {
        if (v16 - 48 > 9)
        {
          unint64_t v19 = (0x100002400uLL >> v16) & 1;
          if (v16 > 0x20) {
            LODWORD(v19) = 0;
          }
          goto LABEL_19;
        }

        v13 |= v16 - 48;
      }

      else
      {
        if (v12 > 7)
        {
          LODWORD(v19) = 0;
LABEL_19:
          while (v14 < v15)
          {
            unsigned int v20 = *v14;
            BOOL v21 = v20 > 0x20;
            uint64_t v22 = (1LL << v20) & 0x100002400LL;
            if (!v21 && v22 != 0) {
              break;
            }
            ++v14;
          }

          while (v14 < v15)
          {
            unsigned int v24 = *v14;
            BOOL v21 = v24 > 0x20;
            uint64_t v25 = (1LL << v24) & 0x100002400LL;
            if (v21 || v25 == 0) {
              break;
            }
            ++v14;
          }

          if ((_DWORD)v19)
          {
            v47[v12] = 0;
            CFBurstTrieAddCharacters((unint64_t)v4, (uint64_t)v47, v12, v13);
            int v13 = 0;
            unsigned int v12 = 0;
          }

          else
          {
            int v13 = 0;
            unsigned int v12 = 0;
            uint64_t v7 = (v7 + 1);
          }

          continue;
        }

        v47[v12++] = v16;
        v13 *= 8;
      }

      ++v14;
    }

    while (v14 < v15);
  }

  __CFHyphenationDestroyMMapType(v43);
  CFRelease(cf);
  free(v41);
  CFIndex v27 = __CFHyphenationMapFileContents(v49, &v45);
  if (v45)
  {
    fwrite("warning: failed to map exceptions file\n", 0x27uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  else
  {
    int v28 = v27;
    uint64_t v29 = CFStringCreateWithBytes(0LL, *(const UInt8 **)v27, *((void *)v27 + 1), 0x8000100u, 1u);
    CFIndex v30 = CFStringGetLength(v29);
    int v31 = (UniChar *)malloc(2 * v30);
    v53.CFIndex location = 0LL;
    v53.size_t length = v30;
    CFStringGetCharacters(v29, v53, v31);
    CFIndex v32 = CFStringGetLength(v29);
    if (v32 >= 1)
    {
      unsigned int v33 = 0;
      int v34 = -1;
      uint64_t v35 = v31;
      int v36 = &v31[v32];
      do
      {
        int v37 = *v35;
        if (v37 == 10 || v37 == 13)
        {
          v46[v33] = 0;
          CFBurstTrieAddCharacters((unint64_t)v4, (uint64_t)v46, v33, v34);
          unsigned int v33 = 0;
          int v34 = -1;
        }

        else if (v37 == 45)
        {
          if (v33) {
            v34 &= ~(1 << (v33 - 1));
          }
          else {
            unsigned int v33 = 0;
          }
        }

        else
        {
          if (v33 > 0x1B) {
            break;
          }
          v46[v33++] = v37;
        }

        ++v35;
      }

      while (v35 < v36);
    }

    __CFHyphenationDestroyMMapType(v28);
    CFRelease(v29);
    free(v31);
  }

  fprintf((FILE *)*MEMORY[0x1895F89D0], "writing trie to %s...\n", cStr);
  int v39 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
  CFBurstTrieSerialize((uint64_t)v4, v39, 6);
  CFRelease(v39);
  CFBurstTrieRelease(v4);
  return v7;
}

_DWORD *__CFHyphenationMapFileContents(const char *a1, int *a2)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  int v4 = malloc(0x18uLL);
  uint64_t v5 = v4;
  if (!v4)
  {
    int v8 = 1;
    goto LABEL_11;
  }

  v4[4] = -1;
  *(void *)int v4 = 0LL;
  *((void *)v4 + __postAndResetMidnight(1, 1) = 0LL;
  if (stat(a1, &v10) == -1)
  {
    int v8 = 2;
LABEL_10:
    __CFHyphenationDestroyMMapType(v5);
    uint64_t v5 = 0LL;
    goto LABEL_11;
  }

  *((void *)v5 + __postAndResetMidnight(1, 1) = v10.st_size;
  int v6 = open(a1, 0);
  _OWORD v5[4] = v6;
  if (v6 < 0)
  {
    int v8 = 3;
    goto LABEL_10;
  }

  uint64_t v7 = mmap(0LL, *((void *)v5 + 1), 1, 1, v6, 0LL);
  *(void *)uint64_t v5 = v7;
  if (v7 == (void *)-1LL)
  {
    int v8 = 4;
    goto LABEL_10;
  }

  int v8 = 0;
LABEL_11:
  *a2 = v8;
  return v5;
}

void __CFHyphenationDestroyMMapType(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)*a1;
    if (v2)
    {
      munmap(v2, a1[1]);
      *a1 = 0LL;
    }

    int v3 = *((_DWORD *)a1 + 4);
    if ((v3 & 0x80000000) == 0) {
      close(v3);
    }
    free(a1);
  }

Boolean CFStringIsHyphenationAvailableForLocale(CFLocaleRef locale)
{
  if (locale)
  {
    locale = (CFLocaleRef)__CFHyphenationCopyTrieInstance(locale);
    if (locale)
    {
      CFBurstTrieRelease(locale);
      LOBYTE(locale) = 1;
    }
  }

  return locale;
}

void *__CFHyphenationCopyTrieInstance(const __CFLocale *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  CFLocaleIdentifier Identifier = CFLocaleGetIdentifier(a1);
  os_unfair_lock_lock_with_options();
  int v3 = (const __CFDictionary *)__CFHyphenationCopyTrieInstance_gTries;
  if (!__CFHyphenationCopyTrieInstance_gTries)
  {
    *(_OWORD *)&v14.version = xmmword_1899ED3A8;
    *(_OWORD *)&v14.release = *(_OWORD *)&off_1899ED3B8;
    v14.equal = 0LL;
    int v3 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &v14);
    __CFHyphenationCopyTrieInstance_gTries = (uint64_t)v3;
  }

  Value = CFDictionaryGetValue(v3, Identifier);
  if (Value)
  {
    uint64_t v5 = Value;
    CFBurstTrieRetain((uint64_t)Value);
    goto LABEL_16;
  }

  int v6 = (const __CFString *)CFLocaleGetValue(a1, @"kCFLocaleLanguageCodeKey");
  CFTypeRef v7 = CFLocaleGetValue(a1, @"kCFLocaleCountryCodeKey");
  DictionaryPathForLanguageAndRegion = __CFHyphenationCreateDictionaryPathForLanguageAndRegion(v6, (unint64_t)v7);
  if (!DictionaryPathForLanguageAndRegion) {
    goto LABEL_15;
  }
  id v9 = DictionaryPathForLanguageAndRegion;
  uint64_t v5 = CFBurstTrieCreateFromFile(DictionaryPathForLanguageAndRegion);
  CFRelease(v9);
  if (v7) {
    BOOL v10 = v5 == 0LL;
  }
  else {
    BOOL v10 = 0;
  }
  if (!v10) {
    goto LABEL_13;
  }
  uint64_t v11 = __CFHyphenationCreateDictionaryPathForLanguageAndRegion(v6, 0LL);
  if (!v11)
  {
LABEL_15:
    uint64_t v5 = 0LL;
    goto LABEL_16;
  }

  unsigned int v12 = v11;
  uint64_t v5 = CFBurstTrieCreateFromFile(v11);
  CFRelease(v12);
LABEL_13:
  if (v5) {
    CFDictionaryAddValue((CFMutableDictionaryRef)__CFHyphenationCopyTrieInstance_gTries, Identifier, v5);
  }
LABEL_16:
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFHyphenationCopyTrieInstance_trieMutex);
  return v5;
}

CFIndex CFStringGetHyphenationLocationBeforeIndex( CFStringRef string, CFIndex location, CFRange limitRange, CFOptionFlags options, CFLocaleRef locale, UTF32Char *character)
{
  v16[1] = *MEMORY[0x1895F89C0];
  CFIndex result = -1LL;
  if (string)
  {
    if (locale)
    {
      CFIndex v9 = limitRange.location;
      if ((limitRange.location & 0x8000000000000000LL) == 0)
      {
        int length = limitRange.length;
        if (limitRange.length >= 1
          && limitRange.location <= location
          && limitRange.location + limitRange.length >= location)
        {
          if (limitRange.length <= CFStringGetLength(string))
          {
            uint64_t HyphenationLocations = _CFHyphenationGetHyphenationLocations( string,  location,  v9,  length,  options,  locale,  (uint64_t)v16,  1LL);
            if (v16[0] >= location || HyphenationLocations <= 0) {
              return -1LL;
            }
            else {
              return v16[0];
            }
          }

          else
          {
            return -1LL;
          }
        }
      }
    }
  }

  return result;
}

uint64_t __CFHyphenationGetHyphensForString( const __CFString *a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, CFIndex a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v40 = a4;
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (a3 > 200) {
    return -1LL;
  }
  CFIndex v13 = a3;
  uint64_t v16 = MEMORY[0x1895F8858](a1, a2);
  MEMORY[0x1895F8858](v16, v17);
  unint64_t v19 = __CFHyphenationCopyTrieInstance(v18);
  if (!v19) {
    return -1LL;
  }
  unsigned int v20 = v19;
  int v37 = &v35;
  uint64_t v38 = a8;
  uint64_t v35 = a5;
  uint64_t v36 = a9;
  memset(v34, 0, 406);
  v43.CFIndex location = a2;
  v43.int length = v13;
  CFStringGetCharacters(a1, v43, &v34[1]);
  v34[0] = 46;
  v34[v13 + 1] = 46;
  uint64_t v21 = v13 + 2;
  v34[v13 + 2] = 0;
  int v39 = &v33;
  __memset_chk();
  if ((v13 & 0x8000000000000000LL) == 0)
  {
    uint64_t v22 = (char *)v39 + 2;
    CFIndex v23 = v13;
    do
    {
      else {
        uint64_t v24 = 0LL;
      }
      if (v24 <= a6)
      {
        if (v40 && v21 <= v13 && *(_BYTE *)(v21 + v40 - 1)) {
          *((_BYTE *)v39 + v2__postAndResetMidnight(1, 1) = 9;
        }
        v34[v21] = 0;
        if (v24 < (unint64_t)v21)
        {
          do
          {
            unsigned int v41 = 0;
            if (v24 > a6) {
              break;
            }
            CFBurstTrieContainsCharacters((uint64_t)v20, (uint64_t)&v34[v24], v21 - v24, &v41);
            unsigned int v25 = v41;
            BOOL v26 = v41 + 0x10000000 < 0x10000001 || v21 < v24;
            if (!v26)
            {
              CFIndex v27 = v23;
              do
              {
                v25 >>= 3;
                uint64_t v28 = v27 + 2;
                --v27;
              }

              while (v28 > v24);
            }

            ++v24;
          }

          while (v24 != v21);
        }
      }

      --v23;
      BOOL v26 = v21-- <= 2;
    }

    while (!v26);
  }

  CFBurstTrieRelease(v20);
  uint64_t result = 0LL;
  uint64_t v29 = v36;
  uint64_t v30 = v35 - 2;
  uint64_t v31 = v38;
  CFIndex v32 = (char *)v39 - 1;
  while (v13 >= 4)
  {
    if ((v32[v13] & 1) != 0 && v13 - 1 <= a6) {
      *(void *)(v31 + 8 * result++) = v30 + v13;
    }
    --v13;
    if (result == v29) {
      return v29;
    }
  }

  return result;
}

CFTypeRef getTokenizersForLocale(void *key)
{
  cf[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  cf[0] = 0LL;
  CFMutableDictionaryRef Mutable = (const __CFDictionary *)gTokenizers;
  if (!gTokenizers)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    gTokenizers = (uint64_t)Mutable;
  }

  if (!CFDictionaryGetValueIfPresent(Mutable, key, cf))
  {
    CFMutableArrayRef v3 = CFArrayCreateMutable(0LL, 3LL, 0LL);
    cf[0] = v3;
    if (v3)
    {
      CFDictionarySetValue((CFMutableDictionaryRef)gTokenizers, key, v3);
      CFRelease(cf[0]);
    }
  }

  return cf[0];
}

uint64_t _CFBurstTrieRetainWrapper(uint64_t a1, uint64_t a2)
{
  return CFBurstTrieRetain(a2);
}

void _CFBurstTrieReleaseWrapper(int a1, void *a2)
{
}

CFStringRef __CFHyphenationCreateDictionaryPathForLanguageAndRegion( const __CFString *a1, unint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  int v4 = a2 | CFStringCompare(a1, @"en", 0LL) ? (__CFString *)a2 : @"US";
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 10LL, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  int v6 = Mutable;
  LinguisticDataPath = (const void *)_CFHyphenationGetLinguisticDataPath();
  CFArrayAppendValue(v6, LinguisticDataPath);
  CFArrayAppendValue(v6, a1);
  if (v4) {
    CFArrayAppendValue(v6, v4);
  }
  CFArrayAppendValue(v6, @"hyphenation.dat");
  CFStringRef v8 = CFStringCreateByCombiningStrings(0LL, v6, @"/");
  CFRelease(v6);
  return v8;
}

void sub_180BAE1FC(_Unwind_Exception *a1)
{
}

unint64_t _CFPropertyListMissingSemicolon( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFLog( 4LL,  (uint64_t)@"CFPropertyListCreateFromXMLData(): Old-style plist parser: missing semicolon in dictionary on line %d. Parsing will be abandoned. Break on _CFPropertyListMissingSemicolon to debug.",  a3,  a4,  a5,  a6,  a7,  a8,  a1);
}

unint64_t _CFPropertyListMissingSemicolonOrValue( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFLog( 4LL,  (uint64_t)@"CFPropertyListCreateFromXMLData(): Old-style plist parser: missing semicolon or value in dictionary on line %d. Parsing will be abandoned. Break on _CFPropertyListMissingSemicolonOrValue to debug.",  a3,  a4,  a5,  a6,  a7,  a8,  a1);
}

const void *__CFCreateOldStylePropertyListOrStringsFile( const __CFAllocator *a1, CFDataRef theData, CFTypeRef cf, CFStringEncoding a4, int a5, CFErrorRef *a6, void *a7)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  if (cf)
  {
    uint64_t v11 = (const __CFString *)CFRetain(cf);
  }

  else
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    uint64_t v11 = CFStringCreateWithBytesNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  BytePtr,  Length,  a4,  0,  (CFAllocatorRef)&__kCFAllocatorNull);
    if (!v11)
    {
      if (a6)
      {
        uint64_t v24 = 0LL;
        *a6 = __CFPropertyListCreateError(3840LL, @"Conversion of string failed.");
        return v24;
      }

      return 0LL;
    }
  }

  CFIndex v16 = CFStringGetLength(v11);
  if (!v16)
  {
    if (a6) {
      *a6 = __CFPropertyListCreateError(3840LL, @"Conversion of string failed. The string is empty.");
    }
    goto LABEL_19;
  }

  CFIndex v17 = v16;
  CharactersPtr = CFStringGetCharactersPtr(v11);
  unint64_t v19 = CharactersPtr;
  if (CharactersPtr)
  {
    uint64_t v33 = CharactersPtr;
    if (!__OFADD__(CharactersPtr, v17))
    {
      CFIndex v23 = (UniChar *)CharactersPtr;
      goto LABEL_22;
    }

    unsigned int v20 = (void *)&unk_18C539000;
    uint64_t v21 = "Unable to address entirety of CFPropertyList";
    goto LABEL_18;
  }

  uint64_t v22 = (UniChar *)CFAllocatorAllocate(a1, 2 * v17, 0LL);
  if (!v22)
  {
    unsigned int v20 = &unk_18C539000;
    uint64_t v21 = "CFPropertyList ran out of memory while attempting to allocate temporary storage.";
LABEL_18:
    v20[334] = v21;
LABEL_19:
    CFRelease(v11);
    return 0LL;
  }

  CFIndex v23 = v22;
  v41.CFIndex location = 0LL;
  v41.int length = v17;
  CFStringGetCharacters(v11, v41, v22);
  CFRelease(v11);
  uint64_t v33 = v23;
  if (__OFADD__(v23, v17))
  {
    qword_18C539A70 = (uint64_t)"Unable to address entirety of CFPropertyList";
LABEL_31:
    CFAllocatorDeallocate(a1, v23);
    return 0LL;
  }

  uint64_t v11 = 0LL;
LABEL_22:
  int v34 = v23;
  uint64_t v35 = (char *)&v23[v17];
  int v37 = a1;
  int v38 = a5;
  CFTypeRef Mutable = CFSetCreateMutable(a1, 0LL, &kCFTypeSetCallBacks);
  if (!Mutable)
  {
    qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
    if (!v19) {
      goto LABEL_31;
    }
    goto LABEL_19;
  }

  CFTypeRef cfa = 0LL;
  if (advanceToNonSpace((uint64_t)&v33))
  {
    BOOL v26 = parsePlistObject((uint64_t)&v33, 1, 0);
    if (!v26)
    {
LABEL_40:
      Error = (__CFError *)cfa;
      if (!a6)
      {
        if (cfa) {
          CFRelease(cfa);
        }
        uint64_t v24 = 0LL;
        if (!v19) {
          goto LABEL_36;
        }
        goto LABEL_45;
      }

      if (!cfa)
      {
        uint64_t v32 = lineNumberStrings((unint64_t *)&v33);
        Error = __CFPropertyListCreateError(3840LL, @"Unknown error parsing property list around line %d", v32);
      }

      uint64_t v24 = 0LL;
      *a6 = Error;
      goto LABEL_44;
    }

    uint64_t v24 = v26;
    CFTypeID v27 = CFGetTypeID(v24);
    CFTypeID TypeID = CFStringGetTypeID();
    CFRelease(v24);
    if (v27 != TypeID)
    {
      if (cfa) {
        CFRelease(cfa);
      }
      uint64_t v30 = lineNumberStrings((unint64_t *)&v33);
      CFTypeRef cfa = __CFPropertyListCreateError(3840LL, @"Junk after plist at line %d", v30);
      goto LABEL_40;
    }

    if (cfa)
    {
      CFRelease(cfa);
      CFTypeRef cfa = 0LL;
    }

    int v34 = v23;
    uint64_t v29 = parsePlistDictContent((uint64_t)&v33, 0);
  }

  else
  {
    uint64_t v29 = CFDictionaryCreateMutable(a1, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }

  uint64_t v24 = v29;
  if (!v29) {
    goto LABEL_40;
  }
LABEL_34:
  if (!a7)
  {
LABEL_44:
    if (!v19) {
      goto LABEL_36;
    }
    goto LABEL_45;
  }

  *a7 = 1LL;
  if (!v19)
  {
LABEL_36:
    CFAllocatorDeallocate(a1, v23);
    goto LABEL_46;
  }

uint64_t advanceToNonSpace(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  unint64_t v1 = *(void *)(a1 + 16);
  while (1)
  {
    CFMutableArrayRef v3 = v2 + 1;
    int v4 = *v2;
    BOOL v5 = (v4 - 9) >= 5 && (v4 - 8232) >= 2;
    if (!v5 || v4 == 32) {
      goto LABEL_6;
    }
    int v6 = *v3;
    if (v6 == 42)
    {
      CFMutableArrayRef v3 = v2 + 2;
      if ((unint64_t)(v2 + 2) < v1)
      {
        v2 += 2;
        while (1)
        {
          int v10 = *v2++;
          BOOL v11 = v10 != 42 || (unint64_t)v2 >= v1;
          if (!v11 && *v2 == 47) {
            break;
          }
          CFMutableArrayRef v3 = v2;
        }

        uint64_t v2 = v3 + 2;
        goto LABEL_7;
      }

__CFString *parsePlistObject(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  if (a3 >= 0x201)
  {
    uint64_t v34 = lineNumberStrings((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Too many nested arrays or dictionaries at line %d", v34);
    goto LABEL_3;
  }

  if (!advanceToNonSpace(a1))
  {
    if (a2)
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unexpected EOF while parsing plist");
      goto LABEL_3;
    }

    return 0LL;
  }

  BOOL v11 = *(unsigned __int16 **)(a1 + 8);
  int v13 = *v11;
  uint64_t v12 = *v11;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v11 + 1;
  if (v13 > 39)
  {
    if ((_DWORD)v12 == 40)
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0LL, &kCFTypeArrayCallBacks);
      if (!Mutable)
      {
        CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to allocate array string while parsing plist");
        goto LABEL_3;
      }

      int v7 = Mutable;
      uint64_t v16 = a3 + 1;
      uint64_t v17 = parsePlistObject(a1, 0LL, v16);
      if (v17)
      {
        uint64_t v18 = (const void *)v17;
        do
        {
          CFArrayAppendValue(v7, v18);
          CFRelease(v18);
          if (!advanceToNonSpace(a1))
          {
            CFRelease(v7);
            uint64_t v40 = lineNumberStrings((unint64_t *)a1);
            CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Expected ',' for array at line %d", v40);
            goto LABEL_3;
          }

          unint64_t v19 = *(_WORD **)(a1 + 8);
          if (*v19 != 44) {
            break;
          }
          *(void *)(a1 + _Block_object_dispose(va, 8) = v19 + 1;
          uint64_t v18 = (const void *)parsePlistObject(a1, 0LL, v16);
        }

        while (v18);
      }

      if (advanceToNonSpace(a1))
      {
        CFDictionaryValueCallBacks v14 = *(__int16 **)(a1 + 8);
        if (*v14 == 41)
        {
          unsigned int v20 = *(const void **)(a1 + 24);
          if (v20)
          {
            CFRelease(v20);
            *(void *)(a1 + 24) = 0LL;
            CFDictionaryValueCallBacks v14 = *(__int16 **)(a1 + 8);
          }

          goto LABEL_65;
        }
      }

      CFRelease(v7);
      uint64_t v37 = lineNumberStrings((unint64_t *)a1);
      CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Expected terminating '' for array at line %d"), v37);
LABEL_3:
      CFErrorRef v5 = Error;
      int v6 = *(const void **)(a1 + 24);
      if (v6) {
        CFRelease(v6);
      }
      int v7 = 0LL;
      *(void *)(a1 + 24) = v5;
      return (__CFString *)v7;
    }

    if ((_DWORD)v12 != 60)
    {
      if ((_DWORD)v12 == 123)
      {
        int v7 = parsePlistDictContent(a1, a3);
        if (!v7) {
          return (__CFString *)v7;
        }
        if (advanceToNonSpace(a1))
        {
          CFDictionaryValueCallBacks v14 = *(__int16 **)(a1 + 8);
          if (*v14 == 125) {
            goto LABEL_65;
          }
        }

        CFRelease(v7);
        uint64_t v35 = lineNumberStrings((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Expected terminating '}' for dictionary at line %d", v35);
        goto LABEL_3;
      }

      goto LABEL_66;
    }

    CFMutableDataRef v21 = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0LL);
    if (!v21)
    {
      uint64_t v36 = lineNumberStrings((unint64_t *)a1);
      CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Unable to allocate data while parsing property list at line %d",  v36);
      goto LABEL_3;
    }

    int v7 = v21;
    CFDictionaryValueCallBacks v14 = *(__int16 **)(a1 + 8);
    unint64_t v22 = *(void *)(a1 + 16);
LABEL_33:
    int v23 = 0;
    while (1)
    {
      unsigned int v24 = (unsigned __int16)*v14;
      if (v24 == 62)
      {
LABEL_58:
        if (v23 < 0)
        {
          CFRelease(v7);
          if (v23 == -2)
          {
LABEL_80:
            uint64_t v38 = lineNumberStrings((unint64_t *)a1);
            CFErrorRef v31 = __CFPropertyListCreateError(3840LL, @"Malformed data byte group at line %d; uneven length", v38);
          }

          else
          {
LABEL_90:
            uint64_t v41 = lineNumberStrings((unint64_t *)a1);
            CFErrorRef v31 = __CFPropertyListCreateError(3840LL, @"Malformed data byte group at line %d; invalid hex", v41);
          }

          CFErrorRef v32 = v31;
          uint64_t v33 = *(const void **)(a1 + 24);
          if (v33) {
            CFRelease(v33);
          }
          *(void *)(a1 + 24) = v32;
          return 0LL;
        }

        if (v23)
        {
          CFDataAppendBytes(v7, bytes, v23);
          CFDictionaryValueCallBacks v14 = *(__int16 **)(a1 + 8);
          unint64_t v22 = *(void *)(a1 + 16);
        }

uint64_t lineNumberStrings(unint64_t *a1)
{
  unint64_t v1 = (unsigned __int16 *)*a1;
  unint64_t v2 = a1[2];
  if (*a1 >= v2) {
    return 1LL;
  }
  unint64_t v3 = a1[1];
  uint64_t result = 1LL;
  do
  {
    int v5 = *v1;
    if (v5 == 10)
    {
      uint64_t result = (result + 1);
    }

    else if (v5 == 13)
    {
      uint64_t result = (result + 1);
    }

    ++v1;
  }

  while ((unint64_t)v1 < v2);
  return result;
}

__CFDictionary *parsePlistDictContent(uint64_t a1, int a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( *(CFAllocatorRef *)(a1 + 32),  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    uint64_t v14 = lineNumberStrings((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError( 3840LL,  @"Unable to allocate dictionary while parsing plist at line %d",  v14);
    uint64_t v16 = *(const void **)(a1 + 24);
    if (v16) {
      CFRelease(v16);
    }
    int v5 = 0LL;
    *(void *)(a1 + 24) = Error;
    return v5;
  }

  int v5 = Mutable;
  int v6 = parsePlistString(a1);
  if (!v6)
  {
LABEL_14:
    int v13 = *(const void **)(a1 + 24);
    if (v13)
    {
      CFRelease(v13);
      *(void *)(a1 + 24) = 0LL;
    }

    return v5;
  }

  int v7 = v6;
  uint64_t v8 = (a2 + 1);
  while (1)
  {
    if (!advanceToNonSpace(a1))
    {
      uint64_t v27 = lineNumberStrings((unint64_t *)a1);
      _CFPropertyListMissingSemicolonOrValue(v27, v28, v29, v30, v31, v32, v33, v34);
      CFErrorRef v35 = __CFPropertyListCreateError(3840LL, @"Missing ';' on line %d", v27);
      goto LABEL_24;
    }

    CFIndex v9 = *(unsigned __int16 **)(a1 + 8);
    int v10 = *v9;
    if (v10 != 61)
    {
      if (v10 == 59)
      {
        CFTypeRef v11 = CFRetain(v7);
        goto LABEL_9;
      }

      uint64_t v39 = lineNumberStrings((unint64_t *)a1);
      CFErrorRef v35 = __CFPropertyListCreateError(3840LL, @"Expected ';' or '=' after key at line %d", v39);
LABEL_24:
      CFErrorRef v36 = v35;
      uint64_t v37 = *(const void **)(a1 + 24);
      if (v37) {
        CFRelease(v37);
      }
      *(void *)(a1 + 24) = v36;
LABEL_27:
      CFRelease(v7);
      goto LABEL_28;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v9 + 1;
    CFTypeRef v11 = (CFTypeRef)parsePlistObject(a1, 1LL, v8);
    if (!v11) {
      goto LABEL_27;
    }
LABEL_9:
    CFDictionarySetValue(v5, v7, v11);
    CFRelease(v7);
    if (v11) {
      CFRelease(v11);
    }
    uint64_t v12 = *(_WORD **)(a1 + 8);
    if (*v12 != 59) {
      break;
    }
    *(void *)(a1 + _Block_object_dispose(va, 8) = v12 + 1;
    int v7 = parsePlistString(a1);
    if (!v7) {
      goto LABEL_14;
    }
  }

  uint64_t v17 = lineNumberStrings((unint64_t *)a1);
  _CFPropertyListMissingSemicolon(v17, v18, v19, v20, v21, v22, v23, v24);
  CFErrorRef v25 = __CFPropertyListCreateError(3840LL, @"Missing ';' on line %d", v17);
  __int16 v26 = *(const void **)(a1 + 24);
  if (v26) {
    CFRelease(v26);
  }
  *(void *)(a1 + 24) = v25;
LABEL_28:
  CFRelease(v5);
  return 0LL;
}

__CFString *parseQuotedPlistString(uint64_t a1, int a2)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16);
  if (v4 >= v3)
  {
LABEL_65:
    *(void *)(a1 + _Block_object_dispose(va, 8) = v4;
    uint64_t v34 = lineNumberStrings((unint64_t *)a1);
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unterminated quoted string starting on line %d", v34);
    goto LABEL_66;
  }

  int v6 = 0LL;
  uint64_t v7 = MEMORY[0x1895F8770];
  uint64_t v8 = *(UniChar **)(a1 + 8);
  CFIndex v9 = v8;
  do
  {
    UniChar chars = *v8;
    if (chars == 92)
    {
      if (!v6)
      {
        CFMutableStringRef Mutable = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0LL);
        if (!Mutable)
        {
          CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to allocate quoted string while parsing plist");
          goto LABEL_66;
        }

        int v6 = Mutable;
        uint64_t v8 = *(UniChar **)(a1 + 8);
      }

      CFStringAppendCharacters(v6, v9, v8 - v9);
      uint64_t v12 = *(void *)(a1 + 8);
      unint64_t v11 = *(void *)(a1 + 16);
      *(void *)(a1 + _Block_object_dispose(va, 8) = v12 + 2;
      if (v12 + 2 == v11)
      {
        CFRelease(v6);
        uint64_t v35 = lineNumberStrings((unint64_t *)a1);
        CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unterminated backslash sequence on line %d", v35);
        goto LABEL_66;
      }

      int v13 = *(unsigned __int16 *)(v12 + 2);
      uint64_t v14 = (_WORD *)(v12 + 4);
      *(void *)(a1 + _Block_object_dispose(va, 8) = v14;
      if (v13 > 84)
      {
        if (v13 > 101)
        {
          switch(v13)
          {
            case 'n':
              LOWORD(v13) = 10;
              break;
            case 'o':
            case 'p':
            case 'q':
            case 's':
            case 'u':
              break;
            case 'r':
              LOWORD(v13) = 13;
              break;
            case 't':
              LOWORD(v13) = 9;
              break;
            case 'v':
              LOWORD(v13) = 11;
              break;
            default:
              if (v13 == 102) {
                LOWORD(v13) = 12;
              }
              break;
          }
        }

        else
        {
          switch(v13)
          {
            case 'U':
              if ((unint64_t)v14 >= v11)
              {
                LOWORD(v13) = 0;
              }

              else
              {
                LOWORD(v13) = 0;
                int v19 = -5;
                do
                {
                  if (__CFADD__(v19++, 1)) {
                    break;
                  }
                  uint64_t v21 = (unsigned __int16)*v14;
                  if (v21 <= 0x7F && (*(_DWORD *)(v7 + 4 * v21 + 60) & 0x10000) != 0)
                  {
                    *(void *)(a1 + _Block_object_dispose(va, 8) = ++v14;
                    else {
                      __int16 v22 = -55;
                    }
                    LOWORD(v13) = v21 + 16 * v13 + v22;
                  }
                }

                while ((unint64_t)v14 < v11);
              }

              break;
            case 'a':
              LOWORD(v13) = 7;
              break;
            case 'b':
              LOWORD(v13) = 8;
              break;
          }
        }
      }

      else
      {
        char v15 = v13 - 48;
        if ((v13 - 48) < 8)
        {
          LOBYTE(v++*(_WORD *)(cf + 16) = 0;
          do
          {
            if ((*v14 & 0xFFF8) != 0x30) {
              break;
            }
            char v15 = *v14++ + 8 * v15 - 48;
            *(void *)(a1 + _Block_object_dispose(va, 8) = v14;
            unsigned int v16 = (v16 + 1);
          }

          while (v16 < 2);
          char v39 = v15;
          if (CFStringEncodingBytesToUnicode( 2817LL,  0LL,  (unint64_t)&v39,  1LL,  0LL,  (uint64_t)&v38,  1LL,  &v37))
          {
            CFErrorRef v17 = __CFPropertyListCreateError(3840LL, @"Unable to convert octet-stream while parsing plist");
            uint64_t v18 = *(const void **)(a1 + 24);
            if (v18) {
              CFRelease(v18);
            }
            LOWORD(v13) = 0;
            *(void *)(a1 + 24) = v17;
          }

          else if (v37 == 1)
          {
            LOWORD(v13) = v38;
          }

          else
          {
            LOWORD(v13) = 0;
          }
        }
      }

      UniChar chars = v13;
      CFStringAppendCharacters(v6, &chars, 1LL);
      uint64_t v8 = *(UniChar **)(a1 + 8);
      unint64_t v3 = *(void *)(a1 + 16);
      CFIndex v9 = v8;
    }

    else
    {
      *(void *)(a1 + _Block_object_dispose(va, 8) = ++v8;
    }
  }

  while ((unint64_t)v8 < v3);
  if (v3 <= (unint64_t)v8)
  {
    if (v6) {
      CFRelease(v6);
    }
    goto LABEL_65;
  }

  if (v6)
  {
    if (v9 != v8) {
      CFStringAppendCharacters(v6, v9, v8 - v9);
    }
    if (*(_DWORD *)(a1 + 40) == 2) {
      goto LABEL_76;
    }
    Value = (__CFString *)CFSetGetValue(*(CFSetRef *)(a1 + 48), v6);
    if (!Value)
    {
      CFStringRef v24 = __CFStringCollectionCopy(*(const __CFAllocator **)(a1 + 32), v6);
      if (!v24)
      {
        CFErrorRef v32 = __CFPropertyListCreateError(3840LL, @"Unable to copy string while parsing plist");
        uint64_t v33 = *(const void **)(a1 + 24);
        if (v33) {
          CFRelease(v33);
        }
        Value = 0LL;
        *(void *)(a1 + 24) = v32;
        goto LABEL_62;
      }

      Value = (__CFString *)v24;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v24);
      __CFTypeCollectionRelease(*(void *)(a1 + 32), Value);
    }

    CFRetain(Value);
LABEL_62:
    CFRelease(v6);
    int v6 = Value;
    goto LABEL_76;
  }

  if (*(_DWORD *)(a1 + 40) != 2)
  {
    int v6 = (__CFString *)_uniqueStringForCharacters(a1, v9, v8 - v9);
LABEL_76:
    *(void *)(a1 + 8) += 2LL;
    uint64_t v31 = *(const void **)(a1 + 24);
    if (v31)
    {
      CFRelease(v31);
      *(void *)(a1 + 24) = 0LL;
    }

    return v6;
  }

  uint64_t v29 = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0LL);
  if (v29)
  {
    int v6 = v29;
    uint64_t v30 = *(const UniChar **)(a1 + 8);
    if (v9 != v30) {
      CFStringAppendCharacters(v29, v9, v30 - v9);
    }
    goto LABEL_76;
  }

  CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to allocate mutable string while parsing plist");
LABEL_66:
  CFErrorRef v26 = Error;
  uint64_t v27 = *(const void **)(a1 + 24);
  if (v27) {
    CFRelease(v27);
  }
  int v6 = 0LL;
  *(void *)(a1 + 24) = v26;
  return v6;
}

__CFString *parseUnquotedPlistString(uint64_t a1)
{
  unint64_t v3 = *(const UniChar **)(a1 + 8);
  unint64_t v2 = *(void *)(a1 + 16);
  unint64_t v4 = *(const UniChar **)(a1 + 8);
  do
  {
    if ((unsigned __int16)(*v4 - 48) >= 0xAu && (unsigned __int16)((*v4 & 0xFFDF) - 65) >= 0x1Au)
    {
      unsigned int v6 = *v4 - 36;
      BOOL v7 = v6 > 0x3B;
      uint64_t v8 = (1LL << v6) & 0x800000000400E01LL;
      if (v7 || v8 == 0) {
        break;
      }
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = ++v4;
  }

  while ((unint64_t)v4 < v2);
  if (v4 == v3)
  {
LABEL_17:
    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unexpected EOF");
    goto LABEL_18;
  }

  if (*(_DWORD *)(a1 + 40) == 2)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0LL);
    if (Mutable)
    {
      unint64_t v11 = Mutable;
      CFStringAppendCharacters(Mutable, v3, (uint64_t)(*(void *)(a1 + 8) - (void)v3) >> 1);
      return v11;
    }

    CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to allocate unquoted string while parsing plist");
LABEL_18:
    CFErrorRef v13 = Error;
    uint64_t v14 = *(const void **)(a1 + 24);
    if (v14) {
      CFRelease(v14);
    }
    unint64_t v11 = 0LL;
    *(void *)(a1 + 24) = v13;
    return v11;
  }

  return (__CFString *)_uniqueStringForCharacters(a1, v3, v4 - v3);
}

CFTypeRef _uniqueStringForCharacters(uint64_t a1, const UniChar *a2, CFIndex a3)
{
  v18[1] = *MEMORY[0x1895F89C0];
  if (!a3) {
    return CFRetain(&stru_1899EF170);
  }
  MEMORY[0x1895F8858](a1, a2);
  BOOL v7 = (char *)v18 - v6;
  if (v8 >= 2048)
  {
    CFIndex v9 = (char *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3 + 1, 0LL);
    if (!v9)
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to allocate string while parsing plist");
      goto LABEL_20;
    }

    goto LABEL_7;
  }

  CFIndex v9 = (char *)v18 - v6;
  if (a3 >= 1)
  {
LABEL_7:
    uint64_t v11 = 0LL;
    while (1)
    {
      unsigned int v12 = a2[v11];
      if (v12 >= 0x80) {
        break;
      }
      v9[v11++] = v12;
      if (a3 == v11) {
        goto LABEL_10;
      }
    }

    CFStringRef v13 = CFStringCreateWithCharacters(*(CFAllocatorRef *)(a1 + 32), a2, a3);
    if (!v13)
    {
      CFErrorRef Error = __CFPropertyListCreateError(3840LL, @"Unable to allocate pre-unique string while parsing plist");
      goto LABEL_20;
    }

__CFString *parsePlistString(uint64_t a1)
{
  unint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  int v3 = *v2;
  if (v3 == 39 || v3 == 34)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = v2 + 1;
    return parseQuotedPlistString(a1, v3);
  }

  BOOL v5 = (v3 - 48) >= 0xA && (unsigned __int16)((v3 & 0xFFDF) - 65) >= 0x1Au;
  if (v5
    && ((v3 - 36) <= 0x3B
      ? (BOOL v6 = ((1LL << (v3 - 36)) & 0x800000000400E01LL) == 0)
      : (BOOL v6 = 1),
        v6))
  {
    return 0LL;
  }

  else
  {
    return parseUnquotedPlistString(a1);
  }

void sub_180BAFBE0(_Unwind_Exception *a1)
{
}

void sub_180BB0280(_Unwind_Exception *a1)
{
}

void sub_180BB1BC0(_Unwind_Exception *a1, int a2)
{
  *(void *)(v4 - 224) = v3;
  free(*(void **)(v4 - 224));
  if (a2 == 1)
  {
    id v7 = objc_begin_catch(a1);

    objc_exception_throw(v7);
    __break(1u);
    JUMPOUT(0x180BB1CC0LL);
  }

  cleanup_sentinel_pair(v4 - 144);
  cleanup_sentinel_pair(v4 - 120);
  _Unwind_Resume(a1);
}

CFErrorRef __archiveIsCorrupt(uint64_t a1)
{
  v3[1] = *MEMORY[0x1895F89C0];
  unint64_t v2 = @"NSLocalizedDescription";
  v3[0] = a1;
  return  CFErrorCreate( 0LL,  @"NSCocoaErrorDomain",  4864LL,  (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v3,  &v2,  1LL));
}

void cleanup_sentinel_pair(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  unint64_t v2 = (void *)(a1 + 8);
  if (*(void *)(a1 + 8)) {
    BOOL v3 = v1 == 0LL;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    objc_msgSend(*(id *)a1, "replaceObject:withObject:", v1);
  }

  void *v2 = 0LL;
  v2[1] = 0LL;
}

void sub_180BB20F4(_Unwind_Exception *exception_object)
{
}

void sub_180BB2C60(_Unwind_Exception *a1)
{
}

uint64_t compareHashesAscending(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void sub_180BB34B4(void *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    objc_begin_catch(a1);
    if (!v2) {
      JUMPOUT(0x180BB31F0LL);
    }
    JUMPOUT(0x180BB31DCLL);
  }

  JUMPOUT(0x180BB349CLL);
}

CFErrorRef sub_180BB34D8(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x180BB349CLL);
  }
  objc_terminate();
  return __archiveIsCorrupt_0(v2);
}

CFErrorRef __archiveIsCorrupt_0(uint64_t a1)
{
  v3[1] = *MEMORY[0x1895F89C0];
  uint64_t v2 = @"NSLocalizedDescription";
  v3[0] = a1;
  return  CFErrorCreate( 0LL,  @"NSCocoaErrorDomain",  4864LL,  (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v3,  &v2,  1LL));
}

uint64_t _CFPrefsSynchronizeDirtySourceForDaemonTermination(void *a1)
{
  v2[5] = *MEMORY[0x1895F89C0];
  v2[0] = MEMORY[0x1895F87A8];
  v2[1] = 3221225472LL;
  size_t v2[2] = ___CFPrefsSynchronizeDirtySourceForDaemonTermination_block_invoke;
  _OWORD v2[3] = &unk_18999B4C8;
  v2[4] = a1;
  return [a1 lockedSync:v2];
}

void _CFPrefsSynchronizeDirtySourceForTimer(void *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 0LL;
  BOOL v6 = &v5;
  uint64_t v7 = 0x3052000000LL;
  uint64_t v8 = __Block_byref_object_copy__319;
  CFIndex v9 = __Block_byref_object_dispose__320;
  uint64_t v10 = 0LL;
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = ___CFPrefsSynchronizeDirtySourceForTimer_block_invoke;
  v4[3] = &unk_1899ED998;
  v4[4] = a1;
  v4[5] = &v5;
  [a1 lockedSync:v4];
  uint64_t v2 = v6[5];
  if (v2)
  {
    unint64_t v3 = (const void *)(*(uint64_t (**)(void))(v2 + 16))();
    [a1 finishedNonRequestWriteWithResult:v3];
    if (v3) {
      CFRelease(v3);
    }
  }

  _Block_object_dispose(&v5, 8);
}

void sub_180BB4EE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void _CFPrefsSynchronizeForDaemonTermination()
{
  CFNumberRef v0 = (const __CFSet *)+[_CFPrefsSynchronizer sharedInstance]();
  -[_CFPrefsSynchronizer synchronizeForDaemonTermination](v0);
}

CFStringRef _internString(const __CFString *a1)
{
  if (!a1) {
    return 0LL;
  }
  Value = @"kCFPreferencesAnyApplication";
  if (!CFEqual(a1, @"kCFPreferencesAnyApplication"))
  {
    if (((unint64_t)a1 & 0x8000000000000000LL) != 0 || CFGetRetainCount(a1) == 0xFFFFFFFFFFFFFFFLL)
    {
      return a1;
    }

    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)&_internString_lock);
      CFMutableStringRef Mutable = (const __CFSet *)_internString_table;
      if (!_internString_table)
      {
        CFMutableStringRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeSetCallBacks);
        _internString_table = (uint64_t)Mutable;
      }

      Value = (const __CFString *)CFSetGetValue(Mutable, a1);
      if (!Value)
      {
        CFSetAddValue((CFMutableSetRef)_internString_table, a1);
        Value = a1;
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&_internString_lock);
      CFRetain(Value);
    }
  }

  return Value;
}

void sub_180BB5228( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BB55EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36)
{
}

void sub_180BB5E98(_Unwind_Exception *a1)
{
}

void __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

CFStringRef _CFPrefsDCopyCurrentUserName()
{
  uid_t v0 = cfprefsdEuid();
  return _CFPrefsCopyUserNameForUID(v0);
}

CFStringRef _CFPrefsCopyUserNameForUID(uid_t a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  int v2 = cfprefsdEuid();
  if (v2 != a1)
  {
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = ___CFPrefsCopyUserNameForUID_block_invoke_2;
    _OWORD v7[3] = &__block_descriptor_36_e5_v8__0l;
    int v8 = v2;
    if (_CFPrefsCopyUserNameForUID_onceToken_83 != -1) {
      dispatch_once(&_CFPrefsCopyUserNameForUID_onceToken_83, v7);
    }
    if (_CFPrefsCopyUserNameForUID_otherCommonUID == a1)
    {
      unint64_t v3 = (const void *)_CFPrefsCopyUserNameForUID_otherCommonUIDName;
      if (_CFPrefsCopyUserNameForUID_otherCommonUIDName) {
        return (const __CFString *)CFRetain(v3);
      }
      return 0LL;
    }

    os_unfair_lock_lock((os_unfair_lock_t)&_CFPrefsCopyUserNameForUID___cacheLock);
    if (_CFPrefsCopyUserNameForUID___cacheKey == a1 && _CFPrefsCopyUserNameForUID___hasCache == 1)
    {
      uint64_t v5 = (const __CFString *)_CFPrefsCopyUserNameForUID___cachedResult;
    }

    else
    {
      BOOL v6 = _calculateUserNameForUID(a1);
      uint64_t v5 = v6;
      if (!v6)
      {
LABEL_17:
        os_unfair_lock_unlock((os_unfair_lock_t)&_CFPrefsCopyUserNameForUID___cacheLock);
        return v5;
      }

      _CFPrefsCopyUserNameForUID___cacheKey = a1;
      _CFPrefsCopyUserNameForUID___hasCache = 1;
      _CFPrefsCopyUserNameForUID___cachedResult = (uint64_t)v6;
    }

    CFRetain(v5);
    goto LABEL_17;
  }

  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___CFPrefsCopyUserNameForUID_block_invoke;
  block[3] = &__block_descriptor_36_e5_v8__0l;
  uid_t v10 = a1;
  if (_CFPrefsCopyUserNameForUID_onceToken != -1) {
    dispatch_once(&_CFPrefsCopyUserNameForUID_onceToken, block);
  }
  unint64_t v3 = (const void *)_CFPrefsCopyUserNameForUID_ourUIDName;
  if (_CFPrefsCopyUserNameForUID_ourUIDName) {
    return (const __CFString *)CFRetain(v3);
  }
  return 0LL;
}

uint64_t cfprefsdEuid()
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) == 0) {
    return geteuid();
  }
  if (cfprefsdEuid_onceToken != -1) {
    dispatch_once(&cfprefsdEuid_onceToken, &__block_literal_global_40);
  }
  return cfprefsdEuid_euid;
}

BOOL _CFPrefsEqualKeyOrSource(void *a1, void *a2)
{
  if (a1 == a2) {
    return 1LL;
  }
  unint64_t v3 = a1;
  Class Class = (__objc2_class *)object_getClass(a1);
  uint64_t v5 = (__objc2_class *)object_getClass(a2);
  if (Class != &OBJC_CLASS___CFPDSourceLookUpKey && v5 != &OBJC_CLASS___CFPDSourceLookUpKey) {
    return 0LL;
  }
  BOOL v6 = Class == &OBJC_CLASS___CFPDSourceLookUpKey;
  if (Class == &OBJC_CLASS___CFPDSourceLookUpKey) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = Class;
  }
  if (Class == &OBJC_CLASS___CFPDSourceLookUpKey) {
    int v8 = a2;
  }
  else {
    int v8 = v3;
  }
  if (!v6) {
    unint64_t v3 = a2;
  }
  if (v7 == &OBJC_CLASS___CFPDSourceLookUpKey)
  {
    uint64_t v11 = (const void *)v3[1];
    unsigned int v12 = (const void *)v8[1];
    if (v11 != v12)
    {
      BOOL v13 = !v11 || v12 == 0LL;
      if (v13 || !CFEqual(v11, v12)) {
        return 0LL;
      }
    }

    uint64_t v14 = (const void *)v3[2];
    char v15 = (const void *)v8[2];
    if (v14 != v15)
    {
      if (v14) {
        BOOL v16 = v15 == 0LL;
      }
      else {
        BOOL v16 = 1;
      }
      if (v16) {
        return 0LL;
      }
      return CFEqual(v14, v15) != 0;
    }

    return 1LL;
  }

  CFIndex v9 = (const void *)v3[2];
  if (v9)
  {
    if (v7 != &OBJC_CLASS___CFPDCloudSource) {
      return 0LL;
    }
    uid_t v10 = (const void *)v8[20];
    if (v9 != v10 && (!v10 || !CFEqual(v9, v10))) {
      return 0LL;
    }
  }

  else if (v7 == &OBJC_CLASS___CFPDCloudSource)
  {
    return 0LL;
  }

  uint64_t v18 = (const void *)[v8 copyUncanonicalizedPath];
  int v19 = (const void *)v3[1];
  if (v19 == v18 || v18 == 0LL || v19 == 0LL)
  {
    BOOL v17 = v19 == v18;
    if (!v18) {
      return v17;
    }
  }

  else
  {
    BOOL v17 = CFEqual(v19, v18) != 0;
  }

  CFRelease(v18);
  return v17;
}

uint64_t _CFPrefsHashKeyOrSource(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  Class Class = (__objc2_class *)object_getClass((id)a1);
  CFStringRef v22 = 0LL;
  CFStringRef v23 = 0LL;
  CFStringRef v24 = 0LL;
  if (Class == &OBJC_CLASS___CFPDSourceLookUpKey)
  {
    BOOL v4 = *(const __CFString **)(a1 + 8);
    if (v4)
    {
      CFIndex Length = CFStringGetLength(v4);
      CFIndex v6 = Length;
      if (Length >= 80) {
        CFIndex v7 = 80LL;
      }
      else {
        CFIndex v7 = Length;
      }
      v26.CFIndex location = 0LL;
      v26.int length = v7;
      CFStringRef v22 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(a1 + 8), v26);
      v27.CFIndex location = v6 - v7;
      v27.int length = v7;
      CFStringRef v8 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(a1 + 8), v27);
    }

    else
    {
      CFStringRef v8 = &stru_1899EF170;
      CFStringRef v22 = &stru_1899EF170;
    }

    CFStringRef v23 = v8;
    uid_t v10 = *(const void **)(a1 + 16);
    if (v10) {
      uint64_t v11 = (const __CFString *)CFRetain(v10);
    }
    else {
      uint64_t v11 = &stru_1899EF170;
    }
    CFStringRef v24 = v11;
  }

  else
  {
    if (Class == &OBJC_CLASS___CFPDCloudSource)
    {
      CFIndex v9 = *(const void **)(a1 + 160);
      if (v9) {
        unint64_t v3 = (const __CFString *)CFRetain(v9);
      }
      else {
        unint64_t v3 = &stru_1899EF170;
      }
    }

    else
    {
      unint64_t v3 = 0LL;
    }

    unsigned int v12 = (const __CFString *)[(id)a1 copyUncanonicalizedPath];
    if (v12)
    {
      BOOL v13 = v12;
      CFIndex v14 = CFStringGetLength(v12);
      CFIndex v15 = v14;
      if (v14 >= 80) {
        CFIndex v16 = 80LL;
      }
      else {
        CFIndex v16 = v14;
      }
      v28.CFIndex location = 0LL;
      v28.int length = v16;
      CFStringRef v22 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v28);
      v29.CFIndex location = v15 - v16;
      v29.int length = v16;
      CFStringRef v23 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v29);
      CFRelease(v13);
    }

    else
    {
      CFStringRef v22 = &stru_1899EF170;
      CFStringRef v23 = &stru_1899EF170;
    }

    if (v3) {
      BOOL v17 = v3;
    }
    else {
      BOOL v17 = &stru_1899EF170;
    }
    CFStringRef v24 = v17;
  }

  uint64_t v18 = 0LL;
  memset(v21, 0, sizeof(v21));
  do
  {
    int v19 = *(CFStringRef *)((char *)&v22 + v18 * 8);
    v21[v18] = CFHash(v19);
    if (v19) {
      CFRelease(v19);
    }
    ++v18;
  }

  while (v18 != 3);
  return CFHashBytes((uint64_t)v21, 24LL);
}

void sub_180BB72EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, id location)
{
}

uint64_t __cfprefsdEuid_block_invoke()
{
  uint64_t result = geteuid();
  cfprefsdEuid_euid = result;
  return result;
}

void _CFPrefsApplyChangesQueueToDictionary(void *a1, __CFDictionary *a2)
{
  if (!a1) {
    _CFPrefsApplyChangesQueueToDictionary_cold_1();
  }
  if (object_getClass(a1) != (Class)MEMORY[0x1895F9220]) {
    _CFPrefsApplyChangesQueueToDictionary_cold_4();
  }
  size_t count = xpc_array_get_count(a1);
  size_t v5 = count;
  if ((count & 1) != 0) {
    _CFPrefsApplyChangesQueueToDictionary_cold_3();
  }
  if (count)
  {
    char v6 = 0;
    size_t v7 = 0LL;
    CFStringRef v8 = (objc_class *)MEMORY[0x1895F9240];
    while (1)
    {
      BOOL value = (const __CFArray *)xpc_array_get_value(a1, v7);
      CFDataRef v10 = _CFXPCCreateCFObjectFromXPCObject(value);
      size_t v11 = v7 + 1;
      xpc_object_t v12 = xpc_array_get_value(a1, v11);
      if (object_getClass(v12) == v8)
      {
        size_t length = xpc_data_get_length(v12);
        bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v12);
        CFIndex v16 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  bytes_ptr,  length,  (CFAllocatorRef)&__kCFAllocatorNull);
        BOOL v13 = CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, 0LL, 0LL, 0LL);
        CFRelease(v16);
        if (!v10) {
          goto LABEL_13;
        }
      }

      else
      {
        BOOL v13 = _CFXPCCreateCFObjectFromXPCObject((const __CFArray *)v12);
        if (!v10) {
          goto LABEL_13;
        }
      }

      if (v13)
      {
        CFTypeID v17 = CFGetTypeID(v13);
        if (v17 == CFNullGetTypeID()) {
          CFDictionaryRemoveValue(a2, v10);
        }
        else {
          CFDictionarySetValue(a2, v10, v13);
        }
LABEL_19:
        CFRelease(v10);
        if (!v13) {
          goto LABEL_16;
        }
LABEL_15:
        CFRelease(v13);
        goto LABEL_16;
      }

void notifyFunc(_xpc_connection_s *a1, uint64_t *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  int v2 = (_xpc_connection_s *)a2[2];
  if (v2 != a1)
  {
    uint64_t v14 = 0LL;
    CFIndex v15 = &v14;
    uint64_t v16 = 0x2020000000LL;
    uint64_t v5 = MEMORY[0x1895F87A8];
    char v17 = 0;
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    _BYTE v13[2] = __notifyFunc_block_invoke;
    v13[3] = &unk_1899EDA68;
    v13[4] = &v14;
    BOOL v6 = withClientContext(a1, (uint64_t)v13);
    if (*((_BYTE *)v15 + 24)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = v6;
    }
    if (v7)
    {
      CFStringRef v8 = a1;
      CFIndex v9 = v2;
      xpc_object_t v10 = xpc_copy((xpc_object_t)a2[1]);
      uint64_t v11 = *a2;
      if (_CFPrefsObservationConnectionQueue_onceToken != -1) {
        dispatch_once(&_CFPrefsObservationConnectionQueue_onceToken, &__block_literal_global_342);
      }
      v12[0] = v5;
      v12[1] = 3221225472LL;
      _OWORD v12[2] = __notifyFunc_block_invoke_2;
      v12[3] = &unk_1899EDAB8;
      void v12[4] = a1;
      v12[5] = v11;
      v12[6] = v10;
      v12[7] = v2;
      xpc_connection_send_message_with_reply( a1,  v10,  (dispatch_queue_t)_CFPrefsObservationConnectionQueue_observationQueue,  v12);
    }

    _Block_object_dispose(&v14, 8);
  }

void sub_180BB8FE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

uint64_t _CFPrefsMessageSenderIsSandboxed(void *a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    BOOL value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    if (!value
      || (remote_connection = value,
          BOOL value = (_xpc_connection_s *)object_getClass(value),
          value != (_xpc_connection_s *)MEMORY[0x1895F9238]))
    {
      _CFPrefsMessageSenderIsSandboxed_cold_1((uint64_t)value, v4, v5);
    }
  }

  uint64_t v9 = 0LL;
  xpc_object_t v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  char v12 = 1;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  uint64_t v8[2] = ___CFPrefsMessageSenderIsSandboxed_block_invoke;
  uint64_t v8[3] = &unk_1899EDB00;
  v8[4] = a1;
  v8[5] = &v9;
  withClientContext(remote_connection, (uint64_t)v8);
  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_180BBA3A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

CFStringRef _calculateUserNameForUID(uid_t a1)
{
  int v2 = 0;
  while (1)
  {
    *__error() = 0;
    unint64_t v3 = getpwuid(a1);
    if (*__error() != 4) {
      break;
    }
LABEL_6:
    if (v3) {
      goto LABEL_10;
    }
  }

  if (!*__error()) {
    goto LABEL_9;
  }
  if (v2 < 3)
  {
    ++v2;
    goto LABEL_6;
  }

  uint64_t v4 = (os_log_s *)_CFPrefsDaemonLog();
  if (!os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
  {
LABEL_9:
    if (!v3) {
      return 0LL;
    }
    goto LABEL_10;
  }

  _calculateUserNameForUID_cold_1(a1, v4);
  if (!v3) {
    return 0LL;
  }
LABEL_10:
  if (v3->pw_name)
  {
    uint64_t v5 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3->pw_name, 0x8000100u);
    uint64_t v6 = _internString(v5);
    CFRelease(v5);
    return v6;
  }

  return 0LL;
}

LABEL_117:
      xpc_dictionary_set_int64(reply, "CFPreferencesShmemIndex", self->_generationShmemIndex);
      bzero(&v81, 0x400uLL);
      -[CFPrefsDaemon getShmemName:bufLen:]((uint64_t)self->_cfprefsd, (char *)&v81);
      xpc_dictionary_set_string(reply, "CFPreferencesShmemName", (const char *)&v81);
      xpc_dictionary_set_uint64(reply, "CFPreferencesShmemState", v57);
      if (v18 == 1) {
        goto LABEL_128;
      }
      if (v18 == 4)
      {
        CFIndex v58 = (os_log_s *)_CFPrefsDaemonLog();
        if (!os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_128;
        }
        int v76 = MEMORY[0x1895F87A8];
        int v77 = 3221225472LL;
        unsigned int v78 = __DEBUG_NEEDS_TOKEN_block_invoke;
        CFIndex v79 = &__block_descriptor_33_e29_v64__0i8_12_20_28_36_44_52B60l;
        LOBYTE(v80) = v8;
        goto LABEL_126;
      }

      string = xpc_dictionary_get_string(reply, "CFPreferencesErrorDescription");
      if (!v8)
      {
        int v76 = MEMORY[0x1895F87A8];
        int v77 = 3221225472LL;
        unsigned int v78 = __ERROR_READ_REJECTED_block_invoke;
        CFIndex v79 = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
        uint64_t v80 = string;
LABEL_126:
        unint64_t v62 = a3;
        uint64_t v61 = 0LL;
        goto LABEL_127;
      }

      uint64_t v60 = &v74;
      if (!v73) {
        uint64_t v60 = &v75;
      }
      uint64_t v61 = *v60;
      int v76 = MEMORY[0x1895F87A8];
      int v77 = 3221225472LL;
      unsigned int v78 = __ERROR_WRITE_REJECTED_block_invoke;
      CFIndex v79 = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
      uint64_t v80 = string;
      unint64_t v62 = a3;
LABEL_127:
      _extractCFPDBits(v62, v61, self, (uint64_t)&v76);
LABEL_128:
      if (v72) {
        -[CFPDSource cleanUpIfNecessaryAfterCreatingPlist]((uint64_t)self);
      }
      if ((*((_BYTE *)self + 142) & 4) != 0) {
        -[CFPDSource syncWriteToDiskAndFlushCacheForReason:]( self,  "syncWriteToDiskAndFlushCacheForReason:",  @"we're never caching");
      }
      -[CFPDSource closeFileDescriptors]((uint64_t)self);
      if (v75) {
        xpc_release(v75);
      }
      if (v74) {
        xpc_release(v74);
      }

      if (v32 != -1) {
        close(v32);
      }
      return reply;
    case 2:
    case 3:
      if (v71) {
        uint64_t v33 = v71;
      }
      else {
        uint64_t v33 = "Operation not allowed";
      }
      populateErrorReply(v33, reply, 0);
      xpc_dictionary_set_BOOL(reply, "CFPreferencesErrorClientFault", 1);
      goto LABEL_117;
    case 4:
      if (!self->_actualPath)
      {
        -[CFPDSource cacheFileInfo](self, "cacheFileInfo");
        if (!self->_actualPath) {
          goto LABEL_76;
        }
      }

      populateErrorReply("Access token needed", reply, 3u);
      __int16 v38 = self->_actualPath;
      char v39 = "CFPreferencesAccessToken";
      goto LABEL_116;
    case 5:
      populateErrorReply("Directory needed", reply, 4u);
      bzero(&v81, 0x402uLL);
      char v39 = "CFPreferencesUncanonicalizedPath";
      goto LABEL_115;
    case 6:
      uint64_t v40 = "Invalid plist data";
      uint64_t v41 = reply;
      uint64_t v42 = 1;
      goto LABEL_83;
    case 7:
LABEL_76:
      uint64_t v40 = "Path not accessible";
      goto LABEL_82;
    case 8:
      uint64_t v40 = "Writing has been disabled";
      goto LABEL_82;
    case 9:
      uint64_t v40 = "Unable to determine access";
LABEL_82:
      uint64_t v41 = reply;
      uint64_t v42 = 0;
      goto LABEL_83;
    default:
      goto LABEL_117;
  }

void DEBUG_READ(void *a1, void *a2, uint64_t a3)
{
  v7[5] = *MEMORY[0x1895F89C0];
  uint64_t v6 = (os_log_s *)_CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = __DEBUG_READ_block_invoke;
    _OWORD v7[3] = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
    void v7[4] = a3;
    _extractCFPDBits(a1, 0LL, a2, (uint64_t)v7);
  }

void DEBUG_READ_EMPTY(void *a1, void *a2, uint64_t a3)
{
  v7[5] = *MEMORY[0x1895F89C0];
  uint64_t v6 = (os_log_s *)_CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v7[0] = MEMORY[0x1895F87A8];
    v7[1] = 3221225472LL;
    v7[2] = __DEBUG_READ_EMPTY_block_invoke;
    _OWORD v7[3] = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
    void v7[4] = a3;
    _extractCFPDBits(a1, 0LL, a2, (uint64_t)v7);
  }

void sub_180BBC81C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void sub_180BBCBB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_180BBCF74(_Unwind_Exception *a1)
{
}

void sub_180BBD490(_Unwind_Exception *a1)
{
}

void __Block_byref_object_copy__319(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__320(uint64_t a1)
{
}

uint64_t _canDup()
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    char v0 = 1;
  }

  else
  {
    if (_canDup_once != -1) {
      dispatch_once(&_canDup_once, &__block_literal_global_324);
    }
    char v0 = _canDup_canDup ^ 1;
  }

  return v0 & 1;
}

uint64_t ___canDup_block_invoke()
{
  uint64_t result = sandbox_check();
  if ((_DWORD)result) {
    _canDup_canDup = 1;
  }
  return result;
}

void _extractCFPDBits(void *a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    size_t length = 0LL;
    data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
    if (data && length == 32)
    {
      __int128 v8 = data[1];
      __int128 buffer = *data;
      *(_OWORD *)pid = v8;
    }

    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        BOOL value = xpc_dictionary_get_value(a1, "connection");
      }

      xpc_connection_get_audit_token();
    }

    uint64_t v10 = pid[1];
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 buffer = 0u;
    *(_OWORD *)pid = 0u;
    BOOL v9 = (_DWORD)v10 != -1 && proc_name(v10, &buffer, 0x40u) >= 0;
  }

  else
  {
    BOOL v9 = 0;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 buffer = 0u;
    *(_OWORD *)pid = 0u;
    uint64_t v10 = 0xFFFFFFFFLL;
  }

  uint64_t v14 = toCString((const __CFString *)[a3 domain], &v37, "no domain");
  CFIndex v15 = toCString((const __CFString *)[a3 user], &v36, "no user");
  if (!a2) {
    goto LABEL_16;
  }
  Class Class = object_getClass(a2);
  if (Class == (Class)MEMORY[0x1895F92E8])
  {
    string_ptr = (char *)xpc_string_get_string_ptr(a2);
    int v17 = 0;
  }

  else
  {
    if (Class != (Class)MEMORY[0x1895F9250])
    {
LABEL_16:
      int v17 = 0;
      string_ptr = "no key";
      goto LABEL_19;
    }

    size_t length = 0LL;
    p_size_t length = &length;
    uint64_t v33 = 0x2020000000LL;
    uint64_t v19 = MEMORY[0x1895F87A8];
    uint64_t v34 = 0LL;
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 3221225472LL;
    applier[2] = ___extractCFPDBits_block_invoke;
    applier[3] = &unk_189996830;
    applier[4] = &length;
    xpc_dictionary_apply(a2, applier);
    string_ptr = (char *)calloc(1uLL, p_length[3] + 3);
    char *string_ptr = 91;
    uint64_t v26 = 0LL;
    CFRange v27 = &v26;
    uint64_t v28 = 0x2020000000LL;
    int v29 = 1;
    v25[0] = v19;
    v25[1] = 3221225472LL;
    v25[2] = ___extractCFPDBits_block_invoke_2;
    _OWORD v25[3] = &unk_1899EDA00;
    v25[4] = &v26;
    void v25[5] = string_ptr;
    xpc_dictionary_apply(a2, v25);
    string_ptr[*((int *)v27 + 6)] = 93;
    _Block_object_dispose(&v26, 8);
    _Block_object_dispose(&length, 8);
    int v17 = 1;
  }

void sub_180BBE798( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

void *toCString(const __CFString *a1, char *a2, void *a3)
{
  if (!a1) {
    goto LABEL_10;
  }
  uint64_t v5 = a1;
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID())
  {
    CFStringRef v7 = CFCopyDescription(v5);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v5 = v7;
    CFAutorelease(v7);
  }

  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  CStringPtr = CFStringGetCStringPtr(v5, SystemEncoding);
  if (!CStringPtr)
  {
    CFIndex Length = CFStringGetLength(v5);
    CFIndex v12 = CFStringGetMaximumSizeForEncoding(Length, SystemEncoding) + 1;
    char v10 = 1;
    uint64_t v13 = (char *)calloc(v12, 1uLL);
    if (CFStringGetCString(v5, v13, v12, SystemEncoding))
    {
      a3 = v13;
      goto LABEL_11;
    }

    free(v13);
LABEL_10:
    char v10 = 0;
    goto LABEL_11;
  }

  char v10 = 0;
  a3 = (void *)CStringPtr;
LABEL_11:
  *a2 = v10;
  return a3;
}

uint64_t ___extractCFPDBits_block_invoke(uint64_t a1, char *__s)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += strlen(__s) + 2;
  return 1LL;
}

uint64_t ___extractCFPDBits_block_invoke_2(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  int v5 = v4;
  strncpy((char *)(*(void *)(a1 + 40) + *(int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)), __s, v4);
  uint64_t v6 = *(void *)(a1 + 40);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v5;
  *(_WORD *)(v6 + *(int *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) = 8236;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += 2;
  return 1LL;
}

uint64_t __notifyFunc_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2 = (_BYTE *)(a2 + 55);
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 55);
  if (*(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL)) {
    uint64_t v2 = (_BYTE *)(a2 + 56);
  }
  _BYTE *v2 = 1;
  return result;
}

void __notifyFunc_block_invoke_2(uint64_t a1, id a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (object_getClass(a2) != (Class)MEMORY[0x1895F9268])
  {
    uint64_t v11 = 0LL;
    CFIndex v12 = &v11;
    uint64_t v13 = 0x2020000000LL;
    char v14 = 0;
    uint64_t v3 = MEMORY[0x1895F87A8];
    size_t v4 = *(_xpc_connection_s **)(a1 + 32);
    v10[0] = MEMORY[0x1895F87A8];
    v10[1] = 3221225472LL;
    _OWORD v10[2] = __notifyFunc_block_invoke_3;
    _OWORD v10[3] = &unk_1899EDA68;
    v10[4] = &v11;
    if (withClientContext(v4, (uint64_t)v10) && *((_BYTE *)v12 + 24))
    {
      v6[0] = v3;
      v6[1] = 3221225472LL;
      CFMutableDictionaryRef v6[2] = __notifyFunc_block_invoke_4;
      _OWORD v6[3] = &unk_1899EDA90;
      __int128 v7 = *(_OWORD *)(a1 + 40);
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v8 = *(void *)(a1 + 56);
      uint64_t v9 = v5;
      -[CFPDSource observingConnectionsLockedSync:]((os_unfair_lock_s *)v7, (uint64_t)v6);
    }

    _Block_object_dispose(&v11, 8);
  }
}

void sub_180BBECE0(_Unwind_Exception *a1)
{
}

uint64_t __notifyFunc_block_invoke_3(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 56);
  *(_BYTE *)(a2 + 56) = 0;
  *(_BYTE *)(a2 + 55) = 0;
  return result;
}

uint64_t __notifyFunc_block_invoke_4(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  __int128 v4 = *(_OWORD *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v1 = *(void *)(a1 + 56);
  uint64_t v5 = v2;
  return notifyFunc(v1, &v4);
}

void *__initializeFSEvents_block_invoke()
{
  char v0 = dlopen("/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices", 256);
  fsEventStreamCreate = dlsym(v0, "FSEventStreamCreate");
  fsEventStreamInvalidate = dlsym(v0, "FSEventStreamInvalidate");
  fsEventStreamRelease = dlsym(v0, "FSEventStreamRelease");
  fsEventStreamSetDispatchQueue = dlsym(v0, "FSEventStreamSetDispatchQueue");
  fsEventStreamStart = dlsym(v0, "FSEventStreamStart");
  fsEventStreamStop = dlsym(v0, "FSEventStreamStop");
  uint64_t result = dlsym(v0, "FSEventStreamGetLatestEventId");
  fsEventStreamGetLatestEventId = (uint64_t)result;
  return result;
}

uint64_t _onqueue_locked_CFPrefsRecreateFileWatcher()
{
  if (dirWatcher)
  {
    fsEventStreamStop();
    fsEventStreamInvalidate(dirWatcher);
    fsEventStreamRelease(dirWatcher);
    dirWatcher = 0LL;
  }

  dirWatcher = fsEventStreamCreate( &__kCFAllocatorSystemDefault,  deletionStreamCallback,  0LL,  watchedDirs,  -1LL,  25LL,  0.0);
  fsEventStreamSetDispatchQueue();
  return dirWatcher;
}

void deletionStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, const __CFArray *a4, uint64_t a5)
{
  void v25[5] = *MEMORY[0x1895F89C0];
  dispatch_assert_queue_V2((dispatch_queue_t)fseventsQueue);
  os_unfair_lock_lock((os_unfair_lock_t)&dirWatcherLock);
  CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
  if (a3)
  {
    CFIndex v8 = 0LL;
    char v9 = 0;
    char v10 = &OBJC_IVAR_____NSBlockVariable_containedObject;
    do
    {
      if ((~*(_DWORD *)(a5 + 4 * v8) & 0x20200) == 0)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a4, v8);
        Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)dirWatcherTargets, ValueAtIndex);
        if (Value)
        {
          uint64_t v13 = Value;
          char v14 = v10;
          uint64_t Count = CFArrayGetCount(Value);
          if (Count >= 1)
          {
            for (CFIndex i = 0LL; i != Count; ++i)
              *((_BYTE *)CFArrayGetValueAtIndex(v13, i) + 14__postAndResetMidnight(1, 1) = 0;
            char v9 = 1;
          }

          v27.CFIndex location = 0LL;
          v27.size_t length = Count;
          CFArrayAppendArray(Mutable, v13, v27);
          char v10 = v14;
        }

        CFDictionaryRemoveValue((CFMutableDictionaryRef)dirWatcherTargets, ValueAtIndex);
        int v17 = (const __CFArray *)*((void *)v10 + 434);
        v26.size_t length = CFArrayGetCount(v17);
        v26.CFIndex location = 0LL;
        CFIndex FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v17, v26, ValueAtIndex);
        if (FirstIndexOfValue != -1) {
          CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)v10 + 434), FirstIndexOfValue);
        }
      }

      ++v8;
    }

    while (v8 != a3);
    if ((v9 & 1) != 0) {
      _onqueue_locked_CFPrefsRecreateFileWatcher();
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&dirWatcherLock);
  CFIndex v19 = CFArrayGetCount(Mutable);
  if (v19 >= 1)
  {
    CFIndex v20 = v19;
    CFIndex v21 = 0LL;
    uint64_t v22 = MEMORY[0x1895F87A8];
    do
    {
      CFStringRef v23 = (void *)CFArrayGetValueAtIndex(Mutable, v21);
      v25[0] = v22;
      v25[1] = 3221225472LL;
      v25[2] = __deletionStreamCallback_block_invoke;
      _OWORD v25[3] = &unk_18999B4C8;
      v25[4] = v23;
      [v23 lockedSync:v25];
      ++v21;
    }

    while (v20 != v21);
  }

  CFRelease(Mutable);
}

uint64_t __deletionStreamCallback_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) clearCacheForReason:@"directory was deleted"];
}

void OUTLINED_FUNCTION_0_31(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

  ;
}

void OUTLINED_FUNCTION_2_15(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

  ;
}

  ;
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_7_2( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_8_2(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose((const void *)(v1 - 72), 8) = a1;
}

void OUTLINED_FUNCTION_9_0( void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_10( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_13(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

int *OUTLINED_FUNCTION_14()
{
  return __error();
}

uint64_t _CFBigNumInitWithInt8(uint64_t result, int a2)
{
  *(void *)uint64_t result = 0LL;
  *(void *)(result + _Block_object_dispose((const void *)(v1 - 72), 8) = 0LL;
  *(void *)(result + ++*(_WORD *)(cf + 16) = 0LL;
  if (a2 < 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }

  *(_DWORD *)uint64_t result = a2;
  return result;
}

uint64_t _CFBigNumInitWithInt16(uint64_t result, int a2)
{
  *(void *)uint64_t result = 0LL;
  *(void *)(result + _Block_object_dispose((const void *)(v1 - 72), 8) = 0LL;
  *(void *)(result + ++*(_WORD *)(cf + 16) = 0LL;
  if (a2 < 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }

  *(_DWORD *)uint64_t result = (unsigned __int16)a2;
  return result;
}

uint64_t _CFBigNumInitWithInt32(uint64_t result, unsigned int a2)
{
  *(void *)uint64_t result = 0LL;
  *(void *)(result + _Block_object_dispose((const void *)(v1 - 72), 8) = 0LL;
  *(void *)(result + ++*(_WORD *)(cf + 16) = 0LL;
  if ((a2 & 0x80000000) != 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }

  *(_DWORD *)uint64_t result = a2 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 / 0x3B9ACA00;
  return result;
}

uint64_t _CFBigNumInitWithInt64(uint64_t result, unint64_t a2)
{
  *(void *)uint64_t result = 0LL;
  *(void *)(result + _Block_object_dispose((const void *)(v1 - 72), 8) = 0LL;
  *(void *)(result + ++*(_WORD *)(cf + 16) = 0LL;
  if ((a2 & 0x8000000000000000LL) != 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -(uint64_t)a2;
  }

  *(_DWORD *)uint64_t result = a2 % 0xDE0B6B3A7640000LL % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 % 0xDE0B6B3A7640000LL / 0x3B9ACA00;
  *(_DWORD *)(result + _Block_object_dispose((const void *)(v1 - 72), 8) = a2 / 0xDE0B6B3A7640000LL;
  return result;
}

__n128 _CFBigNumInitWithInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v3) = a2;
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 72), 8) = 0LL;
  *(void *)(a1 + ++*(_WORD *)(cf + 16) = 0LL;
  if (a3 < 0)
  {
    *(_DWORD *)(a1 + 20) |= 0xFFu;
    uint64_t v3 = -a2;
  }

  int v5 = __udivti3();
  unsigned int v6 = __udivti3();
  unsigned int v7 = __udivti3();
  unsigned __int32 v8 = __udivti3();
  result.n128_u32[0] = 1486618624 * v7 + 402653184 * v6 + v3 - 1000000000 * v8;
  result.n128_u32[1] = v8;
  result.n128_u64[1] = __PAIR64__(v6, v7);
  *(__n128 *)a1 = result;
  *(_DWORD *)(a1 + ++*(_WORD *)(cf + 16) = v5;
  return result;
}

void *_CFBigNumInitWithUInt8(void *result, int a2)
{
  *__n128 result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  *(_DWORD *)__n128 result = a2;
  return result;
}

void *_CFBigNumInitWithUInt16(void *result, int a2)
{
  *__n128 result = 0LL;
  result[1] = 0LL;
  result[2] = 0LL;
  *(_DWORD *)__n128 result = a2;
  return result;
}

uint64_t _CFBigNumInitWithUInt32(uint64_t result, unsigned int a2)
{
  *(void *)__n128 result = 0LL;
  *(void *)(result + _Block_object_dispose((const void *)(v1 - 72), 8) = 0LL;
  *(void *)(result + ++*(_WORD *)(cf + 16) = 0LL;
  *(_DWORD *)__n128 result = a2 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 / 0x3B9ACA00;
  return result;
}

uint64_t _CFBigNumInitWithUInt64(uint64_t result, unint64_t a2)
{
  *(void *)__n128 result = 0LL;
  *(void *)(result + _Block_object_dispose((const void *)(v1 - 72), 8) = 0LL;
  *(void *)(result + ++*(_WORD *)(cf + 16) = 0LL;
  *(_DWORD *)__n128 result = a2 % 0xDE0B6B3A7640000LL % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 % 0xDE0B6B3A7640000LL / 0x3B9ACA00;
  *(_DWORD *)(result + _Block_object_dispose((const void *)(v1 - 72), 8) = a2 / 0xDE0B6B3A7640000LL;
  return result;
}

__n128 _CFBigNumInitWithUInt128(void *a1, int a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  int v4 = __udivti3();
  unsigned int v5 = __udivti3();
  unsigned int v6 = __udivti3();
  unsigned __int32 v7 = __udivti3();
  result.n128_u32[0] = 1486618624 * v6 + 402653184 * v5 + a2 - 1000000000 * v7;
  result.n128_u32[1] = v7;
  result.n128_u64[1] = __PAIR64__(v5, v6);
  *(__n128 *)a1 = result;
  *((_DWORD *)a1 + 4) = v4;
  return result;
}

uint64_t _CFBigNumGetInt8(uint64_t a1)
{
  int v1 = *(_DWORD *)a1;
  if ((*(_BYTE *)(a1 + 20) & 0x80) != 0) {
    int v1 = -v1;
  }
  return (char)v1;
}

uint64_t _CFBigNumGetInt16(uint64_t a1)
{
  int v1 = *(_DWORD *)a1;
  if ((*(_BYTE *)(a1 + 20) & 0x80) != 0) {
    int v1 = -v1;
  }
  return (__int16)v1;
}

uint64_t _CFBigNumGetInt32(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)a1 + 1000000000 * *(_DWORD *)(a1 + 4);
  if ((*(_BYTE *)(a1 + 20) & 0x80) != 0) {
    return -v1;
  }
  else {
    return v1;
  }
}

uint64_t _CFBigNumGetInt64(unsigned int *a1)
{
  if ((a1[5] & 0x80) != 0) {
    return -(*a1 + 1000000000LL * a1[1] + 1000000000000000000LL * a1[2]);
  }
  else {
    return *a1 + 1000000000LL * a1[1] + 1000000000000000000LL * a1[2];
  }
}

uint64_t _CFBigNumGetInt128(unsigned int *a1)
{
  if ((a1[5] & 0x80) != 0) {
    return 0x4CB460F000000000LL * a1[4]
  }
         - (*a1
          + 1000000000LL * a1[1]
          + 1000000000000000000LL * a1[2]
          - 0x602F7FC318000000LL * a1[3]);
  else {
    return *a1
  }
         + 1000000000LL * a1[1]
         + 1000000000000000000LL * a1[2]
         - 0x602F7FC318000000LL * a1[3]
         - 0x4CB460F000000000LL * a1[4];
}

uint64_t _CFBigNumGetUInt8(unsigned __int8 *a1)
{
  return *a1;
}

uint64_t _CFBigNumGetUInt16(unsigned __int16 *a1)
{
  return *a1;
}

uint64_t _CFBigNumGetUInt32(_DWORD *a1)
{
  return (*a1 + 1000000000 * a1[1]);
}

uint64_t _CFBigNumGetUInt64(unsigned int *a1)
{
  return *a1 + 1000000000LL * a1[1] + 1000000000000000000LL * a1[2];
}

uint64_t _CFBigNumGetUInt128(unsigned int *a1)
{
  return *a1
       + 1000000000LL * a1[1]
       + 1000000000000000000LL * a1[2]
       - 0x602F7FC318000000LL * a1[3]
       - 0x4CB460F000000000LL * a1[4];
}

double _CFBigNumInitWithCFNumber(uint64_t a1, unint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  memset(v6, 0, sizeof(v6));
  CFNumberType Type2 = _CFNumberGetType2(a2);
  CFNumberGetValue((CFNumberRef)a2, Type2, v6);
  return _CFBigNumInitWithBytes(a1, (char *)v6, Type2);
}

double _CFBigNumInitWithBytes(uint64_t a1, char *a2, uint64_t a3)
{
  switch(a3)
  {
    case 1LL:
    case 7LL:
      _CFBigNumInitWithInt8(a1, *a2);
      break;
    case 2LL:
    case 8LL:
      _CFBigNumInitWithInt16(a1, *(__int16 *)a2);
      break;
    case 3LL:
    case 9LL:
      _CFBigNumInitWithInt32(a1, *(_DWORD *)a2);
      break;
    case 4LL:
    case 10LL:
    case 11LL:
    case 14LL:
    case 15LL:
      _CFBigNumInitWithInt64(a1, *(void *)a2);
      break;
    case 17LL:
      *(void *)&double result = _CFBigNumInitWithInt128(a1, *((void *)a2 + 1), *(void *)a2).n128_u64[0];
      break;
    default:
      return result;
  }

  return result;
}

CFNumberRef _CFNumberCreateWithBigNum(unsigned int *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  unint64_t v2 = a1[4];
  if (!*(void *)(a1 + 3))
  {
    if (!a1[2] && !a1[1])
    {
      unsigned int v22 = *a1;
      if (*a1 <= 0x7F)
      {
        if ((a1[5] & 0x80) != 0) {
          unsigned int v22 = -v22;
        }
        v25[0] = v22;
        char v14 = v25;
        CFNumberType v15 = kCFNumberSInt8Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
      }

      if (!(v22 >> 15))
      {
        if ((a1[5] & 0x80) != 0) {
          unsigned int v22 = -v22;
        }
        *(_WORD *)uint64_t v25 = v22;
        char v14 = v25;
        CFNumberType v15 = kCFNumberSInt16Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
      }
    }

    if (!a1[2])
    {
      *(void *)&v25[16] = 0LL;
      *(_OWORD *)uint64_t v25 = 0x208CA6BFFuLL;
      *(void *)&v24[16] = 0xFF00000000LL;
      *(_OWORD *)CFStringRef v24 = 0x208CA6C00uLL;
      uint64_t v19 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
      uint64_t v20 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
      if ((unint64_t)(v19 - 1) >= 0xFFFFFFFFFFFFFFFELL && v20 != -1)
      {
        int v21 = *a1 + 1000000000 * a1[1];
        if ((a1[5] & 0x80) != 0) {
          int v21 = -v21;
        }
        LODWORD(v23[0]) = v21;
        char v14 = v23;
        CFNumberType v15 = kCFNumberSInt32Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
      }
    }

    *(_DWORD *)&v25[20] = 0;
    *(void *)&v25[12] = 0LL;
    *(void *)uint64_t v25 = 0xD50630432F2D7FFLL;
    *(_DWORD *)&v25[8] = 9;
    *(void *)&v24[12] = 0LL;
    *(_DWORD *)&v24[20] = 255;
    *(void *)CFStringRef v24 = 0xD50630432F2D800LL;
    *(_DWORD *)&v24[8] = 9;
    uint64_t v16 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
    uint64_t v17 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
    if ((unint64_t)(v16 - 1) >= 0xFFFFFFFFFFFFFFFELL && v17 != -1)
    {
      uint64_t v18 = *a1 + 1000000000LL * a1[1] + 1000000000000000000LL * a1[2];
      if ((a1[5] & 0x80) != 0) {
        uint64_t v18 = -v18;
      }
      v23[0] = v18;
      char v14 = v23;
      CFNumberType v15 = kCFNumberSInt64Type;
      return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
    }
  }

  *(_OWORD *)uint64_t v25 = xmmword_180D7FDC0;
  *(void *)&v25[16] = 170LL;
  *(_OWORD *)CFStringRef v24 = xmmword_180D7FDD0;
  *(void *)&v24[16] = 0xFF000000AALL;
  uint64_t v3 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
  uint64_t v4 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
  CFNumberRef result = 0LL;
  if ((unint64_t)(v3 + 1) <= 1 && v4 != -1)
  {
    uint64_t v6 = *a1 + 1000000000LL * a1[1];
    uint64_t v7 = 1000000000000000000LL * a1[2];
    BOOL v8 = __CFADD__(v6, v7);
    uint64_t v9 = v6 + v7;
    if (v8) {
      unint64_t v10 = ((a1[2] * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64) + 1;
    }
    else {
      unint64_t v10 = (a1[2] * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64;
    }
    unsigned __int128 v13 = __PAIR128__(v10, v9)
        + __PAIR128__( ((a1[3] * (unsigned __int128)0x9FD0803CE8000000LL) >> 64) + 54210108LL * a1[3],  0x9FD0803CE8000000LL * a1[3])
        + __PAIR128__(0xC097CE7BC90715LL, 0xB34B9F1000000000LL) * v2;
    uint64_t v12 = *((void *)&v13 + 1);
    uint64_t v11 = v13;
    if ((a1[5] & 0x80) != 0)
    {
      uint64_t v12 = (unsigned __int128)-(__int128)__PAIR128__((v2 * (unsigned __int128)0xB34B9F1000000000LL) >> 64, v13) >> 64;
      uint64_t v11 = -(uint64_t)v13;
    }

    v23[0] = v11;
    v23[1] = v12;
    char v14 = v23;
    CFNumberType v15 = kCFNumberMaxType|kCFNumberSInt8Type;
    return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
  }

  return result;
}

uint64_t _CFBigNumCompare(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 20);
  int v3 = *(char *)(a2 + 20);
  if ((char)v2 == v3)
  {
    int v4 = v2 << 24;
    uint64_t v5 = 16LL;
    while (1)
    {
      if (v5 == -4) {
        return 0LL;
      }
      unsigned int v6 = *(_DWORD *)(a1 + v5);
      unsigned int v7 = *(_DWORD *)(a2 + v5);
      if (v6 < v7) {
        break;
      }
      v5 -= 4LL;
      if (v6 > v7)
      {
        BOOL v8 = v4 < 0;
        uint64_t v9 = 1LL;
        goto LABEL_12;
      }
    }

    BOOL v8 = v4 < 0;
    uint64_t v9 = -1LL;
LABEL_12:
    if (v8) {
      return -v9;
    }
    else {
      return v9;
    }
  }

  else if ((char)v2 < v3)
  {
    return -1LL;
  }

  else
  {
    return 1LL;
  }

uint64_t _CFBigNumNeg(uint64_t result, __int128 *a2)
{
  uint64_t v2 = 0LL;
  __int128 v3 = *a2;
  *(void *)(result + ++*(_WORD *)(cf + 16) = *((void *)a2 + 2);
  *(_OWORD *)CFNumberRef result = v3;
  while (!*(_DWORD *)((char *)a2 + v2))
  {
    v2 += 4LL;
    if (v2 == 20) {
      return result;
    }
  }

  *(_BYTE *)(result + 20) = *(_BYTE *)(result + 20) * *(_BYTE *)(result + 20) - 1;
  return result;
}

unint64_t _CFBigNumAdd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v3) = *(unsigned __int8 *)(a3 + 20) ^ *(unsigned __int8 *)(a2 + 20);
  if ((_DWORD)v3)
  {
    uint64_t v4 = 16LL;
    while (1)
    {
      if (v4 == -4)
      {
LABEL_6:
        uint64_t v7 = a2;
        goto LABEL_13;
      }

      unsigned int v5 = *(_DWORD *)(a2 + v4);
      unsigned int v6 = *(_DWORD *)(a3 + v4);
      if (v5 < v6) {
        break;
      }
      v4 -= 4LL;
      if (v5 > v6) {
        goto LABEL_6;
      }
    }

    uint64_t v7 = a3;
    a3 = a2;
LABEL_13:
    uint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = *(unsigned int *)(a3 + v10);
      uint64_t v13 = v11 + *(unsigned int *)(v7 + v10);
      uint64_t v15 = v13 - v12;
      BOOL v14 = v13 < v12;
      int v16 = v13 - v12 + 1000000000;
      uint64_t v11 = v15 >> 63;
      if (!v14) {
        int v16 = v15;
      }
      *(_DWORD *)(a1 + v10) = v16;
      v10 += 4LL;
    }

    while (v10 != 20);
    unint64_t v3 = (unint64_t)v15 >> 63;
    int v17 = *(_DWORD *)(a1 + 20);
    if ((*(_BYTE *)(v7 + 20) & 0x80) != 0) {
      unsigned int v18 = v17 | 0xFF;
    }
    else {
      unsigned int v18 = v17 & 0xFFFFFF00;
    }
    *(_DWORD *)(a1 + 20) = v18;
  }

  else
  {
    for (uint64_t i = 0LL; i != 20; i += 4LL)
    {
      unsigned int v9 = *(_DWORD *)(a2 + i) + v3 + *(_DWORD *)(a3 + i);
      unint64_t v3 = v9 > 0x3B9ACA00;
      if (v9 > 0x3B9ACA00) {
        v9 -= 1000000000;
      }
      *(_DWORD *)(a1 + i) = v9;
    }

    *(_BYTE *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  }

  return v3;
}

unint64_t _CFBigNumSub(uint64_t a1, uint64_t a2, __int128 *a3)
{
  _OWORD v6[3] = *MEMORY[0x1895F89C0];
  _CFBigNumNeg((uint64_t)v6, a3);
  return _CFBigNumAdd(a1, a2, (uint64_t)v6);
}

void *_CFBigNumToCString(uint64_t a1, int a2, int a3, char *a4, size_t a5)
{
  size_t v5 = a5;
  unsigned int v6 = a4;
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if ((*(_BYTE *)(a1 + 20) & 0x80) != 0)
  {
    char v8 = 45;
  }

  else
  {
    if (!a3) {
      goto LABEL_6;
    }
    char v8 = 43;
  }

  *a4 = v8;
  unsigned int v6 = a4 + 1;
  size_t v5 = a5 - 1;
LABEL_6:
  snprintf( __str,  0x2EuLL,  "%09u%09u%09u%09u%09u",  *(_DWORD *)(a1 + 16),  *(_DWORD *)(a1 + 12),  *(_DWORD *)(a1 + 8),  *(_DWORD *)(a1 + 4),  *(_DWORD *)a1);
  if (a2)
  {
    memset(v6, 48, v5);
    if (v5 >= 0x2E) {
      size_t v9 = 46LL;
    }
    else {
      size_t v9 = v5;
    }
    return memmove(&v6[v5 - v9], &__str[-v9 + 46], v9);
  }

  else
  {
    for (uint64_t i = __str; *i == 48; ++i)
      ;
    if (*i) {
      uint64_t v12 = i;
    }
    else {
      uint64_t v12 = i - 1;
    }
    return (void *)strlcpy(v6, v12, v5);
  }

void _CFBigNumFromCString(uint64_t a1, char *__s)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose((const void *)(v1 - 72), 8) = 0LL;
  *(void *)(a1 + ++*(_WORD *)(cf + 16) = 0LL;
  size_t v4 = strlen(__s);
  size_t v5 = (unsigned __int8 *)calloc(v4 + 1, 1uLL);
  size_t v6 = strlen(__s);
  memcpy(v5, __s, v6 + 1);
  int v7 = *v5;
  if (v7 == 43) {
    goto LABEL_4;
  }
  char v8 = v5;
  if (v7 == 45)
  {
    *(_DWORD *)(a1 + 20) |= 0xFFu;
LABEL_4:
    char v8 = v5 + 1;
  }

  size_t v9 = (const char *)(v8 - 1);
  do
    int v10 = *(unsigned __int8 *)++v9;
  while (v10 == 48);
  size_t v11 = strlen(v9);
  if (v11)
  {
    if (v11 < 0xA)
    {
      unint64_t v13 = 0LL;
    }

    else
    {
      unint64_t v12 = (v11 - 10) / 9;
      if (v12 >= 3) {
        unint64_t v12 = 3LL;
      }
      unint64_t v13 = v12 + 1;
      uint64_t v14 = &v9[v11 - 9];
      uint64_t v15 = (_DWORD *)a1;
      unint64_t v16 = v12 + 1;
      do
      {
        *v15++ = atol(v14);
        const char *v14 = 0;
        v14 -= 9;
        --v16;
      }

      while (v16);
    }

    *(_DWORD *)(a1 + 4 * v13) = atol(v9);
  }

  free(v5);
}

char *_CFBigNumCopyDescription(_DWORD *a1)
{
  uint64_t v2 = (char *)calloc(0x400uLL, 1uLL);
  unint64_t v3 = v2;
  size_t v4 = "-";
  if ((a1[5] & 0x80) == 0) {
    size_t v4 = "+";
  }
  snprintf(v2, 0x400uLL, "sign:%s 1st:%u 2nd:%u 3rd:%u 4th:%u 5th:%u", v4, *a1, a1[1], a1[2], a1[3], a1[4]);
  return v3;
}

uint64_t _CFPrefsCurrentProcessIsCFPrefsD()
{
  return isCFPrefsD;
}

void _CFPrefsSetDirectModeEnabled(char a1)
{
  forceDirect = a1;
  _CFPrefsResetPreferences(1LL);
}

uint64_t _CFPrefsSetReadOnly(uint64_t result)
{
  forceReadOnly = (_DWORD)result != 0;
  return result;
}

BOOL _CFPrefsDirectMode()
{
  BOOL result = 1LL;
  if ((isCFPrefsD & 1) == 0 && !forceDirect)
  {
    if (_CFPrefsProcessPathRequiresDirectMode_onceToken != -1) {
      dispatch_once(&_CFPrefsProcessPathRequiresDirectMode_onceToken, &__block_literal_global_136);
    }
    if (_CFPrefsProcessPathRequiresDirectMode_onBlacklist)
    {
      return 1LL;
    }

    else
    {
      if (_CFPrefsDirectMode_onceToken != -1) {
        dispatch_once(&_CFPrefsDirectMode_onceToken, &__block_literal_global_43);
      }
      return forceDirect != 0;
    }
  }

  return result;
}

uint64_t _CFPrefsReadOnly()
{
  return forceReadOnly;
}

void populateErrorReply(const char *a1, xpc_object_t xdict, unsigned int a3)
{
  if (!xdict) {
    populateErrorReply_cold_1();
  }
  xpc_dictionary_set_value(xdict, "CFPreferencesPropertyList", 0LL);
  xpc_dictionary_set_string(xdict, "CFPreferencesErrorDescription", a1);
  xpc_dictionary_set_int64(xdict, "CFPreferencesErrorType", a3);
}

BOOL withClientContext(_xpc_connection_s *a1, uint64_t a2)
{
  uint64_t context = (os_unfair_lock_s *)xpc_connection_get_context(a1);
  if (!context) {
    withClientContext_cold_1();
  }
  size_t v5 = context;
  size_t v6 = context + 12;
  os_unfair_lock_lock(context + 12);
  int v7 = BYTE1(v5[14]._os_unfair_lock_opaque);
  os_unfair_lock_unlock((os_unfair_lock_t)&_globalContextLock);
  if (v7) {
    (*(void (**)(uint64_t, os_unfair_lock_s *))(a2 + 16))(a2, v5);
  }
  os_unfair_lock_unlock(v6);
  return v7 != 0;
}

const void *_CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded(void *a1)
{
  length[1] = *MEMORY[0x1895F89C0];
  xpc_dictionary_set_value(a1, "CFPreferencesAuditToken", 0LL);
  length[0] = 0LL;
  BOOL result = xpc_dictionary_get_data(a1, "CFPreferencesAuditTokenToImpersonate", length);
  if (result && length[0] == 32)
  {
    unint64_t v3 = result;
    remote_connection = xpc_dictionary_get_remote_connection(a1);
    if (!remote_connection)
    {
      BOOL value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
      if (!value
        || (remote_connection = value,
            BOOL value = (_xpc_connection_s *)object_getClass(value),
            value != (_xpc_connection_s *)MEMORY[0x1895F9238]))
      {
        _CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_cold_1((uint64_t)value, v6, v7);
      }
    }

    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    uint64_t v8[2] = ___CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_block_invoke;
    uint64_t v8[3] = &unk_1899EDC58;
    v8[4] = a1;
    v8[5] = v3;
    void v8[6] = length[0];
    return (const void *)withClientContext(remote_connection, (uint64_t)v8);
  }

  return result;
}

xpc_object_t _CFPrefsGetEntitlementForMessageWithLockedContext(void *a1, char *key, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1) {
    _CFPrefsGetEntitlementForMessageWithLockedContext_cold_1();
  }
  xpc_object_t v5 = *(xpc_object_t *)(a3 + 32);
  if (v5)
  {
    if (key) {
      return xpc_dictionary_get_value(v5, key);
    }
  }

  else
  {
    size_t length = 0LL;
    data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
    if (data && length == 32)
    {
      __int128 v9 = data[1];
      __int128 v26 = *data;
      __int128 v27 = v9;
    }

    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        BOOL value = xpc_dictionary_get_value(a1, "connection");
      }

      xpc_connection_get_audit_token();
    }

    unint64_t v13 = (void *)xpc_copy_entitlement_for_token();
    if (!v13) {
      goto LABEL_27;
    }
    uint64_t v14 = v13;
    array = (const __CFArray *)xpc_dictionary_get_array(v13, "com.apple.security.application-groups");
    if (array)
    {
      unint64_t v16 = array;
      if (xpc_array_get_count(array)) {
        *(void *)(a3 + 40) = _CFXPCCreateCFObjectFromXPCObject(v16);
      }
    }

    uint64_t v17 = 0LL;
    xpc_object_t v5 = 0LL;
    int v18 = 0;
    do
    {
      uint64_t v19 = entitlementsWeCareAbout[v17];
      if (key)
      {
        size_t v20 = strlen(entitlementsWeCareAbout[v17]);
        BOOL v21 = strncmp(v19, key, v20) == 0;
        char v22 = v21 | v18;
        v18 |= v21;
      }

      else
      {
        char v22 = 1;
      }

      xpc_object_t v23 = xpc_dictionary_get_value(v14, v19);
      if (v23)
      {
        CFStringRef v24 = v23;
        if (!v5) {
          xpc_object_t v5 = xpc_dictionary_create(0LL, 0LL, 0LL);
        }
        xpc_dictionary_set_value(v5, v19, v24);
      }

      ++v17;
    }

    while (v17 != 6);
    if ((v22 & 1) == 0) {
      _CFPrefsGetEntitlementForMessageWithLockedContext_cold_2();
    }
    xpc_release(v14);
    if (!v5)
    {
LABEL_27:
      if (_CFPrefsGetEntitlementForMessageWithLockedContext_onceToken != -1) {
        dispatch_once(&_CFPrefsGetEntitlementForMessageWithLockedContext_onceToken, &__block_literal_global_154);
      }
      xpc_object_t v5 = xpc_retain((xpc_object_t)_CFPrefsGetEntitlementForMessageWithLockedContext_emptyEntitlements);
    }

    *(void *)(a3 + 32) = v5;
    if (key) {
      return xpc_dictionary_get_value(v5, key);
    }
  }

  return 0LL;
}

BOOL _CFPrefsMessageSenderIsSandboxedWithLockedClientContext(void *a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  int v2 = *(unsigned __int8 *)(a2 + 52);
  if (v2 != 255) {
    return v2 == 1;
  }
  size_t length = 0LL;
  data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
  if (data && length == 32)
  {
    __int128 v6 = data[1];
    __int128 v12 = *data;
    __int128 v13 = v6;
  }

  else
  {
    if (!xpc_dictionary_get_remote_connection(a1))
    {
      BOOL value = xpc_dictionary_get_value(a1, "connection");
    }

    xpc_connection_get_audit_token();
  }

  BOOL result = sandbox_check_by_audit_token() != 0;
  *(_BYTE *)(a2 + 52) = result;
  return result;
}

uint64_t _CFPrefsPIDForMessage(void *a1)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  size_t length = 0LL;
  data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
  if (data && length == 32)
  {
    __int128 v3 = data[1];
    __int128 v9 = *data;
    __int128 v10 = v3;
  }

  else
  {
    if (!xpc_dictionary_get_remote_connection(a1))
    {
      BOOL value = xpc_dictionary_get_value(a1, "connection");
    }

    xpc_connection_get_audit_token();
  }

  return DWORD1(v10);
}

uint64_t _CFPrefsGetFixedUpDomainForMessage(void *a1, const void *a2, char a3, const char **a4)
{
  string = xpc_dictionary_get_string(a1, "CFPreferencesDomain");
  if (!string) {
    return 0LL;
  }
  __int128 v9 = string;
  CFStringRef v10 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, string, 0x8000100u);
  if (v10)
  {
    uint64_t v11 = v10;
    if (CFEqual(v10, @"kCFPreferencesAnyApplication")
      || CFEqual(@"Apple Global Domain", v11)
      || CFEqual(@".GlobalPreferences", v11))
    {
      CFRelease(v11);
      __int128 v9 = "kCFPreferencesAnyApplication";
      xpc_dictionary_set_string(a1, "CFPreferencesDomain", "kCFPreferencesAnyApplication");
      uint64_t v11 = @"kCFPreferencesAnyApplication";
    }

    if ((CFStringFind(v11, @"..", 0LL).location != -1 || CFStringGetCharacterAtIndex(v11, 0LL) == 47)
      && !xpc_dictionary_get_BOOL(a1, "CFPreferencesShouldWriteSynchronously"))
    {
      if (_CFPrefsIsAppleInternal_onceToken != -1) {
        dispatch_once(&_CFPrefsIsAppleInternal_onceToken, &__block_literal_global_156);
      }
      if (_CFPrefsIsAppleInternal_internal == 1)
      {
        __int128 v12 = (os_log_s *)_CFPrefsDaemonLog();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
          _CFPrefsGetFixedUpDomainForMessage_cold_1((uint64_t)v9, v12, v13, v14, v15, v16, v17, v18);
        }
      }
    }

    if (CFEqual(v11, @"kCFPreferencesCurrentApplication")
      || a2 && CFEqual(a2, @"kCFPreferencesAnyUser") && (a3 & 1) == 0)
    {
      CFRelease(v11);
      __int128 v9 = 0LL;
    }

    else if (v11)
    {
      uint64_t v19 = _CFPrefsDInternString(v11);
      CFRelease(v11);
      if (!a4) {
        return v19;
      }
      goto LABEL_18;
    }
  }

  uint64_t v19 = 0LL;
  if (a4) {
LABEL_18:
  }
    *a4 = v9;
  return v19;
}

CFStringRef _CFPrefsCopyFixedUpContainerForMessage(void *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  string = xpc_dictionary_get_string(a1, "CFPreferencesContainer");
  bzero(buffer, 0x402uLL);
  BOOL value = (const __CFArray *)xpc_dictionary_get_value(a1, "CFPreferencesHostBundleIdentifier");
  CFDataRef v11 = _CFXPCCreateCFObjectFromXPCObject(value);
  BOOL v12 = xpc_dictionary_get_BOOL(a1, "CFPreferencesCurrentApplicationDomain");
  if (!a2) {
    _CFPrefsCopyFixedUpContainerForMessage_cold_1();
  }
  BOOL v13 = v12;
  if (!v12)
  {
    *(void *)&__int128 v55 = 0LL;
    *((void *)&v55 + __postAndResetMidnight(1, 1) = &v55;
    *(void *)&__int128 v56 = 0x2020000000LL;
    BYTE8(v56) = 0;
    remote_connection = xpc_dictionary_get_remote_connection(a1);
    if (!remote_connection)
    {
      uint64_t v15 = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
      remote_connection = v15;
      if (!v15 || object_getClass(v15) != (Class)MEMORY[0x1895F9238]) {
        __assert_rtn( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  393,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
      }
    }

    length[0] = MEMORY[0x1895F87A8];
    length[1] = 3221225472LL;
    *(void *)&__int128 v47 = ___CFPrefsGetSuiteContainer_block_invoke;
    *((void *)&v47 + __postAndResetMidnight(1, 1) = &unk_1899EDFE8;
    uint64_t v50 = a2;
    uint64_t v51 = buffer;
    int v48 = a1;
    int v49 = &v55;
    BOOL v54 = v13;
    uint64_t v52 = 1026LL;
    CFDataRef v53 = v11;
    withClientContext(remote_connection, (uint64_t)length);
    int v16 = *(unsigned __int8 *)(*((void *)&v55 + 1) + 24LL);
    _Block_object_dispose(&v55, 8);
    if (v16) {
      string = buffer;
    }
  }

  if (v11) {
    CFRelease(v11);
  }
  if (!string || !*string)
  {
    CFStringRef v17 = 0LL;
    if (!a4 || !a5) {
      return v17;
    }
    length[0] = 0LL;
    data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", length);
    if (data && length[0] == 32)
    {
      __int128 v19 = data[1];
      __int128 v55 = *data;
      __int128 v56 = v19;
    }

    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        Class Class = xpc_dictionary_get_value(a1, "connection");
      }

      xpc_connection_get_audit_token();
    }

    *(_OWORD *)size_t length = v55;
    __int128 v47 = v56;
    CFStringRef v17 = 0LL;
    size_t v44 = 0LL;
    xpc_object_t v23 = xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &v44);
    if (v23 && v44 == 32)
    {
      __int128 v24 = v23[1];
      *(_OWORD *)size_t length = *v23;
      __int128 v47 = v24;
    }

    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        __int128 v27 = xpc_dictionary_get_value(a1, "connection");
      }

      xpc_connection_get_audit_token();
    }

    if (sandbox_check_by_audit_token())
    {
      size_t v44 = 0LL;
      uint64_t v30 = xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &v44);
      if (v30 && v44 == 32)
      {
        __int128 v31 = v30[1];
        *(_OWORD *)size_t length = *v30;
        __int128 v47 = v31;
      }

      else
      {
        if (!xpc_dictionary_get_remote_connection(a1))
        {
          CFErrorRef v32 = xpc_dictionary_get_value(a1, "connection");
        }

        xpc_connection_get_audit_token();
      }
    }

    return 0LL;
  }

  if (!strncmp(string, "kCFPreferencesNoContainer", 0x19uLL)) {
    return 0LL;
  }
  getpid();
  int v25 = open(string, 1074790400, string);
  int v26 = v25;
  if (v25 < 0)
  {
    char v36 = (os_log_s *)_CFPrefsDaemonLog();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
      _CFPrefsCopyFixedUpContainerForMessage_cold_5((uint64_t)string, v36, v37, v38, v39, v40, v41, v42);
    }
    return CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, string);
  }

  if (fcntl(v25, 50, buffer) == -1) {
    CFStringRef v17 = 0LL;
  }
  else {
    CFStringRef v17 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
  }
  close(v26);
  return v17;
}

void sub_180BC2350(_Unwind_Exception *a1)
{
}

CFStringRef _CFPrefsCopyFixedUpUserForMessage(void *a1, BOOL *a2, _BYTE *a3)
{
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    BOOL value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    if (!value
      || (remote_connection = value,
          BOOL value = (_xpc_connection_s *)object_getClass(value),
          value != (_xpc_connection_s *)MEMORY[0x1895F9238]))
    {
      _CFPrefsCopyFixedUpUserForMessage_cold_1((uint64_t)value, v8, v9);
    }
  }

  string = xpc_dictionary_get_string(a1, "CFPreferencesUser");
  CFDataRef v11 = string;
  if (string) {
    string = (const char *)CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, string, 0x8000100u);
  }
  if (string) {
    BOOL v12 = (const __CFString *)string;
  }
  else {
    BOOL v12 = @"kCFPreferencesAnyUser";
  }
  if (CFEqual(v12, @"kCFPreferencesCurrentUser"))
  {
    CFRelease(v12);
    uid_t euid = xpc_connection_get_euid(remote_connection);
    BOOL v12 = _CFPrefsCopyUserNameForUID(euid);
    isRootOrRoleAccountUseruint64_t Name = euid < 0x1F5;
  }

  else
  {
    isRootOrRoleAccountUseruint64_t Name = _isRootOrRoleAccountUserName(v12);
  }

  *a3 = isRootOrRoleAccountUserName;
  if (v12)
  {
    CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
    CFRelease(v12);
  }

  else
  {
    CFStringRef Copy = 0LL;
  }

  *a2 = v11 != 0LL;
  return Copy;
}

uint64_t _isRootOrRoleAccountUserName(const __CFString *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (CFEqual(a1, @"root")) {
    return 1LL;
  }
  if (!CFStringGetLength(a1) || CFStringGetCharacterAtIndex(a1, 0LL) != 95) {
    return 0LL;
  }
  uint64_t v16 = 0LL;
  CFStringRef v17 = &v16;
  uint64_t v18 = 0x2020000000LL;
  char v19 = 0;
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    size_t v4 = getpwnam(CStringPtr);
    if (v4) {
      BOOL v5 = v4->pw_uid < 0x1F5;
    }
    else {
      BOOL v5 = 0;
    }
    *((_BYTE *)v17 + 24) = v5;
  }

  else
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    size_t v9 = MaximumSizeForEncoding + 1;
    if ((unint64_t)(MaximumSizeForEncoding + 1) < 0x101)
    {
      if (MaximumSizeForEncoding == -1)
      {
        CFStringRef v10 = 0LL;
      }

      else
      {
        MEMORY[0x1895F8858](MaximumSizeForEncoding, v8);
        CFStringRef v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      }
    }

    else
    {
      CFStringRef v10 = (char *)malloc(MaximumSizeForEncoding + 1);
    }

    bzero(v10, v9);
    int CString = CFStringGetCString(a1, v10, v9, 0x8000100u);
    if (v10 && CString)
    {
      BOOL v12 = getpwnam(v10);
      if (v12) {
        BOOL v13 = v12->pw_uid < 0x1F5;
      }
      else {
        BOOL v13 = 0;
      }
      *((_BYTE *)v17 + 24) = v13;
    }

    if (v9 >= 0x101) {
      free(v10);
    }
  }

  BOOL v2 = *((_BYTE *)v17 + 24) != 0;
  _Block_object_dispose(&v16, 8);
  return v2;
}

void sub_180BC2680(_Unwind_Exception *a1)
{
}

void sub_180BC2A14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

uint64_t indexSearchCallback(void *a1, uint64_t a2)
{
  uint64_t result = objc_opt_isKindOfClass();
  if ((result & 1) != 0)
  {
    uint64_t result = [a1 shmemIndex];
    if (*(_DWORD *)a2 == (_DWORD)result) {
      **(void **)(a2 + _Block_object_dispose((const void *)(v1 - 72), 8) = a1;
    }
  }

  return result;
}

void sub_180BC3600( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41)
{
}

void __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

uint64_t _CFPrefsCopyEntitlementForMessage(void *a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v9 = 0LL;
  CFStringRef v10 = &v9;
  uint64_t v11 = 0x3052000000LL;
  BOOL v12 = __Block_byref_object_copy__5;
  BOOL v13 = __Block_byref_object_dispose__5;
  uint64_t v14 = 0LL;
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    BOOL value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    remote_connection = value;
    if (!value || object_getClass(value) != (Class)MEMORY[0x1895F9238]) {
      __assert_rtn( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  393,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
    }
  }

  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 3221225472LL;
  uint64_t v8[2] = ___CFPrefsCopyEntitlementForMessage_block_invoke;
  uint64_t v8[3] = &unk_1899EE060;
  v8[4] = a1;
  v8[5] = &v9;
  void v8[6] = a2;
  withClientContext(remote_connection, (uint64_t)v8);
  uint64_t v6 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_180BC3E08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

xpc_object_t createErrorReply(const char *a1, xpc_object_t original)
{
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (!reply) {
    xpc_object_t reply = xpc_dictionary_create(0LL, 0LL, 0LL);
  }
  populateErrorReply(a1, reply, 1u);
  return reply;
}

void log_client_activity(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  uint64_t v6 = (os_log_s *)_CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    size_t v18 = 0LL;
    data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &v18);
    if (data && v18 == 32)
    {
      __int128 v8 = data[1];
      __int128 buffer = *data;
      *(_OWORD *)pid = v8;
    }

    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        BOOL value = xpc_dictionary_get_value(a1, "connection");
      }

      xpc_connection_get_audit_token();
    }

    int v12 = pid[1];
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 buffer = 0u;
    *(_OWORD *)pid = 0u;
    if (v12 != -1 && (proc_name(v12, &buffer, 0x40u) & 0x80000000) == 0)
    {
      BOOL v13 = (os_log_s *)_CFPrefsDaemonLog();
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
      if (a3)
      {
        if (v14)
        {
          LODWORD(v1_Block_object_dispose(va, 8) = 67240962;
          HIDWORD(v1_Block_object_dispose(va, 8) = v12;
          __int16 v19 = 2082;
          p___int128 buffer = &buffer;
          __int16 v21 = 2082;
          uint64_t v22 = a2;
          __int16 v23 = 2082;
          uint64_t v24 = a3;
          uint64_t v15 = "Process %{public}d (%{public}s) %{public}s for domain %{public}s";
          uint64_t v16 = v13;
          uint32_t v17 = 38;
LABEL_17:
          _os_log_debug_impl(&dword_180A4C000, v16, OS_LOG_TYPE_DEBUG, v15, (uint8_t *)&v18, v17);
        }
      }

      else if (v14)
      {
        LODWORD(v1_Block_object_dispose(va, 8) = 67240706;
        HIDWORD(v1_Block_object_dispose(va, 8) = v12;
        __int16 v19 = 2082;
        p___int128 buffer = &buffer;
        __int16 v21 = 2082;
        uint64_t v22 = a2;
        uint64_t v15 = "Process %{public}d (%{public}s) %{public}s";
        uint64_t v16 = v13;
        uint32_t v17 = 28;
        goto LABEL_17;
      }
    }
  }

void sub_180BC4C34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void client_context_finalizer(uint64_t a1)
{
  uint64_t v1 = (os_unfair_lock_s *)(a1 + 48);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 48));
  uint64_t v2 = a1;
  if (*(_BYTE *)(a1 + 57)) {
    client_context_finalizer_cold_1();
  }
  __int128 v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    uint64_t v2 = a1;
  }

  size_t v4 = *(void **)(v2 + 32);
  if (v4)
  {
    xpc_release(v4);
    uint64_t v2 = a1;
  }

  BOOL v5 = *(const void **)(v2 + 40);
  if (v5) {
    CFRelease(v5);
  }
  os_unfair_lock_unlock(v1);
}

void __CFXPreferencesDaemon_main(int a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (a1 >= 1)
  {
    isCFPrefsD = 1;
    if (setiopolicy_np(9, 0, 1) < 0)
    {
      uint64_t v1 = (os_log_s *)_CFPrefsDaemonLog();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      {
        int v2 = *__error();
        v8[0] = 67109120;
        v8[1] = v2;
        _os_log_error_impl( &dword_180A4C000,  v1,  OS_LOG_TYPE_ERROR,  "An error occurred while setting iopolicy: %{darwin.errno}d",  (uint8_t *)v8,  8u);
      }
    }

    __int128 v3 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    size_t v4 = dispatch_queue_create("com.apple.cfprefsd", v3);
    signal(15, (void (__cdecl *)(int))1);
    signal(30, (void (__cdecl *)(int))1);
    __CFXPreferencesDaemon_main_sigtermHandler = (uint64_t)dispatch_source_create(MEMORY[0x1895F8B68], 0xFuLL, 0LL, v4);
    dispatch_source_set_event_handler( (dispatch_source_t)__CFXPreferencesDaemon_main_sigtermHandler,  &__block_literal_global_130);
    dispatch_resume((dispatch_object_t)__CFXPreferencesDaemon_main_sigtermHandler);
    BOOL v5 = objc_alloc(&OBJC_CLASS___CFPrefsDaemon);
    else {
      BOOL v7 = getenv("__CFPreferencesTestDaemon") != 0LL;
    }
    cfprefsd = (uint64_t)-[CFPrefsDaemon initWithRole:testMode:](v5, v6, v7);
    [(id)cfprefsd enterSandbox];
    __CFXPreferencesDaemon_main_sigusrHandler = (uint64_t)dispatch_source_create(MEMORY[0x1895F8B68], 0x1EuLL, 0LL, v4);
    dispatch_source_set_event_handler( (dispatch_source_t)__CFXPreferencesDaemon_main_sigusrHandler,  &__block_literal_global_132);
    dispatch_resume((dispatch_object_t)__CFXPreferencesDaemon_main_sigusrHandler);
    dispatch_main();
  }

  printf("cfprefsd is not intended to be used directly");
  exit(0);
}

void sub_180BC57F8(_Unwind_Exception *a1)
{
}

void __dumpDebugInfoCallback_block_invoke(uint64_t a1)
{
  int v2 = (const __CFString *)[*(id *)(a1 + 32) debugDump];
  CFStringAppend(*(CFMutableStringRef *)(a1 + 40), v2);
  CFRelease(v2);
  __int128 v3 = (const void *)[*(id *)(a1 + 32) copyUncanonicalizedPath];
  if (v3)
  {
    size_t v4 = v3;
    if (CFSetContainsValue(*(CFSetRef *)(a1 + 48), v3)) {
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0LL, @"\nPATH COLLISION: %@\n", v4);
    }
    else {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v4);
    }
    CFRelease(v4);
  }

void OUTLINED_FUNCTION_0_32(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

void OUTLINED_FUNCTION_1_22( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void _CFPrefsDictionaryApplyBlock(const __CFDictionary *a1, void *context)
{
}

uint64_t applyBlockApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

BOOL _CFPrefsArmPendingKVOSlot()
{
  uint64_t v0 = _CFGetTSD(0x10u);
  if (!v0) {
    _CFSetTSD(0x10u, 16LL, (uint64_t)dummyKVODestructor);
  }
  return v0 == 0;
}

void sub_180BC61F0(_Unwind_Exception *a1)
{
}

void *_CFUnsandboxedHomeDirectoryForCurrentUser()
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  uid_t v0 = geteuid();
  uid_t v1 = getuid();
  if (v0) {
    uid_t v1 = v0;
  }
  int v2 = getpwuid(v1);
  if (!v2
    || (pw_dir = (const UInt8 *)v2->pw_dir) == 0LL
    || (size_t v4 = strnlen(v2->pw_dir, 0x400uLL),
        (BOOL v5 = (const UInt8 *)CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  pw_dir,  v4,  1u)) == 0LL))
  {
    uint64_t v6 = __CFgetenv("HOME");
    BOOL v5 = (const UInt8 *)v6;
    if (v6)
    {
      size_t v7 = strnlen(v6, 0x400uLL);
      BOOL v5 = (const UInt8 *)CFURLCreateFromFileSystemRepresentation( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v5,  v7,  1u);
    }
  }

  bzero(buffer, 0x400uLL);
  CFURLGetFileSystemRepresentation((CFURLRef)v5, 1u, buffer, 1024LL);
  size_t v8 = strnlen((const char *)buffer, 0x400uLL);
  uint64_t v9 = malloc(v8 + 1);
  memmove(v9, buffer, v8);
  *((_BYTE *)v9 + v_Block_object_dispose((const void *)(v1 - 120), 8) = 0;
  if (v5) {
    CFRelease(v5);
  }
  return v9;
}

void sub_180BC6910(_Unwind_Exception *a1)
{
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void _CFPrefsResetManagedPreferencesStateCache()
{
  CFMutableStringRef Mutable = (__CFDictionary *)locked_getManagedStateCache_knownContainerizedManagedPrefsStates;
  if (!locked_getManagedStateCache_knownContainerizedManagedPrefsStates)
  {
    CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    locked_getManagedStateCache_knownContainerizedManagedPrefsStates = (uint64_t)Mutable;
  }

  CFDictionaryRemoveAllValues(Mutable);
  uint64_t v1 = (__CFDictionary *)locked_getManagedStateCache_knownManagedPrefsStates;
  if (!locked_getManagedStateCache_knownManagedPrefsStates)
  {
    uint64_t v1 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    locked_getManagedStateCache_knownManagedPrefsStates = (uint64_t)v1;
  }

  CFDictionaryRemoveAllValues(v1);
  os_unfair_lock_unlock((os_unfair_lock_t)&managedPreferencesLock);
}

void sub_180BC6BA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void sub_180BC6D28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BC6E50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BC6FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_180BC70F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t synchronizeApplier(uint64_t a1, void *a2)
{
  return [a2 synchronize];
}

void sub_180BC7260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t _CFPrefsGetCacheStringForBundleID(__CFString *a1)
{
  uint64_t v1 = (unint64_t *)_CFPrefsCurrentAppIdentifierCache;
  BOOL v2 = a1 == @"kCFPreferencesCurrentApplication" || _CFPrefsCurrentAppIdentifierCache == (void)a1;
  if (v2 || CFEqual(a1, @"kCFPreferencesCurrentApplication"))
  {
    if (!v1)
    {
      if ((MainBundle = CFBundleGetMainBundle()) != 0LL
        && (CFLocaleIdentifier Identifier = CFBundleGetIdentifier(MainBundle)) != 0LL
        && (uint64_t v1 = (unint64_t *)Identifier, CFStringGetLength(Identifier))
        || (uint64_t v1 = (unint64_t *)_CFProcessNameString()) != 0LL)
      {
        size_t v7 = _CFStringCopyBundleUnloadingProtectedString(v1);
        uint64_t v1 = (unint64_t *)v7;
        while (!__ldaxr((unint64_t *)&_CFPrefsCurrentAppIdentifierCache))
        {
        }

        __clrex();
        CFRelease(v7);
        return _CFPrefsCurrentAppIdentifierCache;
      }
    }
  }

  else if (!v1 || !CFEqual(v1, a1))
  {
    uint64_t v1 = (unint64_t *)@"kCFPreferencesAnyApplication";
    if (!CFEqual(a1, @"kCFPreferencesAnyApplication")
      && !CFEqual(a1, @"Apple Global Domain")
      && !CFEqual(a1, @".GlobalPreferences"))
    {
      return (uint64_t)a1;
    }
  }

  return (uint64_t)v1;
}

void sub_180BC7720(_Unwind_Exception *a1)
{
}

void sub_180BC7930( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BC7C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_180BC7F94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  if ((v10 & 1) != 0) {
    objc_end_catch();
  }
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 88), 8);
  _Unwind_Resume(a1);
}

void withKeysAndValues(const __CFDictionary *a1, uint64_t a2)
{
  v16[1] = *MEMORY[0x1895F89C0];
  if (a1)
  {
    unint64_t Count = CFDictionaryGetCount(a1);
    uint64_t v6 = 2 * Count;
    if (((Count >> 59) & 0xF) != 0)
    {
      CFStringRef v12 = CFStringCreateWithFormat( 0LL,  0LL,  @"*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt",  v6);
      BOOL v13 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSGenericException",  v12,  0LL);
      CFRelease(v12);
      objc_exception_throw(v13);
      _Unwind_Resume(v14);
    }

    if (Count)
    {
      unint64_t v7 = MEMORY[0x1895F8858](v6, v4);
      uint64_t v9 = (const void **)((char *)v16 - v8);
      if (v7 >= 0x101)
      {
        char v10 = (const void **)_CFCreateArrayStorage(v7, 0, v16);
        uint64_t v9 = v10;
LABEL_9:
        uint64_t v11 = &v9[Count];
        CFDictionaryGetKeysAndValues(a1, v9, v11);
        goto LABEL_10;
      }
    }

    else
    {
      MEMORY[0x1895F8858](v6, v4);
      uint64_t v9 = (const void **)v15;
    }

    char v10 = 0LL;
    goto LABEL_9;
  }

  MEMORY[0x1895F8858](0LL, a2);
  uint64_t v11 = (const void **)v15;
  char v10 = 0LL;
  unint64_t Count = 0LL;
  uint64_t v9 = (const void **)v15;
LABEL_10:
  (*(void (**)(uint64_t, const void **, const void **, unint64_t))(a2 + 16))(a2, v9, v11, Count);
  free(v10);
}

void sub_180BC8E50( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BC90C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BC9484( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BC95AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BC9958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_180BC9B2C(_Unwind_Exception *a1)
{
}

void sub_180BC9CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_180BC9DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void _CFPrefsDeliverPendingKVONotificationsGuts(const __CFArray *a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  &kCFTypeDictionaryValueCallBacks);
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v4 = Count;
    for (CFIndex i = 0LL; i != v4; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      uint64_t v8 = ValueAtIndex;
      if (ValueAtIndex) {
        id Property = objc_getProperty(ValueAtIndex, v7, 8LL, 1);
      }
      else {
        id Property = 0LL;
      }
      Value = (void *)CFDictionaryGetValue(Mutable, Property);
      if (!Value)
      {
        Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
        if (v8) {
          id v12 = objc_getProperty(v8, v11, 8LL, 1);
        }
        else {
          id v12 = 0LL;
        }
        CFDictionarySetValue(Mutable, v12, Value);
        CFRelease(Value);
      }

      CFArrayAppendValue((CFMutableArrayRef)Value, v8);
    }
  }

  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)applyBlockApplier, &__block_literal_global_187);
  CFRelease(Mutable);
}

void sub_180BCA1F0(_Unwind_Exception *a1)
{
}

void sub_180BCA20C()
{
}

void sub_180BCA444( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BCAB84( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_180BCADB8(_Unwind_Exception *a1)
{
}

void _CFPrefsSetDirectModeConnection(void *a1)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v2 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v2 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v3 = (id)v2;
  -[_CFXPreferences _replaceDirectConnection:](v2, a1);
}

void *_CFPrefsCopyDirectModeConnection()
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uid_t v0 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uid_t v0 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v1 = -[_CFXPreferences _copyDaemonConnectionSettingUpIfNecessaryForRole:andUserIdentifier:](v0, 2);

  return v1;
}

void sub_180BCB3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_180BCB50C(_Unwind_Exception *exception_object)
{
  if ((v1 & 1) != 0) {
    objc_end_catch();
  }
  _Unwind_Resume(exception_object);
}

uint64_t _CFGetCachedUnsandboxedHomeDirectoryForCurrentUser()
{
  if (_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_onceToken != -1) {
    dispatch_once(&_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_onceToken, &__block_literal_global_151);
  }
  return _CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_unsandboxedHomePath;
}

void _CFPrefsResetPreferences(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  uint64_t v2 = _os_activity_create( &dword_180A4C000,  "Resetting CFPreferences/NSUserDefaults",  MEMORY[0x1895F8D48],  OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v2, &state);
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    id v3 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    id v3 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  [v3 resetPreferences:a1];

  os_activity_scope_leave(&state);
}

void sub_180BCBD38( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state)
{
}

void _CFPreferencesRegisterStandardUserDefaultsExists()
{
  if (_CFPreferencesRegisterStandardUserDefaultsExists_onceToken != -1) {
    dispatch_once(&_CFPreferencesRegisterStandardUserDefaultsExists_onceToken, &__block_literal_global_152);
  }
}

uint64_t _CFPreferencesDoesNSUserDefaultsExist()
{
  return _NSUserDefaultsRegisteredAtLeastOnce;
}

id _CFPreferencesCopyStandardUserDefaults()
{
  if (_NSUserDefaultsRegisteredAtLeastOnce != 1) {
    return 0LL;
  }
  uid_t v0 = (void *)objc_opt_class();
  return objc_msgSend(v0, sel_registerName("_copyStandardUserDefaultsIfPresent"));
}

void _CFPrefsRegisterUserDefaultsInstanceWithCloudConfigurationURL(uint64_t a1, uint64_t a2)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    CFIndex v4 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    CFIndex v4 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v5 = v4;
  [v4 registerUserDefaultsInstance:a1 configurationURL:a2];
}

void _CFPrefsRegisterUserDefaultsInstance(uint64_t a1)
{
}

void _CFPrefsUnregisterUserDefaultsInstance(uint64_t a1)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v2 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v3 = v2;
  [v2 unregisterUserDefaultsInstance:a1];
}

CFStringRef _CFXPreferencesGetByHostIdentifierString()
{
  return &stru_1899EF170;
}

uint64_t _CFPreferencesCopyValueNoCache(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _CFPreferencesCopyValueWithContainer(a1, a2, a3, a4, 0LL);
}

CFPropertyListRef CFPreferencesCopyValue( CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)_CFPreferencesCopyValueWithContainer( (uint64_t)key,  (uint64_t)applicationID,  (uint64_t)userName,  (uint64_t)hostName,  0LL);
}

CFDictionaryRef __CFXPreferencesCopyCurrentApplicationStateWithDeadlockAvoidance(_BYTE *a1)
{
  uint64_t v2 = _CFGetTSD(0xFu);
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    id v3 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v4 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    id v3 = (void *)v4;
    if (!v2 && v4)
    {
      *a1 = 0;
      CFMutableDictionaryRef v5 = -[_CFXPreferences copyDictionaryForApp:withContainer:](v4, @"kCFPreferencesCurrentApplication", 0LL);

      return v5;
    }
  }

  *a1 = 1;

  return CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
}

CFDictionaryRef __CFXPreferencesCopyCurrentApplicationState()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  return __CFXPreferencesCopyCurrentApplicationStateWithDeadlockAvoidance(&v1);
}

void _CFXPreferencesRegisterDefaultValues(uint64_t a1)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v2 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v3 = v2;
  [v2 registerDefaultValues:a1];
}

void _CFXPreferencesReplaceValuesInNamedVolatileSource(uint64_t a1, const __CFDictionary *a2)
{
  void v6[6] = *MEMORY[0x1895F89C0];
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v5 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    uint64_t v4 = (void *)v5;
    if (v5)
    {
      v6[0] = MEMORY[0x1895F87A8];
      v6[1] = 3221225472LL;
      CFMutableDictionaryRef v6[2] = __65___CFXPreferences_replaceValuesInVolatileSourceNamed_withValues___block_invoke;
      _OWORD v6[3] = &unk_1899EE2C8;
      void v6[4] = v5;
      v6[5] = a1;
      withKeysAndValues(a2, (uint64_t)v6);
    }
  }
}

uint64_t _CFXPreferencesCopyVolatileSourceNames()
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uid_t v0 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uid_t v0 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v1 = -[_CFXPreferences volatileSourceNames]((uint64_t)v0);

  return v1;
}

uint64_t _CFXPreferencesCopyDictionaryForNamedVolatileSource(__CFString *a1)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v2 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v3 = -[_CFXPreferences copyDictionaryForVolatileSourceWithName:]((uint64_t)v2, a1);

  return v3;
}

void _CFXPreferencesRemoveNamedVolatileSource(__CFString *a1)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v2 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v2 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v3 = (id)v2;
  -[_CFXPreferences removeVolatileSourceForName:](v2, a1);
}

CFMutableDictionaryRef _CFPrefsCopyAppDictionaryWithContainer(__CFString *a1, const __CFString *a2)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v4 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  CFMutableDictionaryRef v5 = -[_CFXPreferences copyDictionaryForApp:withContainer:]((uint64_t)v4, a1, a2);

  return v5;
}

CFMutableDictionaryRef _CFPrefsCopyAppDictionary(__CFString *a1)
{
  return _CFPrefsCopyAppDictionaryWithContainer(a1, 0LL);
}

CFMutableDictionaryRef _CFXPreferencesCopyDictionaryForApplicationPreferences()
{
  return _CFPrefsCopyAppDictionaryWithContainer(@"kCFPreferencesCurrentApplication", 0LL);
}

CFMutableDictionaryRef _CFXPreferencesCopyDictionaryForSourceWithBundleID(__CFString *a1)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v2 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  CFMutableDictionaryRef v3 = -[_CFXPreferences copyDictionaryForSourceWithIdentifier:]((uint64_t)v2, a1);

  return v3;
}

void _CFXPreferencesReplaceValuesInSourceWithBundleIDWithContainer( uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v12[9] = *MEMORY[0x1895F89C0];
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    char v10 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v11 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    char v10 = (void *)v11;
    if (v11)
    {
      v12[0] = MEMORY[0x1895F87A8];
      v12[1] = 3221225472LL;
      _OWORD v12[2] = __85___CFXPreferences_replaceValuesInSourceForIdentifier_user_host_container_withValues___block_invoke;
      v12[3] = &unk_1899EE378;
      void v12[4] = v11;
      v12[5] = a1;
      v12[6] = a3;
      v12[7] = a4;
      void v12[8] = a5;
      withKeysAndValues(a2, (uint64_t)v12);
    }
  }
}

void _CFXPreferencesReplaceValuesInSourceWithBundleID(uint64_t a1, const __CFDictionary *a2)
{
}

void CFPreferencesFlushCaches()
{
}

uint64_t _CFPreferencesCopyAppValueWithContainerAndConfiguration( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v9 = [v8 copyAppValueForKey:a1 identifier:a2 container:a3 configurationURL:a4];

  return v9;
}

uint64_t _CFPreferencesCopyAppValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0LL);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)_CFPreferencesCopyAppValueWithContainerAndConfiguration( (uint64_t)key,  (uint64_t)applicationID,  0LL,  0LL);
}

BOOL _CFPreferencesGetAppBooleanValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, Boolean *a4)
{
  CFMutableDictionaryRef v5 = (__objc2_class **)_CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0LL);
  BOOL BooleanValueWithValue = _CFPreferencesGetBooleanValueWithValue(v5, a4);
  if (v5) {
    CFRelease(v5);
  }
  return BooleanValueWithValue;
}

BOOL _CFPreferencesGetBooleanValueWithValue(__objc2_class **cf, Boolean *a2)
{
  v9[1] = *(double *)MEMORY[0x1895F89C0];
  if (!cf) {
    goto LABEL_26;
  }
  if (&__kCFBooleanTrue == cf) {
    goto LABEL_11;
  }
  if (&__kCFBooleanFalse == cf)
  {
LABEL_24:
    if (a2)
    {
      BOOL result = 0LL;
      *a2 = 1;
      return result;
    }

    return 0LL;
  }

  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != 22)
  {
    if (v4 == 7)
    {
      if (CFStringCompare((CFStringRef)cf, @"YES", 1uLL) == kCFCompareEqualTo
        || CFStringCompare((CFStringRef)cf, @"true", 1uLL) == kCFCompareEqualTo)
      {
        goto LABEL_11;
      }

      if (CFStringCompare((CFStringRef)cf, @"NO", 1uLL) == kCFCompareEqualTo
        || CFStringCompare((CFStringRef)cf, @"false", 1uLL) == kCFCompareEqualTo)
      {
        goto LABEL_24;
      }

      if (CFEqual(cf, @"1"))
      {
LABEL_11:
        BOOL result = 1LL;
        if (a2) {
          *a2 = 1;
        }
        return result;
      }

      if (CFEqual(cf, @"0")) {
        goto LABEL_24;
      }
    }

Boolean CFPreferencesGetAppBooleanValue( CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppBooleanValueWithContainer( (uint64_t)key,  (uint64_t)applicationID,  0LL,  keyExistsAndHasValidFormat);
}

uint64_t _CFPreferencesGetAppIntegerValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, BOOL *a4)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  CFMutableDictionaryRef v5 = (const __CFNumber *)_CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0LL);
  if (v5)
  {
    uint64_t v6 = v5;
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 == 22)
    {
      int IsFloatType = CFNumberIsFloatType(v6);
      if (a4) {
        *a4 = IsFloatType == 0;
      }
      CFNumberGetValue(v6, kCFNumberCFIndexType, &valuePtr);
      goto LABEL_22;
    }

    if (v7 != 7)
    {
      if (v7 != CFBooleanGetTypeID())
      {
        uint64_t valuePtr = 0LL;
        if (a4) {
          *a4 = 0;
        }
        goto LABEL_22;
      }

      if (a4) {
        *a4 = 1;
      }
      uint64_t v12 = v6 == (const __CFNumber *)&__kCFBooleanTrue;
LABEL_21:
      uint64_t valuePtr = v12;
LABEL_22:
      CFRelease(v6);
      return valuePtr;
    }

    HIDWORD(v15) = 0;
    size_t v18 = v6;
    uint64_t v21 = 0LL;
    CFIndex Length = CFStringGetLength((CFStringRef)v6);
    CharactersPtr = CFStringGetCharactersPtr((CFStringRef)v6);
    CStringPtr = 0LL;
    __int16 v19 = CharactersPtr;
    if (!CharactersPtr) {
      CStringPtr = CFStringGetCStringPtr((CFStringRef)v6, 0x600u);
    }
    uint64_t v23 = 0LL;
    uint64_t v24 = 0LL;
    uint64_t v20 = CStringPtr;
    if (__CFStringScanInteger(buffer, 0LL, (int *)&v15 + 1, 0, &v15))
    {
      uint64_t v10 = SHIDWORD(v15);
      BOOL v11 = CFStringGetLength((CFStringRef)v6) == v10;
      if (!a4) {
        goto LABEL_9;
      }
    }

    else
    {
      BOOL v11 = 0;
      if (!a4)
      {
LABEL_9:
        if (v11) {
          uint64_t v12 = (int)v15;
        }
        else {
          uint64_t v12 = 0LL;
        }
        goto LABEL_21;
      }
    }

    *a4 = v11;
    goto LABEL_9;
  }

  uint64_t result = 0LL;
  if (a4) {
    *a4 = 0;
  }
  return result;
}

CFIndex CFPreferencesGetAppIntegerValue( CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppIntegerValueWithContainer( (uint64_t)key,  (uint64_t)applicationID,  0LL,  (BOOL *)keyExistsAndHasValidFormat);
}

void _CFPreferencesSetAppValueWithContainerAndConfiguration( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v10 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v11 = v10;
  [v10 setValue:a2 forKey:a1 appIdentifier:a3 container:a4 configurationURL:a5];
}

void _CFPreferencesSetAppValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

void _CFPreferencesSetAppCloudSyncEnabled(uint64_t a1, int a2, __CFString *a3, const __CFString *a4)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v8 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v9 = (id)v8;
  -[_CFXPreferences setCloudSyncEnabled:forKey:appIdentifier:container:](v8, a2 != 0, a1, a3, a4);
}

void _CFPreferencesAppFullCloudSynchronizeWithConfiguration( __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4)
{
  void v10[5] = *MEMORY[0x1895F89C0];
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v9 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    uint64_t v8 = (void *)v9;
    if (v9)
    {
      v10[0] = MEMORY[0x1895F87A8];
      v10[1] = 3221225472LL;
      _OWORD v10[2] = __101___CFXPreferences_fullCloudSynchronizeForAppIdentifier_container_configurationURL_completionHandler___block_invoke;
      _OWORD v10[3] = &unk_1899EE258;
      v10[4] = a4;
      -[_CFXPreferences withSearchListForIdentifier:container:cloudConfigurationURL:perform:]( v9,  a1,  a2,  a3,  (uint64_t)v10);
    }
  }
}

void _CFPreferencesAppFullCloudSynchronize(__CFString *a1, const __CFString *a2, uint64_t a3)
{
}

BOOL _CFPreferencesHasAppCloudValue(uint64_t a1, __CFString *a2, const __CFString *a3, uint64_t a4)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  BOOL v9 = -[_CFXPreferences hasCloudValueForKey:appIdentifier:container:configurationURL:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

BOOL _CFPreferencesHasAppValue(uint64_t a1, __CFString *a2, const __CFString *a3, uint64_t a4)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  BOOL v9 = -[_CFXPreferences hasNonRegisteredValueForKey:appIdentifier:container:configurationURL:]( (uint64_t)v8,  a1,  a2,  a3,  a4);

  return v9;
}

void _CFPreferencesAddSuitePreferencesToAppWithContainer(const void *a1, const void *a2, uint64_t a3)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v6 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v6 = (os_unfair_lock_s *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  CFTypeID v7 = v6;
  -[_CFXPreferences addSuitePreferences:toAppIdentifier:container:](v6, a2, a1, a3);
}

void CFPreferencesAddSuitePreferencesToApp(CFStringRef applicationID, CFStringRef suiteID)
{
}

void _CFPreferencesRemoveSuitePreferencesFromAppWithContainer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v6 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v6 = (os_unfair_lock_s *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  CFTypeID v7 = v6;
  -[_CFXPreferences removeSuite:fromApp:withContainer:](v6, a2, a1, a3);
}

void CFPreferencesRemoveSuitePreferencesFromApp(CFStringRef applicationID, CFStringRef suiteID)
{
}

uint64_t _CFPreferencesAppSynchronizeWithContainer(__CFString *a1, const __CFString *a2)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    CFTypeID v4 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    CFTypeID v4 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v5 = -[_CFXPreferences appSynchronizeWithIdentifier:container:]((uint64_t)v4, a1, a2);

  return v5;
}

void _CFPreferencesAppPreload(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    if (v8)
    {
      id v9 = v8;
      +[CFPrefsSearchListSource preloadDomainsForIdentifiers:containers:cloudConfigurationURLs:count:containingPreferences:]( &OBJC_CLASS___CFPrefsSearchListSource,  a1,  a2,  a3,  a4,  v8);
      uint64_t v8 = v9;
    }
  }
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v2 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  Boolean v3 = -[_CFXPreferences appSynchronizeWithIdentifier:container:]((uint64_t)v2, (__CFString *)applicationID, 0LL);

  return v3;
}

uint64_t _CFPreferencesCopyValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v10 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v11 = [v10 copyValueForKey:a1 identifier:a2 user:a3 host:a4 container:a5];

  return v11;
}

CFMutableDictionaryRef _CFPreferencesCopyMultipleWithContainer( uint64_t a1, __CFString *a2, const __CFString *a3, const void *a4, const __CFString *a5)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v10 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  CFMutableDictionaryRef v11 = -[_CFXPreferences copyValuesForKeys:identifier:user:host:container:]((uint64_t)v10, a1, a2, a3, a4, a5);

  return v11;
}

CFDictionaryRef CFPreferencesCopyMultiple( CFArrayRef keysToFetch, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyMultipleWithContainer( (uint64_t)keysToFetch,  (__CFString *)applicationID,  userName,  hostName,  0LL);
}

void _CFPreferencesSetValueWithContainer( uint64_t a1, uint64_t a2, __CFString *a3, const __CFString *a4, const void *a5, const __CFString *a6)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v12 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v12 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v13 = (id)v12;
  -[_CFXPreferences setValue:forKey:identifier:user:host:container:](v12, a2, a1, a3, a4, a5, a6);
}

void CFPreferencesSetValue( CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
}

void CFPreferencesSetMultiple( CFDictionaryRef keysToSet, CFArrayRef keysToRemove, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v10 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v11 = (id)v10;
  -[_CFXPreferences setValuesForKeys:removingValuesForKeys:identifier:user:host:container:]( v10,  (uint64_t)keysToSet,  (uint64_t)keysToRemove,  (__CFString *)applicationID,  userName,  hostName,  0LL);
}

void _CFPreferencesSetAccessRestricted(__CFString *a1, int a2)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v4 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v5 = (id)v4;
  -[_CFXPreferences setAccessRestricted:forAppIdentifier:](v4, a2 != 0, a1);
}

void _CFPreferencesFlushCachesForIdentifier(__CFString *a1, uint64_t a2)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v4 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v5 = v4;
  -[_CFXPreferences flushCachesForAppIdentifier:user:](v4, a1, a2);
}

void _CFPreferencesNotifyOfImpendingUserDeletion()
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
  }

void _CFPreferencesSetBackupDisabled( __CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4, int a5)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v10 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v11 = (id)v10;
  -[_CFXPreferences setBackupDisabled:identifier:user:host:container:](v10, a5 != 0, a1, a2, a3, a4);
}

void _CFPreferencesSetFileProtectionClass( __CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4, int a5)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v10 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v11 = (id)v10;
  -[_CFXPreferences setFileProtectionClass:identifier:user:host:container:](v10, a5, a1, a2, a3, a4);
}

uint64_t _CFPreferencesGetFileProtectionClass( __CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v9 = -[_CFXPreferences fileProtectionClassForIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void _CFPreferencesSetDaemonCacheEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v10 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v11 = v10;
  [v10 setDaemonCacheEnabled:a5 != 0 identifier:a1 user:a2 host:a3 container:a4];
}

uint64_t _CFPreferencesSynchronizeWithContainer( __CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v9 = -[_CFXPreferences synchronizeIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesSynchronizeWithContainer((__CFString *)applicationID, userName, hostName, 0LL);
}

void _CFPrefsSynchronizeForProcessTermination()
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v0 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v0 = [(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  id v1 = (id)v0;
  -[_CFXPreferences synchronizeEverything](v0);
}

uint64_t _CFPreferencesCopyKeyListWithContainer( __CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  uint64_t v9 = -[_CFXPreferences copyKeyListForIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)_CFPreferencesCopyKeyListWithContainer((__CFString *)applicationID, userName, hostName, 0LL);
}

CFArrayRef CFPreferencesCopyApplicationList(CFStringRef userName, CFStringRef hostName)
{
  BOOL v3 = CFEqual(hostName, @"kCFPreferencesCurrentHost") != 0;
  return _CFPreferencesCopyApplicationList(userName, v3);
}

BOOL CFPreferencesIsManaged(const __CFString *a1, int a2)
{
  BOOL v3 = a1;
  if (CFEqual(a1, @"kCFPreferencesAnyUser")
    || CFEqual(v3, @"kCFPreferencesCurrentUser") && !cfprefsdEuid())
  {
    return _CFPrefsIsUserManaged(@"kCFPreferencesAnyUser", a2);
  }

  if (CFEqual(v3, @"kCFPreferencesCurrentUser"))
  {
    else {
      id v5 = CFCopyUserName();
    }
    BOOL v3 = v5;
  }

  else
  {
    CFRetain(v3);
  }

  BOOL IsUserManaged = _CFPrefsIsUserManaged(v3, a2);
  CFRelease(v3);
  return IsUserManaged;
}

BOOL _CFPrefsIsUserManaged(const void *a1, int a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)&managedPreferencesLock);
  ManagedStateCache = locked_getManagedStateCache(a2);
  Boolean Value = (const __CFNumber *)CFDictionaryGetValue(ManagedStateCache, a1);
  *(_DWORD *)uint64_t valuePtr = 0;
  if (!Value || !CFNumberGetValue(Value, kCFNumberIntType, valuePtr) || (int v6 = *(_DWORD *)valuePtr) == 0)
  {
    bzero(valuePtr, 0x400uLL);
    if (_CFPrefsGetPathForManagedBundleID(0LL, a1, a2, valuePtr))
    {
      else {
        int v6 = 1;
      }
    }

    else
    {
      int v6 = 0;
    }

    CFTypeID v7 = (os_log_s *)_CFPrefsClientLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
      _CFPrefsIsUserManaged_cold_1(v6, (uint64_t)a1, v7);
    }
    v11.st_dev = v6;
    uint64_t v8 = locked_getManagedStateCache(a2);
    CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberIntType, &v11);
    CFDictionarySetValue(v8, a1, v9);
    CFRelease(v9);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&managedPreferencesLock);
  return v6 == 1;
}

CFMutableDictionaryRef locked_getManagedStateCache(int a1)
{
  if (a1)
  {
    CFMutableDictionaryRef result = (CFMutableDictionaryRef)locked_getManagedStateCache_knownContainerizedManagedPrefsStates;
    if (!locked_getManagedStateCache_knownContainerizedManagedPrefsStates)
    {
      CFMutableDictionaryRef result = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      locked_getManagedStateCache_knownContainerizedManagedPrefsStates = (uint64_t)result;
    }
  }

  else
  {
    CFMutableDictionaryRef result = (CFMutableDictionaryRef)locked_getManagedStateCache_knownManagedPrefsStates;
    if (!locked_getManagedStateCache_knownManagedPrefsStates)
    {
      CFMutableDictionaryRef result = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      locked_getManagedStateCache_knownManagedPrefsStates = (uint64_t)result;
    }
  }

  return result;
}

Boolean CFPreferencesAppValueIsForced(CFStringRef key, CFStringRef applicationID)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    uint64_t v4 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    uint64_t v4 = (os_unfair_lock_s *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  Boolean v5 = -[_CFXPreferences appValueIsForcedForKey:appIdentifier:](v4, (uint64_t)key, (__CFString *)applicationID);

  return v5;
}

CFMutableDictionaryRef _CFPreferencesCopyMultipleManaged(uint64_t a1, __CFString *a2, int a3)
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    int v6 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    int v6 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  CFMutableDictionaryRef v7 = -[_CFXPreferences copyManagedValuesForKeys:identifier:useSystemContainer:]((uint64_t)v6, a1, a2, a3 != 0);

  return v7;
}

BOOL _CFPreferencesIsManaged()
{
  CFStringRef v0 = CFCopyUserName();
  else {
    id v1 = @"kCFPreferencesAnyUser";
  }
  BOOL IsManaged = CFPreferencesIsManaged(v1, 0);
  CFRelease(v0);
  return IsManaged;
}

unint64_t _CFPreferencesWriteDomainDictionaryToPath(unint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v3 = a1;
  uint64_t v15 = *MEMORY[0x1895F89C0];
  values = a3;
  if (a1)
  {
    uint64_t v4 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"%@/%@%@",  a2,  a3,  @".plist",  values);
    if (!v4)
    {
      unint64_t v3 = 0LL;
LABEL_17:
      CFArrayRef v11 = CFArrayCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const void **)&values,  1LL,  &kCFTypeArrayCallBacks);
      _CFPreferencesManagementStatusChangedForDomains();
      CFRelease(v11);
      return v3;
    }

    Boolean v5 = v4;
    CFURLRef v6 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, kCFURLPOSIXPathStyle, 0);
    if (!v6)
    {
      unint64_t v3 = 0LL;
LABEL_16:
      CFRelease(v5);
      goto LABEL_17;
    }

    CFMutableDictionaryRef v7 = v6;
    if (CFDictionaryGetCount((CFDictionaryRef)v3))
    {
      uint64_t v8 = CFWriteStreamCreateWithAllocatedBuffers( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (CFAllocatorRef)&__kCFAllocatorSystemDefault);
      CFWriteStreamOpen(v8);
      CFPropertyListWrite((CFPropertyListRef)v3, v8, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
      CFWriteStreamClose(v8);
      CFNumberRef v9 = (const __CFData *)CFWriteStreamCopyProperty(v8, @"kCFStreamPropertyDataWritten");
      CFRelease(v8);
      if (v9)
      {
        unint64_t v3 = CFURLWriteDataAndPropertiesToResource(v7, v9, 0LL, errorCode);
        goto LABEL_7;
      }
    }

    else
    {
      bzero(errorCode, 0x402uLL);
      if (CFURLGetFileSystemRepresentation(v7, 1u, (UInt8 *)errorCode, 1024LL))
      {
        unint64_t v3 = unlink((const char *)errorCode) == 0;
        CFURLRef PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
        if (!PathComponent) {
          goto LABEL_15;
        }
        CFNumberRef v9 = PathComponent;
        bzero(errorCode, 0x402uLL);
        if (CFURLGetFileSystemRepresentation(v9, 1u, (UInt8 *)errorCode, 1024LL)) {
          rmdir((const char *)errorCode);
        }
LABEL_7:
        CFRelease(v9);
LABEL_15:
        CFRelease(v7);
        goto LABEL_16;
      }
    }

    unint64_t v3 = 0LL;
    goto LABEL_15;
  }

  return v3;
}

uint64_t _CFPreferencesManagementStatusChangedForDomains()
{
  return notify_post("com.apple.CFPreferences._domainsChangedExternally");
}

unint64_t _CFPreferencesWriteManagedDomain(unint64_t a1, const void *a2, int a3, void *a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  BOOL v7 = a3 != 0;
  bzero(__s, 0x400uLL);
  if (!_CFPrefsGetPathForManagedBundleID(0LL, a2, v7, (UInt8 *)__s)) {
    return 0LL;
  }
  size_t v8 = strlen(__s);
  CFNumberRef v9 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)__s, v8, 1u);
  if (!v9) {
    return 0LL;
  }
  uint64_t v10 = v9;
  CFStringRef v11 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
  CFRelease(v10);
  if (!v11) {
    return 0LL;
  }
  unint64_t v12 = _CFPreferencesWriteDomainDictionaryToPath(a1, (uint64_t)v11, a4);
  CFRelease(v11);
  return v12;
}

unint64_t _CFPreferencesWriteManagedDomainForUser(unint64_t a1, const void *a2, void *a3)
{
  return _CFPreferencesWriteManagedDomain(a1, a2, 0, a3);
}

uint64_t _CFPrefsDirectModeEnabledForDomain( __CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v13 = 0LL;
  BOOL v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  char v16 = 0;
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    size_t v8 = 0LL;
  }

  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
    }
    size_t v8 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
  }

  BOOL v9 = CFEqual(a3, @"kCFPreferencesCurrentHost") != 0;
  v12[0] = MEMORY[0x1895F87A8];
  v12[1] = 3221225472LL;
  _OWORD v12[2] = ___CFPrefsDirectModeEnabledForDomain_block_invoke;
  v12[3] = &unk_1899EE148;
  void v12[4] = &v13;
  -[_CFXPreferences withSourceForIdentifier:user:byHost:container:cloud:perform:]( (uint64_t)v8,  a1,  a2,  v9,  a4,  0,  (uint64_t)v12);

  uint64_t v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_180BCE1C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void _handleExternalNotification(const __CFString *a1)
{
  if ((__CF_FORK_STATE & 2) == 0) {
    __CF_USED();
  }
  if ((__CF_FORK_STATE & 1) != 0) {
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
    {
      uint64_t v2 = 0LL;
    }

    else
    {
      if (_CFPrefsCopyDefaultPreferences_onceToken != -1) {
        dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_185);
      }
      uint64_t v2 = (void *)[(id)_CFPrefsCopyDefaultPreferences_defaultPrefs copyPrefs];
    }

    -[_CFXPreferences flushManagedSources](v2);

    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotificationWithOptions(DarwinNotifyCenter, a1, 0LL, 0LL, 0LL);
  }

uint64_t _CFPreferencesPostValuesChangedInDomains()
{
  return notify_post("com.apple.CFPreferences._domainsChangedExternally");
}

void sub_180BCE4CC(_Unwind_Exception *a1)
{
}

os_unfair_lock_s *__directCFPrefsD_block_invoke()
{
  CFStringRef v0 = objc_alloc(&OBJC_CLASS___CFPrefsDaemon);
  else {
    BOOL v1 = getenv("__CFPreferencesTestDaemon") != 0LL;
  }
  CFMutableDictionaryRef result = -[CFPrefsDaemon initWithRole:testMode:](v0, 2LL, v1);
  directCFPrefsD_daemon = (uint64_t)result;
  return result;
}

  ;
}

void OUTLINED_FUNCTION_1_23(uint64_t a1@<X8>)
{
  *(void *)(a1 + 2672) = v1;
  abort();
}

uint64_t (**__CFStringEncodingGetLatin2ConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_7) {
    __CFStringEncodingPrecomposeLatinCharacter_7 = (_UNKNOWN *)a2(4LL);
  }
  if (a1 > 513)
  {
    switch(a1)
    {
      case 514:
        return __CFConverterISOLatin2;
      case 1042:
        return __CFConverterDOSLatin2;
      case 1281:
        return __CFConverterWinLatin2;
    }
  }

  else
  {
    switch(a1)
    {
      case 29:
        return __CFConverterMacCentEuro;
      case 36:
        return __CFConverterMacCroatian;
      case 38:
        return __CFConverterMacRomanian;
    }
  }

  return 0LL;
}

uint64_t __CFToMacCentEuro(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9675 < 0xFFFFDAD5) {
    return 0LL;
  }
  Boolean v5 = (unsigned __int16 *)&maccenteuro_from_uni;
  CFURLRef v6 = (unsigned __int16 *)&unk_180D8000C;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    size_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFURLRef v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    Boolean v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

uint64_t __CFFromMacCentEuro(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = maccenteuro_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToMacCentEuroPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9675) >= 0xDAD5u)
    {
      CFStringRef v11 = (unsigned __int16 *)&maccenteuro_from_uni;
      unint64_t v12 = (unsigned __int16 *)&unk_180D8000C;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        BOOL v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          CFStringRef v11 = v14 + 2;
        }

        else
        {
          unint64_t v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFIsValidCombiningCharacterForLatin2(int a1)
{
  else {
    return (__CFLatin2CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
  }
}

uint64_t __CFToMacCroatian(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      uint64_t v4 = (unsigned __int16 *)&maccroatian_from_uni;
      Boolean v5 = (unsigned __int16 *)&unk_180D80318;
      do
      {
        uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
        uint64_t v7 = &v4[2 * v6];
        unsigned int v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }

          uint64_t v4 = v7 + 2;
        }

        else
        {
          Boolean v5 = v7 - 2;
        }
      }

      while (v4 <= v5);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a3 = a2;
    return 1LL;
  }

uint64_t __CFFromMacCroatian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    LOWORD(a2) = maccroatian_to_uni[a2 - 128];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToMacCroatianPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0LL);
  if (v9 <= 0x7F)
  {
    LOBYTE(v10) = v9;
    if (!(_BYTE)v9) {
      return 0LL;
    }
    goto LABEL_3;
  }

  unint64_t v12 = (unsigned __int16 *)&maccroatian_from_uni;
  uint64_t v13 = (unsigned __int16 *)&unk_180D80318;
  while (1)
  {
    uint64_t v14 = ((char *)v13 - (char *)v12) >> 3;
    unsigned int v15 = &v12[2 * v14];
    unsigned int v16 = *v15;
    if (v16 <= v9) {
      break;
    }
    uint64_t v13 = v15 - 2;
LABEL_12:
    if (v12 > v13) {
      return 0LL;
    }
  }

  if (v16 < v9)
  {
    unint64_t v12 = v15 + 2;
    goto LABEL_12;
  }

  int v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10) {
    return 0LL;
  }
LABEL_3:
  if (a5) {
    *a4 = v10;
  }
  *a6 = 1LL;
  return 2LL;
}

uint64_t __CFToMacRomanian(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4)
{
  unsigned int v4 = *a2;
  if (v4 > 0x7F)
  {
    if ((unsigned __int16)(v4 + 1792) >= 0x7A0u)
    {
      uint64_t v6 = (unsigned __int16 *)&macromanian_from_uni;
      uint64_t v7 = (unsigned __int16 *)&unk_180D80618;
      do
      {
        uint64_t v8 = ((char *)v7 - (char *)v6) >> 3;
        unsigned int v9 = &v6[2 * v8];
        unsigned int v10 = *v9;
        if (v10 <= v4)
        {
          if (v10 >= v4)
          {
            LOBYTE(v4) = v6[2 * v8 + 1];
            goto LABEL_2;
          }

          uint64_t v6 = v9 + 2;
        }

        else
        {
          uint64_t v7 = v9 - 2;
        }
      }

      while (v6 <= v7);
    }

    return 0LL;
  }

  else
  {
LABEL_2:
    *a4 = v4;
    return 1LL;
  }

BOOL __CFFromMacRomanian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = macromanian_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacRomanianLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    int v4 = *a2++;
    if (v4 != 806) {
      ++result;
    }
  }

  return result;
}

uint64_t __CFFromMacRomanianLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    int v4 = *a2++;
    uint64_t v5 = (1LL << (v4 + 81)) & 0x1800000010001LL;
    else {
      uint64_t v7 = 2LL;
    }
    result += v7;
  }

  return result;
}

uint64_t __CFToMacRomanianPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  if (a3 < 2 || a2[1] != 806)
  {
    unsigned int v12 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0LL);
    if (v12 <= 0x7F)
    {
      LOBYTE(v1__postAndResetMidnight(1, 1) = v12;
      if (!(_BYTE)v12) {
        return 0LL;
      }
      goto LABEL_10;
    }

    uint64_t v13 = (unsigned __int16 *)&macromanian_from_uni;
    uint64_t v14 = (unsigned __int16 *)&unk_180D80618;
    while (1)
    {
      uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
      unsigned int v16 = &v13[2 * v15];
      unsigned int v17 = *v16;
      if (v17 <= v12)
      {
        if (v17 >= v12)
        {
          int v11 = LOBYTE(v13[2 * v15 + 1]);
          if (!v11) {
            return 0LL;
          }
LABEL_10:
          if (a5) {
LABEL_11:
          }
            *a4 = v11;
LABEL_12:
          *a6 = 1LL;
          return 2LL;
        }

        uint64_t v13 = v16 + 2;
      }

      else
      {
        uint64_t v14 = v16 - 2;
      }

      if (v13 > v14) {
        return 0LL;
      }
    }
  }

  uint64_t result = 0LL;
  unsigned int v10 = *a2;
  if (v10 <= 0x72)
  {
    if (v10 == 83)
    {
      if (a5)
      {
        LOBYTE(v1__postAndResetMidnight(1, 1) = -81;
        goto LABEL_11;
      }
    }

    else
    {
      if (v10 != 84) {
        return result;
      }
      if (a5)
      {
        LOBYTE(v1__postAndResetMidnight(1, 1) = -34;
        goto LABEL_11;
      }
    }

    goto LABEL_12;
  }

  if (v10 == 115)
  {
    if (a5)
    {
      LOBYTE(v1__postAndResetMidnight(1, 1) = -65;
      goto LABEL_11;
    }

    goto LABEL_12;
  }

  if (v10 == 116)
  {
    if (a5)
    {
      LOBYTE(v1__postAndResetMidnight(1, 1) = -33;
      goto LABEL_11;
    }

    goto LABEL_12;
  }

  return result;
}

uint64_t __CFToDOSLatin2(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 > 0x7F)
  {
    if (a2 - 9633 >= 0xFFFFDAFF)
    {
      uint64_t v5 = (unsigned __int16 *)&cp852_from_uni;
      uint64_t v6 = (unsigned __int16 *)&unk_180D80918;
      do
      {
        uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
        uint64_t v8 = &v5[2 * v7];
        unsigned int v9 = *v8;
        if (v9 <= a2)
        {
          if (v9 >= a2)
          {
LABEL_19:
            char v3 = v5[2 * v7 + 1];
            goto LABEL_3;
          }

          uint64_t v5 = v8 + 2;
        }

        else
        {
          uint64_t v6 = v8 - 2;
        }
      }

      while (v5 <= v6);
      if (a2 - 734 >= 0xFFFFFDC2)
      {
        uint64_t v5 = (unsigned __int16 *)&latin2_from_uni;
        unsigned int v10 = (unsigned __int16 *)&unk_180D80A98;
        do
        {
          uint64_t v7 = ((char *)v10 - (char *)v5) >> 3;
          int v11 = &v5[2 * v7];
          unsigned int v12 = *v11;
          if (v12 <= a2)
          {
            if (v12 >= a2) {
              goto LABEL_19;
            }
            uint64_t v5 = v11 + 2;
          }

          else
          {
            unsigned int v10 = v11 - 2;
          }
        }

        while (v5 <= v10);
      }
    }

    return 0LL;
  }

  else
  {
    char v3 = a2;
LABEL_3:
    *a3 = v3;
    return 1LL;
  }

BOOL __CFFromDOSLatin2(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = cp852_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0LL);
  int v10 = __CFToDOSLatin2(v9, v9, &v13);
  uint64_t result = 0LL;
  if (v10) {
    BOOL v12 = v13 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a5) {
      *a4 = v13;
    }
    *a6 = 1LL;
    return 2LL;
  }

  return result;
}

uint64_t __CFToWinLatin2(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_19;
  }

  if (a2 - 8483 < 0xFFFFDF83)
  {
LABEL_10:
    if (a2 - 734 >= 0xFFFFFDC2)
    {
      int v4 = (unsigned __int16 *)&latin2_from_uni;
      uint64_t v9 = (unsigned __int16 *)&unk_180D80A98;
      do
      {
        uint64_t v6 = ((char *)v9 - (char *)v4) >> 3;
        int v10 = &v4[2 * v6];
        unsigned int v11 = *v10;
        if (v11 <= a2)
        {
          if (v11 >= a2) {
            goto LABEL_18;
          }
          int v4 = v10 + 2;
        }

        else
        {
          uint64_t v9 = v10 - 2;
        }
      }

      while (v4 <= v9);
    }

    return 0LL;
  }

  int v4 = (unsigned __int16 *)&cp1250_from_uni;
  uint64_t v5 = (unsigned __int16 *)&unk_180D80C40;
  while (1)
  {
    uint64_t v6 = ((char *)v5 - (char *)v4) >> 3;
    uint64_t v7 = &v4[2 * v6];
    unsigned int v8 = *v7;
    if (v8 <= a2) {
      break;
    }
    uint64_t v5 = v7 - 2;
LABEL_9:
    if (v4 > v5) {
      goto LABEL_10;
    }
  }

  if (v8 < a2)
  {
    int v4 = v7 + 2;
    goto LABEL_9;
  }

BOOL __CFFromWinLatin2(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = cp1250_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0LL);
  int v10 = __CFToWinLatin2(v9, v9, &v13);
  uint64_t result = 0LL;
  if (v10) {
    BOOL v12 = v13 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    if (a5) {
      *a4 = v13;
    }
    *a6 = 1LL;
    return 2LL;
  }

  return result;
}

uint64_t __CFToISOLatin2(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 734 < 0xFFFFFDC2) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&latin2_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180D80A98;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unsigned int v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

uint64_t __CFFromISOLatin2(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0x9F) {
    LOWORD(a2) = latin2_to_uni[a2 - 160];
  }
  *a3 = a2;
  return 1LL;
}

uint64_t __CFToISOLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  unsigned int v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0LL);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 734) >= 0xFDC2u)
    {
      unsigned int v11 = (unsigned __int16 *)&latin2_from_uni;
      BOOL v12 = (unsigned __int16 *)&unk_180D80A98;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        uint64_t v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          unsigned int v11 = v14 + 2;
        }

        else
        {
          BOOL v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

__objc2_class **__NSDictionaryImmutablePlaceholder()
{
  return &___immutablePlaceholderDictionary;
}

__objc2_class **__NSDictionaryMutablePlaceholder()
{
  return &___mutablePlaceholderDictionary;
}

void __NSCFDictionaryCreateTransfer( __objc2_class **a1, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  if (__FoundationPresent_static_init_0 != -1) {
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  }
  if (__FoundationPresent_present_0
    && (&__kCFAllocatorSystemDefault == a1
     || !a1 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault()))
  {
    if (a4 == 1)
    {
      __NSSingleEntryDictionaryI_new(*a2, *a3, 12);
    }

    else if (a4)
    {
      __NSDictionaryI_new((uint64_t *)a2, (uint64_t *)a3, 0LL, a4, 12LL);
    }

    else
    {
      unsigned int v8 = &__NSDictionary0__struct;
    }
  }

void __NSCFDictionaryCreate( __objc2_class **a1, unint64_t *a2, unint64_t *a3, unint64_t a4, const CFDictionaryKeyCallBacks *a5, const CFDictionaryValueCallBacks *a6)
{
  if (__FoundationPresent_static_init_0 != -1) {
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  }
  if (__FoundationPresent_present_0
    && (&__kCFAllocatorSystemDefault == a1
     || !a1 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault()))
  {
    BOOL v12 = a5 == &kCFCopyStringDictionaryKeyCallBacks || a5 == &kCFTypeDictionaryKeyCallBacks;
    if (v12 && a6 == &kCFTypeDictionaryValueCallBacks)
    {
      if (a5 == &kCFCopyStringDictionaryKeyCallBacks)
      {
        if (!a4)
        {
          size_t v18 = &__NSDictionary0__struct;
          return;
        }

        if (a4 == 1)
        {
          __NSSingleEntryDictionaryI_new(*a2, *a3, 1);
          return;
        }

        uint64_t v14 = (uint64_t *)a2;
        unsigned int v15 = (uint64_t *)a3;
        unint64_t v16 = a4;
        uint64_t v17 = 1LL;
      }

      else
      {
        uint64_t v14 = (uint64_t *)a2;
        unsigned int v15 = (uint64_t *)a3;
        unint64_t v16 = a4;
        uint64_t v17 = 0LL;
      }

      __NSDictionaryI_new(v14, v15, 0LL, v16, v17);
    }
  }

void __NSCFDictionaryCreateMutable( __objc2_class **a1, unint64_t a2, const CFDictionaryKeyCallBacks *a3, const CFDictionaryValueCallBacks *a4)
{
  if (__FoundationPresent_static_init_0 != -1) {
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  }
  if (__FoundationPresent_present_0
    && (&__kCFAllocatorSystemDefault == a1
     || !a1 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault()))
  {
    if (a3 == &kCFTypeDictionaryKeyCallBacks && a4 == &kCFTypeDictionaryValueCallBacks)
    {
      unint64_t v8 = 0LL;
LABEL_13:
      __NSDictionaryM_new(0LL, 0LL, a2, v8);
      return;
    }

    if (a3 == &kCFCopyStringDictionaryKeyCallBacks && a4 == &kCFTypeDictionaryValueCallBacks)
    {
      unint64_t v8 = 3LL;
      goto LABEL_13;
    }
  }

uint64_t (**__CFStringEncodingGetThaiConverterDefinition(int a1))()
{
  uint64_t v1 = __CFConverterDOSThai;
  uint64_t v2 = __CFConverterISOLatinThai;
  if (a1 != 523) {
    uint64_t v2 = 0LL;
  }
  if (a1 != 1053) {
    uint64_t v1 = v2;
  }
  if (a1 == 21) {
    return __CFConverterMacThai;
  }
  else {
    return v1;
  }
}

uint64_t __CFToDOSThai(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8365 < 0xFFFFDFF3) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&DOSThai_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180D80F88;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromDOSThai(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSThai_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToThaiPrecompose(uint64_t a1, _WORD *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  if (*a2 != 3661 || a2[1] != 3634) {
    return 0LL;
  }
  if (a5) {
    *a4 = -45;
  }
  *a6 = 1LL;
  return 2LL;
}

BOOL __CFIsValidCombiningCharacterForThai(int a1)
{
  return a1 == 3634;
}

uint64_t __CFToISOLatinThai(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 3676 < 0xFFFFFFA5) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&ISOLatinThai_from_uni;
  uint64_t v6 = (unsigned __int16 *)&unk_180D811E4;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    unint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    uint64_t v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromISOLatinThai(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    a2 = ISOLatinThai_to_uni[a2 - 161];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacThai(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4)
{
  unsigned int v4 = *a2;
  if (v4 <= 0x7F) {
    goto LABEL_2;
  }
  if (a3 < 2 || (unsigned __int16 v6 = a2[1] + 1933, v6 > 2u))
  {
    if (v4 - 8483 >= 0xFFFFDF7D)
    {
      uint64_t v13 = (unsigned __int16 *)&MacThai_from_uni;
      uint64_t v14 = (unsigned __int16 *)&unk_180D8148A;
      do
      {
        uint64_t v15 = ((char *)v14 - (char *)v13) >> 3;
        unint64_t v16 = &v13[2 * v15];
        unsigned int v17 = *v16;
        if (v17 <= v4)
        {
          if (v17 >= v4)
          {
            LOBYTE(v4) = v13[2 * v15 + 1];
LABEL_2:
            *a4 = v4;
            return 1LL;
          }

          uint64_t v13 = v16 + 2;
        }

        else
        {
          uint64_t v14 = v16 - 2;
        }
      }

      while (v13 <= v14);
    }

    return 0LL;
  }

  uint64_t v7 = (__int16)v6;
  unint64_t v8 = (char *)*(&off_1899EEA38 + (__int16)v6);
  unsigned int v9 = (unsigned __int16 *)&v8[4 * qword_180D81590[v7]];
  if (*v9 < v4) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v10 = ((char *)v9 - v8) >> 3;
    unsigned int v11 = (unsigned __int16 *)&v8[4 * v10];
    unsigned int v12 = *v11;
    if (v12 <= v4) {
      break;
    }
    unsigned int v9 = v11 - 2;
LABEL_11:
    uint64_t result = 0LL;
  }

  if (v12 < v4)
  {
    unint64_t v8 = (char *)(v11 + 2);
    goto LABEL_11;
  }

  *a4 = v8[4 * v10 + 2];
  return 2LL;
}

BOOL __CFFromMacThai(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
  {
    a2 = MacThai_to_uni[a2 - 128];
    BOOL result = a2 != 65533;
  }

  else
  {
    BOOL result = 1LL;
  }

  *a3 = a2;
  return result;
}

uint64_t __CFToMacThaiLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  for (uint64_t result = 0LL; a3; --a3)
  {
    __int16 v4 = *a2++;
  }

  return result;
}

uint64_t __CFFromMacThaiLen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 & ~(a3 >> 63);
}

void _CFBundleSplitFileName( const __CFString *a1, __CFString **a2, CFStringRef *a3, CFIndex a4, const __CFString *a5, CFIndex a6, uint64_t a7, _DWORD *a8)
{
  CFIndex Length = CFStringGetLength(a1);
  if ((unint64_t)a3 | a4)
  {
    uint64_t v17 = Length;
    CFIndex v8 = Length;
    do
    {
      if (v8-- < 1)
      {
        uint64_t v19 = 0LL;
        goto LABEL_9;
      }
    }

    while (CFStringGetCharacterAtIndex(a1, v8) != 46);
    uint64_t v19 = (unsigned __int16)v8;
    if (a3 && v17 - 1 != (unsigned __int16)v8)
    {
      CFIndex v8 = (CFIndex)&__kCFAllocatorSystemDefault;
      v43.size_t length = CFStringGetLength(a1) + ~v19;
      v43.CFIndex location = v19 + 1;
      *a3 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, v43);
    }

NSSet *mdict_keysOfEntriesWithOptionsPassingTest(uint64_t *a1, char a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  size_t v7 = *(unsigned int *)((char *)__NSDictionarySizes_0 + ((v5 >> 55) & 0x1F8));
  uint64_t v8 = *a1 + 8 * v7;
  unsigned int v9 = +[NSSet set](&OBJC_CLASS___NSMutableSet, "set");
  int v18 = 0;
  v17[0] = MEMORY[0x1895F87A8];
  v17[1] = 3221225472LL;
  CFTypeRef v17[2] = __mdict_keysOfEntriesWithOptionsPassingTest_block_invoke;
  v17[3] = &unk_1899EEA68;
  v17[6] = v6;
  v17[7] = v8;
  v17[8] = &v18;
  v17[4] = v9;
  v17[5] = a3;
  if ((__NSCollectionHandleConcurrentEnumerationIfSpecified(a2, 0, v7, (uint64_t)v17) & 1) == 0)
  {
    char v16 = 0;
    if (v5 >> 58)
    {
      size_t v10 = 0LL;
      do
      {
        unsigned int v11 = *(void **)(v6 + 8 * v10);
        if (v11) {
          BOOL v12 = v11 == &___NSDictionaryM_DeletedMarker;
        }
        else {
          BOOL v12 = 1;
        }
        if (!v12)
        {
          uint64_t v13 = *(void *)(v8 + 8 * v10);
          uint64_t v14 = (void *)_CFAutoreleasePoolPush();
          _CFAutoreleasePoolPop(v14);
          if (v16) {
            break;
          }
        }

        ++v10;
      }

      while (v10 < v7);
    }

    return (NSSet *)(id)-[NSSet copy](v9, "copy");
  }

  return v9;
}

void *__mdict_keysOfEntriesWithOptionsPassingTest_block_invoke(void *result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result[6] + 8 * a2);
  if (v2) {
    BOOL v3 = v2 == &___NSDictionaryM_DeletedMarker;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    __int16 v4 = result;
    unint64_t v5 = (void *)_CFAutoreleasePoolPush();
    if ((*(unsigned int (**)(void))(v4[5] + 16LL))())
    {
      os_unfair_lock_lock((os_unfair_lock_t)v4[8]);
      [(id)v4[4] addObject:v2];
      os_unfair_lock_unlock((os_unfair_lock_t)v4[8]);
    }

    return _CFAutoreleasePoolPop(v5);
  }

  return result;
}

void mdict_removeObjectForKey(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1 + 1;
  unint64_t v3 = (unint64_t)a1[2] >> 58;
  if (v3)
  {
    unint64_t v6 = LODWORD(__NSDictionarySizes_0[v3]);
    uint64_t v7 = *v2;
    uint64_t v20 = *v2 + 8 * v6;
    unint64_t v8 = 0LL;
    unint64_t v9 = [a2 hash] % v6;
    if (v6 <= 1) {
      uint64_t v10 = 1LL;
    }
    else {
      uint64_t v10 = v6;
    }
    unint64_t v11 = v6;
    while (1)
    {
      BOOL v12 = *(void **)(v7 + 8 * v9);
      if (!v12) {
        break;
      }
      if (v12 == &___NSDictionaryM_DeletedMarker)
      {
        ++v8;
        if (v11 == v6) {
          unint64_t v11 = v9;
        }
      }

      else if (v12 == a2 || ([v12 isEqual:a2] & 1) != 0)
      {
        unint64_t v11 = v9;
        goto LABEL_21;
      }

      if (v9 + 1 >= v6) {
        unint64_t v13 = v6;
      }
      else {
        unint64_t v13 = 0LL;
      }
      unint64_t v9 = v9 + 1 - v13;
      if (!--v10) {
        goto LABEL_21;
      }
    }

    if (v11 == v6) {
      unint64_t v11 = v9;
    }
LABEL_21:
    if (v11 < v6)
    {
      unint64_t v14 = *(void *)(v7 + 8 * v11);
      if (v14 && v14 != (void)&___NSDictionaryM_DeletedMarker)
      {
        uint64_t v16 = a1[2];
        if ((v16 & 0x200000000000000LL) != 0) {
          [a1 willChangeValueForKey:a2];
        }
        uint64_t v19 = *(void *)(v20 + 8 * v11);
        *(void *)(v7 + 8 * v1__postAndResetMidnight(1, 1) = &___NSDictionaryM_DeletedMarker;
        *(void *)(v20 + 8 * v1__postAndResetMidnight(1, 1) = 0LL;
        a1[2] = a1[2] & 0xFE000000FFFFFFFFLL | ((((unint64_t)(a1[2] + 0x1FFFFFF00000000LL) >> 32) & 0x1FFFFFF) << 32);
        if (v8 > 0xF)
        {
          mdict_rehashd((uint64_t)a1, v3);
        }

        else
        {
          if (v11 + 1 < v6) {
            unint64_t v17 = v11 + 1;
          }
          else {
            unint64_t v17 = 0LL;
          }
          if (!*(void *)(v7 + 8 * v17))
          {
            do
            {
              *(void *)(v7 + 8 * v1__postAndResetMidnight(1, 1) = 0LL;
              if (v11) {
                unint64_t v18 = v11;
              }
              else {
                unint64_t v18 = v6;
              }
              unint64_t v11 = v18 - 1;
            }

            while (*(_UNKNOWN **)(v7 + 8 * (v18 - 1)) == &___NSDictionaryM_DeletedMarker);
          }
        }

        if ((v16 & 0x200000000000000LL) != 0) {
          [a1 didChangeValueForKey:a2];
        }
        if ((v14 & 0x8000000000000000LL) == 0) {

        }
        if (v19 >= 1) {
      }
        }
    }
  }

void sub_180BD2D48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void sub_180BD34A8(_Unwind_Exception *a1)
{
}

void __NSDictionaryM_new(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char v34 = a4;
  uint64_t v5 = 0LL;
  unint64_t v6 = 0xFFFFFFFF80000000LL * ((a4 >> 1) & 1);
  while (__NSDictionaryCapacities_0[v5] < a3)
  {
    ++v5;
    v6 -= 0x400000000000000LL;
    if (v5 == 40)
    {
      __break(1u);
      break;
    }
  }

  uint64_t v7 = __NSDictionarySizes_0[v5];
  unint64_t v8 = (objc_class *)objc_opt_self();
  uint64_t v9 = __CFAllocateObject(v8, 0LL);
  *(_DWORD *)(v9 + ++*(_WORD *)(cf + 16) = 1;
  *(void *)(v9 + ++*(_WORD *)(cf + 16) = (*(void *)(v9 + 16) & 0x3FFFFFF7FFFFFFFLL) - v6;
  uint64_t v31 = v9;
  if (!a3)
  {
    *(void *)(v9 + _Block_object_dispose(va, 8) = 0LL;
LABEL_43:
    atomic_store(0LL, (unint64_t *)(v31 + 24));
    return;
  }

  uint64_t v10 = v9;
  unint64_t v11 = (char *)calloc(1uLL, 16LL * v7);
  *(void *)(v10 + _Block_object_dispose(va, 8) = v11;
  if (!a1 || !a2) {
    goto LABEL_43;
  }
  BOOL v12 = v11;
  uint64_t v13 = 0LL;
  char v36 = &v11[8 * v7];
  if ((v7 & 0xFFFFFFFE) != 0) {
    uint64_t v14 = v7;
  }
  else {
    uint64_t v14 = 1LL;
  }
  uint64_t v32 = v14;
  while (1)
  {
    uint64_t v15 = *(void **)(a1 + 8 * v13);
    unint64_t v16 = [v15 hash];
    unint64_t v17 = v7;
    if (v5 * 8)
    {
      unint64_t v18 = v16 % v7;
      uint64_t v19 = v32;
      unint64_t v17 = v7;
      while (1)
      {
        uint64_t v20 = *(void **)&v12[8 * v18];
        if (!v20) {
          break;
        }
        if (v20 == &___NSDictionaryM_DeletedMarker)
        {
        }

        else if (v20 == v15 || ([v20 isEqual:v15] & 1) != 0)
        {
          unint64_t v17 = v18;
          goto LABEL_29;
        }

        else {
          uint64_t v21 = 0LL;
        }
        unint64_t v18 = v18 + 1 - v21;
        if (!--v19) {
          goto LABEL_29;
        }
      }
    }

void cow_cleanup(uint64_t a1, int a2)
{
  uint64_t v2 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  if (a2 == 1) {
    uint64_t v2 = &OBJC_IVAR_____NSDictionaryM_storage;
  }
  uint64_t v3 = a1 + *v2;
  uint64_t v5 = *(void ***)v3;
  unint64_t v4 = *(void *)(v3 + 8);
  uint64_t v6 = LODWORD(__NSDictionarySizes_0[v4 >> 58]);
  *(void *)uint64_t v3 = 0LL;
  *(void *)(v3 + _Block_object_dispose(va, 8) = v4 & 0x2000000FFFFFFFFLL;
  if (v4 >> 58)
  {
    uint64_t v7 = &v5[v6];
    unint64_t v8 = v5;
    uint64_t v9 = v6;
    do
    {
      uint64_t v10 = *v8;
      ++v8;
      --v9;
    }

    while (v9);
    do
    {
      ++v7;
      --v6;
    }

    while (v6);
  }

  free(v5);
}

void sub_180BD3F24(_Unwind_Exception *exception_object)
{
}

void sub_180BD4A04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

__n128 cow_copy_instance_2(uint64_t a1, int a2, uint64_t a3, int a4)
{
  unint64_t v4 = &OBJC_IVAR_____NSFrozenDictionaryM_cow;
  if (a2 == 1) {
    uint64_t v5 = &OBJC_IVAR_____NSDictionaryM_cow;
  }
  else {
    uint64_t v5 = &OBJC_IVAR_____NSFrozenDictionaryM_cow;
  }
  if (a2 == 1) {
    uint64_t v6 = &OBJC_IVAR_____NSDictionaryM_storage;
  }
  else {
    uint64_t v6 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  }
  unint64_t v7 = atomic_load((unint64_t *)(a1 + *v5));
  uint64_t v8 = *v6;
  if (a4 == 1)
  {
    unint64_t v4 = &OBJC_IVAR_____NSDictionaryM_cow;
    uint64_t v9 = &OBJC_IVAR_____NSDictionaryM_storage;
  }

  else
  {
    uint64_t v9 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  }

  atomic_store(v7, (unint64_t *)(a3 + *v4));
  __n128 result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v9) = result;
  return result;
}

uint64_t cow_copy_storage_2(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 16);
  if ((v2 & 0x1FFFFFF00000000LL) == 0)
  {
    uint64_t v5 = 0LL;
    *(void *)(a1 + ++*(_WORD *)(cf + 16) = v2 & 0x3FFFFFFFFFFFFFFLL;
LABEL_18:
    uint64_t result = 1LL;
    goto LABEL_19;
  }

  uint64_t v3 = *(unsigned int *)((char *)__NSDictionarySizes_0 + ((v2 >> 55) & 0x1F8));
  uint64_t result = (uint64_t)calloc(1uLL, 16 * v3);
  uint64_t v5 = result;
  if (result)
  {
    if (v2 >> 58)
    {
      uint64_t v6 = 0LL;
      uint64_t v7 = *(void *)(a1 + 8);
      do
      {
        unint64_t v8 = *(void *)(v7 + 8 * v6);
        if (v8)
        {
          *(void *)(v5 + 8 * v6) = v8;
          if ((_UNKNOWN *)v8 != &___NSDictionaryM_DeletedMarker && (v8 & 0x8000000000000000LL) == 0) {
            id v9 = (id)v8;
          }
        }

        ++v6;
      }

      while (v3 != v6);
      uint64_t v10 = 8 * v3;
      do
      {
        unint64_t v11 = *(void *)(v7 + v10);
        if (v11)
        {
          if ((v11 & 0x8000000000000000LL) == 0) {
            id v12 = (id)v11;
          }
          *(void *)(v5 + v10) = v11;
        }

        v10 += 8LL;
        --v3;
      }

      while (v3);
    }

    goto LABEL_18;
  }

uint64_t cow_set_cow_2(uint64_t result, unint64_t a2)
{
  return result;
}

void mdict_rehashd(uint64_t a1, unsigned int a2)
{
  if (a2 >= 0x28)
  {
    __break(1u);
  }

  else
  {
    unint64_t v4 = LODWORD(__NSDictionarySizes_0[a2]);
    uint64_t v5 = (char *)calloc(1uLL, 16 * v4);
    uint64_t v6 = v5;
    uint64_t v21 = a1;
    uint64_t v7 = a1 + 8;
    unint64_t v8 = *(void **)(a1 + 8);
    uint64_t v9 = *(void *)(v7 + 8) >> 58;
    if (v9)
    {
      uint64_t v10 = 0LL;
      uint64_t v22 = &v5[8 * v4];
      uint64_t v11 = LODWORD(__NSDictionarySizes_0[v9]);
      if (v4 <= 1) {
        uint64_t v12 = 1LL;
      }
      else {
        uint64_t v12 = v4;
      }
      do
      {
        uint64_t v13 = (void *)v8[v10];
        if (v13) {
          BOOL v14 = v13 == &___NSDictionaryM_DeletedMarker;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14)
        {
          unint64_t v15 = [(id)v8[v10] hash];
          if (!a2) {
            goto LABEL_22;
          }
          unint64_t v16 = v15 % v4;
          uint64_t v17 = v12;
          while (*(void *)&v6[8 * v16])
          {
            unint64_t v18 = v16 + 1;
            if (v18 >= v4) {
              unint64_t v19 = v4;
            }
            else {
              unint64_t v19 = 0LL;
            }
            unint64_t v16 = v18 - v19;
            if (!--v17) {
              goto LABEL_22;
            }
          }

          if (v16 == 0x7FFFFFFFFFFFFFFFLL) {
LABEL_22:
          }
            __NSMUTABLEDICTIONARY_CONCURRENT_MODIFICATION_DETECTED__();
          *(void *)&v6[8 * v16] = v13;
          *(void *)&v22[8 * v16] = v8[v11 + v10];
        }

        ++v10;
      }

      while (v10 != v11);
    }

    free(v8);
    unint64_t v20 = *(void *)(v21 + 16) & 0x3FFFFFFFFFFFFFFLL | ((unint64_t)a2 << 58);
    *(void *)(v21 + _Block_object_dispose(va, 8) = v6;
    *(void *)(v21 + ++*(_WORD *)(cf + 16) = v20;
  }

void __NSMUTABLEDICTIONARY_CONCURRENT_MODIFICATION_DETECTED__()
{
  CFStringRef v0 = (objc_class *)objc_opt_class();
  uint64_t Name = class_getName(v0);
  CFLog( 3LL,  (uint64_t)@"*** Collection <%s: %p> was mutated while rehashing.",  v2,  v3,  v4,  v5,  v6,  v7,  (uint64_t)Name);
  __break(1u);
}

void *__mdict_enumerateKeysAndObjectsWithOptionsUsingBlock_block_invoke(void *result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result[5] + 8 * a2);
  if (v2) {
    BOOL v3 = v2 == &___NSDictionaryM_DeletedMarker;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = (void *)_CFAutoreleasePoolPush();
    __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(v4[4]);
    return _CFAutoreleasePoolPop(v5);
  }

  return result;
}

void *__mdict_keyOfEntryWithOptionsPassingTest_block_invoke(void *result, uint64_t a2, _BYTE *a3)
{
  BOOL v3 = *(void **)(result[6] + 8 * a2);
  if (v3) {
    BOOL v4 = v3 == &___NSDictionaryM_DeletedMarker;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    uint64_t v6 = result;
    uint64_t v7 = (void *)_CFAutoreleasePoolPush();
    if ((*(unsigned int (**)(void))(v6[4] + 16LL))())
    {
      atomic_store((unint64_t)v3, (unint64_t *)(*(void *)(v6[5] + 8LL) + 24LL));
      *a3 = 1;
    }

    return _CFAutoreleasePoolPop(v7);
  }

  return result;
}

uint64_t _compare_clumpiness_2(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

void *__CFGenerateReport()
{
  v33[129] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v30 = 0LL;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x2020000000LL;
  uint64_t v26 = 0LL;
  id v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  uint64_t v29 = 1LL;
  v21[0] = MEMORY[0x1895F87A8];
  v21[1] = 3221225472LL;
  uint64_t v22 = ____CFGenerateReport_block_invoke;
  uint64_t v23 = &unk_1899EEB00;
  id v24 = &v30;
  uint64_t v25 = &v26;
  int v0 = backtrace(v33, 128);
  uint64_t v1 = backtrace_symbols(v33, v0);
  uint64_t v2 = 0LL;
  if (v0 > 0xFFFFFFFA)
  {
    BOOL v4 = 0LL;
    goto LABEL_14;
  }

  unint64_t v3 = v0 + 5LL;
  BOOL v4 = 0LL;
  if (v3 >> 61) {
    goto LABEL_14;
  }
  uint64_t v5 = (char *)malloc(8 * v3);
  uint64_t v2 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  v31[3] = (uint64_t)v5;
  time_t v20 = time(0LL);
  if (v20 == -1) {
    goto LABEL_12;
  }
  int v6 = asprintf((char **)v31[3], "%s%25s", "Date/Time:     ", "");
  ctime_r(&v20, (char *)(*(void *)(v31[3] - 8) + 15LL));
  size_t v19 = 0LL;
  if (sysctlbyname("kern.osversion", 0LL, &v19, 0LL, 0LL)
    || (int v7 = asprintf((char **)v31[3], "%s%*s", "OS Version:    ", v19, ""), v22((uint64_t)v21, v7))
    || sysctlbyname("kern.osversion", (void *)(*(void *)(v31[3] - 8) + 15LL), &v19, 0LL, 0LL)
    || (*(_BYTE *)(*(void *)(v31[3] - 8) + v19 + 14) = 10,
        unint64_t v8 = (char **)v31[3],
        uint64_t v9 = getprogname(),
        int v10 = asprintf(v8, "%s%s\n", "Application:   ", v9),
        v22((uint64_t)v21, v10))
    || (int v11 = asprintf((char **)v31[3], "\n"), v22((uint64_t)v21, v11))
    || (int v12 = asprintf((char **)v31[3], "Backtrace:\n"), v22((uint64_t)v21, v12)))
  {
LABEL_12:
    BOOL v4 = 0LL;
    goto LABEL_14;
  }

  if (v0 < 1)
  {
LABEL_25:
    BOOL v4 = malloc(v27[3]);
    if (v4 && (unint64_t)v2 < v31[3])
    {
      unint64_t v18 = v2;
      do
      {
        v18 += 8;
        __stpcpy_chk();
      }

      while ((unint64_t)v18 < v31[3]);
    }

void sub_180BD56C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

CFDateRef __CFBinaryPlistCreate15(uint64_t a1, unint64_t a2)
{
  v11[1] = *(const void **)MEMORY[0x1895F89C0];
  if (a2 < 0x10) {
    return 0LL;
  }
  if (__CFADD__(a2, a1)) {
    return 0LL;
  }
  if (*(void *)a1 != 0x35317473696C7062LL) {
    return 0LL;
  }
  if (a1 + a2 - 1 < a1 + 8) {
    return 0LL;
  }
  char v2 = *(_BYTE *)(a1 + 8);
  if ((v2 & 0xF0) != 0x10) {
    return 0LL;
  }
  CFDateRef Object15 = 0LL;
  BOOL v4 = (unsigned __int8 *)(a1 + 9);
  uint64_t v5 = 1LL << (v2 & 0xF);
  if (!__CFADD__(v5, a1 + 9) && (unint64_t)&v4[v5] <= a1 + a2)
  {
    CFDateRef Object15 = 0LL;
    switch((int)v5)
    {
      case 1:
        uint64_t v6 = (char)*v4;
        else {
          uint64_t v7 = *v4 ^ 0x80LL;
        }
        goto LABEL_17;
      case 2:
        unint64_t v8 = (__int16)(*(unsigned __int8 *)(a1 + 10) << 8) | (unint64_t)*(unsigned __int8 *)(a1 + 9);
        if ((v8 & 0x80000000) == 0LL) {
          uint64_t v7 = v8 - 0x8000;
        }
        else {
          uint64_t v7 = (unsigned __int16)v8 ^ 0x8000u;
        }
        goto LABEL_17;
      case 4:
        uint64_t v7 = *(int *)v4 ^ 0xFFFFFFFF80000000LL;
        goto LABEL_17;
      case 8:
        uint64_t v7 = *(void *)(a1 + 9) ^ 0x8000000000000000LL;
LABEL_17:
        CFDateRef Object15 = 0LL;
        if (v7 < 16 || v7 > a2) {
          return Object15;
        }
        uint64_t v9 = (char *)&v4[v5];
        if (*v9 != 18) {
          return 0LL;
        }
        v11[0] = v9 + 5;
        CFDateRef Object15 = __readObject15(a1, v7, v11);
        break;
      default:
        return Object15;
    }
  }

  return Object15;
}

CFDateRef __readObject15(uint64_t a1, uint64_t a2, const void **a3)
{
  values[256] = *(void **)MEMORY[0x1895F89C0];
  unint64_t v3 = a1 + a2;
  unint64_t v4 = a1 + a2 - 1;
  unint64_t v5 = (unint64_t)*a3;
  uint64_t v9 = (char *)(v5 + 1);
  unsigned int v10 = *(unsigned __int8 *)v5;
  *a3 = (const void *)(v5 + 1);
  if (v5 == -1LL) {
    return 0LL;
  }
  int v11 = 0LL;
  switch(v10 >> 4)
  {
    case 0u:
      int v11 = 0LL;
      switch(v10)
      {
        case 0u:
          uint64_t v17 = &kCFNull;
          return *v17;
        case 8u:
          uint64_t v17 = &kCFBooleanFalse;
          return *v17;
        case 9u:
          uint64_t v17 = &kCFBooleanTrue;
          return *v17;
        case 0xCu:
          CFDateRef Object15 = (const __CFString *)__readObject15(a1, a2, a3);
          if (!Object15) {
            return 0LL;
          }
          CFRange v45 = Object15;
          if (CFGetTypeID(Object15) != 7) {
            goto LABEL_141;
          }
          int v11 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v45, 0LL);
          CFRange v46 = v45;
          goto LABEL_138;
        case 0xDu:
          int v11 = (const __CFURL *)__readObject15(a1, a2, a3);
          if (!v11) {
            return v11;
          }
          CFTypeID v47 = CFURLGetTypeID();
          if (v47 == CFGetTypeID(v11) && (int v48 = (const __CFString *)__readObject15(a1, a2, a3)) != 0LL)
          {
            CFRange v45 = v48;
            if (CFGetTypeID(v48) == 7)
            {
              CFURLRef v49 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v45, v11);
              CFRelease(v11);
              CFRelease(v45);
              return v49;
            }

            CFRelease(v11);
LABEL_141:
            uint64_t v51 = v45;
          }

          else
          {
            uint64_t v51 = v11;
          }

          break;
        case 0xEu:
          if (v5 > 0xFFFFFFFFFFFFFFEELL || v3 < v5 + 17) {
            return 0LL;
          }
          uint64_t v50 = *(void *)v9;
          *(void *)&v83.byte8 = *(void *)(v5 + 9);
          *a3 = (const void *)(v5 + 17);
          *(void *)&v83.byte0 = v50;
          return CFUUIDCreateFromUUIDBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v83);
        default:
          return v11;
      }

      goto LABEL_142;
    case 1u:
      if ((v10 & 0xF) > 4) {
        return 0LL;
      }
      if ((v10 & 0xF) != 4)
      {
        if (v3 >= (unint64_t)v9 && (*(_BYTE *)v5 & 0xF0) == 0x10)
        {
          uint64_t v40 = 1LL << (*(_BYTE *)v5 & 0xF);
          if (v5 < ~v40 && v3 >= (unint64_t)&v9[v40])
          {
            int v11 = 0LL;
            switch((int)v40)
            {
              case 1:
                uint64_t v42 = *v9;
                else {
                  unint64_t v43 = *v9 ^ 0x80LL;
                }
                goto LABEL_200;
              case 2:
                unint64_t v81 = (__int16)(*(unsigned __int8 *)(v5 + 2) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 1);
                if ((v81 & 0x80000000) == 0LL) {
                  unint64_t v43 = v81 - 0x8000;
                }
                else {
                  unint64_t v43 = (unsigned __int16)v81 ^ 0x8000u;
                }
                goto LABEL_200;
              case 4:
                unint64_t v43 = *(int *)v9 ^ 0xFFFFFFFF80000000LL;
                goto LABEL_200;
              case 8:
                unint64_t v43 = *(void *)v9 ^ 0x8000000000000000LL;
LABEL_200:
                values[0] = (void *)v43;
                *a3 = &v9[v40];
                CFNumberType v20 = kCFNumberSInt64Type;
                return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, values);
              default:
                return v11;
            }
          }
        }

        return 0LL;
      }

      int v11 = 0LL;
      if (v5 <= 0xFFFFFFFFFFFFFFEELL && v3 >= v5 + 17)
      {
        uint64_t v18 = *(void **)v9;
        *a3 = (const void *)(v5 + 9);
        uint64_t v19 = *(void *)(v5 + 9);
        *a3 = (const void *)(v5 + 17);
        values[0] = (void *)(v19 ^ 0x8000000000000000LL);
        values[1] = v18;
        CFNumberType v20 = kCFNumberMaxType|kCFNumberSInt8Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, values);
      }

      return v11;
    case 2u:
      if ((v10 & 0xF) == 3)
      {
        if (v5 <= 0xFFFFFFFFFFFFFFF6LL && v3 >= v5 + 9)
        {
          unint64_t v39 = *(void *)v9;
          *a3 = (const void *)(v5 + 9);
          values[0] = (void *)bswap64(v39);
          CFNumberType v20 = kCFNumberFloat64Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, values);
        }
      }

      else if ((v10 & 0xF) == 2 && v5 <= 0xFFFFFFFFFFFFFFFALL && v3 >= v5 + 5)
      {
        unsigned int v21 = *(_DWORD *)v9;
        *a3 = (const void *)(v5 + 5);
        LODWORD(values[0]) = bswap32(v21);
        CFNumberType v20 = kCFNumberFloat32Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, values);
      }

      return 0LL;
    case 3u:
      int v11 = 0LL;
      if (v5 > 0xFFFFFFFFFFFFFFF6LL || v10 != 51) {
        return v11;
      }
      if (v3 < v5 + 9) {
        return 0LL;
      }
      unint64_t v22 = *(void *)v9;
      *a3 = (const void *)(v5 + 9);
      return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, COERCE_CFABSOLUTETIME(bswap64(v22)));
    case 4u:
      CFIndex v24 = v10 & 0xF;
      if ((_DWORD)v24 != 15) {
        goto LABEL_149;
      }
      uint64_t v25 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10) {
        return 0LL;
      }
      int v11 = 0LL;
      uint64_t v26 = 1LL << (*v9 & 0xF);
      int v11 = 0LL;
      switch((int)v26)
      {
        case 1:
          uint64_t v27 = (char)*v25;
          else {
            CFIndex v24 = *v25 ^ 0x80LL;
          }
          break;
        case 2:
          unint64_t v67 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v67 & 0x80000000) == 0LL) {
            CFIndex v24 = v67 - 0x8000;
          }
          else {
            CFIndex v24 = (unsigned __int16)v67 ^ 0x8000u;
          }
          break;
        case 4:
          CFIndex v24 = *(int *)v25 ^ 0xFFFFFFFF80000000LL;
          break;
        case 8:
          CFIndex v24 = *(void *)(v5 + 2) ^ 0x8000000000000000LL;
          break;
        default:
          return v11;
      }

      uint64_t v9 = (char *)&v25[v26];
      *a3 = &v25[v26];
LABEL_149:
      if (__CFADD__(v24, v9)) {
        return 0LL;
      }
      CFStringRef v68 = &v9[v24];
      CFDateRef result = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v9, v24);
      goto LABEL_194;
    case 5u:
      CFIndex v28 = v10 & 0xF;
      if ((_DWORD)v28 != 15) {
        goto LABEL_158;
      }
      uint64_t v29 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10) {
        return 0LL;
      }
      int v11 = 0LL;
      uint64_t v30 = 1LL << (*v9 & 0xF);
      int v11 = 0LL;
      switch((int)v30)
      {
        case 1:
          uint64_t v31 = (char)*v29;
          else {
            CFIndex v28 = *v29 ^ 0x80LL;
          }
          break;
        case 2:
          unint64_t v69 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v69 & 0x80000000) == 0LL) {
            CFIndex v28 = v69 - 0x8000;
          }
          else {
            CFIndex v28 = (unsigned __int16)v69 ^ 0x8000u;
          }
          break;
        case 4:
          CFIndex v28 = *(int *)v29 ^ 0xFFFFFFFF80000000LL;
          break;
        case 8:
          CFIndex v28 = *(void *)(v5 + 2) ^ 0x8000000000000000LL;
          break;
        default:
          return v11;
      }

      uint64_t v9 = (char *)&v29[v30];
      *a3 = &v29[v30];
LABEL_158:
      if (__CFADD__(v28, v9)) {
        return 0LL;
      }
      CFStringRef v68 = &v9[v28];
      CFStringEncoding v70 = 1536;
      goto LABEL_193;
    case 6u:
      CFIndex v32 = v10 & 0xF;
      if ((_DWORD)v32 == 15)
      {
        unsigned int v33 = (unsigned __int8 *)(v5 + 2);
        if ((*v9 & 0xF0) != 0x10) {
          return 0LL;
        }
        int v11 = 0LL;
        uint64_t v34 = 1LL << (*v9 & 0xF);
        if (!__CFADD__(v34, v33) && v3 >= (unint64_t)&v33[v34])
        {
          int v11 = 0LL;
          switch((int)v34)
          {
            case 1:
              uint64_t v35 = (char)*v33;
              else {
                CFIndex v32 = *v33 ^ 0x80LL;
              }
              goto LABEL_166;
            case 2:
              unint64_t v71 = (__int16)(v9[2] << 8) | (unint64_t)v9[1];
              if ((v71 & 0x80000000) == 0LL) {
                CFIndex v32 = v71 - 0x8000;
              }
              else {
                CFIndex v32 = (unsigned __int16)v71 ^ 0x8000u;
              }
              goto LABEL_166;
            case 4:
              CFIndex v32 = *(int *)v33 ^ 0xFFFFFFFF80000000LL;
              goto LABEL_166;
            case 8:
              CFIndex v32 = *(void *)(v9 + 1) ^ 0x8000000000000000LL;
LABEL_166:
              uint64_t v9 = (char *)&v33[v34];
              *a3 = &v33[v34];
              goto LABEL_167;
            default:
              return v11;
          }
        }

        return v11;
      }

LABEL_167:
      unint64_t v72 = (unint64_t)&v9[v32 - 1];
      if (~v32 >= v72)
      {
        unint64_t v73 = v32 + v72;
        if ((unint64_t)v9 <= ~v32 && v4 >= v73)
        {
          if (v32)
          {
            if (v32 < 0) {
              return 0LL;
            }
            uint64_t v75 = 2 * v32;
          }

          else
          {
            uint64_t v75 = 0LL;
          }

          int v76 = (UniChar *)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v75, 0LL);
          if (v76)
          {
            int v77 = v76;
            memmove(v76, *a3, v75);
            if (v32)
            {
              unsigned int v78 = v77;
              CFIndex v79 = v32;
              do
              {
                *unsigned int v78 = bswap32(*v78) >> 16;
                ++v78;
                --v79;
              }

              while (v79);
            }

            int v11 = (const __CFURL *)CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v77, v32);
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v77);
            *a3 = (const void *)(v73 + 1);
            return v11;
          }
        }
      }

      return 0LL;
    case 7u:
      CFIndex v28 = v10 & 0xF;
      if ((_DWORD)v28 != 15) {
        goto LABEL_188;
      }
      char v36 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10) {
        return 0LL;
      }
      int v11 = 0LL;
      uint64_t v37 = 1LL << (*v9 & 0xF);
      int v11 = 0LL;
      switch((int)v37)
      {
        case 1:
          uint64_t v38 = (char)*v36;
          else {
            CFIndex v28 = *v36 ^ 0x80LL;
          }
          break;
        case 2:
          unint64_t v80 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v80 & 0x80000000) == 0LL) {
            CFIndex v28 = v80 - 0x8000;
          }
          else {
            CFIndex v28 = (unsigned __int16)v80 ^ 0x8000u;
          }
          break;
        case 4:
          CFIndex v28 = *(int *)v36 ^ 0xFFFFFFFF80000000LL;
          break;
        case 8:
          CFIndex v28 = *(void *)(v5 + 2) ^ 0x8000000000000000LL;
          break;
        default:
          return v11;
      }

      uint64_t v9 = (char *)&v36[v37];
      *a3 = &v36[v37];
LABEL_188:
      if (__CFADD__(v28, v9)) {
        return 0LL;
      }
      CFStringRef v68 = &v9[v28];
      CFStringEncoding v70 = 134217984;
LABEL_193:
      CFDateRef result = (CFDateRef)CFStringCreateWithBytes( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)v9,  v28,  v70,  0);
LABEL_194:
      *a3 = v68;
      return result;
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
      CFIndex v13 = v10 & 0xF;
      if ((_DWORD)v13 != 15)
      {
LABEL_104:
        int v53 = v10 & 0xF0;
        if (v53 == 208)
        {
          if (v13)
          {
            if (v13 < 0) {
              return 0LL;
            }
            v13 *= 2LL;
LABEL_109:
            if ((unint64_t)v13 >= 0x101)
            {
              BOOL v54 = (const void **)CFAllocatorAllocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 8 * v13, 0LL);
              if (!v54) {
                return 0LL;
              }
            }

            else
            {
              BOOL v54 = (const void **)values;
            }

            CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
            unint64_t v58 = 0LL;
            while (1)
            {
              BOOL v59 = (const __CFURL *)__readObject15(a1, a2, a3);
              int v11 = v59;
              if (!v59)
              {
                CFRange v46 = Mutable;
LABEL_138:
                CFRelease(v46);
                return v11;
              }

              CFArrayAppendValue(Mutable, v11);
              if (v13 == ++v58) {
                goto LABEL_113;
              }
            }

            CFRelease(v11);
            uint64_t v51 = Mutable;
LABEL_142:
            CFRelease(v51);
            return 0LL;
          }
        }

        else if (v13)
        {
          goto LABEL_109;
        }

        CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
        CFIndex v13 = 0LL;
        BOOL v54 = (const void **)values;
LABEL_113:
        v84.CFIndex location = 0LL;
        v84.size_t length = v13;
        CFArrayGetValues(Mutable, v84, v54);
        switch(v53)
        {
          case 160:
            __int128 v56 = "newArrayWithObjects:count:";
            uint64_t v57 = "NSArray";
            break;
          case 192:
            __int128 v56 = "newSetWithObjects:count:";
            uint64_t v57 = "NSSet";
            break;
          case 176:
            __int128 v56 = "newOrderedSetWithObjects:count:";
            uint64_t v57 = "NSOrderedSet";
            break;
          default:
            Class v61 = __CFLookUpClass("NSDictionary");
            unint64_t v62 = sel_registerName("newDictionaryWithObjects:forKeys:count:");
            if (v13 >= 0) {
              uint64_t v63 = v13;
            }
            else {
              uint64_t v63 = v13 + 1;
            }
            uint64_t v64 = v63 >> 1;
            int v11 = (const __CFURL *)objc_msgSend(v61, v62, &v54[v63 >> 1], v54, v63 >> 1);
            if (v13 >= 2)
            {
              CFTypeRef v65 = v54;
              do
              {
                uint64_t v66 = *v65++;
                CFRelease(v66);
                --v64;
              }

              while (v64);
            }

            goto LABEL_128;
        }

        Class v60 = __CFLookUpClass(v57);
        int v11 = (const __CFURL *)objc_msgSend(v60, sel_registerName(v56), v54, v13);
LABEL_128:
        CFRelease(Mutable);
        return v11;
      }

      uint64_t v14 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10) {
        return 0LL;
      }
      int v11 = 0LL;
      uint64_t v15 = 1LL << (*v9 & 0xF);
      if (!__CFADD__(v15, v14) && v3 >= (unint64_t)&v14[v15])
      {
        int v11 = 0LL;
        switch((int)v15)
        {
          case 1:
            uint64_t v16 = (char)*v14;
            else {
              CFIndex v13 = *v14 ^ 0x80LL;
            }
            goto LABEL_103;
          case 2:
            unint64_t v52 = (__int16)(v9[2] << 8) | (unint64_t)v9[1];
            if ((v52 & 0x80000000) == 0LL) {
              CFIndex v13 = v52 - 0x8000;
            }
            else {
              CFIndex v13 = (unsigned __int16)v52 ^ 0x8000u;
            }
            goto LABEL_103;
          case 4:
            CFIndex v13 = *(int *)v14 ^ 0xFFFFFFFF80000000LL;
            goto LABEL_103;
          case 8:
            CFIndex v13 = *(void *)(v9 + 1) ^ 0x8000000000000000LL;
LABEL_103:
            *a3 = &v14[v15];
            goto LABEL_104;
          default:
            return v11;
        }
      }

      return v11;
    default:
      return v11;
  }

uint64_t __CFBinaryPlistWrite15(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1895F8858](a1, a2);
  unint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  unsigned int v10 = v9;
  int v11 = (__CFString *)v2;
  *(void *)&__len_4[8148] = *MEMORY[0x1895F89C0];
  bzero(&__len, 0x1FD8uLL);
  v15[0] = v10;
  v15[1] = v8;
  CFTypeRef cf = 0LL;
  uint64_t v17 = 0LL;
  void v15[2] = v6;
  int __len = 0;
  bufferWrite_0((uint64_t)v15, "bplist15", 8LL);
  bufferWrite_0((uint64_t)v15, byte_180D81910, 9LL);
  bufferWrite_0((uint64_t)v15, byte_180D8191A, 5LL);
  BOOL v12 = __writeObject15(v15, v11);
  writeBytes_0((uint64_t)v15, __len_4, __len);
  int __len = 0;
  if ((unint64_t)v10 | v8)
  {
    newBytes[0] = 19;
    *(void *)&newBytes[1] = v17 ^ 0x8000000000000000LL;
    if (v8)
    {
      *(void *)(v8 + _Block_object_dispose(va, 8) = *(void *)newBytes;
      *(_BYTE *)(v8 + ++*(_WORD *)(cf + 16) = newBytes[8];
    }

    if (v10)
    {
      v20.CFIndex location = 8LL;
      v20.size_t length = 9LL;
      CFDataReplaceBytes(v10, v20, newBytes, 9LL);
    }
  }

  if (v12) {
    return v17;
  }
  if (v4 && cf)
  {
    uint64_t result = 0LL;
    *unint64_t v4 = cf;
  }

  else
  {
    if (cf) {
      CFRelease(cf);
    }
    return 0LL;
  }

  return result;
}

void bufferWrite_0(uint64_t a1, _BYTE *__src, uint64_t a3)
{
  if (a3)
  {
    size_t v3 = a3;
    if (a3 < 8144)
    {
      int v6 = *(_DWORD *)(a1 + 40);
      if (8144LL - v6 >= a3) {
        size_t v7 = a3;
      }
      else {
        size_t v7 = 8144LL - v6;
      }
      if (*(void *)a1 || *(void *)(a1 + 8))
      {
        uint64_t v8 = v6;
        switch(v7)
        {
          case 1uLL:
            goto LABEL_13;
          case 2uLL:
            goto LABEL_12;
          case 3uLL:
            goto LABEL_11;
          case 4uLL:
            *(_BYTE *)(v6 + a1 + 47) = __src[3];
            int v6 = *(_DWORD *)(a1 + 40);
LABEL_11:
            *(_BYTE *)(a1 + v6 + 46) = __src[2];
            int v6 = *(_DWORD *)(a1 + 40);
LABEL_12:
            *(_BYTE *)(a1 + v6 + 45) = __src[1];
            uint64_t v8 = *(int *)(a1 + 40);
LABEL_13:
            *(_BYTE *)(a1 + v8 + 44) = *__src;
            break;
          default:
            memmove((void *)(a1 + v6 + 44), __src, v7);
            break;
        }
      }

      int v9 = *(_DWORD *)(a1 + 40) + v7;
      *(_DWORD *)(a1 + 40) = v9;
      if (v9 == 8144)
      {
        writeBytes_0(a1, (void *)(a1 + 44), 8144LL);
        if (*(void *)a1 || *(void *)(a1 + 8))
        {
          v3 -= v7;
          memmove((void *)(a1 + 44), &__src[v7], v3);
        }

        else
        {
          LODWORD(v3) = v3 - v7;
        }

        *(_DWORD *)(a1 + 40) = v3;
      }
    }

    else
    {
      writeBytes_0(a1, (void *)(a1 + 44), *(int *)(a1 + 40));
      *(_DWORD *)(a1 + 40) = 0;
      writeBytes_0(a1, __src, v3);
    }
  }

BOOL __writeObject15(void *a1, __CFString *a2)
{
  valuePtr[256] = *MEMORY[0x1895F89C0];
  int64_t v4 = CFGetTypeID(a2);
  int64_t v5 = v4;
  char __src = 0;
  if (v4 > 19)
  {
    switch(v4)
    {
      case 20LL:
        CFIndex Length = CFDataGetLength((CFDataRef)a2);
        unint64_t v7 = Length;
        char v8 = 15;
        if (Length < 15) {
          char v8 = Length;
        }
        char __src = v8 | 0x40;
        bufferWrite_0((uint64_t)a1, &__src, 1LL);
        if (v7 <= 0x7F)
        {
          LOBYTE(valuePtr[0]) = v7 ^ 0x80;
          LOBYTE(v54) = 16;
          bufferWrite_0((uint64_t)a1, &v54, 1LL);
          p_CFIndex usedBufLen = (CFIndex *)valuePtr;
LABEL_67:
          uint64_t v34 = (uint64_t)a1;
          uint64_t v35 = 1LL;
          goto LABEL_68;
        }

        if (!(v7 >> 15))
        {
          LOBYTE(valuePtr[0]) = 17;
          bufferWrite_0((uint64_t)a1, valuePtr, 1LL);
          LOBYTE(v54) = v7;
          LOBYTE(usedBufLen) = BYTE1(v7) ^ 0x80;
          bufferWrite_0((uint64_t)a1, &v54, 1LL);
          p_CFIndex usedBufLen = &usedBufLen;
          goto LABEL_67;
        }

        if (!(v7 >> 31))
        {
          LOBYTE(valuePtr[0]) = 18;
          bufferWrite_0((uint64_t)a1, valuePtr, 1LL);
          LOBYTE(usedBufLen) = BYTE1(v7);
          LOBYTE(v54) = v7;
          char v53 = BYTE2(v7);
          char v52 = BYTE3(v7) ^ 0x80;
          bufferWrite_0((uint64_t)a1, &v54, 1LL);
          bufferWrite_0((uint64_t)a1, &usedBufLen, 1LL);
          bufferWrite_0((uint64_t)a1, &v53, 1LL);
          p_CFIndex usedBufLen = (CFIndex *)&v52;
          goto LABEL_67;
        }

        LOBYTE(valuePtr[0]) = 19;
        *(_WORD *)((char *)valuePtr + __postAndResetMidnight(1, 1) = v7;
        BYTE3(valuePtr[0]) = BYTE2(v7);
        BYTE4(valuePtr[0]) = BYTE3(v7);
        BYTE5(valuePtr[0]) = BYTE4(v7);
        BYTE6(valuePtr[0]) = BYTE5(v7);
        HIBYTE(valuePtr[0]) = BYTE6(v7);
        LOBYTE(valuePtr[1]) = HIBYTE(v7) ^ 0x80;
        p_CFIndex usedBufLen = (CFIndex *)valuePtr;
        uint64_t v34 = (uint64_t)a1;
        uint64_t v35 = 9LL;
LABEL_68:
        bufferWrite_0(v34, p_usedBufLen, v35);
LABEL_69:
        BytePtr = (CFUUIDBytes *)CFDataGetBytePtr((CFDataRef)a2);
        uint64_t v31 = (uint64_t)a1;
        uint64_t v32 = v7;
        break;
      case 21LL:
        if (CFBooleanGetValue((CFBooleanRef)a2)) {
          char v13 = 9;
        }
        else {
          char v13 = 8;
        }
        char __src = v13;
        uint64_t v10 = 1LL;
        p_src = &__src;
        uint64_t v15 = (uint64_t)a1;
        uint64_t v16 = 1LL;
        goto LABEL_54;
      case 22LL:
        if (!CFNumberIsFloatType((CFNumberRef)a2))
        {
          if (_CFNumberGetType2((unint64_t *)a2) == 17)
          {
            CFNumberGetValue((CFNumberRef)a2, kCFNumberMaxType|kCFNumberSInt8Type, &v54);
            LOBYTE(valuePtr[0]) = 20;
            *(unint64_t *)((char *)valuePtr + __postAndResetMidnight(1, 1) = *((void *)&v54 + 1);
            *(unint64_t *)((char *)&valuePtr[1] + __postAndResetMidnight(1, 1) = v54 ^ 0x8000000000000000LL;
            BytePtr = (CFUUIDBytes *)valuePtr;
            uint64_t v31 = (uint64_t)a1;
            uint64_t v32 = 17LL;
          }

          else
          {
            *(void *)&__int128 v54 = 0LL;
            CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt64Type, &v54);
            if ((void)v54 == (char)v54)
            {
              LOBYTE(valuePtr[0]) = v54 ^ 0x80;
              LOBYTE(usedBufLen) = 16;
              bufferWrite_0((uint64_t)a1, &usedBufLen, 1LL);
              BytePtr = (CFUUIDBytes *)valuePtr;
              uint64_t v31 = (uint64_t)a1;
              uint64_t v32 = 1LL;
            }

            else
            {
              LOBYTE(valuePtr[0]) = 19;
              *(unint64_t *)((char *)valuePtr + __postAndResetMidnight(1, 1) = v54 ^ 0x8000000000000000LL;
              BytePtr = (CFUUIDBytes *)valuePtr;
              uint64_t v31 = (uint64_t)a1;
              uint64_t v32 = 9LL;
            }
          }

          goto LABEL_70;
        }

        if (CFNumberGetByteSize((CFNumberRef)a2) > 4)
        {
          CFNumberGetValue((CFNumberRef)a2, kCFNumberFloat64Type, valuePtr);
          *(void *)&__int128 v54 = bswap64(valuePtr[0]);
          char __src = 35;
          uint64_t v10 = 1LL;
          bufferWrite_0((uint64_t)a1, &__src, 1LL);
          p_src = (char *)&v54;
          uint64_t v15 = (uint64_t)a1;
          uint64_t v16 = 8LL;
        }

        else
        {
          CFNumberGetValue((CFNumberRef)a2, kCFNumberFloat32Type, valuePtr);
          LODWORD(v54) = bswap32(valuePtr[0]);
          char __src = 34;
          uint64_t v10 = 1LL;
          bufferWrite_0((uint64_t)a1, &__src, 1LL);
          p_src = (char *)&v54;
          uint64_t v15 = (uint64_t)a1;
          uint64_t v16 = 4LL;
        }

void writeBytes_0(uint64_t a1, void *__src, uint64_t __len)
{
  if (__len >= 1)
  {
    uint64_t v14 = v5;
    uint64_t v15 = v4;
    uint64_t v16 = v3;
    if (!*(void *)(a1 + 24))
    {
      uint64_t v12 = *(void *)(a1 + 8);
      if (v12)
      {
        uint64_t v13 = *(void *)(a1 + 32);
        if (__CFADD__(__len, v13) || *(void *)(a1 + 16) < (unint64_t)(v13 + __len))
        {
          *(void *)(a1 + 24) = __CFPropertyListCreateError( 3851LL,  @"Binary property list writing could not be completed because databytes is full.",  v6,  v14,  v15,  v16,  v7,  v8);
          return;
        }

        memmove((void *)(v12 + v13), __src, __len);
      }

      if (*(void *)a1) {
        CFDataAppendBytes(*(CFMutableDataRef *)a1, (const UInt8 *)__src, __len);
      }
      *(void *)(a1 + 32) += __len;
    }
  }

uint64_t _CFGetProductName()
{
  if (_CFGetProductName_onceToken != -1) {
    dispatch_once(&_CFGetProductName_onceToken, &__block_literal_global_46);
  }
  return _CFGetProductName__cfBundlePlatform;
}

uint64_t _CFBundleGetProductNameSuffix()
{
  if (_CFBundleGetProductNameSuffix_onceToken != -1) {
    dispatch_once(&_CFBundleGetProductNameSuffix_onceToken, &__block_literal_global_3_0);
  }
  return _CFBundleGetProductNameSuffix__cfBundlePlatformSuffix;
}

CFStringRef _CFBundleGetPlatformNameSuffix()
{
  return @"-tvos";
}

CFStringRef _CFGetPlatformName()
{
  return @"tvos";
}

CFStringRef _CFGetAlternatePlatformName()
{
  return @"macos";
}

uint64_t _CFBundleSupportedPlatformName(const __CFString *a1, CFRange rangeToSearch)
{
  return CFStringFindWithOptions(a1, @"tvos", rangeToSearch, 8uLL, 0LL);
}

uint64_t _CFBundleSupportedProductName(const __CFString *a1, CFRange rangeToSearch)
{
  return CFStringFindWithOptions(a1, @"appletv", rangeToSearch, 8uLL, 0LL);
}

void _CFBundleInfoPlistProcessInfoDictionary(void *a1)
{
  void v8[7] = *MEMORY[0x1895F89C0];
  if (a1 && CFDictionaryGetCount((CFDictionaryRef)a1))
  {
    CFMutableStringRef Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, &kCFTypeArrayCallBacks);
    CFMutableDictionaryRef v3 = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    uint64_t v4 = MEMORY[0x1895F87A8];
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 0x40000000LL;
    _DWORD v8[2] = ___CFBundleInfoPlistProcessInfoDictionary_block_invoke;
    uint64_t v8[3] = &__block_descriptor_tmp_19_0;
    v8[4] = Mutable;
    v8[5] = v3;
    void v8[6] = a1;
    CFDictionaryApply(a1, (uint64_t)v8);
    if (CFArrayGetCount(Mutable) >= 1)
    {
      CFIndex v5 = 0LL;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v5);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, ValueAtIndex);
        ++v5;
      }

      while (v5 < CFArrayGetCount(Mutable));
    }

    v7[0] = v4;
    v7[1] = 0x40000000LL;
    v7[2] = ___CFBundleInfoPlistProcessInfoDictionary_block_invoke_2;
    _OWORD v7[3] = &__block_descriptor_tmp_20;
    void v7[4] = a1;
    CFDictionaryApply(v3, (uint64_t)v7);
    CFRelease(Mutable);
    CFRelease(v3);
  }

CFMutableDictionaryRef _CFBundleLoadLimitedInfoDictionary(uint64_t a1, const __CFSet *a2)
{
  v4[1] = *(CFTypeRef *)MEMORY[0x1895F89C0];
  if (*(void *)(a1 + 24)) {
    _CFBundleLoadLimitedInfoDictionary_cold_2();
  }
  v4[0] = 0LL;
  CFMutableDictionaryRef result = _CFBundleCopyInfoDictionaryInDirectoryWithVersion( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  *(CFURLRef *)(a1 + 16),  v4,  a2,  *(unsigned __int8 *)(a1 + 55),  *(unsigned __int8 *)(a1 + 53));
  *(void *)(a1 + 24) = result;
  if (*(void *)(a1 + 216)) {
    _CFBundleLoadLimitedInfoDictionary_cold_1();
  }
  *(CFTypeRef *)(a1 + 2++*(_WORD *)(cf + 16) = v4[0];
  return result;
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInDirectoryWithVersion( CFAllocatorRef allocator, CFURLRef baseURL, CFTypeRef *a3, const __CFSet *a4, uint64_t a5, int a6)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  if (!baseURL) {
    return 0LL;
  }
  switch(a6)
  {
    case 0:
      uint64_t v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Resources/", baseURL);
      int v11 = @"Resources/Info-iphoneos.plist";
      uint64_t v12 = @"Resources/Info.plist";
      if (v10) {
        goto LABEL_20;
      }
      return CFDictionaryCreateMutable(allocator, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    case 1:
      uint64_t v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Support%20Files/", baseURL);
      int v11 = @"Support%20Files/Info-iphoneos.plist";
      uint64_t v12 = @"Support%20Files/Info.plist";
      if (!v10) {
        return CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
      goto LABEL_20;
    case 2:
      uint64_t v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Contents/", baseURL);
      int v11 = @"Contents/Info-iphoneos.plist";
      uint64_t v12 = @"Contents/Info.plist";
      if (!v10) {
        return CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
      goto LABEL_20;
    case 3:
      uint64_t v14 = CFURLCopyFileSystemPath(baseURL, kCFURLPOSIXPathStyle);
      if (!v14) {
        return CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
      uint64_t v15 = v14;
      if (CFStringHasSuffix(v14, @"Support Files")
        || CFStringHasSuffix(v15, @"Contents")
        || CFStringHasSuffix(v15, @"Resources"))
      {
        uint64_t v10 = 0LL;
        int v11 = @"Resources/Info-iphoneos.plist";
        uint64_t v12 = @"Resources/Info.plist";
      }

      else
      {
        uint64_t v10 = (const __CFURL *)CFRetain(baseURL);
        int v11 = @"Info-iphoneos.plist";
        uint64_t v12 = @"Info.plist";
      }

      CFRelease(v15);
      if (!v10) {
        return CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
      goto LABEL_20;
    case 12:
      uint64_t v10 = CFURLCreateWithString( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  @"WrappedBundle/Contents/",  baseURL);
      int v11 = @"WrappedBundle/Contents/Info-iphoneos.plist";
      uint64_t v12 = @"WrappedBundle/Contents/Info.plist";
      if (!v10) {
        return CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
      goto LABEL_20;
    case 13:
      uint64_t v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"WrappedBundle/", baseURL);
      int v11 = @"WrappedBundle/Info-iphoneos.plist";
      uint64_t v12 = @"WrappedBundle/Info.plist";
      if (!v10) {
        return CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
LABEL_20:
      uint64_t v16 = CFURLCopyAbsoluteURL(v10);
      CFStringRef v17 = CFURLCopyFileSystemPath(v16, kCFURLPOSIXPathStyle);
      CFRelease(v16);
      uint64_t v51 = 0LL;
      char v52 = &v51;
      uint64_t v53 = 0x2000000000LL;
      uint64_t v54 = 0LL;
      uint64_t v47 = 0LL;
      CFUUIDBytes v48 = &v47;
      uint64_t v49 = 0x2000000000LL;
      uint64_t v50 = 0LL;
      if (v17)
      {
        CFIndex Length = CFStringGetLength(@"Info.plist");
        CFIndex v19 = CFStringGetLength(@"Info-iphoneos.plist");
        v46[0] = MEMORY[0x1895F87A8];
        v46[1] = 0x40000000LL;
        CFIndex v46[2] = ___CFBundleCopyInfoDictionaryInDirectoryWithVersion_block_invoke;
        v46[3] = &unk_1899EEC48;
        v46[6] = v19;
        v46[7] = v11;
        v46[4] = &v47;
        v46[5] = &v51;
        v46[8] = baseURL;
        v46[9] = Length;
        v46[10] = v12;
        _CFIterateDirectory(v17, 0, 0LL, (uint64_t)v46);
        CFRelease(v17);
      }

      CFRelease(v10);
      CFTypeRef v45 = 0LL;
      if (!a4) {
        goto LABEL_47;
      }
      char v20 = (const __CFURL *)v52[3];
      CFIndex v21 = (const __CFURL *)v48[3];
      BOOL v59 = v21;
      Class v60 = v20;
      if (v21)
      {
        *(void *)buf = 0LL;
        CFDataRef MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData( v21,  1,  0LL,  (BOOL *)resourceData,  (CFErrorRef *)buf);
        if (MappedOrLoadedPlistData)
        {
          CFTypeRef v45 = v21;
        }

        else if (*(void *)buf)
        {
          _CFBundleLogLoadingInfoPlistError((uint64_t)&v59, *(CFErrorRef *)buf);
          CFRelease(*(CFTypeRef *)buf);
        }
      }

      else
      {
        CFDataRef MappedOrLoadedPlistData = 0LL;
      }

      if (v20 && !MappedOrLoadedPlistData)
      {
        *(void *)buf = 0LL;
        CFDataRef MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData( v20,  1,  0LL,  (BOOL *)resourceData,  (CFErrorRef *)buf);
        if (MappedOrLoadedPlistData)
        {
          CFTypeRef v45 = v20;
        }

        else if (*(void *)buf)
        {
          _CFBundleLogLoadingInfoPlistError((uint64_t)&v60, *(CFErrorRef *)buf);
          CFRelease(*(CFTypeRef *)buf);
        }
      }

      if (!MappedOrLoadedPlistData)
      {
LABEL_47:
        resourceData[0] = 0LL;
        uint64_t v34 = (const __CFURL *)v48[3];
        if (v34
          && (CFURLCreateDataAndPropertiesFromResource( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v34,  resourceData,  0LL,  0LL,  0LL),  (uint64_t v35 = resourceData[0]) != 0LL))
        {
          char v36 = v48;
        }

        else
        {
          uint64_t v37 = (const __CFURL *)v52[3];
          if (!v37
            || (CFURLCreateDataAndPropertiesFromResource( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v37,  resourceData,  0LL,  0LL,  0LL),  (uint64_t v35 = resourceData[0]) == 0LL))
          {
            CFMutableStringRef Mutable = 0LL;
            goto LABEL_64;
          }

          char v36 = v52;
        }

        CFTypeRef v45 = (CFTypeRef)v36[3];
        error[0] = 0LL;
        CFMutableStringRef Mutable = (void *)CFPropertyListCreateWithData(allocator, v35, 1uLL, 0LL, error);
        if (Mutable)
        {
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (TypeID == CFGetTypeID(Mutable))
          {
            _CFBundleInfoPlistProcessInfoDictionary(Mutable);
LABEL_63:
            CFRelease(resourceData[0]);
            goto LABEL_64;
          }

          CFRelease(Mutable);
        }

        else if (error[0])
        {
          CFErrorDomain Domain = CFErrorGetDomain(error[0]);
          CFIndex Code = CFErrorGetCode(error[0]);
          uint64_t v41 = (os_log_s *)_CFBundleResourceLogger();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134349570;
            *(void *)&uint8_t buf[4] = v45;
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = Domain;
            *(_WORD *)&buf[22] = 2050;
            unint64_t v62 = (void *)Code;
            _os_log_error_impl( &dword_180A4C000,  v41,  OS_LOG_TYPE_ERROR,  "There was an error parsing the Info.plist for the bundle at URL <%{public}p>: %{public}@ - %{public}ld",  buf,  0x20u);
          }

          CFRelease(error[0]);
        }

        CFMutableStringRef Mutable = CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        goto LABEL_63;
      }

      CFErrorRef v58 = 0LL;
      CFIndex v23 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, MappedOrLoadedPlistData, 0, &v58);
      CFIndex v24 = v23;
      if (v23)
      {
        CFIndex Count = CFSetGetCount(v23);
        uint64_t v26 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, 0LL, 0LL);
        error[0] = (CFErrorRef)MEMORY[0x1895F87A8];
        error[1] = (CFErrorRef)0x40000000;
        CFErrorRef error[2] = (CFErrorRef)___CFBundleCopyLimitedInfoPlistKeys_block_invoke;
        error[3] = (CFErrorRef)&__block_descriptor_tmp_108;
        error[4] = v26;
        CFSetApply(v24, (uint64_t)error);
        _CFBundleInfoPlistProcessInfoDictionary(v26);
        TopLevelKeyPaths = __CFPropertyListCreateTopLevelKeyPaths( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  a4);
        CFIndex v28 = CFSetGetCount(a4);
        uint64_t v29 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v28, &kCFTypeSetCallBacks);
        CFIndex v30 = CFSetGetCount(a4);
        uint64_t v31 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v30, &kCFTypeSetCallBacks);
        resourceData[0] = (CFDataRef)MEMORY[0x1895F87A8];
        resourceData[1] = (CFDataRef)0x40000000;
        CFDataRef resourceData[2] = (CFDataRef)___CFBundleCopyLimitedInfoPlistKeys_block_invoke_2;
        resourceData[3] = (CFDataRef)&__block_descriptor_tmp_109;
        resourceData[4] = v26;
        resourceData[5] = v29;
        resourceData[6] = v31;
        CFSetApply(TopLevelKeyPaths, (uint64_t)resourceData);
        CFRelease(TopLevelKeyPaths);
        CFTypeRef cf = 0LL;
        if (_CFPropertyListCreateFiltered( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  MappedOrLoadedPlistData,  0LL,  v29,  &cf,  &v58))
        {
          CFTypeRef v32 = cf;
          CFIndex v33 = CFSetGetCount(v31);
          CFMutableStringRef Mutable = CFDictionaryCreateMutable( allocator,  v33,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          *(void *)buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = ___CFCopyLogicalKeysMappedToProcessedValues_block_invoke;
          unint64_t v62 = &__block_descriptor_tmp_110;
          uint64_t v63 = v26;
          CFTypeRef v64 = v32;
          CFTypeRef v65 = Mutable;
          CFSetApply(v31, (uint64_t)buf);
          CFRelease(cf);
        }

        else
        {
          CFMutableStringRef Mutable = 0LL;
        }

        CFRelease(v29);
        CFRelease(v24);
        CFRelease(v26);
        CFRelease(v31);
      }

      else
      {
        CFMutableStringRef Mutable = 0LL;
      }

      if (!Mutable && v58)
      {
        _CFBundleLogLoadingInfoPlistError((uint64_t)&v45, v58);
        CFRelease(v58);
      }

      CFRelease(MappedOrLoadedPlistData);
LABEL_64:
      if (a3 && v45)
      {
        CFRetain(v45);
        *a3 = v45;
      }

      uint64_t v42 = (const void *)v48[3];
      if (v42) {
        CFRelease(v42);
      }
      uint64_t v43 = (const void *)v52[3];
      if (v43) {
        CFRelease(v43);
      }
      _Block_object_dispose(&v47, 8);
      _Block_object_dispose(&v51, 8);
      if (!Mutable) {
        return CFDictionaryCreateMutable( allocator,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }
      return (CFMutableDictionaryRef)Mutable;
    default:
      return CFDictionaryCreateMutable(allocator, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }

void sub_180BD8A48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInDirectory( const __CFAllocator *a1, CFURLRef url, _BYTE *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026LL))
  {
    CFMutableDictionaryRef v11 = 0LL;
    char v10 = 0;
    if (!a3) {
      return v11;
    }
    goto LABEL_5;
  }

  size_t v6 = strlen((const char *)buffer);
  uint64_t v8 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v6, 1u);
  if (!v8) {
    uint64_t v8 = (const __CFURL *)CFRetain(url);
  }
  int BundleVersionForURL = _CFBundleGetBundleVersionForURL((uint64_t)v8, v7);
  char v10 = BundleVersionForURL;
  CFMutableDictionaryRef v11 = _CFBundleCopyInfoDictionaryInDirectoryWithVersion(a1, v8, 0LL, 0LL, 0LL, BundleVersionForURL);
  CFRelease(v8);
  if (a3) {
LABEL_5:
  }
    *a3 = v10;
  return v11;
}

CFDictionaryRef CFBundleCopyInfoDictionaryForURL(CFURLRef url)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  char v4 = 0;
  if (!_CFIsResourceAtURL(url, &v4)) {
    return 0LL;
  }
  if (v4) {
    return _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, 0LL);
  }
  return _CFBundleCopyInfoDictionaryInExecutable(url, v2);
}

uint64_t _CFBundleGetPackageInfoInDirectory(uint64_t a1, const __CFURL *a2, int *a3, _DWORD *a4)
{
  return _CFBundleGetPackageInfoInDirectoryWithInfoDictionary(a2, 0LL, a3, a4);
}

uint64_t _CFBundleGetPackageInfoInDirectoryWithInfoDictionary( CFURLRef baseURL, const __CFDictionary *a2, int *a3, _DWORD *a4)
{
  usedBufLen[257] = *MEMORY[0x1895F89C0];
  CFDataRef resourceData = 0LL;
  uint64_t v8 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Contents/PkgInfo", baseURL);
  CFURLCreateDataAndPropertiesFromResource( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v8,  &resourceData,  0LL,  0LL,  0LL);
  CFRelease(v8);
  int v9 = resourceData;
  if (!resourceData)
  {
    char v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"Support%20Files/PkgInfo", baseURL);
    CFURLCreateDataAndPropertiesFromResource( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v10,  &resourceData,  0LL,  0LL,  0LL);
    CFRelease(v10);
    int v9 = resourceData;
    if (!resourceData)
    {
      CFMutableDictionaryRef v11 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, @"PkgInfo", baseURL);
      CFURLCreateDataAndPropertiesFromResource( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v11,  &resourceData,  0LL,  0LL,  0LL);
      CFRelease(v11);
      int v9 = resourceData;
      if (!resourceData) {
        goto LABEL_14;
      }
    }
  }

  if (CFDataGetLength(v9) < 8)
  {
    if (resourceData) {
      CFRelease(resourceData);
    }
LABEL_14:
    uint64_t v16 = a2;
    if (!a2)
    {
      uint64_t v16 = _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, baseURL, 0LL);
      if (!v16)
      {
        BOOL v21 = 0;
        goto LABEL_42;
      }
    }

    Boolean Value = (const __CFString *)CFDictionaryGetValue(v16, @"CFBundlePackageType");
    uint64_t v18 = (const __CFString *)CFDictionaryGetValue(v16, @"CFBundleSignature");
    usedBufLen[0] = 0LL;
    if (Value && (CFTypeID v19 = CFGetTypeID(Value), v19 == CFStringGetTypeID()) && CFStringGetLength(Value) == 4)
    {
      v48.CFIndex location = 0LL;
      v48.size_t length = 4LL;
      uint64_t v14 = 0LL;
      if (CFStringGetBytes(Value, v48, 0, 0, 0, buffer, 4LL, usedBufLen) == 4 && usedBufLen[0] == 4)
      {
        if (a3) {
          *a3 = bswap32(*(unsigned int *)buffer);
        }
        uint64_t v14 = 1LL;
      }
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    if (v18 && (CFTypeID v20 = CFGetTypeID(v18), v20 == CFStringGetTypeID()) && CFStringGetLength(v18) == 4)
    {
      v49.CFIndex location = 0LL;
      v49.size_t length = 4LL;
      int v13 = 0;
      if (CFStringGetBytes(v18, v49, 0, 0, 0, buffer, 4LL, usedBufLen) == 4)
      {
        uint64_t v15 = v14;
        if (usedBufLen[0] == 4)
        {
          if (a4) {
            *a4 = bswap32(*(unsigned int *)buffer);
          }
          int v13 = 1;
          uint64_t v15 = 1LL;
        }

        goto LABEL_35;
      }
    }

    else
    {
      int v13 = 0;
    }

    uint64_t v15 = v14;
LABEL_35:
    if (!a2) {
      CFRelease(v16);
    }
    goto LABEL_37;
  }

  BytePtr = (unsigned int *)CFDataGetBytePtr(resourceData);
  if (a3) {
    *a3 = bswap32(*BytePtr);
  }
  if (a4) {
    *a4 = bswap32(BytePtr[1]);
  }
  if (resourceData) {
    CFRelease(resourceData);
  }
  int v13 = 1;
  LODWORD(v14) = 1;
  uint64_t v15 = 1LL;
LABEL_37:
  BOOL v21 = (_DWORD)v14 != 0;
  LOBYTE(v++*(_WORD *)(cf + 16) = v13 != 0;
  if (v13 && (_DWORD)v14) {
    return v15;
  }
  if ((_DWORD)v15)
  {
LABEL_43:
    if (a3) {
      char v22 = v21;
    }
    else {
      char v22 = 1;
    }
    if ((v22 & 1) != 0) {
      return 1LL;
    }
    CFIndex v23 = CFURLCopyAbsoluteURL(baseURL);
    CFIndex v24 = CFURLCopyFileSystemPath(v23, kCFURLPOSIXPathStyle);
    CFRelease(v23);
    if (!v24) {
      goto LABEL_107;
    }
    CFIndex Length = CFStringGetLength(v24);
    if (Length >= 1026) {
      CFIndex v26 = 1026LL;
    }
    else {
      CFIndex v26 = Length;
    }
    v50.CFIndex location = 0LL;
    v50.size_t length = v26;
    CFStringGetCharacters(v24, v50, (UniChar *)usedBufLen);
    CFRelease(v24);
    uint64_t v27 = _CFStartOfPathExtension(usedBufLen, v26);
    CFIndex v28 = v26 - v27;
    unint64_t v29 = (v26 - v27) & 0xFFFFFFFFFFFFFFFELL;
    switch(v29)
    {
      case 4uLL:
        if (*((_WORD *)usedBufLen + v27) != 46) {
          goto LABEL_107;
        }
        CFIndex v30 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v30 + 1) != 97 || *((_WORD *)v30 + 2) != 112 || *((_WORD *)usedBufLen + v27 + 3) != 112) {
          goto LABEL_107;
        }
        if (v28 == 4)
        {
LABEL_62:
          int v32 = 1095782476;
LABEL_108:
          *a3 = v32;
          return 1LL;
        }

        int v31 = *((unsigned __int16 *)&usedBufLen[1] + v27);
        break;
      case 6uLL:
        if (*((_WORD *)usedBufLen + v27) != 46) {
          goto LABEL_107;
        }
        if (*((_WORD *)usedBufLen + v27 + 1) != 100) {
          goto LABEL_107;
        }
        CFIndex v33 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v33 + 2) != 101) {
          goto LABEL_107;
        }
        if (*((_WORD *)v33 + 3) != 98) {
          goto LABEL_107;
        }
        uint64_t v34 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v34 + 4) != 117 || *((_WORD *)v34 + 5) != 103) {
          goto LABEL_107;
        }
        if (v28 == 6) {
          goto LABEL_62;
        }
        int v31 = *((unsigned __int16 *)&usedBufLen[1] + v27 + 2);
        break;
      case 8uLL:
        if (*((_WORD *)usedBufLen + v27) != 46) {
          goto LABEL_107;
        }
        if (*((_WORD *)usedBufLen + v27 + 1) == 112)
        {
          uint64_t v35 = (char *)usedBufLen + 2 * v27;
          if (*((_WORD *)v35 + 2) == 114 && *((_WORD *)v35 + 3) == 111)
          {
            char v36 = (char *)usedBufLen + 2 * v27;
            if (*((_WORD *)v36 + 4) == 102 && *((_WORD *)v36 + 5) == 105)
            {
              uint64_t v37 = (char *)usedBufLen + 2 * v27;
              if (*((_WORD *)v37 + 6) == 108
                && *((_WORD *)v37 + 7) == 101
                && (v28 == 8 || *((_WORD *)&usedBufLen[2] + v27) == 47))
              {
                goto LABEL_62;
              }
            }
          }
        }

        if (*((_WORD *)usedBufLen + v27 + 1) != 115
          || *((_WORD *)usedBufLen + v27 + 2) != 101
          || (uint64_t v38 = (char *)usedBufLen + 2 * v27, *((_WORD *)v38 + 3) != 114)
          || *((_WORD *)v38 + 4) != 118
          || (uint64_t v39 = (char *)usedBufLen + 2 * v27, *((_WORD *)v39 + 5) != 105)
          || *((_WORD *)v39 + 6) != 99
          || *((_WORD *)&usedBufLen[1] + v27 + 3) != 101)
        {
LABEL_107:
          int v32 = 1112425548;
          goto LABEL_108;
        }

        if (v28 == 8) {
          goto LABEL_62;
        }
        int v31 = *((unsigned __int16 *)&usedBufLen[2] + v27);
        break;
      default:
        if (v29 == 10 && *((_WORD *)usedBufLen + v27) == 46 && *((_WORD *)usedBufLen + v27 + 1) == 102)
        {
          uint64_t v40 = (char *)usedBufLen + 2 * v27;
          if (*((_WORD *)v40 + 2) == 114 && *((_WORD *)v40 + 3) == 97)
          {
            uint64_t v41 = (char *)usedBufLen + 2 * v27;
            if (*((_WORD *)v41 + 4) == 109 && *((_WORD *)v41 + 5) == 101)
            {
              uint64_t v42 = (char *)usedBufLen + 2 * v27;
              if (*((_WORD *)v42 + 6) == 119 && *((_WORD *)v42 + 7) == 111)
              {
                uint64_t v43 = (char *)usedBufLen + 2 * v27;
                if (*((_WORD *)v43 + 8) == 114
                  && *((_WORD *)v43 + 9) == 107
                  && (v28 == 10 || *((_WORD *)&usedBufLen[2] + v27 + 2) == 47))
                {
                  int v32 = 1179473739;
                  goto LABEL_108;
                }
              }
            }
          }
        }

        goto LABEL_107;
    }

    if (v31 == 47) {
      goto LABEL_62;
    }
    goto LABEL_107;
  }

void CFBundleGetPackageInfo(CFBundleRef bundle, UInt32 *packageType, UInt32 *packageCreator)
{
  size_t v6 = CFBundleCopyBundleURL(bundle);
  InfoDictionary = CFBundleGetInfoDictionary(bundle);
  if (!_CFBundleGetPackageInfoInDirectoryWithInfoDictionary( v6,  InfoDictionary,  (int *)packageType,  packageCreator))
  {
    if (packageType) {
      *packageType = 1112425548;
    }
    if (packageCreator) {
      *packageCreator = 1061109567;
    }
  }

  if (v6) {
    CFRelease(v6);
  }
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  os_unfair_lock_lock((os_unfair_lock_t)bundle + 28);
  _CFBundleRefreshInfoDictionaryAlreadyLocked((uint64_t)bundle);
  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
  return (CFDictionaryRef)*((void *)bundle + 3);
}

Boolean CFBundleGetPackageInfoInDirectory(CFURLRef url, UInt32 *packageType, UInt32 *packageCreator)
{
  return _CFBundleGetPackageInfoInDirectoryWithInfoDictionary(url, 0LL, (int *)packageType, packageCreator);
}

CFDictionaryRef CFBundleCopyInfoDictionaryInDirectory(CFURLRef bundleURL)
{
  return _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, bundleURL, 0LL);
}

void _CFBundleRefreshInfoDictionaryAlreadyLocked(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!*(void *)(a1 + 24))
  {
    CFTypeRef v29 = 0LL;
    unint64_t v2 = _CFBundleCopyInfoDictionaryInDirectoryWithVersion( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  *(CFURLRef *)(a1 + 16),  &v29,  0LL,  *(unsigned __int8 *)(a1 + 55),  *(unsigned __int8 *)(a1 + 53));
    *(void *)(a1 + 24) = v2;
    CFMutableDictionaryRef v3 = *(const void **)(a1 + 216);
    if (v3)
    {
      CFRelease(v3);
      unint64_t v2 = *(const __CFDictionary **)(a1 + 24);
    }

    *(void *)(a1 + 2++*(_WORD *)(cf + 16) = v29;
    if (v2)
    {
      Boolean Value = (const __CFString *)CFDictionaryGetValue(v2, @"CFBundleNumericVersion");
      if (Value || (Boolean Value = (const __CFString *)CFDictionaryGetValue(v2, @"CFBundleVersion")) != 0LL)
      {
        CFTypeID v5 = CFGetTypeID(Value);
        if (v5 == CFStringGetTypeID())
        {
          CFIndex Length = CFStringGetLength(Value);
          if ((unint64_t)(Length - 11) < 0xFFFFFFFFFFFFFFF6LL)
          {
LABEL_10:
            int v7 = 0;
LABEL_54:
            *(_DWORD *)__int128 buffer = v7;
            CFIndex v24 = CFGetAllocator((CFTypeRef)a1);
            CFNumberRef v25 = CFNumberCreate(v24, kCFNumberSInt32Type, buffer);
            CFDictionarySetValue(v2, @"CFBundleNumericVersion", v25);
            CFRelease(v25);
            return;
          }

          unint64_t v9 = Length;
          v33.CFIndex location = 0LL;
          v33.size_t length = Length;
          CFStringGetCharacters(Value, v33, buffer);
          int v10 = buffer[0];
          if ((unsigned __int16)(buffer[0] - 58) >= 0xFFF6u)
          {
            int v15 = buffer[0] - 48;
            if (v9 < 2)
            {
              int v17 = 0;
              int v11 = 0;
              unsigned int v19 = 0;
              BOOL v20 = 0;
              int v21 = 0x8000;
              int v14 = buffer[0] - 48;
              int v15 = 0;
LABEL_50:
              int v7 = v21 + (v17 << 20) + (v14 << 24) + (v15 << 28) + v11 + v19;
              if (v20) {
                int v7 = 0;
              }
              if (v19 > 0xFF) {
                int v7 = 0;
              }
              goto LABEL_54;
            }

            int v10 = buffer[1];
            if ((unsigned __int16)(buffer[1] - 58) >= 0xFFF6u)
            {
              int v14 = buffer[1] - 48;
              if (v9 < 3) {
                goto LABEL_30;
              }
              int v10 = v31;
              if (v31 != 46)
              {
                int v11 = 0;
                int v17 = 0;
                uint64_t v16 = &v31;
                v9 -= 2LL;
                goto LABEL_41;
              }

              uint64_t v12 = -3LL;
              uint64_t v13 = 3LL;
LABEL_17:
              v9 += v12;
              if (v9)
              {
                uint64_t v16 = &buffer[v13];
                int v10 = *v16;
                if ((unsigned __int16)(v10 - 58) < 0xFFF6u)
                {
                  int v11 = 0;
                  int v17 = 0;
LABEL_41:
                  int v18 = v15;
                  goto LABEL_42;
                }

                int v17 = v10 - 48;
                if (v9 >= 2)
                {
                  int v10 = v16[1];
                  if (v10 != 46)
                  {
                    int v11 = 0;
                    --v9;
                    ++v16;
                    goto LABEL_41;
                  }

                  if (v9 != 2)
                  {
                    int v10 = v16[2];
                    if ((unsigned __int16)(v10 - 58) < 0xFFF6u)
                    {
                      int v11 = 0;
                      v9 -= 2LL;
                      v16 += 2;
                      goto LABEL_41;
                    }

                    int v11 = (v10 << 16) - 3145728;
                    v9 -= 3LL;
                    if (v9)
                    {
                      int v28 = v16[3];
                      v16 += 3;
                      int v10 = v28;
                      goto LABEL_41;
                    }

                    goto LABEL_37;
                  }
                }

CFDictionaryRef CFBundleGetLocalInfoDictionary(CFBundleRef bundle)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  unint64_t v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31) {
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  }
  os_unfair_lock_lock_with_options();
  ValueWithKeyPath = (void *)*((void *)bundle + 4);
  if (!ValueWithKeyPath)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
    _CFBundleGetStringsSources((uint64_t)bundle, 1LL, @"InfoPlist", 0LL, (uint64_t)v14);
    if (data[0])
    {
      ValueWithKeyPath = (void *)CFPropertyListCreateWithData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  data[0],  1uLL,  0LL,  0LL);
      if (!ValueWithKeyPath) {
        goto LABEL_20;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(ValueWithKeyPath))
      {
        CFMutableDictionaryRef v6 = 0LL;
LABEL_19:
        CFRelease(ValueWithKeyPath);
        ValueWithKeyPath = v6;
LABEL_20:
        __int128 v11 = v16;
        __int128 v12 = v17;
        uint64_t v13 = v18;
        *(_OWORD *)CFTypeRef cf = *(_OWORD *)v14;
        __int128 v10 = *(_OWORD *)data;
        _CFBundleReleaseStringsSources_0((uint64_t)cf);
        os_unfair_lock_lock_with_options();
        if (*((void *)bundle + 4))
        {
          if (ValueWithKeyPath) {
            CFRelease(ValueWithKeyPath);
          }
          ValueWithKeyPath = (void *)*((void *)bundle + 4);
        }

        else
        {
          *((void *)bundle + 4) = ValueWithKeyPath;
        }

        goto LABEL_3;
      }
    }

    else
    {
      ValueWithKeyPath = 0LL;
      if (!*((void *)&v17 + 1) || !v14[1]) {
        goto LABEL_20;
      }
      int v7 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, &v14[1], 1LL, &kCFTypeSetCallBacks);
      cf[0] = 0LL;
      ValueWithKeyPath = 0LL;
      if (_CFPropertyListCreateFiltered( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  *((CFDataRef *)&v17 + 1),  1LL,  v7,  cf,  0LL))
      {
        ValueWithKeyPath = (void *)_CFPropertyListGetValueWithKeyPath(cf[0], (const __CFString *)v14[1]);
        if (ValueWithKeyPath)
        {
          CFTypeID v8 = CFDictionaryGetTypeID();
          if (v8 == CFGetTypeID(ValueWithKeyPath)) {
            CFRetain(ValueWithKeyPath);
          }
          else {
            ValueWithKeyPath = 0LL;
          }
        }
      }

      if (cf[0]) {
        CFRelease(cf[0]);
      }
      CFRelease(v7);
      if (!ValueWithKeyPath) {
        goto LABEL_20;
      }
    }

    _CFBundleInfoPlistProcessInfoDictionary(ValueWithKeyPath);
    CFMutableDictionaryRef v6 = _parseBundleStrings((uint64_t)bundle, (CFDictionaryRef)ValueWithKeyPath);
    if (!v6) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

CFMutableDictionaryRef _parseBundleStrings(uint64_t a1, CFDictionaryRef theDict)
{
  void v7[6] = *MEMORY[0x1895F89C0];
  CFIndex Count = CFDictionaryGetCount(theDict);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  Count,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 0x40000000LL;
  v7[2] = ___parseBundleStrings_block_invoke;
  _OWORD v7[3] = &__block_descriptor_tmp_117;
  void v7[4] = a1;
  void v7[5] = Mutable;
  CFDictionaryApply(theDict, (uint64_t)v7);
  return Mutable;
}

void _CFBundleReleaseStringsSources_0(uint64_t a1)
{
  unint64_t v2 = *(const void **)a1;
  if (v2) {
    CFRelease(v2);
  }
  CFMutableDictionaryRef v3 = *(const void **)(a1 + 8);
  if (v3) {
    CFRelease(v3);
  }
  char v4 = *(const void **)(a1 + 16);
  if (v4) {
    CFRelease(v4);
  }
  CFTypeID v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRelease(v5);
  }
  CFMutableDictionaryRef v6 = *(const void **)(a1 + 32);
  if (v6) {
    CFRelease(v6);
  }
  int v7 = *(const void **)(a1 + 40);
  if (v7) {
    CFRelease(v7);
  }
  CFTypeID v8 = *(const void **)(a1 + 48);
  if (v8) {
    CFRelease(v8);
  }
  unint64_t v9 = *(const void **)(a1 + 56);
  if (v9) {
    CFRelease(v9);
  }
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  CFTypeRef result = 0LL;
  if (bundle)
  {
    if (key)
    {
      LocalInfoDictionary = CFBundleGetLocalInfoDictionary(bundle);
      if (!LocalInfoDictionary || (CFTypeRef result = CFDictionaryGetValue(LocalInfoDictionary, key)) == 0LL)
      {
        CFTypeRef result = CFBundleGetInfoDictionary(bundle);
        if (result) {
          return CFDictionaryGetValue((CFDictionaryRef)result, key);
        }
      }
    }
  }

  return result;
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  CFStringRef result = (CFStringRef)CFBundleGetInfoDictionary(bundle);
  if (result) {
    return (CFStringRef)CFDictionaryGetValue((CFDictionaryRef)result, @"CFBundleIdentifier");
  }
  return result;
}

CFDictionaryRef _CFBundleCreateFilteredInfoPlist(uint64_t a1, void *a2, char a3)
{
  v17[1] = *(void **)MEMORY[0x1895F89C0];
  CFMutableDictionaryRef v6 = (const __CFURL *)_CFBundleCopyInfoPlistURL(a1);
  if (!v6) {
    return CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  int v7 = v6;
  uint64_t v8 = *(unsigned __int8 *)(a1 + 55);
  unint64_t v9 = CFURLCopyAbsoluteURL(v6);
  __int128 v10 = (__CFString *)CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
  CFRelease(v9);
  if (v10
    && (size_t v16 = 0LL,
        v17[0] = 0LL,
        int v11 = a3 & 1,
        int v12 = _CFReadMappedFromFile(v10, v11, 0, v17, (off_t *)&v16, 0LL),
        CFRelease(v10),
        v12))
  {
    uint64_t v13 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)v17[0],  v16,  (CFAllocatorRef)&__kCFAllocatorNull);
    FilteredInfoPlistWithData = (void *)_CFBundleCreateFilteredInfoPlistWithData(v13, a2, v8, 0LL, (uint64_t)v7);
    CFRelease(v13);
    if (v11) {
      munmap(v17[0], v16);
    }
    else {
      free(v17[0]);
    }
  }

  else
  {
    FilteredInfoPlistWithData = CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }

  CFRelease(v7);
  return (CFDictionaryRef)FilteredInfoPlistWithData;
}

CFTypeRef _CFBundleCopyInfoPlistURL(uint64_t a1)
{
  unint64_t v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  CFMutableDictionaryRef v3 = *(const void **)(a1 + 216);
  if (v3) {
    CFTypeRef v4 = CFRetain(v3);
  }
  else {
    CFTypeRef v4 = 0LL;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

CFDictionaryRef _CFBundleCreateFilteredLocalizedInfoPlist(uint64_t a1, void *a2, void *a3, char a4)
{
  values[1] = *(void **)MEMORY[0x1895F89C0];
  values[0] = a3;
  if (!a1) {
    return CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  if (a3)
  {
    int v7 = CFArrayCreate(0LL, (const void **)values, 1LL, &kCFTypeArrayCallBacks);
    _CFBundleGetStringsSources(a1, a4 & 1, @"InfoPlist", v7, (uint64_t)&v18);
    if (v7) {
      CFRelease(v7);
    }
  }

  else
  {
    _CFBundleGetStringsSources(a1, a4 & 1, @"InfoPlist", 0LL, (uint64_t)&v18);
  }

  unint64_t v9 = (const __CFData *)v19;
  if ((void)v19)
  {
    uint64_t v10 = *(unsigned __int8 *)(a1 + 55);
    uint64_t v11 = v18;
    int v12 = a2;
    uint64_t v13 = 0LL;
  }

  else
  {
    unint64_t v9 = (const __CFData *)*((void *)&v21 + 1);
    uint64_t v10 = *(unsigned __int8 *)(a1 + 55);
    uint64_t v13 = values[0];
    int v12 = a2;
    uint64_t v11 = 0LL;
  }

  FilteredInfoPlistWithData = (const __CFDictionary *)_CFBundleCreateFilteredInfoPlistWithData(v9, v12, v10, v13, v11);
  size_t v16[2] = v20;
  v16[3] = v21;
  uint64_t v17 = v22;
  v16[0] = v18;
  v16[1] = v19;
  _CFBundleReleaseStringsSources_0((uint64_t)v16);
  if (!FilteredInfoPlistWithData) {
    return 0LL;
  }
  CFMutableDictionaryRef v15 = _parseBundleStrings(a1, FilteredInfoPlistWithData);
  CFRelease(FilteredInfoPlistWithData);
  return v15;
}

CFTypeRef _CFBundleCreateFilteredInfoPlistWithData( const __CFData *a1, void *a2, uint64_t a3, const void *a4, uint64_t a5)
{
  v24[5] = *MEMORY[0x1895F89C0];
  CFSetApply(a2, (uint64_t)&__block_literal_global_119);
  CFIndex Count = CFSetGetCount((CFSetRef)a2);
  CFMutableDictionaryRef Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
  uint64_t v11 = MEMORY[0x1895F87A8];
  v24[0] = MEMORY[0x1895F87A8];
  v24[1] = 0x40000000LL;
  v24[2] = ___CFBundleCreateFilteredInfoPlistWithData_block_invoke_2;
  v24[3] = &__block_descriptor_tmp_133;
  v24[4] = Mutable;
  CFSetApply(a2, (uint64_t)v24);
  if (a4)
  {
    CFIndex v12 = CFSetGetCount(Mutable);
    CFMutableSetRef v13 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, &kCFTypeSetCallBacks);
    v23[0] = v11;
    v23[1] = 0x40000000LL;
    void v23[2] = ___CFBundleCreateFilteredInfoPlistWithData_block_invoke_3;
    v23[3] = &__block_descriptor_tmp_136;
    v23[4] = a4;
    v23[5] = v13;
    CFSetApply(Mutable, (uint64_t)v23);
    CFRelease(Mutable);
    CFMutableDictionaryRef Mutable = v13;
  }

  CFTypeRef cf = 0LL;
  if (_CFPropertyListCreateFiltered( (const __CFAllocator *)&__kCFAllocatorSystemDefault,  a1,  1LL,  Mutable,  &cf,  0LL)) {
    BOOL v14 = cf == 0LL;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14) {
    goto LABEL_14;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFTypeID v16 = CFGetTypeID(cf);
  uint64_t v17 = (void *)cf;
  if (TypeID != v16)
  {
    CFRelease(cf);
    __int128 v20 = (os_log_s *)_CFBundleResourceLogger();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      _CFBundleCreateFilteredInfoPlistWithData_cold_1(a5, (uint64_t)a2, v20);
    }
LABEL_14:
    CFTypeRef cf = CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    goto LABEL_18;
  }

  if (a4)
  {
    Boolean Value = (void *)CFDictionaryGetValue((CFDictionaryRef)cf, a4);
    if (Value && (v17 = Value, CFTypeID v19 = CFDictionaryGetTypeID(), v19 == CFGetTypeID(v17)))
    {
      CFRetain(v17);
      CFRelease(cf);
    }

    else
    {
      CFRelease(cf);
      uint64_t v17 = CFDictionaryCreate( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    }

    CFTypeRef cf = v17;
  }

  _CFBundleInfoPlistProcessInfoDictionary(v17);
LABEL_18:
  CFRelease(Mutable);
  return cf;
}

void ___isValidSpecialCase_block_invoke()
{
  int v0 = dlopen("/usr/lib/libMobileGestalt.dylib", 5);
  if (v0)
  {
    uint64_t v1 = (uint64_t (*)(const __CFString *, void))dlsym(v0, "MGCopyAnswer");
    if (v1)
    {
      unint64_t v2 = (const void *)v1(@"h63QSdBCiT/z0WU6rdQv6Q", 0LL);
      if (v2)
      {
        CFMutableDictionaryRef v3 = v2;
        _isValidSpecialCase_useSpecialCase = CFEqual(v2, @"CH") != 0;
        CFRelease(v3);
      }

      else
      {
        _isValidSpecialCase_useSpecialCase = 0;
      }
    }
  }

void _CFBundleLogLoadingInfoPlistError(uint64_t a1, CFErrorRef err)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  CFErrorDomain Domain = CFErrorGetDomain(err);
  CFIndex Code = CFErrorGetCode(err);
  CFMutableDictionaryRef v6 = (os_log_s *)_CFBundleResourceLogger();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    int v7 = 134349570;
    uint64_t v8 = a1;
    __int16 v9 = 2114;
    CFErrorDomain v10 = Domain;
    __int16 v11 = 2050;
    CFIndex v12 = Code;
    _os_log_error_impl( &dword_180A4C000,  v6,  OS_LOG_TYPE_ERROR,  "There was an error parsing the Info.plist for the bundle at URL <%{public}p>: %{public}@ - %{public}ld",  (uint8_t *)&v7,  0x20u);
  }

void ___parseBundleStrings_block_invoke(uint64_t a1, const void *a2, __CFString *cf)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    uint64_t v8 = *(__CFBundle **)(a1 + 32);
    int v7 = (void *)(a1 + 32);
    __int16 v9 = (const void *)_CFStringCreateByParsingMarkdownAndInflectingIfNeeded(cf, v8, 0LL);
    CFErrorDomain v10 = (__CFDictionary *)v7[1];
    if (v9)
    {
      CFDictionaryAddValue(v10, a2, v9);
      CFRelease(v9);
    }

    else
    {
      CFDictionaryAddValue(v10, a2, cf);
      __int16 v11 = (os_log_s *)_CFBundleResourceLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        ___parseBundleStrings_block_invoke_cold_1((uint64_t)a2, v7, v11);
      }
    }
  }

  else
  {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), a2, cf);
  }

void OUTLINED_FUNCTION_0_34(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void OUTLINED_FUNCTION_1_24( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

uint64_t OUTLINED_FUNCTION_0_35(uint64_t a1, const __CFString *a2)
{
  return _CFThrowFormattedException(v2, a2);
}

uint64_t _CFPrefsSetSynchronizeIsSynchronous(uint64_t result)
{
  _CFPrefsSynchronizeIsSynchronous = (_DWORD)result != 0;
  return result;
}

void _CFPrefsImpersonateApplicationWithIdentifierAndPID()
{
  int v0 = (os_log_s *)_CFOSLog();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_FAULT)) {
    _CFPrefsImpersonateApplicationWithIdentifierAndPID_cold_1();
  }
}

uint64_t _CFPrefsImpersonateApplicationWithIdentifierAndAuditToken(uint64_t a1, __int128 *a2)
{
  __int128 v2 = a2[1];
  _CFPrefsAuditTokenToImpersonate = *a2;
  *(_OWORD *)&qword_18C53A0D4 = v2;
  return _CFPrefsImpersonateApplicationWithIdentifierAndContainerDataPath(a1, 0LL);
}

BOOL _CFPrefsGetImpersonatedApplicationAuditToken(_OWORD *a1)
{
  uint64_t v1 = _CFPrefsAuditTokenToImpersonate | *((void *)&_CFPrefsAuditTokenToImpersonate + 1) | qword_18C53A0D4 | unk_18C53A0DC;
  if (a1 && v1)
  {
    __int128 v2 = *(_OWORD *)&qword_18C53A0D4;
    *a1 = _CFPrefsAuditTokenToImpersonate;
    a1[1] = v2;
  }

  return v1 != 0;
}

CFTypeRef _copyValueForKey(uint64_t a1, void *key)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (byte_18C536D9D) {
    objc_msgSend((id)a1, "alreadylocked_clearCache");
  }
  *(void *)__int128 v18 = MEMORY[0x1895F87A8];
  *(void *)&v18[8] = 3221225472LL;
  *(void *)&v18[16] = __alreadylocked_requestNewDataIfStale_block_invoke;
  CFTypeID v19 = &unk_18999B4C8;
  uint64_t v20 = a1;
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)(a1 + 105));
  if ((v4 & 1) == 0)
  {
    CFTypeID v5 = (unsigned int *)atomic_load((unint64_t *)(a1 + 40));
    if (!v5
      || (unsigned int v6 = atomic_load(v5), v7 = atomic_load((unsigned int *)&sentinelGeneration), v6 != v7)
      && (unsigned int v8 = atomic_load((unsigned int *)(a1 + 48)), v6 != v8))
    {
      os_unfair_lock_assert_owner((os_unfair_lock_t)(a1 + 52));
      (*(void (**)(_BYTE *))&v18[16])(v18);
    }
  }

  if (atomic_load((unint64_t *)(a1 + 88)))
  {
    os_unfair_lock_lock(&locallySetDictLock);
    CFErrorDomain v10 = (const __CFDictionary *)atomic_load((unint64_t *)(a1 + 88));
    Boolean Value = (__CFString *)CFDictionaryGetValue(v10, key);
    os_unfair_lock_unlock(&locallySetDictLock);
    if (Value == @"MagicRemovedValue") {
      goto LABEL_13;
    }
    if (Value) {
      goto LABEL_14;
    }
  }

  CFIndex v12 = *(const __CFDictionary **)(a1 + 16);
  if (v12)
  {
    Boolean Value = (__CFString *)CFDictionaryGetValue(v12, key);
    goto LABEL_14;
  }

void sub_180BDB8F0(_Unwind_Exception *a1)
{
}

void locallySetValueOverlayMergeFunc(void *key, const __CFString *value, CFMutableDictionaryRef theDict)
{
  if (value == @"MagicRemovedValue") {
    CFDictionaryRemoveValue(theDict, key);
  }
  else {
    CFDictionarySetValue(theDict, key, value);
  }
}

LABEL_86:
  if (cfb)
  {
    p_generationCFIndex Count = &self->super._generationCount;
    do
      uint64_t v51 = __ldaxr((unint64_t *)p_generationCount);
    while (__stlxr(v51 + 1, (unint64_t *)p_generationCount));
  }

void sub_180BDC3E0(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x180BDC200LL);
  }

  _Unwind_Resume(exc_buf);
}

void sub_180BDC420(_Unwind_Exception *a1)
{
}

void sub_180BDC438(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x180BDC444LL);
}

void sub_180BDC7CC()
{
}

void sub_180BDC7E4( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *exc_buf)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x180BDC7A4LL);
  }

  _Unwind_Resume(v10);
}

void sub_180BDC7FC()
{
}

void sub_180BDC804()
{
}

void sub_180BDC81C()
{
}

void sub_180BDC834(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x180BDC83CLL);
  }
  objc_terminate();
}

void sub_180BDD970(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x180BDD8DCLL);
  }

  _Unwind_Resume(a1);
}

void sub_180BDE4DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_180BDE794(_Unwind_Exception *a1)
{
}

void sub_180BDE950( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

void sub_180BDEB8C(_Unwind_Exception *exception_object)
{
}

uint64_t _CFPrefSetInvalidPropertyListDeletionEnabled(uint64_t result)
{
  atomic_store((_DWORD)result != 0, requestInvalidPropertyListDeletion);
  return result;
}

void sub_180BDEE28(_Unwind_Exception *a1)
{
}

LABEL_95:
    if (object_getClass((id)v16) != (Class)MEMORY[0x1895F9240]) {
      goto LABEL_118;
    }
    uint64_t v51 = xpc_data_get_length((xpc_object_t)v16);
    if (v51 > 0x7FFFFFFFFFFFFFFELL) {
      goto LABEL_118;
    }
    *(void *)&v79.st_dev = 0LL;
    char v52 = (const UInt8 *)xpc_data_get_bytes_ptr((xpc_object_t)v16);
    uint64_t v53 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v52,  v51,  (CFAllocatorRef)&__kCFAllocatorNull);
    uint64_t v54 = (const __CFDictionary *)CFPropertyListCreateWithData( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  v53,  0LL,  0LL,  (CFErrorRef *)&v79);
    __int128 v55 = v54;
    if (!v54 || CFGetTypeID(v54) != 18)
    {
      CFRange v56 = -[CFPrefsSource copyOSLogDescription](self, "copyOSLogDescription");
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
      CFRange v57 = (os_log_s *)_CFPrefsClientLog();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR)) {
        -[CFPrefsPlistSource handleReply:toRequestNewDataMessage:onConnection:retryCount:error:].cold.1();
      }
      _CFSetTSD(0xFu, 0LL, 0LL);
      CFRelease(v56);
      if (*(void *)&v79.st_dev) {
        CFRelease(*(CFTypeRef *)&v79.st_dev);
      }
    }

    if (v53) {
      CFRelease(v53);
    }
    if (v55)
    {
      if (CFDictionaryGetCount(v55) >= 1)
      {
        if (!Mutable) {
          CFMutableDictionaryRef Mutable = (__CFString *)CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        }
        context[0] = MEMORY[0x1895F87A8];
        context[1] = 3221225472LL;
        context[2] = __88__CFPrefsPlistSource_handleReply_toRequestNewDataMessage_onConnection_retryCount_error___block_invoke_57;
        context[3] = &unk_1899EEEB8;
        context[5] = Mutable;
        context[6] = v55;
        context[4] = self;
        CFDictionaryApplyFunction(v55, (CFDictionaryApplierFunction)applyDictBlock, context);
      }

      CFRelease(v55);
    }

LABEL_111:
    CFErrorRef v58 = (os_log_s *)_CFPrefsClientLog();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
    {
      BOOL v59 = -[CFPrefsSource copyOSLogDescription](self, "copyOSLogDescription");
      Class v60 = v14 == -1;
      if (!xdata) {
        Class v60 = 0;
      }
      if (v60)
      {
        Class v61 = "a new base plist";
      }

      else if (self->super._dict)
      {
        Class v61 = "the same base plist";
      }

      else
      {
        Class v61 = "an empty base plist";
      }

      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0LL);
      CFTypeRef v64 = (os_log_s *)_CFPrefsClientLog();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        CFStringEncoding v70 = "no additional changes from the base plist";
        v79.st_dev = 138543874;
        *(void *)&v79.st_mode = v59;
        WORD2(v79.st_ino) = 2080;
        if (value) {
          CFStringEncoding v70 = "a diff relative to the base plist";
        }
        *(__darwin_ino64_t *)((char *)&v79.st_ino + 6) = (__darwin_ino64_t)v61;
        HIWORD(v79.st_gid) = 2080;
        *(void *)&v79.st_rdev = v70;
        _os_log_debug_impl( &dword_180A4C000,  v64,  OS_LOG_TYPE_DEBUG,  "%{public}@ loaded: %s and %s",  (uint8_t *)&v79,  0x20u);
      }

      _CFSetTSD(0xFu, 0LL, 0LL);
      CFRelease(v59);
    }

    dict = self->super._dict;
    if (dict) {
      CFRelease(dict);
    }
    if (Mutable) {
      uint64_t v66 = v17;
    }
    else {
      uint64_t v66 = 0;
    }
    if (v66 == 1)
    {
      CFMutableSetRef MutableCopy = CFDictionaryCreateMutableCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  (CFDictionaryRef)Mutable);
      CFRelease(Mutable);
      CFMutableDictionaryRef Mutable = (__CFString *)MutableCopy;
    }

    self->super._dict = (__CFDictionary *)Mutable;
    p_generationCFIndex Count = &self->super._generationCount;
    do
      unint64_t v69 = __ldaxr((unint64_t *)p_generationCount);
    while (__stlxr(v69 + 1, (unint64_t *)p_generationCount));
    return;
  }

  if (object_getClass((id)value) == (Class)MEMORY[0x1895F9220])
  {
    size_t count = xpc_array_get_count((xpc_object_t)value);
    if ((count & 1) != 0 || Mutable)
    {
      if ((count & 1) != 0) {
        goto LABEL_24;
      }
    }

    else
    {
      uint64_t v35 = self->super._dict;
      if (count)
      {
        if (v35) {
          char v36 = (__CFString *)CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, v35);
        }
        else {
          char v36 = (__CFString *)CFDictionaryCreateMutable( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        }
        goto LABEL_93;
      }

      if (v35)
      {
        char v36 = (__CFString *)CFRetain(self->super._dict);
LABEL_93:
        CFMutableDictionaryRef Mutable = v36;
        goto LABEL_94;
      }

      CFMutableDictionaryRef Mutable = 0LL;
    }

void sub_180BDFBF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
}

uint64_t _plistSizeIsAppropriateToRead(uint64_t a1)
{
  uint64_t v1 = (os_log_s *)_CFPrefsClientLog();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR)) {
    _plistSizeIsAppropriateToRead_cold_1();
  }
  _CFSetTSD(0xFu, 0LL, 0LL);
  return 0LL;
}

void sub_180BDFF88(_Unwind_Exception *a1)
{
}

uint64_t applyDictBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_180BE018C(_Unwind_Exception *a1)
{
}

void sub_180BE0BC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

void sub_180BE0C0C(uint64_t a1, int a2)
{
  if (!a2) {
    JUMPOUT(0x180BE0C04LL);
  }
  objc_terminate();
  __85___CFXPreferences_PlistSourceAdditions__withManagedSourceForIdentifier_user_perform___block_invoke(v2, v3);
}

void sub_180BE0EDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

uint64_t _approximateSizeOfPlistValue(__CFString *cf, CFStringRef *a2, CFIndex *a3)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (a2 && a3) {
    _approximateSizeOfPlistValue_cold_1();
  }
  if (!cf) {
    return 0LL;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  uint64_t v25 = 0LL;
  int v26 = &v25;
  uint64_t v27 = 0x2020000000LL;
  uint64_t v28 = 0LL;
  switch(v6)
  {
    case 7uLL:
      CFIndex Length = CFStringGetLength(cf);
      CFIndex usedBufLen = 0LL;
      v30.CFIndex location = 0LL;
      v30.size_t length = Length;
      if (CFStringGetBytes(cf, v30, 0x600u, 0, 0, 0LL, 0LL, &usedBufLen)) {
        BOOL v8 = usedBufLen == Length;
      }
      else {
        BOOL v8 = 0;
      }
      char v9 = !v8;
      CFIndex v10 = Length << v9;
      double v26[3] = v10;
      if (a2)
      {
        CFStringRef v11 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"string value, approximate encoded size: %ld",  v10);
        goto LABEL_31;
      }

      break;
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
      break;
    case 0x10uLL:
      if (a2)
      {
        uint64_t v13 = @"deleted value";
        goto LABEL_34;
      }

      break;
    case 0x12uLL:
      CFIndex usedBufLen = 0LL;
      p_CFIndex usedBufLen = &usedBufLen;
      if (a3) {
        p_CFIndex usedBufLen = a3;
      }
      v23[0] = MEMORY[0x1895F87A8];
      v23[1] = 3221225472LL;
      void v23[2] = ___approximateSizeOfPlistValue_block_invoke;
      v23[3] = &unk_1899EEF30;
      v23[4] = &v25;
      v23[5] = p_usedBufLen;
      CFDictionaryApply(cf, (uint64_t)v23);
      if (a2)
      {
        CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)cf);
        CFStringRef v11 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"dictionary value, count: %ld, total nested objects: %ld, approximate encoded size: %ld",  Count,  usedBufLen,  v26[3]);
        goto LABEL_31;
      }

      break;
    case 0x13uLL:
      CFIndex usedBufLen = 0LL;
      CFIndex v17 = CFArrayGetCount((CFArrayRef)cf);
      __int128 v18 = &usedBufLen;
      v22[0] = MEMORY[0x1895F87A8];
      v22[1] = 3221225472LL;
      if (a3) {
        __int128 v18 = a3;
      }
      void v22[2] = ___approximateSizeOfPlistValue_block_invoke_2;
      v22[3] = &unk_1899ECEC8;
      v22[4] = &v25;
      v22[5] = v18;
      CFArrayApply((uint64_t)cf, 0LL, v17, (uint64_t)v22);
      if (a2)
      {
        CFIndex v19 = CFArrayGetCount((CFArrayRef)cf);
        CFStringRef v11 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"array value, count: %ld, tested nested objects: %ld, approximate encoded size: %ld",  v19,  usedBufLen,  v26[3]);
        goto LABEL_31;
      }

      break;
    case 0x14uLL:
      CFIndex v20 = CFDataGetLength((CFDataRef)cf);
      double v26[3] = v20;
      if (a2)
      {
        CFStringRef v11 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"data value, size: %ld",  v20);
LABEL_31:
        *a2 = v11;
      }

      break;
    case 0x15uLL:
      uint64_t v28 = 1LL;
      if (a2)
      {
        uint64_t v13 = @"BOOLean value";
        goto LABEL_34;
      }

      break;
    case 0x16uLL:
      Byteuint64_t Size = CFNumberGetByteSize((CFNumberRef)cf);
      double v26[3] = ByteSize;
      if (a2)
      {
        uint64_t v13 = @"number value";
        goto LABEL_34;
      }

      break;
    default:
      if (v6 == 42)
      {
        uint64_t v28 = 8LL;
        if (a2)
        {
          uint64_t v13 = @"date value";
LABEL_34:
          *a2 = v13;
        }
      }

      break;
  }

  if (a3) {
    ++*a3;
  }
  uint64_t v12 = v26[3];
  _Block_object_dispose(&v25, 8);
  return v12;
}

void sub_180BE1434(_Unwind_Exception *a1)
{
}

uint64_t _compareSizes(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = 1LL;
  if (a1 >= a2) {
    uint64_t v2 = -1LL;
  }
  if (a1 == a2) {
    return 0LL;
  }
  else {
    return v2;
  }
}

void *_CFPrefsTestOversizeWarning(const void *a1, const void **a2, const void **a3, CFIndex a4)
{
  return  -[_CFPrefsOversizedPlistDescription initWithDict:setKeys:andValues:count:]( objc_alloc(&OBJC_CLASS____CFPrefsOversizedPlistDescription),  a1,  a2,  a3,  a4);
}

uint64_t __alreadylocked_requestNewDataIfStale_block_invoke(uint64_t a1)
{
  return -[CFPrefsPlistSource alreadylocked_requestNewData](*(void *)(a1 + 32));
}

uint64_t ___approximateSizeOfPlistValue_block_invoke(uint64_t a1, CFTypeRef cf, const void *a3)
{
  uint64_t v5 = _approximateSizeOfPlistValue(cf);
  uint64_t result = _approximateSizeOfPlistValue(a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += result + v5;
  return result;
}

uint64_t ___approximateSizeOfPlistValue_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  uint64_t result = _approximateSizeOfPlistValue(cf);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += result;
  return result;
}

void OUTLINED_FUNCTION_0_36( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_3_9(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

  ;
}

void OUTLINED_FUNCTION_5_5(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
}

void OUTLINED_FUNCTION_6_4( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_7_3( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

void OUTLINED_FUNCTION_8_3( void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
}

  ;
}

  ;
}

  ;
}

  ;
}

void OUTLINED_FUNCTION_13_0(void *a1, os_log_s *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
}

uint64_t (**__CFStringEncodingGetGreekConverterDefinition( int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_8)
  {
    __CFStringEncodingPrecomposeLatinCharacter_8 = (_UNKNOWN *)a2(4LL);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_5 = (_UNKNOWN *)a2(3LL);
  }

  if (a1 > 1028)
  {
    if (a1 != 1029)
    {
      if (a1 == 1283) {
        return __CFConverterWindowsGreek;
      }
      return 0LL;
    }

    return __CFConverterDOSGreek;
  }

  else
  {
    if (a1 != 6)
    {
      if (a1 == 519) {
        return __CFConverterISOLatinGreek;
      }
      return 0LL;
    }

    return __CFConverterMacGreek;
  }

uint64_t __CFToISOLatinGreek(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xA0)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8218 < 0xFFFFE089) {
    return 0LL;
  }
  uint64_t v5 = (unsigned __int16 *)&ISOLatinGreek_from_uni;
  CFTypeID v6 = (unsigned __int16 *)&unk_180D81AE8;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    BOOL v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFTypeID v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    uint64_t v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromISOLatinGreek(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0) {
    a2 = ISOLatinGreek_to_uni[a2 - 161];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToISOLatinGreekPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v16[1] = *MEMORY[0x1895F89C0];
  unsigned int v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 8218) >= 0xE089u)
    {
      CFStringRef v11 = (unsigned __int16 *)&ISOLatinGreek_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_180D81AE8;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        BOOL v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          CFStringRef v11 = v14 + 2;
        }

        else
        {
          uint64_t v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFIsValidCombiningCharacterForGreek()
{
  return __CFStringEncodingIsValidCombiningCharacterForLatin1_5();
}

uint64_t __CFPrecomposeGreekCharacter(unsigned __int16 *a1, uint64_t a2, void *a3)
{
  *a3 = 2LL;
  unsigned int v3 = *a1;
  if (v3 <= 0x7F) {
    return __CFStringEncodingPrecomposeLatinCharacter_8();
  }
  unsigned int v5 = a1[1] | (v3 << 16);
  if (v5 > 0x3D20308) {
    return 65533LL;
  }
  CFTypeID v6 = (unsigned int *)&__CFGreekPrecompMap;
  uint64_t v7 = (unsigned int *)&unk_180D81C6C;
  while (1)
  {
    uint64_t v8 = ((char *)v7 - (char *)v6) >> 4;
    unsigned int v9 = &v6[2 * v8];
    if (*v9 <= v5) {
      break;
    }
    uint64_t v7 = v9 - 2;
LABEL_9:
    if (v6 > v7) {
      return 65533LL;
    }
  }

  if (*v9 < v5)
  {
    CFTypeID v6 = v9 + 2;
    goto LABEL_9;
  }

  uint64_t v10 = LOWORD(v6[2 * v8 + 1]);
  if (a2 >= 3 && a1[2] == 769)
  {
    if ((_DWORD)v10 == 971)
    {
      *a3 = 3LL;
      return 944LL;
    }

    else if ((_DWORD)v10 == 970)
    {
      *a3 = 3LL;
      return 912LL;
    }
  }

  return v10;
}

uint64_t __CFToMacGreek(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8806 < 0xFFFFDE3A) {
    return 0LL;
  }
  unsigned int v5 = (unsigned __int16 *)&MacGreek_from_uni;
  CFTypeID v6 = (unsigned __int16 *)&unk_180D81E70;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFTypeID v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    unsigned int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromMacGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = MacGreek_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacGreekPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v16[1] = *MEMORY[0x1895F89C0];
  unsigned int v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8806) >= 0xDE3Au)
    {
      CFStringRef v11 = (unsigned __int16 *)&MacGreek_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_180D81E70;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        BOOL v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          CFStringRef v11 = v14 + 2;
        }

        else
        {
          uint64_t v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToDOSGreek(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 9633 < 0xFFFFDAFF) {
    return 0LL;
  }
  unsigned int v5 = (unsigned __int16 *)&DOSGreek_from_uni;
  CFTypeID v6 = (unsigned __int16 *)&unk_180D82170;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFTypeID v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    unsigned int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromDOSGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = DOSGreek_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSGreekPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v16[1] = *MEMORY[0x1895F89C0];
  unsigned int v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      CFStringRef v11 = (unsigned __int16 *)&DOSGreek_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_180D82170;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        BOOL v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          CFStringRef v11 = v14 + 2;
        }

        else
        {
          uint64_t v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

uint64_t __CFToWindowsGreek(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
  {
    char v3 = a2;
    goto LABEL_3;
  }

  if (a2 - 8483 < 0xFFFFDF7D) {
    return 0LL;
  }
  unsigned int v5 = (unsigned __int16 *)&WindowsGreek_from_uni;
  CFTypeID v6 = (unsigned __int16 *)&unk_180D8242C;
  while (1)
  {
    uint64_t v7 = ((char *)v6 - (char *)v5) >> 3;
    uint64_t v8 = &v5[2 * v7];
    unsigned int v9 = *v8;
    if (v9 <= a2) {
      break;
    }
    CFTypeID v6 = v8 - 2;
LABEL_10:
    if (v5 > v6) {
      return 0LL;
    }
  }

  if (v9 < a2)
  {
    unsigned int v5 = v8 + 2;
    goto LABEL_10;
  }

  char v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1LL;
}

BOOL __CFFromWindowsGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0) {
    a2 = WindowsGreek_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsGreekPrecompose( uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, void *a6)
{
  v16[1] = *MEMORY[0x1895F89C0];
  unsigned int v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      CFStringRef v11 = (unsigned __int16 *)&WindowsGreek_from_uni;
      uint64_t v12 = (unsigned __int16 *)&unk_180D8242C;
      while (1)
      {
        uint64_t v13 = ((char *)v12 - (char *)v11) >> 3;
        BOOL v14 = &v11[2 * v13];
        unsigned int v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }

          CFStringRef v11 = v14 + 2;
        }

        else
        {
          uint64_t v12 = v14 - 2;
        }

        if (v11 > v12) {
          return 0LL;
        }
      }
    }

    return 0LL;
  }

void __CFArrayHandleOutOfMemory(uint64_t a1)
{
  CFStringRef v1 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"Attempt to allocate %ld bytes for CFArray failed",  a1);
  _CFRaiseMemoryException((uint64_t)v1);
}

#error "180BE2034: call analysis failed (funcsize=5)"
void _CFArrayReplaceValues_cold_1()
{
  qword_18C539A70 = (uint64_t)"CFArray expectation failed";
  __break(1u);
}

void __CFAttributedStringCopyDescription_cold_1()
{
  qword_18C539A70 = (uint64_t)"Ridiculous size count";
  __break(1u);
}

void CFAttributedStringSetAttributes_cold_1()
{
  qword_18C539A70 = (uint64_t)"Ridiculous size count";
  __break(1u);
}

uint64_t __CFReallocationFailed(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  char v7 = 0;
  if (!a3 || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a3 + 16))(a3, a1, &v7), !v7))
  {
    bzero(__str, 0x100uLL);
    int v5 = snprintf(__str, 0x100uLL, "Failed to grow buffer to %ld", a2);
    CFStringRef v6 = CFStringCreateWithBytesNoCopy( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  (const UInt8 *)__str,  v5,  0x600u,  0,  0LL);
    if (!v6) {
      _CFRaiseMemoryException((uint64_t)@"Failed to grow buffer - malloc failure");
    }
    _CFRaiseMemoryException((uint64_t)v6);
  }

  return result;
}

void sub_180BE2150()
{
}

void __CFGetSignatureROMEntryAtIndex_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to access an invalid NSMethodSignature index";
  __break(1u);
}

void __CFRelativeDateTimeFormatterDeallocate_cold_1()
{
  __assert_rtn("__CFRelativeDateTimeFormatterDeallocate", "CFRelativeDateTimeFormatter.c", 80, "cf != NULL");
}

void __CFRelativeDateTimeFormatterCopyDescription_cold_1()
{
  __assert_rtn("__CFRelativeDateTimeFormatterCopyDescription", "CFRelativeDateTimeFormatter.c", 86, "cf != NULL");
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_1()
{
  qword_18C539A70 = (uint64_t)"Invalid CFRelativeDateTimeFormatterStyle";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_2()
{
  qword_18C539A70 = (uint64_t)"Invalid CFCalendarUnit";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_3()
{
  qword_18C539A70 = (uint64_t)"Invalid CFRelativeDateTimeFormatterStyle";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_4()
{
  qword_18C539A70 = (uint64_t)"Invalid CFRelativeDateTimeFormattingContext";
  __break(1u);
}

void _CFCreateArrayStorage_cold_1()
{
  qword_18C539A70 = (uint64_t)"failed to create array buffer";
  __break(1u);
}

void _CFCreateArrayStorage_cold_2()
{
  qword_18C539A70 = (uint64_t)"size unreasonably big";
  __break(1u);
}

void __NSArrayM_new_cold_1()
{
  qword_18C539A70 = (uint64_t)"size unreasonably big";
  __break(1u);
}

void __CFBinaryPlistCreateObjectFiltered_cold_1(os_log_t log)
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  *(_WORD *)CFStringRef v1 = 0;
  _os_log_fault_impl(&dword_180A4C000, log, OS_LOG_TYPE_FAULT, "Too many nested arrays or dictionaries", v1, 2u);
}

void CFBundleGetMainBundle_cold_1(uint64_t a1, os_log_s *a2, void *a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 56);
  int v5 = 138543618;
  uint64_t v6 = a1;
  __int16 v7 = 2048;
  uint64_t v8 = v4;
  _os_log_debug_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_DEBUG,  "main bundle %{public}@ getting handle %p",  (uint8_t *)&v5,  0x16u);
  *a3 = _mainBundle;
}

void _CFURLCreateResolvedDirectoryWithString_cold_1(os_log_s *a1)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  int v2 = *__error();
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl(&dword_180A4C000, a1, OS_LOG_TYPE_ERROR, "Unable to resolve directory (%d)", (uint8_t *)v3, 8u);
  OUTLINED_FUNCTION_1();
}

void _CFBundleCreate_cold_1()
{
}

void _CFBundleCreate_cold_2()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  OUTLINED_FUNCTION_2();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_debug_impl( &dword_180A4C000,  v1,  OS_LOG_TYPE_DEBUG,  "Unable to create bundle at URL (%@): does not exist or not a directory (%d)",  v2,  0x12u);
  OUTLINED_FUNCTION_1();
}

void _CFBundleCreate_cold_3()
{
}

void _CFBundleCreate_cold_4()
{
}

void _CFBundleCreate_cold_5()
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  OUTLINED_FUNCTION_2();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_error_impl( &dword_180A4C000,  v1,  OS_LOG_TYPE_ERROR,  "Unable to create bundle at URL (%@): unable to create file system representation of URL (%d)",  v2,  0x12u);
  OUTLINED_FUNCTION_1();
}

void _CFBundleLoadExecutableAndReturnError_cold_1()
{
}

void _CFBundleLoadExecutableAndReturnError_cold_2()
{
}

void _CFBundleLoadExecutableAndReturnError_cold_3()
{
}

void _CFBundleEnsureBundleExistsForImagePath_cold_1()
{
}

void _CFBundleEnsureBundleExistsForImagePath_cold_2()
{
}

void _CFBundleAddToTablesLocked_cold_1()
{
}

void _CFBundleGetBundleVersionForURL_cold_1()
{
}

void _CFBundleGetBundleVersionForURL_cold_2()
{
}

void _CFBundleGetBundleVersionForURL_cold_3()
{
}

void _CFBundleGetBundleVersionForURL_cold_4()
{
}

void CFCharacterSetGetPredefined_cold_1( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  qword_18C539A70 = (uint64_t)"Unknown builtin CFCharacterSet type";
  __break(1u);
}

void CFCharacterSetAddCharactersInString_cold_1()
{
  qword_18C539A70 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetInvert_cold_1()
{
  qword_18C539A70 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetIntersect_cold_1()
{
  qword_18C539A70 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetAddCharactersInRange_cold_1()
{
  qword_18C539A70 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetRemoveCharactersInRange_cold_1()
{
  qword_18C539A70 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetRemoveCharactersInString_cold_1()
{
  qword_18C539A70 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetUnion_cold_1()
{
  qword_18C539A70 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void __CFDataHandleOutOfMemory(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 0x3FFFFFFFFFELL) {
    CFStringRef v1 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"Attempt to allocate %ld bytes for NS/CFData failed. Maximum size: %lld",  a1,  0x3FFFFFFFFFFLL);
  }
  else {
    CFStringRef v1 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"Attempt to allocate %ld bytes for NS/CFData failed",  a1);
  }
  _CFRaiseMemoryException((uint64_t)v1);
}

#error "180BE2D50: call analysis failed (funcsize=5)"
void CFDataReplaceBytes_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3_0("__CFDataValidateRange", "CFData.c", a3, "range.location <= dataLength");
}

void CFDataReplaceBytes_cold_2()
{
  qword_18C539A70 = (uint64_t)"Negative buffer length passed to CFDataReplaceBytes";
  __break(1u);
}

void CFDataReplaceBytes_cold_3()
{
  qword_18C539A70 = (uint64_t)"Invalid range passed to CFDataReplaceBytes";
  __break(1u);
}

void CFDataReplaceBytes_cold_4()
{
  qword_18C539A70 = (uint64_t)"Invalid length passed to CFDataReplaceBytes when newBytes == NULL";
  __break(1u);
}

void CFDataReplaceBytes_cold_5()
{
  qword_18C539A70 = (uint64_t)"fixed-capacity CFMutableData is full";
  __break(1u);
}

void CFDataReplaceBytes_cold_6()
{
}

void CFDataReplaceBytes_cold_7(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_6("__CFDataValidateRange", "CFData.c", a3, "range.location + range.length <= dataLength");
}

void CFDataReplaceBytes_cold_8()
{
}

void CFDataReplaceBytes_cold_9(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5("__CFDataValidateRange", "CFData.c", a3, "range.length >= 0");
}

void CFDataReplaceBytes_cold_10()
{
}

void CFDataReplaceBytes_cold_11(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("__CFDataValidateRange", "CFData.c", a3, "range.location >= 0");
}

void CFDataReplaceBytes_cold_12()
{
}

void CFDataGetBytes_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3_0("__CFDataValidateRange", "CFData.c", a3, "range.location <= dataLength");
}

void CFDataGetBytes_cold_2()
{
}

void CFDataGetBytes_cold_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_6("__CFDataValidateRange", "CFData.c", a3, "range.location + range.length <= dataLength");
}

void CFDataGetBytes_cold_4()
{
}

void CFDataGetBytes_cold_5(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5("__CFDataValidateRange", "CFData.c", a3, "range.length >= 0");
}

void CFDataGetBytes_cold_6()
{
}

void CFDataGetBytes_cold_7(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("__CFDataValidateRange", "CFData.c", a3, "range.location >= 0");
}

void CFDataGetBytes_cold_8()
{
}

void CFDataSetLength_cold_1()
{
  qword_18C539A70 = (uint64_t)"fixed-capacity CFMutableData is full";
  __break(1u);
}

void CFDataFind_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3_0("__CFDataValidateRange", "CFData.c", a3, "range.location <= dataLength");
}

void CFDataFind_cold_2()
{
}

void CFDataFind_cold_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_6("__CFDataValidateRange", "CFData.c", a3, "range.location + range.length <= dataLength");
}

void CFDataFind_cold_4()
{
}

void CFDataFind_cold_5(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5("__CFDataValidateRange", "CFData.c", a3, "range.length >= 0");
}

void CFDataFind_cold_6()
{
}

void CFDataFind_cold_7(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("__CFDataValidateRange", "CFData.c", a3, "range.location >= 0");
}

void CFDataFind_cold_8()
{
}

void CFGregorianDateIsValid_cold_1(int a1)
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  v1[0] = 67109120;
  v1[1] = a1;
  _os_log_error_impl( &dword_180A4C000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_ERROR,  "Month %d is out of bounds",  (uint8_t *)v1,  8u);
}

void __ResetUDateFormat_cold_1(uint64_t *a1, os_log_s *a2)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *a1;
  int v3 = 138412290;
  uint64_t v4 = v2;
  _os_log_error_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_ERROR,  "Error: CFDateFormatter time zone has an empty name: %@",  (uint8_t *)&v3,  0xCu);
}

void _cow_failure(const __CFString *a1)
{
  qword_18C539A70 = (uint64_t)CFStringGetCStringPtr(a1, 0x600u);
  __break(1u);
}

void _cow_create_cold_1()
{
}

void _cow_copy_cold_1()
{
}

void _cow_mutate_slow_cold_1()
{
}

uint64_t _CFErrorSetCallStackCaptureEnabled(int a1)
{
  do
    unsigned __int8 v1 = __ldaxr(_CFErrorCallStackCaptureEnabled);
  while (__stlxr(a1 != 0, _CFErrorCallStackCaptureEnabled));
  return v1 & 1;
}

void userInfoKeyValueShow_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** userInfoKeyValueShow() called with NULL context ***";
  __break(1u);
}

void _CFPrefsEncodeKeyValuePairsIntoMessage_cold_1()
{
}

void deallocatePurgeable_cold_1(int a1, os_log_s *a2)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  v2[0] = 67240192;
  v2[1] = a1;
  _os_log_fault_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_FAULT,  "couldn't deallocate purgable buffer. Leaking it to avoid crashing. Error was %{public}d",  (uint8_t *)v2,  8u);
}

void _cfmp_record_intent_to_invalidate_cold_1()
{
  qword_18C539A70 = (uint64_t)"Unable to allocate mach_port deallocation record";
  __break(1u);
}

void _cfmp_log_failure_cold_1(uint64_t a1, unsigned __int8 a2, int a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  int v3 = 136446722;
  uint64_t v4 = a1;
  __int16 v5 = 1024;
  int v6 = a2;
  __int16 v7 = 1024;
  int v8 = a3;
  _os_log_error_impl( &dword_180A4C000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_ERROR,  "*** %{public}s, break on '_CFMachPortDeallocationFailure' to debug: {null - ic:%d,ip:%d}",  (uint8_t *)&v3,  0x18u);
}

void _cfmp_deallocation_record_retain_cold_1()
{
  qword_18C539A70 = (uint64_t)"refcnt overflow";
  __break(1u);
}

void _CFBundleDlfcnCheckLoaded_cold_1()
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  OUTLINED_FUNCTION_8();
  __int16 v3 = 2082;
  uint64_t v4 = v0;
  __int16 v5 = 1024;
  int v6 = 277;
  _os_log_debug_impl( &dword_180A4C000,  v1,  OS_LOG_TYPE_DEBUG,  "dlfcn check load bundle %{public}@, dlopen of %{public}s mode 0x%x no handle",  v2,  0x1Cu);
}

void _CFBundleDlfcnLoadBundle_cold_1()
{
}

void _CFBundleDlfcnLoadBundle_cold_2()
{
}

void _CFBundleDlfcnLoadBundle_cold_3()
{
}

void _CFBundleDlfcnLoadFramework_cold_1()
{
}

void _CFBundleDlfcnLoadFramework_cold_2()
{
}

void _CFBundleDlfcnLoadFramework_cold_3()
{
}

void _CFBundleDlfcnUnload_cold_1(uint64_t a1, os_log_s *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  int v3 = 138543618;
  uint64_t v4 = a1;
  __int16 v5 = 2080;
  uint64_t v6 = dlerror();
  _os_log_error_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_ERROR,  "Internal error unloading bundle %{public}@ : %s",  (uint8_t *)&v3,  0x16u);
}

void _CFBundleDlfcnUnload_cold_2()
{
}

void _CFBundleDlfcnGetSymbolByNameWithSearch_cold_1()
{
}

void _CFBundleCopyLoadedImagePathForPointer_cold_1()
{
}

uint64_t _NSDictionaryRaiseInsertNilKeyException(objc_class *a1, const char *a2)
{
  uint64_t v4 = __CFExceptionProem(a1, a2);
  uint64_t v2 = OUTLINED_FUNCTION_0_5(v4, @"%@: attempt to insert nil key");
  return _NSDictionaryRaiseInsertNilValueException(v2);
}

uint64_t _NSDictionaryRaiseInsertNilValueException(objc_class *a1, const char *a2, uint64_t a3)
{
  uint64_t v4 = __CFExceptionProem(a1, a2);
  uint64_t v5 = _CFThrowFormattedException( (uint64_t)@"NSInvalidArgumentException",  @"%@: attempt to insert nil value (key: %@)",  v4,  a3);
  return _NSDictionaryRaiseRemoveNilKeyException(v5);
}

uint64_t _NSDictionaryRaiseRemoveNilKeyException(objc_class *a1, const char *a2)
{
  uint64_t v5 = __CFExceptionProem(a1, a2);
  uint64_t v2 = (objc_class *)OUTLINED_FUNCTION_0_5(v5, @"%@: attempt to remove nil key");
  return -[__NSCFDictionary setObject:forKey:].cold.1(v2, v3);
}

void _CFMachPortCreateWithPort4_cold_1(int a1, uint64_t a2, os_log_s *a3)
{
  LODWORD(v3) = 134218240;
  HIDWORD(v3) = a1;
  OUTLINED_FUNCTION_0_6( &dword_180A4C000,  a2,  a3,  "*** CFMachPortCreateWithPort(): mach_port_type for 0x%lx failed with %d",  v3,  0);
  OUTLINED_FUNCTION_2_4();
}

void _CFMachPortCreateWithPort4_cold_2(os_log_t log)
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  *(_WORD *)os_log_t v1 = 0;
  _os_log_error_impl( &dword_180A4C000,  log,  OS_LOG_TYPE_ERROR,  "*** CFMachPortCreateWithPort(): allocation failure",  v1,  2u);
  OUTLINED_FUNCTION_3_2();
}

void _CFMachPortCreateWithPort4_cold_3(uint64_t a1, uint64_t a2, os_log_s *a3)
{
  LODWORD(v3) = 134218240;
  HIDWORD(v3) = a1;
  OUTLINED_FUNCTION_0_6( &dword_180A4C000,  a2,  a3,  "*** CFMachPortCreateWithPort(): invalid mach port %p (from cache: %d)",  v3,  HIDWORD(a1));
  OUTLINED_FUNCTION_2_4();
}

void _CFMachPortCreateReply_cold_1( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_4( &dword_180A4C000,  a2,  a3,  "*** _CFMachPortCreateReply failed. mach_port_construct() returned %d",  a5,  a6,  a7,  a8,  0);
  OUTLINED_FUNCTION_3_2();
}

void _CFMachPortCreate4_cold_1( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_4( &dword_180A4C000,  a2,  a3,  "*** CFMachPortCreate failed. mach_port_allocate() returned %d",  a5,  a6,  a7,  a8,  0);
  OUTLINED_FUNCTION_3_2();
}

void _CFMachPortCreate4_cold_2(int *a1, int a2, os_log_t log)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  int v3 = *a1;
  v4[0] = 67109376;
  v4[1] = a2;
  __int16 v5 = 1024;
  int v6 = v3;
  _os_log_error_impl( &dword_180A4C000,  log,  OS_LOG_TYPE_ERROR,  "*** CFMachPortCreate failed. mach_port_insert_right() returned %d for port %d",  (uint8_t *)v4,  0xEu);
  OUTLINED_FUNCTION_2_4();
}

void __CFMessagePortCreateLocal_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __CFMessagePortCreateLocal_cold_2(int *a1, os_log_s *a2)
{
  uint64_t v4 = *MEMORY[0x1895F89C0];
  int v2 = *a1;
  v3[0] = 67240192;
  v3[1] = v2;
  _os_log_error_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_ERROR,  "*** CFMessagePortCreateLocal(): CFMachPortCreateWithPort() failed, port = %{public}d",  (uint8_t *)v3,  8u);
  OUTLINED_FUNCTION_1_5();
}

void __CFMessagePortCreateLocal_cold_3(int *a1, int a2, os_log_t log)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  int v3 = *a1;
  v4[0] = 67240448;
  v4[1] = a2;
  __int16 v5 = 1026;
  int v6 = v3;
  _os_log_error_impl( &dword_180A4C000,  log,  OS_LOG_TYPE_ERROR,  "*** CFMessagePortCreateLocal(): mach_port_insert_right(MACH_MSG_TYPE_MAKE_SEND) returned %{public}d, port = %{public}d",  (uint8_t *)v4,  0xEu);
}

void __CFMessagePortCreateLocal_cold_4( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __CFMessagePortCreateLocal_cold_5( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFMessagePortSetName_cold_1()
{
  __assert_rtn("CFMessagePortSetName", "CFMessagePort.c", 729, "ms->_dispatchSource == NULL");
}

void _CFNotificationCenterRegisterDependentNotificationList_cold_1()
{
  qword_18C539A70 = (uint64_t)"Too many invocations of _CFNotificationCenterRegisterDependentNotifications.";
  __break(1u);
}

void _CFXNotificationPost_cold_1(double a1)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  int v1 = 134217984;
  double v2 = a1;
  _os_log_error_impl( &dword_180A4C000,  MEMORY[0x1895F8DA0],  OS_LOG_TYPE_ERROR,  "Detected potentially harmful notification post rate of %g notifications per second",  (uint8_t *)&v1,  0xCu);
}

uint64_t _CFThrowFormattedException(uint64_t a1, CFStringRef format, ...)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  CFStringRef v4 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0LL, format, va);
  CFAutorelease(v4);
  if (v4) {
    CFStringRef v5 = v4;
  }
  else {
    CFStringRef v5 = format;
  }
  objc_exception_throw( +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  a1,  v5,  0LL,  va,  v7));
  return -[__NSCFString characterAtIndex:].cold.1();
}

void __remoteStoreChanged_block_invoke_cold_1(id *a1, os_log_s *a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  uint64_t v3 = [*a1 domain];
  int v4 = 138543362;
  uint64_t v5 = v3;
  _os_log_debug_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_DEBUG,  "cloud preferences changed for %{public}@",  (uint8_t *)&v4,  0xCu);
}

void visit_cold_1()
{
  qword_18C539A70 = (uint64_t)"unable to allocate memory";
  __break(1u);
}

uint64_t _NSArrayRaiseBoundException(uint64_t a1, const char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = _os_log_pack_size();
  MEMORY[0x1895F8858](v7, v8);
  uint64_t v9 = OUTLINED_FUNCTION_1_6();
  uint64_t v10 = PROEM_CLS();
  CFStringRef v11 = PROEM_SEL(a2);
  if (a3 >> 62) {
    uint64_t v12 = " (or possibly larger)";
  }
  else {
    uint64_t v12 = "";
  }
  __os_log_helper_1_2_5_8_32_8_32_8_0_8_32_8_0(v9, (uint64_t)v10, (uint64_t)v11, a3, (uint64_t)v12, a4);
  uint64_t v13 = PROEM_CLS();
  BOOL v14 = PROEM_SEL(a2);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"-[%s %s]: index (%ld%s) beyond bounds (%ld)",  v13,  v14,  a3,  v12,  a4);
  uint64_t v15 = OUTLINED_FUNCTION_2_5();
  CFIndex v17 = (void *)OUTLINED_FUNCTION_0_9(&OBJC_CLASS___NSException, v16, (uint64_t)@"NSInvalidArgumentException", v15);
  objc_exception_throw(v17);
  return _NSArrayRaiseInsertNilException();
}

uint64_t _NSArrayRaiseInsertNilException(uint64_t a1, const char *a2)
{
  uint64_t v3 = _os_log_pack_size();
  MEMORY[0x1895F8858](v3, v4);
  uint64_t v5 = OUTLINED_FUNCTION_1_6();
  uint64_t v6 = PROEM_CLS();
  uint64_t v7 = PROEM_SEL(a2);
  *(_DWORD *)uint64_t v5 = 136315394;
  *(void *)(v5 + 4) = v6;
  *(_WORD *)(v5 + 12) = 2080;
  *(void *)(v5 + 14) = v7;
  uint64_t v8 = PROEM_CLS();
  uint64_t v9 = PROEM_SEL(a2);
  CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"-[%s %s]: attempt to insert nil",  v8,  v9);
  uint64_t v10 = OUTLINED_FUNCTION_2_5();
  uint64_t v12 = (void *)OUTLINED_FUNCTION_0_9(&OBJC_CLASS___NSException, v11, (uint64_t)@"NSInvalidArgumentException", v10);
  objc_exception_throw(v12);
  return -[__NSCFArray insertObject:atIndex:].cold.1();
}

void _CFCopyHomeDirURLForUser_cold_1(uint64_t a1, os_log_s *a2)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(*(void *)a1 + 24LL);
  int v3 = 138543362;
  uint64_t v4 = v2;
  _os_log_error_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_ERROR,  "_CFCopyHomeDirURLForUser failed to create a proper home directory. Falling back to /var/empty. Error(s):\n %{public}@",  (uint8_t *)&v3,  0xCu);
}

void _CFGetTSDCreateIfNeeded_cold_1(int a1)
{
}

void _CFSetTSD_cold_1(int a1)
{
}

void CFPlugInInstanceCreate_cold_1()
{
}

void CFPlugInInstanceCreate_cold_2( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFPlugInInstanceCreate_cold_3()
{
}

void CFPlugInInstanceCreate_cold_4()
{
}

void _CFPFactoryCommonCreateLocked_cold_1()
{
}

void CFPlugInUnregisterFactory_cold_1()
{
}

void _CFPFactoryDisableLocked_cold_1( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPlugInRegisterPlugInTypeLocked_cold_1()
{
}

void _CFPlugInRegisterPlugInTypeLocked_cold_2()
{
}

void CFPlugInUnregisterPlugInType_cold_1()
{
}

void _CFPFactoryRemoveTypeLocked_cold_1()
{
}

void CFPlugInAddInstanceForFactory_cold_1()
{
}

void CFPlugInAddInstanceForFactory_cold_2()
{
}

void CFPlugInRemoveInstanceForFactory_cold_1()
{
}

void CFPlugInRemoveInstanceForFactory_cold_2()
{
}

void _CFPFactoryRemoveInstanceLocked_cold_1()
{
}

void _CFPlugInUnscheduleForUnloading_cold_1()
{
}

void _CFBundleInitPlugIn_cold_1()
{
}

void _registerTypeLocked_cold_1()
{
}

void _CFBundleDeallocatePlugIn_cold_1(uint64_t a1, os_log_s *a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(__CFBundleGetPlugInData(a1) + 16);
  int v6 = 134349312;
  uint64_t v7 = v4;
  __int16 v8 = 2050;
  uint64_t v9 = a1;
  OUTLINED_FUNCTION_3_4( &dword_180A4C000,  a2,  v5,  "Disabling factories in array %{public}p for bundle %{public}p",  (uint8_t *)&v6);
  OUTLINED_FUNCTION_9();
}

void _CFPFactoryDeallocate_cold_1()
{
}

void CFPlugInFindFactoriesForPlugInType_cold_1(const __CFArray *Count, uint64_t a2, os_log_s *a3)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (Count) {
    CFIndex Count = (const __CFArray *)CFArrayGetCount(Count);
  }
  int v5 = 134349314;
  int v6 = Count;
  __int16 v7 = 2114;
  uint64_t v8 = a2;
  OUTLINED_FUNCTION_3_4( &dword_180A4C000,  a3,  (uint64_t)a3,  "%{public}ld factories found for requested plugin type %{public}@",  (uint8_t *)&v5);
  OUTLINED_FUNCTION_9();
}

void __CFPropertyListCreateTopLevelKeyPaths_cold_1()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateTopLevelKeyPaths_cold_2()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_1()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_2()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_3()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_4()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void CFPropertyListCreateDeepCopy_cold_1()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void CFPropertyListCreateDeepCopy_cold_2()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _arrayDeepImmutableCopy_cold_1()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _arrayDeepImmutableCopy_cold_2()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _CFAppendXML0_cold_1()
{
  qword_18C539A70 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFRunLoopDeallocate_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to deallocate CFRunLoop outside of thread destructor -- this is likely an over-r"
                             "elease of the run loop";
  __break(1u);
}

void _CFRunLoopGet2_cold_1()
{
  qword_18C539A70 = (uint64_t)"Foundation-only CFRunLoop function called without Foundation present";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** Unable to create run loop mode queue port. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_2()
{
  qword_18C539A70 = (uint64_t)"*** Unable to create timer Port ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_3()
{
  qword_18C539A70 = (uint64_t)"*** Unable to insert wake up port into port set. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_4()
{
  qword_18C539A70 = (uint64_t)"*** Unable to insert timer port into port set. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_5()
{
  qword_18C539A70 = (uint64_t)"*** Unable to insert timer port into port set. ***";
  __break(1u);
}

void CFRunLoopRunSpecific_cold_1()
{
  qword_18C539A70 = (uint64_t)"Too many nested CFRunLoopRuns";
  __break(1u);
}

void CFRunLoopRunSpecific_cold_2()
{
  qword_18C539A70 = (uint64_t)"CFRunLoopRun underflow";
  __break(1u);
}

void CFRunLoopWakeUp_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** Unable to send message to wake up port. ***";
  __break(1u);
}

void CFRunLoopSourceCreate_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** NULL context value passed to CFRunLoopSourceCreate(). ***";
  __break(1u);
}

void CFRunLoopTimerCreate_cold_1()
{
  qword_18C539A70 = (uint64_t)"NaN was used as an interval for a CFRunLoopTimer";
  __break(1u);
}

void __CFRunLoopServiceMachPort_cold_1(char *a1)
{
  if ((~(_DWORD)a1 & 0x1000400B) != 0 && (a1 & 0x1000400C) != 0x1000400C)
  {
    a1 = mach_error_string((mach_error_t)a1);
LABEL_4:
    qword_18C539A70 = (uint64_t)a1;
LABEL_5:
    __break(1u);
  }

  HIDWORD(v__postAndResetMidnight(1, 1) = (unsigned __int16)a1 & 0x3E00;
  LODWORD(v__postAndResetMidnight(1, 1) = HIDWORD(v1) - 1024;
  a1 = "Out of IPC space";
  switch((v1 >> 10))
  {
    case 0u:
      a1 = "Kernel resource shortage handling out-of-line memory";
      goto LABEL_4;
    case 1u:
      a1 = "Kernel resource shortage handling IPC";
      goto LABEL_4;
    case 3u:
      a1 = "Out of VM address space";
      goto LABEL_4;
    case 7u:
      goto LABEL_4;
    default:
      goto LABEL_5;
  }

void __CFRunLoopDoTimer_cold_1()
{
  qword_18C539A70 = (uint64_t)"A CFRunLoopTimer with an interval of 0 is set to repeat";
  __break(1u);
}

void _CFAssertMismatchedTypeID(unint64_t a1, unint64_t a2)
{
  uint64_t v4 = _CFGetTypeIDDescription(a1);
  if (v4) {
    int v5 = (const char *)v4;
  }
  else {
    int v5 = "<unknown>";
  }
  uint64_t v6 = _CFGetTypeIDDescription(a2);
  if (v6) {
    __int16 v7 = (const char *)v6;
  }
  else {
    __int16 v7 = "<unknown>";
  }
  snprintf(__str, 0xFFuLL, "Expected typeID %lu (%s) does not match actual typeID %lu (%s)", a1, v5, a2, v7);
  qword_18C539A70 = (uint64_t)__str;
  __break(1u);
}

void CF_IS_OBJC_cold_1()
{
  qword_18C539A70 = (uint64_t)"CF objects must have a non-zero isa";
  __break(1u);
}

void _CFRuntimeRegisterClass_cold_1()
{
  qword_18C539A70 = (uint64_t)"Unable to allocate memory for CF runtime type registration";
  __break(1u);
}

void _CFRuntimeUnregisterClassWithTypeID_cold_1()
{
  qword_18C539A70 = (uint64_t)"Built-in CFTypes cannot be unregistered";
  __break(1u);
}

void CFRetain_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** CFRetain() called with NULL ***";
  __break(1u);
}

void __CFGenericTypeID_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFGetTypeID_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFGetNonObjCTypeID_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFRetain_cold_1()
{
  qword_18C539A70 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRetain_cold_2()
{
  qword_18C539A70 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void CFAutorelease_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** CFAutorelease() called with NULL ***";
  __break(1u);
}

void _CFRelease_cold_1()
{
  qword_18C539A70 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRelease_cold_2()
{
  qword_18C539A70 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRelease_cold_3(char *__str, uint64_t a2)
{
  if (a2) {
    snprintf(__str, 0x100uLL, "Detected over-release of a CFTypeRef %p (%lu / %s)");
  }
  else {
    snprintf(__str, 0x100uLL, "Detected over-release of a CFTypeRef %p (unknown type)");
  }
  qword_18C539A70 = (uint64_t)__str;
  __break(1u);
}

void CFRelease_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** CFRelease() called with NULL ***";
  __break(1u);
}

void __CFStringCollectionCopy_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** __CFStringCollectionCopy() called with NULL ***";
  __break(1u);
}

void __CFTypeCollectionRetain_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** __CFTypeCollectionRetain() called with NULL; likely a collection has been corrupted ***";
  __break(1u);
}

void __CFTypeCollectionRelease_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** __CFTypeCollectionRelease() called with NULL; likely a collection has been corrupted ***";
  __break(1u);
}

void CFGetRetainCount_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** CFGetRetainCount() called with NULL ***";
  __break(1u);
}

void CFGetRetainCount_cold_2()
{
  qword_18C539A70 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFNonObjCEqual_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** CFEqual() called with NULL second argument ***";
  __break(1u);
}

void _CFNonObjCEqual_cold_2()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_3()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_4()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_5()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** CFEqual() called with NULL first argument ***";
  __break(1u);
}

void CFEqual_cold_2()
{
  qword_18C539A70 = (uint64_t)"*** CFEqual() called with NULL second argument ***";
  __break(1u);
}

void CFEqual_cold_3()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_4()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_5()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_6()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_7()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCHash_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_1()
{
  qword_18C539A70 = (uint64_t)"*** CFHash() called with NULL ***";
  __break(1u);
}

void CFHash_cold_2()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_3()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_4()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_2()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_3()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_2()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_3()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFSortIndexes_cold_1()
{
  qword_18C539A70 = (uint64_t)"Size of array to be sorted is too big";
  __break(1u);
}

void CFQSortArray_cold_1( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  qword_18C539A70 = (uint64_t)"qsort - malloc failed";
  __break(1u);
}

void CFMergeSortArray_cold_1( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  qword_18C539A70 = (uint64_t)"merge sort - malloc failure";
  __break(1u);
}

void __CFStringHandleOutOfMemory()
{
}

#error "180BE5CC4: call analysis failed (funcsize=7)"
void __CFStringCreateImmutableFunnel3_cold_1()
{
  qword_18C539A70 = (uint64_t)"CFString cannot be created from a negative number of bytes";
  __break(1u);
}

void __CFStringMakeConstantString_cold_1( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendFormat_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringSetExternalCharactersNoCopy_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringInsert_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringDelete_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringReplace_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringReplaceAll_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppend_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendCharacters_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendPascalString_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendCString_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringAppendFormatAndArguments_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringFindAndReplace_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringPad_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringTrim_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringTrimWhitespace_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringLowercase_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringUppercase_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringCapitalize_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringNormalize_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CFStringFold_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __CFStringChangeSizeMultiple_cold_1()
{
  qword_18C539A70 = (uint64_t)"String had a capacity but NULL buffer pointer";
  __break(1u);
}

void __CFStringFormatLocalizedNumber_cold_1()
{
  qword_18C539A70 = (uint64_t)"Unexpected formatter style";
  __break(1u);
}

void _CFStringFormatAppendMetadata_cold_1()
{
}

void __CFDateComponentsDeallocate_cold_1()
{
  __assert_rtn("__CFDateComponentsDeallocate", "CFDateComponents.c", 139, "NULL != cf");
}

void __CFDateComponentsEqual_cold_1()
{
  __assert_rtn("__CFDateComponentsEqual", "CFDateComponents.c", 20, "NULL != cf1");
}

void __CFDateComponentsEqual_cold_2()
{
  __assert_rtn("__CFDateComponentsEqual", "CFDateComponents.c", 21, "NULL != cf2");
}

void __CFDateComponentsHash_cold_1()
{
  __assert_rtn("__CFDateComponentsHash", "CFDateComponents.c", 56, "NULL != cf");
}

void __CFDateComponentsCopyDescription_cold_1()
{
  __assert_rtn("__CFDateComponentsCopyDescription", "CFDateComponents.c", 130, "NULL != cf");
}

void CFDateComponentsCreateCopy_cold_1()
{
  qword_18C539A70 = (uint64_t)"Out of memory";
  __break(1u);
}

void CFDateComponentsCopyCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsCopyCalendar", "CFDateComponents.c", 356, "NULL != dateComp");
}

void CFDateComponentsSetCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsSetCalendar", "CFDateComponents.c", 365, "NULL != dateComp");
}

void CFDateComponentsCopyTimeZone_cold_1()
{
  __assert_rtn("CFDateComponentsCopyTimeZone", "CFDateComponents.c", 386, "NULL != dateComp");
}

void CFDateComponentsSetTimeZone_cold_1()
{
  __assert_rtn("CFDateComponentsSetTimeZone", "CFDateComponents.c", 395, "NULL != dateComp");
}

void CFDateComponentsGetValue_cold_1()
{
  __assert_rtn("CFDateComponentsGetValue", "CFDateComponents.c", 228, "NULL != dateComp");
}

void CFDateComponentsSetValue_cold_1()
{
  __assert_rtn("CFDateComponentsSetValue", "CFDateComponents.c", 293, "NULL != dateComp");
}

void CFDateComponentsIsValidDateInCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsIsValidDateInCalendar", "CFDateComponents.c", 424, "NULL != dateComp");
}

void CFDateComponentsIsValidDateInCalendar_cold_2()
{
  __assert_rtn("CFDateComponentsIsValidDateInCalendar", "CFDateComponents.c", 425, "NULL != inCalendar");
}

void _CFCompareStringsWithLocale_cold_1()
{
  qword_18C539A70 = (uint64_t)"Invalid string range produced for character buffer in _CFCompareStringsWithLocale.";
  __break(1u);
}

void _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser_cold_1( uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  int v3 = 136315394;
  uint64_t v4 = a1;
  __int16 v5 = 2080;
  uint64_t v6 = a2;
  _os_log_error_impl( &dword_180A4C000,  log,  OS_LOG_TYPE_ERROR,  "Error getting app group containers for %s: %s",  (uint8_t *)&v3,  0x16u);
}

void _CFPrefsExtractQuadrupleFromPathIfPossible_cold_1()
{
  qword_18C539A70 = (uint64_t)"Mismatched string find result";
  __break(1u);
}

void _CFPrefsValidateValueForKey_cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempt to set a non-property-list object as an NSUserDefaults/CFPreferences value";
  abort();
}

void _CFPrefsValidateValueForKey_cold_2()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  OUTLINED_FUNCTION_0_13();
  _os_log_fault_impl( &dword_180A4C000,  v0,  OS_LOG_TYPE_FAULT,  "Attempt to set a non-property-list object %{public}@ as an NSUserDefaults/CFPreferences value for key %{public}@",  v1,  0x16u);
}

void _CFURLCopyHostName_cold_1()
{
}

void CFURLGetPortNumber_cold_1()
{
}

void _CFURLCopyUserName_cold_1()
{
}

void _CFURLCopyPassword_cold_1()
{
}

void __CFURLCopyParameterString_block_invoke_24_cold_1(uint64_t a1, os_log_s *a2)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = 138477827;
  uint64_t v4 = v2;
  _os_log_debug_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_DEBUG,  "CFURLCopyParameterString is deprecated and now always returns NULL. The path component now includes the part of the URL string which CFURLCopyParameterString used to return.\n URL = %{private}@",  (uint8_t *)&v3,  0xCu);
}

void _unescapedQueryString_cold_1()
{
}

void _CFAppVersionCheckLessThan_cold_1()
{
  qword_18C539A70 = (uint64_t)"invalid bundleID provided, must be non-null";
  __break(1u);
}

void _CFAppVersionCheckLessThan_cold_2()
{
  qword_18C539A70 = (uint64_t)"version check: bundle ID corrupted";
  __break(1u);
}

void decodeTaggedTimeInterval_cold_1()
{
  __assert_rtn("decodeTaggedTimeInterval", "NSDate.m", 244, "encodedBits.unused == 0");
}

void __cficu_ucal_close_cold_1( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __cficu_ucal_clear_cold_1( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __cficu_ucal_getNow_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFRaiseMemoryException(uint64_t a1)
{
}

void __NSICreateBackingForArgumentIfNeeded_cold_1()
{
  qword_18C539A70 = (uint64_t)"Out of memory";
  __break(1u);
}

void __NSICreateBackingForArgumentIfNeeded_cold_2()
{
  qword_18C539A70 = (uint64_t)"Out of memory";
  __break(1u);
}

void ___forwarding____cold_1()
{
  qword_18C539A70 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void ___forwarding____cold_2(int a1, uint64_t a2, SEL sel)
{
  if (__CFOASafe) {
    OUTLINED_FUNCTION_0_18();
  }
  sel_getName(sel);
  CFLog(3LL, (uint64_t)@"*** -[%s %s]: message sent to deallocated instance %p", v5, v6, v7, v8, v9, v10, a2 + 10);
  __break(1u);
}

void ___forwarding____cold_3(void *a1)
{
}

void ___forwarding____cold_4(char *a1, id a2)
{
  Classuint64_t Name = object_getClassName(a2);
  snprintf( a1,  0x100uLL,  "*** NSForwarding: object %p of class '%s' does not implement forwardInvocation:",  a2,  ClassName);
  qword_18C539A70 = (uint64_t)a1;
  __break(1u);
}

void __block_forwarding____cold_1( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (__CFOASafe) {
    OUTLINED_FUNCTION_0_18();
  }
  CFLog( 3LL,  (uint64_t)@"*** NSBlockInvocation: invocation of deallocated Block instance %p",  a3,  a4,  a5,  a6,  a7,  a8,  a1);
  __break(1u);
}

void __block_forwarding____cold_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPreferencesCopyManagedPreferencesContainerURL_cold_1( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPreferencesCopyManagedPreferencesContainerURL_cold_2()
{
}

void _CFPrefsTemporaryFDToWriteTo_cold_1()
{
}

void _CFPrefsTemporaryFDToWriteTo_cold_2()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  OUTLINED_FUNCTION_8_1();
  _os_log_error_impl( &dword_180A4C000,  v0,  OS_LOG_TYPE_ERROR,  "failed to get file system representation for url: %{private}@",  v1,  0xCu);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsTemporaryFDToWriteTo_cold_3()
{
}

void _CFPrefsTemporaryFDToWriteTo_cold_4(int a1, uint64_t a2, os_log_s *a3)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  strerror(a1);
  OUTLINED_FUNCTION_8_1();
  __int16 v6 = 2081;
  uint64_t v7 = a2;
  _os_log_fault_impl( &dword_180A4C000,  a3,  OS_LOG_TYPE_FAULT,  "error %{public}s creating file %{private}s",  v5,  0x16u);
}

void _CFPrefsWritePlistToFDThenClose_cold_1( os_log_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPrefsWritePlistToFDThenClose_cold_2(int a1, os_log_s *a2)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl(&dword_180A4C000, a2, OS_LOG_TYPE_FAULT, "Couldn't get path for fd %d", (uint8_t *)v2, 8u);
  OUTLINED_FUNCTION_3_5();
}

void _CFPrefsWritePlistToFDThenClose_cold_3()
{
}

void _CFPrefsWritePlistToFDThenClose_cold_4()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  OUTLINED_FUNCTION_8_1();
  _os_log_debug_impl(&dword_180A4C000, v0, OS_LOG_TYPE_DEBUG, "wrote file %{public}s", v1, 0xCu);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsWritePlistToFDThenClose_cold_5(uint64_t a1, uint64_t a2, os_log_s *a3)
{
  LOWORD(v3) = 2080;
  *(void *)((char *)&v3 + 2) = a1;
  OUTLINED_FUNCTION_0_19( &dword_180A4C000,  a2,  a3,  "error %d setting do-not-back-up attribute on file %s",  67109378,  (const char *)v3);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsWritePlistToFDThenClose_cold_6()
{
}

void _CFPrefsWritePlistToFDThenClose_cold_7()
{
}

void _CFPrefsWritePlistToFDThenClose_cold_8()
{
}

NSUInteger __CFRequireConcreteImplementation(objc_class *a1, uint64_t a2)
{
  uint64_t v4 = (objc_class *)objc_opt_class();
  uint64_t v5 = OUTLINED_FUNCTION_0_21(a1);
  if (v4 == a1)
  {
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %@: method sent to an instance (%p) of an abstract class.  Create a concrete instance!",  v5,  a2);
  }

  else
  {
    uint64_t v6 = OUTLINED_FUNCTION_0_21(v4);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %@: method only defined for abstract class.  Define %@!",  v5,  v6);
  }

  uint64_t v7 = +[NSException exceptionWithName:reason:userInfo:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:",  @"NSInvalidArgumentException",  _CFAutoreleasePoolAddObject(),  0LL);
  objc_exception_throw(v7);
  return -[NSSet count](v8, v9);
}

void __CFListFormatterDeallocate_cold_1()
{
  __assert_rtn("__CFListFormatterDeallocate", "CFListFormatter.c", 26, "cf != NULL");
}

void __CFListFormatterCopyDescription_cold_1()
{
  __assert_rtn("__CFListFormatterCopyDescription", "CFListFormatter.c", 32, "cf != NULL");
}

void _CFListFormatterCreate_cold_1()
{
  __assert_rtn("_CFListFormatterCreate", "CFListFormatter.c", 54, "allocator != NULL");
}

void _CFListFormatterCreate_cold_2()
{
  __assert_rtn("_CFListFormatterCreate", "CFListFormatter.c", 57, "locale != NULL");
}

void cbRead_cold_1()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 188, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_2()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 195, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_3()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 173, "pCircBuf->available == 0");
}

void cbRead_cold_4()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 221, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_5()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 228, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_6()
{
  __assert_rtn( "cbRead",  "tsCircularBuffer.c",  204,  "pCircBuf->available == (pCircBuf->pDataBegin - pCircBuf->pDataEnd)");
}

void cbRead_cold_7()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 256, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_8()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 247, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_9()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 245, "pCircBuf->pDataBegin == pCircBuf->pDataEnd");
}

void cbRead_cold_10()
{
  __assert_rtn( "cbRead",  "tsCircularBuffer.c",  237,  "pCircBuf->available == ((pCircBuf->pDataBegin - pCircBuf->pData) + (pCircBuf->pBufferEnd - pCircBuf->pDataEnd))");
}

void __cbRead_cold_1()
{
  __assert_rtn("__cbRead", "tsCircularBuffer.c", 124, "pDestination != NULL");
}

void __cbRead_cold_2()
{
  __assert_rtn("__cbRead", "tsCircularBuffer.c", 125, "pSource != NULL");
}

void __cbRead_cold_3()
{
}

void cbWrite_cold_1()
{
  __assert_rtn("cbWrite", "tsCircularBuffer.c", 338, "pCircBuf->available == pCircBuf->length");
}

void cbWrite_cold_2()
{
  __assert_rtn( "cbWrite",  "tsCircularBuffer.c",  371,  "pCircBuf->available == (pCircBuf->pDataBegin - pCircBuf->pDataEnd)");
}

void cbWrite_cold_3()
{
  __assert_rtn( "cbWrite",  "tsCircularBuffer.c",  391,  "pCircBuf->available == ((pCircBuf->pDataBegin - pCircBuf->pData) + (pCircBuf->pBufferEnd - pCircBuf->pDataEnd))");
}

void __cbWrite_cold_1()
{
  __assert_rtn("__cbWrite", "tsCircularBuffer.c", 295, "pDestination != NULL");
}

void __cbWrite_cold_2()
{
  __assert_rtn("__cbWrite", "tsCircularBuffer.c", 296, "pSource != NULL");
}

void __cbWrite_cold_3()
{
}

void __boundsFail(uint64_t a1, uint64_t a2)
{
  v14[1] = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t v9 = a2;
    uint64_t v3 = _os_log_pack_size();
    CFStringRef v11 = (char *)v14 - ((MEMORY[0x1895F8858](v3, v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v12 = OUTLINED_FUNCTION_0_25();
    double v13 = __os_log_helper_1_2_3_8_32_8_0_8_0(v12, (uint64_t)"__boundsFail", a1, --v9);
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds [0 .. %lu]",  v13,  "__boundsFail",  a1,  v9);
    uint64_t v7 = OUTLINED_FUNCTION_1_17();
    uint64_t v8 = v11;
  }

  else
  {
    uint64_t v3 = _os_log_pack_size();
    uint64_t v5 = (char *)v14 - ((MEMORY[0x1895F8858](v3, v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = OUTLINED_FUNCTION_0_25();
    *(_DWORD *)uint64_t v6 = 136315394;
    *(void *)(v6 + 4) = "__boundsFail";
    *(_WORD *)(v6 + 12) = 2048;
    *(void *)(v6 + 14) = a1;
    CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0LL,  @"*** %s: index %lu beyond bounds for empty array",  "__boundsFail",  a1);
    uint64_t v7 = OUTLINED_FUNCTION_1_17();
    uint64_t v8 = v5;
  }

  objc_exception_throw( +[NSException exceptionWithName:reason:userInfo:osLogPack:size:]( &OBJC_CLASS___NSException,  "exceptionWithName:reason:userInfo:osLogPack:size:",  @"NSRangeException",  v7,  0LL,  v8,  v3));
  _CFGetHandleForLoadedLibrary_cold_1();
}

void _CFGetHandleForLoadedLibrary_cold_1()
{
}

void _CFGetHandleForInsertedOrInterposingLibrary_cold_1()
{
}

void __CFBasicHashRehash_cold_1()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_1()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_2()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_3()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_4()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_5()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_6()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_7()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_8()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_9()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_10()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_11()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_12()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void CFBasicHashCreateCopy_cold_1()
{
  qword_18C539A70 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void _CFXNotificationRegistrarAddObserver_cold_1()
{
  __assert_rtn( "_CFXNotificationRegistrarAddObserver",  "CFXNotificationRegistrar.c",  2222,  "(options & kCFXNotificationValidHandlers) != 0");
}

void _CFXNotificationRegistrarAddObserver_cold_2()
{
  __assert_rtn( "_CFXNotificationRegistrarGrowObserverPool",  "CFXNotificationRegistrar.c",  1120,  "registrar->observerPool.capacity == newCapacity");
}

void _CFXNotificationRegistrarAddObject_cold_1()
{
  __assert_rtn("_CFXNotificationObjectTableRehash", "CFXNotificationRegistrar.c", 2035, "newBucketCount != 0");
}

void _CFXNotificationRegistrarAddName_cold_1()
{
  __assert_rtn("_CFXNotificationNameTableRehash", "CFXNotificationRegistrar.c", 1966, "newBucketCount != 0");
}

void _CFBundleGetStringsSources_cold_1()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  OUTLINED_FUNCTION_0_29();
  _os_log_debug_impl( &dword_180A4C000,  v0,  OS_LOG_TYPE_DEBUG,  "loctable overridden by installed files. Bundle: %@, table: %@",  v1,  0x16u);
}

void _CFBundleIngestResultForBundleCache_cold_1()
{
}

void _CFBundleIngestResultForBundleCache_cold_2()
{
}

void _CFBundleIngestResultForBundleCache_cold_3()
{
}

void _CFBundleIngestResultForBundleCache_cold_4()
{
}

void __CFBundleCreateStringsFromPlistData_cold_1()
{
  uint64_t v2 = *MEMORY[0x1895F89C0];
  OUTLINED_FUNCTION_0_29();
  _os_log_error_impl( &dword_180A4C000,  v0,  OS_LOG_TYPE_ERROR,  "Unable to load .strings file: %@ / %@: Top-level object was not a dictionary",  v1,  0x16u);
}

void CFBurstTrieAddUTF8StringWithWeight_cold_1()
{
  qword_18C539A70 = (uint64_t)"list is NULL";
  __break(1u);
}

void CFBurstTrieCursorCreateByCopy_cold_1()
{
}

void serializeCFBurstTrieLevels_cold_1()
{
  __assert_rtn("serializeCFBurstTrieLevels", "CFBurstTrie.c", 1849, "bitcount == count");
}

void _CFPrefsApplyChangesQueueToDictionary_cold_1()
{
}

void _CFPrefsApplyChangesQueueToDictionary_cold_2()
{
}

void _CFPrefsApplyChangesQueueToDictionary_cold_3()
{
  __assert_rtn("_CFPrefsApplyChangesQueueToDictionary", "CFPDSource.m", 1603, "count % CHANGE_QUEUE_TUPLE_COUNT == 0");
}

void _CFPrefsApplyChangesQueueToDictionary_cold_4()
{
  __assert_rtn("_CFPrefsApplyChangesQueueToDictionary", "CFPDSource.m", 1601, "xpc_get_type(queue) == XPC_TYPE_ARRAY");
}

void _CFPrefsMessageSenderIsSandboxed_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2_15( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _calculateUserNameForUID_cold_1(int a1, os_log_s *a2)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  v2[0] = 67240192;
  v2[1] = a1;
  _os_log_fault_impl( &dword_180A4C000,  a2,  OS_LOG_TYPE_FAULT,  "Could not look up the username for %{public}d after three tries",  (uint8_t *)v2,  8u);
}

void _extractCFPDBits_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2_15( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void populateErrorReply_cold_1()
{
}

void withClientContext_cold_1()
{
}

void _CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_cold_1( uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_1()
{
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_2()
{
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsMessageSenderIsSandboxedWithLockedClientContext_cold_1( uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsPIDForMessage_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsGetFixedUpDomainForMessage_cold_1( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_1()
{
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_5( uint64_t a1, os_log_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _CFPrefsCopyFixedUpUserForMessage_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void log_client_activity_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_32( "_CFPrefsConnectionForMessage",  "CFXPreferences_Internal.h",  a3,  "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void client_context_finalizer_cold_1()
{
}

void _CFPrefsIsUserManaged_cold_1(int a1, uint64_t a2, os_log_t log)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v3 = "enabled";
  if (a1 != 1) {
    uint64_t v3 = "disabled";
  }
  int v4 = 136446467;
  uint64_t v5 = v3;
  __int16 v6 = 2113;
  uint64_t v7 = a2;
  _os_log_debug_impl( &dword_180A4C000,  log,  OS_LOG_TYPE_DEBUG,  "Managed preferences are %{public}s for %{private}@",  (uint8_t *)&v4,  0x16u);
  OUTLINED_FUNCTION_0_33();
}

void _CFBundleLoadLimitedInfoDictionary_cold_1()
{
}

void _CFBundleLoadLimitedInfoDictionary_cold_2()
{
  __assert_rtn("_CFBundleLoadLimitedInfoDictionary", "CFBundle_InfoPlist.c", 1151, "bundle->_infoDict == NULL");
}

void _CFBundleCreateFilteredInfoPlistWithData_cold_1(uint64_t a1, uint64_t a2, os_log_s *a3)
{
  *(_DWORD *)uint64_t v3 = 138478083;
  *(void *)&v3[4] = a1;
  *(_WORD *)&v3[12] = 2114;
  *(void *)&v3[14] = a2;
  OUTLINED_FUNCTION_0_34( &dword_180A4C000,  a2,  a3,  "A filtered Info.plist result was not a dictionary at URL %{private}@ (for key paths %{public}@)",  *(void *)v3,  *(void *)&v3[8],  *(void *)&v3[16]);
  OUTLINED_FUNCTION_2_17();
}

void ___parseBundleStrings_block_invoke_cold_1(uint64_t a1, void *a2, os_log_s *a3)
{
  *(_DWORD *)uint64_t v3 = 138543618;
  *(void *)&v3[4] = a1;
  *(_WORD *)&v3[12] = 2114;
  *(void *)&v3[14] = *a2;
  OUTLINED_FUNCTION_0_34( &dword_180A4C000,  (uint64_t)a2,  a3,  "Could not parse markdown while retrieving localized string for key %{public}@ in bundle %{public}@",  *(void *)v3,  *(void *)&v3[8],  *(void *)&v3[16]);
  OUTLINED_FUNCTION_2_17();
}

void __CFPREFERENCES_HAS_DETECTED_THIS_APP_TRYING_TO_STORE_TOO_MUCH_DATA__( void *a1, const void **a2, const void **a3, CFIndex a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  uint64_t v8 = (os_log_s *)_CFPrefsClientLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v9 = (void *)MEMORY[0x186E03CAC]();
    uint64_t v10 = (const void *)[a1 copyOSLogDescription];
    CFStringRef v11 = (const void *)objc_msgSend(a1, "alreadylocked_copyDictionary");
    uint64_t v12 = -[_CFPrefsOversizedPlistDescription initWithDict:setKeys:andValues:count:]( objc_alloc(&OBJC_CLASS____CFPrefsOversizedPlistDescription),  v11,  a2,  a3,  a4);
    double v13 = (os_log_s *)_CFPrefsClientLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138544130;
      int v26 = v10;
      __int16 v27 = 1024;
      int v28 = 0x100000;
      __int16 v29 = 2114;
      uint64_t v30 = _CFProcessNameString();
      __int16 v31 = 2112;
      uint64_t v32 = v12;
      _os_log_fault_impl( &dword_180A4C000,  v13,  OS_LOG_TYPE_FAULT,  "%{public}@: Attempting to store >= %d bytes of data in CFPreferences/NSUserDefaults on this platform is invalid. This is a bug in %{public}@ or a library it uses.\n %@",  buf,  0x26u);
    }

    CFRelease(v10);
    if (v11) {
      CFRelease(v11);
    }
    objc_autoreleasePoolPop(v9);
  }

  _CFAuditTokenForSelf(buf);
  BOOL v14 = (void *)xpc_copy_entitlement_for_token();
  if (!v14)
  {
LABEL_12:
    CFIndex v17 = CFStringCreateWithFormat( (CFAllocatorRef)&__kCFAllocatorSystemDefault,  0,  @"NSUserDefaults/CFPreferences byte count limit reached for %@",  [a1 domainIdentifier]);
    CFIndex Length = CFStringGetLength(v17);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    uint64_t v20 = 255LL;
    if (MaximumSizeForEncoding < 255) {
      uint64_t v20 = MaximumSizeForEncoding;
    }
    CFIndex v21 = v20 + 1;
    uint64_t v22 = (char *)calloc(1uLL, v20 + 1);
    int CString = CFStringGetCString(v17, v22, v21, 0x8000100u);
    CFIndex v24 = "NSUserDefaults/CFPreferences byte count limit reached";
    if (CString) {
      CFIndex v24 = v22;
    }
    qword_18C539A70 = (uint64_t)v24;
    abort();
  }

  uint64_t v15 = v14;
  if (object_getClass(v14) != (Class)MEMORY[0x1895F9228])
  {
    xpc_release(v15);
    goto LABEL_12;
  }

  BOOL value = xpc_BOOL_get_value(v15);
  xpc_release(v15);
  if (!value) {
    goto LABEL_12;
  }
}

void _CFPrefsImpersonateApplicationWithIdentifierAndPID_cold_1()
{
}

void _copyValueForKey_cold_1()
{
}

void _plistSizeIsAppropriateToRead_cold_1()
{
}

void _approximateSizeOfPlistValue_cold_1()
{
  __assert_rtn("_approximateSizeOfPlistValue", "CFPrefsPlistSource.m", 1901, "outObjectCounter == NULL");
}

int32_t NSVersionOfLinkTimeLibrary(const char *libraryName)
{
  return MEMORY[0x1895F8540](libraryName);
}

fat_arch *__cdecl NXFindBestFatArch( cpu_type_t cputype, cpu_subtype_t cpusubtype, fat_arch *fat_archs, uint32_t nfat_archs)
{
  return (fat_arch *)MEMORY[0x1895F8548](*(void *)&cputype, *(void *)&cpusubtype, fat_archs, *(void *)&nfat_archs);
}

const NXArchInfo *NXGetLocalArchInfo(void)
{
  return (const NXArchInfo *)MEMORY[0x1895F8560]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1895F8720](aBlock);
}

BOOL _Block_isDeallocating(const void *aBlock)
{
  return MEMORY[0x1895F8730](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

const char *__cdecl _Block_signature(void *aBlock)
{
  return (const char *)MEMORY[0x1895F8758](aBlock);
}

BOOL _Block_tryRetain(const void *aBlock)
{
  return MEMORY[0x1895F8760](aBlock);
}

void _Block_use_RR2(const Block_callbacks_RR *callbacks)
{
}

uint64_t _CFURLBookmarkDataCopyDescription()
{
  return MEMORY[0x18960DB20]();
}

uint64_t _CFURLCreateBookmarkData()
{
  return MEMORY[0x18960DB28]();
}

uint64_t _CFURLCreateBookmarkDataFromFile()
{
  return MEMORY[0x18960DB30]();
}

uint64_t _CFURLCreateByResolvingBookmarkData()
{
  return MEMORY[0x18960DB38]();
}

uint64_t _CFURLCreateResourcePropertiesForKeysFromBookmarkData()
{
  return MEMORY[0x18960DB40]();
}

uint64_t _CFURLCreateResourcePropertyForKeyFromBookmarkData()
{
  return MEMORY[0x18960DB48]();
}

uint64_t _CFURLStartAccessingSecurityScopedResource()
{
  return MEMORY[0x18960DB50]();
}

uint64_t _CFURLStopAccessingSecurityScopedResource()
{
  return MEMORY[0x18960DB58]();
}

uint64_t _CFURLWriteBookmarkDataToFile()
{
  return MEMORY[0x18960DB60]();
}

uint64_t _FSCreatePathForFileID()
{
  return MEMORY[0x18960DB68]();
}

uint64_t _FSGetFileSystemRepresentationForFileID()
{
  return MEMORY[0x18960DB70]();
}

uint64_t _FSURLBeginResourcePropertyCacheAccess()
{
  return MEMORY[0x18960DB78]();
}

uint64_t _FSURLCacheResourcePropertiesForKeys()
{
  return MEMORY[0x18960DB80]();
}

uint64_t _FSURLCacheResourcePropertyForKey()
{
  return MEMORY[0x18960DB88]();
}

uint64_t _FSURLClearResourcePropertyCacheForKey()
{
  return MEMORY[0x18960DB90]();
}

uint64_t _FSURLCopyResourcePropertiesForKeys()
{
  return MEMORY[0x18960DB98]();
}

uint64_t _FSURLCopyResourcePropertiesForKeysFromCache()
{
  return MEMORY[0x18960DBA0]();
}

uint64_t _FSURLCopyResourcePropertyForKey()
{
  return MEMORY[0x18960DBA8]();
}

uint64_t _FSURLCopyResourcePropertyForKeyFromCache()
{
  return MEMORY[0x18960DBB0]();
}

uint64_t _FSURLCopyResourcePropertyValuesAndFlags()
{
  return MEMORY[0x18960DBB8]();
}

uint64_t _FSURLCreateStandardError()
{
  return MEMORY[0x18960DBC0]();
}

uint64_t _FSURLEndResourcePropertyCacheAccess()
{
  return MEMORY[0x18960DBC8]();
}

uint64_t _FSURLGetCacheAutoFlushingEnabled()
{
  return MEMORY[0x18960DBD0]();
}

uint64_t _FSURLGetCatalogInfo()
{
  return MEMORY[0x18960DBD8]();
}

uint64_t _FSURLGetResourcePropertyFlags()
{
  return MEMORY[0x18960DBE0]();
}

uint64_t _FSURLGetVolumePropertyFlags()
{
  return MEMORY[0x18960DBE8]();
}

uint64_t _FSURLNoteSecurityScopedResourceMoved()
{
  return MEMORY[0x18960DBF0]();
}

uint64_t _FSURLResourceIsReachable()
{
  return MEMORY[0x18960DBF8]();
}

uint64_t _FSURLSetCacheAutoFlushingEnabled()
{
  return MEMORY[0x18960DC00]();
}

uint64_t _FSURLSetPermanentResourcePropertyForKey()
{
  return MEMORY[0x18960DC08]();
}

uint64_t _FSURLSetResourcePropertiesForKeys()
{
  return MEMORY[0x18960DC10]();
}

uint64_t _FSURLSetResourcePropertyForKey()
{
  return MEMORY[0x18960DC18]();
}

uint64_t _FileCacheClearPropertyValueForKey()
{
  return MEMORY[0x18960DC20]();
}

uint64_t _FileCacheCreateShallowCopy()
{
  return MEMORY[0x18960DC28]();
}

uint64_t _FileCacheGetFinderInfo()
{
  return MEMORY[0x18960DC30]();
}

uint64_t _FileCacheGetFlags()
{
  return MEMORY[0x18960DC38]();
}

uint64_t _FileCacheGetName()
{
  return MEMORY[0x18960DC40]();
}

uint64_t _FileCacheGetPropertyValueForKey()
{
  return MEMORY[0x18960DC48]();
}

uint64_t _FileCacheSetPropertyValueForKey()
{
  return MEMORY[0x18960DC50]();
}

uint64_t _FileURLCreateDisplayPathComponentsArray()
{
  return MEMORY[0x18960DC58]();
}

int *_NSGetArgc(void)
{
  return (int *)MEMORY[0x1895F87B8]();
}

char ***_NSGetArgv(void)
{
  return (char ***)MEMORY[0x1895F87C0]();
}

int _NSGetExecutablePath(char *buf, uint32_t *bufsize)
{
  return MEMORY[0x1895F87D0](buf, bufsize);
}

mach_header_64 *_NSGetMachExecuteHeader(void)
{
  return (mach_header_64 *)MEMORY[0x1895F87D8]();
}

uint64_t _RegisterFilePropertyProvider()
{
  return MEMORY[0x18960DC60]();
}

uint64_t _RegisterFilePropertyWithOptions()
{
  return MEMORY[0x18960DC68]();
}

uint64_t _URLAttachSecurityScopeToFileURL()
{
  return MEMORY[0x18960DC70]();
}

uint64_t _URLCopySecurityScopeFromFileURL()
{
  return MEMORY[0x18960DC78]();
}

uint64_t _URLCreateByResolvingAliasFile()
{
  return MEMORY[0x18960DC80]();
}

uint64_t _URLEnumeratorCreateForDirectoryURL()
{
  return MEMORY[0x18960DC88]();
}

uint64_t _URLEnumeratorCreateForMountedVolumes()
{
  return MEMORY[0x18960DC90]();
}

uint64_t _URLEnumeratorGetDescendentLevel()
{
  return MEMORY[0x18960DC98]();
}

uint64_t _URLEnumeratorGetNextURL()
{
  return MEMORY[0x18960DCA0]();
}

uint64_t _URLEnumeratorGetSourceDidChange()
{
  return MEMORY[0x18960DCA8]();
}

uint64_t _URLEnumeratorGetTypeID()
{
  return MEMORY[0x18960DCB0]();
}

uint64_t _URLEnumeratorGetURLsBulk()
{
  return MEMORY[0x18960DCB8]();
}

uint64_t _URLEnumeratorSkipDescendents()
{
  return MEMORY[0x18960DCC0]();
}

uint64_t _URLReplaceObject()
{
  return MEMORY[0x18960DCC8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t __NSCreateBPlistMappedDataFromURL()
{
  return MEMORY[0x189607BD0]();
}

uint64_t __NSCreateBPlistMappedString()
{
  return MEMORY[0x189607BD8]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1895F8880](*(void *)&a1, a2, *(void *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1895F8898]();
}

double __exp10(double a1)
{
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1895F8918](*(void *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1895F8930]();
}

uint64_t __memmove_chk()
{
  return MEMORY[0x1895F8938]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1895F8940]();
}

uint64_t __stpcpy_chk()
{
  return MEMORY[0x1895F89E8]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1895F8A00]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1895F8A08]();
}

uint64_t __strncat_chk()
{
  return MEMORY[0x1895F8A10]();
}

uint64_t __strncpy_chk()
{
  return MEMORY[0x1895F8A18]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1895F8A28](*(void *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1895F8A30](*(void *)&a1);
}

uint64_t __udivti3()
{
  return MEMORY[0x1895F8A38]();
}

uint64_t _dispatch_get_main_queue_port_4CF()
{
  return MEMORY[0x1895F8AC8]();
}

uint64_t _dispatch_main_queue_callback_4CF()
{
  return MEMORY[0x1895F8AE8]();
}

uint64_t _dispatch_runloop_root_queue_create_4CF()
{
  return MEMORY[0x1895F8B00]();
}

uint64_t _dispatch_runloop_root_queue_get_port_4CF()
{
  return MEMORY[0x1895F8B08]();
}

uint64_t _dispatch_runloop_root_queue_perform_4CF()
{
  return MEMORY[0x1895F8B10]();
}

const mach_header *__cdecl _dyld_get_image_header(uint32_t image_index)
{
  return (const mach_header *)MEMORY[0x1895F8C00](*(void *)&image_index);
}

const char *__cdecl _dyld_get_image_name(uint32_t image_index)
{
  return (const char *)MEMORY[0x1895F8C08](*(void *)&image_index);
}

intptr_t _dyld_get_image_vmaddr_slide(uint32_t image_index)
{
  return MEMORY[0x1895F8C20](*(void *)&image_index);
}

uint32_t _dyld_image_count(void)
{
  return MEMORY[0x1895F8C58]();
}

uint64_t _dyld_is_memory_immutable()
{
  return MEMORY[0x1895F8C60]();
}

BOOL _dyld_shared_cache_contains_path(const char *path)
{
  return MEMORY[0x1895F8CE0](path);
}

uint64_t _objc_autoreleasePoolPrint()
{
  return MEMORY[0x189616388]();
}

uint64_t _objc_getFreedObjectClass()
{
  return MEMORY[0x1896163B8]();
}

uint64_t _objc_registerTaggedPointerClass()
{
  return MEMORY[0x1896163D8]();
}

uint64_t _objc_rootAllocWithZone()
{
  return MEMORY[0x1896163E8]();
}

uint64_t _objc_rootAutorelease()
{
  return MEMORY[0x1896163F0]();
}

uint64_t _objc_rootDealloc()
{
  return MEMORY[0x1896163F8]();
}

uint64_t _objc_rootRelease()
{
  return MEMORY[0x189616418]();
}

uint64_t _objc_rootRetain()
{
  return MEMORY[0x189616428]();
}

uint64_t _objc_rootTryRetain()
{
  return MEMORY[0x189616438]();
}

uint64_t _objc_setBadAllocHandler()
{
  return MEMORY[0x189616448]();
}

os_activity_t _os_activity_create( void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1895F8D40](dso, description, activity, *(void *)&flags);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1895F8D88]();
}

void _os_log_debug_impl( void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl( void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl( void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_pack_fill()
{
  return MEMORY[0x1895F8DD0]();
}

uint64_t _os_log_pack_size()
{
  return MEMORY[0x1895F8DD8]();
}

uint64_t _os_log_set_nscf_formatter()
{
  return MEMORY[0x1895F8DE8]();
}

void abort(void)
{
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1895F9320](*(void *)&a1, a2, a3);
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1895F9328](a1, *(void *)&a2);
}

acl_t acl_dup(acl_t acl)
{
  return (acl_t)MEMORY[0x1895F9388](acl);
}

int acl_free(void *obj_p)
{
  return MEMORY[0x1895F9390](obj_p);
}

acl_t acl_from_text(const char *buf_p)
{
  return (acl_t)MEMORY[0x1895F9398](buf_p);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x1895F9458](acl, len_p);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1895F94C0]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

void asl_close(asl_object_t obj)
{
}

void asl_free(asl_object_t obj)
{
}

asl_object_t asl_new(uint32_t type)
{
  return (asl_object_t)MEMORY[0x1895F9518](*(void *)&type);
}

asl_object_t asl_open(const char *ident, const char *facility, uint32_t opts)
{
  return (asl_object_t)MEMORY[0x1895F9520](ident, facility, *(void *)&opts);
}

int asl_send(asl_object_t obj, asl_object_t msg)
{
  return MEMORY[0x1895F9528](obj, msg);
}

int asl_set(asl_object_t obj, const char *key, const char *value)
{
  return MEMORY[0x1895F9530](obj, key, value);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1895F9540](a1, a2);
}

int atexit(void (*a1)(void))
{
  return MEMORY[0x1895F9588](a1);
}

uint64_t atol(const char *a1)
{
  return MEMORY[0x1895F95A8](a1);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1895F95D0](a1, *(void *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1895F95E0](a1, *(void *)&a2);
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1895F95F8](a1, a2);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1895F9608](*(void *)&a1, a2, *(void *)&a3);
}

kern_return_t bootstrap_check_in(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1895F9610](*(void *)&bp, service_name, sp);
}

uint64_t bootstrap_look_up2()
{
  return MEMORY[0x1895F9620]();
}

uint64_t bootstrap_register2()
{
  return MEMORY[0x1895F9640]();
}

const char *__cdecl bootstrap_strerror(kern_return_t r)
{
  return (const char *)MEMORY[0x1895F9648](*(void *)&r);
}

void *__cdecl bsearch( const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x1895F9650](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
}

int cache_create(const char *name, const cache_attributes_t *attrs, cache_t **cache_out)
{
  return MEMORY[0x1895F9680](name, attrs, cache_out);
}

int cache_destroy(cache_t *cache)
{
  return MEMORY[0x1895F9688](cache);
}

uint64_t cache_get()
{
  return MEMORY[0x1895F9690]();
}

uint64_t cache_get_cost_hint()
{
  return MEMORY[0x1895F96A0]();
}

uint64_t cache_get_count_hint()
{
  return MEMORY[0x1895F96A8]();
}

uint64_t cache_get_minimum_values_hint()
{
  return MEMORY[0x1895F96B0]();
}

uint64_t cache_get_name()
{
  return MEMORY[0x1895F96B8]();
}

uint64_t cache_invoke()
{
  return MEMORY[0x1895F96C0]();
}

int cache_release_value(cache_t *cache, void *value)
{
  return MEMORY[0x1895F96C8](cache, value);
}

int cache_remove(cache_t *cache, void *key)
{
  return MEMORY[0x1895F96D0](cache, key);
}

int cache_remove_all(cache_t *cache)
{
  return MEMORY[0x1895F96D8](cache);
}

uint64_t cache_remove_with_block()
{
  return MEMORY[0x1895F96E0]();
}

int cache_set_and_retain(cache_t *cache, void *key, void *value, cache_cost_t cost)
{
  return MEMORY[0x1895F96E8](cache, key, value, cost);
}

uint64_t cache_set_cost_hint()
{
  return MEMORY[0x1895F96F0]();
}

uint64_t cache_set_count_hint()
{
  return MEMORY[0x1895F96F8]();
}

uint64_t cache_set_minimum_values_hint()
{
  return MEMORY[0x1895F9700]();
}

uint64_t cache_set_name()
{
  return MEMORY[0x1895F9708]();
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x1895F9710](__count, __size);
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x1895FA538](a1, a2);
}

Protocol **__cdecl class_copyProtocolList(Class cls, unsigned int *outCount)
{
  return (Protocol **)MEMORY[0x189616490](cls, outCount);
}

id class_createInstance(Class cls, size_t extraBytes)
{
  return (id)MEMORY[0x189616498](cls, extraBytes);
}

Method class_getInstanceMethod(Class cls, SEL name)
{
  return (Method)MEMORY[0x1896164B0](cls, name);
}

size_t class_getInstanceSize(Class cls)
{
  return MEMORY[0x1896164B8](cls);
}

IMP class_getMethodImplementation(Class cls, SEL name)
{
  return (IMP)MEMORY[0x1896164C8](cls, name);
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x1896164D0](cls);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x1896164E0](cls);
}

BOOL class_isMetaClass(Class cls)
{
  return MEMORY[0x1896164F0](cls);
}

BOOL class_respondsToSelector(Class cls, SEL sel)
{
  return MEMORY[0x189616500](cls, sel);
}

Class class_setSuperclass(Class cls, Class newSuper)
{
  return (Class)MEMORY[0x189616508](cls, newSuper);
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1895FA570](*(void *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1895FA590](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1895FA5A8](a1);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1895FA5F0](*(void *)&a1, a2, *(void *)&a3);
}

uint64_t container_create_or_lookup_app_group_path_by_app_group_identifier()
{
  return MEMORY[0x1895FA720]();
}

uint64_t container_error_copy_unlocalized_description()
{
  return MEMORY[0x1895FA788]();
}

uint64_t container_get_error_description()
{
  return MEMORY[0x1895FA7F8]();
}

uint64_t container_get_identifier()
{
  return MEMORY[0x1895FA800]();
}

uint64_t container_get_path()
{
  return MEMORY[0x1895FA810]();
}

uint64_t container_query_create()
{
  return MEMORY[0x1895FA8F8]();
}

uint64_t container_query_free()
{
  return MEMORY[0x1895FA908]();
}

uint64_t container_query_get_last_error()
{
  return MEMORY[0x1895FA910]();
}

uint64_t container_query_iterate_results_sync()
{
  return MEMORY[0x1895FA920]();
}

uint64_t container_query_operation_set_flags()
{
  return MEMORY[0x1895FA930]();
}

uint64_t container_query_set_class()
{
  return MEMORY[0x1895FA940]();
}

uint64_t container_query_set_identifiers()
{
  return MEMORY[0x1895FA950]();
}

uint64_t container_query_set_persona_unique_string()
{
  return MEMORY[0x1895FA960]();
}

uint64_t container_query_set_uid()
{
  return MEMORY[0x1895FA970]();
}

uint64_t container_system_group_path_for_identifier()
{
  return MEMORY[0x1895FA9D8]();
}

uint64_t csops()
{
  return MEMORY[0x1895FAAA0]();
}

uint64_t csops_audittoken()
{
  return MEMORY[0x1895FAAA8]();
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  return (char *)MEMORY[0x1895FAAC0](a1, a2);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1895FAAE0](a1, a2);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1895FABB0](flags, block);
}

dispatch_data_t dispatch_data_create( const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1895FABF8](buffer, size, queue, destructor);
}

uint64_t dispatch_data_create_alloc()
{
  return MEMORY[0x1895FAC00]();
}

dispatch_queue_global_t dispatch_get_global_queue(uint64_t identifier, unint64_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1895FAC40](identifier, flags);
}

void dispatch_main(void)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency( dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1895FAD68](attr, frequency);
}

uint64_t dispatch_queue_attr_make_with_overcommit()
{
  return MEMORY[0x1895FAD70]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class( dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1895FAD78](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1895FAD80](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2( const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1895FAD90](label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(uint64_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1895FADF0](value);
}

uint64_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1895FAE00](dsema);
}

uint64_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1895FAE08](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create( dispatch_source_type_t type, uintptr_t handle, unint64_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1895FAE50](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer( dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1895FAEE8](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x1895FAEF0](when, delta);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1895FAF48](a1, a2);
}

int dlclose(void *__handle)
{
  return MEMORY[0x1895FAF50](__handle);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1895FAF58]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1895FAF60](__path, *(void *)&__mode);
}

BOOL dlopen_preflight(const char *__path)
{
  return MEMORY[0x1895FAF70](__path);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1895FAF78](__handle, __symbol);
}

int dup(int a1)
{
  return MEMORY[0x1895FAFA8](*(void *)&a1);
}

int dup2(int a1, int a2)
{
  return MEMORY[0x1895FAFB8](*(void *)&a1, *(void *)&a2);
}

uint64_t dyld_get_active_platform()
{
  return MEMORY[0x1895FAFD8]();
}

uint64_t dyld_has_inserted_or_interposing_libraries()
{
  return MEMORY[0x1895FAFF8]();
}

uint64_t dyld_image_path_containing_address()
{
  return MEMORY[0x1895FB030]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1895FB088]();
}

void exit(int a1)
{
}

int fchmod(int a1, mode_t a2)
{
  return MEMORY[0x1895FB1E0](*(void *)&a1, a2);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1895FB1F0](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1895FB210](*(void *)&a1, *(void *)&a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1895FB268](a1);
}

filesec_t filesec_dup(filesec_t a1)
{
  return (filesec_t)MEMORY[0x1895FB2B8](a1);
}

void filesec_free(filesec_t a1)
{
}

int filesec_get_property(filesec_t a1, filesec_property_t a2, void *a3)
{
  return MEMORY[0x1895FB2C8](a1, *(void *)&a2, a3);
}

filesec_t filesec_init(void)
{
  return (filesec_t)MEMORY[0x1895FB2D0]();
}

int filesec_set_property(filesec_t a1, filesec_property_t a2, const void *a3)
{
  return MEMORY[0x1895FB2D8](a1, *(void *)&a2, a3);
}

int filesec_unset_property(filesec_t a1, filesec_property_t a2)
{
  return MEMORY[0x1895FB2E0](a1, *(void *)&a2);
}

int flsl(uint64_t a1)
{
  return MEMORY[0x1895FB308](a1);
}

double fmod(double a1, double a2)
{
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1895FB348](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1895FB360](a1, a2);
}

int fprintf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  return MEMORY[0x1895FB368](a1, a2, a3);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1895FB378](a1, a2);
}

void free(void *a1)
{
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1895FB438](*(void *)&fd, name, value, size, *(void *)&position, *(void *)&options);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1895FB448](*(void *)&a1, a2);
}

int fstatat(int a1, const char *a2, stat *a3, int a4)
{
  return MEMORY[0x1895FB458](*(void *)&a1, a2, a3, *(void *)&a4);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x1895FB460](*(void *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x1895FB468](*(void *)&a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1895FB480](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1895FB4C8](__ptr, __size, __nitems, __stream);
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return (char *)MEMORY[0x1895FB520](a1, a2);
}

gid_t getegid(void)
{
  return MEMORY[0x1895FB530]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1895FB538](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x1895FB540]();
}

int gethostname(char *a1, size_t a2)
{
  return MEMORY[0x1895FB590](a1, a2);
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1895FB610](*(void *)&a1, a2, a3);
}

pid_t getpid(void)
{
  return MEMORY[0x1895FB628]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x1895FB638]();
}

passwd *__cdecl getpwnam(const char *a1)
{
  return (passwd *)MEMORY[0x1895FB660](a1);
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x1895FB670](*(void *)&a1);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x1895FB680](*(void *)&a1, a2);
}

const section_64 *__cdecl getsectbynamefromheader_64( const mach_header_64 *mhp, const char *segname, const char *sectname)
{
  return (const section_64 *)MEMORY[0x1895FB690](mhp, segname, sectname);
}

const segment_command_64 *__cdecl getsegbyname(const char *segname)
{
  return (const segment_command_64 *)MEMORY[0x1895FB6A8](segname);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1895FB6D0](*(void *)&a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return MEMORY[0x1895FB6D8](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1895FB6E0](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1895FB6E8]();
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1895FB708](path, name, value, size, *(void *)&position, *(void *)&options);
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1895FB728](a1, a2);
}

uint64_t instrumentObjcMessageSends()
{
  return MEMORY[0x189616528]();
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x1895FB850](*(void *)&a1, a2);
}

int issetugid(void)
{
  return MEMORY[0x1895FB870]();
}

uint64_t kdebug_is_enabled()
{
  return MEMORY[0x1895FB8B0]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1895FB8C0]();
}

uint64_t kdebug_trace_string()
{
  return MEMORY[0x1895FB8C8]();
}

uint64_t kpersona_info()
{
  return MEMORY[0x1895FB908]();
}

int listen(int a1, int a2)
{
  return MEMORY[0x1895FB9F8](*(void *)&a1, *(void *)&a2);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1895FBA20](a1, a2);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1895FBA80](*(void *)&a1, a2, *(void *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1895FBA88](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1895FBA98]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1895FBAC0](*(void *)&error_value);
}

mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1895FBAE8]( msg,  *(void *)&option,  *(void *)&send_size,  *(void *)&rcv_size,  *(void *)&rcv_name,  *(void *)&timeout,  *(void *)&notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x1895FBB10](*(void *)&task, *(void *)&right, name);
}

kern_return_t mach_port_construct( ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  return MEMORY[0x1895FBB18](*(void *)&task, options, context, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1895FBB28](*(void *)&task, *(void *)&name);
}

kern_return_t mach_port_destruct( ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return MEMORY[0x1895FBB30](*(void *)&task, *(void *)&name, *(void *)&srdelta, guard);
}

kern_return_t mach_port_extract_member(ipc_space_t task, mach_port_name_t name, mach_port_name_t pset)
{
  return MEMORY[0x1895FBB38](*(void *)&task, *(void *)&name, *(void *)&pset);
}

kern_return_t mach_port_get_attributes( ipc_space_inspect_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return MEMORY[0x1895FBB48](*(void *)&task, *(void *)&name, *(void *)&flavor, port_info_out, port_info_outCnt);
}

kern_return_t mach_port_insert_member(ipc_space_t task, mach_port_name_t name, mach_port_name_t pset)
{
  return MEMORY[0x1895FBB68](*(void *)&task, *(void *)&name, *(void *)&pset);
}

kern_return_t mach_port_insert_right( ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x1895FBB70](*(void *)&task, *(void *)&name, *(void *)&poly, *(void *)&polyPoly);
}

kern_return_t mach_port_mod_refs( ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x1895FBB78](*(void *)&task, *(void *)&name, *(void *)&right, *(void *)&delta);
}

kern_return_t mach_port_type(ipc_space_t task, mach_port_name_t name, mach_port_type_t *ptype)
{
  return MEMORY[0x1895FBBA8](*(void *)&task, *(void *)&name, ptype);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1895FBBF8](info);
}

kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags)
{
  return MEMORY[0x1895FBC00](*(void *)&target, address, size, *(void *)&flags);
}

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return MEMORY[0x1895FBC10](*(void *)&target, address, size);
}

kern_return_t mach_vm_region( vm_map_read_t target_task, mach_vm_address_t *address, mach_vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name)
{
  return MEMORY[0x1895FBC40](*(void *)&target_task, address, size, *(void *)&flavor, info, infoCnt, object_name);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x1895FBC88](__size);
}

malloc_zone_t *malloc_default_zone(void)
{
  return (malloc_zone_t *)MEMORY[0x1895FBCA0]();
}

size_t malloc_good_size(size_t size)
{
  return MEMORY[0x1895FBCC0](size);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1895FBCE0](ptr);
}

void *__cdecl malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size)
{
  return (void *)MEMORY[0x1895FBD10](zone, num_items, size);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
}

void *__cdecl malloc_zone_malloc(malloc_zone_t *zone, size_t size)
{
  return (void *)MEMORY[0x1895FBD30](zone, size);
}

void *__cdecl malloc_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size)
{
  return (void *)MEMORY[0x1895FBD40](zone, alignment, size);
}

void *__cdecl malloc_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size)
{
  return (void *)MEMORY[0x1895FBD48](zone, ptr, size);
}

void *__cdecl memchr(const void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1895FBE00](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1895FBE08](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1895FBE18](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1895FBE30](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1895FBE48](__b, *(void *)&__c, __len);
}

void method_exchangeImplementations(Method m1, Method m2)
{
}

SEL method_getName(Method m)
{
  return (SEL)MEMORY[0x189616578](m);
}

const char *__cdecl method_getTypeEncoding(Method m)
{
  return (const char *)MEMORY[0x189616590](m);
}

uint64_t mk_timer_arm()
{
  return MEMORY[0x1895FBED0]();
}

uint64_t mk_timer_cancel()
{
  return MEMORY[0x1895FBED8]();
}

uint64_t mk_timer_create()
{
  return MEMORY[0x1895FBEE0]();
}

uint64_t mk_timer_destroy()
{
  return MEMORY[0x1895FBEE8]();
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1895FBEF0](a1, a2);
}

int mkdirat(int a1, const char *a2, mode_t a3)
{
  return MEMORY[0x1895FBEF8](*(void *)&a1, a2, a3);
}

int mkstemp(char *a1)
{
  return MEMORY[0x1895FBF38](a1);
}

int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
{
  return MEMORY[0x1895FBF40](path, *(void *)&dpclass, *(void *)&dpflags);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1895FBF70](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

double modf(double a1, double *a2)
{
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1895FBF98](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1895FC188](*(void *)&token);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1895FC1B0](name);
}

uint32_t notify_register_dispatch( const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1895FC1C0](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1896165B0](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x1896165B8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1896165C0]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x1896165C8](superclass, name, extraBytes);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1896165D8](a1);
}

void objc_autoreleasePoolPop(void *context)
{
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1896165E8]();
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1896165F8](exc_buf);
}

id objc_constructInstance(Class cls, void *bytes)
{
  return (id)MEMORY[0x189616608](cls, bytes);
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void *__cdecl objc_destructInstance(id obj)
{
  return (void *)MEMORY[0x189616668](obj);
}

Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x189616678](original, name, extraBytes);
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_rethrow(void)
{
}

void objc_exception_throw(id exception)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1896166B8](name);
}

Class objc_getFutureClass(const char *name)
{
  return (Class)MEMORY[0x1896166C0](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1896166C8](self, _cmd, offset, atomic);
}

Protocol *__cdecl objc_getProtocol(const char *name)
{
  return (Protocol *)MEMORY[0x1896166D0](name);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1896166D8](location, val);
}

uint64_t objc_initializeClassPair()
{
  return MEMORY[0x1896166E8]();
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1896166F8](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x189616700](location);
}

Class objc_lookUpClass(const char *name)
{
  return (Class)MEMORY[0x189616708](name);
}

void objc_moveWeak(id *to, id *from)
{
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x189616718](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x189616728](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x189616730]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x189616738]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x189616740]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x189616748]();
}

uint64_t objc_opt_self()
{
  return MEMORY[0x189616750]();
}

void objc_registerClassPair(Class cls)
{
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x189616818](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
}

void objc_setEnumerationMutationHandler(void (__cdecl *handler)(id))
{
}

objc_exception_matcher objc_setExceptionMatcher(objc_exception_matcher fn)
{
  return (objc_exception_matcher)MEMORY[0x189616908](fn);
}

objc_exception_preprocessor objc_setExceptionPreprocessor(objc_exception_preprocessor fn)
{
  return (objc_exception_preprocessor)MEMORY[0x189616910](fn);
}

void objc_setForwardHandler(void *fwd, void *fwd_stret)
{
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

objc_uncaught_exception_handler objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)
{
  return (objc_uncaught_exception_handler)MEMORY[0x189616958](fn);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x189616968](location, obj);
}

id objc_storeWeakOrNil(id *location, id obj)
{
  return (id)MEMORY[0x189616970](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x189616978](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x189616980](obj);
}

void objc_terminate(void)
{
}

id object_dispose(id a1)
{
  return (id)MEMORY[0x1896169A0](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1896169A8](a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return (const char *)MEMORY[0x1896169B0](a1);
}

void *__cdecl object_getIndexedIvars(id a1)
{
  return (void *)MEMORY[0x1896169B8](a1);
}

uint64_t object_getMethodImplementation()
{
  return MEMORY[0x1896169C8]();
}

Class object_setClass(id a1, Class a2)
{
  return (Class)MEMORY[0x1896169D8](a1, a2);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1895FC248](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1895FC250](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

int openat(int a1, const char *a2, int a3, ...)
{
  return MEMORY[0x1895FC268](*(void *)&a1, a2, *(void *)&a3);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1895FC278](a1);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1895FC440](subsystem, category);
}

uint64_t os_log_shim_enabled()
{
  return MEMORY[0x1895FC460]();
}

uint64_t os_log_shim_with_CFString()
{
  return MEMORY[0x1895FC468]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1895FC470](oslog, type);
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1895FC640]();
}

void os_unfair_lock_assert_not_owner(os_unfair_lock_t lock)
{
}

void os_unfair_lock_assert_owner(os_unfair_lock_t lock)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1895FC668]();
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x1895FC670](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_recursive_lock_lock_with_options()
{
  return MEMORY[0x1895FC688]();
}

uint64_t os_unfair_recursive_lock_unlock()
{
  return MEMORY[0x1895FC6A0]();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1895FC6C8]();
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1895FC890](a1);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1895FC8C8](*(void *)&pid, buffer, *(void *)&buffersize);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x1895FC8E0](*(void *)&pid, *(void *)&flavor, arg, buffer, *(void *)&buffersize);
}

int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1895FC8E8](*(void *)&pid, buffer, *(void *)&buffersize);
}

objc_method_description protocol_getMethodDescription( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  uint64_t v4 = (const char *)MEMORY[0x189616A38](p, aSel, isRequiredMethod, isInstanceMethod);
  result.types = v5;
  result.mach_port_name_t name = v4;
  return result;
}

uint64_t pselect_DARWIN_EXTSN()
{
  return MEMORY[0x1895FC930]();
}

int pthread_atfork(void (*a1)(void), void (*a2)(void), void (*a3)(void))
{
  return MEMORY[0x1895FC938](a1, a2, a3);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1895FC940](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1895FC958](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x1895FC960](__attr, *(void *)&__qos_class, *(void *)&__relative_priority);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1895FC968](a1, *(void *)&a2);
}

int pthread_attr_setscope(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1895FC980](a1, *(void *)&a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1895FC9D8](a1, a2, a3, a4);
}

int pthread_equal(pthread_t a1, pthread_t a2)
{
  return MEMORY[0x1895FCA00](a1, a2);
}

int pthread_getugid_np(uid_t *a1, gid_t *a2)
{
  return MEMORY[0x1895FCA48](a1, a2);
}

int pthread_is_threaded_np(void)
{
  return MEMORY[0x1895FCA50]();
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1895FCA60](a1, a2);
}

uint64_t pthread_key_init_np()
{
  return MEMORY[0x1895FCA68]();
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1895FCA70](a1);
}

int pthread_main_np(void)
{
  return MEMORY[0x1895FCA78]();
}

uint64_t pthread_main_thread_np()
{
  return MEMORY[0x1895FCA80]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCA88](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1895FCA90](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCA98](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCAA8](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1895FCAB0](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1895FCAB8](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1895FCAC0](a1, *(void *)&a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1895FCB20]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1895FCB38](a1);
}

int pthread_threadid_np(pthread_t a1, __uint64_t *a2)
{
  return MEMORY[0x1895FCB68](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x1895FCB98](a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1895FCBA0](*(void *)&__fd, __buf, __nbyte, a4);
}

qos_class_t qos_class_main(void)
{
  return MEMORY[0x1895FCBB0]();
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x1895FCBB8]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1895FCC38](*(void *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1895FCC40](a1);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return MEMORY[0x1895FCC48](a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1895FCC50](a1, a2, a3);
}

void *__cdecl realloc(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1895FCC68](__ptr, __size);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x1895FCCA8](*(void *)&a1, a2, a3, *(void *)&a4);
}

ssize_t recvfrom(int a1, void *a2, size_t a3, int a4, sockaddr *a5, socklen_t *a6)
{
  return MEMORY[0x1895FCCB0](*(void *)&a1, a2, a3, *(void *)&a4, a5, a6);
}

int renameat(int a1, const char *a2, int a3, const char *a4)
{
  return MEMORY[0x1895FCD58](*(void *)&a1, a2, *(void *)&a3, a4);
}

int rmdir(const char *a1)
{
  return MEMORY[0x1895FCD80](a1);
}

uint64_t sandbox_check()
{
  return MEMORY[0x1895FCD90]();
}

uint64_t sandbox_check_by_audit_token()
{
  return MEMORY[0x1895FCD98]();
}

uint64_t sandbox_container_path_for_audit_token()
{
  return MEMORY[0x1895FCDA0]();
}

uint64_t sandbox_passthrough_access()
{
  return MEMORY[0x1895FCDE8]();
}

double scalbn(double a1, int a2)
{
  return result;
}

const char *__cdecl sel_getName(SEL sel)
{
  return (const char *)MEMORY[0x189616A48](sel);
}

SEL sel_getUid(const char *str)
{
  return (SEL)MEMORY[0x189616A50](str);
}

SEL sel_registerName(const char *str)
{
  return (SEL)MEMORY[0x189616A68](str);
}

uint64_t select_DARWIN_EXTSN()
{
  return MEMORY[0x1895FCE18]();
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x1895FCE30](*(void *)&a1, a2, a3, *(void *)&a4);
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  return MEMORY[0x1895FCE48](*(void *)&a1, a2, a3, *(void *)&a4, a5, *(void *)&a6);
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return MEMORY[0x1895FCE68](__name, __value, *(void *)&__overwrite);
}

int setiopolicy_np(int a1, int a2, int a3)
{
  return MEMORY[0x1895FCE80](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x1895FCEB8](*(void *)&a1, a2);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x1895FCEC8](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4, *(void *)&a5);
}

int shm_open(const char *a1, int a2, ...)
{
  return MEMORY[0x1895FCEE8](a1, *(void *)&a2);
}

int shutdown(int a1, int a2)
{
  return MEMORY[0x1895FCEF8](*(void *)&a1, *(void *)&a2);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return (void (__cdecl *)(int))MEMORY[0x1895FCF50](*(void *)&a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1895FCF88](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1895FCF90](__str, __size, __format);
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  return MEMORY[0x1895FCF98](a1, a2, a3, a4);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1895FCFA0](*(void *)&a1, *(void *)&a2, *(void *)&a3);
}

int socketpair(int a1, int a2, int a3, int *a4)
{
  return MEMORY[0x1895FCFA8](*(void *)&a1, *(void *)&a2, *(void *)&a3, a4);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1895FD010](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1895FD018](a1, a2);
}

char *__cdecl strchr(const char *__s, int __c)
{
  return (char *)MEMORY[0x1895FD048](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1895FD050](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1895FD078](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1895FD080](*(void *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1895FD0A0](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1895FD0B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1895FD0B8](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1895FD0D0](a1, a2, a3);
}

int strncasecmp_l(const char *a1, const char *a2, size_t a3, locale_t a4)
{
  return MEMORY[0x1895FD0D8](a1, a2, a3, a4);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x1895FD0E0](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1895FD0E8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1895FD0F0](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1895FD100](__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return (char *)MEMORY[0x1895FD108](__big, __little, __len);
}

char *__cdecl strrchr(const char *__s, int __c)
{
  return (char *)MEMORY[0x1895FD120](__s, *(void *)&__c);
}

char *__cdecl strstr(const char *__big, const char *__little)
{
  return (char *)MEMORY[0x1895FD148](__big, __little);
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1895FD180](__str, __endptr, *(void *)&__base);
}

uint64_t strtol_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1895FD188](a1, a2, *(void *)&a3, a4);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1895FD1A0](__str, __endptr, *(void *)&__base);
}

uint64_t strtoll_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1895FD1A8](a1, a2, *(void *)&a3, a4);
}

unint64_t strtoul_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1895FD1C0](a1, a2, *(void *)&a3, a4);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1895FD2B0](a1, *(void *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1895FD2B8](a1, a2, a3, a4, a5);
}

sysdir_search_path_enumeration_state sysdir_get_next_search_path_enumeration( sysdir_search_path_enumeration_state state, char *path)
{
  return MEMORY[0x1895FD2C8](*(void *)&state, path);
}

uint64_t sysdir_start_search_path_enumeration_private()
{
  return MEMORY[0x1895FD2D8]();
}

kern_return_t task_get_special_port(task_inspect_t task, int which_port, mach_port_t *special_port)
{
  return MEMORY[0x1895FD310](*(void *)&task, *(void *)&which_port, special_port);
}

kern_return_t task_info( task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x1895FD320](*(void *)&target_task, *(void *)&flavor, task_info_out, task_info_outCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1895FD400](a1);
}

const char *__cdecl u_errorName(UErrorCode code)
{
  return (const char *)MEMORY[0x189615420](*(void *)&code);
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  return MEMORY[0x189615428](*(void *)&c, *(void *)&which);
}

UBool u_hasBinaryProperty(UChar32 c, UProperty which)
{
  return MEMORY[0x189615438](*(void *)&c, *(void *)&which);
}

UBool u_isdigit(UChar32 c)
{
  return MEMORY[0x189615448](*(void *)&c);
}

int32_t u_strlen(const UChar *s)
{
  return MEMORY[0x189615458](s);
}

uint64_t uadatpg_remapPatternWithOptions()
{
  return MEMORY[0x189615468]();
}

uint64_t ualoc_localizationsToUse()
{
  return MEMORY[0x189615480]();
}

uint64_t ubidi_close()
{
  return MEMORY[0x1896154E0]();
}

uint64_t ubidi_getLevels()
{
  return MEMORY[0x1896154F0]();
}

uint64_t ubidi_getParaLevel()
{
  return MEMORY[0x1896154F8]();
}

uint64_t ubidi_open()
{
  return MEMORY[0x189615510]();
}

uint64_t ubidi_setContext()
{
  return MEMORY[0x189615518]();
}

uint64_t ubidi_setParaWithControls()
{
  return MEMORY[0x189615528]();
}

uint64_t ubrk_close()
{
  return MEMORY[0x189615540]();
}

uint64_t ubrk_last()
{
  return MEMORY[0x189615548]();
}

uint64_t ubrk_open()
{
  return MEMORY[0x189615550]();
}

uint64_t ubrk_preceding()
{
  return MEMORY[0x189615558]();
}

uint64_t ubrk_setText()
{
  return MEMORY[0x189615560]();
}

uint64_t ucal_add()
{
  return MEMORY[0x189615568]();
}

uint64_t ucal_clear()
{
  return MEMORY[0x189615570]();
}

uint64_t ucal_clone()
{
  return MEMORY[0x189615578]();
}

uint64_t ucal_close()
{
  return MEMORY[0x189615580]();
}

uint64_t ucal_get()
{
  return MEMORY[0x189615588]();
}

uint64_t ucal_getAttribute()
{
  return MEMORY[0x189615590]();
}

uint64_t ucal_getDayOfWeekType()
{
  return MEMORY[0x1896155A0]();
}

uint64_t ucal_getFieldDifference()
{
  return MEMORY[0x1896155A8]();
}

uint64_t ucal_getGregorianChange()
{
  return MEMORY[0x1896155B0]();
}

uint64_t ucal_getLimit()
{
  return MEMORY[0x1896155C0]();
}

uint64_t ucal_getMillis()
{
  return MEMORY[0x1896155C8]();
}

uint64_t ucal_getNow()
{
  return MEMORY[0x1896155D0]();
}

uint64_t ucal_getWeekendTransition()
{
  return MEMORY[0x1896155F8]();
}

uint64_t ucal_isWeekend()
{
  return MEMORY[0x189615600]();
}

uint64_t ucal_open()
{
  return MEMORY[0x189615608]();
}

uint64_t ucal_roll()
{
  return MEMORY[0x189615618]();
}

uint64_t ucal_set()
{
  return MEMORY[0x189615620]();
}

uint64_t ucal_setAttribute()
{
  return MEMORY[0x189615628]();
}

uint64_t ucal_setGregorianChange()
{
  return MEMORY[0x189615638]();
}

uint64_t ucal_setMillis()
{
  return MEMORY[0x189615640]();
}

uint64_t ucal_setTimeZone()
{
  return MEMORY[0x189615648]();
}

uint64_t ucnv_close()
{
  return MEMORY[0x189615678]();
}

uint64_t ucnv_countAliases()
{
  return MEMORY[0x189615688]();
}

uint64_t ucnv_countAvailable()
{
  return MEMORY[0x189615690]();
}

uint64_t ucnv_fromUnicode()
{
  return MEMORY[0x189615698]();
}

uint64_t ucnv_getAlias()
{
  return MEMORY[0x1896156A0]();
}

uint64_t ucnv_getAvailableName()
{
  return MEMORY[0x1896156A8]();
}

uint64_t ucnv_getInvalidChars()
{
  return MEMORY[0x1896156B0]();
}

uint64_t ucnv_getInvalidUChars()
{
  return MEMORY[0x1896156B8]();
}

uint64_t ucnv_getStandardName()
{
  return MEMORY[0x1896156C0]();
}

uint64_t ucnv_open()
{
  return MEMORY[0x1896156C8]();
}

uint64_t ucnv_resetFromUnicode()
{
  return MEMORY[0x1896156D0]();
}

uint64_t ucnv_setFromUCallBack()
{
  return MEMORY[0x1896156D8]();
}

uint64_t ucnv_setSubstChars()
{
  return MEMORY[0x1896156E0]();
}

uint64_t ucnv_setToUCallBack()
{
  return MEMORY[0x1896156E8]();
}

uint64_t ucnv_toUnicode()
{
  return MEMORY[0x1896156F0]();
}

uint64_t ucol_close()
{
  return MEMORY[0x1896156F8]();
}

uint64_t ucol_closeElements()
{
  return MEMORY[0x189615700]();
}

uint64_t ucol_getOffset()
{
  return MEMORY[0x189615718]();
}

uint64_t ucol_next()
{
  return MEMORY[0x189615720]();
}

uint64_t ucol_open()
{
  return MEMORY[0x189615728]();
}

uint64_t ucol_openElements()
{
  return MEMORY[0x189615730]();
}

uint64_t ucol_setAttribute()
{
  return MEMORY[0x189615738]();
}

uint64_t ucol_setStrength()
{
  return MEMORY[0x189615740]();
}

uint64_t ucol_strcoll()
{
  return MEMORY[0x189615748]();
}

uint64_t ucurr_getDefaultFractionDigits()
{
  return MEMORY[0x189615758]();
}

uint64_t ucurr_getRoundingIncrement()
{
  return MEMORY[0x189615770]();
}

uint64_t udat_applyPattern()
{
  return MEMORY[0x189615780]();
}

uint64_t udat_applyPatternRelative()
{
  return MEMORY[0x189615788]();
}

uint64_t udat_clone()
{
  return MEMORY[0x189615790]();
}

uint64_t udat_close()
{
  return MEMORY[0x189615798]();
}

uint64_t udat_countSymbols()
{
  return MEMORY[0x1896157A0]();
}

uint64_t udat_format()
{
  return MEMORY[0x1896157A8]();
}

uint64_t udat_formatForFields()
{
  return MEMORY[0x1896157B0]();
}

uint64_t udat_get2DigitYearStart()
{
  return MEMORY[0x1896157B8]();
}

uint64_t udat_getCalendar()
{
  return MEMORY[0x1896157C0]();
}

uint64_t udat_getContext()
{
  return MEMORY[0x1896157C8]();
}

uint64_t udat_getSymbols()
{
  return MEMORY[0x1896157D0]();
}

uint64_t udat_isLenient()
{
  return MEMORY[0x1896157D8]();
}

uint64_t udat_open()
{
  return MEMORY[0x1896157E0]();
}

uint64_t udat_parseCalendar()
{
  return MEMORY[0x1896157E8]();
}

uint64_t udat_patternCharToDateFormatField()
{
  return MEMORY[0x1896157F0]();
}

uint64_t udat_set2DigitYearStart()
{
  return MEMORY[0x1896157F8]();
}

uint64_t udat_setCalendar()
{
  return MEMORY[0x189615808]();
}

uint64_t udat_setContext()
{
  return MEMORY[0x189615810]();
}

uint64_t udat_setLenient()
{
  return MEMORY[0x189615818]();
}

uint64_t udat_setSymbols()
{
  return MEMORY[0x189615820]();
}

uint64_t udat_toCalendarDateField()
{
  return MEMORY[0x189615828]();
}

uint64_t udat_toPattern()
{
  return MEMORY[0x189615830]();
}

uint64_t udat_toPatternRelativeDate()
{
  return MEMORY[0x189615838]();
}

uint64_t udat_toPatternRelativeTime()
{
  return MEMORY[0x189615840]();
}

uint64_t udatpg_close()
{
  return MEMORY[0x189615850]();
}

uint64_t udatpg_getBestPattern()
{
  return MEMORY[0x189615858]();
}

uint64_t udatpg_getSkeleton()
{
  return MEMORY[0x189615870]();
}

uint64_t udatpg_open()
{
  return MEMORY[0x189615878]();
}

uint64_t udtitvfmt_close()
{
  return MEMORY[0x189615880]();
}

uint64_t udtitvfmt_format()
{
  return MEMORY[0x189615888]();
}

uint64_t udtitvfmt_open()
{
  return MEMORY[0x189615890]();
}

uint64_t udtitvfmt_setAttribute()
{
  return MEMORY[0x189615898]();
}

uint64_t uenum_close()
{
  return MEMORY[0x1896158A0]();
}

uint64_t uenum_next()
{
  return MEMORY[0x1896158A8]();
}

uint64_t ufieldpositer_close()
{
  return MEMORY[0x1896158B8]();
}

uint64_t ufieldpositer_next()
{
  return MEMORY[0x1896158C0]();
}

uint64_t ufieldpositer_open()
{
  return MEMORY[0x1896158C8]();
}

uint64_t ulistfmt_close()
{
  return MEMORY[0x189615918]();
}

uint64_t ulistfmt_format()
{
  return MEMORY[0x189615920]();
}

uint64_t ulistfmt_open()
{
  return MEMORY[0x189615928]();
}

uint64_t uloc_canonicalize()
{
  return MEMORY[0x189615940]();
}

uint64_t uloc_getCountry()
{
  return MEMORY[0x189615960]();
}

uint64_t uloc_getKeywordValue()
{
  return MEMORY[0x1896159B0]();
}

uint64_t uloc_getLanguage()
{
  return MEMORY[0x1896159C0]();
}

uint64_t uloc_getScript()
{
  return MEMORY[0x1896159D8]();
}

uint64_t uloc_getVariant()
{
  return MEMORY[0x1896159E0]();
}

uint64_t uloc_openKeywords()
{
  return MEMORY[0x1896159F0]();
}

uint64_t uloc_setKeywordValue()
{
  return MEMORY[0x1896159F8]();
}

int unlink(const char *a1)
{
  return MEMORY[0x1895FD468](a1);
}

int unlinkat(int a1, const char *a2, int a3)
{
  return MEMORY[0x1895FD470](*(void *)&a1, a2, *(void *)&a3);
}

uint64_t unum_applyPattern()
{
  return MEMORY[0x189615A38]();
}

uint64_t unum_close()
{
  return MEMORY[0x189615A48]();
}

uint64_t unum_formatDecimal()
{
  return MEMORY[0x189615A50]();
}

uint64_t unum_formatDouble()
{
  return MEMORY[0x189615A58]();
}

uint64_t unum_getAttribute()
{
  return MEMORY[0x189615A68]();
}

uint64_t unum_getContext()
{
  return MEMORY[0x189615A70]();
}

uint64_t unum_getDoubleAttribute()
{
  return MEMORY[0x189615A78]();
}

uint64_t unum_getSymbol()
{
  return MEMORY[0x189615A80]();
}

uint64_t unum_getTextAttribute()
{
  return MEMORY[0x189615A88]();
}

uint64_t unum_open()
{
  return MEMORY[0x189615A90]();
}

uint64_t unum_parse()
{
  return MEMORY[0x189615A98]();
}

uint64_t unum_parseDecimal()
{
  return MEMORY[0x189615AA0]();
}

uint64_t unum_setAttribute()
{
  return MEMORY[0x189615AC0]();
}

uint64_t unum_setContext()
{
  return MEMORY[0x189615AC8]();
}

uint64_t unum_setDoubleAttribute()
{
  return MEMORY[0x189615AD0]();
}

uint64_t unum_setSymbol()
{
  return MEMORY[0x189615AD8]();
}

uint64_t unum_setTextAttribute()
{
  return MEMORY[0x189615AE0]();
}

uint64_t unum_toPattern()
{
  return MEMORY[0x189615AE8]();
}

uint64_t uplrules_close()
{
  return MEMORY[0x189615B68]();
}

uint64_t uplrules_open()
{
  return MEMORY[0x189615B70]();
}

uint64_t uplrules_select()
{
  return MEMORY[0x189615B78]();
}

uint64_t ureldatefmt_close()
{
  return MEMORY[0x189615C40]();
}

uint64_t ureldatefmt_format()
{
  return MEMORY[0x189615C48]();
}

uint64_t ureldatefmt_formatNumeric()
{
  return MEMORY[0x189615C50]();
}

uint64_t ureldatefmt_open()
{
  return MEMORY[0x189615C58]();
}

uint64_t uscript_getScript()
{
  return MEMORY[0x189615C68]();
}

uint64_t usearch_close()
{
  return MEMORY[0x189615C70]();
}

uint64_t usearch_first()
{
  return MEMORY[0x189615C78]();
}

uint64_t usearch_getMatchedLength()
{
  return MEMORY[0x189615C80]();
}

uint64_t usearch_last()
{
  return MEMORY[0x189615C88]();
}

uint64_t usearch_openFromCollator()
{
  return MEMORY[0x189615C90]();
}

uint64_t uset_close()
{
  return MEMORY[0x189615CA0]();
}

uint64_t uset_getItem()
{
  return MEMORY[0x189615CB8]();
}

uint64_t uset_getItemCount()
{
  return MEMORY[0x189615CC0]();
}

uint64_t uset_openPattern()
{
  return MEMORY[0x189615CC8]();
}

UText *__cdecl utext_setup(UText *ut, int32_t extraSpace, UErrorCode *status)
{
  return (UText *)MEMORY[0x189615CD8](ut, *(void *)&extraSpace, status);
}

uint64_t utrans_close()
{
  return MEMORY[0x189615CE8]();
}

uint64_t utrans_openU()
{
  return MEMORY[0x189615CF0]();
}

uint64_t utrans_trans()
{
  return MEMORY[0x189615CF8]();
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x1895FD4B8](uu1, uu2);
}

void uuid_generate_random(uuid_t out)
{
}

void uuid_generate_time(uuid_t out)
{
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x1895FD4E8](in, uu);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1895FD548](*(void *)&target_task, address, size, *(void *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1895FD558](*(void *)&target_task, address, size);
}

kern_return_t vm_purgable_control( vm_map_t target_task, vm_address_t address, vm_purgable_t control, int *state)
{
  return MEMORY[0x1895FD5A0](*(void *)&target_task, address, *(void *)&control, state);
}

uint64_t voucher_copy()
{
  return MEMORY[0x1895FD5C0]();
}

uint64_t voucher_get_current_persona()
{
  return MEMORY[0x1895FD5D0]();
}

voucher_mach_msg_state_t voucher_mach_msg_adopt(mach_msg_header_t *msg)
{
  return (voucher_mach_msg_state_t)MEMORY[0x1895FD5E8](msg);
}

void voucher_mach_msg_revert(voucher_mach_msg_state_t state)
{
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1895FD610](__str, __size, __format, a4);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1895FD750](*(void *)&__fd, __buf, __nbyte);
}

ssize_t writev(int a1, const iovec *a2, int a3)
{
  return MEMORY[0x1895FD760](*(void *)&a1, a2, *(void *)&a3);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return MEMORY[0x1895FD7C8](xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1895FD7D8](objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1895FD808](xarray);
}

const char *__cdecl xpc_array_get_string(xpc_object_t xarray, size_t index)
{
  return (const char *)MEMORY[0x1895FD840](xarray, index);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1895FD860](xarray, index);
}

void xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value)
{
}

void xpc_array_set_value(xpc_object_t xarray, size_t index, xpc_object_t value)
{
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return (xpc_object_t)MEMORY[0x1895FD8B0](value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return MEMORY[0x1895FD8C0](xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

uint64_t xpc_connection_copy_bundle_id()
{
  return MEMORY[0x1895FD928]();
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1895FD948](name, targetq);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x1895FD950](endpoint);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1895FD968](name, targetq, flags);
}

uint64_t xpc_connection_get_audit_token()
{
  return MEMORY[0x1895FD978]();
}

void *__cdecl xpc_connection_get_context(xpc_connection_t connection)
{
  return (void *)MEMORY[0x1895FD980](connection);
}

gid_t xpc_connection_get_egid(xpc_connection_t connection)
{
  return MEMORY[0x1895FD988](connection);
}

uid_t xpc_connection_get_euid(xpc_connection_t connection)
{
  return MEMORY[0x1895FD990](connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return MEMORY[0x1895FD9A8](connection);
}

void xpc_connection_send_barrier(xpc_connection_t connection, dispatch_block_t barrier)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply( xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1895FD9F0](connection, message);
}

void xpc_connection_set_context(xpc_connection_t connection, void *context)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_finalizer_f(xpc_connection_t connection, xpc_finalizer_t finalizer)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

xpc_object_t xpc_copy(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1895FDA70](object);
}

uint64_t xpc_copy_bootstrap()
{
  return MEMORY[0x1895FDA78]();
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return (char *)MEMORY[0x1895FDA98](object);
}

uint64_t xpc_copy_entitlement_for_self()
{
  return MEMORY[0x1895FDAA8]();
}

uint64_t xpc_copy_entitlement_for_token()
{
  return MEMORY[0x1895FDAB0]();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1895FDB00](bytes, length);
}

xpc_object_t xpc_data_create_with_dispatch_data(dispatch_data_t ddata)
{
  return (xpc_object_t)MEMORY[0x1895FDB08](ddata);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1895FDB20](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1895FDB30](xdata);
}

xpc_object_t xpc_date_create(int64_t interval)
{
  return (xpc_object_t)MEMORY[0x1895FDB38](interval);
}

int64_t xpc_date_get_value(xpc_object_t xdate)
{
  return MEMORY[0x1895FDB58](xdate);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return MEMORY[0x1895FDB78](xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1895FDB98](keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1895FDBB0](original);
}

int xpc_dictionary_dup_fd(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1895FDBB8](xdict, key);
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1895FDBD0](xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1895FDBE8](xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return MEMORY[0x1895FDBF8](xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1895FDC00](xdict, key, length);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  return result;
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1895FDC20](xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return (xpc_connection_t)MEMORY[0x1895FDC38](xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1895FDC48](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1895FDC50](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1895FDC68](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_fd(xpc_object_t xdict, const char *key, int fd)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_object_t xpc_double_create(double value)
{
  return (xpc_object_t)MEMORY[0x1895FDD50](value);
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  return result;
}

xpc_endpoint_t xpc_endpoint_create(xpc_connection_t connection)
{
  return (xpc_endpoint_t)MEMORY[0x1895FDD70](connection);
}

BOOL xpc_equal(xpc_object_t object1, xpc_object_t object2)
{
  return MEMORY[0x1895FDD88](object1, object2);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1895FDE70](object);
}

xpc_object_t xpc_int64_create(int64_t value)
{
  return (xpc_object_t)MEMORY[0x1895FDEB0](value);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return MEMORY[0x1895FDEC8](xint);
}

xpc_object_t xpc_null_create(void)
{
  return (xpc_object_t)MEMORY[0x1895FDF48]();
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1895FDF88](object);
}

xpc_object_t xpc_string_create(const char *string)
{
  return (xpc_object_t)MEMORY[0x1895FE050](string);
}

size_t xpc_string_get_length(xpc_object_t xstring)
{
  return MEMORY[0x1895FE070](xstring);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1895FE080](xstring);
}

xpc_object_t xpc_uuid_create(const unsigned __int8 *uuid)
{
  return (xpc_object_t)MEMORY[0x1895FE0F8](uuid);
}

const uint8_t *__cdecl xpc_uuid_get_bytes(xpc_object_t xuuid)
{
  return (const uint8_t *)MEMORY[0x1895FE110](xuuid);
}

uint64_t objc_msgSend___coordinateReadingItemAtURL_options_writingItemAtURL_options_purposeID_byAccessor_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718]( a1,  sel___coordinateReadingItemAtURL_options_writingItemAtURL_options_purposeID_byAccessor_);
}

uint64_t objc_msgSend___coordinateWritingItemAtURL_options_writingItemAtURL_options_purposeID_byAccessor_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718]( a1,  sel___coordinateWritingItemAtURL_options_writingItemAtURL_options_purposeID_byAccessor_);
}

uint64_t objc_msgSend__localeIdentifierByReplacingLanguageCodeAndScriptCodeForLangCode_desiredComponents_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718]( a1,  sel__localeIdentifierByReplacingLanguageCodeAndScriptCodeForLangCode_desiredComponents_);
}

uint64_t objc_msgSend_copyPropertyListWithoutDrainingPendingChangesValidatingPlist_andReturnFileUID_andMode_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718]( a1,  sel_copyPropertyListWithoutDrainingPendingChangesValidatingPlist_andReturnFileUID_andMode_);
}

uint64_t objc_msgSend_enumerateDatesStartingAfterDate_matchingComponents_options_usingBlock_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718](a1, sel_enumerateDatesStartingAfterDate_matchingComponents_options_usingBlock_);
}

uint64_t objc_msgSend_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718](a1, sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_);
}

uint64_t objc_msgSend_initWithApplicationID_storeID_shared_additionalSource_containerPath_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718](a1, sel_initWithApplicationID_storeID_shared_additionalSource_containerPath_);
}

uint64_t objc_msgSend_initWithDomain_userName_byHost_managed_mirroredKeys_shmemIndex_daemon_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718](a1, sel_initWithDomain_userName_byHost_managed_mirroredKeys_shmemIndex_daemon_);
}

uint64_t objc_msgSend_initWithDomain_userName_storeName_configurationPath_containerPath_shmemIndex_daemon_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718]( a1,  sel_initWithDomain_userName_storeName_configurationPath_containerPath_shmemIndex_daemon_);
}

uint64_t objc_msgSend_validateMessage_withNewKey_newValue_plistIsAvailableToRead_containerPath_fileUID_mode_diagnosticMessage_( void *a1, const char *a2, ...)
{
  return MEMORY[0x189616718]( a1,  sel_validateMessage_withNewKey_newValue_plistIsAvailableToRead_containerPath_fileUID_mode_diagnosticMessage_);
}